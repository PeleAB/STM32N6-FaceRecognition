
STM32N6_GettingStarted_ObjectDetection.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00023320  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .gnu.sgstubs  00000020  34023a80  34023a80  00023a80  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00010430  34023aa0  34023aa0  00023aa0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  34033ed0  34033ed0  00034124  2**0
                  CONTENTS
  5 .ARM          00000008  34033ed0  34033ed0  00033ed0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  34033ed8  34034124  00034124  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  34033ed8  34033ed8  00033ed8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  34033edc  34033edc  00033edc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .data         00000244  34033ee0  34033ee0  00033ee0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          0001fde8  34034124  34034124  00034124  2**2
                  ALLOC
 11 ._user_heap_stack 00004204  34053f0c  34053f0c  00034124  2**0
                  ALLOC
 12 .psram_section 00232800  91000000  91000000  00035000  2**5
                  ALLOC
 13 .ARM.attributes 0000003a  00000000  00000000  00034124  2**0
                  CONTENTS, READONLY
 14 .debug_info   0004ac79  00000000  00000000  0003415e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00006d9f  00000000  00000000  0007edd7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00003548  00000000  00000000  00085b78  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 0000298b  00000000  00000000  000890c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00091e54  00000000  00000000  0008ba4b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00044a08  00000000  00000000  0011d89f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    003b0e58  00000000  00000000  001622a7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000086  00000000  00000000  005130ff  2**0
                  CONTENTS, READONLY
 22 .debug_frame  0000f670  00000000  00000000  00513188  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 000000c7  00000000  00000000  005227f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	34034124 	.word	0x34034124
3400076c:	00000000 	.word	0x00000000
34000770:	34023a58 	.word	0x34023a58

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	34034128 	.word	0x34034128
3400078c:	34023a58 	.word	0x34023a58

34000790 <strlen>:
34000790:	4603      	mov	r3, r0
34000792:	f813 2b01 	ldrb.w	r2, [r3], #1
34000796:	2a00      	cmp	r2, #0
34000798:	d1fb      	bne.n	34000792 <strlen+0x2>
3400079a:	1a18      	subs	r0, r3, r0
3400079c:	3801      	subs	r0, #1
3400079e:	4770      	bx	lr

340007a0 <__aeabi_uldivmod>:
340007a0:	b953      	cbnz	r3, 340007b8 <__aeabi_uldivmod+0x18>
340007a2:	b94a      	cbnz	r2, 340007b8 <__aeabi_uldivmod+0x18>
340007a4:	2900      	cmp	r1, #0
340007a6:	bf08      	it	eq
340007a8:	2800      	cmpeq	r0, #0
340007aa:	bf1c      	itt	ne
340007ac:	f04f 31ff 	movne.w	r1, #4294967295
340007b0:	f04f 30ff 	movne.w	r0, #4294967295
340007b4:	f000 b9b0 	b.w	34000b18 <__aeabi_idiv0>
340007b8:	f1ad 0c08 	sub.w	ip, sp, #8
340007bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
340007c0:	f000 f806 	bl	340007d0 <__udivmoddi4>
340007c4:	f8dd e004 	ldr.w	lr, [sp, #4]
340007c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340007cc:	b004      	add	sp, #16
340007ce:	4770      	bx	lr

340007d0 <__udivmoddi4>:
340007d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340007d4:	9d09      	ldr	r5, [sp, #36]	@ 0x24
340007d6:	4688      	mov	r8, r1
340007d8:	4604      	mov	r4, r0
340007da:	468e      	mov	lr, r1
340007dc:	2b00      	cmp	r3, #0
340007de:	d14a      	bne.n	34000876 <__udivmoddi4+0xa6>
340007e0:	428a      	cmp	r2, r1
340007e2:	4617      	mov	r7, r2
340007e4:	d95f      	bls.n	340008a6 <__udivmoddi4+0xd6>
340007e6:	fab2 f682 	clz	r6, r2
340007ea:	b14e      	cbz	r6, 34000800 <__udivmoddi4+0x30>
340007ec:	f1c6 0320 	rsb	r3, r6, #32
340007f0:	fa01 fe06 	lsl.w	lr, r1, r6
340007f4:	40b7      	lsls	r7, r6
340007f6:	40b4      	lsls	r4, r6
340007f8:	fa20 f303 	lsr.w	r3, r0, r3
340007fc:	ea43 0e0e 	orr.w	lr, r3, lr
34000800:	ea4f 4817 	mov.w	r8, r7, lsr #16
34000804:	fa1f fc87 	uxth.w	ip, r7
34000808:	0c23      	lsrs	r3, r4, #16
3400080a:	fbbe f1f8 	udiv	r1, lr, r8
3400080e:	fb08 ee11 	mls	lr, r8, r1, lr
34000812:	fb01 f20c 	mul.w	r2, r1, ip
34000816:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
3400081a:	429a      	cmp	r2, r3
3400081c:	d907      	bls.n	3400082e <__udivmoddi4+0x5e>
3400081e:	18fb      	adds	r3, r7, r3
34000820:	f101 30ff 	add.w	r0, r1, #4294967295
34000824:	d202      	bcs.n	3400082c <__udivmoddi4+0x5c>
34000826:	429a      	cmp	r2, r3
34000828:	f200 8154 	bhi.w	34000ad4 <__udivmoddi4+0x304>
3400082c:	4601      	mov	r1, r0
3400082e:	1a9b      	subs	r3, r3, r2
34000830:	b2a2      	uxth	r2, r4
34000832:	fbb3 f0f8 	udiv	r0, r3, r8
34000836:	fb08 3310 	mls	r3, r8, r0, r3
3400083a:	fb00 fc0c 	mul.w	ip, r0, ip
3400083e:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
34000842:	4594      	cmp	ip, r2
34000844:	d90b      	bls.n	3400085e <__udivmoddi4+0x8e>
34000846:	18ba      	adds	r2, r7, r2
34000848:	f100 33ff 	add.w	r3, r0, #4294967295
3400084c:	bf2c      	ite	cs
3400084e:	2401      	movcs	r4, #1
34000850:	2400      	movcc	r4, #0
34000852:	4594      	cmp	ip, r2
34000854:	d902      	bls.n	3400085c <__udivmoddi4+0x8c>
34000856:	2c00      	cmp	r4, #0
34000858:	f000 813f 	beq.w	34000ada <__udivmoddi4+0x30a>
3400085c:	4618      	mov	r0, r3
3400085e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
34000862:	eba2 020c 	sub.w	r2, r2, ip
34000866:	2100      	movs	r1, #0
34000868:	b11d      	cbz	r5, 34000872 <__udivmoddi4+0xa2>
3400086a:	40f2      	lsrs	r2, r6
3400086c:	2300      	movs	r3, #0
3400086e:	e9c5 2300 	strd	r2, r3, [r5]
34000872:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34000876:	428b      	cmp	r3, r1
34000878:	d905      	bls.n	34000886 <__udivmoddi4+0xb6>
3400087a:	b10d      	cbz	r5, 34000880 <__udivmoddi4+0xb0>
3400087c:	e9c5 0100 	strd	r0, r1, [r5]
34000880:	2100      	movs	r1, #0
34000882:	4608      	mov	r0, r1
34000884:	e7f5      	b.n	34000872 <__udivmoddi4+0xa2>
34000886:	fab3 f183 	clz	r1, r3
3400088a:	2900      	cmp	r1, #0
3400088c:	d14e      	bne.n	3400092c <__udivmoddi4+0x15c>
3400088e:	4543      	cmp	r3, r8
34000890:	f0c0 8112 	bcc.w	34000ab8 <__udivmoddi4+0x2e8>
34000894:	4282      	cmp	r2, r0
34000896:	f240 810f 	bls.w	34000ab8 <__udivmoddi4+0x2e8>
3400089a:	4608      	mov	r0, r1
3400089c:	2d00      	cmp	r5, #0
3400089e:	d0e8      	beq.n	34000872 <__udivmoddi4+0xa2>
340008a0:	e9c5 4e00 	strd	r4, lr, [r5]
340008a4:	e7e5      	b.n	34000872 <__udivmoddi4+0xa2>
340008a6:	2a00      	cmp	r2, #0
340008a8:	f000 80ac 	beq.w	34000a04 <__udivmoddi4+0x234>
340008ac:	fab2 f682 	clz	r6, r2
340008b0:	2e00      	cmp	r6, #0
340008b2:	f040 80bb 	bne.w	34000a2c <__udivmoddi4+0x25c>
340008b6:	1a8b      	subs	r3, r1, r2
340008b8:	ea4f 4e12 	mov.w	lr, r2, lsr #16
340008bc:	b2bc      	uxth	r4, r7
340008be:	2101      	movs	r1, #1
340008c0:	0c02      	lsrs	r2, r0, #16
340008c2:	b280      	uxth	r0, r0
340008c4:	fbb3 fcfe 	udiv	ip, r3, lr
340008c8:	fb0e 331c 	mls	r3, lr, ip, r3
340008cc:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
340008d0:	fb04 f20c 	mul.w	r2, r4, ip
340008d4:	429a      	cmp	r2, r3
340008d6:	d90e      	bls.n	340008f6 <__udivmoddi4+0x126>
340008d8:	18fb      	adds	r3, r7, r3
340008da:	f10c 38ff 	add.w	r8, ip, #4294967295
340008de:	bf2c      	ite	cs
340008e0:	f04f 0901 	movcs.w	r9, #1
340008e4:	f04f 0900 	movcc.w	r9, #0
340008e8:	429a      	cmp	r2, r3
340008ea:	d903      	bls.n	340008f4 <__udivmoddi4+0x124>
340008ec:	f1b9 0f00 	cmp.w	r9, #0
340008f0:	f000 80ec 	beq.w	34000acc <__udivmoddi4+0x2fc>
340008f4:	46c4      	mov	ip, r8
340008f6:	1a9b      	subs	r3, r3, r2
340008f8:	fbb3 f8fe 	udiv	r8, r3, lr
340008fc:	fb0e 3318 	mls	r3, lr, r8, r3
34000900:	fb04 f408 	mul.w	r4, r4, r8
34000904:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34000908:	4294      	cmp	r4, r2
3400090a:	d90b      	bls.n	34000924 <__udivmoddi4+0x154>
3400090c:	18ba      	adds	r2, r7, r2
3400090e:	f108 33ff 	add.w	r3, r8, #4294967295
34000912:	bf2c      	ite	cs
34000914:	2001      	movcs	r0, #1
34000916:	2000      	movcc	r0, #0
34000918:	4294      	cmp	r4, r2
3400091a:	d902      	bls.n	34000922 <__udivmoddi4+0x152>
3400091c:	2800      	cmp	r0, #0
3400091e:	f000 80d1 	beq.w	34000ac4 <__udivmoddi4+0x2f4>
34000922:	4698      	mov	r8, r3
34000924:	1b12      	subs	r2, r2, r4
34000926:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
3400092a:	e79d      	b.n	34000868 <__udivmoddi4+0x98>
3400092c:	f1c1 0620 	rsb	r6, r1, #32
34000930:	408b      	lsls	r3, r1
34000932:	fa08 f401 	lsl.w	r4, r8, r1
34000936:	fa00 f901 	lsl.w	r9, r0, r1
3400093a:	fa22 f706 	lsr.w	r7, r2, r6
3400093e:	fa28 f806 	lsr.w	r8, r8, r6
34000942:	408a      	lsls	r2, r1
34000944:	431f      	orrs	r7, r3
34000946:	fa20 f306 	lsr.w	r3, r0, r6
3400094a:	0c38      	lsrs	r0, r7, #16
3400094c:	4323      	orrs	r3, r4
3400094e:	fa1f fc87 	uxth.w	ip, r7
34000952:	0c1c      	lsrs	r4, r3, #16
34000954:	fbb8 fef0 	udiv	lr, r8, r0
34000958:	fb00 881e 	mls	r8, r0, lr, r8
3400095c:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
34000960:	fb0e f80c 	mul.w	r8, lr, ip
34000964:	45a0      	cmp	r8, r4
34000966:	d90e      	bls.n	34000986 <__udivmoddi4+0x1b6>
34000968:	193c      	adds	r4, r7, r4
3400096a:	f10e 3aff 	add.w	sl, lr, #4294967295
3400096e:	bf2c      	ite	cs
34000970:	f04f 0b01 	movcs.w	fp, #1
34000974:	f04f 0b00 	movcc.w	fp, #0
34000978:	45a0      	cmp	r8, r4
3400097a:	d903      	bls.n	34000984 <__udivmoddi4+0x1b4>
3400097c:	f1bb 0f00 	cmp.w	fp, #0
34000980:	f000 80b8 	beq.w	34000af4 <__udivmoddi4+0x324>
34000984:	46d6      	mov	lr, sl
34000986:	eba4 0408 	sub.w	r4, r4, r8
3400098a:	fa1f f883 	uxth.w	r8, r3
3400098e:	fbb4 f3f0 	udiv	r3, r4, r0
34000992:	fb00 4413 	mls	r4, r0, r3, r4
34000996:	fb03 fc0c 	mul.w	ip, r3, ip
3400099a:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
3400099e:	45a4      	cmp	ip, r4
340009a0:	d90e      	bls.n	340009c0 <__udivmoddi4+0x1f0>
340009a2:	193c      	adds	r4, r7, r4
340009a4:	f103 30ff 	add.w	r0, r3, #4294967295
340009a8:	bf2c      	ite	cs
340009aa:	f04f 0801 	movcs.w	r8, #1
340009ae:	f04f 0800 	movcc.w	r8, #0
340009b2:	45a4      	cmp	ip, r4
340009b4:	d903      	bls.n	340009be <__udivmoddi4+0x1ee>
340009b6:	f1b8 0f00 	cmp.w	r8, #0
340009ba:	f000 809f 	beq.w	34000afc <__udivmoddi4+0x32c>
340009be:	4603      	mov	r3, r0
340009c0:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
340009c4:	eba4 040c 	sub.w	r4, r4, ip
340009c8:	fba0 ec02 	umull	lr, ip, r0, r2
340009cc:	4564      	cmp	r4, ip
340009ce:	4673      	mov	r3, lr
340009d0:	46e0      	mov	r8, ip
340009d2:	d302      	bcc.n	340009da <__udivmoddi4+0x20a>
340009d4:	d107      	bne.n	340009e6 <__udivmoddi4+0x216>
340009d6:	45f1      	cmp	r9, lr
340009d8:	d205      	bcs.n	340009e6 <__udivmoddi4+0x216>
340009da:	ebbe 0302 	subs.w	r3, lr, r2
340009de:	eb6c 0c07 	sbc.w	ip, ip, r7
340009e2:	3801      	subs	r0, #1
340009e4:	46e0      	mov	r8, ip
340009e6:	b15d      	cbz	r5, 34000a00 <__udivmoddi4+0x230>
340009e8:	ebb9 0203 	subs.w	r2, r9, r3
340009ec:	eb64 0408 	sbc.w	r4, r4, r8
340009f0:	fa04 f606 	lsl.w	r6, r4, r6
340009f4:	fa22 f301 	lsr.w	r3, r2, r1
340009f8:	40cc      	lsrs	r4, r1
340009fa:	431e      	orrs	r6, r3
340009fc:	e9c5 6400 	strd	r6, r4, [r5]
34000a00:	2100      	movs	r1, #0
34000a02:	e736      	b.n	34000872 <__udivmoddi4+0xa2>
34000a04:	fbb1 fcf2 	udiv	ip, r1, r2
34000a08:	0c01      	lsrs	r1, r0, #16
34000a0a:	4614      	mov	r4, r2
34000a0c:	b280      	uxth	r0, r0
34000a0e:	4696      	mov	lr, r2
34000a10:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34000a14:	2620      	movs	r6, #32
34000a16:	4690      	mov	r8, r2
34000a18:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34000a1c:	4610      	mov	r0, r2
34000a1e:	fbb1 f1f2 	udiv	r1, r1, r2
34000a22:	eba3 0308 	sub.w	r3, r3, r8
34000a26:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34000a2a:	e74b      	b.n	340008c4 <__udivmoddi4+0xf4>
34000a2c:	40b7      	lsls	r7, r6
34000a2e:	f1c6 0320 	rsb	r3, r6, #32
34000a32:	fa01 f206 	lsl.w	r2, r1, r6
34000a36:	fa21 f803 	lsr.w	r8, r1, r3
34000a3a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34000a3e:	fa20 f303 	lsr.w	r3, r0, r3
34000a42:	b2bc      	uxth	r4, r7
34000a44:	40b0      	lsls	r0, r6
34000a46:	4313      	orrs	r3, r2
34000a48:	0c02      	lsrs	r2, r0, #16
34000a4a:	0c19      	lsrs	r1, r3, #16
34000a4c:	b280      	uxth	r0, r0
34000a4e:	fbb8 f9fe 	udiv	r9, r8, lr
34000a52:	fb0e 8819 	mls	r8, lr, r9, r8
34000a56:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34000a5a:	fb09 f804 	mul.w	r8, r9, r4
34000a5e:	4588      	cmp	r8, r1
34000a60:	d951      	bls.n	34000b06 <__udivmoddi4+0x336>
34000a62:	1879      	adds	r1, r7, r1
34000a64:	f109 3cff 	add.w	ip, r9, #4294967295
34000a68:	bf2c      	ite	cs
34000a6a:	f04f 0a01 	movcs.w	sl, #1
34000a6e:	f04f 0a00 	movcc.w	sl, #0
34000a72:	4588      	cmp	r8, r1
34000a74:	d902      	bls.n	34000a7c <__udivmoddi4+0x2ac>
34000a76:	f1ba 0f00 	cmp.w	sl, #0
34000a7a:	d031      	beq.n	34000ae0 <__udivmoddi4+0x310>
34000a7c:	eba1 0108 	sub.w	r1, r1, r8
34000a80:	fbb1 f9fe 	udiv	r9, r1, lr
34000a84:	fb09 f804 	mul.w	r8, r9, r4
34000a88:	fb0e 1119 	mls	r1, lr, r9, r1
34000a8c:	b29b      	uxth	r3, r3
34000a8e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34000a92:	4543      	cmp	r3, r8
34000a94:	d235      	bcs.n	34000b02 <__udivmoddi4+0x332>
34000a96:	18fb      	adds	r3, r7, r3
34000a98:	f109 31ff 	add.w	r1, r9, #4294967295
34000a9c:	bf2c      	ite	cs
34000a9e:	f04f 0a01 	movcs.w	sl, #1
34000aa2:	f04f 0a00 	movcc.w	sl, #0
34000aa6:	4543      	cmp	r3, r8
34000aa8:	d2bb      	bcs.n	34000a22 <__udivmoddi4+0x252>
34000aaa:	f1ba 0f00 	cmp.w	sl, #0
34000aae:	d1b8      	bne.n	34000a22 <__udivmoddi4+0x252>
34000ab0:	f1a9 0102 	sub.w	r1, r9, #2
34000ab4:	443b      	add	r3, r7
34000ab6:	e7b4      	b.n	34000a22 <__udivmoddi4+0x252>
34000ab8:	1a84      	subs	r4, r0, r2
34000aba:	eb68 0203 	sbc.w	r2, r8, r3
34000abe:	2001      	movs	r0, #1
34000ac0:	4696      	mov	lr, r2
34000ac2:	e6eb      	b.n	3400089c <__udivmoddi4+0xcc>
34000ac4:	443a      	add	r2, r7
34000ac6:	f1a8 0802 	sub.w	r8, r8, #2
34000aca:	e72b      	b.n	34000924 <__udivmoddi4+0x154>
34000acc:	f1ac 0c02 	sub.w	ip, ip, #2
34000ad0:	443b      	add	r3, r7
34000ad2:	e710      	b.n	340008f6 <__udivmoddi4+0x126>
34000ad4:	3902      	subs	r1, #2
34000ad6:	443b      	add	r3, r7
34000ad8:	e6a9      	b.n	3400082e <__udivmoddi4+0x5e>
34000ada:	443a      	add	r2, r7
34000adc:	3802      	subs	r0, #2
34000ade:	e6be      	b.n	3400085e <__udivmoddi4+0x8e>
34000ae0:	eba7 0808 	sub.w	r8, r7, r8
34000ae4:	f1a9 0c02 	sub.w	ip, r9, #2
34000ae8:	4441      	add	r1, r8
34000aea:	fbb1 f9fe 	udiv	r9, r1, lr
34000aee:	fb09 f804 	mul.w	r8, r9, r4
34000af2:	e7c9      	b.n	34000a88 <__udivmoddi4+0x2b8>
34000af4:	f1ae 0e02 	sub.w	lr, lr, #2
34000af8:	443c      	add	r4, r7
34000afa:	e744      	b.n	34000986 <__udivmoddi4+0x1b6>
34000afc:	3b02      	subs	r3, #2
34000afe:	443c      	add	r4, r7
34000b00:	e75e      	b.n	340009c0 <__udivmoddi4+0x1f0>
34000b02:	4649      	mov	r1, r9
34000b04:	e78d      	b.n	34000a22 <__udivmoddi4+0x252>
34000b06:	eba1 0108 	sub.w	r1, r1, r8
34000b0a:	46cc      	mov	ip, r9
34000b0c:	fbb1 f9fe 	udiv	r9, r1, lr
34000b10:	fb09 f804 	mul.w	r8, r9, r4
34000b14:	e7b8      	b.n	34000a88 <__udivmoddi4+0x2b8>
34000b16:	bf00      	nop

34000b18 <__aeabi_idiv0>:
34000b18:	4770      	bx	lr
34000b1a:	bf00      	nop

34000b1c <CMW_CAMERA_PIPE_FrameEventCallback>:
  * @brief  Frame event callback
  * @param  hdcmipp pointer to the DCMIPP handle
  * @retval None
  */
int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
{
34000b1c:	b480      	push	{r7}
34000b1e:	b083      	sub	sp, #12
34000b20:	af00      	add	r7, sp, #0
34000b22:	6078      	str	r0, [r7, #4]
  switch (pipe)
34000b24:	687b      	ldr	r3, [r7, #4]
34000b26:	2b02      	cmp	r3, #2
34000b28:	d105      	bne.n	34000b36 <CMW_CAMERA_PIPE_FrameEventCallback+0x1a>
  {
    case DCMIPP_PIPE2 :
      cameraFrameReceived++;
34000b2a:	4b06      	ldr	r3, [pc, #24]	@ (34000b44 <CMW_CAMERA_PIPE_FrameEventCallback+0x28>)
34000b2c:	681b      	ldr	r3, [r3, #0]
34000b2e:	3301      	adds	r3, #1
34000b30:	4a04      	ldr	r2, [pc, #16]	@ (34000b44 <CMW_CAMERA_PIPE_FrameEventCallback+0x28>)
34000b32:	6013      	str	r3, [r2, #0]
      break;
34000b34:	bf00      	nop
  }
  return 0;
34000b36:	2300      	movs	r3, #0
}
34000b38:	4618      	mov	r0, r3
34000b3a:	370c      	adds	r7, #12
34000b3c:	46bd      	mov	sp, r7
34000b3e:	f85d 7b04 	ldr.w	r7, [sp], #4
34000b42:	4770      	bx	lr
34000b44:	34034180 	.word	0x34034180

34000b48 <Fuse_Programming>:
/**
  * @brief  Check specific fuse configuration and update it if needed.
  * @retval None
  */
void Fuse_Programming(void)
{
34000b48:	b580      	push	{r7, lr}
34000b4a:	b086      	sub	sp, #24
34000b4c:	af00      	add	r7, sp, #0
  uint32_t fuse_id, bit_mask, data;

  BSEC_HandleTypeDef sBsecHandler;

  sBsecHandler.Instance = BSEC;
34000b4e:	4b21      	ldr	r3, [pc, #132]	@ (34000bd4 <Fuse_Programming+0x8c>)
34000b50:	607b      	str	r3, [r7, #4]

  /* Read current value of fuse */
  fuse_id = BSEC_FUSE_ADDRESS;
34000b52:	237c      	movs	r3, #124	@ 0x7c
34000b54:	617b      	str	r3, [r7, #20]
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34000b56:	f107 020c 	add.w	r2, r7, #12
34000b5a:	1d3b      	adds	r3, r7, #4
34000b5c:	6979      	ldr	r1, [r7, #20]
34000b5e:	4618      	mov	r0, r3
34000b60:	f006 fd6e 	bl	34007640 <HAL_BSEC_OTP_Read>
34000b64:	4603      	mov	r3, r0
34000b66:	2b00      	cmp	r3, #0
34000b68:	d12e      	bne.n	34000bc8 <Fuse_Programming+0x80>
  {
    /* Check if bit has already been set */
    bit_mask = BSEC_FUSE_MASK;
34000b6a:	f44f 33c0 	mov.w	r3, #98304	@ 0x18000
34000b6e:	613b      	str	r3, [r7, #16]
    if ((data & bit_mask) != bit_mask)
34000b70:	68fa      	ldr	r2, [r7, #12]
34000b72:	693b      	ldr	r3, [r7, #16]
34000b74:	4013      	ands	r3, r2
34000b76:	693a      	ldr	r2, [r7, #16]
34000b78:	429a      	cmp	r2, r3
34000b7a:	d027      	beq.n	34000bcc <Fuse_Programming+0x84>
    {
      data |= bit_mask;
34000b7c:	68fa      	ldr	r2, [r7, #12]
34000b7e:	693b      	ldr	r3, [r7, #16]
34000b80:	4313      	orrs	r3, r2
34000b82:	60fb      	str	r3, [r7, #12]
      /* Bitwise programming of lower bits */
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34000b84:	68fa      	ldr	r2, [r7, #12]
34000b86:	1d38      	adds	r0, r7, #4
34000b88:	2300      	movs	r3, #0
34000b8a:	6979      	ldr	r1, [r7, #20]
34000b8c:	f006 fd90 	bl	340076b0 <HAL_BSEC_OTP_Program>
34000b90:	4603      	mov	r3, r0
34000b92:	2b00      	cmp	r3, #0
34000b94:	d115      	bne.n	34000bc2 <Fuse_Programming+0x7a>
      {
        /* Read lower bits to verify the correct programming */
        if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34000b96:	f107 020c 	add.w	r2, r7, #12
34000b9a:	1d3b      	adds	r3, r7, #4
34000b9c:	6979      	ldr	r1, [r7, #20]
34000b9e:	4618      	mov	r0, r3
34000ba0:	f006 fd4e 	bl	34007640 <HAL_BSEC_OTP_Read>
34000ba4:	4603      	mov	r3, r0
34000ba6:	2b00      	cmp	r3, #0
34000ba8:	d108      	bne.n	34000bbc <Fuse_Programming+0x74>
        {
          if ((data & bit_mask) != bit_mask)
34000baa:	68fa      	ldr	r2, [r7, #12]
34000bac:	693b      	ldr	r3, [r7, #16]
34000bae:	4013      	ands	r3, r2
34000bb0:	693a      	ldr	r2, [r7, #16]
34000bb2:	429a      	cmp	r2, r3
34000bb4:	d00a      	beq.n	34000bcc <Fuse_Programming+0x84>
          {
            /* Error : Fuse programming not taken in account */
            ErrorHandler();
34000bb6:	f000 f80f 	bl	34000bd8 <ErrorHandler>
  else
  {
    /* Error  : Fuse read unsuccessful */
    ErrorHandler();
  }
}
34000bba:	e007      	b.n	34000bcc <Fuse_Programming+0x84>
          ErrorHandler();
34000bbc:	f000 f80c 	bl	34000bd8 <ErrorHandler>
}
34000bc0:	e004      	b.n	34000bcc <Fuse_Programming+0x84>
        ErrorHandler();
34000bc2:	f000 f809 	bl	34000bd8 <ErrorHandler>
}
34000bc6:	e001      	b.n	34000bcc <Fuse_Programming+0x84>
    ErrorHandler();
34000bc8:	f000 f806 	bl	34000bd8 <ErrorHandler>
}
34000bcc:	bf00      	nop
34000bce:	3718      	adds	r7, #24
34000bd0:	46bd      	mov	sp, r7
34000bd2:	bd80      	pop	{r7, pc}
34000bd4:	56009000 	.word	0x56009000

34000bd8 <ErrorHandler>:
/**
  * @brief  Handle error which occurs when calling HAL API
  * @retval None
  */
static void ErrorHandler(void)
{
34000bd8:	b480      	push	{r7}
34000bda:	af00      	add	r7, sp, #0
  while(1);
34000bdc:	bf00      	nop
34000bde:	e7fd      	b.n	34000bdc <ErrorHandler+0x4>

34000be0 <app_postprocess_init>:
#elif POSTPROCESS_TYPE == POSTPROCESS_SSEG_DEEPLAB_V3_UF
static uint8_t out_sseg_map[AI_SSEG_DEEPLABV3_PP_WIDTH * AI_SSEG_DEEPLABV3_PP_HEIGHT];
#endif

int32_t app_postprocess_init(void *params_postprocess)
{
34000be0:	b580      	push	{r7, lr}
34000be2:	b084      	sub	sp, #16
34000be4:	af00      	add	r7, sp, #0
34000be6:	6078      	str	r0, [r7, #4]
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
34000be8:	2300      	movs	r3, #0
34000bea:	60fb      	str	r3, [r7, #12]
  yolov2_pp_static_param_t *params = (yolov2_pp_static_param_t *) params_postprocess;
34000bec:	687b      	ldr	r3, [r7, #4]
34000bee:	60bb      	str	r3, [r7, #8]
  params->conf_threshold = AI_OBJDETECT_YOLOV2_PP_CONF_THRESHOLD;
34000bf0:	68bb      	ldr	r3, [r7, #8]
34000bf2:	4a11      	ldr	r2, [pc, #68]	@ (34000c38 <app_postprocess_init+0x58>)
34000bf4:	619a      	str	r2, [r3, #24]
  params->iou_threshold = AI_OBJDETECT_YOLOV2_PP_IOU_THRESHOLD;
34000bf6:	68bb      	ldr	r3, [r7, #8]
34000bf8:	4a10      	ldr	r2, [pc, #64]	@ (34000c3c <app_postprocess_init+0x5c>)
34000bfa:	61da      	str	r2, [r3, #28]
  params->nb_anchors = AI_OBJDETECT_YOLOV2_PP_NB_ANCHORS;
34000bfc:	68bb      	ldr	r3, [r7, #8]
34000bfe:	2205      	movs	r2, #5
34000c00:	605a      	str	r2, [r3, #4]
  params->nb_classes = AI_OBJDETECT_YOLOV2_PP_NB_CLASSES;
34000c02:	68bb      	ldr	r3, [r7, #8]
34000c04:	2201      	movs	r2, #1
34000c06:	601a      	str	r2, [r3, #0]
  params->grid_height = AI_OBJDETECT_YOLOV2_PP_GRID_HEIGHT;
34000c08:	68bb      	ldr	r3, [r7, #8]
34000c0a:	2207      	movs	r2, #7
34000c0c:	60da      	str	r2, [r3, #12]
  params->grid_width = AI_OBJDETECT_YOLOV2_PP_GRID_WIDTH;
34000c0e:	68bb      	ldr	r3, [r7, #8]
34000c10:	2207      	movs	r2, #7
34000c12:	609a      	str	r2, [r3, #8]
  params->nb_input_boxes = AI_OBJDETECT_YOLOV2_PP_NB_INPUT_BOXES;
34000c14:	68bb      	ldr	r3, [r7, #8]
34000c16:	2231      	movs	r2, #49	@ 0x31
34000c18:	611a      	str	r2, [r3, #16]
  params->pAnchors = AI_OBJDETECT_YOLOV2_PP_ANCHORS;
34000c1a:	68bb      	ldr	r3, [r7, #8]
34000c1c:	4a08      	ldr	r2, [pc, #32]	@ (34000c40 <app_postprocess_init+0x60>)
34000c1e:	621a      	str	r2, [r3, #32]
  params->max_boxes_limit = AI_OBJDETECT_YOLOV2_PP_MAX_BOXES_LIMIT;
34000c20:	68bb      	ldr	r3, [r7, #8]
34000c22:	220a      	movs	r2, #10
34000c24:	615a      	str	r2, [r3, #20]
  error = od_yolov2_pp_reset(params);
34000c26:	68b8      	ldr	r0, [r7, #8]
34000c28:	f01c f800 	bl	3401cc2c <od_yolov2_pp_reset>
34000c2c:	60f8      	str	r0, [r7, #12]
  error = sseg_deeplabv3_pp_reset(params);
#else
  #error "PostProcessing type not supported"
#endif

  return error;
34000c2e:	68fb      	ldr	r3, [r7, #12]
}
34000c30:	4618      	mov	r0, r3
34000c32:	3710      	adds	r7, #16
34000c34:	46bd      	mov	sp, r7
34000c36:	bd80      	pop	{r7, pc}
34000c38:	3f19999a 	.word	0x3f19999a
34000c3c:	3e99999a 	.word	0x3e99999a
34000c40:	34025164 	.word	0x34025164

34000c44 <app_postprocess_run>:

int32_t app_postprocess_run(void *pInput[], int nb_input, void *pOutput, void *pInput_param)
{
34000c44:	b580      	push	{r7, lr}
34000c46:	b086      	sub	sp, #24
34000c48:	af00      	add	r7, sp, #0
34000c4a:	60f8      	str	r0, [r7, #12]
34000c4c:	60b9      	str	r1, [r7, #8]
34000c4e:	607a      	str	r2, [r7, #4]
34000c50:	603b      	str	r3, [r7, #0]
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  assert(nb_input == 1);
34000c52:	68bb      	ldr	r3, [r7, #8]
34000c54:	2b01      	cmp	r3, #1
34000c56:	d005      	beq.n	34000c64 <app_postprocess_run+0x20>
34000c58:	4b0b      	ldr	r3, [pc, #44]	@ (34000c88 <app_postprocess_run+0x44>)
34000c5a:	4a0c      	ldr	r2, [pc, #48]	@ (34000c8c <app_postprocess_run+0x48>)
34000c5c:	21c4      	movs	r1, #196	@ 0xc4
34000c5e:	480c      	ldr	r0, [pc, #48]	@ (34000c90 <app_postprocess_run+0x4c>)
34000c60:	f01f fae6 	bl	34020230 <__assert_func>
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
34000c64:	2300      	movs	r3, #0
34000c66:	617b      	str	r3, [r7, #20]
  yolov2_pp_in_t pp_input = {
    .pRaw_detections = (float32_t *) pInput[0]
34000c68:	68fb      	ldr	r3, [r7, #12]
34000c6a:	681b      	ldr	r3, [r3, #0]
  yolov2_pp_in_t pp_input = {
34000c6c:	613b      	str	r3, [r7, #16]
  };
  error = od_yolov2_pp_process(&pp_input, (od_pp_out_t *) pOutput,
34000c6e:	f107 0310 	add.w	r3, r7, #16
34000c72:	683a      	ldr	r2, [r7, #0]
34000c74:	6879      	ldr	r1, [r7, #4]
34000c76:	4618      	mov	r0, r3
34000c78:	f01b ffe6 	bl	3401cc48 <od_yolov2_pp_process>
34000c7c:	6178      	str	r0, [r7, #20]
                                    (sseg_deeplabv3_pp_static_param_t *) pInput_param);
#else
  #error "PostProcessing type not supported"
#endif

  return error;
34000c7e:	697b      	ldr	r3, [r7, #20]
}
34000c80:	4618      	mov	r0, r3
34000c82:	3718      	adds	r7, #24
34000c84:	46bd      	mov	sp, r7
34000c86:	bd80      	pop	{r7, pc}
34000c88:	34023aa0 	.word	0x34023aa0
34000c8c:	3402518c 	.word	0x3402518c
34000c90:	34023ab0 	.word	0x34023ab0

34000c94 <LCD_init>:
  (void)p_postprocess; /* in case both features are disabled */
}

#ifdef ENABLE_LCD_DISPLAY
void LCD_init(void)
{
34000c94:	b580      	push	{r7, lr}
34000c96:	af00      	add	r7, sp, #0
  BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
34000c98:	2101      	movs	r1, #1
34000c9a:	2000      	movs	r0, #0
34000c9c:	f004 f9b6 	bl	3400500c <BSP_LCD_Init>

  LayerConfig.X0          = lcd_bg_area.X0;
34000ca0:	4b29      	ldr	r3, [pc, #164]	@ (34000d48 <LCD_init+0xb4>)
34000ca2:	681b      	ldr	r3, [r3, #0]
34000ca4:	4a29      	ldr	r2, [pc, #164]	@ (34000d4c <LCD_init+0xb8>)
34000ca6:	6013      	str	r3, [r2, #0]
  LayerConfig.Y0          = lcd_bg_area.Y0;
34000ca8:	4b27      	ldr	r3, [pc, #156]	@ (34000d48 <LCD_init+0xb4>)
34000caa:	685b      	ldr	r3, [r3, #4]
34000cac:	4a27      	ldr	r2, [pc, #156]	@ (34000d4c <LCD_init+0xb8>)
34000cae:	6093      	str	r3, [r2, #8]
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34000cb0:	4b25      	ldr	r3, [pc, #148]	@ (34000d48 <LCD_init+0xb4>)
34000cb2:	681a      	ldr	r2, [r3, #0]
34000cb4:	4b24      	ldr	r3, [pc, #144]	@ (34000d48 <LCD_init+0xb4>)
34000cb6:	689b      	ldr	r3, [r3, #8]
34000cb8:	4413      	add	r3, r2
34000cba:	4a24      	ldr	r2, [pc, #144]	@ (34000d4c <LCD_init+0xb8>)
34000cbc:	6053      	str	r3, [r2, #4]
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34000cbe:	4b22      	ldr	r3, [pc, #136]	@ (34000d48 <LCD_init+0xb4>)
34000cc0:	685a      	ldr	r2, [r3, #4]
34000cc2:	4b21      	ldr	r3, [pc, #132]	@ (34000d48 <LCD_init+0xb4>)
34000cc4:	68db      	ldr	r3, [r3, #12]
34000cc6:	4413      	add	r3, r2
34000cc8:	4a20      	ldr	r2, [pc, #128]	@ (34000d4c <LCD_init+0xb8>)
34000cca:	60d3      	str	r3, [r2, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34000ccc:	4b1f      	ldr	r3, [pc, #124]	@ (34000d4c <LCD_init+0xb8>)
34000cce:	2202      	movs	r2, #2
34000cd0:	611a      	str	r2, [r3, #16]
  LayerConfig.Address     = (uint32_t)img_buffer;
34000cd2:	4a1f      	ldr	r2, [pc, #124]	@ (34000d50 <LCD_init+0xbc>)
34000cd4:	4b1d      	ldr	r3, [pc, #116]	@ (34000d4c <LCD_init+0xb8>)
34000cd6:	615a      	str	r2, [r3, #20]

  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34000cd8:	4a1c      	ldr	r2, [pc, #112]	@ (34000d4c <LCD_init+0xb8>)
34000cda:	2100      	movs	r1, #0
34000cdc:	2000      	movs	r0, #0
34000cde:	f004 fb49 	bl	34005374 <BSP_LCD_ConfigLayer>

  LayerConfig.X0 = lcd_fg_area.X0;
34000ce2:	4b1c      	ldr	r3, [pc, #112]	@ (34000d54 <LCD_init+0xc0>)
34000ce4:	681b      	ldr	r3, [r3, #0]
34000ce6:	4a19      	ldr	r2, [pc, #100]	@ (34000d4c <LCD_init+0xb8>)
34000ce8:	6013      	str	r3, [r2, #0]
  LayerConfig.Y0 = lcd_fg_area.Y0;
34000cea:	4b1a      	ldr	r3, [pc, #104]	@ (34000d54 <LCD_init+0xc0>)
34000cec:	685b      	ldr	r3, [r3, #4]
34000cee:	4a17      	ldr	r2, [pc, #92]	@ (34000d4c <LCD_init+0xb8>)
34000cf0:	6093      	str	r3, [r2, #8]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34000cf2:	4b18      	ldr	r3, [pc, #96]	@ (34000d54 <LCD_init+0xc0>)
34000cf4:	681a      	ldr	r2, [r3, #0]
34000cf6:	4b17      	ldr	r3, [pc, #92]	@ (34000d54 <LCD_init+0xc0>)
34000cf8:	689b      	ldr	r3, [r3, #8]
34000cfa:	4413      	add	r3, r2
34000cfc:	4a13      	ldr	r2, [pc, #76]	@ (34000d4c <LCD_init+0xb8>)
34000cfe:	6053      	str	r3, [r2, #4]
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34000d00:	4b14      	ldr	r3, [pc, #80]	@ (34000d54 <LCD_init+0xc0>)
34000d02:	685a      	ldr	r2, [r3, #4]
34000d04:	4b13      	ldr	r3, [pc, #76]	@ (34000d54 <LCD_init+0xc0>)
34000d06:	68db      	ldr	r3, [r3, #12]
34000d08:	4413      	add	r3, r2
34000d0a:	4a10      	ldr	r2, [pc, #64]	@ (34000d4c <LCD_init+0xb8>)
34000d0c:	60d3      	str	r3, [r2, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34000d0e:	4b0f      	ldr	r3, [pc, #60]	@ (34000d4c <LCD_init+0xb8>)
34000d10:	2204      	movs	r2, #4
34000d12:	611a      	str	r2, [r3, #16]
  LayerConfig.Address = (uint32_t)lcd_fg_buffer;
34000d14:	4a10      	ldr	r2, [pc, #64]	@ (34000d58 <LCD_init+0xc4>)
34000d16:	4b0d      	ldr	r3, [pc, #52]	@ (34000d4c <LCD_init+0xb8>)
34000d18:	615a      	str	r2, [r3, #20]

  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
34000d1a:	4a0c      	ldr	r2, [pc, #48]	@ (34000d4c <LCD_init+0xb8>)
34000d1c:	2101      	movs	r1, #1
34000d1e:	2000      	movs	r0, #0
34000d20:	f004 fb28 	bl	34005374 <BSP_LCD_ConfigLayer>
  UTIL_LCD_SetFuncDriver(&LCD_Driver);
34000d24:	480d      	ldr	r0, [pc, #52]	@ (34000d5c <LCD_init+0xc8>)
34000d26:	f01b fb0b 	bl	3401c340 <UTIL_LCD_SetFuncDriver>
  UTIL_LCD_SetLayer(LTDC_LAYER_2);
34000d2a:	2001      	movs	r0, #1
34000d2c:	f01b fb5e 	bl	3401c3ec <UTIL_LCD_SetLayer>
  UTIL_LCD_Clear(0x00000000);
34000d30:	2000      	movs	r0, #0
34000d32:	f01b fbc7 	bl	3401c4c4 <UTIL_LCD_Clear>
  UTIL_LCD_SetFont(&Font20);
34000d36:	480a      	ldr	r0, [pc, #40]	@ (34000d60 <LCD_init+0xcc>)
34000d38:	f01b fbb0 	bl	3401c49c <UTIL_LCD_SetFont>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
34000d3c:	f04f 30ff 	mov.w	r0, #4294967295
34000d40:	f01b fb98 	bl	3401c474 <UTIL_LCD_SetTextColor>
}
34000d44:	bf00      	nop
34000d46:	bd80      	pop	{r7, pc}
34000d48:	34033ee0 	.word	0x34033ee0
34000d4c:	34034140 	.word	0x34034140
34000d50:	91177000 	.word	0x91177000
34000d54:	34033ef0 	.word	0x34033ef0
34000d58:	91000000 	.word	0x91000000
34000d5c:	34032120 	.word	0x34032120
34000d60:	34033f54 	.word	0x34033f54

34000d64 <LL_MEM_EnableClock>:
  *         @arg @ref LL_MEM_CACHEAXIRAM
  *         @arg @ref LL_MEM_VENCRAM
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClock(uint32_t Memories)
{
34000d64:	b480      	push	{r7}
34000d66:	b085      	sub	sp, #20
34000d68:	af00      	add	r7, sp, #0
34000d6a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMENSR, Memories);
34000d6c:	4a07      	ldr	r2, [pc, #28]	@ (34000d8c <LL_MEM_EnableClock+0x28>)
34000d6e:	687b      	ldr	r3, [r7, #4]
34000d70:	f8c2 3a4c 	str.w	r3, [r2, #2636]	@ 0xa4c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMENR);
34000d74:	4b05      	ldr	r3, [pc, #20]	@ (34000d8c <LL_MEM_EnableClock+0x28>)
34000d76:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
34000d7a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000d7c:	68fb      	ldr	r3, [r7, #12]
}
34000d7e:	bf00      	nop
34000d80:	3714      	adds	r7, #20
34000d82:	46bd      	mov	sp, r7
34000d84:	f85d 7b04 	ldr.w	r7, [sp], #4
34000d88:	4770      	bx	lr
34000d8a:	bf00      	nop
34000d8c:	56028000 	.word	0x56028000

34000d90 <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
34000d90:	b480      	push	{r7}
34000d92:	b085      	sub	sp, #20
34000d94:	af00      	add	r7, sp, #0
34000d96:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34000d98:	4a07      	ldr	r2, [pc, #28]	@ (34000db8 <LL_AHB5_GRP1_EnableClock+0x28>)
34000d9a:	687b      	ldr	r3, [r7, #4]
34000d9c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34000da0:	4b05      	ldr	r3, [pc, #20]	@ (34000db8 <LL_AHB5_GRP1_EnableClock+0x28>)
34000da2:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34000da6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000da8:	68fb      	ldr	r3, [r7, #12]
}
34000daa:	bf00      	nop
34000dac:	3714      	adds	r7, #20
34000dae:	46bd      	mov	sp, r7
34000db0:	f85d 7b04 	ldr.w	r7, [sp], #4
34000db4:	4770      	bx	lr
34000db6:	bf00      	nop
34000db8:	56028000 	.word	0x56028000

34000dbc <LL_AHB5_GRP1_ForceReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ForceReset(uint32_t Periphs)
{
34000dbc:	b480      	push	{r7}
34000dbe:	b083      	sub	sp, #12
34000dc0:	af00      	add	r7, sp, #0
34000dc2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34000dc4:	4a04      	ldr	r2, [pc, #16]	@ (34000dd8 <LL_AHB5_GRP1_ForceReset+0x1c>)
34000dc6:	687b      	ldr	r3, [r7, #4]
34000dc8:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34000dcc:	bf00      	nop
34000dce:	370c      	adds	r7, #12
34000dd0:	46bd      	mov	sp, r7
34000dd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34000dd6:	4770      	bx	lr
34000dd8:	56028000 	.word	0x56028000

34000ddc <LL_AHB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ReleaseReset(uint32_t Periphs)
{
34000ddc:	b480      	push	{r7}
34000dde:	b083      	sub	sp, #12
34000de0:	af00      	add	r7, sp, #0
34000de2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34000de4:	4b06      	ldr	r3, [pc, #24]	@ (34000e00 <LL_AHB5_GRP1_ReleaseReset+0x24>)
34000de6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34000dea:	461a      	mov	r2, r3
34000dec:	687b      	ldr	r3, [r7, #4]
34000dee:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34000df2:	bf00      	nop
34000df4:	370c      	adds	r7, #12
34000df6:	46bd      	mov	sp, r7
34000df8:	f85d 7b04 	ldr.w	r7, [sp], #4
34000dfc:	4770      	bx	lr
34000dfe:	bf00      	nop
34000e00:	56028000 	.word	0x56028000

34000e04 <LL_RCC_SetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_IC1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCpuClkSource(uint32_t Source)
{
34000e04:	b480      	push	{r7}
34000e06:	b083      	sub	sp, #12
34000e08:	af00      	add	r7, sp, #0
34000e0a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, Source);
34000e0c:	4b06      	ldr	r3, [pc, #24]	@ (34000e28 <LL_RCC_SetCpuClkSource+0x24>)
34000e0e:	6a1b      	ldr	r3, [r3, #32]
34000e10:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
34000e14:	4904      	ldr	r1, [pc, #16]	@ (34000e28 <LL_RCC_SetCpuClkSource+0x24>)
34000e16:	687b      	ldr	r3, [r7, #4]
34000e18:	4313      	orrs	r3, r2
34000e1a:	620b      	str	r3, [r1, #32]
}
34000e1c:	bf00      	nop
34000e1e:	370c      	adds	r7, #12
34000e20:	46bd      	mov	sp, r7
34000e22:	f85d 7b04 	ldr.w	r7, [sp], #4
34000e26:	4770      	bx	lr
34000e28:	56028000 	.word	0x56028000

34000e2c <LL_RCC_SetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_IC2_IC6_IC11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
34000e2c:	b480      	push	{r7}
34000e2e:	b083      	sub	sp, #12
34000e30:	af00      	add	r7, sp, #0
34000e32:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, Source);
34000e34:	4b06      	ldr	r3, [pc, #24]	@ (34000e50 <LL_RCC_SetSysClkSource+0x24>)
34000e36:	6a1b      	ldr	r3, [r3, #32]
34000e38:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34000e3c:	4904      	ldr	r1, [pc, #16]	@ (34000e50 <LL_RCC_SetSysClkSource+0x24>)
34000e3e:	687b      	ldr	r3, [r7, #4]
34000e40:	4313      	orrs	r3, r2
34000e42:	620b      	str	r3, [r1, #32]
}
34000e44:	bf00      	nop
34000e46:	370c      	adds	r7, #12
34000e48:	46bd      	mov	sp, r7
34000e4a:	f85d 7b04 	ldr.w	r7, [sp], #4
34000e4e:	4770      	bx	lr
34000e50:	56028000 	.word	0x56028000

34000e54 <LL_Buffer_addr_base>:
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
    return eb->blob_address;
  }

  static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
  {
34000e54:	b480      	push	{r7}
34000e56:	b085      	sub	sp, #20
34000e58:	af00      	add	r7, sp, #0
34000e5a:	6078      	str	r0, [r7, #4]
    if (buf->is_user_allocated)
34000e5c:	687b      	ldr	r3, [r7, #4]
34000e5e:	7d1b      	ldrb	r3, [r3, #20]
34000e60:	2b00      	cmp	r3, #0
34000e62:	d005      	beq.n	34000e70 <LL_Buffer_addr_base+0x1c>
    {
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
34000e64:	687b      	ldr	r3, [r7, #4]
34000e66:	685b      	ldr	r3, [r3, #4]
34000e68:	60fb      	str	r3, [r7, #12]
      return *tmp;
34000e6a:	68fb      	ldr	r3, [r7, #12]
34000e6c:	681b      	ldr	r3, [r3, #0]
34000e6e:	e001      	b.n	34000e74 <LL_Buffer_addr_base+0x20>
    }
    return buf->addr_base.p;
34000e70:	687b      	ldr	r3, [r7, #4]
34000e72:	685b      	ldr	r3, [r3, #4]
  }
34000e74:	4618      	mov	r0, r3
34000e76:	3714      	adds	r7, #20
34000e78:	46bd      	mov	sp, r7
34000e7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34000e7e:	4770      	bx	lr

34000e80 <LL_Buffer_addr_start>:

  static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
  {
34000e80:	b580      	push	{r7, lr}
34000e82:	b082      	sub	sp, #8
34000e84:	af00      	add	r7, sp, #0
34000e86:	6078      	str	r0, [r7, #4]
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34000e88:	6878      	ldr	r0, [r7, #4]
34000e8a:	f7ff ffe3 	bl	34000e54 <LL_Buffer_addr_base>
34000e8e:	4602      	mov	r2, r0
34000e90:	687b      	ldr	r3, [r7, #4]
34000e92:	689b      	ldr	r3, [r3, #8]
34000e94:	4413      	add	r3, r2
  }
34000e96:	4618      	mov	r0, r3
34000e98:	3708      	adds	r7, #8
34000e9a:	46bd      	mov	sp, r7
34000e9c:	bd80      	pop	{r7, pc}

34000e9e <LL_Buffer_len>:
  {
    return LL_Buffer_addr_base(buf) + buf->offset_limit;
  }

  static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
  {
34000e9e:	b480      	push	{r7}
34000ea0:	b083      	sub	sp, #12
34000ea2:	af00      	add	r7, sp, #0
34000ea4:	6078      	str	r0, [r7, #4]
    return buf->offset_end - buf->offset_start;
34000ea6:	687b      	ldr	r3, [r7, #4]
34000ea8:	68da      	ldr	r2, [r3, #12]
34000eaa:	687b      	ldr	r3, [r7, #4]
34000eac:	689b      	ldr	r3, [r3, #8]
34000eae:	1ad3      	subs	r3, r2, r3
  }
34000eb0:	4618      	mov	r0, r3
34000eb2:	370c      	adds	r7, #12
34000eb4:	46bd      	mov	sp, r7
34000eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
34000eba:	4770      	bx	lr

34000ebc <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
34000ebc:	b580      	push	{r7, lr}
34000ebe:	b0a4      	sub	sp, #144	@ 0x90
34000ec0:	af00      	add	r7, sp, #0
  /* Power on ICACHE */
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34000ec2:	4bbd      	ldr	r3, [pc, #756]	@ (340011b8 <main+0x2fc>)
34000ec4:	681b      	ldr	r3, [r3, #0]
34000ec6:	4abc      	ldr	r2, [pc, #752]	@ (340011b8 <main+0x2fc>)
34000ec8:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34000ecc:	6013      	str	r3, [r2, #0]

  /* Set back system and CPU clock source to HSI */
  __HAL_RCC_CPUCLK_CONFIG(RCC_CPUCLKSOURCE_HSI);
34000ece:	2000      	movs	r0, #0
34000ed0:	f7ff ff98 	bl	34000e04 <LL_RCC_SetCpuClkSource>
  __HAL_RCC_SYSCLK_CONFIG(RCC_SYSCLKSOURCE_HSI);
34000ed4:	2000      	movs	r0, #0
34000ed6:	f7ff ffa9 	bl	34000e2c <LL_RCC_SetSysClkSource>

  HAL_Init();
34000eda:	f006 fb1b 	bl	34007514 <HAL_Init>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34000ede:	4bb7      	ldr	r3, [pc, #732]	@ (340011bc <main+0x300>)
34000ee0:	695b      	ldr	r3, [r3, #20]
34000ee2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34000ee6:	2b00      	cmp	r3, #0
34000ee8:	d11b      	bne.n	34000f22 <main+0x66>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34000eea:	f3bf 8f4f 	dsb	sy
}
34000eee:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34000ef0:	f3bf 8f6f 	isb	sy
}
34000ef4:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34000ef6:	4bb1      	ldr	r3, [pc, #708]	@ (340011bc <main+0x300>)
34000ef8:	2200      	movs	r2, #0
34000efa:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34000efe:	f3bf 8f4f 	dsb	sy
}
34000f02:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34000f04:	f3bf 8f6f 	isb	sy
}
34000f08:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
34000f0a:	4bac      	ldr	r3, [pc, #688]	@ (340011bc <main+0x300>)
34000f0c:	695b      	ldr	r3, [r3, #20]
34000f0e:	4aab      	ldr	r2, [pc, #684]	@ (340011bc <main+0x300>)
34000f10:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34000f14:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34000f16:	f3bf 8f4f 	dsb	sy
}
34000f1a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34000f1c:	f3bf 8f6f 	isb	sy
}
34000f20:	e000      	b.n	34000f24 <main+0x68>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34000f22:	bf00      	nop

  SCB_EnableICache();

#if defined(USE_DCACHE)
  /* Power on DCACHE */
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
34000f24:	4ba4      	ldr	r3, [pc, #656]	@ (340011b8 <main+0x2fc>)
34000f26:	681b      	ldr	r3, [r3, #0]
34000f28:	4aa3      	ldr	r2, [pc, #652]	@ (340011b8 <main+0x2fc>)
34000f2a:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34000f2e:	6013      	str	r3, [r2, #0]
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34000f30:	4ba2      	ldr	r3, [pc, #648]	@ (340011bc <main+0x300>)
34000f32:	695b      	ldr	r3, [r3, #20]
34000f34:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34000f38:	2b00      	cmp	r3, #0
34000f3a:	d138      	bne.n	34000fae <main+0xf2>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
34000f3c:	4b9f      	ldr	r3, [pc, #636]	@ (340011bc <main+0x300>)
34000f3e:	2200      	movs	r2, #0
34000f40:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34000f44:	f3bf 8f4f 	dsb	sy
}
34000f48:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
34000f4a:	4b9c      	ldr	r3, [pc, #624]	@ (340011bc <main+0x300>)
34000f4c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34000f50:	66bb      	str	r3, [r7, #104]	@ 0x68

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
34000f52:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34000f54:	0b5b      	lsrs	r3, r3, #13
34000f56:	f3c3 030e 	ubfx	r3, r3, #0, #15
34000f5a:	667b      	str	r3, [r7, #100]	@ 0x64
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34000f5c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34000f5e:	08db      	lsrs	r3, r3, #3
34000f60:	f3c3 0309 	ubfx	r3, r3, #0, #10
34000f64:	663b      	str	r3, [r7, #96]	@ 0x60
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34000f66:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34000f68:	015a      	lsls	r2, r3, #5
34000f6a:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
34000f6e:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
34000f70:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
34000f72:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34000f74:	4991      	ldr	r1, [pc, #580]	@ (340011bc <main+0x300>)
34000f76:	4313      	orrs	r3, r2
34000f78:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34000f7c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34000f7e:	1e5a      	subs	r2, r3, #1
34000f80:	663a      	str	r2, [r7, #96]	@ 0x60
34000f82:	2b00      	cmp	r3, #0
34000f84:	d1ef      	bne.n	34000f66 <main+0xaa>
    } while(sets-- != 0U);
34000f86:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34000f88:	1e5a      	subs	r2, r3, #1
34000f8a:	667a      	str	r2, [r7, #100]	@ 0x64
34000f8c:	2b00      	cmp	r3, #0
34000f8e:	d1e5      	bne.n	34000f5c <main+0xa0>
  __ASM volatile ("dsb 0xF":::"memory");
34000f90:	f3bf 8f4f 	dsb	sy
}
34000f94:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
34000f96:	4b89      	ldr	r3, [pc, #548]	@ (340011bc <main+0x300>)
34000f98:	695b      	ldr	r3, [r3, #20]
34000f9a:	4a88      	ldr	r2, [pc, #544]	@ (340011bc <main+0x300>)
34000f9c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34000fa0:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34000fa2:	f3bf 8f4f 	dsb	sy
}
34000fa6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34000fa8:	f3bf 8f6f 	isb	sy
}
34000fac:	e000      	b.n	34000fb0 <main+0xf4>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34000fae:	bf00      	nop
  SCB_EnableDCache();
#endif

  SystemClock_Config();
34000fb0:	f002 ff76 	bl	34003ea0 <SystemClock_Config>

  NPURam_enable();
34000fb4:	f002 fe88 	bl	34003cc8 <NPURam_enable>

  Fuse_Programming();
34000fb8:	f7ff fdc6 	bl	34000b48 <Fuse_Programming>

  NPUCache_config();
34000fbc:	f002 ff02 	bl	34003dc4 <NPUCache_config>

#ifdef ENABLE_PC_STREAM
  PC_STREAM_Init();
34000fc0:	f002 fa92 	bl	340034e8 <PC_STREAM_Init>
#endif

  /*** External RAM and NOR Flash *********************************************/
  BSP_XSPI_RAM_Init(0);
34000fc4:	2000      	movs	r0, #0
34000fc6:	f005 fa13 	bl	340063f0 <BSP_XSPI_RAM_Init>
  BSP_XSPI_RAM_EnableMemoryMappedMode(0);
34000fca:	2000      	movs	r0, #0
34000fcc:	f005 fade 	bl	3400658c <BSP_XSPI_RAM_EnableMemoryMappedMode>

  BSP_XSPI_NOR_Init_t NOR_Init;
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34000fd0:	2301      	movs	r3, #1
34000fd2:	f887 303c 	strb.w	r3, [r7, #60]	@ 0x3c
  NOR_Init.TransferRate = BSP_XSPI_NOR_DTR_TRANSFER;
34000fd6:	2301      	movs	r3, #1
34000fd8:	f887 303d 	strb.w	r3, [r7, #61]	@ 0x3d
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34000fdc:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
34000fe0:	4619      	mov	r1, r3
34000fe2:	2000      	movs	r0, #0
34000fe4:	f005 f822 	bl	3400602c <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34000fe8:	2000      	movs	r0, #0
34000fea:	f005 f909 	bl	34006200 <BSP_XSPI_NOR_EnableMemoryMappedMode>

  /* Set all required IPs as secure privileged */
  Security_Config();
34000fee:	f002 fef1 	bl	34003dd4 <Security_Config>

  IAC_Config();
34000ff2:	f002 ff45 	bl	34003e80 <IAC_Config>
  set_clk_sleep_mode();
34000ff6:	f002 feaf 	bl	34003d58 <set_clk_sleep_mode>

  /*** NN Init ****************************************************************/
  LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(Default);
  const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_Default();
34000ffa:	f000 fac1 	bl	34001580 <LL_ATON_Input_Buffers_Info_Default>
34000ffe:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_Default();
34001002:	f000 fac7 	bl	34001594 <LL_ATON_Output_Buffers_Info_Default>
34001006:	67f8      	str	r0, [r7, #124]	@ 0x7c

  nn_in = (uint8_t *) LL_Buffer_addr_start(&nn_in_info[0]);
34001008:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
3400100c:	f7ff ff38 	bl	34000e80 <LL_Buffer_addr_start>
34001010:	4603      	mov	r3, r0
34001012:	4a6b      	ldr	r2, [pc, #428]	@ (340011c0 <main+0x304>)
34001014:	6013      	str	r3, [r2, #0]
  float32_t *nn_out[MAX_NUMBER_OUTPUT];
  int32_t nn_out_len[MAX_NUMBER_OUTPUT];

  int number_output = 0;
34001016:	2300      	movs	r3, #0
34001018:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

  /* Count number of outputs */
  while (nn_out_info[number_output].name != NULL)
3400101c:	e004      	b.n	34001028 <main+0x16c>
  {
    number_output++;
3400101e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34001022:	3301      	adds	r3, #1
34001024:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  while (nn_out_info[number_output].name != NULL)
34001028:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
3400102c:	4613      	mov	r3, r2
3400102e:	00db      	lsls	r3, r3, #3
34001030:	1a9b      	subs	r3, r3, r2
34001032:	00db      	lsls	r3, r3, #3
34001034:	461a      	mov	r2, r3
34001036:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34001038:	4413      	add	r3, r2
3400103a:	681b      	ldr	r3, [r3, #0]
3400103c:	2b00      	cmp	r3, #0
3400103e:	d1ee      	bne.n	3400101e <main+0x162>
  }
  assert(number_output <= MAX_NUMBER_OUTPUT);
34001040:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34001044:	2b05      	cmp	r3, #5
34001046:	dd05      	ble.n	34001054 <main+0x198>
34001048:	4b5e      	ldr	r3, [pc, #376]	@ (340011c4 <main+0x308>)
3400104a:	4a5f      	ldr	r2, [pc, #380]	@ (340011c8 <main+0x30c>)
3400104c:	2193      	movs	r1, #147	@ 0x93
3400104e:	485f      	ldr	r0, [pc, #380]	@ (340011cc <main+0x310>)
34001050:	f01f f8ee 	bl	34020230 <__assert_func>

  for (int i = 0; i < number_output; i++)
34001054:	2300      	movs	r3, #0
34001056:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
3400105a:	e02d      	b.n	340010b8 <main+0x1fc>
  {
    nn_out[i] = (float32_t *) LL_Buffer_addr_start(&nn_out_info[i]);
3400105c:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
34001060:	4613      	mov	r3, r2
34001062:	00db      	lsls	r3, r3, #3
34001064:	1a9b      	subs	r3, r3, r2
34001066:	00db      	lsls	r3, r3, #3
34001068:	461a      	mov	r2, r3
3400106a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400106c:	4413      	add	r3, r2
3400106e:	4618      	mov	r0, r3
34001070:	f7ff ff06 	bl	34000e80 <LL_Buffer_addr_start>
34001074:	4602      	mov	r2, r0
34001076:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3400107a:	009b      	lsls	r3, r3, #2
3400107c:	3390      	adds	r3, #144	@ 0x90
3400107e:	443b      	add	r3, r7
34001080:	f843 2c68 	str.w	r2, [r3, #-104]
    nn_out_len[i] = LL_Buffer_len(&nn_out_info[i]);
34001084:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
34001088:	4613      	mov	r3, r2
3400108a:	00db      	lsls	r3, r3, #3
3400108c:	1a9b      	subs	r3, r3, r2
3400108e:	00db      	lsls	r3, r3, #3
34001090:	461a      	mov	r2, r3
34001092:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34001094:	4413      	add	r3, r2
34001096:	4618      	mov	r0, r3
34001098:	f7ff ff01 	bl	34000e9e <LL_Buffer_len>
3400109c:	4603      	mov	r3, r0
3400109e:	461a      	mov	r2, r3
340010a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
340010a4:	009b      	lsls	r3, r3, #2
340010a6:	3390      	adds	r3, #144	@ 0x90
340010a8:	443b      	add	r3, r7
340010aa:	f843 2c7c 	str.w	r2, [r3, #-124]
  for (int i = 0; i < number_output; i++)
340010ae:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
340010b2:	3301      	adds	r3, #1
340010b4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
340010b8:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
340010bc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
340010c0:	429a      	cmp	r2, r3
340010c2:	dbcb      	blt.n	3400105c <main+0x1a0>
  }

  uint32_t nn_in_len = LL_Buffer_len(&nn_in_info[0]);
340010c4:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
340010c8:	f7ff fee9 	bl	34000e9e <LL_Buffer_len>
340010cc:	67b8      	str	r0, [r7, #120]	@ 0x78
  uint32_t pitch_nn = 0;
340010ce:	2300      	movs	r3, #0
340010d0:	677b      	str	r3, [r7, #116]	@ 0x74

  UNUSED(nn_in_len);

  /*** Post Processing Init ***************************************************/
  app_postprocess_init(&pp_params);
340010d2:	483f      	ldr	r0, [pc, #252]	@ (340011d0 <main+0x314>)
340010d4:	f7ff fd84 	bl	34000be0 <app_postprocess_init>
  CAM_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
  LCD_init();
  /* Start LCD Display camera pipe stream */
  CAM_DisplayPipe_Start(img_buffer, CMW_MODE_CONTINUOUS);
#else
  LCD_init();
340010d8:	f7ff fddc 	bl	34000c94 <LCD_init>
#endif
  uint32_t ts[3] = { 0 };
340010dc:	f107 0308 	add.w	r3, r7, #8
340010e0:	2200      	movs	r2, #0
340010e2:	601a      	str	r2, [r3, #0]
340010e4:	605a      	str	r2, [r3, #4]
340010e6:	609a      	str	r2, [r3, #8]
      SCB_InvalidateDCache_by_Addr(dcmipp_out_nn, sizeof(dcmipp_out_nn));
      img_crop(dcmipp_out_nn, nn_in, pitch_nn, NN_WIDTH, NN_HEIGHT, NN_BPP);
      SCB_CleanInvalidateDCache_by_Addr(nn_in, nn_in_len);
    }
#else
    uint32_t ts[2] = { 0 };
340010e8:	463b      	mov	r3, r7
340010ea:	2200      	movs	r2, #0
340010ec:	601a      	str	r2, [r3, #0]
340010ee:	605a      	str	r2, [r3, #4]
    /* Receive frame from PC */
    if (PC_STREAM_ReceiveImage(nn_in, nn_in_len) != 0)
340010f0:	4b33      	ldr	r3, [pc, #204]	@ (340011c0 <main+0x304>)
340010f2:	681b      	ldr	r3, [r3, #0]
340010f4:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
340010f6:	4618      	mov	r0, r3
340010f8:	f002 fbe8 	bl	340038cc <PC_STREAM_ReceiveImage>
340010fc:	4603      	mov	r3, r0
340010fe:	2b00      	cmp	r3, #0
34001100:	f040 80ae 	bne.w	34001260 <main+0x3a4>
    {
      continue;
    }
    SCB_CleanInvalidateDCache_by_Addr(nn_in, nn_in_len);
34001104:	4b2e      	ldr	r3, [pc, #184]	@ (340011c0 <main+0x304>)
34001106:	681a      	ldr	r2, [r3, #0]
34001108:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400110a:	65fa      	str	r2, [r7, #92]	@ 0x5c
3400110c:	65bb      	str	r3, [r7, #88]	@ 0x58
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
3400110e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34001110:	2b00      	cmp	r3, #0
34001112:	dd1d      	ble.n	34001150 <main+0x294>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34001114:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34001116:	f003 021f 	and.w	r2, r3, #31
3400111a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3400111c:	4413      	add	r3, r2
3400111e:	657b      	str	r3, [r7, #84]	@ 0x54
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
34001120:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34001122:	653b      	str	r3, [r7, #80]	@ 0x50
  __ASM volatile ("dsb 0xF":::"memory");
34001124:	f3bf 8f4f 	dsb	sy
}
34001128:	bf00      	nop

      __DSB();

      do {
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400112a:	4a24      	ldr	r2, [pc, #144]	@ (340011bc <main+0x300>)
3400112c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3400112e:	f8c2 3270 	str.w	r3, [r2, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
34001132:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34001134:	3320      	adds	r3, #32
34001136:	653b      	str	r3, [r7, #80]	@ 0x50
        op_size -=          __SCB_DCACHE_LINE_SIZE;
34001138:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3400113a:	3b20      	subs	r3, #32
3400113c:	657b      	str	r3, [r7, #84]	@ 0x54
      } while ( op_size > 0 );
3400113e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34001140:	2b00      	cmp	r3, #0
34001142:	dcf2      	bgt.n	3400112a <main+0x26e>
  __ASM volatile ("dsb 0xF":::"memory");
34001144:	f3bf 8f4f 	dsb	sy
}
34001148:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3400114a:	f3bf 8f6f 	isb	sy
}
3400114e:	bf00      	nop

      __DSB();
      __ISB();
    }
  #endif
}
34001150:	bf00      	nop
#ifdef ENABLE_PC_STREAM
    PC_STREAM_SendFrame(nn_in, NN_WIDTH, NN_HEIGHT, NN_BPP);
34001152:	4b1b      	ldr	r3, [pc, #108]	@ (340011c0 <main+0x304>)
34001154:	6818      	ldr	r0, [r3, #0]
34001156:	2303      	movs	r3, #3
34001158:	22e0      	movs	r2, #224	@ 0xe0
3400115a:	21e0      	movs	r1, #224	@ 0xe0
3400115c:	f002 fa56 	bl	3400360c <PC_STREAM_SendFrame>
#endif
#endif

    ts[0] = HAL_GetTick();
34001160:	f006 fa3e 	bl	340075e0 <HAL_GetTick>
34001164:	4603      	mov	r3, r0
34001166:	603b      	str	r3, [r7, #0]
    /* run ATON inference */
    LL_ATON_RT_Main(&NN_Instance_Default);
34001168:	481a      	ldr	r0, [pc, #104]	@ (340011d4 <main+0x318>)
3400116a:	f01c ffe1 	bl	3401e130 <LL_ATON_RT_Main>



    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
3400116e:	f107 0028 	add.w	r0, r7, #40	@ 0x28
34001172:	4b17      	ldr	r3, [pc, #92]	@ (340011d0 <main+0x314>)
34001174:	4a18      	ldr	r2, [pc, #96]	@ (340011d8 <main+0x31c>)
34001176:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
3400117a:	f7ff fd63 	bl	34000c44 <app_postprocess_run>
3400117e:	6738      	str	r0, [r7, #112]	@ 0x70
    ts[1] = HAL_GetTick();
34001180:	f006 fa2e 	bl	340075e0 <HAL_GetTick>
34001184:	4603      	mov	r3, r0
34001186:	607b      	str	r3, [r7, #4]
    if(ts[2]==0)
34001188:	68bb      	ldr	r3, [r7, #8]
3400118a:	2b00      	cmp	r3, #0
3400118c:	d103      	bne.n	34001196 <main+0x2da>
    {
    	ts[2] = HAL_GetTick();
3400118e:	f006 fa27 	bl	340075e0 <HAL_GetTick>
34001192:	4603      	mov	r3, r0
34001194:	60bb      	str	r3, [r7, #8]
    }
    assert(ret == 0);
34001196:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34001198:	2b00      	cmp	r3, #0
3400119a:	d005      	beq.n	340011a8 <main+0x2ec>
3400119c:	4b0f      	ldr	r3, [pc, #60]	@ (340011dc <main+0x320>)
3400119e:	4a0a      	ldr	r2, [pc, #40]	@ (340011c8 <main+0x30c>)
340011a0:	21e2      	movs	r1, #226	@ 0xe2
340011a2:	480a      	ldr	r0, [pc, #40]	@ (340011cc <main+0x310>)
340011a4:	f01f f844 	bl	34020230 <__assert_func>

#if INPUT_SRC_MODE == INPUT_SRC_CAMERA
    Display_NetworkOutput(&pp_output, ts[1] - ts[0], ts[2]);
#else
#ifdef ENABLE_PC_STREAM
    PC_STREAM_SendDetections(&pp_output, 0);
340011a8:	2100      	movs	r1, #0
340011aa:	480b      	ldr	r0, [pc, #44]	@ (340011d8 <main+0x31c>)
340011ac:	f002 fb12 	bl	340037d4 <PC_STREAM_SendDetections>
#endif
#endif

    /* Discard nn_out region (used by pp_input and pp_outputs variables) to avoid Dcache evictions during nn inference */
    for (int i = 0; i < number_output; i++)
340011b0:	2300      	movs	r3, #0
340011b2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
340011b6:	e04c      	b.n	34001252 <main+0x396>
340011b8:	e001e000 	.word	0xe001e000
340011bc:	e000ed00 	.word	0xe000ed00
340011c0:	34034184 	.word	0x34034184
340011c4:	34023af0 	.word	0x34023af0
340011c8:	340251a0 	.word	0x340251a0
340011cc:	34023b14 	.word	0x34023b14
340011d0:	34034158 	.word	0x34034158
340011d4:	34033f00 	.word	0x34033f00
340011d8:	34034188 	.word	0x34034188
340011dc:	34023b48 	.word	0x34023b48
    {
      float32_t *tmp = nn_out[i];
340011e0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340011e4:	009b      	lsls	r3, r3, #2
340011e6:	3390      	adds	r3, #144	@ 0x90
340011e8:	443b      	add	r3, r7
340011ea:	f853 3c68 	ldr.w	r3, [r3, #-104]
340011ee:	66fb      	str	r3, [r7, #108]	@ 0x6c
      SCB_InvalidateDCache_by_Addr(tmp, nn_out_len[i]);
340011f0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
340011f4:	009b      	lsls	r3, r3, #2
340011f6:	3390      	adds	r3, #144	@ 0x90
340011f8:	443b      	add	r3, r7
340011fa:	f853 3c7c 	ldr.w	r3, [r3, #-124]
340011fe:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34001200:	64fa      	str	r2, [r7, #76]	@ 0x4c
34001202:	64bb      	str	r3, [r7, #72]	@ 0x48
    if ( dsize > 0 ) {
34001204:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34001206:	2b00      	cmp	r3, #0
34001208:	dd1d      	ble.n	34001246 <main+0x38a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
3400120a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400120c:	f003 021f 	and.w	r2, r3, #31
34001210:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34001212:	4413      	add	r3, r2
34001214:	647b      	str	r3, [r7, #68]	@ 0x44
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
34001216:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34001218:	643b      	str	r3, [r7, #64]	@ 0x40
  __ASM volatile ("dsb 0xF":::"memory");
3400121a:	f3bf 8f4f 	dsb	sy
}
3400121e:	bf00      	nop
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34001220:	4a10      	ldr	r2, [pc, #64]	@ (34001264 <main+0x3a8>)
34001222:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34001224:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34001228:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400122a:	3320      	adds	r3, #32
3400122c:	643b      	str	r3, [r7, #64]	@ 0x40
        op_size -= __SCB_DCACHE_LINE_SIZE;
3400122e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34001230:	3b20      	subs	r3, #32
34001232:	647b      	str	r3, [r7, #68]	@ 0x44
      } while ( op_size > 0 );
34001234:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34001236:	2b00      	cmp	r3, #0
34001238:	dcf2      	bgt.n	34001220 <main+0x364>
  __ASM volatile ("dsb 0xF":::"memory");
3400123a:	f3bf 8f4f 	dsb	sy
}
3400123e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34001240:	f3bf 8f6f 	isb	sy
}
34001244:	bf00      	nop
}
34001246:	bf00      	nop
    for (int i = 0; i < number_output; i++)
34001248:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400124c:	3301      	adds	r3, #1
3400124e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34001252:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34001256:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3400125a:	429a      	cmp	r2, r3
3400125c:	dbc0      	blt.n	340011e0 <main+0x324>
3400125e:	e743      	b.n	340010e8 <main+0x22c>
      continue;
34001260:	bf00      	nop
  {
34001262:	e741      	b.n	340010e8 <main+0x22c>
34001264:	e000ed00 	.word	0xe000ed00

34001268 <HAL_CACHEAXI_MspInit>:
  }
}


void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34001268:	b580      	push	{r7, lr}
3400126a:	b082      	sub	sp, #8
3400126c:	af00      	add	r7, sp, #0
3400126e:	6078      	str	r0, [r7, #4]
  __HAL_RCC_CACHEAXIRAM_MEM_CLK_ENABLE();
34001270:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34001274:	f7ff fd76 	bl	34000d64 <LL_MEM_EnableClock>
  __HAL_RCC_CACHEAXI_CLK_ENABLE();
34001278:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3400127c:	f7ff fd88 	bl	34000d90 <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_CACHEAXI_FORCE_RESET();
34001280:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34001284:	f7ff fd9a 	bl	34000dbc <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_CACHEAXI_RELEASE_RESET();
34001288:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3400128c:	f7ff fda6 	bl	34000ddc <LL_AHB5_GRP1_ReleaseReset>
}
34001290:	bf00      	nop
34001292:	3708      	adds	r7, #8
34001294:	46bd      	mov	sp, r7
34001296:	bd80      	pop	{r7, pc}

34001298 <assert_failed>:
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{
34001298:	b480      	push	{r7}
3400129a:	b083      	sub	sp, #12
3400129c:	af00      	add	r7, sp, #0
3400129e:	6078      	str	r0, [r7, #4]
340012a0:	6039      	str	r1, [r7, #0]
  UNUSED(file);
  UNUSED(line);
  __BKPT(0);
340012a2:	be00      	bkpt	0x0000
  while (1)
340012a4:	bf00      	nop
340012a6:	e7fd      	b.n	340012a4 <assert_failed+0xc>

340012a8 <mcu_cache_invalidate_range>:
  }  
  return 0;
}

int mcu_cache_invalidate_range(uint32_t start_addr, uint32_t end_addr) 
{
340012a8:	b480      	push	{r7}
340012aa:	b087      	sub	sp, #28
340012ac:	af00      	add	r7, sp, #0
340012ae:	6078      	str	r0, [r7, #4]
340012b0:	6039      	str	r1, [r7, #0]

#include "stm32n6xx_hal.h"

__STATIC_FORCEINLINE int mcu_cache_enabled(void) {
#if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
340012b2:	4b1d      	ldr	r3, [pc, #116]	@ (34001328 <mcu_cache_invalidate_range+0x80>)
340012b4:	695b      	ldr	r3, [r3, #20]
340012b6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340012ba:	2b00      	cmp	r3, #0
340012bc:	d001      	beq.n	340012c2 <mcu_cache_invalidate_range+0x1a>
340012be:	2301      	movs	r3, #1
340012c0:	e000      	b.n	340012c4 <mcu_cache_invalidate_range+0x1c>
#endif // (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)

  return 0;
340012c2:	2300      	movs	r3, #0
  if(mcu_cache_enabled()) {
340012c4:	2b00      	cmp	r3, #0
340012c6:	d027      	beq.n	34001318 <mcu_cache_invalidate_range+0x70>
    SCB_InvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
340012c8:	687b      	ldr	r3, [r7, #4]
340012ca:	6839      	ldr	r1, [r7, #0]
340012cc:	687a      	ldr	r2, [r7, #4]
340012ce:	1a8a      	subs	r2, r1, r2
340012d0:	617b      	str	r3, [r7, #20]
340012d2:	613a      	str	r2, [r7, #16]
    if ( dsize > 0 ) {
340012d4:	693b      	ldr	r3, [r7, #16]
340012d6:	2b00      	cmp	r3, #0
340012d8:	dd1d      	ble.n	34001316 <mcu_cache_invalidate_range+0x6e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340012da:	697b      	ldr	r3, [r7, #20]
340012dc:	f003 021f 	and.w	r2, r3, #31
340012e0:	693b      	ldr	r3, [r7, #16]
340012e2:	4413      	add	r3, r2
340012e4:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
340012e6:	697b      	ldr	r3, [r7, #20]
340012e8:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
340012ea:	f3bf 8f4f 	dsb	sy
}
340012ee:	bf00      	nop
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340012f0:	4a0d      	ldr	r2, [pc, #52]	@ (34001328 <mcu_cache_invalidate_range+0x80>)
340012f2:	68bb      	ldr	r3, [r7, #8]
340012f4:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
340012f8:	68bb      	ldr	r3, [r7, #8]
340012fa:	3320      	adds	r3, #32
340012fc:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
340012fe:	68fb      	ldr	r3, [r7, #12]
34001300:	3b20      	subs	r3, #32
34001302:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
34001304:	68fb      	ldr	r3, [r7, #12]
34001306:	2b00      	cmp	r3, #0
34001308:	dcf2      	bgt.n	340012f0 <mcu_cache_invalidate_range+0x48>
  __ASM volatile ("dsb 0xF":::"memory");
3400130a:	f3bf 8f4f 	dsb	sy
}
3400130e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34001310:	f3bf 8f6f 	isb	sy
}
34001314:	bf00      	nop
}
34001316:	bf00      	nop
  }
  return 0;
34001318:	2300      	movs	r3, #0
}
3400131a:	4618      	mov	r0, r3
3400131c:	371c      	adds	r7, #28
3400131e:	46bd      	mov	sp, r7
34001320:	f85d 7b04 	ldr.w	r7, [sp], #4
34001324:	4770      	bx	lr
34001326:	bf00      	nop
34001328:	e000ed00 	.word	0xe000ed00

3400132c <mcu_cache_clean_range>:

int mcu_cache_clean_range(uint32_t start_addr, uint32_t end_addr) {
3400132c:	b480      	push	{r7}
3400132e:	b087      	sub	sp, #28
34001330:	af00      	add	r7, sp, #0
34001332:	6078      	str	r0, [r7, #4]
34001334:	6039      	str	r1, [r7, #0]
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
34001336:	4b1d      	ldr	r3, [pc, #116]	@ (340013ac <mcu_cache_clean_range+0x80>)
34001338:	695b      	ldr	r3, [r3, #20]
3400133a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400133e:	2b00      	cmp	r3, #0
34001340:	d001      	beq.n	34001346 <mcu_cache_clean_range+0x1a>
34001342:	2301      	movs	r3, #1
34001344:	e000      	b.n	34001348 <mcu_cache_clean_range+0x1c>
  return 0;
34001346:	2300      	movs	r3, #0
  if(mcu_cache_enabled()) {
34001348:	2b00      	cmp	r3, #0
3400134a:	d027      	beq.n	3400139c <mcu_cache_clean_range+0x70>
    SCB_CleanDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
3400134c:	687b      	ldr	r3, [r7, #4]
3400134e:	6839      	ldr	r1, [r7, #0]
34001350:	687a      	ldr	r2, [r7, #4]
34001352:	1a8a      	subs	r2, r1, r2
34001354:	617b      	str	r3, [r7, #20]
34001356:	613a      	str	r2, [r7, #16]
    if ( dsize > 0 ) {
34001358:	693b      	ldr	r3, [r7, #16]
3400135a:	2b00      	cmp	r3, #0
3400135c:	dd1d      	ble.n	3400139a <mcu_cache_clean_range+0x6e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
3400135e:	697b      	ldr	r3, [r7, #20]
34001360:	f003 021f 	and.w	r2, r3, #31
34001364:	693b      	ldr	r3, [r7, #16]
34001366:	4413      	add	r3, r2
34001368:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
3400136a:	697b      	ldr	r3, [r7, #20]
3400136c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
3400136e:	f3bf 8f4f 	dsb	sy
}
34001372:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34001374:	4a0d      	ldr	r2, [pc, #52]	@ (340013ac <mcu_cache_clean_range+0x80>)
34001376:	68bb      	ldr	r3, [r7, #8]
34001378:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
3400137c:	68bb      	ldr	r3, [r7, #8]
3400137e:	3320      	adds	r3, #32
34001380:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
34001382:	68fb      	ldr	r3, [r7, #12]
34001384:	3b20      	subs	r3, #32
34001386:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
34001388:	68fb      	ldr	r3, [r7, #12]
3400138a:	2b00      	cmp	r3, #0
3400138c:	dcf2      	bgt.n	34001374 <mcu_cache_clean_range+0x48>
  __ASM volatile ("dsb 0xF":::"memory");
3400138e:	f3bf 8f4f 	dsb	sy
}
34001392:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34001394:	f3bf 8f6f 	isb	sy
}
34001398:	bf00      	nop
}
3400139a:	bf00      	nop
  }
  return 0;
3400139c:	2300      	movs	r3, #0
}
3400139e:	4618      	mov	r0, r3
340013a0:	371c      	adds	r7, #28
340013a2:	46bd      	mov	sp, r7
340013a4:	f85d 7b04 	ldr.w	r7, [sp], #4
340013a8:	4770      	bx	lr
340013aa:	bf00      	nop
340013ac:	e000ed00 	.word	0xe000ed00

340013b0 <LL_ATON_Cache_MCU_Clean_Range>:
 */
#if defined(LL_ATON_RT_RELOC) && defined(BUILD_AI_NETWORK_RELOC)
  void LL_ATON_Cache_MCU_Clean_Range(uintptr_t virtual_addr, uint32_t size);
#else
  static inline void LL_ATON_Cache_MCU_Clean_Range(uintptr_t virtual_addr, uint32_t size)
  {
340013b0:	b580      	push	{r7, lr}
340013b2:	b082      	sub	sp, #8
340013b4:	af00      	add	r7, sp, #0
340013b6:	6078      	str	r0, [r7, #4]
340013b8:	6039      	str	r1, [r7, #0]
    LL_ATON_OSAL_LOCK_MCU_CACHE();
    mcu_cache_clean_range(virtual_addr, virtual_addr + size);
340013ba:	687a      	ldr	r2, [r7, #4]
340013bc:	683b      	ldr	r3, [r7, #0]
340013be:	4413      	add	r3, r2
340013c0:	4619      	mov	r1, r3
340013c2:	6878      	ldr	r0, [r7, #4]
340013c4:	f7ff ffb2 	bl	3400132c <mcu_cache_clean_range>
    LL_ATON_OSAL_UNLOCK_MCU_CACHE();
  }
340013c8:	bf00      	nop
340013ca:	3708      	adds	r7, #8
340013cc:	46bd      	mov	sp, r7
340013ce:	bd80      	pop	{r7, pc}

340013d0 <LL_ATON_Cache_MCU_Invalidate_Range>:
 */
#if defined(LL_ATON_RT_RELOC) && defined(BUILD_AI_NETWORK_RELOC)
  void LL_ATON_Cache_MCU_Invalidate_Range(uintptr_t virtual_addr, uint32_t size);
#else
  static inline void LL_ATON_Cache_MCU_Invalidate_Range(uintptr_t virtual_addr, uint32_t size)
  {
340013d0:	b580      	push	{r7, lr}
340013d2:	b082      	sub	sp, #8
340013d4:	af00      	add	r7, sp, #0
340013d6:	6078      	str	r0, [r7, #4]
340013d8:	6039      	str	r1, [r7, #0]
    LL_ATON_OSAL_LOCK_MCU_CACHE();
    mcu_cache_invalidate_range(virtual_addr, virtual_addr + size);
340013da:	687a      	ldr	r2, [r7, #4]
340013dc:	683b      	ldr	r3, [r7, #0]
340013de:	4413      	add	r3, r2
340013e0:	4619      	mov	r1, r3
340013e2:	6878      	ldr	r0, [r7, #4]
340013e4:	f7ff ff60 	bl	340012a8 <mcu_cache_invalidate_range>
    LL_ATON_OSAL_UNLOCK_MCU_CACHE();
  }
340013e8:	bf00      	nop
340013ea:	3708      	adds	r7, #8
340013ec:	46bd      	mov	sp, r7
340013ee:	bd80      	pop	{r7, pc}

340013f0 <LL_ATON_Set_User_Input_Buffer_Default>:
/* index=5 file postfix=AXISRAM1 name=cpuRAM1 offset=0x34064000  absolute_mode size=0 READ_WRITE THROUGHPUT=MID LATENCY=MID byte width=8 freq ratio=2.5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=16.616 write_power=14.522 use4initializers=NO score=84  */
/* global pool 6 is ? */
/* index=6 file postfix=AXIFLEXMEM name=flexMEM offset=0x34000000  absolute_mode size=0 READ_WRITE THROUGHPUT=MID LATENCY=MID byte width=8 freq ratio=2.5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=9.381 write_power=8.569 use4initializers=NO score=84  */

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Input_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
{
340013f0:	b480      	push	{r7}
340013f2:	b085      	sub	sp, #20
340013f4:	af00      	add	r7, sp, #0
340013f6:	60f8      	str	r0, [r7, #12]
340013f8:	60b9      	str	r1, [r7, #8]
340013fa:	607a      	str	r2, [r7, #4]
  { 
    return LL_ATON_User_IO_WRONG_INDEX;
340013fc:	2303      	movs	r3, #3
  }
}
340013fe:	4618      	mov	r0, r3
34001400:	3714      	adds	r7, #20
34001402:	46bd      	mov	sp, r7
34001404:	f85d 7b04 	ldr.w	r7, [sp], #4
34001408:	4770      	bx	lr

3400140a <LL_ATON_Get_User_Input_Buffer_Default>:

void *LL_ATON_Get_User_Input_Buffer_Default(uint32_t num)
{
3400140a:	b480      	push	{r7}
3400140c:	b083      	sub	sp, #12
3400140e:	af00      	add	r7, sp, #0
34001410:	6078      	str	r0, [r7, #4]
  { 
    return NULL;
34001412:	2300      	movs	r3, #0
  }
}
34001414:	4618      	mov	r0, r3
34001416:	370c      	adds	r7, #12
34001418:	46bd      	mov	sp, r7
3400141a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400141e:	4770      	bx	lr

34001420 <LL_ATON_Set_User_Output_Buffer_Default>:

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
{
34001420:	b480      	push	{r7}
34001422:	b085      	sub	sp, #20
34001424:	af00      	add	r7, sp, #0
34001426:	60f8      	str	r0, [r7, #12]
34001428:	60b9      	str	r1, [r7, #8]
3400142a:	607a      	str	r2, [r7, #4]
  { 
    return LL_ATON_User_IO_WRONG_INDEX;
3400142c:	2303      	movs	r3, #3
  }
}
3400142e:	4618      	mov	r0, r3
34001430:	3714      	adds	r7, #20
34001432:	46bd      	mov	sp, r7
34001434:	f85d 7b04 	ldr.w	r7, [sp], #4
34001438:	4770      	bx	lr

3400143a <LL_ATON_Get_User_Output_Buffer_Default>:

void *LL_ATON_Get_User_Output_Buffer_Default(uint32_t num)
{
3400143a:	b480      	push	{r7}
3400143c:	b083      	sub	sp, #12
3400143e:	af00      	add	r7, sp, #0
34001440:	6078      	str	r0, [r7, #4]
  { 
    return NULL;
34001442:	2300      	movs	r3, #0
  }
}
34001444:	4618      	mov	r0, r3
34001446:	370c      	adds	r7, #12
34001448:	46bd      	mov	sp, r7
3400144a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400144e:	4770      	bx	lr

34001450 <LL_ATON_EC_Network_Init_Default>:
};


// this function MUST be called ONLY ONCE once for initializing the network
bool LL_ATON_EC_Network_Init_Default(void)
{
34001450:	b480      	push	{r7}
34001452:	af00      	add	r7, sp, #0


  return true;
34001454:	2301      	movs	r3, #1
}
34001456:	4618      	mov	r0, r3
34001458:	46bd      	mov	sp, r7
3400145a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400145e:	4770      	bx	lr

34001460 <LL_ATON_EC_Inference_Init_Default>:

// this function should be called before each inference
bool LL_ATON_EC_Inference_Init_Default(void)
{
34001460:	b480      	push	{r7}
34001462:	af00      	add	r7, sp, #0


  return true;
34001464:	2301      	movs	r3, #1
}
34001466:	4618      	mov	r0, r3
34001468:	46bd      	mov	sp, r7
3400146a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400146e:	4770      	bx	lr

34001470 <_ec_blob_cache_start_func_1>:
/* scheduling epoch=0    nodes=49  ------------------------------------------------------------------- */

// Epoch Controller Blob (name='_ec_blob_1') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_1') start function
static void _ec_blob_cache_start_func_1(const void *epoch_block) {
34001470:	b580      	push	{r7, lr}
34001472:	b082      	sub	sp, #8
34001474:	af00      	add	r7, sp, #0
34001476:	6078      	str	r0, [r7, #4]

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8832))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8832))) /* Equivalent hex address = 0x342e2280UL */, 1472);
34001478:	f44f 61b8 	mov.w	r1, #1472	@ 0x5c0
3400147c:	4803      	ldr	r0, [pc, #12]	@ (3400148c <_ec_blob_cache_start_func_1+0x1c>)
3400147e:	f7ff ffa7 	bl	340013d0 <LL_ATON_Cache_MCU_Invalidate_Range>

};
34001482:	bf00      	nop
34001484:	3708      	adds	r7, #8
34001486:	46bd      	mov	sp, r7
34001488:	bd80      	pop	{r7, pc}
3400148a:	bf00      	nop
3400148c:	342e2280 	.word	0x342e2280

34001490 <LL_ATON_End_EpochBlock_19>:


/* scheduling epoch=19   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_19(const void *epoch_block)
{
34001490:	b580      	push	{r7, lr}
34001492:	b0b0      	sub	sp, #192	@ 0xc0
34001494:	af00      	add	r7, sp, #0
34001496:	6078      	str	r0, [r7, #4]
  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856))) /* Equivalent hex address = 0x342e16e0UL */, 32);
34001498:	2120      	movs	r1, #32
3400149a:	482f      	ldr	r0, [pc, #188]	@ (34001558 <LL_ATON_End_EpochBlock_19+0xc8>)
3400149c:	f7ff ff98 	bl	340013d0 <LL_ATON_Cache_MCU_Invalidate_Range>
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=Dequantize_54 */
  Dequantizelinear_sw_info dequantizelinear1_sw_info = {
340014a0:	f107 030c 	add.w	r3, r7, #12
340014a4:	22b4      	movs	r2, #180	@ 0xb4
340014a6:	2100      	movs	r1, #0
340014a8:	4618      	mov	r0, r3
340014aa:	f020 f893 	bl	340215d4 <memset>
340014ae:	232a      	movs	r3, #42	@ 0x2a
340014b0:	733b      	strb	r3, [r7, #12]
340014b2:	2307      	movs	r3, #7
340014b4:	613b      	str	r3, [r7, #16]
340014b6:	2307      	movs	r3, #7
340014b8:	617b      	str	r3, [r7, #20]
340014ba:	231e      	movs	r3, #30
340014bc:	61bb      	str	r3, [r7, #24]
340014be:	2301      	movs	r3, #1
340014c0:	61fb      	str	r3, [r7, #28]
340014c2:	f240 53be 	movw	r3, #1470	@ 0x5be
340014c6:	623b      	str	r3, [r7, #32]
340014c8:	23d2      	movs	r3, #210	@ 0xd2
340014ca:	627b      	str	r3, [r7, #36]	@ 0x24
340014cc:	231e      	movs	r3, #30
340014ce:	62bb      	str	r3, [r7, #40]	@ 0x28
340014d0:	2301      	movs	r3, #1
340014d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
340014d4:	f240 53be 	movw	r3, #1470	@ 0x5be
340014d8:	633b      	str	r3, [r7, #48]	@ 0x30
340014da:	4b20      	ldr	r3, [pc, #128]	@ (3400155c <LL_ATON_End_EpochBlock_19+0xcc>)
340014dc:	637b      	str	r3, [r7, #52]	@ 0x34
340014de:	2301      	movs	r3, #1
340014e0:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
340014e4:	2307      	movs	r3, #7
340014e6:	63fb      	str	r3, [r7, #60]	@ 0x3c
340014e8:	2307      	movs	r3, #7
340014ea:	643b      	str	r3, [r7, #64]	@ 0x40
340014ec:	231e      	movs	r3, #30
340014ee:	647b      	str	r3, [r7, #68]	@ 0x44
340014f0:	2301      	movs	r3, #1
340014f2:	64bb      	str	r3, [r7, #72]	@ 0x48
340014f4:	f240 53be 	movw	r3, #1470	@ 0x5be
340014f8:	64fb      	str	r3, [r7, #76]	@ 0x4c
340014fa:	f44f 7352 	mov.w	r3, #840	@ 0x348
340014fe:	653b      	str	r3, [r7, #80]	@ 0x50
34001500:	2378      	movs	r3, #120	@ 0x78
34001502:	657b      	str	r3, [r7, #84]	@ 0x54
34001504:	2304      	movs	r3, #4
34001506:	65bb      	str	r3, [r7, #88]	@ 0x58
34001508:	f241 63f8 	movw	r3, #5880	@ 0x16f8
3400150c:	65fb      	str	r3, [r7, #92]	@ 0x5c
3400150e:	4b14      	ldr	r3, [pc, #80]	@ (34001560 <LL_ATON_End_EpochBlock_19+0xd0>)
34001510:	663b      	str	r3, [r7, #96]	@ 0x60
34001512:	2301      	movs	r3, #1
34001514:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
34001518:	2301      	movs	r3, #1
3400151a:	67bb      	str	r3, [r7, #120]	@ 0x78
3400151c:	4b11      	ldr	r3, [pc, #68]	@ (34001564 <LL_ATON_End_EpochBlock_19+0xd4>)
3400151e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34001522:	2301      	movs	r3, #1
34001524:	f887 3090 	strb.w	r3, [r7, #144]	@ 0x90
34001528:	2301      	movs	r3, #1
3400152a:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
3400152e:	4b0e      	ldr	r3, [pc, #56]	@ (34001568 <LL_ATON_End_EpochBlock_19+0xd8>)
34001530:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
34001534:	2301      	movs	r3, #1
34001536:	f887 30bc 	strb.w	r3, [r7, #188]	@ 0xbc
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Dequantize_54 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear1_sw_info);
3400153a:	f107 030c 	add.w	r3, r7, #12
3400153e:	4618      	mov	r0, r3
34001540:	f01d fe5c 	bl	3401f1fc <ll_sw_forward_dequantizelinear>
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 5888);
34001544:	f44f 51b8 	mov.w	r1, #5888	@ 0x1700
34001548:	4805      	ldr	r0, [pc, #20]	@ (34001560 <LL_ATON_End_EpochBlock_19+0xd0>)
3400154a:	f7ff ff31 	bl	340013b0 <LL_ATON_Cache_MCU_Clean_Range>

}
3400154e:	bf00      	nop
34001550:	37c0      	adds	r7, #192	@ 0xc0
34001552:	46bd      	mov	sp, r7
34001554:	bd80      	pop	{r7, pc}
34001556:	bf00      	nop
34001558:	342e16e0 	.word	0x342e16e0
3400155c:	342e2280 	.word	0x342e2280
34001560:	342e0000 	.word	0x342e0000
34001564:	71a8a9b0 	.word	0x71a8a9b0
34001568:	71a8a9c0 	.word	0x71a8a9c0

3400156c <LL_ATON_EpochBlockItems_Default>:
// Epoch Controller Blob (name='_ec_blob_20') micro instructions needed


/* scheduling DONE                 ------------------------------------------------------------------- */

const EpochBlock_ItemTypeDef *LL_ATON_EpochBlockItems_Default(void) {
3400156c:	b480      	push	{r7}
3400156e:	af00      	add	r7, sp, #0
      .flags = EpochBlock_Flags_last_eb,
    },
  };


  return ll_atonn_rt_epoch_block_array;
34001570:	4b02      	ldr	r3, [pc, #8]	@ (3400157c <LL_ATON_EpochBlockItems_Default+0x10>)
}
34001572:	4618      	mov	r0, r3
34001574:	46bd      	mov	sp, r7
34001576:	f85d 7b04 	ldr.w	r7, [sp], #4
3400157a:	4770      	bx	lr
3400157c:	34030400 	.word	0x34030400

34001580 <LL_ATON_Input_Buffers_Info_Default>:

const LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info_Default(void)
{
34001580:	b480      	push	{r7}
34001582:	af00      	add	r7, sp, #0
    {
      .name = NULL,
    }
  };

  return buff_info;
34001584:	4b02      	ldr	r3, [pc, #8]	@ (34001590 <LL_ATON_Input_Buffers_Info_Default+0x10>)
}
34001586:	4618      	mov	r0, r3
34001588:	46bd      	mov	sp, r7
3400158a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400158e:	4770      	bx	lr
34001590:	34030450 	.word	0x34030450

34001594 <LL_ATON_Output_Buffers_Info_Default>:

const LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info_Default(void)
{
34001594:	b480      	push	{r7}
34001596:	af00      	add	r7, sp, #0
    {
      .name = NULL,
    }
  };

  return buff_info;
34001598:	4b02      	ldr	r3, [pc, #8]	@ (340015a4 <LL_ATON_Output_Buffers_Info_Default+0x10>)
}
3400159a:	4618      	mov	r0, r3
3400159c:	46bd      	mov	sp, r7
3400159e:	f85d 7b04 	ldr.w	r7, [sp], #4
340015a2:	4770      	bx	lr
340015a4:	340304e8 	.word	0x340304e8

340015a8 <LL_ATON_Internal_Buffers_Info_Default>:

const LL_Buffer_InfoTypeDef *LL_ATON_Internal_Buffers_Info_Default(void)
{
340015a8:	b480      	push	{r7}
340015aa:	af00      	add	r7, sp, #0
    {
      .name = NULL,
    }
  };

  return buff_info;
340015ac:	4b02      	ldr	r3, [pc, #8]	@ (340015b8 <LL_ATON_Internal_Buffers_Info_Default+0x10>)
}
340015ae:	4618      	mov	r0, r3
340015b0:	46bd      	mov	sp, r7
340015b2:	f85d 7b04 	ldr.w	r7, [sp], #4
340015b6:	4770      	bx	lr
340015b8:	34030578 	.word	0x34030578

340015bc <npu_cache_init>:
#include "stm32n6xx_hal_cacheaxi.h"

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
340015bc:	b580      	push	{r7, lr}
340015be:	af00      	add	r7, sp, #0
  hcacheaxi_s.Instance = CACHEAXI;
340015c0:	4b03      	ldr	r3, [pc, #12]	@ (340015d0 <npu_cache_init+0x14>)
340015c2:	4a04      	ldr	r2, [pc, #16]	@ (340015d4 <npu_cache_init+0x18>)
340015c4:	601a      	str	r2, [r3, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
340015c6:	4802      	ldr	r0, [pc, #8]	@ (340015d0 <npu_cache_init+0x14>)
340015c8:	f006 f98c 	bl	340078e4 <HAL_CACHEAXI_Init>
}
340015cc:	bf00      	nop
340015ce:	bd80      	pop	{r7, pc}
340015d0:	34034190 	.word	0x34034190
340015d4:	580dfc00 	.word	0x580dfc00

340015d8 <npu_cache_enable>:

void npu_cache_enable(void)
{
340015d8:	b580      	push	{r7, lr}
340015da:	b082      	sub	sp, #8
340015dc:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;
  // Enable is wrapped in a loop because most of times, the first call returns
  //    HAL_BUSY, resulting in a cache not enabled.
  do
  {
    status = HAL_CACHEAXI_Enable(&hcacheaxi_s);
340015de:	4806      	ldr	r0, [pc, #24]	@ (340015f8 <npu_cache_enable+0x20>)
340015e0:	f006 f9b6 	bl	34007950 <HAL_CACHEAXI_Enable>
340015e4:	4603      	mov	r3, r0
340015e6:	71fb      	strb	r3, [r7, #7]
  } while (status == HAL_BUSY);
340015e8:	79fb      	ldrb	r3, [r7, #7]
340015ea:	2b02      	cmp	r3, #2
340015ec:	d0f7      	beq.n	340015de <npu_cache_enable+0x6>
}
340015ee:	bf00      	nop
340015f0:	bf00      	nop
340015f2:	3708      	adds	r7, #8
340015f4:	46bd      	mov	sp, r7
340015f6:	bd80      	pop	{r7, pc}
340015f8:	34034190 	.word	0x34034190

340015fc <stbi__start_write_callbacks>:
   int buf_used;
} stbi__write_context;

// initialize a callback-based context
static void stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)
{
340015fc:	b480      	push	{r7}
340015fe:	b085      	sub	sp, #20
34001600:	af00      	add	r7, sp, #0
34001602:	60f8      	str	r0, [r7, #12]
34001604:	60b9      	str	r1, [r7, #8]
34001606:	607a      	str	r2, [r7, #4]
   s->func    = c;
34001608:	68fb      	ldr	r3, [r7, #12]
3400160a:	68ba      	ldr	r2, [r7, #8]
3400160c:	601a      	str	r2, [r3, #0]
   s->context = context;
3400160e:	68fb      	ldr	r3, [r7, #12]
34001610:	687a      	ldr	r2, [r7, #4]
34001612:	605a      	str	r2, [r3, #4]
}
34001614:	bf00      	nop
34001616:	3714      	adds	r7, #20
34001618:	46bd      	mov	sp, r7
3400161a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400161e:	4770      	bx	lr

34001620 <stbiw__putc>:
      s->buf_used = 0;
   }
}

static void stbiw__putc(stbi__write_context *s, unsigned char c)
{
34001620:	b580      	push	{r7, lr}
34001622:	b082      	sub	sp, #8
34001624:	af00      	add	r7, sp, #0
34001626:	6078      	str	r0, [r7, #4]
34001628:	460b      	mov	r3, r1
3400162a:	70fb      	strb	r3, [r7, #3]
   s->func(s->context, &c, 1);
3400162c:	687b      	ldr	r3, [r7, #4]
3400162e:	681b      	ldr	r3, [r3, #0]
34001630:	687a      	ldr	r2, [r7, #4]
34001632:	6850      	ldr	r0, [r2, #4]
34001634:	1cf9      	adds	r1, r7, #3
34001636:	2201      	movs	r2, #1
34001638:	4798      	blx	r3
}
3400163a:	bf00      	nop
3400163c:	3708      	adds	r7, #8
3400163e:	46bd      	mov	sp, r7
34001640:	bd80      	pop	{r7, pc}

34001642 <stbiw__jpg_writeBits>:
 */

static const unsigned char stbiw__jpg_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,
      24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };

static void stbiw__jpg_writeBits(stbi__write_context *s, int *bitBufP, int *bitCntP, const unsigned short *bs) {
34001642:	b580      	push	{r7, lr}
34001644:	b088      	sub	sp, #32
34001646:	af00      	add	r7, sp, #0
34001648:	60f8      	str	r0, [r7, #12]
3400164a:	60b9      	str	r1, [r7, #8]
3400164c:	607a      	str	r2, [r7, #4]
3400164e:	603b      	str	r3, [r7, #0]
   int bitBuf = *bitBufP, bitCnt = *bitCntP;
34001650:	68bb      	ldr	r3, [r7, #8]
34001652:	681b      	ldr	r3, [r3, #0]
34001654:	61fb      	str	r3, [r7, #28]
34001656:	687b      	ldr	r3, [r7, #4]
34001658:	681b      	ldr	r3, [r3, #0]
3400165a:	61bb      	str	r3, [r7, #24]
   bitCnt += bs[1];
3400165c:	683b      	ldr	r3, [r7, #0]
3400165e:	3302      	adds	r3, #2
34001660:	881b      	ldrh	r3, [r3, #0]
34001662:	461a      	mov	r2, r3
34001664:	69bb      	ldr	r3, [r7, #24]
34001666:	4413      	add	r3, r2
34001668:	61bb      	str	r3, [r7, #24]
   bitBuf |= bs[0] << (24 - bitCnt);
3400166a:	683b      	ldr	r3, [r7, #0]
3400166c:	881b      	ldrh	r3, [r3, #0]
3400166e:	461a      	mov	r2, r3
34001670:	69bb      	ldr	r3, [r7, #24]
34001672:	f1c3 0318 	rsb	r3, r3, #24
34001676:	fa02 f303 	lsl.w	r3, r2, r3
3400167a:	69fa      	ldr	r2, [r7, #28]
3400167c:	4313      	orrs	r3, r2
3400167e:	61fb      	str	r3, [r7, #28]
   while(bitCnt >= 8) {
34001680:	e014      	b.n	340016ac <stbiw__jpg_writeBits+0x6a>
      unsigned char c = (bitBuf >> 16) & 255;
34001682:	69fb      	ldr	r3, [r7, #28]
34001684:	141b      	asrs	r3, r3, #16
34001686:	75fb      	strb	r3, [r7, #23]
      stbiw__putc(s, c);
34001688:	7dfb      	ldrb	r3, [r7, #23]
3400168a:	4619      	mov	r1, r3
3400168c:	68f8      	ldr	r0, [r7, #12]
3400168e:	f7ff ffc7 	bl	34001620 <stbiw__putc>
      if(c == 255) {
34001692:	7dfb      	ldrb	r3, [r7, #23]
34001694:	2bff      	cmp	r3, #255	@ 0xff
34001696:	d103      	bne.n	340016a0 <stbiw__jpg_writeBits+0x5e>
         stbiw__putc(s, 0);
34001698:	2100      	movs	r1, #0
3400169a:	68f8      	ldr	r0, [r7, #12]
3400169c:	f7ff ffc0 	bl	34001620 <stbiw__putc>
      }
      bitBuf <<= 8;
340016a0:	69fb      	ldr	r3, [r7, #28]
340016a2:	021b      	lsls	r3, r3, #8
340016a4:	61fb      	str	r3, [r7, #28]
      bitCnt -= 8;
340016a6:	69bb      	ldr	r3, [r7, #24]
340016a8:	3b08      	subs	r3, #8
340016aa:	61bb      	str	r3, [r7, #24]
   while(bitCnt >= 8) {
340016ac:	69bb      	ldr	r3, [r7, #24]
340016ae:	2b07      	cmp	r3, #7
340016b0:	dce7      	bgt.n	34001682 <stbiw__jpg_writeBits+0x40>
   }
   *bitBufP = bitBuf;
340016b2:	68bb      	ldr	r3, [r7, #8]
340016b4:	69fa      	ldr	r2, [r7, #28]
340016b6:	601a      	str	r2, [r3, #0]
   *bitCntP = bitCnt;
340016b8:	687b      	ldr	r3, [r7, #4]
340016ba:	69ba      	ldr	r2, [r7, #24]
340016bc:	601a      	str	r2, [r3, #0]
}
340016be:	bf00      	nop
340016c0:	3720      	adds	r7, #32
340016c2:	46bd      	mov	sp, r7
340016c4:	bd80      	pop	{r7, pc}
	...

340016c8 <stbiw__jpg_DCT>:

static void stbiw__jpg_DCT(float *d0p, float *d1p, float *d2p, float *d3p, float *d4p, float *d5p, float *d6p, float *d7p) {
340016c8:	b480      	push	{r7}
340016ca:	b0a1      	sub	sp, #132	@ 0x84
340016cc:	af00      	add	r7, sp, #0
340016ce:	60f8      	str	r0, [r7, #12]
340016d0:	60b9      	str	r1, [r7, #8]
340016d2:	607a      	str	r2, [r7, #4]
340016d4:	603b      	str	r3, [r7, #0]
   float d0 = *d0p, d1 = *d1p, d2 = *d2p, d3 = *d3p, d4 = *d4p, d5 = *d5p, d6 = *d6p, d7 = *d7p;
340016d6:	68fb      	ldr	r3, [r7, #12]
340016d8:	681b      	ldr	r3, [r3, #0]
340016da:	67fb      	str	r3, [r7, #124]	@ 0x7c
340016dc:	68bb      	ldr	r3, [r7, #8]
340016de:	681b      	ldr	r3, [r3, #0]
340016e0:	67bb      	str	r3, [r7, #120]	@ 0x78
340016e2:	687b      	ldr	r3, [r7, #4]
340016e4:	681b      	ldr	r3, [r3, #0]
340016e6:	677b      	str	r3, [r7, #116]	@ 0x74
340016e8:	683b      	ldr	r3, [r7, #0]
340016ea:	681b      	ldr	r3, [r3, #0]
340016ec:	673b      	str	r3, [r7, #112]	@ 0x70
340016ee:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
340016f2:	681b      	ldr	r3, [r3, #0]
340016f4:	66fb      	str	r3, [r7, #108]	@ 0x6c
340016f6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
340016fa:	681b      	ldr	r3, [r3, #0]
340016fc:	66bb      	str	r3, [r7, #104]	@ 0x68
340016fe:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34001702:	681b      	ldr	r3, [r3, #0]
34001704:	667b      	str	r3, [r7, #100]	@ 0x64
34001706:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3400170a:	681b      	ldr	r3, [r3, #0]
3400170c:	663b      	str	r3, [r7, #96]	@ 0x60
   float z1, z2, z3, z4, z5, z11, z13;

   float tmp0 = d0 + d7;
3400170e:	ed97 7a1f 	vldr	s14, [r7, #124]	@ 0x7c
34001712:	edd7 7a18 	vldr	s15, [r7, #96]	@ 0x60
34001716:	ee77 7a27 	vadd.f32	s15, s14, s15
3400171a:	edc7 7a17 	vstr	s15, [r7, #92]	@ 0x5c
   float tmp7 = d0 - d7;
3400171e:	ed97 7a1f 	vldr	s14, [r7, #124]	@ 0x7c
34001722:	edd7 7a18 	vldr	s15, [r7, #96]	@ 0x60
34001726:	ee77 7a67 	vsub.f32	s15, s14, s15
3400172a:	edc7 7a16 	vstr	s15, [r7, #88]	@ 0x58
   float tmp1 = d1 + d6;
3400172e:	ed97 7a1e 	vldr	s14, [r7, #120]	@ 0x78
34001732:	edd7 7a19 	vldr	s15, [r7, #100]	@ 0x64
34001736:	ee77 7a27 	vadd.f32	s15, s14, s15
3400173a:	edc7 7a15 	vstr	s15, [r7, #84]	@ 0x54
   float tmp6 = d1 - d6;
3400173e:	ed97 7a1e 	vldr	s14, [r7, #120]	@ 0x78
34001742:	edd7 7a19 	vldr	s15, [r7, #100]	@ 0x64
34001746:	ee77 7a67 	vsub.f32	s15, s14, s15
3400174a:	edc7 7a14 	vstr	s15, [r7, #80]	@ 0x50
   float tmp2 = d2 + d5;
3400174e:	ed97 7a1d 	vldr	s14, [r7, #116]	@ 0x74
34001752:	edd7 7a1a 	vldr	s15, [r7, #104]	@ 0x68
34001756:	ee77 7a27 	vadd.f32	s15, s14, s15
3400175a:	edc7 7a13 	vstr	s15, [r7, #76]	@ 0x4c
   float tmp5 = d2 - d5;
3400175e:	ed97 7a1d 	vldr	s14, [r7, #116]	@ 0x74
34001762:	edd7 7a1a 	vldr	s15, [r7, #104]	@ 0x68
34001766:	ee77 7a67 	vsub.f32	s15, s14, s15
3400176a:	edc7 7a12 	vstr	s15, [r7, #72]	@ 0x48
   float tmp3 = d3 + d4;
3400176e:	ed97 7a1c 	vldr	s14, [r7, #112]	@ 0x70
34001772:	edd7 7a1b 	vldr	s15, [r7, #108]	@ 0x6c
34001776:	ee77 7a27 	vadd.f32	s15, s14, s15
3400177a:	edc7 7a11 	vstr	s15, [r7, #68]	@ 0x44
   float tmp4 = d3 - d4;
3400177e:	ed97 7a1c 	vldr	s14, [r7, #112]	@ 0x70
34001782:	edd7 7a1b 	vldr	s15, [r7, #108]	@ 0x6c
34001786:	ee77 7a67 	vsub.f32	s15, s14, s15
3400178a:	edc7 7a10 	vstr	s15, [r7, #64]	@ 0x40

   // Even part
   float tmp10 = tmp0 + tmp3;   // phase 2
3400178e:	ed97 7a17 	vldr	s14, [r7, #92]	@ 0x5c
34001792:	edd7 7a11 	vldr	s15, [r7, #68]	@ 0x44
34001796:	ee77 7a27 	vadd.f32	s15, s14, s15
3400179a:	edc7 7a0f 	vstr	s15, [r7, #60]	@ 0x3c
   float tmp13 = tmp0 - tmp3;
3400179e:	ed97 7a17 	vldr	s14, [r7, #92]	@ 0x5c
340017a2:	edd7 7a11 	vldr	s15, [r7, #68]	@ 0x44
340017a6:	ee77 7a67 	vsub.f32	s15, s14, s15
340017aa:	edc7 7a0e 	vstr	s15, [r7, #56]	@ 0x38
   float tmp11 = tmp1 + tmp2;
340017ae:	ed97 7a15 	vldr	s14, [r7, #84]	@ 0x54
340017b2:	edd7 7a13 	vldr	s15, [r7, #76]	@ 0x4c
340017b6:	ee77 7a27 	vadd.f32	s15, s14, s15
340017ba:	edc7 7a0d 	vstr	s15, [r7, #52]	@ 0x34
   float tmp12 = tmp1 - tmp2;
340017be:	ed97 7a15 	vldr	s14, [r7, #84]	@ 0x54
340017c2:	edd7 7a13 	vldr	s15, [r7, #76]	@ 0x4c
340017c6:	ee77 7a67 	vsub.f32	s15, s14, s15
340017ca:	edc7 7a0c 	vstr	s15, [r7, #48]	@ 0x30

   d0 = tmp10 + tmp11;       // phase 3
340017ce:	ed97 7a0f 	vldr	s14, [r7, #60]	@ 0x3c
340017d2:	edd7 7a0d 	vldr	s15, [r7, #52]	@ 0x34
340017d6:	ee77 7a27 	vadd.f32	s15, s14, s15
340017da:	edc7 7a1f 	vstr	s15, [r7, #124]	@ 0x7c
   d4 = tmp10 - tmp11;
340017de:	ed97 7a0f 	vldr	s14, [r7, #60]	@ 0x3c
340017e2:	edd7 7a0d 	vldr	s15, [r7, #52]	@ 0x34
340017e6:	ee77 7a67 	vsub.f32	s15, s14, s15
340017ea:	edc7 7a1b 	vstr	s15, [r7, #108]	@ 0x6c

   z1 = (tmp12 + tmp13) * 0.707106781f; // c4
340017ee:	ed97 7a0c 	vldr	s14, [r7, #48]	@ 0x30
340017f2:	edd7 7a0e 	vldr	s15, [r7, #56]	@ 0x38
340017f6:	ee77 7a27 	vadd.f32	s15, s14, s15
340017fa:	ed9f 7a52 	vldr	s14, [pc, #328]	@ 34001944 <stbiw__jpg_DCT+0x27c>
340017fe:	ee67 7a87 	vmul.f32	s15, s15, s14
34001802:	edc7 7a0b 	vstr	s15, [r7, #44]	@ 0x2c
   d2 = tmp13 + z1;       // phase 5
34001806:	ed97 7a0e 	vldr	s14, [r7, #56]	@ 0x38
3400180a:	edd7 7a0b 	vldr	s15, [r7, #44]	@ 0x2c
3400180e:	ee77 7a27 	vadd.f32	s15, s14, s15
34001812:	edc7 7a1d 	vstr	s15, [r7, #116]	@ 0x74
   d6 = tmp13 - z1;
34001816:	ed97 7a0e 	vldr	s14, [r7, #56]	@ 0x38
3400181a:	edd7 7a0b 	vldr	s15, [r7, #44]	@ 0x2c
3400181e:	ee77 7a67 	vsub.f32	s15, s14, s15
34001822:	edc7 7a19 	vstr	s15, [r7, #100]	@ 0x64

   // Odd part
   tmp10 = tmp4 + tmp5;       // phase 2
34001826:	ed97 7a10 	vldr	s14, [r7, #64]	@ 0x40
3400182a:	edd7 7a12 	vldr	s15, [r7, #72]	@ 0x48
3400182e:	ee77 7a27 	vadd.f32	s15, s14, s15
34001832:	edc7 7a0f 	vstr	s15, [r7, #60]	@ 0x3c
   tmp11 = tmp5 + tmp6;
34001836:	ed97 7a12 	vldr	s14, [r7, #72]	@ 0x48
3400183a:	edd7 7a14 	vldr	s15, [r7, #80]	@ 0x50
3400183e:	ee77 7a27 	vadd.f32	s15, s14, s15
34001842:	edc7 7a0d 	vstr	s15, [r7, #52]	@ 0x34
   tmp12 = tmp6 + tmp7;
34001846:	ed97 7a14 	vldr	s14, [r7, #80]	@ 0x50
3400184a:	edd7 7a16 	vldr	s15, [r7, #88]	@ 0x58
3400184e:	ee77 7a27 	vadd.f32	s15, s14, s15
34001852:	edc7 7a0c 	vstr	s15, [r7, #48]	@ 0x30

   // The rotator is modified from fig 4-8 to avoid extra negations.
   z5 = (tmp10 - tmp12) * 0.382683433f; // c6
34001856:	ed97 7a0f 	vldr	s14, [r7, #60]	@ 0x3c
3400185a:	edd7 7a0c 	vldr	s15, [r7, #48]	@ 0x30
3400185e:	ee77 7a67 	vsub.f32	s15, s14, s15
34001862:	ed9f 7a39 	vldr	s14, [pc, #228]	@ 34001948 <stbiw__jpg_DCT+0x280>
34001866:	ee67 7a87 	vmul.f32	s15, s15, s14
3400186a:	edc7 7a0a 	vstr	s15, [r7, #40]	@ 0x28
   z2 = tmp10 * 0.541196100f + z5; // c2-c6
3400186e:	edd7 7a0f 	vldr	s15, [r7, #60]	@ 0x3c
34001872:	ed9f 7a36 	vldr	s14, [pc, #216]	@ 3400194c <stbiw__jpg_DCT+0x284>
34001876:	ee67 7a87 	vmul.f32	s15, s15, s14
3400187a:	ed97 7a0a 	vldr	s14, [r7, #40]	@ 0x28
3400187e:	ee77 7a27 	vadd.f32	s15, s14, s15
34001882:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
   z4 = tmp12 * 1.306562965f + z5; // c2+c6
34001886:	edd7 7a0c 	vldr	s15, [r7, #48]	@ 0x30
3400188a:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 34001950 <stbiw__jpg_DCT+0x288>
3400188e:	ee67 7a87 	vmul.f32	s15, s15, s14
34001892:	ed97 7a0a 	vldr	s14, [r7, #40]	@ 0x28
34001896:	ee77 7a27 	vadd.f32	s15, s14, s15
3400189a:	edc7 7a08 	vstr	s15, [r7, #32]
   z3 = tmp11 * 0.707106781f; // c4
3400189e:	edd7 7a0d 	vldr	s15, [r7, #52]	@ 0x34
340018a2:	ed9f 7a28 	vldr	s14, [pc, #160]	@ 34001944 <stbiw__jpg_DCT+0x27c>
340018a6:	ee67 7a87 	vmul.f32	s15, s15, s14
340018aa:	edc7 7a07 	vstr	s15, [r7, #28]

   z11 = tmp7 + z3;      // phase 5
340018ae:	ed97 7a16 	vldr	s14, [r7, #88]	@ 0x58
340018b2:	edd7 7a07 	vldr	s15, [r7, #28]
340018b6:	ee77 7a27 	vadd.f32	s15, s14, s15
340018ba:	edc7 7a06 	vstr	s15, [r7, #24]
   z13 = tmp7 - z3;
340018be:	ed97 7a16 	vldr	s14, [r7, #88]	@ 0x58
340018c2:	edd7 7a07 	vldr	s15, [r7, #28]
340018c6:	ee77 7a67 	vsub.f32	s15, s14, s15
340018ca:	edc7 7a05 	vstr	s15, [r7, #20]

   *d5p = z13 + z2;         // phase 6
340018ce:	ed97 7a05 	vldr	s14, [r7, #20]
340018d2:	edd7 7a09 	vldr	s15, [r7, #36]	@ 0x24
340018d6:	ee77 7a27 	vadd.f32	s15, s14, s15
340018da:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
340018de:	edc3 7a00 	vstr	s15, [r3]
   *d3p = z13 - z2;
340018e2:	ed97 7a05 	vldr	s14, [r7, #20]
340018e6:	edd7 7a09 	vldr	s15, [r7, #36]	@ 0x24
340018ea:	ee77 7a67 	vsub.f32	s15, s14, s15
340018ee:	683b      	ldr	r3, [r7, #0]
340018f0:	edc3 7a00 	vstr	s15, [r3]
   *d1p = z11 + z4;
340018f4:	ed97 7a06 	vldr	s14, [r7, #24]
340018f8:	edd7 7a08 	vldr	s15, [r7, #32]
340018fc:	ee77 7a27 	vadd.f32	s15, s14, s15
34001900:	68bb      	ldr	r3, [r7, #8]
34001902:	edc3 7a00 	vstr	s15, [r3]
   *d7p = z11 - z4;
34001906:	ed97 7a06 	vldr	s14, [r7, #24]
3400190a:	edd7 7a08 	vldr	s15, [r7, #32]
3400190e:	ee77 7a67 	vsub.f32	s15, s14, s15
34001912:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34001916:	edc3 7a00 	vstr	s15, [r3]

   *d0p = d0;  *d2p = d2;  *d4p = d4;  *d6p = d6;
3400191a:	68fb      	ldr	r3, [r7, #12]
3400191c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
3400191e:	601a      	str	r2, [r3, #0]
34001920:	687b      	ldr	r3, [r7, #4]
34001922:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
34001924:	601a      	str	r2, [r3, #0]
34001926:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3400192a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
3400192c:	601a      	str	r2, [r3, #0]
3400192e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34001932:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34001934:	601a      	str	r2, [r3, #0]
}
34001936:	bf00      	nop
34001938:	3784      	adds	r7, #132	@ 0x84
3400193a:	46bd      	mov	sp, r7
3400193c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001940:	4770      	bx	lr
34001942:	bf00      	nop
34001944:	3f3504f3 	.word	0x3f3504f3
34001948:	3ec3ef15 	.word	0x3ec3ef15
3400194c:	3f0a8bd4 	.word	0x3f0a8bd4
34001950:	3fa73d75 	.word	0x3fa73d75

34001954 <stbiw__jpg_calcBits>:

static void stbiw__jpg_calcBits(int val, unsigned short bits[2]) {
34001954:	b480      	push	{r7}
34001956:	b085      	sub	sp, #20
34001958:	af00      	add	r7, sp, #0
3400195a:	6078      	str	r0, [r7, #4]
3400195c:	6039      	str	r1, [r7, #0]
   int tmp1 = val < 0 ? -val : val;
3400195e:	687b      	ldr	r3, [r7, #4]
34001960:	2b00      	cmp	r3, #0
34001962:	bfb8      	it	lt
34001964:	425b      	neglt	r3, r3
34001966:	60fb      	str	r3, [r7, #12]
   val = val < 0 ? val-1 : val;
34001968:	687b      	ldr	r3, [r7, #4]
3400196a:	2b00      	cmp	r3, #0
3400196c:	da02      	bge.n	34001974 <stbiw__jpg_calcBits+0x20>
3400196e:	687b      	ldr	r3, [r7, #4]
34001970:	3b01      	subs	r3, #1
34001972:	e000      	b.n	34001976 <stbiw__jpg_calcBits+0x22>
34001974:	687b      	ldr	r3, [r7, #4]
34001976:	607b      	str	r3, [r7, #4]
   bits[1] = 1;
34001978:	683b      	ldr	r3, [r7, #0]
3400197a:	3302      	adds	r3, #2
3400197c:	2201      	movs	r2, #1
3400197e:	801a      	strh	r2, [r3, #0]
   while(tmp1 >>= 1) {
34001980:	e005      	b.n	3400198e <stbiw__jpg_calcBits+0x3a>
      ++bits[1];
34001982:	683b      	ldr	r3, [r7, #0]
34001984:	3302      	adds	r3, #2
34001986:	881a      	ldrh	r2, [r3, #0]
34001988:	3201      	adds	r2, #1
3400198a:	b292      	uxth	r2, r2
3400198c:	801a      	strh	r2, [r3, #0]
   while(tmp1 >>= 1) {
3400198e:	68fb      	ldr	r3, [r7, #12]
34001990:	105b      	asrs	r3, r3, #1
34001992:	60fb      	str	r3, [r7, #12]
34001994:	68fb      	ldr	r3, [r7, #12]
34001996:	2b00      	cmp	r3, #0
34001998:	d1f3      	bne.n	34001982 <stbiw__jpg_calcBits+0x2e>
   }
   bits[0] = val & ((1<<bits[1])-1);
3400199a:	683b      	ldr	r3, [r7, #0]
3400199c:	3302      	adds	r3, #2
3400199e:	881b      	ldrh	r3, [r3, #0]
340019a0:	461a      	mov	r2, r3
340019a2:	2301      	movs	r3, #1
340019a4:	4093      	lsls	r3, r2
340019a6:	b29b      	uxth	r3, r3
340019a8:	3b01      	subs	r3, #1
340019aa:	b29b      	uxth	r3, r3
340019ac:	b21a      	sxth	r2, r3
340019ae:	687b      	ldr	r3, [r7, #4]
340019b0:	b21b      	sxth	r3, r3
340019b2:	4013      	ands	r3, r2
340019b4:	b21b      	sxth	r3, r3
340019b6:	b29a      	uxth	r2, r3
340019b8:	683b      	ldr	r3, [r7, #0]
340019ba:	801a      	strh	r2, [r3, #0]
}
340019bc:	bf00      	nop
340019be:	3714      	adds	r7, #20
340019c0:	46bd      	mov	sp, r7
340019c2:	f85d 7b04 	ldr.w	r7, [sp], #4
340019c6:	4770      	bx	lr

340019c8 <stbiw__jpg_processDU>:

static int stbiw__jpg_processDU(stbi__write_context *s, int *bitBuf, int *bitCnt, float *CDU, int du_stride, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {
340019c8:	b5f0      	push	{r4, r5, r6, r7, lr}
340019ca:	b0db      	sub	sp, #364	@ 0x16c
340019cc:	af04      	add	r7, sp, #16
340019ce:	f507 74ac 	add.w	r4, r7, #344	@ 0x158
340019d2:	f5a4 74a6 	sub.w	r4, r4, #332	@ 0x14c
340019d6:	6020      	str	r0, [r4, #0]
340019d8:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
340019dc:	f5a0 70a8 	sub.w	r0, r0, #336	@ 0x150
340019e0:	6001      	str	r1, [r0, #0]
340019e2:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
340019e6:	f5a1 71aa 	sub.w	r1, r1, #340	@ 0x154
340019ea:	600a      	str	r2, [r1, #0]
340019ec:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
340019f0:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
340019f4:	6013      	str	r3, [r2, #0]
   const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };
340019f6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
340019fa:	881b      	ldrh	r3, [r3, #0]
340019fc:	f8a7 3120 	strh.w	r3, [r7, #288]	@ 0x120
34001a00:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
34001a04:	885b      	ldrh	r3, [r3, #2]
34001a06:	f8a7 3122 	strh.w	r3, [r7, #290]	@ 0x122
   const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };
34001a0a:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
34001a0e:	f503 7370 	add.w	r3, r3, #960	@ 0x3c0
34001a12:	881b      	ldrh	r3, [r3, #0]
34001a14:	f8a7 311c 	strh.w	r3, [r7, #284]	@ 0x11c
34001a18:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
34001a1c:	f503 7370 	add.w	r3, r3, #960	@ 0x3c0
34001a20:	885b      	ldrh	r3, [r3, #2]
34001a22:	f8a7 311e 	strh.w	r3, [r7, #286]	@ 0x11e
   int dataOff, i, j, n, diff, end0pos, x, y;
   int DU[64];

   // DCT rows
   for(dataOff=0, n=du_stride*8; dataOff<n; dataOff+=du_stride) {
34001a26:	2300      	movs	r3, #0
34001a28:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34001a2c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
34001a30:	00db      	lsls	r3, r3, #3
34001a32:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
34001a36:	e061      	b.n	34001afc <stbiw__jpg_processDU+0x134>
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7]);
34001a38:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001a3c:	009b      	lsls	r3, r3, #2
34001a3e:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001a42:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001a46:	6812      	ldr	r2, [r2, #0]
34001a48:	18d5      	adds	r5, r2, r3
34001a4a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001a4e:	3301      	adds	r3, #1
34001a50:	009b      	lsls	r3, r3, #2
34001a52:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001a56:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001a5a:	6812      	ldr	r2, [r2, #0]
34001a5c:	18d6      	adds	r6, r2, r3
34001a5e:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001a62:	3302      	adds	r3, #2
34001a64:	009b      	lsls	r3, r3, #2
34001a66:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001a6a:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001a6e:	6812      	ldr	r2, [r2, #0]
34001a70:	eb02 0c03 	add.w	ip, r2, r3
34001a74:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001a78:	3303      	adds	r3, #3
34001a7a:	009b      	lsls	r3, r3, #2
34001a7c:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001a80:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001a84:	6812      	ldr	r2, [r2, #0]
34001a86:	eb02 0e03 	add.w	lr, r2, r3
34001a8a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001a8e:	3304      	adds	r3, #4
34001a90:	009b      	lsls	r3, r3, #2
34001a92:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001a96:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001a9a:	6812      	ldr	r2, [r2, #0]
34001a9c:	4413      	add	r3, r2
34001a9e:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
34001aa2:	3205      	adds	r2, #5
34001aa4:	0092      	lsls	r2, r2, #2
34001aa6:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001aaa:	f5a1 71ac 	sub.w	r1, r1, #344	@ 0x158
34001aae:	6809      	ldr	r1, [r1, #0]
34001ab0:	440a      	add	r2, r1
34001ab2:	f8d7 1154 	ldr.w	r1, [r7, #340]	@ 0x154
34001ab6:	3106      	adds	r1, #6
34001ab8:	0089      	lsls	r1, r1, #2
34001aba:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001abe:	f5a0 70ac 	sub.w	r0, r0, #344	@ 0x158
34001ac2:	6800      	ldr	r0, [r0, #0]
34001ac4:	4401      	add	r1, r0
34001ac6:	f8d7 0154 	ldr.w	r0, [r7, #340]	@ 0x154
34001aca:	3007      	adds	r0, #7
34001acc:	0080      	lsls	r0, r0, #2
34001ace:	f507 74ac 	add.w	r4, r7, #344	@ 0x158
34001ad2:	f5a4 74ac 	sub.w	r4, r4, #344	@ 0x158
34001ad6:	6824      	ldr	r4, [r4, #0]
34001ad8:	4420      	add	r0, r4
34001ada:	9003      	str	r0, [sp, #12]
34001adc:	9102      	str	r1, [sp, #8]
34001ade:	9201      	str	r2, [sp, #4]
34001ae0:	9300      	str	r3, [sp, #0]
34001ae2:	4673      	mov	r3, lr
34001ae4:	4662      	mov	r2, ip
34001ae6:	4631      	mov	r1, r6
34001ae8:	4628      	mov	r0, r5
34001aea:	f7ff fded 	bl	340016c8 <stbiw__jpg_DCT>
   for(dataOff=0, n=du_stride*8; dataOff<n; dataOff+=du_stride) {
34001aee:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
34001af2:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
34001af6:	4413      	add	r3, r2
34001af8:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34001afc:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
34001b00:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
34001b04:	429a      	cmp	r2, r3
34001b06:	db97      	blt.n	34001a38 <stbiw__jpg_processDU+0x70>
   }
   // DCT columns
   for(dataOff=0; dataOff<8; ++dataOff) {
34001b08:	2300      	movs	r3, #0
34001b0a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34001b0e:	e07d      	b.n	34001c0c <stbiw__jpg_processDU+0x244>
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],
34001b10:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001b14:	009b      	lsls	r3, r3, #2
34001b16:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001b1a:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001b1e:	6812      	ldr	r2, [r2, #0]
34001b20:	18d5      	adds	r5, r2, r3
34001b22:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
34001b26:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
34001b2a:	4413      	add	r3, r2
34001b2c:	009b      	lsls	r3, r3, #2
34001b2e:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001b32:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001b36:	6812      	ldr	r2, [r2, #0]
34001b38:	18d6      	adds	r6, r2, r3
34001b3a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
34001b3e:	005a      	lsls	r2, r3, #1
34001b40:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001b44:	4413      	add	r3, r2
34001b46:	009b      	lsls	r3, r3, #2
34001b48:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001b4c:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001b50:	6812      	ldr	r2, [r2, #0]
34001b52:	eb02 0c03 	add.w	ip, r2, r3
34001b56:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
34001b5a:	4613      	mov	r3, r2
34001b5c:	005b      	lsls	r3, r3, #1
34001b5e:	441a      	add	r2, r3
34001b60:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001b64:	4413      	add	r3, r2
34001b66:	009b      	lsls	r3, r3, #2
34001b68:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001b6c:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001b70:	6812      	ldr	r2, [r2, #0]
34001b72:	eb02 0e03 	add.w	lr, r2, r3
34001b76:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
34001b7a:	009a      	lsls	r2, r3, #2
34001b7c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001b80:	4413      	add	r3, r2
34001b82:	009b      	lsls	r3, r3, #2
34001b84:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001b88:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001b8c:	6812      	ldr	r2, [r2, #0]
34001b8e:	18d1      	adds	r1, r2, r3
                     &CDU[dataOff+du_stride*5], &CDU[dataOff+du_stride*6], &CDU[dataOff+du_stride*7]);
34001b90:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
34001b94:	4613      	mov	r3, r2
34001b96:	009b      	lsls	r3, r3, #2
34001b98:	441a      	add	r2, r3
34001b9a:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001b9e:	4413      	add	r3, r2
34001ba0:	009b      	lsls	r3, r3, #2
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],
34001ba2:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001ba6:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001baa:	6812      	ldr	r2, [r2, #0]
34001bac:	18d0      	adds	r0, r2, r3
                     &CDU[dataOff+du_stride*5], &CDU[dataOff+du_stride*6], &CDU[dataOff+du_stride*7]);
34001bae:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
34001bb2:	4613      	mov	r3, r2
34001bb4:	005b      	lsls	r3, r3, #1
34001bb6:	4413      	add	r3, r2
34001bb8:	005b      	lsls	r3, r3, #1
34001bba:	461a      	mov	r2, r3
34001bbc:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001bc0:	4413      	add	r3, r2
34001bc2:	009b      	lsls	r3, r3, #2
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],
34001bc4:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001bc8:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001bcc:	6812      	ldr	r2, [r2, #0]
34001bce:	18d4      	adds	r4, r2, r3
                     &CDU[dataOff+du_stride*5], &CDU[dataOff+du_stride*6], &CDU[dataOff+du_stride*7]);
34001bd0:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
34001bd4:	4613      	mov	r3, r2
34001bd6:	00db      	lsls	r3, r3, #3
34001bd8:	1a9a      	subs	r2, r3, r2
34001bda:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001bde:	4413      	add	r3, r2
34001be0:	009b      	lsls	r3, r3, #2
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],
34001be2:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001be6:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001bea:	6812      	ldr	r2, [r2, #0]
34001bec:	4413      	add	r3, r2
34001bee:	9303      	str	r3, [sp, #12]
34001bf0:	9402      	str	r4, [sp, #8]
34001bf2:	9001      	str	r0, [sp, #4]
34001bf4:	9100      	str	r1, [sp, #0]
34001bf6:	4673      	mov	r3, lr
34001bf8:	4662      	mov	r2, ip
34001bfa:	4631      	mov	r1, r6
34001bfc:	4628      	mov	r0, r5
34001bfe:	f7ff fd63 	bl	340016c8 <stbiw__jpg_DCT>
   for(dataOff=0; dataOff<8; ++dataOff) {
34001c02:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001c06:	3301      	adds	r3, #1
34001c08:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34001c0c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
34001c10:	2b07      	cmp	r3, #7
34001c12:	f77f af7d 	ble.w	34001b10 <stbiw__jpg_processDU+0x148>
   }
   // Quantize/descale/zigzag the coefficients
   for(y = 0, j=0; y < 8; ++y) {
34001c16:	2300      	movs	r3, #0
34001c18:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34001c1c:	2300      	movs	r3, #0
34001c1e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34001c22:	e05e      	b.n	34001ce2 <stbiw__jpg_processDU+0x31a>
      for(x = 0; x < 8; ++x,++j) {
34001c24:	2300      	movs	r3, #0
34001c26:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34001c2a:	e051      	b.n	34001cd0 <stbiw__jpg_processDU+0x308>
         float v;
         i = y*du_stride+x;
34001c2c:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
34001c30:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
34001c34:	fb02 f303 	mul.w	r3, r2, r3
34001c38:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
34001c3c:	4413      	add	r3, r2
34001c3e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
         v = CDU[i]*fdtbl[j];
34001c42:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
34001c46:	009b      	lsls	r3, r3, #2
34001c48:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001c4c:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
34001c50:	6812      	ldr	r2, [r2, #0]
34001c52:	4413      	add	r3, r2
34001c54:	ed93 7a00 	vldr	s14, [r3]
34001c58:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
34001c5c:	009b      	lsls	r3, r3, #2
34001c5e:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
34001c62:	4413      	add	r3, r2
34001c64:	edd3 7a00 	vldr	s15, [r3]
34001c68:	ee67 7a27 	vmul.f32	s15, s14, s15
34001c6c:	edc7 7a49 	vstr	s15, [r7, #292]	@ 0x124
         // DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));
         // ceilf() and floorf() are C99, not C89, but I /think/ they're not needed here anyway?
         DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? v - 0.5f : v + 0.5f);
34001c70:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
34001c74:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34001c78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001c7c:	d508      	bpl.n	34001c90 <stbiw__jpg_processDU+0x2c8>
34001c7e:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
34001c82:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34001c86:	ee77 7ac7 	vsub.f32	s15, s15, s14
34001c8a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001c8e:	e007      	b.n	34001ca0 <stbiw__jpg_processDU+0x2d8>
34001c90:	edd7 7a49 	vldr	s15, [r7, #292]	@ 0x124
34001c94:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34001c98:	ee77 7a87 	vadd.f32	s15, s15, s14
34001c9c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001ca0:	4ab8      	ldr	r2, [pc, #736]	@ (34001f84 <stbiw__jpg_processDU+0x5bc>)
34001ca2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
34001ca6:	4413      	add	r3, r2
34001ca8:	781b      	ldrb	r3, [r3, #0]
34001caa:	461a      	mov	r2, r3
34001cac:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001cb0:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001cb4:	ee17 1a90 	vmov	r1, s15
34001cb8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      for(x = 0; x < 8; ++x,++j) {
34001cbc:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
34001cc0:	3301      	adds	r3, #1
34001cc2:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34001cc6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
34001cca:	3301      	adds	r3, #1
34001ccc:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34001cd0:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
34001cd4:	2b07      	cmp	r3, #7
34001cd6:	dda9      	ble.n	34001c2c <stbiw__jpg_processDU+0x264>
   for(y = 0, j=0; y < 8; ++y) {
34001cd8:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
34001cdc:	3301      	adds	r3, #1
34001cde:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34001ce2:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
34001ce6:	2b07      	cmp	r3, #7
34001ce8:	dd9c      	ble.n	34001c24 <stbiw__jpg_processDU+0x25c>
      }
   }

   // Encode DC
   diff = DU[0] - DC;
34001cea:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001cee:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001cf2:	681a      	ldr	r2, [r3, #0]
34001cf4:	f8d7 3178 	ldr.w	r3, [r7, #376]	@ 0x178
34001cf8:	1ad3      	subs	r3, r2, r3
34001cfa:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
   if (diff == 0) {
34001cfe:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
34001d02:	2b00      	cmp	r3, #0
34001d04:	d113      	bne.n	34001d2e <stbiw__jpg_processDU+0x366>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0]);
34001d06:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001d0a:	f5a3 72aa 	sub.w	r2, r3, #340	@ 0x154
34001d0e:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001d12:	f5a3 71a8 	sub.w	r1, r3, #336	@ 0x150
34001d16:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001d1a:	f5a3 70a6 	sub.w	r0, r3, #332	@ 0x14c
34001d1e:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
34001d22:	6812      	ldr	r2, [r2, #0]
34001d24:	6809      	ldr	r1, [r1, #0]
34001d26:	6800      	ldr	r0, [r0, #0]
34001d28:	f7ff fc8b 	bl	34001642 <stbiw__jpg_writeBits>
34001d2c:	e033      	b.n	34001d96 <stbiw__jpg_processDU+0x3ce>
   } else {
      unsigned short bits[2];
      stbiw__jpg_calcBits(diff, bits);
34001d2e:	f107 0318 	add.w	r3, r7, #24
34001d32:	4619      	mov	r1, r3
34001d34:	f8d7 0130 	ldr.w	r0, [r7, #304]	@ 0x130
34001d38:	f7ff fe0c 	bl	34001954 <stbiw__jpg_calcBits>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]]);
34001d3c:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001d40:	f5a3 73a0 	sub.w	r3, r3, #320	@ 0x140
34001d44:	885b      	ldrh	r3, [r3, #2]
34001d46:	009b      	lsls	r3, r3, #2
34001d48:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
34001d4c:	4413      	add	r3, r2
34001d4e:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001d52:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001d56:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001d5a:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001d5e:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001d62:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001d66:	6812      	ldr	r2, [r2, #0]
34001d68:	6809      	ldr	r1, [r1, #0]
34001d6a:	6800      	ldr	r0, [r0, #0]
34001d6c:	f7ff fc69 	bl	34001642 <stbiw__jpg_writeBits>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);
34001d70:	f107 0318 	add.w	r3, r7, #24
34001d74:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001d78:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001d7c:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001d80:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001d84:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001d88:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001d8c:	6812      	ldr	r2, [r2, #0]
34001d8e:	6809      	ldr	r1, [r1, #0]
34001d90:	6800      	ldr	r0, [r0, #0]
34001d92:	f7ff fc56 	bl	34001642 <stbiw__jpg_writeBits>
   }
   // Encode ACs
   end0pos = 63;
34001d96:	233f      	movs	r3, #63	@ 0x3f
34001d98:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
   for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos) {
34001d9c:	e004      	b.n	34001da8 <stbiw__jpg_processDU+0x3e0>
34001d9e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
34001da2:	3b01      	subs	r3, #1
34001da4:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34001da8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
34001dac:	2b00      	cmp	r3, #0
34001dae:	dd09      	ble.n	34001dc4 <stbiw__jpg_processDU+0x3fc>
34001db0:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001db4:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001db8:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
34001dbc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34001dc0:	2b00      	cmp	r3, #0
34001dc2:	d0ec      	beq.n	34001d9e <stbiw__jpg_processDU+0x3d6>
   }
   // end0pos = first element in reverse order !=0
   if(end0pos == 0) {
34001dc4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
34001dc8:	2b00      	cmp	r3, #0
34001dca:	d118      	bne.n	34001dfe <stbiw__jpg_processDU+0x436>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);
34001dcc:	f507 7390 	add.w	r3, r7, #288	@ 0x120
34001dd0:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001dd4:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001dd8:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001ddc:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001de0:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001de4:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001de8:	6812      	ldr	r2, [r2, #0]
34001dea:	6809      	ldr	r1, [r1, #0]
34001dec:	6800      	ldr	r0, [r0, #0]
34001dee:	f7ff fc28 	bl	34001642 <stbiw__jpg_writeBits>
      return DU[0];
34001df2:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001df6:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001dfa:	681b      	ldr	r3, [r3, #0]
34001dfc:	e0bc      	b.n	34001f78 <stbiw__jpg_processDU+0x5b0>
   }
   for(i = 1; i <= end0pos; ++i) {
34001dfe:	2301      	movs	r3, #1
34001e00:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34001e04:	e095      	b.n	34001f32 <stbiw__jpg_processDU+0x56a>
      int startpos = i;
34001e06:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
34001e0a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
      int nrzeroes;
      unsigned short bits[2];
      for (; DU[i]==0 && i<=end0pos; ++i) {
34001e0e:	e004      	b.n	34001e1a <stbiw__jpg_processDU+0x452>
34001e10:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
34001e14:	3301      	adds	r3, #1
34001e16:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34001e1a:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001e1e:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001e22:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
34001e26:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34001e2a:	2b00      	cmp	r3, #0
34001e2c:	d105      	bne.n	34001e3a <stbiw__jpg_processDU+0x472>
34001e2e:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
34001e32:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
34001e36:	429a      	cmp	r2, r3
34001e38:	ddea      	ble.n	34001e10 <stbiw__jpg_processDU+0x448>
      }
      nrzeroes = i-startpos;
34001e3a:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
34001e3e:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
34001e42:	1ad3      	subs	r3, r2, r3
34001e44:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
      if ( nrzeroes >= 16 ) {
34001e48:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
34001e4c:	2b0f      	cmp	r3, #15
34001e4e:	dd2c      	ble.n	34001eaa <stbiw__jpg_processDU+0x4e2>
         int lng = nrzeroes>>4;
34001e50:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
34001e54:	111b      	asrs	r3, r3, #4
34001e56:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
         int nrmarker;
         for (nrmarker=1; nrmarker <= lng; ++nrmarker)
34001e5a:	2301      	movs	r3, #1
34001e5c:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34001e60:	e017      	b.n	34001e92 <stbiw__jpg_processDU+0x4ca>
            stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes);
34001e62:	f507 738e 	add.w	r3, r7, #284	@ 0x11c
34001e66:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001e6a:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001e6e:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001e72:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001e76:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001e7a:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001e7e:	6812      	ldr	r2, [r2, #0]
34001e80:	6809      	ldr	r1, [r1, #0]
34001e82:	6800      	ldr	r0, [r0, #0]
34001e84:	f7ff fbdd 	bl	34001642 <stbiw__jpg_writeBits>
         for (nrmarker=1; nrmarker <= lng; ++nrmarker)
34001e88:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
34001e8c:	3301      	adds	r3, #1
34001e8e:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34001e92:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
34001e96:	f8d7 3128 	ldr.w	r3, [r7, #296]	@ 0x128
34001e9a:	429a      	cmp	r2, r3
34001e9c:	dde1      	ble.n	34001e62 <stbiw__jpg_processDU+0x49a>
         nrzeroes &= 15;
34001e9e:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
34001ea2:	f003 030f 	and.w	r3, r3, #15
34001ea6:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
      }
      stbiw__jpg_calcBits(DU[i], bits);
34001eaa:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001eae:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001eb2:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
34001eb6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34001eba:	f107 0214 	add.w	r2, r7, #20
34001ebe:	4611      	mov	r1, r2
34001ec0:	4618      	mov	r0, r3
34001ec2:	f7ff fd47 	bl	34001954 <stbiw__jpg_calcBits>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]]);
34001ec6:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
34001eca:	011b      	lsls	r3, r3, #4
34001ecc:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001ed0:	f5a2 72a2 	sub.w	r2, r2, #324	@ 0x144
34001ed4:	8852      	ldrh	r2, [r2, #2]
34001ed6:	4413      	add	r3, r2
34001ed8:	009b      	lsls	r3, r3, #2
34001eda:	f8d7 2180 	ldr.w	r2, [r7, #384]	@ 0x180
34001ede:	4413      	add	r3, r2
34001ee0:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001ee4:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001ee8:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001eec:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001ef0:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001ef4:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001ef8:	6812      	ldr	r2, [r2, #0]
34001efa:	6809      	ldr	r1, [r1, #0]
34001efc:	6800      	ldr	r0, [r0, #0]
34001efe:	f7ff fba0 	bl	34001642 <stbiw__jpg_writeBits>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);
34001f02:	f107 0314 	add.w	r3, r7, #20
34001f06:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001f0a:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001f0e:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001f12:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001f16:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001f1a:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001f1e:	6812      	ldr	r2, [r2, #0]
34001f20:	6809      	ldr	r1, [r1, #0]
34001f22:	6800      	ldr	r0, [r0, #0]
34001f24:	f7ff fb8d 	bl	34001642 <stbiw__jpg_writeBits>
   for(i = 1; i <= end0pos; ++i) {
34001f28:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
34001f2c:	3301      	adds	r3, #1
34001f2e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34001f32:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
34001f36:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
34001f3a:	429a      	cmp	r2, r3
34001f3c:	f77f af63 	ble.w	34001e06 <stbiw__jpg_processDU+0x43e>
   }
   if(end0pos != 63) {
34001f40:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
34001f44:	2b3f      	cmp	r3, #63	@ 0x3f
34001f46:	d012      	beq.n	34001f6e <stbiw__jpg_processDU+0x5a6>
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);
34001f48:	f507 7390 	add.w	r3, r7, #288	@ 0x120
34001f4c:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
34001f50:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
34001f54:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
34001f58:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
34001f5c:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
34001f60:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
34001f64:	6812      	ldr	r2, [r2, #0]
34001f66:	6809      	ldr	r1, [r1, #0]
34001f68:	6800      	ldr	r0, [r0, #0]
34001f6a:	f7ff fb6a 	bl	34001642 <stbiw__jpg_writeBits>
   }
   return DU[0];
34001f6e:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
34001f72:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
34001f76:	681b      	ldr	r3, [r3, #0]
}
34001f78:	4618      	mov	r0, r3
34001f7a:	f507 77ae 	add.w	r7, r7, #348	@ 0x15c
34001f7e:	46bd      	mov	sp, r7
34001f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
34001f82:	bf00      	nop
34001f84:	34030cd8 	.word	0x34030cd8

34001f88 <stbi_write_jpg_core>:

static int stbi_write_jpg_core(stbi__write_context *s, int width, int height, int comp, const void* data, int quality) {
34001f88:	b590      	push	{r4, r7, lr}
34001f8a:	f5ad 5d8a 	sub.w	sp, sp, #4416	@ 0x1140
34001f8e:	b085      	sub	sp, #20
34001f90:	af06      	add	r7, sp, #24
34001f92:	f507 749c 	add.w	r4, r7, #312	@ 0x138
34001f96:	f5a4 7496 	sub.w	r4, r4, #300	@ 0x12c
34001f9a:	6020      	str	r0, [r4, #0]
34001f9c:	f507 709c 	add.w	r0, r7, #312	@ 0x138
34001fa0:	f5a0 7098 	sub.w	r0, r0, #304	@ 0x130
34001fa4:	6001      	str	r1, [r0, #0]
34001fa6:	f507 719c 	add.w	r1, r7, #312	@ 0x138
34001faa:	f5a1 719a 	sub.w	r1, r1, #308	@ 0x134
34001fae:	600a      	str	r2, [r1, #0]
34001fb0:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34001fb4:	f5a2 729c 	sub.w	r2, r2, #312	@ 0x138
34001fb8:	6013      	str	r3, [r2, #0]

   int row, col, i, k, subsample;
   float fdtbl_Y[64], fdtbl_UV[64];
   unsigned char YTable[64], UVTable[64];

   if(!data || !width || !height || comp > 4 || comp < 1) {
34001fba:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
34001fbe:	f103 0308 	add.w	r3, r3, #8
34001fc2:	681b      	ldr	r3, [r3, #0]
34001fc4:	2b00      	cmp	r3, #0
34001fc6:	d01b      	beq.n	34002000 <stbi_write_jpg_core+0x78>
34001fc8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34001fcc:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34001fd0:	681b      	ldr	r3, [r3, #0]
34001fd2:	2b00      	cmp	r3, #0
34001fd4:	d014      	beq.n	34002000 <stbi_write_jpg_core+0x78>
34001fd6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34001fda:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34001fde:	681b      	ldr	r3, [r3, #0]
34001fe0:	2b00      	cmp	r3, #0
34001fe2:	d00d      	beq.n	34002000 <stbi_write_jpg_core+0x78>
34001fe4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34001fe8:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
34001fec:	681b      	ldr	r3, [r3, #0]
34001fee:	2b04      	cmp	r3, #4
34001ff0:	dc06      	bgt.n	34002000 <stbi_write_jpg_core+0x78>
34001ff2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34001ff6:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
34001ffa:	681b      	ldr	r3, [r3, #0]
34001ffc:	2b00      	cmp	r3, #0
34001ffe:	dc02      	bgt.n	34002006 <stbi_write_jpg_core+0x7e>
      return 0;
34002000:	2300      	movs	r3, #0
34002002:	f001 ba3b 	b.w	3400347c <stbi_write_jpg_core+0x14f4>
   }

   quality = quality ? quality : 90;
34002006:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
3400200a:	f103 030c 	add.w	r3, r3, #12
3400200e:	681b      	ldr	r3, [r3, #0]
34002010:	2b00      	cmp	r3, #0
34002012:	d005      	beq.n	34002020 <stbi_write_jpg_core+0x98>
34002014:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
34002018:	f103 030c 	add.w	r3, r3, #12
3400201c:	681b      	ldr	r3, [r3, #0]
3400201e:	e000      	b.n	34002022 <stbi_write_jpg_core+0x9a>
34002020:	235a      	movs	r3, #90	@ 0x5a
34002022:	f507 528a 	add.w	r2, r7, #4416	@ 0x1140
34002026:	f102 020c 	add.w	r2, r2, #12
3400202a:	6013      	str	r3, [r2, #0]
   subsample = quality <= 90 ? 1 : 0;
3400202c:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
34002030:	f103 030c 	add.w	r3, r3, #12
34002034:	681b      	ldr	r3, [r3, #0]
34002036:	2b5a      	cmp	r3, #90	@ 0x5a
34002038:	bfd4      	ite	le
3400203a:	2301      	movle	r3, #1
3400203c:	2300      	movgt	r3, #0
3400203e:	b2db      	uxtb	r3, r3
34002040:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002044:	f102 0204 	add.w	r2, r2, #4
34002048:	6013      	str	r3, [r2, #0]
   quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;
3400204a:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
3400204e:	f103 030c 	add.w	r3, r3, #12
34002052:	681b      	ldr	r3, [r3, #0]
34002054:	2b00      	cmp	r3, #0
34002056:	dd08      	ble.n	3400206a <stbi_write_jpg_core+0xe2>
34002058:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
3400205c:	f103 030c 	add.w	r3, r3, #12
34002060:	681b      	ldr	r3, [r3, #0]
34002062:	2b64      	cmp	r3, #100	@ 0x64
34002064:	bfa8      	it	ge
34002066:	2364      	movge	r3, #100	@ 0x64
34002068:	e000      	b.n	3400206c <stbi_write_jpg_core+0xe4>
3400206a:	2301      	movs	r3, #1
3400206c:	f507 528a 	add.w	r2, r7, #4416	@ 0x1140
34002070:	f102 020c 	add.w	r2, r2, #12
34002074:	6013      	str	r3, [r2, #0]
   quality = quality < 50 ? 5000 / quality : 200 - quality * 2;
34002076:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
3400207a:	f103 030c 	add.w	r3, r3, #12
3400207e:	681b      	ldr	r3, [r3, #0]
34002080:	2b31      	cmp	r3, #49	@ 0x31
34002082:	dc09      	bgt.n	34002098 <stbi_write_jpg_core+0x110>
34002084:	f241 3288 	movw	r2, #5000	@ 0x1388
34002088:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
3400208c:	f103 030c 	add.w	r3, r3, #12
34002090:	681b      	ldr	r3, [r3, #0]
34002092:	fb92 f3f3 	sdiv	r3, r2, r3
34002096:	e007      	b.n	340020a8 <stbi_write_jpg_core+0x120>
34002098:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
3400209c:	f103 030c 	add.w	r3, r3, #12
340020a0:	681b      	ldr	r3, [r3, #0]
340020a2:	f1c3 0364 	rsb	r3, r3, #100	@ 0x64
340020a6:	005b      	lsls	r3, r3, #1
340020a8:	f507 528a 	add.w	r2, r7, #4416	@ 0x1140
340020ac:	f102 020c 	add.w	r2, r2, #12
340020b0:	6013      	str	r3, [r2, #0]

   for(i = 0; i < 64; ++i) {
340020b2:	2300      	movs	r3, #0
340020b4:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340020b8:	f102 020c 	add.w	r2, r2, #12
340020bc:	6013      	str	r3, [r2, #0]
340020be:	e090      	b.n	340021e2 <stbi_write_jpg_core+0x25a>
      int uvti, yti = (YQT[i]*quality+50)/100;
340020c0:	4a56      	ldr	r2, [pc, #344]	@ (3400221c <stbi_write_jpg_core+0x294>)
340020c2:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340020c6:	f103 030c 	add.w	r3, r3, #12
340020ca:	681b      	ldr	r3, [r3, #0]
340020cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
340020d0:	f507 528a 	add.w	r2, r7, #4416	@ 0x1140
340020d4:	f102 020c 	add.w	r2, r2, #12
340020d8:	6812      	ldr	r2, [r2, #0]
340020da:	fb02 f303 	mul.w	r3, r2, r3
340020de:	3332      	adds	r3, #50	@ 0x32
340020e0:	4a4f      	ldr	r2, [pc, #316]	@ (34002220 <stbi_write_jpg_core+0x298>)
340020e2:	fb82 1203 	smull	r1, r2, r2, r3
340020e6:	1152      	asrs	r2, r2, #5
340020e8:	17db      	asrs	r3, r3, #31
340020ea:	1ad3      	subs	r3, r2, r3
340020ec:	f507 5285 	add.w	r2, r7, #4256	@ 0x10a0
340020f0:	f102 0218 	add.w	r2, r2, #24
340020f4:	6013      	str	r3, [r2, #0]
      YTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (yti < 1 ? 1 : yti > 255 ? 255 : yti);
340020f6:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
340020fa:	f103 0318 	add.w	r3, r3, #24
340020fe:	681b      	ldr	r3, [r3, #0]
34002100:	2b00      	cmp	r3, #0
34002102:	dd0f      	ble.n	34002124 <stbi_write_jpg_core+0x19c>
34002104:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
34002108:	f103 0318 	add.w	r3, r3, #24
3400210c:	681b      	ldr	r3, [r3, #0]
3400210e:	2bff      	cmp	r3, #255	@ 0xff
34002110:	dc06      	bgt.n	34002120 <stbi_write_jpg_core+0x198>
34002112:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
34002116:	f103 0318 	add.w	r3, r3, #24
3400211a:	681b      	ldr	r3, [r3, #0]
3400211c:	b2db      	uxtb	r3, r3
3400211e:	e002      	b.n	34002126 <stbi_write_jpg_core+0x19e>
34002120:	23ff      	movs	r3, #255	@ 0xff
34002122:	e000      	b.n	34002126 <stbi_write_jpg_core+0x19e>
34002124:	2301      	movs	r3, #1
34002126:	493f      	ldr	r1, [pc, #252]	@ (34002224 <stbi_write_jpg_core+0x29c>)
34002128:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400212c:	f102 020c 	add.w	r2, r2, #12
34002130:	6812      	ldr	r2, [r2, #0]
34002132:	440a      	add	r2, r1
34002134:	7812      	ldrb	r2, [r2, #0]
34002136:	4611      	mov	r1, r2
34002138:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400213c:	f102 0218 	add.w	r2, r2, #24
34002140:	f5a2 7231 	sub.w	r2, r2, #708	@ 0x2c4
34002144:	5453      	strb	r3, [r2, r1]
      uvti = (UVQT[i]*quality+50)/100;
34002146:	4a38      	ldr	r2, [pc, #224]	@ (34002228 <stbi_write_jpg_core+0x2a0>)
34002148:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400214c:	f103 030c 	add.w	r3, r3, #12
34002150:	681b      	ldr	r3, [r3, #0]
34002152:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34002156:	f507 528a 	add.w	r2, r7, #4416	@ 0x1140
3400215a:	f102 020c 	add.w	r2, r2, #12
3400215e:	6812      	ldr	r2, [r2, #0]
34002160:	fb02 f303 	mul.w	r3, r2, r3
34002164:	3332      	adds	r3, #50	@ 0x32
34002166:	4a2e      	ldr	r2, [pc, #184]	@ (34002220 <stbi_write_jpg_core+0x298>)
34002168:	fb82 1203 	smull	r1, r2, r2, r3
3400216c:	1152      	asrs	r2, r2, #5
3400216e:	17db      	asrs	r3, r3, #31
34002170:	1ad3      	subs	r3, r2, r3
34002172:	f507 5285 	add.w	r2, r7, #4256	@ 0x10a0
34002176:	f102 0214 	add.w	r2, r2, #20
3400217a:	6013      	str	r3, [r2, #0]
      UVTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (uvti < 1 ? 1 : uvti > 255 ? 255 : uvti);
3400217c:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
34002180:	f103 0314 	add.w	r3, r3, #20
34002184:	681b      	ldr	r3, [r3, #0]
34002186:	2b00      	cmp	r3, #0
34002188:	dd0f      	ble.n	340021aa <stbi_write_jpg_core+0x222>
3400218a:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
3400218e:	f103 0314 	add.w	r3, r3, #20
34002192:	681b      	ldr	r3, [r3, #0]
34002194:	2bff      	cmp	r3, #255	@ 0xff
34002196:	dc06      	bgt.n	340021a6 <stbi_write_jpg_core+0x21e>
34002198:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
3400219c:	f103 0314 	add.w	r3, r3, #20
340021a0:	681b      	ldr	r3, [r3, #0]
340021a2:	b2db      	uxtb	r3, r3
340021a4:	e002      	b.n	340021ac <stbi_write_jpg_core+0x224>
340021a6:	23ff      	movs	r3, #255	@ 0xff
340021a8:	e000      	b.n	340021ac <stbi_write_jpg_core+0x224>
340021aa:	2301      	movs	r3, #1
340021ac:	491d      	ldr	r1, [pc, #116]	@ (34002224 <stbi_write_jpg_core+0x29c>)
340021ae:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340021b2:	f102 020c 	add.w	r2, r2, #12
340021b6:	6812      	ldr	r2, [r2, #0]
340021b8:	440a      	add	r2, r1
340021ba:	7812      	ldrb	r2, [r2, #0]
340021bc:	4611      	mov	r1, r2
340021be:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340021c2:	f102 0218 	add.w	r2, r2, #24
340021c6:	f5a2 7241 	sub.w	r2, r2, #772	@ 0x304
340021ca:	5453      	strb	r3, [r2, r1]
   for(i = 0; i < 64; ++i) {
340021cc:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340021d0:	f103 030c 	add.w	r3, r3, #12
340021d4:	681b      	ldr	r3, [r3, #0]
340021d6:	3301      	adds	r3, #1
340021d8:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340021dc:	f102 020c 	add.w	r2, r2, #12
340021e0:	6013      	str	r3, [r2, #0]
340021e2:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340021e6:	f103 030c 	add.w	r3, r3, #12
340021ea:	681b      	ldr	r3, [r3, #0]
340021ec:	2b3f      	cmp	r3, #63	@ 0x3f
340021ee:	f77f af67 	ble.w	340020c0 <stbi_write_jpg_core+0x138>
   }

   for(row = 0, k = 0; row < 8; ++row) {
340021f2:	2300      	movs	r3, #0
340021f4:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340021f8:	f102 0214 	add.w	r2, r2, #20
340021fc:	6013      	str	r3, [r2, #0]
340021fe:	2300      	movs	r3, #0
34002200:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002204:	f102 0208 	add.w	r2, r2, #8
34002208:	6013      	str	r3, [r2, #0]
3400220a:	e0b6      	b.n	3400237a <stbi_write_jpg_core+0x3f2>
      for(col = 0; col < 8; ++col, ++k) {
3400220c:	2300      	movs	r3, #0
3400220e:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002212:	f102 0210 	add.w	r2, r2, #16
34002216:	6013      	str	r3, [r2, #0]
34002218:	e09c      	b.n	34002354 <stbi_write_jpg_core+0x3cc>
3400221a:	bf00      	nop
3400221c:	34030d18 	.word	0x34030d18
34002220:	51eb851f 	.word	0x51eb851f
34002224:	34030cd8 	.word	0x34030cd8
34002228:	34030e18 	.word	0x34030e18
         fdtbl_Y[k]  = 1 / (YTable [stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);
3400222c:	4a92      	ldr	r2, [pc, #584]	@ (34002478 <stbi_write_jpg_core+0x4f0>)
3400222e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002232:	f103 0308 	add.w	r3, r3, #8
34002236:	681b      	ldr	r3, [r3, #0]
34002238:	4413      	add	r3, r2
3400223a:	781b      	ldrb	r3, [r3, #0]
3400223c:	461a      	mov	r2, r3
3400223e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002242:	f103 0318 	add.w	r3, r3, #24
34002246:	f5a3 7331 	sub.w	r3, r3, #708	@ 0x2c4
3400224a:	5c9b      	ldrb	r3, [r3, r2]
3400224c:	ee07 3a90 	vmov	s15, r3
34002250:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
34002254:	4a89      	ldr	r2, [pc, #548]	@ (3400247c <stbi_write_jpg_core+0x4f4>)
34002256:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400225a:	f103 0314 	add.w	r3, r3, #20
3400225e:	681b      	ldr	r3, [r3, #0]
34002260:	009b      	lsls	r3, r3, #2
34002262:	4413      	add	r3, r2
34002264:	edd3 7a00 	vldr	s15, [r3]
34002268:	ee27 7a27 	vmul.f32	s14, s14, s15
3400226c:	4a83      	ldr	r2, [pc, #524]	@ (3400247c <stbi_write_jpg_core+0x4f4>)
3400226e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002272:	f103 0310 	add.w	r3, r3, #16
34002276:	681b      	ldr	r3, [r3, #0]
34002278:	009b      	lsls	r3, r3, #2
3400227a:	4413      	add	r3, r2
3400227c:	edd3 7a00 	vldr	s15, [r3]
34002280:	ee27 7a27 	vmul.f32	s14, s14, s15
34002284:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
34002288:	eec6 7a87 	vdiv.f32	s15, s13, s14
3400228c:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002290:	f103 0318 	add.w	r3, r3, #24
34002294:	f5a3 72c2 	sub.w	r2, r3, #388	@ 0x184
34002298:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400229c:	f103 0308 	add.w	r3, r3, #8
340022a0:	681b      	ldr	r3, [r3, #0]
340022a2:	009b      	lsls	r3, r3, #2
340022a4:	4413      	add	r3, r2
340022a6:	edc3 7a00 	vstr	s15, [r3]
         fdtbl_UV[k] = 1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);
340022aa:	4a73      	ldr	r2, [pc, #460]	@ (34002478 <stbi_write_jpg_core+0x4f0>)
340022ac:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340022b0:	f103 0308 	add.w	r3, r3, #8
340022b4:	681b      	ldr	r3, [r3, #0]
340022b6:	4413      	add	r3, r2
340022b8:	781b      	ldrb	r3, [r3, #0]
340022ba:	461a      	mov	r2, r3
340022bc:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340022c0:	f103 0318 	add.w	r3, r3, #24
340022c4:	f5a3 7341 	sub.w	r3, r3, #772	@ 0x304
340022c8:	5c9b      	ldrb	r3, [r3, r2]
340022ca:	ee07 3a90 	vmov	s15, r3
340022ce:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
340022d2:	4a6a      	ldr	r2, [pc, #424]	@ (3400247c <stbi_write_jpg_core+0x4f4>)
340022d4:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340022d8:	f103 0314 	add.w	r3, r3, #20
340022dc:	681b      	ldr	r3, [r3, #0]
340022de:	009b      	lsls	r3, r3, #2
340022e0:	4413      	add	r3, r2
340022e2:	edd3 7a00 	vldr	s15, [r3]
340022e6:	ee27 7a27 	vmul.f32	s14, s14, s15
340022ea:	4a64      	ldr	r2, [pc, #400]	@ (3400247c <stbi_write_jpg_core+0x4f4>)
340022ec:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340022f0:	f103 0310 	add.w	r3, r3, #16
340022f4:	681b      	ldr	r3, [r3, #0]
340022f6:	009b      	lsls	r3, r3, #2
340022f8:	4413      	add	r3, r2
340022fa:	edd3 7a00 	vldr	s15, [r3]
340022fe:	ee27 7a27 	vmul.f32	s14, s14, s15
34002302:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
34002306:	eec6 7a87 	vdiv.f32	s15, s13, s14
3400230a:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400230e:	f103 0318 	add.w	r3, r3, #24
34002312:	f5a3 7221 	sub.w	r2, r3, #644	@ 0x284
34002316:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400231a:	f103 0308 	add.w	r3, r3, #8
3400231e:	681b      	ldr	r3, [r3, #0]
34002320:	009b      	lsls	r3, r3, #2
34002322:	4413      	add	r3, r2
34002324:	edc3 7a00 	vstr	s15, [r3]
      for(col = 0; col < 8; ++col, ++k) {
34002328:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400232c:	f103 0310 	add.w	r3, r3, #16
34002330:	681b      	ldr	r3, [r3, #0]
34002332:	3301      	adds	r3, #1
34002334:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002338:	f102 0210 	add.w	r2, r2, #16
3400233c:	6013      	str	r3, [r2, #0]
3400233e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002342:	f103 0308 	add.w	r3, r3, #8
34002346:	681b      	ldr	r3, [r3, #0]
34002348:	3301      	adds	r3, #1
3400234a:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400234e:	f102 0208 	add.w	r2, r2, #8
34002352:	6013      	str	r3, [r2, #0]
34002354:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002358:	f103 0310 	add.w	r3, r3, #16
3400235c:	681b      	ldr	r3, [r3, #0]
3400235e:	2b07      	cmp	r3, #7
34002360:	f77f af64 	ble.w	3400222c <stbi_write_jpg_core+0x2a4>
   for(row = 0, k = 0; row < 8; ++row) {
34002364:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002368:	f103 0314 	add.w	r3, r3, #20
3400236c:	681b      	ldr	r3, [r3, #0]
3400236e:	3301      	adds	r3, #1
34002370:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002374:	f102 0214 	add.w	r2, r2, #20
34002378:	6013      	str	r3, [r2, #0]
3400237a:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400237e:	f103 0314 	add.w	r3, r3, #20
34002382:	681b      	ldr	r3, [r3, #0]
34002384:	2b07      	cmp	r3, #7
34002386:	f77f af41 	ble.w	3400220c <stbi_write_jpg_core+0x284>

   // Write Headers
   {
      static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };
      static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };
      const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width),
3400238a:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400238e:	f103 0318 	add.w	r3, r3, #24
34002392:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
34002396:	22ff      	movs	r2, #255	@ 0xff
34002398:	701a      	strb	r2, [r3, #0]
3400239a:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400239e:	f103 0318 	add.w	r3, r3, #24
340023a2:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340023a6:	22c0      	movs	r2, #192	@ 0xc0
340023a8:	705a      	strb	r2, [r3, #1]
340023aa:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340023ae:	f103 0318 	add.w	r3, r3, #24
340023b2:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340023b6:	2200      	movs	r2, #0
340023b8:	709a      	strb	r2, [r3, #2]
340023ba:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340023be:	f103 0318 	add.w	r3, r3, #24
340023c2:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340023c6:	2211      	movs	r2, #17
340023c8:	70da      	strb	r2, [r3, #3]
340023ca:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340023ce:	f103 0318 	add.w	r3, r3, #24
340023d2:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340023d6:	2208      	movs	r2, #8
340023d8:	711a      	strb	r2, [r3, #4]
340023da:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340023de:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
340023e2:	681b      	ldr	r3, [r3, #0]
340023e4:	121b      	asrs	r3, r3, #8
340023e6:	b2da      	uxtb	r2, r3
340023e8:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340023ec:	f103 0318 	add.w	r3, r3, #24
340023f0:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340023f4:	715a      	strb	r2, [r3, #5]
340023f6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340023fa:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
340023fe:	681b      	ldr	r3, [r3, #0]
34002400:	b2da      	uxtb	r2, r3
34002402:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002406:	f103 0318 	add.w	r3, r3, #24
3400240a:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400240e:	719a      	strb	r2, [r3, #6]
34002410:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002414:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34002418:	681b      	ldr	r3, [r3, #0]
3400241a:	121b      	asrs	r3, r3, #8
3400241c:	b2da      	uxtb	r2, r3
3400241e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002422:	f103 0318 	add.w	r3, r3, #24
34002426:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400242a:	71da      	strb	r2, [r3, #7]
3400242c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002430:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34002434:	681b      	ldr	r3, [r3, #0]
34002436:	b2da      	uxtb	r2, r3
34002438:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400243c:	f103 0318 	add.w	r3, r3, #24
34002440:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
34002444:	721a      	strb	r2, [r3, #8]
34002446:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400244a:	f103 0318 	add.w	r3, r3, #24
3400244e:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
34002452:	2203      	movs	r2, #3
34002454:	725a      	strb	r2, [r3, #9]
34002456:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400245a:	f103 0318 	add.w	r3, r3, #24
3400245e:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
34002462:	2201      	movs	r2, #1
34002464:	729a      	strb	r2, [r3, #10]
                                      3,1,(unsigned char)(subsample?0x22:0x11),0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };
34002466:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
3400246a:	f103 0304 	add.w	r3, r3, #4
3400246e:	681b      	ldr	r3, [r3, #0]
34002470:	2b00      	cmp	r3, #0
34002472:	d005      	beq.n	34002480 <stbi_write_jpg_core+0x4f8>
34002474:	2222      	movs	r2, #34	@ 0x22
34002476:	e004      	b.n	34002482 <stbi_write_jpg_core+0x4fa>
34002478:	34030cd8 	.word	0x34030cd8
3400247c:	34030f18 	.word	0x34030f18
34002480:	2211      	movs	r2, #17
      const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width),
34002482:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002486:	f103 0318 	add.w	r3, r3, #24
3400248a:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400248e:	72da      	strb	r2, [r3, #11]
34002490:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002494:	f103 0318 	add.w	r3, r3, #24
34002498:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400249c:	2200      	movs	r2, #0
3400249e:	731a      	strb	r2, [r3, #12]
340024a0:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340024a4:	f103 0318 	add.w	r3, r3, #24
340024a8:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340024ac:	2202      	movs	r2, #2
340024ae:	735a      	strb	r2, [r3, #13]
340024b0:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340024b4:	f103 0318 	add.w	r3, r3, #24
340024b8:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340024bc:	2211      	movs	r2, #17
340024be:	739a      	strb	r2, [r3, #14]
340024c0:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340024c4:	f103 0318 	add.w	r3, r3, #24
340024c8:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340024cc:	2201      	movs	r2, #1
340024ce:	73da      	strb	r2, [r3, #15]
340024d0:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340024d4:	f103 0318 	add.w	r3, r3, #24
340024d8:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340024dc:	2203      	movs	r2, #3
340024de:	741a      	strb	r2, [r3, #16]
340024e0:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340024e4:	f103 0318 	add.w	r3, r3, #24
340024e8:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340024ec:	2211      	movs	r2, #17
340024ee:	745a      	strb	r2, [r3, #17]
340024f0:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340024f4:	f103 0318 	add.w	r3, r3, #24
340024f8:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
340024fc:	2201      	movs	r2, #1
340024fe:	749a      	strb	r2, [r3, #18]
34002500:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002504:	f103 0318 	add.w	r3, r3, #24
34002508:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400250c:	22ff      	movs	r2, #255	@ 0xff
3400250e:	74da      	strb	r2, [r3, #19]
34002510:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002514:	f103 0318 	add.w	r3, r3, #24
34002518:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400251c:	22c4      	movs	r2, #196	@ 0xc4
3400251e:	751a      	strb	r2, [r3, #20]
34002520:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002524:	f103 0318 	add.w	r3, r3, #24
34002528:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400252c:	2201      	movs	r2, #1
3400252e:	755a      	strb	r2, [r3, #21]
34002530:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002534:	f103 0318 	add.w	r3, r3, #24
34002538:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400253c:	22a2      	movs	r2, #162	@ 0xa2
3400253e:	759a      	strb	r2, [r3, #22]
34002540:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002544:	f103 0318 	add.w	r3, r3, #24
34002548:	f5a3 7347 	sub.w	r3, r3, #796	@ 0x31c
3400254c:	2200      	movs	r2, #0
3400254e:	75da      	strb	r2, [r3, #23]
      s->func(s->context, (void*)head0, sizeof(head0));
34002550:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002554:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002558:	681b      	ldr	r3, [r3, #0]
3400255a:	681b      	ldr	r3, [r3, #0]
3400255c:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002560:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
34002564:	6812      	ldr	r2, [r2, #0]
34002566:	6850      	ldr	r0, [r2, #4]
34002568:	2219      	movs	r2, #25
3400256a:	49bb      	ldr	r1, [pc, #748]	@ (34002858 <stbi_write_jpg_core+0x8d0>)
3400256c:	4798      	blx	r3
      s->func(s->context, (void*)YTable, sizeof(YTable));
3400256e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002572:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002576:	681b      	ldr	r3, [r3, #0]
34002578:	681b      	ldr	r3, [r3, #0]
3400257a:	f507 729c 	add.w	r2, r7, #312	@ 0x138
3400257e:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
34002582:	6812      	ldr	r2, [r2, #0]
34002584:	6850      	ldr	r0, [r2, #4]
34002586:	f607 6174 	addw	r1, r7, #3700	@ 0xe74
3400258a:	2240      	movs	r2, #64	@ 0x40
3400258c:	4798      	blx	r3
      stbiw__putc(s, 1);
3400258e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002592:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002596:	2101      	movs	r1, #1
34002598:	6818      	ldr	r0, [r3, #0]
3400259a:	f7ff f841 	bl	34001620 <stbiw__putc>
      s->func(s->context, UVTable, sizeof(UVTable));
3400259e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340025a2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
340025a6:	681b      	ldr	r3, [r3, #0]
340025a8:	681b      	ldr	r3, [r3, #0]
340025aa:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340025ae:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
340025b2:	6812      	ldr	r2, [r2, #0]
340025b4:	6850      	ldr	r0, [r2, #4]
340025b6:	f607 6134 	addw	r1, r7, #3636	@ 0xe34
340025ba:	2240      	movs	r2, #64	@ 0x40
340025bc:	4798      	blx	r3
      s->func(s->context, (void*)head1, sizeof(head1));
340025be:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340025c2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
340025c6:	681b      	ldr	r3, [r3, #0]
340025c8:	681b      	ldr	r3, [r3, #0]
340025ca:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340025ce:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
340025d2:	6812      	ldr	r2, [r2, #0]
340025d4:	6850      	ldr	r0, [r2, #4]
340025d6:	f607 611c 	addw	r1, r7, #3612	@ 0xe1c
340025da:	2218      	movs	r2, #24
340025dc:	4798      	blx	r3
      s->func(s->context, (void*)(std_dc_luminance_nrcodes+1), sizeof(std_dc_luminance_nrcodes)-1);
340025de:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340025e2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
340025e6:	681b      	ldr	r3, [r3, #0]
340025e8:	681b      	ldr	r3, [r3, #0]
340025ea:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340025ee:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
340025f2:	6812      	ldr	r2, [r2, #0]
340025f4:	6850      	ldr	r0, [r2, #4]
340025f6:	4999      	ldr	r1, [pc, #612]	@ (3400285c <stbi_write_jpg_core+0x8d4>)
340025f8:	2210      	movs	r2, #16
340025fa:	4798      	blx	r3
      s->func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values));
340025fc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002600:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002604:	681b      	ldr	r3, [r3, #0]
34002606:	681b      	ldr	r3, [r3, #0]
34002608:	f507 729c 	add.w	r2, r7, #312	@ 0x138
3400260c:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
34002610:	6812      	ldr	r2, [r2, #0]
34002612:	6850      	ldr	r0, [r2, #4]
34002614:	220c      	movs	r2, #12
34002616:	4992      	ldr	r1, [pc, #584]	@ (34002860 <stbi_write_jpg_core+0x8d8>)
34002618:	4798      	blx	r3
      stbiw__putc(s, 0x10); // HTYACinfo
3400261a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400261e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002622:	2110      	movs	r1, #16
34002624:	6818      	ldr	r0, [r3, #0]
34002626:	f7fe fffb 	bl	34001620 <stbiw__putc>
      s->func(s->context, (void*)(std_ac_luminance_nrcodes+1), sizeof(std_ac_luminance_nrcodes)-1);
3400262a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400262e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002632:	681b      	ldr	r3, [r3, #0]
34002634:	681b      	ldr	r3, [r3, #0]
34002636:	f507 729c 	add.w	r2, r7, #312	@ 0x138
3400263a:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
3400263e:	6812      	ldr	r2, [r2, #0]
34002640:	6850      	ldr	r0, [r2, #4]
34002642:	4988      	ldr	r1, [pc, #544]	@ (34002864 <stbi_write_jpg_core+0x8dc>)
34002644:	2210      	movs	r2, #16
34002646:	4798      	blx	r3
      s->func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values));
34002648:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400264c:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002650:	681b      	ldr	r3, [r3, #0]
34002652:	681b      	ldr	r3, [r3, #0]
34002654:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002658:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
3400265c:	6812      	ldr	r2, [r2, #0]
3400265e:	6850      	ldr	r0, [r2, #4]
34002660:	22a2      	movs	r2, #162	@ 0xa2
34002662:	4981      	ldr	r1, [pc, #516]	@ (34002868 <stbi_write_jpg_core+0x8e0>)
34002664:	4798      	blx	r3
      stbiw__putc(s, 1); // HTUDCinfo
34002666:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400266a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
3400266e:	2101      	movs	r1, #1
34002670:	6818      	ldr	r0, [r3, #0]
34002672:	f7fe ffd5 	bl	34001620 <stbiw__putc>
      s->func(s->context, (void*)(std_dc_chrominance_nrcodes+1), sizeof(std_dc_chrominance_nrcodes)-1);
34002676:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400267a:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
3400267e:	681b      	ldr	r3, [r3, #0]
34002680:	681b      	ldr	r3, [r3, #0]
34002682:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002686:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
3400268a:	6812      	ldr	r2, [r2, #0]
3400268c:	6850      	ldr	r0, [r2, #4]
3400268e:	4977      	ldr	r1, [pc, #476]	@ (3400286c <stbi_write_jpg_core+0x8e4>)
34002690:	2210      	movs	r2, #16
34002692:	4798      	blx	r3
      s->func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values));
34002694:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002698:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
3400269c:	681b      	ldr	r3, [r3, #0]
3400269e:	681b      	ldr	r3, [r3, #0]
340026a0:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340026a4:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
340026a8:	6812      	ldr	r2, [r2, #0]
340026aa:	6850      	ldr	r0, [r2, #4]
340026ac:	220c      	movs	r2, #12
340026ae:	4970      	ldr	r1, [pc, #448]	@ (34002870 <stbi_write_jpg_core+0x8e8>)
340026b0:	4798      	blx	r3
      stbiw__putc(s, 0x11); // HTUACinfo
340026b2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340026b6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
340026ba:	2111      	movs	r1, #17
340026bc:	6818      	ldr	r0, [r3, #0]
340026be:	f7fe ffaf 	bl	34001620 <stbiw__putc>
      s->func(s->context, (void*)(std_ac_chrominance_nrcodes+1), sizeof(std_ac_chrominance_nrcodes)-1);
340026c2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340026c6:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
340026ca:	681b      	ldr	r3, [r3, #0]
340026cc:	681b      	ldr	r3, [r3, #0]
340026ce:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340026d2:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
340026d6:	6812      	ldr	r2, [r2, #0]
340026d8:	6850      	ldr	r0, [r2, #4]
340026da:	4966      	ldr	r1, [pc, #408]	@ (34002874 <stbi_write_jpg_core+0x8ec>)
340026dc:	2210      	movs	r2, #16
340026de:	4798      	blx	r3
      s->func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values));
340026e0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340026e4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
340026e8:	681b      	ldr	r3, [r3, #0]
340026ea:	681b      	ldr	r3, [r3, #0]
340026ec:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340026f0:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
340026f4:	6812      	ldr	r2, [r2, #0]
340026f6:	6850      	ldr	r0, [r2, #4]
340026f8:	22a2      	movs	r2, #162	@ 0xa2
340026fa:	495f      	ldr	r1, [pc, #380]	@ (34002878 <stbi_write_jpg_core+0x8f0>)
340026fc:	4798      	blx	r3
      s->func(s->context, (void*)head2, sizeof(head2));
340026fe:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002702:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34002706:	681b      	ldr	r3, [r3, #0]
34002708:	681b      	ldr	r3, [r3, #0]
3400270a:	f507 729c 	add.w	r2, r7, #312	@ 0x138
3400270e:	f5a2 7296 	sub.w	r2, r2, #300	@ 0x12c
34002712:	6812      	ldr	r2, [r2, #0]
34002714:	6850      	ldr	r0, [r2, #4]
34002716:	220e      	movs	r2, #14
34002718:	4958      	ldr	r1, [pc, #352]	@ (3400287c <stbi_write_jpg_core+0x8f4>)
3400271a:	4798      	blx	r3
   }

   // Encode 8x8 macroblocks
   {
      static const unsigned short fillBits[] = {0x7F, 7};
      int DCY=0, DCU=0, DCV=0;
3400271c:	2300      	movs	r3, #0
3400271e:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002722:	f102 0204 	add.w	r2, r2, #4
34002726:	6013      	str	r3, [r2, #0]
34002728:	2300      	movs	r3, #0
3400272a:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400272e:	6013      	str	r3, [r2, #0]
34002730:	2300      	movs	r3, #0
34002732:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002736:	f102 021c 	add.w	r2, r2, #28
3400273a:	6013      	str	r3, [r2, #0]
      int bitBuf=0, bitCnt=0;
3400273c:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002740:	f103 0318 	add.w	r3, r3, #24
34002744:	f5a3 7348 	sub.w	r3, r3, #800	@ 0x320
34002748:	2200      	movs	r2, #0
3400274a:	601a      	str	r2, [r3, #0]
3400274c:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002750:	f103 0318 	add.w	r3, r3, #24
34002754:	f5a3 7349 	sub.w	r3, r3, #804	@ 0x324
34002758:	2200      	movs	r2, #0
3400275a:	601a      	str	r2, [r3, #0]
      // comp == 2 is grey+alpha (alpha is ignored)
      int ofsG = comp > 2 ? 1 : 0, ofsB = comp > 2 ? 2 : 0;
3400275c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002760:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
34002764:	681b      	ldr	r3, [r3, #0]
34002766:	2b02      	cmp	r3, #2
34002768:	bfcc      	ite	gt
3400276a:	2301      	movgt	r3, #1
3400276c:	2300      	movle	r3, #0
3400276e:	b2db      	uxtb	r3, r3
34002770:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002774:	6013      	str	r3, [r2, #0]
34002776:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400277a:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
3400277e:	681b      	ldr	r3, [r3, #0]
34002780:	2b02      	cmp	r3, #2
34002782:	dd01      	ble.n	34002788 <stbi_write_jpg_core+0x800>
34002784:	2302      	movs	r3, #2
34002786:	e000      	b.n	3400278a <stbi_write_jpg_core+0x802>
34002788:	2300      	movs	r3, #0
3400278a:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
3400278e:	f102 021c 	add.w	r2, r2, #28
34002792:	6013      	str	r3, [r2, #0]
      const unsigned char *dataR = (const unsigned char *)data;
34002794:	f507 538a 	add.w	r3, r7, #4416	@ 0x1140
34002798:	f103 0308 	add.w	r3, r3, #8
3400279c:	681b      	ldr	r3, [r3, #0]
3400279e:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340027a2:	f102 0218 	add.w	r2, r2, #24
340027a6:	6013      	str	r3, [r2, #0]
      const unsigned char *dataG = dataR + ofsG;
340027a8:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340027ac:	681b      	ldr	r3, [r3, #0]
340027ae:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340027b2:	f102 0218 	add.w	r2, r2, #24
340027b6:	6812      	ldr	r2, [r2, #0]
340027b8:	4413      	add	r3, r2
340027ba:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340027be:	f102 0214 	add.w	r2, r2, #20
340027c2:	6013      	str	r3, [r2, #0]
      const unsigned char *dataB = dataR + ofsB;
340027c4:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
340027c8:	f103 031c 	add.w	r3, r3, #28
340027cc:	681b      	ldr	r3, [r3, #0]
340027ce:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340027d2:	f102 0218 	add.w	r2, r2, #24
340027d6:	6812      	ldr	r2, [r2, #0]
340027d8:	4413      	add	r3, r2
340027da:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340027de:	f102 0210 	add.w	r2, r2, #16
340027e2:	6013      	str	r3, [r2, #0]
      int x, y, pos;
      if(subsample) {
340027e4:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340027e8:	f103 0304 	add.w	r3, r3, #4
340027ec:	681b      	ldr	r3, [r3, #0]
340027ee:	2b00      	cmp	r3, #0
340027f0:	f000 83d6 	beq.w	34002fa0 <stbi_write_jpg_core+0x1018>
         for(y = 0; y < height; y += 16) {
340027f4:	2300      	movs	r3, #0
340027f6:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
340027fa:	f102 0214 	add.w	r2, r2, #20
340027fe:	6013      	str	r3, [r2, #0]
34002800:	e3c0      	b.n	34002f84 <stbi_write_jpg_core+0xffc>
            for(x = 0; x < width; x += 16) {
34002802:	2300      	movs	r3, #0
34002804:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002808:	f102 0218 	add.w	r2, r2, #24
3400280c:	6013      	str	r3, [r2, #0]
3400280e:	e3a1      	b.n	34002f54 <stbi_write_jpg_core+0xfcc>
               float Y[256], U[256], V[256];
               for(row = y, pos = 0; row < y+16; ++row) {
34002810:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002814:	f103 0314 	add.w	r3, r3, #20
34002818:	681b      	ldr	r3, [r3, #0]
3400281a:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400281e:	f102 0214 	add.w	r2, r2, #20
34002822:	6013      	str	r3, [r2, #0]
34002824:	2300      	movs	r3, #0
34002826:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
3400282a:	f102 0210 	add.w	r2, r2, #16
3400282e:	6013      	str	r3, [r2, #0]
34002830:	e1a1      	b.n	34002b76 <stbi_write_jpg_core+0xbee>
                  // row >= height => use last input row
                  int clamped_row = (row < height) ? row : height - 1;
34002832:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002836:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
3400283a:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400283e:	f102 0214 	add.w	r2, r2, #20
34002842:	6812      	ldr	r2, [r2, #0]
34002844:	681b      	ldr	r3, [r3, #0]
34002846:	429a      	cmp	r2, r3
34002848:	db1a      	blt.n	34002880 <stbi_write_jpg_core+0x8f8>
3400284a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400284e:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34002852:	681b      	ldr	r3, [r3, #0]
34002854:	3b01      	subs	r3, #1
34002856:	e018      	b.n	3400288a <stbi_write_jpg_core+0x902>
34002858:	34030f38 	.word	0x34030f38
3400285c:	34030f55 	.word	0x34030f55
34002860:	34030f68 	.word	0x34030f68
34002864:	34030f75 	.word	0x34030f75
34002868:	34030f88 	.word	0x34030f88
3400286c:	3403102d 	.word	0x3403102d
34002870:	34031040 	.word	0x34031040
34002874:	3403104d 	.word	0x3403104d
34002878:	34031060 	.word	0x34031060
3400287c:	34031104 	.word	0x34031104
34002880:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002884:	f103 0314 	add.w	r3, r3, #20
34002888:	681b      	ldr	r3, [r3, #0]
3400288a:	f507 5286 	add.w	r2, r7, #4288	@ 0x10c0
3400288e:	f102 0210 	add.w	r2, r2, #16
34002892:	6013      	str	r3, [r2, #0]
                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;
34002894:	4b23      	ldr	r3, [pc, #140]	@ (34002924 <stbi_write_jpg_core+0x99c>)
34002896:	681b      	ldr	r3, [r3, #0]
34002898:	2b00      	cmp	r3, #0
3400289a:	d00c      	beq.n	340028b6 <stbi_write_jpg_core+0x92e>
3400289c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340028a0:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
340028a4:	681b      	ldr	r3, [r3, #0]
340028a6:	1e5a      	subs	r2, r3, #1
340028a8:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340028ac:	f103 0310 	add.w	r3, r3, #16
340028b0:	681b      	ldr	r3, [r3, #0]
340028b2:	1ad3      	subs	r3, r2, r3
340028b4:	e004      	b.n	340028c0 <stbi_write_jpg_core+0x938>
340028b6:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340028ba:	f103 0310 	add.w	r3, r3, #16
340028be:	681b      	ldr	r3, [r3, #0]
340028c0:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340028c4:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
340028c8:	6812      	ldr	r2, [r2, #0]
340028ca:	fb03 f202 	mul.w	r2, r3, r2
340028ce:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340028d2:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
340028d6:	681b      	ldr	r3, [r3, #0]
340028d8:	fb02 f303 	mul.w	r3, r2, r3
340028dc:	f507 5286 	add.w	r2, r7, #4288	@ 0x10c0
340028e0:	f102 020c 	add.w	r2, r2, #12
340028e4:	6013      	str	r3, [r2, #0]
                  for(col = x; col < x+16; ++col, ++pos) {
340028e6:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340028ea:	f103 0318 	add.w	r3, r3, #24
340028ee:	681b      	ldr	r3, [r3, #0]
340028f0:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340028f4:	f102 0210 	add.w	r2, r2, #16
340028f8:	6013      	str	r3, [r2, #0]
340028fa:	e123      	b.n	34002b44 <stbi_write_jpg_core+0xbbc>
                     // if col >= width => use pixel from last input column
                     int p = base_p + ((col < width) ? col : (width-1))*comp;
340028fc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002900:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34002904:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002908:	f102 0210 	add.w	r2, r2, #16
3400290c:	6812      	ldr	r2, [r2, #0]
3400290e:	681b      	ldr	r3, [r3, #0]
34002910:	429a      	cmp	r2, r3
34002912:	db19      	blt.n	34002948 <stbi_write_jpg_core+0x9c0>
34002914:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002918:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
3400291c:	681b      	ldr	r3, [r3, #0]
3400291e:	3b01      	subs	r3, #1
34002920:	e017      	b.n	34002952 <stbi_write_jpg_core+0x9ca>
34002922:	bf00      	nop
34002924:	3403419c 	.word	0x3403419c
34002928:	3e991687 	.word	0x3e991687
3400292c:	3f1645a2 	.word	0x3f1645a2
34002930:	3de978d5 	.word	0x3de978d5
34002934:	43000000 	.word	0x43000000
34002938:	be2cca2e 	.word	0xbe2cca2e
3400293c:	3ea99ae9 	.word	0x3ea99ae9
34002940:	3ed65e89 	.word	0x3ed65e89
34002944:	3da685db 	.word	0x3da685db
34002948:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400294c:	f103 0310 	add.w	r3, r3, #16
34002950:	681b      	ldr	r3, [r3, #0]
34002952:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002956:	f5a2 729c 	sub.w	r2, r2, #312	@ 0x138
3400295a:	6812      	ldr	r2, [r2, #0]
3400295c:	fb02 f303 	mul.w	r3, r2, r3
34002960:	f507 5286 	add.w	r2, r7, #4288	@ 0x10c0
34002964:	f102 020c 	add.w	r2, r2, #12
34002968:	6812      	ldr	r2, [r2, #0]
3400296a:	4413      	add	r3, r2
3400296c:	f507 5286 	add.w	r2, r7, #4288	@ 0x10c0
34002970:	f102 0208 	add.w	r2, r2, #8
34002974:	6013      	str	r3, [r2, #0]
                     float r = dataR[p], g = dataG[p], b = dataB[p];
34002976:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
3400297a:	f103 0308 	add.w	r3, r3, #8
3400297e:	681b      	ldr	r3, [r3, #0]
34002980:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
34002984:	f102 0218 	add.w	r2, r2, #24
34002988:	6812      	ldr	r2, [r2, #0]
3400298a:	4413      	add	r3, r2
3400298c:	781b      	ldrb	r3, [r3, #0]
3400298e:	ee07 3a90 	vmov	s15, r3
34002992:	eef8 7a67 	vcvt.f32.u32	s15, s15
34002996:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
3400299a:	f103 0304 	add.w	r3, r3, #4
3400299e:	edc3 7a00 	vstr	s15, [r3]
340029a2:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340029a6:	f103 0308 	add.w	r3, r3, #8
340029aa:	681b      	ldr	r3, [r3, #0]
340029ac:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340029b0:	f102 0214 	add.w	r2, r2, #20
340029b4:	6812      	ldr	r2, [r2, #0]
340029b6:	4413      	add	r3, r2
340029b8:	781b      	ldrb	r3, [r3, #0]
340029ba:	ee07 3a90 	vmov	s15, r3
340029be:	eef8 7a67 	vcvt.f32.u32	s15, s15
340029c2:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340029c6:	edc3 7a00 	vstr	s15, [r3]
340029ca:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340029ce:	f103 0308 	add.w	r3, r3, #8
340029d2:	681b      	ldr	r3, [r3, #0]
340029d4:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340029d8:	f102 0210 	add.w	r2, r2, #16
340029dc:	6812      	ldr	r2, [r2, #0]
340029de:	4413      	add	r3, r2
340029e0:	781b      	ldrb	r3, [r3, #0]
340029e2:	ee07 3a90 	vmov	s15, r3
340029e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
340029ea:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
340029ee:	f103 031c 	add.w	r3, r3, #28
340029f2:	edc3 7a00 	vstr	s15, [r3]
                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;
340029f6:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340029fa:	f103 0304 	add.w	r3, r3, #4
340029fe:	edd3 7a00 	vldr	s15, [r3]
34002a02:	ed1f 7a37 	vldr	s14, [pc, #-220]	@ 34002928 <stbi_write_jpg_core+0x9a0>
34002a06:	ee27 7a87 	vmul.f32	s14, s15, s14
34002a0a:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002a0e:	edd3 7a00 	vldr	s15, [r3]
34002a12:	ed5f 6a3a 	vldr	s13, [pc, #-232]	@ 3400292c <stbi_write_jpg_core+0x9a4>
34002a16:	ee67 7aa6 	vmul.f32	s15, s15, s13
34002a1a:	ee37 7a27 	vadd.f32	s14, s14, s15
34002a1e:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
34002a22:	f103 031c 	add.w	r3, r3, #28
34002a26:	edd3 7a00 	vldr	s15, [r3]
34002a2a:	ed5f 6a3f 	vldr	s13, [pc, #-252]	@ 34002930 <stbi_write_jpg_core+0x9a8>
34002a2e:	ee67 7aa6 	vmul.f32	s15, s15, s13
34002a32:	ee77 7a27 	vadd.f32	s15, s14, s15
34002a36:	ed1f 7a41 	vldr	s14, [pc, #-260]	@ 34002934 <stbi_write_jpg_core+0x9ac>
34002a3a:	ee77 7ac7 	vsub.f32	s15, s15, s14
34002a3e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002a42:	f103 0318 	add.w	r3, r3, #24
34002a46:	f6a3 7224 	subw	r2, r3, #3876	@ 0xf24
34002a4a:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002a4e:	f103 0310 	add.w	r3, r3, #16
34002a52:	681b      	ldr	r3, [r3, #0]
34002a54:	009b      	lsls	r3, r3, #2
34002a56:	4413      	add	r3, r2
34002a58:	edc3 7a00 	vstr	s15, [r3]
                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;
34002a5c:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002a60:	f103 0304 	add.w	r3, r3, #4
34002a64:	edd3 7a00 	vldr	s15, [r3]
34002a68:	ed1f 7a4d 	vldr	s14, [pc, #-308]	@ 34002938 <stbi_write_jpg_core+0x9b0>
34002a6c:	ee27 7a87 	vmul.f32	s14, s15, s14
34002a70:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002a74:	edd3 7a00 	vldr	s15, [r3]
34002a78:	ed5f 6a50 	vldr	s13, [pc, #-320]	@ 3400293c <stbi_write_jpg_core+0x9b4>
34002a7c:	ee67 7aa6 	vmul.f32	s15, s15, s13
34002a80:	ee37 7a67 	vsub.f32	s14, s14, s15
34002a84:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
34002a88:	f103 031c 	add.w	r3, r3, #28
34002a8c:	edd3 7a00 	vldr	s15, [r3]
34002a90:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
34002a94:	ee67 7aa6 	vmul.f32	s15, s15, s13
34002a98:	ee77 7a27 	vadd.f32	s15, s14, s15
34002a9c:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002aa0:	f103 0318 	add.w	r3, r3, #24
34002aa4:	f6a3 3224 	subw	r2, r3, #2852	@ 0xb24
34002aa8:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002aac:	f103 0310 	add.w	r3, r3, #16
34002ab0:	681b      	ldr	r3, [r3, #0]
34002ab2:	009b      	lsls	r3, r3, #2
34002ab4:	4413      	add	r3, r2
34002ab6:	edc3 7a00 	vstr	s15, [r3]
                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;
34002aba:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002abe:	f103 0304 	add.w	r3, r3, #4
34002ac2:	edd3 7a00 	vldr	s15, [r3]
34002ac6:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34002aca:	ee27 7a87 	vmul.f32	s14, s15, s14
34002ace:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002ad2:	edd3 7a00 	vldr	s15, [r3]
34002ad6:	ed5f 6a66 	vldr	s13, [pc, #-408]	@ 34002940 <stbi_write_jpg_core+0x9b8>
34002ada:	ee67 7aa6 	vmul.f32	s15, s15, s13
34002ade:	ee37 7a67 	vsub.f32	s14, s14, s15
34002ae2:	f507 5385 	add.w	r3, r7, #4256	@ 0x10a0
34002ae6:	f103 031c 	add.w	r3, r3, #28
34002aea:	edd3 7a00 	vldr	s15, [r3]
34002aee:	ed5f 6a6b 	vldr	s13, [pc, #-428]	@ 34002944 <stbi_write_jpg_core+0x9bc>
34002af2:	ee67 7aa6 	vmul.f32	s15, s15, s13
34002af6:	ee77 7a67 	vsub.f32	s15, s14, s15
34002afa:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002afe:	f103 0318 	add.w	r3, r3, #24
34002b02:	f2a3 7224 	subw	r2, r3, #1828	@ 0x724
34002b06:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002b0a:	f103 0310 	add.w	r3, r3, #16
34002b0e:	681b      	ldr	r3, [r3, #0]
34002b10:	009b      	lsls	r3, r3, #2
34002b12:	4413      	add	r3, r2
34002b14:	edc3 7a00 	vstr	s15, [r3]
                  for(col = x; col < x+16; ++col, ++pos) {
34002b18:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002b1c:	f103 0310 	add.w	r3, r3, #16
34002b20:	681b      	ldr	r3, [r3, #0]
34002b22:	3301      	adds	r3, #1
34002b24:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002b28:	f102 0210 	add.w	r2, r2, #16
34002b2c:	6013      	str	r3, [r2, #0]
34002b2e:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002b32:	f103 0310 	add.w	r3, r3, #16
34002b36:	681b      	ldr	r3, [r3, #0]
34002b38:	3301      	adds	r3, #1
34002b3a:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002b3e:	f102 0210 	add.w	r2, r2, #16
34002b42:	6013      	str	r3, [r2, #0]
34002b44:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002b48:	f103 0318 	add.w	r3, r3, #24
34002b4c:	681b      	ldr	r3, [r3, #0]
34002b4e:	330f      	adds	r3, #15
34002b50:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002b54:	f102 0210 	add.w	r2, r2, #16
34002b58:	6812      	ldr	r2, [r2, #0]
34002b5a:	429a      	cmp	r2, r3
34002b5c:	f77f aece 	ble.w	340028fc <stbi_write_jpg_core+0x974>
               for(row = y, pos = 0; row < y+16; ++row) {
34002b60:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002b64:	f103 0314 	add.w	r3, r3, #20
34002b68:	681b      	ldr	r3, [r3, #0]
34002b6a:	3301      	adds	r3, #1
34002b6c:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002b70:	f102 0214 	add.w	r2, r2, #20
34002b74:	6013      	str	r3, [r2, #0]
34002b76:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002b7a:	f103 0314 	add.w	r3, r3, #20
34002b7e:	681b      	ldr	r3, [r3, #0]
34002b80:	330f      	adds	r3, #15
34002b82:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002b86:	f102 0214 	add.w	r2, r2, #20
34002b8a:	6812      	ldr	r2, [r2, #0]
34002b8c:	429a      	cmp	r2, r3
34002b8e:	f77f ae50 	ble.w	34002832 <stbi_write_jpg_core+0x8aa>
                  }
               }
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+0,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
34002b92:	f507 7405 	add.w	r4, r7, #532	@ 0x214
34002b96:	f607 6214 	addw	r2, r7, #3604	@ 0xe14
34002b9a:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
34002b9e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002ba2:	f5a3 7096 	sub.w	r0, r3, #300	@ 0x12c
34002ba6:	4b4b      	ldr	r3, [pc, #300]	@ (34002cd4 <stbi_write_jpg_core+0xd4c>)
34002ba8:	9304      	str	r3, [sp, #16]
34002baa:	4b4b      	ldr	r3, [pc, #300]	@ (34002cd8 <stbi_write_jpg_core+0xd50>)
34002bac:	9303      	str	r3, [sp, #12]
34002bae:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002bb2:	f103 0304 	add.w	r3, r3, #4
34002bb6:	681b      	ldr	r3, [r3, #0]
34002bb8:	9302      	str	r3, [sp, #8]
34002bba:	f607 73b4 	addw	r3, r7, #4020	@ 0xfb4
34002bbe:	9301      	str	r3, [sp, #4]
34002bc0:	2310      	movs	r3, #16
34002bc2:	9300      	str	r3, [sp, #0]
34002bc4:	4623      	mov	r3, r4
34002bc6:	6800      	ldr	r0, [r0, #0]
34002bc8:	f7fe fefe 	bl	340019c8 <stbiw__jpg_processDU>
34002bcc:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002bd0:	f103 0304 	add.w	r3, r3, #4
34002bd4:	6018      	str	r0, [r3, #0]
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+8,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
34002bd6:	f507 7305 	add.w	r3, r7, #532	@ 0x214
34002bda:	3320      	adds	r3, #32
34002bdc:	f607 6414 	addw	r4, r7, #3604	@ 0xe14
34002be0:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
34002be4:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002be8:	f5a2 7096 	sub.w	r0, r2, #300	@ 0x12c
34002bec:	4a39      	ldr	r2, [pc, #228]	@ (34002cd4 <stbi_write_jpg_core+0xd4c>)
34002bee:	9204      	str	r2, [sp, #16]
34002bf0:	4a39      	ldr	r2, [pc, #228]	@ (34002cd8 <stbi_write_jpg_core+0xd50>)
34002bf2:	9203      	str	r2, [sp, #12]
34002bf4:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002bf8:	f102 0204 	add.w	r2, r2, #4
34002bfc:	6812      	ldr	r2, [r2, #0]
34002bfe:	9202      	str	r2, [sp, #8]
34002c00:	f607 72b4 	addw	r2, r7, #4020	@ 0xfb4
34002c04:	9201      	str	r2, [sp, #4]
34002c06:	2210      	movs	r2, #16
34002c08:	9200      	str	r2, [sp, #0]
34002c0a:	4622      	mov	r2, r4
34002c0c:	6800      	ldr	r0, [r0, #0]
34002c0e:	f7fe fedb 	bl	340019c8 <stbiw__jpg_processDU>
34002c12:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002c16:	f103 0304 	add.w	r3, r3, #4
34002c1a:	6018      	str	r0, [r3, #0]
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+128, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
34002c1c:	f507 7305 	add.w	r3, r7, #532	@ 0x214
34002c20:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34002c24:	f607 6414 	addw	r4, r7, #3604	@ 0xe14
34002c28:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
34002c2c:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002c30:	f5a2 7096 	sub.w	r0, r2, #300	@ 0x12c
34002c34:	4a27      	ldr	r2, [pc, #156]	@ (34002cd4 <stbi_write_jpg_core+0xd4c>)
34002c36:	9204      	str	r2, [sp, #16]
34002c38:	4a27      	ldr	r2, [pc, #156]	@ (34002cd8 <stbi_write_jpg_core+0xd50>)
34002c3a:	9203      	str	r2, [sp, #12]
34002c3c:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002c40:	f102 0204 	add.w	r2, r2, #4
34002c44:	6812      	ldr	r2, [r2, #0]
34002c46:	9202      	str	r2, [sp, #8]
34002c48:	f607 72b4 	addw	r2, r7, #4020	@ 0xfb4
34002c4c:	9201      	str	r2, [sp, #4]
34002c4e:	2210      	movs	r2, #16
34002c50:	9200      	str	r2, [sp, #0]
34002c52:	4622      	mov	r2, r4
34002c54:	6800      	ldr	r0, [r0, #0]
34002c56:	f7fe feb7 	bl	340019c8 <stbiw__jpg_processDU>
34002c5a:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002c5e:	f103 0304 	add.w	r3, r3, #4
34002c62:	6018      	str	r0, [r3, #0]
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+136, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
34002c64:	f507 7305 	add.w	r3, r7, #532	@ 0x214
34002c68:	f503 7308 	add.w	r3, r3, #544	@ 0x220
34002c6c:	f607 6414 	addw	r4, r7, #3604	@ 0xe14
34002c70:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
34002c74:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002c78:	f5a2 7096 	sub.w	r0, r2, #300	@ 0x12c
34002c7c:	4a15      	ldr	r2, [pc, #84]	@ (34002cd4 <stbi_write_jpg_core+0xd4c>)
34002c7e:	9204      	str	r2, [sp, #16]
34002c80:	4a15      	ldr	r2, [pc, #84]	@ (34002cd8 <stbi_write_jpg_core+0xd50>)
34002c82:	9203      	str	r2, [sp, #12]
34002c84:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002c88:	f102 0204 	add.w	r2, r2, #4
34002c8c:	6812      	ldr	r2, [r2, #0]
34002c8e:	9202      	str	r2, [sp, #8]
34002c90:	f607 72b4 	addw	r2, r7, #4020	@ 0xfb4
34002c94:	9201      	str	r2, [sp, #4]
34002c96:	2210      	movs	r2, #16
34002c98:	9200      	str	r2, [sp, #0]
34002c9a:	4622      	mov	r2, r4
34002c9c:	6800      	ldr	r0, [r0, #0]
34002c9e:	f7fe fe93 	bl	340019c8 <stbiw__jpg_processDU>
34002ca2:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002ca6:	f103 0304 	add.w	r3, r3, #4
34002caa:	6018      	str	r0, [r3, #0]

               // subsample U,V
               {
                  float subU[64], subV[64];
                  int yy, xx;
                  for(yy = 0, pos = 0; yy < 8; ++yy) {
34002cac:	2300      	movs	r3, #0
34002cae:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002cb2:	f102 020c 	add.w	r2, r2, #12
34002cb6:	6013      	str	r3, [r2, #0]
34002cb8:	2300      	movs	r3, #0
34002cba:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002cbe:	f102 0210 	add.w	r2, r2, #16
34002cc2:	6013      	str	r3, [r2, #0]
34002cc4:	e0f1      	b.n	34002eaa <stbi_write_jpg_core+0xf22>
                     for(xx = 0; xx < 8; ++xx, ++pos) {
34002cc6:	2300      	movs	r3, #0
34002cc8:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002ccc:	f102 0208 	add.w	r2, r2, #8
34002cd0:	6013      	str	r3, [r2, #0]
34002cd2:	e0d7      	b.n	34002e84 <stbi_write_jpg_core+0xefc>
34002cd4:	34031514 	.word	0x34031514
34002cd8:	34031114 	.word	0x34031114
                        int j = yy*32+xx*2;
34002cdc:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002ce0:	f103 030c 	add.w	r3, r3, #12
34002ce4:	681b      	ldr	r3, [r3, #0]
34002ce6:	011a      	lsls	r2, r3, #4
34002ce8:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002cec:	f103 0308 	add.w	r3, r3, #8
34002cf0:	681b      	ldr	r3, [r3, #0]
34002cf2:	4413      	add	r3, r2
34002cf4:	005b      	lsls	r3, r3, #1
34002cf6:	f507 5286 	add.w	r2, r7, #4288	@ 0x10c0
34002cfa:	f102 0214 	add.w	r2, r2, #20
34002cfe:	6013      	str	r3, [r2, #0]
                        subU[pos] = (U[j+0] + U[j+1] + U[j+16] + U[j+17]) * 0.25f;
34002d00:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002d04:	f103 0318 	add.w	r3, r3, #24
34002d08:	f6a3 3224 	subw	r2, r3, #2852	@ 0xb24
34002d0c:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002d10:	f103 0314 	add.w	r3, r3, #20
34002d14:	681b      	ldr	r3, [r3, #0]
34002d16:	009b      	lsls	r3, r3, #2
34002d18:	4413      	add	r3, r2
34002d1a:	ed93 7a00 	vldr	s14, [r3]
34002d1e:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002d22:	f103 0314 	add.w	r3, r3, #20
34002d26:	681b      	ldr	r3, [r3, #0]
34002d28:	3301      	adds	r3, #1
34002d2a:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002d2e:	f102 0218 	add.w	r2, r2, #24
34002d32:	f6a2 3224 	subw	r2, r2, #2852	@ 0xb24
34002d36:	009b      	lsls	r3, r3, #2
34002d38:	4413      	add	r3, r2
34002d3a:	edd3 7a00 	vldr	s15, [r3]
34002d3e:	ee37 7a27 	vadd.f32	s14, s14, s15
34002d42:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002d46:	f103 0314 	add.w	r3, r3, #20
34002d4a:	681b      	ldr	r3, [r3, #0]
34002d4c:	3310      	adds	r3, #16
34002d4e:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002d52:	f102 0218 	add.w	r2, r2, #24
34002d56:	f6a2 3224 	subw	r2, r2, #2852	@ 0xb24
34002d5a:	009b      	lsls	r3, r3, #2
34002d5c:	4413      	add	r3, r2
34002d5e:	edd3 7a00 	vldr	s15, [r3]
34002d62:	ee37 7a27 	vadd.f32	s14, s14, s15
34002d66:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002d6a:	f103 0314 	add.w	r3, r3, #20
34002d6e:	681b      	ldr	r3, [r3, #0]
34002d70:	3311      	adds	r3, #17
34002d72:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002d76:	f102 0218 	add.w	r2, r2, #24
34002d7a:	f6a2 3224 	subw	r2, r2, #2852	@ 0xb24
34002d7e:	009b      	lsls	r3, r3, #2
34002d80:	4413      	add	r3, r2
34002d82:	edd3 7a00 	vldr	s15, [r3]
34002d86:	ee77 7a27 	vadd.f32	s15, s14, s15
34002d8a:	eeb5 7a00 	vmov.f32	s14, #80	@ 0x3e800000  0.250
34002d8e:	ee67 7a87 	vmul.f32	s15, s15, s14
34002d92:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002d96:	f5a3 7292 	sub.w	r2, r3, #292	@ 0x124
34002d9a:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002d9e:	f103 0310 	add.w	r3, r3, #16
34002da2:	681b      	ldr	r3, [r3, #0]
34002da4:	009b      	lsls	r3, r3, #2
34002da6:	4413      	add	r3, r2
34002da8:	edc3 7a00 	vstr	s15, [r3]
                        subV[pos] = (V[j+0] + V[j+1] + V[j+16] + V[j+17]) * 0.25f;
34002dac:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002db0:	f103 0318 	add.w	r3, r3, #24
34002db4:	f2a3 7224 	subw	r2, r3, #1828	@ 0x724
34002db8:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002dbc:	f103 0314 	add.w	r3, r3, #20
34002dc0:	681b      	ldr	r3, [r3, #0]
34002dc2:	009b      	lsls	r3, r3, #2
34002dc4:	4413      	add	r3, r2
34002dc6:	ed93 7a00 	vldr	s14, [r3]
34002dca:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002dce:	f103 0314 	add.w	r3, r3, #20
34002dd2:	681b      	ldr	r3, [r3, #0]
34002dd4:	3301      	adds	r3, #1
34002dd6:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002dda:	f102 0218 	add.w	r2, r2, #24
34002dde:	f2a2 7224 	subw	r2, r2, #1828	@ 0x724
34002de2:	009b      	lsls	r3, r3, #2
34002de4:	4413      	add	r3, r2
34002de6:	edd3 7a00 	vldr	s15, [r3]
34002dea:	ee37 7a27 	vadd.f32	s14, s14, s15
34002dee:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002df2:	f103 0314 	add.w	r3, r3, #20
34002df6:	681b      	ldr	r3, [r3, #0]
34002df8:	3310      	adds	r3, #16
34002dfa:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002dfe:	f102 0218 	add.w	r2, r2, #24
34002e02:	f2a2 7224 	subw	r2, r2, #1828	@ 0x724
34002e06:	009b      	lsls	r3, r3, #2
34002e08:	4413      	add	r3, r2
34002e0a:	edd3 7a00 	vldr	s15, [r3]
34002e0e:	ee37 7a27 	vadd.f32	s14, s14, s15
34002e12:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34002e16:	f103 0314 	add.w	r3, r3, #20
34002e1a:	681b      	ldr	r3, [r3, #0]
34002e1c:	3311      	adds	r3, #17
34002e1e:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002e22:	f102 0218 	add.w	r2, r2, #24
34002e26:	f2a2 7224 	subw	r2, r2, #1828	@ 0x724
34002e2a:	009b      	lsls	r3, r3, #2
34002e2c:	4413      	add	r3, r2
34002e2e:	edd3 7a00 	vldr	s15, [r3]
34002e32:	ee77 7a27 	vadd.f32	s15, s14, s15
34002e36:	eeb5 7a00 	vmov.f32	s14, #80	@ 0x3e800000  0.250
34002e3a:	ee67 7a87 	vmul.f32	s15, s15, s14
34002e3e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002e42:	461a      	mov	r2, r3
34002e44:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002e48:	f103 0310 	add.w	r3, r3, #16
34002e4c:	681b      	ldr	r3, [r3, #0]
34002e4e:	009b      	lsls	r3, r3, #2
34002e50:	4413      	add	r3, r2
34002e52:	3b24      	subs	r3, #36	@ 0x24
34002e54:	edc3 7a00 	vstr	s15, [r3]
                     for(xx = 0; xx < 8; ++xx, ++pos) {
34002e58:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002e5c:	f103 0308 	add.w	r3, r3, #8
34002e60:	681b      	ldr	r3, [r3, #0]
34002e62:	3301      	adds	r3, #1
34002e64:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002e68:	f102 0208 	add.w	r2, r2, #8
34002e6c:	6013      	str	r3, [r2, #0]
34002e6e:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002e72:	f103 0310 	add.w	r3, r3, #16
34002e76:	681b      	ldr	r3, [r3, #0]
34002e78:	3301      	adds	r3, #1
34002e7a:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002e7e:	f102 0210 	add.w	r2, r2, #16
34002e82:	6013      	str	r3, [r2, #0]
34002e84:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002e88:	f103 0308 	add.w	r3, r3, #8
34002e8c:	681b      	ldr	r3, [r3, #0]
34002e8e:	2b07      	cmp	r3, #7
34002e90:	f77f af24 	ble.w	34002cdc <stbi_write_jpg_core+0xd54>
                  for(yy = 0, pos = 0; yy < 8; ++yy) {
34002e94:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002e98:	f103 030c 	add.w	r3, r3, #12
34002e9c:	681b      	ldr	r3, [r3, #0]
34002e9e:	3301      	adds	r3, #1
34002ea0:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002ea4:	f102 020c 	add.w	r2, r2, #12
34002ea8:	6013      	str	r3, [r2, #0]
34002eaa:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002eae:	f103 030c 	add.w	r3, r3, #12
34002eb2:	681b      	ldr	r3, [r3, #0]
34002eb4:	2b07      	cmp	r3, #7
34002eb6:	f77f af06 	ble.w	34002cc6 <stbi_write_jpg_core+0xd3e>
                     }
                  }
                  DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subU, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
34002eba:	f107 0318 	add.w	r3, r7, #24
34002ebe:	3b04      	subs	r3, #4
34002ec0:	f607 6414 	addw	r4, r7, #3604	@ 0xe14
34002ec4:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
34002ec8:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002ecc:	f5a2 7096 	sub.w	r0, r2, #300	@ 0x12c
34002ed0:	4a75      	ldr	r2, [pc, #468]	@ (340030a8 <stbi_write_jpg_core+0x1120>)
34002ed2:	9204      	str	r2, [sp, #16]
34002ed4:	4a75      	ldr	r2, [pc, #468]	@ (340030ac <stbi_write_jpg_core+0x1124>)
34002ed6:	9203      	str	r2, [sp, #12]
34002ed8:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002edc:	6812      	ldr	r2, [r2, #0]
34002ede:	9202      	str	r2, [sp, #8]
34002ee0:	f607 62b4 	addw	r2, r7, #3764	@ 0xeb4
34002ee4:	9201      	str	r2, [sp, #4]
34002ee6:	2208      	movs	r2, #8
34002ee8:	9200      	str	r2, [sp, #0]
34002eea:	4622      	mov	r2, r4
34002eec:	6800      	ldr	r0, [r0, #0]
34002eee:	f7fe fd6b 	bl	340019c8 <stbiw__jpg_processDU>
34002ef2:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34002ef6:	6018      	str	r0, [r3, #0]
                  DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subV, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
34002ef8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
34002efc:	3b04      	subs	r3, #4
34002efe:	f607 6414 	addw	r4, r7, #3604	@ 0xe14
34002f02:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
34002f06:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34002f0a:	f5a2 7096 	sub.w	r0, r2, #300	@ 0x12c
34002f0e:	4a66      	ldr	r2, [pc, #408]	@ (340030a8 <stbi_write_jpg_core+0x1120>)
34002f10:	9204      	str	r2, [sp, #16]
34002f12:	4a66      	ldr	r2, [pc, #408]	@ (340030ac <stbi_write_jpg_core+0x1124>)
34002f14:	9203      	str	r2, [sp, #12]
34002f16:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002f1a:	f102 021c 	add.w	r2, r2, #28
34002f1e:	6812      	ldr	r2, [r2, #0]
34002f20:	9202      	str	r2, [sp, #8]
34002f22:	f607 62b4 	addw	r2, r7, #3764	@ 0xeb4
34002f26:	9201      	str	r2, [sp, #4]
34002f28:	2208      	movs	r2, #8
34002f2a:	9200      	str	r2, [sp, #0]
34002f2c:	4622      	mov	r2, r4
34002f2e:	6800      	ldr	r0, [r0, #0]
34002f30:	f7fe fd4a 	bl	340019c8 <stbiw__jpg_processDU>
34002f34:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002f38:	f103 031c 	add.w	r3, r3, #28
34002f3c:	6018      	str	r0, [r3, #0]
            for(x = 0; x < width; x += 16) {
34002f3e:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002f42:	f103 0318 	add.w	r3, r3, #24
34002f46:	681b      	ldr	r3, [r3, #0]
34002f48:	3310      	adds	r3, #16
34002f4a:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002f4e:	f102 0218 	add.w	r2, r2, #24
34002f52:	6013      	str	r3, [r2, #0]
34002f54:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002f58:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34002f5c:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002f60:	f102 0218 	add.w	r2, r2, #24
34002f64:	6812      	ldr	r2, [r2, #0]
34002f66:	681b      	ldr	r3, [r3, #0]
34002f68:	429a      	cmp	r2, r3
34002f6a:	f6ff ac51 	blt.w	34002810 <stbi_write_jpg_core+0x888>
         for(y = 0; y < height; y += 16) {
34002f6e:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002f72:	f103 0314 	add.w	r3, r3, #20
34002f76:	681b      	ldr	r3, [r3, #0]
34002f78:	3310      	adds	r3, #16
34002f7a:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002f7e:	f102 0214 	add.w	r2, r2, #20
34002f82:	6013      	str	r3, [r2, #0]
34002f84:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002f88:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34002f8c:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002f90:	f102 0214 	add.w	r2, r2, #20
34002f94:	6812      	ldr	r2, [r2, #0]
34002f96:	681b      	ldr	r3, [r3, #0]
34002f98:	429a      	cmp	r2, r3
34002f9a:	f6ff ac32 	blt.w	34002802 <stbi_write_jpg_core+0x87a>
34002f9e:	e250      	b.n	34003442 <stbi_write_jpg_core+0x14ba>
               }
            }
         }
      } else {
         for(y = 0; y < height; y += 8) {
34002fa0:	2300      	movs	r3, #0
34002fa2:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002fa6:	f102 0214 	add.w	r2, r2, #20
34002faa:	6013      	str	r3, [r2, #0]
34002fac:	e23c      	b.n	34003428 <stbi_write_jpg_core+0x14a0>
            for(x = 0; x < width; x += 8) {
34002fae:	2300      	movs	r3, #0
34002fb0:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002fb4:	f102 0218 	add.w	r2, r2, #24
34002fb8:	6013      	str	r3, [r2, #0]
34002fba:	e21d      	b.n	340033f8 <stbi_write_jpg_core+0x1470>
               float Y[64], U[64], V[64];
               for(row = y, pos = 0; row < y+8; ++row) {
34002fbc:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34002fc0:	f103 0314 	add.w	r3, r3, #20
34002fc4:	681b      	ldr	r3, [r3, #0]
34002fc6:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002fca:	f102 0214 	add.w	r2, r2, #20
34002fce:	6013      	str	r3, [r2, #0]
34002fd0:	2300      	movs	r3, #0
34002fd2:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34002fd6:	f102 0210 	add.w	r2, r2, #16
34002fda:	6013      	str	r3, [r2, #0]
34002fdc:	e191      	b.n	34003302 <stbi_write_jpg_core+0x137a>
                  // row >= height => use last input row
                  int clamped_row = (row < height) ? row : height - 1;
34002fde:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002fe2:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34002fe6:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34002fea:	f102 0214 	add.w	r2, r2, #20
34002fee:	6812      	ldr	r2, [r2, #0]
34002ff0:	681b      	ldr	r3, [r3, #0]
34002ff2:	429a      	cmp	r2, r3
34002ff4:	db06      	blt.n	34003004 <stbi_write_jpg_core+0x107c>
34002ff6:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34002ffa:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34002ffe:	681b      	ldr	r3, [r3, #0]
34003000:	3b01      	subs	r3, #1
34003002:	e004      	b.n	3400300e <stbi_write_jpg_core+0x1086>
34003004:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34003008:	f103 0314 	add.w	r3, r3, #20
3400300c:	681b      	ldr	r3, [r3, #0]
3400300e:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
34003012:	f102 020c 	add.w	r2, r2, #12
34003016:	6013      	str	r3, [r2, #0]
                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;
34003018:	4b25      	ldr	r3, [pc, #148]	@ (340030b0 <stbi_write_jpg_core+0x1128>)
3400301a:	681b      	ldr	r3, [r3, #0]
3400301c:	2b00      	cmp	r3, #0
3400301e:	d00c      	beq.n	3400303a <stbi_write_jpg_core+0x10b2>
34003020:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34003024:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34003028:	681b      	ldr	r3, [r3, #0]
3400302a:	1e5a      	subs	r2, r3, #1
3400302c:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
34003030:	f103 030c 	add.w	r3, r3, #12
34003034:	681b      	ldr	r3, [r3, #0]
34003036:	1ad3      	subs	r3, r2, r3
34003038:	e004      	b.n	34003044 <stbi_write_jpg_core+0x10bc>
3400303a:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
3400303e:	f103 030c 	add.w	r3, r3, #12
34003042:	681b      	ldr	r3, [r3, #0]
34003044:	f507 729c 	add.w	r2, r7, #312	@ 0x138
34003048:	f5a2 7298 	sub.w	r2, r2, #304	@ 0x130
3400304c:	6812      	ldr	r2, [r2, #0]
3400304e:	fb03 f202 	mul.w	r2, r3, r2
34003052:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34003056:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
3400305a:	681b      	ldr	r3, [r3, #0]
3400305c:	fb02 f303 	mul.w	r3, r2, r3
34003060:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
34003064:	f102 0208 	add.w	r2, r2, #8
34003068:	6013      	str	r3, [r2, #0]
                  for(col = x; col < x+8; ++col, ++pos) {
3400306a:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
3400306e:	f103 0318 	add.w	r3, r3, #24
34003072:	681b      	ldr	r3, [r3, #0]
34003074:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34003078:	f102 0210 	add.w	r2, r2, #16
3400307c:	6013      	str	r3, [r2, #0]
3400307e:	e127      	b.n	340032d0 <stbi_write_jpg_core+0x1348>
                     // if col >= width => use pixel from last input column
                     int p = base_p + ((col < width) ? col : (width-1))*comp;
34003080:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34003084:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34003088:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
3400308c:	f102 0210 	add.w	r2, r2, #16
34003090:	6812      	ldr	r2, [r2, #0]
34003092:	681b      	ldr	r3, [r3, #0]
34003094:	429a      	cmp	r2, r3
34003096:	db1d      	blt.n	340030d4 <stbi_write_jpg_core+0x114c>
34003098:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400309c:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
340030a0:	681b      	ldr	r3, [r3, #0]
340030a2:	3b01      	subs	r3, #1
340030a4:	e01b      	b.n	340030de <stbi_write_jpg_core+0x1156>
340030a6:	bf00      	nop
340030a8:	34031d14 	.word	0x34031d14
340030ac:	34031914 	.word	0x34031914
340030b0:	3403419c 	.word	0x3403419c
340030b4:	3e991687 	.word	0x3e991687
340030b8:	3f1645a2 	.word	0x3f1645a2
340030bc:	3de978d5 	.word	0x3de978d5
340030c0:	43000000 	.word	0x43000000
340030c4:	be2cca2e 	.word	0xbe2cca2e
340030c8:	3ea99ae9 	.word	0x3ea99ae9
340030cc:	3ed65e89 	.word	0x3ed65e89
340030d0:	3da685db 	.word	0x3da685db
340030d4:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340030d8:	f103 0310 	add.w	r3, r3, #16
340030dc:	681b      	ldr	r3, [r3, #0]
340030de:	f507 729c 	add.w	r2, r7, #312	@ 0x138
340030e2:	f5a2 729c 	sub.w	r2, r2, #312	@ 0x138
340030e6:	6812      	ldr	r2, [r2, #0]
340030e8:	fb02 f303 	mul.w	r3, r2, r3
340030ec:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340030f0:	f102 0208 	add.w	r2, r2, #8
340030f4:	6812      	ldr	r2, [r2, #0]
340030f6:	4413      	add	r3, r2
340030f8:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
340030fc:	f102 0204 	add.w	r2, r2, #4
34003100:	6013      	str	r3, [r2, #0]
                     float r = dataR[p], g = dataG[p], b = dataB[p];
34003102:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
34003106:	f103 0304 	add.w	r3, r3, #4
3400310a:	681b      	ldr	r3, [r3, #0]
3400310c:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
34003110:	f102 0218 	add.w	r2, r2, #24
34003114:	6812      	ldr	r2, [r2, #0]
34003116:	4413      	add	r3, r2
34003118:	781b      	ldrb	r3, [r3, #0]
3400311a:	ee07 3a90 	vmov	s15, r3
3400311e:	eef8 7a67 	vcvt.f32.u32	s15, s15
34003122:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
34003126:	edc3 7a00 	vstr	s15, [r3]
3400312a:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
3400312e:	f103 0304 	add.w	r3, r3, #4
34003132:	681b      	ldr	r3, [r3, #0]
34003134:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
34003138:	f102 0214 	add.w	r2, r2, #20
3400313c:	6812      	ldr	r2, [r2, #0]
3400313e:	4413      	add	r3, r2
34003140:	781b      	ldrb	r3, [r3, #0]
34003142:	ee07 3a90 	vmov	s15, r3
34003146:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400314a:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
3400314e:	f103 031c 	add.w	r3, r3, #28
34003152:	edc3 7a00 	vstr	s15, [r3]
34003156:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
3400315a:	f103 0304 	add.w	r3, r3, #4
3400315e:	681b      	ldr	r3, [r3, #0]
34003160:	f507 5287 	add.w	r2, r7, #4320	@ 0x10e0
34003164:	f102 0210 	add.w	r2, r2, #16
34003168:	6812      	ldr	r2, [r2, #0]
3400316a:	4413      	add	r3, r2
3400316c:	781b      	ldrb	r3, [r3, #0]
3400316e:	ee07 3a90 	vmov	s15, r3
34003172:	eef8 7a67 	vcvt.f32.u32	s15, s15
34003176:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
3400317a:	f103 0318 	add.w	r3, r3, #24
3400317e:	edc3 7a00 	vstr	s15, [r3]
                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;
34003182:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
34003186:	edd3 7a00 	vldr	s15, [r3]
3400318a:	ed1f 7a36 	vldr	s14, [pc, #-216]	@ 340030b4 <stbi_write_jpg_core+0x112c>
3400318e:	ee27 7a87 	vmul.f32	s14, s15, s14
34003192:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34003196:	f103 031c 	add.w	r3, r3, #28
3400319a:	edd3 7a00 	vldr	s15, [r3]
3400319e:	ed5f 6a3a 	vldr	s13, [pc, #-232]	@ 340030b8 <stbi_write_jpg_core+0x1130>
340031a2:	ee67 7aa6 	vmul.f32	s15, s15, s13
340031a6:	ee37 7a27 	vadd.f32	s14, s14, s15
340031aa:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340031ae:	f103 0318 	add.w	r3, r3, #24
340031b2:	edd3 7a00 	vldr	s15, [r3]
340031b6:	ed5f 6a3f 	vldr	s13, [pc, #-252]	@ 340030bc <stbi_write_jpg_core+0x1134>
340031ba:	ee67 7aa6 	vmul.f32	s15, s15, s13
340031be:	ee77 7a27 	vadd.f32	s15, s14, s15
340031c2:	ed1f 7a41 	vldr	s14, [pc, #-260]	@ 340030c0 <stbi_write_jpg_core+0x1138>
340031c6:	ee77 7ac7 	vsub.f32	s15, s15, s14
340031ca:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340031ce:	f103 0318 	add.w	r3, r3, #24
340031d2:	f6a3 7224 	subw	r2, r3, #3876	@ 0xf24
340031d6:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340031da:	f103 0310 	add.w	r3, r3, #16
340031de:	681b      	ldr	r3, [r3, #0]
340031e0:	009b      	lsls	r3, r3, #2
340031e2:	4413      	add	r3, r2
340031e4:	edc3 7a00 	vstr	s15, [r3]
                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;
340031e8:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
340031ec:	edd3 7a00 	vldr	s15, [r3]
340031f0:	ed1f 7a4c 	vldr	s14, [pc, #-304]	@ 340030c4 <stbi_write_jpg_core+0x113c>
340031f4:	ee27 7a87 	vmul.f32	s14, s15, s14
340031f8:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
340031fc:	f103 031c 	add.w	r3, r3, #28
34003200:	edd3 7a00 	vldr	s15, [r3]
34003204:	ed5f 6a50 	vldr	s13, [pc, #-320]	@ 340030c8 <stbi_write_jpg_core+0x1140>
34003208:	ee67 7aa6 	vmul.f32	s15, s15, s13
3400320c:	ee37 7a67 	vsub.f32	s14, s14, s15
34003210:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34003214:	f103 0318 	add.w	r3, r3, #24
34003218:	edd3 7a00 	vldr	s15, [r3]
3400321c:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
34003220:	ee67 7aa6 	vmul.f32	s15, s15, s13
34003224:	ee77 7a27 	vadd.f32	s15, s14, s15
34003228:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400322c:	f103 0318 	add.w	r3, r3, #24
34003230:	f6a3 3224 	subw	r2, r3, #2852	@ 0xb24
34003234:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34003238:	f103 0310 	add.w	r3, r3, #16
3400323c:	681b      	ldr	r3, [r3, #0]
3400323e:	009b      	lsls	r3, r3, #2
34003240:	4413      	add	r3, r2
34003242:	edc3 7a00 	vstr	s15, [r3]
                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;
34003246:	f507 5387 	add.w	r3, r7, #4320	@ 0x10e0
3400324a:	edd3 7a00 	vldr	s15, [r3]
3400324e:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34003252:	ee27 7a87 	vmul.f32	s14, s15, s14
34003256:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
3400325a:	f103 031c 	add.w	r3, r3, #28
3400325e:	edd3 7a00 	vldr	s15, [r3]
34003262:	ed5f 6a66 	vldr	s13, [pc, #-408]	@ 340030cc <stbi_write_jpg_core+0x1144>
34003266:	ee67 7aa6 	vmul.f32	s15, s15, s13
3400326a:	ee37 7a67 	vsub.f32	s14, s14, s15
3400326e:	f507 5386 	add.w	r3, r7, #4288	@ 0x10c0
34003272:	f103 0318 	add.w	r3, r3, #24
34003276:	edd3 7a00 	vldr	s15, [r3]
3400327a:	ed5f 6a6b 	vldr	s13, [pc, #-428]	@ 340030d0 <stbi_write_jpg_core+0x1148>
3400327e:	ee67 7aa6 	vmul.f32	s15, s15, s13
34003282:	ee77 7a67 	vsub.f32	s15, s14, s15
34003286:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400328a:	f103 0318 	add.w	r3, r3, #24
3400328e:	f2a3 7224 	subw	r2, r3, #1828	@ 0x724
34003292:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34003296:	f103 0310 	add.w	r3, r3, #16
3400329a:	681b      	ldr	r3, [r3, #0]
3400329c:	009b      	lsls	r3, r3, #2
3400329e:	4413      	add	r3, r2
340032a0:	edc3 7a00 	vstr	s15, [r3]
                  for(col = x; col < x+8; ++col, ++pos) {
340032a4:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340032a8:	f103 0310 	add.w	r3, r3, #16
340032ac:	681b      	ldr	r3, [r3, #0]
340032ae:	3301      	adds	r3, #1
340032b0:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340032b4:	f102 0210 	add.w	r2, r2, #16
340032b8:	6013      	str	r3, [r2, #0]
340032ba:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340032be:	f103 0310 	add.w	r3, r3, #16
340032c2:	681b      	ldr	r3, [r3, #0]
340032c4:	3301      	adds	r3, #1
340032c6:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
340032ca:	f102 0210 	add.w	r2, r2, #16
340032ce:	6013      	str	r3, [r2, #0]
340032d0:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340032d4:	f103 0318 	add.w	r3, r3, #24
340032d8:	681b      	ldr	r3, [r3, #0]
340032da:	3307      	adds	r3, #7
340032dc:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340032e0:	f102 0210 	add.w	r2, r2, #16
340032e4:	6812      	ldr	r2, [r2, #0]
340032e6:	429a      	cmp	r2, r3
340032e8:	f77f aeca 	ble.w	34003080 <stbi_write_jpg_core+0x10f8>
               for(row = y, pos = 0; row < y+8; ++row) {
340032ec:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
340032f0:	f103 0314 	add.w	r3, r3, #20
340032f4:	681b      	ldr	r3, [r3, #0]
340032f6:	3301      	adds	r3, #1
340032f8:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
340032fc:	f102 0214 	add.w	r2, r2, #20
34003300:	6013      	str	r3, [r2, #0]
34003302:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34003306:	f103 0314 	add.w	r3, r3, #20
3400330a:	681b      	ldr	r3, [r3, #0]
3400330c:	3307      	adds	r3, #7
3400330e:	f507 5289 	add.w	r2, r7, #4384	@ 0x1120
34003312:	f102 0214 	add.w	r2, r2, #20
34003316:	6812      	ldr	r2, [r2, #0]
34003318:	429a      	cmp	r2, r3
3400331a:	f77f ae60 	ble.w	34002fde <stbi_write_jpg_core+0x1056>
                  }
               }

               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y, 8, fdtbl_Y,  DCY, YDC_HT, YAC_HT);
3400331e:	f507 7405 	add.w	r4, r7, #532	@ 0x214
34003322:	f607 6214 	addw	r2, r7, #3604	@ 0xe14
34003326:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
3400332a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400332e:	f5a3 7096 	sub.w	r0, r3, #300	@ 0x12c
34003332:	4b55      	ldr	r3, [pc, #340]	@ (34003488 <stbi_write_jpg_core+0x1500>)
34003334:	9304      	str	r3, [sp, #16]
34003336:	4b55      	ldr	r3, [pc, #340]	@ (3400348c <stbi_write_jpg_core+0x1504>)
34003338:	9303      	str	r3, [sp, #12]
3400333a:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400333e:	f103 0304 	add.w	r3, r3, #4
34003342:	681b      	ldr	r3, [r3, #0]
34003344:	9302      	str	r3, [sp, #8]
34003346:	f607 73b4 	addw	r3, r7, #4020	@ 0xfb4
3400334a:	9301      	str	r3, [sp, #4]
3400334c:	2308      	movs	r3, #8
3400334e:	9300      	str	r3, [sp, #0]
34003350:	4623      	mov	r3, r4
34003352:	6800      	ldr	r0, [r0, #0]
34003354:	f7fe fb38 	bl	340019c8 <stbiw__jpg_processDU>
34003358:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400335c:	f103 0304 	add.w	r3, r3, #4
34003360:	6018      	str	r0, [r3, #0]
               DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, U, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
34003362:	f207 6414 	addw	r4, r7, #1556	@ 0x614
34003366:	f607 6214 	addw	r2, r7, #3604	@ 0xe14
3400336a:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
3400336e:	f507 739c 	add.w	r3, r7, #312	@ 0x138
34003372:	f5a3 7096 	sub.w	r0, r3, #300	@ 0x12c
34003376:	4b46      	ldr	r3, [pc, #280]	@ (34003490 <stbi_write_jpg_core+0x1508>)
34003378:	9304      	str	r3, [sp, #16]
3400337a:	4b46      	ldr	r3, [pc, #280]	@ (34003494 <stbi_write_jpg_core+0x150c>)
3400337c:	9303      	str	r3, [sp, #12]
3400337e:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
34003382:	681b      	ldr	r3, [r3, #0]
34003384:	9302      	str	r3, [sp, #8]
34003386:	f607 63b4 	addw	r3, r7, #3764	@ 0xeb4
3400338a:	9301      	str	r3, [sp, #4]
3400338c:	2308      	movs	r3, #8
3400338e:	9300      	str	r3, [sp, #0]
34003390:	4623      	mov	r3, r4
34003392:	6800      	ldr	r0, [r0, #0]
34003394:	f7fe fb18 	bl	340019c8 <stbiw__jpg_processDU>
34003398:	f507 5389 	add.w	r3, r7, #4384	@ 0x1120
3400339c:	6018      	str	r0, [r3, #0]
               DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, V, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
3400339e:	f607 2414 	addw	r4, r7, #2580	@ 0xa14
340033a2:	f607 6214 	addw	r2, r7, #3604	@ 0xe14
340033a6:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
340033aa:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340033ae:	f5a3 7096 	sub.w	r0, r3, #300	@ 0x12c
340033b2:	4b37      	ldr	r3, [pc, #220]	@ (34003490 <stbi_write_jpg_core+0x1508>)
340033b4:	9304      	str	r3, [sp, #16]
340033b6:	4b37      	ldr	r3, [pc, #220]	@ (34003494 <stbi_write_jpg_core+0x150c>)
340033b8:	9303      	str	r3, [sp, #12]
340033ba:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340033be:	f103 031c 	add.w	r3, r3, #28
340033c2:	681b      	ldr	r3, [r3, #0]
340033c4:	9302      	str	r3, [sp, #8]
340033c6:	f607 63b4 	addw	r3, r7, #3764	@ 0xeb4
340033ca:	9301      	str	r3, [sp, #4]
340033cc:	2308      	movs	r3, #8
340033ce:	9300      	str	r3, [sp, #0]
340033d0:	4623      	mov	r3, r4
340033d2:	6800      	ldr	r0, [r0, #0]
340033d4:	f7fe faf8 	bl	340019c8 <stbiw__jpg_processDU>
340033d8:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340033dc:	f103 031c 	add.w	r3, r3, #28
340033e0:	6018      	str	r0, [r3, #0]
            for(x = 0; x < width; x += 8) {
340033e2:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
340033e6:	f103 0318 	add.w	r3, r3, #24
340033ea:	681b      	ldr	r3, [r3, #0]
340033ec:	3308      	adds	r3, #8
340033ee:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
340033f2:	f102 0218 	add.w	r2, r2, #24
340033f6:	6013      	str	r3, [r2, #0]
340033f8:	f507 739c 	add.w	r3, r7, #312	@ 0x138
340033fc:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34003400:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34003404:	f102 0218 	add.w	r2, r2, #24
34003408:	6812      	ldr	r2, [r2, #0]
3400340a:	681b      	ldr	r3, [r3, #0]
3400340c:	429a      	cmp	r2, r3
3400340e:	f6ff add5 	blt.w	34002fbc <stbi_write_jpg_core+0x1034>
         for(y = 0; y < height; y += 8) {
34003412:	f507 5388 	add.w	r3, r7, #4352	@ 0x1100
34003416:	f103 0314 	add.w	r3, r3, #20
3400341a:	681b      	ldr	r3, [r3, #0]
3400341c:	3308      	adds	r3, #8
3400341e:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34003422:	f102 0214 	add.w	r2, r2, #20
34003426:	6013      	str	r3, [r2, #0]
34003428:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400342c:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
34003430:	f507 5288 	add.w	r2, r7, #4352	@ 0x1100
34003434:	f102 0214 	add.w	r2, r2, #20
34003438:	6812      	ldr	r2, [r2, #0]
3400343a:	681b      	ldr	r3, [r3, #0]
3400343c:	429a      	cmp	r2, r3
3400343e:	f6ff adb6 	blt.w	34002fae <stbi_write_jpg_core+0x1026>
            }
         }
      }

      // Do the bit alignment of the EOI marker
      stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits);
34003442:	f607 6214 	addw	r2, r7, #3604	@ 0xe14
34003446:	f607 6118 	addw	r1, r7, #3608	@ 0xe18
3400344a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400344e:	f5a3 7096 	sub.w	r0, r3, #300	@ 0x12c
34003452:	4b11      	ldr	r3, [pc, #68]	@ (34003498 <stbi_write_jpg_core+0x1510>)
34003454:	6800      	ldr	r0, [r0, #0]
34003456:	f7fe f8f4 	bl	34001642 <stbiw__jpg_writeBits>
   }

   // EOI
   stbiw__putc(s, 0xFF);
3400345a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400345e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34003462:	21ff      	movs	r1, #255	@ 0xff
34003464:	6818      	ldr	r0, [r3, #0]
34003466:	f7fe f8db 	bl	34001620 <stbiw__putc>
   stbiw__putc(s, 0xD9);
3400346a:	f507 739c 	add.w	r3, r7, #312	@ 0x138
3400346e:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
34003472:	21d9      	movs	r1, #217	@ 0xd9
34003474:	6818      	ldr	r0, [r3, #0]
34003476:	f7fe f8d3 	bl	34001620 <stbiw__putc>

   return 1;
3400347a:	2301      	movs	r3, #1
}
3400347c:	4618      	mov	r0, r3
3400347e:	f507 5789 	add.w	r7, r7, #4384	@ 0x1120
34003482:	371c      	adds	r7, #28
34003484:	46bd      	mov	sp, r7
34003486:	bd90      	pop	{r4, r7, pc}
34003488:	34031514 	.word	0x34031514
3400348c:	34031114 	.word	0x34031114
34003490:	34031d14 	.word	0x34031d14
34003494:	34031914 	.word	0x34031914
34003498:	34032114 	.word	0x34032114

3400349c <stbi_write_jpg_to_func>:

STBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality)
{
3400349c:	b580      	push	{r7, lr}
3400349e:	b09a      	sub	sp, #104	@ 0x68
340034a0:	af02      	add	r7, sp, #8
340034a2:	60f8      	str	r0, [r7, #12]
340034a4:	60b9      	str	r1, [r7, #8]
340034a6:	607a      	str	r2, [r7, #4]
340034a8:	603b      	str	r3, [r7, #0]
   stbi__write_context s = { 0 };
340034aa:	f107 0314 	add.w	r3, r7, #20
340034ae:	224c      	movs	r2, #76	@ 0x4c
340034b0:	2100      	movs	r1, #0
340034b2:	4618      	mov	r0, r3
340034b4:	f01e f88e 	bl	340215d4 <memset>
   stbi__start_write_callbacks(&s, func, context);
340034b8:	f107 0314 	add.w	r3, r7, #20
340034bc:	68ba      	ldr	r2, [r7, #8]
340034be:	68f9      	ldr	r1, [r7, #12]
340034c0:	4618      	mov	r0, r3
340034c2:	f7fe f89b 	bl	340015fc <stbi__start_write_callbacks>
   return stbi_write_jpg_core(&s, x, y, comp, (void *) data, quality);
340034c6:	f107 0014 	add.w	r0, r7, #20
340034ca:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
340034cc:	9301      	str	r3, [sp, #4]
340034ce:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340034d0:	9300      	str	r3, [sp, #0]
340034d2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
340034d4:	683a      	ldr	r2, [r7, #0]
340034d6:	6879      	ldr	r1, [r7, #4]
340034d8:	f7fe fd56 	bl	34001f88 <stbi_write_jpg_core>
340034dc:	4603      	mov	r3, r0
}
340034de:	4618      	mov	r0, r3
340034e0:	3760      	adds	r7, #96	@ 0x60
340034e2:	46bd      	mov	sp, r7
340034e4:	bd80      	pop	{r7, pc}
	...

340034e8 <PC_STREAM_Init>:
    .Parity = UART_PARITY_NONE,
    .HwFlowCtl = UART_HWCONTROL_NONE
};
static uint8_t jpeg_buf[64 * 512];
void PC_STREAM_Init(void)
{
340034e8:	b580      	push	{r7, lr}
340034ea:	af00      	add	r7, sp, #0
    BSP_COM_Init(COM1, &PcUartInit);
340034ec:	4902      	ldr	r1, [pc, #8]	@ (340034f8 <PC_STREAM_Init+0x10>)
340034ee:	2000      	movs	r0, #0
340034f0:	f001 fbb2 	bl	34004c58 <BSP_COM_Init>
#if (USE_COM_LOG > 0)
    BSP_COM_SelectLogPort(COM1);
#endif
}
340034f4:	bf00      	nop
340034f6:	bd80      	pop	{r7, pc}
340034f8:	34033f30 	.word	0x34033f30

340034fc <mem_write>:
    int size;
    int cap;
} mem_writer_t;

static void mem_write(void *context, void *data, int size)
{
340034fc:	b580      	push	{r7, lr}
340034fe:	b086      	sub	sp, #24
34003500:	af00      	add	r7, sp, #0
34003502:	60f8      	str	r0, [r7, #12]
34003504:	60b9      	str	r1, [r7, #8]
34003506:	607a      	str	r2, [r7, #4]
    mem_writer_t *wr = (mem_writer_t *)context;
34003508:	68fb      	ldr	r3, [r7, #12]
3400350a:	617b      	str	r3, [r7, #20]
    if (wr->size + size <= wr->cap)
3400350c:	697b      	ldr	r3, [r7, #20]
3400350e:	685a      	ldr	r2, [r3, #4]
34003510:	687b      	ldr	r3, [r7, #4]
34003512:	441a      	add	r2, r3
34003514:	697b      	ldr	r3, [r7, #20]
34003516:	689b      	ldr	r3, [r3, #8]
34003518:	429a      	cmp	r2, r3
3400351a:	dc0f      	bgt.n	3400353c <mem_write+0x40>
    {
        memcpy(wr->buf + wr->size, data, size);
3400351c:	697b      	ldr	r3, [r7, #20]
3400351e:	681b      	ldr	r3, [r3, #0]
34003520:	697a      	ldr	r2, [r7, #20]
34003522:	6852      	ldr	r2, [r2, #4]
34003524:	4413      	add	r3, r2
34003526:	687a      	ldr	r2, [r7, #4]
34003528:	68b9      	ldr	r1, [r7, #8]
3400352a:	4618      	mov	r0, r3
3400352c:	f01e fae1 	bl	34021af2 <memcpy>
        wr->size += size;
34003530:	697b      	ldr	r3, [r7, #20]
34003532:	685a      	ldr	r2, [r3, #4]
34003534:	687b      	ldr	r3, [r7, #4]
34003536:	441a      	add	r2, r3
34003538:	697b      	ldr	r3, [r7, #20]
3400353a:	605a      	str	r2, [r3, #4]
    }
}
3400353c:	bf00      	nop
3400353e:	3718      	adds	r7, #24
34003540:	46bd      	mov	sp, r7
34003542:	bd80      	pop	{r7, pc}

34003544 <rgb565_to_gray>:

static uint8_t rgb565_to_gray(uint16_t pixel)
{
34003544:	b480      	push	{r7}
34003546:	b085      	sub	sp, #20
34003548:	af00      	add	r7, sp, #0
3400354a:	4603      	mov	r3, r0
3400354c:	80fb      	strh	r3, [r7, #6]
    uint8_t r8 = ((pixel >> 11) & 0x1F) << 3;
3400354e:	88fb      	ldrh	r3, [r7, #6]
34003550:	0adb      	lsrs	r3, r3, #11
34003552:	b29b      	uxth	r3, r3
34003554:	b2db      	uxtb	r3, r3
34003556:	00db      	lsls	r3, r3, #3
34003558:	73fb      	strb	r3, [r7, #15]
    uint8_t g8 = ((pixel >> 5) & 0x3F) << 2;
3400355a:	88fb      	ldrh	r3, [r7, #6]
3400355c:	095b      	lsrs	r3, r3, #5
3400355e:	b29b      	uxth	r3, r3
34003560:	b2db      	uxtb	r3, r3
34003562:	009b      	lsls	r3, r3, #2
34003564:	73bb      	strb	r3, [r7, #14]
    uint8_t b8 = (pixel & 0x1F) << 3;
34003566:	88fb      	ldrh	r3, [r7, #6]
34003568:	b2db      	uxtb	r3, r3
3400356a:	00db      	lsls	r3, r3, #3
3400356c:	737b      	strb	r3, [r7, #13]
    return (uint8_t)((r8 * 30 + g8 * 59 + b8 * 11) / 100);
3400356e:	7bfa      	ldrb	r2, [r7, #15]
34003570:	4613      	mov	r3, r2
34003572:	011b      	lsls	r3, r3, #4
34003574:	1a9b      	subs	r3, r3, r2
34003576:	005b      	lsls	r3, r3, #1
34003578:	4619      	mov	r1, r3
3400357a:	7bba      	ldrb	r2, [r7, #14]
3400357c:	4613      	mov	r3, r2
3400357e:	011b      	lsls	r3, r3, #4
34003580:	1a9b      	subs	r3, r3, r2
34003582:	009b      	lsls	r3, r3, #2
34003584:	1a9b      	subs	r3, r3, r2
34003586:	4419      	add	r1, r3
34003588:	7b7a      	ldrb	r2, [r7, #13]
3400358a:	4613      	mov	r3, r2
3400358c:	009b      	lsls	r3, r3, #2
3400358e:	4413      	add	r3, r2
34003590:	005b      	lsls	r3, r3, #1
34003592:	4413      	add	r3, r2
34003594:	440b      	add	r3, r1
34003596:	4a06      	ldr	r2, [pc, #24]	@ (340035b0 <rgb565_to_gray+0x6c>)
34003598:	fb82 1203 	smull	r1, r2, r2, r3
3400359c:	1152      	asrs	r2, r2, #5
3400359e:	17db      	asrs	r3, r3, #31
340035a0:	1ad3      	subs	r3, r2, r3
340035a2:	b2db      	uxtb	r3, r3
}
340035a4:	4618      	mov	r0, r3
340035a6:	3714      	adds	r7, #20
340035a8:	46bd      	mov	sp, r7
340035aa:	f85d 7b04 	ldr.w	r7, [sp], #4
340035ae:	4770      	bx	lr
340035b0:	51eb851f 	.word	0x51eb851f

340035b4 <rgb888_to_gray>:

static uint8_t rgb888_to_gray(uint8_t r, uint8_t g, uint8_t b)
{
340035b4:	b480      	push	{r7}
340035b6:	b083      	sub	sp, #12
340035b8:	af00      	add	r7, sp, #0
340035ba:	4603      	mov	r3, r0
340035bc:	71fb      	strb	r3, [r7, #7]
340035be:	460b      	mov	r3, r1
340035c0:	71bb      	strb	r3, [r7, #6]
340035c2:	4613      	mov	r3, r2
340035c4:	717b      	strb	r3, [r7, #5]
    return (uint8_t)((r * 30 + g * 59 + b * 11) / 100);
340035c6:	79fa      	ldrb	r2, [r7, #7]
340035c8:	4613      	mov	r3, r2
340035ca:	011b      	lsls	r3, r3, #4
340035cc:	1a9b      	subs	r3, r3, r2
340035ce:	005b      	lsls	r3, r3, #1
340035d0:	4619      	mov	r1, r3
340035d2:	79ba      	ldrb	r2, [r7, #6]
340035d4:	4613      	mov	r3, r2
340035d6:	011b      	lsls	r3, r3, #4
340035d8:	1a9b      	subs	r3, r3, r2
340035da:	009b      	lsls	r3, r3, #2
340035dc:	1a9b      	subs	r3, r3, r2
340035de:	4419      	add	r1, r3
340035e0:	797a      	ldrb	r2, [r7, #5]
340035e2:	4613      	mov	r3, r2
340035e4:	009b      	lsls	r3, r3, #2
340035e6:	4413      	add	r3, r2
340035e8:	005b      	lsls	r3, r3, #1
340035ea:	4413      	add	r3, r2
340035ec:	440b      	add	r3, r1
340035ee:	4a06      	ldr	r2, [pc, #24]	@ (34003608 <rgb888_to_gray+0x54>)
340035f0:	fb82 1203 	smull	r1, r2, r2, r3
340035f4:	1152      	asrs	r2, r2, #5
340035f6:	17db      	asrs	r3, r3, #31
340035f8:	1ad3      	subs	r3, r2, r3
340035fa:	b2db      	uxtb	r3, r3
}
340035fc:	4618      	mov	r0, r3
340035fe:	370c      	adds	r7, #12
34003600:	46bd      	mov	sp, r7
34003602:	f85d 7b04 	ldr.w	r7, [sp], #4
34003606:	4770      	bx	lr
34003608:	51eb851f 	.word	0x51eb851f

3400360c <PC_STREAM_SendFrame>:

void PC_STREAM_SendFrame(const uint8_t *frame, uint32_t width, uint32_t height, uint32_t bpp)
{
3400360c:	b5b0      	push	{r4, r5, r7, lr}
3400360e:	b0a0      	sub	sp, #128	@ 0x80
34003610:	af04      	add	r7, sp, #16
34003612:	60f8      	str	r0, [r7, #12]
34003614:	60b9      	str	r1, [r7, #8]
34003616:	607a      	str	r2, [r7, #4]
34003618:	603b      	str	r3, [r7, #0]

    uint32_t sw = width / STREAM_SCALE;
3400361a:	68bb      	ldr	r3, [r7, #8]
3400361c:	085b      	lsrs	r3, r3, #1
3400361e:	66fb      	str	r3, [r7, #108]	@ 0x6c
    uint32_t sh = height / STREAM_SCALE;
34003620:	687b      	ldr	r3, [r7, #4]
34003622:	085b      	lsrs	r3, r3, #1
34003624:	66bb      	str	r3, [r7, #104]	@ 0x68
    if (sw > STREAM_MAX_WIDTH)  sw = STREAM_MAX_WIDTH;
34003626:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34003628:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
3400362c:	d902      	bls.n	34003634 <PC_STREAM_SendFrame+0x28>
3400362e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34003632:	66fb      	str	r3, [r7, #108]	@ 0x6c
    if (sh > STREAM_MAX_HEIGHT) sh = STREAM_MAX_HEIGHT;
34003634:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34003636:	2bf0      	cmp	r3, #240	@ 0xf0
34003638:	d901      	bls.n	3400363e <PC_STREAM_SendFrame+0x32>
3400363a:	23f0      	movs	r3, #240	@ 0xf0
3400363c:	66bb      	str	r3, [r7, #104]	@ 0x68

    // Convert input to grayscale and store in stream_buffer
    for (uint32_t y = 0; y < sh; y++)
3400363e:	2300      	movs	r3, #0
34003640:	667b      	str	r3, [r7, #100]	@ 0x64
34003642:	e062      	b.n	3400370a <PC_STREAM_SendFrame+0xfe>
    {
        const uint8_t *line = frame + (y * STREAM_SCALE) * width * bpp;
34003644:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34003646:	68ba      	ldr	r2, [r7, #8]
34003648:	fb02 f303 	mul.w	r3, r2, r3
3400364c:	683a      	ldr	r2, [r7, #0]
3400364e:	fb02 f303 	mul.w	r3, r2, r3
34003652:	005b      	lsls	r3, r3, #1
34003654:	68fa      	ldr	r2, [r7, #12]
34003656:	4413      	add	r3, r2
34003658:	64fb      	str	r3, [r7, #76]	@ 0x4c
        for (uint32_t x = 0; x < sw; x++)
3400365a:	2300      	movs	r3, #0
3400365c:	663b      	str	r3, [r7, #96]	@ 0x60
3400365e:	e04d      	b.n	340036fc <PC_STREAM_SendFrame+0xf0>
        {
            if (bpp == 2)
34003660:	683b      	ldr	r3, [r7, #0]
34003662:	2b02      	cmp	r3, #2
34003664:	d118      	bne.n	34003698 <PC_STREAM_SendFrame+0x8c>
            {
                const uint16_t *line16 = (const uint16_t *)line;
34003666:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34003668:	647b      	str	r3, [r7, #68]	@ 0x44
                uint16_t px = line16[x * STREAM_SCALE];
3400366a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3400366c:	009b      	lsls	r3, r3, #2
3400366e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34003670:	4413      	add	r3, r2
34003672:	881b      	ldrh	r3, [r3, #0]
34003674:	f8a7 3042 	strh.w	r3, [r7, #66]	@ 0x42
                stream_buffer[y * sw + x] = rgb565_to_gray(px);
34003678:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3400367a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
3400367c:	fb03 f202 	mul.w	r2, r3, r2
34003680:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34003682:	18d4      	adds	r4, r2, r3
34003684:	f8b7 3042 	ldrh.w	r3, [r7, #66]	@ 0x42
34003688:	4618      	mov	r0, r3
3400368a:	f7ff ff5b 	bl	34003544 <rgb565_to_gray>
3400368e:	4603      	mov	r3, r0
34003690:	461a      	mov	r2, r3
34003692:	4b4a      	ldr	r3, [pc, #296]	@ (340037bc <PC_STREAM_SendFrame+0x1b0>)
34003694:	551a      	strb	r2, [r3, r4]
34003696:	e02e      	b.n	340036f6 <PC_STREAM_SendFrame+0xea>
            }
            else if (bpp == 3)
34003698:	683b      	ldr	r3, [r7, #0]
3400369a:	2b03      	cmp	r3, #3
3400369c:	d11e      	bne.n	340036dc <PC_STREAM_SendFrame+0xd0>
            {
                const uint8_t *px = line + x * STREAM_SCALE * 3;
3400369e:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
340036a0:	4613      	mov	r3, r2
340036a2:	005b      	lsls	r3, r3, #1
340036a4:	4413      	add	r3, r2
340036a6:	005b      	lsls	r3, r3, #1
340036a8:	461a      	mov	r2, r3
340036aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340036ac:	4413      	add	r3, r2
340036ae:	64bb      	str	r3, [r7, #72]	@ 0x48
                stream_buffer[y * sw + x] = rgb888_to_gray(px[0], px[1], px[2]);
340036b0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340036b2:	7818      	ldrb	r0, [r3, #0]
340036b4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340036b6:	3301      	adds	r3, #1
340036b8:	7819      	ldrb	r1, [r3, #0]
340036ba:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340036bc:	3302      	adds	r3, #2
340036be:	781d      	ldrb	r5, [r3, #0]
340036c0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
340036c2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
340036c4:	fb03 f202 	mul.w	r2, r3, r2
340036c8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
340036ca:	18d4      	adds	r4, r2, r3
340036cc:	462a      	mov	r2, r5
340036ce:	f7ff ff71 	bl	340035b4 <rgb888_to_gray>
340036d2:	4603      	mov	r3, r0
340036d4:	461a      	mov	r2, r3
340036d6:	4b39      	ldr	r3, [pc, #228]	@ (340037bc <PC_STREAM_SendFrame+0x1b0>)
340036d8:	551a      	strb	r2, [r3, r4]
340036da:	e00c      	b.n	340036f6 <PC_STREAM_SendFrame+0xea>
            }
            else
            {
                stream_buffer[y * sw + x] = line[x * STREAM_SCALE];
340036dc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
340036de:	005b      	lsls	r3, r3, #1
340036e0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
340036e2:	441a      	add	r2, r3
340036e4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
340036e6:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
340036e8:	fb03 f101 	mul.w	r1, r3, r1
340036ec:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
340036ee:	440b      	add	r3, r1
340036f0:	7811      	ldrb	r1, [r2, #0]
340036f2:	4a32      	ldr	r2, [pc, #200]	@ (340037bc <PC_STREAM_SendFrame+0x1b0>)
340036f4:	54d1      	strb	r1, [r2, r3]
        for (uint32_t x = 0; x < sw; x++)
340036f6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
340036f8:	3301      	adds	r3, #1
340036fa:	663b      	str	r3, [r7, #96]	@ 0x60
340036fc:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
340036fe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34003700:	429a      	cmp	r2, r3
34003702:	d3ad      	bcc.n	34003660 <PC_STREAM_SendFrame+0x54>
    for (uint32_t y = 0; y < sh; y++)
34003704:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34003706:	3301      	adds	r3, #1
34003708:	667b      	str	r3, [r7, #100]	@ 0x64
3400370a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
3400370c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400370e:	429a      	cmp	r2, r3
34003710:	d398      	bcc.n	34003644 <PC_STREAM_SendFrame+0x38>
            }
        }
    }

    // Encode to JPEG into jpeg_buf
    mem_writer_t w = { jpeg_buf, 0, sizeof(jpeg_buf) };
34003712:	4a2b      	ldr	r2, [pc, #172]	@ (340037c0 <PC_STREAM_SendFrame+0x1b4>)
34003714:	f107 0334 	add.w	r3, r7, #52	@ 0x34
34003718:	ca07      	ldmia	r2, {r0, r1, r2}
3400371a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    stbi_write_jpg_to_func(mem_write, &w, sw, sh, 1, stream_buffer, 80);
3400371e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34003720:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34003722:	f107 0134 	add.w	r1, r7, #52	@ 0x34
34003726:	2050      	movs	r0, #80	@ 0x50
34003728:	9002      	str	r0, [sp, #8]
3400372a:	4824      	ldr	r0, [pc, #144]	@ (340037bc <PC_STREAM_SendFrame+0x1b0>)
3400372c:	9001      	str	r0, [sp, #4]
3400372e:	2001      	movs	r0, #1
34003730:	9000      	str	r0, [sp, #0]
34003732:	4824      	ldr	r0, [pc, #144]	@ (340037c4 <PC_STREAM_SendFrame+0x1b8>)
34003734:	f7ff feb2 	bl	3400349c <stbi_write_jpg_to_func>

    // Send a simple header first
    char header[32];
    int hl = snprintf(header, sizeof(header), "JPG %u %u %u\n",
                      (unsigned)sw, (unsigned)sh, (unsigned)w.size);
34003738:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int hl = snprintf(header, sizeof(header), "JPG %u %u %u\n",
3400373a:	f107 0014 	add.w	r0, r7, #20
3400373e:	9301      	str	r3, [sp, #4]
34003740:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34003742:	9300      	str	r3, [sp, #0]
34003744:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34003746:	4a20      	ldr	r2, [pc, #128]	@ (340037c8 <PC_STREAM_SendFrame+0x1bc>)
34003748:	2120      	movs	r1, #32
3400374a:	f01d fe1b 	bl	34021384 <sniprintf>
3400374e:	6578      	str	r0, [r7, #84]	@ 0x54
    if (hl > 0)
34003750:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34003752:	2b00      	cmp	r3, #0
34003754:	dd08      	ble.n	34003768 <PC_STREAM_SendFrame+0x15c>
    {
        HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)header, (uint16_t)hl, HAL_MAX_DELAY);
34003756:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34003758:	b29a      	uxth	r2, r3
3400375a:	f107 0114 	add.w	r1, r7, #20
3400375e:	f04f 33ff 	mov.w	r3, #4294967295
34003762:	481a      	ldr	r0, [pc, #104]	@ (340037cc <PC_STREAM_SendFrame+0x1c0>)
34003764:	f016 fc7a 	bl	3401a05c <HAL_UART_Transmit>
    }

    // Now send jpeg_buf in chunks
    uint32_t bytes_left = w.size;
34003768:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3400376a:	65fb      	str	r3, [r7, #92]	@ 0x5c
    uint8_t *ptr = jpeg_buf;
3400376c:	4b18      	ldr	r3, [pc, #96]	@ (340037d0 <PC_STREAM_SendFrame+0x1c4>)
3400376e:	65bb      	str	r3, [r7, #88]	@ 0x58
    while (bytes_left > 0)
34003770:	e01c      	b.n	340037ac <PC_STREAM_SendFrame+0x1a0>
    {
        uint16_t this_chunk = (bytes_left > UART_CHUNK_SIZE)
34003772:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34003774:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34003778:	d802      	bhi.n	34003780 <PC_STREAM_SendFrame+0x174>
3400377a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3400377c:	b29b      	uxth	r3, r3
3400377e:	e001      	b.n	34003784 <PC_STREAM_SendFrame+0x178>
34003780:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34003784:	f8a7 3052 	strh.w	r3, [r7, #82]	@ 0x52
                               ? UART_CHUNK_SIZE
                               : (uint16_t)bytes_left;

        HAL_UART_Transmit(&hcom_uart[COM1], ptr, this_chunk, HAL_MAX_DELAY);
34003788:	f8b7 2052 	ldrh.w	r2, [r7, #82]	@ 0x52
3400378c:	f04f 33ff 	mov.w	r3, #4294967295
34003790:	6db9      	ldr	r1, [r7, #88]	@ 0x58
34003792:	480e      	ldr	r0, [pc, #56]	@ (340037cc <PC_STREAM_SendFrame+0x1c0>)
34003794:	f016 fc62 	bl	3401a05c <HAL_UART_Transmit>

        ptr         += this_chunk;
34003798:	f8b7 3052 	ldrh.w	r3, [r7, #82]	@ 0x52
3400379c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
3400379e:	4413      	add	r3, r2
340037a0:	65bb      	str	r3, [r7, #88]	@ 0x58
        bytes_left  -= this_chunk;
340037a2:	f8b7 3052 	ldrh.w	r3, [r7, #82]	@ 0x52
340037a6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
340037a8:	1ad3      	subs	r3, r2, r3
340037aa:	65fb      	str	r3, [r7, #92]	@ 0x5c
    while (bytes_left > 0)
340037ac:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
340037ae:	2b00      	cmp	r3, #0
340037b0:	d1df      	bne.n	34003772 <PC_STREAM_SendFrame+0x166>
    }
}
340037b2:	bf00      	nop
340037b4:	bf00      	nop
340037b6:	3770      	adds	r7, #112	@ 0x70
340037b8:	46bd      	mov	sp, r7
340037ba:	bdb0      	pop	{r4, r5, r7, pc}
340037bc:	3403c1a0 	.word	0x3403c1a0
340037c0:	34023f20 	.word	0x34023f20
340037c4:	340034fd 	.word	0x340034fd
340037c8:	34023f10 	.word	0x34023f10
340037cc:	340538a0 	.word	0x340538a0
340037d0:	340341a0 	.word	0x340341a0

340037d4 <PC_STREAM_SendDetections>:

void PC_STREAM_SendDetections(const od_pp_out_t *detections, uint32_t frame_id)
{
340037d4:	b580      	push	{r7, lr}
340037d6:	b0a0      	sub	sp, #128	@ 0x80
340037d8:	af0a      	add	r7, sp, #40	@ 0x28
340037da:	6078      	str	r0, [r7, #4]
340037dc:	6039      	str	r1, [r7, #0]
    char line[64];
    int ll = snprintf(line, sizeof(line), "DETS %lu %d\n", (unsigned long)frame_id, (int)detections->nb_detect);
340037de:	687b      	ldr	r3, [r7, #4]
340037e0:	685b      	ldr	r3, [r3, #4]
340037e2:	f107 000c 	add.w	r0, r7, #12
340037e6:	9300      	str	r3, [sp, #0]
340037e8:	683b      	ldr	r3, [r7, #0]
340037ea:	4a34      	ldr	r2, [pc, #208]	@ (340038bc <PC_STREAM_SendDetections+0xe8>)
340037ec:	2140      	movs	r1, #64	@ 0x40
340037ee:	f01d fdc9 	bl	34021384 <sniprintf>
340037f2:	6538      	str	r0, [r7, #80]	@ 0x50
    if (ll > 0)
340037f4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340037f6:	2b00      	cmp	r3, #0
340037f8:	dd08      	ble.n	3400380c <PC_STREAM_SendDetections+0x38>
    {
        HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)line, (uint16_t)ll, HAL_MAX_DELAY);
340037fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340037fc:	b29a      	uxth	r2, r3
340037fe:	f107 010c 	add.w	r1, r7, #12
34003802:	f04f 33ff 	mov.w	r3, #4294967295
34003806:	482e      	ldr	r0, [pc, #184]	@ (340038c0 <PC_STREAM_SendDetections+0xec>)
34003808:	f016 fc28 	bl	3401a05c <HAL_UART_Transmit>
    }
    for(int i=0; i<detections->nb_detect; i++)
3400380c:	2300      	movs	r3, #0
3400380e:	657b      	str	r3, [r7, #84]	@ 0x54
34003810:	e044      	b.n	3400389c <PC_STREAM_SendDetections+0xc8>
    {
        const od_pp_outBuffer_t *r = &detections->pOutBuff[i];
34003812:	687b      	ldr	r3, [r7, #4]
34003814:	6819      	ldr	r1, [r3, #0]
34003816:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34003818:	4613      	mov	r3, r2
3400381a:	005b      	lsls	r3, r3, #1
3400381c:	4413      	add	r3, r2
3400381e:	00db      	lsls	r3, r3, #3
34003820:	440b      	add	r3, r1
34003822:	64fb      	str	r3, [r7, #76]	@ 0x4c
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
34003824:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34003826:	695a      	ldr	r2, [r3, #20]
                      (double)r->x_center, (double)r->y_center, (double)r->width,
34003828:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400382a:	edd3 7a00 	vldr	s15, [r3]
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
3400382e:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
                      (double)r->x_center, (double)r->y_center, (double)r->width,
34003832:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34003834:	edd3 6a01 	vldr	s13, [r3, #4]
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
34003838:	eeb7 6ae6 	vcvt.f64.f32	d6, s13
                      (double)r->x_center, (double)r->y_center, (double)r->width,
3400383c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400383e:	edd3 5a02 	vldr	s11, [r3, #8]
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
34003842:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
                      (double)r->height, (double)r->conf);
34003846:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34003848:	edd3 4a03 	vldr	s9, [r3, #12]
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
3400384c:	eeb7 4ae4 	vcvt.f64.f32	d4, s9
                      (double)r->height, (double)r->conf);
34003850:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34003852:	edd3 3a04 	vldr	s7, [r3, #16]
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
34003856:	eeb7 3ae3 	vcvt.f64.f32	d3, s7
3400385a:	f107 000c 	add.w	r0, r7, #12
3400385e:	ed8d 3b08 	vstr	d3, [sp, #32]
34003862:	ed8d 4b06 	vstr	d4, [sp, #24]
34003866:	ed8d 5b04 	vstr	d5, [sp, #16]
3400386a:	ed8d 6b02 	vstr	d6, [sp, #8]
3400386e:	ed8d 7b00 	vstr	d7, [sp]
34003872:	4613      	mov	r3, r2
34003874:	4a13      	ldr	r2, [pc, #76]	@ (340038c4 <PC_STREAM_SendDetections+0xf0>)
34003876:	2140      	movs	r1, #64	@ 0x40
34003878:	f01d fd84 	bl	34021384 <sniprintf>
3400387c:	6538      	str	r0, [r7, #80]	@ 0x50
        if (ll > 0)
3400387e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34003880:	2b00      	cmp	r3, #0
34003882:	dd08      	ble.n	34003896 <PC_STREAM_SendDetections+0xc2>
        {
            HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)line, (uint16_t)ll, HAL_MAX_DELAY);
34003884:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34003886:	b29a      	uxth	r2, r3
34003888:	f107 010c 	add.w	r1, r7, #12
3400388c:	f04f 33ff 	mov.w	r3, #4294967295
34003890:	480b      	ldr	r0, [pc, #44]	@ (340038c0 <PC_STREAM_SendDetections+0xec>)
34003892:	f016 fbe3 	bl	3401a05c <HAL_UART_Transmit>
    for(int i=0; i<detections->nb_detect; i++)
34003896:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34003898:	3301      	adds	r3, #1
3400389a:	657b      	str	r3, [r7, #84]	@ 0x54
3400389c:	687b      	ldr	r3, [r7, #4]
3400389e:	685b      	ldr	r3, [r3, #4]
340038a0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
340038a2:	429a      	cmp	r2, r3
340038a4:	dbb5      	blt.n	34003812 <PC_STREAM_SendDetections+0x3e>
        }
    }
    static const char end_marker[] = "END\n";
    HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)end_marker, sizeof(end_marker) - 1, HAL_MAX_DELAY);
340038a6:	f04f 33ff 	mov.w	r3, #4294967295
340038aa:	2204      	movs	r2, #4
340038ac:	4906      	ldr	r1, [pc, #24]	@ (340038c8 <PC_STREAM_SendDetections+0xf4>)
340038ae:	4804      	ldr	r0, [pc, #16]	@ (340038c0 <PC_STREAM_SendDetections+0xec>)
340038b0:	f016 fbd4 	bl	3401a05c <HAL_UART_Transmit>
}
340038b4:	bf00      	nop
340038b6:	3758      	adds	r7, #88	@ 0x58
340038b8:	46bd      	mov	sp, r7
340038ba:	bd80      	pop	{r7, pc}
340038bc:	34023f2c 	.word	0x34023f2c
340038c0:	340538a0 	.word	0x340538a0
340038c4:	34023f3c 	.word	0x34023f3c
340038c8:	34032118 	.word	0x34032118

340038cc <PC_STREAM_ReceiveImage>:

int PC_STREAM_ReceiveImage(uint8_t *buffer, uint32_t length)
{
340038cc:	b580      	push	{r7, lr}
340038ce:	b086      	sub	sp, #24
340038d0:	af00      	add	r7, sp, #0
340038d2:	6078      	str	r0, [r7, #4]
340038d4:	6039      	str	r1, [r7, #0]
    HAL_StatusTypeDef st = HAL_OK;
340038d6:	2300      	movs	r3, #0
340038d8:	75fb      	strb	r3, [r7, #23]
    uint32_t remaining = length;
340038da:	683b      	ldr	r3, [r7, #0]
340038dc:	613b      	str	r3, [r7, #16]
    uint8_t *ptr = buffer;
340038de:	687b      	ldr	r3, [r7, #4]
340038e0:	60fb      	str	r3, [r7, #12]

    while (remaining > 0 && st == HAL_OK)
340038e2:	e01d      	b.n	34003920 <PC_STREAM_ReceiveImage+0x54>
    {
        /* HAL UART API takes a uint16_t size parameter */
        uint16_t chunk = (remaining > 0xFFFFU) ? 0xFFFFU : (uint16_t)remaining;
340038e4:	693b      	ldr	r3, [r7, #16]
340038e6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340038ea:	d202      	bcs.n	340038f2 <PC_STREAM_ReceiveImage+0x26>
340038ec:	693b      	ldr	r3, [r7, #16]
340038ee:	b29b      	uxth	r3, r3
340038f0:	e001      	b.n	340038f6 <PC_STREAM_ReceiveImage+0x2a>
340038f2:	f64f 73ff 	movw	r3, #65535	@ 0xffff
340038f6:	817b      	strh	r3, [r7, #10]
        st = HAL_UART_Receive(&hcom_uart[COM1], ptr, chunk, HAL_MAX_DELAY);
340038f8:	897a      	ldrh	r2, [r7, #10]
340038fa:	f04f 33ff 	mov.w	r3, #4294967295
340038fe:	68f9      	ldr	r1, [r7, #12]
34003900:	4812      	ldr	r0, [pc, #72]	@ (3400394c <PC_STREAM_ReceiveImage+0x80>)
34003902:	f016 fc39 	bl	3401a178 <HAL_UART_Receive>
34003906:	4603      	mov	r3, r0
34003908:	75fb      	strb	r3, [r7, #23]
        if (st != HAL_OK)
3400390a:	7dfb      	ldrb	r3, [r7, #23]
3400390c:	2b00      	cmp	r3, #0
3400390e:	d10e      	bne.n	3400392e <PC_STREAM_ReceiveImage+0x62>
        {
            break;
        }
        ptr += chunk;
34003910:	897b      	ldrh	r3, [r7, #10]
34003912:	68fa      	ldr	r2, [r7, #12]
34003914:	4413      	add	r3, r2
34003916:	60fb      	str	r3, [r7, #12]
        remaining -= chunk;
34003918:	897b      	ldrh	r3, [r7, #10]
3400391a:	693a      	ldr	r2, [r7, #16]
3400391c:	1ad3      	subs	r3, r2, r3
3400391e:	613b      	str	r3, [r7, #16]
    while (remaining > 0 && st == HAL_OK)
34003920:	693b      	ldr	r3, [r7, #16]
34003922:	2b00      	cmp	r3, #0
34003924:	d004      	beq.n	34003930 <PC_STREAM_ReceiveImage+0x64>
34003926:	7dfb      	ldrb	r3, [r7, #23]
34003928:	2b00      	cmp	r3, #0
3400392a:	d0db      	beq.n	340038e4 <PC_STREAM_ReceiveImage+0x18>
3400392c:	e000      	b.n	34003930 <PC_STREAM_ReceiveImage+0x64>
            break;
3400392e:	bf00      	nop
    }

    return (st == HAL_OK && remaining == 0U) ? 0 : -1;
34003930:	7dfb      	ldrb	r3, [r7, #23]
34003932:	2b00      	cmp	r3, #0
34003934:	d104      	bne.n	34003940 <PC_STREAM_ReceiveImage+0x74>
34003936:	693b      	ldr	r3, [r7, #16]
34003938:	2b00      	cmp	r3, #0
3400393a:	d101      	bne.n	34003940 <PC_STREAM_ReceiveImage+0x74>
3400393c:	2300      	movs	r3, #0
3400393e:	e001      	b.n	34003944 <PC_STREAM_ReceiveImage+0x78>
34003940:	f04f 33ff 	mov.w	r3, #4294967295
}
34003944:	4618      	mov	r0, r3
34003946:	3718      	adds	r7, #24
34003948:	46bd      	mov	sp, r7
3400394a:	bd80      	pop	{r7, pc}
3400394c:	340538a0 	.word	0x340538a0

34003950 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
34003950:	b480      	push	{r7}
34003952:	af00      	add	r7, sp, #0
}
34003954:	bf00      	nop
34003956:	46bd      	mov	sp, r7
34003958:	f85d 7b04 	ldr.w	r7, [sp], #4
3400395c:	4770      	bx	lr

3400395e <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
3400395e:	b480      	push	{r7}
34003960:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
34003962:	bf00      	nop
34003964:	e7fd      	b.n	34003962 <HardFault_Handler+0x4>

34003966 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
34003966:	b480      	push	{r7}
34003968:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
3400396a:	bf00      	nop
3400396c:	e7fd      	b.n	3400396a <MemManage_Handler+0x4>

3400396e <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
3400396e:	b480      	push	{r7}
34003970:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
34003972:	bf00      	nop
34003974:	e7fd      	b.n	34003972 <BusFault_Handler+0x4>

34003976 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
34003976:	b480      	push	{r7}
34003978:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
3400397a:	bf00      	nop
3400397c:	e7fd      	b.n	3400397a <UsageFault_Handler+0x4>

3400397e <SecureFault_Handler>:
  * @brief  This function handles Secure Fault exception.
  * @param  None
  * @retval None
  */
void SecureFault_Handler(void)
{
3400397e:	b480      	push	{r7}
34003980:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Secure Fault exception occurs */
  while (1)
34003982:	bf00      	nop
34003984:	e7fd      	b.n	34003982 <SecureFault_Handler+0x4>

34003986 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
34003986:	b480      	push	{r7}
34003988:	af00      	add	r7, sp, #0
}
3400398a:	bf00      	nop
3400398c:	46bd      	mov	sp, r7
3400398e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003992:	4770      	bx	lr

34003994 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
34003994:	b480      	push	{r7}
34003996:	af00      	add	r7, sp, #0
  while (1)
34003998:	bf00      	nop
3400399a:	e7fd      	b.n	34003998 <DebugMon_Handler+0x4>

3400399c <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
3400399c:	b480      	push	{r7}
3400399e:	af00      	add	r7, sp, #0
  while (1)
340039a0:	bf00      	nop
340039a2:	e7fd      	b.n	340039a0 <PendSV_Handler+0x4>

340039a4 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
340039a4:	b580      	push	{r7, lr}
340039a6:	af00      	add	r7, sp, #0
  HAL_IncTick();
340039a8:	f003 fe06 	bl	340075b8 <HAL_IncTick>
}
340039ac:	bf00      	nop
340039ae:	bd80      	pop	{r7, pc}

340039b0 <CSI_IRQHandler>:
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32n6xx.s).                                               */
/******************************************************************************/
void CSI_IRQHandler(void)
{
340039b0:	b580      	push	{r7, lr}
340039b2:	b082      	sub	sp, #8
340039b4:	af00      	add	r7, sp, #0
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
340039b6:	f018 fc79 	bl	3401c2ac <CMW_CAMERA_GetDCMIPPHandle>
340039ba:	6078      	str	r0, [r7, #4]
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
340039bc:	6878      	ldr	r0, [r7, #4]
340039be:	f004 fb3d 	bl	3400803c <HAL_DCMIPP_CSI_IRQHandler>
}
340039c2:	bf00      	nop
340039c4:	3708      	adds	r7, #8
340039c6:	46bd      	mov	sp, r7
340039c8:	bd80      	pop	{r7, pc}

340039ca <DCMIPP_IRQHandler>:

void DCMIPP_IRQHandler(void)
{
340039ca:	b580      	push	{r7, lr}
340039cc:	b082      	sub	sp, #8
340039ce:	af00      	add	r7, sp, #0
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
340039d0:	f018 fc6c 	bl	3401c2ac <CMW_CAMERA_GetDCMIPPHandle>
340039d4:	6078      	str	r0, [r7, #4]
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
340039d6:	6878      	ldr	r0, [r7, #4]
340039d8:	f004 f94c 	bl	34007c74 <HAL_DCMIPP_IRQHandler>
340039dc:	bf00      	nop
340039de:	3708      	adds	r7, #8
340039e0:	46bd      	mov	sp, r7
340039e2:	bd80      	pop	{r7, pc}

340039e4 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
340039e4:	b480      	push	{r7}
340039e6:	af00      	add	r7, sp, #0
  return 1;
340039e8:	2301      	movs	r3, #1
}
340039ea:	4618      	mov	r0, r3
340039ec:	46bd      	mov	sp, r7
340039ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340039f2:	4770      	bx	lr

340039f4 <_kill>:

int _kill(int pid, int sig)
{
340039f4:	b580      	push	{r7, lr}
340039f6:	b082      	sub	sp, #8
340039f8:	af00      	add	r7, sp, #0
340039fa:	6078      	str	r0, [r7, #4]
340039fc:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
340039fe:	f01e f83d 	bl	34021a7c <__errno>
34003a02:	4603      	mov	r3, r0
34003a04:	2216      	movs	r2, #22
34003a06:	601a      	str	r2, [r3, #0]
  return -1;
34003a08:	f04f 33ff 	mov.w	r3, #4294967295
}
34003a0c:	4618      	mov	r0, r3
34003a0e:	3708      	adds	r7, #8
34003a10:	46bd      	mov	sp, r7
34003a12:	bd80      	pop	{r7, pc}

34003a14 <_exit>:

void _exit (int status)
{
34003a14:	b580      	push	{r7, lr}
34003a16:	b082      	sub	sp, #8
34003a18:	af00      	add	r7, sp, #0
34003a1a:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
34003a1c:	f04f 31ff 	mov.w	r1, #4294967295
34003a20:	6878      	ldr	r0, [r7, #4]
34003a22:	f7ff ffe7 	bl	340039f4 <_kill>
  while (1) {}    /* Make sure we hang here */
34003a26:	bf00      	nop
34003a28:	e7fd      	b.n	34003a26 <_exit+0x12>

34003a2a <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
34003a2a:	b580      	push	{r7, lr}
34003a2c:	b086      	sub	sp, #24
34003a2e:	af00      	add	r7, sp, #0
34003a30:	60f8      	str	r0, [r7, #12]
34003a32:	60b9      	str	r1, [r7, #8]
34003a34:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34003a36:	2300      	movs	r3, #0
34003a38:	617b      	str	r3, [r7, #20]
34003a3a:	e00a      	b.n	34003a52 <_read+0x28>
  {
    *ptr++ = __io_getchar();
34003a3c:	f3af 8000 	nop.w
34003a40:	4601      	mov	r1, r0
34003a42:	68bb      	ldr	r3, [r7, #8]
34003a44:	1c5a      	adds	r2, r3, #1
34003a46:	60ba      	str	r2, [r7, #8]
34003a48:	b2ca      	uxtb	r2, r1
34003a4a:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34003a4c:	697b      	ldr	r3, [r7, #20]
34003a4e:	3301      	adds	r3, #1
34003a50:	617b      	str	r3, [r7, #20]
34003a52:	697a      	ldr	r2, [r7, #20]
34003a54:	687b      	ldr	r3, [r7, #4]
34003a56:	429a      	cmp	r2, r3
34003a58:	dbf0      	blt.n	34003a3c <_read+0x12>
  }

  return len;
34003a5a:	687b      	ldr	r3, [r7, #4]
}
34003a5c:	4618      	mov	r0, r3
34003a5e:	3718      	adds	r7, #24
34003a60:	46bd      	mov	sp, r7
34003a62:	bd80      	pop	{r7, pc}

34003a64 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
34003a64:	b580      	push	{r7, lr}
34003a66:	b086      	sub	sp, #24
34003a68:	af00      	add	r7, sp, #0
34003a6a:	60f8      	str	r0, [r7, #12]
34003a6c:	60b9      	str	r1, [r7, #8]
34003a6e:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34003a70:	2300      	movs	r3, #0
34003a72:	617b      	str	r3, [r7, #20]
34003a74:	e009      	b.n	34003a8a <_write+0x26>
  {
    __io_putchar(*ptr++);
34003a76:	68bb      	ldr	r3, [r7, #8]
34003a78:	1c5a      	adds	r2, r3, #1
34003a7a:	60ba      	str	r2, [r7, #8]
34003a7c:	781b      	ldrb	r3, [r3, #0]
34003a7e:	4618      	mov	r0, r3
34003a80:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34003a84:	697b      	ldr	r3, [r7, #20]
34003a86:	3301      	adds	r3, #1
34003a88:	617b      	str	r3, [r7, #20]
34003a8a:	697a      	ldr	r2, [r7, #20]
34003a8c:	687b      	ldr	r3, [r7, #4]
34003a8e:	429a      	cmp	r2, r3
34003a90:	dbf1      	blt.n	34003a76 <_write+0x12>
  }
  return len;
34003a92:	687b      	ldr	r3, [r7, #4]
}
34003a94:	4618      	mov	r0, r3
34003a96:	3718      	adds	r7, #24
34003a98:	46bd      	mov	sp, r7
34003a9a:	bd80      	pop	{r7, pc}

34003a9c <_close>:

int _close(int file)
{
34003a9c:	b480      	push	{r7}
34003a9e:	b083      	sub	sp, #12
34003aa0:	af00      	add	r7, sp, #0
34003aa2:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
34003aa4:	f04f 33ff 	mov.w	r3, #4294967295
}
34003aa8:	4618      	mov	r0, r3
34003aaa:	370c      	adds	r7, #12
34003aac:	46bd      	mov	sp, r7
34003aae:	f85d 7b04 	ldr.w	r7, [sp], #4
34003ab2:	4770      	bx	lr

34003ab4 <_fstat>:


int _fstat(int file, struct stat *st)
{
34003ab4:	b480      	push	{r7}
34003ab6:	b083      	sub	sp, #12
34003ab8:	af00      	add	r7, sp, #0
34003aba:	6078      	str	r0, [r7, #4]
34003abc:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
34003abe:	683b      	ldr	r3, [r7, #0]
34003ac0:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34003ac4:	605a      	str	r2, [r3, #4]
  return 0;
34003ac6:	2300      	movs	r3, #0
}
34003ac8:	4618      	mov	r0, r3
34003aca:	370c      	adds	r7, #12
34003acc:	46bd      	mov	sp, r7
34003ace:	f85d 7b04 	ldr.w	r7, [sp], #4
34003ad2:	4770      	bx	lr

34003ad4 <_isatty>:

int _isatty(int file)
{
34003ad4:	b480      	push	{r7}
34003ad6:	b083      	sub	sp, #12
34003ad8:	af00      	add	r7, sp, #0
34003ada:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
34003adc:	2301      	movs	r3, #1
}
34003ade:	4618      	mov	r0, r3
34003ae0:	370c      	adds	r7, #12
34003ae2:	46bd      	mov	sp, r7
34003ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
34003ae8:	4770      	bx	lr

34003aea <_lseek>:

int _lseek(int file, int ptr, int dir)
{
34003aea:	b480      	push	{r7}
34003aec:	b085      	sub	sp, #20
34003aee:	af00      	add	r7, sp, #0
34003af0:	60f8      	str	r0, [r7, #12]
34003af2:	60b9      	str	r1, [r7, #8]
34003af4:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
34003af6:	2300      	movs	r3, #0
}
34003af8:	4618      	mov	r0, r3
34003afa:	3714      	adds	r7, #20
34003afc:	46bd      	mov	sp, r7
34003afe:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b02:	4770      	bx	lr

34003b04 <LL_MEM_EnableClock>:
{
34003b04:	b480      	push	{r7}
34003b06:	b085      	sub	sp, #20
34003b08:	af00      	add	r7, sp, #0
34003b0a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->MEMENSR, Memories);
34003b0c:	4a07      	ldr	r2, [pc, #28]	@ (34003b2c <LL_MEM_EnableClock+0x28>)
34003b0e:	687b      	ldr	r3, [r7, #4]
34003b10:	f8c2 3a4c 	str.w	r3, [r2, #2636]	@ 0xa4c
  tmpreg = READ_REG(RCC->MEMENR);
34003b14:	4b05      	ldr	r3, [pc, #20]	@ (34003b2c <LL_MEM_EnableClock+0x28>)
34003b16:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
34003b1a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003b1c:	68fb      	ldr	r3, [r7, #12]
}
34003b1e:	bf00      	nop
34003b20:	3714      	adds	r7, #20
34003b22:	46bd      	mov	sp, r7
34003b24:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b28:	4770      	bx	lr
34003b2a:	bf00      	nop
34003b2c:	56028000 	.word	0x56028000

34003b30 <LL_MEM_EnableClockLowPower>:
{
34003b30:	b480      	push	{r7}
34003b32:	b085      	sub	sp, #20
34003b34:	af00      	add	r7, sp, #0
34003b36:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->MEMLPENSR, Memories);
34003b38:	4a07      	ldr	r2, [pc, #28]	@ (34003b58 <LL_MEM_EnableClockLowPower+0x28>)
34003b3a:	687b      	ldr	r3, [r7, #4]
34003b3c:	f8c2 3a8c 	str.w	r3, [r2, #2700]	@ 0xa8c
  tmpreg = READ_REG(RCC->MEMLPENR);
34003b40:	4b05      	ldr	r3, [pc, #20]	@ (34003b58 <LL_MEM_EnableClockLowPower+0x28>)
34003b42:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
34003b46:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003b48:	68fb      	ldr	r3, [r7, #12]
}
34003b4a:	bf00      	nop
34003b4c:	3714      	adds	r7, #20
34003b4e:	46bd      	mov	sp, r7
34003b50:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b54:	4770      	bx	lr
34003b56:	bf00      	nop
34003b58:	56028000 	.word	0x56028000

34003b5c <LL_AHB2_GRP1_EnableClock>:
{
34003b5c:	b480      	push	{r7}
34003b5e:	b085      	sub	sp, #20
34003b60:	af00      	add	r7, sp, #0
34003b62:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB2ENSR, Periphs);
34003b64:	4a07      	ldr	r2, [pc, #28]	@ (34003b84 <LL_AHB2_GRP1_EnableClock+0x28>)
34003b66:	687b      	ldr	r3, [r7, #4]
34003b68:	f8c2 3a54 	str.w	r3, [r2, #2644]	@ 0xa54
  tmpreg = READ_REG(RCC->AHB2ENR);
34003b6c:	4b05      	ldr	r3, [pc, #20]	@ (34003b84 <LL_AHB2_GRP1_EnableClock+0x28>)
34003b6e:	f8d3 3254 	ldr.w	r3, [r3, #596]	@ 0x254
34003b72:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003b74:	68fb      	ldr	r3, [r7, #12]
}
34003b76:	bf00      	nop
34003b78:	3714      	adds	r7, #20
34003b7a:	46bd      	mov	sp, r7
34003b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b80:	4770      	bx	lr
34003b82:	bf00      	nop
34003b84:	56028000 	.word	0x56028000

34003b88 <LL_AHB3_GRP1_EnableClock>:
{
34003b88:	b480      	push	{r7}
34003b8a:	b085      	sub	sp, #20
34003b8c:	af00      	add	r7, sp, #0
34003b8e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34003b90:	4a07      	ldr	r2, [pc, #28]	@ (34003bb0 <LL_AHB3_GRP1_EnableClock+0x28>)
34003b92:	687b      	ldr	r3, [r7, #4]
34003b94:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34003b98:	4b05      	ldr	r3, [pc, #20]	@ (34003bb0 <LL_AHB3_GRP1_EnableClock+0x28>)
34003b9a:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
34003b9e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003ba0:	68fb      	ldr	r3, [r7, #12]
}
34003ba2:	bf00      	nop
34003ba4:	3714      	adds	r7, #20
34003ba6:	46bd      	mov	sp, r7
34003ba8:	f85d 7b04 	ldr.w	r7, [sp], #4
34003bac:	4770      	bx	lr
34003bae:	bf00      	nop
34003bb0:	56028000 	.word	0x56028000

34003bb4 <LL_AHB3_GRP1_ForceReset>:
{
34003bb4:	b480      	push	{r7}
34003bb6:	b083      	sub	sp, #12
34003bb8:	af00      	add	r7, sp, #0
34003bba:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3RSTSR, Periphs);
34003bbc:	4a04      	ldr	r2, [pc, #16]	@ (34003bd0 <LL_AHB3_GRP1_ForceReset+0x1c>)
34003bbe:	687b      	ldr	r3, [r7, #4]
34003bc0:	f8c2 3a18 	str.w	r3, [r2, #2584]	@ 0xa18
}
34003bc4:	bf00      	nop
34003bc6:	370c      	adds	r7, #12
34003bc8:	46bd      	mov	sp, r7
34003bca:	f85d 7b04 	ldr.w	r7, [sp], #4
34003bce:	4770      	bx	lr
34003bd0:	56028000 	.word	0x56028000

34003bd4 <LL_AHB3_GRP1_ReleaseReset>:
{
34003bd4:	b480      	push	{r7}
34003bd6:	b083      	sub	sp, #12
34003bd8:	af00      	add	r7, sp, #0
34003bda:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3RSTCR, Periphs);
34003bdc:	4b06      	ldr	r3, [pc, #24]	@ (34003bf8 <LL_AHB3_GRP1_ReleaseReset+0x24>)
34003bde:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003be2:	461a      	mov	r2, r3
34003be4:	687b      	ldr	r3, [r7, #4]
34003be6:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
}
34003bea:	bf00      	nop
34003bec:	370c      	adds	r7, #12
34003bee:	46bd      	mov	sp, r7
34003bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
34003bf4:	4770      	bx	lr
34003bf6:	bf00      	nop
34003bf8:	56028000 	.word	0x56028000

34003bfc <LL_AHB5_GRP1_EnableClock>:
{
34003bfc:	b480      	push	{r7}
34003bfe:	b085      	sub	sp, #20
34003c00:	af00      	add	r7, sp, #0
34003c02:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34003c04:	4a07      	ldr	r2, [pc, #28]	@ (34003c24 <LL_AHB5_GRP1_EnableClock+0x28>)
34003c06:	687b      	ldr	r3, [r7, #4]
34003c08:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34003c0c:	4b05      	ldr	r3, [pc, #20]	@ (34003c24 <LL_AHB5_GRP1_EnableClock+0x28>)
34003c0e:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34003c12:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003c14:	68fb      	ldr	r3, [r7, #12]
}
34003c16:	bf00      	nop
34003c18:	3714      	adds	r7, #20
34003c1a:	46bd      	mov	sp, r7
34003c1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c20:	4770      	bx	lr
34003c22:	bf00      	nop
34003c24:	56028000 	.word	0x56028000

34003c28 <LL_AHB5_GRP1_ForceReset>:
{
34003c28:	b480      	push	{r7}
34003c2a:	b083      	sub	sp, #12
34003c2c:	af00      	add	r7, sp, #0
34003c2e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34003c30:	4a04      	ldr	r2, [pc, #16]	@ (34003c44 <LL_AHB5_GRP1_ForceReset+0x1c>)
34003c32:	687b      	ldr	r3, [r7, #4]
34003c34:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34003c38:	bf00      	nop
34003c3a:	370c      	adds	r7, #12
34003c3c:	46bd      	mov	sp, r7
34003c3e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c42:	4770      	bx	lr
34003c44:	56028000 	.word	0x56028000

34003c48 <LL_AHB5_GRP1_ReleaseReset>:
{
34003c48:	b480      	push	{r7}
34003c4a:	b083      	sub	sp, #12
34003c4c:	af00      	add	r7, sp, #0
34003c4e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34003c50:	4b06      	ldr	r3, [pc, #24]	@ (34003c6c <LL_AHB5_GRP1_ReleaseReset+0x24>)
34003c52:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003c56:	461a      	mov	r2, r3
34003c58:	687b      	ldr	r3, [r7, #4]
34003c5a:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34003c5e:	bf00      	nop
34003c60:	370c      	adds	r7, #12
34003c62:	46bd      	mov	sp, r7
34003c64:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c68:	4770      	bx	lr
34003c6a:	bf00      	nop
34003c6c:	56028000 	.word	0x56028000

34003c70 <LL_AHB5_GRP1_EnableClockLowPower>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003c70:	b480      	push	{r7}
34003c72:	b085      	sub	sp, #20
34003c74:	af00      	add	r7, sp, #0
34003c76:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
34003c78:	4a07      	ldr	r2, [pc, #28]	@ (34003c98 <LL_AHB5_GRP1_EnableClockLowPower+0x28>)
34003c7a:	687b      	ldr	r3, [r7, #4]
34003c7c:	f8c2 3aa0 	str.w	r3, [r2, #2720]	@ 0xaa0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5LPENR);
34003c80:	4b05      	ldr	r3, [pc, #20]	@ (34003c98 <LL_AHB5_GRP1_EnableClockLowPower+0x28>)
34003c82:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
34003c86:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003c88:	68fb      	ldr	r3, [r7, #12]
}
34003c8a:	bf00      	nop
34003c8c:	3714      	adds	r7, #20
34003c8e:	46bd      	mov	sp, r7
34003c90:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c94:	4770      	bx	lr
34003c96:	bf00      	nop
34003c98:	56028000 	.word	0x56028000

34003c9c <LL_APB5_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003c9c:	b480      	push	{r7}
34003c9e:	b085      	sub	sp, #20
34003ca0:	af00      	add	r7, sp, #0
34003ca2:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34003ca4:	4a07      	ldr	r2, [pc, #28]	@ (34003cc4 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
34003ca6:	687b      	ldr	r3, [r7, #4]
34003ca8:	f8c2 3abc 	str.w	r3, [r2, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
34003cac:	4b05      	ldr	r3, [pc, #20]	@ (34003cc4 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
34003cae:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
34003cb2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003cb4:	68fb      	ldr	r3, [r7, #12]
}
34003cb6:	bf00      	nop
34003cb8:	3714      	adds	r7, #20
34003cba:	46bd      	mov	sp, r7
34003cbc:	f85d 7b04 	ldr.w	r7, [sp], #4
34003cc0:	4770      	bx	lr
34003cc2:	bf00      	nop
34003cc4:	56028000 	.word	0x56028000

34003cc8 <NPURam_enable>:
#include "stm32n6xx_hal_rif.h"
#include "npu_cache.h"
#include "stm32n6570_discovery.h"

void NPURam_enable(void)
{
34003cc8:	b580      	push	{r7, lr}
34003cca:	b084      	sub	sp, #16
34003ccc:	af00      	add	r7, sp, #0
  __HAL_RCC_NPU_CLK_ENABLE();
34003cce:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34003cd2:	f7ff ff93 	bl	34003bfc <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_NPU_FORCE_RESET();
34003cd6:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34003cda:	f7ff ffa5 	bl	34003c28 <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_NPU_RELEASE_RESET();
34003cde:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34003ce2:	f7ff ffb1 	bl	34003c48 <LL_AHB5_GRP1_ReleaseReset>

  /* Enable NPU RAMs (4x448KB) */
  __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
34003ce6:	2001      	movs	r0, #1
34003ce8:	f7ff ff0c 	bl	34003b04 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
34003cec:	2002      	movs	r0, #2
34003cee:	f7ff ff09 	bl	34003b04 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
34003cf2:	2004      	movs	r0, #4
34003cf4:	f7ff ff06 	bl	34003b04 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
34003cf8:	2008      	movs	r0, #8
34003cfa:	f7ff ff03 	bl	34003b04 <LL_MEM_EnableClock>
  __HAL_RCC_RAMCFG_CLK_ENABLE();
34003cfe:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34003d02:	f7ff ff2b 	bl	34003b5c <LL_AHB2_GRP1_EnableClock>
  RAMCFG_HandleTypeDef hramcfg = {0};
34003d06:	1d3b      	adds	r3, r7, #4
34003d08:	2200      	movs	r2, #0
34003d0a:	601a      	str	r2, [r3, #0]
34003d0c:	605a      	str	r2, [r3, #4]
34003d0e:	609a      	str	r2, [r3, #8]
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
34003d10:	4b0d      	ldr	r3, [pc, #52]	@ (34003d48 <NPURam_enable+0x80>)
34003d12:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34003d14:	1d3b      	adds	r3, r7, #4
34003d16:	4618      	mov	r0, r3
34003d18:	f007 fa08 	bl	3400b12c <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
34003d1c:	4b0b      	ldr	r3, [pc, #44]	@ (34003d4c <NPURam_enable+0x84>)
34003d1e:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34003d20:	1d3b      	adds	r3, r7, #4
34003d22:	4618      	mov	r0, r3
34003d24:	f007 fa02 	bl	3400b12c <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
34003d28:	4b09      	ldr	r3, [pc, #36]	@ (34003d50 <NPURam_enable+0x88>)
34003d2a:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34003d2c:	1d3b      	adds	r3, r7, #4
34003d2e:	4618      	mov	r0, r3
34003d30:	f007 f9fc 	bl	3400b12c <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
34003d34:	4b07      	ldr	r3, [pc, #28]	@ (34003d54 <NPURam_enable+0x8c>)
34003d36:	607b      	str	r3, [r7, #4]
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34003d38:	1d3b      	adds	r3, r7, #4
34003d3a:	4618      	mov	r0, r3
34003d3c:	f007 f9f6 	bl	3400b12c <HAL_RAMCFG_EnableAXISRAM>
}
34003d40:	bf00      	nop
34003d42:	3710      	adds	r7, #16
34003d44:	46bd      	mov	sp, r7
34003d46:	bd80      	pop	{r7, pc}
34003d48:	52023100 	.word	0x52023100
34003d4c:	52023180 	.word	0x52023180
34003d50:	52023200 	.word	0x52023200
34003d54:	52023280 	.word	0x52023280

34003d58 <set_clk_sleep_mode>:

void set_clk_sleep_mode(void)
{
34003d58:	b580      	push	{r7, lr}
34003d5a:	af00      	add	r7, sp, #0
  /* Keep required clocks active during sleep */
  __HAL_RCC_XSPI1_CLK_SLEEP_ENABLE();
34003d5c:	2020      	movs	r0, #32
34003d5e:	f7ff ff87 	bl	34003c70 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_XSPI2_CLK_SLEEP_ENABLE();
34003d62:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34003d66:	f7ff ff83 	bl	34003c70 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_NPU_CLK_SLEEP_ENABLE();
34003d6a:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
34003d6e:	f7ff ff7f 	bl	34003c70 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CACHEAXI_CLK_SLEEP_ENABLE();
34003d72:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34003d76:	f7ff ff7b 	bl	34003c70 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_LTDC_CLK_SLEEP_ENABLE();
34003d7a:	2002      	movs	r0, #2
34003d7c:	f7ff ff8e 	bl	34003c9c <LL_APB5_GRP1_EnableClockLowPower>
  __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE();
34003d80:	2002      	movs	r0, #2
34003d82:	f7ff ff75 	bl	34003c70 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_DCMIPP_CLK_SLEEP_ENABLE();
34003d86:	2004      	movs	r0, #4
34003d88:	f7ff ff88 	bl	34003c9c <LL_APB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CSI_CLK_SLEEP_ENABLE();
34003d8c:	2040      	movs	r0, #64	@ 0x40
34003d8e:	f7ff ff85 	bl	34003c9c <LL_APB5_GRP1_EnableClockLowPower>

  __HAL_RCC_FLEXRAM_MEM_CLK_SLEEP_ENABLE();
34003d92:	f44f 7000 	mov.w	r0, #512	@ 0x200
34003d96:	f7ff fecb 	bl	34003b30 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM1_MEM_CLK_SLEEP_ENABLE();
34003d9a:	2080      	movs	r0, #128	@ 0x80
34003d9c:	f7ff fec8 	bl	34003b30 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM2_MEM_CLK_SLEEP_ENABLE();
34003da0:	f44f 7080 	mov.w	r0, #256	@ 0x100
34003da4:	f7ff fec4 	bl	34003b30 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM3_MEM_CLK_SLEEP_ENABLE();
34003da8:	2001      	movs	r0, #1
34003daa:	f7ff fec1 	bl	34003b30 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM4_MEM_CLK_SLEEP_ENABLE();
34003dae:	2002      	movs	r0, #2
34003db0:	f7ff febe 	bl	34003b30 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM5_MEM_CLK_SLEEP_ENABLE();
34003db4:	2004      	movs	r0, #4
34003db6:	f7ff febb 	bl	34003b30 <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM6_MEM_CLK_SLEEP_ENABLE();
34003dba:	2008      	movs	r0, #8
34003dbc:	f7ff feb8 	bl	34003b30 <LL_MEM_EnableClockLowPower>
}
34003dc0:	bf00      	nop
34003dc2:	bd80      	pop	{r7, pc}

34003dc4 <NPUCache_config>:

void NPUCache_config(void)
{
34003dc4:	b580      	push	{r7, lr}
34003dc6:	af00      	add	r7, sp, #0
  npu_cache_init();
34003dc8:	f7fd fbf8 	bl	340015bc <npu_cache_init>
  npu_cache_enable();
34003dcc:	f7fd fc04 	bl	340015d8 <npu_cache_enable>
}
34003dd0:	bf00      	nop
34003dd2:	bd80      	pop	{r7, pc}

34003dd4 <Security_Config>:

void Security_Config(void)
{
34003dd4:	b580      	push	{r7, lr}
34003dd6:	b082      	sub	sp, #8
34003dd8:	af00      	add	r7, sp, #0
  __HAL_RCC_RIFSC_CLK_ENABLE();
34003dda:	f44f 7000 	mov.w	r0, #512	@ 0x200
34003dde:	f7ff fed3 	bl	34003b88 <LL_AHB3_GRP1_EnableClock>
  RIMC_MasterConfig_t RIMC_master = {0};
34003de2:	463b      	mov	r3, r7
34003de4:	2200      	movs	r2, #0
34003de6:	601a      	str	r2, [r3, #0]
34003de8:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34003dea:	2302      	movs	r3, #2
34003dec:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34003dee:	2303      	movs	r3, #3
34003df0:	607b      	str	r3, [r7, #4]
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34003df2:	463b      	mov	r3, r7
34003df4:	4619      	mov	r1, r3
34003df6:	2001      	movs	r0, #1
34003df8:	f015 fb9c 	bl	34019534 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34003dfc:	463b      	mov	r3, r7
34003dfe:	4619      	mov	r1, r3
34003e00:	2008      	movs	r0, #8
34003e02:	f015 fb97 	bl	34019534 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34003e06:	463b      	mov	r3, r7
34003e08:	4619      	mov	r1, r3
34003e0a:	2009      	movs	r0, #9
34003e0c:	f015 fb92 	bl	34019534 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34003e10:	463b      	mov	r3, r7
34003e12:	4619      	mov	r1, r3
34003e14:	200a      	movs	r0, #10
34003e16:	f015 fb8d 	bl	34019534 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34003e1a:	463b      	mov	r3, r7
34003e1c:	4619      	mov	r1, r3
34003e1e:	200b      	movs	r0, #11
34003e20:	f015 fb88 	bl	34019534 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e24:	2103      	movs	r1, #3
34003e26:	480f      	ldr	r0, [pc, #60]	@ (34003e64 <Security_Config+0x90>)
34003e28:	f015 fc2e 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e2c:	2103      	movs	r1, #3
34003e2e:	480e      	ldr	r0, [pc, #56]	@ (34003e68 <Security_Config+0x94>)
34003e30:	f015 fc2a 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI    , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e34:	2103      	movs	r1, #3
34003e36:	480d      	ldr	r0, [pc, #52]	@ (34003e6c <Security_Config+0x98>)
34003e38:	f015 fc26 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e3c:	2103      	movs	r1, #3
34003e3e:	480c      	ldr	r0, [pc, #48]	@ (34003e70 <Security_Config+0x9c>)
34003e40:	f015 fc22 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e44:	2103      	movs	r1, #3
34003e46:	480b      	ldr	r0, [pc, #44]	@ (34003e74 <Security_Config+0xa0>)
34003e48:	f015 fc1e 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e4c:	2103      	movs	r1, #3
34003e4e:	480a      	ldr	r0, [pc, #40]	@ (34003e78 <Security_Config+0xa4>)
34003e50:	f015 fc1a 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003e54:	2103      	movs	r1, #3
34003e56:	4809      	ldr	r0, [pc, #36]	@ (34003e7c <Security_Config+0xa8>)
34003e58:	f015 fc16 	bl	34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>
}
34003e5c:	bf00      	nop
34003e5e:	3708      	adds	r7, #8
34003e60:	46bd      	mov	sp, r7
34003e62:	bd80      	pop	{r7, pc}
34003e64:	3000000a 	.word	0x3000000a
34003e68:	30000005 	.word	0x30000005
34003e6c:	2000001c 	.word	0x2000001c
34003e70:	2000001d 	.word	0x2000001d
34003e74:	30000006 	.word	0x30000006
34003e78:	30000007 	.word	0x30000007
34003e7c:	30000008 	.word	0x30000008

34003e80 <IAC_Config>:

void IAC_Config(void)
{
34003e80:	b580      	push	{r7, lr}
34003e82:	af00      	add	r7, sp, #0
  __HAL_RCC_IAC_CLK_ENABLE();
34003e84:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34003e88:	f7ff fe7e 	bl	34003b88 <LL_AHB3_GRP1_EnableClock>
  __HAL_RCC_IAC_FORCE_RESET();
34003e8c:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34003e90:	f7ff fe90 	bl	34003bb4 <LL_AHB3_GRP1_ForceReset>
  __HAL_RCC_IAC_RELEASE_RESET();
34003e94:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34003e98:	f7ff fe9c 	bl	34003bd4 <LL_AHB3_GRP1_ReleaseReset>
}
34003e9c:	bf00      	nop
34003e9e:	bd80      	pop	{r7, pc}

34003ea0 <SystemClock_Config>:

void SystemClock_Config(void)
{
34003ea0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
34003ea4:	f5ad 7d1a 	sub.w	sp, sp, #616	@ 0x268
34003ea8:	af00      	add	r7, sp, #0
  BSP_SMPS_Init(SMPS_VOLTAGE_OVERDRIVE);
34003eaa:	2001      	movs	r0, #1
34003eac:	f000 feaa 	bl	34004c04 <BSP_SMPS_Init>

  RCC_OscInitTypeDef osc = {0};
34003eb0:	f507 73e8 	add.w	r3, r7, #464	@ 0x1d0
34003eb4:	2298      	movs	r2, #152	@ 0x98
34003eb6:	2100      	movs	r1, #0
34003eb8:	4618      	mov	r0, r3
34003eba:	f01d fb8b 	bl	340215d4 <memset>
  RCC_ClkInitTypeDef clk = {0};
34003ebe:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34003ec2:	2240      	movs	r2, #64	@ 0x40
34003ec4:	2100      	movs	r1, #0
34003ec6:	4618      	mov	r0, r3
34003ec8:	f01d fb84 	bl	340215d4 <memset>
  RCC_PeriphCLKInitTypeDef periph = {0};
34003ecc:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34003ed0:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34003ed4:	4618      	mov	r0, r3
34003ed6:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34003eda:	461a      	mov	r2, r3
34003edc:	2100      	movs	r1, #0
34003ede:	f01d fb79 	bl	340215d4 <memset>

  osc.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34003ee2:	2300      	movs	r3, #0
34003ee4:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

  /* PLL1 = 64 x 25 / 2 = 800MHz */
  osc.PLL1.PLLState = RCC_PLL_ON;
34003ee8:	2302      	movs	r3, #2
34003eea:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
  osc.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34003eee:	2300      	movs	r3, #0
34003ef0:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
  osc.PLL1.PLLM = 2;
34003ef4:	2302      	movs	r3, #2
34003ef6:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
  osc.PLL1.PLLN = 25;
34003efa:	2319      	movs	r3, #25
34003efc:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
  osc.PLL1.PLLFractional = 0;
34003f00:	2300      	movs	r3, #0
34003f02:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
  osc.PLL1.PLLP1 = 1;
34003f06:	2301      	movs	r3, #1
34003f08:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
  osc.PLL1.PLLP2 = 1;
34003f0c:	2301      	movs	r3, #1
34003f0e:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210

  /* PLL2 = 64 x 125 / 8 = 1000MHz */
  osc.PLL2.PLLState = RCC_PLL_ON;
34003f12:	2302      	movs	r3, #2
34003f14:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
  osc.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34003f18:	2300      	movs	r3, #0
34003f1a:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
  osc.PLL2.PLLM = 8;
34003f1e:	2308      	movs	r3, #8
34003f20:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
  osc.PLL2.PLLFractional = 0;
34003f24:	2300      	movs	r3, #0
34003f26:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
  osc.PLL2.PLLN = 125;
34003f2a:	237d      	movs	r3, #125	@ 0x7d
34003f2c:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
  osc.PLL2.PLLP1 = 1;
34003f30:	2301      	movs	r3, #1
34003f32:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
  osc.PLL2.PLLP2 = 1;
34003f36:	2301      	movs	r3, #1
34003f38:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c

  /* PLL3 = (64 x 225 / 8) / (1 * 2) = 900MHz */
  osc.PLL3.PLLState = RCC_PLL_ON;
34003f3c:	2302      	movs	r3, #2
34003f3e:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  osc.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
34003f42:	2300      	movs	r3, #0
34003f44:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  osc.PLL3.PLLM = 8;
34003f48:	2308      	movs	r3, #8
34003f4a:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  osc.PLL3.PLLN = 225;
34003f4e:	23e1      	movs	r3, #225	@ 0xe1
34003f50:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
  osc.PLL3.PLLFractional = 0;
34003f54:	2300      	movs	r3, #0
34003f56:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  osc.PLL3.PLLP1 = 1;
34003f5a:	2301      	movs	r3, #1
34003f5c:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  osc.PLL3.PLLP2 = 2;
34003f60:	2302      	movs	r3, #2
34003f62:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248

  /* PLL4 = (64 x 225 / 8) / (6 * 6) = 50 MHz */
  osc.PLL4.PLLState = RCC_PLL_ON;
34003f66:	2302      	movs	r3, #2
34003f68:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  osc.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34003f6c:	2300      	movs	r3, #0
34003f6e:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
  osc.PLL4.PLLM = 8;
34003f72:	2308      	movs	r3, #8
34003f74:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
  osc.PLL4.PLLFractional = 0;
34003f78:	2300      	movs	r3, #0
34003f7a:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
  osc.PLL4.PLLN = 225;
34003f7e:	23e1      	movs	r3, #225	@ 0xe1
34003f80:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
  osc.PLL4.PLLP1 = 6;
34003f84:	2306      	movs	r3, #6
34003f86:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
  osc.PLL4.PLLP2 = 6;
34003f8a:	2306      	movs	r3, #6
34003f8c:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264

  if (HAL_RCC_OscConfig(&osc) != HAL_OK)
34003f90:	f507 73e8 	add.w	r3, r7, #464	@ 0x1d0
34003f94:	4618      	mov	r0, r3
34003f96:	f007 fba1 	bl	3400b6dc <HAL_RCC_OscConfig>
34003f9a:	4603      	mov	r3, r0
34003f9c:	2b00      	cmp	r3, #0
34003f9e:	d001      	beq.n	34003fa4 <SystemClock_Config+0x104>
  {
    while(1);
34003fa0:	bf00      	nop
34003fa2:	e7fd      	b.n	34003fa0 <SystemClock_Config+0x100>
  }

  clk.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK |
34003fa4:	237f      	movs	r3, #127	@ 0x7f
34003fa6:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
                   RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
                   RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK4 |
                   RCC_CLOCKTYPE_PCLK5);

  /* CPU CLock (sysa_ck) = ic1_ck = PLL1 output/ic1_divider = 800 MHz */
  clk.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34003faa:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34003fae:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
  clk.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34003fb2:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34003fb6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
  clk.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34003fba:	2300      	movs	r3, #0
34003fbc:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
  clk.IC1Selection.ClockDivider = 1;
34003fc0:	2301      	movs	r3, #1
34003fc2:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4

  /* AXI Clock (sysb_ck) = ic2_ck = PLL1 output/ic2_divider = 400 MHz */
  clk.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34003fc6:	2300      	movs	r3, #0
34003fc8:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
  clk.IC2Selection.ClockDivider = 2;
34003fcc:	2302      	movs	r3, #2
34003fce:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

  /* NPU Clock (sysc_ck) = ic6_ck = PLL2 output/ic6_divider = 1000 MHz */
  clk.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34003fd2:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
34003fd6:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
  clk.IC6Selection.ClockDivider = 1;
34003fda:	2301      	movs	r3, #1
34003fdc:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4

  /* AXISRAM3/4/5/6 Clock (sysd_ck) = ic11_ck = PLL3 output/ic11_divider = 900 MHz */
  clk.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34003fe0:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34003fe4:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
  clk.IC11Selection.ClockDivider = 1;
34003fe8:	2301      	movs	r3, #1
34003fea:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc

  /* HCLK = sysb_ck / HCLK divider = 200 MHz */
  clk.AHBCLKDivider = RCC_HCLK_DIV2;
34003fee:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34003ff2:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c

  /* PCLKx = HCLK / PCLKx divider = 200 MHz */
  clk.APB1CLKDivider = RCC_APB1_DIV1;
34003ff6:	2300      	movs	r3, #0
34003ff8:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
  clk.APB2CLKDivider = RCC_APB2_DIV1;
34003ffc:	2300      	movs	r3, #0
34003ffe:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
  clk.APB4CLKDivider = RCC_APB4_DIV1;
34004002:	2300      	movs	r3, #0
34004004:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
  clk.APB5CLKDivider = RCC_APB5_DIV1;
34004008:	2300      	movs	r3, #0
3400400a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

  if (HAL_RCC_ClockConfig(&clk) != HAL_OK)
3400400e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34004012:	4618      	mov	r0, r3
34004014:	f008 f882 	bl	3400c11c <HAL_RCC_ClockConfig>
34004018:	4603      	mov	r3, r0
3400401a:	2b00      	cmp	r3, #0
3400401c:	d001      	beq.n	34004022 <SystemClock_Config+0x182>
  {
    while(1);
3400401e:	bf00      	nop
34004020:	e7fd      	b.n	3400401e <SystemClock_Config+0x17e>
  }

  periph.PeriphClockSelection = 0;
34004022:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34004026:	f5a3 711a 	sub.w	r1, r3, #616	@ 0x268
3400402a:	f04f 0200 	mov.w	r2, #0
3400402e:	f04f 0300 	mov.w	r3, #0
34004032:	e9c1 2300 	strd	r2, r3, [r1]
  periph.PeriphClockSelection |= RCC_PERIPHCLK_XSPI1;
34004036:	f507 731a 	add.w	r3, r7, #616	@ 0x268
3400403a:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
3400403e:	e9d3 2300 	ldrd	r2, r3, [r3]
34004042:	4690      	mov	r8, r2
34004044:	f443 0980 	orr.w	r9, r3, #4194304	@ 0x400000
34004048:	f507 731a 	add.w	r3, r7, #616	@ 0x268
3400404c:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34004050:	e9c3 8900 	strd	r8, r9, [r3]
  periph.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34004054:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34004058:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
3400405c:	4a13      	ldr	r2, [pc, #76]	@ (340040ac <SystemClock_Config+0x20c>)
3400405e:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
  periph.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34004062:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34004066:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
3400406a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400406e:	4614      	mov	r4, r2
34004070:	f443 0500 	orr.w	r5, r3, #8388608	@ 0x800000
34004074:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34004078:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
3400407c:	e9c3 4500 	strd	r4, r5, [r3]
  periph.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34004080:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34004084:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34004088:	4a09      	ldr	r2, [pc, #36]	@ (340040b0 <SystemClock_Config+0x210>)
3400408a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

  if (HAL_RCCEx_PeriphCLKConfig(&periph) != HAL_OK)
3400408e:	463b      	mov	r3, r7
34004090:	4618      	mov	r0, r3
34004092:	f00a fc39 	bl	3400e908 <HAL_RCCEx_PeriphCLKConfig>
34004096:	4603      	mov	r3, r0
34004098:	2b00      	cmp	r3, #0
3400409a:	d001      	beq.n	340040a0 <SystemClock_Config+0x200>
  {
    while (1);
3400409c:	bf00      	nop
3400409e:	e7fd      	b.n	3400409c <SystemClock_Config+0x1fc>
  }
}
340040a0:	bf00      	nop
340040a2:	f507 771a 	add.w	r7, r7, #616	@ 0x268
340040a6:	46bd      	mov	sp, r7
340040a8:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
340040ac:	03000014 	.word	0x03000014
340040b0:	03000414 	.word	0x03000414

340040b4 <IAC_IRQHandler>:

  return ret;
}

void IAC_IRQHandler(void)
{
340040b4:	b480      	push	{r7}
340040b6:	af00      	add	r7, sp, #0
  while (1)
340040b8:	bf00      	nop
340040ba:	e7fd      	b.n	340040b8 <IAC_IRQHandler+0x4>

340040bc <APS256XX_EnableMemoryMappedMode>:
  * @param  BurstType Type of burst used for the access
  * @retval Memory status
  */
int32_t APS256XX_EnableMemoryMappedMode(XSPI_HandleTypeDef *Ctx, uint32_t ReadLatencyCode, uint32_t WriteLatencyCode,
                                        uint32_t IOMode, uint32_t BurstType)
{
340040bc:	b580      	push	{r7, lr}
340040be:	b09c      	sub	sp, #112	@ 0x70
340040c0:	af00      	add	r7, sp, #0
340040c2:	60f8      	str	r0, [r7, #12]
340040c4:	60b9      	str	r1, [r7, #8]
340040c6:	607a      	str	r2, [r7, #4]
340040c8:	603b      	str	r3, [r7, #0]
  XSPI_RegularCmdTypeDef   sCommand = {0};
340040ca:	f107 0324 	add.w	r3, r7, #36	@ 0x24
340040ce:	224c      	movs	r2, #76	@ 0x4c
340040d0:	2100      	movs	r1, #0
340040d2:	4618      	mov	r0, r3
340040d4:	f01d fa7e 	bl	340215d4 <memset>
  XSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
340040d8:	f107 0314 	add.w	r3, r7, #20
340040dc:	2200      	movs	r2, #0
340040de:	601a      	str	r2, [r3, #0]
340040e0:	605a      	str	r2, [r3, #4]
340040e2:	609a      	str	r2, [r3, #8]
340040e4:	60da      	str	r2, [r3, #12]

  /* Initialize the write command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_WRITE_CFG;
340040e6:	2302      	movs	r3, #2
340040e8:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
340040ea:	2304      	movs	r3, #4
340040ec:	633b      	str	r3, [r7, #48]	@ 0x30
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
340040ee:	2300      	movs	r3, #0
340040f0:	637b      	str	r3, [r7, #52]	@ 0x34
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340040f2:	2300      	movs	r3, #0
340040f4:	63bb      	str	r3, [r7, #56]	@ 0x38
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
340040f6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
340040f8:	2b00      	cmp	r3, #0
340040fa:	d101      	bne.n	34004100 <APS256XX_EnableMemoryMappedMode+0x44>
340040fc:	23a0      	movs	r3, #160	@ 0xa0
340040fe:	e000      	b.n	34004102 <APS256XX_EnableMemoryMappedMode+0x46>
34004100:	2380      	movs	r3, #128	@ 0x80
34004102:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
34004104:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34004108:	643b      	str	r3, [r7, #64]	@ 0x40
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3400410a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3400410e:	647b      	str	r3, [r7, #68]	@ 0x44
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34004110:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34004114:	64bb      	str	r3, [r7, #72]	@ 0x48
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
34004116:	2300      	movs	r3, #0
34004118:	653b      	str	r3, [r7, #80]	@ 0x50
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
3400411a:	683b      	ldr	r3, [r7, #0]
3400411c:	2b00      	cmp	r3, #0
3400411e:	d102      	bne.n	34004126 <APS256XX_EnableMemoryMappedMode+0x6a>
34004120:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34004124:	e001      	b.n	3400412a <APS256XX_EnableMemoryMappedMode+0x6e>
34004126:	f04f 63a0 	mov.w	r3, #83886080	@ 0x5000000
3400412a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
3400412c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34004130:	667b      	str	r3, [r7, #100]	@ 0x64
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
34004132:	687b      	ldr	r3, [r7, #4]
34004134:	3b01      	subs	r3, #1
34004136:	66bb      	str	r3, [r7, #104]	@ 0x68
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
34004138:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
3400413c:	66fb      	str	r3, [r7, #108]	@ 0x6c
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400413e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34004142:	f241 3288 	movw	r2, #5000	@ 0x1388
34004146:	4619      	mov	r1, r3
34004148:	68f8      	ldr	r0, [r7, #12]
3400414a:	f017 f9e9 	bl	3401b520 <HAL_XSPI_Command>
3400414e:	4603      	mov	r3, r0
34004150:	2b00      	cmp	r3, #0
34004152:	d002      	beq.n	3400415a <APS256XX_EnableMemoryMappedMode+0x9e>
  {
    return APS256XX_ERROR;
34004154:	f04f 33ff 	mov.w	r3, #4294967295
34004158:	e028      	b.n	340041ac <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  /* Initialize the read command */
  sCommand.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
3400415a:	2301      	movs	r3, #1
3400415c:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
3400415e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34004160:	2b00      	cmp	r3, #0
34004162:	d101      	bne.n	34004168 <APS256XX_EnableMemoryMappedMode+0xac>
34004164:	2320      	movs	r3, #32
34004166:	e000      	b.n	3400416a <APS256XX_EnableMemoryMappedMode+0xae>
34004168:	2300      	movs	r3, #0
3400416a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
3400416c:	68bb      	ldr	r3, [r7, #8]
3400416e:	3b01      	subs	r3, #1
34004170:	66bb      	str	r3, [r7, #104]	@ 0x68

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34004172:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34004176:	f241 3288 	movw	r2, #5000	@ 0x1388
3400417a:	4619      	mov	r1, r3
3400417c:	68f8      	ldr	r0, [r7, #12]
3400417e:	f017 f9cf 	bl	3401b520 <HAL_XSPI_Command>
34004182:	4603      	mov	r3, r0
34004184:	2b00      	cmp	r3, #0
34004186:	d002      	beq.n	3400418e <APS256XX_EnableMemoryMappedMode+0xd2>
  {
    return APS256XX_ERROR;
34004188:	f04f 33ff 	mov.w	r3, #4294967295
3400418c:	e00e      	b.n	340041ac <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  /* Activation of memory-mapped mode */
  sMemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
3400418e:	2300      	movs	r3, #0
34004190:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_MemoryMapped(Ctx, &sMemMappedCfg) != HAL_OK)
34004192:	f107 0314 	add.w	r3, r7, #20
34004196:	4619      	mov	r1, r3
34004198:	68f8      	ldr	r0, [r7, #12]
3400419a:	f017 fdb3 	bl	3401bd04 <HAL_XSPI_MemoryMapped>
3400419e:	4603      	mov	r3, r0
340041a0:	2b00      	cmp	r3, #0
340041a2:	d002      	beq.n	340041aa <APS256XX_EnableMemoryMappedMode+0xee>
  {
    return APS256XX_ERROR;
340041a4:	f04f 33ff 	mov.w	r3, #4294967295
340041a8:	e000      	b.n	340041ac <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  return APS256XX_OK;
340041aa:	2300      	movs	r3, #0
}
340041ac:	4618      	mov	r0, r3
340041ae:	3770      	adds	r7, #112	@ 0x70
340041b0:	46bd      	mov	sp, r7
340041b2:	bd80      	pop	{r7, pc}

340041b4 <APS256XX_WriteReg>:
  * @param  Address Register address
  * @param  Value Value to write to register
  * @retval error status
  */
int32_t APS256XX_WriteReg(XSPI_HandleTypeDef *Ctx, uint32_t Address, uint8_t Value)
{
340041b4:	b580      	push	{r7, lr}
340041b6:	b098      	sub	sp, #96	@ 0x60
340041b8:	af00      	add	r7, sp, #0
340041ba:	60f8      	str	r0, [r7, #12]
340041bc:	60b9      	str	r1, [r7, #8]
340041be:	4613      	mov	r3, r2
340041c0:	71fb      	strb	r3, [r7, #7]
  XSPI_RegularCmdTypeDef sCommand = {0};
340041c2:	f107 0314 	add.w	r3, r7, #20
340041c6:	224c      	movs	r2, #76	@ 0x4c
340041c8:	2100      	movs	r1, #0
340041ca:	4618      	mov	r0, r3
340041cc:	f01d fa02 	bl	340215d4 <memset>

  /* Initialize the write register command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_COMMON_CFG;
340041d0:	2300      	movs	r3, #0
340041d2:	617b      	str	r3, [r7, #20]
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
340041d4:	2304      	movs	r3, #4
340041d6:	623b      	str	r3, [r7, #32]
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
340041d8:	2300      	movs	r3, #0
340041da:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340041dc:	2300      	movs	r3, #0
340041de:	62bb      	str	r3, [r7, #40]	@ 0x28
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
340041e0:	23c0      	movs	r3, #192	@ 0xc0
340041e2:	61fb      	str	r3, [r7, #28]
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
340041e4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340041e8:	633b      	str	r3, [r7, #48]	@ 0x30
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
340041ea:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340041ee:	637b      	str	r3, [r7, #52]	@ 0x34
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
340041f0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340041f4:	63bb      	str	r3, [r7, #56]	@ 0x38
  sCommand.Address             = Address;
340041f6:	68bb      	ldr	r3, [r7, #8]
340041f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
340041fa:	2300      	movs	r3, #0
340041fc:	643b      	str	r3, [r7, #64]	@ 0x40
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
340041fe:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34004202:	64fb      	str	r3, [r7, #76]	@ 0x4c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
34004204:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34004208:	657b      	str	r3, [r7, #84]	@ 0x54
  sCommand.DataLength          = 2;
3400420a:	2302      	movs	r3, #2
3400420c:	653b      	str	r3, [r7, #80]	@ 0x50
  sCommand.DummyCycles         = 0;
3400420e:	2300      	movs	r3, #0
34004210:	65bb      	str	r3, [r7, #88]	@ 0x58
  sCommand.DQSMode             = HAL_XSPI_DQS_DISABLE;
34004212:	2300      	movs	r3, #0
34004214:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Configure the command */
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34004216:	f107 0314 	add.w	r3, r7, #20
3400421a:	f241 3288 	movw	r2, #5000	@ 0x1388
3400421e:	4619      	mov	r1, r3
34004220:	68f8      	ldr	r0, [r7, #12]
34004222:	f017 f97d 	bl	3401b520 <HAL_XSPI_Command>
34004226:	4603      	mov	r3, r0
34004228:	2b00      	cmp	r3, #0
3400422a:	d002      	beq.n	34004232 <APS256XX_WriteReg+0x7e>
  {
    return APS256XX_ERROR;
3400422c:	f04f 33ff 	mov.w	r3, #4294967295
34004230:	e00d      	b.n	3400424e <APS256XX_WriteReg+0x9a>
  }

  /* Transmission of the data */
  if (HAL_XSPI_Transmit(Ctx, (uint8_t *)(&Value), HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34004232:	1dfb      	adds	r3, r7, #7
34004234:	f241 3288 	movw	r2, #5000	@ 0x1388
34004238:	4619      	mov	r1, r3
3400423a:	68f8      	ldr	r0, [r7, #12]
3400423c:	f017 fb82 	bl	3401b944 <HAL_XSPI_Transmit>
34004240:	4603      	mov	r3, r0
34004242:	2b00      	cmp	r3, #0
34004244:	d002      	beq.n	3400424c <APS256XX_WriteReg+0x98>
  {
    return APS256XX_ERROR;
34004246:	f04f 33ff 	mov.w	r3, #4294967295
3400424a:	e000      	b.n	3400424e <APS256XX_WriteReg+0x9a>
  }

  return APS256XX_OK;
3400424c:	2300      	movs	r3, #0
}
3400424e:	4618      	mov	r0, r3
34004250:	3760      	adds	r7, #96	@ 0x60
34004252:	46bd      	mov	sp, r7
34004254:	bd80      	pop	{r7, pc}

34004256 <MX66UW1G45G_GetFlashInfo>:
  * @brief  Get Flash information
  * @param  pInfo pointer to information structure
  * @retval error status
  */
int32_t MX66UW1G45G_GetFlashInfo(MX66UW1G45G_Info_t *pInfo)
{
34004256:	b480      	push	{r7}
34004258:	b083      	sub	sp, #12
3400425a:	af00      	add	r7, sp, #0
3400425c:	6078      	str	r0, [r7, #4]
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize = MX66UW1G45G_FLASH_SIZE;
3400425e:	687b      	ldr	r3, [r7, #4]
34004260:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34004264:	601a      	str	r2, [r3, #0]
  pInfo->EraseSectorSize = MX66UW1G45G_BLOCK_64K;
34004266:	687b      	ldr	r3, [r7, #4]
34004268:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400426c:	605a      	str	r2, [r3, #4]
  pInfo->EraseSectorsNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_64K);
3400426e:	687b      	ldr	r3, [r7, #4]
34004270:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34004274:	609a      	str	r2, [r3, #8]
  pInfo->EraseSubSectorSize = MX66UW1G45G_BLOCK_4K;
34004276:	687b      	ldr	r3, [r7, #4]
34004278:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400427c:	60da      	str	r2, [r3, #12]
  pInfo->EraseSubSectorNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
3400427e:	687b      	ldr	r3, [r7, #4]
34004280:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34004284:	611a      	str	r2, [r3, #16]
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
34004286:	687b      	ldr	r3, [r7, #4]
34004288:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400428c:	615a      	str	r2, [r3, #20]
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
3400428e:	687b      	ldr	r3, [r7, #4]
34004290:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34004294:	619a      	str	r2, [r3, #24]
  pInfo->ProgPageSize = MX66UW1G45G_PAGE_SIZE;
34004296:	687b      	ldr	r3, [r7, #4]
34004298:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400429c:	61da      	str	r2, [r3, #28]
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
3400429e:	687b      	ldr	r3, [r7, #4]
340042a0:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
340042a4:	621a      	str	r2, [r3, #32]

  return MX66UW1G45G_OK;
340042a6:	2300      	movs	r3, #0
};
340042a8:	4618      	mov	r0, r3
340042aa:	370c      	adds	r7, #12
340042ac:	46bd      	mov	sp, r7
340042ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340042b2:	4770      	bx	lr

340042b4 <MX66UW1G45G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX66UW1G45G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                        MX66UW1G45G_Transfer_t Rate)
{
340042b4:	b580      	push	{r7, lr}
340042b6:	b09a      	sub	sp, #104	@ 0x68
340042b8:	af00      	add	r7, sp, #0
340042ba:	6078      	str	r0, [r7, #4]
340042bc:	460b      	mov	r3, r1
340042be:	70fb      	strb	r3, [r7, #3]
340042c0:	4613      	mov	r3, r2
340042c2:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
340042c4:	f107 031c 	add.w	r3, r7, #28
340042c8:	224c      	movs	r2, #76	@ 0x4c
340042ca:	2100      	movs	r1, #0
340042cc:	4618      	mov	r0, r3
340042ce:	f01d f981 	bl	340215d4 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
340042d2:	f107 0308 	add.w	r3, r7, #8
340042d6:	2200      	movs	r2, #0
340042d8:	601a      	str	r2, [r3, #0]
340042da:	605a      	str	r2, [r3, #4]
340042dc:	609a      	str	r2, [r3, #8]
340042de:	60da      	str	r2, [r3, #12]
340042e0:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340042e2:	78fb      	ldrb	r3, [r7, #3]
340042e4:	2b00      	cmp	r3, #0
340042e6:	d105      	bne.n	340042f4 <MX66UW1G45G_AutoPollingMemReady+0x40>
340042e8:	78bb      	ldrb	r3, [r7, #2]
340042ea:	2b01      	cmp	r3, #1
340042ec:	d102      	bne.n	340042f4 <MX66UW1G45G_AutoPollingMemReady+0x40>
  {
    return MX66UW1G45G_ERROR;
340042ee:	f04f 33ff 	mov.w	r3, #4294967295
340042f2:	e089      	b.n	34004408 <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  /* Configure automatic polling mode to wait for memory ready */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
340042f4:	2300      	movs	r3, #0
340042f6:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
340042f8:	78fb      	ldrb	r3, [r7, #3]
340042fa:	2b00      	cmp	r3, #0
340042fc:	d101      	bne.n	34004302 <MX66UW1G45G_AutoPollingMemReady+0x4e>
340042fe:	2301      	movs	r3, #1
34004300:	e000      	b.n	34004304 <MX66UW1G45G_AutoPollingMemReady+0x50>
34004302:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34004304:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34004306:	78bb      	ldrb	r3, [r7, #2]
34004308:	2b01      	cmp	r3, #1
3400430a:	d101      	bne.n	34004310 <MX66UW1G45G_AutoPollingMemReady+0x5c>
3400430c:	2308      	movs	r3, #8
3400430e:	e000      	b.n	34004312 <MX66UW1G45G_AutoPollingMemReady+0x5e>
34004310:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004312:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34004314:	78fb      	ldrb	r3, [r7, #3]
34004316:	2b00      	cmp	r3, #0
34004318:	d101      	bne.n	3400431e <MX66UW1G45G_AutoPollingMemReady+0x6a>
3400431a:	2300      	movs	r3, #0
3400431c:	e000      	b.n	34004320 <MX66UW1G45G_AutoPollingMemReady+0x6c>
3400431e:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34004320:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_STATUS_REG_CMD
                              : MX66UW1G45G_OCTA_READ_STATUS_REG_CMD;
34004322:	78fb      	ldrb	r3, [r7, #3]
34004324:	2b00      	cmp	r3, #0
34004326:	d101      	bne.n	3400432c <MX66UW1G45G_AutoPollingMemReady+0x78>
34004328:	2305      	movs	r3, #5
3400432a:	e001      	b.n	34004330 <MX66UW1G45G_AutoPollingMemReady+0x7c>
3400432c:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34004330:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34004332:	78fb      	ldrb	r3, [r7, #3]
34004334:	2b00      	cmp	r3, #0
34004336:	d101      	bne.n	3400433c <MX66UW1G45G_AutoPollingMemReady+0x88>
34004338:	2300      	movs	r3, #0
3400433a:	e001      	b.n	34004340 <MX66UW1G45G_AutoPollingMemReady+0x8c>
3400433c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34004340:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34004342:	78bb      	ldrb	r3, [r7, #2]
34004344:	2b01      	cmp	r3, #1
34004346:	d102      	bne.n	3400434e <MX66UW1G45G_AutoPollingMemReady+0x9a>
34004348:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400434c:	e000      	b.n	34004350 <MX66UW1G45G_AutoPollingMemReady+0x9c>
3400434e:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004350:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34004352:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34004356:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address = 0U;
34004358:	2300      	movs	r3, #0
3400435a:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
3400435c:	2300      	movs	r3, #0
3400435e:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34004360:	78fb      	ldrb	r3, [r7, #3]
34004362:	2b00      	cmp	r3, #0
34004364:	d102      	bne.n	3400436c <MX66UW1G45G_AutoPollingMemReady+0xb8>
34004366:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400436a:	e001      	b.n	34004370 <MX66UW1G45G_AutoPollingMemReady+0xbc>
3400436c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34004370:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
34004372:	78bb      	ldrb	r3, [r7, #2]
34004374:	2b01      	cmp	r3, #1
34004376:	d102      	bne.n	3400437e <MX66UW1G45G_AutoPollingMemReady+0xca>
34004378:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3400437c:	e000      	b.n	34004380 <MX66UW1G45G_AutoPollingMemReady+0xcc>
3400437e:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004380:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34004382:	78fb      	ldrb	r3, [r7, #3]
34004384:	2b00      	cmp	r3, #0
34004386:	d006      	beq.n	34004396 <MX66UW1G45G_AutoPollingMemReady+0xe2>
34004388:	78bb      	ldrb	r3, [r7, #2]
3400438a:	2b01      	cmp	r3, #1
3400438c:	d101      	bne.n	34004392 <MX66UW1G45G_AutoPollingMemReady+0xde>
3400438e:	2305      	movs	r3, #5
34004390:	e002      	b.n	34004398 <MX66UW1G45G_AutoPollingMemReady+0xe4>
34004392:	2304      	movs	r3, #4
34004394:	e000      	b.n	34004398 <MX66UW1G45G_AutoPollingMemReady+0xe4>
34004396:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34004398:	663b      	str	r3, [r7, #96]	@ 0x60
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
3400439a:	78bb      	ldrb	r3, [r7, #2]
3400439c:	2b01      	cmp	r3, #1
3400439e:	d101      	bne.n	340043a4 <MX66UW1G45G_AutoPollingMemReady+0xf0>
340043a0:	2302      	movs	r3, #2
340043a2:	e000      	b.n	340043a6 <MX66UW1G45G_AutoPollingMemReady+0xf2>
340043a4:	2301      	movs	r3, #1
340043a6:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
340043a8:	78bb      	ldrb	r3, [r7, #2]
340043aa:	2b01      	cmp	r3, #1
340043ac:	d102      	bne.n	340043b4 <MX66UW1G45G_AutoPollingMemReady+0x100>
340043ae:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
340043b2:	e000      	b.n	340043b6 <MX66UW1G45G_AutoPollingMemReady+0x102>
340043b4:	2300      	movs	r3, #0
340043b6:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  s_config.MatchValue = 0U;
340043b8:	2300      	movs	r3, #0
340043ba:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
340043bc:	2301      	movs	r3, #1
340043be:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
340043c0:	2300      	movs	r3, #0
340043c2:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime = MX66UW1G45G_AUTOPOLLING_INTERVAL_TIME;
340043c4:	2310      	movs	r3, #16
340043c6:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
340043c8:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
340043cc:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340043ce:	f107 031c 	add.w	r3, r7, #28
340043d2:	f241 3288 	movw	r2, #5000	@ 0x1388
340043d6:	4619      	mov	r1, r3
340043d8:	6878      	ldr	r0, [r7, #4]
340043da:	f017 f8a1 	bl	3401b520 <HAL_XSPI_Command>
340043de:	4603      	mov	r3, r0
340043e0:	2b00      	cmp	r3, #0
340043e2:	d002      	beq.n	340043ea <MX66UW1G45G_AutoPollingMemReady+0x136>
  {
    return MX66UW1G45G_ERROR;
340043e4:	f04f 33ff 	mov.w	r3, #4294967295
340043e8:	e00e      	b.n	34004408 <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340043ea:	f107 0308 	add.w	r3, r7, #8
340043ee:	f241 3288 	movw	r2, #5000	@ 0x1388
340043f2:	4619      	mov	r1, r3
340043f4:	6878      	ldr	r0, [r7, #4]
340043f6:	f017 fbbb 	bl	3401bb70 <HAL_XSPI_AutoPolling>
340043fa:	4603      	mov	r3, r0
340043fc:	2b00      	cmp	r3, #0
340043fe:	d002      	beq.n	34004406 <MX66UW1G45G_AutoPollingMemReady+0x152>
  {
    return MX66UW1G45G_ERROR;
34004400:	f04f 33ff 	mov.w	r3, #4294967295
34004404:	e000      	b.n	34004408 <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  return MX66UW1G45G_OK;
34004406:	2300      	movs	r3, #0
}
34004408:	4618      	mov	r0, r3
3400440a:	3768      	adds	r7, #104	@ 0x68
3400440c:	46bd      	mov	sp, r7
3400440e:	bd80      	pop	{r7, pc}

34004410 <MX66UW1G45G_EnableSTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                              MX66UW1G45G_AddressWidth_t AddressWidth)
{
34004410:	b580      	push	{r7, lr}
34004412:	b09a      	sub	sp, #104	@ 0x68
34004414:	af00      	add	r7, sp, #0
34004416:	6078      	str	r0, [r7, #4]
34004418:	460b      	mov	r3, r1
3400441a:	70fb      	strb	r3, [r7, #3]
3400441c:	4613      	mov	r3, r2
3400441e:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34004420:	f107 031c 	add.w	r3, r7, #28
34004424:	224c      	movs	r2, #76	@ 0x4c
34004426:	2100      	movs	r1, #0
34004428:	4618      	mov	r0, r3
3400442a:	f01d f8d3 	bl	340215d4 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
3400442e:	f107 030c 	add.w	r3, r7, #12
34004432:	2200      	movs	r2, #0
34004434:	601a      	str	r2, [r3, #0]
34004436:	605a      	str	r2, [r3, #4]
34004438:	609a      	str	r2, [r3, #8]
3400443a:	60da      	str	r2, [r3, #12]

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX66UW1G45G_OPI_MODE) && (AddressWidth == MX66UW1G45G_3BYTES_SIZE))
3400443c:	78fb      	ldrb	r3, [r7, #3]
3400443e:	2b01      	cmp	r3, #1
34004440:	d105      	bne.n	3400444e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
34004442:	78bb      	ldrb	r3, [r7, #2]
34004444:	2b00      	cmp	r3, #0
34004446:	d102      	bne.n	3400444e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
  {
    return MX66UW1G45G_ERROR;
34004448:	f04f 33ff 	mov.w	r3, #4294967295
3400444c:	e084      	b.n	34004558 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
3400444e:	2301      	movs	r3, #1
34004450:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34004452:	78fb      	ldrb	r3, [r7, #3]
34004454:	2b00      	cmp	r3, #0
34004456:	d101      	bne.n	3400445c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x4c>
34004458:	2301      	movs	r3, #1
3400445a:	e000      	b.n	3400445e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x4e>
3400445c:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
3400445e:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34004460:	2300      	movs	r3, #0
34004462:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34004464:	78fb      	ldrb	r3, [r7, #3]
34004466:	2b00      	cmp	r3, #0
34004468:	d101      	bne.n	3400446e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x5e>
3400446a:	2300      	movs	r3, #0
3400446c:	e000      	b.n	34004470 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x60>
3400446e:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34004470:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? ((AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                                     ? MX66UW1G45G_FAST_READ_CMD
                                     : MX66UW1G45G_4_BYTE_ADDR_FAST_READ_CMD)
                              : MX66UW1G45G_OCTA_READ_CMD;
34004472:	78fb      	ldrb	r3, [r7, #3]
34004474:	2b00      	cmp	r3, #0
34004476:	d106      	bne.n	34004486 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x76>
34004478:	78bb      	ldrb	r3, [r7, #2]
3400447a:	2b00      	cmp	r3, #0
3400447c:	d101      	bne.n	34004482 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x72>
3400447e:	230b      	movs	r3, #11
34004480:	e003      	b.n	3400448a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x7a>
34004482:	230c      	movs	r3, #12
34004484:	e001      	b.n	3400448a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x7a>
34004486:	f64e 4313 	movw	r3, #60435	@ 0xec13
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3400448a:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
3400448c:	78fb      	ldrb	r3, [r7, #3]
3400448e:	2b00      	cmp	r3, #0
34004490:	d102      	bne.n	34004498 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x88>
34004492:	f44f 7380 	mov.w	r3, #256	@ 0x100
34004496:	e001      	b.n	3400449c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x8c>
34004498:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3400449c:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
3400449e:	2300      	movs	r3, #0
340044a0:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                               ? HAL_XSPI_ADDRESS_24_BITS
                               : HAL_XSPI_ADDRESS_32_BITS;
340044a2:	78bb      	ldrb	r3, [r7, #2]
340044a4:	2b00      	cmp	r3, #0
340044a6:	d102      	bne.n	340044ae <MX66UW1G45G_EnableSTRMemoryMappedMode+0x9e>
340044a8:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340044ac:	e001      	b.n	340044b2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xa2>
340044ae:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
340044b2:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340044b4:	2300      	movs	r3, #0
340044b6:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
340044b8:	78fb      	ldrb	r3, [r7, #3]
340044ba:	2b00      	cmp	r3, #0
340044bc:	d102      	bne.n	340044c4 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xb4>
340044be:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340044c2:	e001      	b.n	340044c8 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xb8>
340044c4:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340044c8:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
340044ca:	2300      	movs	r3, #0
340044cc:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
340044ce:	78fb      	ldrb	r3, [r7, #3]
340044d0:	2b00      	cmp	r3, #0
340044d2:	d101      	bne.n	340044d8 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xc8>
340044d4:	2308      	movs	r3, #8
340044d6:	e000      	b.n	340044da <MX66UW1G45G_EnableSTRMemoryMappedMode+0xca>
340044d8:	230a      	movs	r3, #10
340044da:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
340044dc:	2300      	movs	r3, #0
340044de:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the read command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340044e0:	f107 031c 	add.w	r3, r7, #28
340044e4:	f241 3288 	movw	r2, #5000	@ 0x1388
340044e8:	4619      	mov	r1, r3
340044ea:	6878      	ldr	r0, [r7, #4]
340044ec:	f017 f818 	bl	3401b520 <HAL_XSPI_Command>
340044f0:	4603      	mov	r3, r0
340044f2:	2b00      	cmp	r3, #0
340044f4:	d002      	beq.n	340044fc <MX66UW1G45G_EnableSTRMemoryMappedMode+0xec>
  {
    return MX66UW1G45G_ERROR;
340044f6:	f04f 33ff 	mov.w	r3, #4294967295
340044fa:	e02d      	b.n	34004558 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
340044fc:	2302      	movs	r3, #2
340044fe:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? ((AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                                     ? MX66UW1G45G_PAGE_PROG_CMD
                                     : MX66UW1G45G_4_BYTE_PAGE_PROG_CMD)
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34004500:	78fb      	ldrb	r3, [r7, #3]
34004502:	2b00      	cmp	r3, #0
34004504:	d106      	bne.n	34004514 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x104>
34004506:	78bb      	ldrb	r3, [r7, #2]
34004508:	2b00      	cmp	r3, #0
3400450a:	d101      	bne.n	34004510 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x100>
3400450c:	2302      	movs	r3, #2
3400450e:	e003      	b.n	34004518 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x108>
34004510:	2312      	movs	r3, #18
34004512:	e001      	b.n	34004518 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x108>
34004514:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34004518:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles = 0U;
3400451a:	2300      	movs	r3, #0
3400451c:	663b      	str	r3, [r7, #96]	@ 0x60

  /* Send the write command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400451e:	f107 031c 	add.w	r3, r7, #28
34004522:	f241 3288 	movw	r2, #5000	@ 0x1388
34004526:	4619      	mov	r1, r3
34004528:	6878      	ldr	r0, [r7, #4]
3400452a:	f016 fff9 	bl	3401b520 <HAL_XSPI_Command>
3400452e:	4603      	mov	r3, r0
34004530:	2b00      	cmp	r3, #0
34004532:	d002      	beq.n	3400453a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x12a>
  {
    return MX66UW1G45G_ERROR;
34004534:	f04f 33ff 	mov.w	r3, #4294967295
34004538:	e00e      	b.n	34004558 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
3400453a:	2300      	movs	r3, #0
3400453c:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
3400453e:	f107 030c 	add.w	r3, r7, #12
34004542:	4619      	mov	r1, r3
34004544:	6878      	ldr	r0, [r7, #4]
34004546:	f017 fbdd 	bl	3401bd04 <HAL_XSPI_MemoryMapped>
3400454a:	4603      	mov	r3, r0
3400454c:	2b00      	cmp	r3, #0
3400454e:	d002      	beq.n	34004556 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x146>
  {
    return MX66UW1G45G_ERROR;
34004550:	f04f 33ff 	mov.w	r3, #4294967295
34004554:	e000      	b.n	34004558 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  return MX66UW1G45G_OK;
34004556:	2300      	movs	r3, #0
}
34004558:	4618      	mov	r0, r3
3400455a:	3768      	adds	r7, #104	@ 0x68
3400455c:	46bd      	mov	sp, r7
3400455e:	bd80      	pop	{r7, pc}

34004560 <MX66UW1G45G_EnableDTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode)
{
34004560:	b580      	push	{r7, lr}
34004562:	b09a      	sub	sp, #104	@ 0x68
34004564:	af00      	add	r7, sp, #0
34004566:	6078      	str	r0, [r7, #4]
34004568:	460b      	mov	r3, r1
3400456a:	70fb      	strb	r3, [r7, #3]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef s_command = {0};
3400456c:	f107 031c 	add.w	r3, r7, #28
34004570:	224c      	movs	r2, #76	@ 0x4c
34004572:	2100      	movs	r1, #0
34004574:	4618      	mov	r0, r3
34004576:	f01d f82d 	bl	340215d4 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
3400457a:	f107 030c 	add.w	r3, r7, #12
3400457e:	2200      	movs	r2, #0
34004580:	601a      	str	r2, [r3, #0]
34004582:	605a      	str	r2, [r3, #4]
34004584:	609a      	str	r2, [r3, #8]
34004586:	60da      	str	r2, [r3, #12]

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34004588:	2301      	movs	r3, #1
3400458a:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
3400458c:	2304      	movs	r3, #4
3400458e:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
34004590:	2308      	movs	r3, #8
34004592:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
34004594:	2310      	movs	r3, #16
34004596:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = MX66UW1G45G_OCTA_READ_DTR_CMD;
34004598:	f64e 6311 	movw	r3, #60945	@ 0xee11
3400459c:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
3400459e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340045a2:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
340045a4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340045a8:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
340045aa:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340045ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340045b0:	2300      	movs	r3, #0
340045b2:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
340045b4:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340045b8:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
340045ba:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340045be:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
340045c0:	230a      	movs	r3, #10
340045c2:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
340045c4:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
340045c8:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340045ca:	f107 031c 	add.w	r3, r7, #28
340045ce:	f241 3288 	movw	r2, #5000	@ 0x1388
340045d2:	4619      	mov	r1, r3
340045d4:	6878      	ldr	r0, [r7, #4]
340045d6:	f016 ffa3 	bl	3401b520 <HAL_XSPI_Command>
340045da:	4603      	mov	r3, r0
340045dc:	2b00      	cmp	r3, #0
340045de:	d002      	beq.n	340045e6 <MX66UW1G45G_EnableDTRMemoryMappedMode+0x86>
  {
    return MX66UW1G45G_ERROR;
340045e0:	f04f 33ff 	mov.w	r3, #4294967295
340045e4:	e025      	b.n	34004632 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
340045e6:	2302      	movs	r3, #2
340045e8:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
340045ea:	f241 23ed 	movw	r3, #4845	@ 0x12ed
340045ee:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles = 0U;
340045f0:	2300      	movs	r3, #0
340045f2:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
340045f4:	2300      	movs	r3, #0
340045f6:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340045f8:	f107 031c 	add.w	r3, r7, #28
340045fc:	f241 3288 	movw	r2, #5000	@ 0x1388
34004600:	4619      	mov	r1, r3
34004602:	6878      	ldr	r0, [r7, #4]
34004604:	f016 ff8c 	bl	3401b520 <HAL_XSPI_Command>
34004608:	4603      	mov	r3, r0
3400460a:	2b00      	cmp	r3, #0
3400460c:	d002      	beq.n	34004614 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xb4>
  {
    return MX66UW1G45G_ERROR;
3400460e:	f04f 33ff 	mov.w	r3, #4294967295
34004612:	e00e      	b.n	34004632 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }
  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34004614:	2300      	movs	r3, #0
34004616:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34004618:	f107 030c 	add.w	r3, r7, #12
3400461c:	4619      	mov	r1, r3
3400461e:	6878      	ldr	r0, [r7, #4]
34004620:	f017 fb70 	bl	3401bd04 <HAL_XSPI_MemoryMapped>
34004624:	4603      	mov	r3, r0
34004626:	2b00      	cmp	r3, #0
34004628:	d002      	beq.n	34004630 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd0>
  {
    return MX66UW1G45G_ERROR;
3400462a:	f04f 33ff 	mov.w	r3, #4294967295
3400462e:	e000      	b.n	34004632 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }

  return MX66UW1G45G_OK;
34004630:	2300      	movs	r3, #0
}
34004632:	4618      	mov	r0, r3
34004634:	3768      	adds	r7, #104	@ 0x68
34004636:	46bd      	mov	sp, r7
34004638:	bd80      	pop	{r7, pc}

3400463a <MX66UW1G45G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
3400463a:	b580      	push	{r7, lr}
3400463c:	b09a      	sub	sp, #104	@ 0x68
3400463e:	af00      	add	r7, sp, #0
34004640:	6078      	str	r0, [r7, #4]
34004642:	460b      	mov	r3, r1
34004644:	70fb      	strb	r3, [r7, #3]
34004646:	4613      	mov	r3, r2
34004648:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
3400464a:	f107 031c 	add.w	r3, r7, #28
3400464e:	224c      	movs	r2, #76	@ 0x4c
34004650:	2100      	movs	r1, #0
34004652:	4618      	mov	r0, r3
34004654:	f01c ffbe 	bl	340215d4 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
34004658:	f107 0308 	add.w	r3, r7, #8
3400465c:	2200      	movs	r2, #0
3400465e:	601a      	str	r2, [r3, #0]
34004660:	605a      	str	r2, [r3, #4]
34004662:	609a      	str	r2, [r3, #8]
34004664:	60da      	str	r2, [r3, #12]
34004666:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34004668:	78fb      	ldrb	r3, [r7, #3]
3400466a:	2b00      	cmp	r3, #0
3400466c:	d105      	bne.n	3400467a <MX66UW1G45G_WriteEnable+0x40>
3400466e:	78bb      	ldrb	r3, [r7, #2]
34004670:	2b01      	cmp	r3, #1
34004672:	d102      	bne.n	3400467a <MX66UW1G45G_WriteEnable+0x40>
  {
    return MX66UW1G45G_ERROR;
34004674:	f04f 33ff 	mov.w	r3, #4294967295
34004678:	e0a7      	b.n	340047ca <MX66UW1G45G_WriteEnable+0x190>
  }

  /* Initialize the write enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
3400467a:	2300      	movs	r3, #0
3400467c:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
3400467e:	78fb      	ldrb	r3, [r7, #3]
34004680:	2b00      	cmp	r3, #0
34004682:	d101      	bne.n	34004688 <MX66UW1G45G_WriteEnable+0x4e>
34004684:	2301      	movs	r3, #1
34004686:	e000      	b.n	3400468a <MX66UW1G45G_WriteEnable+0x50>
34004688:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
3400468a:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3400468c:	78bb      	ldrb	r3, [r7, #2]
3400468e:	2b01      	cmp	r3, #1
34004690:	d101      	bne.n	34004696 <MX66UW1G45G_WriteEnable+0x5c>
34004692:	2308      	movs	r3, #8
34004694:	e000      	b.n	34004698 <MX66UW1G45G_WriteEnable+0x5e>
34004696:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004698:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
3400469a:	78fb      	ldrb	r3, [r7, #3]
3400469c:	2b00      	cmp	r3, #0
3400469e:	d101      	bne.n	340046a4 <MX66UW1G45G_WriteEnable+0x6a>
340046a0:	2300      	movs	r3, #0
340046a2:	e000      	b.n	340046a6 <MX66UW1G45G_WriteEnable+0x6c>
340046a4:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
340046a6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_WRITE_ENABLE_CMD
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
340046a8:	78fb      	ldrb	r3, [r7, #3]
340046aa:	2b00      	cmp	r3, #0
340046ac:	d101      	bne.n	340046b2 <MX66UW1G45G_WriteEnable+0x78>
340046ae:	2306      	movs	r3, #6
340046b0:	e001      	b.n	340046b6 <MX66UW1G45G_WriteEnable+0x7c>
340046b2:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340046b6:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
340046b8:	2300      	movs	r3, #0
340046ba:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
340046bc:	2300      	movs	r3, #0
340046be:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = HAL_XSPI_DATA_NONE;
340046c0:	2300      	movs	r3, #0
340046c2:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = 0U;
340046c4:	2300      	movs	r3, #0
340046c6:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
340046c8:	2300      	movs	r3, #0
340046ca:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340046cc:	f107 031c 	add.w	r3, r7, #28
340046d0:	f241 3288 	movw	r2, #5000	@ 0x1388
340046d4:	4619      	mov	r1, r3
340046d6:	6878      	ldr	r0, [r7, #4]
340046d8:	f016 ff22 	bl	3401b520 <HAL_XSPI_Command>
340046dc:	4603      	mov	r3, r0
340046de:	2b00      	cmp	r3, #0
340046e0:	d002      	beq.n	340046e8 <MX66UW1G45G_WriteEnable+0xae>
  {
    return MX66UW1G45G_ERROR;
340046e2:	f04f 33ff 	mov.w	r3, #4294967295
340046e6:	e070      	b.n	340047ca <MX66UW1G45G_WriteEnable+0x190>
  }

  /* Configure automatic polling mode to wait for write enabling */
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_STATUS_REG_CMD
                              : MX66UW1G45G_OCTA_READ_STATUS_REG_CMD;
340046e8:	78fb      	ldrb	r3, [r7, #3]
340046ea:	2b00      	cmp	r3, #0
340046ec:	d101      	bne.n	340046f2 <MX66UW1G45G_WriteEnable+0xb8>
340046ee:	2305      	movs	r3, #5
340046f0:	e001      	b.n	340046f6 <MX66UW1G45G_WriteEnable+0xbc>
340046f2:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
340046f6:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
340046f8:	78fb      	ldrb	r3, [r7, #3]
340046fa:	2b00      	cmp	r3, #0
340046fc:	d101      	bne.n	34004702 <MX66UW1G45G_WriteEnable+0xc8>
340046fe:	2300      	movs	r3, #0
34004700:	e001      	b.n	34004706 <MX66UW1G45G_WriteEnable+0xcc>
34004702:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34004706:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34004708:	78bb      	ldrb	r3, [r7, #2]
3400470a:	2b01      	cmp	r3, #1
3400470c:	d102      	bne.n	34004714 <MX66UW1G45G_WriteEnable+0xda>
3400470e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34004712:	e000      	b.n	34004716 <MX66UW1G45G_WriteEnable+0xdc>
34004714:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004716:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34004718:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3400471c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address = 0U;
3400471e:	2300      	movs	r3, #0
34004720:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34004722:	78fb      	ldrb	r3, [r7, #3]
34004724:	2b00      	cmp	r3, #0
34004726:	d102      	bne.n	3400472e <MX66UW1G45G_WriteEnable+0xf4>
34004728:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400472c:	e001      	b.n	34004732 <MX66UW1G45G_WriteEnable+0xf8>
3400472e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34004732:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34004734:	78bb      	ldrb	r3, [r7, #2]
34004736:	2b01      	cmp	r3, #1
34004738:	d102      	bne.n	34004740 <MX66UW1G45G_WriteEnable+0x106>
3400473a:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3400473e:	e000      	b.n	34004742 <MX66UW1G45G_WriteEnable+0x108>
34004740:	2300      	movs	r3, #0
34004742:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34004744:	78fb      	ldrb	r3, [r7, #3]
34004746:	2b00      	cmp	r3, #0
34004748:	d006      	beq.n	34004758 <MX66UW1G45G_WriteEnable+0x11e>
3400474a:	78bb      	ldrb	r3, [r7, #2]
3400474c:	2b01      	cmp	r3, #1
3400474e:	d101      	bne.n	34004754 <MX66UW1G45G_WriteEnable+0x11a>
34004750:	2305      	movs	r3, #5
34004752:	e002      	b.n	3400475a <MX66UW1G45G_WriteEnable+0x120>
34004754:	2304      	movs	r3, #4
34004756:	e000      	b.n	3400475a <MX66UW1G45G_WriteEnable+0x120>
34004758:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
3400475a:	663b      	str	r3, [r7, #96]	@ 0x60
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
3400475c:	78bb      	ldrb	r3, [r7, #2]
3400475e:	2b01      	cmp	r3, #1
34004760:	d101      	bne.n	34004766 <MX66UW1G45G_WriteEnable+0x12c>
34004762:	2302      	movs	r3, #2
34004764:	e000      	b.n	34004768 <MX66UW1G45G_WriteEnable+0x12e>
34004766:	2301      	movs	r3, #1
34004768:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
3400476a:	78bb      	ldrb	r3, [r7, #2]
3400476c:	2b01      	cmp	r3, #1
3400476e:	d102      	bne.n	34004776 <MX66UW1G45G_WriteEnable+0x13c>
34004770:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34004774:	e000      	b.n	34004778 <MX66UW1G45G_WriteEnable+0x13e>
34004776:	2300      	movs	r3, #0
34004778:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400477a:	f107 031c 	add.w	r3, r7, #28
3400477e:	f241 3288 	movw	r2, #5000	@ 0x1388
34004782:	4619      	mov	r1, r3
34004784:	6878      	ldr	r0, [r7, #4]
34004786:	f016 fecb 	bl	3401b520 <HAL_XSPI_Command>
3400478a:	4603      	mov	r3, r0
3400478c:	2b00      	cmp	r3, #0
3400478e:	d002      	beq.n	34004796 <MX66UW1G45G_WriteEnable+0x15c>
  {
    return MX66UW1G45G_ERROR;
34004790:	f04f 33ff 	mov.w	r3, #4294967295
34004794:	e019      	b.n	340047ca <MX66UW1G45G_WriteEnable+0x190>
  }

  s_config.MatchValue = 2U;
34004796:	2302      	movs	r3, #2
34004798:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask = 2U;
3400479a:	2302      	movs	r3, #2
3400479c:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
3400479e:	2300      	movs	r3, #0
340047a0:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime = MX66UW1G45G_AUTOPOLLING_INTERVAL_TIME;
340047a2:	2310      	movs	r3, #16
340047a4:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
340047a6:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
340047aa:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340047ac:	f107 0308 	add.w	r3, r7, #8
340047b0:	f241 3288 	movw	r2, #5000	@ 0x1388
340047b4:	4619      	mov	r1, r3
340047b6:	6878      	ldr	r0, [r7, #4]
340047b8:	f017 f9da 	bl	3401bb70 <HAL_XSPI_AutoPolling>
340047bc:	4603      	mov	r3, r0
340047be:	2b00      	cmp	r3, #0
340047c0:	d002      	beq.n	340047c8 <MX66UW1G45G_WriteEnable+0x18e>
  {
    return MX66UW1G45G_ERROR;
340047c2:	f04f 33ff 	mov.w	r3, #4294967295
340047c6:	e000      	b.n	340047ca <MX66UW1G45G_WriteEnable+0x190>
  }

  return MX66UW1G45G_OK;
340047c8:	2300      	movs	r3, #0
}
340047ca:	4618      	mov	r0, r3
340047cc:	3768      	adds	r7, #104	@ 0x68
340047ce:	46bd      	mov	sp, r7
340047d0:	bd80      	pop	{r7, pc}

340047d2 <MX66UW1G45G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX66UW1G45G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                      MX66UW1G45G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
340047d2:	b580      	push	{r7, lr}
340047d4:	b098      	sub	sp, #96	@ 0x60
340047d6:	af00      	add	r7, sp, #0
340047d8:	60f8      	str	r0, [r7, #12]
340047da:	607b      	str	r3, [r7, #4]
340047dc:	460b      	mov	r3, r1
340047de:	72fb      	strb	r3, [r7, #11]
340047e0:	4613      	mov	r3, r2
340047e2:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
340047e4:	f107 0314 	add.w	r3, r7, #20
340047e8:	224c      	movs	r2, #76	@ 0x4c
340047ea:	2100      	movs	r1, #0
340047ec:	4618      	mov	r0, r3
340047ee:	f01c fef1 	bl	340215d4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340047f2:	7afb      	ldrb	r3, [r7, #11]
340047f4:	2b00      	cmp	r3, #0
340047f6:	d105      	bne.n	34004804 <MX66UW1G45G_WriteCfg2Register+0x32>
340047f8:	7abb      	ldrb	r3, [r7, #10]
340047fa:	2b01      	cmp	r3, #1
340047fc:	d102      	bne.n	34004804 <MX66UW1G45G_WriteCfg2Register+0x32>
  {
    return MX66UW1G45G_ERROR;
340047fe:	f04f 33ff 	mov.w	r3, #4294967295
34004802:	e073      	b.n	340048ec <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  /* Initialize the writing of configuration register 2 */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34004804:	2300      	movs	r3, #0
34004806:	617b      	str	r3, [r7, #20]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34004808:	7afb      	ldrb	r3, [r7, #11]
3400480a:	2b00      	cmp	r3, #0
3400480c:	d101      	bne.n	34004812 <MX66UW1G45G_WriteCfg2Register+0x40>
3400480e:	2301      	movs	r3, #1
34004810:	e000      	b.n	34004814 <MX66UW1G45G_WriteCfg2Register+0x42>
34004812:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34004814:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34004816:	7abb      	ldrb	r3, [r7, #10]
34004818:	2b01      	cmp	r3, #1
3400481a:	d101      	bne.n	34004820 <MX66UW1G45G_WriteCfg2Register+0x4e>
3400481c:	2308      	movs	r3, #8
3400481e:	e000      	b.n	34004822 <MX66UW1G45G_WriteCfg2Register+0x50>
34004820:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004822:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34004824:	7afb      	ldrb	r3, [r7, #11]
34004826:	2b00      	cmp	r3, #0
34004828:	d101      	bne.n	3400482e <MX66UW1G45G_WriteCfg2Register+0x5c>
3400482a:	2300      	movs	r3, #0
3400482c:	e000      	b.n	34004830 <MX66UW1G45G_WriteCfg2Register+0x5e>
3400482e:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34004830:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_WRITE_CFG_REG2_CMD
                              : MX66UW1G45G_OCTA_WRITE_CFG_REG2_CMD;
34004832:	7afb      	ldrb	r3, [r7, #11]
34004834:	2b00      	cmp	r3, #0
34004836:	d101      	bne.n	3400483c <MX66UW1G45G_WriteCfg2Register+0x6a>
34004838:	2372      	movs	r3, #114	@ 0x72
3400483a:	e001      	b.n	34004840 <MX66UW1G45G_WriteCfg2Register+0x6e>
3400483c:	f247 238d 	movw	r3, #29325	@ 0x728d
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34004840:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34004842:	7afb      	ldrb	r3, [r7, #11]
34004844:	2b00      	cmp	r3, #0
34004846:	d102      	bne.n	3400484e <MX66UW1G45G_WriteCfg2Register+0x7c>
34004848:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400484c:	e001      	b.n	34004852 <MX66UW1G45G_WriteCfg2Register+0x80>
3400484e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34004852:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34004854:	7abb      	ldrb	r3, [r7, #10]
34004856:	2b01      	cmp	r3, #1
34004858:	d102      	bne.n	34004860 <MX66UW1G45G_WriteCfg2Register+0x8e>
3400485a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400485e:	e000      	b.n	34004862 <MX66UW1G45G_WriteCfg2Register+0x90>
34004860:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004862:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34004864:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34004868:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address = WriteAddr;
3400486a:	687b      	ldr	r3, [r7, #4]
3400486c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
3400486e:	2300      	movs	r3, #0
34004870:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34004872:	7afb      	ldrb	r3, [r7, #11]
34004874:	2b00      	cmp	r3, #0
34004876:	d102      	bne.n	3400487e <MX66UW1G45G_WriteCfg2Register+0xac>
34004878:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400487c:	e001      	b.n	34004882 <MX66UW1G45G_WriteCfg2Register+0xb0>
3400487e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34004882:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
34004884:	7abb      	ldrb	r3, [r7, #10]
34004886:	2b01      	cmp	r3, #1
34004888:	d102      	bne.n	34004890 <MX66UW1G45G_WriteCfg2Register+0xbe>
3400488a:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3400488e:	e000      	b.n	34004892 <MX66UW1G45G_WriteCfg2Register+0xc0>
34004890:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004892:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = 0U;
34004894:	2300      	movs	r3, #0
34004896:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34004898:	7afb      	ldrb	r3, [r7, #11]
3400489a:	2b00      	cmp	r3, #0
3400489c:	d006      	beq.n	340048ac <MX66UW1G45G_WriteCfg2Register+0xda>
3400489e:	7abb      	ldrb	r3, [r7, #10]
340048a0:	2b01      	cmp	r3, #1
340048a2:	d101      	bne.n	340048a8 <MX66UW1G45G_WriteCfg2Register+0xd6>
340048a4:	2302      	movs	r3, #2
340048a6:	e002      	b.n	340048ae <MX66UW1G45G_WriteCfg2Register+0xdc>
340048a8:	2301      	movs	r3, #1
340048aa:	e000      	b.n	340048ae <MX66UW1G45G_WriteCfg2Register+0xdc>
340048ac:	2301      	movs	r3, #1
340048ae:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
340048b0:	2300      	movs	r3, #0
340048b2:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340048b4:	f107 0314 	add.w	r3, r7, #20
340048b8:	f241 3288 	movw	r2, #5000	@ 0x1388
340048bc:	4619      	mov	r1, r3
340048be:	68f8      	ldr	r0, [r7, #12]
340048c0:	f016 fe2e 	bl	3401b520 <HAL_XSPI_Command>
340048c4:	4603      	mov	r3, r0
340048c6:	2b00      	cmp	r3, #0
340048c8:	d002      	beq.n	340048d0 <MX66UW1G45G_WriteCfg2Register+0xfe>
  {
    return MX66UW1G45G_ERROR;
340048ca:	f04f 33ff 	mov.w	r3, #4294967295
340048ce:	e00d      	b.n	340048ec <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340048d0:	f241 3288 	movw	r2, #5000	@ 0x1388
340048d4:	f107 0168 	add.w	r1, r7, #104	@ 0x68
340048d8:	68f8      	ldr	r0, [r7, #12]
340048da:	f017 f833 	bl	3401b944 <HAL_XSPI_Transmit>
340048de:	4603      	mov	r3, r0
340048e0:	2b00      	cmp	r3, #0
340048e2:	d002      	beq.n	340048ea <MX66UW1G45G_WriteCfg2Register+0x118>
  {
    return MX66UW1G45G_ERROR;
340048e4:	f04f 33ff 	mov.w	r3, #4294967295
340048e8:	e000      	b.n	340048ec <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  return MX66UW1G45G_OK;
340048ea:	2300      	movs	r3, #0
}
340048ec:	4618      	mov	r0, r3
340048ee:	3760      	adds	r7, #96	@ 0x60
340048f0:	46bd      	mov	sp, r7
340048f2:	bd80      	pop	{r7, pc}

340048f4 <MX66UW1G45G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX66UW1G45G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                     MX66UW1G45G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
340048f4:	b580      	push	{r7, lr}
340048f6:	b098      	sub	sp, #96	@ 0x60
340048f8:	af00      	add	r7, sp, #0
340048fa:	60f8      	str	r0, [r7, #12]
340048fc:	607b      	str	r3, [r7, #4]
340048fe:	460b      	mov	r3, r1
34004900:	72fb      	strb	r3, [r7, #11]
34004902:	4613      	mov	r3, r2
34004904:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
34004906:	f107 0314 	add.w	r3, r7, #20
3400490a:	224c      	movs	r2, #76	@ 0x4c
3400490c:	2100      	movs	r1, #0
3400490e:	4618      	mov	r0, r3
34004910:	f01c fe60 	bl	340215d4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34004914:	7afb      	ldrb	r3, [r7, #11]
34004916:	2b00      	cmp	r3, #0
34004918:	d105      	bne.n	34004926 <MX66UW1G45G_ReadCfg2Register+0x32>
3400491a:	7abb      	ldrb	r3, [r7, #10]
3400491c:	2b01      	cmp	r3, #1
3400491e:	d102      	bne.n	34004926 <MX66UW1G45G_ReadCfg2Register+0x32>
  {
    return MX66UW1G45G_ERROR;
34004920:	f04f 33ff 	mov.w	r3, #4294967295
34004924:	e07d      	b.n	34004a22 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  /* Initialize the reading of status register */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34004926:	2300      	movs	r3, #0
34004928:	617b      	str	r3, [r7, #20]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
3400492a:	7afb      	ldrb	r3, [r7, #11]
3400492c:	2b00      	cmp	r3, #0
3400492e:	d101      	bne.n	34004934 <MX66UW1G45G_ReadCfg2Register+0x40>
34004930:	2301      	movs	r3, #1
34004932:	e000      	b.n	34004936 <MX66UW1G45G_ReadCfg2Register+0x42>
34004934:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34004936:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34004938:	7abb      	ldrb	r3, [r7, #10]
3400493a:	2b01      	cmp	r3, #1
3400493c:	d101      	bne.n	34004942 <MX66UW1G45G_ReadCfg2Register+0x4e>
3400493e:	2308      	movs	r3, #8
34004940:	e000      	b.n	34004944 <MX66UW1G45G_ReadCfg2Register+0x50>
34004942:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004944:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34004946:	7afb      	ldrb	r3, [r7, #11]
34004948:	2b00      	cmp	r3, #0
3400494a:	d101      	bne.n	34004950 <MX66UW1G45G_ReadCfg2Register+0x5c>
3400494c:	2300      	movs	r3, #0
3400494e:	e000      	b.n	34004952 <MX66UW1G45G_ReadCfg2Register+0x5e>
34004950:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34004952:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_CFG_REG2_CMD
                              : MX66UW1G45G_OCTA_READ_CFG_REG2_CMD;
34004954:	7afb      	ldrb	r3, [r7, #11]
34004956:	2b00      	cmp	r3, #0
34004958:	d101      	bne.n	3400495e <MX66UW1G45G_ReadCfg2Register+0x6a>
3400495a:	2371      	movs	r3, #113	@ 0x71
3400495c:	e001      	b.n	34004962 <MX66UW1G45G_ReadCfg2Register+0x6e>
3400495e:	f247 138e 	movw	r3, #29070	@ 0x718e
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34004962:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34004964:	7afb      	ldrb	r3, [r7, #11]
34004966:	2b00      	cmp	r3, #0
34004968:	d102      	bne.n	34004970 <MX66UW1G45G_ReadCfg2Register+0x7c>
3400496a:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400496e:	e001      	b.n	34004974 <MX66UW1G45G_ReadCfg2Register+0x80>
34004970:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34004974:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34004976:	7abb      	ldrb	r3, [r7, #10]
34004978:	2b01      	cmp	r3, #1
3400497a:	d102      	bne.n	34004982 <MX66UW1G45G_ReadCfg2Register+0x8e>
3400497c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34004980:	e000      	b.n	34004984 <MX66UW1G45G_ReadCfg2Register+0x90>
34004982:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004984:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34004986:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3400498a:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address = ReadAddr;
3400498c:	687b      	ldr	r3, [r7, #4]
3400498e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34004990:	2300      	movs	r3, #0
34004992:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34004994:	7afb      	ldrb	r3, [r7, #11]
34004996:	2b00      	cmp	r3, #0
34004998:	d102      	bne.n	340049a0 <MX66UW1G45G_ReadCfg2Register+0xac>
3400499a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400499e:	e001      	b.n	340049a4 <MX66UW1G45G_ReadCfg2Register+0xb0>
340049a0:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
340049a4:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
340049a6:	7abb      	ldrb	r3, [r7, #10]
340049a8:	2b01      	cmp	r3, #1
340049aa:	d102      	bne.n	340049b2 <MX66UW1G45G_ReadCfg2Register+0xbe>
340049ac:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340049b0:	e000      	b.n	340049b4 <MX66UW1G45G_ReadCfg2Register+0xc0>
340049b2:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
340049b4:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
340049b6:	7afb      	ldrb	r3, [r7, #11]
340049b8:	2b00      	cmp	r3, #0
340049ba:	d006      	beq.n	340049ca <MX66UW1G45G_ReadCfg2Register+0xd6>
340049bc:	7abb      	ldrb	r3, [r7, #10]
340049be:	2b01      	cmp	r3, #1
340049c0:	d101      	bne.n	340049c6 <MX66UW1G45G_ReadCfg2Register+0xd2>
340049c2:	2305      	movs	r3, #5
340049c4:	e002      	b.n	340049cc <MX66UW1G45G_ReadCfg2Register+0xd8>
340049c6:	2304      	movs	r3, #4
340049c8:	e000      	b.n	340049cc <MX66UW1G45G_ReadCfg2Register+0xd8>
340049ca:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
340049cc:	65bb      	str	r3, [r7, #88]	@ 0x58
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
340049ce:	7abb      	ldrb	r3, [r7, #10]
340049d0:	2b01      	cmp	r3, #1
340049d2:	d101      	bne.n	340049d8 <MX66UW1G45G_ReadCfg2Register+0xe4>
340049d4:	2302      	movs	r3, #2
340049d6:	e000      	b.n	340049da <MX66UW1G45G_ReadCfg2Register+0xe6>
340049d8:	2301      	movs	r3, #1
340049da:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
340049dc:	7abb      	ldrb	r3, [r7, #10]
340049de:	2b01      	cmp	r3, #1
340049e0:	d102      	bne.n	340049e8 <MX66UW1G45G_ReadCfg2Register+0xf4>
340049e2:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
340049e6:	e000      	b.n	340049ea <MX66UW1G45G_ReadCfg2Register+0xf6>
340049e8:	2300      	movs	r3, #0
340049ea:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340049ec:	f107 0314 	add.w	r3, r7, #20
340049f0:	f241 3288 	movw	r2, #5000	@ 0x1388
340049f4:	4619      	mov	r1, r3
340049f6:	68f8      	ldr	r0, [r7, #12]
340049f8:	f016 fd92 	bl	3401b520 <HAL_XSPI_Command>
340049fc:	4603      	mov	r3, r0
340049fe:	2b00      	cmp	r3, #0
34004a00:	d002      	beq.n	34004a08 <MX66UW1G45G_ReadCfg2Register+0x114>
  {
    return MX66UW1G45G_ERROR;
34004a02:	f04f 33ff 	mov.w	r3, #4294967295
34004a06:	e00c      	b.n	34004a22 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  /* Reception of the data */
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34004a08:	f241 3288 	movw	r2, #5000	@ 0x1388
34004a0c:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
34004a0e:	68f8      	ldr	r0, [r7, #12]
34004a10:	f017 f80b 	bl	3401ba2a <HAL_XSPI_Receive>
34004a14:	4603      	mov	r3, r0
34004a16:	2b00      	cmp	r3, #0
34004a18:	d002      	beq.n	34004a20 <MX66UW1G45G_ReadCfg2Register+0x12c>
  {
    return MX66UW1G45G_ERROR;
34004a1a:	f04f 33ff 	mov.w	r3, #4294967295
34004a1e:	e000      	b.n	34004a22 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  return MX66UW1G45G_OK;
34004a20:	2300      	movs	r3, #0
}
34004a22:	4618      	mov	r0, r3
34004a24:	3760      	adds	r7, #96	@ 0x60
34004a26:	46bd      	mov	sp, r7
34004a28:	bd80      	pop	{r7, pc}

34004a2a <MX66UW1G45G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34004a2a:	b580      	push	{r7, lr}
34004a2c:	b096      	sub	sp, #88	@ 0x58
34004a2e:	af00      	add	r7, sp, #0
34004a30:	6078      	str	r0, [r7, #4]
34004a32:	460b      	mov	r3, r1
34004a34:	70fb      	strb	r3, [r7, #3]
34004a36:	4613      	mov	r3, r2
34004a38:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34004a3a:	f107 030c 	add.w	r3, r7, #12
34004a3e:	224c      	movs	r2, #76	@ 0x4c
34004a40:	2100      	movs	r1, #0
34004a42:	4618      	mov	r0, r3
34004a44:	f01c fdc6 	bl	340215d4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34004a48:	78fb      	ldrb	r3, [r7, #3]
34004a4a:	2b00      	cmp	r3, #0
34004a4c:	d105      	bne.n	34004a5a <MX66UW1G45G_ResetEnable+0x30>
34004a4e:	78bb      	ldrb	r3, [r7, #2]
34004a50:	2b01      	cmp	r3, #1
34004a52:	d102      	bne.n	34004a5a <MX66UW1G45G_ResetEnable+0x30>
  {
    return MX66UW1G45G_ERROR;
34004a54:	f04f 33ff 	mov.w	r3, #4294967295
34004a58:	e039      	b.n	34004ace <MX66UW1G45G_ResetEnable+0xa4>
  }

  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34004a5a:	2300      	movs	r3, #0
34004a5c:	60fb      	str	r3, [r7, #12]
  s_command.IOSelect =  HAL_XSPI_SELECT_IO_3_0;
34004a5e:	2300      	movs	r3, #0
34004a60:	613b      	str	r3, [r7, #16]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34004a62:	78fb      	ldrb	r3, [r7, #3]
34004a64:	2b00      	cmp	r3, #0
34004a66:	d101      	bne.n	34004a6c <MX66UW1G45G_ResetEnable+0x42>
34004a68:	2301      	movs	r3, #1
34004a6a:	e000      	b.n	34004a6e <MX66UW1G45G_ResetEnable+0x44>
34004a6c:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34004a6e:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34004a70:	78bb      	ldrb	r3, [r7, #2]
34004a72:	2b01      	cmp	r3, #1
34004a74:	d101      	bne.n	34004a7a <MX66UW1G45G_ResetEnable+0x50>
34004a76:	2308      	movs	r3, #8
34004a78:	e000      	b.n	34004a7c <MX66UW1G45G_ResetEnable+0x52>
34004a7a:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004a7c:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34004a7e:	78fb      	ldrb	r3, [r7, #3]
34004a80:	2b00      	cmp	r3, #0
34004a82:	d101      	bne.n	34004a88 <MX66UW1G45G_ResetEnable+0x5e>
34004a84:	2300      	movs	r3, #0
34004a86:	e000      	b.n	34004a8a <MX66UW1G45G_ResetEnable+0x60>
34004a88:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34004a8a:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_ENABLE_CMD
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34004a8c:	78fb      	ldrb	r3, [r7, #3]
34004a8e:	2b00      	cmp	r3, #0
34004a90:	d101      	bne.n	34004a96 <MX66UW1G45G_ResetEnable+0x6c>
34004a92:	2366      	movs	r3, #102	@ 0x66
34004a94:	e001      	b.n	34004a9a <MX66UW1G45G_ResetEnable+0x70>
34004a96:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34004a9a:	617b      	str	r3, [r7, #20]
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
34004a9c:	2300      	movs	r3, #0
34004a9e:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34004aa0:	2300      	movs	r3, #0
34004aa2:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34004aa4:	2300      	movs	r3, #0
34004aa6:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles = 0U;
34004aa8:	2300      	movs	r3, #0
34004aaa:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34004aac:	2300      	movs	r3, #0
34004aae:	657b      	str	r3, [r7, #84]	@ 0x54


  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34004ab0:	f107 030c 	add.w	r3, r7, #12
34004ab4:	f241 3288 	movw	r2, #5000	@ 0x1388
34004ab8:	4619      	mov	r1, r3
34004aba:	6878      	ldr	r0, [r7, #4]
34004abc:	f016 fd30 	bl	3401b520 <HAL_XSPI_Command>
34004ac0:	4603      	mov	r3, r0
34004ac2:	2b00      	cmp	r3, #0
34004ac4:	d002      	beq.n	34004acc <MX66UW1G45G_ResetEnable+0xa2>
  {
    return MX66UW1G45G_ERROR;
34004ac6:	f04f 33ff 	mov.w	r3, #4294967295
34004aca:	e000      	b.n	34004ace <MX66UW1G45G_ResetEnable+0xa4>
  }

  return MX66UW1G45G_OK;
34004acc:	2300      	movs	r3, #0
}
34004ace:	4618      	mov	r0, r3
34004ad0:	3758      	adds	r7, #88	@ 0x58
34004ad2:	46bd      	mov	sp, r7
34004ad4:	bd80      	pop	{r7, pc}

34004ad6 <MX66UW1G45G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34004ad6:	b580      	push	{r7, lr}
34004ad8:	b096      	sub	sp, #88	@ 0x58
34004ada:	af00      	add	r7, sp, #0
34004adc:	6078      	str	r0, [r7, #4]
34004ade:	460b      	mov	r3, r1
34004ae0:	70fb      	strb	r3, [r7, #3]
34004ae2:	4613      	mov	r3, r2
34004ae4:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34004ae6:	f107 030c 	add.w	r3, r7, #12
34004aea:	224c      	movs	r2, #76	@ 0x4c
34004aec:	2100      	movs	r1, #0
34004aee:	4618      	mov	r0, r3
34004af0:	f01c fd70 	bl	340215d4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34004af4:	78fb      	ldrb	r3, [r7, #3]
34004af6:	2b00      	cmp	r3, #0
34004af8:	d105      	bne.n	34004b06 <MX66UW1G45G_ResetMemory+0x30>
34004afa:	78bb      	ldrb	r3, [r7, #2]
34004afc:	2b01      	cmp	r3, #1
34004afe:	d102      	bne.n	34004b06 <MX66UW1G45G_ResetMemory+0x30>
  {
    return MX66UW1G45G_ERROR;
34004b00:	f04f 33ff 	mov.w	r3, #4294967295
34004b04:	e037      	b.n	34004b76 <MX66UW1G45G_ResetMemory+0xa0>
  }

  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34004b06:	2300      	movs	r3, #0
34004b08:	60fb      	str	r3, [r7, #12]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34004b0a:	78fb      	ldrb	r3, [r7, #3]
34004b0c:	2b00      	cmp	r3, #0
34004b0e:	d101      	bne.n	34004b14 <MX66UW1G45G_ResetMemory+0x3e>
34004b10:	2301      	movs	r3, #1
34004b12:	e000      	b.n	34004b16 <MX66UW1G45G_ResetMemory+0x40>
34004b14:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34004b16:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34004b18:	78bb      	ldrb	r3, [r7, #2]
34004b1a:	2b01      	cmp	r3, #1
34004b1c:	d101      	bne.n	34004b22 <MX66UW1G45G_ResetMemory+0x4c>
34004b1e:	2308      	movs	r3, #8
34004b20:	e000      	b.n	34004b24 <MX66UW1G45G_ResetMemory+0x4e>
34004b22:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34004b24:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34004b26:	78fb      	ldrb	r3, [r7, #3]
34004b28:	2b00      	cmp	r3, #0
34004b2a:	d101      	bne.n	34004b30 <MX66UW1G45G_ResetMemory+0x5a>
34004b2c:	2300      	movs	r3, #0
34004b2e:	e000      	b.n	34004b32 <MX66UW1G45G_ResetMemory+0x5c>
34004b30:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34004b32:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_MEMORY_CMD
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34004b34:	78fb      	ldrb	r3, [r7, #3]
34004b36:	2b00      	cmp	r3, #0
34004b38:	d101      	bne.n	34004b3e <MX66UW1G45G_ResetMemory+0x68>
34004b3a:	2399      	movs	r3, #153	@ 0x99
34004b3c:	e001      	b.n	34004b42 <MX66UW1G45G_ResetMemory+0x6c>
34004b3e:	f649 1366 	movw	r3, #39270	@ 0x9966
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34004b42:	617b      	str	r3, [r7, #20]
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
34004b44:	2300      	movs	r3, #0
34004b46:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34004b48:	2300      	movs	r3, #0
34004b4a:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34004b4c:	2300      	movs	r3, #0
34004b4e:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles = 0U;
34004b50:	2300      	movs	r3, #0
34004b52:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34004b54:	2300      	movs	r3, #0
34004b56:	657b      	str	r3, [r7, #84]	@ 0x54
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34004b58:	f107 030c 	add.w	r3, r7, #12
34004b5c:	f241 3288 	movw	r2, #5000	@ 0x1388
34004b60:	4619      	mov	r1, r3
34004b62:	6878      	ldr	r0, [r7, #4]
34004b64:	f016 fcdc 	bl	3401b520 <HAL_XSPI_Command>
34004b68:	4603      	mov	r3, r0
34004b6a:	2b00      	cmp	r3, #0
34004b6c:	d002      	beq.n	34004b74 <MX66UW1G45G_ResetMemory+0x9e>
  {
    return MX66UW1G45G_ERROR;
34004b6e:	f04f 33ff 	mov.w	r3, #4294967295
34004b72:	e000      	b.n	34004b76 <MX66UW1G45G_ResetMemory+0xa0>
  }

  return MX66UW1G45G_OK;
34004b74:	2300      	movs	r3, #0
}
34004b76:	4618      	mov	r0, r3
34004b78:	3758      	adds	r7, #88	@ 0x58
34004b7a:	46bd      	mov	sp, r7
34004b7c:	bd80      	pop	{r7, pc}
	...

34004b80 <LL_AHB4_GRP1_EnableClock>:
{
34004b80:	b480      	push	{r7}
34004b82:	b085      	sub	sp, #20
34004b84:	af00      	add	r7, sp, #0
34004b86:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34004b88:	4a07      	ldr	r2, [pc, #28]	@ (34004ba8 <LL_AHB4_GRP1_EnableClock+0x28>)
34004b8a:	687b      	ldr	r3, [r7, #4]
34004b8c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34004b90:	4b05      	ldr	r3, [pc, #20]	@ (34004ba8 <LL_AHB4_GRP1_EnableClock+0x28>)
34004b92:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34004b96:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004b98:	68fb      	ldr	r3, [r7, #12]
}
34004b9a:	bf00      	nop
34004b9c:	3714      	adds	r7, #20
34004b9e:	46bd      	mov	sp, r7
34004ba0:	f85d 7b04 	ldr.w	r7, [sp], #4
34004ba4:	4770      	bx	lr
34004ba6:	bf00      	nop
34004ba8:	56028000 	.word	0x56028000

34004bac <LL_APB1_GRP1_EnableClock>:
{
34004bac:	b480      	push	{r7}
34004bae:	b085      	sub	sp, #20
34004bb0:	af00      	add	r7, sp, #0
34004bb2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34004bb4:	4a07      	ldr	r2, [pc, #28]	@ (34004bd4 <LL_APB1_GRP1_EnableClock+0x28>)
34004bb6:	687b      	ldr	r3, [r7, #4]
34004bb8:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
34004bbc:	4b05      	ldr	r3, [pc, #20]	@ (34004bd4 <LL_APB1_GRP1_EnableClock+0x28>)
34004bbe:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
34004bc2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004bc4:	68fb      	ldr	r3, [r7, #12]
}
34004bc6:	bf00      	nop
34004bc8:	3714      	adds	r7, #20
34004bca:	46bd      	mov	sp, r7
34004bcc:	f85d 7b04 	ldr.w	r7, [sp], #4
34004bd0:	4770      	bx	lr
34004bd2:	bf00      	nop
34004bd4:	56028000 	.word	0x56028000

34004bd8 <LL_APB2_GRP1_EnableClock>:
{
34004bd8:	b480      	push	{r7}
34004bda:	b085      	sub	sp, #20
34004bdc:	af00      	add	r7, sp, #0
34004bde:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB2ENSR, Periphs);
34004be0:	4a07      	ldr	r2, [pc, #28]	@ (34004c00 <LL_APB2_GRP1_EnableClock+0x28>)
34004be2:	687b      	ldr	r3, [r7, #4]
34004be4:	f8c2 3a6c 	str.w	r3, [r2, #2668]	@ 0xa6c
  tmpreg = READ_REG(RCC->APB2ENR);
34004be8:	4b05      	ldr	r3, [pc, #20]	@ (34004c00 <LL_APB2_GRP1_EnableClock+0x28>)
34004bea:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
34004bee:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004bf0:	68fb      	ldr	r3, [r7, #12]
}
34004bf2:	bf00      	nop
34004bf4:	3714      	adds	r7, #20
34004bf6:	46bd      	mov	sp, r7
34004bf8:	f85d 7b04 	ldr.w	r7, [sp], #4
34004bfc:	4770      	bx	lr
34004bfe:	bf00      	nop
34004c00:	56028000 	.word	0x56028000

34004c04 <BSP_SMPS_Init>:
  * @param Voltage configuration
  *          This parameter can be one of the following values:
  *            @arg  SMPS_VOLTAGE_NOMINAL
  *            @arg  SMPS_VOLTAGE_OVERDRIVE
  */
void BSP_SMPS_Init(SMPSVoltage_TypeDef Voltage){
34004c04:	b580      	push	{r7, lr}
34004c06:	b088      	sub	sp, #32
34004c08:	af00      	add	r7, sp, #0
34004c0a:	4603      	mov	r3, r0
34004c0c:	71fb      	strb	r3, [r7, #7]
  SMPS_GPIO_CLK_ENABLE();
34004c0e:	2020      	movs	r0, #32
34004c10:	f7ff ffb6 	bl	34004b80 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitTypeDef  gpio_init_structure = {0};
34004c14:	f107 030c 	add.w	r3, r7, #12
34004c18:	2200      	movs	r2, #0
34004c1a:	601a      	str	r2, [r3, #0]
34004c1c:	605a      	str	r2, [r3, #4]
34004c1e:	609a      	str	r2, [r3, #8]
34004c20:	60da      	str	r2, [r3, #12]
34004c22:	611a      	str	r2, [r3, #16]
  /* configure the external SMPS control pin */
  gpio_init_structure.Pin = SMPS_GPIO_PIN;
34004c24:	2310      	movs	r3, #16
34004c26:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34004c28:	2301      	movs	r3, #1
34004c2a:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull = GPIO_NOPULL;
34004c2c:	2300      	movs	r3, #0
34004c2e:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34004c30:	2303      	movs	r3, #3
34004c32:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34004c34:	f107 030c 	add.w	r3, r7, #12
34004c38:	4619      	mov	r1, r3
34004c3a:	4806      	ldr	r0, [pc, #24]	@ (34004c54 <BSP_SMPS_Init+0x50>)
34004c3c:	f004 fbc8 	bl	340093d0 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(SMPS_GPIO_PORT, SMPS_GPIO_PIN, (GPIO_PinState) Voltage);
34004c40:	79fb      	ldrb	r3, [r7, #7]
34004c42:	461a      	mov	r2, r3
34004c44:	2110      	movs	r1, #16
34004c46:	4803      	ldr	r0, [pc, #12]	@ (34004c54 <BSP_SMPS_Init+0x50>)
34004c48:	f004 ff22 	bl	34009a90 <HAL_GPIO_WritePin>
}
34004c4c:	bf00      	nop
34004c4e:	3720      	adds	r7, #32
34004c50:	46bd      	mov	sp, r7
34004c52:	bd80      	pop	{r7, pc}
34004c54:	56021400 	.word	0x56021400

34004c58 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                configuration information for the specified USART peripheral.
  * @retval BSP status
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
34004c58:	b580      	push	{r7, lr}
34004c5a:	b084      	sub	sp, #16
34004c5c:	af00      	add	r7, sp, #0
34004c5e:	4603      	mov	r3, r0
34004c60:	6039      	str	r1, [r7, #0]
34004c62:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
34004c64:	2300      	movs	r3, #0
34004c66:	60fb      	str	r3, [r7, #12]

  if(COM >= COMn)
34004c68:	79fb      	ldrb	r3, [r7, #7]
34004c6a:	2b01      	cmp	r3, #1
34004c6c:	d903      	bls.n	34004c76 <BSP_COM_Init+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34004c6e:	f06f 0301 	mvn.w	r3, #1
34004c72:	60fb      	str	r3, [r7, #12]
34004c74:	e041      	b.n	34004cfa <BSP_COM_Init+0xa2>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
34004c76:	79fa      	ldrb	r2, [r7, #7]
34004c78:	79fb      	ldrb	r3, [r7, #7]
34004c7a:	4922      	ldr	r1, [pc, #136]	@ (34004d04 <BSP_COM_Init+0xac>)
34004c7c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
34004c80:	4921      	ldr	r1, [pc, #132]	@ (34004d08 <BSP_COM_Init+0xb0>)
34004c82:	2094      	movs	r0, #148	@ 0x94
34004c84:	fb00 f303 	mul.w	r3, r0, r3
34004c88:	440b      	add	r3, r1
34004c8a:	601a      	str	r2, [r3, #0]

    /* Init the UART Msp */
#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
34004c8c:	79fb      	ldrb	r3, [r7, #7]
34004c8e:	2294      	movs	r2, #148	@ 0x94
34004c90:	fb02 f303 	mul.w	r3, r2, r3
34004c94:	4a1c      	ldr	r2, [pc, #112]	@ (34004d08 <BSP_COM_Init+0xb0>)
34004c96:	4413      	add	r3, r2
34004c98:	4618      	mov	r0, r3
34004c9a:	f000 f89b 	bl	34004dd4 <UART_MspInit>
        return BSP_ERROR_MSP_FAILURE;
      }
    }
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

    if (ret == BSP_ERROR_NONE)
34004c9e:	68fb      	ldr	r3, [r7, #12]
34004ca0:	2b00      	cmp	r3, #0
34004ca2:	d12a      	bne.n	34004cfa <BSP_COM_Init+0xa2>
    {
      if (COM == COM1)
34004ca4:	79fb      	ldrb	r3, [r7, #7]
34004ca6:	2b00      	cmp	r3, #0
34004ca8:	d110      	bne.n	34004ccc <BSP_COM_Init+0x74>
      {
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
34004caa:	79fb      	ldrb	r3, [r7, #7]
34004cac:	2294      	movs	r2, #148	@ 0x94
34004cae:	fb02 f303 	mul.w	r3, r2, r3
34004cb2:	4a15      	ldr	r2, [pc, #84]	@ (34004d08 <BSP_COM_Init+0xb0>)
34004cb4:	4413      	add	r3, r2
34004cb6:	6839      	ldr	r1, [r7, #0]
34004cb8:	4618      	mov	r0, r3
34004cba:	f000 f827 	bl	34004d0c <MX_USART1_Init>
34004cbe:	4603      	mov	r3, r0
34004cc0:	2b00      	cmp	r3, #0
34004cc2:	d01a      	beq.n	34004cfa <BSP_COM_Init+0xa2>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34004cc4:	f06f 0303 	mvn.w	r3, #3
34004cc8:	60fb      	str	r3, [r7, #12]
34004cca:	e016      	b.n	34004cfa <BSP_COM_Init+0xa2>
        }
      }
      else if (COM == COM2)
34004ccc:	79fb      	ldrb	r3, [r7, #7]
34004cce:	2b01      	cmp	r3, #1
34004cd0:	d110      	bne.n	34004cf4 <BSP_COM_Init+0x9c>
      {
        if (MX_USART2_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
34004cd2:	79fb      	ldrb	r3, [r7, #7]
34004cd4:	2294      	movs	r2, #148	@ 0x94
34004cd6:	fb02 f303 	mul.w	r3, r2, r3
34004cda:	4a0b      	ldr	r2, [pc, #44]	@ (34004d08 <BSP_COM_Init+0xb0>)
34004cdc:	4413      	add	r3, r2
34004cde:	6839      	ldr	r1, [r7, #0]
34004ce0:	4618      	mov	r0, r3
34004ce2:	f000 f845 	bl	34004d70 <MX_USART2_Init>
34004ce6:	4603      	mov	r3, r0
34004ce8:	2b00      	cmp	r3, #0
34004cea:	d006      	beq.n	34004cfa <BSP_COM_Init+0xa2>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34004cec:	f06f 0303 	mvn.w	r3, #3
34004cf0:	60fb      	str	r3, [r7, #12]
34004cf2:	e002      	b.n	34004cfa <BSP_COM_Init+0xa2>
        }
      }
      else /* COM = ??? */
      {
        ret = BSP_ERROR_WRONG_PARAM;
34004cf4:	f06f 0301 	mvn.w	r3, #1
34004cf8:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  return ret;
34004cfa:	68fb      	ldr	r3, [r7, #12]
}
34004cfc:	4618      	mov	r0, r3
34004cfe:	3710      	adds	r7, #16
34004d00:	46bd      	mov	sp, r7
34004d02:	bd80      	pop	{r7, pc}
34004d04:	34033f40 	.word	0x34033f40
34004d08:	340538a0 	.word	0x340538a0

34004d0c <MX_USART1_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
34004d0c:	b580      	push	{r7, lr}
34004d0e:	b082      	sub	sp, #8
34004d10:	af00      	add	r7, sp, #0
34004d12:	6078      	str	r0, [r7, #4]
34004d14:	6039      	str	r1, [r7, #0]
  /* USART configuration */
  huart->Instance          = COM_UART[COM1];
34004d16:	4b15      	ldr	r3, [pc, #84]	@ (34004d6c <MX_USART1_Init+0x60>)
34004d18:	681a      	ldr	r2, [r3, #0]
34004d1a:	687b      	ldr	r3, [r7, #4]
34004d1c:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
34004d1e:	683b      	ldr	r3, [r7, #0]
34004d20:	681a      	ldr	r2, [r3, #0]
34004d22:	687b      	ldr	r3, [r7, #4]
34004d24:	605a      	str	r2, [r3, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
34004d26:	687b      	ldr	r3, [r7, #4]
34004d28:	220c      	movs	r2, #12
34004d2a:	615a      	str	r2, [r3, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
34004d2c:	683b      	ldr	r3, [r7, #0]
34004d2e:	895b      	ldrh	r3, [r3, #10]
34004d30:	461a      	mov	r2, r3
34004d32:	687b      	ldr	r3, [r7, #4]
34004d34:	611a      	str	r2, [r3, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
34004d36:	683b      	ldr	r3, [r7, #0]
34004d38:	685a      	ldr	r2, [r3, #4]
34004d3a:	687b      	ldr	r3, [r7, #4]
34004d3c:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
34004d3e:	683b      	ldr	r3, [r7, #0]
34004d40:	891b      	ldrh	r3, [r3, #8]
34004d42:	461a      	mov	r2, r3
34004d44:	687b      	ldr	r3, [r7, #4]
34004d46:	60da      	str	r2, [r3, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
34004d48:	683b      	ldr	r3, [r7, #0]
34004d4a:	899b      	ldrh	r3, [r3, #12]
34004d4c:	461a      	mov	r2, r3
34004d4e:	687b      	ldr	r3, [r7, #4]
34004d50:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
34004d52:	687b      	ldr	r3, [r7, #4]
34004d54:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34004d58:	61da      	str	r2, [r3, #28]

  return HAL_UART_Init(huart);
34004d5a:	6878      	ldr	r0, [r7, #4]
34004d5c:	f014 fff8 	bl	34019d50 <HAL_UART_Init>
34004d60:	4603      	mov	r3, r0
}
34004d62:	4618      	mov	r0, r3
34004d64:	3708      	adds	r7, #8
34004d66:	46bd      	mov	sp, r7
34004d68:	bd80      	pop	{r7, pc}
34004d6a:	bf00      	nop
34004d6c:	34033f40 	.word	0x34033f40

34004d70 <MX_USART2_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART2_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
34004d70:	b580      	push	{r7, lr}
34004d72:	b082      	sub	sp, #8
34004d74:	af00      	add	r7, sp, #0
34004d76:	6078      	str	r0, [r7, #4]
34004d78:	6039      	str	r1, [r7, #0]
  /* USART configuration */
  huart->Instance          = COM_UART[COM2];
34004d7a:	4b15      	ldr	r3, [pc, #84]	@ (34004dd0 <MX_USART2_Init+0x60>)
34004d7c:	685a      	ldr	r2, [r3, #4]
34004d7e:	687b      	ldr	r3, [r7, #4]
34004d80:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
34004d82:	683b      	ldr	r3, [r7, #0]
34004d84:	681a      	ldr	r2, [r3, #0]
34004d86:	687b      	ldr	r3, [r7, #4]
34004d88:	605a      	str	r2, [r3, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
34004d8a:	687b      	ldr	r3, [r7, #4]
34004d8c:	220c      	movs	r2, #12
34004d8e:	615a      	str	r2, [r3, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
34004d90:	683b      	ldr	r3, [r7, #0]
34004d92:	895b      	ldrh	r3, [r3, #10]
34004d94:	461a      	mov	r2, r3
34004d96:	687b      	ldr	r3, [r7, #4]
34004d98:	611a      	str	r2, [r3, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
34004d9a:	683b      	ldr	r3, [r7, #0]
34004d9c:	685a      	ldr	r2, [r3, #4]
34004d9e:	687b      	ldr	r3, [r7, #4]
34004da0:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
34004da2:	683b      	ldr	r3, [r7, #0]
34004da4:	891b      	ldrh	r3, [r3, #8]
34004da6:	461a      	mov	r2, r3
34004da8:	687b      	ldr	r3, [r7, #4]
34004daa:	60da      	str	r2, [r3, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
34004dac:	683b      	ldr	r3, [r7, #0]
34004dae:	899b      	ldrh	r3, [r3, #12]
34004db0:	461a      	mov	r2, r3
34004db2:	687b      	ldr	r3, [r7, #4]
34004db4:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
34004db6:	687b      	ldr	r3, [r7, #4]
34004db8:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34004dbc:	61da      	str	r2, [r3, #28]

  return HAL_UART_Init(huart);
34004dbe:	6878      	ldr	r0, [r7, #4]
34004dc0:	f014 ffc6 	bl	34019d50 <HAL_UART_Init>
34004dc4:	4603      	mov	r3, r0
}
34004dc6:	4618      	mov	r0, r3
34004dc8:	3708      	adds	r7, #8
34004dca:	46bd      	mov	sp, r7
34004dcc:	bd80      	pop	{r7, pc}
34004dce:	bf00      	nop
34004dd0:	34033f40 	.word	0x34033f40

34004dd4 <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
34004dd4:	b580      	push	{r7, lr}
34004dd6:	b090      	sub	sp, #64	@ 0x40
34004dd8:	af00      	add	r7, sp, #0
34004dda:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_Init;
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
34004ddc:	4a40      	ldr	r2, [pc, #256]	@ (34004ee0 <UART_MspInit+0x10c>)
34004dde:	f107 0320 	add.w	r3, r7, #32
34004de2:	e892 0003 	ldmia.w	r2, {r0, r1}
34004de6:	e883 0003 	stmia.w	r3, {r0, r1}
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
34004dea:	4a3e      	ldr	r2, [pc, #248]	@ (34004ee4 <UART_MspInit+0x110>)
34004dec:	f107 0318 	add.w	r3, r7, #24
34004df0:	e892 0003 	ldmia.w	r2, {r0, r1}
34004df4:	e883 0003 	stmia.w	r3, {r0, r1}
  uint16_t         COM_TX_PIN[COMn]  = {COM1_TX_PIN, COM2_TX_PIN};
34004df8:	4b3b      	ldr	r3, [pc, #236]	@ (34004ee8 <UART_MspInit+0x114>)
34004dfa:	681b      	ldr	r3, [r3, #0]
34004dfc:	617b      	str	r3, [r7, #20]
  uint16_t         COM_RX_PIN[COMn]  = {COM1_RX_PIN, COM2_RX_PIN};
34004dfe:	4b3b      	ldr	r3, [pc, #236]	@ (34004eec <UART_MspInit+0x118>)
34004e00:	681b      	ldr	r3, [r3, #0]
34004e02:	613b      	str	r3, [r7, #16]
  uint8_t          COM_TX_AF[COMn]   = {COM1_TX_AF, COM2_TX_AF};
34004e04:	f240 7307 	movw	r3, #1799	@ 0x707
34004e08:	81bb      	strh	r3, [r7, #12]
  uint8_t          COM_RX_AF[COMn]   = {COM1_RX_AF, COM2_RX_AF};
34004e0a:	f240 7307 	movw	r3, #1799	@ 0x707
34004e0e:	813b      	strh	r3, [r7, #8]
  COM_TypeDef      COM;

  /* Get COM according instance */
  if (huart->Instance == COM1_UART)
34004e10:	687b      	ldr	r3, [r7, #4]
34004e12:	681b      	ldr	r3, [r3, #0]
34004e14:	4a36      	ldr	r2, [pc, #216]	@ (34004ef0 <UART_MspInit+0x11c>)
34004e16:	4293      	cmp	r3, r2
34004e18:	d10c      	bne.n	34004e34 <UART_MspInit+0x60>
  {
    COM = COM1;
34004e1a:	2300      	movs	r3, #0
34004e1c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    /* Enable COM and GPIO clocks */
    COM1_TX_GPIO_CLK_ENABLE();
34004e20:	2010      	movs	r0, #16
34004e22:	f7ff fead 	bl	34004b80 <LL_AHB4_GRP1_EnableClock>
    COM1_RX_GPIO_CLK_ENABLE();
34004e26:	2010      	movs	r0, #16
34004e28:	f7ff feaa 	bl	34004b80 <LL_AHB4_GRP1_EnableClock>
    COM1_CLK_ENABLE();
34004e2c:	2010      	movs	r0, #16
34004e2e:	f7ff fed3 	bl	34004bd8 <LL_APB2_GRP1_EnableClock>
34004e32:	e011      	b.n	34004e58 <UART_MspInit+0x84>
  }
  else if (huart->Instance == COM2_UART)
34004e34:	687b      	ldr	r3, [r7, #4]
34004e36:	681b      	ldr	r3, [r3, #0]
34004e38:	4a2e      	ldr	r2, [pc, #184]	@ (34004ef4 <UART_MspInit+0x120>)
34004e3a:	4293      	cmp	r3, r2
34004e3c:	d14b      	bne.n	34004ed6 <UART_MspInit+0x102>
  {
    COM = COM2;
34004e3e:	2301      	movs	r3, #1
34004e40:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    /* Enable COM and GPIO clocks */
    COM2_TX_GPIO_CLK_ENABLE();
34004e44:	2008      	movs	r0, #8
34004e46:	f7ff fe9b 	bl	34004b80 <LL_AHB4_GRP1_EnableClock>
    COM2_RX_GPIO_CLK_ENABLE();
34004e4a:	2020      	movs	r0, #32
34004e4c:	f7ff fe98 	bl	34004b80 <LL_AHB4_GRP1_EnableClock>
    COM2_CLK_ENABLE();
34004e50:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
34004e54:	f7ff feaa 	bl	34004bac <LL_APB1_GRP1_EnableClock>
  {
      return;
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
34004e58:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34004e5c:	005b      	lsls	r3, r3, #1
34004e5e:	3340      	adds	r3, #64	@ 0x40
34004e60:	443b      	add	r3, r7
34004e62:	f833 3c2c 	ldrh.w	r3, [r3, #-44]
34004e66:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
34004e68:	2302      	movs	r3, #2
34004e6a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
34004e6c:	2302      	movs	r3, #2
34004e6e:	637b      	str	r3, [r7, #52]	@ 0x34
  GPIO_Init.Pull      = GPIO_PULLUP;
34004e70:	2301      	movs	r3, #1
34004e72:	633b      	str	r3, [r7, #48]	@ 0x30
  GPIO_Init.Alternate = COM_TX_AF[COM];
34004e74:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34004e78:	3340      	adds	r3, #64	@ 0x40
34004e7a:	443b      	add	r3, r7
34004e7c:	f813 3c34 	ldrb.w	r3, [r3, #-52]
34004e80:	63bb      	str	r3, [r7, #56]	@ 0x38
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
34004e82:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34004e86:	009b      	lsls	r3, r3, #2
34004e88:	3340      	adds	r3, #64	@ 0x40
34004e8a:	443b      	add	r3, r7
34004e8c:	f853 3c20 	ldr.w	r3, [r3, #-32]
34004e90:	f107 0228 	add.w	r2, r7, #40	@ 0x28
34004e94:	4611      	mov	r1, r2
34004e96:	4618      	mov	r0, r3
34004e98:	f004 fa9a 	bl	340093d0 <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
34004e9c:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34004ea0:	005b      	lsls	r3, r3, #1
34004ea2:	3340      	adds	r3, #64	@ 0x40
34004ea4:	443b      	add	r3, r7
34004ea6:	f833 3c30 	ldrh.w	r3, [r3, #-48]
34004eaa:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_Init.Alternate = COM_RX_AF[COM];
34004eac:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34004eb0:	3340      	adds	r3, #64	@ 0x40
34004eb2:	443b      	add	r3, r7
34004eb4:	f813 3c38 	ldrb.w	r3, [r3, #-56]
34004eb8:	63bb      	str	r3, [r7, #56]	@ 0x38
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
34004eba:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34004ebe:	009b      	lsls	r3, r3, #2
34004ec0:	3340      	adds	r3, #64	@ 0x40
34004ec2:	443b      	add	r3, r7
34004ec4:	f853 3c28 	ldr.w	r3, [r3, #-40]
34004ec8:	f107 0228 	add.w	r2, r7, #40	@ 0x28
34004ecc:	4611      	mov	r1, r2
34004ece:	4618      	mov	r0, r3
34004ed0:	f004 fa7e 	bl	340093d0 <HAL_GPIO_Init>
34004ed4:	e000      	b.n	34004ed8 <UART_MspInit+0x104>
      return;
34004ed6:	bf00      	nop
}
34004ed8:	3740      	adds	r7, #64	@ 0x40
34004eda:	46bd      	mov	sp, r7
34004edc:	bd80      	pop	{r7, pc}
34004ede:	bf00      	nop
34004ee0:	34023f74 	.word	0x34023f74
34004ee4:	34023f7c 	.word	0x34023f7c
34004ee8:	34023f84 	.word	0x34023f84
34004eec:	34023f88 	.word	0x34023f88
34004ef0:	52001000 	.word	0x52001000
34004ef4:	50004400 	.word	0x50004400

34004ef8 <LL_AHB4_GRP1_EnableClock>:
{
34004ef8:	b480      	push	{r7}
34004efa:	b085      	sub	sp, #20
34004efc:	af00      	add	r7, sp, #0
34004efe:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34004f00:	4a07      	ldr	r2, [pc, #28]	@ (34004f20 <LL_AHB4_GRP1_EnableClock+0x28>)
34004f02:	687b      	ldr	r3, [r7, #4]
34004f04:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34004f08:	4b05      	ldr	r3, [pc, #20]	@ (34004f20 <LL_AHB4_GRP1_EnableClock+0x28>)
34004f0a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34004f0e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004f10:	68fb      	ldr	r3, [r7, #12]
}
34004f12:	bf00      	nop
34004f14:	3714      	adds	r7, #20
34004f16:	46bd      	mov	sp, r7
34004f18:	f85d 7b04 	ldr.w	r7, [sp], #4
34004f1c:	4770      	bx	lr
34004f1e:	bf00      	nop
34004f20:	56028000 	.word	0x56028000

34004f24 <LL_AHB5_GRP1_EnableClock>:
{
34004f24:	b480      	push	{r7}
34004f26:	b085      	sub	sp, #20
34004f28:	af00      	add	r7, sp, #0
34004f2a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34004f2c:	4a07      	ldr	r2, [pc, #28]	@ (34004f4c <LL_AHB5_GRP1_EnableClock+0x28>)
34004f2e:	687b      	ldr	r3, [r7, #4]
34004f30:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34004f34:	4b05      	ldr	r3, [pc, #20]	@ (34004f4c <LL_AHB5_GRP1_EnableClock+0x28>)
34004f36:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34004f3a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004f3c:	68fb      	ldr	r3, [r7, #12]
}
34004f3e:	bf00      	nop
34004f40:	3714      	adds	r7, #20
34004f42:	46bd      	mov	sp, r7
34004f44:	f85d 7b04 	ldr.w	r7, [sp], #4
34004f48:	4770      	bx	lr
34004f4a:	bf00      	nop
34004f4c:	56028000 	.word	0x56028000

34004f50 <LL_AHB5_GRP1_ForceReset>:
{
34004f50:	b480      	push	{r7}
34004f52:	b083      	sub	sp, #12
34004f54:	af00      	add	r7, sp, #0
34004f56:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34004f58:	4a04      	ldr	r2, [pc, #16]	@ (34004f6c <LL_AHB5_GRP1_ForceReset+0x1c>)
34004f5a:	687b      	ldr	r3, [r7, #4]
34004f5c:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34004f60:	bf00      	nop
34004f62:	370c      	adds	r7, #12
34004f64:	46bd      	mov	sp, r7
34004f66:	f85d 7b04 	ldr.w	r7, [sp], #4
34004f6a:	4770      	bx	lr
34004f6c:	56028000 	.word	0x56028000

34004f70 <LL_AHB5_GRP1_ReleaseReset>:
{
34004f70:	b480      	push	{r7}
34004f72:	b083      	sub	sp, #12
34004f74:	af00      	add	r7, sp, #0
34004f76:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004f78:	4b06      	ldr	r3, [pc, #24]	@ (34004f94 <LL_AHB5_GRP1_ReleaseReset+0x24>)
34004f7a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34004f7e:	461a      	mov	r2, r3
34004f80:	687b      	ldr	r3, [r7, #4]
34004f82:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34004f86:	bf00      	nop
34004f88:	370c      	adds	r7, #12
34004f8a:	46bd      	mov	sp, r7
34004f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34004f90:	4770      	bx	lr
34004f92:	bf00      	nop
34004f94:	56028000 	.word	0x56028000

34004f98 <LL_APB5_GRP1_EnableClock>:
{
34004f98:	b480      	push	{r7}
34004f9a:	b085      	sub	sp, #20
34004f9c:	af00      	add	r7, sp, #0
34004f9e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5ENSR, Periphs);
34004fa0:	4a07      	ldr	r2, [pc, #28]	@ (34004fc0 <LL_APB5_GRP1_EnableClock+0x28>)
34004fa2:	687b      	ldr	r3, [r7, #4]
34004fa4:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34004fa8:	4b05      	ldr	r3, [pc, #20]	@ (34004fc0 <LL_APB5_GRP1_EnableClock+0x28>)
34004faa:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
34004fae:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004fb0:	68fb      	ldr	r3, [r7, #12]
}
34004fb2:	bf00      	nop
34004fb4:	3714      	adds	r7, #20
34004fb6:	46bd      	mov	sp, r7
34004fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34004fbc:	4770      	bx	lr
34004fbe:	bf00      	nop
34004fc0:	56028000 	.word	0x56028000

34004fc4 <LL_APB5_GRP1_ForceReset>:
{
34004fc4:	b480      	push	{r7}
34004fc6:	b083      	sub	sp, #12
34004fc8:	af00      	add	r7, sp, #0
34004fca:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34004fcc:	4a04      	ldr	r2, [pc, #16]	@ (34004fe0 <LL_APB5_GRP1_ForceReset+0x1c>)
34004fce:	687b      	ldr	r3, [r7, #4]
34004fd0:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
34004fd4:	bf00      	nop
34004fd6:	370c      	adds	r7, #12
34004fd8:	46bd      	mov	sp, r7
34004fda:	f85d 7b04 	ldr.w	r7, [sp], #4
34004fde:	4770      	bx	lr
34004fe0:	56028000 	.word	0x56028000

34004fe4 <LL_APB5_GRP1_ReleaseReset>:
{
34004fe4:	b480      	push	{r7}
34004fe6:	b083      	sub	sp, #12
34004fe8:	af00      	add	r7, sp, #0
34004fea:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34004fec:	4b06      	ldr	r3, [pc, #24]	@ (34005008 <LL_APB5_GRP1_ReleaseReset+0x24>)
34004fee:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34004ff2:	461a      	mov	r2, r3
34004ff4:	687b      	ldr	r3, [r7, #4]
34004ff6:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
34004ffa:	bf00      	nop
34004ffc:	370c      	adds	r7, #12
34004ffe:	46bd      	mov	sp, r7
34005000:	f85d 7b04 	ldr.w	r7, [sp], #4
34005004:	4770      	bx	lr
34005006:	bf00      	nop
34005008:	56028000 	.word	0x56028000

3400500c <BSP_LCD_Init>:
  * @param  Orientation LCD_ORIENTATION_LANDSCAPE
  * @retval BSP status
  */

int32_t BSP_LCD_Init(uint32_t Instance, uint32_t Orientation)
{
3400500c:	b580      	push	{r7, lr}
3400500e:	b084      	sub	sp, #16
34005010:	af02      	add	r7, sp, #8
34005012:	6078      	str	r0, [r7, #4]
34005014:	6039      	str	r1, [r7, #0]
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34005016:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
3400501a:	9300      	str	r3, [sp, #0]
3400501c:	f44f 7348 	mov.w	r3, #800	@ 0x320
34005020:	2202      	movs	r2, #2
34005022:	6839      	ldr	r1, [r7, #0]
34005024:	6878      	ldr	r0, [r7, #4]
34005026:	f000 f805 	bl	34005034 <BSP_LCD_InitEx>
3400502a:	4603      	mov	r3, r0
}
3400502c:	4618      	mov	r0, r3
3400502e:	3708      	adds	r7, #8
34005030:	46bd      	mov	sp, r7
34005032:	bd80      	pop	{r7, pc}

34005034 <BSP_LCD_InitEx>:
  * @param  Width       Display width
  * @param  Height      Display height
  * @retval BSP status
  */
int32_t BSP_LCD_InitEx(uint32_t Instance, uint32_t Orientation, uint32_t PixelFormat, uint32_t Width, uint32_t Height)
{
34005034:	b580      	push	{r7, lr}
34005036:	b08c      	sub	sp, #48	@ 0x30
34005038:	af00      	add	r7, sp, #0
3400503a:	60f8      	str	r0, [r7, #12]
3400503c:	60b9      	str	r1, [r7, #8]
3400503e:	607a      	str	r2, [r7, #4]
34005040:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34005042:	2300      	movs	r3, #0
34005044:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ltdc_pixel_format;
  MX_LTDC_LayerConfig_t config = {0};
34005046:	f107 0310 	add.w	r3, r7, #16
3400504a:	2200      	movs	r2, #0
3400504c:	601a      	str	r2, [r3, #0]
3400504e:	605a      	str	r2, [r3, #4]
34005050:	609a      	str	r2, [r3, #8]
34005052:	60da      	str	r2, [r3, #12]
34005054:	611a      	str	r2, [r3, #16]
34005056:	615a      	str	r2, [r3, #20]

  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
34005058:	68bb      	ldr	r3, [r7, #8]
3400505a:	2b01      	cmp	r3, #1
3400505c:	d80e      	bhi.n	3400507c <BSP_LCD_InitEx+0x48>
3400505e:	68fb      	ldr	r3, [r7, #12]
34005060:	2b00      	cmp	r3, #0
34005062:	d10b      	bne.n	3400507c <BSP_LCD_InitEx+0x48>
34005064:	687b      	ldr	r3, [r7, #4]
34005066:	2b02      	cmp	r3, #2
34005068:	d00c      	beq.n	34005084 <BSP_LCD_InitEx+0x50>
     ((PixelFormat != LCD_PIXEL_FORMAT_RGB565) && (PixelFormat != LCD_PIXEL_FORMAT_RGB888) && \
3400506a:	687b      	ldr	r3, [r7, #4]
3400506c:	2b01      	cmp	r3, #1
3400506e:	d009      	beq.n	34005084 <BSP_LCD_InitEx+0x50>
34005070:	687b      	ldr	r3, [r7, #4]
34005072:	2b00      	cmp	r3, #0
34005074:	d006      	beq.n	34005084 <BSP_LCD_InitEx+0x50>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
34005076:	687b      	ldr	r3, [r7, #4]
34005078:	2b04      	cmp	r3, #4
3400507a:	d003      	beq.n	34005084 <BSP_LCD_InitEx+0x50>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400507c:	f06f 0301 	mvn.w	r3, #1
34005080:	62fb      	str	r3, [r7, #44]	@ 0x2c
34005082:	e087      	b.n	34005194 <BSP_LCD_InitEx+0x160>
  }
  else
  {
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
34005084:	687b      	ldr	r3, [r7, #4]
34005086:	2b02      	cmp	r3, #2
34005088:	d109      	bne.n	3400509e <BSP_LCD_InitEx+0x6a>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
3400508a:	2304      	movs	r3, #4
3400508c:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 2U;
3400508e:	4a44      	ldr	r2, [pc, #272]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
34005090:	68fb      	ldr	r3, [r7, #12]
34005092:	015b      	lsls	r3, r3, #5
34005094:	4413      	add	r3, r2
34005096:	3310      	adds	r3, #16
34005098:	2202      	movs	r2, #2
3400509a:	601a      	str	r2, [r3, #0]
3400509c:	e022      	b.n	340050e4 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
3400509e:	687b      	ldr	r3, [r7, #4]
340050a0:	2b01      	cmp	r3, #1
340050a2:	d109      	bne.n	340050b8 <BSP_LCD_InitEx+0x84>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB888;
340050a4:	2306      	movs	r3, #6
340050a6:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 3U;
340050a8:	4a3d      	ldr	r2, [pc, #244]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
340050aa:	68fb      	ldr	r3, [r7, #12]
340050ac:	015b      	lsls	r3, r3, #5
340050ae:	4413      	add	r3, r2
340050b0:	3310      	adds	r3, #16
340050b2:	2203      	movs	r2, #3
340050b4:	601a      	str	r2, [r3, #0]
340050b6:	e015      	b.n	340050e4 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
340050b8:	687b      	ldr	r3, [r7, #4]
340050ba:	2b04      	cmp	r3, #4
340050bc:	d109      	bne.n	340050d2 <BSP_LCD_InitEx+0x9e>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
340050be:	2308      	movs	r3, #8
340050c0:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 2U;
340050c2:	4a37      	ldr	r2, [pc, #220]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
340050c4:	68fb      	ldr	r3, [r7, #12]
340050c6:	015b      	lsls	r3, r3, #5
340050c8:	4413      	add	r3, r2
340050ca:	3310      	adds	r3, #16
340050cc:	2202      	movs	r2, #2
340050ce:	601a      	str	r2, [r3, #0]
340050d0:	e008      	b.n	340050e4 <BSP_LCD_InitEx+0xb0>
    }
    else /* LCD_PIXEL_FORMAT_ARGB8888 */
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB8888;
340050d2:	2300      	movs	r3, #0
340050d4:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 4U;
340050d6:	4a32      	ldr	r2, [pc, #200]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
340050d8:	68fb      	ldr	r3, [r7, #12]
340050da:	015b      	lsls	r3, r3, #5
340050dc:	4413      	add	r3, r2
340050de:	3310      	adds	r3, #16
340050e0:	2204      	movs	r2, #4
340050e2:	601a      	str	r2, [r3, #0]
    }

    /* Store pixel format, xsize and ysize information */
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
340050e4:	4a2e      	ldr	r2, [pc, #184]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
340050e6:	68fb      	ldr	r3, [r7, #12]
340050e8:	015b      	lsls	r3, r3, #5
340050ea:	4413      	add	r3, r2
340050ec:	330c      	adds	r3, #12
340050ee:	687a      	ldr	r2, [r7, #4]
340050f0:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize  = Width;
340050f2:	4a2b      	ldr	r2, [pc, #172]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
340050f4:	68fb      	ldr	r3, [r7, #12]
340050f6:	015b      	lsls	r3, r3, #5
340050f8:	4413      	add	r3, r2
340050fa:	683a      	ldr	r2, [r7, #0]
340050fc:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize  = Height;
340050fe:	4a28      	ldr	r2, [pc, #160]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
34005100:	68fb      	ldr	r3, [r7, #12]
34005102:	015b      	lsls	r3, r3, #5
34005104:	4413      	add	r3, r2
34005106:	3304      	adds	r3, #4
34005108:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3400510a:	601a      	str	r2, [r3, #0]

    /* Initializes peripherals instance value */
    hlcd_ltdc.Instance = LTDC;
3400510c:	4b25      	ldr	r3, [pc, #148]	@ (340051a4 <BSP_LCD_InitEx+0x170>)
3400510e:	4a26      	ldr	r2, [pc, #152]	@ (340051a8 <BSP_LCD_InitEx+0x174>)
34005110:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
34005112:	4b26      	ldr	r3, [pc, #152]	@ (340051ac <BSP_LCD_InitEx+0x178>)
34005114:	4a26      	ldr	r2, [pc, #152]	@ (340051b0 <BSP_LCD_InitEx+0x17c>)
34005116:	601a      	str	r2, [r3, #0]
      {
        return BSP_ERROR_PERIPH_FAILURE;
      }
    }
#else
    LTDC_MspInit(&hlcd_ltdc);
34005118:	4822      	ldr	r0, [pc, #136]	@ (340051a4 <BSP_LCD_InitEx+0x170>)
3400511a:	f000 fe63 	bl	34005de4 <LTDC_MspInit>
#endif /* (USE_HAL_LTDC_REGISTER_CALLBACKS == 1) */

    DMA2D_MspInit(&hlcd_dma2d);
3400511e:	4823      	ldr	r0, [pc, #140]	@ (340051ac <BSP_LCD_InitEx+0x178>)
34005120:	f000 ff1c 	bl	34005f5c <DMA2D_MspInit>

    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34005124:	481f      	ldr	r0, [pc, #124]	@ (340051a4 <BSP_LCD_InitEx+0x170>)
34005126:	f000 f8dc 	bl	340052e2 <MX_LTDC_ClockConfig>
3400512a:	4603      	mov	r3, r0
3400512c:	2b00      	cmp	r3, #0
3400512e:	d003      	beq.n	34005138 <BSP_LCD_InitEx+0x104>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34005130:	f06f 0303 	mvn.w	r3, #3
34005134:	62fb      	str	r3, [r7, #44]	@ 0x2c
34005136:	e00a      	b.n	3400514e <BSP_LCD_InitEx+0x11a>
    }
    else
    {
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
34005138:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3400513a:	6839      	ldr	r1, [r7, #0]
3400513c:	4819      	ldr	r0, [pc, #100]	@ (340051a4 <BSP_LCD_InitEx+0x170>)
3400513e:	f000 f83b 	bl	340051b8 <MX_LTDC_Init>
34005142:	4603      	mov	r3, r0
34005144:	2b00      	cmp	r3, #0
34005146:	d002      	beq.n	3400514e <BSP_LCD_InitEx+0x11a>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
34005148:	f06f 0303 	mvn.w	r3, #3
3400514c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      }
    }

    if (ret == BSP_ERROR_NONE)
3400514e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34005150:	2b00      	cmp	r3, #0
34005152:	d11f      	bne.n	34005194 <BSP_LCD_InitEx+0x160>
      else
      {
#endif /* DATA_IN_ExtRAM */
        /* Configure default LTDC Layer 0. This configuration can be override by calling
        BSP_LCD_ConfigLayer() at application level */
        config.X0          = 0;
34005154:	2300      	movs	r3, #0
34005156:	613b      	str	r3, [r7, #16]
        config.X1          = Width;
34005158:	683b      	ldr	r3, [r7, #0]
3400515a:	617b      	str	r3, [r7, #20]
        config.Y0          = 0;
3400515c:	2300      	movs	r3, #0
3400515e:	61bb      	str	r3, [r7, #24]
        config.Y1          = Height;
34005160:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34005162:	61fb      	str	r3, [r7, #28]
        config.PixelFormat = ltdc_pixel_format;
34005164:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34005166:	623b      	str	r3, [r7, #32]
        config.Address     = LCD_LAYER_0_ADDRESS;
34005168:	4b12      	ldr	r3, [pc, #72]	@ (340051b4 <BSP_LCD_InitEx+0x180>)
3400516a:	627b      	str	r3, [r7, #36]	@ 0x24

        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
3400516c:	f107 0310 	add.w	r3, r7, #16
34005170:	461a      	mov	r2, r3
34005172:	2100      	movs	r1, #0
34005174:	480b      	ldr	r0, [pc, #44]	@ (340051a4 <BSP_LCD_InitEx+0x170>)
34005176:	f000 f86b 	bl	34005250 <MX_LTDC_ConfigLayer>
3400517a:	4603      	mov	r3, r0
3400517c:	2b00      	cmp	r3, #0
3400517e:	d002      	beq.n	34005186 <BSP_LCD_InitEx+0x152>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34005180:	f06f 0303 	mvn.w	r3, #3
34005184:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }

        /* By default the reload is activated and executed immediately */
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34005186:	4a06      	ldr	r2, [pc, #24]	@ (340051a0 <BSP_LCD_InitEx+0x16c>)
34005188:	68fb      	ldr	r3, [r7, #12]
3400518a:	015b      	lsls	r3, r3, #5
3400518c:	4413      	add	r3, r2
3400518e:	3318      	adds	r3, #24
34005190:	2201      	movs	r2, #1
34005192:	601a      	str	r2, [r3, #0]
      }
#endif /* DATA_IN_ExtRAM */
    }
  }

  return ret;
34005194:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
34005196:	4618      	mov	r0, r3
34005198:	3730      	adds	r7, #48	@ 0x30
3400519a:	46bd      	mov	sp, r7
3400519c:	bd80      	pop	{r7, pc}
3400519e:	bf00      	nop
340051a0:	34053ad8 	.word	0x34053ad8
340051a4:	34053a30 	.word	0x34053a30
340051a8:	58001000 	.word	0x58001000
340051ac:	340539c8 	.word	0x340539c8
340051b0:	58021000 	.word	0x58021000
340051b4:	34200000 	.word	0x34200000

340051b8 <MX_LTDC_Init>:
  * @param  Width  LTDC width
  * @param  Height LTDC height
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_Init(LTDC_HandleTypeDef *hltdc, uint32_t Width, uint32_t Height)
{
340051b8:	b580      	push	{r7, lr}
340051ba:	b084      	sub	sp, #16
340051bc:	af00      	add	r7, sp, #0
340051be:	60f8      	str	r0, [r7, #12]
340051c0:	60b9      	str	r1, [r7, #8]
340051c2:	607a      	str	r2, [r7, #4]
  hltdc->Instance = LTDC;
340051c4:	68fb      	ldr	r3, [r7, #12]
340051c6:	4a21      	ldr	r2, [pc, #132]	@ (3400524c <MX_LTDC_Init+0x94>)
340051c8:	601a      	str	r2, [r3, #0]
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
340051ca:	68fb      	ldr	r3, [r7, #12]
340051cc:	2200      	movs	r2, #0
340051ce:	605a      	str	r2, [r3, #4]
  hltdc->Init.VSPolarity = LTDC_VSPOLARITY_AL;
340051d0:	68fb      	ldr	r3, [r7, #12]
340051d2:	2200      	movs	r2, #0
340051d4:	609a      	str	r2, [r3, #8]
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
340051d6:	68fb      	ldr	r3, [r7, #12]
340051d8:	2200      	movs	r2, #0
340051da:	60da      	str	r2, [r3, #12]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
340051dc:	68fb      	ldr	r3, [r7, #12]
340051de:	2200      	movs	r2, #0
340051e0:	611a      	str	r2, [r3, #16]

  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
340051e2:	68fb      	ldr	r3, [r7, #12]
340051e4:	2203      	movs	r2, #3
340051e6:	615a      	str	r2, [r3, #20]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
340051e8:	68fb      	ldr	r3, [r7, #12]
340051ea:	220b      	movs	r2, #11
340051ec:	61da      	str	r2, [r3, #28]
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
340051ee:	68bb      	ldr	r3, [r7, #8]
340051f0:	f103 020b 	add.w	r2, r3, #11
340051f4:	68fb      	ldr	r3, [r7, #12]
340051f6:	625a      	str	r2, [r3, #36]	@ 0x24
  hltdc->Init.TotalWidth         = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP + RK050HR18_HFP - 1U;
340051f8:	68bb      	ldr	r3, [r7, #8]
340051fa:	f103 0213 	add.w	r2, r3, #19
340051fe:	68fb      	ldr	r3, [r7, #12]
34005200:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Init.VerticalSync       = (uint32_t)RK050HR18_VSYNC - 1U;
34005202:	68fb      	ldr	r3, [r7, #12]
34005204:	2203      	movs	r2, #3
34005206:	619a      	str	r2, [r3, #24]
  hltdc->Init.AccumulatedVBP     = (uint32_t)RK050HR18_VSYNC + (uint32_t)RK050HR18_VBP - 1U;
34005208:	68fb      	ldr	r3, [r7, #12]
3400520a:	220b      	movs	r2, #11
3400520c:	621a      	str	r2, [r3, #32]
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
3400520e:	687b      	ldr	r3, [r7, #4]
34005210:	f103 020b 	add.w	r2, r3, #11
34005214:	68fb      	ldr	r3, [r7, #12]
34005216:	629a      	str	r2, [r3, #40]	@ 0x28
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34005218:	687b      	ldr	r3, [r7, #4]
3400521a:	f103 0213 	add.w	r2, r3, #19
3400521e:	68fb      	ldr	r3, [r7, #12]
34005220:	631a      	str	r2, [r3, #48]	@ 0x30

  hltdc->Init.Backcolor.Blue  = 0x0;
34005222:	68fb      	ldr	r3, [r7, #12]
34005224:	2200      	movs	r2, #0
34005226:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hltdc->Init.Backcolor.Green = 0x0;
3400522a:	68fb      	ldr	r3, [r7, #12]
3400522c:	2200      	movs	r2, #0
3400522e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
  hltdc->Init.Backcolor.Red   = 0x0;
34005232:	68fb      	ldr	r3, [r7, #12]
34005234:	2200      	movs	r2, #0
34005236:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36

  return HAL_LTDC_Init(hltdc);
3400523a:	68f8      	ldr	r0, [r7, #12]
3400523c:	f004 fc54 	bl	34009ae8 <HAL_LTDC_Init>
34005240:	4603      	mov	r3, r0
}
34005242:	4618      	mov	r0, r3
34005244:	3710      	adds	r7, #16
34005246:	46bd      	mov	sp, r7
34005248:	bd80      	pop	{r7, pc}
3400524a:	bf00      	nop
3400524c:	58001000 	.word	0x58001000

34005250 <MX_LTDC_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, uint32_t LayerIndex, MX_LTDC_LayerConfig_t *Config)
{
34005250:	b580      	push	{r7, lr}
34005252:	b092      	sub	sp, #72	@ 0x48
34005254:	af00      	add	r7, sp, #0
34005256:	60f8      	str	r0, [r7, #12]
34005258:	60b9      	str	r1, [r7, #8]
3400525a:	607a      	str	r2, [r7, #4]
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
3400525c:	f107 0314 	add.w	r3, r7, #20
34005260:	2234      	movs	r2, #52	@ 0x34
34005262:	2100      	movs	r1, #0
34005264:	4618      	mov	r0, r3
34005266:	f01c f9b5 	bl	340215d4 <memset>

  pLayerCfg.WindowX0 = Config->X0;
3400526a:	687b      	ldr	r3, [r7, #4]
3400526c:	681b      	ldr	r3, [r3, #0]
3400526e:	617b      	str	r3, [r7, #20]
  pLayerCfg.WindowX1 = Config->X1;
34005270:	687b      	ldr	r3, [r7, #4]
34005272:	685b      	ldr	r3, [r3, #4]
34005274:	61bb      	str	r3, [r7, #24]
  pLayerCfg.WindowY0 = Config->Y0;
34005276:	687b      	ldr	r3, [r7, #4]
34005278:	689b      	ldr	r3, [r3, #8]
3400527a:	61fb      	str	r3, [r7, #28]
  pLayerCfg.WindowY1 = Config->Y1;
3400527c:	687b      	ldr	r3, [r7, #4]
3400527e:	68db      	ldr	r3, [r3, #12]
34005280:	623b      	str	r3, [r7, #32]
  pLayerCfg.PixelFormat = Config->PixelFormat;
34005282:	687b      	ldr	r3, [r7, #4]
34005284:	691b      	ldr	r3, [r3, #16]
34005286:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
34005288:	23ff      	movs	r3, #255	@ 0xff
3400528a:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg.Alpha0 = 0;
3400528c:	2300      	movs	r3, #0
3400528e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
34005290:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
34005294:	633b      	str	r3, [r7, #48]	@ 0x30
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34005296:	2307      	movs	r3, #7
34005298:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg.FBStartAdress = Config->Address;
3400529a:	687b      	ldr	r3, [r7, #4]
3400529c:	695b      	ldr	r3, [r3, #20]
3400529e:	63bb      	str	r3, [r7, #56]	@ 0x38
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
340052a0:	687b      	ldr	r3, [r7, #4]
340052a2:	685a      	ldr	r2, [r3, #4]
340052a4:	687b      	ldr	r3, [r7, #4]
340052a6:	681b      	ldr	r3, [r3, #0]
340052a8:	1ad3      	subs	r3, r2, r3
340052aa:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
340052ac:	687b      	ldr	r3, [r7, #4]
340052ae:	68da      	ldr	r2, [r3, #12]
340052b0:	687b      	ldr	r3, [r7, #4]
340052b2:	689b      	ldr	r3, [r3, #8]
340052b4:	1ad3      	subs	r3, r2, r3
340052b6:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.Backcolor.Blue = 0;
340052b8:	2300      	movs	r3, #0
340052ba:	f887 3044 	strb.w	r3, [r7, #68]	@ 0x44
  pLayerCfg.Backcolor.Green = 0;
340052be:	2300      	movs	r3, #0
340052c0:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
  pLayerCfg.Backcolor.Red = 0;
340052c4:	2300      	movs	r3, #0
340052c6:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
340052ca:	f107 0314 	add.w	r3, r7, #20
340052ce:	68ba      	ldr	r2, [r7, #8]
340052d0:	4619      	mov	r1, r3
340052d2:	68f8      	ldr	r0, [r7, #12]
340052d4:	f004 fd52 	bl	34009d7c <HAL_LTDC_ConfigLayer>
340052d8:	4603      	mov	r3, r0
}
340052da:	4618      	mov	r0, r3
340052dc:	3748      	adds	r7, #72	@ 0x48
340052de:	46bd      	mov	sp, r7
340052e0:	bd80      	pop	{r7, pc}

340052e2 <MX_LTDC_ClockConfig>:
  * @param  hltdc  LTDC Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_LTDC_ClockConfig(LTDC_HandleTypeDef *hltdc)
{
340052e2:	b580      	push	{r7, lr}
340052e4:	b0e8      	sub	sp, #416	@ 0x1a0
340052e6:	af00      	add	r7, sp, #0
340052e8:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
340052ec:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
340052f0:	6018      	str	r0, [r3, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hltdc);

  HAL_StatusTypeDef   status =  HAL_OK;
340052f2:	2300      	movs	r3, #0
340052f4:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
340052f8:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
340052fc:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34005300:	4618      	mov	r0, r3
34005302:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34005306:	461a      	mov	r2, r3
34005308:	2100      	movs	r1, #0
3400530a:	f01c f963 	bl	340215d4 <memset>
  /* PLL3_VCO Input = HSE_VALUE/PLLM = 48 Mhz / 192 = 0.25 */
  /* PLL3_VCO Output = PLL3_VCO Input * PLLN = 0.25 Mhz * 100 = 25 */
  /* PLLLCDCLK = PLL3_VCO Output/(PLLP1 * PLLP2) = 25/1 = 25Mhz */
  /* LTDC clock frequency = PLLLCDCLK = 25 Mhz */

  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
3400530e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34005312:	f5a3 71cc 	sub.w	r1, r3, #408	@ 0x198
34005316:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400531a:	f04f 0300 	mov.w	r3, #0
3400531e:	e9c1 2300 	strd	r2, r3, [r1]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34005322:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34005326:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
3400532a:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
3400532e:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL4;
34005332:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34005336:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
3400533a:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
3400533e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34005342:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34005346:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
3400534a:	2202      	movs	r2, #2
3400534c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34005350:	f107 0308 	add.w	r3, r7, #8
34005354:	4618      	mov	r0, r3
34005356:	f009 fad7 	bl	3400e908 <HAL_RCCEx_PeriphCLKConfig>
3400535a:	4603      	mov	r3, r0
3400535c:	2b00      	cmp	r3, #0
3400535e:	d002      	beq.n	34005366 <MX_LTDC_ClockConfig+0x84>
  {
    status = HAL_ERROR;
34005360:	2301      	movs	r3, #1
34005362:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  }

  return status;
34005366:	f897 319f 	ldrb.w	r3, [r7, #415]	@ 0x19f
}
3400536a:	4618      	mov	r0, r3
3400536c:	f507 77d0 	add.w	r7, r7, #416	@ 0x1a0
34005370:	46bd      	mov	sp, r7
34005372:	bd80      	pop	{r7, pc}

34005374 <BSP_LCD_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
int32_t BSP_LCD_ConfigLayer(uint32_t Instance, uint32_t LayerIndex, BSP_LCD_LayerConfig_t *Config)
{
34005374:	b580      	push	{r7, lr}
34005376:	b086      	sub	sp, #24
34005378:	af00      	add	r7, sp, #0
3400537a:	60f8      	str	r0, [r7, #12]
3400537c:	60b9      	str	r1, [r7, #8]
3400537e:	607a      	str	r2, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34005380:	2300      	movs	r3, #0
34005382:	617b      	str	r3, [r7, #20]
  if(Instance >= LCD_INSTANCES_NBR)
34005384:	68fb      	ldr	r3, [r7, #12]
34005386:	2b00      	cmp	r3, #0
34005388:	d003      	beq.n	34005392 <BSP_LCD_ConfigLayer+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400538a:	f06f 0301 	mvn.w	r3, #1
3400538e:	617b      	str	r3, [r7, #20]
34005390:	e025      	b.n	340053de <BSP_LCD_ConfigLayer+0x6a>
  }
  else
  {
    if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_RGB565)
34005392:	687b      	ldr	r3, [r7, #4]
34005394:	691b      	ldr	r3, [r3, #16]
34005396:	2b02      	cmp	r3, #2
34005398:	d103      	bne.n	340053a2 <BSP_LCD_ConfigLayer+0x2e>
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
3400539a:	687b      	ldr	r3, [r7, #4]
3400539c:	2204      	movs	r2, #4
3400539e:	611a      	str	r2, [r3, #16]
340053a0:	e012      	b.n	340053c8 <BSP_LCD_ConfigLayer+0x54>
    }
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB4444)
340053a2:	687b      	ldr	r3, [r7, #4]
340053a4:	691b      	ldr	r3, [r3, #16]
340053a6:	2b04      	cmp	r3, #4
340053a8:	d103      	bne.n	340053b2 <BSP_LCD_ConfigLayer+0x3e>
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
340053aa:	687b      	ldr	r3, [r7, #4]
340053ac:	2208      	movs	r2, #8
340053ae:	611a      	str	r2, [r3, #16]
340053b0:	e00a      	b.n	340053c8 <BSP_LCD_ConfigLayer+0x54>
    }
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB8888)
340053b2:	687b      	ldr	r3, [r7, #4]
340053b4:	691b      	ldr	r3, [r3, #16]
340053b6:	2b00      	cmp	r3, #0
340053b8:	d103      	bne.n	340053c2 <BSP_LCD_ConfigLayer+0x4e>
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
340053ba:	687b      	ldr	r3, [r7, #4]
340053bc:	2200      	movs	r2, #0
340053be:	611a      	str	r2, [r3, #16]
340053c0:	e002      	b.n	340053c8 <BSP_LCD_ConfigLayer+0x54>
    }
    else
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
340053c2:	687b      	ldr	r3, [r7, #4]
340053c4:	2206      	movs	r2, #6
340053c6:	611a      	str	r2, [r3, #16]
    }
    if (MX_LTDC_ConfigLayer(&hlcd_ltdc, LayerIndex, Config) != HAL_OK)
340053c8:	687a      	ldr	r2, [r7, #4]
340053ca:	68b9      	ldr	r1, [r7, #8]
340053cc:	4806      	ldr	r0, [pc, #24]	@ (340053e8 <BSP_LCD_ConfigLayer+0x74>)
340053ce:	f7ff ff3f 	bl	34005250 <MX_LTDC_ConfigLayer>
340053d2:	4603      	mov	r3, r0
340053d4:	2b00      	cmp	r3, #0
340053d6:	d002      	beq.n	340053de <BSP_LCD_ConfigLayer+0x6a>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
340053d8:	f06f 0303 	mvn.w	r3, #3
340053dc:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
340053de:	697b      	ldr	r3, [r7, #20]
}
340053e0:	4618      	mov	r0, r3
340053e2:	3718      	adds	r7, #24
340053e4:	46bd      	mov	sp, r7
340053e6:	bd80      	pop	{r7, pc}
340053e8:	34053a30 	.word	0x34053a30

340053ec <BSP_LCD_GetPixelFormat>:
  * @param  Instance    LCD Instance
  * @param  PixelFormat Active LCD Pixel Format
  * @retval BSP status
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
340053ec:	b480      	push	{r7}
340053ee:	b085      	sub	sp, #20
340053f0:	af00      	add	r7, sp, #0
340053f2:	6078      	str	r0, [r7, #4]
340053f4:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
340053f6:	2300      	movs	r3, #0
340053f8:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
340053fa:	687b      	ldr	r3, [r7, #4]
340053fc:	2b00      	cmp	r3, #0
340053fe:	d003      	beq.n	34005408 <BSP_LCD_GetPixelFormat+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34005400:	f06f 0301 	mvn.w	r3, #1
34005404:	60fb      	str	r3, [r7, #12]
34005406:	e007      	b.n	34005418 <BSP_LCD_GetPixelFormat+0x2c>
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat =  Lcd_Ctx[Instance].PixelFormat;
34005408:	4a07      	ldr	r2, [pc, #28]	@ (34005428 <BSP_LCD_GetPixelFormat+0x3c>)
3400540a:	687b      	ldr	r3, [r7, #4]
3400540c:	015b      	lsls	r3, r3, #5
3400540e:	4413      	add	r3, r2
34005410:	330c      	adds	r3, #12
34005412:	681a      	ldr	r2, [r3, #0]
34005414:	683b      	ldr	r3, [r7, #0]
34005416:	601a      	str	r2, [r3, #0]
  }

  return ret;
34005418:	68fb      	ldr	r3, [r7, #12]
}
3400541a:	4618      	mov	r0, r3
3400541c:	3714      	adds	r7, #20
3400541e:	46bd      	mov	sp, r7
34005420:	f85d 7b04 	ldr.w	r7, [sp], #4
34005424:	4770      	bx	lr
34005426:	bf00      	nop
34005428:	34053ad8 	.word	0x34053ad8

3400542c <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
3400542c:	b480      	push	{r7}
3400542e:	b085      	sub	sp, #20
34005430:	af00      	add	r7, sp, #0
34005432:	6078      	str	r0, [r7, #4]
34005434:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34005436:	2300      	movs	r3, #0
34005438:	60fb      	str	r3, [r7, #12]
  LTDC_LayerCfgTypeDef *pLayerCfg;

  if(Instance >= LCD_INSTANCES_NBR)
3400543a:	687b      	ldr	r3, [r7, #4]
3400543c:	2b00      	cmp	r3, #0
3400543e:	d003      	beq.n	34005448 <BSP_LCD_SetActiveLayer+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34005440:	f06f 0301 	mvn.w	r3, #1
34005444:	60fb      	str	r3, [r7, #12]
34005446:	e064      	b.n	34005512 <BSP_LCD_SetActiveLayer+0xe6>
  }
  else
  {
    pLayerCfg = &hlcd_ltdc.LayerCfg[LayerIndex];
34005448:	683b      	ldr	r3, [r7, #0]
3400544a:	2234      	movs	r2, #52	@ 0x34
3400544c:	fb02 f303 	mul.w	r3, r2, r3
34005450:	3338      	adds	r3, #56	@ 0x38
34005452:	4a33      	ldr	r2, [pc, #204]	@ (34005520 <BSP_LCD_SetActiveLayer+0xf4>)
34005454:	4413      	add	r3, r2
34005456:	60bb      	str	r3, [r7, #8]

    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
34005458:	4a32      	ldr	r2, [pc, #200]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
3400545a:	687b      	ldr	r3, [r7, #4]
3400545c:	015b      	lsls	r3, r3, #5
3400545e:	4413      	add	r3, r2
34005460:	3308      	adds	r3, #8
34005462:	683a      	ldr	r2, [r7, #0]
34005464:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34005466:	68bb      	ldr	r3, [r7, #8]
34005468:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400546a:	492e      	ldr	r1, [pc, #184]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
3400546c:	687b      	ldr	r3, [r7, #4]
3400546e:	015b      	lsls	r3, r3, #5
34005470:	440b      	add	r3, r1
34005472:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize = pLayerCfg->ImageHeight;
34005474:	68bb      	ldr	r3, [r7, #8]
34005476:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34005478:	492a      	ldr	r1, [pc, #168]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
3400547a:	687b      	ldr	r3, [r7, #4]
3400547c:	015b      	lsls	r3, r3, #5
3400547e:	440b      	add	r3, r1
34005480:	3304      	adds	r3, #4
34005482:	601a      	str	r2, [r3, #0]

    if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB565)
34005484:	68bb      	ldr	r3, [r7, #8]
34005486:	691b      	ldr	r3, [r3, #16]
34005488:	2b04      	cmp	r3, #4
3400548a:	d10e      	bne.n	340054aa <BSP_LCD_SetActiveLayer+0x7e>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
3400548c:	4a25      	ldr	r2, [pc, #148]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
3400548e:	687b      	ldr	r3, [r7, #4]
34005490:	015b      	lsls	r3, r3, #5
34005492:	4413      	add	r3, r2
34005494:	3310      	adds	r3, #16
34005496:	2202      	movs	r2, #2
34005498:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB565;
3400549a:	4a22      	ldr	r2, [pc, #136]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
3400549c:	687b      	ldr	r3, [r7, #4]
3400549e:	015b      	lsls	r3, r3, #5
340054a0:	4413      	add	r3, r2
340054a2:	330c      	adds	r3, #12
340054a4:	2202      	movs	r2, #2
340054a6:	601a      	str	r2, [r3, #0]
340054a8:	e033      	b.n	34005512 <BSP_LCD_SetActiveLayer+0xe6>
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
340054aa:	68bb      	ldr	r3, [r7, #8]
340054ac:	691b      	ldr	r3, [r3, #16]
340054ae:	2b08      	cmp	r3, #8
340054b0:	d10e      	bne.n	340054d0 <BSP_LCD_SetActiveLayer+0xa4>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
340054b2:	4a1c      	ldr	r2, [pc, #112]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
340054b4:	687b      	ldr	r3, [r7, #4]
340054b6:	015b      	lsls	r3, r3, #5
340054b8:	4413      	add	r3, r2
340054ba:	3310      	adds	r3, #16
340054bc:	2202      	movs	r2, #2
340054be:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
340054c0:	4a18      	ldr	r2, [pc, #96]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
340054c2:	687b      	ldr	r3, [r7, #4]
340054c4:	015b      	lsls	r3, r3, #5
340054c6:	4413      	add	r3, r2
340054c8:	330c      	adds	r3, #12
340054ca:	2204      	movs	r2, #4
340054cc:	601a      	str	r2, [r3, #0]
340054ce:	e020      	b.n	34005512 <BSP_LCD_SetActiveLayer+0xe6>
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB888)
340054d0:	68bb      	ldr	r3, [r7, #8]
340054d2:	691b      	ldr	r3, [r3, #16]
340054d4:	2b06      	cmp	r3, #6
340054d6:	d10e      	bne.n	340054f6 <BSP_LCD_SetActiveLayer+0xca>
    {
      Lcd_Ctx[Instance].BppFactor = 3;
340054d8:	4a12      	ldr	r2, [pc, #72]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
340054da:	687b      	ldr	r3, [r7, #4]
340054dc:	015b      	lsls	r3, r3, #5
340054de:	4413      	add	r3, r2
340054e0:	3310      	adds	r3, #16
340054e2:	2203      	movs	r2, #3
340054e4:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB888;
340054e6:	4a0f      	ldr	r2, [pc, #60]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
340054e8:	687b      	ldr	r3, [r7, #4]
340054ea:	015b      	lsls	r3, r3, #5
340054ec:	4413      	add	r3, r2
340054ee:	330c      	adds	r3, #12
340054f0:	2201      	movs	r2, #1
340054f2:	601a      	str	r2, [r3, #0]
340054f4:	e00d      	b.n	34005512 <BSP_LCD_SetActiveLayer+0xe6>
    }
    else
    {
      Lcd_Ctx[Instance].BppFactor = 4;
340054f6:	4a0b      	ldr	r2, [pc, #44]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
340054f8:	687b      	ldr	r3, [r7, #4]
340054fa:	015b      	lsls	r3, r3, #5
340054fc:	4413      	add	r3, r2
340054fe:	3310      	adds	r3, #16
34005500:	2204      	movs	r2, #4
34005502:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
34005504:	4a07      	ldr	r2, [pc, #28]	@ (34005524 <BSP_LCD_SetActiveLayer+0xf8>)
34005506:	687b      	ldr	r3, [r7, #4]
34005508:	015b      	lsls	r3, r3, #5
3400550a:	4413      	add	r3, r2
3400550c:	330c      	adds	r3, #12
3400550e:	2200      	movs	r2, #0
34005510:	601a      	str	r2, [r3, #0]
    }
  }

  return ret;
34005512:	68fb      	ldr	r3, [r7, #12]
}
34005514:	4618      	mov	r0, r3
34005516:	3714      	adds	r7, #20
34005518:	46bd      	mov	sp, r7
3400551a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400551e:	4770      	bx	lr
34005520:	34053a30 	.word	0x34053a30
34005524:	34053ad8 	.word	0x34053ad8

34005528 <BSP_LCD_GetXSize>:
  * @param  Instance  LCD Instance
  * @param  XSize     LCD width
  * @retval BSP status
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
34005528:	b480      	push	{r7}
3400552a:	b085      	sub	sp, #20
3400552c:	af00      	add	r7, sp, #0
3400552e:	6078      	str	r0, [r7, #4]
34005530:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34005532:	2300      	movs	r3, #0
34005534:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34005536:	687b      	ldr	r3, [r7, #4]
34005538:	2b00      	cmp	r3, #0
3400553a:	d003      	beq.n	34005544 <BSP_LCD_GetXSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400553c:	f06f 0301 	mvn.w	r3, #1
34005540:	60fb      	str	r3, [r7, #12]
34005542:	e006      	b.n	34005552 <BSP_LCD_GetXSize+0x2a>
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
34005544:	4a06      	ldr	r2, [pc, #24]	@ (34005560 <BSP_LCD_GetXSize+0x38>)
34005546:	687b      	ldr	r3, [r7, #4]
34005548:	015b      	lsls	r3, r3, #5
3400554a:	4413      	add	r3, r2
3400554c:	681a      	ldr	r2, [r3, #0]
3400554e:	683b      	ldr	r3, [r7, #0]
34005550:	601a      	str	r2, [r3, #0]
  }

  return ret;
34005552:	68fb      	ldr	r3, [r7, #12]
}
34005554:	4618      	mov	r0, r3
34005556:	3714      	adds	r7, #20
34005558:	46bd      	mov	sp, r7
3400555a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400555e:	4770      	bx	lr
34005560:	34053ad8 	.word	0x34053ad8

34005564 <BSP_LCD_GetYSize>:
  * @param  Instance  LCD Instance
  * @param  YSize     LCD Height
  * @retval BSP status
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
34005564:	b480      	push	{r7}
34005566:	b085      	sub	sp, #20
34005568:	af00      	add	r7, sp, #0
3400556a:	6078      	str	r0, [r7, #4]
3400556c:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
3400556e:	2300      	movs	r3, #0
34005570:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34005572:	687b      	ldr	r3, [r7, #4]
34005574:	2b00      	cmp	r3, #0
34005576:	d003      	beq.n	34005580 <BSP_LCD_GetYSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34005578:	f06f 0301 	mvn.w	r3, #1
3400557c:	60fb      	str	r3, [r7, #12]
3400557e:	e007      	b.n	34005590 <BSP_LCD_GetYSize+0x2c>
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34005580:	4a07      	ldr	r2, [pc, #28]	@ (340055a0 <BSP_LCD_GetYSize+0x3c>)
34005582:	687b      	ldr	r3, [r7, #4]
34005584:	015b      	lsls	r3, r3, #5
34005586:	4413      	add	r3, r2
34005588:	3304      	adds	r3, #4
3400558a:	681a      	ldr	r2, [r3, #0]
3400558c:	683b      	ldr	r3, [r7, #0]
3400558e:	601a      	str	r2, [r3, #0]
  }

  return ret;
34005590:	68fb      	ldr	r3, [r7, #12]
}
34005592:	4618      	mov	r0, r3
34005594:	3714      	adds	r7, #20
34005596:	46bd      	mov	sp, r7
34005598:	f85d 7b04 	ldr.w	r7, [sp], #4
3400559c:	4770      	bx	lr
3400559e:	bf00      	nop
340055a0:	34053ad8 	.word	0x34053ad8

340055a4 <BSP_LCD_DrawBitmap>:
  * @param  Ypos Bmp Y position in the LCD
  * @param  pBmp Pointer to Bmp picture address in the internal Flash.
  * @retval BSP status
  */
int32_t BSP_LCD_DrawBitmap(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pBmp)
{
340055a4:	b580      	push	{r7, lr}
340055a6:	b08e      	sub	sp, #56	@ 0x38
340055a8:	af02      	add	r7, sp, #8
340055aa:	60f8      	str	r0, [r7, #12]
340055ac:	60b9      	str	r1, [r7, #8]
340055ae:	607a      	str	r2, [r7, #4]
340055b0:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
340055b2:	2300      	movs	r3, #0
340055b4:	61fb      	str	r3, [r7, #28]
  uint32_t Address;
  uint32_t input_color_mode;
  uint8_t *pbmp;

  /* Get bitmap data address offset */
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
340055b6:	683b      	ldr	r3, [r7, #0]
340055b8:	330a      	adds	r3, #10
340055ba:	781b      	ldrb	r3, [r3, #0]
340055bc:	461a      	mov	r2, r3
340055be:	683b      	ldr	r3, [r7, #0]
340055c0:	330b      	adds	r3, #11
340055c2:	781b      	ldrb	r3, [r3, #0]
340055c4:	021b      	lsls	r3, r3, #8
340055c6:	441a      	add	r2, r3
340055c8:	683b      	ldr	r3, [r7, #0]
340055ca:	330c      	adds	r3, #12
340055cc:	781b      	ldrb	r3, [r3, #0]
340055ce:	041b      	lsls	r3, r3, #16
340055d0:	441a      	add	r2, r3
340055d2:	683b      	ldr	r3, [r7, #0]
340055d4:	330d      	adds	r3, #13
340055d6:	781b      	ldrb	r3, [r3, #0]
340055d8:	061b      	lsls	r3, r3, #24
340055da:	4413      	add	r3, r2
340055dc:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Read bitmap width */
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
340055de:	683b      	ldr	r3, [r7, #0]
340055e0:	3312      	adds	r3, #18
340055e2:	781b      	ldrb	r3, [r3, #0]
340055e4:	461a      	mov	r2, r3
340055e6:	683b      	ldr	r3, [r7, #0]
340055e8:	3313      	adds	r3, #19
340055ea:	781b      	ldrb	r3, [r3, #0]
340055ec:	021b      	lsls	r3, r3, #8
340055ee:	441a      	add	r2, r3
340055f0:	683b      	ldr	r3, [r7, #0]
340055f2:	3314      	adds	r3, #20
340055f4:	781b      	ldrb	r3, [r3, #0]
340055f6:	041b      	lsls	r3, r3, #16
340055f8:	441a      	add	r2, r3
340055fa:	683b      	ldr	r3, [r7, #0]
340055fc:	3315      	adds	r3, #21
340055fe:	781b      	ldrb	r3, [r3, #0]
34005600:	061b      	lsls	r3, r3, #24
34005602:	4413      	add	r3, r2
34005604:	61bb      	str	r3, [r7, #24]

  /* Read bitmap height */
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
34005606:	683b      	ldr	r3, [r7, #0]
34005608:	3316      	adds	r3, #22
3400560a:	781b      	ldrb	r3, [r3, #0]
3400560c:	461a      	mov	r2, r3
3400560e:	683b      	ldr	r3, [r7, #0]
34005610:	3317      	adds	r3, #23
34005612:	781b      	ldrb	r3, [r3, #0]
34005614:	021b      	lsls	r3, r3, #8
34005616:	441a      	add	r2, r3
34005618:	683b      	ldr	r3, [r7, #0]
3400561a:	3318      	adds	r3, #24
3400561c:	781b      	ldrb	r3, [r3, #0]
3400561e:	041b      	lsls	r3, r3, #16
34005620:	441a      	add	r2, r3
34005622:	683b      	ldr	r3, [r7, #0]
34005624:	3319      	adds	r3, #25
34005626:	781b      	ldrb	r3, [r3, #0]
34005628:	061b      	lsls	r3, r3, #24
3400562a:	4413      	add	r3, r2
3400562c:	617b      	str	r3, [r7, #20]

  /* Read bit/pixel */
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
3400562e:	683b      	ldr	r3, [r7, #0]
34005630:	331c      	adds	r3, #28
34005632:	781b      	ldrb	r3, [r3, #0]
34005634:	461a      	mov	r2, r3
34005636:	683b      	ldr	r3, [r7, #0]
34005638:	331d      	adds	r3, #29
3400563a:	781b      	ldrb	r3, [r3, #0]
3400563c:	021b      	lsls	r3, r3, #8
3400563e:	4413      	add	r3, r2
34005640:	613b      	str	r3, [r7, #16]

  /* Set the address */
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34005642:	4a37      	ldr	r2, [pc, #220]	@ (34005720 <BSP_LCD_DrawBitmap+0x17c>)
34005644:	68fb      	ldr	r3, [r7, #12]
34005646:	015b      	lsls	r3, r3, #5
34005648:	4413      	add	r3, r2
3400564a:	3308      	adds	r3, #8
3400564c:	681b      	ldr	r3, [r3, #0]
3400564e:	4a35      	ldr	r2, [pc, #212]	@ (34005724 <BSP_LCD_DrawBitmap+0x180>)
34005650:	2134      	movs	r1, #52	@ 0x34
34005652:	fb01 f303 	mul.w	r3, r1, r3
34005656:	4413      	add	r3, r2
34005658:	335c      	adds	r3, #92	@ 0x5c
3400565a:	681a      	ldr	r2, [r3, #0]
3400565c:	4930      	ldr	r1, [pc, #192]	@ (34005720 <BSP_LCD_DrawBitmap+0x17c>)
3400565e:	68fb      	ldr	r3, [r7, #12]
34005660:	015b      	lsls	r3, r3, #5
34005662:	440b      	add	r3, r1
34005664:	681b      	ldr	r3, [r3, #0]
34005666:	6879      	ldr	r1, [r7, #4]
34005668:	fb03 f101 	mul.w	r1, r3, r1
3400566c:	68bb      	ldr	r3, [r7, #8]
3400566e:	440b      	add	r3, r1
34005670:	482b      	ldr	r0, [pc, #172]	@ (34005720 <BSP_LCD_DrawBitmap+0x17c>)
34005672:	68f9      	ldr	r1, [r7, #12]
34005674:	0149      	lsls	r1, r1, #5
34005676:	4401      	add	r1, r0
34005678:	3110      	adds	r1, #16
3400567a:	6809      	ldr	r1, [r1, #0]
3400567c:	fb01 f303 	mul.w	r3, r1, r3
34005680:	4413      	add	r3, r2
34005682:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Get the layer pixel format */
  if ((bit_pixel/8U) == 4U)
34005684:	693b      	ldr	r3, [r7, #16]
34005686:	3b20      	subs	r3, #32
34005688:	2b07      	cmp	r3, #7
3400568a:	d802      	bhi.n	34005692 <BSP_LCD_DrawBitmap+0xee>
  {
    input_color_mode = DMA2D_INPUT_ARGB8888;
3400568c:	2300      	movs	r3, #0
3400568e:	627b      	str	r3, [r7, #36]	@ 0x24
34005690:	e008      	b.n	340056a4 <BSP_LCD_DrawBitmap+0x100>
  }
  else if ((bit_pixel/8U) == 2U)
34005692:	693b      	ldr	r3, [r7, #16]
34005694:	3b10      	subs	r3, #16
34005696:	2b07      	cmp	r3, #7
34005698:	d802      	bhi.n	340056a0 <BSP_LCD_DrawBitmap+0xfc>
  {
    input_color_mode = DMA2D_INPUT_RGB565;
3400569a:	2302      	movs	r3, #2
3400569c:	627b      	str	r3, [r7, #36]	@ 0x24
3400569e:	e001      	b.n	340056a4 <BSP_LCD_DrawBitmap+0x100>
  }
  else
  {
    input_color_mode = DMA2D_INPUT_RGB888;
340056a0:	2301      	movs	r3, #1
340056a2:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Bypass the bitmap header */
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
340056a4:	697b      	ldr	r3, [r7, #20]
340056a6:	3b01      	subs	r3, #1
340056a8:	69ba      	ldr	r2, [r7, #24]
340056aa:	fb02 f303 	mul.w	r3, r2, r3
340056ae:	693a      	ldr	r2, [r7, #16]
340056b0:	08d2      	lsrs	r2, r2, #3
340056b2:	fb03 f202 	mul.w	r2, r3, r2
340056b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340056b8:	4413      	add	r3, r2
340056ba:	683a      	ldr	r2, [r7, #0]
340056bc:	4413      	add	r3, r2
340056be:	623b      	str	r3, [r7, #32]

  /* Convert picture to ARGB8888 pixel format */
  for(index=0; index < height; index++)
340056c0:	2300      	movs	r3, #0
340056c2:	62fb      	str	r3, [r7, #44]	@ 0x2c
340056c4:	e023      	b.n	3400570e <BSP_LCD_DrawBitmap+0x16a>
  {
    /* Pixel format conversion */
    LL_ConvertLineToRGB(Instance, (uint32_t *)pbmp, (uint32_t *)Address, width, input_color_mode);
340056c6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340056c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340056ca:	9300      	str	r3, [sp, #0]
340056cc:	69bb      	ldr	r3, [r7, #24]
340056ce:	6a39      	ldr	r1, [r7, #32]
340056d0:	68f8      	ldr	r0, [r7, #12]
340056d2:	f000 fb27 	bl	34005d24 <LL_ConvertLineToRGB>

    /* Increment the source and destination buffers */
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
340056d6:	4a12      	ldr	r2, [pc, #72]	@ (34005720 <BSP_LCD_DrawBitmap+0x17c>)
340056d8:	68fb      	ldr	r3, [r7, #12]
340056da:	015b      	lsls	r3, r3, #5
340056dc:	4413      	add	r3, r2
340056de:	681b      	ldr	r3, [r3, #0]
340056e0:	490f      	ldr	r1, [pc, #60]	@ (34005720 <BSP_LCD_DrawBitmap+0x17c>)
340056e2:	68fa      	ldr	r2, [r7, #12]
340056e4:	0152      	lsls	r2, r2, #5
340056e6:	440a      	add	r2, r1
340056e8:	3210      	adds	r2, #16
340056ea:	6812      	ldr	r2, [r2, #0]
340056ec:	fb02 f303 	mul.w	r3, r2, r3
340056f0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340056f2:	4413      	add	r3, r2
340056f4:	62bb      	str	r3, [r7, #40]	@ 0x28
    pbmp -= width*(bit_pixel/8U);
340056f6:	693b      	ldr	r3, [r7, #16]
340056f8:	08db      	lsrs	r3, r3, #3
340056fa:	69ba      	ldr	r2, [r7, #24]
340056fc:	fb02 f303 	mul.w	r3, r2, r3
34005700:	425b      	negs	r3, r3
34005702:	6a3a      	ldr	r2, [r7, #32]
34005704:	4413      	add	r3, r2
34005706:	623b      	str	r3, [r7, #32]
  for(index=0; index < height; index++)
34005708:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400570a:	3301      	adds	r3, #1
3400570c:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400570e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34005710:	697b      	ldr	r3, [r7, #20]
34005712:	429a      	cmp	r2, r3
34005714:	d3d7      	bcc.n	340056c6 <BSP_LCD_DrawBitmap+0x122>
  }

  return ret;
34005716:	69fb      	ldr	r3, [r7, #28]
}
34005718:	4618      	mov	r0, r3
3400571a:	3730      	adds	r7, #48	@ 0x30
3400571c:	46bd      	mov	sp, r7
3400571e:	bd80      	pop	{r7, pc}
34005720:	34053ad8 	.word	0x34053ad8
34005724:	34053a30 	.word	0x34053a30

34005728 <BSP_LCD_FillRGBRect>:
  * @param  Width Rectangle width.
  * @param  Height Rectangle Height.
  * @retval BSP status.
  */
int32_t BSP_LCD_FillRGBRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
34005728:	b580      	push	{r7, lr}
3400572a:	b088      	sub	sp, #32
3400572c:	af00      	add	r7, sp, #0
3400572e:	60f8      	str	r0, [r7, #12]
34005730:	60b9      	str	r1, [r7, #8]
34005732:	607a      	str	r2, [r7, #4]
34005734:	603b      	str	r3, [r7, #0]
  uint32_t i;
  uint8_t *pdata = pData;
34005736:	683b      	ldr	r3, [r7, #0]
34005738:	61bb      	str	r3, [r7, #24]
    pdata += Lcd_Ctx[Instance].BppFactor*Width;
  }
#else
  uint32_t color;
  uint32_t j;
  for(i = 0; i < Height; i++)
3400573a:	2300      	movs	r3, #0
3400573c:	61fb      	str	r3, [r7, #28]
3400573e:	e032      	b.n	340057a6 <BSP_LCD_FillRGBRect+0x7e>
  {
    for(j = 0; j < Width; j++)
34005740:	2300      	movs	r3, #0
34005742:	617b      	str	r3, [r7, #20]
34005744:	e028      	b.n	34005798 <BSP_LCD_FillRGBRect+0x70>
    {
      color = (uint32_t)((uint32_t)*pdata | ((uint32_t)(*(pdata + 1U)) << 8U) | ((uint32_t)(*(pdata + 2U)) << 16U) | ((uint32_t)(*(pdata + 3U)) << 24U));
34005746:	69bb      	ldr	r3, [r7, #24]
34005748:	781b      	ldrb	r3, [r3, #0]
3400574a:	461a      	mov	r2, r3
3400574c:	69bb      	ldr	r3, [r7, #24]
3400574e:	3301      	adds	r3, #1
34005750:	781b      	ldrb	r3, [r3, #0]
34005752:	021b      	lsls	r3, r3, #8
34005754:	431a      	orrs	r2, r3
34005756:	69bb      	ldr	r3, [r7, #24]
34005758:	3302      	adds	r3, #2
3400575a:	781b      	ldrb	r3, [r3, #0]
3400575c:	041b      	lsls	r3, r3, #16
3400575e:	431a      	orrs	r2, r3
34005760:	69bb      	ldr	r3, [r7, #24]
34005762:	3303      	adds	r3, #3
34005764:	781b      	ldrb	r3, [r3, #0]
34005766:	061b      	lsls	r3, r3, #24
34005768:	4313      	orrs	r3, r2
3400576a:	613b      	str	r3, [r7, #16]
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
3400576c:	68ba      	ldr	r2, [r7, #8]
3400576e:	697b      	ldr	r3, [r7, #20]
34005770:	18d1      	adds	r1, r2, r3
34005772:	687a      	ldr	r2, [r7, #4]
34005774:	69fb      	ldr	r3, [r7, #28]
34005776:	441a      	add	r2, r3
34005778:	693b      	ldr	r3, [r7, #16]
3400577a:	68f8      	ldr	r0, [r7, #12]
3400577c:	f000 f96c 	bl	34005a58 <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
34005780:	4a0d      	ldr	r2, [pc, #52]	@ (340057b8 <BSP_LCD_FillRGBRect+0x90>)
34005782:	68fb      	ldr	r3, [r7, #12]
34005784:	015b      	lsls	r3, r3, #5
34005786:	4413      	add	r3, r2
34005788:	3310      	adds	r3, #16
3400578a:	681b      	ldr	r3, [r3, #0]
3400578c:	69ba      	ldr	r2, [r7, #24]
3400578e:	4413      	add	r3, r2
34005790:	61bb      	str	r3, [r7, #24]
    for(j = 0; j < Width; j++)
34005792:	697b      	ldr	r3, [r7, #20]
34005794:	3301      	adds	r3, #1
34005796:	617b      	str	r3, [r7, #20]
34005798:	697a      	ldr	r2, [r7, #20]
3400579a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400579c:	429a      	cmp	r2, r3
3400579e:	d3d2      	bcc.n	34005746 <BSP_LCD_FillRGBRect+0x1e>
  for(i = 0; i < Height; i++)
340057a0:	69fb      	ldr	r3, [r7, #28]
340057a2:	3301      	adds	r3, #1
340057a4:	61fb      	str	r3, [r7, #28]
340057a6:	69fa      	ldr	r2, [r7, #28]
340057a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340057aa:	429a      	cmp	r2, r3
340057ac:	d3c8      	bcc.n	34005740 <BSP_LCD_FillRGBRect+0x18>
    }
  }
#endif /* (USE_DMA2D_TO_FILL_RGB_RECT == 1) */

  return BSP_ERROR_NONE;
340057ae:	2300      	movs	r3, #0
}
340057b0:	4618      	mov	r0, r3
340057b2:	3720      	adds	r7, #32
340057b4:	46bd      	mov	sp, r7
340057b6:	bd80      	pop	{r7, pc}
340057b8:	34053ad8 	.word	0x34053ad8

340057bc <BSP_LCD_DrawHLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawHLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
340057bc:	b580      	push	{r7, lr}
340057be:	b088      	sub	sp, #32
340057c0:	af02      	add	r7, sp, #8
340057c2:	60f8      	str	r0, [r7, #12]
340057c4:	60b9      	str	r1, [r7, #8]
340057c6:	607a      	str	r2, [r7, #4]
340057c8:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340057ca:	4a18      	ldr	r2, [pc, #96]	@ (3400582c <BSP_LCD_DrawHLine+0x70>)
340057cc:	68fb      	ldr	r3, [r7, #12]
340057ce:	015b      	lsls	r3, r3, #5
340057d0:	4413      	add	r3, r2
340057d2:	3308      	adds	r3, #8
340057d4:	681b      	ldr	r3, [r3, #0]
340057d6:	4a16      	ldr	r2, [pc, #88]	@ (34005830 <BSP_LCD_DrawHLine+0x74>)
340057d8:	2134      	movs	r1, #52	@ 0x34
340057da:	fb01 f303 	mul.w	r3, r1, r3
340057de:	4413      	add	r3, r2
340057e0:	335c      	adds	r3, #92	@ 0x5c
340057e2:	681a      	ldr	r2, [r3, #0]
340057e4:	4911      	ldr	r1, [pc, #68]	@ (3400582c <BSP_LCD_DrawHLine+0x70>)
340057e6:	68fb      	ldr	r3, [r7, #12]
340057e8:	015b      	lsls	r3, r3, #5
340057ea:	440b      	add	r3, r1
340057ec:	3310      	adds	r3, #16
340057ee:	681b      	ldr	r3, [r3, #0]
340057f0:	480e      	ldr	r0, [pc, #56]	@ (3400582c <BSP_LCD_DrawHLine+0x70>)
340057f2:	68f9      	ldr	r1, [r7, #12]
340057f4:	0149      	lsls	r1, r1, #5
340057f6:	4401      	add	r1, r0
340057f8:	6809      	ldr	r1, [r1, #0]
340057fa:	6878      	ldr	r0, [r7, #4]
340057fc:	fb01 f000 	mul.w	r0, r1, r0
34005800:	68b9      	ldr	r1, [r7, #8]
34005802:	4401      	add	r1, r0
34005804:	fb01 f303 	mul.w	r3, r1, r3
34005808:	4413      	add	r3, r2
3400580a:	617b      	str	r3, [r7, #20]

  /* Write line */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
3400580c:	6979      	ldr	r1, [r7, #20]
3400580e:	6a3b      	ldr	r3, [r7, #32]
34005810:	9301      	str	r3, [sp, #4]
34005812:	2300      	movs	r3, #0
34005814:	9300      	str	r3, [sp, #0]
34005816:	2301      	movs	r3, #1
34005818:	683a      	ldr	r2, [r7, #0]
3400581a:	68f8      	ldr	r0, [r7, #12]
3400581c:	f000 f9e6 	bl	34005bec <LL_FillBuffer>

  return BSP_ERROR_NONE;
34005820:	2300      	movs	r3, #0
}
34005822:	4618      	mov	r0, r3
34005824:	3718      	adds	r7, #24
34005826:	46bd      	mov	sp, r7
34005828:	bd80      	pop	{r7, pc}
3400582a:	bf00      	nop
3400582c:	34053ad8 	.word	0x34053ad8
34005830:	34053a30 	.word	0x34053a30

34005834 <BSP_LCD_DrawVLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawVLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34005834:	b580      	push	{r7, lr}
34005836:	b088      	sub	sp, #32
34005838:	af02      	add	r7, sp, #8
3400583a:	60f8      	str	r0, [r7, #12]
3400583c:	60b9      	str	r1, [r7, #8]
3400583e:	607a      	str	r2, [r7, #4]
34005840:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34005842:	4a1a      	ldr	r2, [pc, #104]	@ (340058ac <BSP_LCD_DrawVLine+0x78>)
34005844:	68fb      	ldr	r3, [r7, #12]
34005846:	015b      	lsls	r3, r3, #5
34005848:	4413      	add	r3, r2
3400584a:	3308      	adds	r3, #8
3400584c:	681b      	ldr	r3, [r3, #0]
3400584e:	4a18      	ldr	r2, [pc, #96]	@ (340058b0 <BSP_LCD_DrawVLine+0x7c>)
34005850:	2134      	movs	r1, #52	@ 0x34
34005852:	fb01 f303 	mul.w	r3, r1, r3
34005856:	4413      	add	r3, r2
34005858:	335c      	adds	r3, #92	@ 0x5c
3400585a:	681a      	ldr	r2, [r3, #0]
3400585c:	4913      	ldr	r1, [pc, #76]	@ (340058ac <BSP_LCD_DrawVLine+0x78>)
3400585e:	68fb      	ldr	r3, [r7, #12]
34005860:	015b      	lsls	r3, r3, #5
34005862:	440b      	add	r3, r1
34005864:	3310      	adds	r3, #16
34005866:	681b      	ldr	r3, [r3, #0]
34005868:	4810      	ldr	r0, [pc, #64]	@ (340058ac <BSP_LCD_DrawVLine+0x78>)
3400586a:	68f9      	ldr	r1, [r7, #12]
3400586c:	0149      	lsls	r1, r1, #5
3400586e:	4401      	add	r1, r0
34005870:	6809      	ldr	r1, [r1, #0]
34005872:	6878      	ldr	r0, [r7, #4]
34005874:	fb01 f000 	mul.w	r0, r1, r0
34005878:	68b9      	ldr	r1, [r7, #8]
3400587a:	4401      	add	r1, r0
3400587c:	fb01 f303 	mul.w	r3, r1, r3
34005880:	4413      	add	r3, r2
34005882:	617b      	str	r3, [r7, #20]

  /* Write line */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34005884:	6979      	ldr	r1, [r7, #20]
34005886:	4a09      	ldr	r2, [pc, #36]	@ (340058ac <BSP_LCD_DrawVLine+0x78>)
34005888:	68fb      	ldr	r3, [r7, #12]
3400588a:	015b      	lsls	r3, r3, #5
3400588c:	4413      	add	r3, r2
3400588e:	681b      	ldr	r3, [r3, #0]
34005890:	3b01      	subs	r3, #1
34005892:	6a3a      	ldr	r2, [r7, #32]
34005894:	9201      	str	r2, [sp, #4]
34005896:	9300      	str	r3, [sp, #0]
34005898:	683b      	ldr	r3, [r7, #0]
3400589a:	2201      	movs	r2, #1
3400589c:	68f8      	ldr	r0, [r7, #12]
3400589e:	f000 f9a5 	bl	34005bec <LL_FillBuffer>

  return BSP_ERROR_NONE;
340058a2:	2300      	movs	r3, #0
}
340058a4:	4618      	mov	r0, r3
340058a6:	3718      	adds	r7, #24
340058a8:	46bd      	mov	sp, r7
340058aa:	bd80      	pop	{r7, pc}
340058ac:	34053ad8 	.word	0x34053ad8
340058b0:	34053a30 	.word	0x34053a30

340058b4 <BSP_LCD_FillRect>:
  * @param  Height Rectangle height
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_FillRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
340058b4:	b580      	push	{r7, lr}
340058b6:	b088      	sub	sp, #32
340058b8:	af02      	add	r7, sp, #8
340058ba:	60f8      	str	r0, [r7, #12]
340058bc:	60b9      	str	r1, [r7, #8]
340058be:	607a      	str	r2, [r7, #4]
340058c0:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the rectangle start address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340058c2:	4a1b      	ldr	r2, [pc, #108]	@ (34005930 <BSP_LCD_FillRect+0x7c>)
340058c4:	68fb      	ldr	r3, [r7, #12]
340058c6:	015b      	lsls	r3, r3, #5
340058c8:	4413      	add	r3, r2
340058ca:	3308      	adds	r3, #8
340058cc:	681b      	ldr	r3, [r3, #0]
340058ce:	4a19      	ldr	r2, [pc, #100]	@ (34005934 <BSP_LCD_FillRect+0x80>)
340058d0:	2134      	movs	r1, #52	@ 0x34
340058d2:	fb01 f303 	mul.w	r3, r1, r3
340058d6:	4413      	add	r3, r2
340058d8:	335c      	adds	r3, #92	@ 0x5c
340058da:	681a      	ldr	r2, [r3, #0]
340058dc:	4914      	ldr	r1, [pc, #80]	@ (34005930 <BSP_LCD_FillRect+0x7c>)
340058de:	68fb      	ldr	r3, [r7, #12]
340058e0:	015b      	lsls	r3, r3, #5
340058e2:	440b      	add	r3, r1
340058e4:	3310      	adds	r3, #16
340058e6:	681b      	ldr	r3, [r3, #0]
340058e8:	4811      	ldr	r0, [pc, #68]	@ (34005930 <BSP_LCD_FillRect+0x7c>)
340058ea:	68f9      	ldr	r1, [r7, #12]
340058ec:	0149      	lsls	r1, r1, #5
340058ee:	4401      	add	r1, r0
340058f0:	6809      	ldr	r1, [r1, #0]
340058f2:	6878      	ldr	r0, [r7, #4]
340058f4:	fb01 f000 	mul.w	r0, r1, r0
340058f8:	68b9      	ldr	r1, [r7, #8]
340058fa:	4401      	add	r1, r0
340058fc:	fb01 f303 	mul.w	r3, r1, r3
34005900:	4413      	add	r3, r2
34005902:	617b      	str	r3, [r7, #20]

  /* Fill the rectangle */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34005904:	6979      	ldr	r1, [r7, #20]
34005906:	4a0a      	ldr	r2, [pc, #40]	@ (34005930 <BSP_LCD_FillRect+0x7c>)
34005908:	68fb      	ldr	r3, [r7, #12]
3400590a:	015b      	lsls	r3, r3, #5
3400590c:	4413      	add	r3, r2
3400590e:	681a      	ldr	r2, [r3, #0]
34005910:	683b      	ldr	r3, [r7, #0]
34005912:	1ad3      	subs	r3, r2, r3
34005914:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34005916:	9201      	str	r2, [sp, #4]
34005918:	9300      	str	r3, [sp, #0]
3400591a:	6a3b      	ldr	r3, [r7, #32]
3400591c:	683a      	ldr	r2, [r7, #0]
3400591e:	68f8      	ldr	r0, [r7, #12]
34005920:	f000 f964 	bl	34005bec <LL_FillBuffer>

  return BSP_ERROR_NONE;
34005924:	2300      	movs	r3, #0
}
34005926:	4618      	mov	r0, r3
34005928:	3718      	adds	r7, #24
3400592a:	46bd      	mov	sp, r7
3400592c:	bd80      	pop	{r7, pc}
3400592e:	bf00      	nop
34005930:	34053ad8 	.word	0x34053ad8
34005934:	34053a30 	.word	0x34053a30

34005938 <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
34005938:	b480      	push	{r7}
3400593a:	b085      	sub	sp, #20
3400593c:	af00      	add	r7, sp, #0
3400593e:	60f8      	str	r0, [r7, #12]
34005940:	60b9      	str	r1, [r7, #8]
34005942:	607a      	str	r2, [r7, #4]
34005944:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34005946:	4a42      	ldr	r2, [pc, #264]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
34005948:	68fb      	ldr	r3, [r7, #12]
3400594a:	015b      	lsls	r3, r3, #5
3400594c:	4413      	add	r3, r2
3400594e:	3308      	adds	r3, #8
34005950:	681b      	ldr	r3, [r3, #0]
34005952:	4a40      	ldr	r2, [pc, #256]	@ (34005a54 <BSP_LCD_ReadPixel+0x11c>)
34005954:	2134      	movs	r1, #52	@ 0x34
34005956:	fb01 f303 	mul.w	r3, r1, r3
3400595a:	4413      	add	r3, r2
3400595c:	3348      	adds	r3, #72	@ 0x48
3400595e:	681b      	ldr	r3, [r3, #0]
34005960:	2b00      	cmp	r3, #0
34005962:	d11c      	bne.n	3400599e <BSP_LCD_ReadPixel+0x66>
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34005964:	4a3a      	ldr	r2, [pc, #232]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
34005966:	68fb      	ldr	r3, [r7, #12]
34005968:	015b      	lsls	r3, r3, #5
3400596a:	4413      	add	r3, r2
3400596c:	3308      	adds	r3, #8
3400596e:	681b      	ldr	r3, [r3, #0]
34005970:	4a38      	ldr	r2, [pc, #224]	@ (34005a54 <BSP_LCD_ReadPixel+0x11c>)
34005972:	2134      	movs	r1, #52	@ 0x34
34005974:	fb01 f303 	mul.w	r3, r1, r3
34005978:	4413      	add	r3, r2
3400597a:	335c      	adds	r3, #92	@ 0x5c
3400597c:	681a      	ldr	r2, [r3, #0]
3400597e:	4934      	ldr	r1, [pc, #208]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
34005980:	68fb      	ldr	r3, [r7, #12]
34005982:	015b      	lsls	r3, r3, #5
34005984:	440b      	add	r3, r1
34005986:	681b      	ldr	r3, [r3, #0]
34005988:	6879      	ldr	r1, [r7, #4]
3400598a:	fb03 f101 	mul.w	r1, r3, r1
3400598e:	68bb      	ldr	r3, [r7, #8]
34005990:	440b      	add	r3, r1
34005992:	009b      	lsls	r3, r3, #2
34005994:	4413      	add	r3, r2
34005996:	681a      	ldr	r2, [r3, #0]
34005998:	683b      	ldr	r3, [r7, #0]
3400599a:	601a      	str	r2, [r3, #0]
3400599c:	e051      	b.n	34005a42 <BSP_LCD_ReadPixel+0x10a>
  }
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
3400599e:	4a2c      	ldr	r2, [pc, #176]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
340059a0:	68fb      	ldr	r3, [r7, #12]
340059a2:	015b      	lsls	r3, r3, #5
340059a4:	4413      	add	r3, r2
340059a6:	3308      	adds	r3, #8
340059a8:	681b      	ldr	r3, [r3, #0]
340059aa:	4a2a      	ldr	r2, [pc, #168]	@ (34005a54 <BSP_LCD_ReadPixel+0x11c>)
340059ac:	2134      	movs	r1, #52	@ 0x34
340059ae:	fb01 f303 	mul.w	r3, r1, r3
340059b2:	4413      	add	r3, r2
340059b4:	3348      	adds	r3, #72	@ 0x48
340059b6:	681b      	ldr	r3, [r3, #0]
340059b8:	2b06      	cmp	r3, #6
340059ba:	d124      	bne.n	34005a06 <BSP_LCD_ReadPixel+0xce>
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340059bc:	4a24      	ldr	r2, [pc, #144]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
340059be:	68fb      	ldr	r3, [r7, #12]
340059c0:	015b      	lsls	r3, r3, #5
340059c2:	4413      	add	r3, r2
340059c4:	3308      	adds	r3, #8
340059c6:	681b      	ldr	r3, [r3, #0]
340059c8:	4a22      	ldr	r2, [pc, #136]	@ (34005a54 <BSP_LCD_ReadPixel+0x11c>)
340059ca:	2134      	movs	r1, #52	@ 0x34
340059cc:	fb01 f303 	mul.w	r3, r1, r3
340059d0:	4413      	add	r3, r2
340059d2:	335c      	adds	r3, #92	@ 0x5c
340059d4:	6819      	ldr	r1, [r3, #0]
340059d6:	4a1e      	ldr	r2, [pc, #120]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
340059d8:	68fb      	ldr	r3, [r7, #12]
340059da:	015b      	lsls	r3, r3, #5
340059dc:	4413      	add	r3, r2
340059de:	681b      	ldr	r3, [r3, #0]
340059e0:	687a      	ldr	r2, [r7, #4]
340059e2:	fb03 f202 	mul.w	r2, r3, r2
340059e6:	68bb      	ldr	r3, [r7, #8]
340059e8:	441a      	add	r2, r3
340059ea:	4613      	mov	r3, r2
340059ec:	005b      	lsls	r3, r3, #1
340059ee:	4413      	add	r3, r2
340059f0:	440b      	add	r3, r1
340059f2:	681a      	ldr	r2, [r3, #0]
340059f4:	683b      	ldr	r3, [r7, #0]
340059f6:	601a      	str	r2, [r3, #0]
    *Color = CONVERTARGB88882RGB888(*Color);
340059f8:	683b      	ldr	r3, [r7, #0]
340059fa:	681b      	ldr	r3, [r3, #0]
340059fc:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34005a00:	683b      	ldr	r3, [r7, #0]
34005a02:	601a      	str	r2, [r3, #0]
34005a04:	e01d      	b.n	34005a42 <BSP_LCD_ReadPixel+0x10a>
  }
  else /* if((hlcd_ltdc.LayerCfg[layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565) */
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34005a06:	4a12      	ldr	r2, [pc, #72]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
34005a08:	68fb      	ldr	r3, [r7, #12]
34005a0a:	015b      	lsls	r3, r3, #5
34005a0c:	4413      	add	r3, r2
34005a0e:	3308      	adds	r3, #8
34005a10:	681b      	ldr	r3, [r3, #0]
34005a12:	4a10      	ldr	r2, [pc, #64]	@ (34005a54 <BSP_LCD_ReadPixel+0x11c>)
34005a14:	2134      	movs	r1, #52	@ 0x34
34005a16:	fb01 f303 	mul.w	r3, r1, r3
34005a1a:	4413      	add	r3, r2
34005a1c:	335c      	adds	r3, #92	@ 0x5c
34005a1e:	681a      	ldr	r2, [r3, #0]
34005a20:	490b      	ldr	r1, [pc, #44]	@ (34005a50 <BSP_LCD_ReadPixel+0x118>)
34005a22:	68fb      	ldr	r3, [r7, #12]
34005a24:	015b      	lsls	r3, r3, #5
34005a26:	440b      	add	r3, r1
34005a28:	681b      	ldr	r3, [r3, #0]
34005a2a:	6879      	ldr	r1, [r7, #4]
34005a2c:	fb03 f101 	mul.w	r1, r3, r1
34005a30:	68bb      	ldr	r3, [r7, #8]
34005a32:	440b      	add	r3, r1
34005a34:	005b      	lsls	r3, r3, #1
34005a36:	4413      	add	r3, r2
34005a38:	881b      	ldrh	r3, [r3, #0]
34005a3a:	b29b      	uxth	r3, r3
34005a3c:	461a      	mov	r2, r3
34005a3e:	683b      	ldr	r3, [r7, #0]
34005a40:	601a      	str	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
34005a42:	2300      	movs	r3, #0
}
34005a44:	4618      	mov	r0, r3
34005a46:	3714      	adds	r7, #20
34005a48:	46bd      	mov	sp, r7
34005a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
34005a4e:	4770      	bx	lr
34005a50:	34053ad8 	.word	0x34053ad8
34005a54:	34053a30 	.word	0x34053a30

34005a58 <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
34005a58:	b480      	push	{r7}
34005a5a:	b085      	sub	sp, #20
34005a5c:	af00      	add	r7, sp, #0
34005a5e:	60f8      	str	r0, [r7, #12]
34005a60:	60b9      	str	r1, [r7, #8]
34005a62:	607a      	str	r2, [r7, #4]
34005a64:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34005a66:	4a5f      	ldr	r2, [pc, #380]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005a68:	68fb      	ldr	r3, [r7, #12]
34005a6a:	015b      	lsls	r3, r3, #5
34005a6c:	4413      	add	r3, r2
34005a6e:	3308      	adds	r3, #8
34005a70:	681b      	ldr	r3, [r3, #0]
34005a72:	4a5d      	ldr	r2, [pc, #372]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005a74:	2134      	movs	r1, #52	@ 0x34
34005a76:	fb01 f303 	mul.w	r3, r1, r3
34005a7a:	4413      	add	r3, r2
34005a7c:	3348      	adds	r3, #72	@ 0x48
34005a7e:	681b      	ldr	r3, [r3, #0]
34005a80:	2b00      	cmp	r3, #0
34005a82:	d11c      	bne.n	34005abe <BSP_LCD_WritePixel+0x66>
  {
    /* Write data value to RAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
34005a84:	4a57      	ldr	r2, [pc, #348]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005a86:	68fb      	ldr	r3, [r7, #12]
34005a88:	015b      	lsls	r3, r3, #5
34005a8a:	4413      	add	r3, r2
34005a8c:	3308      	adds	r3, #8
34005a8e:	681b      	ldr	r3, [r3, #0]
34005a90:	4a55      	ldr	r2, [pc, #340]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005a92:	2134      	movs	r1, #52	@ 0x34
34005a94:	fb01 f303 	mul.w	r3, r1, r3
34005a98:	4413      	add	r3, r2
34005a9a:	335c      	adds	r3, #92	@ 0x5c
34005a9c:	681a      	ldr	r2, [r3, #0]
34005a9e:	4951      	ldr	r1, [pc, #324]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005aa0:	68fb      	ldr	r3, [r7, #12]
34005aa2:	015b      	lsls	r3, r3, #5
34005aa4:	440b      	add	r3, r1
34005aa6:	681b      	ldr	r3, [r3, #0]
34005aa8:	6879      	ldr	r1, [r7, #4]
34005aaa:	fb03 f101 	mul.w	r1, r3, r1
34005aae:	68bb      	ldr	r3, [r7, #8]
34005ab0:	440b      	add	r3, r1
34005ab2:	009b      	lsls	r3, r3, #2
34005ab4:	4413      	add	r3, r2
34005ab6:	461a      	mov	r2, r3
34005ab8:	683b      	ldr	r3, [r7, #0]
34005aba:	6013      	str	r3, [r2, #0]
34005abc:	e08a      	b.n	34005bd4 <BSP_LCD_WritePixel+0x17c>
  }
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34005abe:	4a49      	ldr	r2, [pc, #292]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005ac0:	68fb      	ldr	r3, [r7, #12]
34005ac2:	015b      	lsls	r3, r3, #5
34005ac4:	4413      	add	r3, r2
34005ac6:	3308      	adds	r3, #8
34005ac8:	681b      	ldr	r3, [r3, #0]
34005aca:	4a47      	ldr	r2, [pc, #284]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005acc:	2134      	movs	r1, #52	@ 0x34
34005ace:	fb01 f303 	mul.w	r3, r1, r3
34005ad2:	4413      	add	r3, r2
34005ad4:	3348      	adds	r3, #72	@ 0x48
34005ad6:	681b      	ldr	r3, [r3, #0]
34005ad8:	2b06      	cmp	r3, #6
34005ada:	d15f      	bne.n	34005b9c <BSP_LCD_WritePixel+0x144>
  {
    /* Write data value to RAM memory */
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-3U)) = (uint8_t) (Color);
34005adc:	4a41      	ldr	r2, [pc, #260]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005ade:	68fb      	ldr	r3, [r7, #12]
34005ae0:	015b      	lsls	r3, r3, #5
34005ae2:	4413      	add	r3, r2
34005ae4:	3308      	adds	r3, #8
34005ae6:	681b      	ldr	r3, [r3, #0]
34005ae8:	4a3f      	ldr	r2, [pc, #252]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005aea:	2134      	movs	r1, #52	@ 0x34
34005aec:	fb01 f303 	mul.w	r3, r1, r3
34005af0:	4413      	add	r3, r2
34005af2:	335c      	adds	r3, #92	@ 0x5c
34005af4:	6819      	ldr	r1, [r3, #0]
34005af6:	4a3b      	ldr	r2, [pc, #236]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005af8:	68fb      	ldr	r3, [r7, #12]
34005afa:	015b      	lsls	r3, r3, #5
34005afc:	4413      	add	r3, r2
34005afe:	681b      	ldr	r3, [r3, #0]
34005b00:	687a      	ldr	r2, [r7, #4]
34005b02:	fb03 f202 	mul.w	r2, r3, r2
34005b06:	68bb      	ldr	r3, [r7, #8]
34005b08:	441a      	add	r2, r3
34005b0a:	4613      	mov	r3, r2
34005b0c:	005b      	lsls	r3, r3, #1
34005b0e:	4413      	add	r3, r2
34005b10:	440b      	add	r3, r1
34005b12:	3b03      	subs	r3, #3
34005b14:	683a      	ldr	r2, [r7, #0]
34005b16:	b2d2      	uxtb	r2, r2
34005b18:	701a      	strb	r2, [r3, #0]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34005b1a:	683b      	ldr	r3, [r7, #0]
34005b1c:	0a18      	lsrs	r0, r3, #8
34005b1e:	4a31      	ldr	r2, [pc, #196]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005b20:	68fb      	ldr	r3, [r7, #12]
34005b22:	015b      	lsls	r3, r3, #5
34005b24:	4413      	add	r3, r2
34005b26:	3308      	adds	r3, #8
34005b28:	681b      	ldr	r3, [r3, #0]
34005b2a:	4a2f      	ldr	r2, [pc, #188]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005b2c:	2134      	movs	r1, #52	@ 0x34
34005b2e:	fb01 f303 	mul.w	r3, r1, r3
34005b32:	4413      	add	r3, r2
34005b34:	335c      	adds	r3, #92	@ 0x5c
34005b36:	6819      	ldr	r1, [r3, #0]
34005b38:	4a2a      	ldr	r2, [pc, #168]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005b3a:	68fb      	ldr	r3, [r7, #12]
34005b3c:	015b      	lsls	r3, r3, #5
34005b3e:	4413      	add	r3, r2
34005b40:	681b      	ldr	r3, [r3, #0]
34005b42:	687a      	ldr	r2, [r7, #4]
34005b44:	fb03 f202 	mul.w	r2, r3, r2
34005b48:	68bb      	ldr	r3, [r7, #8]
34005b4a:	441a      	add	r2, r3
34005b4c:	4613      	mov	r3, r2
34005b4e:	005b      	lsls	r3, r3, #1
34005b50:	4413      	add	r3, r2
34005b52:	440b      	add	r3, r1
34005b54:	3b02      	subs	r3, #2
34005b56:	b2c2      	uxtb	r2, r0
34005b58:	701a      	strb	r2, [r3, #0]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34005b5a:	683b      	ldr	r3, [r7, #0]
34005b5c:	0c18      	lsrs	r0, r3, #16
34005b5e:	4a21      	ldr	r2, [pc, #132]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005b60:	68fb      	ldr	r3, [r7, #12]
34005b62:	015b      	lsls	r3, r3, #5
34005b64:	4413      	add	r3, r2
34005b66:	3308      	adds	r3, #8
34005b68:	681b      	ldr	r3, [r3, #0]
34005b6a:	4a1f      	ldr	r2, [pc, #124]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005b6c:	2134      	movs	r1, #52	@ 0x34
34005b6e:	fb01 f303 	mul.w	r3, r1, r3
34005b72:	4413      	add	r3, r2
34005b74:	335c      	adds	r3, #92	@ 0x5c
34005b76:	6819      	ldr	r1, [r3, #0]
34005b78:	4a1a      	ldr	r2, [pc, #104]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005b7a:	68fb      	ldr	r3, [r7, #12]
34005b7c:	015b      	lsls	r3, r3, #5
34005b7e:	4413      	add	r3, r2
34005b80:	681b      	ldr	r3, [r3, #0]
34005b82:	687a      	ldr	r2, [r7, #4]
34005b84:	fb03 f202 	mul.w	r2, r3, r2
34005b88:	68bb      	ldr	r3, [r7, #8]
34005b8a:	441a      	add	r2, r3
34005b8c:	4613      	mov	r3, r2
34005b8e:	005b      	lsls	r3, r3, #1
34005b90:	4413      	add	r3, r2
34005b92:	440b      	add	r3, r1
34005b94:	3b01      	subs	r3, #1
34005b96:	b2c2      	uxtb	r2, r0
34005b98:	701a      	strb	r2, [r3, #0]
34005b9a:	e01b      	b.n	34005bd4 <BSP_LCD_WritePixel+0x17c>
  }
  else
  {
    /* Write data value to RAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
34005b9c:	4a11      	ldr	r2, [pc, #68]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005b9e:	68fb      	ldr	r3, [r7, #12]
34005ba0:	015b      	lsls	r3, r3, #5
34005ba2:	4413      	add	r3, r2
34005ba4:	3308      	adds	r3, #8
34005ba6:	681b      	ldr	r3, [r3, #0]
34005ba8:	4a0f      	ldr	r2, [pc, #60]	@ (34005be8 <BSP_LCD_WritePixel+0x190>)
34005baa:	2134      	movs	r1, #52	@ 0x34
34005bac:	fb01 f303 	mul.w	r3, r1, r3
34005bb0:	4413      	add	r3, r2
34005bb2:	335c      	adds	r3, #92	@ 0x5c
34005bb4:	681a      	ldr	r2, [r3, #0]
34005bb6:	490b      	ldr	r1, [pc, #44]	@ (34005be4 <BSP_LCD_WritePixel+0x18c>)
34005bb8:	68fb      	ldr	r3, [r7, #12]
34005bba:	015b      	lsls	r3, r3, #5
34005bbc:	440b      	add	r3, r1
34005bbe:	681b      	ldr	r3, [r3, #0]
34005bc0:	6879      	ldr	r1, [r7, #4]
34005bc2:	fb03 f101 	mul.w	r1, r3, r1
34005bc6:	68bb      	ldr	r3, [r7, #8]
34005bc8:	440b      	add	r3, r1
34005bca:	005b      	lsls	r3, r3, #1
34005bcc:	4413      	add	r3, r2
34005bce:	683a      	ldr	r2, [r7, #0]
34005bd0:	b292      	uxth	r2, r2
34005bd2:	801a      	strh	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
34005bd4:	2300      	movs	r3, #0
}
34005bd6:	4618      	mov	r0, r3
34005bd8:	3714      	adds	r7, #20
34005bda:	46bd      	mov	sp, r7
34005bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
34005be0:	4770      	bx	lr
34005be2:	bf00      	nop
34005be4:	34053ad8 	.word	0x34053ad8
34005be8:	34053a30 	.word	0x34053a30

34005bec <LL_FillBuffer>:
  * @param  ySize Buffer height
  * @param  OffLine Offset
  * @param  Color RGB color
  */
static void LL_FillBuffer(uint32_t Instance, uint32_t *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t Color)
{
34005bec:	b580      	push	{r7, lr}
34005bee:	b088      	sub	sp, #32
34005bf0:	af02      	add	r7, sp, #8
34005bf2:	60f8      	str	r0, [r7, #12]
34005bf4:	60b9      	str	r1, [r7, #8]
34005bf6:	607a      	str	r2, [r7, #4]
34005bf8:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;
  uint32_t input_color = Color;
34005bfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005bfc:	613b      	str	r3, [r7, #16]

  switch(Lcd_Ctx[Instance].PixelFormat)
34005bfe:	4a46      	ldr	r2, [pc, #280]	@ (34005d18 <LL_FillBuffer+0x12c>)
34005c00:	68fb      	ldr	r3, [r7, #12]
34005c02:	015b      	lsls	r3, r3, #5
34005c04:	4413      	add	r3, r2
34005c06:	330c      	adds	r3, #12
34005c08:	681b      	ldr	r3, [r3, #0]
34005c0a:	2b04      	cmp	r3, #4
34005c0c:	d02f      	beq.n	34005c6e <LL_FillBuffer+0x82>
34005c0e:	2b04      	cmp	r3, #4
34005c10:	d859      	bhi.n	34005cc6 <LL_FillBuffer+0xda>
34005c12:	2b01      	cmp	r3, #1
34005c14:	d050      	beq.n	34005cb8 <LL_FillBuffer+0xcc>
34005c16:	2b02      	cmp	r3, #2
34005c18:	d155      	bne.n	34005cc6 <LL_FillBuffer+0xda>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
34005c1a:	2302      	movs	r3, #2
34005c1c:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB5652ARGB8888(Color);
34005c1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005c20:	0adb      	lsrs	r3, r3, #11
34005c22:	f003 021f 	and.w	r2, r3, #31
34005c26:	4613      	mov	r3, r2
34005c28:	011b      	lsls	r3, r3, #4
34005c2a:	4413      	add	r3, r2
34005c2c:	015a      	lsls	r2, r3, #5
34005c2e:	1ad3      	subs	r3, r2, r3
34005c30:	3317      	adds	r3, #23
34005c32:	099b      	lsrs	r3, r3, #6
34005c34:	0419      	lsls	r1, r3, #16
34005c36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005c38:	095b      	lsrs	r3, r3, #5
34005c3a:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
34005c3e:	4613      	mov	r3, r2
34005c40:	01db      	lsls	r3, r3, #7
34005c42:	4413      	add	r3, r2
34005c44:	005b      	lsls	r3, r3, #1
34005c46:	4413      	add	r3, r2
34005c48:	3321      	adds	r3, #33	@ 0x21
34005c4a:	099b      	lsrs	r3, r3, #6
34005c4c:	021b      	lsls	r3, r3, #8
34005c4e:	4319      	orrs	r1, r3
34005c50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005c52:	f003 021f 	and.w	r2, r3, #31
34005c56:	4613      	mov	r3, r2
34005c58:	011b      	lsls	r3, r3, #4
34005c5a:	4413      	add	r3, r2
34005c5c:	015a      	lsls	r2, r3, #5
34005c5e:	1ad3      	subs	r3, r2, r3
34005c60:	3317      	adds	r3, #23
34005c62:	099b      	lsrs	r3, r3, #6
34005c64:	430b      	orrs	r3, r1
34005c66:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34005c6a:	613b      	str	r3, [r7, #16]
    break;
34005c6c:	e02e      	b.n	34005ccc <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
34005c6e:	2304      	movs	r3, #4
34005c70:	617b      	str	r3, [r7, #20]
    input_color = CONVERTARGB44442ARGB8888(Color);
34005c72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005c74:	0b1b      	lsrs	r3, r3, #12
34005c76:	f003 020f 	and.w	r2, r3, #15
34005c7a:	4613      	mov	r3, r2
34005c7c:	011b      	lsls	r3, r3, #4
34005c7e:	4413      	add	r3, r2
34005c80:	0619      	lsls	r1, r3, #24
34005c82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005c84:	0a1b      	lsrs	r3, r3, #8
34005c86:	f003 020f 	and.w	r2, r3, #15
34005c8a:	4613      	mov	r3, r2
34005c8c:	011b      	lsls	r3, r3, #4
34005c8e:	4413      	add	r3, r2
34005c90:	041b      	lsls	r3, r3, #16
34005c92:	4319      	orrs	r1, r3
34005c94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005c96:	091b      	lsrs	r3, r3, #4
34005c98:	f003 020f 	and.w	r2, r3, #15
34005c9c:	4613      	mov	r3, r2
34005c9e:	011b      	lsls	r3, r3, #4
34005ca0:	4413      	add	r3, r2
34005ca2:	021b      	lsls	r3, r3, #8
34005ca4:	4319      	orrs	r1, r3
34005ca6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005ca8:	f003 020f 	and.w	r2, r3, #15
34005cac:	4613      	mov	r3, r2
34005cae:	011b      	lsls	r3, r3, #4
34005cb0:	4413      	add	r3, r2
34005cb2:	430b      	orrs	r3, r1
34005cb4:	613b      	str	r3, [r7, #16]
    break;
34005cb6:	e009      	b.n	34005ccc <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
34005cb8:	2301      	movs	r3, #1
34005cba:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB8882ARGB8888(Color);
34005cbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005cbe:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34005cc2:	613b      	str	r3, [r7, #16]
    break;
34005cc4:	e002      	b.n	34005ccc <LL_FillBuffer+0xe0>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
34005cc6:	2300      	movs	r3, #0
34005cc8:	617b      	str	r3, [r7, #20]
    break;
34005cca:	bf00      	nop
  }

  /* Register to memory mode with ARGB8888 as color Mode */
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
34005ccc:	4b13      	ldr	r3, [pc, #76]	@ (34005d1c <LL_FillBuffer+0x130>)
34005cce:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34005cd2:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34005cd4:	4a11      	ldr	r2, [pc, #68]	@ (34005d1c <LL_FillBuffer+0x130>)
34005cd6:	697b      	ldr	r3, [r7, #20]
34005cd8:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = OffLine;
34005cda:	4a10      	ldr	r2, [pc, #64]	@ (34005d1c <LL_FillBuffer+0x130>)
34005cdc:	6a3b      	ldr	r3, [r7, #32]
34005cde:	60d3      	str	r3, [r2, #12]

  hlcd_dma2d.Instance = DMA2D;
34005ce0:	4b0e      	ldr	r3, [pc, #56]	@ (34005d1c <LL_FillBuffer+0x130>)
34005ce2:	4a0f      	ldr	r2, [pc, #60]	@ (34005d20 <LL_FillBuffer+0x134>)
34005ce4:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34005ce6:	480d      	ldr	r0, [pc, #52]	@ (34005d1c <LL_FillBuffer+0x130>)
34005ce8:	f002 fec8 	bl	34008a7c <HAL_DMA2D_Init>
34005cec:	4603      	mov	r3, r0
34005cee:	2b00      	cmp	r3, #0
34005cf0:	d10e      	bne.n	34005d10 <LL_FillBuffer+0x124>
  {
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
34005cf2:	68ba      	ldr	r2, [r7, #8]
34005cf4:	683b      	ldr	r3, [r7, #0]
34005cf6:	9300      	str	r3, [sp, #0]
34005cf8:	687b      	ldr	r3, [r7, #4]
34005cfa:	6939      	ldr	r1, [r7, #16]
34005cfc:	4807      	ldr	r0, [pc, #28]	@ (34005d1c <LL_FillBuffer+0x130>)
34005cfe:	f002 ffaf 	bl	34008c60 <HAL_DMA2D_Start>
34005d02:	4603      	mov	r3, r0
34005d04:	2b00      	cmp	r3, #0
34005d06:	d103      	bne.n	34005d10 <LL_FillBuffer+0x124>
    {
      /* Polling For DMA transfer */
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34005d08:	2132      	movs	r1, #50	@ 0x32
34005d0a:	4804      	ldr	r0, [pc, #16]	@ (34005d1c <LL_FillBuffer+0x130>)
34005d0c:	f002 ffe8 	bl	34008ce0 <HAL_DMA2D_PollForTransfer>
    }
  }
}
34005d10:	bf00      	nop
34005d12:	3718      	adds	r7, #24
34005d14:	46bd      	mov	sp, r7
34005d16:	bd80      	pop	{r7, pc}
34005d18:	34053ad8 	.word	0x34053ad8
34005d1c:	340539c8 	.word	0x340539c8
34005d20:	58021000 	.word	0x58021000

34005d24 <LL_ConvertLineToRGB>:
  * @param  pDst Output color
  * @param  xSize Buffer width
  * @param  ColorMode Input color mode
  */
static void LL_ConvertLineToRGB(uint32_t Instance, uint32_t *pSrc, uint32_t *pDst, uint32_t xSize, uint32_t ColorMode)
{
34005d24:	b580      	push	{r7, lr}
34005d26:	b088      	sub	sp, #32
34005d28:	af02      	add	r7, sp, #8
34005d2a:	60f8      	str	r0, [r7, #12]
34005d2c:	60b9      	str	r1, [r7, #8]
34005d2e:	607a      	str	r2, [r7, #4]
34005d30:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;

  switch(Lcd_Ctx[Instance].PixelFormat)
34005d32:	4a29      	ldr	r2, [pc, #164]	@ (34005dd8 <LL_ConvertLineToRGB+0xb4>)
34005d34:	68fb      	ldr	r3, [r7, #12]
34005d36:	015b      	lsls	r3, r3, #5
34005d38:	4413      	add	r3, r2
34005d3a:	330c      	adds	r3, #12
34005d3c:	681b      	ldr	r3, [r3, #0]
34005d3e:	2b04      	cmp	r3, #4
34005d40:	d008      	beq.n	34005d54 <LL_ConvertLineToRGB+0x30>
34005d42:	2b04      	cmp	r3, #4
34005d44:	d80c      	bhi.n	34005d60 <LL_ConvertLineToRGB+0x3c>
34005d46:	2b01      	cmp	r3, #1
34005d48:	d007      	beq.n	34005d5a <LL_ConvertLineToRGB+0x36>
34005d4a:	2b02      	cmp	r3, #2
34005d4c:	d108      	bne.n	34005d60 <LL_ConvertLineToRGB+0x3c>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
34005d4e:	2302      	movs	r3, #2
34005d50:	617b      	str	r3, [r7, #20]
    break;
34005d52:	e008      	b.n	34005d66 <LL_ConvertLineToRGB+0x42>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
34005d54:	2304      	movs	r3, #4
34005d56:	617b      	str	r3, [r7, #20]
    break;
34005d58:	e005      	b.n	34005d66 <LL_ConvertLineToRGB+0x42>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
34005d5a:	2301      	movs	r3, #1
34005d5c:	617b      	str	r3, [r7, #20]
    break;
34005d5e:	e002      	b.n	34005d66 <LL_ConvertLineToRGB+0x42>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
34005d60:	2300      	movs	r3, #0
34005d62:	617b      	str	r3, [r7, #20]
    break;
34005d64:	bf00      	nop
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
34005d66:	4b1d      	ldr	r3, [pc, #116]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d68:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34005d6c:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34005d6e:	4a1b      	ldr	r2, [pc, #108]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d70:	697b      	ldr	r3, [r7, #20]
34005d72:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = 0;
34005d74:	4b19      	ldr	r3, [pc, #100]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d76:	2200      	movs	r2, #0
34005d78:	60da      	str	r2, [r3, #12]

  /* Foreground Configuration */
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34005d7a:	4b18      	ldr	r3, [pc, #96]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d7c:	2200      	movs	r2, #0
34005d7e:	64da      	str	r2, [r3, #76]	@ 0x4c
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
34005d80:	4b16      	ldr	r3, [pc, #88]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d82:	22ff      	movs	r2, #255	@ 0xff
34005d84:	651a      	str	r2, [r3, #80]	@ 0x50
  hlcd_dma2d.LayerCfg[1].InputColorMode = ColorMode;
34005d86:	4a15      	ldr	r2, [pc, #84]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d88:	6a3b      	ldr	r3, [r7, #32]
34005d8a:	6493      	str	r3, [r2, #72]	@ 0x48
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
34005d8c:	4b13      	ldr	r3, [pc, #76]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d8e:	2200      	movs	r2, #0
34005d90:	645a      	str	r2, [r3, #68]	@ 0x44

  hlcd_dma2d.Instance = DMA2D;
34005d92:	4b12      	ldr	r3, [pc, #72]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d94:	4a12      	ldr	r2, [pc, #72]	@ (34005de0 <LL_ConvertLineToRGB+0xbc>)
34005d96:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34005d98:	4810      	ldr	r0, [pc, #64]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005d9a:	f002 fe6f 	bl	34008a7c <HAL_DMA2D_Init>
34005d9e:	4603      	mov	r3, r0
34005da0:	2b00      	cmp	r3, #0
34005da2:	d115      	bne.n	34005dd0 <LL_ConvertLineToRGB+0xac>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
34005da4:	2101      	movs	r1, #1
34005da6:	480d      	ldr	r0, [pc, #52]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005da8:	f003 f884 	bl	34008eb4 <HAL_DMA2D_ConfigLayer>
34005dac:	4603      	mov	r3, r0
34005dae:	2b00      	cmp	r3, #0
34005db0:	d10e      	bne.n	34005dd0 <LL_ConvertLineToRGB+0xac>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
34005db2:	68b9      	ldr	r1, [r7, #8]
34005db4:	687a      	ldr	r2, [r7, #4]
34005db6:	2301      	movs	r3, #1
34005db8:	9300      	str	r3, [sp, #0]
34005dba:	683b      	ldr	r3, [r7, #0]
34005dbc:	4807      	ldr	r0, [pc, #28]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005dbe:	f002 ff4f 	bl	34008c60 <HAL_DMA2D_Start>
34005dc2:	4603      	mov	r3, r0
34005dc4:	2b00      	cmp	r3, #0
34005dc6:	d103      	bne.n	34005dd0 <LL_ConvertLineToRGB+0xac>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34005dc8:	2132      	movs	r1, #50	@ 0x32
34005dca:	4804      	ldr	r0, [pc, #16]	@ (34005ddc <LL_ConvertLineToRGB+0xb8>)
34005dcc:	f002 ff88 	bl	34008ce0 <HAL_DMA2D_PollForTransfer>
      }
    }
  }
}
34005dd0:	bf00      	nop
34005dd2:	3718      	adds	r7, #24
34005dd4:	46bd      	mov	sp, r7
34005dd6:	bd80      	pop	{r7, pc}
34005dd8:	34053ad8 	.word	0x34053ad8
34005ddc:	340539c8 	.word	0x340539c8
34005de0:	58021000 	.word	0x58021000

34005de4 <LTDC_MspInit>:
  * @brief  Initialize the BSP LTDC Msp.
  * @param  hltdc  LTDC handle
  * @retval None
  */
static void LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
34005de4:	b580      	push	{r7, lr}
34005de6:	b088      	sub	sp, #32
34005de8:	af00      	add	r7, sp, #0
34005dea:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure = {0};
34005dec:	f107 030c 	add.w	r3, r7, #12
34005df0:	2200      	movs	r2, #0
34005df2:	601a      	str	r2, [r3, #0]
34005df4:	605a      	str	r2, [r3, #4]
34005df6:	609a      	str	r2, [r3, #8]
34005df8:	60da      	str	r2, [r3, #12]
34005dfa:	611a      	str	r2, [r3, #16]

  if (hltdc->Instance == LTDC)
34005dfc:	687b      	ldr	r3, [r7, #4]
34005dfe:	681b      	ldr	r3, [r3, #0]
34005e00:	4a4e      	ldr	r2, [pc, #312]	@ (34005f3c <LTDC_MspInit+0x158>)
34005e02:	4293      	cmp	r3, r2
34005e04:	f040 8095 	bne.w	34005f32 <LTDC_MspInit+0x14e>
  {
    __HAL_RCC_LTDC_CLK_ENABLE();
34005e08:	2002      	movs	r0, #2
34005e0a:	f7ff f8c5 	bl	34004f98 <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_LTDC_FORCE_RESET();
34005e0e:	2002      	movs	r0, #2
34005e10:	f7ff f8d8 	bl	34004fc4 <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_LTDC_RELEASE_RESET();
34005e14:	2002      	movs	r0, #2
34005e16:	f7ff f8e5 	bl	34004fe4 <LL_APB5_GRP1_ReleaseReset>
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
34005e1a:	2001      	movs	r0, #1
34005e1c:	f7ff f86c 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
34005e20:	2002      	movs	r0, #2
34005e22:	f7ff f869 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
34005e26:	2008      	movs	r0, #8
34005e28:	f7ff f866 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
34005e2c:	2010      	movs	r0, #16
34005e2e:	f7ff f863 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
34005e32:	2040      	movs	r0, #64	@ 0x40
34005e34:	f7ff f860 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34005e38:	2080      	movs	r0, #128	@ 0x80
34005e3a:	f7ff f85d 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
34005e3e:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34005e42:	f7ff f859 	bl	34004ef8 <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
34005e46:	2302      	movs	r3, #2
34005e48:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Pull      = GPIO_NOPULL;
34005e4a:	2300      	movs	r3, #0
34005e4c:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34005e4e:	2302      	movs	r3, #2
34005e50:	61bb      	str	r3, [r7, #24]

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34005e52:	f248 1387 	movw	r3, #33159	@ 0x8187
34005e56:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34005e58:	230e      	movs	r3, #14
34005e5a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
34005e5c:	f107 030c 	add.w	r3, r7, #12
34005e60:	4619      	mov	r1, r3
34005e62:	4837      	ldr	r0, [pc, #220]	@ (34005f40 <LTDC_MspInit+0x15c>)
34005e64:	f003 fab4 	bl	340093d0 <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34005e68:	f64f 0314 	movw	r3, #63508	@ 0xf814
34005e6c:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34005e6e:	230e      	movs	r3, #14
34005e70:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34005e72:	f107 030c 	add.w	r3, r7, #12
34005e76:	4619      	mov	r1, r3
34005e78:	4832      	ldr	r0, [pc, #200]	@ (34005f44 <LTDC_MspInit+0x160>)
34005e7a:	f003 faa9 	bl	340093d0 <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34005e7e:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
34005e82:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34005e84:	230e      	movs	r3, #14
34005e86:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34005e88:	f107 030c 	add.w	r3, r7, #12
34005e8c:	4619      	mov	r1, r3
34005e8e:	482e      	ldr	r0, [pc, #184]	@ (34005f48 <LTDC_MspInit+0x164>)
34005e90:	f003 fa9e 	bl	340093d0 <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
34005e94:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34005e98:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34005e9a:	230e      	movs	r3, #14
34005e9c:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34005e9e:	f107 030c 	add.w	r3, r7, #12
34005ea2:	4619      	mov	r1, r3
34005ea4:	4829      	ldr	r0, [pc, #164]	@ (34005f4c <LTDC_MspInit+0x168>)
34005ea6:	f003 fa93 	bl	340093d0 <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34005eaa:	f641 1343 	movw	r3, #6467	@ 0x1943
34005eae:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34005eb0:	230e      	movs	r3, #14
34005eb2:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34005eb4:	f107 030c 	add.w	r3, r7, #12
34005eb8:	4619      	mov	r1, r3
34005eba:	4825      	ldr	r0, [pc, #148]	@ (34005f50 <LTDC_MspInit+0x16c>)
34005ebc:	f003 fa88 	bl	340093d0 <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34005ec0:	2358      	movs	r3, #88	@ 0x58
34005ec2:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34005ec4:	230e      	movs	r3, #14
34005ec6:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34005ec8:	f107 030c 	add.w	r3, r7, #12
34005ecc:	4619      	mov	r1, r3
34005ece:	4821      	ldr	r0, [pc, #132]	@ (34005f54 <LTDC_MspInit+0x170>)
34005ed0:	f003 fa7e 	bl	340093d0 <HAL_GPIO_Init>

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
34005ed4:	2302      	movs	r3, #2
34005ed6:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34005ed8:	2301      	movs	r3, #1
34005eda:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34005edc:	f107 030c 	add.w	r3, r7, #12
34005ee0:	4619      	mov	r1, r3
34005ee2:	481a      	ldr	r0, [pc, #104]	@ (34005f4c <LTDC_MspInit+0x168>)
34005ee4:	f003 fa74 	bl	340093d0 <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
34005ee8:	2348      	movs	r3, #72	@ 0x48
34005eea:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34005eec:	2301      	movs	r3, #1
34005eee:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34005ef0:	f107 030c 	add.w	r3, r7, #12
34005ef4:	4619      	mov	r1, r3
34005ef6:	4818      	ldr	r0, [pc, #96]	@ (34005f58 <LTDC_MspInit+0x174>)
34005ef8:	f003 fa6a 	bl	340093d0 <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
34005efc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34005f00:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34005f02:	2301      	movs	r3, #1
34005f04:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34005f06:	f107 030c 	add.w	r3, r7, #12
34005f0a:	4619      	mov	r1, r3
34005f0c:	4810      	ldr	r0, [pc, #64]	@ (34005f50 <LTDC_MspInit+0x16c>)
34005f0e:	f003 fa5f 	bl	340093d0 <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
34005f12:	2201      	movs	r2, #1
34005f14:	2108      	movs	r1, #8
34005f16:	4810      	ldr	r0, [pc, #64]	@ (34005f58 <LTDC_MspInit+0x174>)
34005f18:	f003 fdba 	bl	34009a90 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
34005f1c:	2201      	movs	r2, #1
34005f1e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34005f22:	480b      	ldr	r0, [pc, #44]	@ (34005f50 <LTDC_MspInit+0x16c>)
34005f24:	f003 fdb4 	bl	34009a90 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
34005f28:	2201      	movs	r2, #1
34005f2a:	2140      	movs	r1, #64	@ 0x40
34005f2c:	480a      	ldr	r0, [pc, #40]	@ (34005f58 <LTDC_MspInit+0x174>)
34005f2e:	f003 fdaf 	bl	34009a90 <HAL_GPIO_WritePin>

  }
}
34005f32:	bf00      	nop
34005f34:	3720      	adds	r7, #32
34005f36:	46bd      	mov	sp, r7
34005f38:	bd80      	pop	{r7, pc}
34005f3a:	bf00      	nop
34005f3c:	58001000 	.word	0x58001000
34005f40:	56020000 	.word	0x56020000
34005f44:	56020400 	.word	0x56020400
34005f48:	56020c00 	.word	0x56020c00
34005f4c:	56021000 	.word	0x56021000
34005f50:	56021800 	.word	0x56021800
34005f54:	56021c00 	.word	0x56021c00
34005f58:	56024000 	.word	0x56024000

34005f5c <DMA2D_MspInit>:
  * @brief  Initialize the BSP DMA2D Msp.
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
34005f5c:	b580      	push	{r7, lr}
34005f5e:	b082      	sub	sp, #8
34005f60:	af00      	add	r7, sp, #0
34005f62:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance == DMA2D)
34005f64:	687b      	ldr	r3, [r7, #4]
34005f66:	681b      	ldr	r3, [r3, #0]
34005f68:	4a07      	ldr	r2, [pc, #28]	@ (34005f88 <DMA2D_MspInit+0x2c>)
34005f6a:	4293      	cmp	r3, r2
34005f6c:	d108      	bne.n	34005f80 <DMA2D_MspInit+0x24>
  {
    /** Enable the DMA2D clock */
    __HAL_RCC_DMA2D_CLK_ENABLE();
34005f6e:	2002      	movs	r0, #2
34005f70:	f7fe ffd8 	bl	34004f24 <LL_AHB5_GRP1_EnableClock>

    /** Toggle Sw reset of DMA2D IP */
    __HAL_RCC_DMA2D_FORCE_RESET();
34005f74:	2002      	movs	r0, #2
34005f76:	f7fe ffeb 	bl	34004f50 <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_DMA2D_RELEASE_RESET();
34005f7a:	2002      	movs	r0, #2
34005f7c:	f7fe fff8 	bl	34004f70 <LL_AHB5_GRP1_ReleaseReset>
  }
}
34005f80:	bf00      	nop
34005f82:	3708      	adds	r7, #8
34005f84:	46bd      	mov	sp, r7
34005f86:	bd80      	pop	{r7, pc}
34005f88:	58021000 	.word	0x58021000

34005f8c <LL_AHB4_GRP1_EnableClock>:
{
34005f8c:	b480      	push	{r7}
34005f8e:	b085      	sub	sp, #20
34005f90:	af00      	add	r7, sp, #0
34005f92:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34005f94:	4a07      	ldr	r2, [pc, #28]	@ (34005fb4 <LL_AHB4_GRP1_EnableClock+0x28>)
34005f96:	687b      	ldr	r3, [r7, #4]
34005f98:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34005f9c:	4b05      	ldr	r3, [pc, #20]	@ (34005fb4 <LL_AHB4_GRP1_EnableClock+0x28>)
34005f9e:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34005fa2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34005fa4:	68fb      	ldr	r3, [r7, #12]
}
34005fa6:	bf00      	nop
34005fa8:	3714      	adds	r7, #20
34005faa:	46bd      	mov	sp, r7
34005fac:	f85d 7b04 	ldr.w	r7, [sp], #4
34005fb0:	4770      	bx	lr
34005fb2:	bf00      	nop
34005fb4:	56028000 	.word	0x56028000

34005fb8 <LL_AHB5_GRP1_EnableClock>:
{
34005fb8:	b480      	push	{r7}
34005fba:	b085      	sub	sp, #20
34005fbc:	af00      	add	r7, sp, #0
34005fbe:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34005fc0:	4a07      	ldr	r2, [pc, #28]	@ (34005fe0 <LL_AHB5_GRP1_EnableClock+0x28>)
34005fc2:	687b      	ldr	r3, [r7, #4]
34005fc4:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34005fc8:	4b05      	ldr	r3, [pc, #20]	@ (34005fe0 <LL_AHB5_GRP1_EnableClock+0x28>)
34005fca:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34005fce:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34005fd0:	68fb      	ldr	r3, [r7, #12]
}
34005fd2:	bf00      	nop
34005fd4:	3714      	adds	r7, #20
34005fd6:	46bd      	mov	sp, r7
34005fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
34005fdc:	4770      	bx	lr
34005fde:	bf00      	nop
34005fe0:	56028000 	.word	0x56028000

34005fe4 <LL_AHB5_GRP1_ForceReset>:
{
34005fe4:	b480      	push	{r7}
34005fe6:	b083      	sub	sp, #12
34005fe8:	af00      	add	r7, sp, #0
34005fea:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34005fec:	4a04      	ldr	r2, [pc, #16]	@ (34006000 <LL_AHB5_GRP1_ForceReset+0x1c>)
34005fee:	687b      	ldr	r3, [r7, #4]
34005ff0:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34005ff4:	bf00      	nop
34005ff6:	370c      	adds	r7, #12
34005ff8:	46bd      	mov	sp, r7
34005ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
34005ffe:	4770      	bx	lr
34006000:	56028000 	.word	0x56028000

34006004 <LL_AHB5_GRP1_ReleaseReset>:
{
34006004:	b480      	push	{r7}
34006006:	b083      	sub	sp, #12
34006008:	af00      	add	r7, sp, #0
3400600a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400600c:	4b06      	ldr	r3, [pc, #24]	@ (34006028 <LL_AHB5_GRP1_ReleaseReset+0x24>)
3400600e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34006012:	461a      	mov	r2, r3
34006014:	687b      	ldr	r3, [r7, #4]
34006016:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
3400601a:	bf00      	nop
3400601c:	370c      	adds	r7, #12
3400601e:	46bd      	mov	sp, r7
34006020:	f85d 7b04 	ldr.w	r7, [sp], #4
34006024:	4770      	bx	lr
34006026:	bf00      	nop
34006028:	56028000 	.word	0x56028000

3400602c <BSP_XSPI_NOR_Init>:
  * @param  Instance   XSPI Instance
  * @param  Init       XSPI Init structure
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_Init(uint32_t Instance, BSP_XSPI_NOR_Init_t *Init)
{
3400602c:	b590      	push	{r4, r7, lr}
3400602e:	b095      	sub	sp, #84	@ 0x54
34006030:	af00      	add	r7, sp, #0
34006032:	6078      	str	r0, [r7, #4]
34006034:	6039      	str	r1, [r7, #0]
  int32_t ret;
  BSP_XSPI_NOR_Info_t pInfo;
  MX_XSPI_InitTypeDef xspi_init;

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34006036:	687b      	ldr	r3, [r7, #4]
34006038:	2b00      	cmp	r3, #0
3400603a:	d003      	beq.n	34006044 <BSP_XSPI_NOR_Init+0x18>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400603c:	f06f 0301 	mvn.w	r3, #1
34006040:	64fb      	str	r3, [r7, #76]	@ 0x4c
34006042:	e080      	b.n	34006146 <BSP_XSPI_NOR_Init+0x11a>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
34006044:	4947      	ldr	r1, [pc, #284]	@ (34006164 <BSP_XSPI_NOR_Init+0x138>)
34006046:	687a      	ldr	r2, [r7, #4]
34006048:	4613      	mov	r3, r2
3400604a:	005b      	lsls	r3, r3, #1
3400604c:	4413      	add	r3, r2
3400604e:	440b      	add	r3, r1
34006050:	781b      	ldrb	r3, [r3, #0]
34006052:	2b00      	cmp	r3, #0
34006054:	d175      	bne.n	34006142 <BSP_XSPI_NOR_Init+0x116>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_NOR_MspInit(&hxspi_nor[Instance]);
34006056:	687b      	ldr	r3, [r7, #4]
34006058:	2264      	movs	r2, #100	@ 0x64
3400605a:	fb02 f303 	mul.w	r3, r2, r3
3400605e:	4a42      	ldr	r2, [pc, #264]	@ (34006168 <BSP_XSPI_NOR_Init+0x13c>)
34006060:	4413      	add	r3, r2
34006062:	4618      	mov	r0, r3
34006064:	f000 faba 	bl	340065dc <XSPI_NOR_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Get Flash information of one memory */
      (void)MX66UW1G45G_GetFlashInfo(&pInfo);
34006068:	f107 031c 	add.w	r3, r7, #28
3400606c:	4618      	mov	r0, r3
3400606e:	f7fe f8f2 	bl	34004256 <MX66UW1G45G_GetFlashInfo>

      /* Fill config structure */
      xspi_init.ClockPrescaler = 0x03; /* XSPI clock = 200MHz / ClockPrescaler = 50MHz, then switch to 200MHz*/
34006072:	2303      	movs	r3, #3
34006074:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
34006076:	69fb      	ldr	r3, [r7, #28]
34006078:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
3400607a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400607c:	fa93 f3a3 	rbit	r3, r3
34006080:	643b      	str	r3, [r7, #64]	@ 0x40
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
34006082:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34006084:	64bb      	str	r3, [r7, #72]	@ 0x48
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
34006086:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34006088:	2b00      	cmp	r3, #0
3400608a:	d101      	bne.n	34006090 <BSP_XSPI_NOR_Init+0x64>
  {
    return 32U;
3400608c:	2320      	movs	r3, #32
3400608e:	e003      	b.n	34006098 <BSP_XSPI_NOR_Init+0x6c>
  }
  return __builtin_clz(value);
34006090:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34006092:	fab3 f383 	clz	r3, r3
34006096:	b2db      	uxtb	r3, r3
34006098:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3400609a:	2300      	movs	r3, #0
3400609c:	617b      	str	r3, [r7, #20]
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
3400609e:	683b      	ldr	r3, [r7, #0]
340060a0:	785b      	ldrb	r3, [r3, #1]
340060a2:	61bb      	str	r3, [r7, #24]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
340060a4:	687b      	ldr	r3, [r7, #4]
340060a6:	2264      	movs	r2, #100	@ 0x64
340060a8:	fb02 f303 	mul.w	r3, r2, r3
340060ac:	4a2e      	ldr	r2, [pc, #184]	@ (34006168 <BSP_XSPI_NOR_Init+0x13c>)
340060ae:	4413      	add	r3, r2
340060b0:	f107 020c 	add.w	r2, r7, #12
340060b4:	4611      	mov	r1, r2
340060b6:	4618      	mov	r0, r3
340060b8:	f000 f858 	bl	3400616c <MX_XSPI_NOR_Init>
340060bc:	4603      	mov	r3, r0
340060be:	2b00      	cmp	r3, #0
340060c0:	d003      	beq.n	340060ca <BSP_XSPI_NOR_Init+0x9e>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
340060c2:	f06f 0303 	mvn.w	r3, #3
340060c6:	64fb      	str	r3, [r7, #76]	@ 0x4c
340060c8:	e03d      	b.n	34006146 <BSP_XSPI_NOR_Init+0x11a>
      }
      /* XSPI memory reset */
      else if (XSPI_NOR_ResetMemory(Instance) != BSP_ERROR_NONE)
340060ca:	6878      	ldr	r0, [r7, #4]
340060cc:	f000 fb4c 	bl	34006768 <XSPI_NOR_ResetMemory>
340060d0:	4603      	mov	r3, r0
340060d2:	2b00      	cmp	r3, #0
340060d4:	d003      	beq.n	340060de <BSP_XSPI_NOR_Init+0xb2>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
340060d6:	f06f 0304 	mvn.w	r3, #4
340060da:	64fb      	str	r3, [r7, #76]	@ 0x4c
340060dc:	e033      	b.n	34006146 <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Check if memory is ready */
      else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340060de:	687b      	ldr	r3, [r7, #4]
340060e0:	2264      	movs	r2, #100	@ 0x64
340060e2:	fb02 f303 	mul.w	r3, r2, r3
340060e6:	4a20      	ldr	r2, [pc, #128]	@ (34006168 <BSP_XSPI_NOR_Init+0x13c>)
340060e8:	1898      	adds	r0, r3, r2
340060ea:	491e      	ldr	r1, [pc, #120]	@ (34006164 <BSP_XSPI_NOR_Init+0x138>)
340060ec:	687a      	ldr	r2, [r7, #4]
340060ee:	4613      	mov	r3, r2
340060f0:	005b      	lsls	r3, r3, #1
340060f2:	4413      	add	r3, r2
340060f4:	440b      	add	r3, r1
340060f6:	3301      	adds	r3, #1
340060f8:	7819      	ldrb	r1, [r3, #0]
340060fa:	4c1a      	ldr	r4, [pc, #104]	@ (34006164 <BSP_XSPI_NOR_Init+0x138>)
340060fc:	687a      	ldr	r2, [r7, #4]
340060fe:	4613      	mov	r3, r2
34006100:	005b      	lsls	r3, r3, #1
34006102:	4413      	add	r3, r2
34006104:	4423      	add	r3, r4
34006106:	3302      	adds	r3, #2
34006108:	781b      	ldrb	r3, [r3, #0]
3400610a:	461a      	mov	r2, r3
3400610c:	f7fe f8d2 	bl	340042b4 <MX66UW1G45G_AutoPollingMemReady>
34006110:	4603      	mov	r3, r0
34006112:	2b00      	cmp	r3, #0
34006114:	d003      	beq.n	3400611e <BSP_XSPI_NOR_Init+0xf2>
                                                XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34006116:	f06f 0304 	mvn.w	r3, #4
3400611a:	64fb      	str	r3, [r7, #76]	@ 0x4c
3400611c:	e013      	b.n	34006146 <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Configure the memory */
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
3400611e:	683b      	ldr	r3, [r7, #0]
34006120:	7819      	ldrb	r1, [r3, #0]
34006122:	683b      	ldr	r3, [r7, #0]
34006124:	785b      	ldrb	r3, [r3, #1]
34006126:	461a      	mov	r2, r3
34006128:	6878      	ldr	r0, [r7, #4]
3400612a:	f000 f8d5 	bl	340062d8 <BSP_XSPI_NOR_ConfigFlash>
3400612e:	4603      	mov	r3, r0
34006130:	2b00      	cmp	r3, #0
34006132:	d003      	beq.n	3400613c <BSP_XSPI_NOR_Init+0x110>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34006134:	f06f 0304 	mvn.w	r3, #4
34006138:	64fb      	str	r3, [r7, #76]	@ 0x4c
3400613a:	e004      	b.n	34006146 <BSP_XSPI_NOR_Init+0x11a>
      }
      else
      {
        ret = BSP_ERROR_NONE;
3400613c:	2300      	movs	r3, #0
3400613e:	64fb      	str	r3, [r7, #76]	@ 0x4c
34006140:	e001      	b.n	34006146 <BSP_XSPI_NOR_Init+0x11a>
      }
    }
    else
    {
      ret = BSP_ERROR_NONE;
34006142:	2300      	movs	r3, #0
34006144:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

 (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
34006146:	687b      	ldr	r3, [r7, #4]
34006148:	2264      	movs	r2, #100	@ 0x64
3400614a:	fb02 f303 	mul.w	r3, r2, r3
3400614e:	4a06      	ldr	r2, [pc, #24]	@ (34006168 <BSP_XSPI_NOR_Init+0x13c>)
34006150:	4413      	add	r3, r2
34006152:	2100      	movs	r1, #0
34006154:	4618      	mov	r0, r3
34006156:	f015 fe77 	bl	3401be48 <HAL_XSPI_SetClockPrescaler>

  /* Return BSP status */
  return ret;
3400615a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
3400615c:	4618      	mov	r0, r3
3400615e:	3754      	adds	r7, #84	@ 0x54
34006160:	46bd      	mov	sp, r7
34006162:	bd90      	pop	{r4, r7, pc}
34006164:	34053b5c 	.word	0x34053b5c
34006168:	34053af8 	.word	0x34053af8

3400616c <MX_XSPI_NOR_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_NOR_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
3400616c:	b580      	push	{r7, lr}
3400616e:	b082      	sub	sp, #8
34006170:	af00      	add	r7, sp, #0
34006172:	6078      	str	r0, [r7, #4]
34006174:	6039      	str	r1, [r7, #0]
  /* XSPI initialization */
  hxspi->Instance = XSPI2;
34006176:	687b      	ldr	r3, [r7, #4]
34006178:	4a20      	ldr	r2, [pc, #128]	@ (340061fc <MX_XSPI_NOR_Init+0x90>)
3400617a:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte       = 1;
3400617c:	687b      	ldr	r3, [r7, #4]
3400617e:	2201      	movs	r2, #1
34006180:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
34006182:	683b      	ldr	r3, [r7, #0]
34006184:	681a      	ldr	r2, [r3, #0]
34006186:	687b      	ldr	r3, [r7, #4]
34006188:	611a      	str	r2, [r3, #16]
  hxspi->Init.ChipSelectHighTimeCycle = 2;
3400618a:	687b      	ldr	r3, [r7, #4]
3400618c:	2202      	movs	r2, #2
3400618e:	615a      	str	r2, [r3, #20]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34006190:	687b      	ldr	r3, [r7, #4]
34006192:	2200      	movs	r2, #0
34006194:	619a      	str	r2, [r3, #24]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
34006196:	687b      	ldr	r3, [r7, #4]
34006198:	2200      	movs	r2, #0
3400619a:	61da      	str	r2, [r3, #28]
  hxspi->Init.DelayHoldQuarterCycle   = HAL_XSPI_DHQC_DISABLE;
3400619c:	687b      	ldr	r3, [r7, #4]
3400619e:	2200      	movs	r2, #0
340061a0:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
340061a2:	683b      	ldr	r3, [r7, #0]
340061a4:	685a      	ldr	r2, [r3, #4]
340061a6:	687b      	ldr	r3, [r7, #4]
340061a8:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting          = Init->SampleShifting;
340061aa:	683b      	ldr	r3, [r7, #0]
340061ac:	689a      	ldr	r2, [r3, #8]
340061ae:	687b      	ldr	r3, [r7, #4]
340061b0:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary      = HAL_XSPI_BONDARYOF_NONE;
340061b2:	687b      	ldr	r3, [r7, #4]
340061b4:	2200      	movs	r2, #0
340061b6:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
340061b8:	687b      	ldr	r3, [r7, #4]
340061ba:	2200      	movs	r2, #0
340061bc:	609a      	str	r2, [r3, #8]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
340061be:	687b      	ldr	r3, [r7, #4]
340061c0:	2200      	movs	r2, #0
340061c2:	621a      	str	r2, [r3, #32]

  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
340061c4:	683b      	ldr	r3, [r7, #0]
340061c6:	68db      	ldr	r3, [r3, #12]
340061c8:	2b01      	cmp	r3, #1
340061ca:	d108      	bne.n	340061de <MX_XSPI_NOR_Init+0x72>
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
340061cc:	687b      	ldr	r3, [r7, #4]
340061ce:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340061d2:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
340061d4:	687b      	ldr	r3, [r7, #4]
340061d6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
340061da:	62da      	str	r2, [r3, #44]	@ 0x2c
340061dc:	e006      	b.n	340061ec <MX_XSPI_NOR_Init+0x80>
  }
  else
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
340061de:	687b      	ldr	r3, [r7, #4]
340061e0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340061e4:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
340061e6:	687b      	ldr	r3, [r7, #4]
340061e8:	2200      	movs	r2, #0
340061ea:	62da      	str	r2, [r3, #44]	@ 0x2c
  }
  return HAL_XSPI_Init(hxspi);
340061ec:	6878      	ldr	r0, [r7, #4]
340061ee:	f014 fe9f 	bl	3401af30 <HAL_XSPI_Init>
340061f2:	4603      	mov	r3, r0
}
340061f4:	4618      	mov	r0, r3
340061f6:	3708      	adds	r7, #8
340061f8:	46bd      	mov	sp, r7
340061fa:	bd80      	pop	{r7, pc}
340061fc:	5802a000 	.word	0x5802a000

34006200 <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_EnableMemoryMappedMode(uint32_t Instance)
{
34006200:	b580      	push	{r7, lr}
34006202:	b084      	sub	sp, #16
34006204:	af00      	add	r7, sp, #0
34006206:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34006208:	2300      	movs	r3, #0
3400620a:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
3400620c:	687b      	ldr	r3, [r7, #4]
3400620e:	2b00      	cmp	r3, #0
34006210:	d003      	beq.n	3400621a <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34006212:	f06f 0301 	mvn.w	r3, #1
34006216:	60fb      	str	r3, [r7, #12]
34006218:	e055      	b.n	340062c6 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
  }
  else
  {

    /* Bypass the Pre-scaler */
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
3400621a:	687b      	ldr	r3, [r7, #4]
3400621c:	2264      	movs	r2, #100	@ 0x64
3400621e:	fb02 f303 	mul.w	r3, r2, r3
34006222:	4a2b      	ldr	r2, [pc, #172]	@ (340062d0 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
34006224:	4413      	add	r3, r2
34006226:	2100      	movs	r1, #0
34006228:	4618      	mov	r0, r3
3400622a:	f015 fe0d 	bl	3401be48 <HAL_XSPI_SetClockPrescaler>

    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
3400622e:	4929      	ldr	r1, [pc, #164]	@ (340062d4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34006230:	687a      	ldr	r2, [r7, #4]
34006232:	4613      	mov	r3, r2
34006234:	005b      	lsls	r3, r3, #1
34006236:	4413      	add	r3, r2
34006238:	440b      	add	r3, r1
3400623a:	3302      	adds	r3, #2
3400623c:	781b      	ldrb	r3, [r3, #0]
3400623e:	2b00      	cmp	r3, #0
34006240:	d121      	bne.n	34006286 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x86>
    {
      if (MX66UW1G45G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006242:	687b      	ldr	r3, [r7, #4]
34006244:	2264      	movs	r2, #100	@ 0x64
34006246:	fb02 f303 	mul.w	r3, r2, r3
3400624a:	4a21      	ldr	r2, [pc, #132]	@ (340062d0 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
3400624c:	1898      	adds	r0, r3, r2
3400624e:	4921      	ldr	r1, [pc, #132]	@ (340062d4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34006250:	687a      	ldr	r2, [r7, #4]
34006252:	4613      	mov	r3, r2
34006254:	005b      	lsls	r3, r3, #1
34006256:	4413      	add	r3, r2
34006258:	440b      	add	r3, r1
3400625a:	3301      	adds	r3, #1
3400625c:	781b      	ldrb	r3, [r3, #0]
3400625e:	2201      	movs	r2, #1
34006260:	4619      	mov	r1, r3
34006262:	f7fe f8d5 	bl	34004410 <MX66UW1G45G_EnableSTRMemoryMappedMode>
34006266:	4603      	mov	r3, r0
34006268:	2b00      	cmp	r3, #0
3400626a:	d003      	beq.n	34006274 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x74>
                                                 MX66UW1G45G_4BYTES_SIZE) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
3400626c:	f06f 0304 	mvn.w	r3, #4
34006270:	60fb      	str	r3, [r7, #12]
34006272:	e028      	b.n	340062c6 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
      else /* Update XSPI context if all operations are well done */
      {
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
34006274:	4917      	ldr	r1, [pc, #92]	@ (340062d4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34006276:	687a      	ldr	r2, [r7, #4]
34006278:	4613      	mov	r3, r2
3400627a:	005b      	lsls	r3, r3, #1
3400627c:	4413      	add	r3, r2
3400627e:	440b      	add	r3, r1
34006280:	2202      	movs	r2, #2
34006282:	701a      	strb	r2, [r3, #0]
34006284:	e01f      	b.n	340062c6 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
    }
    else
    {
      if (MX66UW1G45G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
34006286:	687b      	ldr	r3, [r7, #4]
34006288:	2264      	movs	r2, #100	@ 0x64
3400628a:	fb02 f303 	mul.w	r3, r2, r3
3400628e:	4a10      	ldr	r2, [pc, #64]	@ (340062d0 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
34006290:	1898      	adds	r0, r3, r2
34006292:	4910      	ldr	r1, [pc, #64]	@ (340062d4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34006294:	687a      	ldr	r2, [r7, #4]
34006296:	4613      	mov	r3, r2
34006298:	005b      	lsls	r3, r3, #1
3400629a:	4413      	add	r3, r2
3400629c:	440b      	add	r3, r1
3400629e:	3301      	adds	r3, #1
340062a0:	781b      	ldrb	r3, [r3, #0]
340062a2:	4619      	mov	r1, r3
340062a4:	f7fe f95c 	bl	34004560 <MX66UW1G45G_EnableDTRMemoryMappedMode>
340062a8:	4603      	mov	r3, r0
340062aa:	2b00      	cmp	r3, #0
340062ac:	d003      	beq.n	340062b6 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb6>
                                                 XSPI_Nor_Ctx[Instance].InterfaceMode) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
340062ae:	f06f 0304 	mvn.w	r3, #4
340062b2:	60fb      	str	r3, [r7, #12]
340062b4:	e007      	b.n	340062c6 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
      else /* Update XSPI context if all operations are well done */
      {

       XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
340062b6:	4907      	ldr	r1, [pc, #28]	@ (340062d4 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
340062b8:	687a      	ldr	r2, [r7, #4]
340062ba:	4613      	mov	r3, r2
340062bc:	005b      	lsls	r3, r3, #1
340062be:	4413      	add	r3, r2
340062c0:	440b      	add	r3, r1
340062c2:	2202      	movs	r2, #2
340062c4:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
340062c6:	68fb      	ldr	r3, [r7, #12]
}
340062c8:	4618      	mov	r0, r3
340062ca:	3710      	adds	r7, #16
340062cc:	46bd      	mov	sp, r7
340062ce:	bd80      	pop	{r7, pc}
340062d0:	34053af8 	.word	0x34053af8
340062d4:	34053b5c 	.word	0x34053b5c

340062d8 <BSP_XSPI_NOR_ConfigFlash>:
  * @param  Mode      XSPI mode
  * @param  Rate      XSPI transfer rate
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_ConfigFlash(uint32_t Instance, BSP_XSPI_NOR_Interface_t Mode, BSP_XSPI_NOR_Transfer_t Rate)
{
340062d8:	b580      	push	{r7, lr}
340062da:	b084      	sub	sp, #16
340062dc:	af00      	add	r7, sp, #0
340062de:	6078      	str	r0, [r7, #4]
340062e0:	460b      	mov	r3, r1
340062e2:	70fb      	strb	r3, [r7, #3]
340062e4:	4613      	mov	r3, r2
340062e6:	70bb      	strb	r3, [r7, #2]
  int32_t ret = BSP_ERROR_NONE;
340062e8:	2300      	movs	r3, #0
340062ea:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
340062ec:	687b      	ldr	r3, [r7, #4]
340062ee:	2b00      	cmp	r3, #0
340062f0:	d003      	beq.n	340062fa <BSP_XSPI_NOR_ConfigFlash+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
340062f2:	f06f 0301 	mvn.w	r3, #1
340062f6:	60fb      	str	r3, [r7, #12]
340062f8:	e072      	b.n	340063e0 <BSP_XSPI_NOR_ConfigFlash+0x108>
  }
  else
  {
    /* Check if MMP mode locked ************************************************/
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
340062fa:	493c      	ldr	r1, [pc, #240]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
340062fc:	687a      	ldr	r2, [r7, #4]
340062fe:	4613      	mov	r3, r2
34006300:	005b      	lsls	r3, r3, #1
34006302:	4413      	add	r3, r2
34006304:	440b      	add	r3, r1
34006306:	781b      	ldrb	r3, [r3, #0]
34006308:	2b02      	cmp	r3, #2
3400630a:	d103      	bne.n	34006314 <BSP_XSPI_NOR_ConfigFlash+0x3c>
    {
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
3400630c:	f06f 0319 	mvn.w	r3, #25
34006310:	60fb      	str	r3, [r7, #12]
34006312:	e065      	b.n	340063e0 <BSP_XSPI_NOR_ConfigFlash+0x108>
    }
    else
    {
      /* Setup Flash interface ***************************************************/
      switch (XSPI_Nor_Ctx[Instance].InterfaceMode)
34006314:	4935      	ldr	r1, [pc, #212]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
34006316:	687a      	ldr	r2, [r7, #4]
34006318:	4613      	mov	r3, r2
3400631a:	005b      	lsls	r3, r3, #1
3400631c:	4413      	add	r3, r2
3400631e:	440b      	add	r3, r1
34006320:	3301      	adds	r3, #1
34006322:	781b      	ldrb	r3, [r3, #0]
34006324:	2b01      	cmp	r3, #1
34006326:	d12b      	bne.n	34006380 <BSP_XSPI_NOR_ConfigFlash+0xa8>
      {
        case BSP_XSPI_NOR_OPI_MODE :  /* 8-8-8 commands */
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != XSPI_Nor_Ctx[Instance].TransferRate))
34006328:	78fb      	ldrb	r3, [r7, #3]
3400632a:	2b01      	cmp	r3, #1
3400632c:	d10a      	bne.n	34006344 <BSP_XSPI_NOR_ConfigFlash+0x6c>
3400632e:	492f      	ldr	r1, [pc, #188]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
34006330:	687a      	ldr	r2, [r7, #4]
34006332:	4613      	mov	r3, r2
34006334:	005b      	lsls	r3, r3, #1
34006336:	4413      	add	r3, r2
34006338:	440b      	add	r3, r1
3400633a:	3302      	adds	r3, #2
3400633c:	781b      	ldrb	r3, [r3, #0]
3400633e:	78ba      	ldrb	r2, [r7, #2]
34006340:	429a      	cmp	r2, r3
34006342:	d02d      	beq.n	340063a0 <BSP_XSPI_NOR_ConfigFlash+0xc8>
          {
            /* Exit OPI mode */
            ret = XSPI_NOR_ExitOPIMode(Instance);
34006344:	6878      	ldr	r0, [r7, #4]
34006346:	f000 fc57 	bl	34006bf8 <XSPI_NOR_ExitOPIMode>
3400634a:	60f8      	str	r0, [r7, #12]

            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
3400634c:	68fb      	ldr	r3, [r7, #12]
3400634e:	2b00      	cmp	r3, #0
34006350:	d126      	bne.n	340063a0 <BSP_XSPI_NOR_ConfigFlash+0xc8>
34006352:	78fb      	ldrb	r3, [r7, #3]
34006354:	2b01      	cmp	r3, #1
34006356:	d123      	bne.n	340063a0 <BSP_XSPI_NOR_ConfigFlash+0xc8>
            {

              if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34006358:	4924      	ldr	r1, [pc, #144]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
3400635a:	687a      	ldr	r2, [r7, #4]
3400635c:	4613      	mov	r3, r2
3400635e:	005b      	lsls	r3, r3, #1
34006360:	4413      	add	r3, r2
34006362:	440b      	add	r3, r1
34006364:	3302      	adds	r3, #2
34006366:	781b      	ldrb	r3, [r3, #0]
34006368:	2b00      	cmp	r3, #0
3400636a:	d104      	bne.n	34006376 <BSP_XSPI_NOR_ConfigFlash+0x9e>
              {
                /* Enter DTR OPI mode */
                ret = XSPI_NOR_EnterDOPIMode(Instance);
3400636c:	6878      	ldr	r0, [r7, #4]
3400636e:	f000 fa93 	bl	34006898 <XSPI_NOR_EnterDOPIMode>
34006372:	60f8      	str	r0, [r7, #12]
                /* Enter STR OPI mode */
                ret = XSPI_NOR_EnterSOPIMode(Instance);
              }
            }
          }
          break;
34006374:	e014      	b.n	340063a0 <BSP_XSPI_NOR_ConfigFlash+0xc8>
                ret = XSPI_NOR_EnterSOPIMode(Instance);
34006376:	6878      	ldr	r0, [r7, #4]
34006378:	f000 fb78 	bl	34006a6c <XSPI_NOR_EnterSOPIMode>
3400637c:	60f8      	str	r0, [r7, #12]
          break;
3400637e:	e00f      	b.n	340063a0 <BSP_XSPI_NOR_ConfigFlash+0xc8>

        case BSP_XSPI_NOR_SPI_MODE :  /* 1-1-1 commands, Power on H/W default setting */
        default :
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
34006380:	78fb      	ldrb	r3, [r7, #3]
34006382:	2b01      	cmp	r3, #1
34006384:	d10e      	bne.n	340063a4 <BSP_XSPI_NOR_ConfigFlash+0xcc>
          {
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
34006386:	78bb      	ldrb	r3, [r7, #2]
34006388:	2b00      	cmp	r3, #0
3400638a:	d104      	bne.n	34006396 <BSP_XSPI_NOR_ConfigFlash+0xbe>
            {
              /* Enter STR OPI mode */
              ret = XSPI_NOR_EnterSOPIMode(Instance);
3400638c:	6878      	ldr	r0, [r7, #4]
3400638e:	f000 fb6d 	bl	34006a6c <XSPI_NOR_EnterSOPIMode>
34006392:	60f8      	str	r0, [r7, #12]
            {
              /* Enter DTR OPI mode */
              ret = XSPI_NOR_EnterDOPIMode(Instance);
            }
          }
          break;
34006394:	e006      	b.n	340063a4 <BSP_XSPI_NOR_ConfigFlash+0xcc>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
34006396:	6878      	ldr	r0, [r7, #4]
34006398:	f000 fa7e 	bl	34006898 <XSPI_NOR_EnterDOPIMode>
3400639c:	60f8      	str	r0, [r7, #12]
          break;
3400639e:	e001      	b.n	340063a4 <BSP_XSPI_NOR_ConfigFlash+0xcc>
          break;
340063a0:	bf00      	nop
340063a2:	e000      	b.n	340063a6 <BSP_XSPI_NOR_ConfigFlash+0xce>
          break;
340063a4:	bf00      	nop
      }

      /* Update XSPI context if all operations are well done */
      if (ret == BSP_ERROR_NONE)
340063a6:	68fb      	ldr	r3, [r7, #12]
340063a8:	2b00      	cmp	r3, #0
340063aa:	d119      	bne.n	340063e0 <BSP_XSPI_NOR_ConfigFlash+0x108>
      {
        /* Update current status parameter *****************************************/
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
340063ac:	490f      	ldr	r1, [pc, #60]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
340063ae:	687a      	ldr	r2, [r7, #4]
340063b0:	4613      	mov	r3, r2
340063b2:	005b      	lsls	r3, r3, #1
340063b4:	4413      	add	r3, r2
340063b6:	440b      	add	r3, r1
340063b8:	2201      	movs	r2, #1
340063ba:	701a      	strb	r2, [r3, #0]
        XSPI_Nor_Ctx[Instance].InterfaceMode = Mode;
340063bc:	490b      	ldr	r1, [pc, #44]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
340063be:	687a      	ldr	r2, [r7, #4]
340063c0:	4613      	mov	r3, r2
340063c2:	005b      	lsls	r3, r3, #1
340063c4:	4413      	add	r3, r2
340063c6:	440b      	add	r3, r1
340063c8:	3301      	adds	r3, #1
340063ca:	78fa      	ldrb	r2, [r7, #3]
340063cc:	701a      	strb	r2, [r3, #0]
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
340063ce:	4907      	ldr	r1, [pc, #28]	@ (340063ec <BSP_XSPI_NOR_ConfigFlash+0x114>)
340063d0:	687a      	ldr	r2, [r7, #4]
340063d2:	4613      	mov	r3, r2
340063d4:	005b      	lsls	r3, r3, #1
340063d6:	4413      	add	r3, r2
340063d8:	440b      	add	r3, r1
340063da:	3302      	adds	r3, #2
340063dc:	78ba      	ldrb	r2, [r7, #2]
340063de:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
340063e0:	68fb      	ldr	r3, [r7, #12]
}
340063e2:	4618      	mov	r0, r3
340063e4:	3710      	adds	r7, #16
340063e6:	46bd      	mov	sp, r7
340063e8:	bd80      	pop	{r7, pc}
340063ea:	bf00      	nop
340063ec:	34053b5c 	.word	0x34053b5c

340063f0 <BSP_XSPI_RAM_Init>:
  * @brief  Initializes the XSPI interface.
  * @param  Instance   XSPI Instance
  * @retval BSP status
  */
int32_t BSP_XSPI_RAM_Init(uint32_t Instance)
{
340063f0:	b580      	push	{r7, lr}
340063f2:	b088      	sub	sp, #32
340063f4:	af00      	add	r7, sp, #0
340063f6:	6078      	str	r0, [r7, #4]
  MX_XSPI_InitTypeDef xspi_init;
  int32_t ret = BSP_ERROR_NONE;
340063f8:	2300      	movs	r3, #0
340063fa:	61fb      	str	r3, [r7, #28]

  /* Check if the instance is supported */
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
340063fc:	687b      	ldr	r3, [r7, #4]
340063fe:	2b00      	cmp	r3, #0
34006400:	d003      	beq.n	3400640a <BSP_XSPI_RAM_Init+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34006402:	f06f 0301 	mvn.w	r3, #1
34006406:	61fb      	str	r3, [r7, #28]
34006408:	e062      	b.n	340064d0 <BSP_XSPI_RAM_Init+0xe0>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (XSPI_Ram_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
3400640a:	4a34      	ldr	r2, [pc, #208]	@ (340064dc <BSP_XSPI_RAM_Init+0xec>)
3400640c:	687b      	ldr	r3, [r7, #4]
3400640e:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
34006412:	2b00      	cmp	r3, #0
34006414:	d131      	bne.n	3400647a <BSP_XSPI_RAM_Init+0x8a>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_RAM_MspInit(&hxspi_ram[Instance]);
34006416:	687b      	ldr	r3, [r7, #4]
34006418:	2264      	movs	r2, #100	@ 0x64
3400641a:	fb02 f303 	mul.w	r3, r2, r3
3400641e:	4a30      	ldr	r2, [pc, #192]	@ (340064e0 <BSP_XSPI_RAM_Init+0xf0>)
34006420:	4413      	add	r3, r2
34006422:	4618      	mov	r0, r3
34006424:	f000 fc9c 	bl	34006d60 <XSPI_RAM_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Fill config structure */
      xspi_init.ClockPrescaler = 3;
34006428:	2303      	movs	r3, #3
3400642a:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = HAL_XSPI_SIZE_256MB;
3400642c:	2318      	movs	r3, #24
3400642e:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34006430:	2300      	movs	r3, #0
34006432:	617b      	str	r3, [r7, #20]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
34006434:	687b      	ldr	r3, [r7, #4]
34006436:	2264      	movs	r2, #100	@ 0x64
34006438:	fb02 f303 	mul.w	r3, r2, r3
3400643c:	4a28      	ldr	r2, [pc, #160]	@ (340064e0 <BSP_XSPI_RAM_Init+0xf0>)
3400643e:	4413      	add	r3, r2
34006440:	f107 020c 	add.w	r2, r7, #12
34006444:	4611      	mov	r1, r2
34006446:	4618      	mov	r0, r3
34006448:	f000 f84c 	bl	340064e4 <MX_XSPI_RAM_Init>
3400644c:	4603      	mov	r3, r0
3400644e:	2b00      	cmp	r3, #0
34006450:	d002      	beq.n	34006458 <BSP_XSPI_RAM_Init+0x68>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
34006452:	f06f 0303 	mvn.w	r3, #3
34006456:	61fb      	str	r3, [r7, #28]
      }
      /* Update current status parameter */
      XSPI_Ram_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34006458:	4a20      	ldr	r2, [pc, #128]	@ (340064dc <BSP_XSPI_RAM_Init+0xec>)
3400645a:	687b      	ldr	r3, [r7, #4]
3400645c:	2101      	movs	r1, #1
3400645e:	f802 1023 	strb.w	r1, [r2, r3, lsl #2]
      XSPI_Ram_Ctx[Instance].LatencyType   = BSP_XSPI_RAM_FIXED_LATENCY;
34006462:	4a1e      	ldr	r2, [pc, #120]	@ (340064dc <BSP_XSPI_RAM_Init+0xec>)
34006464:	687b      	ldr	r3, [r7, #4]
34006466:	009b      	lsls	r3, r3, #2
34006468:	4413      	add	r3, r2
3400646a:	2201      	movs	r2, #1
3400646c:	705a      	strb	r2, [r3, #1]
      XSPI_Ram_Ctx[Instance].BurstType     = BSP_XSPI_RAM_LINEAR_BURST;
3400646e:	4a1b      	ldr	r2, [pc, #108]	@ (340064dc <BSP_XSPI_RAM_Init+0xec>)
34006470:	687b      	ldr	r3, [r7, #4]
34006472:	009b      	lsls	r3, r3, #2
34006474:	4413      	add	r3, r2
34006476:	2201      	movs	r2, #1
34006478:	709a      	strb	r2, [r3, #2]
    }

    /* Read Latency=7 up to 200MHz */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 0, 0x30));
3400647a:	687b      	ldr	r3, [r7, #4]
3400647c:	2264      	movs	r2, #100	@ 0x64
3400647e:	fb02 f303 	mul.w	r3, r2, r3
34006482:	4a17      	ldr	r2, [pc, #92]	@ (340064e0 <BSP_XSPI_RAM_Init+0xf0>)
34006484:	4413      	add	r3, r2
34006486:	2230      	movs	r2, #48	@ 0x30
34006488:	2100      	movs	r1, #0
3400648a:	4618      	mov	r0, r3
3400648c:	f7fd fe92 	bl	340041b4 <APS256XX_WriteReg>

    /* Write Latency=7 up to 200MHz */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 4, 0x20));
34006490:	687b      	ldr	r3, [r7, #4]
34006492:	2264      	movs	r2, #100	@ 0x64
34006494:	fb02 f303 	mul.w	r3, r2, r3
34006498:	4a11      	ldr	r2, [pc, #68]	@ (340064e0 <BSP_XSPI_RAM_Init+0xf0>)
3400649a:	4413      	add	r3, r2
3400649c:	2220      	movs	r2, #32
3400649e:	2104      	movs	r1, #4
340064a0:	4618      	mov	r0, r3
340064a2:	f7fd fe87 	bl	340041b4 <APS256XX_WriteReg>

    /* Switch to x16 mode */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 8, 0x40));
340064a6:	687b      	ldr	r3, [r7, #4]
340064a8:	2264      	movs	r2, #100	@ 0x64
340064aa:	fb02 f303 	mul.w	r3, r2, r3
340064ae:	4a0c      	ldr	r2, [pc, #48]	@ (340064e0 <BSP_XSPI_RAM_Init+0xf0>)
340064b0:	4413      	add	r3, r2
340064b2:	2240      	movs	r2, #64	@ 0x40
340064b4:	2108      	movs	r1, #8
340064b6:	4618      	mov	r0, r3
340064b8:	f7fd fe7c 	bl	340041b4 <APS256XX_WriteReg>

    /* Bypass the Pre-scaler */
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_ram[Instance], 0));
340064bc:	687b      	ldr	r3, [r7, #4]
340064be:	2264      	movs	r2, #100	@ 0x64
340064c0:	fb02 f303 	mul.w	r3, r2, r3
340064c4:	4a06      	ldr	r2, [pc, #24]	@ (340064e0 <BSP_XSPI_RAM_Init+0xf0>)
340064c6:	4413      	add	r3, r2
340064c8:	2100      	movs	r1, #0
340064ca:	4618      	mov	r0, r3
340064cc:	f015 fcbc 	bl	3401be48 <HAL_XSPI_SetClockPrescaler>

  }

  /* Return BSP status */
  return ret;
340064d0:	69fb      	ldr	r3, [r7, #28]
}
340064d2:	4618      	mov	r0, r3
340064d4:	3720      	adds	r7, #32
340064d6:	46bd      	mov	sp, r7
340064d8:	bd80      	pop	{r7, pc}
340064da:	bf00      	nop
340064dc:	34053bc4 	.word	0x34053bc4
340064e0:	34053b60 	.word	0x34053b60

340064e4 <MX_XSPI_RAM_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_RAM_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
340064e4:	b580      	push	{r7, lr}
340064e6:	b084      	sub	sp, #16
340064e8:	af00      	add	r7, sp, #0
340064ea:	6078      	str	r0, [r7, #4]
340064ec:	6039      	str	r1, [r7, #0]
  uint32_t hspi_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1);
340064ee:	f04f 0000 	mov.w	r0, #0
340064f2:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
340064f6:	f00e fe55 	bl	340151a4 <HAL_RCCEx_GetPeriphCLKFreq>
340064fa:	60f8      	str	r0, [r7, #12]

  /* XSPI initialization */
  hxspi->Instance = XSPI1;
340064fc:	687b      	ldr	r3, [r7, #4]
340064fe:	4a21      	ldr	r2, [pc, #132]	@ (34006584 <MX_XSPI_RAM_Init+0xa0>)
34006500:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte          = 8;
34006502:	687b      	ldr	r3, [r7, #4]
34006504:	2208      	movs	r2, #8
34006506:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemoryType                 = HAL_XSPI_MEMTYPE_APMEM_16BITS;
34006508:	687b      	ldr	r3, [r7, #4]
3400650a:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
3400650e:	60da      	str	r2, [r3, #12]
  hxspi->Init.MemoryMode                 = HAL_XSPI_SINGLE_MEM;
34006510:	687b      	ldr	r3, [r7, #4]
34006512:	2200      	movs	r2, #0
34006514:	609a      	str	r2, [r3, #8]
  hxspi->Init.MemorySize                 = Init->MemorySize;
34006516:	683b      	ldr	r3, [r7, #0]
34006518:	681a      	ldr	r2, [r3, #0]
3400651a:	687b      	ldr	r3, [r7, #4]
3400651c:	611a      	str	r2, [r3, #16]
  hxspi->Init.MemorySelect               = HAL_XSPI_CSSEL_NCS1;
3400651e:	687b      	ldr	r3, [r7, #4]
34006520:	2200      	movs	r2, #0
34006522:	63da      	str	r2, [r3, #60]	@ 0x3c
  hxspi->Init.ChipSelectHighTimeCycle    = 1;
34006524:	687b      	ldr	r3, [r7, #4]
34006526:	2201      	movs	r2, #1
34006528:	615a      	str	r2, [r3, #20]
  hxspi->Init.ClockMode                  = HAL_XSPI_CLOCK_MODE_0;
3400652a:	687b      	ldr	r3, [r7, #4]
3400652c:	2200      	movs	r2, #0
3400652e:	61da      	str	r2, [r3, #28]
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
34006530:	683b      	ldr	r3, [r7, #0]
34006532:	685a      	ldr	r2, [r3, #4]
34006534:	687b      	ldr	r3, [r7, #4]
34006536:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting             = Init->SampleShifting;
34006538:	683b      	ldr	r3, [r7, #0]
3400653a:	689a      	ldr	r2, [r3, #8]
3400653c:	687b      	ldr	r3, [r7, #4]
3400653e:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.DelayHoldQuarterCycle      = HAL_XSPI_DHQC_ENABLE;
34006540:	687b      	ldr	r3, [r7, #4]
34006542:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34006546:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
34006548:	687b      	ldr	r3, [r7, #4]
3400654a:	220b      	movs	r2, #11
3400654c:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi->Init.FreeRunningClock           = HAL_XSPI_FREERUNCLK_DISABLE;
3400654e:	687b      	ldr	r3, [r7, #4]
34006550:	2200      	movs	r2, #0
34006552:	619a      	str	r2, [r3, #24]
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
34006554:	687b      	ldr	r3, [r7, #4]
34006556:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006558:	68fa      	ldr	r2, [r7, #12]
3400655a:	fbb2 f3f3 	udiv	r3, r2, r3
3400655e:	005b      	lsls	r3, r3, #1
34006560:	4a09      	ldr	r2, [pc, #36]	@ (34006588 <MX_XSPI_RAM_Init+0xa4>)
34006562:	fba2 2303 	umull	r2, r3, r2, r3
34006566:	0c9b      	lsrs	r3, r3, #18
34006568:	1f1a      	subs	r2, r3, #4
3400656a:	687b      	ldr	r3, [r7, #4]
3400656c:	639a      	str	r2, [r3, #56]	@ 0x38
#if defined (OCTOSPI_DCR1_DLYBYP)
  hxspi->Init.DelayBlockBypass           = HAL_XSPI_DELAY_BLOCK_BYPASS;
#endif /* defined (OCTOSPI_DCR1_DLYBYP) */
  hxspi->Init.WrapSize                   = HAL_XSPI_WRAP_NOT_SUPPORTED;
3400656e:	687b      	ldr	r3, [r7, #4]
34006570:	2200      	movs	r2, #0
34006572:	621a      	str	r2, [r3, #32]

  return HAL_XSPI_Init(hxspi);
34006574:	6878      	ldr	r0, [r7, #4]
34006576:	f014 fcdb 	bl	3401af30 <HAL_XSPI_Init>
3400657a:	4603      	mov	r3, r0
}
3400657c:	4618      	mov	r0, r3
3400657e:	3710      	adds	r7, #16
34006580:	46bd      	mov	sp, r7
34006582:	bd80      	pop	{r7, pc}
34006584:	58025000 	.word	0x58025000
34006588:	431bde83 	.word	0x431bde83

3400658c <BSP_XSPI_RAM_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_RAM_EnableMemoryMappedMode(uint32_t Instance)
{
3400658c:	b580      	push	{r7, lr}
3400658e:	b086      	sub	sp, #24
34006590:	af02      	add	r7, sp, #8
34006592:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34006594:	2300      	movs	r3, #0
34006596:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34006598:	687b      	ldr	r3, [r7, #4]
3400659a:	2b00      	cmp	r3, #0
3400659c:	d003      	beq.n	340065a6 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400659e:	f06f 0301 	mvn.w	r3, #1
340065a2:	60fb      	str	r3, [r7, #12]
340065a4:	e012      	b.n	340065cc <BSP_XSPI_RAM_EnableMemoryMappedMode+0x40>
  }
  else
  {
    if (APS256XX_EnableMemoryMappedMode(&hxspi_ram[Instance], 7, 7, 1, 0) != APS256XX_OK)
340065a6:	687b      	ldr	r3, [r7, #4]
340065a8:	2264      	movs	r2, #100	@ 0x64
340065aa:	fb02 f303 	mul.w	r3, r2, r3
340065ae:	4a0a      	ldr	r2, [pc, #40]	@ (340065d8 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x4c>)
340065b0:	1898      	adds	r0, r3, r2
340065b2:	2300      	movs	r3, #0
340065b4:	9300      	str	r3, [sp, #0]
340065b6:	2301      	movs	r3, #1
340065b8:	2207      	movs	r2, #7
340065ba:	2107      	movs	r1, #7
340065bc:	f7fd fd7e 	bl	340040bc <APS256XX_EnableMemoryMappedMode>
340065c0:	4603      	mov	r3, r0
340065c2:	2b00      	cmp	r3, #0
340065c4:	d002      	beq.n	340065cc <BSP_XSPI_RAM_EnableMemoryMappedMode+0x40>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
340065c6:	f06f 0303 	mvn.w	r3, #3
340065ca:	60fb      	str	r3, [r7, #12]
    }
  }


  /* Return BSP status */
  return ret;
340065cc:	68fb      	ldr	r3, [r7, #12]
}
340065ce:	4618      	mov	r0, r3
340065d0:	3710      	adds	r7, #16
340065d2:	46bd      	mov	sp, r7
340065d4:	bd80      	pop	{r7, pc}
340065d6:	bf00      	nop
340065d8:	34053b60 	.word	0x34053b60

340065dc <XSPI_NOR_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_NOR_MspInit(const XSPI_HandleTypeDef *hxspi)
{
340065dc:	b580      	push	{r7, lr}
340065de:	b088      	sub	sp, #32
340065e0:	af00      	add	r7, sp, #0
340065e2:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

  /* Enable the XSPI memory interface clock */
  XSPI_NOR_CLK_ENABLE();
340065e4:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
340065e8:	f7ff fce6 	bl	34005fb8 <LL_AHB5_GRP1_EnableClock>

  /* Reset the XSPI memory interface */
  XSPI_NOR_FORCE_RESET();
340065ec:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
340065f0:	f7ff fcf8 	bl	34005fe4 <LL_AHB5_GRP1_ForceReset>
  XSPI_NOR_RELEASE_RESET();
340065f4:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
340065f8:	f7ff fd04 	bl	34006004 <LL_AHB5_GRP1_ReleaseReset>

  /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
340065fc:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34006600:	f7ff fcc4 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
34006604:	f004 fd82 	bl	3400b10c <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
34006608:	2101      	movs	r1, #1
3400660a:	2002      	movs	r0, #2
3400660c:	f004 fcfe 	bl	3400b00c <HAL_PWREx_ConfigVddIORange>

  /* Enable GPIO clocks */
  XSPI_NOR_CLK_GPIO_CLK_ENABLE();
34006610:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006614:	f7ff fcba 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_DQS_GPIO_CLK_ENABLE();
34006618:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3400661c:	f7ff fcb6 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_CS_GPIO_CLK_ENABLE();
34006620:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006624:	f7ff fcb2 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D0_GPIO_CLK_ENABLE();
34006628:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3400662c:	f7ff fcae 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D1_GPIO_CLK_ENABLE();
34006630:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006634:	f7ff fcaa 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D2_GPIO_CLK_ENABLE();
34006638:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3400663c:	f7ff fca6 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D3_GPIO_CLK_ENABLE();
34006640:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006644:	f7ff fca2 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D4_GPIO_CLK_ENABLE();
34006648:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3400664c:	f7ff fc9e 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D5_GPIO_CLK_ENABLE();
34006650:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006654:	f7ff fc9a 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D6_GPIO_CLK_ENABLE();
34006658:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3400665c:	f7ff fc96 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D7_GPIO_CLK_ENABLE();
34006660:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006664:	f7ff fc92 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_CS_PIN;
34006668:	2302      	movs	r3, #2
3400666a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
3400666c:	2302      	movs	r3, #2
3400666e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34006670:	2301      	movs	r3, #1
34006672:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
34006674:	2302      	movs	r3, #2
34006676:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34006678:	2309      	movs	r3, #9
3400667a:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
3400667c:	f107 030c 	add.w	r3, r7, #12
34006680:	4619      	mov	r1, r3
34006682:	4838      	ldr	r0, [pc, #224]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
34006684:	f002 fea4 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI DQS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_DQS_PIN;
34006688:	2301      	movs	r3, #1
3400668a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_DQS_PIN_AF;
3400668c:	2309      	movs	r3, #9
3400668e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
34006690:	f107 030c 	add.w	r3, r7, #12
34006694:	4619      	mov	r1, r3
34006696:	4833      	ldr	r0, [pc, #204]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
34006698:	f002 fe9a 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
3400669c:	2340      	movs	r3, #64	@ 0x40
3400669e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
340066a0:	2300      	movs	r3, #0
340066a2:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_CLK_PIN_AF;
340066a4:	2309      	movs	r3, #9
340066a6:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
340066a8:	f107 030c 	add.w	r3, r7, #12
340066ac:	4619      	mov	r1, r3
340066ae:	482d      	ldr	r0, [pc, #180]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
340066b0:	f002 fe8e 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
340066b4:	2304      	movs	r3, #4
340066b6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D0_PIN_AF;
340066b8:	2309      	movs	r3, #9
340066ba:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
340066bc:	f107 030c 	add.w	r3, r7, #12
340066c0:	4619      	mov	r1, r3
340066c2:	4828      	ldr	r0, [pc, #160]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
340066c4:	f002 fe84 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
340066c8:	2308      	movs	r3, #8
340066ca:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D1_PIN_AF;
340066cc:	2309      	movs	r3, #9
340066ce:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
340066d0:	f107 030c 	add.w	r3, r7, #12
340066d4:	4619      	mov	r1, r3
340066d6:	4823      	ldr	r0, [pc, #140]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
340066d8:	f002 fe7a 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
340066dc:	2310      	movs	r3, #16
340066de:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D2_PIN_AF;
340066e0:	2309      	movs	r3, #9
340066e2:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
340066e4:	f107 030c 	add.w	r3, r7, #12
340066e8:	4619      	mov	r1, r3
340066ea:	481e      	ldr	r0, [pc, #120]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
340066ec:	f002 fe70 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
340066f0:	2320      	movs	r3, #32
340066f2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D3_PIN_AF;
340066f4:	2309      	movs	r3, #9
340066f6:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
340066f8:	f107 030c 	add.w	r3, r7, #12
340066fc:	4619      	mov	r1, r3
340066fe:	4819      	ldr	r0, [pc, #100]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
34006700:	f002 fe66 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
34006704:	f44f 7380 	mov.w	r3, #256	@ 0x100
34006708:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D4_PIN_AF;
3400670a:	2309      	movs	r3, #9
3400670c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
3400670e:	f107 030c 	add.w	r3, r7, #12
34006712:	4619      	mov	r1, r3
34006714:	4813      	ldr	r0, [pc, #76]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
34006716:	f002 fe5b 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
3400671a:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400671e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D5_PIN_AF;
34006720:	2309      	movs	r3, #9
34006722:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
34006724:	f107 030c 	add.w	r3, r7, #12
34006728:	4619      	mov	r1, r3
3400672a:	480e      	ldr	r0, [pc, #56]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
3400672c:	f002 fe50 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
34006730:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34006734:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D6_PIN_AF;
34006736:	2309      	movs	r3, #9
34006738:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
3400673a:	f107 030c 	add.w	r3, r7, #12
3400673e:	4619      	mov	r1, r3
34006740:	4808      	ldr	r0, [pc, #32]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
34006742:	f002 fe45 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
34006746:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400674a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D7_PIN_AF;
3400674c:	2309      	movs	r3, #9
3400674e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
34006750:	f107 030c 	add.w	r3, r7, #12
34006754:	4619      	mov	r1, r3
34006756:	4803      	ldr	r0, [pc, #12]	@ (34006764 <XSPI_NOR_MspInit+0x188>)
34006758:	f002 fe3a 	bl	340093d0 <HAL_GPIO_Init>
}
3400675c:	bf00      	nop
3400675e:	3720      	adds	r7, #32
34006760:	46bd      	mov	sp, r7
34006762:	bd80      	pop	{r7, pc}
34006764:	56023400 	.word	0x56023400

34006768 <XSPI_NOR_ResetMemory>:
  * @brief  This function reset the XSPI memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ResetMemory(uint32_t Instance)
{
34006768:	b580      	push	{r7, lr}
3400676a:	b084      	sub	sp, #16
3400676c:	af00      	add	r7, sp, #0
3400676e:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34006770:	2300      	movs	r3, #0
34006772:	60fb      	str	r3, [r7, #12]

  if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34006774:	687b      	ldr	r3, [r7, #4]
34006776:	2264      	movs	r2, #100	@ 0x64
34006778:	fb02 f303 	mul.w	r3, r2, r3
3400677c:	4a44      	ldr	r2, [pc, #272]	@ (34006890 <XSPI_NOR_ResetMemory+0x128>)
3400677e:	4413      	add	r3, r2
34006780:	2200      	movs	r2, #0
34006782:	2100      	movs	r1, #0
34006784:	4618      	mov	r0, r3
34006786:	f7fe f950 	bl	34004a2a <MX66UW1G45G_ResetEnable>
3400678a:	4603      	mov	r3, r0
3400678c:	2b00      	cmp	r3, #0
3400678e:	d003      	beq.n	34006798 <XSPI_NOR_ResetMemory+0x30>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006790:	f06f 0304 	mvn.w	r3, #4
34006794:	60fb      	str	r3, [r7, #12]
34006796:	e076      	b.n	34006886 <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34006798:	687b      	ldr	r3, [r7, #4]
3400679a:	2264      	movs	r2, #100	@ 0x64
3400679c:	fb02 f303 	mul.w	r3, r2, r3
340067a0:	4a3b      	ldr	r2, [pc, #236]	@ (34006890 <XSPI_NOR_ResetMemory+0x128>)
340067a2:	4413      	add	r3, r2
340067a4:	2200      	movs	r2, #0
340067a6:	2100      	movs	r1, #0
340067a8:	4618      	mov	r0, r3
340067aa:	f7fe f994 	bl	34004ad6 <MX66UW1G45G_ResetMemory>
340067ae:	4603      	mov	r3, r0
340067b0:	2b00      	cmp	r3, #0
340067b2:	d003      	beq.n	340067bc <XSPI_NOR_ResetMemory+0x54>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340067b4:	f06f 0304 	mvn.w	r3, #4
340067b8:	60fb      	str	r3, [r7, #12]
340067ba:	e064      	b.n	34006886 <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340067bc:	687b      	ldr	r3, [r7, #4]
340067be:	2264      	movs	r2, #100	@ 0x64
340067c0:	fb02 f303 	mul.w	r3, r2, r3
340067c4:	4a32      	ldr	r2, [pc, #200]	@ (34006890 <XSPI_NOR_ResetMemory+0x128>)
340067c6:	4413      	add	r3, r2
340067c8:	2200      	movs	r2, #0
340067ca:	2101      	movs	r1, #1
340067cc:	4618      	mov	r0, r3
340067ce:	f7fe f92c 	bl	34004a2a <MX66UW1G45G_ResetEnable>
340067d2:	4603      	mov	r3, r0
340067d4:	2b00      	cmp	r3, #0
340067d6:	d003      	beq.n	340067e0 <XSPI_NOR_ResetMemory+0x78>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340067d8:	f06f 0304 	mvn.w	r3, #4
340067dc:	60fb      	str	r3, [r7, #12]
340067de:	e052      	b.n	34006886 <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340067e0:	687b      	ldr	r3, [r7, #4]
340067e2:	2264      	movs	r2, #100	@ 0x64
340067e4:	fb02 f303 	mul.w	r3, r2, r3
340067e8:	4a29      	ldr	r2, [pc, #164]	@ (34006890 <XSPI_NOR_ResetMemory+0x128>)
340067ea:	4413      	add	r3, r2
340067ec:	2200      	movs	r2, #0
340067ee:	2101      	movs	r1, #1
340067f0:	4618      	mov	r0, r3
340067f2:	f7fe f970 	bl	34004ad6 <MX66UW1G45G_ResetMemory>
340067f6:	4603      	mov	r3, r0
340067f8:	2b00      	cmp	r3, #0
340067fa:	d003      	beq.n	34006804 <XSPI_NOR_ResetMemory+0x9c>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340067fc:	f06f 0304 	mvn.w	r3, #4
34006800:	60fb      	str	r3, [r7, #12]
34006802:	e040      	b.n	34006886 <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34006804:	687b      	ldr	r3, [r7, #4]
34006806:	2264      	movs	r2, #100	@ 0x64
34006808:	fb02 f303 	mul.w	r3, r2, r3
3400680c:	4a20      	ldr	r2, [pc, #128]	@ (34006890 <XSPI_NOR_ResetMemory+0x128>)
3400680e:	4413      	add	r3, r2
34006810:	2201      	movs	r2, #1
34006812:	2101      	movs	r1, #1
34006814:	4618      	mov	r0, r3
34006816:	f7fe f908 	bl	34004a2a <MX66UW1G45G_ResetEnable>
3400681a:	4603      	mov	r3, r0
3400681c:	2b00      	cmp	r3, #0
3400681e:	d003      	beq.n	34006828 <XSPI_NOR_ResetMemory+0xc0>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006820:	f06f 0304 	mvn.w	r3, #4
34006824:	60fb      	str	r3, [r7, #12]
34006826:	e02e      	b.n	34006886 <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34006828:	687b      	ldr	r3, [r7, #4]
3400682a:	2264      	movs	r2, #100	@ 0x64
3400682c:	fb02 f303 	mul.w	r3, r2, r3
34006830:	4a17      	ldr	r2, [pc, #92]	@ (34006890 <XSPI_NOR_ResetMemory+0x128>)
34006832:	4413      	add	r3, r2
34006834:	2201      	movs	r2, #1
34006836:	2101      	movs	r1, #1
34006838:	4618      	mov	r0, r3
3400683a:	f7fe f94c 	bl	34004ad6 <MX66UW1G45G_ResetMemory>
3400683e:	4603      	mov	r3, r0
34006840:	2b00      	cmp	r3, #0
34006842:	d003      	beq.n	3400684c <XSPI_NOR_ResetMemory+0xe4>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006844:	f06f 0304 	mvn.w	r3, #4
34006848:	60fb      	str	r3, [r7, #12]
3400684a:	e01c      	b.n	34006886 <XSPI_NOR_ResetMemory+0x11e>
  }
  else
  {
    XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;     /* After reset S/W setting to indirect access  */
3400684c:	4911      	ldr	r1, [pc, #68]	@ (34006894 <XSPI_NOR_ResetMemory+0x12c>)
3400684e:	687a      	ldr	r2, [r7, #4]
34006850:	4613      	mov	r3, r2
34006852:	005b      	lsls	r3, r3, #1
34006854:	4413      	add	r3, r2
34006856:	440b      	add	r3, r1
34006858:	2201      	movs	r2, #1
3400685a:	701a      	strb	r2, [r3, #0]
    XSPI_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;    /* After reset H/W back to SPI mode by default */
3400685c:	490d      	ldr	r1, [pc, #52]	@ (34006894 <XSPI_NOR_ResetMemory+0x12c>)
3400685e:	687a      	ldr	r2, [r7, #4]
34006860:	4613      	mov	r3, r2
34006862:	005b      	lsls	r3, r3, #1
34006864:	4413      	add	r3, r2
34006866:	440b      	add	r3, r1
34006868:	3301      	adds	r3, #1
3400686a:	2200      	movs	r2, #0
3400686c:	701a      	strb	r2, [r3, #0]
    XSPI_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode        */
3400686e:	4909      	ldr	r1, [pc, #36]	@ (34006894 <XSPI_NOR_ResetMemory+0x12c>)
34006870:	687a      	ldr	r2, [r7, #4]
34006872:	4613      	mov	r3, r2
34006874:	005b      	lsls	r3, r3, #1
34006876:	4413      	add	r3, r2
34006878:	440b      	add	r3, r1
3400687a:	3302      	adds	r3, #2
3400687c:	2200      	movs	r2, #0
3400687e:	701a      	strb	r2, [r3, #0]

    /* After SWreset CMD, wait in case SWReset occurred during erase operation */
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34006880:	2064      	movs	r0, #100	@ 0x64
34006882:	f000 feb9 	bl	340075f8 <HAL_Delay>
  }

  /* Return BSP status */
  return ret;
34006886:	68fb      	ldr	r3, [r7, #12]
}
34006888:	4618      	mov	r0, r3
3400688a:	3710      	adds	r7, #16
3400688c:	46bd      	mov	sp, r7
3400688e:	bd80      	pop	{r7, pc}
34006890:	34053af8 	.word	0x34053af8
34006894:	34053b5c 	.word	0x34053b5c

34006898 <XSPI_NOR_EnterDOPIMode>:
  * @brief  This function enables the octal DTR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
{
34006898:	b590      	push	{r4, r7, lr}
3400689a:	b087      	sub	sp, #28
3400689c:	af02      	add	r7, sp, #8
3400689e:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340068a0:	687b      	ldr	r3, [r7, #4]
340068a2:	2264      	movs	r2, #100	@ 0x64
340068a4:	fb02 f303 	mul.w	r3, r2, r3
340068a8:	4a6e      	ldr	r2, [pc, #440]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
340068aa:	1898      	adds	r0, r3, r2
340068ac:	496e      	ldr	r1, [pc, #440]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
340068ae:	687a      	ldr	r2, [r7, #4]
340068b0:	4613      	mov	r3, r2
340068b2:	005b      	lsls	r3, r3, #1
340068b4:	4413      	add	r3, r2
340068b6:	440b      	add	r3, r1
340068b8:	3301      	adds	r3, #1
340068ba:	7819      	ldrb	r1, [r3, #0]
340068bc:	4c6a      	ldr	r4, [pc, #424]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
340068be:	687a      	ldr	r2, [r7, #4]
340068c0:	4613      	mov	r3, r2
340068c2:	005b      	lsls	r3, r3, #1
340068c4:	4413      	add	r3, r2
340068c6:	4423      	add	r3, r4
340068c8:	3302      	adds	r3, #2
340068ca:	781b      	ldrb	r3, [r3, #0]
340068cc:	461a      	mov	r2, r3
340068ce:	f7fd feb4 	bl	3400463a <MX66UW1G45G_WriteEnable>
340068d2:	4603      	mov	r3, r0
340068d4:	2b00      	cmp	r3, #0
340068d6:	d003      	beq.n	340068e0 <XSPI_NOR_EnterDOPIMode+0x48>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340068d8:	f06f 0304 	mvn.w	r3, #4
340068dc:	60fb      	str	r3, [r7, #12]
340068de:	e0bb      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
340068e0:	687b      	ldr	r3, [r7, #4]
340068e2:	2264      	movs	r2, #100	@ 0x64
340068e4:	fb02 f303 	mul.w	r3, r2, r3
340068e8:	4a5e      	ldr	r2, [pc, #376]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
340068ea:	1898      	adds	r0, r3, r2
340068ec:	495e      	ldr	r1, [pc, #376]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
340068ee:	687a      	ldr	r2, [r7, #4]
340068f0:	4613      	mov	r3, r2
340068f2:	005b      	lsls	r3, r3, #1
340068f4:	4413      	add	r3, r2
340068f6:	440b      	add	r3, r1
340068f8:	3301      	adds	r3, #1
340068fa:	7819      	ldrb	r1, [r3, #0]
340068fc:	4c5a      	ldr	r4, [pc, #360]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
340068fe:	687a      	ldr	r2, [r7, #4]
34006900:	4613      	mov	r3, r2
34006902:	005b      	lsls	r3, r3, #1
34006904:	4413      	add	r3, r2
34006906:	4423      	add	r3, r4
34006908:	3302      	adds	r3, #2
3400690a:	781a      	ldrb	r2, [r3, #0]
3400690c:	2300      	movs	r3, #0
3400690e:	9300      	str	r3, [sp, #0]
34006910:	f44f 7340 	mov.w	r3, #768	@ 0x300
34006914:	f7fd ff5d 	bl	340047d2 <MX66UW1G45G_WriteCfg2Register>
34006918:	4603      	mov	r3, r0
3400691a:	2b00      	cmp	r3, #0
3400691c:	d003      	beq.n	34006926 <XSPI_NOR_EnterDOPIMode+0x8e>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG3_ADDR,
                                          MX66UW1G45G_CR2_DC_20_CYCLES) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400691e:	f06f 0304 	mvn.w	r3, #4
34006922:	60fb      	str	r3, [r7, #12]
34006924:	e098      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Enable write operations */
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006926:	687b      	ldr	r3, [r7, #4]
34006928:	2264      	movs	r2, #100	@ 0x64
3400692a:	fb02 f303 	mul.w	r3, r2, r3
3400692e:	4a4d      	ldr	r2, [pc, #308]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
34006930:	1898      	adds	r0, r3, r2
34006932:	494d      	ldr	r1, [pc, #308]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34006934:	687a      	ldr	r2, [r7, #4]
34006936:	4613      	mov	r3, r2
34006938:	005b      	lsls	r3, r3, #1
3400693a:	4413      	add	r3, r2
3400693c:	440b      	add	r3, r1
3400693e:	3301      	adds	r3, #1
34006940:	7819      	ldrb	r1, [r3, #0]
34006942:	4c49      	ldr	r4, [pc, #292]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34006944:	687a      	ldr	r2, [r7, #4]
34006946:	4613      	mov	r3, r2
34006948:	005b      	lsls	r3, r3, #1
3400694a:	4413      	add	r3, r2
3400694c:	4423      	add	r3, r4
3400694e:	3302      	adds	r3, #2
34006950:	781b      	ldrb	r3, [r3, #0]
34006952:	461a      	mov	r2, r3
34006954:	f7fd fe71 	bl	3400463a <MX66UW1G45G_WriteEnable>
34006958:	4603      	mov	r3, r0
3400695a:	2b00      	cmp	r3, #0
3400695c:	d003      	beq.n	34006966 <XSPI_NOR_EnterDOPIMode+0xce>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
3400695e:	f06f 0304 	mvn.w	r3, #4
34006962:	60fb      	str	r3, [r7, #12]
34006964:	e078      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006966:	687b      	ldr	r3, [r7, #4]
34006968:	2264      	movs	r2, #100	@ 0x64
3400696a:	fb02 f303 	mul.w	r3, r2, r3
3400696e:	4a3d      	ldr	r2, [pc, #244]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
34006970:	1898      	adds	r0, r3, r2
34006972:	493d      	ldr	r1, [pc, #244]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34006974:	687a      	ldr	r2, [r7, #4]
34006976:	4613      	mov	r3, r2
34006978:	005b      	lsls	r3, r3, #1
3400697a:	4413      	add	r3, r2
3400697c:	440b      	add	r3, r1
3400697e:	3301      	adds	r3, #1
34006980:	7819      	ldrb	r1, [r3, #0]
34006982:	4c39      	ldr	r4, [pc, #228]	@ (34006a68 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34006984:	687a      	ldr	r2, [r7, #4]
34006986:	4613      	mov	r3, r2
34006988:	005b      	lsls	r3, r3, #1
3400698a:	4413      	add	r3, r2
3400698c:	4423      	add	r3, r4
3400698e:	3302      	adds	r3, #2
34006990:	781a      	ldrb	r2, [r3, #0]
34006992:	2302      	movs	r3, #2
34006994:	9300      	str	r3, [sp, #0]
34006996:	2300      	movs	r3, #0
34006998:	f7fd ff1b 	bl	340047d2 <MX66UW1G45G_WriteCfg2Register>
3400699c:	4603      	mov	r3, r0
3400699e:	2b00      	cmp	r3, #0
340069a0:	d003      	beq.n	340069aa <XSPI_NOR_EnterDOPIMode+0x112>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                          MX66UW1G45G_CR2_DOPI) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
340069a2:	f06f 0304 	mvn.w	r3, #4
340069a6:	60fb      	str	r3, [r7, #12]
340069a8:	e056      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
340069aa:	2028      	movs	r0, #40	@ 0x28
340069ac:	f000 fe24 	bl	340075f8 <HAL_Delay>

    /* Reconfigure the memory type of the peripheral */
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
340069b0:	4a2c      	ldr	r2, [pc, #176]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
340069b2:	687b      	ldr	r3, [r7, #4]
340069b4:	2164      	movs	r1, #100	@ 0x64
340069b6:	fb01 f303 	mul.w	r3, r1, r3
340069ba:	4413      	add	r3, r2
340069bc:	330c      	adds	r3, #12
340069be:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340069c2:	601a      	str	r2, [r3, #0]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
340069c4:	4a27      	ldr	r2, [pc, #156]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
340069c6:	687b      	ldr	r3, [r7, #4]
340069c8:	2164      	movs	r1, #100	@ 0x64
340069ca:	fb01 f303 	mul.w	r3, r1, r3
340069ce:	4413      	add	r3, r2
340069d0:	332c      	adds	r3, #44	@ 0x2c
340069d2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
340069d6:	601a      	str	r2, [r3, #0]
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
340069d8:	687b      	ldr	r3, [r7, #4]
340069da:	2264      	movs	r2, #100	@ 0x64
340069dc:	fb02 f303 	mul.w	r3, r2, r3
340069e0:	4a20      	ldr	r2, [pc, #128]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
340069e2:	4413      	add	r3, r2
340069e4:	4618      	mov	r0, r3
340069e6:	f014 faa3 	bl	3401af30 <HAL_XSPI_Init>
340069ea:	4603      	mov	r3, r0
340069ec:	2b00      	cmp	r3, #0
340069ee:	d003      	beq.n	340069f8 <XSPI_NOR_EnterDOPIMode+0x160>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
340069f0:	f06f 0303 	mvn.w	r3, #3
340069f4:	60fb      	str	r3, [r7, #12]
340069f6:	e02f      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    /* Check Flash busy ? */
    else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340069f8:	687b      	ldr	r3, [r7, #4]
340069fa:	2264      	movs	r2, #100	@ 0x64
340069fc:	fb02 f303 	mul.w	r3, r2, r3
34006a00:	4a18      	ldr	r2, [pc, #96]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
34006a02:	4413      	add	r3, r2
34006a04:	2201      	movs	r2, #1
34006a06:	2101      	movs	r1, #1
34006a08:	4618      	mov	r0, r3
34006a0a:	f7fd fc53 	bl	340042b4 <MX66UW1G45G_AutoPollingMemReady>
34006a0e:	4603      	mov	r3, r0
34006a10:	2b00      	cmp	r3, #0
34006a12:	d003      	beq.n	34006a1c <XSPI_NOR_EnterDOPIMode+0x184>
                                              BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006a14:	f06f 0304 	mvn.w	r3, #4
34006a18:	60fb      	str	r3, [r7, #12]
34006a1a:	e01d      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    /* Check the configuration has been correctly done */
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
34006a1c:	687b      	ldr	r3, [r7, #4]
34006a1e:	2264      	movs	r2, #100	@ 0x64
34006a20:	fb02 f303 	mul.w	r3, r2, r3
34006a24:	4a0f      	ldr	r2, [pc, #60]	@ (34006a64 <XSPI_NOR_EnterDOPIMode+0x1cc>)
34006a26:	1898      	adds	r0, r3, r2
34006a28:	f107 0308 	add.w	r3, r7, #8
34006a2c:	9300      	str	r3, [sp, #0]
34006a2e:	2300      	movs	r3, #0
34006a30:	2201      	movs	r2, #1
34006a32:	2101      	movs	r1, #1
34006a34:	f7fd ff5e 	bl	340048f4 <MX66UW1G45G_ReadCfg2Register>
34006a38:	4603      	mov	r3, r0
34006a3a:	2b00      	cmp	r3, #0
34006a3c:	d003      	beq.n	34006a46 <XSPI_NOR_EnterDOPIMode+0x1ae>
                                           MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006a3e:	f06f 0304 	mvn.w	r3, #4
34006a42:	60fb      	str	r3, [r7, #12]
34006a44:	e008      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    else if (reg[0] != MX66UW1G45G_CR2_DOPI)
34006a46:	7a3b      	ldrb	r3, [r7, #8]
34006a48:	2b02      	cmp	r3, #2
34006a4a:	d003      	beq.n	34006a54 <XSPI_NOR_EnterDOPIMode+0x1bc>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006a4c:	f06f 0304 	mvn.w	r3, #4
34006a50:	60fb      	str	r3, [r7, #12]
34006a52:	e001      	b.n	34006a58 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    else
    {
      ret = BSP_ERROR_NONE;
34006a54:	2300      	movs	r3, #0
34006a56:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
34006a58:	68fb      	ldr	r3, [r7, #12]
}
34006a5a:	4618      	mov	r0, r3
34006a5c:	3714      	adds	r7, #20
34006a5e:	46bd      	mov	sp, r7
34006a60:	bd90      	pop	{r4, r7, pc}
34006a62:	bf00      	nop
34006a64:	34053af8 	.word	0x34053af8
34006a68:	34053b5c 	.word	0x34053b5c

34006a6c <XSPI_NOR_EnterSOPIMode>:
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
{
34006a6c:	b590      	push	{r4, r7, lr}
34006a6e:	b087      	sub	sp, #28
34006a70:	af02      	add	r7, sp, #8
34006a72:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006a74:	687b      	ldr	r3, [r7, #4]
34006a76:	2264      	movs	r2, #100	@ 0x64
34006a78:	fb02 f303 	mul.w	r3, r2, r3
34006a7c:	4a5c      	ldr	r2, [pc, #368]	@ (34006bf0 <XSPI_NOR_EnterSOPIMode+0x184>)
34006a7e:	1898      	adds	r0, r3, r2
34006a80:	495c      	ldr	r1, [pc, #368]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006a82:	687a      	ldr	r2, [r7, #4]
34006a84:	4613      	mov	r3, r2
34006a86:	005b      	lsls	r3, r3, #1
34006a88:	4413      	add	r3, r2
34006a8a:	440b      	add	r3, r1
34006a8c:	3301      	adds	r3, #1
34006a8e:	7819      	ldrb	r1, [r3, #0]
34006a90:	4c58      	ldr	r4, [pc, #352]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006a92:	687a      	ldr	r2, [r7, #4]
34006a94:	4613      	mov	r3, r2
34006a96:	005b      	lsls	r3, r3, #1
34006a98:	4413      	add	r3, r2
34006a9a:	4423      	add	r3, r4
34006a9c:	3302      	adds	r3, #2
34006a9e:	781b      	ldrb	r3, [r3, #0]
34006aa0:	461a      	mov	r2, r3
34006aa2:	f7fd fdca 	bl	3400463a <MX66UW1G45G_WriteEnable>
34006aa6:	4603      	mov	r3, r0
34006aa8:	2b00      	cmp	r3, #0
34006aaa:	d003      	beq.n	34006ab4 <XSPI_NOR_EnterSOPIMode+0x48>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006aac:	f06f 0304 	mvn.w	r3, #4
34006ab0:	60fb      	str	r3, [r7, #12]
34006ab2:	e097      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006ab4:	687b      	ldr	r3, [r7, #4]
34006ab6:	2264      	movs	r2, #100	@ 0x64
34006ab8:	fb02 f303 	mul.w	r3, r2, r3
34006abc:	4a4c      	ldr	r2, [pc, #304]	@ (34006bf0 <XSPI_NOR_EnterSOPIMode+0x184>)
34006abe:	1898      	adds	r0, r3, r2
34006ac0:	494c      	ldr	r1, [pc, #304]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006ac2:	687a      	ldr	r2, [r7, #4]
34006ac4:	4613      	mov	r3, r2
34006ac6:	005b      	lsls	r3, r3, #1
34006ac8:	4413      	add	r3, r2
34006aca:	440b      	add	r3, r1
34006acc:	3301      	adds	r3, #1
34006ace:	7819      	ldrb	r1, [r3, #0]
34006ad0:	4c48      	ldr	r4, [pc, #288]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006ad2:	687a      	ldr	r2, [r7, #4]
34006ad4:	4613      	mov	r3, r2
34006ad6:	005b      	lsls	r3, r3, #1
34006ad8:	4413      	add	r3, r2
34006ada:	4423      	add	r3, r4
34006adc:	3302      	adds	r3, #2
34006ade:	781a      	ldrb	r2, [r3, #0]
34006ae0:	2300      	movs	r3, #0
34006ae2:	9300      	str	r3, [sp, #0]
34006ae4:	f44f 7340 	mov.w	r3, #768	@ 0x300
34006ae8:	f7fd fe73 	bl	340047d2 <MX66UW1G45G_WriteCfg2Register>
34006aec:	4603      	mov	r3, r0
34006aee:	2b00      	cmp	r3, #0
34006af0:	d003      	beq.n	34006afa <XSPI_NOR_EnterSOPIMode+0x8e>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG3_ADDR,
                                          MX66UW1G45G_CR2_DC_20_CYCLES) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006af2:	f06f 0304 	mvn.w	r3, #4
34006af6:	60fb      	str	r3, [r7, #12]
34006af8:	e074      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Enable write operations */
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006afa:	687b      	ldr	r3, [r7, #4]
34006afc:	2264      	movs	r2, #100	@ 0x64
34006afe:	fb02 f303 	mul.w	r3, r2, r3
34006b02:	4a3b      	ldr	r2, [pc, #236]	@ (34006bf0 <XSPI_NOR_EnterSOPIMode+0x184>)
34006b04:	1898      	adds	r0, r3, r2
34006b06:	493b      	ldr	r1, [pc, #236]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006b08:	687a      	ldr	r2, [r7, #4]
34006b0a:	4613      	mov	r3, r2
34006b0c:	005b      	lsls	r3, r3, #1
34006b0e:	4413      	add	r3, r2
34006b10:	440b      	add	r3, r1
34006b12:	3301      	adds	r3, #1
34006b14:	7819      	ldrb	r1, [r3, #0]
34006b16:	4c37      	ldr	r4, [pc, #220]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006b18:	687a      	ldr	r2, [r7, #4]
34006b1a:	4613      	mov	r3, r2
34006b1c:	005b      	lsls	r3, r3, #1
34006b1e:	4413      	add	r3, r2
34006b20:	4423      	add	r3, r4
34006b22:	3302      	adds	r3, #2
34006b24:	781b      	ldrb	r3, [r3, #0]
34006b26:	461a      	mov	r2, r3
34006b28:	f7fd fd87 	bl	3400463a <MX66UW1G45G_WriteEnable>
34006b2c:	4603      	mov	r3, r0
34006b2e:	2b00      	cmp	r3, #0
34006b30:	d003      	beq.n	34006b3a <XSPI_NOR_EnterSOPIMode+0xce>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006b32:	f06f 0304 	mvn.w	r3, #4
34006b36:	60fb      	str	r3, [r7, #12]
34006b38:	e054      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006b3a:	687b      	ldr	r3, [r7, #4]
34006b3c:	2264      	movs	r2, #100	@ 0x64
34006b3e:	fb02 f303 	mul.w	r3, r2, r3
34006b42:	4a2b      	ldr	r2, [pc, #172]	@ (34006bf0 <XSPI_NOR_EnterSOPIMode+0x184>)
34006b44:	1898      	adds	r0, r3, r2
34006b46:	492b      	ldr	r1, [pc, #172]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006b48:	687a      	ldr	r2, [r7, #4]
34006b4a:	4613      	mov	r3, r2
34006b4c:	005b      	lsls	r3, r3, #1
34006b4e:	4413      	add	r3, r2
34006b50:	440b      	add	r3, r1
34006b52:	3301      	adds	r3, #1
34006b54:	7819      	ldrb	r1, [r3, #0]
34006b56:	4c27      	ldr	r4, [pc, #156]	@ (34006bf4 <XSPI_NOR_EnterSOPIMode+0x188>)
34006b58:	687a      	ldr	r2, [r7, #4]
34006b5a:	4613      	mov	r3, r2
34006b5c:	005b      	lsls	r3, r3, #1
34006b5e:	4413      	add	r3, r2
34006b60:	4423      	add	r3, r4
34006b62:	3302      	adds	r3, #2
34006b64:	781a      	ldrb	r2, [r3, #0]
34006b66:	2301      	movs	r3, #1
34006b68:	9300      	str	r3, [sp, #0]
34006b6a:	2300      	movs	r3, #0
34006b6c:	f7fd fe31 	bl	340047d2 <MX66UW1G45G_WriteCfg2Register>
34006b70:	4603      	mov	r3, r0
34006b72:	2b00      	cmp	r3, #0
34006b74:	d003      	beq.n	34006b7e <XSPI_NOR_EnterSOPIMode+0x112>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                          MX66UW1G45G_CR2_SOPI) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006b76:	f06f 0304 	mvn.w	r3, #4
34006b7a:	60fb      	str	r3, [r7, #12]
34006b7c:	e032      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34006b7e:	2028      	movs	r0, #40	@ 0x28
34006b80:	f000 fd3a 	bl	340075f8 <HAL_Delay>

    /* Check Flash busy ? */
    if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34006b84:	687b      	ldr	r3, [r7, #4]
34006b86:	2264      	movs	r2, #100	@ 0x64
34006b88:	fb02 f303 	mul.w	r3, r2, r3
34006b8c:	4a18      	ldr	r2, [pc, #96]	@ (34006bf0 <XSPI_NOR_EnterSOPIMode+0x184>)
34006b8e:	4413      	add	r3, r2
34006b90:	2200      	movs	r2, #0
34006b92:	2101      	movs	r1, #1
34006b94:	4618      	mov	r0, r3
34006b96:	f7fd fb8d 	bl	340042b4 <MX66UW1G45G_AutoPollingMemReady>
34006b9a:	4603      	mov	r3, r0
34006b9c:	2b00      	cmp	r3, #0
34006b9e:	d003      	beq.n	34006ba8 <XSPI_NOR_EnterSOPIMode+0x13c>
                                         BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006ba0:	f06f 0304 	mvn.w	r3, #4
34006ba4:	60fb      	str	r3, [r7, #12]
34006ba6:	e01d      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
    }
    /* Check the configuration has been correctly done */
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34006ba8:	687b      	ldr	r3, [r7, #4]
34006baa:	2264      	movs	r2, #100	@ 0x64
34006bac:	fb02 f303 	mul.w	r3, r2, r3
34006bb0:	4a0f      	ldr	r2, [pc, #60]	@ (34006bf0 <XSPI_NOR_EnterSOPIMode+0x184>)
34006bb2:	1898      	adds	r0, r3, r2
34006bb4:	f107 0308 	add.w	r3, r7, #8
34006bb8:	9300      	str	r3, [sp, #0]
34006bba:	2300      	movs	r3, #0
34006bbc:	2200      	movs	r2, #0
34006bbe:	2101      	movs	r1, #1
34006bc0:	f7fd fe98 	bl	340048f4 <MX66UW1G45G_ReadCfg2Register>
34006bc4:	4603      	mov	r3, r0
34006bc6:	2b00      	cmp	r3, #0
34006bc8:	d003      	beq.n	34006bd2 <XSPI_NOR_EnterSOPIMode+0x166>
                                           MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006bca:	f06f 0304 	mvn.w	r3, #4
34006bce:	60fb      	str	r3, [r7, #12]
34006bd0:	e008      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
    }
    else if (reg[0] != MX66UW1G45G_CR2_SOPI)
34006bd2:	7a3b      	ldrb	r3, [r7, #8]
34006bd4:	2b01      	cmp	r3, #1
34006bd6:	d003      	beq.n	34006be0 <XSPI_NOR_EnterSOPIMode+0x174>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006bd8:	f06f 0304 	mvn.w	r3, #4
34006bdc:	60fb      	str	r3, [r7, #12]
34006bde:	e001      	b.n	34006be4 <XSPI_NOR_EnterSOPIMode+0x178>
    }
    else
    {
      ret = BSP_ERROR_NONE;
34006be0:	2300      	movs	r3, #0
34006be2:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
34006be4:	68fb      	ldr	r3, [r7, #12]
}
34006be6:	4618      	mov	r0, r3
34006be8:	3714      	adds	r7, #20
34006bea:	46bd      	mov	sp, r7
34006bec:	bd90      	pop	{r4, r7, pc}
34006bee:	bf00      	nop
34006bf0:	34053af8 	.word	0x34053af8
34006bf4:	34053b5c 	.word	0x34053b5c

34006bf8 <XSPI_NOR_ExitOPIMode>:
  * @brief  This function disables the octal DTR or STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
34006bf8:	b590      	push	{r4, r7, lr}
34006bfa:	b087      	sub	sp, #28
34006bfc:	af02      	add	r7, sp, #8
34006bfe:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34006c00:	2300      	movs	r3, #0
34006c02:	60fb      	str	r3, [r7, #12]
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006c04:	687b      	ldr	r3, [r7, #4]
34006c06:	2264      	movs	r2, #100	@ 0x64
34006c08:	fb02 f303 	mul.w	r3, r2, r3
34006c0c:	4a52      	ldr	r2, [pc, #328]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006c0e:	1898      	adds	r0, r3, r2
34006c10:	4952      	ldr	r1, [pc, #328]	@ (34006d5c <XSPI_NOR_ExitOPIMode+0x164>)
34006c12:	687a      	ldr	r2, [r7, #4]
34006c14:	4613      	mov	r3, r2
34006c16:	005b      	lsls	r3, r3, #1
34006c18:	4413      	add	r3, r2
34006c1a:	440b      	add	r3, r1
34006c1c:	3301      	adds	r3, #1
34006c1e:	7819      	ldrb	r1, [r3, #0]
34006c20:	4c4e      	ldr	r4, [pc, #312]	@ (34006d5c <XSPI_NOR_ExitOPIMode+0x164>)
34006c22:	687a      	ldr	r2, [r7, #4]
34006c24:	4613      	mov	r3, r2
34006c26:	005b      	lsls	r3, r3, #1
34006c28:	4413      	add	r3, r2
34006c2a:	4423      	add	r3, r4
34006c2c:	3302      	adds	r3, #2
34006c2e:	781b      	ldrb	r3, [r3, #0]
34006c30:	461a      	mov	r2, r3
34006c32:	f7fd fd02 	bl	3400463a <MX66UW1G45G_WriteEnable>
34006c36:	4603      	mov	r3, r0
34006c38:	2b00      	cmp	r3, #0
34006c3a:	d003      	beq.n	34006c44 <XSPI_NOR_ExitOPIMode+0x4c>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34006c3c:	f06f 0304 	mvn.w	r3, #4
34006c40:	60fb      	str	r3, [r7, #12]
34006c42:	e083      	b.n	34006d4c <XSPI_NOR_ExitOPIMode+0x154>
  }
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
34006c44:	2300      	movs	r3, #0
34006c46:	723b      	strb	r3, [r7, #8]
    reg[1] = 0;
34006c48:	2300      	movs	r3, #0
34006c4a:	727b      	strb	r3, [r7, #9]
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34006c4c:	687b      	ldr	r3, [r7, #4]
34006c4e:	2264      	movs	r2, #100	@ 0x64
34006c50:	fb02 f303 	mul.w	r3, r2, r3
34006c54:	4a40      	ldr	r2, [pc, #256]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006c56:	1898      	adds	r0, r3, r2
34006c58:	4940      	ldr	r1, [pc, #256]	@ (34006d5c <XSPI_NOR_ExitOPIMode+0x164>)
34006c5a:	687a      	ldr	r2, [r7, #4]
34006c5c:	4613      	mov	r3, r2
34006c5e:	005b      	lsls	r3, r3, #1
34006c60:	4413      	add	r3, r2
34006c62:	440b      	add	r3, r1
34006c64:	3301      	adds	r3, #1
34006c66:	7819      	ldrb	r1, [r3, #0]
34006c68:	4c3c      	ldr	r4, [pc, #240]	@ (34006d5c <XSPI_NOR_ExitOPIMode+0x164>)
34006c6a:	687a      	ldr	r2, [r7, #4]
34006c6c:	4613      	mov	r3, r2
34006c6e:	005b      	lsls	r3, r3, #1
34006c70:	4413      	add	r3, r2
34006c72:	4423      	add	r3, r4
34006c74:	3302      	adds	r3, #2
34006c76:	781a      	ldrb	r2, [r3, #0]
34006c78:	7a3b      	ldrb	r3, [r7, #8]
34006c7a:	9300      	str	r3, [sp, #0]
34006c7c:	2300      	movs	r3, #0
34006c7e:	f7fd fda8 	bl	340047d2 <MX66UW1G45G_WriteCfg2Register>
34006c82:	4603      	mov	r3, r0
34006c84:	2b00      	cmp	r3, #0
34006c86:	d003      	beq.n	34006c90 <XSPI_NOR_ExitOPIMode+0x98>
                                       XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                       reg[0]) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34006c88:	f06f 0304 	mvn.w	r3, #4
34006c8c:	60fb      	str	r3, [r7, #12]
34006c8e:	e05d      	b.n	34006d4c <XSPI_NOR_ExitOPIMode+0x154>
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34006c90:	2028      	movs	r0, #40	@ 0x28
34006c92:	f000 fcb1 	bl	340075f8 <HAL_Delay>

      if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
34006c96:	4931      	ldr	r1, [pc, #196]	@ (34006d5c <XSPI_NOR_ExitOPIMode+0x164>)
34006c98:	687a      	ldr	r2, [r7, #4]
34006c9a:	4613      	mov	r3, r2
34006c9c:	005b      	lsls	r3, r3, #1
34006c9e:	4413      	add	r3, r2
34006ca0:	440b      	add	r3, r1
34006ca2:	3302      	adds	r3, #2
34006ca4:	781b      	ldrb	r3, [r3, #0]
34006ca6:	2b01      	cmp	r3, #1
34006ca8:	d120      	bne.n	34006cec <XSPI_NOR_ExitOPIMode+0xf4>
      {
        /* Reconfigure the memory type of the peripheral */
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
34006caa:	4a2b      	ldr	r2, [pc, #172]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006cac:	687b      	ldr	r3, [r7, #4]
34006cae:	2164      	movs	r1, #100	@ 0x64
34006cb0:	fb01 f303 	mul.w	r3, r1, r3
34006cb4:	4413      	add	r3, r2
34006cb6:	330c      	adds	r3, #12
34006cb8:	2200      	movs	r2, #0
34006cba:	601a      	str	r2, [r3, #0]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34006cbc:	4a26      	ldr	r2, [pc, #152]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006cbe:	687b      	ldr	r3, [r7, #4]
34006cc0:	2164      	movs	r1, #100	@ 0x64
34006cc2:	fb01 f303 	mul.w	r3, r1, r3
34006cc6:	4413      	add	r3, r2
34006cc8:	332c      	adds	r3, #44	@ 0x2c
34006cca:	2200      	movs	r2, #0
34006ccc:	601a      	str	r2, [r3, #0]
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34006cce:	687b      	ldr	r3, [r7, #4]
34006cd0:	2264      	movs	r2, #100	@ 0x64
34006cd2:	fb02 f303 	mul.w	r3, r2, r3
34006cd6:	4a20      	ldr	r2, [pc, #128]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006cd8:	4413      	add	r3, r2
34006cda:	4618      	mov	r0, r3
34006cdc:	f014 f928 	bl	3401af30 <HAL_XSPI_Init>
34006ce0:	4603      	mov	r3, r0
34006ce2:	2b00      	cmp	r3, #0
34006ce4:	d002      	beq.n	34006cec <XSPI_NOR_ExitOPIMode+0xf4>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34006ce6:	f06f 0303 	mvn.w	r3, #3
34006cea:	60fb      	str	r3, [r7, #12]
        }
      }

      if (ret == BSP_ERROR_NONE)
34006cec:	68fb      	ldr	r3, [r7, #12]
34006cee:	2b00      	cmp	r3, #0
34006cf0:	d12c      	bne.n	34006d4c <XSPI_NOR_ExitOPIMode+0x154>
      {
        /* Check Flash busy ? */
        if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34006cf2:	687b      	ldr	r3, [r7, #4]
34006cf4:	2264      	movs	r2, #100	@ 0x64
34006cf6:	fb02 f303 	mul.w	r3, r2, r3
34006cfa:	4a17      	ldr	r2, [pc, #92]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006cfc:	4413      	add	r3, r2
34006cfe:	2200      	movs	r2, #0
34006d00:	2100      	movs	r1, #0
34006d02:	4618      	mov	r0, r3
34006d04:	f7fd fad6 	bl	340042b4 <MX66UW1G45G_AutoPollingMemReady>
34006d08:	4603      	mov	r3, r0
34006d0a:	2b00      	cmp	r3, #0
34006d0c:	d003      	beq.n	34006d16 <XSPI_NOR_ExitOPIMode+0x11e>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34006d0e:	f06f 0304 	mvn.w	r3, #4
34006d12:	60fb      	str	r3, [r7, #12]
34006d14:	e01a      	b.n	34006d4c <XSPI_NOR_ExitOPIMode+0x154>
        }
        /* Check the configuration has been correctly done */
        else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34006d16:	687b      	ldr	r3, [r7, #4]
34006d18:	2264      	movs	r2, #100	@ 0x64
34006d1a:	fb02 f303 	mul.w	r3, r2, r3
34006d1e:	4a0e      	ldr	r2, [pc, #56]	@ (34006d58 <XSPI_NOR_ExitOPIMode+0x160>)
34006d20:	1898      	adds	r0, r3, r2
34006d22:	f107 0308 	add.w	r3, r7, #8
34006d26:	9300      	str	r3, [sp, #0]
34006d28:	2300      	movs	r3, #0
34006d2a:	2200      	movs	r2, #0
34006d2c:	2100      	movs	r1, #0
34006d2e:	f7fd fde1 	bl	340048f4 <MX66UW1G45G_ReadCfg2Register>
34006d32:	4603      	mov	r3, r0
34006d34:	2b00      	cmp	r3, #0
34006d36:	d003      	beq.n	34006d40 <XSPI_NOR_ExitOPIMode+0x148>
                                               MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34006d38:	f06f 0304 	mvn.w	r3, #4
34006d3c:	60fb      	str	r3, [r7, #12]
34006d3e:	e005      	b.n	34006d4c <XSPI_NOR_ExitOPIMode+0x154>
        }
        else if (reg[0] != 0U)
34006d40:	7a3b      	ldrb	r3, [r7, #8]
34006d42:	2b00      	cmp	r3, #0
34006d44:	d002      	beq.n	34006d4c <XSPI_NOR_ExitOPIMode+0x154>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34006d46:	f06f 0304 	mvn.w	r3, #4
34006d4a:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  /* Return BSP status */
  return ret;
34006d4c:	68fb      	ldr	r3, [r7, #12]
}
34006d4e:	4618      	mov	r0, r3
34006d50:	3714      	adds	r7, #20
34006d52:	46bd      	mov	sp, r7
34006d54:	bd90      	pop	{r4, r7, pc}
34006d56:	bf00      	nop
34006d58:	34053af8 	.word	0x34053af8
34006d5c:	34053b5c 	.word	0x34053b5c

34006d60 <XSPI_RAM_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_RAM_MspInit(const XSPI_HandleTypeDef *hxspi)
{
34006d60:	b580      	push	{r7, lr}
34006d62:	b088      	sub	sp, #32
34006d64:	af00      	add	r7, sp, #0
34006d66:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

 /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
34006d68:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34006d6c:	f7ff f90e 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO2();
34006d70:	f004 f9bc 	bl	3400b0ec <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2, PWR_VDDIO_RANGE_1V8);
34006d74:	2101      	movs	r1, #1
34006d76:	2001      	movs	r0, #1
34006d78:	f004 f948 	bl	3400b00c <HAL_PWREx_ConfigVddIORange>

  /* Enable the XSPI memory interface clock */
  XSPI_RAM_CLK_ENABLE();
34006d7c:	2020      	movs	r0, #32
34006d7e:	f7ff f91b 	bl	34005fb8 <LL_AHB5_GRP1_EnableClock>

  /* Reset the XSPI memory interface */
  XSPI_RAM_FORCE_RESET();
34006d82:	2020      	movs	r0, #32
34006d84:	f7ff f92e 	bl	34005fe4 <LL_AHB5_GRP1_ForceReset>
  XSPI_RAM_RELEASE_RESET();
34006d88:	2020      	movs	r0, #32
34006d8a:	f7ff f93b 	bl	34006004 <LL_AHB5_GRP1_ReleaseReset>

  /* Enable and reset XSPI I/O Manager */
  __HAL_RCC_XSPIM_CLK_ENABLE();
34006d8e:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006d92:	f7ff f911 	bl	34005fb8 <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_XSPIM_FORCE_RESET();
34006d96:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006d9a:	f7ff f923 	bl	34005fe4 <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_XSPIM_RELEASE_RESET();
34006d9e:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34006da2:	f7ff f92f 	bl	34006004 <LL_AHB5_GRP1_ReleaseReset>

  /* Enable GPIO clocks */
  XSPI_RAM_CLK_GPIO_CLK_ENABLE();
34006da6:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34006daa:	f7ff f8ef 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_DQS_GPIO_CLK_ENABLE();
34006dae:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34006db2:	f7ff f8eb 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_CS_GPIO_CLK_ENABLE();
34006db6:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34006dba:	f7ff f8e7 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D0_GPIO_CLK_ENABLE();
34006dbe:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006dc2:	f7ff f8e3 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D1_GPIO_CLK_ENABLE();
34006dc6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006dca:	f7ff f8df 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D2_GPIO_CLK_ENABLE();
34006dce:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006dd2:	f7ff f8db 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D3_GPIO_CLK_ENABLE();
34006dd6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006dda:	f7ff f8d7 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D4_GPIO_CLK_ENABLE();
34006dde:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006de2:	f7ff f8d3 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D5_GPIO_CLK_ENABLE();
34006de6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006dea:	f7ff f8cf 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D6_GPIO_CLK_ENABLE();
34006dee:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006df2:	f7ff f8cb 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D7_GPIO_CLK_ENABLE();
34006df6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34006dfa:	f7ff f8c7 	bl	34005f8c <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CS_PIN;
34006dfe:	2301      	movs	r3, #1
34006e00:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34006e02:	2302      	movs	r3, #2
34006e04:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34006e06:	2301      	movs	r3, #1
34006e08:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34006e0a:	2303      	movs	r3, #3
34006e0c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
34006e0e:	2309      	movs	r3, #9
34006e10:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
34006e12:	f107 030c 	add.w	r3, r7, #12
34006e16:	4619      	mov	r1, r3
34006e18:	486a      	ldr	r0, [pc, #424]	@ (34006fc4 <XSPI_RAM_MspInit+0x264>)
34006e1a:	f002 fad9 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI DQS0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
34006e1e:	2304      	movs	r3, #4
34006e20:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
34006e22:	2309      	movs	r3, #9
34006e24:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34006e26:	2301      	movs	r3, #1
34006e28:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
34006e2a:	f107 030c 	add.w	r3, r7, #12
34006e2e:	4619      	mov	r1, r3
34006e30:	4864      	ldr	r0, [pc, #400]	@ (34006fc4 <XSPI_RAM_MspInit+0x264>)
34006e32:	f002 facd 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI DQS1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
34006e36:	2308      	movs	r3, #8
34006e38:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
34006e3a:	2309      	movs	r3, #9
34006e3c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34006e3e:	2301      	movs	r3, #1
34006e40:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
34006e42:	f107 030c 	add.w	r3, r7, #12
34006e46:	4619      	mov	r1, r3
34006e48:	485e      	ldr	r0, [pc, #376]	@ (34006fc4 <XSPI_RAM_MspInit+0x264>)
34006e4a:	f002 fac1 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
34006e4e:	2310      	movs	r3, #16
34006e50:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34006e52:	2301      	movs	r3, #1
34006e54:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
34006e56:	2309      	movs	r3, #9
34006e58:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
34006e5a:	f107 030c 	add.w	r3, r7, #12
34006e5e:	4619      	mov	r1, r3
34006e60:	4858      	ldr	r0, [pc, #352]	@ (34006fc4 <XSPI_RAM_MspInit+0x264>)
34006e62:	f002 fab5 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
34006e66:	2301      	movs	r3, #1
34006e68:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
34006e6a:	2309      	movs	r3, #9
34006e6c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34006e6e:	2301      	movs	r3, #1
34006e70:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
34006e72:	f107 030c 	add.w	r3, r7, #12
34006e76:	4619      	mov	r1, r3
34006e78:	4853      	ldr	r0, [pc, #332]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006e7a:	f002 faa9 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
34006e7e:	2302      	movs	r3, #2
34006e80:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
34006e82:	2309      	movs	r3, #9
34006e84:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
34006e86:	f107 030c 	add.w	r3, r7, #12
34006e8a:	4619      	mov	r1, r3
34006e8c:	484e      	ldr	r0, [pc, #312]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006e8e:	f002 fa9f 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
34006e92:	2304      	movs	r3, #4
34006e94:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
34006e96:	2309      	movs	r3, #9
34006e98:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
34006e9a:	f107 030c 	add.w	r3, r7, #12
34006e9e:	4619      	mov	r1, r3
34006ea0:	4849      	ldr	r0, [pc, #292]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006ea2:	f002 fa95 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
34006ea6:	2308      	movs	r3, #8
34006ea8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
34006eaa:	2309      	movs	r3, #9
34006eac:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
34006eae:	f107 030c 	add.w	r3, r7, #12
34006eb2:	4619      	mov	r1, r3
34006eb4:	4844      	ldr	r0, [pc, #272]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006eb6:	f002 fa8b 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
34006eba:	2310      	movs	r3, #16
34006ebc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
34006ebe:	2309      	movs	r3, #9
34006ec0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
34006ec2:	f107 030c 	add.w	r3, r7, #12
34006ec6:	4619      	mov	r1, r3
34006ec8:	483f      	ldr	r0, [pc, #252]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006eca:	f002 fa81 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
34006ece:	2320      	movs	r3, #32
34006ed0:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
34006ed2:	2309      	movs	r3, #9
34006ed4:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
34006ed6:	f107 030c 	add.w	r3, r7, #12
34006eda:	4619      	mov	r1, r3
34006edc:	483a      	ldr	r0, [pc, #232]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006ede:	f002 fa77 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
34006ee2:	2340      	movs	r3, #64	@ 0x40
34006ee4:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
34006ee6:	2309      	movs	r3, #9
34006ee8:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34006eea:	f107 030c 	add.w	r3, r7, #12
34006eee:	4619      	mov	r1, r3
34006ef0:	4835      	ldr	r0, [pc, #212]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006ef2:	f002 fa6d 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
34006ef6:	2380      	movs	r3, #128	@ 0x80
34006ef8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
34006efa:	2309      	movs	r3, #9
34006efc:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
34006efe:	f107 030c 	add.w	r3, r7, #12
34006f02:	4619      	mov	r1, r3
34006f04:	4830      	ldr	r0, [pc, #192]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f06:	f002 fa63 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D8 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
34006f0a:	f44f 7380 	mov.w	r3, #256	@ 0x100
34006f0e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
34006f10:	2309      	movs	r3, #9
34006f12:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
34006f14:	f107 030c 	add.w	r3, r7, #12
34006f18:	4619      	mov	r1, r3
34006f1a:	482b      	ldr	r0, [pc, #172]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f1c:	f002 fa58 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D9 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
34006f20:	f44f 7300 	mov.w	r3, #512	@ 0x200
34006f24:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
34006f26:	2309      	movs	r3, #9
34006f28:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
34006f2a:	f107 030c 	add.w	r3, r7, #12
34006f2e:	4619      	mov	r1, r3
34006f30:	4825      	ldr	r0, [pc, #148]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f32:	f002 fa4d 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D10 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
34006f36:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34006f3a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
34006f3c:	2309      	movs	r3, #9
34006f3e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
34006f40:	f107 030c 	add.w	r3, r7, #12
34006f44:	4619      	mov	r1, r3
34006f46:	4820      	ldr	r0, [pc, #128]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f48:	f002 fa42 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D11 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
34006f4c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34006f50:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
34006f52:	2309      	movs	r3, #9
34006f54:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
34006f56:	f107 030c 	add.w	r3, r7, #12
34006f5a:	4619      	mov	r1, r3
34006f5c:	481a      	ldr	r0, [pc, #104]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f5e:	f002 fa37 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D12 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
34006f62:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34006f66:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
34006f68:	2309      	movs	r3, #9
34006f6a:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
34006f6c:	f107 030c 	add.w	r3, r7, #12
34006f70:	4619      	mov	r1, r3
34006f72:	4815      	ldr	r0, [pc, #84]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f74:	f002 fa2c 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D13 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
34006f78:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34006f7c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
34006f7e:	2309      	movs	r3, #9
34006f80:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
34006f82:	f107 030c 	add.w	r3, r7, #12
34006f86:	4619      	mov	r1, r3
34006f88:	480f      	ldr	r0, [pc, #60]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006f8a:	f002 fa21 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D14 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34006f8e:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34006f92:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
34006f94:	2309      	movs	r3, #9
34006f96:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
34006f98:	f107 030c 	add.w	r3, r7, #12
34006f9c:	4619      	mov	r1, r3
34006f9e:	480a      	ldr	r0, [pc, #40]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006fa0:	f002 fa16 	bl	340093d0 <HAL_GPIO_Init>

  /* XSPI D15 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
34006fa4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34006fa8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
34006faa:	2309      	movs	r3, #9
34006fac:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
34006fae:	f107 030c 	add.w	r3, r7, #12
34006fb2:	4619      	mov	r1, r3
34006fb4:	4804      	ldr	r0, [pc, #16]	@ (34006fc8 <XSPI_RAM_MspInit+0x268>)
34006fb6:	f002 fa0b 	bl	340093d0 <HAL_GPIO_Init>
}
34006fba:	bf00      	nop
34006fbc:	3720      	adds	r7, #32
34006fbe:	46bd      	mov	sp, r7
34006fc0:	bd80      	pop	{r7, pc}
34006fc2:	bf00      	nop
34006fc4:	56023800 	.word	0x56023800
34006fc8:	56023c00 	.word	0x56023c00

34006fcc <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34006fcc:	b480      	push	{r7}
34006fce:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34006fd0:	4b6a      	ldr	r3, [pc, #424]	@ (3400717c <SystemInit+0x1b0>)
34006fd2:	4a6b      	ldr	r2, [pc, #428]	@ (34007180 <SystemInit+0x1b4>)
34006fd4:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34006fd6:	4b6b      	ldr	r3, [pc, #428]	@ (34007184 <SystemInit+0x1b8>)
34006fd8:	2201      	movs	r2, #1
34006fda:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34006fde:	4b69      	ldr	r3, [pc, #420]	@ (34007184 <SystemInit+0x1b8>)
34006fe0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34006fe4:	461a      	mov	r2, r3
34006fe6:	2301      	movs	r3, #1
34006fe8:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34006fec:	4b65      	ldr	r3, [pc, #404]	@ (34007184 <SystemInit+0x1b8>)
34006fee:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34006ff2:	461a      	mov	r2, r3
34006ff4:	2301      	movs	r3, #1
34006ff6:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
34006ffa:	4b63      	ldr	r3, [pc, #396]	@ (34007188 <SystemInit+0x1bc>)
34006ffc:	2200      	movs	r2, #0
34006ffe:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34007000:	4b61      	ldr	r3, [pc, #388]	@ (34007188 <SystemInit+0x1bc>)
34007002:	2200      	movs	r2, #0
34007004:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34007006:	4b60      	ldr	r3, [pc, #384]	@ (34007188 <SystemInit+0x1bc>)
34007008:	2200      	movs	r2, #0
3400700a:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
3400700c:	4b5e      	ldr	r3, [pc, #376]	@ (34007188 <SystemInit+0x1bc>)
3400700e:	2201      	movs	r2, #1
34007010:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34007012:	4b5d      	ldr	r3, [pc, #372]	@ (34007188 <SystemInit+0x1bc>)
34007014:	2200      	movs	r2, #0
34007016:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34007018:	4b5b      	ldr	r3, [pc, #364]	@ (34007188 <SystemInit+0x1bc>)
3400701a:	2200      	movs	r2, #0
3400701c:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
3400701e:	4b5a      	ldr	r3, [pc, #360]	@ (34007188 <SystemInit+0x1bc>)
34007020:	2202      	movs	r2, #2
34007022:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34007024:	4b58      	ldr	r3, [pc, #352]	@ (34007188 <SystemInit+0x1bc>)
34007026:	2200      	movs	r2, #0
34007028:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3400702a:	4b57      	ldr	r3, [pc, #348]	@ (34007188 <SystemInit+0x1bc>)
3400702c:	2200      	movs	r2, #0
3400702e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
34007030:	4b55      	ldr	r3, [pc, #340]	@ (34007188 <SystemInit+0x1bc>)
34007032:	2203      	movs	r2, #3
34007034:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34007036:	4b54      	ldr	r3, [pc, #336]	@ (34007188 <SystemInit+0x1bc>)
34007038:	2200      	movs	r2, #0
3400703a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3400703c:	4b52      	ldr	r3, [pc, #328]	@ (34007188 <SystemInit+0x1bc>)
3400703e:	2200      	movs	r2, #0
34007040:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
34007042:	4b51      	ldr	r3, [pc, #324]	@ (34007188 <SystemInit+0x1bc>)
34007044:	2204      	movs	r2, #4
34007046:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34007048:	4b4f      	ldr	r3, [pc, #316]	@ (34007188 <SystemInit+0x1bc>)
3400704a:	2200      	movs	r2, #0
3400704c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3400704e:	4b4e      	ldr	r3, [pc, #312]	@ (34007188 <SystemInit+0x1bc>)
34007050:	2200      	movs	r2, #0
34007052:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
34007054:	4b4c      	ldr	r3, [pc, #304]	@ (34007188 <SystemInit+0x1bc>)
34007056:	2205      	movs	r2, #5
34007058:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3400705a:	4b4b      	ldr	r3, [pc, #300]	@ (34007188 <SystemInit+0x1bc>)
3400705c:	2200      	movs	r2, #0
3400705e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34007060:	4b49      	ldr	r3, [pc, #292]	@ (34007188 <SystemInit+0x1bc>)
34007062:	2200      	movs	r2, #0
34007064:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
34007066:	4b48      	ldr	r3, [pc, #288]	@ (34007188 <SystemInit+0x1bc>)
34007068:	2206      	movs	r2, #6
3400706a:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3400706c:	4b46      	ldr	r3, [pc, #280]	@ (34007188 <SystemInit+0x1bc>)
3400706e:	2200      	movs	r2, #0
34007070:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34007072:	4b45      	ldr	r3, [pc, #276]	@ (34007188 <SystemInit+0x1bc>)
34007074:	2200      	movs	r2, #0
34007076:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
34007078:	4b43      	ldr	r3, [pc, #268]	@ (34007188 <SystemInit+0x1bc>)
3400707a:	2207      	movs	r2, #7
3400707c:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3400707e:	4b42      	ldr	r3, [pc, #264]	@ (34007188 <SystemInit+0x1bc>)
34007080:	2200      	movs	r2, #0
34007082:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34007084:	4b40      	ldr	r3, [pc, #256]	@ (34007188 <SystemInit+0x1bc>)
34007086:	2200      	movs	r2, #0
34007088:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
3400708a:	4b3e      	ldr	r3, [pc, #248]	@ (34007184 <SystemInit+0x1b8>)
3400708c:	2201      	movs	r2, #1
3400708e:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34007092:	4b3c      	ldr	r3, [pc, #240]	@ (34007184 <SystemInit+0x1b8>)
34007094:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34007098:	4b38      	ldr	r3, [pc, #224]	@ (3400717c <SystemInit+0x1b0>)
3400709a:	4a3c      	ldr	r2, [pc, #240]	@ (3400718c <SystemInit+0x1c0>)
3400709c:	689b      	ldr	r3, [r3, #8]
3400709e:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
340070a0:	4b3b      	ldr	r3, [pc, #236]	@ (34007190 <SystemInit+0x1c4>)
340070a2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340070a4:	4a3a      	ldr	r2, [pc, #232]	@ (34007190 <SystemInit+0x1c4>)
340070a6:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
340070aa:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
340070ac:	4b38      	ldr	r3, [pc, #224]	@ (34007190 <SystemInit+0x1c4>)
340070ae:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340070b0:	4a37      	ldr	r2, [pc, #220]	@ (34007190 <SystemInit+0x1c4>)
340070b2:	f043 0310 	orr.w	r3, r3, #16
340070b6:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
340070b8:	4b35      	ldr	r3, [pc, #212]	@ (34007190 <SystemInit+0x1c4>)
340070ba:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
340070bc:	4b31      	ldr	r3, [pc, #196]	@ (34007184 <SystemInit+0x1b8>)
340070be:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
340070c2:	4a30      	ldr	r2, [pc, #192]	@ (34007184 <SystemInit+0x1b8>)
340070c4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
340070c8:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
340070cc:	4b2d      	ldr	r3, [pc, #180]	@ (34007184 <SystemInit+0x1b8>)
340070ce:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
340070d2:	4a2c      	ldr	r2, [pc, #176]	@ (34007184 <SystemInit+0x1b8>)
340070d4:	f043 0310 	orr.w	r3, r3, #16
340070d8:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
340070dc:	4b29      	ldr	r3, [pc, #164]	@ (34007184 <SystemInit+0x1b8>)
340070de:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
340070e2:	4b28      	ldr	r3, [pc, #160]	@ (34007184 <SystemInit+0x1b8>)
340070e4:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
340070e8:	4a26      	ldr	r2, [pc, #152]	@ (34007184 <SystemInit+0x1b8>)
340070ea:	f023 0310 	bic.w	r3, r3, #16
340070ee:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
340070f2:	4b24      	ldr	r3, [pc, #144]	@ (34007184 <SystemInit+0x1b8>)
340070f4:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
340070f8:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
340070fc:	4b21      	ldr	r3, [pc, #132]	@ (34007184 <SystemInit+0x1b8>)
340070fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34007102:	461a      	mov	r2, r3
34007104:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34007108:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
3400710c:	4b1d      	ldr	r3, [pc, #116]	@ (34007184 <SystemInit+0x1b8>)
3400710e:	2201      	movs	r2, #1
34007110:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34007114:	4b1b      	ldr	r3, [pc, #108]	@ (34007184 <SystemInit+0x1b8>)
34007116:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400711a:	461a      	mov	r2, r3
3400711c:	2301      	movs	r3, #1
3400711e:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34007122:	4b18      	ldr	r3, [pc, #96]	@ (34007184 <SystemInit+0x1b8>)
34007124:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34007128:	461a      	mov	r2, r3
3400712a:	2301      	movs	r3, #1
3400712c:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34007130:	4b14      	ldr	r3, [pc, #80]	@ (34007184 <SystemInit+0x1b8>)
34007132:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34007136:	461a      	mov	r2, r3
34007138:	2340      	movs	r3, #64	@ 0x40
3400713a:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
3400713e:	4b13      	ldr	r3, [pc, #76]	@ (3400718c <SystemInit+0x1c0>)
34007140:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34007142:	4b10      	ldr	r3, [pc, #64]	@ (34007184 <SystemInit+0x1b8>)
34007144:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34007148:	461a      	mov	r2, r3
3400714a:	2301      	movs	r3, #1
3400714c:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34007150:	4b0a      	ldr	r3, [pc, #40]	@ (3400717c <SystemInit+0x1b0>)
34007152:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34007156:	4a09      	ldr	r2, [pc, #36]	@ (3400717c <SystemInit+0x1b0>)
34007158:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
3400715c:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34007160:	4b0c      	ldr	r3, [pc, #48]	@ (34007194 <SystemInit+0x1c8>)
34007162:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34007166:	4a0b      	ldr	r2, [pc, #44]	@ (34007194 <SystemInit+0x1c8>)
34007168:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
3400716c:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34007170:	bf00      	nop
34007172:	46bd      	mov	sp, r7
34007174:	f85d 7b04 	ldr.w	r7, [sp], #4
34007178:	4770      	bx	lr
3400717a:	bf00      	nop
3400717c:	e000ed00 	.word	0xe000ed00
34007180:	34000400 	.word	0x34000400
34007184:	56028000 	.word	0x56028000
34007188:	e000edd0 	.word	0xe000edd0
3400718c:	56008000 	.word	0x56008000
34007190:	56024800 	.word	0x56024800
34007194:	e002ed00 	.word	0xe002ed00

34007198 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34007198:	b480      	push	{r7}
3400719a:	b08d      	sub	sp, #52	@ 0x34
3400719c:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
3400719e:	2300      	movs	r3, #0
340071a0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
340071a2:	2300      	movs	r3, #0
340071a4:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
340071a6:	2300      	movs	r3, #0
340071a8:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
340071aa:	2300      	movs	r3, #0
340071ac:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
340071ae:	2300      	movs	r3, #0
340071b0:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
340071b2:	2300      	movs	r3, #0
340071b4:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
340071b6:	4b9b      	ldr	r3, [pc, #620]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340071b8:	6a1b      	ldr	r3, [r3, #32]
340071ba:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
340071be:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340071c2:	d029      	beq.n	34007218 <SystemCoreClockUpdate+0x80>
340071c4:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340071c8:	f200 8180 	bhi.w	340074cc <SystemCoreClockUpdate+0x334>
340071cc:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340071d0:	d01f      	beq.n	34007212 <SystemCoreClockUpdate+0x7a>
340071d2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340071d6:	f200 8179 	bhi.w	340074cc <SystemCoreClockUpdate+0x334>
340071da:	2b00      	cmp	r3, #0
340071dc:	d003      	beq.n	340071e6 <SystemCoreClockUpdate+0x4e>
340071de:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
340071e2:	d00a      	beq.n	340071fa <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
340071e4:	e172      	b.n	340074cc <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
340071e6:	4b8f      	ldr	r3, [pc, #572]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340071e8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340071ea:	09db      	lsrs	r3, r3, #7
340071ec:	f003 0303 	and.w	r3, r3, #3
340071f0:	4a8d      	ldr	r2, [pc, #564]	@ (34007428 <SystemCoreClockUpdate+0x290>)
340071f2:	fa22 f303 	lsr.w	r3, r2, r3
340071f6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
340071f8:	e169      	b.n	340074ce <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
340071fa:	4b8a      	ldr	r3, [pc, #552]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340071fc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340071fe:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007202:	2b00      	cmp	r3, #0
34007204:	d102      	bne.n	3400720c <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34007206:	4b89      	ldr	r3, [pc, #548]	@ (3400742c <SystemCoreClockUpdate+0x294>)
34007208:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3400720a:	e160      	b.n	340074ce <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
3400720c:	4b88      	ldr	r3, [pc, #544]	@ (34007430 <SystemCoreClockUpdate+0x298>)
3400720e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34007210:	e15d      	b.n	340074ce <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34007212:	4b88      	ldr	r3, [pc, #544]	@ (34007434 <SystemCoreClockUpdate+0x29c>)
34007214:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34007216:	e15a      	b.n	340074ce <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34007218:	4b82      	ldr	r3, [pc, #520]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
3400721a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400721e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34007222:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007226:	d066      	beq.n	340072f6 <SystemCoreClockUpdate+0x15e>
34007228:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400722c:	f200 8091 	bhi.w	34007352 <SystemCoreClockUpdate+0x1ba>
34007230:	2b00      	cmp	r3, #0
34007232:	d003      	beq.n	3400723c <SystemCoreClockUpdate+0xa4>
34007234:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34007238:	d02f      	beq.n	3400729a <SystemCoreClockUpdate+0x102>
3400723a:	e08a      	b.n	34007352 <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
3400723c:	4b79      	ldr	r3, [pc, #484]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
3400723e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007242:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34007244:	68fb      	ldr	r3, [r7, #12]
34007246:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3400724a:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
3400724c:	68fb      	ldr	r3, [r7, #12]
3400724e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34007252:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34007254:	693b      	ldr	r3, [r7, #16]
34007256:	2b00      	cmp	r3, #0
34007258:	f040 80a9 	bne.w	340073ae <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
3400725c:	68fb      	ldr	r3, [r7, #12]
3400725e:	0d1b      	lsrs	r3, r3, #20
34007260:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34007264:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34007266:	68fb      	ldr	r3, [r7, #12]
34007268:	0a1b      	lsrs	r3, r3, #8
3400726a:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400726e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34007270:	4b6c      	ldr	r3, [pc, #432]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
34007272:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34007276:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400727a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
3400727c:	4b69      	ldr	r3, [pc, #420]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
3400727e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34007282:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34007284:	68fb      	ldr	r3, [r7, #12]
34007286:	0edb      	lsrs	r3, r3, #27
34007288:	f003 0307 	and.w	r3, r3, #7
3400728c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
3400728e:	68fb      	ldr	r3, [r7, #12]
34007290:	0e1b      	lsrs	r3, r3, #24
34007292:	f003 0307 	and.w	r3, r3, #7
34007296:	61bb      	str	r3, [r7, #24]
      break;
34007298:	e089      	b.n	340073ae <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
3400729a:	4b62      	ldr	r3, [pc, #392]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
3400729c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340072a0:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
340072a2:	68fb      	ldr	r3, [r7, #12]
340072a4:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
340072a8:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
340072aa:	68fb      	ldr	r3, [r7, #12]
340072ac:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340072b0:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
340072b2:	693b      	ldr	r3, [r7, #16]
340072b4:	2b00      	cmp	r3, #0
340072b6:	d17c      	bne.n	340073b2 <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
340072b8:	68fb      	ldr	r3, [r7, #12]
340072ba:	0d1b      	lsrs	r3, r3, #20
340072bc:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340072c0:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
340072c2:	68fb      	ldr	r3, [r7, #12]
340072c4:	0a1b      	lsrs	r3, r3, #8
340072c6:	f3c3 030b 	ubfx	r3, r3, #0, #12
340072ca:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
340072cc:	4b55      	ldr	r3, [pc, #340]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340072ce:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
340072d2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340072d6:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
340072d8:	4b52      	ldr	r3, [pc, #328]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340072da:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
340072de:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
340072e0:	68fb      	ldr	r3, [r7, #12]
340072e2:	0edb      	lsrs	r3, r3, #27
340072e4:	f003 0307 	and.w	r3, r3, #7
340072e8:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
340072ea:	68fb      	ldr	r3, [r7, #12]
340072ec:	0e1b      	lsrs	r3, r3, #24
340072ee:	f003 0307 	and.w	r3, r3, #7
340072f2:	61bb      	str	r3, [r7, #24]
      break;
340072f4:	e05d      	b.n	340073b2 <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
340072f6:	4b4b      	ldr	r3, [pc, #300]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340072f8:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340072fc:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
340072fe:	68fb      	ldr	r3, [r7, #12]
34007300:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34007304:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34007306:	68fb      	ldr	r3, [r7, #12]
34007308:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400730c:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3400730e:	693b      	ldr	r3, [r7, #16]
34007310:	2b00      	cmp	r3, #0
34007312:	d150      	bne.n	340073b6 <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34007314:	68fb      	ldr	r3, [r7, #12]
34007316:	0d1b      	lsrs	r3, r3, #20
34007318:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3400731c:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
3400731e:	68fb      	ldr	r3, [r7, #12]
34007320:	0a1b      	lsrs	r3, r3, #8
34007322:	f3c3 030b 	ubfx	r3, r3, #0, #12
34007326:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34007328:	4b3e      	ldr	r3, [pc, #248]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
3400732a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400732e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007332:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34007334:	4b3b      	ldr	r3, [pc, #236]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
34007336:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400733a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
3400733c:	68fb      	ldr	r3, [r7, #12]
3400733e:	0edb      	lsrs	r3, r3, #27
34007340:	f003 0307 	and.w	r3, r3, #7
34007344:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34007346:	68fb      	ldr	r3, [r7, #12]
34007348:	0e1b      	lsrs	r3, r3, #24
3400734a:	f003 0307 	and.w	r3, r3, #7
3400734e:	61bb      	str	r3, [r7, #24]
      break;
34007350:	e031      	b.n	340073b6 <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34007352:	4b34      	ldr	r3, [pc, #208]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
34007354:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34007358:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
3400735a:	68fb      	ldr	r3, [r7, #12]
3400735c:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34007360:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
34007362:	68fb      	ldr	r3, [r7, #12]
34007364:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34007368:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3400736a:	693b      	ldr	r3, [r7, #16]
3400736c:	2b00      	cmp	r3, #0
3400736e:	d124      	bne.n	340073ba <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34007370:	68fb      	ldr	r3, [r7, #12]
34007372:	0d1b      	lsrs	r3, r3, #20
34007374:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34007378:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
3400737a:	68fb      	ldr	r3, [r7, #12]
3400737c:	0a1b      	lsrs	r3, r3, #8
3400737e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34007382:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34007384:	4b27      	ldr	r3, [pc, #156]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
34007386:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400738a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400738e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34007390:	4b24      	ldr	r3, [pc, #144]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
34007392:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34007396:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34007398:	68fb      	ldr	r3, [r7, #12]
3400739a:	0edb      	lsrs	r3, r3, #27
3400739c:	f003 0307 	and.w	r3, r3, #7
340073a0:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
340073a2:	68fb      	ldr	r3, [r7, #12]
340073a4:	0e1b      	lsrs	r3, r3, #24
340073a6:	f003 0307 	and.w	r3, r3, #7
340073aa:	61bb      	str	r3, [r7, #24]
      break;
340073ac:	e005      	b.n	340073ba <SystemCoreClockUpdate+0x222>
      break;
340073ae:	bf00      	nop
340073b0:	e004      	b.n	340073bc <SystemCoreClockUpdate+0x224>
      break;
340073b2:	bf00      	nop
340073b4:	e002      	b.n	340073bc <SystemCoreClockUpdate+0x224>
      break;
340073b6:	bf00      	nop
340073b8:	e000      	b.n	340073bc <SystemCoreClockUpdate+0x224>
      break;
340073ba:	bf00      	nop
    switch (pllsource)
340073bc:	697b      	ldr	r3, [r7, #20]
340073be:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340073c2:	d02c      	beq.n	3400741e <SystemCoreClockUpdate+0x286>
340073c4:	697b      	ldr	r3, [r7, #20]
340073c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340073ca:	d839      	bhi.n	34007440 <SystemCoreClockUpdate+0x2a8>
340073cc:	697b      	ldr	r3, [r7, #20]
340073ce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340073d2:	d021      	beq.n	34007418 <SystemCoreClockUpdate+0x280>
340073d4:	697b      	ldr	r3, [r7, #20]
340073d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340073da:	d831      	bhi.n	34007440 <SystemCoreClockUpdate+0x2a8>
340073dc:	697b      	ldr	r3, [r7, #20]
340073de:	2b00      	cmp	r3, #0
340073e0:	d004      	beq.n	340073ec <SystemCoreClockUpdate+0x254>
340073e2:	697b      	ldr	r3, [r7, #20]
340073e4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340073e8:	d00a      	beq.n	34007400 <SystemCoreClockUpdate+0x268>
      break;
340073ea:	e029      	b.n	34007440 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
340073ec:	4b0d      	ldr	r3, [pc, #52]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
340073ee:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340073f0:	09db      	lsrs	r3, r3, #7
340073f2:	f003 0303 	and.w	r3, r3, #3
340073f6:	4a0c      	ldr	r2, [pc, #48]	@ (34007428 <SystemCoreClockUpdate+0x290>)
340073f8:	fa22 f303 	lsr.w	r3, r2, r3
340073fc:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
340073fe:	e020      	b.n	34007442 <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34007400:	4b08      	ldr	r3, [pc, #32]	@ (34007424 <SystemCoreClockUpdate+0x28c>)
34007402:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007404:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007408:	2b00      	cmp	r3, #0
3400740a:	d102      	bne.n	34007412 <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
3400740c:	4b07      	ldr	r3, [pc, #28]	@ (3400742c <SystemCoreClockUpdate+0x294>)
3400740e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34007410:	e017      	b.n	34007442 <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34007412:	4b07      	ldr	r3, [pc, #28]	@ (34007430 <SystemCoreClockUpdate+0x298>)
34007414:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34007416:	e014      	b.n	34007442 <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34007418:	4b06      	ldr	r3, [pc, #24]	@ (34007434 <SystemCoreClockUpdate+0x29c>)
3400741a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3400741c:	e011      	b.n	34007442 <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
3400741e:	4b06      	ldr	r3, [pc, #24]	@ (34007438 <SystemCoreClockUpdate+0x2a0>)
34007420:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34007422:	e00e      	b.n	34007442 <SystemCoreClockUpdate+0x2aa>
34007424:	56028000 	.word	0x56028000
34007428:	03d09000 	.word	0x03d09000
3400742c:	003d0900 	.word	0x003d0900
34007430:	00f42400 	.word	0x00f42400
34007434:	02dc6c00 	.word	0x02dc6c00
34007438:	00bb8000 	.word	0x00bb8000
3400743c:	4b800000 	.word	0x4b800000
      break;
34007440:	bf00      	nop
    if (pllbypass == 0U)
34007442:	693b      	ldr	r3, [r7, #16]
34007444:	2b00      	cmp	r3, #0
34007446:	d134      	bne.n	340074b2 <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34007448:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400744a:	ee07 3a90 	vmov	s15, r3
3400744e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34007452:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34007454:	ee07 3a90 	vmov	s15, r3
34007458:	eef8 6a67 	vcvt.f32.u32	s13, s15
3400745c:	6a3b      	ldr	r3, [r7, #32]
3400745e:	ee07 3a90 	vmov	s15, r3
34007462:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34007466:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 3400743c <SystemCoreClockUpdate+0x2a4>
3400746a:	eec6 7a25 	vdiv.f32	s15, s12, s11
3400746e:	ee76 7aa7 	vadd.f32	s15, s13, s15
34007472:	ee67 6a27 	vmul.f32	s13, s14, s15
34007476:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007478:	ee07 3a90 	vmov	s15, r3
3400747c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34007480:	eec6 7a87 	vdiv.f32	s15, s13, s14
34007484:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34007488:	69fb      	ldr	r3, [r7, #28]
3400748a:	ee07 3a90 	vmov	s15, r3
3400748e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34007492:	69bb      	ldr	r3, [r7, #24]
34007494:	ee07 3a90 	vmov	s15, r3
34007498:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400749c:	ee27 7a27 	vmul.f32	s14, s14, s15
340074a0:	edd7 6a02 	vldr	s13, [r7, #8]
340074a4:	eec6 7a87 	vdiv.f32	s15, s13, s14
340074a8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
340074ac:	ee17 3a90 	vmov	r3, s15
340074b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
340074b2:	4b0b      	ldr	r3, [pc, #44]	@ (340074e0 <SystemCoreClockUpdate+0x348>)
340074b4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340074b8:	0c1b      	lsrs	r3, r3, #16
340074ba:	b2db      	uxtb	r3, r3
340074bc:	3301      	adds	r3, #1
340074be:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
340074c0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340074c2:	687b      	ldr	r3, [r7, #4]
340074c4:	fbb2 f3f3 	udiv	r3, r2, r3
340074c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
340074ca:	e000      	b.n	340074ce <SystemCoreClockUpdate+0x336>
    break;
340074cc:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
340074ce:	4a05      	ldr	r2, [pc, #20]	@ (340074e4 <SystemCoreClockUpdate+0x34c>)
340074d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340074d2:	6013      	str	r3, [r2, #0]
}
340074d4:	bf00      	nop
340074d6:	3734      	adds	r7, #52	@ 0x34
340074d8:	46bd      	mov	sp, r7
340074da:	f85d 7b04 	ldr.w	r7, [sp], #4
340074de:	4770      	bx	lr
340074e0:	56028000 	.word	0x56028000
340074e4:	34033f48 	.word	0x34033f48

340074e8 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
340074e8:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
340074ec:	b588      	push	{r3, r7, lr}
340074ee:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
340074f0:	f7ff fe52 	bl	34007198 <SystemCoreClockUpdate>

  return SystemCoreClock;
340074f4:	4b06      	ldr	r3, [pc, #24]	@ (34007510 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
340074f6:	681b      	ldr	r3, [r3, #0]
}
340074f8:	4618      	mov	r0, r3
340074fa:	46bd      	mov	sp, r7
340074fc:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34007500:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34007504:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34007508:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
3400750c:	4774      	bxns	lr
3400750e:	bf00      	nop
34007510:	34033f48 	.word	0x34033f48

34007514 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34007514:	b580      	push	{r7, lr}
34007516:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34007518:	2003      	movs	r0, #3
3400751a:	f000 fb25 	bl	34007b68 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
3400751e:	f7ff fe3b 	bl	34007198 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34007522:	200f      	movs	r0, #15
34007524:	f000 f812 	bl	3400754c <HAL_InitTick>
34007528:	4603      	mov	r3, r0
3400752a:	2b00      	cmp	r3, #0
3400752c:	d001      	beq.n	34007532 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
3400752e:	2301      	movs	r3, #1
34007530:	e002      	b.n	34007538 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34007532:	f000 f803 	bl	3400753c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34007536:	2300      	movs	r3, #0
}
34007538:	4618      	mov	r0, r3
3400753a:	bd80      	pop	{r7, pc}

3400753c <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
3400753c:	b480      	push	{r7}
3400753e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
34007540:	bf00      	nop
34007542:	46bd      	mov	sp, r7
34007544:	f85d 7b04 	ldr.w	r7, [sp], #4
34007548:	4770      	bx	lr
	...

3400754c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
3400754c:	b580      	push	{r7, lr}
3400754e:	b082      	sub	sp, #8
34007550:	af00      	add	r7, sp, #0
34007552:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34007554:	4b15      	ldr	r3, [pc, #84]	@ (340075ac <HAL_InitTick+0x60>)
34007556:	781b      	ldrb	r3, [r3, #0]
34007558:	2b00      	cmp	r3, #0
3400755a:	d101      	bne.n	34007560 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
3400755c:	2301      	movs	r3, #1
3400755e:	e021      	b.n	340075a4 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34007560:	4b13      	ldr	r3, [pc, #76]	@ (340075b0 <HAL_InitTick+0x64>)
34007562:	681a      	ldr	r2, [r3, #0]
34007564:	4b11      	ldr	r3, [pc, #68]	@ (340075ac <HAL_InitTick+0x60>)
34007566:	781b      	ldrb	r3, [r3, #0]
34007568:	4619      	mov	r1, r3
3400756a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
3400756e:	fbb3 f3f1 	udiv	r3, r3, r1
34007572:	fbb2 f3f3 	udiv	r3, r2, r3
34007576:	4618      	mov	r0, r3
34007578:	f000 fb70 	bl	34007c5c <HAL_SYSTICK_Config>
3400757c:	4603      	mov	r3, r0
3400757e:	2b00      	cmp	r3, #0
34007580:	d001      	beq.n	34007586 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
34007582:	2301      	movs	r3, #1
34007584:	e00e      	b.n	340075a4 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34007586:	687b      	ldr	r3, [r7, #4]
34007588:	2b0f      	cmp	r3, #15
3400758a:	d80a      	bhi.n	340075a2 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
3400758c:	2200      	movs	r2, #0
3400758e:	6879      	ldr	r1, [r7, #4]
34007590:	f04f 30ff 	mov.w	r0, #4294967295
34007594:	f000 fb08 	bl	34007ba8 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34007598:	4a06      	ldr	r2, [pc, #24]	@ (340075b4 <HAL_InitTick+0x68>)
3400759a:	687b      	ldr	r3, [r7, #4]
3400759c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
3400759e:	2300      	movs	r3, #0
340075a0:	e000      	b.n	340075a4 <HAL_InitTick+0x58>
    return HAL_ERROR;
340075a2:	2301      	movs	r3, #1
}
340075a4:	4618      	mov	r0, r3
340075a6:	3708      	adds	r7, #8
340075a8:	46bd      	mov	sp, r7
340075aa:	bd80      	pop	{r7, pc}
340075ac:	34033f50 	.word	0x34033f50
340075b0:	34033f48 	.word	0x34033f48
340075b4:	34033f4c 	.word	0x34033f4c

340075b8 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
340075b8:	b480      	push	{r7}
340075ba:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
340075bc:	4b06      	ldr	r3, [pc, #24]	@ (340075d8 <HAL_IncTick+0x20>)
340075be:	781b      	ldrb	r3, [r3, #0]
340075c0:	461a      	mov	r2, r3
340075c2:	4b06      	ldr	r3, [pc, #24]	@ (340075dc <HAL_IncTick+0x24>)
340075c4:	681b      	ldr	r3, [r3, #0]
340075c6:	4413      	add	r3, r2
340075c8:	4a04      	ldr	r2, [pc, #16]	@ (340075dc <HAL_IncTick+0x24>)
340075ca:	6013      	str	r3, [r2, #0]
}
340075cc:	bf00      	nop
340075ce:	46bd      	mov	sp, r7
340075d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340075d4:	4770      	bx	lr
340075d6:	bf00      	nop
340075d8:	34033f50 	.word	0x34033f50
340075dc:	34053bc8 	.word	0x34053bc8

340075e0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
340075e0:	b480      	push	{r7}
340075e2:	af00      	add	r7, sp, #0
  return uwTick;
340075e4:	4b03      	ldr	r3, [pc, #12]	@ (340075f4 <HAL_GetTick+0x14>)
340075e6:	681b      	ldr	r3, [r3, #0]
}
340075e8:	4618      	mov	r0, r3
340075ea:	46bd      	mov	sp, r7
340075ec:	f85d 7b04 	ldr.w	r7, [sp], #4
340075f0:	4770      	bx	lr
340075f2:	bf00      	nop
340075f4:	34053bc8 	.word	0x34053bc8

340075f8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
340075f8:	b580      	push	{r7, lr}
340075fa:	b084      	sub	sp, #16
340075fc:	af00      	add	r7, sp, #0
340075fe:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
34007600:	f7ff ffee 	bl	340075e0 <HAL_GetTick>
34007604:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
34007606:	687b      	ldr	r3, [r7, #4]
34007608:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
3400760a:	68fb      	ldr	r3, [r7, #12]
3400760c:	f1b3 3fff 	cmp.w	r3, #4294967295
34007610:	d005      	beq.n	3400761e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
34007612:	4b0a      	ldr	r3, [pc, #40]	@ (3400763c <HAL_Delay+0x44>)
34007614:	781b      	ldrb	r3, [r3, #0]
34007616:	461a      	mov	r2, r3
34007618:	68fb      	ldr	r3, [r7, #12]
3400761a:	4413      	add	r3, r2
3400761c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
3400761e:	bf00      	nop
34007620:	f7ff ffde 	bl	340075e0 <HAL_GetTick>
34007624:	4602      	mov	r2, r0
34007626:	68bb      	ldr	r3, [r7, #8]
34007628:	1ad3      	subs	r3, r2, r3
3400762a:	68fa      	ldr	r2, [r7, #12]
3400762c:	429a      	cmp	r2, r3
3400762e:	d8f7      	bhi.n	34007620 <HAL_Delay+0x28>
  {
  }
}
34007630:	bf00      	nop
34007632:	bf00      	nop
34007634:	3710      	adds	r7, #16
34007636:	46bd      	mov	sp, r7
34007638:	bd80      	pop	{r7, pc}
3400763a:	bf00      	nop
3400763c:	34033f50 	.word	0x34033f50

34007640 <HAL_BSEC_OTP_Read>:
  * @param  pFuseData  Returned value of fuse. The returned value is between 0 and 0xFFFFFFFFU
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Read(BSEC_HandleTypeDef * hbsec, uint32_t FuseId, uint32_t *pFuseData)
{
34007640:	b580      	push	{r7, lr}
34007642:	b084      	sub	sp, #16
34007644:	af00      	add	r7, sp, #0
34007646:	60f8      	str	r0, [r7, #12]
34007648:	60b9      	str	r1, [r7, #8]
3400764a:	607a      	str	r2, [r7, #4]
  /* Check the handle pointer */
  if (hbsec == NULL)
3400764c:	68fb      	ldr	r3, [r7, #12]
3400764e:	2b00      	cmp	r3, #0
34007650:	d101      	bne.n	34007656 <HAL_BSEC_OTP_Read+0x16>
  {
    return HAL_ERROR;
34007652:	2301      	movs	r3, #1
34007654:	e026      	b.n	340076a4 <HAL_BSEC_OTP_Read+0x64>
  }

  /* Check the address of returned value and instance */
 if ((pFuseData == NULL) || (hbsec->Instance != BSEC))
34007656:	687b      	ldr	r3, [r7, #4]
34007658:	2b00      	cmp	r3, #0
3400765a:	d004      	beq.n	34007666 <HAL_BSEC_OTP_Read+0x26>
3400765c:	68fb      	ldr	r3, [r7, #12]
3400765e:	681b      	ldr	r3, [r3, #0]
34007660:	4a12      	ldr	r2, [pc, #72]	@ (340076ac <HAL_BSEC_OTP_Read+0x6c>)
34007662:	4293      	cmp	r3, r2
34007664:	d004      	beq.n	34007670 <HAL_BSEC_OTP_Read+0x30>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34007666:	68fb      	ldr	r3, [r7, #12]
34007668:	2201      	movs	r2, #1
3400766a:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
3400766c:	2301      	movs	r3, #1
3400766e:	e019      	b.n	340076a4 <HAL_BSEC_OTP_Read+0x64>
  }

  if (FuseId < BSEC_NB_FUSES)
34007670:	68bb      	ldr	r3, [r7, #8]
34007672:	f5b3 7fbc 	cmp.w	r3, #376	@ 0x178
34007676:	d211      	bcs.n	3400769c <HAL_BSEC_OTP_Read+0x5c>
  {
    /* Reload the data :
       - Unshadowed fuse are not automatically reload and data no more available after register read
       - Shadowed fuse contains by default the shadow value in the register */
    if (HAL_BSEC_OTP_Reload(hbsec, FuseId) == HAL_OK)
34007678:	68b9      	ldr	r1, [r7, #8]
3400767a:	68f8      	ldr	r0, [r7, #12]
3400767c:	f000 f8ba 	bl	340077f4 <HAL_BSEC_OTP_Reload>
34007680:	4603      	mov	r3, r0
34007682:	2b00      	cmp	r3, #0
34007684:	d108      	bne.n	34007698 <HAL_BSEC_OTP_Read+0x58>
    {
      /* Read data from shadow register */
      *pFuseData = hbsec->Instance->FVRw[FuseId];
34007686:	68fb      	ldr	r3, [r7, #12]
34007688:	681b      	ldr	r3, [r3, #0]
3400768a:	68ba      	ldr	r2, [r7, #8]
3400768c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
34007690:	687b      	ldr	r3, [r7, #4]
34007692:	601a      	str	r2, [r3, #0]
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
    return HAL_ERROR;
  }

  return HAL_OK;
34007694:	2300      	movs	r3, #0
34007696:	e005      	b.n	340076a4 <HAL_BSEC_OTP_Read+0x64>
      return HAL_ERROR;
34007698:	2301      	movs	r3, #1
3400769a:	e003      	b.n	340076a4 <HAL_BSEC_OTP_Read+0x64>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
3400769c:	68fb      	ldr	r3, [r7, #12]
3400769e:	2201      	movs	r2, #1
340076a0:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
340076a2:	2301      	movs	r3, #1
}
340076a4:	4618      	mov	r0, r3
340076a6:	3710      	adds	r7, #16
340076a8:	46bd      	mov	sp, r7
340076aa:	bd80      	pop	{r7, pc}
340076ac:	56009000 	.word	0x56009000

340076b0 <HAL_BSEC_OTP_Program>:
  * @param  Lock      Permanent lock value, this parameter is @ref BSEC_Permanent_Lock
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Program(BSEC_HandleTypeDef *hbsec, uint32_t FuseId, uint32_t FuseData, uint32_t Lock)
{
340076b0:	b580      	push	{r7, lr}
340076b2:	b088      	sub	sp, #32
340076b4:	af00      	add	r7, sp, #0
340076b6:	60f8      	str	r0, [r7, #12]
340076b8:	60b9      	str	r1, [r7, #8]
340076ba:	607a      	str	r2, [r7, #4]
340076bc:	603b      	str	r3, [r7, #0]
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t read_data;
  uint32_t tick_start = HAL_GetTick();
340076be:	f7ff ff8f 	bl	340075e0 <HAL_GetTick>
340076c2:	61f8      	str	r0, [r7, #28]

  /* Check the handle pointer */
  if (hbsec == NULL)
340076c4:	68fb      	ldr	r3, [r7, #12]
340076c6:	2b00      	cmp	r3, #0
340076c8:	d101      	bne.n	340076ce <HAL_BSEC_OTP_Program+0x1e>
  {
    return HAL_ERROR;
340076ca:	2301      	movs	r3, #1
340076cc:	e08a      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
340076ce:	68fb      	ldr	r3, [r7, #12]
340076d0:	681b      	ldr	r3, [r3, #0]
340076d2:	4a46      	ldr	r2, [pc, #280]	@ (340077ec <HAL_BSEC_OTP_Program+0x13c>)
340076d4:	4293      	cmp	r3, r2
340076d6:	d004      	beq.n	340076e2 <HAL_BSEC_OTP_Program+0x32>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340076d8:	68fb      	ldr	r3, [r7, #12]
340076da:	2201      	movs	r2, #1
340076dc:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
340076de:	2301      	movs	r3, #1
340076e0:	e080      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
  }

  /* Check the permanent lock */
  assert_param(IS_BSEC_PERMANENT_LOCK(Lock));
340076e2:	683b      	ldr	r3, [r7, #0]
340076e4:	2b00      	cmp	r3, #0
340076e6:	d008      	beq.n	340076fa <HAL_BSEC_OTP_Program+0x4a>
340076e8:	683b      	ldr	r3, [r7, #0]
340076ea:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
340076ee:	d004      	beq.n	340076fa <HAL_BSEC_OTP_Program+0x4a>
340076f0:	f44f 71dd 	mov.w	r1, #442	@ 0x1ba
340076f4:	483e      	ldr	r0, [pc, #248]	@ (340077f0 <HAL_BSEC_OTP_Program+0x140>)
340076f6:	f7f9 fdcf 	bl	34001298 <assert_failed>

  /* Get the correct register value */
  if (FuseId < BSEC_NB_FUSES)
340076fa:	68bb      	ldr	r3, [r7, #8]
340076fc:	f5b3 7fbc 	cmp.w	r3, #376	@ 0x178
34007700:	d26a      	bcs.n	340077d8 <HAL_BSEC_OTP_Program+0x128>
  {
    status_reg = FuseId / 32U;
34007702:	68bb      	ldr	r3, [r7, #8]
34007704:	095b      	lsrs	r3, r3, #5
34007706:	61bb      	str	r3, [r7, #24]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
34007708:	68bb      	ldr	r3, [r7, #8]
3400770a:	f003 031f 	and.w	r3, r3, #31
3400770e:	2201      	movs	r2, #1
34007710:	fa02 f303 	lsl.w	r3, r2, r3
34007714:	617b      	str	r3, [r7, #20]

    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34007716:	68fb      	ldr	r3, [r7, #12]
34007718:	681b      	ldr	r3, [r3, #0]
3400771a:	69ba      	ldr	r2, [r7, #24]
3400771c:	f502 7200 	add.w	r2, r2, #512	@ 0x200
34007720:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
34007724:	697b      	ldr	r3, [r7, #20]
34007726:	4013      	ands	r3, r2
34007728:	2b00      	cmp	r3, #0
3400772a:	d150      	bne.n	340077ce <HAL_BSEC_OTP_Program+0x11e>
    {
      /* Write data in register */
      hbsec->Instance->WDR = FuseData;
3400772c:	68fb      	ldr	r3, [r7, #12]
3400772e:	681b      	ldr	r3, [r3, #0]
34007730:	687a      	ldr	r2, [r7, #4]
34007732:	f8c3 2c08 	str.w	r2, [r3, #3080]	@ 0xc08

      /* Perform a program of the fuse register */
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR),
34007736:	68fb      	ldr	r3, [r7, #12]
34007738:	681b      	ldr	r3, [r3, #0]
3400773a:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
3400773e:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
34007742:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34007746:	68b9      	ldr	r1, [r7, #8]
34007748:	683a      	ldr	r2, [r7, #0]
3400774a:	430a      	orrs	r2, r1
3400774c:	431a      	orrs	r2, r3
3400774e:	68fb      	ldr	r3, [r7, #12]
34007750:	681b      	ldr	r3, [r3, #0]
34007752:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
34007756:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
                                         (FuseId | BSEC_OTPCR_PROG | Lock));

      /* Wait the operation is finished */
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
3400775a:	e00c      	b.n	34007776 <HAL_BSEC_OTP_Program+0xc6>
      {
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
3400775c:	f7ff ff40 	bl	340075e0 <HAL_GetTick>
34007760:	4602      	mov	r2, r0
34007762:	69fb      	ldr	r3, [r7, #28]
34007764:	1ad3      	subs	r3, r2, r3
34007766:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
3400776a:	d904      	bls.n	34007776 <HAL_BSEC_OTP_Program+0xc6>
        {
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
3400776c:	68fb      	ldr	r3, [r7, #12]
3400776e:	220a      	movs	r2, #10
34007770:	605a      	str	r2, [r3, #4]
          return HAL_ERROR;
34007772:	2301      	movs	r3, #1
34007774:	e036      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34007776:	68fb      	ldr	r3, [r7, #12]
34007778:	681b      	ldr	r3, [r3, #0]
3400777a:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
3400777e:	f003 0301 	and.w	r3, r3, #1
34007782:	2b00      	cmp	r3, #0
34007784:	d1ea      	bne.n	3400775c <HAL_BSEC_OTP_Program+0xac>
        }
      }

      /* Check programming errors */
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_PROGFAIL) != 0U)
34007786:	68fb      	ldr	r3, [r7, #12]
34007788:	681b      	ldr	r3, [r3, #0]
3400778a:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
3400778e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34007792:	2b00      	cmp	r3, #0
34007794:	d005      	beq.n	340077a2 <HAL_BSEC_OTP_Program+0xf2>
      {
        hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
34007796:	68fb      	ldr	r3, [r7, #12]
34007798:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400779c:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
3400779e:	2301      	movs	r3, #1
340077a0:	e020      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
      }

      /* Read back programmed data */
      if (HAL_BSEC_OTP_Read(hbsec, FuseId, &read_data) == HAL_OK)
340077a2:	f107 0310 	add.w	r3, r7, #16
340077a6:	461a      	mov	r2, r3
340077a8:	68b9      	ldr	r1, [r7, #8]
340077aa:	68f8      	ldr	r0, [r7, #12]
340077ac:	f7ff ff48 	bl	34007640 <HAL_BSEC_OTP_Read>
340077b0:	4603      	mov	r3, r0
340077b2:	2b00      	cmp	r3, #0
340077b4:	d109      	bne.n	340077ca <HAL_BSEC_OTP_Program+0x11a>
      {
        /* Verify programmed data */
        if (read_data != FuseData)
340077b6:	693b      	ldr	r3, [r7, #16]
340077b8:	687a      	ldr	r2, [r7, #4]
340077ba:	429a      	cmp	r2, r3
340077bc:	d011      	beq.n	340077e2 <HAL_BSEC_OTP_Program+0x132>
        {
          hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
340077be:	68fb      	ldr	r3, [r7, #12]
340077c0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
340077c4:	605a      	str	r2, [r3, #4]
          return HAL_ERROR;
340077c6:	2301      	movs	r3, #1
340077c8:	e00c      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
        }
      }
      else
      {
        return HAL_ERROR;
340077ca:	2301      	movs	r3, #1
340077cc:	e00a      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
      }
    }
    else
    {
      /* Fuse is sticky programming locked */
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
340077ce:	68fb      	ldr	r3, [r7, #12]
340077d0:	2204      	movs	r2, #4
340077d2:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
340077d4:	2301      	movs	r3, #1
340077d6:	e005      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
    }
  }
  else
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340077d8:	68fb      	ldr	r3, [r7, #12]
340077da:	2201      	movs	r2, #1
340077dc:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
340077de:	2301      	movs	r3, #1
340077e0:	e000      	b.n	340077e4 <HAL_BSEC_OTP_Program+0x134>
  }

  return HAL_OK;
340077e2:	2300      	movs	r3, #0
}
340077e4:	4618      	mov	r0, r3
340077e6:	3720      	adds	r7, #32
340077e8:	46bd      	mov	sp, r7
340077ea:	bd80      	pop	{r7, pc}
340077ec:	56009000 	.word	0x56009000
340077f0:	34023f8c 	.word	0x34023f8c

340077f4 <HAL_BSEC_OTP_Reload>:
  * @param  FuseId  Fuse to be reload, this parameter value is between 0 and BSEC_NB_FUSES-1
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Reload(BSEC_HandleTypeDef *hbsec, uint32_t FuseId)
{
340077f4:	b580      	push	{r7, lr}
340077f6:	b086      	sub	sp, #24
340077f8:	af00      	add	r7, sp, #0
340077fa:	6078      	str	r0, [r7, #4]
340077fc:	6039      	str	r1, [r7, #0]
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t tick_start = HAL_GetTick();
340077fe:	f7ff feef 	bl	340075e0 <HAL_GetTick>
34007802:	6178      	str	r0, [r7, #20]

  /* Check the handle pointer */
  if (hbsec == NULL)
34007804:	687b      	ldr	r3, [r7, #4]
34007806:	2b00      	cmp	r3, #0
34007808:	d101      	bne.n	3400780e <HAL_BSEC_OTP_Reload+0x1a>
  {
    return HAL_ERROR;
3400780a:	2301      	movs	r3, #1
3400780c:	e063      	b.n	340078d6 <HAL_BSEC_OTP_Reload+0xe2>
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
3400780e:	687b      	ldr	r3, [r7, #4]
34007810:	681b      	ldr	r3, [r3, #0]
34007812:	4a33      	ldr	r2, [pc, #204]	@ (340078e0 <HAL_BSEC_OTP_Reload+0xec>)
34007814:	4293      	cmp	r3, r2
34007816:	d004      	beq.n	34007822 <HAL_BSEC_OTP_Reload+0x2e>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34007818:	687b      	ldr	r3, [r7, #4]
3400781a:	2201      	movs	r2, #1
3400781c:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
3400781e:	2301      	movs	r3, #1
34007820:	e059      	b.n	340078d6 <HAL_BSEC_OTP_Reload+0xe2>
  }

  if (FuseId < BSEC_NB_FUSES)
34007822:	683b      	ldr	r3, [r7, #0]
34007824:	f5b3 7fbc 	cmp.w	r3, #376	@ 0x178
34007828:	d24f      	bcs.n	340078ca <HAL_BSEC_OTP_Reload+0xd6>
  {
    status_reg = FuseId / 32U;
3400782a:	683b      	ldr	r3, [r7, #0]
3400782c:	095b      	lsrs	r3, r3, #5
3400782e:	613b      	str	r3, [r7, #16]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
34007830:	683b      	ldr	r3, [r7, #0]
34007832:	f003 031f 	and.w	r3, r3, #31
34007836:	2201      	movs	r2, #1
34007838:	fa02 f303 	lsl.w	r3, r2, r3
3400783c:	60fb      	str	r3, [r7, #12]

    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
3400783e:	687b      	ldr	r3, [r7, #4]
34007840:	681b      	ldr	r3, [r3, #0]
34007842:	693a      	ldr	r2, [r7, #16]
34007844:	f502 7208 	add.w	r2, r2, #544	@ 0x220
34007848:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
3400784c:	68fb      	ldr	r3, [r7, #12]
3400784e:	4013      	ands	r3, r2
34007850:	2b00      	cmp	r3, #0
34007852:	d135      	bne.n	340078c0 <HAL_BSEC_OTP_Reload+0xcc>
    {
      /* Perform a reload of the fuse register */
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR), FuseId);
34007854:	687b      	ldr	r3, [r7, #4]
34007856:	681b      	ldr	r3, [r3, #0]
34007858:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
3400785c:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
34007860:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34007864:	687a      	ldr	r2, [r7, #4]
34007866:	6812      	ldr	r2, [r2, #0]
34007868:	6839      	ldr	r1, [r7, #0]
3400786a:	430b      	orrs	r3, r1
3400786c:	f8c2 3c04 	str.w	r3, [r2, #3076]	@ 0xc04

      /* Wait the operation is finished */
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34007870:	e00c      	b.n	3400788c <HAL_BSEC_OTP_Reload+0x98>
      {
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
34007872:	f7ff feb5 	bl	340075e0 <HAL_GetTick>
34007876:	4602      	mov	r2, r0
34007878:	697b      	ldr	r3, [r7, #20]
3400787a:	1ad3      	subs	r3, r2, r3
3400787c:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34007880:	d904      	bls.n	3400788c <HAL_BSEC_OTP_Reload+0x98>
        {
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
34007882:	687b      	ldr	r3, [r7, #4]
34007884:	220a      	movs	r2, #10
34007886:	605a      	str	r2, [r3, #4]
          return HAL_ERROR;
34007888:	2301      	movs	r3, #1
3400788a:	e024      	b.n	340078d6 <HAL_BSEC_OTP_Reload+0xe2>
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
3400788c:	687b      	ldr	r3, [r7, #4]
3400788e:	681b      	ldr	r3, [r3, #0]
34007890:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34007894:	f003 0301 	and.w	r3, r3, #1
34007898:	2b00      	cmp	r3, #0
3400789a:	d1ea      	bne.n	34007872 <HAL_BSEC_OTP_Reload+0x7e>
        }
      }

      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS) != 0U)
3400789c:	687b      	ldr	r3, [r7, #4]
3400789e:	681b      	ldr	r3, [r3, #0]
340078a0:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
340078a4:	f403 038c 	and.w	r3, r3, #4587520	@ 0x460000
340078a8:	2b00      	cmp	r3, #0
340078aa:	d013      	beq.n	340078d4 <HAL_BSEC_OTP_Reload+0xe0>
      {
        /* An error occurred during reloading, value can't be relied on */
        hbsec->ErrorCode = (hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS);
340078ac:	687b      	ldr	r3, [r7, #4]
340078ae:	681b      	ldr	r3, [r3, #0]
340078b0:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
340078b4:	f403 028c 	and.w	r2, r3, #4587520	@ 0x460000
340078b8:	687b      	ldr	r3, [r7, #4]
340078ba:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
340078bc:	2301      	movs	r3, #1
340078be:	e00a      	b.n	340078d6 <HAL_BSEC_OTP_Reload+0xe2>
      }
    }
    else
    {
      /* Shadow register is sticky reload locked */
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
340078c0:	687b      	ldr	r3, [r7, #4]
340078c2:	2204      	movs	r2, #4
340078c4:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
340078c6:	2301      	movs	r3, #1
340078c8:	e005      	b.n	340078d6 <HAL_BSEC_OTP_Reload+0xe2>
    }
  }
  else
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340078ca:	687b      	ldr	r3, [r7, #4]
340078cc:	2201      	movs	r2, #1
340078ce:	605a      	str	r2, [r3, #4]
    return HAL_ERROR;
340078d0:	2301      	movs	r3, #1
340078d2:	e000      	b.n	340078d6 <HAL_BSEC_OTP_Reload+0xe2>
  }

  return HAL_OK;
340078d4:	2300      	movs	r3, #0
}
340078d6:	4618      	mov	r0, r3
340078d8:	3718      	adds	r7, #24
340078da:	46bd      	mov	sp, r7
340078dc:	bd80      	pop	{r7, pc}
340078de:	bf00      	nop
340078e0:	56009000 	.word	0x56009000

340078e4 <HAL_CACHEAXI_Init>:
  * @note   In case HAL_CACHEAXI_Init() returns HAL_BUSY because an invalidation
  *         procedure is ongoing, the application should call again HAL_CACHEAXI_Init()
  *         until it returns HAL_OK to have the CACHEAXI enabled
  */
HAL_StatusTypeDef  HAL_CACHEAXI_Init(CACHEAXI_HandleTypeDef *hcacheaxi)
{
340078e4:	b580      	push	{r7, lr}
340078e6:	b084      	sub	sp, #16
340078e8:	af00      	add	r7, sp, #0
340078ea:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the CACHEAXI handle allocation */
  if (hcacheaxi == NULL)
340078ec:	687b      	ldr	r3, [r7, #4]
340078ee:	2b00      	cmp	r3, #0
340078f0:	d101      	bne.n	340078f6 <HAL_CACHEAXI_Init+0x12>
  {
    return HAL_ERROR;
340078f2:	2301      	movs	r3, #1
340078f4:	e021      	b.n	3400793a <HAL_CACHEAXI_Init+0x56>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
340078f6:	687b      	ldr	r3, [r7, #4]
340078f8:	681b      	ldr	r3, [r3, #0]
340078fa:	4a12      	ldr	r2, [pc, #72]	@ (34007944 <HAL_CACHEAXI_Init+0x60>)
340078fc:	4293      	cmp	r3, r2
340078fe:	d008      	beq.n	34007912 <HAL_CACHEAXI_Init+0x2e>
34007900:	687b      	ldr	r3, [r7, #4]
34007902:	681b      	ldr	r3, [r3, #0]
34007904:	4a10      	ldr	r2, [pc, #64]	@ (34007948 <HAL_CACHEAXI_Init+0x64>)
34007906:	4293      	cmp	r3, r2
34007908:	d003      	beq.n	34007912 <HAL_CACHEAXI_Init+0x2e>
3400790a:	21bc      	movs	r1, #188	@ 0xbc
3400790c:	480f      	ldr	r0, [pc, #60]	@ (3400794c <HAL_CACHEAXI_Init+0x68>)
3400790e:	f7f9 fcc3 	bl	34001298 <assert_failed>

  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34007912:	687b      	ldr	r3, [r7, #4]
34007914:	791b      	ldrb	r3, [r3, #4]
34007916:	b2db      	uxtb	r3, r3
34007918:	2b00      	cmp	r3, #0
3400791a:	d102      	bne.n	34007922 <HAL_CACHEAXI_Init+0x3e>

    /* Init the low level hardware */
    hcacheaxi->MspInitCallback(hcacheaxi);
#else
    /* Init the low level hardware */
    HAL_CACHEAXI_MspInit(hcacheaxi);
3400791c:	6878      	ldr	r0, [r7, #4]
3400791e:	f7f9 fca3 	bl	34001268 <HAL_CACHEAXI_MspInit>
#endif /* USE_HAL_CACHEAXI_REGISTER_CALLBACKS */
  }

  /* Init the error code */
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34007922:	687b      	ldr	r3, [r7, #4]
34007924:	2200      	movs	r2, #0
34007926:	609a      	str	r2, [r3, #8]

  /* Init the CACHEAXI handle state */
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34007928:	687b      	ldr	r3, [r7, #4]
3400792a:	2201      	movs	r2, #1
3400792c:	711a      	strb	r2, [r3, #4]

  /* Enable the selected CACHEAXI peripheral */
  status = HAL_CACHEAXI_Enable(hcacheaxi);
3400792e:	6878      	ldr	r0, [r7, #4]
34007930:	f000 f80e 	bl	34007950 <HAL_CACHEAXI_Enable>
34007934:	4603      	mov	r3, r0
34007936:	73fb      	strb	r3, [r7, #15]

  return status;
34007938:	7bfb      	ldrb	r3, [r7, #15]
}
3400793a:	4618      	mov	r0, r3
3400793c:	3710      	adds	r7, #16
3400793e:	46bd      	mov	sp, r7
34007940:	bd80      	pop	{r7, pc}
34007942:	bf00      	nop
34007944:	580dfc00 	.word	0x580dfc00
34007948:	480dfc00 	.word	0x480dfc00
3400794c:	34023ffc 	.word	0x34023ffc

34007950 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34007950:	b580      	push	{r7, lr}
34007952:	b084      	sub	sp, #16
34007954:	af00      	add	r7, sp, #0
34007956:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34007958:	2300      	movs	r3, #0
3400795a:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
3400795c:	687b      	ldr	r3, [r7, #4]
3400795e:	2b00      	cmp	r3, #0
34007960:	d101      	bne.n	34007966 <HAL_CACHEAXI_Enable+0x16>
  {
    return HAL_ERROR;
34007962:	2301      	movs	r3, #1
34007964:	e043      	b.n	340079ee <HAL_CACHEAXI_Enable+0x9e>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
34007966:	687b      	ldr	r3, [r7, #4]
34007968:	681b      	ldr	r3, [r3, #0]
3400796a:	4a23      	ldr	r2, [pc, #140]	@ (340079f8 <HAL_CACHEAXI_Enable+0xa8>)
3400796c:	4293      	cmp	r3, r2
3400796e:	d009      	beq.n	34007984 <HAL_CACHEAXI_Enable+0x34>
34007970:	687b      	ldr	r3, [r7, #4]
34007972:	681b      	ldr	r3, [r3, #0]
34007974:	4a21      	ldr	r2, [pc, #132]	@ (340079fc <HAL_CACHEAXI_Enable+0xac>)
34007976:	4293      	cmp	r3, r2
34007978:	d004      	beq.n	34007984 <HAL_CACHEAXI_Enable+0x34>
3400797a:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
3400797e:	4820      	ldr	r0, [pc, #128]	@ (34007a00 <HAL_CACHEAXI_Enable+0xb0>)
34007980:	f7f9 fc8a 	bl	34001298 <assert_failed>

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34007984:	687b      	ldr	r3, [r7, #4]
34007986:	681b      	ldr	r3, [r3, #0]
34007988:	685b      	ldr	r3, [r3, #4]
3400798a:	f003 0301 	and.w	r3, r3, #1
3400798e:	2b00      	cmp	r3, #0
34007990:	d01e      	beq.n	340079d0 <HAL_CACHEAXI_Enable+0x80>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34007992:	f7ff fe25 	bl	340075e0 <HAL_GetTick>
34007996:	60b8      	str	r0, [r7, #8]

    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34007998:	e013      	b.n	340079c2 <HAL_CACHEAXI_Enable+0x72>
    {
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
3400799a:	f7ff fe21 	bl	340075e0 <HAL_GetTick>
3400799e:	4602      	mov	r2, r0
340079a0:	68bb      	ldr	r3, [r7, #8]
340079a2:	1ad3      	subs	r3, r2, r3
340079a4:	2b01      	cmp	r3, #1
340079a6:	d90c      	bls.n	340079c2 <HAL_CACHEAXI_Enable+0x72>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
340079a8:	687b      	ldr	r3, [r7, #4]
340079aa:	681b      	ldr	r3, [r3, #0]
340079ac:	685b      	ldr	r3, [r3, #4]
340079ae:	f003 0301 	and.w	r3, r3, #1
340079b2:	2b00      	cmp	r3, #0
340079b4:	d105      	bne.n	340079c2 <HAL_CACHEAXI_Enable+0x72>
        {
          /* Update error code */
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
340079b6:	687b      	ldr	r3, [r7, #4]
340079b8:	2210      	movs	r2, #16
340079ba:	609a      	str	r2, [r3, #8]
          /* Return error status */
          status =  HAL_ERROR;
340079bc:	2301      	movs	r3, #1
340079be:	73fb      	strb	r3, [r7, #15]
          break;
340079c0:	e006      	b.n	340079d0 <HAL_CACHEAXI_Enable+0x80>
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
340079c2:	687b      	ldr	r3, [r7, #4]
340079c4:	681b      	ldr	r3, [r3, #0]
340079c6:	685b      	ldr	r3, [r3, #4]
340079c8:	f003 0301 	and.w	r3, r3, #1
340079cc:	2b00      	cmp	r3, #0
340079ce:	d1e4      	bne.n	3400799a <HAL_CACHEAXI_Enable+0x4a>
        }
      }
    }
  }

  if (status == HAL_OK)
340079d0:	7bfb      	ldrb	r3, [r7, #15]
340079d2:	2b00      	cmp	r3, #0
340079d4:	d10a      	bne.n	340079ec <HAL_CACHEAXI_Enable+0x9c>
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
340079d6:	687b      	ldr	r3, [r7, #4]
340079d8:	2200      	movs	r2, #0
340079da:	609a      	str	r2, [r3, #8]
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
340079dc:	687b      	ldr	r3, [r7, #4]
340079de:	681b      	ldr	r3, [r3, #0]
340079e0:	681a      	ldr	r2, [r3, #0]
340079e2:	687b      	ldr	r3, [r7, #4]
340079e4:	681b      	ldr	r3, [r3, #0]
340079e6:	f042 0201 	orr.w	r2, r2, #1
340079ea:	601a      	str	r2, [r3, #0]
  }

  return status;
340079ec:	7bfb      	ldrb	r3, [r7, #15]
}
340079ee:	4618      	mov	r0, r3
340079f0:	3710      	adds	r7, #16
340079f2:	46bd      	mov	sp, r7
340079f4:	bd80      	pop	{r7, pc}
340079f6:	bf00      	nop
340079f8:	580dfc00 	.word	0x580dfc00
340079fc:	480dfc00 	.word	0x480dfc00
34007a00:	34023ffc 	.word	0x34023ffc

34007a04 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34007a04:	b480      	push	{r7}
34007a06:	b085      	sub	sp, #20
34007a08:	af00      	add	r7, sp, #0
34007a0a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34007a0c:	687b      	ldr	r3, [r7, #4]
34007a0e:	f003 0307 	and.w	r3, r3, #7
34007a12:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34007a14:	4b0c      	ldr	r3, [pc, #48]	@ (34007a48 <__NVIC_SetPriorityGrouping+0x44>)
34007a16:	68db      	ldr	r3, [r3, #12]
34007a18:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34007a1a:	68ba      	ldr	r2, [r7, #8]
34007a1c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34007a20:	4013      	ands	r3, r2
34007a22:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34007a24:	68fb      	ldr	r3, [r7, #12]
34007a26:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34007a28:	68bb      	ldr	r3, [r7, #8]
34007a2a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34007a2c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34007a30:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34007a34:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34007a36:	4a04      	ldr	r2, [pc, #16]	@ (34007a48 <__NVIC_SetPriorityGrouping+0x44>)
34007a38:	68bb      	ldr	r3, [r7, #8]
34007a3a:	60d3      	str	r3, [r2, #12]
}
34007a3c:	bf00      	nop
34007a3e:	3714      	adds	r7, #20
34007a40:	46bd      	mov	sp, r7
34007a42:	f85d 7b04 	ldr.w	r7, [sp], #4
34007a46:	4770      	bx	lr
34007a48:	e000ed00 	.word	0xe000ed00

34007a4c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34007a4c:	b480      	push	{r7}
34007a4e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34007a50:	4b04      	ldr	r3, [pc, #16]	@ (34007a64 <__NVIC_GetPriorityGrouping+0x18>)
34007a52:	68db      	ldr	r3, [r3, #12]
34007a54:	0a1b      	lsrs	r3, r3, #8
34007a56:	f003 0307 	and.w	r3, r3, #7
}
34007a5a:	4618      	mov	r0, r3
34007a5c:	46bd      	mov	sp, r7
34007a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
34007a62:	4770      	bx	lr
34007a64:	e000ed00 	.word	0xe000ed00

34007a68 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34007a68:	b480      	push	{r7}
34007a6a:	b083      	sub	sp, #12
34007a6c:	af00      	add	r7, sp, #0
34007a6e:	4603      	mov	r3, r0
34007a70:	6039      	str	r1, [r7, #0]
34007a72:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34007a74:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34007a78:	2b00      	cmp	r3, #0
34007a7a:	db0a      	blt.n	34007a92 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34007a7c:	683b      	ldr	r3, [r7, #0]
34007a7e:	b2da      	uxtb	r2, r3
34007a80:	490c      	ldr	r1, [pc, #48]	@ (34007ab4 <__NVIC_SetPriority+0x4c>)
34007a82:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34007a86:	0112      	lsls	r2, r2, #4
34007a88:	b2d2      	uxtb	r2, r2
34007a8a:	440b      	add	r3, r1
34007a8c:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34007a90:	e00a      	b.n	34007aa8 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34007a92:	683b      	ldr	r3, [r7, #0]
34007a94:	b2da      	uxtb	r2, r3
34007a96:	4908      	ldr	r1, [pc, #32]	@ (34007ab8 <__NVIC_SetPriority+0x50>)
34007a98:	88fb      	ldrh	r3, [r7, #6]
34007a9a:	f003 030f 	and.w	r3, r3, #15
34007a9e:	3b04      	subs	r3, #4
34007aa0:	0112      	lsls	r2, r2, #4
34007aa2:	b2d2      	uxtb	r2, r2
34007aa4:	440b      	add	r3, r1
34007aa6:	761a      	strb	r2, [r3, #24]
}
34007aa8:	bf00      	nop
34007aaa:	370c      	adds	r7, #12
34007aac:	46bd      	mov	sp, r7
34007aae:	f85d 7b04 	ldr.w	r7, [sp], #4
34007ab2:	4770      	bx	lr
34007ab4:	e000e100 	.word	0xe000e100
34007ab8:	e000ed00 	.word	0xe000ed00

34007abc <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34007abc:	b480      	push	{r7}
34007abe:	b089      	sub	sp, #36	@ 0x24
34007ac0:	af00      	add	r7, sp, #0
34007ac2:	60f8      	str	r0, [r7, #12]
34007ac4:	60b9      	str	r1, [r7, #8]
34007ac6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34007ac8:	68fb      	ldr	r3, [r7, #12]
34007aca:	f003 0307 	and.w	r3, r3, #7
34007ace:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34007ad0:	69fb      	ldr	r3, [r7, #28]
34007ad2:	f1c3 0307 	rsb	r3, r3, #7
34007ad6:	2b04      	cmp	r3, #4
34007ad8:	bf28      	it	cs
34007ada:	2304      	movcs	r3, #4
34007adc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34007ade:	69fb      	ldr	r3, [r7, #28]
34007ae0:	3304      	adds	r3, #4
34007ae2:	2b06      	cmp	r3, #6
34007ae4:	d902      	bls.n	34007aec <NVIC_EncodePriority+0x30>
34007ae6:	69fb      	ldr	r3, [r7, #28]
34007ae8:	3b03      	subs	r3, #3
34007aea:	e000      	b.n	34007aee <NVIC_EncodePriority+0x32>
34007aec:	2300      	movs	r3, #0
34007aee:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34007af0:	f04f 32ff 	mov.w	r2, #4294967295
34007af4:	69bb      	ldr	r3, [r7, #24]
34007af6:	fa02 f303 	lsl.w	r3, r2, r3
34007afa:	43da      	mvns	r2, r3
34007afc:	68bb      	ldr	r3, [r7, #8]
34007afe:	401a      	ands	r2, r3
34007b00:	697b      	ldr	r3, [r7, #20]
34007b02:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34007b04:	f04f 31ff 	mov.w	r1, #4294967295
34007b08:	697b      	ldr	r3, [r7, #20]
34007b0a:	fa01 f303 	lsl.w	r3, r1, r3
34007b0e:	43d9      	mvns	r1, r3
34007b10:	687b      	ldr	r3, [r7, #4]
34007b12:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34007b14:	4313      	orrs	r3, r2
         );
}
34007b16:	4618      	mov	r0, r3
34007b18:	3724      	adds	r7, #36	@ 0x24
34007b1a:	46bd      	mov	sp, r7
34007b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34007b20:	4770      	bx	lr
	...

34007b24 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34007b24:	b580      	push	{r7, lr}
34007b26:	b082      	sub	sp, #8
34007b28:	af00      	add	r7, sp, #0
34007b2a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34007b2c:	687b      	ldr	r3, [r7, #4]
34007b2e:	3b01      	subs	r3, #1
34007b30:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34007b34:	d301      	bcc.n	34007b3a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
34007b36:	2301      	movs	r3, #1
34007b38:	e00f      	b.n	34007b5a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34007b3a:	4a0a      	ldr	r2, [pc, #40]	@ (34007b64 <SysTick_Config+0x40>)
34007b3c:	687b      	ldr	r3, [r7, #4]
34007b3e:	3b01      	subs	r3, #1
34007b40:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
34007b42:	210f      	movs	r1, #15
34007b44:	f04f 30ff 	mov.w	r0, #4294967295
34007b48:	f7ff ff8e 	bl	34007a68 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34007b4c:	4b05      	ldr	r3, [pc, #20]	@ (34007b64 <SysTick_Config+0x40>)
34007b4e:	2200      	movs	r2, #0
34007b50:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34007b52:	4b04      	ldr	r3, [pc, #16]	@ (34007b64 <SysTick_Config+0x40>)
34007b54:	2207      	movs	r2, #7
34007b56:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34007b58:	2300      	movs	r3, #0
}
34007b5a:	4618      	mov	r0, r3
34007b5c:	3708      	adds	r7, #8
34007b5e:	46bd      	mov	sp, r7
34007b60:	bd80      	pop	{r7, pc}
34007b62:	bf00      	nop
34007b64:	e000e010 	.word	0xe000e010

34007b68 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34007b68:	b580      	push	{r7, lr}
34007b6a:	b082      	sub	sp, #8
34007b6c:	af00      	add	r7, sp, #0
34007b6e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
34007b70:	687b      	ldr	r3, [r7, #4]
34007b72:	2b07      	cmp	r3, #7
34007b74:	d00f      	beq.n	34007b96 <HAL_NVIC_SetPriorityGrouping+0x2e>
34007b76:	687b      	ldr	r3, [r7, #4]
34007b78:	2b06      	cmp	r3, #6
34007b7a:	d00c      	beq.n	34007b96 <HAL_NVIC_SetPriorityGrouping+0x2e>
34007b7c:	687b      	ldr	r3, [r7, #4]
34007b7e:	2b05      	cmp	r3, #5
34007b80:	d009      	beq.n	34007b96 <HAL_NVIC_SetPriorityGrouping+0x2e>
34007b82:	687b      	ldr	r3, [r7, #4]
34007b84:	2b04      	cmp	r3, #4
34007b86:	d006      	beq.n	34007b96 <HAL_NVIC_SetPriorityGrouping+0x2e>
34007b88:	687b      	ldr	r3, [r7, #4]
34007b8a:	2b03      	cmp	r3, #3
34007b8c:	d003      	beq.n	34007b96 <HAL_NVIC_SetPriorityGrouping+0x2e>
34007b8e:	21e6      	movs	r1, #230	@ 0xe6
34007b90:	4804      	ldr	r0, [pc, #16]	@ (34007ba4 <HAL_NVIC_SetPriorityGrouping+0x3c>)
34007b92:	f7f9 fb81 	bl	34001298 <assert_failed>

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34007b96:	6878      	ldr	r0, [r7, #4]
34007b98:	f7ff ff34 	bl	34007a04 <__NVIC_SetPriorityGrouping>
}
34007b9c:	bf00      	nop
34007b9e:	3708      	adds	r7, #8
34007ba0:	46bd      	mov	sp, r7
34007ba2:	bd80      	pop	{r7, pc}
34007ba4:	34024070 	.word	0x34024070

34007ba8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34007ba8:	b580      	push	{r7, lr}
34007baa:	b086      	sub	sp, #24
34007bac:	af00      	add	r7, sp, #0
34007bae:	4603      	mov	r3, r0
34007bb0:	60b9      	str	r1, [r7, #8]
34007bb2:	607a      	str	r2, [r7, #4]
34007bb4:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34007bb6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34007bba:	f113 0f0c 	cmn.w	r3, #12
34007bbe:	db04      	blt.n	34007bca <HAL_NVIC_SetPriority+0x22>
34007bc0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34007bc4:	f113 0f04 	cmn.w	r3, #4
34007bc8:	d103      	bne.n	34007bd2 <HAL_NVIC_SetPriority+0x2a>
34007bca:	21ff      	movs	r1, #255	@ 0xff
34007bcc:	4822      	ldr	r0, [pc, #136]	@ (34007c58 <HAL_NVIC_SetPriority+0xb0>)
34007bce:	f7f9 fb63 	bl	34001298 <assert_failed>

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34007bd2:	f7ff ff3b 	bl	34007a4c <__NVIC_GetPriorityGrouping>
34007bd6:	4603      	mov	r3, r0
34007bd8:	f003 0307 	and.w	r3, r3, #7
34007bdc:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
34007bde:	697b      	ldr	r3, [r7, #20]
34007be0:	2b02      	cmp	r3, #2
34007be2:	d806      	bhi.n	34007bf2 <HAL_NVIC_SetPriority+0x4a>
34007be4:	687b      	ldr	r3, [r7, #4]
34007be6:	2b00      	cmp	r3, #0
34007be8:	bf0c      	ite	eq
34007bea:	2301      	moveq	r3, #1
34007bec:	2300      	movne	r3, #0
34007bee:	b2db      	uxtb	r3, r3
34007bf0:	e00a      	b.n	34007c08 <HAL_NVIC_SetPriority+0x60>
34007bf2:	697b      	ldr	r3, [r7, #20]
34007bf4:	3b03      	subs	r3, #3
34007bf6:	2201      	movs	r2, #1
34007bf8:	fa02 f303 	lsl.w	r3, r2, r3
34007bfc:	687a      	ldr	r2, [r7, #4]
34007bfe:	429a      	cmp	r2, r3
34007c00:	bf34      	ite	cc
34007c02:	2301      	movcc	r3, #1
34007c04:	2300      	movcs	r3, #0
34007c06:	b2db      	uxtb	r3, r3
34007c08:	2b00      	cmp	r3, #0
34007c0a:	d104      	bne.n	34007c16 <HAL_NVIC_SetPriority+0x6e>
34007c0c:	f44f 7181 	mov.w	r1, #258	@ 0x102
34007c10:	4811      	ldr	r0, [pc, #68]	@ (34007c58 <HAL_NVIC_SetPriority+0xb0>)
34007c12:	f7f9 fb41 	bl	34001298 <assert_failed>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));
34007c16:	68bb      	ldr	r3, [r7, #8]
34007c18:	2b0f      	cmp	r3, #15
34007c1a:	d808      	bhi.n	34007c2e <HAL_NVIC_SetPriority+0x86>
34007c1c:	697b      	ldr	r3, [r7, #20]
34007c1e:	f1c3 0307 	rsb	r3, r3, #7
34007c22:	2201      	movs	r2, #1
34007c24:	fa02 f303 	lsl.w	r3, r2, r3
34007c28:	68ba      	ldr	r2, [r7, #8]
34007c2a:	429a      	cmp	r2, r3
34007c2c:	d304      	bcc.n	34007c38 <HAL_NVIC_SetPriority+0x90>
34007c2e:	f240 1103 	movw	r1, #259	@ 0x103
34007c32:	4809      	ldr	r0, [pc, #36]	@ (34007c58 <HAL_NVIC_SetPriority+0xb0>)
34007c34:	f7f9 fb30 	bl	34001298 <assert_failed>

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
34007c38:	687a      	ldr	r2, [r7, #4]
34007c3a:	68b9      	ldr	r1, [r7, #8]
34007c3c:	6978      	ldr	r0, [r7, #20]
34007c3e:	f7ff ff3d 	bl	34007abc <NVIC_EncodePriority>
34007c42:	4602      	mov	r2, r0
34007c44:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34007c48:	4611      	mov	r1, r2
34007c4a:	4618      	mov	r0, r3
34007c4c:	f7ff ff0c 	bl	34007a68 <__NVIC_SetPriority>
}
34007c50:	bf00      	nop
34007c52:	3718      	adds	r7, #24
34007c54:	46bd      	mov	sp, r7
34007c56:	bd80      	pop	{r7, pc}
34007c58:	34024070 	.word	0x34024070

34007c5c <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34007c5c:	b580      	push	{r7, lr}
34007c5e:	b082      	sub	sp, #8
34007c60:	af00      	add	r7, sp, #0
34007c62:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34007c64:	6878      	ldr	r0, [r7, #4]
34007c66:	f7ff ff5d 	bl	34007b24 <SysTick_Config>
34007c6a:	4603      	mov	r3, r0
}
34007c6c:	4618      	mov	r0, r3
34007c6e:	3708      	adds	r7, #8
34007c70:	46bd      	mov	sp, r7
34007c72:	bd80      	pop	{r7, pc}

34007c74 <HAL_DCMIPP_IRQHandler>:
  * @brief  Handles DCMIPP interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34007c74:	b580      	push	{r7, lr}
34007c76:	b084      	sub	sp, #16
34007c78:	af00      	add	r7, sp, #0
34007c7a:	6078      	str	r0, [r7, #4]
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34007c7c:	687b      	ldr	r3, [r7, #4]
34007c7e:	681b      	ldr	r3, [r3, #0]
34007c80:	f8d3 33f8 	ldr.w	r3, [r3, #1016]	@ 0x3f8
34007c84:	60fb      	str	r3, [r7, #12]
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
34007c86:	687b      	ldr	r3, [r7, #4]
34007c88:	681b      	ldr	r3, [r3, #0]
34007c8a:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
34007c8e:	60bb      	str	r3, [r7, #8]

  /* ========================= PIPE0 INTERRUPTS ==================== */
  /* Limit error on the PIPE0 ********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34007c90:	68fb      	ldr	r3, [r7, #12]
34007c92:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34007c96:	2b00      	cmp	r3, #0
34007c98:	d01e      	beq.n	34007cd8 <HAL_DCMIPP_IRQHandler+0x64>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34007c9a:	68bb      	ldr	r3, [r7, #8]
34007c9c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34007ca0:	2b00      	cmp	r3, #0
34007ca2:	d019      	beq.n	34007cd8 <HAL_DCMIPP_IRQHandler+0x64>
    {
      /* Disable Limit error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34007ca4:	687b      	ldr	r3, [r7, #4]
34007ca6:	681b      	ldr	r3, [r3, #0]
34007ca8:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007cac:	687b      	ldr	r3, [r7, #4]
34007cae:	681b      	ldr	r3, [r3, #0]
34007cb0:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34007cb4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34007cb8:	687b      	ldr	r3, [r7, #4]
34007cba:	689b      	ldr	r3, [r3, #8]
34007cbc:	f043 0204 	orr.w	r2, r3, #4
34007cc0:	687b      	ldr	r3, [r7, #4]
34007cc2:	609a      	str	r2, [r3, #8]

      /* Clear the Limit error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
34007cc4:	687b      	ldr	r3, [r7, #4]
34007cc6:	681b      	ldr	r3, [r3, #0]
34007cc8:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34007ccc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LIMIT Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34007cd0:	2100      	movs	r1, #0
34007cd2:	6878      	ldr	r0, [r7, #4]
34007cd4:	f000 fe67 	bl	340089a6 <HAL_DCMIPP_PIPE_LimitEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
34007cd8:	68fb      	ldr	r3, [r7, #12]
34007cda:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34007cde:	2b00      	cmp	r3, #0
34007ce0:	d00e      	beq.n	34007d00 <HAL_DCMIPP_IRQHandler+0x8c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
34007ce2:	68bb      	ldr	r3, [r7, #8]
34007ce4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34007ce8:	2b00      	cmp	r3, #0
34007cea:	d009      	beq.n	34007d00 <HAL_DCMIPP_IRQHandler+0x8c>
    {
      /* Clear the VSYNC flag for pipe0 */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34007cec:	687b      	ldr	r3, [r7, #4]
34007cee:	681b      	ldr	r3, [r3, #0]
34007cf0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34007cf4:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34007cf8:	2100      	movs	r1, #0
34007cfa:	6878      	ldr	r0, [r7, #4]
34007cfc:	f014 faec 	bl	3401c2d8 <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* FRAME interrupt management ****************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34007d00:	68fb      	ldr	r3, [r7, #12]
34007d02:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007d06:	2b00      	cmp	r3, #0
34007d08:	d023      	beq.n	34007d52 <HAL_DCMIPP_IRQHandler+0xde>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
34007d0a:	68bb      	ldr	r3, [r7, #8]
34007d0c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007d10:	2b00      	cmp	r3, #0
34007d12:	d01e      	beq.n	34007d52 <HAL_DCMIPP_IRQHandler+0xde>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007d14:	687b      	ldr	r3, [r7, #4]
34007d16:	681b      	ldr	r3, [r3, #0]
34007d18:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007d1c:	f003 0304 	and.w	r3, r3, #4
34007d20:	2b04      	cmp	r3, #4
34007d22:	d10c      	bne.n	34007d3e <HAL_DCMIPP_IRQHandler+0xca>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34007d24:	687b      	ldr	r3, [r7, #4]
34007d26:	681b      	ldr	r3, [r3, #0]
34007d28:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007d2c:	687b      	ldr	r3, [r7, #4]
34007d2e:	681b      	ldr	r3, [r3, #0]
34007d30:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34007d34:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34007d38:	687b      	ldr	r3, [r7, #4]
34007d3a:	2201      	movs	r2, #1
34007d3c:	715a      	strb	r2, [r3, #5]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34007d3e:	687b      	ldr	r3, [r7, #4]
34007d40:	681b      	ldr	r3, [r3, #0]
34007d42:	f44f 7200 	mov.w	r2, #512	@ 0x200
34007d46:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34007d4a:	2100      	movs	r1, #0
34007d4c:	6878      	ldr	r0, [r7, #4]
34007d4e:	f014 fadd 	bl	3401c30c <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* LINE interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34007d52:	68fb      	ldr	r3, [r7, #12]
34007d54:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34007d58:	2b00      	cmp	r3, #0
34007d5a:	d00e      	beq.n	34007d7a <HAL_DCMIPP_IRQHandler+0x106>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34007d5c:	68bb      	ldr	r3, [r7, #8]
34007d5e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34007d62:	2b00      	cmp	r3, #0
34007d64:	d009      	beq.n	34007d7a <HAL_DCMIPP_IRQHandler+0x106>
    {
      /* Clear the LINE flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34007d66:	687b      	ldr	r3, [r7, #4]
34007d68:	681b      	ldr	r3, [r3, #0]
34007d6a:	f44f 7280 	mov.w	r2, #256	@ 0x100
34007d6e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LINE Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34007d72:	2100      	movs	r1, #0
34007d74:	6878      	ldr	r0, [r7, #4]
34007d76:	f000 fe0b 	bl	34008990 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error interrupt for Pipe0 ***************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
34007d7a:	68fb      	ldr	r3, [r7, #12]
34007d7c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34007d80:	2b00      	cmp	r3, #0
34007d82:	d021      	beq.n	34007dc8 <HAL_DCMIPP_IRQHandler+0x154>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34007d84:	68bb      	ldr	r3, [r7, #8]
34007d86:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34007d8a:	2b00      	cmp	r3, #0
34007d8c:	d01c      	beq.n	34007dc8 <HAL_DCMIPP_IRQHandler+0x154>
    {
      /* Disable Overrun Error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34007d8e:	687b      	ldr	r3, [r7, #4]
34007d90:	681b      	ldr	r3, [r3, #0]
34007d92:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007d96:	687b      	ldr	r3, [r7, #4]
34007d98:	681b      	ldr	r3, [r3, #0]
34007d9a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34007d9e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34007da2:	687b      	ldr	r3, [r7, #4]
34007da4:	689b      	ldr	r3, [r3, #8]
34007da6:	f043 0208 	orr.w	r2, r3, #8
34007daa:	687b      	ldr	r3, [r7, #4]
34007dac:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34007dae:	687b      	ldr	r3, [r7, #4]
34007db0:	681b      	ldr	r3, [r3, #0]
34007db2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34007db6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP Pipe state */
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
34007dba:	687b      	ldr	r3, [r7, #4]
34007dbc:	2204      	movs	r2, #4
34007dbe:	715a      	strb	r2, [r3, #5]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34007dc0:	2100      	movs	r1, #0
34007dc2:	6878      	ldr	r0, [r7, #4]
34007dc4:	f000 fdfa 	bl	340089bc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE1 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34007dc8:	68fb      	ldr	r3, [r7, #12]
34007dca:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34007dce:	2b00      	cmp	r3, #0
34007dd0:	d00e      	beq.n	34007df0 <HAL_DCMIPP_IRQHandler+0x17c>
  {
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34007dd2:	68bb      	ldr	r3, [r7, #8]
34007dd4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34007dd8:	2b00      	cmp	r3, #0
34007dda:	d009      	beq.n	34007df0 <HAL_DCMIPP_IRQHandler+0x17c>
    {
      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34007ddc:	687b      	ldr	r3, [r7, #4]
34007dde:	681b      	ldr	r3, [r3, #0]
34007de0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34007de4:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34007de8:	2101      	movs	r1, #1
34007dea:	6878      	ldr	r0, [r7, #4]
34007dec:	f000 fdd0 	bl	34008990 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
34007df0:	68fb      	ldr	r3, [r7, #12]
34007df2:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34007df6:	2b00      	cmp	r3, #0
34007df8:	d00e      	beq.n	34007e18 <HAL_DCMIPP_IRQHandler+0x1a4>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
34007dfa:	68bb      	ldr	r3, [r7, #8]
34007dfc:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34007e00:	2b00      	cmp	r3, #0
34007e02:	d009      	beq.n	34007e18 <HAL_DCMIPP_IRQHandler+0x1a4>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34007e04:	687b      	ldr	r3, [r7, #4]
34007e06:	681b      	ldr	r3, [r3, #0]
34007e08:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34007e0c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34007e10:	2101      	movs	r1, #1
34007e12:	6878      	ldr	r0, [r7, #4]
34007e14:	f014 fa60 	bl	3401c2d8 <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34007e18:	68fb      	ldr	r3, [r7, #12]
34007e1a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34007e1e:	2b00      	cmp	r3, #0
34007e20:	d023      	beq.n	34007e6a <HAL_DCMIPP_IRQHandler+0x1f6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34007e22:	68bb      	ldr	r3, [r7, #8]
34007e24:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34007e28:	2b00      	cmp	r3, #0
34007e2a:	d01e      	beq.n	34007e6a <HAL_DCMIPP_IRQHandler+0x1f6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007e2c:	687b      	ldr	r3, [r7, #4]
34007e2e:	681b      	ldr	r3, [r3, #0]
34007e30:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34007e34:	f003 0304 	and.w	r3, r3, #4
34007e38:	2b04      	cmp	r3, #4
34007e3a:	d10c      	bne.n	34007e56 <HAL_DCMIPP_IRQHandler+0x1e2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34007e3c:	687b      	ldr	r3, [r7, #4]
34007e3e:	681b      	ldr	r3, [r3, #0]
34007e40:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007e44:	687b      	ldr	r3, [r7, #4]
34007e46:	681b      	ldr	r3, [r3, #0]
34007e48:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34007e4c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34007e50:	687b      	ldr	r3, [r7, #4]
34007e52:	2201      	movs	r2, #1
34007e54:	719a      	strb	r2, [r3, #6]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34007e56:	687b      	ldr	r3, [r7, #4]
34007e58:	681b      	ldr	r3, [r3, #0]
34007e5a:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34007e5e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34007e62:	2101      	movs	r1, #1
34007e64:	6878      	ldr	r0, [r7, #4]
34007e66:	f014 fa51 	bl	3401c30c <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error on the PIPE1 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
34007e6a:	68fb      	ldr	r3, [r7, #12]
34007e6c:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34007e70:	2b00      	cmp	r3, #0
34007e72:	d021      	beq.n	34007eb8 <HAL_DCMIPP_IRQHandler+0x244>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34007e74:	68bb      	ldr	r3, [r7, #8]
34007e76:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34007e7a:	2b00      	cmp	r3, #0
34007e7c:	d01c      	beq.n	34007eb8 <HAL_DCMIPP_IRQHandler+0x244>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34007e7e:	687b      	ldr	r3, [r7, #4]
34007e80:	681b      	ldr	r3, [r3, #0]
34007e82:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007e86:	687b      	ldr	r3, [r7, #4]
34007e88:	681b      	ldr	r3, [r3, #0]
34007e8a:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34007e8e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34007e92:	687b      	ldr	r3, [r7, #4]
34007e94:	689b      	ldr	r3, [r3, #8]
34007e96:	f043 0210 	orr.w	r2, r3, #16
34007e9a:	687b      	ldr	r3, [r7, #4]
34007e9c:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34007e9e:	687b      	ldr	r3, [r7, #4]
34007ea0:	681b      	ldr	r3, [r3, #0]
34007ea2:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34007ea6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34007eaa:	687b      	ldr	r3, [r7, #4]
34007eac:	2204      	movs	r2, #4
34007eae:	719a      	strb	r2, [r3, #6]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34007eb0:	2101      	movs	r1, #1
34007eb2:	6878      	ldr	r0, [r7, #4]
34007eb4:	f000 fd82 	bl	340089bc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE2 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
34007eb8:	68fb      	ldr	r3, [r7, #12]
34007eba:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34007ebe:	2b00      	cmp	r3, #0
34007ec0:	d00e      	beq.n	34007ee0 <HAL_DCMIPP_IRQHandler+0x26c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34007ec2:	68bb      	ldr	r3, [r7, #8]
34007ec4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34007ec8:	2b00      	cmp	r3, #0
34007eca:	d009      	beq.n	34007ee0 <HAL_DCMIPP_IRQHandler+0x26c>
    {
      /* Clear the End of Line flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34007ecc:	687b      	ldr	r3, [r7, #4]
34007ece:	681b      	ldr	r3, [r3, #0]
34007ed0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34007ed4:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34007ed8:	2102      	movs	r1, #2
34007eda:	6878      	ldr	r0, [r7, #4]
34007edc:	f000 fd58 	bl	34008990 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34007ee0:	68fb      	ldr	r3, [r7, #12]
34007ee2:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34007ee6:	2b00      	cmp	r3, #0
34007ee8:	d00e      	beq.n	34007f08 <HAL_DCMIPP_IRQHandler+0x294>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
34007eea:	68bb      	ldr	r3, [r7, #8]
34007eec:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34007ef0:	2b00      	cmp	r3, #0
34007ef2:	d009      	beq.n	34007f08 <HAL_DCMIPP_IRQHandler+0x294>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34007ef4:	687b      	ldr	r3, [r7, #4]
34007ef6:	681b      	ldr	r3, [r3, #0]
34007ef8:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34007efc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34007f00:	2102      	movs	r1, #2
34007f02:	6878      	ldr	r0, [r7, #4]
34007f04:	f014 f9e8 	bl	3401c2d8 <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
34007f08:	68fb      	ldr	r3, [r7, #12]
34007f0a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34007f0e:	2b00      	cmp	r3, #0
34007f10:	d023      	beq.n	34007f5a <HAL_DCMIPP_IRQHandler+0x2e6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34007f12:	68bb      	ldr	r3, [r7, #8]
34007f14:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34007f18:	2b00      	cmp	r3, #0
34007f1a:	d01e      	beq.n	34007f5a <HAL_DCMIPP_IRQHandler+0x2e6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007f1c:	687b      	ldr	r3, [r7, #4]
34007f1e:	681b      	ldr	r3, [r3, #0]
34007f20:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34007f24:	f003 0304 	and.w	r3, r3, #4
34007f28:	2b04      	cmp	r3, #4
34007f2a:	d10c      	bne.n	34007f46 <HAL_DCMIPP_IRQHandler+0x2d2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34007f2c:	687b      	ldr	r3, [r7, #4]
34007f2e:	681b      	ldr	r3, [r3, #0]
34007f30:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007f34:	687b      	ldr	r3, [r7, #4]
34007f36:	681b      	ldr	r3, [r3, #0]
34007f38:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34007f3c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34007f40:	687b      	ldr	r3, [r7, #4]
34007f42:	2201      	movs	r2, #1
34007f44:	71da      	strb	r2, [r3, #7]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34007f46:	687b      	ldr	r3, [r7, #4]
34007f48:	681b      	ldr	r3, [r3, #0]
34007f4a:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34007f4e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34007f52:	2102      	movs	r1, #2
34007f54:	6878      	ldr	r0, [r7, #4]
34007f56:	f014 f9d9 	bl	3401c30c <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
  /* Overrun error on the PIPE2 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
34007f5a:	68fb      	ldr	r3, [r7, #12]
34007f5c:	2b00      	cmp	r3, #0
34007f5e:	da1f      	bge.n	34007fa0 <HAL_DCMIPP_IRQHandler+0x32c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34007f60:	68bb      	ldr	r3, [r7, #8]
34007f62:	2b00      	cmp	r3, #0
34007f64:	da1c      	bge.n	34007fa0 <HAL_DCMIPP_IRQHandler+0x32c>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34007f66:	687b      	ldr	r3, [r7, #4]
34007f68:	681b      	ldr	r3, [r3, #0]
34007f6a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007f6e:	687b      	ldr	r3, [r7, #4]
34007f70:	681b      	ldr	r3, [r3, #0]
34007f72:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34007f76:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
34007f7a:	687b      	ldr	r3, [r7, #4]
34007f7c:	689b      	ldr	r3, [r3, #8]
34007f7e:	f043 0220 	orr.w	r2, r3, #32
34007f82:	687b      	ldr	r3, [r7, #4]
34007f84:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34007f86:	687b      	ldr	r3, [r7, #4]
34007f88:	681b      	ldr	r3, [r3, #0]
34007f8a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34007f8e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34007f92:	687b      	ldr	r3, [r7, #4]
34007f94:	2204      	movs	r2, #4
34007f96:	71da      	strb	r2, [r3, #7]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34007f98:	2102      	movs	r1, #2
34007f9a:	6878      	ldr	r0, [r7, #4]
34007f9c:	f000 fd0e 	bl	340089bc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization Error Interrupt on the parallel interface  **************/
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34007fa0:	68fb      	ldr	r3, [r7, #12]
34007fa2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007fa6:	2b00      	cmp	r3, #0
34007fa8:	d01f      	beq.n	34007fea <HAL_DCMIPP_IRQHandler+0x376>
  {
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34007faa:	68bb      	ldr	r3, [r7, #8]
34007fac:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007fb0:	2b00      	cmp	r3, #0
34007fb2:	d01a      	beq.n	34007fea <HAL_DCMIPP_IRQHandler+0x376>
    {
      /* Disable Synchronization error interrupt on parallel interface */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34007fb4:	687b      	ldr	r3, [r7, #4]
34007fb6:	681b      	ldr	r3, [r3, #0]
34007fb8:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007fbc:	687b      	ldr	r3, [r7, #4]
34007fbe:	681b      	ldr	r3, [r3, #0]
34007fc0:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34007fc4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34007fc8:	687b      	ldr	r3, [r7, #4]
34007fca:	689b      	ldr	r3, [r3, #8]
34007fcc:	f043 0202 	orr.w	r2, r3, #2
34007fd0:	687b      	ldr	r3, [r7, #4]
34007fd2:	609a      	str	r2, [r3, #8]

      /* Clear the synchronization error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34007fd4:	687b      	ldr	r3, [r7, #4]
34007fd6:	681b      	ldr	r3, [r3, #0]
34007fd8:	2240      	movs	r2, #64	@ 0x40
34007fda:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34007fde:	687b      	ldr	r3, [r7, #4]
34007fe0:	2204      	movs	r2, #4
34007fe2:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34007fe4:	6878      	ldr	r0, [r7, #4]
34007fe6:	f000 fcf4 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* IPPLUG AXI transfer Error Interrupt     *********************************/
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34007fea:	68fb      	ldr	r3, [r7, #12]
34007fec:	f003 0320 	and.w	r3, r3, #32
34007ff0:	2b00      	cmp	r3, #0
34007ff2:	d01f      	beq.n	34008034 <HAL_DCMIPP_IRQHandler+0x3c0>
  {
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34007ff4:	68bb      	ldr	r3, [r7, #8]
34007ff6:	f003 0320 	and.w	r3, r3, #32
34007ffa:	2b00      	cmp	r3, #0
34007ffc:	d01a      	beq.n	34008034 <HAL_DCMIPP_IRQHandler+0x3c0>
    {
      /* Disable IPPLUG AXI transfer Error Interrupt */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34007ffe:	687b      	ldr	r3, [r7, #4]
34008000:	681b      	ldr	r3, [r3, #0]
34008002:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34008006:	687b      	ldr	r3, [r7, #4]
34008008:	681b      	ldr	r3, [r3, #0]
3400800a:	f022 0220 	bic.w	r2, r2, #32
3400800e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34008012:	687b      	ldr	r3, [r7, #4]
34008014:	689b      	ldr	r3, [r3, #8]
34008016:	f043 0201 	orr.w	r2, r3, #1
3400801a:	687b      	ldr	r3, [r7, #4]
3400801c:	609a      	str	r2, [r3, #8]

      /* Clear the AXI transfer error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
3400801e:	687b      	ldr	r3, [r7, #4]
34008020:	681b      	ldr	r3, [r3, #0]
34008022:	2220      	movs	r2, #32
34008024:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008028:	687b      	ldr	r3, [r7, #4]
3400802a:	2204      	movs	r2, #4
3400802c:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400802e:	6878      	ldr	r0, [r7, #4]
34008030:	f000 fccf 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34008034:	bf00      	nop
34008036:	3710      	adds	r7, #16
34008038:	46bd      	mov	sp, r7
3400803a:	bd80      	pop	{r7, pc}

3400803c <HAL_DCMIPP_CSI_IRQHandler>:
  * @brief  Handles DCMIPP CSI interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_CSI_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
3400803c:	b580      	push	{r7, lr}
3400803e:	b088      	sub	sp, #32
34008040:	af00      	add	r7, sp, #0
34008042:	6078      	str	r0, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34008044:	4bb1      	ldr	r3, [pc, #708]	@ (3400830c <HAL_DCMIPP_CSI_IRQHandler+0x2d0>)
34008046:	61fb      	str	r3, [r7, #28]

  /* Read the SR0 register once */
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34008048:	69fb      	ldr	r3, [r7, #28]
3400804a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400804e:	61bb      	str	r3, [r7, #24]
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34008050:	69fb      	ldr	r3, [r7, #28]
34008052:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34008056:	617b      	str	r3, [r7, #20]

  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
34008058:	69fb      	ldr	r3, [r7, #28]
3400805a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400805e:	613b      	str	r3, [r7, #16]
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34008060:	69fb      	ldr	r3, [r7, #28]
34008062:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34008066:	60fb      	str	r3, [r7, #12]

  /* Clock changer FIFO full event */
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34008068:	69bb      	ldr	r3, [r7, #24]
3400806a:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400806e:	2b00      	cmp	r3, #0
34008070:	d014      	beq.n	3400809c <HAL_DCMIPP_CSI_IRQHandler+0x60>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34008072:	693b      	ldr	r3, [r7, #16]
34008074:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34008078:	2b00      	cmp	r3, #0
3400807a:	d00f      	beq.n	3400809c <HAL_DCMIPP_CSI_IRQHandler+0x60>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
3400807c:	69fb      	ldr	r3, [r7, #28]
3400807e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008082:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
34008086:	69fb      	ldr	r3, [r7, #28]
34008088:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
3400808c:	69fb      	ldr	r3, [r7, #28]
3400808e:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34008092:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ClockChangerFifoFullEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
34008096:	6878      	ldr	r0, [r7, #4]
34008098:	f000 fcb0 	bl	340089fc <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  }

  /*###############################
     Byte/Line Counter Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
3400809c:	69bb      	ldr	r3, [r7, #24]
3400809e:	f003 0308 	and.w	r3, r3, #8
340080a2:	2b00      	cmp	r3, #0
340080a4:	d01c      	beq.n	340080e0 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
340080a6:	693b      	ldr	r3, [r7, #16]
340080a8:	f003 0308 	and.w	r3, r3, #8
340080ac:	2b00      	cmp	r3, #0
340080ae:	d017      	beq.n	340080e0 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340080b0:	687b      	ldr	r3, [r7, #4]
340080b2:	681b      	ldr	r3, [r3, #0]
340080b4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340080b8:	f003 0304 	and.w	r3, r3, #4
340080bc:	2b04      	cmp	r3, #4
340080be:	d107      	bne.n	340080d0 <HAL_DCMIPP_CSI_IRQHandler+0x94>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
340080c0:	69fb      	ldr	r3, [r7, #28]
340080c2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340080c6:	f023 0208 	bic.w	r2, r3, #8
340080ca:	69fb      	ldr	r3, [r7, #28]
340080cc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
340080d0:	69fb      	ldr	r3, [r7, #28]
340080d2:	2208      	movs	r2, #8
340080d4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340080d8:	2103      	movs	r1, #3
340080da:	6878      	ldr	r0, [r7, #4]
340080dc:	f000 fcc3 	bl	34008a66 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
340080e0:	69bb      	ldr	r3, [r7, #24]
340080e2:	f003 0304 	and.w	r3, r3, #4
340080e6:	2b00      	cmp	r3, #0
340080e8:	d01c      	beq.n	34008124 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
340080ea:	693b      	ldr	r3, [r7, #16]
340080ec:	f003 0304 	and.w	r3, r3, #4
340080f0:	2b00      	cmp	r3, #0
340080f2:	d017      	beq.n	34008124 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340080f4:	687b      	ldr	r3, [r7, #4]
340080f6:	681b      	ldr	r3, [r3, #0]
340080f8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340080fc:	f003 0304 	and.w	r3, r3, #4
34008100:	2b04      	cmp	r3, #4
34008102:	d107      	bne.n	34008114 <HAL_DCMIPP_CSI_IRQHandler+0xd8>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
34008104:	69fb      	ldr	r3, [r7, #28]
34008106:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400810a:	f023 0204 	bic.w	r2, r3, #4
3400810e:	69fb      	ldr	r3, [r7, #28]
34008110:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
34008114:	69fb      	ldr	r3, [r7, #28]
34008116:	2204      	movs	r2, #4
34008118:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
3400811c:	2102      	movs	r1, #2
3400811e:	6878      	ldr	r0, [r7, #4]
34008120:	f000 fca1 	bl	34008a66 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
34008124:	69bb      	ldr	r3, [r7, #24]
34008126:	f003 0302 	and.w	r3, r3, #2
3400812a:	2b00      	cmp	r3, #0
3400812c:	d01c      	beq.n	34008168 <HAL_DCMIPP_CSI_IRQHandler+0x12c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
3400812e:	693b      	ldr	r3, [r7, #16]
34008130:	f003 0302 	and.w	r3, r3, #2
34008134:	2b00      	cmp	r3, #0
34008136:	d017      	beq.n	34008168 <HAL_DCMIPP_CSI_IRQHandler+0x12c>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34008138:	687b      	ldr	r3, [r7, #4]
3400813a:	681b      	ldr	r3, [r3, #0]
3400813c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008140:	f003 0304 	and.w	r3, r3, #4
34008144:	2b04      	cmp	r3, #4
34008146:	d107      	bne.n	34008158 <HAL_DCMIPP_CSI_IRQHandler+0x11c>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
34008148:	69fb      	ldr	r3, [r7, #28]
3400814a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400814e:	f023 0202 	bic.w	r2, r3, #2
34008152:	69fb      	ldr	r3, [r7, #28]
34008154:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
34008158:	69fb      	ldr	r3, [r7, #28]
3400815a:	2202      	movs	r2, #2
3400815c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34008160:	2101      	movs	r1, #1
34008162:	6878      	ldr	r0, [r7, #4]
34008164:	f000 fc7f 	bl	34008a66 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34008168:	69bb      	ldr	r3, [r7, #24]
3400816a:	f003 0301 	and.w	r3, r3, #1
3400816e:	2b00      	cmp	r3, #0
34008170:	d01c      	beq.n	340081ac <HAL_DCMIPP_CSI_IRQHandler+0x170>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34008172:	693b      	ldr	r3, [r7, #16]
34008174:	f003 0301 	and.w	r3, r3, #1
34008178:	2b00      	cmp	r3, #0
3400817a:	d017      	beq.n	340081ac <HAL_DCMIPP_CSI_IRQHandler+0x170>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400817c:	687b      	ldr	r3, [r7, #4]
3400817e:	681b      	ldr	r3, [r3, #0]
34008180:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008184:	f003 0304 	and.w	r3, r3, #4
34008188:	2b04      	cmp	r3, #4
3400818a:	d107      	bne.n	3400819c <HAL_DCMIPP_CSI_IRQHandler+0x160>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
3400818c:	69fb      	ldr	r3, [r7, #28]
3400818e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008192:	f023 0201 	bic.w	r2, r3, #1
34008196:	69fb      	ldr	r3, [r7, #28]
34008198:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
3400819c:	69fb      	ldr	r3, [r7, #28]
3400819e:	2201      	movs	r2, #1
340081a0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
340081a4:	2100      	movs	r1, #0
340081a6:	6878      	ldr	r0, [r7, #4]
340081a8:	f000 fc5d 	bl	34008a66 <HAL_DCMIPP_CSI_LineByteEventCallback>
  }

  /*###############################
            End Of Frame
    ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
340081ac:	69bb      	ldr	r3, [r7, #24]
340081ae:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340081b2:	2b00      	cmp	r3, #0
340081b4:	d01d      	beq.n	340081f2 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
340081b6:	693b      	ldr	r3, [r7, #16]
340081b8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340081bc:	2b00      	cmp	r3, #0
340081be:	d018      	beq.n	340081f2 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340081c0:	687b      	ldr	r3, [r7, #4]
340081c2:	681b      	ldr	r3, [r3, #0]
340081c4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340081c8:	f003 0304 	and.w	r3, r3, #4
340081cc:	2b04      	cmp	r3, #4
340081ce:	d107      	bne.n	340081e0 <HAL_DCMIPP_CSI_IRQHandler+0x1a4>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
340081d0:	69fb      	ldr	r3, [r7, #28]
340081d2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340081d6:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
340081da:	69fb      	ldr	r3, [r7, #28]
340081dc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
340081e0:	69fb      	ldr	r3, [r7, #28]
340081e2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340081e6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
340081ea:	2103      	movs	r1, #3
340081ec:	6878      	ldr	r0, [r7, #4]
340081ee:	f000 fc19 	bl	34008a24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
340081f2:	69bb      	ldr	r3, [r7, #24]
340081f4:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
340081f8:	2b00      	cmp	r3, #0
340081fa:	d01d      	beq.n	34008238 <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
340081fc:	693b      	ldr	r3, [r7, #16]
340081fe:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34008202:	2b00      	cmp	r3, #0
34008204:	d018      	beq.n	34008238 <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34008206:	687b      	ldr	r3, [r7, #4]
34008208:	681b      	ldr	r3, [r3, #0]
3400820a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3400820e:	f003 0304 	and.w	r3, r3, #4
34008212:	2b04      	cmp	r3, #4
34008214:	d107      	bne.n	34008226 <HAL_DCMIPP_CSI_IRQHandler+0x1ea>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
34008216:	69fb      	ldr	r3, [r7, #28]
34008218:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400821c:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
34008220:	69fb      	ldr	r3, [r7, #28]
34008222:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
34008226:	69fb      	ldr	r3, [r7, #28]
34008228:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3400822c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34008230:	2102      	movs	r1, #2
34008232:	6878      	ldr	r0, [r7, #4]
34008234:	f000 fbf6 	bl	34008a24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
34008238:	69bb      	ldr	r3, [r7, #24]
3400823a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400823e:	2b00      	cmp	r3, #0
34008240:	d01d      	beq.n	3400827e <HAL_DCMIPP_CSI_IRQHandler+0x242>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
34008242:	693b      	ldr	r3, [r7, #16]
34008244:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34008248:	2b00      	cmp	r3, #0
3400824a:	d018      	beq.n	3400827e <HAL_DCMIPP_CSI_IRQHandler+0x242>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400824c:	687b      	ldr	r3, [r7, #4]
3400824e:	681b      	ldr	r3, [r3, #0]
34008250:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008254:	f003 0304 	and.w	r3, r3, #4
34008258:	2b04      	cmp	r3, #4
3400825a:	d107      	bne.n	3400826c <HAL_DCMIPP_CSI_IRQHandler+0x230>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
3400825c:	69fb      	ldr	r3, [r7, #28]
3400825e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008262:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
34008266:	69fb      	ldr	r3, [r7, #28]
34008268:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
3400826c:	69fb      	ldr	r3, [r7, #28]
3400826e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34008272:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34008276:	2101      	movs	r1, #1
34008278:	6878      	ldr	r0, [r7, #4]
3400827a:	f000 fbd3 	bl	34008a24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
3400827e:	69bb      	ldr	r3, [r7, #24]
34008280:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34008284:	2b00      	cmp	r3, #0
34008286:	d01d      	beq.n	340082c4 <HAL_DCMIPP_CSI_IRQHandler+0x288>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
34008288:	693b      	ldr	r3, [r7, #16]
3400828a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400828e:	2b00      	cmp	r3, #0
34008290:	d018      	beq.n	340082c4 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34008292:	687b      	ldr	r3, [r7, #4]
34008294:	681b      	ldr	r3, [r3, #0]
34008296:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3400829a:	f003 0304 	and.w	r3, r3, #4
3400829e:	2b04      	cmp	r3, #4
340082a0:	d107      	bne.n	340082b2 <HAL_DCMIPP_CSI_IRQHandler+0x276>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
340082a2:	69fb      	ldr	r3, [r7, #28]
340082a4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340082a8:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
340082ac:	69fb      	ldr	r3, [r7, #28]
340082ae:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
340082b2:	69fb      	ldr	r3, [r7, #28]
340082b4:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
340082b8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_CSIREGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340082bc:	2100      	movs	r1, #0
340082be:	6878      	ldr	r0, [r7, #4]
340082c0:	f000 fbb0 	bl	34008a24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  }

  /*###############################
           Start Of Frame
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
340082c4:	69bb      	ldr	r3, [r7, #24]
340082c6:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340082ca:	2b00      	cmp	r3, #0
340082cc:	d020      	beq.n	34008310 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
340082ce:	693b      	ldr	r3, [r7, #16]
340082d0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340082d4:	2b00      	cmp	r3, #0
340082d6:	d01b      	beq.n	34008310 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340082d8:	687b      	ldr	r3, [r7, #4]
340082da:	681b      	ldr	r3, [r3, #0]
340082dc:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340082e0:	f003 0304 	and.w	r3, r3, #4
340082e4:	2b04      	cmp	r3, #4
340082e6:	d107      	bne.n	340082f8 <HAL_DCMIPP_CSI_IRQHandler+0x2bc>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
340082e8:	69fb      	ldr	r3, [r7, #28]
340082ea:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340082ee:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
340082f2:	69fb      	ldr	r3, [r7, #28]
340082f4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
340082f8:	69fb      	ldr	r3, [r7, #28]
340082fa:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340082fe:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34008302:	2103      	movs	r1, #3
34008304:	6878      	ldr	r0, [r7, #4]
34008306:	f000 fb98 	bl	34008a3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
3400830a:	e001      	b.n	34008310 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
3400830c:	58006000 	.word	0x58006000
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
34008310:	69bb      	ldr	r3, [r7, #24]
34008312:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34008316:	2b00      	cmp	r3, #0
34008318:	d01d      	beq.n	34008356 <HAL_DCMIPP_CSI_IRQHandler+0x31a>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
3400831a:	693b      	ldr	r3, [r7, #16]
3400831c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34008320:	2b00      	cmp	r3, #0
34008322:	d018      	beq.n	34008356 <HAL_DCMIPP_CSI_IRQHandler+0x31a>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34008324:	687b      	ldr	r3, [r7, #4]
34008326:	681b      	ldr	r3, [r3, #0]
34008328:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3400832c:	f003 0304 	and.w	r3, r3, #4
34008330:	2b04      	cmp	r3, #4
34008332:	d107      	bne.n	34008344 <HAL_DCMIPP_CSI_IRQHandler+0x308>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34008334:	69fb      	ldr	r3, [r7, #28]
34008336:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400833a:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
3400833e:	69fb      	ldr	r3, [r7, #28]
34008340:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34008344:	69fb      	ldr	r3, [r7, #28]
34008346:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400834a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
3400834e:	2102      	movs	r1, #2
34008350:	6878      	ldr	r0, [r7, #4]
34008352:	f000 fb72 	bl	34008a3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
34008356:	69bb      	ldr	r3, [r7, #24]
34008358:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400835c:	2b00      	cmp	r3, #0
3400835e:	d01d      	beq.n	3400839c <HAL_DCMIPP_CSI_IRQHandler+0x360>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34008360:	693b      	ldr	r3, [r7, #16]
34008362:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34008366:	2b00      	cmp	r3, #0
34008368:	d018      	beq.n	3400839c <HAL_DCMIPP_CSI_IRQHandler+0x360>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400836a:	687b      	ldr	r3, [r7, #4]
3400836c:	681b      	ldr	r3, [r3, #0]
3400836e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008372:	f003 0304 	and.w	r3, r3, #4
34008376:	2b04      	cmp	r3, #4
34008378:	d107      	bne.n	3400838a <HAL_DCMIPP_CSI_IRQHandler+0x34e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
3400837a:	69fb      	ldr	r3, [r7, #28]
3400837c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008380:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34008384:	69fb      	ldr	r3, [r7, #28]
34008386:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
3400838a:	69fb      	ldr	r3, [r7, #28]
3400838c:	f44f 7200 	mov.w	r2, #512	@ 0x200
34008390:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34008394:	2101      	movs	r1, #1
34008396:	6878      	ldr	r0, [r7, #4]
34008398:	f000 fb4f 	bl	34008a3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
3400839c:	69bb      	ldr	r3, [r7, #24]
3400839e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340083a2:	2b00      	cmp	r3, #0
340083a4:	d01d      	beq.n	340083e2 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
340083a6:	693b      	ldr	r3, [r7, #16]
340083a8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340083ac:	2b00      	cmp	r3, #0
340083ae:	d018      	beq.n	340083e2 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340083b0:	687b      	ldr	r3, [r7, #4]
340083b2:	681b      	ldr	r3, [r3, #0]
340083b4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340083b8:	f003 0304 	and.w	r3, r3, #4
340083bc:	2b04      	cmp	r3, #4
340083be:	d107      	bne.n	340083d0 <HAL_DCMIPP_CSI_IRQHandler+0x394>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
340083c0:	69fb      	ldr	r3, [r7, #28]
340083c2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340083c6:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
340083ca:	69fb      	ldr	r3, [r7, #28]
340083cc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
340083d0:	69fb      	ldr	r3, [r7, #28]
340083d2:	f44f 7280 	mov.w	r2, #256	@ 0x100
340083d6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340083da:	2100      	movs	r1, #0
340083dc:	6878      	ldr	r0, [r7, #4]
340083de:	f000 fb2c 	bl	34008a3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  }

  /*###############################
           Timer Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
340083e2:	69bb      	ldr	r3, [r7, #24]
340083e4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340083e8:	2b00      	cmp	r3, #0
340083ea:	d01c      	beq.n	34008426 <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
340083ec:	693b      	ldr	r3, [r7, #16]
340083ee:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340083f2:	2b00      	cmp	r3, #0
340083f4:	d017      	beq.n	34008426 <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340083f6:	687b      	ldr	r3, [r7, #4]
340083f8:	681b      	ldr	r3, [r3, #0]
340083fa:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340083fe:	f003 0304 	and.w	r3, r3, #4
34008402:	2b04      	cmp	r3, #4
34008404:	d107      	bne.n	34008416 <HAL_DCMIPP_CSI_IRQHandler+0x3da>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
34008406:	69fb      	ldr	r3, [r7, #28]
34008408:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400840c:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34008410:	69fb      	ldr	r3, [r7, #28]
34008412:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
34008416:	69fb      	ldr	r3, [r7, #28]
34008418:	2280      	movs	r2, #128	@ 0x80
3400841a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
3400841e:	2103      	movs	r1, #3
34008420:	6878      	ldr	r0, [r7, #4]
34008422:	f000 fb15 	bl	34008a50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
34008426:	69bb      	ldr	r3, [r7, #24]
34008428:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400842c:	2b00      	cmp	r3, #0
3400842e:	d01c      	beq.n	3400846a <HAL_DCMIPP_CSI_IRQHandler+0x42e>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34008430:	693b      	ldr	r3, [r7, #16]
34008432:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34008436:	2b00      	cmp	r3, #0
34008438:	d017      	beq.n	3400846a <HAL_DCMIPP_CSI_IRQHandler+0x42e>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400843a:	687b      	ldr	r3, [r7, #4]
3400843c:	681b      	ldr	r3, [r3, #0]
3400843e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008442:	f003 0304 	and.w	r3, r3, #4
34008446:	2b04      	cmp	r3, #4
34008448:	d107      	bne.n	3400845a <HAL_DCMIPP_CSI_IRQHandler+0x41e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
3400844a:	69fb      	ldr	r3, [r7, #28]
3400844c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008450:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
34008454:	69fb      	ldr	r3, [r7, #28]
34008456:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
3400845a:	69fb      	ldr	r3, [r7, #28]
3400845c:	2240      	movs	r2, #64	@ 0x40
3400845e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34008462:	2102      	movs	r1, #2
34008464:	6878      	ldr	r0, [r7, #4]
34008466:	f000 faf3 	bl	34008a50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
3400846a:	69bb      	ldr	r3, [r7, #24]
3400846c:	f003 0320 	and.w	r3, r3, #32
34008470:	2b00      	cmp	r3, #0
34008472:	d01c      	beq.n	340084ae <HAL_DCMIPP_CSI_IRQHandler+0x472>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34008474:	693b      	ldr	r3, [r7, #16]
34008476:	f003 0320 	and.w	r3, r3, #32
3400847a:	2b00      	cmp	r3, #0
3400847c:	d017      	beq.n	340084ae <HAL_DCMIPP_CSI_IRQHandler+0x472>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400847e:	687b      	ldr	r3, [r7, #4]
34008480:	681b      	ldr	r3, [r3, #0]
34008482:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008486:	f003 0304 	and.w	r3, r3, #4
3400848a:	2b04      	cmp	r3, #4
3400848c:	d107      	bne.n	3400849e <HAL_DCMIPP_CSI_IRQHandler+0x462>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
3400848e:	69fb      	ldr	r3, [r7, #28]
34008490:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008494:	f023 0220 	bic.w	r2, r3, #32
34008498:	69fb      	ldr	r3, [r7, #28]
3400849a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
3400849e:	69fb      	ldr	r3, [r7, #28]
340084a0:	2220      	movs	r2, #32
340084a2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
340084a6:	2101      	movs	r1, #1
340084a8:	6878      	ldr	r0, [r7, #4]
340084aa:	f000 fad1 	bl	34008a50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
340084ae:	69bb      	ldr	r3, [r7, #24]
340084b0:	f003 0310 	and.w	r3, r3, #16
340084b4:	2b00      	cmp	r3, #0
340084b6:	d01c      	beq.n	340084f2 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
340084b8:	693b      	ldr	r3, [r7, #16]
340084ba:	f003 0310 	and.w	r3, r3, #16
340084be:	2b00      	cmp	r3, #0
340084c0:	d017      	beq.n	340084f2 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340084c2:	687b      	ldr	r3, [r7, #4]
340084c4:	681b      	ldr	r3, [r3, #0]
340084c6:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340084ca:	f003 0304 	and.w	r3, r3, #4
340084ce:	2b04      	cmp	r3, #4
340084d0:	d107      	bne.n	340084e2 <HAL_DCMIPP_CSI_IRQHandler+0x4a6>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
340084d2:	69fb      	ldr	r3, [r7, #28]
340084d4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340084d8:	f023 0210 	bic.w	r2, r3, #16
340084dc:	69fb      	ldr	r3, [r7, #28]
340084de:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
340084e2:	69fb      	ldr	r3, [r7, #28]
340084e4:	2210      	movs	r2, #16
340084e6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
340084ea:	2100      	movs	r1, #0
340084ec:	6878      	ldr	r0, [r7, #4]
340084ee:	f000 faaf 	bl	34008a50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization error  */
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
340084f2:	69bb      	ldr	r3, [r7, #24]
340084f4:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340084f8:	2b00      	cmp	r3, #0
340084fa:	d01a      	beq.n	34008532 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
340084fc:	693b      	ldr	r3, [r7, #16]
340084fe:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34008502:	2b00      	cmp	r3, #0
34008504:	d015      	beq.n	34008532 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
34008506:	69fb      	ldr	r3, [r7, #28]
34008508:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400850c:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
34008510:	69fb      	ldr	r3, [r7, #28]
34008512:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
34008516:	69fb      	ldr	r3, [r7, #28]
34008518:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
3400851c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
34008520:	687b      	ldr	r3, [r7, #4]
34008522:	689b      	ldr	r3, [r3, #8]
34008524:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
34008528:	687b      	ldr	r3, [r7, #4]
3400852a:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400852c:	6878      	ldr	r0, [r7, #4]
3400852e:	f000 fa50 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
34008532:	69bb      	ldr	r3, [r7, #24]
34008534:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34008538:	2b00      	cmp	r3, #0
3400853a:	d01a      	beq.n	34008572 <HAL_DCMIPP_CSI_IRQHandler+0x536>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
3400853c:	693b      	ldr	r3, [r7, #16]
3400853e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34008542:	2b00      	cmp	r3, #0
34008544:	d015      	beq.n	34008572 <HAL_DCMIPP_CSI_IRQHandler+0x536>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
34008546:	69fb      	ldr	r3, [r7, #28]
34008548:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400854c:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
34008550:	69fb      	ldr	r3, [r7, #28]
34008552:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
34008556:	69fb      	ldr	r3, [r7, #28]
34008558:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
3400855c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
34008560:	687b      	ldr	r3, [r7, #4]
34008562:	689b      	ldr	r3, [r3, #8]
34008564:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
34008568:	687b      	ldr	r3, [r7, #4]
3400856a:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400856c:	6878      	ldr	r0, [r7, #4]
3400856e:	f000 fa30 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34008572:	69bb      	ldr	r3, [r7, #24]
34008574:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34008578:	2b00      	cmp	r3, #0
3400857a:	d01a      	beq.n	340085b2 <HAL_DCMIPP_CSI_IRQHandler+0x576>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
3400857c:	693b      	ldr	r3, [r7, #16]
3400857e:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34008582:	2b00      	cmp	r3, #0
34008584:	d015      	beq.n	340085b2 <HAL_DCMIPP_CSI_IRQHandler+0x576>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34008586:	69fb      	ldr	r3, [r7, #28]
34008588:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400858c:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
34008590:	69fb      	ldr	r3, [r7, #28]
34008592:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
34008596:	69fb      	ldr	r3, [r7, #28]
34008598:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
3400859c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
340085a0:	687b      	ldr	r3, [r7, #4]
340085a2:	689b      	ldr	r3, [r3, #8]
340085a4:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
340085a8:	687b      	ldr	r3, [r7, #4]
340085aa:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340085ac:	6878      	ldr	r0, [r7, #4]
340085ae:	f000 fa10 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
340085b2:	69bb      	ldr	r3, [r7, #24]
340085b4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340085b8:	2b00      	cmp	r3, #0
340085ba:	d01a      	beq.n	340085f2 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
340085bc:	693b      	ldr	r3, [r7, #16]
340085be:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340085c2:	2b00      	cmp	r3, #0
340085c4:	d015      	beq.n	340085f2 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
340085c6:	69fb      	ldr	r3, [r7, #28]
340085c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340085cc:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
340085d0:	69fb      	ldr	r3, [r7, #28]
340085d2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
340085d6:	69fb      	ldr	r3, [r7, #28]
340085d8:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
340085dc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
340085e0:	687b      	ldr	r3, [r7, #4]
340085e2:	689b      	ldr	r3, [r3, #8]
340085e4:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
340085e8:	687b      	ldr	r3, [r7, #4]
340085ea:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340085ec:	6878      	ldr	r0, [r7, #4]
340085ee:	f000 f9f0 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
340085f2:	69bb      	ldr	r3, [r7, #24]
340085f4:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340085f8:	2b00      	cmp	r3, #0
340085fa:	d01a      	beq.n	34008632 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
340085fc:	693b      	ldr	r3, [r7, #16]
340085fe:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34008602:	2b00      	cmp	r3, #0
34008604:	d015      	beq.n	34008632 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34008606:	69fb      	ldr	r3, [r7, #28]
34008608:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400860c:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
34008610:	69fb      	ldr	r3, [r7, #28]
34008612:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
34008616:	69fb      	ldr	r3, [r7, #28]
34008618:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
3400861c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
34008620:	687b      	ldr	r3, [r7, #4]
34008622:	689b      	ldr	r3, [r3, #8]
34008624:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34008628:	687b      	ldr	r3, [r7, #4]
3400862a:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400862c:	6878      	ldr	r0, [r7, #4]
3400862e:	f000 f9d0 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
34008632:	69bb      	ldr	r3, [r7, #24]
34008634:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34008638:	2b00      	cmp	r3, #0
3400863a:	d01a      	beq.n	34008672 <HAL_DCMIPP_CSI_IRQHandler+0x636>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
3400863c:	693b      	ldr	r3, [r7, #16]
3400863e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34008642:	2b00      	cmp	r3, #0
34008644:	d015      	beq.n	34008672 <HAL_DCMIPP_CSI_IRQHandler+0x636>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
34008646:	69fb      	ldr	r3, [r7, #28]
34008648:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400864c:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34008650:	69fb      	ldr	r3, [r7, #28]
34008652:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
34008656:	69fb      	ldr	r3, [r7, #28]
34008658:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
3400865c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
34008660:	687b      	ldr	r3, [r7, #4]
34008662:	689b      	ldr	r3, [r3, #8]
34008664:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
34008668:	687b      	ldr	r3, [r7, #4]
3400866a:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400866c:	6878      	ldr	r0, [r7, #4]
3400866e:	f000 f9b0 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
34008672:	69bb      	ldr	r3, [r7, #24]
34008674:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34008678:	2b00      	cmp	r3, #0
3400867a:	d01a      	beq.n	340086b2 <HAL_DCMIPP_CSI_IRQHandler+0x676>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
3400867c:	693b      	ldr	r3, [r7, #16]
3400867e:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34008682:	2b00      	cmp	r3, #0
34008684:	d015      	beq.n	340086b2 <HAL_DCMIPP_CSI_IRQHandler+0x676>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
34008686:	69fb      	ldr	r3, [r7, #28]
34008688:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400868c:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34008690:	69fb      	ldr	r3, [r7, #28]
34008692:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
34008696:	69fb      	ldr	r3, [r7, #28]
34008698:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400869c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
340086a0:	687b      	ldr	r3, [r7, #4]
340086a2:	689b      	ldr	r3, [r3, #8]
340086a4:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
340086a8:	687b      	ldr	r3, [r7, #4]
340086aa:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340086ac:	6878      	ldr	r0, [r7, #4]
340086ae:	f000 f990 	bl	340089d2 <HAL_DCMIPP_ErrorCallback>
    }
  }

  /* Lane 0 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
340086b2:	697b      	ldr	r3, [r7, #20]
340086b4:	f003 0301 	and.w	r3, r3, #1
340086b8:	2b00      	cmp	r3, #0
340086ba:	d01d      	beq.n	340086f8 <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
340086bc:	68fb      	ldr	r3, [r7, #12]
340086be:	f003 0301 	and.w	r3, r3, #1
340086c2:	2b00      	cmp	r3, #0
340086c4:	d018      	beq.n	340086f8 <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
340086c6:	69fb      	ldr	r3, [r7, #28]
340086c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340086cc:	f023 0201 	bic.w	r2, r3, #1
340086d0:	69fb      	ldr	r3, [r7, #28]
340086d2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
340086d6:	69fb      	ldr	r3, [r7, #28]
340086d8:	2201      	movs	r2, #1
340086da:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
340086de:	687b      	ldr	r3, [r7, #4]
340086e0:	689b      	ldr	r3, [r3, #8]
340086e2:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
340086e6:	687b      	ldr	r3, [r7, #4]
340086e8:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
340086ea:	687b      	ldr	r3, [r7, #4]
340086ec:	2204      	movs	r2, #4
340086ee:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340086f0:	2101      	movs	r1, #1
340086f2:	6878      	ldr	r0, [r7, #4]
340086f4:	f000 f977 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
340086f8:	697b      	ldr	r3, [r7, #20]
340086fa:	f003 0302 	and.w	r3, r3, #2
340086fe:	2b00      	cmp	r3, #0
34008700:	d01d      	beq.n	3400873e <HAL_DCMIPP_CSI_IRQHandler+0x702>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
34008702:	68fb      	ldr	r3, [r7, #12]
34008704:	f003 0302 	and.w	r3, r3, #2
34008708:	2b00      	cmp	r3, #0
3400870a:	d018      	beq.n	3400873e <HAL_DCMIPP_CSI_IRQHandler+0x702>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
3400870c:	69fb      	ldr	r3, [r7, #28]
3400870e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008712:	f023 0202 	bic.w	r2, r3, #2
34008716:	69fb      	ldr	r3, [r7, #28]
34008718:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
3400871c:	69fb      	ldr	r3, [r7, #28]
3400871e:	2202      	movs	r2, #2
34008720:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34008724:	687b      	ldr	r3, [r7, #4]
34008726:	689b      	ldr	r3, [r3, #8]
34008728:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
3400872c:	687b      	ldr	r3, [r7, #4]
3400872e:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008730:	687b      	ldr	r3, [r7, #4]
34008732:	2204      	movs	r2, #4
34008734:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34008736:	2101      	movs	r1, #1
34008738:	6878      	ldr	r0, [r7, #4]
3400873a:	f000 f954 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
3400873e:	697b      	ldr	r3, [r7, #20]
34008740:	f003 0304 	and.w	r3, r3, #4
34008744:	2b00      	cmp	r3, #0
34008746:	d01a      	beq.n	3400877e <HAL_DCMIPP_CSI_IRQHandler+0x742>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
34008748:	68fb      	ldr	r3, [r7, #12]
3400874a:	f003 0304 	and.w	r3, r3, #4
3400874e:	2b00      	cmp	r3, #0
34008750:	d015      	beq.n	3400877e <HAL_DCMIPP_CSI_IRQHandler+0x742>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34008752:	69fb      	ldr	r3, [r7, #28]
34008754:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008758:	f023 0204 	bic.w	r2, r3, #4
3400875c:	69fb      	ldr	r3, [r7, #28]
3400875e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
34008762:	69fb      	ldr	r3, [r7, #28]
34008764:	2204      	movs	r2, #4
34008766:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
3400876a:	687b      	ldr	r3, [r7, #4]
3400876c:	689b      	ldr	r3, [r3, #8]
3400876e:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34008772:	687b      	ldr	r3, [r7, #4]
34008774:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34008776:	2101      	movs	r1, #1
34008778:	6878      	ldr	r0, [r7, #4]
3400877a:	f000 f934 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
3400877e:	697b      	ldr	r3, [r7, #20]
34008780:	f003 0308 	and.w	r3, r3, #8
34008784:	2b00      	cmp	r3, #0
34008786:	d01a      	beq.n	340087be <HAL_DCMIPP_CSI_IRQHandler+0x782>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
34008788:	68fb      	ldr	r3, [r7, #12]
3400878a:	f003 0308 	and.w	r3, r3, #8
3400878e:	2b00      	cmp	r3, #0
34008790:	d015      	beq.n	340087be <HAL_DCMIPP_CSI_IRQHandler+0x782>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34008792:	69fb      	ldr	r3, [r7, #28]
34008794:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008798:	f023 0208 	bic.w	r2, r3, #8
3400879c:	69fb      	ldr	r3, [r7, #28]
3400879e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
340087a2:	69fb      	ldr	r3, [r7, #28]
340087a4:	2208      	movs	r2, #8
340087a6:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
340087aa:	687b      	ldr	r3, [r7, #4]
340087ac:	689b      	ldr	r3, [r3, #8]
340087ae:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
340087b2:	687b      	ldr	r3, [r7, #4]
340087b4:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340087b6:	2101      	movs	r1, #1
340087b8:	6878      	ldr	r0, [r7, #4]
340087ba:	f000 f914 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
340087be:	697b      	ldr	r3, [r7, #20]
340087c0:	f003 0310 	and.w	r3, r3, #16
340087c4:	2b00      	cmp	r3, #0
340087c6:	d01a      	beq.n	340087fe <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
340087c8:	68fb      	ldr	r3, [r7, #12]
340087ca:	f003 0310 	and.w	r3, r3, #16
340087ce:	2b00      	cmp	r3, #0
340087d0:	d015      	beq.n	340087fe <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
340087d2:	69fb      	ldr	r3, [r7, #28]
340087d4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340087d8:	f023 0210 	bic.w	r2, r3, #16
340087dc:	69fb      	ldr	r3, [r7, #28]
340087de:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
340087e2:	69fb      	ldr	r3, [r7, #28]
340087e4:	2210      	movs	r2, #16
340087e6:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
340087ea:	687b      	ldr	r3, [r7, #4]
340087ec:	689b      	ldr	r3, [r3, #8]
340087ee:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
340087f2:	687b      	ldr	r3, [r7, #4]
340087f4:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340087f6:	2101      	movs	r1, #1
340087f8:	6878      	ldr	r0, [r7, #4]
340087fa:	f000 f8f4 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
    }
  }

  /* Lane 1 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
340087fe:	697b      	ldr	r3, [r7, #20]
34008800:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34008804:	2b00      	cmp	r3, #0
34008806:	d01e      	beq.n	34008846 <HAL_DCMIPP_CSI_IRQHandler+0x80a>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
34008808:	68fb      	ldr	r3, [r7, #12]
3400880a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400880e:	2b00      	cmp	r3, #0
34008810:	d019      	beq.n	34008846 <HAL_DCMIPP_CSI_IRQHandler+0x80a>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34008812:	69fb      	ldr	r3, [r7, #28]
34008814:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008818:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
3400881c:	69fb      	ldr	r3, [r7, #28]
3400881e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
34008822:	69fb      	ldr	r3, [r7, #28]
34008824:	f44f 7280 	mov.w	r2, #256	@ 0x100
34008828:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
3400882c:	687b      	ldr	r3, [r7, #4]
3400882e:	689b      	ldr	r3, [r3, #8]
34008830:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
34008834:	687b      	ldr	r3, [r7, #4]
34008836:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008838:	687b      	ldr	r3, [r7, #4]
3400883a:	2204      	movs	r2, #4
3400883c:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400883e:	2102      	movs	r1, #2
34008840:	6878      	ldr	r0, [r7, #4]
34008842:	f000 f8d0 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
34008846:	697b      	ldr	r3, [r7, #20]
34008848:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400884c:	2b00      	cmp	r3, #0
3400884e:	d01e      	beq.n	3400888e <HAL_DCMIPP_CSI_IRQHandler+0x852>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34008850:	68fb      	ldr	r3, [r7, #12]
34008852:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34008856:	2b00      	cmp	r3, #0
34008858:	d019      	beq.n	3400888e <HAL_DCMIPP_CSI_IRQHandler+0x852>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
3400885a:	69fb      	ldr	r3, [r7, #28]
3400885c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008860:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34008864:	69fb      	ldr	r3, [r7, #28]
34008866:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
3400886a:	69fb      	ldr	r3, [r7, #28]
3400886c:	f44f 7200 	mov.w	r2, #512	@ 0x200
34008870:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34008874:	687b      	ldr	r3, [r7, #4]
34008876:	689b      	ldr	r3, [r3, #8]
34008878:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
3400887c:	687b      	ldr	r3, [r7, #4]
3400887e:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008880:	687b      	ldr	r3, [r7, #4]
34008882:	2204      	movs	r2, #4
34008884:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34008886:	2102      	movs	r1, #2
34008888:	6878      	ldr	r0, [r7, #4]
3400888a:	f000 f8ac 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
3400888e:	697b      	ldr	r3, [r7, #20]
34008890:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34008894:	2b00      	cmp	r3, #0
34008896:	d01b      	beq.n	340088d0 <HAL_DCMIPP_CSI_IRQHandler+0x894>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
34008898:	68fb      	ldr	r3, [r7, #12]
3400889a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400889e:	2b00      	cmp	r3, #0
340088a0:	d016      	beq.n	340088d0 <HAL_DCMIPP_CSI_IRQHandler+0x894>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
340088a2:	69fb      	ldr	r3, [r7, #28]
340088a4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340088a8:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
340088ac:	69fb      	ldr	r3, [r7, #28]
340088ae:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
340088b2:	69fb      	ldr	r3, [r7, #28]
340088b4:	f44f 6280 	mov.w	r2, #1024	@ 0x400
340088b8:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
340088bc:	687b      	ldr	r3, [r7, #4]
340088be:	689b      	ldr	r3, [r3, #8]
340088c0:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
340088c4:	687b      	ldr	r3, [r7, #4]
340088c6:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340088c8:	2102      	movs	r1, #2
340088ca:	6878      	ldr	r0, [r7, #4]
340088cc:	f000 f88b 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
340088d0:	697b      	ldr	r3, [r7, #20]
340088d2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340088d6:	2b00      	cmp	r3, #0
340088d8:	d01b      	beq.n	34008912 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
340088da:	68fb      	ldr	r3, [r7, #12]
340088dc:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340088e0:	2b00      	cmp	r3, #0
340088e2:	d016      	beq.n	34008912 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
340088e4:	69fb      	ldr	r3, [r7, #28]
340088e6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340088ea:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
340088ee:	69fb      	ldr	r3, [r7, #28]
340088f0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
340088f4:	69fb      	ldr	r3, [r7, #28]
340088f6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340088fa:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
340088fe:	687b      	ldr	r3, [r7, #4]
34008900:	689b      	ldr	r3, [r3, #8]
34008902:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34008906:	687b      	ldr	r3, [r7, #4]
34008908:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400890a:	2102      	movs	r1, #2
3400890c:	6878      	ldr	r0, [r7, #4]
3400890e:	f000 f86a 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34008912:	697b      	ldr	r3, [r7, #20]
34008914:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34008918:	2b00      	cmp	r3, #0
3400891a:	d01b      	beq.n	34008954 <HAL_DCMIPP_CSI_IRQHandler+0x918>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
3400891c:	68fb      	ldr	r3, [r7, #12]
3400891e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34008922:	2b00      	cmp	r3, #0
34008924:	d016      	beq.n	34008954 <HAL_DCMIPP_CSI_IRQHandler+0x918>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34008926:	69fb      	ldr	r3, [r7, #28]
34008928:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400892c:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34008930:	69fb      	ldr	r3, [r7, #28]
34008932:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34008936:	69fb      	ldr	r3, [r7, #28]
34008938:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400893c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34008940:	687b      	ldr	r3, [r7, #4]
34008942:	689b      	ldr	r3, [r3, #8]
34008944:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
34008948:	687b      	ldr	r3, [r7, #4]
3400894a:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3400894c:	2102      	movs	r1, #2
3400894e:	6878      	ldr	r0, [r7, #4]
34008950:	f000 f849 	bl	340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
34008954:	69bb      	ldr	r3, [r7, #24]
34008956:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400895a:	2b00      	cmp	r3, #0
3400895c:	d014      	beq.n	34008988 <HAL_DCMIPP_CSI_IRQHandler+0x94c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
3400895e:	693b      	ldr	r3, [r7, #16]
34008960:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34008964:	2b00      	cmp	r3, #0
34008966:	d00f      	beq.n	34008988 <HAL_DCMIPP_CSI_IRQHandler+0x94c>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34008968:	69fb      	ldr	r3, [r7, #28]
3400896a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400896e:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
34008972:	69fb      	ldr	r3, [r7, #28]
34008974:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34008978:	69fb      	ldr	r3, [r7, #28]
3400897a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400897e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ShortPacketDetectionEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34008982:	6878      	ldr	r0, [r7, #4]
34008984:	f000 f844 	bl	34008a10 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34008988:	bf00      	nop
3400898a:	3720      	adds	r7, #32
3400898c:	46bd      	mov	sp, r7
3400898e:	bd80      	pop	{r7, pc}

34008990 <HAL_DCMIPP_PIPE_LineEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008990:	b480      	push	{r7}
34008992:	b083      	sub	sp, #12
34008994:	af00      	add	r7, sp, #0
34008996:	6078      	str	r0, [r7, #4]
34008998:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LineEventMainPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
3400899a:	bf00      	nop
3400899c:	370c      	adds	r7, #12
3400899e:	46bd      	mov	sp, r7
340089a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340089a4:	4770      	bx	lr

340089a6 <HAL_DCMIPP_PIPE_LimitEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340089a6:	b480      	push	{r7}
340089a8:	b083      	sub	sp, #12
340089aa:	af00      	add	r7, sp, #0
340089ac:	6078      	str	r0, [r7, #4]
340089ae:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LimitEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
340089b0:	bf00      	nop
340089b2:	370c      	adds	r7, #12
340089b4:	46bd      	mov	sp, r7
340089b6:	f85d 7b04 	ldr.w	r7, [sp], #4
340089ba:	4770      	bx	lr

340089bc <HAL_DCMIPP_PIPE_ErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340089bc:	b480      	push	{r7}
340089be:	b083      	sub	sp, #12
340089c0:	af00      	add	r7, sp, #0
340089c2:	6078      	str	r0, [r7, #4]
340089c4:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_SyncErrorEventCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
340089c6:	bf00      	nop
340089c8:	370c      	adds	r7, #12
340089ca:	46bd      	mov	sp, r7
340089cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340089d0:	4770      	bx	lr

340089d2 <HAL_DCMIPP_ErrorCallback>:
  * @brief  Error callback on DCMIPP
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
340089d2:	b480      	push	{r7}
340089d4:	b083      	sub	sp, #12
340089d6:	af00      	add	r7, sp, #0
340089d8:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_ErrorCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmipp);
}
340089da:	bf00      	nop
340089dc:	370c      	adds	r7, #12
340089de:	46bd      	mov	sp, r7
340089e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340089e4:	4770      	bx	lr

340089e6 <HAL_DCMIPP_CSI_LineErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  DataLane
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
{
340089e6:	b480      	push	{r7}
340089e8:	b083      	sub	sp, #12
340089ea:	af00      	add	r7, sp, #0
340089ec:	6078      	str	r0, [r7, #4]
340089ee:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_LineErrorCallback could be implemented in the user file
   */
  UNUSED(DataLane);
  UNUSED(hdcmipp);
}
340089f0:	bf00      	nop
340089f2:	370c      	adds	r7, #12
340089f4:	46bd      	mov	sp, r7
340089f6:	f85d 7b04 	ldr.w	r7, [sp], #4
340089fa:	4770      	bx	lr

340089fc <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
  * @brief  Clock Changer Fifo Full Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
340089fc:	b480      	push	{r7}
340089fe:	b083      	sub	sp, #12
34008a00:	af00      	add	r7, sp, #0
34008a02:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34008a04:	bf00      	nop
34008a06:	370c      	adds	r7, #12
34008a08:	46bd      	mov	sp, r7
34008a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a0e:	4770      	bx	lr

34008a10 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
  * @brief  Short Packet Detection Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34008a10:	b480      	push	{r7}
34008a12:	b083      	sub	sp, #12
34008a14:	af00      	add	r7, sp, #0
34008a16:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34008a18:	bf00      	nop
34008a1a:	370c      	adds	r7, #12
34008a1c:	46bd      	mov	sp, r7
34008a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a22:	4770      	bx	lr

34008a24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34008a24:	b480      	push	{r7}
34008a26:	b083      	sub	sp, #12
34008a28:	af00      	add	r7, sp, #0
34008a2a:	6078      	str	r0, [r7, #4]
34008a2c:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_EndOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34008a2e:	bf00      	nop
34008a30:	370c      	adds	r7, #12
34008a32:	46bd      	mov	sp, r7
34008a34:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a38:	4770      	bx	lr

34008a3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34008a3a:	b480      	push	{r7}
34008a3c:	b083      	sub	sp, #12
34008a3e:	af00      	add	r7, sp, #0
34008a40:	6078      	str	r0, [r7, #4]
34008a42:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_StartOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34008a44:	bf00      	nop
34008a46:	370c      	adds	r7, #12
34008a48:	46bd      	mov	sp, r7
34008a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a4e:	4770      	bx	lr

34008a50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Timer
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
{
34008a50:	b480      	push	{r7}
34008a52:	b083      	sub	sp, #12
34008a54:	af00      	add	r7, sp, #0
34008a56:	6078      	str	r0, [r7, #4]
34008a58:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_TimerCounterEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(Timer);
}
34008a5a:	bf00      	nop
34008a5c:	370c      	adds	r7, #12
34008a5e:	46bd      	mov	sp, r7
34008a60:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a64:	4770      	bx	lr

34008a66 <HAL_DCMIPP_CSI_LineByteEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Counter
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
{
34008a66:	b480      	push	{r7}
34008a68:	b083      	sub	sp, #12
34008a6a:	af00      	add	r7, sp, #0
34008a6c:	6078      	str	r0, [r7, #4]
34008a6e:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
          the HAL_DCMIPP_CSI_LineByteEventCallback could be implemented in the user file
  */
  UNUSED(hdcmipp);
  UNUSED(Counter);
}
34008a70:	bf00      	nop
34008a72:	370c      	adds	r7, #12
34008a74:	46bd      	mov	sp, r7
34008a76:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a7a:	4770      	bx	lr

34008a7c <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
34008a7c:	b580      	push	{r7, lr}
34008a7e:	b082      	sub	sp, #8
34008a80:	af00      	add	r7, sp, #0
34008a82:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
34008a84:	687b      	ldr	r3, [r7, #4]
34008a86:	2b00      	cmp	r3, #0
34008a88:	d101      	bne.n	34008a8e <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
34008a8a:	2301      	movs	r3, #1
34008a8c:	e0d4      	b.n	34008c38 <HAL_DMA2D_Init+0x1bc>
  }

  /* Check the parameters */
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
34008a8e:	687b      	ldr	r3, [r7, #4]
34008a90:	681b      	ldr	r3, [r3, #0]
34008a92:	4a6b      	ldr	r2, [pc, #428]	@ (34008c40 <HAL_DMA2D_Init+0x1c4>)
34008a94:	4293      	cmp	r3, r2
34008a96:	d008      	beq.n	34008aaa <HAL_DMA2D_Init+0x2e>
34008a98:	687b      	ldr	r3, [r7, #4]
34008a9a:	681b      	ldr	r3, [r3, #0]
34008a9c:	4a69      	ldr	r2, [pc, #420]	@ (34008c44 <HAL_DMA2D_Init+0x1c8>)
34008a9e:	4293      	cmp	r3, r2
34008aa0:	d003      	beq.n	34008aaa <HAL_DMA2D_Init+0x2e>
34008aa2:	21f7      	movs	r1, #247	@ 0xf7
34008aa4:	4868      	ldr	r0, [pc, #416]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008aa6:	f7f8 fbf7 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
34008aaa:	687b      	ldr	r3, [r7, #4]
34008aac:	685b      	ldr	r3, [r3, #4]
34008aae:	2b00      	cmp	r3, #0
34008ab0:	d01c      	beq.n	34008aec <HAL_DMA2D_Init+0x70>
34008ab2:	687b      	ldr	r3, [r7, #4]
34008ab4:	685b      	ldr	r3, [r3, #4]
34008ab6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34008aba:	d017      	beq.n	34008aec <HAL_DMA2D_Init+0x70>
34008abc:	687b      	ldr	r3, [r7, #4]
34008abe:	685b      	ldr	r3, [r3, #4]
34008ac0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34008ac4:	d012      	beq.n	34008aec <HAL_DMA2D_Init+0x70>
34008ac6:	687b      	ldr	r3, [r7, #4]
34008ac8:	685b      	ldr	r3, [r3, #4]
34008aca:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34008ace:	d00d      	beq.n	34008aec <HAL_DMA2D_Init+0x70>
34008ad0:	687b      	ldr	r3, [r7, #4]
34008ad2:	685b      	ldr	r3, [r3, #4]
34008ad4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34008ad8:	d008      	beq.n	34008aec <HAL_DMA2D_Init+0x70>
34008ada:	687b      	ldr	r3, [r7, #4]
34008adc:	685b      	ldr	r3, [r3, #4]
34008ade:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34008ae2:	d003      	beq.n	34008aec <HAL_DMA2D_Init+0x70>
34008ae4:	21f8      	movs	r1, #248	@ 0xf8
34008ae6:	4858      	ldr	r0, [pc, #352]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008ae8:	f7f8 fbd6 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
34008aec:	687b      	ldr	r3, [r7, #4]
34008aee:	689b      	ldr	r3, [r3, #8]
34008af0:	2b00      	cmp	r3, #0
34008af2:	d013      	beq.n	34008b1c <HAL_DMA2D_Init+0xa0>
34008af4:	687b      	ldr	r3, [r7, #4]
34008af6:	689b      	ldr	r3, [r3, #8]
34008af8:	2b01      	cmp	r3, #1
34008afa:	d00f      	beq.n	34008b1c <HAL_DMA2D_Init+0xa0>
34008afc:	687b      	ldr	r3, [r7, #4]
34008afe:	689b      	ldr	r3, [r3, #8]
34008b00:	2b02      	cmp	r3, #2
34008b02:	d00b      	beq.n	34008b1c <HAL_DMA2D_Init+0xa0>
34008b04:	687b      	ldr	r3, [r7, #4]
34008b06:	689b      	ldr	r3, [r3, #8]
34008b08:	2b03      	cmp	r3, #3
34008b0a:	d007      	beq.n	34008b1c <HAL_DMA2D_Init+0xa0>
34008b0c:	687b      	ldr	r3, [r7, #4]
34008b0e:	689b      	ldr	r3, [r3, #8]
34008b10:	2b04      	cmp	r3, #4
34008b12:	d003      	beq.n	34008b1c <HAL_DMA2D_Init+0xa0>
34008b14:	21f9      	movs	r1, #249	@ 0xf9
34008b16:	484c      	ldr	r0, [pc, #304]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008b18:	f7f8 fbbe 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
34008b1c:	687b      	ldr	r3, [r7, #4]
34008b1e:	68db      	ldr	r3, [r3, #12]
34008b20:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34008b24:	d303      	bcc.n	34008b2e <HAL_DMA2D_Init+0xb2>
34008b26:	21fa      	movs	r1, #250	@ 0xfa
34008b28:	4847      	ldr	r0, [pc, #284]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008b2a:	f7f8 fbb5 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->Init.AlphaInverted));
34008b2e:	687b      	ldr	r3, [r7, #4]
34008b30:	691b      	ldr	r3, [r3, #16]
34008b32:	2b00      	cmp	r3, #0
34008b34:	d007      	beq.n	34008b46 <HAL_DMA2D_Init+0xca>
34008b36:	687b      	ldr	r3, [r7, #4]
34008b38:	691b      	ldr	r3, [r3, #16]
34008b3a:	2b01      	cmp	r3, #1
34008b3c:	d003      	beq.n	34008b46 <HAL_DMA2D_Init+0xca>
34008b3e:	21fb      	movs	r1, #251	@ 0xfb
34008b40:	4841      	ldr	r0, [pc, #260]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008b42:	f7f8 fba9 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->Init.RedBlueSwap));
34008b46:	687b      	ldr	r3, [r7, #4]
34008b48:	695b      	ldr	r3, [r3, #20]
34008b4a:	2b00      	cmp	r3, #0
34008b4c:	d007      	beq.n	34008b5e <HAL_DMA2D_Init+0xe2>
34008b4e:	687b      	ldr	r3, [r7, #4]
34008b50:	695b      	ldr	r3, [r3, #20]
34008b52:	2b01      	cmp	r3, #1
34008b54:	d003      	beq.n	34008b5e <HAL_DMA2D_Init+0xe2>
34008b56:	21fc      	movs	r1, #252	@ 0xfc
34008b58:	483b      	ldr	r0, [pc, #236]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008b5a:	f7f8 fb9d 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_LOM_MODE(hdma2d->Init.LineOffsetMode));
34008b5e:	687b      	ldr	r3, [r7, #4]
34008b60:	69db      	ldr	r3, [r3, #28]
34008b62:	2b00      	cmp	r3, #0
34008b64:	d007      	beq.n	34008b76 <HAL_DMA2D_Init+0xfa>
34008b66:	687b      	ldr	r3, [r7, #4]
34008b68:	69db      	ldr	r3, [r3, #28]
34008b6a:	2b40      	cmp	r3, #64	@ 0x40
34008b6c:	d003      	beq.n	34008b76 <HAL_DMA2D_Init+0xfa>
34008b6e:	21fd      	movs	r1, #253	@ 0xfd
34008b70:	4835      	ldr	r0, [pc, #212]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008b72:	f7f8 fb91 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_BYTES_SWAP(hdma2d->Init.BytesSwap));
34008b76:	687b      	ldr	r3, [r7, #4]
34008b78:	699b      	ldr	r3, [r3, #24]
34008b7a:	2b00      	cmp	r3, #0
34008b7c:	d008      	beq.n	34008b90 <HAL_DMA2D_Init+0x114>
34008b7e:	687b      	ldr	r3, [r7, #4]
34008b80:	699b      	ldr	r3, [r3, #24]
34008b82:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34008b86:	d003      	beq.n	34008b90 <HAL_DMA2D_Init+0x114>
34008b88:	21fe      	movs	r1, #254	@ 0xfe
34008b8a:	482f      	ldr	r0, [pc, #188]	@ (34008c48 <HAL_DMA2D_Init+0x1cc>)
34008b8c:	f7f8 fb84 	bl	34001298 <assert_failed>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
34008b90:	687b      	ldr	r3, [r7, #4]
34008b92:	f893 3061 	ldrb.w	r3, [r3, #97]	@ 0x61
34008b96:	b2db      	uxtb	r3, r3
34008b98:	2b00      	cmp	r3, #0
34008b9a:	d106      	bne.n	34008baa <HAL_DMA2D_Init+0x12e>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
34008b9c:	687b      	ldr	r3, [r7, #4]
34008b9e:	2200      	movs	r2, #0
34008ba0:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
34008ba4:	6878      	ldr	r0, [r7, #4]
34008ba6:	f000 f851 	bl	34008c4c <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34008baa:	687b      	ldr	r3, [r7, #4]
34008bac:	2202      	movs	r2, #2
34008bae:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34008bb2:	687b      	ldr	r3, [r7, #4]
34008bb4:	681b      	ldr	r3, [r3, #0]
34008bb6:	681b      	ldr	r3, [r3, #0]
34008bb8:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
34008bbc:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34008bc0:	687a      	ldr	r2, [r7, #4]
34008bc2:	6851      	ldr	r1, [r2, #4]
34008bc4:	687a      	ldr	r2, [r7, #4]
34008bc6:	69d2      	ldr	r2, [r2, #28]
34008bc8:	4311      	orrs	r1, r2
34008bca:	687a      	ldr	r2, [r7, #4]
34008bcc:	6812      	ldr	r2, [r2, #0]
34008bce:	430b      	orrs	r3, r1
34008bd0:	6013      	str	r3, [r2, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
34008bd2:	687b      	ldr	r3, [r7, #4]
34008bd4:	681b      	ldr	r3, [r3, #0]
34008bd6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34008bd8:	f423 7383 	bic.w	r3, r3, #262	@ 0x106
34008bdc:	f023 0301 	bic.w	r3, r3, #1
34008be0:	687a      	ldr	r2, [r7, #4]
34008be2:	6891      	ldr	r1, [r2, #8]
34008be4:	687a      	ldr	r2, [r7, #4]
34008be6:	6992      	ldr	r2, [r2, #24]
34008be8:	4311      	orrs	r1, r2
34008bea:	687a      	ldr	r2, [r7, #4]
34008bec:	6812      	ldr	r2, [r2, #0]
34008bee:	430b      	orrs	r3, r1
34008bf0:	6353      	str	r3, [r2, #52]	@ 0x34
             hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
34008bf2:	687b      	ldr	r3, [r7, #4]
34008bf4:	681b      	ldr	r3, [r3, #0]
34008bf6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34008bf8:	0c1b      	lsrs	r3, r3, #16
34008bfa:	041b      	lsls	r3, r3, #16
34008bfc:	687a      	ldr	r2, [r7, #4]
34008bfe:	68d1      	ldr	r1, [r2, #12]
34008c00:	687a      	ldr	r2, [r7, #4]
34008c02:	6812      	ldr	r2, [r2, #0]
34008c04:	430b      	orrs	r3, r1
34008c06:	6413      	str	r3, [r2, #64]	@ 0x40
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
34008c08:	687b      	ldr	r3, [r7, #4]
34008c0a:	681b      	ldr	r3, [r3, #0]
34008c0c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34008c0e:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
34008c12:	687b      	ldr	r3, [r7, #4]
34008c14:	691b      	ldr	r3, [r3, #16]
34008c16:	051a      	lsls	r2, r3, #20
34008c18:	687b      	ldr	r3, [r7, #4]
34008c1a:	695b      	ldr	r3, [r3, #20]
34008c1c:	055b      	lsls	r3, r3, #21
34008c1e:	431a      	orrs	r2, r3
34008c20:	687b      	ldr	r3, [r7, #4]
34008c22:	681b      	ldr	r3, [r3, #0]
34008c24:	430a      	orrs	r2, r1
34008c26:	635a      	str	r2, [r3, #52]	@ 0x34
             ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34008c28:	687b      	ldr	r3, [r7, #4]
34008c2a:	2200      	movs	r2, #0
34008c2c:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34008c2e:	687b      	ldr	r3, [r7, #4]
34008c30:	2201      	movs	r2, #1
34008c32:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  return HAL_OK;
34008c36:	2300      	movs	r3, #0
}
34008c38:	4618      	mov	r0, r3
34008c3a:	3708      	adds	r7, #8
34008c3c:	46bd      	mov	sp, r7
34008c3e:	bd80      	pop	{r7, pc}
34008c40:	58021000 	.word	0x58021000
34008c44:	48021000 	.word	0x48021000
34008c48:	340240e4 	.word	0x340240e4

34008c4c <HAL_DMA2D_MspInit>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
34008c4c:	b480      	push	{r7}
34008c4e:	b083      	sub	sp, #12
34008c50:	af00      	add	r7, sp, #0
34008c52:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspInit can be implemented in the user file.
   */
}
34008c54:	bf00      	nop
34008c56:	370c      	adds	r7, #12
34008c58:	46bd      	mov	sp, r7
34008c5a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008c5e:	4770      	bx	lr

34008c60 <HAL_DMA2D_Start>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                  uint32_t Height)
{
34008c60:	b580      	push	{r7, lr}
34008c62:	b086      	sub	sp, #24
34008c64:	af02      	add	r7, sp, #8
34008c66:	60f8      	str	r0, [r7, #12]
34008c68:	60b9      	str	r1, [r7, #8]
34008c6a:	607a      	str	r2, [r7, #4]
34008c6c:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
34008c6e:	69bb      	ldr	r3, [r7, #24]
34008c70:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34008c74:	d304      	bcc.n	34008c80 <HAL_DMA2D_Start+0x20>
34008c76:	f240 21a9 	movw	r1, #681	@ 0x2a9
34008c7a:	4818      	ldr	r0, [pc, #96]	@ (34008cdc <HAL_DMA2D_Start+0x7c>)
34008c7c:	f7f8 fb0c 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_PIXEL(Width));
34008c80:	683b      	ldr	r3, [r7, #0]
34008c82:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34008c86:	d304      	bcc.n	34008c92 <HAL_DMA2D_Start+0x32>
34008c88:	f240 21aa 	movw	r1, #682	@ 0x2aa
34008c8c:	4813      	ldr	r0, [pc, #76]	@ (34008cdc <HAL_DMA2D_Start+0x7c>)
34008c8e:	f7f8 fb03 	bl	34001298 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hdma2d);
34008c92:	68fb      	ldr	r3, [r7, #12]
34008c94:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
34008c98:	2b01      	cmp	r3, #1
34008c9a:	d101      	bne.n	34008ca0 <HAL_DMA2D_Start+0x40>
34008c9c:	2302      	movs	r3, #2
34008c9e:	e018      	b.n	34008cd2 <HAL_DMA2D_Start+0x72>
34008ca0:	68fb      	ldr	r3, [r7, #12]
34008ca2:	2201      	movs	r2, #1
34008ca4:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34008ca8:	68fb      	ldr	r3, [r7, #12]
34008caa:	2202      	movs	r2, #2
34008cac:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
34008cb0:	69bb      	ldr	r3, [r7, #24]
34008cb2:	9300      	str	r3, [sp, #0]
34008cb4:	683b      	ldr	r3, [r7, #0]
34008cb6:	687a      	ldr	r2, [r7, #4]
34008cb8:	68b9      	ldr	r1, [r7, #8]
34008cba:	68f8      	ldr	r0, [r7, #12]
34008cbc:	f000 fae2 	bl	34009284 <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
34008cc0:	68fb      	ldr	r3, [r7, #12]
34008cc2:	681b      	ldr	r3, [r3, #0]
34008cc4:	681a      	ldr	r2, [r3, #0]
34008cc6:	68fb      	ldr	r3, [r7, #12]
34008cc8:	681b      	ldr	r3, [r3, #0]
34008cca:	f042 0201 	orr.w	r2, r2, #1
34008cce:	601a      	str	r2, [r3, #0]

  return HAL_OK;
34008cd0:	2300      	movs	r3, #0
}
34008cd2:	4618      	mov	r0, r3
34008cd4:	3710      	adds	r7, #16
34008cd6:	46bd      	mov	sp, r7
34008cd8:	bd80      	pop	{r7, pc}
34008cda:	bf00      	nop
34008cdc:	340240e4 	.word	0x340240e4

34008ce0 <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
34008ce0:	b580      	push	{r7, lr}
34008ce2:	b086      	sub	sp, #24
34008ce4:	af00      	add	r7, sp, #0
34008ce6:	6078      	str	r0, [r7, #4]
34008ce8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
34008cea:	2300      	movs	r3, #0
34008cec:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34008cee:	687b      	ldr	r3, [r7, #4]
34008cf0:	681b      	ldr	r3, [r3, #0]
34008cf2:	681b      	ldr	r3, [r3, #0]
34008cf4:	f003 0301 	and.w	r3, r3, #1
34008cf8:	2b00      	cmp	r3, #0
34008cfa:	d056      	beq.n	34008daa <HAL_DMA2D_PollForTransfer+0xca>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34008cfc:	f7fe fc70 	bl	340075e0 <HAL_GetTick>
34008d00:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
34008d02:	e04b      	b.n	34008d9c <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
34008d04:	687b      	ldr	r3, [r7, #4]
34008d06:	681b      	ldr	r3, [r3, #0]
34008d08:	685b      	ldr	r3, [r3, #4]
34008d0a:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34008d0c:	68fb      	ldr	r3, [r7, #12]
34008d0e:	f003 0321 	and.w	r3, r3, #33	@ 0x21
34008d12:	2b00      	cmp	r3, #0
34008d14:	d023      	beq.n	34008d5e <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34008d16:	68fb      	ldr	r3, [r7, #12]
34008d18:	f003 0320 	and.w	r3, r3, #32
34008d1c:	2b00      	cmp	r3, #0
34008d1e:	d005      	beq.n	34008d2c <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34008d20:	687b      	ldr	r3, [r7, #4]
34008d22:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008d24:	f043 0202 	orr.w	r2, r3, #2
34008d28:	687b      	ldr	r3, [r7, #4]
34008d2a:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34008d2c:	68fb      	ldr	r3, [r7, #12]
34008d2e:	f003 0301 	and.w	r3, r3, #1
34008d32:	2b00      	cmp	r3, #0
34008d34:	d005      	beq.n	34008d42 <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34008d36:	687b      	ldr	r3, [r7, #4]
34008d38:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008d3a:	f043 0201 	orr.w	r2, r3, #1
34008d3e:	687b      	ldr	r3, [r7, #4]
34008d40:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34008d42:	687b      	ldr	r3, [r7, #4]
34008d44:	681b      	ldr	r3, [r3, #0]
34008d46:	2221      	movs	r2, #33	@ 0x21
34008d48:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34008d4a:	687b      	ldr	r3, [r7, #4]
34008d4c:	2204      	movs	r2, #4
34008d4e:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
34008d52:	687b      	ldr	r3, [r7, #4]
34008d54:	2200      	movs	r2, #0
34008d56:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
34008d5a:	2301      	movs	r3, #1
34008d5c:	e0a5      	b.n	34008eaa <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34008d5e:	683b      	ldr	r3, [r7, #0]
34008d60:	f1b3 3fff 	cmp.w	r3, #4294967295
34008d64:	d01a      	beq.n	34008d9c <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34008d66:	f7fe fc3b 	bl	340075e0 <HAL_GetTick>
34008d6a:	4602      	mov	r2, r0
34008d6c:	697b      	ldr	r3, [r7, #20]
34008d6e:	1ad3      	subs	r3, r2, r3
34008d70:	683a      	ldr	r2, [r7, #0]
34008d72:	429a      	cmp	r2, r3
34008d74:	d302      	bcc.n	34008d7c <HAL_DMA2D_PollForTransfer+0x9c>
34008d76:	683b      	ldr	r3, [r7, #0]
34008d78:	2b00      	cmp	r3, #0
34008d7a:	d10f      	bne.n	34008d9c <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34008d7c:	687b      	ldr	r3, [r7, #4]
34008d7e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008d80:	f043 0220 	orr.w	r2, r3, #32
34008d84:	687b      	ldr	r3, [r7, #4]
34008d86:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34008d88:	687b      	ldr	r3, [r7, #4]
34008d8a:	2203      	movs	r2, #3
34008d8c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
34008d90:	687b      	ldr	r3, [r7, #4]
34008d92:	2200      	movs	r2, #0
34008d94:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
34008d98:	2303      	movs	r3, #3
34008d9a:	e086      	b.n	34008eaa <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
34008d9c:	687b      	ldr	r3, [r7, #4]
34008d9e:	681b      	ldr	r3, [r3, #0]
34008da0:	685b      	ldr	r3, [r3, #4]
34008da2:	f003 0302 	and.w	r3, r3, #2
34008da6:	2b00      	cmp	r3, #0
34008da8:	d0ac      	beq.n	34008d04 <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
34008daa:	687b      	ldr	r3, [r7, #4]
34008dac:	681b      	ldr	r3, [r3, #0]
34008dae:	69db      	ldr	r3, [r3, #28]
34008db0:	f003 0320 	and.w	r3, r3, #32
34008db4:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
34008db6:	687b      	ldr	r3, [r7, #4]
34008db8:	681b      	ldr	r3, [r3, #0]
34008dba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008dbc:	f003 0320 	and.w	r3, r3, #32
34008dc0:	693a      	ldr	r2, [r7, #16]
34008dc2:	4313      	orrs	r3, r2
34008dc4:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
34008dc6:	693b      	ldr	r3, [r7, #16]
34008dc8:	2b00      	cmp	r3, #0
34008dca:	d061      	beq.n	34008e90 <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34008dcc:	f7fe fc08 	bl	340075e0 <HAL_GetTick>
34008dd0:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34008dd2:	e056      	b.n	34008e82 <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
34008dd4:	687b      	ldr	r3, [r7, #4]
34008dd6:	681b      	ldr	r3, [r3, #0]
34008dd8:	685b      	ldr	r3, [r3, #4]
34008dda:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34008ddc:	68fb      	ldr	r3, [r7, #12]
34008dde:	f003 0329 	and.w	r3, r3, #41	@ 0x29
34008de2:	2b00      	cmp	r3, #0
34008de4:	d02e      	beq.n	34008e44 <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34008de6:	68fb      	ldr	r3, [r7, #12]
34008de8:	f003 0308 	and.w	r3, r3, #8
34008dec:	2b00      	cmp	r3, #0
34008dee:	d005      	beq.n	34008dfc <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34008df0:	687b      	ldr	r3, [r7, #4]
34008df2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008df4:	f043 0204 	orr.w	r2, r3, #4
34008df8:	687b      	ldr	r3, [r7, #4]
34008dfa:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34008dfc:	68fb      	ldr	r3, [r7, #12]
34008dfe:	f003 0320 	and.w	r3, r3, #32
34008e02:	2b00      	cmp	r3, #0
34008e04:	d005      	beq.n	34008e12 <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34008e06:	687b      	ldr	r3, [r7, #4]
34008e08:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008e0a:	f043 0202 	orr.w	r2, r3, #2
34008e0e:	687b      	ldr	r3, [r7, #4]
34008e10:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34008e12:	68fb      	ldr	r3, [r7, #12]
34008e14:	f003 0301 	and.w	r3, r3, #1
34008e18:	2b00      	cmp	r3, #0
34008e1a:	d005      	beq.n	34008e28 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34008e1c:	687b      	ldr	r3, [r7, #4]
34008e1e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008e20:	f043 0201 	orr.w	r2, r3, #1
34008e24:	687b      	ldr	r3, [r7, #4]
34008e26:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34008e28:	687b      	ldr	r3, [r7, #4]
34008e2a:	681b      	ldr	r3, [r3, #0]
34008e2c:	2229      	movs	r2, #41	@ 0x29
34008e2e:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34008e30:	687b      	ldr	r3, [r7, #4]
34008e32:	2204      	movs	r2, #4
34008e34:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
34008e38:	687b      	ldr	r3, [r7, #4]
34008e3a:	2200      	movs	r2, #0
34008e3c:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
34008e40:	2301      	movs	r3, #1
34008e42:	e032      	b.n	34008eaa <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34008e44:	683b      	ldr	r3, [r7, #0]
34008e46:	f1b3 3fff 	cmp.w	r3, #4294967295
34008e4a:	d01a      	beq.n	34008e82 <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34008e4c:	f7fe fbc8 	bl	340075e0 <HAL_GetTick>
34008e50:	4602      	mov	r2, r0
34008e52:	697b      	ldr	r3, [r7, #20]
34008e54:	1ad3      	subs	r3, r2, r3
34008e56:	683a      	ldr	r2, [r7, #0]
34008e58:	429a      	cmp	r2, r3
34008e5a:	d302      	bcc.n	34008e62 <HAL_DMA2D_PollForTransfer+0x182>
34008e5c:	683b      	ldr	r3, [r7, #0]
34008e5e:	2b00      	cmp	r3, #0
34008e60:	d10f      	bne.n	34008e82 <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34008e62:	687b      	ldr	r3, [r7, #4]
34008e64:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34008e66:	f043 0220 	orr.w	r2, r3, #32
34008e6a:	687b      	ldr	r3, [r7, #4]
34008e6c:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34008e6e:	687b      	ldr	r3, [r7, #4]
34008e70:	2203      	movs	r2, #3
34008e72:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
34008e76:	687b      	ldr	r3, [r7, #4]
34008e78:	2200      	movs	r2, #0
34008e7a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
34008e7e:	2303      	movs	r3, #3
34008e80:	e013      	b.n	34008eaa <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34008e82:	687b      	ldr	r3, [r7, #4]
34008e84:	681b      	ldr	r3, [r3, #0]
34008e86:	685b      	ldr	r3, [r3, #4]
34008e88:	f003 0310 	and.w	r3, r3, #16
34008e8c:	2b00      	cmp	r3, #0
34008e8e:	d0a1      	beq.n	34008dd4 <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34008e90:	687b      	ldr	r3, [r7, #4]
34008e92:	681b      	ldr	r3, [r3, #0]
34008e94:	2212      	movs	r2, #18
34008e96:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
34008e98:	687b      	ldr	r3, [r7, #4]
34008e9a:	2201      	movs	r2, #1
34008e9c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
34008ea0:	687b      	ldr	r3, [r7, #4]
34008ea2:	2200      	movs	r2, #0
34008ea4:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34008ea8:	2300      	movs	r3, #0
}
34008eaa:	4618      	mov	r0, r3
34008eac:	3718      	adds	r7, #24
34008eae:	46bd      	mov	sp, r7
34008eb0:	bd80      	pop	{r7, pc}
	...

34008eb4 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
34008eb4:	b580      	push	{r7, lr}
34008eb6:	b086      	sub	sp, #24
34008eb8:	af00      	add	r7, sp, #0
34008eba:	6078      	str	r0, [r7, #4]
34008ebc:	6039      	str	r1, [r7, #0]
  const DMA2D_LayerCfgTypeDef *pLayerCfg;
  uint32_t regMask;
  uint32_t regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
34008ebe:	683b      	ldr	r3, [r7, #0]
34008ec0:	2b00      	cmp	r3, #0
34008ec2:	d007      	beq.n	34008ed4 <HAL_DMA2D_ConfigLayer+0x20>
34008ec4:	683b      	ldr	r3, [r7, #0]
34008ec6:	2b01      	cmp	r3, #1
34008ec8:	d004      	beq.n	34008ed4 <HAL_DMA2D_ConfigLayer+0x20>
34008eca:	f240 61f3 	movw	r1, #1779	@ 0x6f3
34008ece:	489f      	ldr	r0, [pc, #636]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
34008ed0:	f7f8 f9e2 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
34008ed4:	6879      	ldr	r1, [r7, #4]
34008ed6:	683a      	ldr	r2, [r7, #0]
34008ed8:	4613      	mov	r3, r2
34008eda:	00db      	lsls	r3, r3, #3
34008edc:	1a9b      	subs	r3, r3, r2
34008ede:	009b      	lsls	r3, r3, #2
34008ee0:	440b      	add	r3, r1
34008ee2:	3328      	adds	r3, #40	@ 0x28
34008ee4:	681b      	ldr	r3, [r3, #0]
34008ee6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34008eea:	d304      	bcc.n	34008ef6 <HAL_DMA2D_ConfigLayer+0x42>
34008eec:	f240 61f4 	movw	r1, #1780	@ 0x6f4
34008ef0:	4896      	ldr	r0, [pc, #600]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
34008ef2:	f7f8 f9d1 	bl	34001298 <assert_failed>
  if (hdma2d->Init.Mode != DMA2D_R2M)
34008ef6:	687b      	ldr	r3, [r7, #4]
34008ef8:	685b      	ldr	r3, [r3, #4]
34008efa:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34008efe:	f000 80b3 	beq.w	34009068 <HAL_DMA2D_ConfigLayer+0x1b4>
  {
    assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
34008f02:	6879      	ldr	r1, [r7, #4]
34008f04:	683a      	ldr	r2, [r7, #0]
34008f06:	4613      	mov	r3, r2
34008f08:	00db      	lsls	r3, r3, #3
34008f0a:	1a9b      	subs	r3, r3, r2
34008f0c:	009b      	lsls	r3, r3, #2
34008f0e:	440b      	add	r3, r1
34008f10:	332c      	adds	r3, #44	@ 0x2c
34008f12:	681b      	ldr	r3, [r3, #0]
34008f14:	2b00      	cmp	r3, #0
34008f16:	d07d      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f18:	6879      	ldr	r1, [r7, #4]
34008f1a:	683a      	ldr	r2, [r7, #0]
34008f1c:	4613      	mov	r3, r2
34008f1e:	00db      	lsls	r3, r3, #3
34008f20:	1a9b      	subs	r3, r3, r2
34008f22:	009b      	lsls	r3, r3, #2
34008f24:	440b      	add	r3, r1
34008f26:	332c      	adds	r3, #44	@ 0x2c
34008f28:	681b      	ldr	r3, [r3, #0]
34008f2a:	2b01      	cmp	r3, #1
34008f2c:	d072      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f2e:	6879      	ldr	r1, [r7, #4]
34008f30:	683a      	ldr	r2, [r7, #0]
34008f32:	4613      	mov	r3, r2
34008f34:	00db      	lsls	r3, r3, #3
34008f36:	1a9b      	subs	r3, r3, r2
34008f38:	009b      	lsls	r3, r3, #2
34008f3a:	440b      	add	r3, r1
34008f3c:	332c      	adds	r3, #44	@ 0x2c
34008f3e:	681b      	ldr	r3, [r3, #0]
34008f40:	2b02      	cmp	r3, #2
34008f42:	d067      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f44:	6879      	ldr	r1, [r7, #4]
34008f46:	683a      	ldr	r2, [r7, #0]
34008f48:	4613      	mov	r3, r2
34008f4a:	00db      	lsls	r3, r3, #3
34008f4c:	1a9b      	subs	r3, r3, r2
34008f4e:	009b      	lsls	r3, r3, #2
34008f50:	440b      	add	r3, r1
34008f52:	332c      	adds	r3, #44	@ 0x2c
34008f54:	681b      	ldr	r3, [r3, #0]
34008f56:	2b03      	cmp	r3, #3
34008f58:	d05c      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f5a:	6879      	ldr	r1, [r7, #4]
34008f5c:	683a      	ldr	r2, [r7, #0]
34008f5e:	4613      	mov	r3, r2
34008f60:	00db      	lsls	r3, r3, #3
34008f62:	1a9b      	subs	r3, r3, r2
34008f64:	009b      	lsls	r3, r3, #2
34008f66:	440b      	add	r3, r1
34008f68:	332c      	adds	r3, #44	@ 0x2c
34008f6a:	681b      	ldr	r3, [r3, #0]
34008f6c:	2b04      	cmp	r3, #4
34008f6e:	d051      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f70:	6879      	ldr	r1, [r7, #4]
34008f72:	683a      	ldr	r2, [r7, #0]
34008f74:	4613      	mov	r3, r2
34008f76:	00db      	lsls	r3, r3, #3
34008f78:	1a9b      	subs	r3, r3, r2
34008f7a:	009b      	lsls	r3, r3, #2
34008f7c:	440b      	add	r3, r1
34008f7e:	332c      	adds	r3, #44	@ 0x2c
34008f80:	681b      	ldr	r3, [r3, #0]
34008f82:	2b05      	cmp	r3, #5
34008f84:	d046      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f86:	6879      	ldr	r1, [r7, #4]
34008f88:	683a      	ldr	r2, [r7, #0]
34008f8a:	4613      	mov	r3, r2
34008f8c:	00db      	lsls	r3, r3, #3
34008f8e:	1a9b      	subs	r3, r3, r2
34008f90:	009b      	lsls	r3, r3, #2
34008f92:	440b      	add	r3, r1
34008f94:	332c      	adds	r3, #44	@ 0x2c
34008f96:	681b      	ldr	r3, [r3, #0]
34008f98:	2b06      	cmp	r3, #6
34008f9a:	d03b      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008f9c:	6879      	ldr	r1, [r7, #4]
34008f9e:	683a      	ldr	r2, [r7, #0]
34008fa0:	4613      	mov	r3, r2
34008fa2:	00db      	lsls	r3, r3, #3
34008fa4:	1a9b      	subs	r3, r3, r2
34008fa6:	009b      	lsls	r3, r3, #2
34008fa8:	440b      	add	r3, r1
34008faa:	332c      	adds	r3, #44	@ 0x2c
34008fac:	681b      	ldr	r3, [r3, #0]
34008fae:	2b07      	cmp	r3, #7
34008fb0:	d030      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008fb2:	6879      	ldr	r1, [r7, #4]
34008fb4:	683a      	ldr	r2, [r7, #0]
34008fb6:	4613      	mov	r3, r2
34008fb8:	00db      	lsls	r3, r3, #3
34008fba:	1a9b      	subs	r3, r3, r2
34008fbc:	009b      	lsls	r3, r3, #2
34008fbe:	440b      	add	r3, r1
34008fc0:	332c      	adds	r3, #44	@ 0x2c
34008fc2:	681b      	ldr	r3, [r3, #0]
34008fc4:	2b08      	cmp	r3, #8
34008fc6:	d025      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008fc8:	6879      	ldr	r1, [r7, #4]
34008fca:	683a      	ldr	r2, [r7, #0]
34008fcc:	4613      	mov	r3, r2
34008fce:	00db      	lsls	r3, r3, #3
34008fd0:	1a9b      	subs	r3, r3, r2
34008fd2:	009b      	lsls	r3, r3, #2
34008fd4:	440b      	add	r3, r1
34008fd6:	332c      	adds	r3, #44	@ 0x2c
34008fd8:	681b      	ldr	r3, [r3, #0]
34008fda:	2b09      	cmp	r3, #9
34008fdc:	d01a      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008fde:	6879      	ldr	r1, [r7, #4]
34008fe0:	683a      	ldr	r2, [r7, #0]
34008fe2:	4613      	mov	r3, r2
34008fe4:	00db      	lsls	r3, r3, #3
34008fe6:	1a9b      	subs	r3, r3, r2
34008fe8:	009b      	lsls	r3, r3, #2
34008fea:	440b      	add	r3, r1
34008fec:	332c      	adds	r3, #44	@ 0x2c
34008fee:	681b      	ldr	r3, [r3, #0]
34008ff0:	2b0a      	cmp	r3, #10
34008ff2:	d00f      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
34008ff4:	6879      	ldr	r1, [r7, #4]
34008ff6:	683a      	ldr	r2, [r7, #0]
34008ff8:	4613      	mov	r3, r2
34008ffa:	00db      	lsls	r3, r3, #3
34008ffc:	1a9b      	subs	r3, r3, r2
34008ffe:	009b      	lsls	r3, r3, #2
34009000:	440b      	add	r3, r1
34009002:	332c      	adds	r3, #44	@ 0x2c
34009004:	681b      	ldr	r3, [r3, #0]
34009006:	2b0b      	cmp	r3, #11
34009008:	d004      	beq.n	34009014 <HAL_DMA2D_ConfigLayer+0x160>
3400900a:	f240 61f7 	movw	r1, #1783	@ 0x6f7
3400900e:	484f      	ldr	r0, [pc, #316]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
34009010:	f7f8 f942 	bl	34001298 <assert_failed>
    if (hdma2d->Init.Mode != DMA2D_M2M)
34009014:	687b      	ldr	r3, [r7, #4]
34009016:	685b      	ldr	r3, [r3, #4]
34009018:	2b00      	cmp	r3, #0
3400901a:	d025      	beq.n	34009068 <HAL_DMA2D_ConfigLayer+0x1b4>
    {
      assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
3400901c:	6879      	ldr	r1, [r7, #4]
3400901e:	683a      	ldr	r2, [r7, #0]
34009020:	4613      	mov	r3, r2
34009022:	00db      	lsls	r3, r3, #3
34009024:	1a9b      	subs	r3, r3, r2
34009026:	009b      	lsls	r3, r3, #2
34009028:	440b      	add	r3, r1
3400902a:	3330      	adds	r3, #48	@ 0x30
3400902c:	681b      	ldr	r3, [r3, #0]
3400902e:	2b00      	cmp	r3, #0
34009030:	d01a      	beq.n	34009068 <HAL_DMA2D_ConfigLayer+0x1b4>
34009032:	6879      	ldr	r1, [r7, #4]
34009034:	683a      	ldr	r2, [r7, #0]
34009036:	4613      	mov	r3, r2
34009038:	00db      	lsls	r3, r3, #3
3400903a:	1a9b      	subs	r3, r3, r2
3400903c:	009b      	lsls	r3, r3, #2
3400903e:	440b      	add	r3, r1
34009040:	3330      	adds	r3, #48	@ 0x30
34009042:	681b      	ldr	r3, [r3, #0]
34009044:	2b01      	cmp	r3, #1
34009046:	d00f      	beq.n	34009068 <HAL_DMA2D_ConfigLayer+0x1b4>
34009048:	6879      	ldr	r1, [r7, #4]
3400904a:	683a      	ldr	r2, [r7, #0]
3400904c:	4613      	mov	r3, r2
3400904e:	00db      	lsls	r3, r3, #3
34009050:	1a9b      	subs	r3, r3, r2
34009052:	009b      	lsls	r3, r3, #2
34009054:	440b      	add	r3, r1
34009056:	3330      	adds	r3, #48	@ 0x30
34009058:	681b      	ldr	r3, [r3, #0]
3400905a:	2b02      	cmp	r3, #2
3400905c:	d004      	beq.n	34009068 <HAL_DMA2D_ConfigLayer+0x1b4>
3400905e:	f240 61fa 	movw	r1, #1786	@ 0x6fa
34009062:	483a      	ldr	r0, [pc, #232]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
34009064:	f7f8 f918 	bl	34001298 <assert_failed>
    }
  }
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
34009068:	6879      	ldr	r1, [r7, #4]
3400906a:	683a      	ldr	r2, [r7, #0]
3400906c:	4613      	mov	r3, r2
3400906e:	00db      	lsls	r3, r3, #3
34009070:	1a9b      	subs	r3, r3, r2
34009072:	009b      	lsls	r3, r3, #2
34009074:	440b      	add	r3, r1
34009076:	3338      	adds	r3, #56	@ 0x38
34009078:	681b      	ldr	r3, [r3, #0]
3400907a:	2b00      	cmp	r3, #0
3400907c:	d00f      	beq.n	3400909e <HAL_DMA2D_ConfigLayer+0x1ea>
3400907e:	6879      	ldr	r1, [r7, #4]
34009080:	683a      	ldr	r2, [r7, #0]
34009082:	4613      	mov	r3, r2
34009084:	00db      	lsls	r3, r3, #3
34009086:	1a9b      	subs	r3, r3, r2
34009088:	009b      	lsls	r3, r3, #2
3400908a:	440b      	add	r3, r1
3400908c:	3338      	adds	r3, #56	@ 0x38
3400908e:	681b      	ldr	r3, [r3, #0]
34009090:	2b01      	cmp	r3, #1
34009092:	d004      	beq.n	3400909e <HAL_DMA2D_ConfigLayer+0x1ea>
34009094:	f240 61fd 	movw	r1, #1789	@ 0x6fd
34009098:	482c      	ldr	r0, [pc, #176]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
3400909a:	f7f8 f8fd 	bl	34001298 <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
3400909e:	6879      	ldr	r1, [r7, #4]
340090a0:	683a      	ldr	r2, [r7, #0]
340090a2:	4613      	mov	r3, r2
340090a4:	00db      	lsls	r3, r3, #3
340090a6:	1a9b      	subs	r3, r3, r2
340090a8:	009b      	lsls	r3, r3, #2
340090aa:	440b      	add	r3, r1
340090ac:	333c      	adds	r3, #60	@ 0x3c
340090ae:	681b      	ldr	r3, [r3, #0]
340090b0:	2b00      	cmp	r3, #0
340090b2:	d00f      	beq.n	340090d4 <HAL_DMA2D_ConfigLayer+0x220>
340090b4:	6879      	ldr	r1, [r7, #4]
340090b6:	683a      	ldr	r2, [r7, #0]
340090b8:	4613      	mov	r3, r2
340090ba:	00db      	lsls	r3, r3, #3
340090bc:	1a9b      	subs	r3, r3, r2
340090be:	009b      	lsls	r3, r3, #2
340090c0:	440b      	add	r3, r1
340090c2:	333c      	adds	r3, #60	@ 0x3c
340090c4:	681b      	ldr	r3, [r3, #0]
340090c6:	2b01      	cmp	r3, #1
340090c8:	d004      	beq.n	340090d4 <HAL_DMA2D_ConfigLayer+0x220>
340090ca:	f240 61fe 	movw	r1, #1790	@ 0x6fe
340090ce:	481f      	ldr	r0, [pc, #124]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
340090d0:	f7f8 f8e2 	bl	34001298 <assert_failed>

  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
340090d4:	683b      	ldr	r3, [r7, #0]
340090d6:	2b01      	cmp	r3, #1
340090d8:	d130      	bne.n	3400913c <HAL_DMA2D_ConfigLayer+0x288>
340090da:	6879      	ldr	r1, [r7, #4]
340090dc:	683a      	ldr	r2, [r7, #0]
340090de:	4613      	mov	r3, r2
340090e0:	00db      	lsls	r3, r3, #3
340090e2:	1a9b      	subs	r3, r3, r2
340090e4:	009b      	lsls	r3, r3, #2
340090e6:	440b      	add	r3, r1
340090e8:	332c      	adds	r3, #44	@ 0x2c
340090ea:	681b      	ldr	r3, [r3, #0]
340090ec:	2b0b      	cmp	r3, #11
340090ee:	d125      	bne.n	3400913c <HAL_DMA2D_ConfigLayer+0x288>
  {
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
340090f0:	6879      	ldr	r1, [r7, #4]
340090f2:	683a      	ldr	r2, [r7, #0]
340090f4:	4613      	mov	r3, r2
340090f6:	00db      	lsls	r3, r3, #3
340090f8:	1a9b      	subs	r3, r3, r2
340090fa:	009b      	lsls	r3, r3, #2
340090fc:	440b      	add	r3, r1
340090fe:	3340      	adds	r3, #64	@ 0x40
34009100:	681b      	ldr	r3, [r3, #0]
34009102:	2b00      	cmp	r3, #0
34009104:	d01a      	beq.n	3400913c <HAL_DMA2D_ConfigLayer+0x288>
34009106:	6879      	ldr	r1, [r7, #4]
34009108:	683a      	ldr	r2, [r7, #0]
3400910a:	4613      	mov	r3, r2
3400910c:	00db      	lsls	r3, r3, #3
3400910e:	1a9b      	subs	r3, r3, r2
34009110:	009b      	lsls	r3, r3, #2
34009112:	440b      	add	r3, r1
34009114:	3340      	adds	r3, #64	@ 0x40
34009116:	681b      	ldr	r3, [r3, #0]
34009118:	2b01      	cmp	r3, #1
3400911a:	d00f      	beq.n	3400913c <HAL_DMA2D_ConfigLayer+0x288>
3400911c:	6879      	ldr	r1, [r7, #4]
3400911e:	683a      	ldr	r2, [r7, #0]
34009120:	4613      	mov	r3, r2
34009122:	00db      	lsls	r3, r3, #3
34009124:	1a9b      	subs	r3, r3, r2
34009126:	009b      	lsls	r3, r3, #2
34009128:	440b      	add	r3, r1
3400912a:	3340      	adds	r3, #64	@ 0x40
3400912c:	681b      	ldr	r3, [r3, #0]
3400912e:	2b02      	cmp	r3, #2
34009130:	d004      	beq.n	3400913c <HAL_DMA2D_ConfigLayer+0x288>
34009132:	f240 7102 	movw	r1, #1794	@ 0x702
34009136:	4805      	ldr	r0, [pc, #20]	@ (3400914c <HAL_DMA2D_ConfigLayer+0x298>)
34009138:	f7f8 f8ae 	bl	34001298 <assert_failed>
  }

  /* Process locked */
  __HAL_LOCK(hdma2d);
3400913c:	687b      	ldr	r3, [r7, #4]
3400913e:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
34009142:	2b01      	cmp	r3, #1
34009144:	d104      	bne.n	34009150 <HAL_DMA2D_ConfigLayer+0x29c>
34009146:	2302      	movs	r3, #2
34009148:	e095      	b.n	34009276 <HAL_DMA2D_ConfigLayer+0x3c2>
3400914a:	bf00      	nop
3400914c:	340240e4 	.word	0x340240e4
34009150:	687b      	ldr	r3, [r7, #4]
34009152:	2201      	movs	r2, #1
34009154:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34009158:	687b      	ldr	r3, [r7, #4]
3400915a:	2202      	movs	r2, #2
3400915c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
34009160:	683a      	ldr	r2, [r7, #0]
34009162:	4613      	mov	r3, r2
34009164:	00db      	lsls	r3, r3, #3
34009166:	1a9b      	subs	r3, r3, r2
34009168:	009b      	lsls	r3, r3, #2
3400916a:	3328      	adds	r3, #40	@ 0x28
3400916c:	687a      	ldr	r2, [r7, #4]
3400916e:	4413      	add	r3, r2
34009170:	60fb      	str	r3, [r7, #12]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34009172:	68fb      	ldr	r3, [r7, #12]
34009174:	685a      	ldr	r2, [r3, #4]
34009176:	68fb      	ldr	r3, [r7, #12]
34009178:	689b      	ldr	r3, [r3, #8]
3400917a:	041b      	lsls	r3, r3, #16
3400917c:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
3400917e:	68fb      	ldr	r3, [r7, #12]
34009180:	691b      	ldr	r3, [r3, #16]
34009182:	051b      	lsls	r3, r3, #20
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34009184:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34009186:	68fb      	ldr	r3, [r7, #12]
34009188:	695b      	ldr	r3, [r3, #20]
3400918a:	055b      	lsls	r3, r3, #21
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400918c:	4313      	orrs	r3, r2
3400918e:	613b      	str	r3, [r7, #16]
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
34009190:	4b3b      	ldr	r3, [pc, #236]	@ (34009280 <HAL_DMA2D_ConfigLayer+0x3cc>)
34009192:	617b      	str	r3, [r7, #20]


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34009194:	68fb      	ldr	r3, [r7, #12]
34009196:	685b      	ldr	r3, [r3, #4]
34009198:	2b0a      	cmp	r3, #10
3400919a:	d003      	beq.n	340091a4 <HAL_DMA2D_ConfigLayer+0x2f0>
3400919c:	68fb      	ldr	r3, [r7, #12]
3400919e:	685b      	ldr	r3, [r3, #4]
340091a0:	2b09      	cmp	r3, #9
340091a2:	d107      	bne.n	340091b4 <HAL_DMA2D_ConfigLayer+0x300>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
340091a4:	68fb      	ldr	r3, [r7, #12]
340091a6:	68db      	ldr	r3, [r3, #12]
340091a8:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
340091ac:	693a      	ldr	r2, [r7, #16]
340091ae:	4313      	orrs	r3, r2
340091b0:	613b      	str	r3, [r7, #16]
340091b2:	e005      	b.n	340091c0 <HAL_DMA2D_ConfigLayer+0x30c>
  }
  else
  {
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
340091b4:	68fb      	ldr	r3, [r7, #12]
340091b6:	68db      	ldr	r3, [r3, #12]
340091b8:	061b      	lsls	r3, r3, #24
340091ba:	693a      	ldr	r2, [r7, #16]
340091bc:	4313      	orrs	r3, r2
340091be:	613b      	str	r3, [r7, #16]
  }

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
340091c0:	683b      	ldr	r3, [r7, #0]
340091c2:	2b00      	cmp	r3, #0
340091c4:	d120      	bne.n	34009208 <HAL_DMA2D_ConfigLayer+0x354>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340091c6:	687b      	ldr	r3, [r7, #4]
340091c8:	681b      	ldr	r3, [r3, #0]
340091ca:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340091cc:	697b      	ldr	r3, [r7, #20]
340091ce:	43db      	mvns	r3, r3
340091d0:	ea02 0103 	and.w	r1, r2, r3
340091d4:	687b      	ldr	r3, [r7, #4]
340091d6:	681b      	ldr	r3, [r3, #0]
340091d8:	693a      	ldr	r2, [r7, #16]
340091da:	430a      	orrs	r2, r1
340091dc:	625a      	str	r2, [r3, #36]	@ 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
340091de:	687b      	ldr	r3, [r7, #4]
340091e0:	681b      	ldr	r3, [r3, #0]
340091e2:	68fa      	ldr	r2, [r7, #12]
340091e4:	6812      	ldr	r2, [r2, #0]
340091e6:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340091e8:	68fb      	ldr	r3, [r7, #12]
340091ea:	685b      	ldr	r3, [r3, #4]
340091ec:	2b0a      	cmp	r3, #10
340091ee:	d003      	beq.n	340091f8 <HAL_DMA2D_ConfigLayer+0x344>
340091f0:	68fb      	ldr	r3, [r7, #12]
340091f2:	685b      	ldr	r3, [r3, #4]
340091f4:	2b09      	cmp	r3, #9
340091f6:	d135      	bne.n	34009264 <HAL_DMA2D_ConfigLayer+0x3b0>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
340091f8:	68fb      	ldr	r3, [r7, #12]
340091fa:	68da      	ldr	r2, [r3, #12]
340091fc:	687b      	ldr	r3, [r7, #4]
340091fe:	681b      	ldr	r3, [r3, #0]
34009200:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
34009204:	629a      	str	r2, [r3, #40]	@ 0x28
34009206:	e02d      	b.n	34009264 <HAL_DMA2D_ConfigLayer+0x3b0>
  }
  /* Configure the foreground DMA2D layer */
  else
  {

    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
34009208:	68fb      	ldr	r3, [r7, #12]
3400920a:	685b      	ldr	r3, [r3, #4]
3400920c:	2b0b      	cmp	r3, #11
3400920e:	d109      	bne.n	34009224 <HAL_DMA2D_ConfigLayer+0x370>
    {
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
34009210:	68fb      	ldr	r3, [r7, #12]
34009212:	699b      	ldr	r3, [r3, #24]
34009214:	049b      	lsls	r3, r3, #18
34009216:	693a      	ldr	r2, [r7, #16]
34009218:	4313      	orrs	r3, r2
3400921a:	613b      	str	r3, [r7, #16]
      regMask  |= DMA2D_FGPFCCR_CSS;
3400921c:	697b      	ldr	r3, [r7, #20]
3400921e:	f443 2340 	orr.w	r3, r3, #786432	@ 0xc0000
34009222:	617b      	str	r3, [r7, #20]
    }

    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34009224:	687b      	ldr	r3, [r7, #4]
34009226:	681b      	ldr	r3, [r3, #0]
34009228:	69da      	ldr	r2, [r3, #28]
3400922a:	697b      	ldr	r3, [r7, #20]
3400922c:	43db      	mvns	r3, r3
3400922e:	ea02 0103 	and.w	r1, r2, r3
34009232:	687b      	ldr	r3, [r7, #4]
34009234:	681b      	ldr	r3, [r3, #0]
34009236:	693a      	ldr	r2, [r7, #16]
34009238:	430a      	orrs	r2, r1
3400923a:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
3400923c:	687b      	ldr	r3, [r7, #4]
3400923e:	681b      	ldr	r3, [r3, #0]
34009240:	68fa      	ldr	r2, [r7, #12]
34009242:	6812      	ldr	r2, [r2, #0]
34009244:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34009246:	68fb      	ldr	r3, [r7, #12]
34009248:	685b      	ldr	r3, [r3, #4]
3400924a:	2b0a      	cmp	r3, #10
3400924c:	d003      	beq.n	34009256 <HAL_DMA2D_ConfigLayer+0x3a2>
3400924e:	68fb      	ldr	r3, [r7, #12]
34009250:	685b      	ldr	r3, [r3, #4]
34009252:	2b09      	cmp	r3, #9
34009254:	d106      	bne.n	34009264 <HAL_DMA2D_ConfigLayer+0x3b0>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
34009256:	68fb      	ldr	r3, [r7, #12]
34009258:	68da      	ldr	r2, [r3, #12]
3400925a:	687b      	ldr	r3, [r7, #4]
3400925c:	681b      	ldr	r3, [r3, #0]
3400925e:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
34009262:	621a      	str	r2, [r3, #32]
                                                                   DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
34009264:	687b      	ldr	r3, [r7, #4]
34009266:	2201      	movs	r2, #1
34009268:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
3400926c:	687b      	ldr	r3, [r7, #4]
3400926e:	2200      	movs	r2, #0
34009270:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34009274:	2300      	movs	r3, #0
}
34009276:	4618      	mov	r0, r3
34009278:	3718      	adds	r7, #24
3400927a:	46bd      	mov	sp, r7
3400927c:	bd80      	pop	{r7, pc}
3400927e:	bf00      	nop
34009280:	ff33000f 	.word	0xff33000f

34009284 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
34009284:	b480      	push	{r7}
34009286:	b08b      	sub	sp, #44	@ 0x2c
34009288:	af00      	add	r7, sp, #0
3400928a:	60f8      	str	r0, [r7, #12]
3400928c:	60b9      	str	r1, [r7, #8]
3400928e:	607a      	str	r2, [r7, #4]
34009290:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34009292:	68fb      	ldr	r3, [r7, #12]
34009294:	681b      	ldr	r3, [r3, #0]
34009296:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009298:	f003 4140 	and.w	r1, r3, #3221225472	@ 0xc0000000
3400929c:	683b      	ldr	r3, [r7, #0]
3400929e:	041a      	lsls	r2, r3, #16
340092a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340092a2:	431a      	orrs	r2, r3
340092a4:	68fb      	ldr	r3, [r7, #12]
340092a6:	681b      	ldr	r3, [r3, #0]
340092a8:	430a      	orrs	r2, r1
340092aa:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
340092ac:	68fb      	ldr	r3, [r7, #12]
340092ae:	681b      	ldr	r3, [r3, #0]
340092b0:	687a      	ldr	r2, [r7, #4]
340092b2:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
340092b4:	68fb      	ldr	r3, [r7, #12]
340092b6:	685b      	ldr	r3, [r3, #4]
340092b8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340092bc:	d174      	bne.n	340093a8 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
340092be:	68bb      	ldr	r3, [r7, #8]
340092c0:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
340092c4:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
340092c6:	68bb      	ldr	r3, [r7, #8]
340092c8:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
340092cc:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
340092ce:	68bb      	ldr	r3, [r7, #8]
340092d0:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
340092d4:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
340092d6:	68bb      	ldr	r3, [r7, #8]
340092d8:	b2db      	uxtb	r3, r3
340092da:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
340092dc:	68fb      	ldr	r3, [r7, #12]
340092de:	689b      	ldr	r3, [r3, #8]
340092e0:	2b00      	cmp	r3, #0
340092e2:	d108      	bne.n	340092f6 <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
340092e4:	69ba      	ldr	r2, [r7, #24]
340092e6:	69fb      	ldr	r3, [r7, #28]
340092e8:	431a      	orrs	r2, r3
340092ea:	6a3b      	ldr	r3, [r7, #32]
340092ec:	4313      	orrs	r3, r2
340092ee:	697a      	ldr	r2, [r7, #20]
340092f0:	4313      	orrs	r3, r2
340092f2:	627b      	str	r3, [r7, #36]	@ 0x24
340092f4:	e053      	b.n	3400939e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
340092f6:	68fb      	ldr	r3, [r7, #12]
340092f8:	689b      	ldr	r3, [r3, #8]
340092fa:	2b01      	cmp	r3, #1
340092fc:	d106      	bne.n	3400930c <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
340092fe:	69ba      	ldr	r2, [r7, #24]
34009300:	69fb      	ldr	r3, [r7, #28]
34009302:	4313      	orrs	r3, r2
34009304:	697a      	ldr	r2, [r7, #20]
34009306:	4313      	orrs	r3, r2
34009308:	627b      	str	r3, [r7, #36]	@ 0x24
3400930a:	e048      	b.n	3400939e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
3400930c:	68fb      	ldr	r3, [r7, #12]
3400930e:	689b      	ldr	r3, [r3, #8]
34009310:	2b02      	cmp	r3, #2
34009312:	d111      	bne.n	34009338 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
34009314:	69fb      	ldr	r3, [r7, #28]
34009316:	0cdb      	lsrs	r3, r3, #19
34009318:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
3400931a:	69bb      	ldr	r3, [r7, #24]
3400931c:	0a9b      	lsrs	r3, r3, #10
3400931e:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
34009320:	697b      	ldr	r3, [r7, #20]
34009322:	08db      	lsrs	r3, r3, #3
34009324:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
34009326:	69bb      	ldr	r3, [r7, #24]
34009328:	015a      	lsls	r2, r3, #5
3400932a:	69fb      	ldr	r3, [r7, #28]
3400932c:	02db      	lsls	r3, r3, #11
3400932e:	4313      	orrs	r3, r2
34009330:	697a      	ldr	r2, [r7, #20]
34009332:	4313      	orrs	r3, r2
34009334:	627b      	str	r3, [r7, #36]	@ 0x24
34009336:	e032      	b.n	3400939e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
34009338:	68fb      	ldr	r3, [r7, #12]
3400933a:	689b      	ldr	r3, [r3, #8]
3400933c:	2b03      	cmp	r3, #3
3400933e:	d117      	bne.n	34009370 <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
34009340:	6a3b      	ldr	r3, [r7, #32]
34009342:	0fdb      	lsrs	r3, r3, #31
34009344:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
34009346:	69fb      	ldr	r3, [r7, #28]
34009348:	0cdb      	lsrs	r3, r3, #19
3400934a:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
3400934c:	69bb      	ldr	r3, [r7, #24]
3400934e:	0adb      	lsrs	r3, r3, #11
34009350:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
34009352:	697b      	ldr	r3, [r7, #20]
34009354:	08db      	lsrs	r3, r3, #3
34009356:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34009358:	69bb      	ldr	r3, [r7, #24]
3400935a:	015a      	lsls	r2, r3, #5
3400935c:	69fb      	ldr	r3, [r7, #28]
3400935e:	029b      	lsls	r3, r3, #10
34009360:	431a      	orrs	r2, r3
34009362:	6a3b      	ldr	r3, [r7, #32]
34009364:	03db      	lsls	r3, r3, #15
34009366:	4313      	orrs	r3, r2
34009368:	697a      	ldr	r2, [r7, #20]
3400936a:	4313      	orrs	r3, r2
3400936c:	627b      	str	r3, [r7, #36]	@ 0x24
3400936e:	e016      	b.n	3400939e <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
34009370:	6a3b      	ldr	r3, [r7, #32]
34009372:	0f1b      	lsrs	r3, r3, #28
34009374:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
34009376:	69fb      	ldr	r3, [r7, #28]
34009378:	0d1b      	lsrs	r3, r3, #20
3400937a:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
3400937c:	69bb      	ldr	r3, [r7, #24]
3400937e:	0b1b      	lsrs	r3, r3, #12
34009380:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
34009382:	697b      	ldr	r3, [r7, #20]
34009384:	091b      	lsrs	r3, r3, #4
34009386:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34009388:	69bb      	ldr	r3, [r7, #24]
3400938a:	011a      	lsls	r2, r3, #4
3400938c:	69fb      	ldr	r3, [r7, #28]
3400938e:	021b      	lsls	r3, r3, #8
34009390:	431a      	orrs	r2, r3
34009392:	6a3b      	ldr	r3, [r7, #32]
34009394:	031b      	lsls	r3, r3, #12
34009396:	4313      	orrs	r3, r2
34009398:	697a      	ldr	r2, [r7, #20]
3400939a:	4313      	orrs	r3, r2
3400939c:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
3400939e:	68fb      	ldr	r3, [r7, #12]
340093a0:	681b      	ldr	r3, [r3, #0]
340093a2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340093a4:	639a      	str	r2, [r3, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
340093a6:	e00d      	b.n	340093c4 <DMA2D_SetConfig+0x140>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
340093a8:	68fb      	ldr	r3, [r7, #12]
340093aa:	685b      	ldr	r3, [r3, #4]
340093ac:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340093b0:	d104      	bne.n	340093bc <DMA2D_SetConfig+0x138>
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
340093b2:	68fb      	ldr	r3, [r7, #12]
340093b4:	681b      	ldr	r3, [r3, #0]
340093b6:	68ba      	ldr	r2, [r7, #8]
340093b8:	615a      	str	r2, [r3, #20]
}
340093ba:	e003      	b.n	340093c4 <DMA2D_SetConfig+0x140>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
340093bc:	68fb      	ldr	r3, [r7, #12]
340093be:	681b      	ldr	r3, [r3, #0]
340093c0:	68ba      	ldr	r2, [r7, #8]
340093c2:	60da      	str	r2, [r3, #12]
}
340093c4:	bf00      	nop
340093c6:	372c      	adds	r7, #44	@ 0x2c
340093c8:	46bd      	mov	sp, r7
340093ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340093ce:	4770      	bx	lr

340093d0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
340093d0:	b580      	push	{r7, lr}
340093d2:	b086      	sub	sp, #24
340093d4:	af00      	add	r7, sp, #0
340093d6:	6078      	str	r0, [r7, #4]
340093d8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
340093da:	2300      	movs	r3, #0
340093dc:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent;
  uint32_t temp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
340093de:	687b      	ldr	r3, [r7, #4]
340093e0:	4a5b      	ldr	r2, [pc, #364]	@ (34009550 <HAL_GPIO_Init+0x180>)
340093e2:	4293      	cmp	r3, r2
340093e4:	d05f      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
340093e6:	687b      	ldr	r3, [r7, #4]
340093e8:	4a5a      	ldr	r2, [pc, #360]	@ (34009554 <HAL_GPIO_Init+0x184>)
340093ea:	4293      	cmp	r3, r2
340093ec:	d05b      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
340093ee:	687b      	ldr	r3, [r7, #4]
340093f0:	4a59      	ldr	r2, [pc, #356]	@ (34009558 <HAL_GPIO_Init+0x188>)
340093f2:	4293      	cmp	r3, r2
340093f4:	d057      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
340093f6:	687b      	ldr	r3, [r7, #4]
340093f8:	4a58      	ldr	r2, [pc, #352]	@ (3400955c <HAL_GPIO_Init+0x18c>)
340093fa:	4293      	cmp	r3, r2
340093fc:	d053      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
340093fe:	687b      	ldr	r3, [r7, #4]
34009400:	4a57      	ldr	r2, [pc, #348]	@ (34009560 <HAL_GPIO_Init+0x190>)
34009402:	4293      	cmp	r3, r2
34009404:	d04f      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009406:	687b      	ldr	r3, [r7, #4]
34009408:	4a56      	ldr	r2, [pc, #344]	@ (34009564 <HAL_GPIO_Init+0x194>)
3400940a:	4293      	cmp	r3, r2
3400940c:	d04b      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400940e:	687b      	ldr	r3, [r7, #4]
34009410:	4a55      	ldr	r2, [pc, #340]	@ (34009568 <HAL_GPIO_Init+0x198>)
34009412:	4293      	cmp	r3, r2
34009414:	d047      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009416:	687b      	ldr	r3, [r7, #4]
34009418:	4a54      	ldr	r2, [pc, #336]	@ (3400956c <HAL_GPIO_Init+0x19c>)
3400941a:	4293      	cmp	r3, r2
3400941c:	d043      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400941e:	687b      	ldr	r3, [r7, #4]
34009420:	4a53      	ldr	r2, [pc, #332]	@ (34009570 <HAL_GPIO_Init+0x1a0>)
34009422:	4293      	cmp	r3, r2
34009424:	d03f      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009426:	687b      	ldr	r3, [r7, #4]
34009428:	4a52      	ldr	r2, [pc, #328]	@ (34009574 <HAL_GPIO_Init+0x1a4>)
3400942a:	4293      	cmp	r3, r2
3400942c:	d03b      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400942e:	687b      	ldr	r3, [r7, #4]
34009430:	4a51      	ldr	r2, [pc, #324]	@ (34009578 <HAL_GPIO_Init+0x1a8>)
34009432:	4293      	cmp	r3, r2
34009434:	d037      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009436:	687b      	ldr	r3, [r7, #4]
34009438:	4a50      	ldr	r2, [pc, #320]	@ (3400957c <HAL_GPIO_Init+0x1ac>)
3400943a:	4293      	cmp	r3, r2
3400943c:	d033      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400943e:	687b      	ldr	r3, [r7, #4]
34009440:	4a4f      	ldr	r2, [pc, #316]	@ (34009580 <HAL_GPIO_Init+0x1b0>)
34009442:	4293      	cmp	r3, r2
34009444:	d02f      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009446:	687b      	ldr	r3, [r7, #4]
34009448:	4a4e      	ldr	r2, [pc, #312]	@ (34009584 <HAL_GPIO_Init+0x1b4>)
3400944a:	4293      	cmp	r3, r2
3400944c:	d02b      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400944e:	687b      	ldr	r3, [r7, #4]
34009450:	4a4d      	ldr	r2, [pc, #308]	@ (34009588 <HAL_GPIO_Init+0x1b8>)
34009452:	4293      	cmp	r3, r2
34009454:	d027      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009456:	687b      	ldr	r3, [r7, #4]
34009458:	4a4c      	ldr	r2, [pc, #304]	@ (3400958c <HAL_GPIO_Init+0x1bc>)
3400945a:	4293      	cmp	r3, r2
3400945c:	d023      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400945e:	687b      	ldr	r3, [r7, #4]
34009460:	4a4b      	ldr	r2, [pc, #300]	@ (34009590 <HAL_GPIO_Init+0x1c0>)
34009462:	4293      	cmp	r3, r2
34009464:	d01f      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009466:	687b      	ldr	r3, [r7, #4]
34009468:	4a4a      	ldr	r2, [pc, #296]	@ (34009594 <HAL_GPIO_Init+0x1c4>)
3400946a:	4293      	cmp	r3, r2
3400946c:	d01b      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400946e:	687b      	ldr	r3, [r7, #4]
34009470:	4a49      	ldr	r2, [pc, #292]	@ (34009598 <HAL_GPIO_Init+0x1c8>)
34009472:	4293      	cmp	r3, r2
34009474:	d017      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009476:	687b      	ldr	r3, [r7, #4]
34009478:	4a48      	ldr	r2, [pc, #288]	@ (3400959c <HAL_GPIO_Init+0x1cc>)
3400947a:	4293      	cmp	r3, r2
3400947c:	d013      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400947e:	687b      	ldr	r3, [r7, #4]
34009480:	4a47      	ldr	r2, [pc, #284]	@ (340095a0 <HAL_GPIO_Init+0x1d0>)
34009482:	4293      	cmp	r3, r2
34009484:	d00f      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009486:	687b      	ldr	r3, [r7, #4]
34009488:	4a46      	ldr	r2, [pc, #280]	@ (340095a4 <HAL_GPIO_Init+0x1d4>)
3400948a:	4293      	cmp	r3, r2
3400948c:	d00b      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400948e:	687b      	ldr	r3, [r7, #4]
34009490:	4a45      	ldr	r2, [pc, #276]	@ (340095a8 <HAL_GPIO_Init+0x1d8>)
34009492:	4293      	cmp	r3, r2
34009494:	d007      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
34009496:	687b      	ldr	r3, [r7, #4]
34009498:	4a44      	ldr	r2, [pc, #272]	@ (340095ac <HAL_GPIO_Init+0x1dc>)
3400949a:	4293      	cmp	r3, r2
3400949c:	d003      	beq.n	340094a6 <HAL_GPIO_Init+0xd6>
3400949e:	21ad      	movs	r1, #173	@ 0xad
340094a0:	4843      	ldr	r0, [pc, #268]	@ (340095b0 <HAL_GPIO_Init+0x1e0>)
340094a2:	f7f7 fef9 	bl	34001298 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
340094a6:	683b      	ldr	r3, [r7, #0]
340094a8:	681b      	ldr	r3, [r3, #0]
340094aa:	b29b      	uxth	r3, r3
340094ac:	2b00      	cmp	r3, #0
340094ae:	d004      	beq.n	340094ba <HAL_GPIO_Init+0xea>
340094b0:	683b      	ldr	r3, [r7, #0]
340094b2:	681b      	ldr	r3, [r3, #0]
340094b4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340094b8:	d303      	bcc.n	340094c2 <HAL_GPIO_Init+0xf2>
340094ba:	21ae      	movs	r1, #174	@ 0xae
340094bc:	483c      	ldr	r0, [pc, #240]	@ (340095b0 <HAL_GPIO_Init+0x1e0>)
340094be:	f7f7 feeb 	bl	34001298 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
340094c2:	683b      	ldr	r3, [r7, #0]
340094c4:	685b      	ldr	r3, [r3, #4]
340094c6:	2b00      	cmp	r3, #0
340094c8:	f000 82bb 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
340094cc:	683b      	ldr	r3, [r7, #0]
340094ce:	685b      	ldr	r3, [r3, #4]
340094d0:	2b01      	cmp	r3, #1
340094d2:	f000 82b6 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
340094d6:	683b      	ldr	r3, [r7, #0]
340094d8:	685b      	ldr	r3, [r3, #4]
340094da:	2b11      	cmp	r3, #17
340094dc:	f000 82b1 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
340094e0:	683b      	ldr	r3, [r7, #0]
340094e2:	685b      	ldr	r3, [r3, #4]
340094e4:	2b02      	cmp	r3, #2
340094e6:	f000 82ac 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
340094ea:	683b      	ldr	r3, [r7, #0]
340094ec:	685b      	ldr	r3, [r3, #4]
340094ee:	2b12      	cmp	r3, #18
340094f0:	f000 82a7 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
340094f4:	683b      	ldr	r3, [r7, #0]
340094f6:	685b      	ldr	r3, [r3, #4]
340094f8:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
340094fc:	f000 82a1 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
34009500:	683b      	ldr	r3, [r7, #0]
34009502:	685b      	ldr	r3, [r3, #4]
34009504:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
34009508:	f000 829b 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
3400950c:	683b      	ldr	r3, [r7, #0]
3400950e:	685b      	ldr	r3, [r3, #4]
34009510:	f5b3 1f44 	cmp.w	r3, #3211264	@ 0x310000
34009514:	f000 8295 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
34009518:	683b      	ldr	r3, [r7, #0]
3400951a:	685b      	ldr	r3, [r3, #4]
3400951c:	f5b3 1f90 	cmp.w	r3, #1179648	@ 0x120000
34009520:	f000 828f 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
34009524:	683b      	ldr	r3, [r7, #0]
34009526:	685b      	ldr	r3, [r3, #4]
34009528:	f5b3 1f08 	cmp.w	r3, #2228224	@ 0x220000
3400952c:	f000 8289 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
34009530:	683b      	ldr	r3, [r7, #0]
34009532:	685b      	ldr	r3, [r3, #4]
34009534:	f5b3 1f48 	cmp.w	r3, #3276800	@ 0x320000
34009538:	f000 8283 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
3400953c:	683b      	ldr	r3, [r7, #0]
3400953e:	685b      	ldr	r3, [r3, #4]
34009540:	2b03      	cmp	r3, #3
34009542:	f000 827e 	beq.w	34009a42 <HAL_GPIO_Init+0x672>
34009546:	21af      	movs	r1, #175	@ 0xaf
34009548:	4819      	ldr	r0, [pc, #100]	@ (340095b0 <HAL_GPIO_Init+0x1e0>)
3400954a:	f7f7 fea5 	bl	34001298 <assert_failed>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3400954e:	e278      	b.n	34009a42 <HAL_GPIO_Init+0x672>
34009550:	56020000 	.word	0x56020000
34009554:	46020000 	.word	0x46020000
34009558:	56020400 	.word	0x56020400
3400955c:	46020400 	.word	0x46020400
34009560:	56020800 	.word	0x56020800
34009564:	46020800 	.word	0x46020800
34009568:	56020c00 	.word	0x56020c00
3400956c:	46020c00 	.word	0x46020c00
34009570:	56021000 	.word	0x56021000
34009574:	46021000 	.word	0x46021000
34009578:	56021400 	.word	0x56021400
3400957c:	46021400 	.word	0x46021400
34009580:	56021800 	.word	0x56021800
34009584:	46021800 	.word	0x46021800
34009588:	56021c00 	.word	0x56021c00
3400958c:	46021c00 	.word	0x46021c00
34009590:	56023400 	.word	0x56023400
34009594:	46023400 	.word	0x46023400
34009598:	56023800 	.word	0x56023800
3400959c:	46023800 	.word	0x46023800
340095a0:	56023c00 	.word	0x56023c00
340095a4:	46023c00 	.word	0x46023c00
340095a8:	56024000 	.word	0x56024000
340095ac:	46024000 	.word	0x46024000
340095b0:	34024154 	.word	0x34024154
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
340095b4:	683b      	ldr	r3, [r7, #0]
340095b6:	681a      	ldr	r2, [r3, #0]
340095b8:	2101      	movs	r1, #1
340095ba:	697b      	ldr	r3, [r7, #20]
340095bc:	fa01 f303 	lsl.w	r3, r1, r3
340095c0:	4013      	ands	r3, r2
340095c2:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
340095c4:	68fb      	ldr	r3, [r7, #12]
340095c6:	2b00      	cmp	r3, #0
340095c8:	f000 8238 	beq.w	34009a3c <HAL_GPIO_Init+0x66c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
340095cc:	683b      	ldr	r3, [r7, #0]
340095ce:	685b      	ldr	r3, [r3, #4]
340095d0:	f003 0303 	and.w	r3, r3, #3
340095d4:	2b01      	cmp	r3, #1
340095d6:	d005      	beq.n	340095e4 <HAL_GPIO_Init+0x214>
340095d8:	683b      	ldr	r3, [r7, #0]
340095da:	685b      	ldr	r3, [r3, #4]
340095dc:	f003 0303 	and.w	r3, r3, #3
340095e0:	2b02      	cmp	r3, #2
340095e2:	d144      	bne.n	3400966e <HAL_GPIO_Init+0x29e>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
340095e4:	683b      	ldr	r3, [r7, #0]
340095e6:	68db      	ldr	r3, [r3, #12]
340095e8:	2b00      	cmp	r3, #0
340095ea:	d00f      	beq.n	3400960c <HAL_GPIO_Init+0x23c>
340095ec:	683b      	ldr	r3, [r7, #0]
340095ee:	68db      	ldr	r3, [r3, #12]
340095f0:	2b01      	cmp	r3, #1
340095f2:	d00b      	beq.n	3400960c <HAL_GPIO_Init+0x23c>
340095f4:	683b      	ldr	r3, [r7, #0]
340095f6:	68db      	ldr	r3, [r3, #12]
340095f8:	2b02      	cmp	r3, #2
340095fa:	d007      	beq.n	3400960c <HAL_GPIO_Init+0x23c>
340095fc:	683b      	ldr	r3, [r7, #0]
340095fe:	68db      	ldr	r3, [r3, #12]
34009600:	2b03      	cmp	r3, #3
34009602:	d003      	beq.n	3400960c <HAL_GPIO_Init+0x23c>
34009604:	21be      	movs	r1, #190	@ 0xbe
34009606:	4896      	ldr	r0, [pc, #600]	@ (34009860 <HAL_GPIO_Init+0x490>)
34009608:	f7f7 fe46 	bl	34001298 <assert_failed>

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
3400960c:	687b      	ldr	r3, [r7, #4]
3400960e:	689b      	ldr	r3, [r3, #8]
34009610:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34009612:	697b      	ldr	r3, [r7, #20]
34009614:	005b      	lsls	r3, r3, #1
34009616:	2203      	movs	r2, #3
34009618:	fa02 f303 	lsl.w	r3, r2, r3
3400961c:	43db      	mvns	r3, r3
3400961e:	693a      	ldr	r2, [r7, #16]
34009620:	4013      	ands	r3, r2
34009622:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34009624:	683b      	ldr	r3, [r7, #0]
34009626:	68da      	ldr	r2, [r3, #12]
34009628:	697b      	ldr	r3, [r7, #20]
3400962a:	005b      	lsls	r3, r3, #1
3400962c:	fa02 f303 	lsl.w	r3, r2, r3
34009630:	693a      	ldr	r2, [r7, #16]
34009632:	4313      	orrs	r3, r2
34009634:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34009636:	687b      	ldr	r3, [r7, #4]
34009638:	693a      	ldr	r2, [r7, #16]
3400963a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
3400963c:	687b      	ldr	r3, [r7, #4]
3400963e:	685b      	ldr	r3, [r3, #4]
34009640:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34009642:	2201      	movs	r2, #1
34009644:	697b      	ldr	r3, [r7, #20]
34009646:	fa02 f303 	lsl.w	r3, r2, r3
3400964a:	43db      	mvns	r3, r3
3400964c:	693a      	ldr	r2, [r7, #16]
3400964e:	4013      	ands	r3, r2
34009650:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34009652:	683b      	ldr	r3, [r7, #0]
34009654:	685b      	ldr	r3, [r3, #4]
34009656:	091b      	lsrs	r3, r3, #4
34009658:	f003 0201 	and.w	r2, r3, #1
3400965c:	697b      	ldr	r3, [r7, #20]
3400965e:	fa02 f303 	lsl.w	r3, r2, r3
34009662:	693a      	ldr	r2, [r7, #16]
34009664:	4313      	orrs	r3, r2
34009666:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34009668:	687b      	ldr	r3, [r7, #4]
3400966a:	693a      	ldr	r2, [r7, #16]
3400966c:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3400966e:	683b      	ldr	r3, [r7, #0]
34009670:	685b      	ldr	r3, [r3, #4]
34009672:	f003 0303 	and.w	r3, r3, #3
34009676:	2b03      	cmp	r3, #3
34009678:	d109      	bne.n	3400968e <HAL_GPIO_Init+0x2be>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3400967a:	683b      	ldr	r3, [r7, #0]
3400967c:	685b      	ldr	r3, [r3, #4]
3400967e:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34009682:	2b03      	cmp	r3, #3
34009684:	d12b      	bne.n	340096de <HAL_GPIO_Init+0x30e>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34009686:	683b      	ldr	r3, [r7, #0]
34009688:	689b      	ldr	r3, [r3, #8]
3400968a:	2b01      	cmp	r3, #1
3400968c:	d027      	beq.n	340096de <HAL_GPIO_Init+0x30e>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
3400968e:	683b      	ldr	r3, [r7, #0]
34009690:	689b      	ldr	r3, [r3, #8]
34009692:	2b00      	cmp	r3, #0
34009694:	d00b      	beq.n	340096ae <HAL_GPIO_Init+0x2de>
34009696:	683b      	ldr	r3, [r7, #0]
34009698:	689b      	ldr	r3, [r3, #8]
3400969a:	2b01      	cmp	r3, #1
3400969c:	d007      	beq.n	340096ae <HAL_GPIO_Init+0x2de>
3400969e:	683b      	ldr	r3, [r7, #0]
340096a0:	689b      	ldr	r3, [r3, #8]
340096a2:	2b02      	cmp	r3, #2
340096a4:	d003      	beq.n	340096ae <HAL_GPIO_Init+0x2de>
340096a6:	21d1      	movs	r1, #209	@ 0xd1
340096a8:	486d      	ldr	r0, [pc, #436]	@ (34009860 <HAL_GPIO_Init+0x490>)
340096aa:	f7f7 fdf5 	bl	34001298 <assert_failed>

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
340096ae:	687b      	ldr	r3, [r7, #4]
340096b0:	68db      	ldr	r3, [r3, #12]
340096b2:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340096b4:	697b      	ldr	r3, [r7, #20]
340096b6:	005b      	lsls	r3, r3, #1
340096b8:	2203      	movs	r2, #3
340096ba:	fa02 f303 	lsl.w	r3, r2, r3
340096be:	43db      	mvns	r3, r3
340096c0:	693a      	ldr	r2, [r7, #16]
340096c2:	4013      	ands	r3, r2
340096c4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
340096c6:	683b      	ldr	r3, [r7, #0]
340096c8:	689a      	ldr	r2, [r3, #8]
340096ca:	697b      	ldr	r3, [r7, #20]
340096cc:	005b      	lsls	r3, r3, #1
340096ce:	fa02 f303 	lsl.w	r3, r2, r3
340096d2:	693a      	ldr	r2, [r7, #16]
340096d4:	4313      	orrs	r3, r2
340096d6:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
340096d8:	687b      	ldr	r3, [r7, #4]
340096da:	693a      	ldr	r2, [r7, #16]
340096dc:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
340096de:	683b      	ldr	r3, [r7, #0]
340096e0:	685b      	ldr	r3, [r3, #4]
340096e2:	f003 0303 	and.w	r3, r3, #3
340096e6:	2b02      	cmp	r3, #2
340096e8:	f040 8090 	bne.w	3400980c <HAL_GPIO_Init+0x43c>
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
340096ec:	687b      	ldr	r3, [r7, #4]
340096ee:	4a5d      	ldr	r2, [pc, #372]	@ (34009864 <HAL_GPIO_Init+0x494>)
340096f0:	4293      	cmp	r3, r2
340096f2:	d05f      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
340096f4:	687b      	ldr	r3, [r7, #4]
340096f6:	4a5c      	ldr	r2, [pc, #368]	@ (34009868 <HAL_GPIO_Init+0x498>)
340096f8:	4293      	cmp	r3, r2
340096fa:	d05b      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
340096fc:	687b      	ldr	r3, [r7, #4]
340096fe:	4a5b      	ldr	r2, [pc, #364]	@ (3400986c <HAL_GPIO_Init+0x49c>)
34009700:	4293      	cmp	r3, r2
34009702:	d057      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009704:	687b      	ldr	r3, [r7, #4]
34009706:	4a5a      	ldr	r2, [pc, #360]	@ (34009870 <HAL_GPIO_Init+0x4a0>)
34009708:	4293      	cmp	r3, r2
3400970a:	d053      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400970c:	687b      	ldr	r3, [r7, #4]
3400970e:	4a59      	ldr	r2, [pc, #356]	@ (34009874 <HAL_GPIO_Init+0x4a4>)
34009710:	4293      	cmp	r3, r2
34009712:	d04f      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009714:	687b      	ldr	r3, [r7, #4]
34009716:	4a58      	ldr	r2, [pc, #352]	@ (34009878 <HAL_GPIO_Init+0x4a8>)
34009718:	4293      	cmp	r3, r2
3400971a:	d04b      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400971c:	687b      	ldr	r3, [r7, #4]
3400971e:	4a57      	ldr	r2, [pc, #348]	@ (3400987c <HAL_GPIO_Init+0x4ac>)
34009720:	4293      	cmp	r3, r2
34009722:	d047      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009724:	687b      	ldr	r3, [r7, #4]
34009726:	4a56      	ldr	r2, [pc, #344]	@ (34009880 <HAL_GPIO_Init+0x4b0>)
34009728:	4293      	cmp	r3, r2
3400972a:	d043      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400972c:	687b      	ldr	r3, [r7, #4]
3400972e:	4a55      	ldr	r2, [pc, #340]	@ (34009884 <HAL_GPIO_Init+0x4b4>)
34009730:	4293      	cmp	r3, r2
34009732:	d03f      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009734:	687b      	ldr	r3, [r7, #4]
34009736:	4a54      	ldr	r2, [pc, #336]	@ (34009888 <HAL_GPIO_Init+0x4b8>)
34009738:	4293      	cmp	r3, r2
3400973a:	d03b      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400973c:	687b      	ldr	r3, [r7, #4]
3400973e:	4a53      	ldr	r2, [pc, #332]	@ (3400988c <HAL_GPIO_Init+0x4bc>)
34009740:	4293      	cmp	r3, r2
34009742:	d037      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009744:	687b      	ldr	r3, [r7, #4]
34009746:	4a52      	ldr	r2, [pc, #328]	@ (34009890 <HAL_GPIO_Init+0x4c0>)
34009748:	4293      	cmp	r3, r2
3400974a:	d033      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400974c:	687b      	ldr	r3, [r7, #4]
3400974e:	4a51      	ldr	r2, [pc, #324]	@ (34009894 <HAL_GPIO_Init+0x4c4>)
34009750:	4293      	cmp	r3, r2
34009752:	d02f      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009754:	687b      	ldr	r3, [r7, #4]
34009756:	4a50      	ldr	r2, [pc, #320]	@ (34009898 <HAL_GPIO_Init+0x4c8>)
34009758:	4293      	cmp	r3, r2
3400975a:	d02b      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400975c:	687b      	ldr	r3, [r7, #4]
3400975e:	4a4f      	ldr	r2, [pc, #316]	@ (3400989c <HAL_GPIO_Init+0x4cc>)
34009760:	4293      	cmp	r3, r2
34009762:	d027      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009764:	687b      	ldr	r3, [r7, #4]
34009766:	4a4e      	ldr	r2, [pc, #312]	@ (340098a0 <HAL_GPIO_Init+0x4d0>)
34009768:	4293      	cmp	r3, r2
3400976a:	d023      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400976c:	687b      	ldr	r3, [r7, #4]
3400976e:	4a4d      	ldr	r2, [pc, #308]	@ (340098a4 <HAL_GPIO_Init+0x4d4>)
34009770:	4293      	cmp	r3, r2
34009772:	d01f      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009774:	687b      	ldr	r3, [r7, #4]
34009776:	4a4c      	ldr	r2, [pc, #304]	@ (340098a8 <HAL_GPIO_Init+0x4d8>)
34009778:	4293      	cmp	r3, r2
3400977a:	d01b      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400977c:	687b      	ldr	r3, [r7, #4]
3400977e:	4a4b      	ldr	r2, [pc, #300]	@ (340098ac <HAL_GPIO_Init+0x4dc>)
34009780:	4293      	cmp	r3, r2
34009782:	d017      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009784:	687b      	ldr	r3, [r7, #4]
34009786:	4a4a      	ldr	r2, [pc, #296]	@ (340098b0 <HAL_GPIO_Init+0x4e0>)
34009788:	4293      	cmp	r3, r2
3400978a:	d013      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400978c:	687b      	ldr	r3, [r7, #4]
3400978e:	4a49      	ldr	r2, [pc, #292]	@ (340098b4 <HAL_GPIO_Init+0x4e4>)
34009790:	4293      	cmp	r3, r2
34009792:	d00f      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
34009794:	687b      	ldr	r3, [r7, #4]
34009796:	4a48      	ldr	r2, [pc, #288]	@ (340098b8 <HAL_GPIO_Init+0x4e8>)
34009798:	4293      	cmp	r3, r2
3400979a:	d00b      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
3400979c:	687b      	ldr	r3, [r7, #4]
3400979e:	4a47      	ldr	r2, [pc, #284]	@ (340098bc <HAL_GPIO_Init+0x4ec>)
340097a0:	4293      	cmp	r3, r2
340097a2:	d007      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
340097a4:	687b      	ldr	r3, [r7, #4]
340097a6:	4a46      	ldr	r2, [pc, #280]	@ (340098c0 <HAL_GPIO_Init+0x4f0>)
340097a8:	4293      	cmp	r3, r2
340097aa:	d003      	beq.n	340097b4 <HAL_GPIO_Init+0x3e4>
340097ac:	21de      	movs	r1, #222	@ 0xde
340097ae:	482c      	ldr	r0, [pc, #176]	@ (34009860 <HAL_GPIO_Init+0x490>)
340097b0:	f7f7 fd72 	bl	34001298 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
340097b4:	683b      	ldr	r3, [r7, #0]
340097b6:	691b      	ldr	r3, [r3, #16]
340097b8:	2b0f      	cmp	r3, #15
340097ba:	d903      	bls.n	340097c4 <HAL_GPIO_Init+0x3f4>
340097bc:	21df      	movs	r1, #223	@ 0xdf
340097be:	4828      	ldr	r0, [pc, #160]	@ (34009860 <HAL_GPIO_Init+0x490>)
340097c0:	f7f7 fd6a 	bl	34001298 <assert_failed>

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
340097c4:	697b      	ldr	r3, [r7, #20]
340097c6:	08da      	lsrs	r2, r3, #3
340097c8:	687b      	ldr	r3, [r7, #4]
340097ca:	3208      	adds	r2, #8
340097cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
340097d0:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340097d2:	697b      	ldr	r3, [r7, #20]
340097d4:	f003 0307 	and.w	r3, r3, #7
340097d8:	009b      	lsls	r3, r3, #2
340097da:	220f      	movs	r2, #15
340097dc:	fa02 f303 	lsl.w	r3, r2, r3
340097e0:	43db      	mvns	r3, r3
340097e2:	693a      	ldr	r2, [r7, #16]
340097e4:	4013      	ands	r3, r2
340097e6:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340097e8:	683b      	ldr	r3, [r7, #0]
340097ea:	691a      	ldr	r2, [r3, #16]
340097ec:	697b      	ldr	r3, [r7, #20]
340097ee:	f003 0307 	and.w	r3, r3, #7
340097f2:	009b      	lsls	r3, r3, #2
340097f4:	fa02 f303 	lsl.w	r3, r2, r3
340097f8:	693a      	ldr	r2, [r7, #16]
340097fa:	4313      	orrs	r3, r2
340097fc:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
340097fe:	697b      	ldr	r3, [r7, #20]
34009800:	08da      	lsrs	r2, r3, #3
34009802:	687b      	ldr	r3, [r7, #4]
34009804:	3208      	adds	r2, #8
34009806:	6939      	ldr	r1, [r7, #16]
34009808:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
3400980c:	687b      	ldr	r3, [r7, #4]
3400980e:	681b      	ldr	r3, [r3, #0]
34009810:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34009812:	697b      	ldr	r3, [r7, #20]
34009814:	005b      	lsls	r3, r3, #1
34009816:	2203      	movs	r2, #3
34009818:	fa02 f303 	lsl.w	r3, r2, r3
3400981c:	43db      	mvns	r3, r3
3400981e:	693a      	ldr	r2, [r7, #16]
34009820:	4013      	ands	r3, r2
34009822:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34009824:	683b      	ldr	r3, [r7, #0]
34009826:	685b      	ldr	r3, [r3, #4]
34009828:	f003 0203 	and.w	r2, r3, #3
3400982c:	697b      	ldr	r3, [r7, #20]
3400982e:	005b      	lsls	r3, r3, #1
34009830:	fa02 f303 	lsl.w	r3, r2, r3
34009834:	693a      	ldr	r2, [r7, #16]
34009836:	4313      	orrs	r3, r2
34009838:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
3400983a:	687b      	ldr	r3, [r7, #4]
3400983c:	693a      	ldr	r2, [r7, #16]
3400983e:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34009840:	683b      	ldr	r3, [r7, #0]
34009842:	685b      	ldr	r3, [r3, #4]
34009844:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34009848:	2b00      	cmp	r3, #0
3400984a:	f000 80f7 	beq.w	34009a3c <HAL_GPIO_Init+0x66c>
      {
        temp = EXTI->EXTICR[position >> 2u];
3400984e:	4a1d      	ldr	r2, [pc, #116]	@ (340098c4 <HAL_GPIO_Init+0x4f4>)
34009850:	697b      	ldr	r3, [r7, #20]
34009852:	089b      	lsrs	r3, r3, #2
34009854:	3318      	adds	r3, #24
34009856:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400985a:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400985c:	697b      	ldr	r3, [r7, #20]
3400985e:	e033      	b.n	340098c8 <HAL_GPIO_Init+0x4f8>
34009860:	34024154 	.word	0x34024154
34009864:	56020000 	.word	0x56020000
34009868:	46020000 	.word	0x46020000
3400986c:	56020400 	.word	0x56020400
34009870:	46020400 	.word	0x46020400
34009874:	56020800 	.word	0x56020800
34009878:	46020800 	.word	0x46020800
3400987c:	56020c00 	.word	0x56020c00
34009880:	46020c00 	.word	0x46020c00
34009884:	56021000 	.word	0x56021000
34009888:	46021000 	.word	0x46021000
3400988c:	56021400 	.word	0x56021400
34009890:	46021400 	.word	0x46021400
34009894:	56021800 	.word	0x56021800
34009898:	46021800 	.word	0x46021800
3400989c:	56021c00 	.word	0x56021c00
340098a0:	46021c00 	.word	0x46021c00
340098a4:	56023400 	.word	0x56023400
340098a8:	46023400 	.word	0x46023400
340098ac:	56023800 	.word	0x56023800
340098b0:	46023800 	.word	0x46023800
340098b4:	56023c00 	.word	0x56023c00
340098b8:	46023c00 	.word	0x46023c00
340098bc:	56024000 	.word	0x56024000
340098c0:	46024000 	.word	0x46024000
340098c4:	56025000 	.word	0x56025000
340098c8:	f003 0303 	and.w	r3, r3, #3
340098cc:	00db      	lsls	r3, r3, #3
340098ce:	220f      	movs	r2, #15
340098d0:	fa02 f303 	lsl.w	r3, r2, r3
340098d4:	43db      	mvns	r3, r3
340098d6:	693a      	ldr	r2, [r7, #16]
340098d8:	4013      	ands	r3, r2
340098da:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340098dc:	687b      	ldr	r3, [r7, #4]
340098de:	4a5f      	ldr	r2, [pc, #380]	@ (34009a5c <HAL_GPIO_Init+0x68c>)
340098e0:	4293      	cmp	r3, r2
340098e2:	d043      	beq.n	3400996c <HAL_GPIO_Init+0x59c>
340098e4:	687b      	ldr	r3, [r7, #4]
340098e6:	4a5e      	ldr	r2, [pc, #376]	@ (34009a60 <HAL_GPIO_Init+0x690>)
340098e8:	4293      	cmp	r3, r2
340098ea:	d03d      	beq.n	34009968 <HAL_GPIO_Init+0x598>
340098ec:	687b      	ldr	r3, [r7, #4]
340098ee:	4a5d      	ldr	r2, [pc, #372]	@ (34009a64 <HAL_GPIO_Init+0x694>)
340098f0:	4293      	cmp	r3, r2
340098f2:	d037      	beq.n	34009964 <HAL_GPIO_Init+0x594>
340098f4:	687b      	ldr	r3, [r7, #4]
340098f6:	4a5c      	ldr	r2, [pc, #368]	@ (34009a68 <HAL_GPIO_Init+0x698>)
340098f8:	4293      	cmp	r3, r2
340098fa:	d031      	beq.n	34009960 <HAL_GPIO_Init+0x590>
340098fc:	687b      	ldr	r3, [r7, #4]
340098fe:	4a5b      	ldr	r2, [pc, #364]	@ (34009a6c <HAL_GPIO_Init+0x69c>)
34009900:	4293      	cmp	r3, r2
34009902:	d02b      	beq.n	3400995c <HAL_GPIO_Init+0x58c>
34009904:	687b      	ldr	r3, [r7, #4]
34009906:	4a5a      	ldr	r2, [pc, #360]	@ (34009a70 <HAL_GPIO_Init+0x6a0>)
34009908:	4293      	cmp	r3, r2
3400990a:	d025      	beq.n	34009958 <HAL_GPIO_Init+0x588>
3400990c:	687b      	ldr	r3, [r7, #4]
3400990e:	4a59      	ldr	r2, [pc, #356]	@ (34009a74 <HAL_GPIO_Init+0x6a4>)
34009910:	4293      	cmp	r3, r2
34009912:	d01f      	beq.n	34009954 <HAL_GPIO_Init+0x584>
34009914:	687b      	ldr	r3, [r7, #4]
34009916:	4a58      	ldr	r2, [pc, #352]	@ (34009a78 <HAL_GPIO_Init+0x6a8>)
34009918:	4293      	cmp	r3, r2
3400991a:	d019      	beq.n	34009950 <HAL_GPIO_Init+0x580>
3400991c:	687b      	ldr	r3, [r7, #4]
3400991e:	4a57      	ldr	r2, [pc, #348]	@ (34009a7c <HAL_GPIO_Init+0x6ac>)
34009920:	4293      	cmp	r3, r2
34009922:	d013      	beq.n	3400994c <HAL_GPIO_Init+0x57c>
34009924:	687b      	ldr	r3, [r7, #4]
34009926:	4a56      	ldr	r2, [pc, #344]	@ (34009a80 <HAL_GPIO_Init+0x6b0>)
34009928:	4293      	cmp	r3, r2
3400992a:	d00d      	beq.n	34009948 <HAL_GPIO_Init+0x578>
3400992c:	687b      	ldr	r3, [r7, #4]
3400992e:	4a55      	ldr	r2, [pc, #340]	@ (34009a84 <HAL_GPIO_Init+0x6b4>)
34009930:	4293      	cmp	r3, r2
34009932:	d007      	beq.n	34009944 <HAL_GPIO_Init+0x574>
34009934:	687b      	ldr	r3, [r7, #4]
34009936:	4a54      	ldr	r2, [pc, #336]	@ (34009a88 <HAL_GPIO_Init+0x6b8>)
34009938:	4293      	cmp	r3, r2
3400993a:	d101      	bne.n	34009940 <HAL_GPIO_Init+0x570>
3400993c:	230b      	movs	r3, #11
3400993e:	e016      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009940:	2310      	movs	r3, #16
34009942:	e014      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009944:	230a      	movs	r3, #10
34009946:	e012      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009948:	2309      	movs	r3, #9
3400994a:	e010      	b.n	3400996e <HAL_GPIO_Init+0x59e>
3400994c:	2308      	movs	r3, #8
3400994e:	e00e      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009950:	2307      	movs	r3, #7
34009952:	e00c      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009954:	2306      	movs	r3, #6
34009956:	e00a      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009958:	2305      	movs	r3, #5
3400995a:	e008      	b.n	3400996e <HAL_GPIO_Init+0x59e>
3400995c:	2304      	movs	r3, #4
3400995e:	e006      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009960:	2303      	movs	r3, #3
34009962:	e004      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009964:	2302      	movs	r3, #2
34009966:	e002      	b.n	3400996e <HAL_GPIO_Init+0x59e>
34009968:	2301      	movs	r3, #1
3400996a:	e000      	b.n	3400996e <HAL_GPIO_Init+0x59e>
3400996c:	2300      	movs	r3, #0
3400996e:	697a      	ldr	r2, [r7, #20]
34009970:	f002 0203 	and.w	r2, r2, #3
34009974:	00d2      	lsls	r2, r2, #3
34009976:	4093      	lsls	r3, r2
34009978:	693a      	ldr	r2, [r7, #16]
3400997a:	4313      	orrs	r3, r2
3400997c:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
3400997e:	4943      	ldr	r1, [pc, #268]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
34009980:	697b      	ldr	r3, [r7, #20]
34009982:	089b      	lsrs	r3, r3, #2
34009984:	3318      	adds	r3, #24
34009986:	693a      	ldr	r2, [r7, #16]
34009988:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
3400998c:	4b3f      	ldr	r3, [pc, #252]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
3400998e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34009992:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34009994:	68fb      	ldr	r3, [r7, #12]
34009996:	43db      	mvns	r3, r3
34009998:	693a      	ldr	r2, [r7, #16]
3400999a:	4013      	ands	r3, r2
3400999c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
3400999e:	683b      	ldr	r3, [r7, #0]
340099a0:	685b      	ldr	r3, [r3, #4]
340099a2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340099a6:	2b00      	cmp	r3, #0
340099a8:	d003      	beq.n	340099b2 <HAL_GPIO_Init+0x5e2>
        {
          temp |= iocurrent;
340099aa:	693a      	ldr	r2, [r7, #16]
340099ac:	68fb      	ldr	r3, [r7, #12]
340099ae:	4313      	orrs	r3, r2
340099b0:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
340099b2:	4a36      	ldr	r2, [pc, #216]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
340099b4:	693b      	ldr	r3, [r7, #16]
340099b6:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
340099ba:	4b34      	ldr	r3, [pc, #208]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
340099bc:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
340099c0:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340099c2:	68fb      	ldr	r3, [r7, #12]
340099c4:	43db      	mvns	r3, r3
340099c6:	693a      	ldr	r2, [r7, #16]
340099c8:	4013      	ands	r3, r2
340099ca:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
340099cc:	683b      	ldr	r3, [r7, #0]
340099ce:	685b      	ldr	r3, [r3, #4]
340099d0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
340099d4:	2b00      	cmp	r3, #0
340099d6:	d003      	beq.n	340099e0 <HAL_GPIO_Init+0x610>
        {
          temp |= iocurrent;
340099d8:	693a      	ldr	r2, [r7, #16]
340099da:	68fb      	ldr	r3, [r7, #12]
340099dc:	4313      	orrs	r3, r2
340099de:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
340099e0:	4a2a      	ldr	r2, [pc, #168]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
340099e2:	693b      	ldr	r3, [r7, #16]
340099e4:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
340099e8:	4b28      	ldr	r3, [pc, #160]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
340099ea:	681b      	ldr	r3, [r3, #0]
340099ec:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340099ee:	68fb      	ldr	r3, [r7, #12]
340099f0:	43db      	mvns	r3, r3
340099f2:	693a      	ldr	r2, [r7, #16]
340099f4:	4013      	ands	r3, r2
340099f6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
340099f8:	683b      	ldr	r3, [r7, #0]
340099fa:	685b      	ldr	r3, [r3, #4]
340099fc:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34009a00:	2b00      	cmp	r3, #0
34009a02:	d003      	beq.n	34009a0c <HAL_GPIO_Init+0x63c>
        {
          temp |= iocurrent;
34009a04:	693a      	ldr	r2, [r7, #16]
34009a06:	68fb      	ldr	r3, [r7, #12]
34009a08:	4313      	orrs	r3, r2
34009a0a:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34009a0c:	4a1f      	ldr	r2, [pc, #124]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
34009a0e:	693b      	ldr	r3, [r7, #16]
34009a10:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
34009a12:	4b1e      	ldr	r3, [pc, #120]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
34009a14:	685b      	ldr	r3, [r3, #4]
34009a16:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34009a18:	68fb      	ldr	r3, [r7, #12]
34009a1a:	43db      	mvns	r3, r3
34009a1c:	693a      	ldr	r2, [r7, #16]
34009a1e:	4013      	ands	r3, r2
34009a20:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34009a22:	683b      	ldr	r3, [r7, #0]
34009a24:	685b      	ldr	r3, [r3, #4]
34009a26:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34009a2a:	2b00      	cmp	r3, #0
34009a2c:	d003      	beq.n	34009a36 <HAL_GPIO_Init+0x666>
        {
          temp |= iocurrent;
34009a2e:	693a      	ldr	r2, [r7, #16]
34009a30:	68fb      	ldr	r3, [r7, #12]
34009a32:	4313      	orrs	r3, r2
34009a34:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34009a36:	4a15      	ldr	r2, [pc, #84]	@ (34009a8c <HAL_GPIO_Init+0x6bc>)
34009a38:	693b      	ldr	r3, [r7, #16]
34009a3a:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34009a3c:	697b      	ldr	r3, [r7, #20]
34009a3e:	3301      	adds	r3, #1
34009a40:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34009a42:	683b      	ldr	r3, [r7, #0]
34009a44:	681a      	ldr	r2, [r3, #0]
34009a46:	697b      	ldr	r3, [r7, #20]
34009a48:	fa22 f303 	lsr.w	r3, r2, r3
34009a4c:	2b00      	cmp	r3, #0
34009a4e:	f47f adb1 	bne.w	340095b4 <HAL_GPIO_Init+0x1e4>
  }
}
34009a52:	bf00      	nop
34009a54:	bf00      	nop
34009a56:	3718      	adds	r7, #24
34009a58:	46bd      	mov	sp, r7
34009a5a:	bd80      	pop	{r7, pc}
34009a5c:	56020000 	.word	0x56020000
34009a60:	56020400 	.word	0x56020400
34009a64:	56020800 	.word	0x56020800
34009a68:	56020c00 	.word	0x56020c00
34009a6c:	56021000 	.word	0x56021000
34009a70:	56021400 	.word	0x56021400
34009a74:	56021800 	.word	0x56021800
34009a78:	56021c00 	.word	0x56021c00
34009a7c:	56023400 	.word	0x56023400
34009a80:	56023800 	.word	0x56023800
34009a84:	56023c00 	.word	0x56023c00
34009a88:	56024000 	.word	0x56024000
34009a8c:	56025000 	.word	0x56025000

34009a90 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34009a90:	b580      	push	{r7, lr}
34009a92:	b082      	sub	sp, #8
34009a94:	af00      	add	r7, sp, #0
34009a96:	6078      	str	r0, [r7, #4]
34009a98:	460b      	mov	r3, r1
34009a9a:	807b      	strh	r3, [r7, #2]
34009a9c:	4613      	mov	r3, r2
34009a9e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
34009aa0:	887b      	ldrh	r3, [r7, #2]
34009aa2:	2b00      	cmp	r3, #0
34009aa4:	d104      	bne.n	34009ab0 <HAL_GPIO_WritePin+0x20>
34009aa6:	f44f 71d0 	mov.w	r1, #416	@ 0x1a0
34009aaa:	480e      	ldr	r0, [pc, #56]	@ (34009ae4 <HAL_GPIO_WritePin+0x54>)
34009aac:	f7f7 fbf4 	bl	34001298 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
34009ab0:	787b      	ldrb	r3, [r7, #1]
34009ab2:	2b00      	cmp	r3, #0
34009ab4:	d007      	beq.n	34009ac6 <HAL_GPIO_WritePin+0x36>
34009ab6:	787b      	ldrb	r3, [r7, #1]
34009ab8:	2b01      	cmp	r3, #1
34009aba:	d004      	beq.n	34009ac6 <HAL_GPIO_WritePin+0x36>
34009abc:	f240 11a1 	movw	r1, #417	@ 0x1a1
34009ac0:	4808      	ldr	r0, [pc, #32]	@ (34009ae4 <HAL_GPIO_WritePin+0x54>)
34009ac2:	f7f7 fbe9 	bl	34001298 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
34009ac6:	787b      	ldrb	r3, [r7, #1]
34009ac8:	2b00      	cmp	r3, #0
34009aca:	d003      	beq.n	34009ad4 <HAL_GPIO_WritePin+0x44>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34009acc:	887a      	ldrh	r2, [r7, #2]
34009ace:	687b      	ldr	r3, [r7, #4]
34009ad0:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34009ad2:	e002      	b.n	34009ada <HAL_GPIO_WritePin+0x4a>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34009ad4:	887a      	ldrh	r2, [r7, #2]
34009ad6:	687b      	ldr	r3, [r7, #4]
34009ad8:	629a      	str	r2, [r3, #40]	@ 0x28
}
34009ada:	bf00      	nop
34009adc:	3708      	adds	r7, #8
34009ade:	46bd      	mov	sp, r7
34009ae0:	bd80      	pop	{r7, pc}
34009ae2:	bf00      	nop
34009ae4:	34024154 	.word	0x34024154

34009ae8 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
34009ae8:	b580      	push	{r7, lr}
34009aea:	b084      	sub	sp, #16
34009aec:	af00      	add	r7, sp, #0
34009aee:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
34009af0:	687b      	ldr	r3, [r7, #4]
34009af2:	2b00      	cmp	r3, #0
34009af4:	d101      	bne.n	34009afa <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
34009af6:	2301      	movs	r3, #1
34009af8:	e12c      	b.n	34009d54 <HAL_LTDC_Init+0x26c>
  }

  /* Check function parameters */
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
34009afa:	687b      	ldr	r3, [r7, #4]
34009afc:	681b      	ldr	r3, [r3, #0]
34009afe:	4a97      	ldr	r2, [pc, #604]	@ (34009d5c <HAL_LTDC_Init+0x274>)
34009b00:	4293      	cmp	r3, r2
34009b02:	d008      	beq.n	34009b16 <HAL_LTDC_Init+0x2e>
34009b04:	687b      	ldr	r3, [r7, #4]
34009b06:	681b      	ldr	r3, [r3, #0]
34009b08:	4a95      	ldr	r2, [pc, #596]	@ (34009d60 <HAL_LTDC_Init+0x278>)
34009b0a:	4293      	cmp	r3, r2
34009b0c:	d003      	beq.n	34009b16 <HAL_LTDC_Init+0x2e>
34009b0e:	21f8      	movs	r1, #248	@ 0xf8
34009b10:	4894      	ldr	r0, [pc, #592]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b12:	f7f7 fbc1 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
34009b16:	687b      	ldr	r3, [r7, #4]
34009b18:	695b      	ldr	r3, [r3, #20]
34009b1a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b1e:	d303      	bcc.n	34009b28 <HAL_LTDC_Init+0x40>
34009b20:	21f9      	movs	r1, #249	@ 0xf9
34009b22:	4890      	ldr	r0, [pc, #576]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b24:	f7f7 fbb8 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
34009b28:	687b      	ldr	r3, [r7, #4]
34009b2a:	699b      	ldr	r3, [r3, #24]
34009b2c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b30:	d303      	bcc.n	34009b3a <HAL_LTDC_Init+0x52>
34009b32:	21fa      	movs	r1, #250	@ 0xfa
34009b34:	488b      	ldr	r0, [pc, #556]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b36:	f7f7 fbaf 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
34009b3a:	687b      	ldr	r3, [r7, #4]
34009b3c:	69db      	ldr	r3, [r3, #28]
34009b3e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b42:	d303      	bcc.n	34009b4c <HAL_LTDC_Init+0x64>
34009b44:	21fb      	movs	r1, #251	@ 0xfb
34009b46:	4887      	ldr	r0, [pc, #540]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b48:	f7f7 fba6 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
34009b4c:	687b      	ldr	r3, [r7, #4]
34009b4e:	6a1b      	ldr	r3, [r3, #32]
34009b50:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b54:	d303      	bcc.n	34009b5e <HAL_LTDC_Init+0x76>
34009b56:	21fc      	movs	r1, #252	@ 0xfc
34009b58:	4882      	ldr	r0, [pc, #520]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b5a:	f7f7 fb9d 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
34009b5e:	687b      	ldr	r3, [r7, #4]
34009b60:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34009b62:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b66:	d303      	bcc.n	34009b70 <HAL_LTDC_Init+0x88>
34009b68:	21fd      	movs	r1, #253	@ 0xfd
34009b6a:	487e      	ldr	r0, [pc, #504]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b6c:	f7f7 fb94 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
34009b70:	687b      	ldr	r3, [r7, #4]
34009b72:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34009b74:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b78:	d303      	bcc.n	34009b82 <HAL_LTDC_Init+0x9a>
34009b7a:	21fe      	movs	r1, #254	@ 0xfe
34009b7c:	4879      	ldr	r0, [pc, #484]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b7e:	f7f7 fb8b 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
34009b82:	687b      	ldr	r3, [r7, #4]
34009b84:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34009b86:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b8a:	d303      	bcc.n	34009b94 <HAL_LTDC_Init+0xac>
34009b8c:	21ff      	movs	r1, #255	@ 0xff
34009b8e:	4875      	ldr	r0, [pc, #468]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009b90:	f7f7 fb82 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
34009b94:	687b      	ldr	r3, [r7, #4]
34009b96:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34009b98:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009b9c:	d304      	bcc.n	34009ba8 <HAL_LTDC_Init+0xc0>
34009b9e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34009ba2:	4870      	ldr	r0, [pc, #448]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009ba4:	f7f7 fb78 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
34009ba8:	687b      	ldr	r3, [r7, #4]
34009baa:	685b      	ldr	r3, [r3, #4]
34009bac:	2b00      	cmp	r3, #0
34009bae:	d009      	beq.n	34009bc4 <HAL_LTDC_Init+0xdc>
34009bb0:	687b      	ldr	r3, [r7, #4]
34009bb2:	685b      	ldr	r3, [r3, #4]
34009bb4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34009bb8:	d004      	beq.n	34009bc4 <HAL_LTDC_Init+0xdc>
34009bba:	f240 1101 	movw	r1, #257	@ 0x101
34009bbe:	4869      	ldr	r0, [pc, #420]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009bc0:	f7f7 fb6a 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
34009bc4:	687b      	ldr	r3, [r7, #4]
34009bc6:	689b      	ldr	r3, [r3, #8]
34009bc8:	2b00      	cmp	r3, #0
34009bca:	d009      	beq.n	34009be0 <HAL_LTDC_Init+0xf8>
34009bcc:	687b      	ldr	r3, [r7, #4]
34009bce:	689b      	ldr	r3, [r3, #8]
34009bd0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34009bd4:	d004      	beq.n	34009be0 <HAL_LTDC_Init+0xf8>
34009bd6:	f44f 7181 	mov.w	r1, #258	@ 0x102
34009bda:	4862      	ldr	r0, [pc, #392]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009bdc:	f7f7 fb5c 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
34009be0:	687b      	ldr	r3, [r7, #4]
34009be2:	68db      	ldr	r3, [r3, #12]
34009be4:	2b00      	cmp	r3, #0
34009be6:	d009      	beq.n	34009bfc <HAL_LTDC_Init+0x114>
34009be8:	687b      	ldr	r3, [r7, #4]
34009bea:	68db      	ldr	r3, [r3, #12]
34009bec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009bf0:	d004      	beq.n	34009bfc <HAL_LTDC_Init+0x114>
34009bf2:	f240 1103 	movw	r1, #259	@ 0x103
34009bf6:	485b      	ldr	r0, [pc, #364]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009bf8:	f7f7 fb4e 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
34009bfc:	687b      	ldr	r3, [r7, #4]
34009bfe:	691b      	ldr	r3, [r3, #16]
34009c00:	2b00      	cmp	r3, #0
34009c02:	d009      	beq.n	34009c18 <HAL_LTDC_Init+0x130>
34009c04:	687b      	ldr	r3, [r7, #4]
34009c06:	691b      	ldr	r3, [r3, #16]
34009c08:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009c0c:	d004      	beq.n	34009c18 <HAL_LTDC_Init+0x130>
34009c0e:	f44f 7182 	mov.w	r1, #260	@ 0x104
34009c12:	4854      	ldr	r0, [pc, #336]	@ (34009d64 <HAL_LTDC_Init+0x27c>)
34009c14:	f7f7 fb40 	bl	34001298 <assert_failed>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34009c18:	687b      	ldr	r3, [r7, #4]
34009c1a:	f893 30a1 	ldrb.w	r3, [r3, #161]	@ 0xa1
34009c1e:	b2db      	uxtb	r3, r3
34009c20:	2b00      	cmp	r3, #0
34009c22:	d106      	bne.n	34009c32 <HAL_LTDC_Init+0x14a>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
34009c24:	687b      	ldr	r3, [r7, #4]
34009c26:	2200      	movs	r2, #0
34009c28:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
34009c2c:	6878      	ldr	r0, [r7, #4]
34009c2e:	f000 f89b 	bl	34009d68 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34009c32:	687b      	ldr	r3, [r7, #4]
34009c34:	2202      	movs	r2, #2
34009c36:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34009c3a:	687b      	ldr	r3, [r7, #4]
34009c3c:	681b      	ldr	r3, [r3, #0]
34009c3e:	699a      	ldr	r2, [r3, #24]
34009c40:	687b      	ldr	r3, [r7, #4]
34009c42:	681b      	ldr	r3, [r3, #0]
34009c44:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34009c48:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34009c4a:	687b      	ldr	r3, [r7, #4]
34009c4c:	681b      	ldr	r3, [r3, #0]
34009c4e:	6999      	ldr	r1, [r3, #24]
34009c50:	687b      	ldr	r3, [r7, #4]
34009c52:	685a      	ldr	r2, [r3, #4]
34009c54:	687b      	ldr	r3, [r7, #4]
34009c56:	689b      	ldr	r3, [r3, #8]
34009c58:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34009c5a:	687b      	ldr	r3, [r7, #4]
34009c5c:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34009c5e:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34009c60:	687b      	ldr	r3, [r7, #4]
34009c62:	691b      	ldr	r3, [r3, #16]
34009c64:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34009c66:	687b      	ldr	r3, [r7, #4]
34009c68:	681b      	ldr	r3, [r3, #0]
34009c6a:	430a      	orrs	r2, r1
34009c6c:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  tmp = (hltdc->Init.HorizontalSync << 16U);
34009c6e:	687b      	ldr	r3, [r7, #4]
34009c70:	695b      	ldr	r3, [r3, #20]
34009c72:	041b      	lsls	r3, r3, #16
34009c74:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34009c76:	687b      	ldr	r3, [r7, #4]
34009c78:	6999      	ldr	r1, [r3, #24]
34009c7a:	687b      	ldr	r3, [r7, #4]
34009c7c:	681b      	ldr	r3, [r3, #0]
34009c7e:	68fa      	ldr	r2, [r7, #12]
34009c80:	430a      	orrs	r2, r1
34009c82:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
34009c84:	687b      	ldr	r3, [r7, #4]
34009c86:	69db      	ldr	r3, [r3, #28]
34009c88:	041b      	lsls	r3, r3, #16
34009c8a:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34009c8c:	687b      	ldr	r3, [r7, #4]
34009c8e:	6a19      	ldr	r1, [r3, #32]
34009c90:	687b      	ldr	r3, [r7, #4]
34009c92:	681b      	ldr	r3, [r3, #0]
34009c94:	68fa      	ldr	r2, [r7, #12]
34009c96:	430a      	orrs	r2, r1
34009c98:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
34009c9a:	687b      	ldr	r3, [r7, #4]
34009c9c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34009c9e:	041b      	lsls	r3, r3, #16
34009ca0:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34009ca2:	687b      	ldr	r3, [r7, #4]
34009ca4:	6a99      	ldr	r1, [r3, #40]	@ 0x28
34009ca6:	687b      	ldr	r3, [r7, #4]
34009ca8:	681b      	ldr	r3, [r3, #0]
34009caa:	68fa      	ldr	r2, [r7, #12]
34009cac:	430a      	orrs	r2, r1
34009cae:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  tmp = (hltdc->Init.TotalWidth << 16U);
34009cb0:	687b      	ldr	r3, [r7, #4]
34009cb2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34009cb4:	041b      	lsls	r3, r3, #16
34009cb6:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34009cb8:	687b      	ldr	r3, [r7, #4]
34009cba:	6b19      	ldr	r1, [r3, #48]	@ 0x30
34009cbc:	687b      	ldr	r3, [r7, #4]
34009cbe:	681b      	ldr	r3, [r3, #0]
34009cc0:	68fa      	ldr	r2, [r7, #12]
34009cc2:	430a      	orrs	r2, r1
34009cc4:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34009cc6:	687b      	ldr	r3, [r7, #4]
34009cc8:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
34009ccc:	021b      	lsls	r3, r3, #8
34009cce:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34009cd0:	687b      	ldr	r3, [r7, #4]
34009cd2:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34009cd6:	041b      	lsls	r3, r3, #16
34009cd8:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34009cda:	687b      	ldr	r3, [r7, #4]
34009cdc:	681b      	ldr	r3, [r3, #0]
34009cde:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34009ce0:	687b      	ldr	r3, [r7, #4]
34009ce2:	681b      	ldr	r3, [r3, #0]
34009ce4:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
34009ce8:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34009cea:	687b      	ldr	r3, [r7, #4]
34009cec:	681b      	ldr	r3, [r3, #0]
34009cee:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34009cf0:	68ba      	ldr	r2, [r7, #8]
34009cf2:	68fb      	ldr	r3, [r7, #12]
34009cf4:	4313      	orrs	r3, r2
34009cf6:	687a      	ldr	r2, [r7, #4]
34009cf8:	f892 2034 	ldrb.w	r2, [r2, #52]	@ 0x34
34009cfc:	431a      	orrs	r2, r3
34009cfe:	687b      	ldr	r3, [r7, #4]
34009d00:	681b      	ldr	r3, [r3, #0]
34009d02:	430a      	orrs	r2, r1
34009d04:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Activate Global Reload for Layer 1 and Layer 2 */
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34009d06:	687b      	ldr	r3, [r7, #4]
34009d08:	681b      	ldr	r3, [r3, #0]
34009d0a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34009d0e:	461a      	mov	r2, r3
34009d10:	2304      	movs	r3, #4
34009d12:	6093      	str	r3, [r2, #8]
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34009d14:	687b      	ldr	r3, [r7, #4]
34009d16:	681b      	ldr	r3, [r3, #0]
34009d18:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34009d1c:	461a      	mov	r2, r3
34009d1e:	2304      	movs	r3, #4
34009d20:	6093      	str	r3, [r2, #8]

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34009d22:	687b      	ldr	r3, [r7, #4]
34009d24:	681b      	ldr	r3, [r3, #0]
34009d26:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34009d28:	687b      	ldr	r3, [r7, #4]
34009d2a:	681b      	ldr	r3, [r3, #0]
34009d2c:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34009d30:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
34009d32:	687b      	ldr	r3, [r7, #4]
34009d34:	681b      	ldr	r3, [r3, #0]
34009d36:	699a      	ldr	r2, [r3, #24]
34009d38:	687b      	ldr	r3, [r7, #4]
34009d3a:	681b      	ldr	r3, [r3, #0]
34009d3c:	f042 0201 	orr.w	r2, r2, #1
34009d40:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34009d42:	687b      	ldr	r3, [r7, #4]
34009d44:	2200      	movs	r2, #0
34009d46:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
34009d4a:	687b      	ldr	r3, [r7, #4]
34009d4c:	2201      	movs	r2, #1
34009d4e:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  return HAL_OK;
34009d52:	2300      	movs	r3, #0
}
34009d54:	4618      	mov	r0, r3
34009d56:	3710      	adds	r7, #16
34009d58:	46bd      	mov	sp, r7
34009d5a:	bd80      	pop	{r7, pc}
34009d5c:	58001000 	.word	0x58001000
34009d60:	48001000 	.word	0x48001000
34009d64:	340241c4 	.word	0x340241c4

34009d68 <HAL_LTDC_MspInit>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
34009d68:	b480      	push	{r7}
34009d6a:	b083      	sub	sp, #12
34009d6c:	af00      	add	r7, sp, #0
34009d6e:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspInit could be implemented in the user file
   */
}
34009d70:	bf00      	nop
34009d72:	370c      	adds	r7, #12
34009d74:	46bd      	mov	sp, r7
34009d76:	f85d 7b04 	ldr.w	r7, [sp], #4
34009d7a:	4770      	bx	lr

34009d7c <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
34009d7c:	b5b0      	push	{r4, r5, r7, lr}
34009d7e:	b086      	sub	sp, #24
34009d80:	af02      	add	r7, sp, #8
34009d82:	60f8      	str	r0, [r7, #12]
34009d84:	60b9      	str	r1, [r7, #8]
34009d86:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));
34009d88:	687b      	ldr	r3, [r7, #4]
34009d8a:	2b01      	cmp	r3, #1
34009d8c:	d904      	bls.n	34009d98 <HAL_LTDC_ConfigLayer+0x1c>
34009d8e:	f240 4104 	movw	r1, #1028	@ 0x404
34009d92:	4880      	ldr	r0, [pc, #512]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009d94:	f7f7 fa80 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
34009d98:	68bb      	ldr	r3, [r7, #8]
34009d9a:	681b      	ldr	r3, [r3, #0]
34009d9c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009da0:	d304      	bcc.n	34009dac <HAL_LTDC_ConfigLayer+0x30>
34009da2:	f240 4105 	movw	r1, #1029	@ 0x405
34009da6:	487b      	ldr	r0, [pc, #492]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009da8:	f7f7 fa76 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
34009dac:	68bb      	ldr	r3, [r7, #8]
34009dae:	685b      	ldr	r3, [r3, #4]
34009db0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009db4:	d304      	bcc.n	34009dc0 <HAL_LTDC_ConfigLayer+0x44>
34009db6:	f240 4106 	movw	r1, #1030	@ 0x406
34009dba:	4876      	ldr	r0, [pc, #472]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009dbc:	f7f7 fa6c 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
34009dc0:	68bb      	ldr	r3, [r7, #8]
34009dc2:	689b      	ldr	r3, [r3, #8]
34009dc4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009dc8:	d304      	bcc.n	34009dd4 <HAL_LTDC_ConfigLayer+0x58>
34009dca:	f240 4107 	movw	r1, #1031	@ 0x407
34009dce:	4871      	ldr	r0, [pc, #452]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009dd0:	f7f7 fa62 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
34009dd4:	68bb      	ldr	r3, [r7, #8]
34009dd6:	68db      	ldr	r3, [r3, #12]
34009dd8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009ddc:	d304      	bcc.n	34009de8 <HAL_LTDC_ConfigLayer+0x6c>
34009dde:	f44f 6181 	mov.w	r1, #1032	@ 0x408
34009de2:	486c      	ldr	r0, [pc, #432]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009de4:	f7f7 fa58 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
34009de8:	68bb      	ldr	r3, [r7, #8]
34009dea:	691b      	ldr	r3, [r3, #16]
34009dec:	2b00      	cmp	r3, #0
34009dee:	d030      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009df0:	68bb      	ldr	r3, [r7, #8]
34009df2:	691b      	ldr	r3, [r3, #16]
34009df4:	2b01      	cmp	r3, #1
34009df6:	d02c      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009df8:	68bb      	ldr	r3, [r7, #8]
34009dfa:	691b      	ldr	r3, [r3, #16]
34009dfc:	2b02      	cmp	r3, #2
34009dfe:	d028      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e00:	68bb      	ldr	r3, [r7, #8]
34009e02:	691b      	ldr	r3, [r3, #16]
34009e04:	2b03      	cmp	r3, #3
34009e06:	d024      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e08:	68bb      	ldr	r3, [r7, #8]
34009e0a:	691b      	ldr	r3, [r3, #16]
34009e0c:	2b04      	cmp	r3, #4
34009e0e:	d020      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e10:	68bb      	ldr	r3, [r7, #8]
34009e12:	691b      	ldr	r3, [r3, #16]
34009e14:	2b05      	cmp	r3, #5
34009e16:	d01c      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e18:	68bb      	ldr	r3, [r7, #8]
34009e1a:	691b      	ldr	r3, [r3, #16]
34009e1c:	2b06      	cmp	r3, #6
34009e1e:	d018      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e20:	68bb      	ldr	r3, [r7, #8]
34009e22:	691b      	ldr	r3, [r3, #16]
34009e24:	2b07      	cmp	r3, #7
34009e26:	d014      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e28:	68bb      	ldr	r3, [r7, #8]
34009e2a:	691b      	ldr	r3, [r3, #16]
34009e2c:	2b08      	cmp	r3, #8
34009e2e:	d010      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e30:	68bb      	ldr	r3, [r7, #8]
34009e32:	691b      	ldr	r3, [r3, #16]
34009e34:	2b09      	cmp	r3, #9
34009e36:	d00c      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e38:	68bb      	ldr	r3, [r7, #8]
34009e3a:	691b      	ldr	r3, [r3, #16]
34009e3c:	2b0a      	cmp	r3, #10
34009e3e:	d008      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e40:	68bb      	ldr	r3, [r7, #8]
34009e42:	691b      	ldr	r3, [r3, #16]
34009e44:	2b0b      	cmp	r3, #11
34009e46:	d004      	beq.n	34009e52 <HAL_LTDC_ConfigLayer+0xd6>
34009e48:	f240 4109 	movw	r1, #1033	@ 0x409
34009e4c:	4851      	ldr	r0, [pc, #324]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009e4e:	f7f7 fa23 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha));
34009e52:	68bb      	ldr	r3, [r7, #8]
34009e54:	695b      	ldr	r3, [r3, #20]
34009e56:	2bff      	cmp	r3, #255	@ 0xff
34009e58:	d904      	bls.n	34009e64 <HAL_LTDC_ConfigLayer+0xe8>
34009e5a:	f240 410a 	movw	r1, #1034	@ 0x40a
34009e5e:	484d      	ldr	r0, [pc, #308]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009e60:	f7f7 fa1a 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
34009e64:	68bb      	ldr	r3, [r7, #8]
34009e66:	699b      	ldr	r3, [r3, #24]
34009e68:	2bff      	cmp	r3, #255	@ 0xff
34009e6a:	d904      	bls.n	34009e76 <HAL_LTDC_ConfigLayer+0xfa>
34009e6c:	f240 410b 	movw	r1, #1035	@ 0x40b
34009e70:	4848      	ldr	r0, [pc, #288]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009e72:	f7f7 fa11 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
34009e76:	68bb      	ldr	r3, [r7, #8]
34009e78:	69db      	ldr	r3, [r3, #28]
34009e7a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34009e7e:	d009      	beq.n	34009e94 <HAL_LTDC_ConfigLayer+0x118>
34009e80:	68bb      	ldr	r3, [r7, #8]
34009e82:	69db      	ldr	r3, [r3, #28]
34009e84:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34009e88:	d004      	beq.n	34009e94 <HAL_LTDC_ConfigLayer+0x118>
34009e8a:	f240 410c 	movw	r1, #1036	@ 0x40c
34009e8e:	4841      	ldr	r0, [pc, #260]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009e90:	f7f7 fa02 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
34009e94:	68bb      	ldr	r3, [r7, #8]
34009e96:	6a1b      	ldr	r3, [r3, #32]
34009e98:	2b05      	cmp	r3, #5
34009e9a:	d008      	beq.n	34009eae <HAL_LTDC_ConfigLayer+0x132>
34009e9c:	68bb      	ldr	r3, [r7, #8]
34009e9e:	6a1b      	ldr	r3, [r3, #32]
34009ea0:	2b07      	cmp	r3, #7
34009ea2:	d004      	beq.n	34009eae <HAL_LTDC_ConfigLayer+0x132>
34009ea4:	f240 410d 	movw	r1, #1037	@ 0x40d
34009ea8:	483a      	ldr	r0, [pc, #232]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009eaa:	f7f7 f9f5 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
34009eae:	68bb      	ldr	r3, [r7, #8]
34009eb0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34009eb2:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34009eb6:	d304      	bcc.n	34009ec2 <HAL_LTDC_ConfigLayer+0x146>
34009eb8:	f240 410e 	movw	r1, #1038	@ 0x40e
34009ebc:	4835      	ldr	r0, [pc, #212]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009ebe:	f7f7 f9eb 	bl	34001298 <assert_failed>
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
34009ec2:	68bb      	ldr	r3, [r7, #8]
34009ec4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34009ec6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34009eca:	d304      	bcc.n	34009ed6 <HAL_LTDC_ConfigLayer+0x15a>
34009ecc:	f240 410f 	movw	r1, #1039	@ 0x40f
34009ed0:	4830      	ldr	r0, [pc, #192]	@ (34009f94 <HAL_LTDC_ConfigLayer+0x218>)
34009ed2:	f7f7 f9e1 	bl	34001298 <assert_failed>

  /* Process locked */
  __HAL_LOCK(hltdc);
34009ed6:	68fb      	ldr	r3, [r7, #12]
34009ed8:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
34009edc:	2b01      	cmp	r3, #1
34009ede:	d101      	bne.n	34009ee4 <HAL_LTDC_ConfigLayer+0x168>
34009ee0:	2302      	movs	r3, #2
34009ee2:	e052      	b.n	34009f8a <HAL_LTDC_ConfigLayer+0x20e>
34009ee4:	68fb      	ldr	r3, [r7, #12]
34009ee6:	2201      	movs	r2, #1
34009ee8:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34009eec:	68fb      	ldr	r3, [r7, #12]
34009eee:	2202      	movs	r2, #2
34009ef0:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34009ef4:	68fa      	ldr	r2, [r7, #12]
34009ef6:	687b      	ldr	r3, [r7, #4]
34009ef8:	2134      	movs	r1, #52	@ 0x34
34009efa:	fb01 f303 	mul.w	r3, r1, r3
34009efe:	4413      	add	r3, r2
34009f00:	f103 0238 	add.w	r2, r3, #56	@ 0x38
34009f04:	68bb      	ldr	r3, [r7, #8]
34009f06:	4614      	mov	r4, r2
34009f08:	461d      	mov	r5, r3
34009f0a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34009f0c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34009f0e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34009f10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34009f12:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34009f14:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34009f16:	682b      	ldr	r3, [r5, #0]
34009f18:	6023      	str	r3, [r4, #0]

  /* Configure Predefined format */
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34009f1a:	6879      	ldr	r1, [r7, #4]
34009f1c:	68f8      	ldr	r0, [r7, #12]
34009f1e:	f000 ff6f 	bl	3400ae00 <LTDC_SetPredefFormat>

  /* Configure composition and blending*/
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34009f22:	6879      	ldr	r1, [r7, #4]
34009f24:	68f8      	ldr	r0, [r7, #12]
34009f26:	f000 fec3 	bl	3400acb0 <LTDC_SetCompositionConfig>

  /* Disable YUV format */
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34009f2a:	68fb      	ldr	r3, [r7, #12]
34009f2c:	681b      	ldr	r3, [r3, #0]
34009f2e:	461a      	mov	r2, r3
34009f30:	687b      	ldr	r3, [r7, #4]
34009f32:	021b      	lsls	r3, r3, #8
34009f34:	4413      	add	r3, r2
34009f36:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34009f3a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34009f3c:	68fa      	ldr	r2, [r7, #12]
34009f3e:	6812      	ldr	r2, [r2, #0]
34009f40:	4611      	mov	r1, r2
34009f42:	687a      	ldr	r2, [r7, #4]
34009f44:	0212      	lsls	r2, r2, #8
34009f46:	440a      	add	r2, r1
34009f48:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34009f4c:	f023 0308 	bic.w	r3, r3, #8
34009f50:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34009f52:	687b      	ldr	r3, [r7, #4]
34009f54:	9300      	str	r3, [sp, #0]
34009f56:	2303      	movs	r3, #3
34009f58:	2200      	movs	r2, #0
34009f5a:	2100      	movs	r1, #0
34009f5c:	68f8      	ldr	r0, [r7, #12]
34009f5e:	f000 f81b 	bl	34009f98 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34009f62:	68fb      	ldr	r3, [r7, #12]
34009f64:	681b      	ldr	r3, [r3, #0]
34009f66:	461a      	mov	r2, r3
34009f68:	687b      	ldr	r3, [r7, #4]
34009f6a:	021b      	lsls	r3, r3, #8
34009f6c:	4413      	add	r3, r2
34009f6e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34009f72:	461a      	mov	r2, r3
34009f74:	2305      	movs	r3, #5
34009f76:	6093      	str	r3, [r2, #8]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
34009f78:	68fb      	ldr	r3, [r7, #12]
34009f7a:	2201      	movs	r2, #1
34009f7c:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
34009f80:	68fb      	ldr	r3, [r7, #12]
34009f82:	2200      	movs	r2, #0
34009f84:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
34009f88:	2300      	movs	r3, #0
}
34009f8a:	4618      	mov	r0, r3
34009f8c:	3710      	adds	r7, #16
34009f8e:	46bd      	mov	sp, r7
34009f90:	bdb0      	pop	{r4, r5, r7, pc}
34009f92:	bf00      	nop
34009f94:	340241c4 	.word	0x340241c4

34009f98 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
34009f98:	b4b0      	push	{r4, r5, r7}
34009f9a:	b087      	sub	sp, #28
34009f9c:	af00      	add	r7, sp, #0
34009f9e:	60f8      	str	r0, [r7, #12]
34009fa0:	60b9      	str	r1, [r7, #8]
34009fa2:	607a      	str	r2, [r7, #4]
34009fa4:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34009fa6:	68fb      	ldr	r3, [r7, #12]
34009fa8:	681b      	ldr	r3, [r3, #0]
34009faa:	461a      	mov	r2, r3
34009fac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34009fae:	021b      	lsls	r3, r3, #8
34009fb0:	4413      	add	r3, r2
34009fb2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34009fb6:	4618      	mov	r0, r3
34009fb8:	68fa      	ldr	r2, [r7, #12]
34009fba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34009fbc:	2134      	movs	r1, #52	@ 0x34
34009fbe:	fb01 f303 	mul.w	r3, r1, r3
34009fc2:	4413      	add	r3, r2
34009fc4:	3364      	adds	r3, #100	@ 0x64
34009fc6:	681b      	ldr	r3, [r3, #0]
34009fc8:	63c3      	str	r3, [r0, #60]	@ 0x3c

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34009fca:	68fa      	ldr	r2, [r7, #12]
34009fcc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34009fce:	2134      	movs	r1, #52	@ 0x34
34009fd0:	fb01 f303 	mul.w	r3, r1, r3
34009fd4:	4413      	add	r3, r2
34009fd6:	3348      	adds	r3, #72	@ 0x48
34009fd8:	681b      	ldr	r3, [r3, #0]
34009fda:	2b03      	cmp	r3, #3
34009fdc:	d821      	bhi.n	3400a022 <LTDC_SetConfig+0x8a>
34009fde:	e025      	b.n	3400a02c <LTDC_SetConfig+0x94>
34009fe0:	3b04      	subs	r3, #4
34009fe2:	2201      	movs	r2, #1
34009fe4:	fa02 f303 	lsl.w	r3, r2, r3
34009fe8:	f240 229b 	movw	r2, #667	@ 0x29b
34009fec:	401a      	ands	r2, r3
34009fee:	2a00      	cmp	r2, #0
34009ff0:	bf14      	ite	ne
34009ff2:	2201      	movne	r2, #1
34009ff4:	2200      	moveq	r2, #0
34009ff6:	b2d2      	uxtb	r2, r2
34009ff8:	2a00      	cmp	r2, #0
34009ffa:	d11d      	bne.n	3400a038 <LTDC_SetConfig+0xa0>
34009ffc:	f403 7280 	and.w	r2, r3, #256	@ 0x100
3400a000:	2a00      	cmp	r2, #0
3400a002:	bf14      	ite	ne
3400a004:	2201      	movne	r2, #1
3400a006:	2200      	moveq	r2, #0
3400a008:	b2d2      	uxtb	r2, r2
3400a00a:	2a00      	cmp	r2, #0
3400a00c:	d117      	bne.n	3400a03e <LTDC_SetConfig+0xa6>
3400a00e:	f003 0304 	and.w	r3, r3, #4
3400a012:	2b00      	cmp	r3, #0
3400a014:	bf14      	ite	ne
3400a016:	2301      	movne	r3, #1
3400a018:	2300      	moveq	r3, #0
3400a01a:	b2db      	uxtb	r3, r3
3400a01c:	2b00      	cmp	r3, #0
3400a01e:	d108      	bne.n	3400a032 <LTDC_SetConfig+0x9a>
3400a020:	e01b      	b.n	3400a05a <LTDC_SetConfig+0xc2>
3400a022:	2b0d      	cmp	r3, #13
3400a024:	d819      	bhi.n	3400a05a <LTDC_SetConfig+0xc2>
3400a026:	2b04      	cmp	r3, #4
3400a028:	d2da      	bcs.n	34009fe0 <LTDC_SetConfig+0x48>
3400a02a:	e016      	b.n	3400a05a <LTDC_SetConfig+0xc2>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
3400a02c:	2304      	movs	r3, #4
3400a02e:	617b      	str	r3, [r7, #20]
      break;
3400a030:	e016      	b.n	3400a060 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
3400a032:	2303      	movs	r3, #3
3400a034:	617b      	str	r3, [r7, #20]
      break;
3400a036:	e013      	b.n	3400a060 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3400a038:	2302      	movs	r3, #2
3400a03a:	617b      	str	r3, [r7, #20]
      break;
3400a03c:	e010      	b.n	3400a060 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
3400a03e:	68fb      	ldr	r3, [r7, #12]
3400a040:	681b      	ldr	r3, [r3, #0]
3400a042:	461a      	mov	r2, r3
3400a044:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a046:	021b      	lsls	r3, r3, #8
3400a048:	4413      	add	r3, r2
3400a04a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a04e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400a050:	0c9b      	lsrs	r3, r3, #18
3400a052:	f003 0307 	and.w	r3, r3, #7
3400a056:	617b      	str	r3, [r7, #20]
      break;
3400a058:	e002      	b.n	3400a060 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
3400a05a:	2301      	movs	r3, #1
3400a05c:	617b      	str	r3, [r7, #20]
      break;
3400a05e:	bf00      	nop
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3400a060:	68fa      	ldr	r2, [r7, #12]
3400a062:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a064:	2134      	movs	r1, #52	@ 0x34
3400a066:	fb01 f303 	mul.w	r3, r1, r3
3400a06a:	4413      	add	r3, r2
3400a06c:	333c      	adds	r3, #60	@ 0x3c
3400a06e:	681a      	ldr	r2, [r3, #0]
3400a070:	68fb      	ldr	r3, [r7, #12]
3400a072:	681b      	ldr	r3, [r3, #0]
3400a074:	68db      	ldr	r3, [r3, #12]
3400a076:	0c1b      	lsrs	r3, r3, #16
3400a078:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400a07c:	4413      	add	r3, r2
3400a07e:	041b      	lsls	r3, r3, #16
3400a080:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400a082:	68fa      	ldr	r2, [r7, #12]
3400a084:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a086:	2134      	movs	r1, #52	@ 0x34
3400a088:	fb01 f303 	mul.w	r3, r1, r3
3400a08c:	4413      	add	r3, r2
3400a08e:	3338      	adds	r3, #56	@ 0x38
3400a090:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400a092:	68fb      	ldr	r3, [r7, #12]
3400a094:	681b      	ldr	r3, [r3, #0]
3400a096:	68db      	ldr	r3, [r3, #12]
3400a098:	0c1b      	lsrs	r3, r3, #16
3400a09a:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400a09e:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400a0a0:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400a0a2:	68fb      	ldr	r3, [r7, #12]
3400a0a4:	681b      	ldr	r3, [r3, #0]
3400a0a6:	4619      	mov	r1, r3
3400a0a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a0aa:	021b      	lsls	r3, r3, #8
3400a0ac:	440b      	add	r3, r1
3400a0ae:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a0b2:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400a0b4:	693b      	ldr	r3, [r7, #16]
3400a0b6:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400a0b8:	610b      	str	r3, [r1, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3400a0ba:	68fa      	ldr	r2, [r7, #12]
3400a0bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a0be:	2134      	movs	r1, #52	@ 0x34
3400a0c0:	fb01 f303 	mul.w	r3, r1, r3
3400a0c4:	4413      	add	r3, r2
3400a0c6:	3344      	adds	r3, #68	@ 0x44
3400a0c8:	681a      	ldr	r2, [r3, #0]
3400a0ca:	68fb      	ldr	r3, [r7, #12]
3400a0cc:	681b      	ldr	r3, [r3, #0]
3400a0ce:	68db      	ldr	r3, [r3, #12]
3400a0d0:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400a0d4:	4413      	add	r3, r2
3400a0d6:	041b      	lsls	r3, r3, #16
3400a0d8:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400a0da:	68fa      	ldr	r2, [r7, #12]
3400a0dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a0de:	2134      	movs	r1, #52	@ 0x34
3400a0e0:	fb01 f303 	mul.w	r3, r1, r3
3400a0e4:	4413      	add	r3, r2
3400a0e6:	3340      	adds	r3, #64	@ 0x40
3400a0e8:	681a      	ldr	r2, [r3, #0]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400a0ea:	68fb      	ldr	r3, [r7, #12]
3400a0ec:	681b      	ldr	r3, [r3, #0]
3400a0ee:	68db      	ldr	r3, [r3, #12]
3400a0f0:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400a0f4:	4413      	add	r3, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400a0f6:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400a0f8:	68fb      	ldr	r3, [r7, #12]
3400a0fa:	681b      	ldr	r3, [r3, #0]
3400a0fc:	4619      	mov	r1, r3
3400a0fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a100:	021b      	lsls	r3, r3, #8
3400a102:	440b      	add	r3, r1
3400a104:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a108:	4619      	mov	r1, r3
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400a10a:	693b      	ldr	r3, [r7, #16]
3400a10c:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400a10e:	614b      	str	r3, [r1, #20]

  if (Mirror == LTDC_MIRROR_NONE)
3400a110:	683b      	ldr	r3, [r7, #0]
3400a112:	2b03      	cmp	r3, #3
3400a114:	f040 80fb 	bne.w	3400a30e <LTDC_SetConfig+0x376>
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3400a118:	68fb      	ldr	r3, [r7, #12]
3400a11a:	681b      	ldr	r3, [r3, #0]
3400a11c:	461a      	mov	r2, r3
3400a11e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a120:	021b      	lsls	r3, r3, #8
3400a122:	4413      	add	r3, r2
3400a124:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a128:	4618      	mov	r0, r3
3400a12a:	68fa      	ldr	r2, [r7, #12]
3400a12c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a12e:	2134      	movs	r1, #52	@ 0x34
3400a130:	fb01 f303 	mul.w	r3, r1, r3
3400a134:	4413      	add	r3, r2
3400a136:	335c      	adds	r3, #92	@ 0x5c
3400a138:	681b      	ldr	r3, [r3, #0]
3400a13a:	6343      	str	r3, [r0, #52]	@ 0x34

    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400a13c:	68fa      	ldr	r2, [r7, #12]
3400a13e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a140:	2134      	movs	r1, #52	@ 0x34
3400a142:	fb01 f303 	mul.w	r3, r1, r3
3400a146:	4413      	add	r3, r2
3400a148:	3348      	adds	r3, #72	@ 0x48
3400a14a:	681b      	ldr	r3, [r3, #0]
3400a14c:	f240 120d 	movw	r2, #269	@ 0x10d
3400a150:	4293      	cmp	r3, r2
3400a152:	d004      	beq.n	3400a15e <LTDC_SetConfig+0x1c6>
3400a154:	f240 220d 	movw	r2, #525	@ 0x20d
3400a158:	4293      	cmp	r3, r2
3400a15a:	d043      	beq.n	3400a1e4 <LTDC_SetConfig+0x24c>
        /* Configure the frame buffer line number */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
        break;
      default:
        /* Nothing to do */
        break;
3400a15c:	e092      	b.n	3400a284 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3400a15e:	68fb      	ldr	r3, [r7, #12]
3400a160:	681b      	ldr	r3, [r3, #0]
3400a162:	461a      	mov	r2, r3
3400a164:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a166:	021b      	lsls	r3, r3, #8
3400a168:	4413      	add	r3, r2
3400a16a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a16e:	461a      	mov	r2, r3
3400a170:	68bb      	ldr	r3, [r7, #8]
3400a172:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400a174:	68fa      	ldr	r2, [r7, #12]
3400a176:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a178:	2134      	movs	r1, #52	@ 0x34
3400a17a:	fb01 f303 	mul.w	r3, r1, r3
3400a17e:	4413      	add	r3, r2
3400a180:	3360      	adds	r3, #96	@ 0x60
3400a182:	681b      	ldr	r3, [r3, #0]
3400a184:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a186:	68f9      	ldr	r1, [r7, #12]
3400a188:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a18a:	2034      	movs	r0, #52	@ 0x34
3400a18c:	fb00 f303 	mul.w	r3, r0, r3
3400a190:	440b      	add	r3, r1
3400a192:	333c      	adds	r3, #60	@ 0x3c
3400a194:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3400a196:	68f8      	ldr	r0, [r7, #12]
3400a198:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a19a:	2434      	movs	r4, #52	@ 0x34
3400a19c:	fb04 f303 	mul.w	r3, r4, r3
3400a1a0:	4403      	add	r3, r0
3400a1a2:	3338      	adds	r3, #56	@ 0x38
3400a1a4:	681b      	ldr	r3, [r3, #0]
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a1a6:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3400a1a8:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400a1aa:	68f9      	ldr	r1, [r7, #12]
3400a1ac:	6809      	ldr	r1, [r1, #0]
3400a1ae:	4608      	mov	r0, r1
3400a1b0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a1b2:	0209      	lsls	r1, r1, #8
3400a1b4:	4401      	add	r1, r0
3400a1b6:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a1ba:	4313      	orrs	r3, r2
3400a1bc:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3400a1be:	68fa      	ldr	r2, [r7, #12]
3400a1c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a1c2:	2134      	movs	r1, #52	@ 0x34
3400a1c4:	fb01 f303 	mul.w	r3, r1, r3
3400a1c8:	4413      	add	r3, r2
3400a1ca:	3364      	adds	r3, #100	@ 0x64
3400a1cc:	681b      	ldr	r3, [r3, #0]
3400a1ce:	68fa      	ldr	r2, [r7, #12]
3400a1d0:	6812      	ldr	r2, [r2, #0]
3400a1d2:	4611      	mov	r1, r2
3400a1d4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a1d6:	0212      	lsls	r2, r2, #8
3400a1d8:	440a      	add	r2, r1
3400a1da:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a1de:	085b      	lsrs	r3, r3, #1
3400a1e0:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400a1e2:	e04f      	b.n	3400a284 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3400a1e4:	68fb      	ldr	r3, [r7, #12]
3400a1e6:	681b      	ldr	r3, [r3, #0]
3400a1e8:	461a      	mov	r2, r3
3400a1ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a1ec:	021b      	lsls	r3, r3, #8
3400a1ee:	4413      	add	r3, r2
3400a1f0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a1f4:	461a      	mov	r2, r3
3400a1f6:	68bb      	ldr	r3, [r7, #8]
3400a1f8:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
3400a1fa:	68fb      	ldr	r3, [r7, #12]
3400a1fc:	681b      	ldr	r3, [r3, #0]
3400a1fe:	461a      	mov	r2, r3
3400a200:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a202:	021b      	lsls	r3, r3, #8
3400a204:	4413      	add	r3, r2
3400a206:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a20a:	461a      	mov	r2, r3
3400a20c:	687b      	ldr	r3, [r7, #4]
3400a20e:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400a210:	68fa      	ldr	r2, [r7, #12]
3400a212:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a214:	2134      	movs	r1, #52	@ 0x34
3400a216:	fb01 f303 	mul.w	r3, r1, r3
3400a21a:	4413      	add	r3, r2
3400a21c:	3360      	adds	r3, #96	@ 0x60
3400a21e:	681b      	ldr	r3, [r3, #0]
3400a220:	085b      	lsrs	r3, r3, #1
3400a222:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a224:	68f9      	ldr	r1, [r7, #12]
3400a226:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a228:	2034      	movs	r0, #52	@ 0x34
3400a22a:	fb00 f303 	mul.w	r3, r0, r3
3400a22e:	440b      	add	r3, r1
3400a230:	333c      	adds	r3, #60	@ 0x3c
3400a232:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400a234:	68f8      	ldr	r0, [r7, #12]
3400a236:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a238:	2434      	movs	r4, #52	@ 0x34
3400a23a:	fb04 f303 	mul.w	r3, r4, r3
3400a23e:	4403      	add	r3, r0
3400a240:	3338      	adds	r3, #56	@ 0x38
3400a242:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a244:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400a246:	085b      	lsrs	r3, r3, #1
3400a248:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400a24a:	68f9      	ldr	r1, [r7, #12]
3400a24c:	6809      	ldr	r1, [r1, #0]
3400a24e:	4608      	mov	r0, r1
3400a250:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a252:	0209      	lsls	r1, r1, #8
3400a254:	4401      	add	r1, r0
3400a256:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a25a:	4313      	orrs	r3, r2
3400a25c:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3400a25e:	68fa      	ldr	r2, [r7, #12]
3400a260:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a262:	2134      	movs	r1, #52	@ 0x34
3400a264:	fb01 f303 	mul.w	r3, r1, r3
3400a268:	4413      	add	r3, r2
3400a26a:	3364      	adds	r3, #100	@ 0x64
3400a26c:	681b      	ldr	r3, [r3, #0]
3400a26e:	68fa      	ldr	r2, [r7, #12]
3400a270:	6812      	ldr	r2, [r2, #0]
3400a272:	4611      	mov	r1, r2
3400a274:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a276:	0212      	lsls	r2, r2, #8
3400a278:	440a      	add	r2, r1
3400a27a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a27e:	085b      	lsrs	r3, r3, #1
3400a280:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400a282:	bf00      	nop
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400a284:	68fa      	ldr	r2, [r7, #12]
3400a286:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a288:	2134      	movs	r1, #52	@ 0x34
3400a28a:	fb01 f303 	mul.w	r3, r1, r3
3400a28e:	4413      	add	r3, r2
3400a290:	3360      	adds	r3, #96	@ 0x60
3400a292:	681b      	ldr	r3, [r3, #0]
3400a294:	697a      	ldr	r2, [r7, #20]
3400a296:	fb02 f303 	mul.w	r3, r2, r3
3400a29a:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a29c:	68f9      	ldr	r1, [r7, #12]
3400a29e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a2a0:	2034      	movs	r0, #52	@ 0x34
3400a2a2:	fb00 f303 	mul.w	r3, r0, r3
3400a2a6:	440b      	add	r3, r1
3400a2a8:	333c      	adds	r3, #60	@ 0x3c
3400a2aa:	6819      	ldr	r1, [r3, #0]
3400a2ac:	68f8      	ldr	r0, [r7, #12]
3400a2ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a2b0:	2434      	movs	r4, #52	@ 0x34
3400a2b2:	fb04 f303 	mul.w	r3, r4, r3
3400a2b6:	4403      	add	r3, r0
3400a2b8:	3338      	adds	r3, #56	@ 0x38
3400a2ba:	681b      	ldr	r3, [r3, #0]
3400a2bc:	1acb      	subs	r3, r1, r3
3400a2be:	6979      	ldr	r1, [r7, #20]
3400a2c0:	fb01 f303 	mul.w	r3, r1, r3
                                            stride)  + 7U));
3400a2c4:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400a2c6:	68f9      	ldr	r1, [r7, #12]
3400a2c8:	6809      	ldr	r1, [r1, #0]
3400a2ca:	4608      	mov	r0, r1
3400a2cc:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a2ce:	0209      	lsls	r1, r1, #8
3400a2d0:	4401      	add	r1, r0
3400a2d2:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a2d6:	4313      	orrs	r3, r2
3400a2d8:	638b      	str	r3, [r1, #56]	@ 0x38

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR,LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3400a2da:	68fb      	ldr	r3, [r7, #12]
3400a2dc:	681b      	ldr	r3, [r3, #0]
3400a2de:	461a      	mov	r2, r3
3400a2e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a2e2:	021b      	lsls	r3, r3, #8
3400a2e4:	4413      	add	r3, r2
3400a2e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a2ea:	68db      	ldr	r3, [r3, #12]
3400a2ec:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3400a2f0:	f023 0301 	bic.w	r3, r3, #1
3400a2f4:	68fa      	ldr	r2, [r7, #12]
3400a2f6:	6812      	ldr	r2, [r2, #0]
3400a2f8:	4611      	mov	r1, r2
3400a2fa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a2fc:	0212      	lsls	r2, r2, #8
3400a2fe:	440a      	add	r2, r1
3400a300:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a304:	f043 0301 	orr.w	r3, r3, #1
3400a308:	60d3      	str	r3, [r2, #12]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
  }
}
3400a30a:	f000 bccc 	b.w	3400aca6 <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
3400a30e:	683b      	ldr	r3, [r7, #0]
3400a310:	2b00      	cmp	r3, #0
3400a312:	f040 814e 	bne.w	3400a5b2 <LTDC_SetConfig+0x61a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a316:	68fa      	ldr	r2, [r7, #12]
3400a318:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a31a:	2134      	movs	r1, #52	@ 0x34
3400a31c:	fb01 f303 	mul.w	r3, r1, r3
3400a320:	4413      	add	r3, r2
3400a322:	335c      	adds	r3, #92	@ 0x5c
3400a324:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a326:	68f9      	ldr	r1, [r7, #12]
3400a328:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a32a:	2034      	movs	r0, #52	@ 0x34
3400a32c:	fb00 f303 	mul.w	r3, r0, r3
3400a330:	440b      	add	r3, r1
3400a332:	333c      	adds	r3, #60	@ 0x3c
3400a334:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400a336:	68f8      	ldr	r0, [r7, #12]
3400a338:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a33a:	2434      	movs	r4, #52	@ 0x34
3400a33c:	fb04 f303 	mul.w	r3, r4, r3
3400a340:	4403      	add	r3, r0
3400a342:	3338      	adds	r3, #56	@ 0x38
3400a344:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a346:	1acb      	subs	r3, r1, r3
3400a348:	6979      	ldr	r1, [r7, #20]
3400a34a:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a34e:	4413      	add	r3, r2
3400a350:	68fa      	ldr	r2, [r7, #12]
3400a352:	6812      	ldr	r2, [r2, #0]
3400a354:	4611      	mov	r1, r2
3400a356:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a358:	0212      	lsls	r2, r2, #8
3400a35a:	440a      	add	r2, r1
3400a35c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400a360:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a362:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400a364:	68fa      	ldr	r2, [r7, #12]
3400a366:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a368:	2134      	movs	r1, #52	@ 0x34
3400a36a:	fb01 f303 	mul.w	r3, r1, r3
3400a36e:	4413      	add	r3, r2
3400a370:	3348      	adds	r3, #72	@ 0x48
3400a372:	681b      	ldr	r3, [r3, #0]
3400a374:	f240 120d 	movw	r2, #269	@ 0x10d
3400a378:	4293      	cmp	r3, r2
3400a37a:	d004      	beq.n	3400a386 <LTDC_SetConfig+0x3ee>
3400a37c:	f240 220d 	movw	r2, #525	@ 0x20d
3400a380:	4293      	cmp	r3, r2
3400a382:	d058      	beq.n	3400a436 <LTDC_SetConfig+0x49e>
        break;
3400a384:	e0d3      	b.n	3400a52e <LTDC_SetConfig+0x596>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a386:	68fa      	ldr	r2, [r7, #12]
3400a388:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a38a:	2134      	movs	r1, #52	@ 0x34
3400a38c:	fb01 f303 	mul.w	r3, r1, r3
3400a390:	4413      	add	r3, r2
3400a392:	333c      	adds	r3, #60	@ 0x3c
3400a394:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400a396:	68f9      	ldr	r1, [r7, #12]
3400a398:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a39a:	2034      	movs	r0, #52	@ 0x34
3400a39c:	fb00 f303 	mul.w	r3, r0, r3
3400a3a0:	440b      	add	r3, r1
3400a3a2:	3338      	adds	r3, #56	@ 0x38
3400a3a4:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a3a6:	1ad3      	subs	r3, r2, r3
3400a3a8:	697a      	ldr	r2, [r7, #20]
3400a3aa:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400a3ae:	68bb      	ldr	r3, [r7, #8]
3400a3b0:	4413      	add	r3, r2
3400a3b2:	68fa      	ldr	r2, [r7, #12]
3400a3b4:	6812      	ldr	r2, [r2, #0]
3400a3b6:	4611      	mov	r1, r2
3400a3b8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a3ba:	0212      	lsls	r2, r2, #8
3400a3bc:	440a      	add	r2, r1
3400a3be:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400a3c2:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400a3c4:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400a3c6:	68fa      	ldr	r2, [r7, #12]
3400a3c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a3ca:	2134      	movs	r1, #52	@ 0x34
3400a3cc:	fb01 f303 	mul.w	r3, r1, r3
3400a3d0:	4413      	add	r3, r2
3400a3d2:	3360      	adds	r3, #96	@ 0x60
3400a3d4:	681b      	ldr	r3, [r3, #0]
3400a3d6:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0 +
3400a3d8:	68f9      	ldr	r1, [r7, #12]
3400a3da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a3dc:	2034      	movs	r0, #52	@ 0x34
3400a3de:	fb00 f303 	mul.w	r3, r0, r3
3400a3e2:	440b      	add	r3, r1
3400a3e4:	333c      	adds	r3, #60	@ 0x3c
3400a3e6:	6819      	ldr	r1, [r3, #0]
3400a3e8:	68f8      	ldr	r0, [r7, #12]
3400a3ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a3ec:	2434      	movs	r4, #52	@ 0x34
3400a3ee:	fb04 f303 	mul.w	r3, r4, r3
3400a3f2:	4403      	add	r3, r0
3400a3f4:	3338      	adds	r3, #56	@ 0x38
3400a3f6:	681b      	ldr	r3, [r3, #0]
3400a3f8:	1acb      	subs	r3, r1, r3
3400a3fa:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400a3fc:	68f9      	ldr	r1, [r7, #12]
3400a3fe:	6809      	ldr	r1, [r1, #0]
3400a400:	4608      	mov	r0, r1
3400a402:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a404:	0209      	lsls	r1, r1, #8
3400a406:	4401      	add	r1, r0
3400a408:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a40c:	4313      	orrs	r3, r2
3400a40e:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U ;
3400a410:	68fa      	ldr	r2, [r7, #12]
3400a412:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a414:	2134      	movs	r1, #52	@ 0x34
3400a416:	fb01 f303 	mul.w	r3, r1, r3
3400a41a:	4413      	add	r3, r2
3400a41c:	3364      	adds	r3, #100	@ 0x64
3400a41e:	681b      	ldr	r3, [r3, #0]
3400a420:	68fa      	ldr	r2, [r7, #12]
3400a422:	6812      	ldr	r2, [r2, #0]
3400a424:	4611      	mov	r1, r2
3400a426:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a428:	0212      	lsls	r2, r2, #8
3400a42a:	440a      	add	r2, r1
3400a42c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a430:	085b      	lsrs	r3, r3, #1
3400a432:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400a434:	e07b      	b.n	3400a52e <LTDC_SetConfig+0x596>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a436:	68fa      	ldr	r2, [r7, #12]
3400a438:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a43a:	2134      	movs	r1, #52	@ 0x34
3400a43c:	fb01 f303 	mul.w	r3, r1, r3
3400a440:	4413      	add	r3, r2
3400a442:	333c      	adds	r3, #60	@ 0x3c
3400a444:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400a446:	68f9      	ldr	r1, [r7, #12]
3400a448:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a44a:	2034      	movs	r0, #52	@ 0x34
3400a44c:	fb00 f303 	mul.w	r3, r0, r3
3400a450:	440b      	add	r3, r1
3400a452:	3338      	adds	r3, #56	@ 0x38
3400a454:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a456:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400a458:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a45a:	697a      	ldr	r2, [r7, #20]
3400a45c:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400a460:	68bb      	ldr	r3, [r7, #8]
3400a462:	4413      	add	r3, r2
3400a464:	68fa      	ldr	r2, [r7, #12]
3400a466:	6812      	ldr	r2, [r2, #0]
3400a468:	4611      	mov	r1, r2
3400a46a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a46c:	0212      	lsls	r2, r2, #8
3400a46e:	440a      	add	r2, r1
3400a470:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400a474:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400a476:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a478:	68fa      	ldr	r2, [r7, #12]
3400a47a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a47c:	2134      	movs	r1, #52	@ 0x34
3400a47e:	fb01 f303 	mul.w	r3, r1, r3
3400a482:	4413      	add	r3, r2
3400a484:	333c      	adds	r3, #60	@ 0x3c
3400a486:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400a488:	68f9      	ldr	r1, [r7, #12]
3400a48a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a48c:	2034      	movs	r0, #52	@ 0x34
3400a48e:	fb00 f303 	mul.w	r3, r0, r3
3400a492:	440b      	add	r3, r1
3400a494:	3338      	adds	r3, #56	@ 0x38
3400a496:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a498:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400a49a:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a49c:	697a      	ldr	r2, [r7, #20]
3400a49e:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400a4a2:	687b      	ldr	r3, [r7, #4]
3400a4a4:	4413      	add	r3, r2
3400a4a6:	68fa      	ldr	r2, [r7, #12]
3400a4a8:	6812      	ldr	r2, [r2, #0]
3400a4aa:	4611      	mov	r1, r2
3400a4ac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a4ae:	0212      	lsls	r2, r2, #8
3400a4b0:	440a      	add	r2, r1
3400a4b2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400a4b6:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400a4b8:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400a4ba:	68fa      	ldr	r2, [r7, #12]
3400a4bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a4be:	2134      	movs	r1, #52	@ 0x34
3400a4c0:	fb01 f303 	mul.w	r3, r1, r3
3400a4c4:	4413      	add	r3, r2
3400a4c6:	3360      	adds	r3, #96	@ 0x60
3400a4c8:	681b      	ldr	r3, [r3, #0]
3400a4ca:	085b      	lsrs	r3, r3, #1
3400a4cc:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a4ce:	68f9      	ldr	r1, [r7, #12]
3400a4d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a4d2:	2034      	movs	r0, #52	@ 0x34
3400a4d4:	fb00 f303 	mul.w	r3, r0, r3
3400a4d8:	440b      	add	r3, r1
3400a4da:	333c      	adds	r3, #60	@ 0x3c
3400a4dc:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400a4de:	68f8      	ldr	r0, [r7, #12]
3400a4e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a4e2:	2434      	movs	r4, #52	@ 0x34
3400a4e4:	fb04 f303 	mul.w	r3, r4, r3
3400a4e8:	4403      	add	r3, r0
3400a4ea:	3338      	adds	r3, #56	@ 0x38
3400a4ec:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a4ee:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400a4f0:	085b      	lsrs	r3, r3, #1
3400a4f2:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400a4f4:	68f9      	ldr	r1, [r7, #12]
3400a4f6:	6809      	ldr	r1, [r1, #0]
3400a4f8:	4608      	mov	r0, r1
3400a4fa:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a4fc:	0209      	lsls	r1, r1, #8
3400a4fe:	4401      	add	r1, r0
3400a500:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a504:	4313      	orrs	r3, r2
3400a506:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400a508:	68fa      	ldr	r2, [r7, #12]
3400a50a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a50c:	2134      	movs	r1, #52	@ 0x34
3400a50e:	fb01 f303 	mul.w	r3, r1, r3
3400a512:	4413      	add	r3, r2
3400a514:	3364      	adds	r3, #100	@ 0x64
3400a516:	681b      	ldr	r3, [r3, #0]
3400a518:	68fa      	ldr	r2, [r7, #12]
3400a51a:	6812      	ldr	r2, [r2, #0]
3400a51c:	4611      	mov	r1, r2
3400a51e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a520:	0212      	lsls	r2, r2, #8
3400a522:	440a      	add	r2, r1
3400a524:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a528:	085b      	lsrs	r3, r3, #1
3400a52a:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400a52c:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400a52e:	68fa      	ldr	r2, [r7, #12]
3400a530:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a532:	2134      	movs	r1, #52	@ 0x34
3400a534:	fb01 f303 	mul.w	r3, r1, r3
3400a538:	4413      	add	r3, r2
3400a53a:	3360      	adds	r3, #96	@ 0x60
3400a53c:	681b      	ldr	r3, [r3, #0]
3400a53e:	697a      	ldr	r2, [r7, #20]
3400a540:	fb02 f303 	mul.w	r3, r2, r3
3400a544:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a546:	68f9      	ldr	r1, [r7, #12]
3400a548:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a54a:	2034      	movs	r0, #52	@ 0x34
3400a54c:	fb00 f303 	mul.w	r3, r0, r3
3400a550:	440b      	add	r3, r1
3400a552:	333c      	adds	r3, #60	@ 0x3c
3400a554:	6819      	ldr	r1, [r3, #0]
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3400a556:	68f8      	ldr	r0, [r7, #12]
3400a558:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a55a:	2434      	movs	r4, #52	@ 0x34
3400a55c:	fb04 f303 	mul.w	r3, r4, r3
3400a560:	4403      	add	r3, r0
3400a562:	3338      	adds	r3, #56	@ 0x38
3400a564:	681b      	ldr	r3, [r3, #0]
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a566:	1acb      	subs	r3, r1, r3
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3400a568:	6979      	ldr	r1, [r7, #20]
3400a56a:	fb01 f303 	mul.w	r3, r1, r3
3400a56e:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400a570:	68f9      	ldr	r1, [r7, #12]
3400a572:	6809      	ldr	r1, [r1, #0]
3400a574:	4608      	mov	r0, r1
3400a576:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a578:	0209      	lsls	r1, r1, #8
3400a57a:	4401      	add	r1, r0
3400a57c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a580:	4313      	orrs	r3, r2
3400a582:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3400a584:	68fb      	ldr	r3, [r7, #12]
3400a586:	681b      	ldr	r3, [r3, #0]
3400a588:	461a      	mov	r2, r3
3400a58a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a58c:	021b      	lsls	r3, r3, #8
3400a58e:	4413      	add	r3, r2
3400a590:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a594:	68db      	ldr	r3, [r3, #12]
3400a596:	68fa      	ldr	r2, [r7, #12]
3400a598:	6812      	ldr	r2, [r2, #0]
3400a59a:	4611      	mov	r1, r2
3400a59c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a59e:	0212      	lsls	r2, r2, #8
3400a5a0:	440a      	add	r2, r1
3400a5a2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a5a6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400a5aa:	f043 0301 	orr.w	r3, r3, #1
3400a5ae:	60d3      	str	r3, [r2, #12]
}
3400a5b0:	e379      	b.n	3400aca6 <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3400a5b2:	683b      	ldr	r3, [r7, #0]
3400a5b4:	2b01      	cmp	r3, #1
3400a5b6:	f040 81b4 	bne.w	3400a922 <LTDC_SetConfig+0x98a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a5ba:	68fa      	ldr	r2, [r7, #12]
3400a5bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a5be:	2134      	movs	r1, #52	@ 0x34
3400a5c0:	fb01 f303 	mul.w	r3, r1, r3
3400a5c4:	4413      	add	r3, r2
3400a5c6:	335c      	adds	r3, #92	@ 0x5c
3400a5c8:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a5ca:	68f9      	ldr	r1, [r7, #12]
3400a5cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a5ce:	2034      	movs	r0, #52	@ 0x34
3400a5d0:	fb00 f303 	mul.w	r3, r0, r3
3400a5d4:	440b      	add	r3, r1
3400a5d6:	333c      	adds	r3, #60	@ 0x3c
3400a5d8:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a5da:	68f8      	ldr	r0, [r7, #12]
3400a5dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a5de:	2434      	movs	r4, #52	@ 0x34
3400a5e0:	fb04 f303 	mul.w	r3, r4, r3
3400a5e4:	4403      	add	r3, r0
3400a5e6:	3338      	adds	r3, #56	@ 0x38
3400a5e8:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a5ea:	1acb      	subs	r3, r1, r3
3400a5ec:	6979      	ldr	r1, [r7, #20]
3400a5ee:	fb01 f303 	mul.w	r3, r1, r3
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a5f2:	68f8      	ldr	r0, [r7, #12]
3400a5f4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a5f6:	2434      	movs	r4, #52	@ 0x34
3400a5f8:	fb04 f101 	mul.w	r1, r4, r1
3400a5fc:	4401      	add	r1, r0
3400a5fe:	3144      	adds	r1, #68	@ 0x44
3400a600:	6808      	ldr	r0, [r1, #0]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400a602:	68fc      	ldr	r4, [r7, #12]
3400a604:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a606:	2534      	movs	r5, #52	@ 0x34
3400a608:	fb05 f101 	mul.w	r1, r5, r1
3400a60c:	4421      	add	r1, r4
3400a60e:	3140      	adds	r1, #64	@ 0x40
3400a610:	6809      	ldr	r1, [r1, #0]
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a612:	1a41      	subs	r1, r0, r1
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400a614:	3901      	subs	r1, #1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a616:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a61a:	68f9      	ldr	r1, [r7, #12]
3400a61c:	6809      	ldr	r1, [r1, #0]
3400a61e:	4608      	mov	r0, r1
3400a620:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a622:	0209      	lsls	r1, r1, #8
3400a624:	4401      	add	r1, r0
3400a626:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a62a:	4413      	add	r3, r2
3400a62c:	634b      	str	r3, [r1, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400a62e:	68fa      	ldr	r2, [r7, #12]
3400a630:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a632:	2134      	movs	r1, #52	@ 0x34
3400a634:	fb01 f303 	mul.w	r3, r1, r3
3400a638:	4413      	add	r3, r2
3400a63a:	3348      	adds	r3, #72	@ 0x48
3400a63c:	681b      	ldr	r3, [r3, #0]
3400a63e:	f240 120d 	movw	r2, #269	@ 0x10d
3400a642:	4293      	cmp	r3, r2
3400a644:	d004      	beq.n	3400a650 <LTDC_SetConfig+0x6b8>
3400a646:	f240 220d 	movw	r2, #525	@ 0x20d
3400a64a:	4293      	cmp	r3, r2
3400a64c:	d075      	beq.n	3400a73a <LTDC_SetConfig+0x7a2>
        break;
3400a64e:	e122      	b.n	3400a896 <LTDC_SetConfig+0x8fe>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a650:	68fa      	ldr	r2, [r7, #12]
3400a652:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a654:	2134      	movs	r1, #52	@ 0x34
3400a656:	fb01 f303 	mul.w	r3, r1, r3
3400a65a:	4413      	add	r3, r2
3400a65c:	333c      	adds	r3, #60	@ 0x3c
3400a65e:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a660:	68f9      	ldr	r1, [r7, #12]
3400a662:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a664:	2034      	movs	r0, #52	@ 0x34
3400a666:	fb00 f303 	mul.w	r3, r0, r3
3400a66a:	440b      	add	r3, r1
3400a66c:	3338      	adds	r3, #56	@ 0x38
3400a66e:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a670:	1ad3      	subs	r3, r2, r3
3400a672:	697a      	ldr	r2, [r7, #20]
3400a674:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a678:	68f9      	ldr	r1, [r7, #12]
3400a67a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a67c:	2034      	movs	r0, #52	@ 0x34
3400a67e:	fb00 f202 	mul.w	r2, r0, r2
3400a682:	440a      	add	r2, r1
3400a684:	3244      	adds	r2, #68	@ 0x44
3400a686:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400a688:	68f8      	ldr	r0, [r7, #12]
3400a68a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a68c:	2434      	movs	r4, #52	@ 0x34
3400a68e:	fb04 f202 	mul.w	r2, r4, r2
3400a692:	4402      	add	r2, r0
3400a694:	3240      	adds	r2, #64	@ 0x40
3400a696:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a698:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400a69a:	0852      	lsrs	r2, r2, #1
3400a69c:	3a01      	subs	r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a69e:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400a6a2:	68fb      	ldr	r3, [r7, #12]
3400a6a4:	681b      	ldr	r3, [r3, #0]
3400a6a6:	4619      	mov	r1, r3
3400a6a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a6aa:	021b      	lsls	r3, r3, #8
3400a6ac:	440b      	add	r3, r1
3400a6ae:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a6b2:	4619      	mov	r1, r3
3400a6b4:	68bb      	ldr	r3, [r7, #8]
3400a6b6:	4413      	add	r3, r2
3400a6b8:	640b      	str	r3, [r1, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400a6ba:	68fa      	ldr	r2, [r7, #12]
3400a6bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a6be:	2134      	movs	r1, #52	@ 0x34
3400a6c0:	fb01 f303 	mul.w	r3, r1, r3
3400a6c4:	4413      	add	r3, r2
3400a6c6:	3360      	adds	r3, #96	@ 0x60
3400a6c8:	681b      	ldr	r3, [r3, #0]
3400a6ca:	697a      	ldr	r2, [r7, #20]
3400a6cc:	fb02 f303 	mul.w	r3, r2, r3
3400a6d0:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400a6d4:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a6d6:	68f9      	ldr	r1, [r7, #12]
3400a6d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a6da:	2034      	movs	r0, #52	@ 0x34
3400a6dc:	fb00 f303 	mul.w	r3, r0, r3
3400a6e0:	440b      	add	r3, r1
3400a6e2:	333c      	adds	r3, #60	@ 0x3c
3400a6e4:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3400a6e6:	68f8      	ldr	r0, [r7, #12]
3400a6e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a6ea:	2434      	movs	r4, #52	@ 0x34
3400a6ec:	fb04 f303 	mul.w	r3, r4, r3
3400a6f0:	4403      	add	r3, r0
3400a6f2:	3338      	adds	r3, #56	@ 0x38
3400a6f4:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a6f6:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3400a6f8:	6979      	ldr	r1, [r7, #20]
3400a6fa:	fb01 f303 	mul.w	r3, r1, r3
3400a6fe:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400a700:	68f9      	ldr	r1, [r7, #12]
3400a702:	6809      	ldr	r1, [r1, #0]
3400a704:	4608      	mov	r0, r1
3400a706:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a708:	0209      	lsls	r1, r1, #8
3400a70a:	4401      	add	r1, r0
3400a70c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a710:	4313      	orrs	r3, r2
3400a712:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400a714:	68fa      	ldr	r2, [r7, #12]
3400a716:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a718:	2134      	movs	r1, #52	@ 0x34
3400a71a:	fb01 f303 	mul.w	r3, r1, r3
3400a71e:	4413      	add	r3, r2
3400a720:	3364      	adds	r3, #100	@ 0x64
3400a722:	681b      	ldr	r3, [r3, #0]
3400a724:	68fa      	ldr	r2, [r7, #12]
3400a726:	6812      	ldr	r2, [r2, #0]
3400a728:	4611      	mov	r1, r2
3400a72a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a72c:	0212      	lsls	r2, r2, #8
3400a72e:	440a      	add	r2, r1
3400a730:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a734:	085b      	lsrs	r3, r3, #1
3400a736:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400a738:	e0ad      	b.n	3400a896 <LTDC_SetConfig+0x8fe>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a73a:	68fa      	ldr	r2, [r7, #12]
3400a73c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a73e:	2134      	movs	r1, #52	@ 0x34
3400a740:	fb01 f303 	mul.w	r3, r1, r3
3400a744:	4413      	add	r3, r2
3400a746:	333c      	adds	r3, #60	@ 0x3c
3400a748:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400a74a:	68f9      	ldr	r1, [r7, #12]
3400a74c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a74e:	2034      	movs	r0, #52	@ 0x34
3400a750:	fb00 f303 	mul.w	r3, r0, r3
3400a754:	440b      	add	r3, r1
3400a756:	3338      	adds	r3, #56	@ 0x38
3400a758:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a75a:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400a75c:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a75e:	697a      	ldr	r2, [r7, #20]
3400a760:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a764:	68f9      	ldr	r1, [r7, #12]
3400a766:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a768:	2034      	movs	r0, #52	@ 0x34
3400a76a:	fb00 f202 	mul.w	r2, r0, r2
3400a76e:	440a      	add	r2, r1
3400a770:	3244      	adds	r2, #68	@ 0x44
3400a772:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400a774:	68f8      	ldr	r0, [r7, #12]
3400a776:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a778:	2434      	movs	r4, #52	@ 0x34
3400a77a:	fb04 f202 	mul.w	r2, r4, r2
3400a77e:	4402      	add	r2, r0
3400a780:	3240      	adds	r2, #64	@ 0x40
3400a782:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a784:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400a786:	0852      	lsrs	r2, r2, #1
3400a788:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400a78a:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400a78e:	68fb      	ldr	r3, [r7, #12]
3400a790:	681b      	ldr	r3, [r3, #0]
3400a792:	4619      	mov	r1, r3
3400a794:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a796:	021b      	lsls	r3, r3, #8
3400a798:	440b      	add	r3, r1
3400a79a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a79e:	4619      	mov	r1, r3
3400a7a0:	68bb      	ldr	r3, [r7, #8]
3400a7a2:	4413      	add	r3, r2
3400a7a4:	640b      	str	r3, [r1, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a7a6:	68fa      	ldr	r2, [r7, #12]
3400a7a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a7aa:	2134      	movs	r1, #52	@ 0x34
3400a7ac:	fb01 f303 	mul.w	r3, r1, r3
3400a7b0:	4413      	add	r3, r2
3400a7b2:	333c      	adds	r3, #60	@ 0x3c
3400a7b4:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400a7b6:	68f9      	ldr	r1, [r7, #12]
3400a7b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a7ba:	2034      	movs	r0, #52	@ 0x34
3400a7bc:	fb00 f303 	mul.w	r3, r0, r3
3400a7c0:	440b      	add	r3, r1
3400a7c2:	3338      	adds	r3, #56	@ 0x38
3400a7c4:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a7c6:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400a7c8:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a7ca:	697a      	ldr	r2, [r7, #20]
3400a7cc:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a7d0:	68f9      	ldr	r1, [r7, #12]
3400a7d2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a7d4:	2034      	movs	r0, #52	@ 0x34
3400a7d6:	fb00 f202 	mul.w	r2, r0, r2
3400a7da:	440a      	add	r2, r1
3400a7dc:	3244      	adds	r2, #68	@ 0x44
3400a7de:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400a7e0:	68f8      	ldr	r0, [r7, #12]
3400a7e2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a7e4:	2434      	movs	r4, #52	@ 0x34
3400a7e6:	fb04 f202 	mul.w	r2, r4, r2
3400a7ea:	4402      	add	r2, r0
3400a7ec:	3240      	adds	r2, #64	@ 0x40
3400a7ee:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a7f0:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400a7f2:	0852      	lsrs	r2, r2, #1
3400a7f4:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400a7f6:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400a7fa:	68fb      	ldr	r3, [r7, #12]
3400a7fc:	681b      	ldr	r3, [r3, #0]
3400a7fe:	4619      	mov	r1, r3
3400a800:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a802:	021b      	lsls	r3, r3, #8
3400a804:	440b      	add	r3, r1
3400a806:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a80a:	4619      	mov	r1, r3
3400a80c:	687b      	ldr	r3, [r7, #4]
3400a80e:	4413      	add	r3, r2
3400a810:	644b      	str	r3, [r1, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3400a812:	68fa      	ldr	r2, [r7, #12]
3400a814:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a816:	2134      	movs	r1, #52	@ 0x34
3400a818:	fb01 f303 	mul.w	r3, r1, r3
3400a81c:	4413      	add	r3, r2
3400a81e:	3360      	adds	r3, #96	@ 0x60
3400a820:	681b      	ldr	r3, [r3, #0]
3400a822:	085b      	lsrs	r3, r3, #1
3400a824:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400a828:	697a      	ldr	r2, [r7, #20]
3400a82a:	fb02 f303 	mul.w	r3, r2, r3
                                               stride) << 16U) |
3400a82e:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a830:	68f9      	ldr	r1, [r7, #12]
3400a832:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a834:	2034      	movs	r0, #52	@ 0x34
3400a836:	fb00 f303 	mul.w	r3, r0, r3
3400a83a:	440b      	add	r3, r1
3400a83c:	333c      	adds	r3, #60	@ 0x3c
3400a83e:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400a840:	68f8      	ldr	r0, [r7, #12]
3400a842:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a844:	2434      	movs	r4, #52	@ 0x34
3400a846:	fb04 f303 	mul.w	r3, r4, r3
3400a84a:	4403      	add	r3, r0
3400a84c:	3338      	adds	r3, #56	@ 0x38
3400a84e:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a850:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400a852:	085b      	lsrs	r3, r3, #1
3400a854:	6979      	ldr	r1, [r7, #20]
3400a856:	fb01 f303 	mul.w	r3, r1, r3
3400a85a:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3400a85c:	68f9      	ldr	r1, [r7, #12]
3400a85e:	6809      	ldr	r1, [r1, #0]
3400a860:	4608      	mov	r0, r1
3400a862:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a864:	0209      	lsls	r1, r1, #8
3400a866:	4401      	add	r1, r0
3400a868:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                               stride) << 16U) |
3400a86c:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3400a86e:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400a870:	68fa      	ldr	r2, [r7, #12]
3400a872:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a874:	2134      	movs	r1, #52	@ 0x34
3400a876:	fb01 f303 	mul.w	r3, r1, r3
3400a87a:	4413      	add	r3, r2
3400a87c:	3364      	adds	r3, #100	@ 0x64
3400a87e:	681b      	ldr	r3, [r3, #0]
3400a880:	68fa      	ldr	r2, [r7, #12]
3400a882:	6812      	ldr	r2, [r2, #0]
3400a884:	4611      	mov	r1, r2
3400a886:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a888:	0212      	lsls	r2, r2, #8
3400a88a:	440a      	add	r2, r1
3400a88c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a890:	085b      	lsrs	r3, r3, #1
3400a892:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400a894:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400a896:	68fa      	ldr	r2, [r7, #12]
3400a898:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a89a:	2134      	movs	r1, #52	@ 0x34
3400a89c:	fb01 f303 	mul.w	r3, r1, r3
3400a8a0:	4413      	add	r3, r2
3400a8a2:	3360      	adds	r3, #96	@ 0x60
3400a8a4:	681b      	ldr	r3, [r3, #0]
3400a8a6:	697a      	ldr	r2, [r7, #20]
3400a8a8:	fb02 f303 	mul.w	r3, r2, r3
3400a8ac:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400a8b0:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a8b2:	68f9      	ldr	r1, [r7, #12]
3400a8b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a8b6:	2034      	movs	r0, #52	@ 0x34
3400a8b8:	fb00 f303 	mul.w	r3, r0, r3
3400a8bc:	440b      	add	r3, r1
3400a8be:	333c      	adds	r3, #60	@ 0x3c
3400a8c0:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400a8c2:	68f8      	ldr	r0, [r7, #12]
3400a8c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a8c6:	2434      	movs	r4, #52	@ 0x34
3400a8c8:	fb04 f303 	mul.w	r3, r4, r3
3400a8cc:	4403      	add	r3, r0
3400a8ce:	3338      	adds	r3, #56	@ 0x38
3400a8d0:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a8d2:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400a8d4:	6979      	ldr	r1, [r7, #20]
3400a8d6:	fb01 f303 	mul.w	r3, r1, r3
3400a8da:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400a8dc:	68f9      	ldr	r1, [r7, #12]
3400a8de:	6809      	ldr	r1, [r1, #0]
3400a8e0:	4608      	mov	r0, r1
3400a8e2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a8e4:	0209      	lsls	r1, r1, #8
3400a8e6:	4401      	add	r1, r0
3400a8e8:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400a8ec:	4313      	orrs	r3, r2
3400a8ee:	638b      	str	r3, [r1, #56]	@ 0x38
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3400a8f0:	68fb      	ldr	r3, [r7, #12]
3400a8f2:	681b      	ldr	r3, [r3, #0]
3400a8f4:	461a      	mov	r2, r3
3400a8f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a8f8:	021b      	lsls	r3, r3, #8
3400a8fa:	4413      	add	r3, r2
3400a8fc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400a900:	68db      	ldr	r3, [r3, #12]
3400a902:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3400a906:	f023 0301 	bic.w	r3, r3, #1
3400a90a:	68fa      	ldr	r2, [r7, #12]
3400a90c:	6812      	ldr	r2, [r2, #0]
3400a90e:	4611      	mov	r1, r2
3400a910:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a912:	0212      	lsls	r2, r2, #8
3400a914:	440a      	add	r2, r1
3400a916:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400a91a:	f043 0301 	orr.w	r3, r3, #1
3400a91e:	60d3      	str	r3, [r2, #12]
}
3400a920:	e1c1      	b.n	3400aca6 <LTDC_SetConfig+0xd0e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a922:	68fa      	ldr	r2, [r7, #12]
3400a924:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a926:	2134      	movs	r1, #52	@ 0x34
3400a928:	fb01 f303 	mul.w	r3, r1, r3
3400a92c:	4413      	add	r3, r2
3400a92e:	335c      	adds	r3, #92	@ 0x5c
3400a930:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a932:	68f9      	ldr	r1, [r7, #12]
3400a934:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a936:	2034      	movs	r0, #52	@ 0x34
3400a938:	fb00 f303 	mul.w	r3, r0, r3
3400a93c:	440b      	add	r3, r1
3400a93e:	333c      	adds	r3, #60	@ 0x3c
3400a940:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a942:	68f8      	ldr	r0, [r7, #12]
3400a944:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a946:	2434      	movs	r4, #52	@ 0x34
3400a948:	fb04 f303 	mul.w	r3, r4, r3
3400a94c:	4403      	add	r3, r0
3400a94e:	3338      	adds	r3, #56	@ 0x38
3400a950:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a952:	1acb      	subs	r3, r1, r3
3400a954:	6979      	ldr	r1, [r7, #20]
3400a956:	fb01 f303 	mul.w	r3, r1, r3
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400a95a:	68f8      	ldr	r0, [r7, #12]
3400a95c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a95e:	2434      	movs	r4, #52	@ 0x34
3400a960:	fb04 f101 	mul.w	r1, r4, r1
3400a964:	4401      	add	r1, r0
3400a966:	3144      	adds	r1, #68	@ 0x44
3400a968:	6808      	ldr	r0, [r1, #0]
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3400a96a:	68fc      	ldr	r4, [r7, #12]
3400a96c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400a96e:	2534      	movs	r5, #52	@ 0x34
3400a970:	fb05 f101 	mul.w	r1, r5, r1
3400a974:	4421      	add	r1, r4
3400a976:	3140      	adds	r1, #64	@ 0x40
3400a978:	6809      	ldr	r1, [r1, #0]
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400a97a:	1a41      	subs	r1, r0, r1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a97c:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a980:	4413      	add	r3, r2
3400a982:	68fa      	ldr	r2, [r7, #12]
3400a984:	6812      	ldr	r2, [r2, #0]
3400a986:	4611      	mov	r1, r2
3400a988:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a98a:	0212      	lsls	r2, r2, #8
3400a98c:	440a      	add	r2, r1
3400a98e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3400a992:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400a994:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400a996:	68fa      	ldr	r2, [r7, #12]
3400a998:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a99a:	2134      	movs	r1, #52	@ 0x34
3400a99c:	fb01 f303 	mul.w	r3, r1, r3
3400a9a0:	4413      	add	r3, r2
3400a9a2:	3348      	adds	r3, #72	@ 0x48
3400a9a4:	681b      	ldr	r3, [r3, #0]
3400a9a6:	f240 120d 	movw	r2, #269	@ 0x10d
3400a9aa:	4293      	cmp	r3, r2
3400a9ac:	d004      	beq.n	3400a9b8 <LTDC_SetConfig+0xa20>
3400a9ae:	f240 220d 	movw	r2, #525	@ 0x20d
3400a9b2:	4293      	cmp	r3, r2
3400a9b4:	d074      	beq.n	3400aaa0 <LTDC_SetConfig+0xb08>
        break;
3400a9b6:	e133      	b.n	3400ac20 <LTDC_SetConfig+0xc88>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a9b8:	68fa      	ldr	r2, [r7, #12]
3400a9ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a9bc:	2134      	movs	r1, #52	@ 0x34
3400a9be:	fb01 f303 	mul.w	r3, r1, r3
3400a9c2:	4413      	add	r3, r2
3400a9c4:	333c      	adds	r3, #60	@ 0x3c
3400a9c6:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400a9c8:	68f9      	ldr	r1, [r7, #12]
3400a9ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400a9cc:	2034      	movs	r0, #52	@ 0x34
3400a9ce:	fb00 f303 	mul.w	r3, r0, r3
3400a9d2:	440b      	add	r3, r1
3400a9d4:	3338      	adds	r3, #56	@ 0x38
3400a9d6:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400a9d8:	1ad3      	subs	r3, r2, r3
3400a9da:	697a      	ldr	r2, [r7, #20]
3400a9dc:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400a9e0:	68f9      	ldr	r1, [r7, #12]
3400a9e2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a9e4:	2034      	movs	r0, #52	@ 0x34
3400a9e6:	fb00 f202 	mul.w	r2, r0, r2
3400a9ea:	440a      	add	r2, r1
3400a9ec:	3244      	adds	r2, #68	@ 0x44
3400a9ee:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400a9f0:	68f8      	ldr	r0, [r7, #12]
3400a9f2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400a9f4:	2434      	movs	r4, #52	@ 0x34
3400a9f6:	fb04 f202 	mul.w	r2, r4, r2
3400a9fa:	4402      	add	r2, r0
3400a9fc:	3240      	adds	r2, #64	@ 0x40
3400a9fe:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400aa00:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400aa02:	0852      	lsrs	r2, r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400aa04:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400aa08:	68bb      	ldr	r3, [r7, #8]
3400aa0a:	4413      	add	r3, r2
3400aa0c:	68fa      	ldr	r2, [r7, #12]
3400aa0e:	6812      	ldr	r2, [r2, #0]
3400aa10:	4611      	mov	r1, r2
3400aa12:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400aa14:	0212      	lsls	r2, r2, #8
3400aa16:	440a      	add	r2, r1
3400aa18:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400aa1c:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400aa1e:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400aa20:	68fa      	ldr	r2, [r7, #12]
3400aa22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aa24:	2134      	movs	r1, #52	@ 0x34
3400aa26:	fb01 f303 	mul.w	r3, r1, r3
3400aa2a:	4413      	add	r3, r2
3400aa2c:	3360      	adds	r3, #96	@ 0x60
3400aa2e:	681b      	ldr	r3, [r3, #0]
3400aa30:	697a      	ldr	r2, [r7, #20]
3400aa32:	fb02 f303 	mul.w	r3, r2, r3
3400aa36:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400aa3a:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400aa3c:	68f9      	ldr	r1, [r7, #12]
3400aa3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aa40:	2034      	movs	r0, #52	@ 0x34
3400aa42:	fb00 f303 	mul.w	r3, r0, r3
3400aa46:	440b      	add	r3, r1
3400aa48:	333c      	adds	r3, #60	@ 0x3c
3400aa4a:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3400aa4c:	68f8      	ldr	r0, [r7, #12]
3400aa4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aa50:	2434      	movs	r4, #52	@ 0x34
3400aa52:	fb04 f303 	mul.w	r3, r4, r3
3400aa56:	4403      	add	r3, r0
3400aa58:	3338      	adds	r3, #56	@ 0x38
3400aa5a:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400aa5c:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3400aa5e:	6979      	ldr	r1, [r7, #20]
3400aa60:	fb01 f303 	mul.w	r3, r1, r3
3400aa64:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400aa66:	68f9      	ldr	r1, [r7, #12]
3400aa68:	6809      	ldr	r1, [r1, #0]
3400aa6a:	4608      	mov	r0, r1
3400aa6c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400aa6e:	0209      	lsls	r1, r1, #8
3400aa70:	4401      	add	r1, r0
3400aa72:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400aa76:	4313      	orrs	r3, r2
3400aa78:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400aa7a:	68fa      	ldr	r2, [r7, #12]
3400aa7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aa7e:	2134      	movs	r1, #52	@ 0x34
3400aa80:	fb01 f303 	mul.w	r3, r1, r3
3400aa84:	4413      	add	r3, r2
3400aa86:	3364      	adds	r3, #100	@ 0x64
3400aa88:	681b      	ldr	r3, [r3, #0]
3400aa8a:	68fa      	ldr	r2, [r7, #12]
3400aa8c:	6812      	ldr	r2, [r2, #0]
3400aa8e:	4611      	mov	r1, r2
3400aa90:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400aa92:	0212      	lsls	r2, r2, #8
3400aa94:	440a      	add	r2, r1
3400aa96:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400aa9a:	085b      	lsrs	r3, r3, #1
3400aa9c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400aa9e:	e0bf      	b.n	3400ac20 <LTDC_SetConfig+0xc88>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400aaa0:	68fa      	ldr	r2, [r7, #12]
3400aaa2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aaa4:	2134      	movs	r1, #52	@ 0x34
3400aaa6:	fb01 f303 	mul.w	r3, r1, r3
3400aaaa:	4413      	add	r3, r2
3400aaac:	333c      	adds	r3, #60	@ 0x3c
3400aaae:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400aab0:	68f9      	ldr	r1, [r7, #12]
3400aab2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aab4:	2034      	movs	r0, #52	@ 0x34
3400aab6:	fb00 f303 	mul.w	r3, r0, r3
3400aaba:	440b      	add	r3, r1
3400aabc:	3338      	adds	r3, #56	@ 0x38
3400aabe:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400aac0:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400aac2:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400aac4:	697a      	ldr	r2, [r7, #20]
3400aac6:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400aaca:	68f9      	ldr	r1, [r7, #12]
3400aacc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400aace:	2034      	movs	r0, #52	@ 0x34
3400aad0:	fb00 f202 	mul.w	r2, r0, r2
3400aad4:	440a      	add	r2, r1
3400aad6:	3244      	adds	r2, #68	@ 0x44
3400aad8:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400aada:	68f8      	ldr	r0, [r7, #12]
3400aadc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400aade:	2434      	movs	r4, #52	@ 0x34
3400aae0:	fb04 f202 	mul.w	r2, r4, r2
3400aae4:	4402      	add	r2, r0
3400aae6:	3240      	adds	r2, #64	@ 0x40
3400aae8:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400aaea:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400aaec:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400aaee:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400aaf2:	68bb      	ldr	r3, [r7, #8]
3400aaf4:	4413      	add	r3, r2
3400aaf6:	68fa      	ldr	r2, [r7, #12]
3400aaf8:	6812      	ldr	r2, [r2, #0]
3400aafa:	4611      	mov	r1, r2
3400aafc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400aafe:	0212      	lsls	r2, r2, #8
3400ab00:	440a      	add	r2, r1
3400ab02:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400ab06:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400ab08:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ab0a:	68fa      	ldr	r2, [r7, #12]
3400ab0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ab0e:	2134      	movs	r1, #52	@ 0x34
3400ab10:	fb01 f303 	mul.w	r3, r1, r3
3400ab14:	4413      	add	r3, r2
3400ab16:	333c      	adds	r3, #60	@ 0x3c
3400ab18:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400ab1a:	68f9      	ldr	r1, [r7, #12]
3400ab1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ab1e:	2034      	movs	r0, #52	@ 0x34
3400ab20:	fb00 f303 	mul.w	r3, r0, r3
3400ab24:	440b      	add	r3, r1
3400ab26:	3338      	adds	r3, #56	@ 0x38
3400ab28:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ab2a:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400ab2c:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ab2e:	697a      	ldr	r2, [r7, #20]
3400ab30:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400ab34:	68f9      	ldr	r1, [r7, #12]
3400ab36:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ab38:	2034      	movs	r0, #52	@ 0x34
3400ab3a:	fb00 f202 	mul.w	r2, r0, r2
3400ab3e:	440a      	add	r2, r1
3400ab40:	3244      	adds	r2, #68	@ 0x44
3400ab42:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400ab44:	68f8      	ldr	r0, [r7, #12]
3400ab46:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ab48:	2434      	movs	r4, #52	@ 0x34
3400ab4a:	fb04 f202 	mul.w	r2, r4, r2
3400ab4e:	4402      	add	r2, r0
3400ab50:	3240      	adds	r2, #64	@ 0x40
3400ab52:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400ab54:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400ab56:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400ab58:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400ab5c:	687b      	ldr	r3, [r7, #4]
3400ab5e:	4413      	add	r3, r2
3400ab60:	68fa      	ldr	r2, [r7, #12]
3400ab62:	6812      	ldr	r2, [r2, #0]
3400ab64:	4611      	mov	r1, r2
3400ab66:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ab68:	0212      	lsls	r2, r2, #8
3400ab6a:	440a      	add	r2, r1
3400ab6c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400ab70:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400ab72:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400ab74:	68fa      	ldr	r2, [r7, #12]
3400ab76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ab78:	2134      	movs	r1, #52	@ 0x34
3400ab7a:	fb01 f303 	mul.w	r3, r1, r3
3400ab7e:	4413      	add	r3, r2
3400ab80:	3360      	adds	r3, #96	@ 0x60
3400ab82:	681b      	ldr	r3, [r3, #0]
3400ab84:	085b      	lsrs	r3, r3, #1
3400ab86:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400ab8a:	697a      	ldr	r2, [r7, #20]
3400ab8c:	fb02 f303 	mul.w	r3, r2, r3
                                              << 16U) |
3400ab90:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ab92:	68f9      	ldr	r1, [r7, #12]
3400ab94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ab96:	2034      	movs	r0, #52	@ 0x34
3400ab98:	fb00 f303 	mul.w	r3, r0, r3
3400ab9c:	440b      	add	r3, r1
3400ab9e:	333c      	adds	r3, #60	@ 0x3c
3400aba0:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400aba2:	68f8      	ldr	r0, [r7, #12]
3400aba4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400aba6:	2434      	movs	r4, #52	@ 0x34
3400aba8:	fb04 f303 	mul.w	r3, r4, r3
3400abac:	4403      	add	r3, r0
3400abae:	3338      	adds	r3, #56	@ 0x38
3400abb0:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400abb2:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400abb4:	085b      	lsrs	r3, r3, #1
3400abb6:	6979      	ldr	r1, [r7, #20]
3400abb8:	fb01 f303 	mul.w	r3, r1, r3
3400abbc:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400abbe:	68f9      	ldr	r1, [r7, #12]
3400abc0:	6809      	ldr	r1, [r1, #0]
3400abc2:	4608      	mov	r0, r1
3400abc4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400abc6:	0209      	lsls	r1, r1, #8
3400abc8:	4401      	add	r1, r0
3400abca:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                              << 16U) |
3400abce:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400abd0:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
3400abd2:	68fb      	ldr	r3, [r7, #12]
3400abd4:	681b      	ldr	r3, [r3, #0]
3400abd6:	461a      	mov	r2, r3
3400abd8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400abda:	021b      	lsls	r3, r3, #8
3400abdc:	4413      	add	r3, r2
3400abde:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400abe2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400abe4:	68fa      	ldr	r2, [r7, #12]
3400abe6:	6812      	ldr	r2, [r2, #0]
3400abe8:	4611      	mov	r1, r2
3400abea:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400abec:	0212      	lsls	r2, r2, #8
3400abee:	440a      	add	r2, r1
3400abf0:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400abf4:	0c1b      	lsrs	r3, r3, #16
3400abf6:	041b      	lsls	r3, r3, #16
3400abf8:	64d3      	str	r3, [r2, #76]	@ 0x4c
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400abfa:	68fa      	ldr	r2, [r7, #12]
3400abfc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400abfe:	2134      	movs	r1, #52	@ 0x34
3400ac00:	fb01 f303 	mul.w	r3, r1, r3
3400ac04:	4413      	add	r3, r2
3400ac06:	3364      	adds	r3, #100	@ 0x64
3400ac08:	681b      	ldr	r3, [r3, #0]
3400ac0a:	68fa      	ldr	r2, [r7, #12]
3400ac0c:	6812      	ldr	r2, [r2, #0]
3400ac0e:	4611      	mov	r1, r2
3400ac10:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ac12:	0212      	lsls	r2, r2, #8
3400ac14:	440a      	add	r2, r1
3400ac16:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400ac1a:	085b      	lsrs	r3, r3, #1
3400ac1c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400ac1e:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400ac20:	68fa      	ldr	r2, [r7, #12]
3400ac22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ac24:	2134      	movs	r1, #52	@ 0x34
3400ac26:	fb01 f303 	mul.w	r3, r1, r3
3400ac2a:	4413      	add	r3, r2
3400ac2c:	3360      	adds	r3, #96	@ 0x60
3400ac2e:	681b      	ldr	r3, [r3, #0]
3400ac30:	697a      	ldr	r2, [r7, #20]
3400ac32:	fb02 f303 	mul.w	r3, r2, r3
3400ac36:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400ac3a:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ac3c:	68f9      	ldr	r1, [r7, #12]
3400ac3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ac40:	2034      	movs	r0, #52	@ 0x34
3400ac42:	fb00 f303 	mul.w	r3, r0, r3
3400ac46:	440b      	add	r3, r1
3400ac48:	333c      	adds	r3, #60	@ 0x3c
3400ac4a:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400ac4c:	68f8      	ldr	r0, [r7, #12]
3400ac4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ac50:	2434      	movs	r4, #52	@ 0x34
3400ac52:	fb04 f303 	mul.w	r3, r4, r3
3400ac56:	4403      	add	r3, r0
3400ac58:	3338      	adds	r3, #56	@ 0x38
3400ac5a:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ac5c:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400ac5e:	6979      	ldr	r1, [r7, #20]
3400ac60:	fb01 f303 	mul.w	r3, r1, r3
3400ac64:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400ac66:	68f9      	ldr	r1, [r7, #12]
3400ac68:	6809      	ldr	r1, [r1, #0]
3400ac6a:	4608      	mov	r0, r1
3400ac6c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400ac6e:	0209      	lsls	r1, r1, #8
3400ac70:	4401      	add	r1, r0
3400ac72:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400ac76:	4313      	orrs	r3, r2
3400ac78:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3400ac7a:	68fb      	ldr	r3, [r7, #12]
3400ac7c:	681b      	ldr	r3, [r3, #0]
3400ac7e:	461a      	mov	r2, r3
3400ac80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ac82:	021b      	lsls	r3, r3, #8
3400ac84:	4413      	add	r3, r2
3400ac86:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ac8a:	68db      	ldr	r3, [r3, #12]
3400ac8c:	68fa      	ldr	r2, [r7, #12]
3400ac8e:	6812      	ldr	r2, [r2, #0]
3400ac90:	4611      	mov	r1, r2
3400ac92:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ac94:	0212      	lsls	r2, r2, #8
3400ac96:	440a      	add	r2, r1
3400ac98:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400ac9c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400aca0:	f043 0301 	orr.w	r3, r3, #1
3400aca4:	60d3      	str	r3, [r2, #12]
}
3400aca6:	bf00      	nop
3400aca8:	371c      	adds	r7, #28
3400acaa:	46bd      	mov	sp, r7
3400acac:	bcb0      	pop	{r4, r5, r7}
3400acae:	4770      	bx	lr

3400acb0 <LTDC_SetCompositionConfig>:
  *                 - Other layer indices as defined by the hardware and used within the driver.
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
 */
static void LTDC_SetCompositionConfig(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3400acb0:	b480      	push	{r7}
3400acb2:	b087      	sub	sp, #28
3400acb4:	af00      	add	r7, sp, #0
3400acb6:	6078      	str	r0, [r7, #4]
3400acb8:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
3400acba:	687a      	ldr	r2, [r7, #4]
3400acbc:	683b      	ldr	r3, [r7, #0]
3400acbe:	2134      	movs	r1, #52	@ 0x34
3400acc0:	fb01 f303 	mul.w	r3, r1, r3
3400acc4:	4413      	add	r3, r2
3400acc6:	3369      	adds	r3, #105	@ 0x69
3400acc8:	781b      	ldrb	r3, [r3, #0]
3400acca:	021b      	lsls	r3, r3, #8
3400accc:	617b      	str	r3, [r7, #20]
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
3400acce:	687a      	ldr	r2, [r7, #4]
3400acd0:	683b      	ldr	r3, [r7, #0]
3400acd2:	2134      	movs	r1, #52	@ 0x34
3400acd4:	fb01 f303 	mul.w	r3, r1, r3
3400acd8:	4413      	add	r3, r2
3400acda:	336a      	adds	r3, #106	@ 0x6a
3400acdc:	781b      	ldrb	r3, [r3, #0]
3400acde:	041b      	lsls	r3, r3, #16
3400ace0:	613b      	str	r3, [r7, #16]
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
3400ace2:	687a      	ldr	r2, [r7, #4]
3400ace4:	683b      	ldr	r3, [r7, #0]
3400ace6:	2134      	movs	r1, #52	@ 0x34
3400ace8:	fb01 f303 	mul.w	r3, r1, r3
3400acec:	4413      	add	r3, r2
3400acee:	3350      	adds	r3, #80	@ 0x50
3400acf0:	681b      	ldr	r3, [r3, #0]
3400acf2:	061b      	lsls	r3, r3, #24
3400acf4:	60fb      	str	r3, [r7, #12]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3400acf6:	687a      	ldr	r2, [r7, #4]
3400acf8:	683b      	ldr	r3, [r7, #0]
3400acfa:	2134      	movs	r1, #52	@ 0x34
3400acfc:	fb01 f303 	mul.w	r3, r1, r3
3400ad00:	4413      	add	r3, r2
3400ad02:	3368      	adds	r3, #104	@ 0x68
3400ad04:	781b      	ldrb	r3, [r3, #0]
3400ad06:	461a      	mov	r2, r3
3400ad08:	697b      	ldr	r3, [r7, #20]
3400ad0a:	431a      	orrs	r2, r3
3400ad0c:	693b      	ldr	r3, [r7, #16]
3400ad0e:	431a      	orrs	r2, r3
3400ad10:	687b      	ldr	r3, [r7, #4]
3400ad12:	681b      	ldr	r3, [r3, #0]
3400ad14:	4619      	mov	r1, r3
3400ad16:	683b      	ldr	r3, [r7, #0]
3400ad18:	021b      	lsls	r3, r3, #8
3400ad1a:	440b      	add	r3, r1
3400ad1c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ad20:	4619      	mov	r1, r3
3400ad22:	68fb      	ldr	r3, [r7, #12]
3400ad24:	4313      	orrs	r3, r2
3400ad26:	624b      	str	r3, [r1, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
3400ad28:	687b      	ldr	r3, [r7, #4]
3400ad2a:	681b      	ldr	r3, [r3, #0]
3400ad2c:	461a      	mov	r2, r3
3400ad2e:	683b      	ldr	r3, [r7, #0]
3400ad30:	021b      	lsls	r3, r3, #8
3400ad32:	4413      	add	r3, r2
3400ad34:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ad38:	6a1b      	ldr	r3, [r3, #32]
3400ad3a:	687a      	ldr	r2, [r7, #4]
3400ad3c:	6812      	ldr	r2, [r2, #0]
3400ad3e:	4611      	mov	r1, r2
3400ad40:	683a      	ldr	r2, [r7, #0]
3400ad42:	0212      	lsls	r2, r2, #8
3400ad44:	440a      	add	r2, r1
3400ad46:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400ad4a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400ad4e:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
3400ad50:	687b      	ldr	r3, [r7, #4]
3400ad52:	681b      	ldr	r3, [r3, #0]
3400ad54:	461a      	mov	r2, r3
3400ad56:	683b      	ldr	r3, [r7, #0]
3400ad58:	021b      	lsls	r3, r3, #8
3400ad5a:	4413      	add	r3, r2
3400ad5c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ad60:	4618      	mov	r0, r3
3400ad62:	687a      	ldr	r2, [r7, #4]
3400ad64:	683b      	ldr	r3, [r7, #0]
3400ad66:	2134      	movs	r1, #52	@ 0x34
3400ad68:	fb01 f303 	mul.w	r3, r1, r3
3400ad6c:	4413      	add	r3, r2
3400ad6e:	334c      	adds	r3, #76	@ 0x4c
3400ad70:	681b      	ldr	r3, [r3, #0]
3400ad72:	6203      	str	r3, [r0, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
3400ad74:	687b      	ldr	r3, [r7, #4]
3400ad76:	681b      	ldr	r3, [r3, #0]
3400ad78:	461a      	mov	r2, r3
3400ad7a:	683b      	ldr	r3, [r7, #0]
3400ad7c:	021b      	lsls	r3, r3, #8
3400ad7e:	4413      	add	r3, r2
3400ad80:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ad84:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400ad86:	687b      	ldr	r3, [r7, #4]
3400ad88:	681b      	ldr	r3, [r3, #0]
3400ad8a:	4619      	mov	r1, r3
3400ad8c:	683b      	ldr	r3, [r7, #0]
3400ad8e:	021b      	lsls	r3, r3, #8
3400ad90:	440b      	add	r3, r1
3400ad92:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ad96:	4619      	mov	r1, r3
3400ad98:	4b18      	ldr	r3, [pc, #96]	@ (3400adfc <LTDC_SetCompositionConfig+0x14c>)
3400ad9a:	4013      	ands	r3, r2
3400ad9c:	628b      	str	r3, [r1, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
3400ad9e:	687b      	ldr	r3, [r7, #4]
3400ada0:	681b      	ldr	r3, [r3, #0]
3400ada2:	461a      	mov	r2, r3
3400ada4:	683b      	ldr	r3, [r7, #0]
3400ada6:	021b      	lsls	r3, r3, #8
3400ada8:	4413      	add	r3, r2
3400adaa:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400adae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400adb0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400adb4:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400adb6:	687a      	ldr	r2, [r7, #4]
3400adb8:	683b      	ldr	r3, [r7, #0]
3400adba:	2134      	movs	r1, #52	@ 0x34
3400adbc:	fb01 f303 	mul.w	r3, r1, r3
3400adc0:	4413      	add	r3, r2
3400adc2:	3354      	adds	r3, #84	@ 0x54
3400adc4:	681a      	ldr	r2, [r3, #0]
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3400adc6:	6879      	ldr	r1, [r7, #4]
3400adc8:	683b      	ldr	r3, [r7, #0]
3400adca:	2034      	movs	r0, #52	@ 0x34
3400adcc:	fb00 f303 	mul.w	r3, r0, r3
3400add0:	440b      	add	r3, r1
3400add2:	3358      	adds	r3, #88	@ 0x58
3400add4:	681b      	ldr	r3, [r3, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400add6:	431a      	orrs	r2, r3
3400add8:	687b      	ldr	r3, [r7, #4]
3400adda:	681b      	ldr	r3, [r3, #0]
3400addc:	4619      	mov	r1, r3
3400adde:	683b      	ldr	r3, [r7, #0]
3400ade0:	021b      	lsls	r3, r3, #8
3400ade2:	440b      	add	r3, r1
3400ade4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ade8:	4619      	mov	r1, r3
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3400adea:	697b      	ldr	r3, [r7, #20]
3400adec:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400adee:	628b      	str	r3, [r1, #40]	@ 0x28
}
3400adf0:	bf00      	nop
3400adf2:	371c      	adds	r7, #28
3400adf4:	46bd      	mov	sp, r7
3400adf6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400adfa:	4770      	bx	lr
3400adfc:	fffef8f8 	.word	0xfffef8f8

3400ae00 <LTDC_SetPredefFormat>:
  *
  *  @note This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetPredefFormat(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3400ae00:	b480      	push	{r7}
3400ae02:	b08d      	sub	sp, #52	@ 0x34
3400ae04:	af00      	add	r7, sp, #0
3400ae06:	6078      	str	r0, [r7, #4]
3400ae08:	6039      	str	r1, [r7, #0]
  uint32_t PSIZE = 0U;
3400ae0a:	2300      	movs	r3, #0
3400ae0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ALEN = 0U;
3400ae0e:	2300      	movs	r3, #0
3400ae10:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t APOS = 0U;
3400ae12:	2300      	movs	r3, #0
3400ae14:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t RLEN = 0U;
3400ae16:	2300      	movs	r3, #0
3400ae18:	623b      	str	r3, [r7, #32]
  uint32_t RPOS = 0U;
3400ae1a:	2300      	movs	r3, #0
3400ae1c:	61fb      	str	r3, [r7, #28]
  uint32_t BLEN = 0U;
3400ae1e:	2300      	movs	r3, #0
3400ae20:	61bb      	str	r3, [r7, #24]
  uint32_t BPOS = 0U;
3400ae22:	2300      	movs	r3, #0
3400ae24:	617b      	str	r3, [r7, #20]
  uint32_t GLEN = 0U;
3400ae26:	2300      	movs	r3, #0
3400ae28:	613b      	str	r3, [r7, #16]
  uint32_t GPOS = 0U;
3400ae2a:	2300      	movs	r3, #0
3400ae2c:	60fb      	str	r3, [r7, #12]

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400ae2e:	687a      	ldr	r2, [r7, #4]
3400ae30:	683b      	ldr	r3, [r7, #0]
3400ae32:	2134      	movs	r1, #52	@ 0x34
3400ae34:	fb01 f303 	mul.w	r3, r1, r3
3400ae38:	4413      	add	r3, r2
3400ae3a:	3348      	adds	r3, #72	@ 0x48
3400ae3c:	681b      	ldr	r3, [r3, #0]
3400ae3e:	3b07      	subs	r3, #7
3400ae40:	2b04      	cmp	r3, #4
3400ae42:	d86c      	bhi.n	3400af1e <LTDC_SetPredefFormat+0x11e>
3400ae44:	a201      	add	r2, pc, #4	@ (adr r2, 3400ae4c <LTDC_SetPredefFormat+0x4c>)
3400ae46:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400ae4a:	bf00      	nop
3400ae4c:	3400ae61 	.word	0x3400ae61
3400ae50:	3400ae87 	.word	0x3400ae87
3400ae54:	3400aead 	.word	0x3400aead
3400ae58:	3400aed3 	.word	0x3400aed3
3400ae5c:	3400aef9 	.word	0x3400aef9
  {
    case LTDC_PIXEL_FORMAT_ARGB1555:
      PSIZE = 2U;
3400ae60:	2302      	movs	r3, #2
3400ae62:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 1U;
3400ae64:	2301      	movs	r3, #1
3400ae66:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 15U;
3400ae68:	230f      	movs	r3, #15
3400ae6a:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 5U;
3400ae6c:	2305      	movs	r3, #5
3400ae6e:	623b      	str	r3, [r7, #32]
      RPOS = 10U;
3400ae70:	230a      	movs	r3, #10
3400ae72:	61fb      	str	r3, [r7, #28]
      GLEN = 5U;
3400ae74:	2305      	movs	r3, #5
3400ae76:	613b      	str	r3, [r7, #16]
      GPOS = 5U;
3400ae78:	2305      	movs	r3, #5
3400ae7a:	60fb      	str	r3, [r7, #12]
      BLEN = 5U;
3400ae7c:	2305      	movs	r3, #5
3400ae7e:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400ae80:	2300      	movs	r3, #0
3400ae82:	617b      	str	r3, [r7, #20]
      break;
3400ae84:	e04c      	b.n	3400af20 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_ARGB4444:
      PSIZE = 2U;
3400ae86:	2302      	movs	r3, #2
3400ae88:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3400ae8a:	2304      	movs	r3, #4
3400ae8c:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 12U;
3400ae8e:	230c      	movs	r3, #12
3400ae90:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3400ae92:	2304      	movs	r3, #4
3400ae94:	623b      	str	r3, [r7, #32]
      RPOS = 8U;
3400ae96:	2308      	movs	r3, #8
3400ae98:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3400ae9a:	2304      	movs	r3, #4
3400ae9c:	613b      	str	r3, [r7, #16]
      GPOS = 4U;
3400ae9e:	2304      	movs	r3, #4
3400aea0:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3400aea2:	2304      	movs	r3, #4
3400aea4:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400aea6:	2300      	movs	r3, #0
3400aea8:	617b      	str	r3, [r7, #20]
      break;
3400aeaa:	e039      	b.n	3400af20 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_L8:
      PSIZE = 1U;
3400aeac:	2301      	movs	r3, #1
3400aeae:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 0U;
3400aeb0:	2300      	movs	r3, #0
3400aeb2:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 0U;
3400aeb4:	2300      	movs	r3, #0
3400aeb6:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3400aeb8:	2308      	movs	r3, #8
3400aeba:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3400aebc:	2300      	movs	r3, #0
3400aebe:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3400aec0:	2308      	movs	r3, #8
3400aec2:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3400aec4:	2300      	movs	r3, #0
3400aec6:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3400aec8:	2308      	movs	r3, #8
3400aeca:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400aecc:	2300      	movs	r3, #0
3400aece:	617b      	str	r3, [r7, #20]
      break;
3400aed0:	e026      	b.n	3400af20 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL44:
      PSIZE = 1U;
3400aed2:	2301      	movs	r3, #1
3400aed4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3400aed6:	2304      	movs	r3, #4
3400aed8:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 4U;
3400aeda:	2304      	movs	r3, #4
3400aedc:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3400aede:	2304      	movs	r3, #4
3400aee0:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3400aee2:	2300      	movs	r3, #0
3400aee4:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3400aee6:	2304      	movs	r3, #4
3400aee8:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3400aeea:	2300      	movs	r3, #0
3400aeec:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3400aeee:	2304      	movs	r3, #4
3400aef0:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400aef2:	2300      	movs	r3, #0
3400aef4:	617b      	str	r3, [r7, #20]
      break;
3400aef6:	e013      	b.n	3400af20 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL88:
      PSIZE = 2U;
3400aef8:	2302      	movs	r3, #2
3400aefa:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 8U;
3400aefc:	2308      	movs	r3, #8
3400aefe:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 8U;
3400af00:	2308      	movs	r3, #8
3400af02:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3400af04:	2308      	movs	r3, #8
3400af06:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3400af08:	2300      	movs	r3, #0
3400af0a:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3400af0c:	2308      	movs	r3, #8
3400af0e:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3400af10:	2300      	movs	r3, #0
3400af12:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3400af14:	2308      	movs	r3, #8
3400af16:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400af18:	2300      	movs	r3, #0
3400af1a:	617b      	str	r3, [r7, #20]
      break;
3400af1c:	e000      	b.n	3400af20 <LTDC_SetPredefFormat+0x120>
    default:
      break;
3400af1e:	bf00      	nop
  }

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400af20:	687a      	ldr	r2, [r7, #4]
3400af22:	683b      	ldr	r3, [r7, #0]
3400af24:	2134      	movs	r1, #52	@ 0x34
3400af26:	fb01 f303 	mul.w	r3, r1, r3
3400af2a:	4413      	add	r3, r2
3400af2c:	3348      	adds	r3, #72	@ 0x48
3400af2e:	681b      	ldr	r3, [r3, #0]
3400af30:	2b06      	cmp	r3, #6
3400af32:	d903      	bls.n	3400af3c <LTDC_SetPredefFormat+0x13c>
3400af34:	3b07      	subs	r3, #7
3400af36:	2b04      	cmp	r3, #4
3400af38:	d860      	bhi.n	3400affc <LTDC_SetPredefFormat+0x1fc>
3400af3a:	e028      	b.n	3400af8e <LTDC_SetPredefFormat+0x18e>
    case LTDC_PIXEL_FORMAT_RGBA8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_RGB565:
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_RGB888:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
3400af3c:	687b      	ldr	r3, [r7, #4]
3400af3e:	681b      	ldr	r3, [r3, #0]
3400af40:	461a      	mov	r2, r3
3400af42:	683b      	ldr	r3, [r7, #0]
3400af44:	021b      	lsls	r3, r3, #8
3400af46:	4413      	add	r3, r2
3400af48:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400af4c:	4618      	mov	r0, r3
3400af4e:	687a      	ldr	r2, [r7, #4]
3400af50:	683b      	ldr	r3, [r7, #0]
3400af52:	2134      	movs	r1, #52	@ 0x34
3400af54:	fb01 f303 	mul.w	r3, r1, r3
3400af58:	4413      	add	r3, r2
3400af5a:	3348      	adds	r3, #72	@ 0x48
3400af5c:	681b      	ldr	r3, [r3, #0]
3400af5e:	61c3      	str	r3, [r0, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
3400af60:	687b      	ldr	r3, [r7, #4]
3400af62:	681b      	ldr	r3, [r3, #0]
3400af64:	461a      	mov	r2, r3
3400af66:	683b      	ldr	r3, [r7, #0]
3400af68:	021b      	lsls	r3, r3, #8
3400af6a:	4413      	add	r3, r2
3400af6c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400af70:	461a      	mov	r2, r3
3400af72:	2300      	movs	r3, #0
3400af74:	6753      	str	r3, [r2, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
3400af76:	687b      	ldr	r3, [r7, #4]
3400af78:	681b      	ldr	r3, [r3, #0]
3400af7a:	461a      	mov	r2, r3
3400af7c:	683b      	ldr	r3, [r7, #0]
3400af7e:	021b      	lsls	r3, r3, #8
3400af80:	4413      	add	r3, r2
3400af82:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400af86:	461a      	mov	r2, r3
3400af88:	2300      	movs	r3, #0
3400af8a:	6793      	str	r3, [r2, #120]	@ 0x78
      break;
3400af8c:	e037      	b.n	3400affe <LTDC_SetPredefFormat+0x1fe>
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_AL88:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
3400af8e:	687b      	ldr	r3, [r7, #4]
3400af90:	681b      	ldr	r3, [r3, #0]
3400af92:	461a      	mov	r2, r3
3400af94:	683b      	ldr	r3, [r7, #0]
3400af96:	021b      	lsls	r3, r3, #8
3400af98:	4413      	add	r3, r2
3400af9a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400af9e:	461a      	mov	r2, r3
3400afa0:	2307      	movs	r3, #7
3400afa2:	61d3      	str	r3, [r2, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400afa4:	6a3b      	ldr	r3, [r7, #32]
3400afa6:	039a      	lsls	r2, r3, #14
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3400afa8:	69fb      	ldr	r3, [r7, #28]
3400afaa:	025b      	lsls	r3, r3, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400afac:	441a      	add	r2, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3400afae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400afb0:	015b      	lsls	r3, r3, #5
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3400afb2:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400afb4:	687b      	ldr	r3, [r7, #4]
3400afb6:	681b      	ldr	r3, [r3, #0]
3400afb8:	4619      	mov	r1, r3
3400afba:	683b      	ldr	r3, [r7, #0]
3400afbc:	021b      	lsls	r3, r3, #8
3400afbe:	440b      	add	r3, r1
3400afc0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400afc4:	4619      	mov	r1, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3400afc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400afc8:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400afca:	674b      	str	r3, [r1, #116]	@ 0x74
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400afcc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400afce:	049a      	lsls	r2, r3, #18
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3400afd0:	69bb      	ldr	r3, [r7, #24]
3400afd2:	039b      	lsls	r3, r3, #14
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400afd4:	441a      	add	r2, r3
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3400afd6:	697b      	ldr	r3, [r7, #20]
3400afd8:	025b      	lsls	r3, r3, #9
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3400afda:	441a      	add	r2, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400afdc:	693b      	ldr	r3, [r7, #16]
3400afde:	015b      	lsls	r3, r3, #5
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3400afe0:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400afe2:	687b      	ldr	r3, [r7, #4]
3400afe4:	681b      	ldr	r3, [r3, #0]
3400afe6:	4619      	mov	r1, r3
3400afe8:	683b      	ldr	r3, [r7, #0]
3400afea:	021b      	lsls	r3, r3, #8
3400afec:	440b      	add	r3, r1
3400afee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400aff2:	4619      	mov	r1, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400aff4:	68fb      	ldr	r3, [r7, #12]
3400aff6:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400aff8:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
3400affa:	e000      	b.n	3400affe <LTDC_SetPredefFormat+0x1fe>
    default:
      break;
3400affc:	bf00      	nop
  }
}
3400affe:	bf00      	nop
3400b000:	3734      	adds	r7, #52	@ 0x34
3400b002:	46bd      	mov	sp, r7
3400b004:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b008:	4770      	bx	lr
3400b00a:	bf00      	nop

3400b00c <HAL_PWREx_ConfigVddIORange>:
  * @note   Setting this configuration while VDDIOx is in 3v3 range
  *         damages the device.
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
3400b00c:	b580      	push	{r7, lr}
3400b00e:	b082      	sub	sp, #8
3400b010:	af00      	add	r7, sp, #0
3400b012:	6078      	str	r0, [r7, #4]
3400b014:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
3400b016:	687b      	ldr	r3, [r7, #4]
3400b018:	2b00      	cmp	r3, #0
3400b01a:	d010      	beq.n	3400b03e <HAL_PWREx_ConfigVddIORange+0x32>
3400b01c:	687b      	ldr	r3, [r7, #4]
3400b01e:	2b01      	cmp	r3, #1
3400b020:	d00d      	beq.n	3400b03e <HAL_PWREx_ConfigVddIORange+0x32>
3400b022:	687b      	ldr	r3, [r7, #4]
3400b024:	2b02      	cmp	r3, #2
3400b026:	d00a      	beq.n	3400b03e <HAL_PWREx_ConfigVddIORange+0x32>
3400b028:	687b      	ldr	r3, [r7, #4]
3400b02a:	2b03      	cmp	r3, #3
3400b02c:	d007      	beq.n	3400b03e <HAL_PWREx_ConfigVddIORange+0x32>
3400b02e:	687b      	ldr	r3, [r7, #4]
3400b030:	2b04      	cmp	r3, #4
3400b032:	d004      	beq.n	3400b03e <HAL_PWREx_ConfigVddIORange+0x32>
3400b034:	f240 316a 	movw	r1, #874	@ 0x36a
3400b038:	482a      	ldr	r0, [pc, #168]	@ (3400b0e4 <HAL_PWREx_ConfigVddIORange+0xd8>)
3400b03a:	f7f6 f92d 	bl	34001298 <assert_failed>
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
3400b03e:	683b      	ldr	r3, [r7, #0]
3400b040:	2b00      	cmp	r3, #0
3400b042:	d007      	beq.n	3400b054 <HAL_PWREx_ConfigVddIORange+0x48>
3400b044:	683b      	ldr	r3, [r7, #0]
3400b046:	2b01      	cmp	r3, #1
3400b048:	d004      	beq.n	3400b054 <HAL_PWREx_ConfigVddIORange+0x48>
3400b04a:	f240 316b 	movw	r1, #875	@ 0x36b
3400b04e:	4825      	ldr	r0, [pc, #148]	@ (3400b0e4 <HAL_PWREx_ConfigVddIORange+0xd8>)
3400b050:	f7f6 f922 	bl	34001298 <assert_failed>

  switch (VddIOPort)
3400b054:	687b      	ldr	r3, [r7, #4]
3400b056:	2b04      	cmp	r3, #4
3400b058:	d83e      	bhi.n	3400b0d8 <HAL_PWREx_ConfigVddIORange+0xcc>
3400b05a:	a201      	add	r2, pc, #4	@ (adr r2, 3400b060 <HAL_PWREx_ConfigVddIORange+0x54>)
3400b05c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400b060:	3400b075 	.word	0x3400b075
3400b064:	3400b089 	.word	0x3400b089
3400b068:	3400b09d 	.word	0x3400b09d
3400b06c:	3400b0b1 	.word	0x3400b0b1
3400b070:	3400b0c5 	.word	0x3400b0c5
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
3400b074:	4b1c      	ldr	r3, [pc, #112]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b076:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b078:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400b07c:	683b      	ldr	r3, [r7, #0]
3400b07e:	061b      	lsls	r3, r3, #24
3400b080:	4919      	ldr	r1, [pc, #100]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b082:	4313      	orrs	r3, r2
3400b084:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3400b086:	e028      	b.n	3400b0da <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
3400b088:	4b17      	ldr	r3, [pc, #92]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b08a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b08c:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
3400b090:	683b      	ldr	r3, [r7, #0]
3400b092:	065b      	lsls	r3, r3, #25
3400b094:	4914      	ldr	r1, [pc, #80]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b096:	4313      	orrs	r3, r2
3400b098:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3400b09a:	e01e      	b.n	3400b0da <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
3400b09c:	4b12      	ldr	r3, [pc, #72]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b09e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b0a0:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
3400b0a4:	683b      	ldr	r3, [r7, #0]
3400b0a6:	069b      	lsls	r3, r3, #26
3400b0a8:	490f      	ldr	r1, [pc, #60]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b0aa:	4313      	orrs	r3, r2
3400b0ac:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3400b0ae:	e014      	b.n	3400b0da <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
3400b0b0:	4b0d      	ldr	r3, [pc, #52]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b0b2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400b0b4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400b0b8:	683b      	ldr	r3, [r7, #0]
3400b0ba:	061b      	lsls	r3, r3, #24
3400b0bc:	490a      	ldr	r1, [pc, #40]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b0be:	4313      	orrs	r3, r2
3400b0c0:	634b      	str	r3, [r1, #52]	@ 0x34
      break;
3400b0c2:	e00a      	b.n	3400b0da <HAL_PWREx_ConfigVddIORange+0xce>

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3400b0c4:	4b08      	ldr	r3, [pc, #32]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b0c6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400b0c8:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400b0cc:	683b      	ldr	r3, [r7, #0]
3400b0ce:	061b      	lsls	r3, r3, #24
3400b0d0:	4905      	ldr	r1, [pc, #20]	@ (3400b0e8 <HAL_PWREx_ConfigVddIORange+0xdc>)
3400b0d2:	4313      	orrs	r3, r2
3400b0d4:	638b      	str	r3, [r1, #56]	@ 0x38
      break;
3400b0d6:	e000      	b.n	3400b0da <HAL_PWREx_ConfigVddIORange+0xce>

    default:
      break;
3400b0d8:	bf00      	nop
  }
}
3400b0da:	bf00      	nop
3400b0dc:	3708      	adds	r7, #8
3400b0de:	46bd      	mov	sp, r7
3400b0e0:	bd80      	pop	{r7, pc}
3400b0e2:	bf00      	nop
3400b0e4:	340242f4 	.word	0x340242f4
3400b0e8:	56024800 	.word	0x56024800

3400b0ec <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
3400b0ec:	b480      	push	{r7}
3400b0ee:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
3400b0f0:	4b05      	ldr	r3, [pc, #20]	@ (3400b108 <HAL_PWREx_EnableVddIO2+0x1c>)
3400b0f2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b0f4:	4a04      	ldr	r2, [pc, #16]	@ (3400b108 <HAL_PWREx_EnableVddIO2+0x1c>)
3400b0f6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400b0fa:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400b0fc:	bf00      	nop
3400b0fe:	46bd      	mov	sp, r7
3400b100:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b104:	4770      	bx	lr
3400b106:	bf00      	nop
3400b108:	56024800 	.word	0x56024800

3400b10c <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
3400b10c:	b480      	push	{r7}
3400b10e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
3400b110:	4b05      	ldr	r3, [pc, #20]	@ (3400b128 <HAL_PWREx_EnableVddIO3+0x1c>)
3400b112:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b114:	4a04      	ldr	r2, [pc, #16]	@ (3400b128 <HAL_PWREx_EnableVddIO3+0x1c>)
3400b116:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400b11a:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400b11c:	bf00      	nop
3400b11e:	46bd      	mov	sp, r7
3400b120:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b124:	4770      	bx	lr
3400b126:	bf00      	nop
3400b128:	56024800 	.word	0x56024800

3400b12c <HAL_RAMCFG_EnableAXISRAM>:
  *                   contains the configuration information for the
  *                   specified RAMCFG instance.
  * @retval None.
  */
void HAL_RAMCFG_EnableAXISRAM(const RAMCFG_HandleTypeDef *hramcfg)
{
3400b12c:	b580      	push	{r7, lr}
3400b12e:	b082      	sub	sp, #8
3400b130:	af00      	add	r7, sp, #0
3400b132:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
3400b134:	687b      	ldr	r3, [r7, #4]
3400b136:	681b      	ldr	r3, [r3, #0]
3400b138:	4a20      	ldr	r2, [pc, #128]	@ (3400b1bc <HAL_RAMCFG_EnableAXISRAM+0x90>)
3400b13a:	4293      	cmp	r3, r2
3400b13c:	d031      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b13e:	687b      	ldr	r3, [r7, #4]
3400b140:	681b      	ldr	r3, [r3, #0]
3400b142:	4a1f      	ldr	r2, [pc, #124]	@ (3400b1c0 <HAL_RAMCFG_EnableAXISRAM+0x94>)
3400b144:	4293      	cmp	r3, r2
3400b146:	d02c      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b148:	687b      	ldr	r3, [r7, #4]
3400b14a:	681b      	ldr	r3, [r3, #0]
3400b14c:	4a1d      	ldr	r2, [pc, #116]	@ (3400b1c4 <HAL_RAMCFG_EnableAXISRAM+0x98>)
3400b14e:	4293      	cmp	r3, r2
3400b150:	d027      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b152:	687b      	ldr	r3, [r7, #4]
3400b154:	681b      	ldr	r3, [r3, #0]
3400b156:	4a1c      	ldr	r2, [pc, #112]	@ (3400b1c8 <HAL_RAMCFG_EnableAXISRAM+0x9c>)
3400b158:	4293      	cmp	r3, r2
3400b15a:	d022      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b15c:	687b      	ldr	r3, [r7, #4]
3400b15e:	681b      	ldr	r3, [r3, #0]
3400b160:	4a1a      	ldr	r2, [pc, #104]	@ (3400b1cc <HAL_RAMCFG_EnableAXISRAM+0xa0>)
3400b162:	4293      	cmp	r3, r2
3400b164:	d01d      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b166:	687b      	ldr	r3, [r7, #4]
3400b168:	681b      	ldr	r3, [r3, #0]
3400b16a:	4a19      	ldr	r2, [pc, #100]	@ (3400b1d0 <HAL_RAMCFG_EnableAXISRAM+0xa4>)
3400b16c:	4293      	cmp	r3, r2
3400b16e:	d018      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b170:	687b      	ldr	r3, [r7, #4]
3400b172:	681b      	ldr	r3, [r3, #0]
3400b174:	4a17      	ldr	r2, [pc, #92]	@ (3400b1d4 <HAL_RAMCFG_EnableAXISRAM+0xa8>)
3400b176:	4293      	cmp	r3, r2
3400b178:	d013      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b17a:	687b      	ldr	r3, [r7, #4]
3400b17c:	681b      	ldr	r3, [r3, #0]
3400b17e:	4a16      	ldr	r2, [pc, #88]	@ (3400b1d8 <HAL_RAMCFG_EnableAXISRAM+0xac>)
3400b180:	4293      	cmp	r3, r2
3400b182:	d00e      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b184:	687b      	ldr	r3, [r7, #4]
3400b186:	681b      	ldr	r3, [r3, #0]
3400b188:	4a14      	ldr	r2, [pc, #80]	@ (3400b1dc <HAL_RAMCFG_EnableAXISRAM+0xb0>)
3400b18a:	4293      	cmp	r3, r2
3400b18c:	d009      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b18e:	687b      	ldr	r3, [r7, #4]
3400b190:	681b      	ldr	r3, [r3, #0]
3400b192:	4a13      	ldr	r2, [pc, #76]	@ (3400b1e0 <HAL_RAMCFG_EnableAXISRAM+0xb4>)
3400b194:	4293      	cmp	r3, r2
3400b196:	d004      	beq.n	3400b1a2 <HAL_RAMCFG_EnableAXISRAM+0x76>
3400b198:	f240 4107 	movw	r1, #1031	@ 0x407
3400b19c:	4811      	ldr	r0, [pc, #68]	@ (3400b1e4 <HAL_RAMCFG_EnableAXISRAM+0xb8>)
3400b19e:	f7f6 f87b 	bl	34001298 <assert_failed>

  /* AXISRAMi power on */
  CLEAR_BIT(hramcfg->Instance->CR, RAMCFG_AXISRAM_POWERDOWN);
3400b1a2:	687b      	ldr	r3, [r7, #4]
3400b1a4:	681b      	ldr	r3, [r3, #0]
3400b1a6:	681a      	ldr	r2, [r3, #0]
3400b1a8:	687b      	ldr	r3, [r7, #4]
3400b1aa:	681b      	ldr	r3, [r3, #0]
3400b1ac:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
3400b1b0:	601a      	str	r2, [r3, #0]
}
3400b1b2:	bf00      	nop
3400b1b4:	3708      	adds	r7, #8
3400b1b6:	46bd      	mov	sp, r7
3400b1b8:	bd80      	pop	{r7, pc}
3400b1ba:	bf00      	nop
3400b1bc:	52023080 	.word	0x52023080
3400b1c0:	42023080 	.word	0x42023080
3400b1c4:	52023100 	.word	0x52023100
3400b1c8:	42023100 	.word	0x42023100
3400b1cc:	52023180 	.word	0x52023180
3400b1d0:	42023180 	.word	0x42023180
3400b1d4:	52023200 	.word	0x52023200
3400b1d8:	42023200 	.word	0x42023200
3400b1dc:	52023280 	.word	0x52023280
3400b1e0:	42023280 	.word	0x42023280
3400b1e4:	34024368 	.word	0x34024368

3400b1e8 <LL_RCC_HSE_IsReady>:
{
3400b1e8:	b480      	push	{r7}
3400b1ea:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400b1ec:	4b06      	ldr	r3, [pc, #24]	@ (3400b208 <LL_RCC_HSE_IsReady+0x20>)
3400b1ee:	685b      	ldr	r3, [r3, #4]
3400b1f0:	f003 0310 	and.w	r3, r3, #16
3400b1f4:	2b00      	cmp	r3, #0
3400b1f6:	d001      	beq.n	3400b1fc <LL_RCC_HSE_IsReady+0x14>
3400b1f8:	2301      	movs	r3, #1
3400b1fa:	e000      	b.n	3400b1fe <LL_RCC_HSE_IsReady+0x16>
3400b1fc:	2300      	movs	r3, #0
}
3400b1fe:	4618      	mov	r0, r3
3400b200:	46bd      	mov	sp, r7
3400b202:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b206:	4770      	bx	lr
3400b208:	56028000 	.word	0x56028000

3400b20c <LL_RCC_HSI_Enable>:
{
3400b20c:	b480      	push	{r7}
3400b20e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3400b210:	4b04      	ldr	r3, [pc, #16]	@ (3400b224 <LL_RCC_HSI_Enable+0x18>)
3400b212:	2208      	movs	r2, #8
3400b214:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3400b218:	bf00      	nop
3400b21a:	46bd      	mov	sp, r7
3400b21c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b220:	4770      	bx	lr
3400b222:	bf00      	nop
3400b224:	56028000 	.word	0x56028000

3400b228 <LL_RCC_HSI_Disable>:
{
3400b228:	b480      	push	{r7}
3400b22a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
3400b22c:	4b05      	ldr	r3, [pc, #20]	@ (3400b244 <LL_RCC_HSI_Disable+0x1c>)
3400b22e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400b232:	461a      	mov	r2, r3
3400b234:	2308      	movs	r3, #8
3400b236:	6013      	str	r3, [r2, #0]
}
3400b238:	bf00      	nop
3400b23a:	46bd      	mov	sp, r7
3400b23c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b240:	4770      	bx	lr
3400b242:	bf00      	nop
3400b244:	56028000 	.word	0x56028000

3400b248 <LL_RCC_HSI_IsReady>:
{
3400b248:	b480      	push	{r7}
3400b24a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400b24c:	4b06      	ldr	r3, [pc, #24]	@ (3400b268 <LL_RCC_HSI_IsReady+0x20>)
3400b24e:	685b      	ldr	r3, [r3, #4]
3400b250:	f003 0308 	and.w	r3, r3, #8
3400b254:	2b00      	cmp	r3, #0
3400b256:	d001      	beq.n	3400b25c <LL_RCC_HSI_IsReady+0x14>
3400b258:	2301      	movs	r3, #1
3400b25a:	e000      	b.n	3400b25e <LL_RCC_HSI_IsReady+0x16>
3400b25c:	2300      	movs	r3, #0
}
3400b25e:	4618      	mov	r0, r3
3400b260:	46bd      	mov	sp, r7
3400b262:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b266:	4770      	bx	lr
3400b268:	56028000 	.word	0x56028000

3400b26c <LL_RCC_HSI_SetDivider>:
{
3400b26c:	b480      	push	{r7}
3400b26e:	b083      	sub	sp, #12
3400b270:	af00      	add	r7, sp, #0
3400b272:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
3400b274:	4b06      	ldr	r3, [pc, #24]	@ (3400b290 <LL_RCC_HSI_SetDivider+0x24>)
3400b276:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400b278:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
3400b27c:	4904      	ldr	r1, [pc, #16]	@ (3400b290 <LL_RCC_HSI_SetDivider+0x24>)
3400b27e:	687b      	ldr	r3, [r7, #4]
3400b280:	4313      	orrs	r3, r2
3400b282:	648b      	str	r3, [r1, #72]	@ 0x48
}
3400b284:	bf00      	nop
3400b286:	370c      	adds	r7, #12
3400b288:	46bd      	mov	sp, r7
3400b28a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b28e:	4770      	bx	lr
3400b290:	56028000 	.word	0x56028000

3400b294 <LL_RCC_HSI_GetDivider>:
{
3400b294:	b480      	push	{r7}
3400b296:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400b298:	4b04      	ldr	r3, [pc, #16]	@ (3400b2ac <LL_RCC_HSI_GetDivider+0x18>)
3400b29a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400b29c:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3400b2a0:	4618      	mov	r0, r3
3400b2a2:	46bd      	mov	sp, r7
3400b2a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b2a8:	4770      	bx	lr
3400b2aa:	bf00      	nop
3400b2ac:	56028000 	.word	0x56028000

3400b2b0 <LL_RCC_HSI_SetCalibTrimming>:
{
3400b2b0:	b480      	push	{r7}
3400b2b2:	b083      	sub	sp, #12
3400b2b4:	af00      	add	r7, sp, #0
3400b2b6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
3400b2b8:	4b07      	ldr	r3, [pc, #28]	@ (3400b2d8 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3400b2ba:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400b2bc:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
3400b2c0:	687b      	ldr	r3, [r7, #4]
3400b2c2:	041b      	lsls	r3, r3, #16
3400b2c4:	4904      	ldr	r1, [pc, #16]	@ (3400b2d8 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3400b2c6:	4313      	orrs	r3, r2
3400b2c8:	648b      	str	r3, [r1, #72]	@ 0x48
}
3400b2ca:	bf00      	nop
3400b2cc:	370c      	adds	r7, #12
3400b2ce:	46bd      	mov	sp, r7
3400b2d0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b2d4:	4770      	bx	lr
3400b2d6:	bf00      	nop
3400b2d8:	56028000 	.word	0x56028000

3400b2dc <LL_RCC_MSI_Enable>:
{
3400b2dc:	b480      	push	{r7}
3400b2de:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3400b2e0:	4b04      	ldr	r3, [pc, #16]	@ (3400b2f4 <LL_RCC_MSI_Enable+0x18>)
3400b2e2:	2204      	movs	r2, #4
3400b2e4:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3400b2e8:	bf00      	nop
3400b2ea:	46bd      	mov	sp, r7
3400b2ec:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b2f0:	4770      	bx	lr
3400b2f2:	bf00      	nop
3400b2f4:	56028000 	.word	0x56028000

3400b2f8 <LL_RCC_MSI_Disable>:
{
3400b2f8:	b480      	push	{r7}
3400b2fa:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
3400b2fc:	4b05      	ldr	r3, [pc, #20]	@ (3400b314 <LL_RCC_MSI_Disable+0x1c>)
3400b2fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400b302:	461a      	mov	r2, r3
3400b304:	2304      	movs	r3, #4
3400b306:	6013      	str	r3, [r2, #0]
}
3400b308:	bf00      	nop
3400b30a:	46bd      	mov	sp, r7
3400b30c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b310:	4770      	bx	lr
3400b312:	bf00      	nop
3400b314:	56028000 	.word	0x56028000

3400b318 <LL_RCC_MSI_IsReady>:
{
3400b318:	b480      	push	{r7}
3400b31a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400b31c:	4b06      	ldr	r3, [pc, #24]	@ (3400b338 <LL_RCC_MSI_IsReady+0x20>)
3400b31e:	685b      	ldr	r3, [r3, #4]
3400b320:	f003 0304 	and.w	r3, r3, #4
3400b324:	2b00      	cmp	r3, #0
3400b326:	d001      	beq.n	3400b32c <LL_RCC_MSI_IsReady+0x14>
3400b328:	2301      	movs	r3, #1
3400b32a:	e000      	b.n	3400b32e <LL_RCC_MSI_IsReady+0x16>
3400b32c:	2300      	movs	r3, #0
}
3400b32e:	4618      	mov	r0, r3
3400b330:	46bd      	mov	sp, r7
3400b332:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b336:	4770      	bx	lr
3400b338:	56028000 	.word	0x56028000

3400b33c <LL_RCC_MSI_SetFrequency>:
{
3400b33c:	b480      	push	{r7}
3400b33e:	b083      	sub	sp, #12
3400b340:	af00      	add	r7, sp, #0
3400b342:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
3400b344:	4b06      	ldr	r3, [pc, #24]	@ (3400b360 <LL_RCC_MSI_SetFrequency+0x24>)
3400b346:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400b348:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400b34c:	4904      	ldr	r1, [pc, #16]	@ (3400b360 <LL_RCC_MSI_SetFrequency+0x24>)
3400b34e:	687b      	ldr	r3, [r7, #4]
3400b350:	4313      	orrs	r3, r2
3400b352:	644b      	str	r3, [r1, #68]	@ 0x44
}
3400b354:	bf00      	nop
3400b356:	370c      	adds	r7, #12
3400b358:	46bd      	mov	sp, r7
3400b35a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b35e:	4770      	bx	lr
3400b360:	56028000 	.word	0x56028000

3400b364 <LL_RCC_MSI_GetFrequency>:
{
3400b364:	b480      	push	{r7}
3400b366:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400b368:	4b04      	ldr	r3, [pc, #16]	@ (3400b37c <LL_RCC_MSI_GetFrequency+0x18>)
3400b36a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400b36c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3400b370:	4618      	mov	r0, r3
3400b372:	46bd      	mov	sp, r7
3400b374:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b378:	4770      	bx	lr
3400b37a:	bf00      	nop
3400b37c:	56028000 	.word	0x56028000

3400b380 <LL_RCC_MSI_SetCalibTrimming>:
{
3400b380:	b480      	push	{r7}
3400b382:	b083      	sub	sp, #12
3400b384:	af00      	add	r7, sp, #0
3400b386:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
3400b388:	4b07      	ldr	r3, [pc, #28]	@ (3400b3a8 <LL_RCC_MSI_SetCalibTrimming+0x28>)
3400b38a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400b38c:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
3400b390:	687b      	ldr	r3, [r7, #4]
3400b392:	041b      	lsls	r3, r3, #16
3400b394:	4904      	ldr	r1, [pc, #16]	@ (3400b3a8 <LL_RCC_MSI_SetCalibTrimming+0x28>)
3400b396:	4313      	orrs	r3, r2
3400b398:	644b      	str	r3, [r1, #68]	@ 0x44
}
3400b39a:	bf00      	nop
3400b39c:	370c      	adds	r7, #12
3400b39e:	46bd      	mov	sp, r7
3400b3a0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b3a4:	4770      	bx	lr
3400b3a6:	bf00      	nop
3400b3a8:	56028000 	.word	0x56028000

3400b3ac <LL_RCC_LSE_IsReady>:
{
3400b3ac:	b480      	push	{r7}
3400b3ae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400b3b0:	4b06      	ldr	r3, [pc, #24]	@ (3400b3cc <LL_RCC_LSE_IsReady+0x20>)
3400b3b2:	685b      	ldr	r3, [r3, #4]
3400b3b4:	f003 0302 	and.w	r3, r3, #2
3400b3b8:	2b00      	cmp	r3, #0
3400b3ba:	d001      	beq.n	3400b3c0 <LL_RCC_LSE_IsReady+0x14>
3400b3bc:	2301      	movs	r3, #1
3400b3be:	e000      	b.n	3400b3c2 <LL_RCC_LSE_IsReady+0x16>
3400b3c0:	2300      	movs	r3, #0
}
3400b3c2:	4618      	mov	r0, r3
3400b3c4:	46bd      	mov	sp, r7
3400b3c6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b3ca:	4770      	bx	lr
3400b3cc:	56028000 	.word	0x56028000

3400b3d0 <LL_RCC_LSI_Enable>:
{
3400b3d0:	b480      	push	{r7}
3400b3d2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
3400b3d4:	4b04      	ldr	r3, [pc, #16]	@ (3400b3e8 <LL_RCC_LSI_Enable+0x18>)
3400b3d6:	2201      	movs	r2, #1
3400b3d8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3400b3dc:	bf00      	nop
3400b3de:	46bd      	mov	sp, r7
3400b3e0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b3e4:	4770      	bx	lr
3400b3e6:	bf00      	nop
3400b3e8:	56028000 	.word	0x56028000

3400b3ec <LL_RCC_LSI_Disable>:
{
3400b3ec:	b480      	push	{r7}
3400b3ee:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
3400b3f0:	4b05      	ldr	r3, [pc, #20]	@ (3400b408 <LL_RCC_LSI_Disable+0x1c>)
3400b3f2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400b3f6:	461a      	mov	r2, r3
3400b3f8:	2301      	movs	r3, #1
3400b3fa:	6013      	str	r3, [r2, #0]
}
3400b3fc:	bf00      	nop
3400b3fe:	46bd      	mov	sp, r7
3400b400:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b404:	4770      	bx	lr
3400b406:	bf00      	nop
3400b408:	56028000 	.word	0x56028000

3400b40c <LL_RCC_LSI_IsReady>:
{
3400b40c:	b480      	push	{r7}
3400b40e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400b410:	4b04      	ldr	r3, [pc, #16]	@ (3400b424 <LL_RCC_LSI_IsReady+0x18>)
3400b412:	685b      	ldr	r3, [r3, #4]
3400b414:	f003 0301 	and.w	r3, r3, #1
}
3400b418:	4618      	mov	r0, r3
3400b41a:	46bd      	mov	sp, r7
3400b41c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b420:	4770      	bx	lr
3400b422:	bf00      	nop
3400b424:	56028000 	.word	0x56028000

3400b428 <LL_RCC_GetCpuClkSource>:
{
3400b428:	b480      	push	{r7}
3400b42a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
3400b42c:	4b04      	ldr	r3, [pc, #16]	@ (3400b440 <LL_RCC_GetCpuClkSource+0x18>)
3400b42e:	6a1b      	ldr	r3, [r3, #32]
3400b430:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3400b434:	4618      	mov	r0, r3
3400b436:	46bd      	mov	sp, r7
3400b438:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b43c:	4770      	bx	lr
3400b43e:	bf00      	nop
3400b440:	56028000 	.word	0x56028000

3400b444 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
3400b444:	b480      	push	{r7}
3400b446:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3400b448:	4b04      	ldr	r3, [pc, #16]	@ (3400b45c <LL_RCC_GetSysClkSource+0x18>)
3400b44a:	6a1b      	ldr	r3, [r3, #32]
3400b44c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400b450:	4618      	mov	r0, r3
3400b452:	46bd      	mov	sp, r7
3400b454:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b458:	4770      	bx	lr
3400b45a:	bf00      	nop
3400b45c:	56028000 	.word	0x56028000

3400b460 <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
3400b460:	b480      	push	{r7}
3400b462:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400b464:	4b04      	ldr	r3, [pc, #16]	@ (3400b478 <LL_RCC_PLL1_GetSource+0x18>)
3400b466:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400b46a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400b46e:	4618      	mov	r0, r3
3400b470:	46bd      	mov	sp, r7
3400b472:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b476:	4770      	bx	lr
3400b478:	56028000 	.word	0x56028000

3400b47c <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
3400b47c:	b480      	push	{r7}
3400b47e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400b480:	4b07      	ldr	r3, [pc, #28]	@ (3400b4a0 <LL_RCC_PLL1_IsReady+0x24>)
3400b482:	685b      	ldr	r3, [r3, #4]
3400b484:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400b488:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b48c:	d101      	bne.n	3400b492 <LL_RCC_PLL1_IsReady+0x16>
3400b48e:	2301      	movs	r3, #1
3400b490:	e000      	b.n	3400b494 <LL_RCC_PLL1_IsReady+0x18>
3400b492:	2300      	movs	r3, #0
}
3400b494:	4618      	mov	r0, r3
3400b496:	46bd      	mov	sp, r7
3400b498:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b49c:	4770      	bx	lr
3400b49e:	bf00      	nop
3400b4a0:	56028000 	.word	0x56028000

3400b4a4 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
3400b4a4:	b480      	push	{r7}
3400b4a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400b4a8:	4b07      	ldr	r3, [pc, #28]	@ (3400b4c8 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3400b4aa:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400b4ae:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400b4b2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400b4b6:	d101      	bne.n	3400b4bc <LL_RCC_PLL1_IsEnabledBypass+0x18>
3400b4b8:	2301      	movs	r3, #1
3400b4ba:	e000      	b.n	3400b4be <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3400b4bc:	2300      	movs	r3, #0
}
3400b4be:	4618      	mov	r0, r3
3400b4c0:	46bd      	mov	sp, r7
3400b4c2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b4c6:	4770      	bx	lr
3400b4c8:	56028000 	.word	0x56028000

3400b4cc <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
3400b4cc:	b480      	push	{r7}
3400b4ce:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400b4d0:	4b04      	ldr	r3, [pc, #16]	@ (3400b4e4 <LL_RCC_PLL2_GetSource+0x18>)
3400b4d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400b4d6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400b4da:	4618      	mov	r0, r3
3400b4dc:	46bd      	mov	sp, r7
3400b4de:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b4e2:	4770      	bx	lr
3400b4e4:	56028000 	.word	0x56028000

3400b4e8 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
3400b4e8:	b480      	push	{r7}
3400b4ea:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400b4ec:	4b07      	ldr	r3, [pc, #28]	@ (3400b50c <LL_RCC_PLL2_IsReady+0x24>)
3400b4ee:	685b      	ldr	r3, [r3, #4]
3400b4f0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400b4f4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400b4f8:	d101      	bne.n	3400b4fe <LL_RCC_PLL2_IsReady+0x16>
3400b4fa:	2301      	movs	r3, #1
3400b4fc:	e000      	b.n	3400b500 <LL_RCC_PLL2_IsReady+0x18>
3400b4fe:	2300      	movs	r3, #0
}
3400b500:	4618      	mov	r0, r3
3400b502:	46bd      	mov	sp, r7
3400b504:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b508:	4770      	bx	lr
3400b50a:	bf00      	nop
3400b50c:	56028000 	.word	0x56028000

3400b510 <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
3400b510:	b480      	push	{r7}
3400b512:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400b514:	4b07      	ldr	r3, [pc, #28]	@ (3400b534 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3400b516:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400b51a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400b51e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400b522:	d101      	bne.n	3400b528 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3400b524:	2301      	movs	r3, #1
3400b526:	e000      	b.n	3400b52a <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3400b528:	2300      	movs	r3, #0
}
3400b52a:	4618      	mov	r0, r3
3400b52c:	46bd      	mov	sp, r7
3400b52e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b532:	4770      	bx	lr
3400b534:	56028000 	.word	0x56028000

3400b538 <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
3400b538:	b480      	push	{r7}
3400b53a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400b53c:	4b04      	ldr	r3, [pc, #16]	@ (3400b550 <LL_RCC_PLL3_GetSource+0x18>)
3400b53e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400b542:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400b546:	4618      	mov	r0, r3
3400b548:	46bd      	mov	sp, r7
3400b54a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b54e:	4770      	bx	lr
3400b550:	56028000 	.word	0x56028000

3400b554 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
3400b554:	b480      	push	{r7}
3400b556:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400b558:	4b07      	ldr	r3, [pc, #28]	@ (3400b578 <LL_RCC_PLL3_IsReady+0x24>)
3400b55a:	685b      	ldr	r3, [r3, #4]
3400b55c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400b560:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400b564:	d101      	bne.n	3400b56a <LL_RCC_PLL3_IsReady+0x16>
3400b566:	2301      	movs	r3, #1
3400b568:	e000      	b.n	3400b56c <LL_RCC_PLL3_IsReady+0x18>
3400b56a:	2300      	movs	r3, #0
}
3400b56c:	4618      	mov	r0, r3
3400b56e:	46bd      	mov	sp, r7
3400b570:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b574:	4770      	bx	lr
3400b576:	bf00      	nop
3400b578:	56028000 	.word	0x56028000

3400b57c <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
3400b57c:	b480      	push	{r7}
3400b57e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400b580:	4b07      	ldr	r3, [pc, #28]	@ (3400b5a0 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3400b582:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400b586:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400b58a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400b58e:	d101      	bne.n	3400b594 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3400b590:	2301      	movs	r3, #1
3400b592:	e000      	b.n	3400b596 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3400b594:	2300      	movs	r3, #0
}
3400b596:	4618      	mov	r0, r3
3400b598:	46bd      	mov	sp, r7
3400b59a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b59e:	4770      	bx	lr
3400b5a0:	56028000 	.word	0x56028000

3400b5a4 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
3400b5a4:	b480      	push	{r7}
3400b5a6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3400b5a8:	4b04      	ldr	r3, [pc, #16]	@ (3400b5bc <LL_RCC_PLL4_GetSource+0x18>)
3400b5aa:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400b5ae:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400b5b2:	4618      	mov	r0, r3
3400b5b4:	46bd      	mov	sp, r7
3400b5b6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b5ba:	4770      	bx	lr
3400b5bc:	56028000 	.word	0x56028000

3400b5c0 <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
3400b5c0:	b480      	push	{r7}
3400b5c2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400b5c4:	4b07      	ldr	r3, [pc, #28]	@ (3400b5e4 <LL_RCC_PLL4_IsReady+0x24>)
3400b5c6:	685b      	ldr	r3, [r3, #4]
3400b5c8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400b5cc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400b5d0:	d101      	bne.n	3400b5d6 <LL_RCC_PLL4_IsReady+0x16>
3400b5d2:	2301      	movs	r3, #1
3400b5d4:	e000      	b.n	3400b5d8 <LL_RCC_PLL4_IsReady+0x18>
3400b5d6:	2300      	movs	r3, #0
}
3400b5d8:	4618      	mov	r0, r3
3400b5da:	46bd      	mov	sp, r7
3400b5dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b5e0:	4770      	bx	lr
3400b5e2:	bf00      	nop
3400b5e4:	56028000 	.word	0x56028000

3400b5e8 <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
3400b5e8:	b480      	push	{r7}
3400b5ea:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400b5ec:	4b07      	ldr	r3, [pc, #28]	@ (3400b60c <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3400b5ee:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400b5f2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400b5f6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400b5fa:	d101      	bne.n	3400b600 <LL_RCC_PLL4_IsEnabledBypass+0x18>
3400b5fc:	2301      	movs	r3, #1
3400b5fe:	e000      	b.n	3400b602 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3400b600:	2300      	movs	r3, #0
}
3400b602:	4618      	mov	r0, r3
3400b604:	46bd      	mov	sp, r7
3400b606:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b60a:	4770      	bx	lr
3400b60c:	56028000 	.word	0x56028000

3400b610 <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
3400b610:	b480      	push	{r7}
3400b612:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
3400b614:	4b04      	ldr	r3, [pc, #16]	@ (3400b628 <LL_RCC_IC1_Enable+0x18>)
3400b616:	2201      	movs	r2, #1
3400b618:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400b61c:	bf00      	nop
3400b61e:	46bd      	mov	sp, r7
3400b620:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b624:	4770      	bx	lr
3400b626:	bf00      	nop
3400b628:	56028000 	.word	0x56028000

3400b62c <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
3400b62c:	b480      	push	{r7}
3400b62e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400b630:	4b04      	ldr	r3, [pc, #16]	@ (3400b644 <LL_RCC_IC1_GetSource+0x18>)
3400b632:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400b636:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400b63a:	4618      	mov	r0, r3
3400b63c:	46bd      	mov	sp, r7
3400b63e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b642:	4770      	bx	lr
3400b644:	56028000 	.word	0x56028000

3400b648 <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
3400b648:	b480      	push	{r7}
3400b64a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3400b64c:	4b05      	ldr	r3, [pc, #20]	@ (3400b664 <LL_RCC_IC1_GetDivider+0x1c>)
3400b64e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400b652:	0c1b      	lsrs	r3, r3, #16
3400b654:	b2db      	uxtb	r3, r3
3400b656:	3301      	adds	r3, #1
}
3400b658:	4618      	mov	r0, r3
3400b65a:	46bd      	mov	sp, r7
3400b65c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b660:	4770      	bx	lr
3400b662:	bf00      	nop
3400b664:	56028000 	.word	0x56028000

3400b668 <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3400b668:	b480      	push	{r7}
3400b66a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400b66c:	4b04      	ldr	r3, [pc, #16]	@ (3400b680 <LL_RCC_IC2_GetSource+0x18>)
3400b66e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400b672:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400b676:	4618      	mov	r0, r3
3400b678:	46bd      	mov	sp, r7
3400b67a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b67e:	4770      	bx	lr
3400b680:	56028000 	.word	0x56028000

3400b684 <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
3400b684:	b480      	push	{r7}
3400b686:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400b688:	4b05      	ldr	r3, [pc, #20]	@ (3400b6a0 <LL_RCC_IC2_GetDivider+0x1c>)
3400b68a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400b68e:	0c1b      	lsrs	r3, r3, #16
3400b690:	b2db      	uxtb	r3, r3
3400b692:	3301      	adds	r3, #1
}
3400b694:	4618      	mov	r0, r3
3400b696:	46bd      	mov	sp, r7
3400b698:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b69c:	4770      	bx	lr
3400b69e:	bf00      	nop
3400b6a0:	56028000 	.word	0x56028000

3400b6a4 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
3400b6a4:	b480      	push	{r7}
3400b6a6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400b6a8:	4b04      	ldr	r3, [pc, #16]	@ (3400b6bc <LL_RCC_IC6_GetSource+0x18>)
3400b6aa:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400b6ae:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400b6b2:	4618      	mov	r0, r3
3400b6b4:	46bd      	mov	sp, r7
3400b6b6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b6ba:	4770      	bx	lr
3400b6bc:	56028000 	.word	0x56028000

3400b6c0 <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
3400b6c0:	b480      	push	{r7}
3400b6c2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400b6c4:	4b04      	ldr	r3, [pc, #16]	@ (3400b6d8 <LL_RCC_IC11_GetSource+0x18>)
3400b6c6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400b6ca:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400b6ce:	4618      	mov	r0, r3
3400b6d0:	46bd      	mov	sp, r7
3400b6d2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b6d6:	4770      	bx	lr
3400b6d8:	56028000 	.word	0x56028000

3400b6dc <HAL_RCC_OscConfig>:
  * @note   This function does not protect the MCOxSEL, the PERSEL and the PPPSEL glitch-free muxes
  *         (Mux selection cannot be changed if selected input clock is inactive).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
3400b6dc:	b580      	push	{r7, lr}
3400b6de:	b0a2      	sub	sp, #136	@ 0x88
3400b6e0:	af00      	add	r7, sp, #0
3400b6e2:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
3400b6e4:	687b      	ldr	r3, [r7, #4]
3400b6e6:	2b00      	cmp	r3, #0
3400b6e8:	d102      	bne.n	3400b6f0 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
3400b6ea:	2301      	movs	r3, #1
3400b6ec:	f000 bd10 	b.w	3400c110 <HAL_RCC_OscConfig+0xa34>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));
3400b6f0:	687b      	ldr	r3, [r7, #4]
3400b6f2:	681b      	ldr	r3, [r3, #0]
3400b6f4:	2b00      	cmp	r3, #0
3400b6f6:	d022      	beq.n	3400b73e <HAL_RCC_OscConfig+0x62>
3400b6f8:	687b      	ldr	r3, [r7, #4]
3400b6fa:	681b      	ldr	r3, [r3, #0]
3400b6fc:	f003 0301 	and.w	r3, r3, #1
3400b700:	2b00      	cmp	r3, #0
3400b702:	d11c      	bne.n	3400b73e <HAL_RCC_OscConfig+0x62>
3400b704:	687b      	ldr	r3, [r7, #4]
3400b706:	681b      	ldr	r3, [r3, #0]
3400b708:	f003 0302 	and.w	r3, r3, #2
3400b70c:	2b00      	cmp	r3, #0
3400b70e:	d116      	bne.n	3400b73e <HAL_RCC_OscConfig+0x62>
3400b710:	687b      	ldr	r3, [r7, #4]
3400b712:	681b      	ldr	r3, [r3, #0]
3400b714:	f003 0310 	and.w	r3, r3, #16
3400b718:	2b00      	cmp	r3, #0
3400b71a:	d110      	bne.n	3400b73e <HAL_RCC_OscConfig+0x62>
3400b71c:	687b      	ldr	r3, [r7, #4]
3400b71e:	681b      	ldr	r3, [r3, #0]
3400b720:	f003 0308 	and.w	r3, r3, #8
3400b724:	2b00      	cmp	r3, #0
3400b726:	d10a      	bne.n	3400b73e <HAL_RCC_OscConfig+0x62>
3400b728:	687b      	ldr	r3, [r7, #4]
3400b72a:	681b      	ldr	r3, [r3, #0]
3400b72c:	f003 0304 	and.w	r3, r3, #4
3400b730:	2b00      	cmp	r3, #0
3400b732:	d104      	bne.n	3400b73e <HAL_RCC_OscConfig+0x62>
3400b734:	f44f 71b8 	mov.w	r1, #368	@ 0x170
3400b738:	4892      	ldr	r0, [pc, #584]	@ (3400b984 <HAL_RCC_OscConfig+0x2a8>)
3400b73a:	f7f5 fdad 	bl	34001298 <assert_failed>

  cpuclksrc = LL_RCC_GetCpuClkSource();
3400b73e:	f7ff fe73 	bl	3400b428 <LL_RCC_GetCpuClkSource>
3400b742:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
3400b746:	f7ff fe7d 	bl	3400b444 <LL_RCC_GetSysClkSource>
3400b74a:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
3400b74e:	f7ff fe87 	bl	3400b460 <LL_RCC_PLL1_GetSource>
3400b752:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
3400b754:	f7ff feba 	bl	3400b4cc <LL_RCC_PLL2_GetSource>
3400b758:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
3400b75a:	f7ff feed 	bl	3400b538 <LL_RCC_PLL3_GetSource>
3400b75e:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
3400b760:	f7ff ff20 	bl	3400b5a4 <LL_RCC_PLL4_GetSource>
3400b764:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
3400b766:	4b88      	ldr	r3, [pc, #544]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b768:	685b      	ldr	r3, [r3, #4]
3400b76a:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
3400b76c:	687b      	ldr	r3, [r7, #4]
3400b76e:	681b      	ldr	r3, [r3, #0]
3400b770:	f003 0301 	and.w	r3, r3, #1
3400b774:	2b00      	cmp	r3, #0
3400b776:	f000 80c3 	beq.w	3400b900 <HAL_RCC_OscConfig+0x224>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));
3400b77a:	687b      	ldr	r3, [r7, #4]
3400b77c:	685b      	ldr	r3, [r3, #4]
3400b77e:	2b00      	cmp	r3, #0
3400b780:	d013      	beq.n	3400b7aa <HAL_RCC_OscConfig+0xce>
3400b782:	687b      	ldr	r3, [r7, #4]
3400b784:	685b      	ldr	r3, [r3, #4]
3400b786:	2b10      	cmp	r3, #16
3400b788:	d00f      	beq.n	3400b7aa <HAL_RCC_OscConfig+0xce>
3400b78a:	687b      	ldr	r3, [r7, #4]
3400b78c:	685b      	ldr	r3, [r3, #4]
3400b78e:	f248 0210 	movw	r2, #32784	@ 0x8010
3400b792:	4293      	cmp	r3, r2
3400b794:	d009      	beq.n	3400b7aa <HAL_RCC_OscConfig+0xce>
3400b796:	687b      	ldr	r3, [r7, #4]
3400b798:	685b      	ldr	r3, [r3, #4]
3400b79a:	4a7c      	ldr	r2, [pc, #496]	@ (3400b98c <HAL_RCC_OscConfig+0x2b0>)
3400b79c:	4293      	cmp	r3, r2
3400b79e:	d004      	beq.n	3400b7aa <HAL_RCC_OscConfig+0xce>
3400b7a0:	f44f 71bf 	mov.w	r1, #382	@ 0x17e
3400b7a4:	4877      	ldr	r0, [pc, #476]	@ (3400b984 <HAL_RCC_OscConfig+0x2a8>)
3400b7a6:	f7f5 fd77 	bl	34001298 <assert_failed>

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3400b7aa:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400b7ae:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400b7b2:	d028      	beq.n	3400b806 <HAL_RCC_OscConfig+0x12a>
3400b7b4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400b7b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b7bc:	d023      	beq.n	3400b806 <HAL_RCC_OscConfig+0x12a>
3400b7be:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400b7c0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b7c4:	d104      	bne.n	3400b7d0 <HAL_RCC_OscConfig+0xf4>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400b7c6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b7c8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400b7cc:	2b00      	cmp	r3, #0
3400b7ce:	d11a      	bne.n	3400b806 <HAL_RCC_OscConfig+0x12a>
3400b7d0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400b7d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b7d6:	d104      	bne.n	3400b7e2 <HAL_RCC_OscConfig+0x106>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400b7d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b7da:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400b7de:	2b00      	cmp	r3, #0
3400b7e0:	d111      	bne.n	3400b806 <HAL_RCC_OscConfig+0x12a>
3400b7e2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3400b7e4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b7e8:	d104      	bne.n	3400b7f4 <HAL_RCC_OscConfig+0x118>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400b7ea:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b7ec:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400b7f0:	2b00      	cmp	r3, #0
3400b7f2:	d108      	bne.n	3400b806 <HAL_RCC_OscConfig+0x12a>
3400b7f4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400b7f6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b7fa:	d10b      	bne.n	3400b814 <HAL_RCC_OscConfig+0x138>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400b7fc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b7fe:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400b802:	2b00      	cmp	r3, #0
3400b804:	d006      	beq.n	3400b814 <HAL_RCC_OscConfig+0x138>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
3400b806:	687b      	ldr	r3, [r7, #4]
3400b808:	685b      	ldr	r3, [r3, #4]
3400b80a:	2b00      	cmp	r3, #0
3400b80c:	d178      	bne.n	3400b900 <HAL_RCC_OscConfig+0x224>
      {
        return HAL_ERROR;
3400b80e:	2301      	movs	r3, #1
3400b810:	f000 bc7e 	b.w	3400c110 <HAL_RCC_OscConfig+0xa34>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3400b814:	687b      	ldr	r3, [r7, #4]
3400b816:	685b      	ldr	r3, [r3, #4]
3400b818:	2b10      	cmp	r3, #16
3400b81a:	d104      	bne.n	3400b826 <HAL_RCC_OscConfig+0x14a>
3400b81c:	4b5a      	ldr	r3, [pc, #360]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b81e:	2210      	movs	r2, #16
3400b820:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400b824:	e043      	b.n	3400b8ae <HAL_RCC_OscConfig+0x1d2>
3400b826:	687b      	ldr	r3, [r7, #4]
3400b828:	685b      	ldr	r3, [r3, #4]
3400b82a:	2b00      	cmp	r3, #0
3400b82c:	d10c      	bne.n	3400b848 <HAL_RCC_OscConfig+0x16c>
3400b82e:	4b56      	ldr	r3, [pc, #344]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b830:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400b834:	461a      	mov	r2, r3
3400b836:	2310      	movs	r3, #16
3400b838:	6013      	str	r3, [r2, #0]
3400b83a:	4b53      	ldr	r3, [pc, #332]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b83c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400b83e:	4a52      	ldr	r2, [pc, #328]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b840:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3400b844:	6553      	str	r3, [r2, #84]	@ 0x54
3400b846:	e032      	b.n	3400b8ae <HAL_RCC_OscConfig+0x1d2>
3400b848:	687b      	ldr	r3, [r7, #4]
3400b84a:	685b      	ldr	r3, [r3, #4]
3400b84c:	f248 0210 	movw	r2, #32784	@ 0x8010
3400b850:	4293      	cmp	r3, r2
3400b852:	d110      	bne.n	3400b876 <HAL_RCC_OscConfig+0x19a>
3400b854:	4b4c      	ldr	r3, [pc, #304]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b856:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400b858:	4a4b      	ldr	r2, [pc, #300]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b85a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400b85e:	6553      	str	r3, [r2, #84]	@ 0x54
3400b860:	4b49      	ldr	r3, [pc, #292]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b862:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400b864:	4a48      	ldr	r2, [pc, #288]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b866:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b86a:	6553      	str	r3, [r2, #84]	@ 0x54
3400b86c:	4b46      	ldr	r3, [pc, #280]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b86e:	2210      	movs	r2, #16
3400b870:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400b874:	e01b      	b.n	3400b8ae <HAL_RCC_OscConfig+0x1d2>
3400b876:	687b      	ldr	r3, [r7, #4]
3400b878:	685b      	ldr	r3, [r3, #4]
3400b87a:	4a44      	ldr	r2, [pc, #272]	@ (3400b98c <HAL_RCC_OscConfig+0x2b0>)
3400b87c:	4293      	cmp	r3, r2
3400b87e:	d10a      	bne.n	3400b896 <HAL_RCC_OscConfig+0x1ba>
3400b880:	4b41      	ldr	r3, [pc, #260]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b882:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400b884:	4a40      	ldr	r2, [pc, #256]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b886:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
3400b88a:	6553      	str	r3, [r2, #84]	@ 0x54
3400b88c:	4b3e      	ldr	r3, [pc, #248]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b88e:	2210      	movs	r2, #16
3400b890:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400b894:	e00b      	b.n	3400b8ae <HAL_RCC_OscConfig+0x1d2>
3400b896:	4b3c      	ldr	r3, [pc, #240]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b898:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400b89c:	461a      	mov	r2, r3
3400b89e:	2310      	movs	r3, #16
3400b8a0:	6013      	str	r3, [r2, #0]
3400b8a2:	4b39      	ldr	r3, [pc, #228]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b8a4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400b8a6:	4a38      	ldr	r2, [pc, #224]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b8a8:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3400b8ac:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400b8ae:	f7fb fe97 	bl	340075e0 <HAL_GetTick>
3400b8b2:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3400b8b4:	687b      	ldr	r3, [r7, #4]
3400b8b6:	685b      	ldr	r3, [r3, #4]
3400b8b8:	2b00      	cmp	r3, #0
3400b8ba:	d01b      	beq.n	3400b8f4 <HAL_RCC_OscConfig+0x218>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3400b8bc:	e009      	b.n	3400b8d2 <HAL_RCC_OscConfig+0x1f6>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3400b8be:	f7fb fe8f 	bl	340075e0 <HAL_GetTick>
3400b8c2:	4602      	mov	r2, r0
3400b8c4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400b8c6:	1ad3      	subs	r3, r2, r3
3400b8c8:	2b64      	cmp	r3, #100	@ 0x64
3400b8ca:	d902      	bls.n	3400b8d2 <HAL_RCC_OscConfig+0x1f6>
          {
            return HAL_TIMEOUT;
3400b8cc:	2303      	movs	r3, #3
3400b8ce:	f000 bc1f 	b.w	3400c110 <HAL_RCC_OscConfig+0xa34>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3400b8d2:	4b2d      	ldr	r3, [pc, #180]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b8d4:	685b      	ldr	r3, [r3, #4]
3400b8d6:	f003 0310 	and.w	r3, r3, #16
3400b8da:	2b00      	cmp	r3, #0
3400b8dc:	d0ef      	beq.n	3400b8be <HAL_RCC_OscConfig+0x1e2>
3400b8de:	e00f      	b.n	3400b900 <HAL_RCC_OscConfig+0x224>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3400b8e0:	f7fb fe7e 	bl	340075e0 <HAL_GetTick>
3400b8e4:	4602      	mov	r2, r0
3400b8e6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400b8e8:	1ad3      	subs	r3, r2, r3
3400b8ea:	2b64      	cmp	r3, #100	@ 0x64
3400b8ec:	d902      	bls.n	3400b8f4 <HAL_RCC_OscConfig+0x218>
          {
            return HAL_TIMEOUT;
3400b8ee:	2303      	movs	r3, #3
3400b8f0:	f000 bc0e 	b.w	3400c110 <HAL_RCC_OscConfig+0xa34>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
3400b8f4:	4b24      	ldr	r3, [pc, #144]	@ (3400b988 <HAL_RCC_OscConfig+0x2ac>)
3400b8f6:	685b      	ldr	r3, [r3, #4]
3400b8f8:	f003 0310 	and.w	r3, r3, #16
3400b8fc:	2b00      	cmp	r3, #0
3400b8fe:	d1ef      	bne.n	3400b8e0 <HAL_RCC_OscConfig+0x204>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
3400b900:	687b      	ldr	r3, [r7, #4]
3400b902:	681b      	ldr	r3, [r3, #0]
3400b904:	f003 0302 	and.w	r3, r3, #2
3400b908:	2b00      	cmp	r3, #0
3400b90a:	f000 80c3 	beq.w	3400ba94 <HAL_RCC_OscConfig+0x3b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
3400b90e:	687b      	ldr	r3, [r7, #4]
3400b910:	68db      	ldr	r3, [r3, #12]
3400b912:	2b00      	cmp	r3, #0
3400b914:	d008      	beq.n	3400b928 <HAL_RCC_OscConfig+0x24c>
3400b916:	687b      	ldr	r3, [r7, #4]
3400b918:	68db      	ldr	r3, [r3, #12]
3400b91a:	2b08      	cmp	r3, #8
3400b91c:	d004      	beq.n	3400b928 <HAL_RCC_OscConfig+0x24c>
3400b91e:	f240 11b3 	movw	r1, #435	@ 0x1b3
3400b922:	4818      	ldr	r0, [pc, #96]	@ (3400b984 <HAL_RCC_OscConfig+0x2a8>)
3400b924:	f7f5 fcb8 	bl	34001298 <assert_failed>

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3400b928:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400b92c:	2b00      	cmp	r3, #0
3400b92e:	d023      	beq.n	3400b978 <HAL_RCC_OscConfig+0x29c>
3400b930:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400b934:	2b00      	cmp	r3, #0
3400b936:	d01f      	beq.n	3400b978 <HAL_RCC_OscConfig+0x29c>
3400b938:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400b93a:	2b00      	cmp	r3, #0
3400b93c:	d104      	bne.n	3400b948 <HAL_RCC_OscConfig+0x26c>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400b93e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b940:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400b944:	2b00      	cmp	r3, #0
3400b946:	d117      	bne.n	3400b978 <HAL_RCC_OscConfig+0x29c>
3400b948:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400b94a:	2b00      	cmp	r3, #0
3400b94c:	d104      	bne.n	3400b958 <HAL_RCC_OscConfig+0x27c>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400b94e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b950:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400b954:	2b00      	cmp	r3, #0
3400b956:	d10f      	bne.n	3400b978 <HAL_RCC_OscConfig+0x29c>
3400b958:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3400b95a:	2b00      	cmp	r3, #0
3400b95c:	d104      	bne.n	3400b968 <HAL_RCC_OscConfig+0x28c>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400b95e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b960:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400b964:	2b00      	cmp	r3, #0
3400b966:	d107      	bne.n	3400b978 <HAL_RCC_OscConfig+0x29c>
3400b968:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400b96a:	2b00      	cmp	r3, #0
3400b96c:	d13b      	bne.n	3400b9e6 <HAL_RCC_OscConfig+0x30a>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400b96e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400b970:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400b974:	2b00      	cmp	r3, #0
3400b976:	d036      	beq.n	3400b9e6 <HAL_RCC_OscConfig+0x30a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3400b978:	687b      	ldr	r3, [r7, #4]
3400b97a:	68db      	ldr	r3, [r3, #12]
3400b97c:	2b00      	cmp	r3, #0
3400b97e:	d107      	bne.n	3400b990 <HAL_RCC_OscConfig+0x2b4>
      {
        return HAL_ERROR;
3400b980:	2301      	movs	r3, #1
3400b982:	e3c5      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
3400b984:	340243dc 	.word	0x340243dc
3400b988:	56028000 	.word	0x56028000
3400b98c:	00018010 	.word	0x00018010
      }
      /* Otherwise, just the divider and calibration is allowed */
      else
      {
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
3400b990:	687b      	ldr	r3, [r7, #4]
3400b992:	691b      	ldr	r3, [r3, #16]
3400b994:	2b00      	cmp	r3, #0
3400b996:	d012      	beq.n	3400b9be <HAL_RCC_OscConfig+0x2e2>
3400b998:	687b      	ldr	r3, [r7, #4]
3400b99a:	691b      	ldr	r3, [r3, #16]
3400b99c:	2b80      	cmp	r3, #128	@ 0x80
3400b99e:	d00e      	beq.n	3400b9be <HAL_RCC_OscConfig+0x2e2>
3400b9a0:	687b      	ldr	r3, [r7, #4]
3400b9a2:	691b      	ldr	r3, [r3, #16]
3400b9a4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400b9a8:	d009      	beq.n	3400b9be <HAL_RCC_OscConfig+0x2e2>
3400b9aa:	687b      	ldr	r3, [r7, #4]
3400b9ac:	691b      	ldr	r3, [r3, #16]
3400b9ae:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
3400b9b2:	d004      	beq.n	3400b9be <HAL_RCC_OscConfig+0x2e2>
3400b9b4:	f240 11c5 	movw	r1, #453	@ 0x1c5
3400b9b8:	48a2      	ldr	r0, [pc, #648]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400b9ba:	f7f5 fc6d 	bl	34001298 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
3400b9be:	687b      	ldr	r3, [r7, #4]
3400b9c0:	695b      	ldr	r3, [r3, #20]
3400b9c2:	2b7f      	cmp	r3, #127	@ 0x7f
3400b9c4:	d904      	bls.n	3400b9d0 <HAL_RCC_OscConfig+0x2f4>
3400b9c6:	f44f 71e3 	mov.w	r1, #454	@ 0x1c6
3400b9ca:	489e      	ldr	r0, [pc, #632]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400b9cc:	f7f5 fc64 	bl	34001298 <assert_failed>

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3400b9d0:	687b      	ldr	r3, [r7, #4]
3400b9d2:	691b      	ldr	r3, [r3, #16]
3400b9d4:	4618      	mov	r0, r3
3400b9d6:	f7ff fc49 	bl	3400b26c <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3400b9da:	687b      	ldr	r3, [r7, #4]
3400b9dc:	695b      	ldr	r3, [r3, #20]
3400b9de:	4618      	mov	r0, r3
3400b9e0:	f7ff fc66 	bl	3400b2b0 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3400b9e4:	e056      	b.n	3400ba94 <HAL_RCC_OscConfig+0x3b8>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
3400b9e6:	687b      	ldr	r3, [r7, #4]
3400b9e8:	68db      	ldr	r3, [r3, #12]
3400b9ea:	2b00      	cmp	r3, #0
3400b9ec:	d03e      	beq.n	3400ba6c <HAL_RCC_OscConfig+0x390>
      {
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
3400b9ee:	687b      	ldr	r3, [r7, #4]
3400b9f0:	691b      	ldr	r3, [r3, #16]
3400b9f2:	2b00      	cmp	r3, #0
3400b9f4:	d012      	beq.n	3400ba1c <HAL_RCC_OscConfig+0x340>
3400b9f6:	687b      	ldr	r3, [r7, #4]
3400b9f8:	691b      	ldr	r3, [r3, #16]
3400b9fa:	2b80      	cmp	r3, #128	@ 0x80
3400b9fc:	d00e      	beq.n	3400ba1c <HAL_RCC_OscConfig+0x340>
3400b9fe:	687b      	ldr	r3, [r7, #4]
3400ba00:	691b      	ldr	r3, [r3, #16]
3400ba02:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ba06:	d009      	beq.n	3400ba1c <HAL_RCC_OscConfig+0x340>
3400ba08:	687b      	ldr	r3, [r7, #4]
3400ba0a:	691b      	ldr	r3, [r3, #16]
3400ba0c:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
3400ba10:	d004      	beq.n	3400ba1c <HAL_RCC_OscConfig+0x340>
3400ba12:	f44f 71ea 	mov.w	r1, #468	@ 0x1d4
3400ba16:	488b      	ldr	r0, [pc, #556]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400ba18:	f7f5 fc3e 	bl	34001298 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
3400ba1c:	687b      	ldr	r3, [r7, #4]
3400ba1e:	695b      	ldr	r3, [r3, #20]
3400ba20:	2b7f      	cmp	r3, #127	@ 0x7f
3400ba22:	d904      	bls.n	3400ba2e <HAL_RCC_OscConfig+0x352>
3400ba24:	f240 11d5 	movw	r1, #469	@ 0x1d5
3400ba28:	4886      	ldr	r0, [pc, #536]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400ba2a:	f7f5 fc35 	bl	34001298 <assert_failed>

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
3400ba2e:	f7ff fbed 	bl	3400b20c <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400ba32:	f7fb fdd5 	bl	340075e0 <HAL_GetTick>
3400ba36:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
3400ba38:	e008      	b.n	3400ba4c <HAL_RCC_OscConfig+0x370>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3400ba3a:	f7fb fdd1 	bl	340075e0 <HAL_GetTick>
3400ba3e:	4602      	mov	r2, r0
3400ba40:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400ba42:	1ad3      	subs	r3, r2, r3
3400ba44:	2b01      	cmp	r3, #1
3400ba46:	d901      	bls.n	3400ba4c <HAL_RCC_OscConfig+0x370>
          {
            return HAL_TIMEOUT;
3400ba48:	2303      	movs	r3, #3
3400ba4a:	e361      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_HSI_IsReady() == 0U)
3400ba4c:	f7ff fbfc 	bl	3400b248 <LL_RCC_HSI_IsReady>
3400ba50:	4603      	mov	r3, r0
3400ba52:	2b00      	cmp	r3, #0
3400ba54:	d0f1      	beq.n	3400ba3a <HAL_RCC_OscConfig+0x35e>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3400ba56:	687b      	ldr	r3, [r7, #4]
3400ba58:	691b      	ldr	r3, [r3, #16]
3400ba5a:	4618      	mov	r0, r3
3400ba5c:	f7ff fc06 	bl	3400b26c <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3400ba60:	687b      	ldr	r3, [r7, #4]
3400ba62:	695b      	ldr	r3, [r3, #20]
3400ba64:	4618      	mov	r0, r3
3400ba66:	f7ff fc23 	bl	3400b2b0 <LL_RCC_HSI_SetCalibTrimming>
3400ba6a:	e013      	b.n	3400ba94 <HAL_RCC_OscConfig+0x3b8>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
3400ba6c:	f7ff fbdc 	bl	3400b228 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400ba70:	f7fb fdb6 	bl	340075e0 <HAL_GetTick>
3400ba74:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3400ba76:	e008      	b.n	3400ba8a <HAL_RCC_OscConfig+0x3ae>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3400ba78:	f7fb fdb2 	bl	340075e0 <HAL_GetTick>
3400ba7c:	4602      	mov	r2, r0
3400ba7e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400ba80:	1ad3      	subs	r3, r2, r3
3400ba82:	2b01      	cmp	r3, #1
3400ba84:	d901      	bls.n	3400ba8a <HAL_RCC_OscConfig+0x3ae>
          {
            return HAL_TIMEOUT;
3400ba86:	2303      	movs	r3, #3
3400ba88:	e342      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_HSI_IsReady() != 0U)
3400ba8a:	f7ff fbdd 	bl	3400b248 <LL_RCC_HSI_IsReady>
3400ba8e:	4603      	mov	r3, r0
3400ba90:	2b00      	cmp	r3, #0
3400ba92:	d1f1      	bne.n	3400ba78 <HAL_RCC_OscConfig+0x39c>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
3400ba94:	687b      	ldr	r3, [r7, #4]
3400ba96:	681b      	ldr	r3, [r3, #0]
3400ba98:	f003 0310 	and.w	r3, r3, #16
3400ba9c:	2b00      	cmp	r3, #0
3400ba9e:	f000 809e 	beq.w	3400bbde <HAL_RCC_OscConfig+0x502>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));
3400baa2:	687b      	ldr	r3, [r7, #4]
3400baa4:	69db      	ldr	r3, [r3, #28]
3400baa6:	2b00      	cmp	r3, #0
3400baa8:	d008      	beq.n	3400babc <HAL_RCC_OscConfig+0x3e0>
3400baaa:	687b      	ldr	r3, [r7, #4]
3400baac:	69db      	ldr	r3, [r3, #28]
3400baae:	2b04      	cmp	r3, #4
3400bab0:	d004      	beq.n	3400babc <HAL_RCC_OscConfig+0x3e0>
3400bab2:	f240 2103 	movw	r1, #515	@ 0x203
3400bab6:	4863      	ldr	r0, [pc, #396]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400bab8:	f7f5 fbee 	bl	34001298 <assert_failed>

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3400babc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400bac0:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400bac4:	d028      	beq.n	3400bb18 <HAL_RCC_OscConfig+0x43c>
3400bac6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400baca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bace:	d023      	beq.n	3400bb18 <HAL_RCC_OscConfig+0x43c>
3400bad0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400bad2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bad6:	d104      	bne.n	3400bae2 <HAL_RCC_OscConfig+0x406>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400bad8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400bada:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400bade:	2b00      	cmp	r3, #0
3400bae0:	d11a      	bne.n	3400bb18 <HAL_RCC_OscConfig+0x43c>
3400bae2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400bae4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bae8:	d104      	bne.n	3400baf4 <HAL_RCC_OscConfig+0x418>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400baea:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400baec:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400baf0:	2b00      	cmp	r3, #0
3400baf2:	d111      	bne.n	3400bb18 <HAL_RCC_OscConfig+0x43c>
3400baf4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3400baf6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bafa:	d104      	bne.n	3400bb06 <HAL_RCC_OscConfig+0x42a>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400bafc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400bafe:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400bb02:	2b00      	cmp	r3, #0
3400bb04:	d108      	bne.n	3400bb18 <HAL_RCC_OscConfig+0x43c>
3400bb06:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400bb08:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bb0c:	d119      	bne.n	3400bb42 <HAL_RCC_OscConfig+0x466>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400bb0e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400bb10:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400bb14:	2b00      	cmp	r3, #0
3400bb16:	d014      	beq.n	3400bb42 <HAL_RCC_OscConfig+0x466>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3400bb18:	687b      	ldr	r3, [r7, #4]
3400bb1a:	69db      	ldr	r3, [r3, #28]
3400bb1c:	2b00      	cmp	r3, #0
3400bb1e:	d101      	bne.n	3400bb24 <HAL_RCC_OscConfig+0x448>
      {
        return HAL_ERROR;
3400bb20:	2301      	movs	r3, #1
3400bb22:	e2f5      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
3400bb24:	687b      	ldr	r3, [r7, #4]
3400bb26:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400bb28:	2b1f      	cmp	r3, #31
3400bb2a:	d904      	bls.n	3400bb36 <HAL_RCC_OscConfig+0x45a>
3400bb2c:	f240 2116 	movw	r1, #534	@ 0x216
3400bb30:	4844      	ldr	r0, [pc, #272]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400bb32:	f7f5 fbb1 	bl	34001298 <assert_failed>

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3400bb36:	687b      	ldr	r3, [r7, #4]
3400bb38:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400bb3a:	4618      	mov	r0, r3
3400bb3c:	f7ff fc20 	bl	3400b380 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3400bb40:	e04d      	b.n	3400bbde <HAL_RCC_OscConfig+0x502>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
3400bb42:	687b      	ldr	r3, [r7, #4]
3400bb44:	69db      	ldr	r3, [r3, #28]
3400bb46:	2b00      	cmp	r3, #0
3400bb48:	d035      	beq.n	3400bbb6 <HAL_RCC_OscConfig+0x4da>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
3400bb4a:	687b      	ldr	r3, [r7, #4]
3400bb4c:	6a1b      	ldr	r3, [r3, #32]
3400bb4e:	2b00      	cmp	r3, #0
3400bb50:	d009      	beq.n	3400bb66 <HAL_RCC_OscConfig+0x48a>
3400bb52:	687b      	ldr	r3, [r7, #4]
3400bb54:	6a1b      	ldr	r3, [r3, #32]
3400bb56:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400bb5a:	d004      	beq.n	3400bb66 <HAL_RCC_OscConfig+0x48a>
3400bb5c:	f240 2122 	movw	r1, #546	@ 0x222
3400bb60:	4838      	ldr	r0, [pc, #224]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400bb62:	f7f5 fb99 	bl	34001298 <assert_failed>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
3400bb66:	687b      	ldr	r3, [r7, #4]
3400bb68:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400bb6a:	2b1f      	cmp	r3, #31
3400bb6c:	d904      	bls.n	3400bb78 <HAL_RCC_OscConfig+0x49c>
3400bb6e:	f240 2123 	movw	r1, #547	@ 0x223
3400bb72:	4834      	ldr	r0, [pc, #208]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400bb74:	f7f5 fb90 	bl	34001298 <assert_failed>

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
3400bb78:	687b      	ldr	r3, [r7, #4]
3400bb7a:	6a1b      	ldr	r3, [r3, #32]
3400bb7c:	4618      	mov	r0, r3
3400bb7e:	f7ff fbdd 	bl	3400b33c <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
3400bb82:	f7ff fbab 	bl	3400b2dc <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400bb86:	f7fb fd2b 	bl	340075e0 <HAL_GetTick>
3400bb8a:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
3400bb8c:	e008      	b.n	3400bba0 <HAL_RCC_OscConfig+0x4c4>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3400bb8e:	f7fb fd27 	bl	340075e0 <HAL_GetTick>
3400bb92:	4602      	mov	r2, r0
3400bb94:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400bb96:	1ad3      	subs	r3, r2, r3
3400bb98:	2b01      	cmp	r3, #1
3400bb9a:	d901      	bls.n	3400bba0 <HAL_RCC_OscConfig+0x4c4>
          {
            return HAL_TIMEOUT;
3400bb9c:	2303      	movs	r3, #3
3400bb9e:	e2b7      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_MSI_IsReady() == 0U)
3400bba0:	f7ff fbba 	bl	3400b318 <LL_RCC_MSI_IsReady>
3400bba4:	4603      	mov	r3, r0
3400bba6:	2b00      	cmp	r3, #0
3400bba8:	d0f1      	beq.n	3400bb8e <HAL_RCC_OscConfig+0x4b2>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3400bbaa:	687b      	ldr	r3, [r7, #4]
3400bbac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400bbae:	4618      	mov	r0, r3
3400bbb0:	f7ff fbe6 	bl	3400b380 <LL_RCC_MSI_SetCalibTrimming>
3400bbb4:	e013      	b.n	3400bbde <HAL_RCC_OscConfig+0x502>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
3400bbb6:	f7ff fb9f 	bl	3400b2f8 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400bbba:	f7fb fd11 	bl	340075e0 <HAL_GetTick>
3400bbbe:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
3400bbc0:	e008      	b.n	3400bbd4 <HAL_RCC_OscConfig+0x4f8>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3400bbc2:	f7fb fd0d 	bl	340075e0 <HAL_GetTick>
3400bbc6:	4602      	mov	r2, r0
3400bbc8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400bbca:	1ad3      	subs	r3, r2, r3
3400bbcc:	2b01      	cmp	r3, #1
3400bbce:	d901      	bls.n	3400bbd4 <HAL_RCC_OscConfig+0x4f8>
          {
            return HAL_TIMEOUT;
3400bbd0:	2303      	movs	r3, #3
3400bbd2:	e29d      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
        while (LL_RCC_MSI_IsReady() != 0U)
3400bbd4:	f7ff fba0 	bl	3400b318 <LL_RCC_MSI_IsReady>
3400bbd8:	4603      	mov	r3, r0
3400bbda:	2b00      	cmp	r3, #0
3400bbdc:	d1f1      	bne.n	3400bbc2 <HAL_RCC_OscConfig+0x4e6>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
3400bbde:	687b      	ldr	r3, [r7, #4]
3400bbe0:	681b      	ldr	r3, [r3, #0]
3400bbe2:	f003 0308 	and.w	r3, r3, #8
3400bbe6:	2b00      	cmp	r3, #0
3400bbe8:	d03c      	beq.n	3400bc64 <HAL_RCC_OscConfig+0x588>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));
3400bbea:	687b      	ldr	r3, [r7, #4]
3400bbec:	699b      	ldr	r3, [r3, #24]
3400bbee:	2b00      	cmp	r3, #0
3400bbf0:	d008      	beq.n	3400bc04 <HAL_RCC_OscConfig+0x528>
3400bbf2:	687b      	ldr	r3, [r7, #4]
3400bbf4:	699b      	ldr	r3, [r3, #24]
3400bbf6:	2b01      	cmp	r3, #1
3400bbf8:	d004      	beq.n	3400bc04 <HAL_RCC_OscConfig+0x528>
3400bbfa:	f240 2153 	movw	r1, #595	@ 0x253
3400bbfe:	4811      	ldr	r0, [pc, #68]	@ (3400bc44 <HAL_RCC_OscConfig+0x568>)
3400bc00:	f7f5 fb4a 	bl	34001298 <assert_failed>

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3400bc04:	687b      	ldr	r3, [r7, #4]
3400bc06:	699b      	ldr	r3, [r3, #24]
3400bc08:	2b00      	cmp	r3, #0
3400bc0a:	d014      	beq.n	3400bc36 <HAL_RCC_OscConfig+0x55a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
3400bc0c:	f7ff fbe0 	bl	3400b3d0 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400bc10:	f7fb fce6 	bl	340075e0 <HAL_GetTick>
3400bc14:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3400bc16:	e008      	b.n	3400bc2a <HAL_RCC_OscConfig+0x54e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3400bc18:	f7fb fce2 	bl	340075e0 <HAL_GetTick>
3400bc1c:	4602      	mov	r2, r0
3400bc1e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400bc20:	1ad3      	subs	r3, r2, r3
3400bc22:	2b01      	cmp	r3, #1
3400bc24:	d901      	bls.n	3400bc2a <HAL_RCC_OscConfig+0x54e>
        {
          return HAL_TIMEOUT;
3400bc26:	2303      	movs	r3, #3
3400bc28:	e272      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSI_IsReady() == 0U)
3400bc2a:	f7ff fbef 	bl	3400b40c <LL_RCC_LSI_IsReady>
3400bc2e:	4603      	mov	r3, r0
3400bc30:	2b00      	cmp	r3, #0
3400bc32:	d0f1      	beq.n	3400bc18 <HAL_RCC_OscConfig+0x53c>
3400bc34:	e016      	b.n	3400bc64 <HAL_RCC_OscConfig+0x588>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3400bc36:	f7ff fbd9 	bl	3400b3ec <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400bc3a:	f7fb fcd1 	bl	340075e0 <HAL_GetTick>
3400bc3e:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
3400bc40:	e00b      	b.n	3400bc5a <HAL_RCC_OscConfig+0x57e>
3400bc42:	bf00      	nop
3400bc44:	340243dc 	.word	0x340243dc
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3400bc48:	f7fb fcca 	bl	340075e0 <HAL_GetTick>
3400bc4c:	4602      	mov	r2, r0
3400bc4e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400bc50:	1ad3      	subs	r3, r2, r3
3400bc52:	2b01      	cmp	r3, #1
3400bc54:	d901      	bls.n	3400bc5a <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
3400bc56:	2303      	movs	r3, #3
3400bc58:	e25a      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSI_IsReady() != 0U)
3400bc5a:	f7ff fbd7 	bl	3400b40c <LL_RCC_LSI_IsReady>
3400bc5e:	4603      	mov	r3, r0
3400bc60:	2b00      	cmp	r3, #0
3400bc62:	d1f1      	bne.n	3400bc48 <HAL_RCC_OscConfig+0x56c>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3400bc64:	687b      	ldr	r3, [r7, #4]
3400bc66:	681b      	ldr	r3, [r3, #0]
3400bc68:	f003 0304 	and.w	r3, r3, #4
3400bc6c:	2b00      	cmp	r3, #0
3400bc6e:	f000 80a4 	beq.w	3400bdba <HAL_RCC_OscConfig+0x6de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));
3400bc72:	687b      	ldr	r3, [r7, #4]
3400bc74:	689b      	ldr	r3, [r3, #8]
3400bc76:	2b00      	cmp	r3, #0
3400bc78:	d013      	beq.n	3400bca2 <HAL_RCC_OscConfig+0x5c6>
3400bc7a:	687b      	ldr	r3, [r7, #4]
3400bc7c:	689b      	ldr	r3, [r3, #8]
3400bc7e:	2b02      	cmp	r3, #2
3400bc80:	d00f      	beq.n	3400bca2 <HAL_RCC_OscConfig+0x5c6>
3400bc82:	687b      	ldr	r3, [r7, #4]
3400bc84:	689b      	ldr	r3, [r3, #8]
3400bc86:	f248 0202 	movw	r2, #32770	@ 0x8002
3400bc8a:	4293      	cmp	r3, r2
3400bc8c:	d009      	beq.n	3400bca2 <HAL_RCC_OscConfig+0x5c6>
3400bc8e:	687b      	ldr	r3, [r7, #4]
3400bc90:	689b      	ldr	r3, [r3, #8]
3400bc92:	4a9b      	ldr	r2, [pc, #620]	@ (3400bf00 <HAL_RCC_OscConfig+0x824>)
3400bc94:	4293      	cmp	r3, r2
3400bc96:	d004      	beq.n	3400bca2 <HAL_RCC_OscConfig+0x5c6>
3400bc98:	f240 217e 	movw	r1, #638	@ 0x27e
3400bc9c:	4899      	ldr	r0, [pc, #612]	@ (3400bf04 <HAL_RCC_OscConfig+0x828>)
3400bc9e:	f7f5 fafb 	bl	34001298 <assert_failed>

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400bca2:	687b      	ldr	r3, [r7, #4]
3400bca4:	689b      	ldr	r3, [r3, #8]
3400bca6:	2b02      	cmp	r3, #2
3400bca8:	d104      	bne.n	3400bcb4 <HAL_RCC_OscConfig+0x5d8>
3400bcaa:	4b97      	ldr	r3, [pc, #604]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcac:	2202      	movs	r2, #2
3400bcae:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400bcb2:	e055      	b.n	3400bd60 <HAL_RCC_OscConfig+0x684>
3400bcb4:	687b      	ldr	r3, [r7, #4]
3400bcb6:	689b      	ldr	r3, [r3, #8]
3400bcb8:	2b00      	cmp	r3, #0
3400bcba:	d112      	bne.n	3400bce2 <HAL_RCC_OscConfig+0x606>
3400bcbc:	4b92      	ldr	r3, [pc, #584]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcbe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400bcc2:	461a      	mov	r2, r3
3400bcc4:	2302      	movs	r3, #2
3400bcc6:	6013      	str	r3, [r2, #0]
3400bcc8:	4b8f      	ldr	r3, [pc, #572]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bccc:	4a8e      	ldr	r2, [pc, #568]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcce:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400bcd2:	6413      	str	r3, [r2, #64]	@ 0x40
3400bcd4:	4b8c      	ldr	r3, [pc, #560]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcd6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bcd8:	4a8b      	ldr	r2, [pc, #556]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcda:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400bcde:	6413      	str	r3, [r2, #64]	@ 0x40
3400bce0:	e03e      	b.n	3400bd60 <HAL_RCC_OscConfig+0x684>
3400bce2:	687b      	ldr	r3, [r7, #4]
3400bce4:	689b      	ldr	r3, [r3, #8]
3400bce6:	f248 0202 	movw	r2, #32770	@ 0x8002
3400bcea:	4293      	cmp	r3, r2
3400bcec:	d110      	bne.n	3400bd10 <HAL_RCC_OscConfig+0x634>
3400bcee:	4b86      	ldr	r3, [pc, #536]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcf0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bcf2:	4a85      	ldr	r2, [pc, #532]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcf4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400bcf8:	6413      	str	r3, [r2, #64]	@ 0x40
3400bcfa:	4b83      	ldr	r3, [pc, #524]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bcfc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bcfe:	4a82      	ldr	r2, [pc, #520]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd00:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400bd04:	6413      	str	r3, [r2, #64]	@ 0x40
3400bd06:	4b80      	ldr	r3, [pc, #512]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd08:	2202      	movs	r2, #2
3400bd0a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400bd0e:	e027      	b.n	3400bd60 <HAL_RCC_OscConfig+0x684>
3400bd10:	687b      	ldr	r3, [r7, #4]
3400bd12:	689b      	ldr	r3, [r3, #8]
3400bd14:	4a7a      	ldr	r2, [pc, #488]	@ (3400bf00 <HAL_RCC_OscConfig+0x824>)
3400bd16:	4293      	cmp	r3, r2
3400bd18:	d110      	bne.n	3400bd3c <HAL_RCC_OscConfig+0x660>
3400bd1a:	4b7b      	ldr	r3, [pc, #492]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd1c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bd1e:	4a7a      	ldr	r2, [pc, #488]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd20:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400bd24:	6413      	str	r3, [r2, #64]	@ 0x40
3400bd26:	4b78      	ldr	r3, [pc, #480]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd28:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bd2a:	4a77      	ldr	r2, [pc, #476]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd2c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400bd30:	6413      	str	r3, [r2, #64]	@ 0x40
3400bd32:	4b75      	ldr	r3, [pc, #468]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd34:	2202      	movs	r2, #2
3400bd36:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400bd3a:	e011      	b.n	3400bd60 <HAL_RCC_OscConfig+0x684>
3400bd3c:	4b72      	ldr	r3, [pc, #456]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd3e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400bd42:	461a      	mov	r2, r3
3400bd44:	2302      	movs	r3, #2
3400bd46:	6013      	str	r3, [r2, #0]
3400bd48:	4b6f      	ldr	r3, [pc, #444]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd4a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bd4c:	4a6e      	ldr	r2, [pc, #440]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd4e:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400bd52:	6413      	str	r3, [r2, #64]	@ 0x40
3400bd54:	4b6c      	ldr	r3, [pc, #432]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd56:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bd58:	4a6b      	ldr	r2, [pc, #428]	@ (3400bf08 <HAL_RCC_OscConfig+0x82c>)
3400bd5a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400bd5e:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3400bd60:	687b      	ldr	r3, [r7, #4]
3400bd62:	689b      	ldr	r3, [r3, #8]
3400bd64:	2b00      	cmp	r3, #0
3400bd66:	d014      	beq.n	3400bd92 <HAL_RCC_OscConfig+0x6b6>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400bd68:	f7fb fc3a 	bl	340075e0 <HAL_GetTick>
3400bd6c:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
3400bd6e:	e00a      	b.n	3400bd86 <HAL_RCC_OscConfig+0x6aa>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400bd70:	f7fb fc36 	bl	340075e0 <HAL_GetTick>
3400bd74:	4602      	mov	r2, r0
3400bd76:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400bd78:	1ad3      	subs	r3, r2, r3
3400bd7a:	f241 3288 	movw	r2, #5000	@ 0x1388
3400bd7e:	4293      	cmp	r3, r2
3400bd80:	d901      	bls.n	3400bd86 <HAL_RCC_OscConfig+0x6aa>
        {
          return HAL_TIMEOUT;
3400bd82:	2303      	movs	r3, #3
3400bd84:	e1c4      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSE_IsReady() == 0U)
3400bd86:	f7ff fb11 	bl	3400b3ac <LL_RCC_LSE_IsReady>
3400bd8a:	4603      	mov	r3, r0
3400bd8c:	2b00      	cmp	r3, #0
3400bd8e:	d0ef      	beq.n	3400bd70 <HAL_RCC_OscConfig+0x694>
3400bd90:	e013      	b.n	3400bdba <HAL_RCC_OscConfig+0x6de>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400bd92:	f7fb fc25 	bl	340075e0 <HAL_GetTick>
3400bd96:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
3400bd98:	e00a      	b.n	3400bdb0 <HAL_RCC_OscConfig+0x6d4>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400bd9a:	f7fb fc21 	bl	340075e0 <HAL_GetTick>
3400bd9e:	4602      	mov	r2, r0
3400bda0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400bda2:	1ad3      	subs	r3, r2, r3
3400bda4:	f241 3288 	movw	r2, #5000	@ 0x1388
3400bda8:	4293      	cmp	r3, r2
3400bdaa:	d901      	bls.n	3400bdb0 <HAL_RCC_OscConfig+0x6d4>
        {
          return HAL_TIMEOUT;
3400bdac:	2303      	movs	r3, #3
3400bdae:	e1af      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      while (LL_RCC_LSE_IsReady() != 0U)
3400bdb0:	f7ff fafc 	bl	3400b3ac <LL_RCC_LSE_IsReady>
3400bdb4:	4603      	mov	r3, r0
3400bdb6:	2b00      	cmp	r3, #0
3400bdb8:	d1ef      	bne.n	3400bd9a <HAL_RCC_OscConfig+0x6be>
    }
  }

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));
3400bdba:	687b      	ldr	r3, [r7, #4]
3400bdbc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bdbe:	2b00      	cmp	r3, #0
3400bdc0:	d010      	beq.n	3400bde4 <HAL_RCC_OscConfig+0x708>
3400bdc2:	687b      	ldr	r3, [r7, #4]
3400bdc4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bdc6:	2b01      	cmp	r3, #1
3400bdc8:	d00c      	beq.n	3400bde4 <HAL_RCC_OscConfig+0x708>
3400bdca:	687b      	ldr	r3, [r7, #4]
3400bdcc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bdce:	2b02      	cmp	r3, #2
3400bdd0:	d008      	beq.n	3400bde4 <HAL_RCC_OscConfig+0x708>
3400bdd2:	687b      	ldr	r3, [r7, #4]
3400bdd4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bdd6:	2b03      	cmp	r3, #3
3400bdd8:	d004      	beq.n	3400bde4 <HAL_RCC_OscConfig+0x708>
3400bdda:	f240 21a3 	movw	r1, #675	@ 0x2a3
3400bdde:	4849      	ldr	r0, [pc, #292]	@ (3400bf04 <HAL_RCC_OscConfig+0x828>)
3400bde0:	f7f5 fa5a 	bl	34001298 <assert_failed>

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
3400bde4:	687b      	ldr	r3, [r7, #4]
3400bde6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bde8:	2b00      	cmp	r3, #0
3400bdea:	d04c      	beq.n	3400be86 <HAL_RCC_OscConfig+0x7aa>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
3400bdec:	687b      	ldr	r3, [r7, #4]
3400bdee:	3328      	adds	r3, #40	@ 0x28
3400bdf0:	4619      	mov	r1, r3
3400bdf2:	2000      	movs	r0, #0
3400bdf4:	f001 f8e0 	bl	3400cfb8 <RCC_PLL_IsNewConfig>
3400bdf8:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3400bdfa:	f7ff fb3f 	bl	3400b47c <LL_RCC_PLL1_IsReady>
3400bdfe:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
3400be00:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3400be02:	2b01      	cmp	r3, #1
3400be04:	d130      	bne.n	3400be68 <HAL_RCC_OscConfig+0x78c>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400be06:	f7ff fc11 	bl	3400b62c <LL_RCC_IC1_GetSource>
3400be0a:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400be0c:	f7ff fc2c 	bl	3400b668 <LL_RCC_IC2_GetSource>
3400be10:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400be12:	f7ff fc47 	bl	3400b6a4 <LL_RCC_IC6_GetSource>
3400be16:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400be18:	f7ff fc52 	bl	3400b6c0 <LL_RCC_IC11_GetSource>
3400be1c:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
3400be1e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400be22:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400be26:	d104      	bne.n	3400be32 <HAL_RCC_OscConfig+0x756>
3400be28:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3400be2a:	2b00      	cmp	r3, #0
3400be2c:	d101      	bne.n	3400be32 <HAL_RCC_OscConfig+0x756>
      {
        return HAL_ERROR;
3400be2e:	2301      	movs	r3, #1
3400be30:	e16e      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400be32:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400be36:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400be3a:	d10a      	bne.n	3400be52 <HAL_RCC_OscConfig+0x776>
3400be3c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3400be3e:	2b00      	cmp	r3, #0
3400be40:	d005      	beq.n	3400be4e <HAL_RCC_OscConfig+0x772>
3400be42:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3400be44:	2b00      	cmp	r3, #0
3400be46:	d002      	beq.n	3400be4e <HAL_RCC_OscConfig+0x772>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400be48:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3400be4a:	2b00      	cmp	r3, #0
3400be4c:	d101      	bne.n	3400be52 <HAL_RCC_OscConfig+0x776>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
3400be4e:	2301      	movs	r3, #1
3400be50:	e15e      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3400be52:	687b      	ldr	r3, [r7, #4]
3400be54:	3328      	adds	r3, #40	@ 0x28
3400be56:	4619      	mov	r1, r3
3400be58:	2000      	movs	r0, #0
3400be5a:	f000 fedd 	bl	3400cc18 <RCC_PLL_Config>
3400be5e:	4603      	mov	r3, r0
3400be60:	2b00      	cmp	r3, #0
3400be62:	d010      	beq.n	3400be86 <HAL_RCC_OscConfig+0x7aa>
      {
        return HAL_ERROR;
3400be64:	2301      	movs	r3, #1
3400be66:	e153      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3400be68:	687b      	ldr	r3, [r7, #4]
3400be6a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400be6c:	2b02      	cmp	r3, #2
3400be6e:	d10a      	bne.n	3400be86 <HAL_RCC_OscConfig+0x7aa>
3400be70:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3400be72:	2b00      	cmp	r3, #0
3400be74:	d107      	bne.n	3400be86 <HAL_RCC_OscConfig+0x7aa>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3400be76:	2000      	movs	r0, #0
3400be78:	f001 f872 	bl	3400cf60 <RCC_PLL_Enable>
3400be7c:	4603      	mov	r3, r0
3400be7e:	2b00      	cmp	r3, #0
3400be80:	d001      	beq.n	3400be86 <HAL_RCC_OscConfig+0x7aa>
      {
        return HAL_ERROR;
3400be82:	2301      	movs	r3, #1
3400be84:	e144      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
    }
  }

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));
3400be86:	687b      	ldr	r3, [r7, #4]
3400be88:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400be8a:	2b00      	cmp	r3, #0
3400be8c:	d010      	beq.n	3400beb0 <HAL_RCC_OscConfig+0x7d4>
3400be8e:	687b      	ldr	r3, [r7, #4]
3400be90:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400be92:	2b01      	cmp	r3, #1
3400be94:	d00c      	beq.n	3400beb0 <HAL_RCC_OscConfig+0x7d4>
3400be96:	687b      	ldr	r3, [r7, #4]
3400be98:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400be9a:	2b02      	cmp	r3, #2
3400be9c:	d008      	beq.n	3400beb0 <HAL_RCC_OscConfig+0x7d4>
3400be9e:	687b      	ldr	r3, [r7, #4]
3400bea0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bea2:	2b03      	cmp	r3, #3
3400bea4:	d004      	beq.n	3400beb0 <HAL_RCC_OscConfig+0x7d4>
3400bea6:	f240 21d1 	movw	r1, #721	@ 0x2d1
3400beaa:	4816      	ldr	r0, [pc, #88]	@ (3400bf04 <HAL_RCC_OscConfig+0x828>)
3400beac:	f7f5 f9f4 	bl	34001298 <assert_failed>

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3400beb0:	687b      	ldr	r3, [r7, #4]
3400beb2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400beb4:	2b00      	cmp	r3, #0
3400beb6:	d056      	beq.n	3400bf66 <HAL_RCC_OscConfig+0x88a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
3400beb8:	687b      	ldr	r3, [r7, #4]
3400beba:	3344      	adds	r3, #68	@ 0x44
3400bebc:	4619      	mov	r1, r3
3400bebe:	2001      	movs	r0, #1
3400bec0:	f001 f87a 	bl	3400cfb8 <RCC_PLL_IsNewConfig>
3400bec4:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
3400bec6:	f7ff fb0f 	bl	3400b4e8 <LL_RCC_PLL2_IsReady>
3400beca:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
3400becc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400bece:	2b01      	cmp	r3, #1
3400bed0:	d13a      	bne.n	3400bf48 <HAL_RCC_OscConfig+0x86c>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400bed2:	f7ff fbab 	bl	3400b62c <LL_RCC_IC1_GetSource>
3400bed6:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400bed8:	f7ff fbc6 	bl	3400b668 <LL_RCC_IC2_GetSource>
3400bedc:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400bede:	f7ff fbe1 	bl	3400b6a4 <LL_RCC_IC6_GetSource>
3400bee2:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400bee4:	f7ff fbec 	bl	3400b6c0 <LL_RCC_IC11_GetSource>
3400bee8:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
3400beea:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400beee:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400bef2:	d10b      	bne.n	3400bf0c <HAL_RCC_OscConfig+0x830>
3400bef4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400bef6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400befa:	d107      	bne.n	3400bf0c <HAL_RCC_OscConfig+0x830>
      {
        return HAL_ERROR;
3400befc:	2301      	movs	r3, #1
3400befe:	e107      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
3400bf00:	00018002 	.word	0x00018002
3400bf04:	340243dc 	.word	0x340243dc
3400bf08:	56028000 	.word	0x56028000
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400bf0c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400bf10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400bf14:	d10d      	bne.n	3400bf32 <HAL_RCC_OscConfig+0x856>
3400bf16:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400bf18:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bf1c:	d007      	beq.n	3400bf2e <HAL_RCC_OscConfig+0x852>
3400bf1e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400bf20:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bf24:	d003      	beq.n	3400bf2e <HAL_RCC_OscConfig+0x852>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400bf26:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3400bf28:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400bf2c:	d101      	bne.n	3400bf32 <HAL_RCC_OscConfig+0x856>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
3400bf2e:	2301      	movs	r3, #1
3400bf30:	e0ee      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3400bf32:	687b      	ldr	r3, [r7, #4]
3400bf34:	3344      	adds	r3, #68	@ 0x44
3400bf36:	4619      	mov	r1, r3
3400bf38:	2001      	movs	r0, #1
3400bf3a:	f000 fe6d 	bl	3400cc18 <RCC_PLL_Config>
3400bf3e:	4603      	mov	r3, r0
3400bf40:	2b00      	cmp	r3, #0
3400bf42:	d010      	beq.n	3400bf66 <HAL_RCC_OscConfig+0x88a>
      {
        return HAL_ERROR;
3400bf44:	2301      	movs	r3, #1
3400bf46:	e0e3      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3400bf48:	687b      	ldr	r3, [r7, #4]
3400bf4a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bf4c:	2b02      	cmp	r3, #2
3400bf4e:	d10a      	bne.n	3400bf66 <HAL_RCC_OscConfig+0x88a>
3400bf50:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400bf52:	2b00      	cmp	r3, #0
3400bf54:	d107      	bne.n	3400bf66 <HAL_RCC_OscConfig+0x88a>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3400bf56:	2001      	movs	r0, #1
3400bf58:	f001 f802 	bl	3400cf60 <RCC_PLL_Enable>
3400bf5c:	4603      	mov	r3, r0
3400bf5e:	2b00      	cmp	r3, #0
3400bf60:	d001      	beq.n	3400bf66 <HAL_RCC_OscConfig+0x88a>
      {
        return HAL_ERROR;
3400bf62:	2301      	movs	r3, #1
3400bf64:	e0d4      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
    }
  }

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));
3400bf66:	687b      	ldr	r3, [r7, #4]
3400bf68:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf6a:	2b00      	cmp	r3, #0
3400bf6c:	d010      	beq.n	3400bf90 <HAL_RCC_OscConfig+0x8b4>
3400bf6e:	687b      	ldr	r3, [r7, #4]
3400bf70:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf72:	2b01      	cmp	r3, #1
3400bf74:	d00c      	beq.n	3400bf90 <HAL_RCC_OscConfig+0x8b4>
3400bf76:	687b      	ldr	r3, [r7, #4]
3400bf78:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf7a:	2b02      	cmp	r3, #2
3400bf7c:	d008      	beq.n	3400bf90 <HAL_RCC_OscConfig+0x8b4>
3400bf7e:	687b      	ldr	r3, [r7, #4]
3400bf80:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf82:	2b03      	cmp	r3, #3
3400bf84:	d004      	beq.n	3400bf90 <HAL_RCC_OscConfig+0x8b4>
3400bf86:	f240 21ff 	movw	r1, #767	@ 0x2ff
3400bf8a:	4863      	ldr	r0, [pc, #396]	@ (3400c118 <HAL_RCC_OscConfig+0xa3c>)
3400bf8c:	f7f5 f984 	bl	34001298 <assert_failed>

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
3400bf90:	687b      	ldr	r3, [r7, #4]
3400bf92:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400bf94:	2b00      	cmp	r3, #0
3400bf96:	d050      	beq.n	3400c03a <HAL_RCC_OscConfig+0x95e>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
3400bf98:	687b      	ldr	r3, [r7, #4]
3400bf9a:	3360      	adds	r3, #96	@ 0x60
3400bf9c:	4619      	mov	r1, r3
3400bf9e:	2002      	movs	r0, #2
3400bfa0:	f001 f80a 	bl	3400cfb8 <RCC_PLL_IsNewConfig>
3400bfa4:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
3400bfa6:	f7ff fa69 	bl	3400b47c <LL_RCC_PLL1_IsReady>
3400bfaa:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
3400bfac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3400bfae:	2b01      	cmp	r3, #1
3400bfb0:	d134      	bne.n	3400c01c <HAL_RCC_OscConfig+0x940>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400bfb2:	f7ff fb3b 	bl	3400b62c <LL_RCC_IC1_GetSource>
3400bfb6:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400bfb8:	f7ff fb56 	bl	3400b668 <LL_RCC_IC2_GetSource>
3400bfbc:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400bfbe:	f7ff fb71 	bl	3400b6a4 <LL_RCC_IC6_GetSource>
3400bfc2:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400bfc4:	f7ff fb7c 	bl	3400b6c0 <LL_RCC_IC11_GetSource>
3400bfc8:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3400bfca:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400bfce:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400bfd2:	d105      	bne.n	3400bfe0 <HAL_RCC_OscConfig+0x904>
3400bfd4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400bfd6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bfda:	d101      	bne.n	3400bfe0 <HAL_RCC_OscConfig+0x904>
      {
        return HAL_ERROR;
3400bfdc:	2301      	movs	r3, #1
3400bfde:	e097      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
3400bfe0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400bfe4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400bfe8:	d10d      	bne.n	3400c006 <HAL_RCC_OscConfig+0x92a>
3400bfea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400bfec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bff0:	d007      	beq.n	3400c002 <HAL_RCC_OscConfig+0x926>
3400bff2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bff4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400bff8:	d003      	beq.n	3400c002 <HAL_RCC_OscConfig+0x926>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
3400bffa:	6a3b      	ldr	r3, [r7, #32]
3400bffc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c000:	d101      	bne.n	3400c006 <HAL_RCC_OscConfig+0x92a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
3400c002:	2301      	movs	r3, #1
3400c004:	e084      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3400c006:	687b      	ldr	r3, [r7, #4]
3400c008:	3360      	adds	r3, #96	@ 0x60
3400c00a:	4619      	mov	r1, r3
3400c00c:	2002      	movs	r0, #2
3400c00e:	f000 fe03 	bl	3400cc18 <RCC_PLL_Config>
3400c012:	4603      	mov	r3, r0
3400c014:	2b00      	cmp	r3, #0
3400c016:	d010      	beq.n	3400c03a <HAL_RCC_OscConfig+0x95e>
      {
        return HAL_ERROR;
3400c018:	2301      	movs	r3, #1
3400c01a:	e079      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
3400c01c:	687b      	ldr	r3, [r7, #4]
3400c01e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400c020:	2b02      	cmp	r3, #2
3400c022:	d10a      	bne.n	3400c03a <HAL_RCC_OscConfig+0x95e>
3400c024:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c026:	2b00      	cmp	r3, #0
3400c028:	d107      	bne.n	3400c03a <HAL_RCC_OscConfig+0x95e>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3400c02a:	2002      	movs	r0, #2
3400c02c:	f000 ff98 	bl	3400cf60 <RCC_PLL_Enable>
3400c030:	4603      	mov	r3, r0
3400c032:	2b00      	cmp	r3, #0
3400c034:	d001      	beq.n	3400c03a <HAL_RCC_OscConfig+0x95e>
      {
        return HAL_ERROR;
3400c036:	2301      	movs	r3, #1
3400c038:	e06a      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
    }
  }

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));
3400c03a:	687b      	ldr	r3, [r7, #4]
3400c03c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c03e:	2b00      	cmp	r3, #0
3400c040:	d010      	beq.n	3400c064 <HAL_RCC_OscConfig+0x988>
3400c042:	687b      	ldr	r3, [r7, #4]
3400c044:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c046:	2b01      	cmp	r3, #1
3400c048:	d00c      	beq.n	3400c064 <HAL_RCC_OscConfig+0x988>
3400c04a:	687b      	ldr	r3, [r7, #4]
3400c04c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c04e:	2b02      	cmp	r3, #2
3400c050:	d008      	beq.n	3400c064 <HAL_RCC_OscConfig+0x988>
3400c052:	687b      	ldr	r3, [r7, #4]
3400c054:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c056:	2b03      	cmp	r3, #3
3400c058:	d004      	beq.n	3400c064 <HAL_RCC_OscConfig+0x988>
3400c05a:	f44f 714b 	mov.w	r1, #812	@ 0x32c
3400c05e:	482e      	ldr	r0, [pc, #184]	@ (3400c118 <HAL_RCC_OscConfig+0xa3c>)
3400c060:	f7f5 f91a 	bl	34001298 <assert_failed>

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
3400c064:	687b      	ldr	r3, [r7, #4]
3400c066:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c068:	2b00      	cmp	r3, #0
3400c06a:	d050      	beq.n	3400c10e <HAL_RCC_OscConfig+0xa32>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
3400c06c:	687b      	ldr	r3, [r7, #4]
3400c06e:	337c      	adds	r3, #124	@ 0x7c
3400c070:	4619      	mov	r1, r3
3400c072:	2003      	movs	r0, #3
3400c074:	f000 ffa0 	bl	3400cfb8 <RCC_PLL_IsNewConfig>
3400c078:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
3400c07a:	f7ff faa1 	bl	3400b5c0 <LL_RCC_PLL4_IsReady>
3400c07e:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
3400c080:	69fb      	ldr	r3, [r7, #28]
3400c082:	2b01      	cmp	r3, #1
3400c084:	d134      	bne.n	3400c0f0 <HAL_RCC_OscConfig+0xa14>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400c086:	f7ff fad1 	bl	3400b62c <LL_RCC_IC1_GetSource>
3400c08a:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400c08c:	f7ff faec 	bl	3400b668 <LL_RCC_IC2_GetSource>
3400c090:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400c092:	f7ff fb07 	bl	3400b6a4 <LL_RCC_IC6_GetSource>
3400c096:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400c098:	f7ff fb12 	bl	3400b6c0 <LL_RCC_IC11_GetSource>
3400c09c:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
3400c09e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400c0a2:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400c0a6:	d105      	bne.n	3400c0b4 <HAL_RCC_OscConfig+0x9d8>
3400c0a8:	697b      	ldr	r3, [r7, #20]
3400c0aa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c0ae:	d101      	bne.n	3400c0b4 <HAL_RCC_OscConfig+0x9d8>
      {
        return HAL_ERROR;
3400c0b0:	2301      	movs	r3, #1
3400c0b2:	e02d      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400c0b4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400c0b8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c0bc:	d10d      	bne.n	3400c0da <HAL_RCC_OscConfig+0x9fe>
3400c0be:	693b      	ldr	r3, [r7, #16]
3400c0c0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c0c4:	d007      	beq.n	3400c0d6 <HAL_RCC_OscConfig+0x9fa>
3400c0c6:	68fb      	ldr	r3, [r7, #12]
3400c0c8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c0cc:	d003      	beq.n	3400c0d6 <HAL_RCC_OscConfig+0x9fa>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400c0ce:	68bb      	ldr	r3, [r7, #8]
3400c0d0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c0d4:	d101      	bne.n	3400c0da <HAL_RCC_OscConfig+0x9fe>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3400c0d6:	2301      	movs	r3, #1
3400c0d8:	e01a      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
3400c0da:	687b      	ldr	r3, [r7, #4]
3400c0dc:	337c      	adds	r3, #124	@ 0x7c
3400c0de:	4619      	mov	r1, r3
3400c0e0:	2003      	movs	r0, #3
3400c0e2:	f000 fd99 	bl	3400cc18 <RCC_PLL_Config>
3400c0e6:	4603      	mov	r3, r0
3400c0e8:	2b00      	cmp	r3, #0
3400c0ea:	d010      	beq.n	3400c10e <HAL_RCC_OscConfig+0xa32>
      {
        return HAL_ERROR;
3400c0ec:	2301      	movs	r3, #1
3400c0ee:	e00f      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
3400c0f0:	687b      	ldr	r3, [r7, #4]
3400c0f2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400c0f4:	2b02      	cmp	r3, #2
3400c0f6:	d10a      	bne.n	3400c10e <HAL_RCC_OscConfig+0xa32>
3400c0f8:	69bb      	ldr	r3, [r7, #24]
3400c0fa:	2b00      	cmp	r3, #0
3400c0fc:	d107      	bne.n	3400c10e <HAL_RCC_OscConfig+0xa32>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3400c0fe:	2003      	movs	r0, #3
3400c100:	f000 ff2e 	bl	3400cf60 <RCC_PLL_Enable>
3400c104:	4603      	mov	r3, r0
3400c106:	2b00      	cmp	r3, #0
3400c108:	d001      	beq.n	3400c10e <HAL_RCC_OscConfig+0xa32>
      {
        return HAL_ERROR;
3400c10a:	2301      	movs	r3, #1
3400c10c:	e000      	b.n	3400c110 <HAL_RCC_OscConfig+0xa34>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
3400c10e:	2300      	movs	r3, #0
}
3400c110:	4618      	mov	r0, r3
3400c112:	3788      	adds	r7, #136	@ 0x88
3400c114:	46bd      	mov	sp, r7
3400c116:	bd80      	pop	{r7, pc}
3400c118:	340243dc 	.word	0x340243dc

3400c11c <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3400c11c:	b580      	push	{r7, lr}
3400c11e:	b084      	sub	sp, #16
3400c120:	af00      	add	r7, sp, #0
3400c122:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
3400c124:	687b      	ldr	r3, [r7, #4]
3400c126:	2b00      	cmp	r3, #0
3400c128:	d102      	bne.n	3400c130 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
3400c12a:	2301      	movs	r3, #1
3400c12c:	f000 bc6d 	b.w	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
  }

  /* Check the parameters */
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));
3400c130:	687b      	ldr	r3, [r7, #4]
3400c132:	681b      	ldr	r3, [r3, #0]
3400c134:	2b7f      	cmp	r3, #127	@ 0x7f
3400c136:	d904      	bls.n	3400c142 <HAL_RCC_ClockConfig+0x26>
3400c138:	f44f 715f 	mov.w	r1, #892	@ 0x37c
3400c13c:	4880      	ldr	r0, [pc, #512]	@ (3400c340 <HAL_RCC_ClockConfig+0x224>)
3400c13e:	f7f5 f8ab 	bl	34001298 <assert_failed>

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400c142:	687b      	ldr	r3, [r7, #4]
3400c144:	681b      	ldr	r3, [r3, #0]
3400c146:	f003 0308 	and.w	r3, r3, #8
3400c14a:	2b00      	cmp	r3, #0
3400c14c:	d035      	beq.n	3400c1ba <HAL_RCC_ClockConfig+0x9e>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
3400c14e:	687b      	ldr	r3, [r7, #4]
3400c150:	691b      	ldr	r3, [r3, #16]
3400c152:	2b00      	cmp	r3, #0
3400c154:	d020      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c156:	687b      	ldr	r3, [r7, #4]
3400c158:	691b      	ldr	r3, [r3, #16]
3400c15a:	2b01      	cmp	r3, #1
3400c15c:	d01c      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c15e:	687b      	ldr	r3, [r7, #4]
3400c160:	691b      	ldr	r3, [r3, #16]
3400c162:	2b02      	cmp	r3, #2
3400c164:	d018      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c166:	687b      	ldr	r3, [r7, #4]
3400c168:	691b      	ldr	r3, [r3, #16]
3400c16a:	2b03      	cmp	r3, #3
3400c16c:	d014      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c16e:	687b      	ldr	r3, [r7, #4]
3400c170:	691b      	ldr	r3, [r3, #16]
3400c172:	2b04      	cmp	r3, #4
3400c174:	d010      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c176:	687b      	ldr	r3, [r7, #4]
3400c178:	691b      	ldr	r3, [r3, #16]
3400c17a:	2b05      	cmp	r3, #5
3400c17c:	d00c      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c17e:	687b      	ldr	r3, [r7, #4]
3400c180:	691b      	ldr	r3, [r3, #16]
3400c182:	2b06      	cmp	r3, #6
3400c184:	d008      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c186:	687b      	ldr	r3, [r7, #4]
3400c188:	691b      	ldr	r3, [r3, #16]
3400c18a:	2b07      	cmp	r3, #7
3400c18c:	d004      	beq.n	3400c198 <HAL_RCC_ClockConfig+0x7c>
3400c18e:	f240 3183 	movw	r1, #899	@ 0x383
3400c192:	486b      	ldr	r0, [pc, #428]	@ (3400c340 <HAL_RCC_ClockConfig+0x224>)
3400c194:	f7f5 f880 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3400c198:	687b      	ldr	r3, [r7, #4]
3400c19a:	691a      	ldr	r2, [r3, #16]
3400c19c:	4b69      	ldr	r3, [pc, #420]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c19e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c1a0:	f003 0307 	and.w	r3, r3, #7
3400c1a4:	429a      	cmp	r2, r3
3400c1a6:	d908      	bls.n	3400c1ba <HAL_RCC_ClockConfig+0x9e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3400c1a8:	4b66      	ldr	r3, [pc, #408]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c1aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c1ac:	f023 0207 	bic.w	r2, r3, #7
3400c1b0:	687b      	ldr	r3, [r7, #4]
3400c1b2:	691b      	ldr	r3, [r3, #16]
3400c1b4:	4963      	ldr	r1, [pc, #396]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c1b6:	4313      	orrs	r3, r2
3400c1b8:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3400c1ba:	687b      	ldr	r3, [r7, #4]
3400c1bc:	681b      	ldr	r3, [r3, #0]
3400c1be:	f003 0310 	and.w	r3, r3, #16
3400c1c2:	2b00      	cmp	r3, #0
3400c1c4:	d035      	beq.n	3400c232 <HAL_RCC_ClockConfig+0x116>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
3400c1c6:	687b      	ldr	r3, [r7, #4]
3400c1c8:	695b      	ldr	r3, [r3, #20]
3400c1ca:	2b00      	cmp	r3, #0
3400c1cc:	d020      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1ce:	687b      	ldr	r3, [r7, #4]
3400c1d0:	695b      	ldr	r3, [r3, #20]
3400c1d2:	2b10      	cmp	r3, #16
3400c1d4:	d01c      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1d6:	687b      	ldr	r3, [r7, #4]
3400c1d8:	695b      	ldr	r3, [r3, #20]
3400c1da:	2b20      	cmp	r3, #32
3400c1dc:	d018      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1de:	687b      	ldr	r3, [r7, #4]
3400c1e0:	695b      	ldr	r3, [r3, #20]
3400c1e2:	2b30      	cmp	r3, #48	@ 0x30
3400c1e4:	d014      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1e6:	687b      	ldr	r3, [r7, #4]
3400c1e8:	695b      	ldr	r3, [r3, #20]
3400c1ea:	2b40      	cmp	r3, #64	@ 0x40
3400c1ec:	d010      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1ee:	687b      	ldr	r3, [r7, #4]
3400c1f0:	695b      	ldr	r3, [r3, #20]
3400c1f2:	2b50      	cmp	r3, #80	@ 0x50
3400c1f4:	d00c      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1f6:	687b      	ldr	r3, [r7, #4]
3400c1f8:	695b      	ldr	r3, [r3, #20]
3400c1fa:	2b60      	cmp	r3, #96	@ 0x60
3400c1fc:	d008      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c1fe:	687b      	ldr	r3, [r7, #4]
3400c200:	695b      	ldr	r3, [r3, #20]
3400c202:	2b70      	cmp	r3, #112	@ 0x70
3400c204:	d004      	beq.n	3400c210 <HAL_RCC_ClockConfig+0xf4>
3400c206:	f240 318d 	movw	r1, #909	@ 0x38d
3400c20a:	484d      	ldr	r0, [pc, #308]	@ (3400c340 <HAL_RCC_ClockConfig+0x224>)
3400c20c:	f7f5 f844 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3400c210:	687b      	ldr	r3, [r7, #4]
3400c212:	695a      	ldr	r2, [r3, #20]
3400c214:	4b4b      	ldr	r3, [pc, #300]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c216:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c218:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3400c21c:	429a      	cmp	r2, r3
3400c21e:	d908      	bls.n	3400c232 <HAL_RCC_ClockConfig+0x116>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3400c220:	4b48      	ldr	r3, [pc, #288]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c222:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c224:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3400c228:	687b      	ldr	r3, [r7, #4]
3400c22a:	695b      	ldr	r3, [r3, #20]
3400c22c:	4945      	ldr	r1, [pc, #276]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c22e:	4313      	orrs	r3, r2
3400c230:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400c232:	687b      	ldr	r3, [r7, #4]
3400c234:	681b      	ldr	r3, [r3, #0]
3400c236:	f003 0320 	and.w	r3, r3, #32
3400c23a:	2b00      	cmp	r3, #0
3400c23c:	d03c      	beq.n	3400c2b8 <HAL_RCC_ClockConfig+0x19c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
3400c23e:	687b      	ldr	r3, [r7, #4]
3400c240:	699b      	ldr	r3, [r3, #24]
3400c242:	2b00      	cmp	r3, #0
3400c244:	d027      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c246:	687b      	ldr	r3, [r7, #4]
3400c248:	699b      	ldr	r3, [r3, #24]
3400c24a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400c24e:	d022      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c250:	687b      	ldr	r3, [r7, #4]
3400c252:	699b      	ldr	r3, [r3, #24]
3400c254:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400c258:	d01d      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c25a:	687b      	ldr	r3, [r7, #4]
3400c25c:	699b      	ldr	r3, [r3, #24]
3400c25e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3400c262:	d018      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c264:	687b      	ldr	r3, [r7, #4]
3400c266:	699b      	ldr	r3, [r3, #24]
3400c268:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400c26c:	d013      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c26e:	687b      	ldr	r3, [r7, #4]
3400c270:	699b      	ldr	r3, [r3, #24]
3400c272:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
3400c276:	d00e      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c278:	687b      	ldr	r3, [r7, #4]
3400c27a:	699b      	ldr	r3, [r3, #24]
3400c27c:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
3400c280:	d009      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c282:	687b      	ldr	r3, [r7, #4]
3400c284:	699b      	ldr	r3, [r3, #24]
3400c286:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
3400c28a:	d004      	beq.n	3400c296 <HAL_RCC_ClockConfig+0x17a>
3400c28c:	f240 3197 	movw	r1, #919	@ 0x397
3400c290:	482b      	ldr	r0, [pc, #172]	@ (3400c340 <HAL_RCC_ClockConfig+0x224>)
3400c292:	f7f5 f801 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3400c296:	687b      	ldr	r3, [r7, #4]
3400c298:	699a      	ldr	r2, [r3, #24]
3400c29a:	4b2a      	ldr	r3, [pc, #168]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c29c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c29e:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3400c2a2:	429a      	cmp	r2, r3
3400c2a4:	d908      	bls.n	3400c2b8 <HAL_RCC_ClockConfig+0x19c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3400c2a6:	4b27      	ldr	r3, [pc, #156]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c2a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c2aa:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3400c2ae:	687b      	ldr	r3, [r7, #4]
3400c2b0:	699b      	ldr	r3, [r3, #24]
3400c2b2:	4924      	ldr	r1, [pc, #144]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c2b4:	4313      	orrs	r3, r2
3400c2b6:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3400c2b8:	687b      	ldr	r3, [r7, #4]
3400c2ba:	681b      	ldr	r3, [r3, #0]
3400c2bc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400c2c0:	2b00      	cmp	r3, #0
3400c2c2:	d041      	beq.n	3400c348 <HAL_RCC_ClockConfig+0x22c>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
3400c2c4:	687b      	ldr	r3, [r7, #4]
3400c2c6:	69db      	ldr	r3, [r3, #28]
3400c2c8:	2b00      	cmp	r3, #0
3400c2ca:	d027      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c2cc:	687b      	ldr	r3, [r7, #4]
3400c2ce:	69db      	ldr	r3, [r3, #28]
3400c2d0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400c2d4:	d022      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c2d6:	687b      	ldr	r3, [r7, #4]
3400c2d8:	69db      	ldr	r3, [r3, #28]
3400c2da:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400c2de:	d01d      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c2e0:	687b      	ldr	r3, [r7, #4]
3400c2e2:	69db      	ldr	r3, [r3, #28]
3400c2e4:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400c2e8:	d018      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c2ea:	687b      	ldr	r3, [r7, #4]
3400c2ec:	69db      	ldr	r3, [r3, #28]
3400c2ee:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400c2f2:	d013      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c2f4:	687b      	ldr	r3, [r7, #4]
3400c2f6:	69db      	ldr	r3, [r3, #28]
3400c2f8:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400c2fc:	d00e      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c2fe:	687b      	ldr	r3, [r7, #4]
3400c300:	69db      	ldr	r3, [r3, #28]
3400c302:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400c306:	d009      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c308:	687b      	ldr	r3, [r7, #4]
3400c30a:	69db      	ldr	r3, [r3, #28]
3400c30c:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3400c310:	d004      	beq.n	3400c31c <HAL_RCC_ClockConfig+0x200>
3400c312:	f240 31a1 	movw	r1, #929	@ 0x3a1
3400c316:	480a      	ldr	r0, [pc, #40]	@ (3400c340 <HAL_RCC_ClockConfig+0x224>)
3400c318:	f7f4 ffbe 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3400c31c:	687b      	ldr	r3, [r7, #4]
3400c31e:	69da      	ldr	r2, [r3, #28]
3400c320:	4b08      	ldr	r3, [pc, #32]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c322:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c324:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3400c328:	429a      	cmp	r2, r3
3400c32a:	d90d      	bls.n	3400c348 <HAL_RCC_ClockConfig+0x22c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3400c32c:	4b05      	ldr	r3, [pc, #20]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c32e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c330:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400c334:	687b      	ldr	r3, [r7, #4]
3400c336:	69db      	ldr	r3, [r3, #28]
3400c338:	4902      	ldr	r1, [pc, #8]	@ (3400c344 <HAL_RCC_ClockConfig+0x228>)
3400c33a:	4313      	orrs	r3, r2
3400c33c:	624b      	str	r3, [r1, #36]	@ 0x24
3400c33e:	e003      	b.n	3400c348 <HAL_RCC_ClockConfig+0x22c>
3400c340:	340243dc 	.word	0x340243dc
3400c344:	56028000 	.word	0x56028000
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3400c348:	687b      	ldr	r3, [r7, #4]
3400c34a:	681b      	ldr	r3, [r3, #0]
3400c34c:	f003 0304 	and.w	r3, r3, #4
3400c350:	2b00      	cmp	r3, #0
3400c352:	d03c      	beq.n	3400c3ce <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
3400c354:	687b      	ldr	r3, [r7, #4]
3400c356:	68db      	ldr	r3, [r3, #12]
3400c358:	2b00      	cmp	r3, #0
3400c35a:	d027      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c35c:	687b      	ldr	r3, [r7, #4]
3400c35e:	68db      	ldr	r3, [r3, #12]
3400c360:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400c364:	d022      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c366:	687b      	ldr	r3, [r7, #4]
3400c368:	68db      	ldr	r3, [r3, #12]
3400c36a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400c36e:	d01d      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c370:	687b      	ldr	r3, [r7, #4]
3400c372:	68db      	ldr	r3, [r3, #12]
3400c374:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400c378:	d018      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c37a:	687b      	ldr	r3, [r7, #4]
3400c37c:	68db      	ldr	r3, [r3, #12]
3400c37e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3400c382:	d013      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c384:	687b      	ldr	r3, [r7, #4]
3400c386:	68db      	ldr	r3, [r3, #12]
3400c388:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
3400c38c:	d00e      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c38e:	687b      	ldr	r3, [r7, #4]
3400c390:	68db      	ldr	r3, [r3, #12]
3400c392:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
3400c396:	d009      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c398:	687b      	ldr	r3, [r7, #4]
3400c39a:	68db      	ldr	r3, [r3, #12]
3400c39c:	f5b3 0fe0 	cmp.w	r3, #7340032	@ 0x700000
3400c3a0:	d004      	beq.n	3400c3ac <HAL_RCC_ClockConfig+0x290>
3400c3a2:	f240 31ab 	movw	r1, #939	@ 0x3ab
3400c3a6:	4874      	ldr	r0, [pc, #464]	@ (3400c578 <HAL_RCC_ClockConfig+0x45c>)
3400c3a8:	f7f4 ff76 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400c3ac:	687b      	ldr	r3, [r7, #4]
3400c3ae:	68da      	ldr	r2, [r3, #12]
3400c3b0:	4b72      	ldr	r3, [pc, #456]	@ (3400c57c <HAL_RCC_ClockConfig+0x460>)
3400c3b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c3b4:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400c3b8:	429a      	cmp	r2, r3
3400c3ba:	d908      	bls.n	3400c3ce <HAL_RCC_ClockConfig+0x2b2>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400c3bc:	4b6f      	ldr	r3, [pc, #444]	@ (3400c57c <HAL_RCC_ClockConfig+0x460>)
3400c3be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c3c0:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3400c3c4:	687b      	ldr	r3, [r7, #4]
3400c3c6:	68db      	ldr	r3, [r3, #12]
3400c3c8:	496c      	ldr	r1, [pc, #432]	@ (3400c57c <HAL_RCC_ClockConfig+0x460>)
3400c3ca:	4313      	orrs	r3, r2
3400c3cc:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
3400c3ce:	687b      	ldr	r3, [r7, #4]
3400c3d0:	681b      	ldr	r3, [r3, #0]
3400c3d2:	f003 0301 	and.w	r3, r3, #1
3400c3d6:	2b00      	cmp	r3, #0
3400c3d8:	f000 80a2 	beq.w	3400c520 <HAL_RCC_ClockConfig+0x404>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));
3400c3dc:	687b      	ldr	r3, [r7, #4]
3400c3de:	685b      	ldr	r3, [r3, #4]
3400c3e0:	2b00      	cmp	r3, #0
3400c3e2:	d013      	beq.n	3400c40c <HAL_RCC_ClockConfig+0x2f0>
3400c3e4:	687b      	ldr	r3, [r7, #4]
3400c3e6:	685b      	ldr	r3, [r3, #4]
3400c3e8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400c3ec:	d00e      	beq.n	3400c40c <HAL_RCC_ClockConfig+0x2f0>
3400c3ee:	687b      	ldr	r3, [r7, #4]
3400c3f0:	685b      	ldr	r3, [r3, #4]
3400c3f2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400c3f6:	d009      	beq.n	3400c40c <HAL_RCC_ClockConfig+0x2f0>
3400c3f8:	687b      	ldr	r3, [r7, #4]
3400c3fa:	685b      	ldr	r3, [r3, #4]
3400c3fc:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400c400:	d004      	beq.n	3400c40c <HAL_RCC_ClockConfig+0x2f0>
3400c402:	f240 31b6 	movw	r1, #950	@ 0x3b6
3400c406:	485c      	ldr	r0, [pc, #368]	@ (3400c578 <HAL_RCC_ClockConfig+0x45c>)
3400c408:	f7f4 ff46 	bl	34001298 <assert_failed>

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
3400c40c:	687b      	ldr	r3, [r7, #4]
3400c40e:	685b      	ldr	r3, [r3, #4]
3400c410:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400c414:	d106      	bne.n	3400c424 <HAL_RCC_ClockConfig+0x308>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3400c416:	f7fe fee7 	bl	3400b1e8 <LL_RCC_HSE_IsReady>
3400c41a:	4603      	mov	r3, r0
3400c41c:	2b00      	cmp	r3, #0
3400c41e:	d15a      	bne.n	3400c4d6 <HAL_RCC_ClockConfig+0x3ba>
      {
        return HAL_ERROR;
3400c420:	2301      	movs	r3, #1
3400c422:	e2f2      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3400c424:	687b      	ldr	r3, [r7, #4]
3400c426:	685b      	ldr	r3, [r3, #4]
3400c428:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400c42c:	d140      	bne.n	3400c4b0 <HAL_RCC_ClockConfig+0x394>
    {
      /* Check parameters */
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
3400c42e:	687b      	ldr	r3, [r7, #4]
3400c430:	6a1b      	ldr	r3, [r3, #32]
3400c432:	2b00      	cmp	r3, #0
3400c434:	d013      	beq.n	3400c45e <HAL_RCC_ClockConfig+0x342>
3400c436:	687b      	ldr	r3, [r7, #4]
3400c438:	6a1b      	ldr	r3, [r3, #32]
3400c43a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c43e:	d00e      	beq.n	3400c45e <HAL_RCC_ClockConfig+0x342>
3400c440:	687b      	ldr	r3, [r7, #4]
3400c442:	6a1b      	ldr	r3, [r3, #32]
3400c444:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c448:	d009      	beq.n	3400c45e <HAL_RCC_ClockConfig+0x342>
3400c44a:	687b      	ldr	r3, [r7, #4]
3400c44c:	6a1b      	ldr	r3, [r3, #32]
3400c44e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c452:	d004      	beq.n	3400c45e <HAL_RCC_ClockConfig+0x342>
3400c454:	f240 31c5 	movw	r1, #965	@ 0x3c5
3400c458:	4847      	ldr	r0, [pc, #284]	@ (3400c578 <HAL_RCC_ClockConfig+0x45c>)
3400c45a:	f7f4 ff1d 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));
3400c45e:	687b      	ldr	r3, [r7, #4]
3400c460:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c462:	2b00      	cmp	r3, #0
3400c464:	d004      	beq.n	3400c470 <HAL_RCC_ClockConfig+0x354>
3400c466:	687b      	ldr	r3, [r7, #4]
3400c468:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c46a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c46e:	d904      	bls.n	3400c47a <HAL_RCC_ClockConfig+0x35e>
3400c470:	f240 31c6 	movw	r1, #966	@ 0x3c6
3400c474:	4840      	ldr	r0, [pc, #256]	@ (3400c578 <HAL_RCC_ClockConfig+0x45c>)
3400c476:	f7f4 ff0f 	bl	34001298 <assert_failed>

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
3400c47a:	f7ff f8d7 	bl	3400b62c <LL_RCC_IC1_GetSource>
3400c47e:	4602      	mov	r2, r0
3400c480:	687b      	ldr	r3, [r7, #4]
3400c482:	6a1b      	ldr	r3, [r3, #32]
3400c484:	4619      	mov	r1, r3
3400c486:	4610      	mov	r0, r2
3400c488:	f000 fe4a 	bl	3400d120 <RCC_IC_CheckPLLSources>
3400c48c:	4603      	mov	r3, r0
3400c48e:	2b01      	cmp	r3, #1
3400c490:	d001      	beq.n	3400c496 <HAL_RCC_ClockConfig+0x37a>
      {
        return HAL_ERROR;
3400c492:	2301      	movs	r3, #1
3400c494:	e2b9      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
3400c496:	687b      	ldr	r3, [r7, #4]
3400c498:	6a1a      	ldr	r2, [r3, #32]
3400c49a:	687b      	ldr	r3, [r7, #4]
3400c49c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c49e:	3b01      	subs	r3, #1
3400c4a0:	041b      	lsls	r3, r3, #16
3400c4a2:	4936      	ldr	r1, [pc, #216]	@ (3400c57c <HAL_RCC_ClockConfig+0x460>)
3400c4a4:	4313      	orrs	r3, r2
3400c4a6:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
3400c4aa:	f7ff f8b1 	bl	3400b610 <LL_RCC_IC1_Enable>
3400c4ae:	e012      	b.n	3400c4d6 <HAL_RCC_ClockConfig+0x3ba>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
3400c4b0:	687b      	ldr	r3, [r7, #4]
3400c4b2:	685b      	ldr	r3, [r3, #4]
3400c4b4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400c4b8:	d106      	bne.n	3400c4c8 <HAL_RCC_ClockConfig+0x3ac>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3400c4ba:	f7fe ff2d 	bl	3400b318 <LL_RCC_MSI_IsReady>
3400c4be:	4603      	mov	r3, r0
3400c4c0:	2b00      	cmp	r3, #0
3400c4c2:	d108      	bne.n	3400c4d6 <HAL_RCC_ClockConfig+0x3ba>
      {
        return HAL_ERROR;
3400c4c4:	2301      	movs	r3, #1
3400c4c6:	e2a0      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3400c4c8:	f7fe febe 	bl	3400b248 <LL_RCC_HSI_IsReady>
3400c4cc:	4603      	mov	r3, r0
3400c4ce:	2b00      	cmp	r3, #0
3400c4d0:	d101      	bne.n	3400c4d6 <HAL_RCC_ClockConfig+0x3ba>
      {
        return HAL_ERROR;
3400c4d2:	2301      	movs	r3, #1
3400c4d4:	e299      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3400c4d6:	4b29      	ldr	r3, [pc, #164]	@ (3400c57c <HAL_RCC_ClockConfig+0x460>)
3400c4d8:	6a1b      	ldr	r3, [r3, #32]
3400c4da:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
3400c4de:	687b      	ldr	r3, [r7, #4]
3400c4e0:	685b      	ldr	r3, [r3, #4]
3400c4e2:	4926      	ldr	r1, [pc, #152]	@ (3400c57c <HAL_RCC_ClockConfig+0x460>)
3400c4e4:	4313      	orrs	r3, r2
3400c4e6:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400c4e8:	f7fb f87a 	bl	340075e0 <HAL_GetTick>
3400c4ec:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3400c4ee:	e00a      	b.n	3400c506 <HAL_RCC_ClockConfig+0x3ea>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400c4f0:	f7fb f876 	bl	340075e0 <HAL_GetTick>
3400c4f4:	4602      	mov	r2, r0
3400c4f6:	68fb      	ldr	r3, [r7, #12]
3400c4f8:	1ad3      	subs	r3, r2, r3
3400c4fa:	f241 3288 	movw	r2, #5000	@ 0x1388
3400c4fe:	4293      	cmp	r3, r2
3400c500:	d901      	bls.n	3400c506 <HAL_RCC_ClockConfig+0x3ea>
      {
        return HAL_TIMEOUT;
3400c502:	2303      	movs	r3, #3
3400c504:	e281      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3400c506:	f7fe ff8f 	bl	3400b428 <LL_RCC_GetCpuClkSource>
3400c50a:	4602      	mov	r2, r0
3400c50c:	687b      	ldr	r3, [r7, #4]
3400c50e:	685b      	ldr	r3, [r3, #4]
3400c510:	011b      	lsls	r3, r3, #4
3400c512:	429a      	cmp	r2, r3
3400c514:	d1ec      	bne.n	3400c4f0 <HAL_RCC_ClockConfig+0x3d4>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3400c516:	f000 fa83 	bl	3400ca20 <HAL_RCC_GetCpuClockFreq>
3400c51a:	4603      	mov	r3, r0
3400c51c:	4a18      	ldr	r2, [pc, #96]	@ (3400c580 <HAL_RCC_ClockConfig+0x464>)
3400c51e:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3400c520:	687b      	ldr	r3, [r7, #4]
3400c522:	681b      	ldr	r3, [r3, #0]
3400c524:	f003 0302 	and.w	r3, r3, #2
3400c528:	2b00      	cmp	r3, #0
3400c52a:	f000 8127 	beq.w	3400c77c <HAL_RCC_ClockConfig+0x660>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
3400c52e:	687b      	ldr	r3, [r7, #4]
3400c530:	689b      	ldr	r3, [r3, #8]
3400c532:	2b00      	cmp	r3, #0
3400c534:	d013      	beq.n	3400c55e <HAL_RCC_ClockConfig+0x442>
3400c536:	687b      	ldr	r3, [r7, #4]
3400c538:	689b      	ldr	r3, [r3, #8]
3400c53a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400c53e:	d00e      	beq.n	3400c55e <HAL_RCC_ClockConfig+0x442>
3400c540:	687b      	ldr	r3, [r7, #4]
3400c542:	689b      	ldr	r3, [r3, #8]
3400c544:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400c548:	d009      	beq.n	3400c55e <HAL_RCC_ClockConfig+0x442>
3400c54a:	687b      	ldr	r3, [r7, #4]
3400c54c:	689b      	ldr	r3, [r3, #8]
3400c54e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400c552:	d004      	beq.n	3400c55e <HAL_RCC_ClockConfig+0x442>
3400c554:	f240 31ff 	movw	r1, #1023	@ 0x3ff
3400c558:	4807      	ldr	r0, [pc, #28]	@ (3400c578 <HAL_RCC_ClockConfig+0x45c>)
3400c55a:	f7f4 fe9d 	bl	34001298 <assert_failed>

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3400c55e:	687b      	ldr	r3, [r7, #4]
3400c560:	689b      	ldr	r3, [r3, #8]
3400c562:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400c566:	d10d      	bne.n	3400c584 <HAL_RCC_ClockConfig+0x468>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3400c568:	f7fe fe3e 	bl	3400b1e8 <LL_RCC_HSE_IsReady>
3400c56c:	4603      	mov	r3, r0
3400c56e:	2b00      	cmp	r3, #0
3400c570:	f040 80e0 	bne.w	3400c734 <HAL_RCC_ClockConfig+0x618>
      {
        return HAL_ERROR;
3400c574:	2301      	movs	r3, #1
3400c576:	e248      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
3400c578:	340243dc 	.word	0x340243dc
3400c57c:	56028000 	.word	0x56028000
3400c580:	34033f48 	.word	0x34033f48
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
3400c584:	687b      	ldr	r3, [r7, #4]
3400c586:	689b      	ldr	r3, [r3, #8]
3400c588:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400c58c:	f040 80c0 	bne.w	3400c710 <HAL_RCC_ClockConfig+0x5f4>
    {
      /* Check parameters */
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC2Selection.ClockSelection));
3400c590:	687b      	ldr	r3, [r7, #4]
3400c592:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400c594:	2b00      	cmp	r3, #0
3400c596:	d013      	beq.n	3400c5c0 <HAL_RCC_ClockConfig+0x4a4>
3400c598:	687b      	ldr	r3, [r7, #4]
3400c59a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400c59c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c5a0:	d00e      	beq.n	3400c5c0 <HAL_RCC_ClockConfig+0x4a4>
3400c5a2:	687b      	ldr	r3, [r7, #4]
3400c5a4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400c5a6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c5aa:	d009      	beq.n	3400c5c0 <HAL_RCC_ClockConfig+0x4a4>
3400c5ac:	687b      	ldr	r3, [r7, #4]
3400c5ae:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400c5b0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c5b4:	d004      	beq.n	3400c5c0 <HAL_RCC_ClockConfig+0x4a4>
3400c5b6:	f240 410e 	movw	r1, #1038	@ 0x40e
3400c5ba:	486a      	ldr	r0, [pc, #424]	@ (3400c764 <HAL_RCC_ClockConfig+0x648>)
3400c5bc:	f7f4 fe6c 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC2Selection.ClockDivider));
3400c5c0:	687b      	ldr	r3, [r7, #4]
3400c5c2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400c5c4:	2b00      	cmp	r3, #0
3400c5c6:	d004      	beq.n	3400c5d2 <HAL_RCC_ClockConfig+0x4b6>
3400c5c8:	687b      	ldr	r3, [r7, #4]
3400c5ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400c5cc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c5d0:	d904      	bls.n	3400c5dc <HAL_RCC_ClockConfig+0x4c0>
3400c5d2:	f240 410f 	movw	r1, #1039	@ 0x40f
3400c5d6:	4863      	ldr	r0, [pc, #396]	@ (3400c764 <HAL_RCC_ClockConfig+0x648>)
3400c5d8:	f7f4 fe5e 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC6Selection.ClockSelection));
3400c5dc:	687b      	ldr	r3, [r7, #4]
3400c5de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400c5e0:	2b00      	cmp	r3, #0
3400c5e2:	d013      	beq.n	3400c60c <HAL_RCC_ClockConfig+0x4f0>
3400c5e4:	687b      	ldr	r3, [r7, #4]
3400c5e6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400c5e8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c5ec:	d00e      	beq.n	3400c60c <HAL_RCC_ClockConfig+0x4f0>
3400c5ee:	687b      	ldr	r3, [r7, #4]
3400c5f0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400c5f2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c5f6:	d009      	beq.n	3400c60c <HAL_RCC_ClockConfig+0x4f0>
3400c5f8:	687b      	ldr	r3, [r7, #4]
3400c5fa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400c5fc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c600:	d004      	beq.n	3400c60c <HAL_RCC_ClockConfig+0x4f0>
3400c602:	f44f 6182 	mov.w	r1, #1040	@ 0x410
3400c606:	4857      	ldr	r0, [pc, #348]	@ (3400c764 <HAL_RCC_ClockConfig+0x648>)
3400c608:	f7f4 fe46 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC6Selection.ClockDivider));
3400c60c:	687b      	ldr	r3, [r7, #4]
3400c60e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400c610:	2b00      	cmp	r3, #0
3400c612:	d004      	beq.n	3400c61e <HAL_RCC_ClockConfig+0x502>
3400c614:	687b      	ldr	r3, [r7, #4]
3400c616:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400c618:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c61c:	d904      	bls.n	3400c628 <HAL_RCC_ClockConfig+0x50c>
3400c61e:	f240 4111 	movw	r1, #1041	@ 0x411
3400c622:	4850      	ldr	r0, [pc, #320]	@ (3400c764 <HAL_RCC_ClockConfig+0x648>)
3400c624:	f7f4 fe38 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
3400c628:	687b      	ldr	r3, [r7, #4]
3400c62a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400c62c:	2b00      	cmp	r3, #0
3400c62e:	d013      	beq.n	3400c658 <HAL_RCC_ClockConfig+0x53c>
3400c630:	687b      	ldr	r3, [r7, #4]
3400c632:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400c634:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400c638:	d00e      	beq.n	3400c658 <HAL_RCC_ClockConfig+0x53c>
3400c63a:	687b      	ldr	r3, [r7, #4]
3400c63c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400c63e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400c642:	d009      	beq.n	3400c658 <HAL_RCC_ClockConfig+0x53c>
3400c644:	687b      	ldr	r3, [r7, #4]
3400c646:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400c648:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400c64c:	d004      	beq.n	3400c658 <HAL_RCC_ClockConfig+0x53c>
3400c64e:	f240 4112 	movw	r1, #1042	@ 0x412
3400c652:	4844      	ldr	r0, [pc, #272]	@ (3400c764 <HAL_RCC_ClockConfig+0x648>)
3400c654:	f7f4 fe20 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));
3400c658:	687b      	ldr	r3, [r7, #4]
3400c65a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400c65c:	2b00      	cmp	r3, #0
3400c65e:	d004      	beq.n	3400c66a <HAL_RCC_ClockConfig+0x54e>
3400c660:	687b      	ldr	r3, [r7, #4]
3400c662:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400c664:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c668:	d904      	bls.n	3400c674 <HAL_RCC_ClockConfig+0x558>
3400c66a:	f240 4113 	movw	r1, #1043	@ 0x413
3400c66e:	483d      	ldr	r0, [pc, #244]	@ (3400c764 <HAL_RCC_ClockConfig+0x648>)
3400c670:	f7f4 fe12 	bl	34001298 <assert_failed>

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3400c674:	f7fe fff8 	bl	3400b668 <LL_RCC_IC2_GetSource>
3400c678:	4602      	mov	r2, r0
3400c67a:	687b      	ldr	r3, [r7, #4]
3400c67c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400c67e:	4619      	mov	r1, r3
3400c680:	4610      	mov	r0, r2
3400c682:	f000 fd4d 	bl	3400d120 <RCC_IC_CheckPLLSources>
3400c686:	4603      	mov	r3, r0
3400c688:	2b01      	cmp	r3, #1
3400c68a:	d001      	beq.n	3400c690 <HAL_RCC_ClockConfig+0x574>
      {
        return HAL_ERROR;
3400c68c:	2301      	movs	r3, #1
3400c68e:	e1bc      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3400c690:	f7ff f808 	bl	3400b6a4 <LL_RCC_IC6_GetSource>
3400c694:	4602      	mov	r2, r0
3400c696:	687b      	ldr	r3, [r7, #4]
3400c698:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400c69a:	4619      	mov	r1, r3
3400c69c:	4610      	mov	r0, r2
3400c69e:	f000 fd3f 	bl	3400d120 <RCC_IC_CheckPLLSources>
3400c6a2:	4603      	mov	r3, r0
3400c6a4:	2b01      	cmp	r3, #1
3400c6a6:	d001      	beq.n	3400c6ac <HAL_RCC_ClockConfig+0x590>
      {
        return HAL_ERROR;
3400c6a8:	2301      	movs	r3, #1
3400c6aa:	e1ae      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3400c6ac:	f7ff f808 	bl	3400b6c0 <LL_RCC_IC11_GetSource>
3400c6b0:	4602      	mov	r2, r0
3400c6b2:	687b      	ldr	r3, [r7, #4]
3400c6b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400c6b6:	4619      	mov	r1, r3
3400c6b8:	4610      	mov	r0, r2
3400c6ba:	f000 fd31 	bl	3400d120 <RCC_IC_CheckPLLSources>
3400c6be:	4603      	mov	r3, r0
3400c6c0:	2b01      	cmp	r3, #1
3400c6c2:	d001      	beq.n	3400c6c8 <HAL_RCC_ClockConfig+0x5ac>
      {
        return HAL_ERROR;
3400c6c4:	2301      	movs	r3, #1
3400c6c6:	e1a0      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3400c6c8:	687b      	ldr	r3, [r7, #4]
3400c6ca:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400c6cc:	687b      	ldr	r3, [r7, #4]
3400c6ce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400c6d0:	3b01      	subs	r3, #1
3400c6d2:	041b      	lsls	r3, r3, #16
3400c6d4:	4924      	ldr	r1, [pc, #144]	@ (3400c768 <HAL_RCC_ClockConfig+0x64c>)
3400c6d6:	4313      	orrs	r3, r2
3400c6d8:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3400c6dc:	687b      	ldr	r3, [r7, #4]
3400c6de:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3400c6e0:	687b      	ldr	r3, [r7, #4]
3400c6e2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400c6e4:	3b01      	subs	r3, #1
3400c6e6:	041b      	lsls	r3, r3, #16
3400c6e8:	491f      	ldr	r1, [pc, #124]	@ (3400c768 <HAL_RCC_ClockConfig+0x64c>)
3400c6ea:	4313      	orrs	r3, r2
3400c6ec:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3400c6f0:	687b      	ldr	r3, [r7, #4]
3400c6f2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400c6f4:	687b      	ldr	r3, [r7, #4]
3400c6f6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400c6f8:	3b01      	subs	r3, #1
3400c6fa:	041b      	lsls	r3, r3, #16
3400c6fc:	491a      	ldr	r1, [pc, #104]	@ (3400c768 <HAL_RCC_ClockConfig+0x64c>)
3400c6fe:	4313      	orrs	r3, r2
3400c700:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3400c704:	4b18      	ldr	r3, [pc, #96]	@ (3400c768 <HAL_RCC_ClockConfig+0x64c>)
3400c706:	f240 4222 	movw	r2, #1058	@ 0x422
3400c70a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
3400c70e:	e011      	b.n	3400c734 <HAL_RCC_ClockConfig+0x618>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3400c710:	687b      	ldr	r3, [r7, #4]
3400c712:	689b      	ldr	r3, [r3, #8]
3400c714:	2b00      	cmp	r3, #0
3400c716:	d106      	bne.n	3400c726 <HAL_RCC_ClockConfig+0x60a>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3400c718:	f7fe fd96 	bl	3400b248 <LL_RCC_HSI_IsReady>
3400c71c:	4603      	mov	r3, r0
3400c71e:	2b00      	cmp	r3, #0
3400c720:	d108      	bne.n	3400c734 <HAL_RCC_ClockConfig+0x618>
      {
        return HAL_ERROR;
3400c722:	2301      	movs	r3, #1
3400c724:	e171      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3400c726:	f7fe fdf7 	bl	3400b318 <LL_RCC_MSI_IsReady>
3400c72a:	4603      	mov	r3, r0
3400c72c:	2b00      	cmp	r3, #0
3400c72e:	d101      	bne.n	3400c734 <HAL_RCC_ClockConfig+0x618>
      {
        return HAL_ERROR;
3400c730:	2301      	movs	r3, #1
3400c732:	e16a      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3400c734:	4b0c      	ldr	r3, [pc, #48]	@ (3400c768 <HAL_RCC_ClockConfig+0x64c>)
3400c736:	6a1b      	ldr	r3, [r3, #32]
3400c738:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3400c73c:	687b      	ldr	r3, [r7, #4]
3400c73e:	689b      	ldr	r3, [r3, #8]
3400c740:	4909      	ldr	r1, [pc, #36]	@ (3400c768 <HAL_RCC_ClockConfig+0x64c>)
3400c742:	4313      	orrs	r3, r2
3400c744:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400c746:	f7fa ff4b 	bl	340075e0 <HAL_GetTick>
3400c74a:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3400c74c:	e00e      	b.n	3400c76c <HAL_RCC_ClockConfig+0x650>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400c74e:	f7fa ff47 	bl	340075e0 <HAL_GetTick>
3400c752:	4602      	mov	r2, r0
3400c754:	68fb      	ldr	r3, [r7, #12]
3400c756:	1ad3      	subs	r3, r2, r3
3400c758:	f241 3288 	movw	r2, #5000	@ 0x1388
3400c75c:	4293      	cmp	r3, r2
3400c75e:	d905      	bls.n	3400c76c <HAL_RCC_ClockConfig+0x650>
      {
        return HAL_TIMEOUT;
3400c760:	2303      	movs	r3, #3
3400c762:	e152      	b.n	3400ca0a <HAL_RCC_ClockConfig+0x8ee>
3400c764:	340243dc 	.word	0x340243dc
3400c768:	56028000 	.word	0x56028000
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3400c76c:	f7fe fe6a 	bl	3400b444 <LL_RCC_GetSysClkSource>
3400c770:	4602      	mov	r2, r0
3400c772:	687b      	ldr	r3, [r7, #4]
3400c774:	689b      	ldr	r3, [r3, #8]
3400c776:	011b      	lsls	r3, r3, #4
3400c778:	429a      	cmp	r2, r3
3400c77a:	d1e8      	bne.n	3400c74e <HAL_RCC_ClockConfig+0x632>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3400c77c:	687b      	ldr	r3, [r7, #4]
3400c77e:	681b      	ldr	r3, [r3, #0]
3400c780:	f003 0304 	and.w	r3, r3, #4
3400c784:	2b00      	cmp	r3, #0
3400c786:	d03c      	beq.n	3400c802 <HAL_RCC_ClockConfig+0x6e6>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
3400c788:	687b      	ldr	r3, [r7, #4]
3400c78a:	68db      	ldr	r3, [r3, #12]
3400c78c:	2b00      	cmp	r3, #0
3400c78e:	d027      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c790:	687b      	ldr	r3, [r7, #4]
3400c792:	68db      	ldr	r3, [r3, #12]
3400c794:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400c798:	d022      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c79a:	687b      	ldr	r3, [r7, #4]
3400c79c:	68db      	ldr	r3, [r3, #12]
3400c79e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400c7a2:	d01d      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c7a4:	687b      	ldr	r3, [r7, #4]
3400c7a6:	68db      	ldr	r3, [r3, #12]
3400c7a8:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400c7ac:	d018      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c7ae:	687b      	ldr	r3, [r7, #4]
3400c7b0:	68db      	ldr	r3, [r3, #12]
3400c7b2:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3400c7b6:	d013      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c7b8:	687b      	ldr	r3, [r7, #4]
3400c7ba:	68db      	ldr	r3, [r3, #12]
3400c7bc:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
3400c7c0:	d00e      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c7c2:	687b      	ldr	r3, [r7, #4]
3400c7c4:	68db      	ldr	r3, [r3, #12]
3400c7c6:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
3400c7ca:	d009      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c7cc:	687b      	ldr	r3, [r7, #4]
3400c7ce:	68db      	ldr	r3, [r3, #12]
3400c7d0:	f5b3 0fe0 	cmp.w	r3, #7340032	@ 0x700000
3400c7d4:	d004      	beq.n	3400c7e0 <HAL_RCC_ClockConfig+0x6c4>
3400c7d6:	f240 4156 	movw	r1, #1110	@ 0x456
3400c7da:	488e      	ldr	r0, [pc, #568]	@ (3400ca14 <HAL_RCC_ClockConfig+0x8f8>)
3400c7dc:	f7f4 fd5c 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400c7e0:	687b      	ldr	r3, [r7, #4]
3400c7e2:	68da      	ldr	r2, [r3, #12]
3400c7e4:	4b8c      	ldr	r3, [pc, #560]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c7e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c7e8:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400c7ec:	429a      	cmp	r2, r3
3400c7ee:	d208      	bcs.n	3400c802 <HAL_RCC_ClockConfig+0x6e6>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400c7f0:	4b89      	ldr	r3, [pc, #548]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c7f2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c7f4:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3400c7f8:	687b      	ldr	r3, [r7, #4]
3400c7fa:	68db      	ldr	r3, [r3, #12]
3400c7fc:	4986      	ldr	r1, [pc, #536]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c7fe:	4313      	orrs	r3, r2
3400c800:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400c802:	687b      	ldr	r3, [r7, #4]
3400c804:	681b      	ldr	r3, [r3, #0]
3400c806:	f003 0308 	and.w	r3, r3, #8
3400c80a:	2b00      	cmp	r3, #0
3400c80c:	d035      	beq.n	3400c87a <HAL_RCC_ClockConfig+0x75e>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
3400c80e:	687b      	ldr	r3, [r7, #4]
3400c810:	691b      	ldr	r3, [r3, #16]
3400c812:	2b00      	cmp	r3, #0
3400c814:	d020      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c816:	687b      	ldr	r3, [r7, #4]
3400c818:	691b      	ldr	r3, [r3, #16]
3400c81a:	2b01      	cmp	r3, #1
3400c81c:	d01c      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c81e:	687b      	ldr	r3, [r7, #4]
3400c820:	691b      	ldr	r3, [r3, #16]
3400c822:	2b02      	cmp	r3, #2
3400c824:	d018      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c826:	687b      	ldr	r3, [r7, #4]
3400c828:	691b      	ldr	r3, [r3, #16]
3400c82a:	2b03      	cmp	r3, #3
3400c82c:	d014      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c82e:	687b      	ldr	r3, [r7, #4]
3400c830:	691b      	ldr	r3, [r3, #16]
3400c832:	2b04      	cmp	r3, #4
3400c834:	d010      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c836:	687b      	ldr	r3, [r7, #4]
3400c838:	691b      	ldr	r3, [r3, #16]
3400c83a:	2b05      	cmp	r3, #5
3400c83c:	d00c      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c83e:	687b      	ldr	r3, [r7, #4]
3400c840:	691b      	ldr	r3, [r3, #16]
3400c842:	2b06      	cmp	r3, #6
3400c844:	d008      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c846:	687b      	ldr	r3, [r7, #4]
3400c848:	691b      	ldr	r3, [r3, #16]
3400c84a:	2b07      	cmp	r3, #7
3400c84c:	d004      	beq.n	3400c858 <HAL_RCC_ClockConfig+0x73c>
3400c84e:	f240 4161 	movw	r1, #1121	@ 0x461
3400c852:	4870      	ldr	r0, [pc, #448]	@ (3400ca14 <HAL_RCC_ClockConfig+0x8f8>)
3400c854:	f7f4 fd20 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3400c858:	687b      	ldr	r3, [r7, #4]
3400c85a:	691a      	ldr	r2, [r3, #16]
3400c85c:	4b6e      	ldr	r3, [pc, #440]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c85e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c860:	f003 0307 	and.w	r3, r3, #7
3400c864:	429a      	cmp	r2, r3
3400c866:	d208      	bcs.n	3400c87a <HAL_RCC_ClockConfig+0x75e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3400c868:	4b6b      	ldr	r3, [pc, #428]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c86a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c86c:	f023 0207 	bic.w	r2, r3, #7
3400c870:	687b      	ldr	r3, [r7, #4]
3400c872:	691b      	ldr	r3, [r3, #16]
3400c874:	4968      	ldr	r1, [pc, #416]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c876:	4313      	orrs	r3, r2
3400c878:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3400c87a:	687b      	ldr	r3, [r7, #4]
3400c87c:	681b      	ldr	r3, [r3, #0]
3400c87e:	f003 0310 	and.w	r3, r3, #16
3400c882:	2b00      	cmp	r3, #0
3400c884:	d035      	beq.n	3400c8f2 <HAL_RCC_ClockConfig+0x7d6>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
3400c886:	687b      	ldr	r3, [r7, #4]
3400c888:	695b      	ldr	r3, [r3, #20]
3400c88a:	2b00      	cmp	r3, #0
3400c88c:	d020      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c88e:	687b      	ldr	r3, [r7, #4]
3400c890:	695b      	ldr	r3, [r3, #20]
3400c892:	2b10      	cmp	r3, #16
3400c894:	d01c      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c896:	687b      	ldr	r3, [r7, #4]
3400c898:	695b      	ldr	r3, [r3, #20]
3400c89a:	2b20      	cmp	r3, #32
3400c89c:	d018      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c89e:	687b      	ldr	r3, [r7, #4]
3400c8a0:	695b      	ldr	r3, [r3, #20]
3400c8a2:	2b30      	cmp	r3, #48	@ 0x30
3400c8a4:	d014      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c8a6:	687b      	ldr	r3, [r7, #4]
3400c8a8:	695b      	ldr	r3, [r3, #20]
3400c8aa:	2b40      	cmp	r3, #64	@ 0x40
3400c8ac:	d010      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c8ae:	687b      	ldr	r3, [r7, #4]
3400c8b0:	695b      	ldr	r3, [r3, #20]
3400c8b2:	2b50      	cmp	r3, #80	@ 0x50
3400c8b4:	d00c      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c8b6:	687b      	ldr	r3, [r7, #4]
3400c8b8:	695b      	ldr	r3, [r3, #20]
3400c8ba:	2b60      	cmp	r3, #96	@ 0x60
3400c8bc:	d008      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c8be:	687b      	ldr	r3, [r7, #4]
3400c8c0:	695b      	ldr	r3, [r3, #20]
3400c8c2:	2b70      	cmp	r3, #112	@ 0x70
3400c8c4:	d004      	beq.n	3400c8d0 <HAL_RCC_ClockConfig+0x7b4>
3400c8c6:	f240 416b 	movw	r1, #1131	@ 0x46b
3400c8ca:	4852      	ldr	r0, [pc, #328]	@ (3400ca14 <HAL_RCC_ClockConfig+0x8f8>)
3400c8cc:	f7f4 fce4 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3400c8d0:	687b      	ldr	r3, [r7, #4]
3400c8d2:	695a      	ldr	r2, [r3, #20]
3400c8d4:	4b50      	ldr	r3, [pc, #320]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c8d6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c8d8:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3400c8dc:	429a      	cmp	r2, r3
3400c8de:	d208      	bcs.n	3400c8f2 <HAL_RCC_ClockConfig+0x7d6>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3400c8e0:	4b4d      	ldr	r3, [pc, #308]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c8e2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c8e4:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3400c8e8:	687b      	ldr	r3, [r7, #4]
3400c8ea:	695b      	ldr	r3, [r3, #20]
3400c8ec:	494a      	ldr	r1, [pc, #296]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c8ee:	4313      	orrs	r3, r2
3400c8f0:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400c8f2:	687b      	ldr	r3, [r7, #4]
3400c8f4:	681b      	ldr	r3, [r3, #0]
3400c8f6:	f003 0320 	and.w	r3, r3, #32
3400c8fa:	2b00      	cmp	r3, #0
3400c8fc:	d03c      	beq.n	3400c978 <HAL_RCC_ClockConfig+0x85c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
3400c8fe:	687b      	ldr	r3, [r7, #4]
3400c900:	699b      	ldr	r3, [r3, #24]
3400c902:	2b00      	cmp	r3, #0
3400c904:	d027      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c906:	687b      	ldr	r3, [r7, #4]
3400c908:	699b      	ldr	r3, [r3, #24]
3400c90a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400c90e:	d022      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c910:	687b      	ldr	r3, [r7, #4]
3400c912:	699b      	ldr	r3, [r3, #24]
3400c914:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400c918:	d01d      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c91a:	687b      	ldr	r3, [r7, #4]
3400c91c:	699b      	ldr	r3, [r3, #24]
3400c91e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3400c922:	d018      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c924:	687b      	ldr	r3, [r7, #4]
3400c926:	699b      	ldr	r3, [r3, #24]
3400c928:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400c92c:	d013      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c92e:	687b      	ldr	r3, [r7, #4]
3400c930:	699b      	ldr	r3, [r3, #24]
3400c932:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
3400c936:	d00e      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c938:	687b      	ldr	r3, [r7, #4]
3400c93a:	699b      	ldr	r3, [r3, #24]
3400c93c:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
3400c940:	d009      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c942:	687b      	ldr	r3, [r7, #4]
3400c944:	699b      	ldr	r3, [r3, #24]
3400c946:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
3400c94a:	d004      	beq.n	3400c956 <HAL_RCC_ClockConfig+0x83a>
3400c94c:	f240 4175 	movw	r1, #1141	@ 0x475
3400c950:	4830      	ldr	r0, [pc, #192]	@ (3400ca14 <HAL_RCC_ClockConfig+0x8f8>)
3400c952:	f7f4 fca1 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3400c956:	687b      	ldr	r3, [r7, #4]
3400c958:	699a      	ldr	r2, [r3, #24]
3400c95a:	4b2f      	ldr	r3, [pc, #188]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c95c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c95e:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3400c962:	429a      	cmp	r2, r3
3400c964:	d208      	bcs.n	3400c978 <HAL_RCC_ClockConfig+0x85c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3400c966:	4b2c      	ldr	r3, [pc, #176]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c968:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c96a:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3400c96e:	687b      	ldr	r3, [r7, #4]
3400c970:	699b      	ldr	r3, [r3, #24]
3400c972:	4929      	ldr	r1, [pc, #164]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c974:	4313      	orrs	r3, r2
3400c976:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3400c978:	687b      	ldr	r3, [r7, #4]
3400c97a:	681b      	ldr	r3, [r3, #0]
3400c97c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400c980:	2b00      	cmp	r3, #0
3400c982:	d03c      	beq.n	3400c9fe <HAL_RCC_ClockConfig+0x8e2>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
3400c984:	687b      	ldr	r3, [r7, #4]
3400c986:	69db      	ldr	r3, [r3, #28]
3400c988:	2b00      	cmp	r3, #0
3400c98a:	d027      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c98c:	687b      	ldr	r3, [r7, #4]
3400c98e:	69db      	ldr	r3, [r3, #28]
3400c990:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400c994:	d022      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c996:	687b      	ldr	r3, [r7, #4]
3400c998:	69db      	ldr	r3, [r3, #28]
3400c99a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400c99e:	d01d      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c9a0:	687b      	ldr	r3, [r7, #4]
3400c9a2:	69db      	ldr	r3, [r3, #28]
3400c9a4:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400c9a8:	d018      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c9aa:	687b      	ldr	r3, [r7, #4]
3400c9ac:	69db      	ldr	r3, [r3, #28]
3400c9ae:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400c9b2:	d013      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c9b4:	687b      	ldr	r3, [r7, #4]
3400c9b6:	69db      	ldr	r3, [r3, #28]
3400c9b8:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400c9bc:	d00e      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c9be:	687b      	ldr	r3, [r7, #4]
3400c9c0:	69db      	ldr	r3, [r3, #28]
3400c9c2:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400c9c6:	d009      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c9c8:	687b      	ldr	r3, [r7, #4]
3400c9ca:	69db      	ldr	r3, [r3, #28]
3400c9cc:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3400c9d0:	d004      	beq.n	3400c9dc <HAL_RCC_ClockConfig+0x8c0>
3400c9d2:	f240 417f 	movw	r1, #1151	@ 0x47f
3400c9d6:	480f      	ldr	r0, [pc, #60]	@ (3400ca14 <HAL_RCC_ClockConfig+0x8f8>)
3400c9d8:	f7f4 fc5e 	bl	34001298 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3400c9dc:	687b      	ldr	r3, [r7, #4]
3400c9de:	69da      	ldr	r2, [r3, #28]
3400c9e0:	4b0d      	ldr	r3, [pc, #52]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c9e2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c9e4:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3400c9e8:	429a      	cmp	r2, r3
3400c9ea:	d208      	bcs.n	3400c9fe <HAL_RCC_ClockConfig+0x8e2>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3400c9ec:	4b0a      	ldr	r3, [pc, #40]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c9ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400c9f0:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400c9f4:	687b      	ldr	r3, [r7, #4]
3400c9f6:	69db      	ldr	r3, [r3, #28]
3400c9f8:	4907      	ldr	r1, [pc, #28]	@ (3400ca18 <HAL_RCC_ClockConfig+0x8fc>)
3400c9fa:	4313      	orrs	r3, r2
3400c9fc:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
3400c9fe:	4b07      	ldr	r3, [pc, #28]	@ (3400ca1c <HAL_RCC_ClockConfig+0x900>)
3400ca00:	681b      	ldr	r3, [r3, #0]
3400ca02:	4618      	mov	r0, r3
3400ca04:	f7fa fda2 	bl	3400754c <HAL_InitTick>
3400ca08:	4603      	mov	r3, r0
}
3400ca0a:	4618      	mov	r0, r3
3400ca0c:	3710      	adds	r7, #16
3400ca0e:	46bd      	mov	sp, r7
3400ca10:	bd80      	pop	{r7, pc}
3400ca12:	bf00      	nop
3400ca14:	340243dc 	.word	0x340243dc
3400ca18:	56028000 	.word	0x56028000
3400ca1c:	34033f4c 	.word	0x34033f4c

3400ca20 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
3400ca20:	b580      	push	{r7, lr}
3400ca22:	b082      	sub	sp, #8
3400ca24:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3400ca26:	2300      	movs	r3, #0
3400ca28:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
3400ca2a:	f7fe fcfd 	bl	3400b428 <LL_RCC_GetCpuClkSource>
3400ca2e:	4603      	mov	r3, r0
3400ca30:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400ca34:	d025      	beq.n	3400ca82 <HAL_RCC_GetCpuClockFreq+0x62>
3400ca36:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400ca3a:	d860      	bhi.n	3400cafe <HAL_RCC_GetCpuClockFreq+0xde>
3400ca3c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400ca40:	d01c      	beq.n	3400ca7c <HAL_RCC_GetCpuClockFreq+0x5c>
3400ca42:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400ca46:	d85a      	bhi.n	3400cafe <HAL_RCC_GetCpuClockFreq+0xde>
3400ca48:	2b00      	cmp	r3, #0
3400ca4a:	d003      	beq.n	3400ca54 <HAL_RCC_GetCpuClockFreq+0x34>
3400ca4c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400ca50:	d009      	beq.n	3400ca66 <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3400ca52:	e054      	b.n	3400cafe <HAL_RCC_GetCpuClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400ca54:	f7fe fc1e 	bl	3400b294 <LL_RCC_HSI_GetDivider>
3400ca58:	4603      	mov	r3, r0
3400ca5a:	09db      	lsrs	r3, r3, #7
3400ca5c:	4a2b      	ldr	r2, [pc, #172]	@ (3400cb0c <HAL_RCC_GetCpuClockFreq+0xec>)
3400ca5e:	fa22 f303 	lsr.w	r3, r2, r3
3400ca62:	607b      	str	r3, [r7, #4]
      break;
3400ca64:	e04c      	b.n	3400cb00 <HAL_RCC_GetCpuClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3400ca66:	f7fe fc7d 	bl	3400b364 <LL_RCC_MSI_GetFrequency>
3400ca6a:	4603      	mov	r3, r0
3400ca6c:	2b00      	cmp	r3, #0
3400ca6e:	d102      	bne.n	3400ca76 <HAL_RCC_GetCpuClockFreq+0x56>
        frequency = MSI_VALUE;
3400ca70:	4b27      	ldr	r3, [pc, #156]	@ (3400cb10 <HAL_RCC_GetCpuClockFreq+0xf0>)
3400ca72:	607b      	str	r3, [r7, #4]
      break;
3400ca74:	e044      	b.n	3400cb00 <HAL_RCC_GetCpuClockFreq+0xe0>
        frequency = 16000000UL;
3400ca76:	4b27      	ldr	r3, [pc, #156]	@ (3400cb14 <HAL_RCC_GetCpuClockFreq+0xf4>)
3400ca78:	607b      	str	r3, [r7, #4]
      break;
3400ca7a:	e041      	b.n	3400cb00 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSE_VALUE;
3400ca7c:	4b26      	ldr	r3, [pc, #152]	@ (3400cb18 <HAL_RCC_GetCpuClockFreq+0xf8>)
3400ca7e:	607b      	str	r3, [r7, #4]
      break;
3400ca80:	e03e      	b.n	3400cb00 <HAL_RCC_GetCpuClockFreq+0xe0>
      ic_divider = LL_RCC_IC1_GetDivider();
3400ca82:	f7fe fde1 	bl	3400b648 <LL_RCC_IC1_GetDivider>
3400ca86:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
3400ca88:	f7fe fdd0 	bl	3400b62c <LL_RCC_IC1_GetSource>
3400ca8c:	4603      	mov	r3, r0
3400ca8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ca92:	d029      	beq.n	3400cae8 <HAL_RCC_GetCpuClockFreq+0xc8>
3400ca94:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ca98:	d82f      	bhi.n	3400cafa <HAL_RCC_GetCpuClockFreq+0xda>
3400ca9a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ca9e:	d01a      	beq.n	3400cad6 <HAL_RCC_GetCpuClockFreq+0xb6>
3400caa0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400caa4:	d829      	bhi.n	3400cafa <HAL_RCC_GetCpuClockFreq+0xda>
3400caa6:	2b00      	cmp	r3, #0
3400caa8:	d003      	beq.n	3400cab2 <HAL_RCC_GetCpuClockFreq+0x92>
3400caaa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400caae:	d009      	beq.n	3400cac4 <HAL_RCC_GetCpuClockFreq+0xa4>
          break;
3400cab0:	e023      	b.n	3400cafa <HAL_RCC_GetCpuClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400cab2:	f009 f813 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3400cab6:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400cab8:	687a      	ldr	r2, [r7, #4]
3400caba:	683b      	ldr	r3, [r7, #0]
3400cabc:	fbb2 f3f3 	udiv	r3, r2, r3
3400cac0:	607b      	str	r3, [r7, #4]
          break;
3400cac2:	e01b      	b.n	3400cafc <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400cac4:	f009 f850 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3400cac8:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400caca:	687a      	ldr	r2, [r7, #4]
3400cacc:	683b      	ldr	r3, [r7, #0]
3400cace:	fbb2 f3f3 	udiv	r3, r2, r3
3400cad2:	607b      	str	r3, [r7, #4]
          break;
3400cad4:	e012      	b.n	3400cafc <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400cad6:	f009 f88d 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3400cada:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400cadc:	687a      	ldr	r2, [r7, #4]
3400cade:	683b      	ldr	r3, [r7, #0]
3400cae0:	fbb2 f3f3 	udiv	r3, r2, r3
3400cae4:	607b      	str	r3, [r7, #4]
          break;
3400cae6:	e009      	b.n	3400cafc <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400cae8:	f009 f8ca 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
3400caec:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400caee:	687a      	ldr	r2, [r7, #4]
3400caf0:	683b      	ldr	r3, [r7, #0]
3400caf2:	fbb2 f3f3 	udiv	r3, r2, r3
3400caf6:	607b      	str	r3, [r7, #4]
          break;
3400caf8:	e000      	b.n	3400cafc <HAL_RCC_GetCpuClockFreq+0xdc>
          break;
3400cafa:	bf00      	nop
      break;
3400cafc:	e000      	b.n	3400cb00 <HAL_RCC_GetCpuClockFreq+0xe0>
      break;
3400cafe:	bf00      	nop
  }

  return frequency;
3400cb00:	687b      	ldr	r3, [r7, #4]
}
3400cb02:	4618      	mov	r0, r3
3400cb04:	3708      	adds	r7, #8
3400cb06:	46bd      	mov	sp, r7
3400cb08:	bd80      	pop	{r7, pc}
3400cb0a:	bf00      	nop
3400cb0c:	03d09000 	.word	0x03d09000
3400cb10:	003d0900 	.word	0x003d0900
3400cb14:	00f42400 	.word	0x00f42400
3400cb18:	02dc6c00 	.word	0x02dc6c00

3400cb1c <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
3400cb1c:	b580      	push	{r7, lr}
3400cb1e:	b082      	sub	sp, #8
3400cb20:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3400cb22:	2300      	movs	r3, #0
3400cb24:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
3400cb26:	f7fe fc8d 	bl	3400b444 <LL_RCC_GetSysClkSource>
3400cb2a:	4603      	mov	r3, r0
3400cb2c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cb30:	d025      	beq.n	3400cb7e <HAL_RCC_GetSysClockFreq+0x62>
3400cb32:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cb36:	d860      	bhi.n	3400cbfa <HAL_RCC_GetSysClockFreq+0xde>
3400cb38:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cb3c:	d01c      	beq.n	3400cb78 <HAL_RCC_GetSysClockFreq+0x5c>
3400cb3e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cb42:	d85a      	bhi.n	3400cbfa <HAL_RCC_GetSysClockFreq+0xde>
3400cb44:	2b00      	cmp	r3, #0
3400cb46:	d003      	beq.n	3400cb50 <HAL_RCC_GetSysClockFreq+0x34>
3400cb48:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cb4c:	d009      	beq.n	3400cb62 <HAL_RCC_GetSysClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3400cb4e:	e054      	b.n	3400cbfa <HAL_RCC_GetSysClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400cb50:	f7fe fba0 	bl	3400b294 <LL_RCC_HSI_GetDivider>
3400cb54:	4603      	mov	r3, r0
3400cb56:	09db      	lsrs	r3, r3, #7
3400cb58:	4a2b      	ldr	r2, [pc, #172]	@ (3400cc08 <HAL_RCC_GetSysClockFreq+0xec>)
3400cb5a:	fa22 f303 	lsr.w	r3, r2, r3
3400cb5e:	607b      	str	r3, [r7, #4]
      break;
3400cb60:	e04c      	b.n	3400cbfc <HAL_RCC_GetSysClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3400cb62:	f7fe fbff 	bl	3400b364 <LL_RCC_MSI_GetFrequency>
3400cb66:	4603      	mov	r3, r0
3400cb68:	2b00      	cmp	r3, #0
3400cb6a:	d102      	bne.n	3400cb72 <HAL_RCC_GetSysClockFreq+0x56>
        frequency = MSI_VALUE;
3400cb6c:	4b27      	ldr	r3, [pc, #156]	@ (3400cc0c <HAL_RCC_GetSysClockFreq+0xf0>)
3400cb6e:	607b      	str	r3, [r7, #4]
      break;
3400cb70:	e044      	b.n	3400cbfc <HAL_RCC_GetSysClockFreq+0xe0>
        frequency = 16000000UL;
3400cb72:	4b27      	ldr	r3, [pc, #156]	@ (3400cc10 <HAL_RCC_GetSysClockFreq+0xf4>)
3400cb74:	607b      	str	r3, [r7, #4]
      break;
3400cb76:	e041      	b.n	3400cbfc <HAL_RCC_GetSysClockFreq+0xe0>
      frequency = HSE_VALUE;
3400cb78:	4b26      	ldr	r3, [pc, #152]	@ (3400cc14 <HAL_RCC_GetSysClockFreq+0xf8>)
3400cb7a:	607b      	str	r3, [r7, #4]
      break;
3400cb7c:	e03e      	b.n	3400cbfc <HAL_RCC_GetSysClockFreq+0xe0>
      ic_divider = LL_RCC_IC2_GetDivider();
3400cb7e:	f7fe fd81 	bl	3400b684 <LL_RCC_IC2_GetDivider>
3400cb82:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC2_GetSource())
3400cb84:	f7fe fd70 	bl	3400b668 <LL_RCC_IC2_GetSource>
3400cb88:	4603      	mov	r3, r0
3400cb8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cb8e:	d029      	beq.n	3400cbe4 <HAL_RCC_GetSysClockFreq+0xc8>
3400cb90:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cb94:	d82f      	bhi.n	3400cbf6 <HAL_RCC_GetSysClockFreq+0xda>
3400cb96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cb9a:	d01a      	beq.n	3400cbd2 <HAL_RCC_GetSysClockFreq+0xb6>
3400cb9c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cba0:	d829      	bhi.n	3400cbf6 <HAL_RCC_GetSysClockFreq+0xda>
3400cba2:	2b00      	cmp	r3, #0
3400cba4:	d003      	beq.n	3400cbae <HAL_RCC_GetSysClockFreq+0x92>
3400cba6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cbaa:	d009      	beq.n	3400cbc0 <HAL_RCC_GetSysClockFreq+0xa4>
          break;
3400cbac:	e023      	b.n	3400cbf6 <HAL_RCC_GetSysClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400cbae:	f008 ff95 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3400cbb2:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400cbb4:	687a      	ldr	r2, [r7, #4]
3400cbb6:	683b      	ldr	r3, [r7, #0]
3400cbb8:	fbb2 f3f3 	udiv	r3, r2, r3
3400cbbc:	607b      	str	r3, [r7, #4]
          break;
3400cbbe:	e01b      	b.n	3400cbf8 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400cbc0:	f008 ffd2 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3400cbc4:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400cbc6:	687a      	ldr	r2, [r7, #4]
3400cbc8:	683b      	ldr	r3, [r7, #0]
3400cbca:	fbb2 f3f3 	udiv	r3, r2, r3
3400cbce:	607b      	str	r3, [r7, #4]
          break;
3400cbd0:	e012      	b.n	3400cbf8 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400cbd2:	f009 f80f 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3400cbd6:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400cbd8:	687a      	ldr	r2, [r7, #4]
3400cbda:	683b      	ldr	r3, [r7, #0]
3400cbdc:	fbb2 f3f3 	udiv	r3, r2, r3
3400cbe0:	607b      	str	r3, [r7, #4]
          break;
3400cbe2:	e009      	b.n	3400cbf8 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400cbe4:	f009 f84c 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
3400cbe8:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400cbea:	687a      	ldr	r2, [r7, #4]
3400cbec:	683b      	ldr	r3, [r7, #0]
3400cbee:	fbb2 f3f3 	udiv	r3, r2, r3
3400cbf2:	607b      	str	r3, [r7, #4]
          break;
3400cbf4:	e000      	b.n	3400cbf8 <HAL_RCC_GetSysClockFreq+0xdc>
          break;
3400cbf6:	bf00      	nop
      break;
3400cbf8:	e000      	b.n	3400cbfc <HAL_RCC_GetSysClockFreq+0xe0>
      break;
3400cbfa:	bf00      	nop
  }

  return frequency;
3400cbfc:	687b      	ldr	r3, [r7, #4]
}
3400cbfe:	4618      	mov	r0, r3
3400cc00:	3708      	adds	r7, #8
3400cc02:	46bd      	mov	sp, r7
3400cc04:	bd80      	pop	{r7, pc}
3400cc06:	bf00      	nop
3400cc08:	03d09000 	.word	0x03d09000
3400cc0c:	003d0900 	.word	0x003d0900
3400cc10:	00f42400 	.word	0x00f42400
3400cc14:	02dc6c00 	.word	0x02dc6c00

3400cc18 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3400cc18:	b580      	push	{r7, lr}
3400cc1a:	b088      	sub	sp, #32
3400cc1c:	af00      	add	r7, sp, #0
3400cc1e:	6078      	str	r0, [r7, #4]
3400cc20:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3400cc22:	2300      	movs	r3, #0
3400cc24:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3400cc26:	687b      	ldr	r3, [r7, #4]
3400cc28:	011a      	lsls	r2, r3, #4
3400cc2a:	4b9a      	ldr	r3, [pc, #616]	@ (3400ce94 <RCC_PLL_Config+0x27c>)
3400cc2c:	4413      	add	r3, r2
3400cc2e:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3400cc30:	687b      	ldr	r3, [r7, #4]
3400cc32:	011a      	lsls	r2, r3, #4
3400cc34:	4b98      	ldr	r3, [pc, #608]	@ (3400ce98 <RCC_PLL_Config+0x280>)
3400cc36:	4413      	add	r3, r2
3400cc38:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3400cc3a:	687b      	ldr	r3, [r7, #4]
3400cc3c:	011a      	lsls	r2, r3, #4
3400cc3e:	4b97      	ldr	r3, [pc, #604]	@ (3400ce9c <RCC_PLL_Config+0x284>)
3400cc40:	4413      	add	r3, r2
3400cc42:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
3400cc44:	683b      	ldr	r3, [r7, #0]
3400cc46:	681b      	ldr	r3, [r3, #0]
3400cc48:	2b02      	cmp	r3, #2
3400cc4a:	f040 80e9 	bne.w	3400ce20 <RCC_PLL_Config+0x208>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
3400cc4e:	683b      	ldr	r3, [r7, #0]
3400cc50:	685b      	ldr	r3, [r3, #4]
3400cc52:	2b00      	cmp	r3, #0
3400cc54:	d013      	beq.n	3400cc7e <RCC_PLL_Config+0x66>
3400cc56:	683b      	ldr	r3, [r7, #0]
3400cc58:	685b      	ldr	r3, [r3, #4]
3400cc5a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400cc5e:	d00e      	beq.n	3400cc7e <RCC_PLL_Config+0x66>
3400cc60:	683b      	ldr	r3, [r7, #0]
3400cc62:	685b      	ldr	r3, [r3, #4]
3400cc64:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400cc68:	d009      	beq.n	3400cc7e <RCC_PLL_Config+0x66>
3400cc6a:	683b      	ldr	r3, [r7, #0]
3400cc6c:	685b      	ldr	r3, [r3, #4]
3400cc6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400cc72:	d004      	beq.n	3400cc7e <RCC_PLL_Config+0x66>
3400cc74:	f44f 61ff 	mov.w	r1, #2040	@ 0x7f8
3400cc78:	4889      	ldr	r0, [pc, #548]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400cc7a:	f7f4 fb0d 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_PLLFRACN_VALUE(pPLLInit->PLLFractional));
3400cc7e:	683b      	ldr	r3, [r7, #0]
3400cc80:	68db      	ldr	r3, [r3, #12]
3400cc82:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400cc86:	d304      	bcc.n	3400cc92 <RCC_PLL_Config+0x7a>
3400cc88:	f240 71f9 	movw	r1, #2041	@ 0x7f9
3400cc8c:	4884      	ldr	r0, [pc, #528]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400cc8e:	f7f4 fb03 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_PLLM_VALUE(pPLLInit->PLLM));
3400cc92:	683b      	ldr	r3, [r7, #0]
3400cc94:	689b      	ldr	r3, [r3, #8]
3400cc96:	2b00      	cmp	r3, #0
3400cc98:	d003      	beq.n	3400cca2 <RCC_PLL_Config+0x8a>
3400cc9a:	683b      	ldr	r3, [r7, #0]
3400cc9c:	689b      	ldr	r3, [r3, #8]
3400cc9e:	2b3f      	cmp	r3, #63	@ 0x3f
3400cca0:	d904      	bls.n	3400ccac <RCC_PLL_Config+0x94>
3400cca2:	f240 71fa 	movw	r1, #2042	@ 0x7fa
3400cca6:	487e      	ldr	r0, [pc, #504]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400cca8:	f7f4 faf6 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
3400ccac:	683b      	ldr	r3, [r7, #0]
3400ccae:	691b      	ldr	r3, [r3, #16]
3400ccb0:	2b09      	cmp	r3, #9
3400ccb2:	d905      	bls.n	3400ccc0 <RCC_PLL_Config+0xa8>
3400ccb4:	683b      	ldr	r3, [r7, #0]
3400ccb6:	691b      	ldr	r3, [r3, #16]
3400ccb8:	f640 12c4 	movw	r2, #2500	@ 0x9c4
3400ccbc:	4293      	cmp	r3, r2
3400ccbe:	d904      	bls.n	3400ccca <RCC_PLL_Config+0xb2>
3400ccc0:	f240 71fb 	movw	r1, #2043	@ 0x7fb
3400ccc4:	4876      	ldr	r0, [pc, #472]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400ccc6:	f7f4 fae7 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
3400ccca:	683b      	ldr	r3, [r7, #0]
3400cccc:	695b      	ldr	r3, [r3, #20]
3400ccce:	2b00      	cmp	r3, #0
3400ccd0:	d003      	beq.n	3400ccda <RCC_PLL_Config+0xc2>
3400ccd2:	683b      	ldr	r3, [r7, #0]
3400ccd4:	695b      	ldr	r3, [r3, #20]
3400ccd6:	2b07      	cmp	r3, #7
3400ccd8:	d904      	bls.n	3400cce4 <RCC_PLL_Config+0xcc>
3400ccda:	f240 71fc 	movw	r1, #2044	@ 0x7fc
3400ccde:	4870      	ldr	r0, [pc, #448]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400cce0:	f7f4 fada 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));
3400cce4:	683b      	ldr	r3, [r7, #0]
3400cce6:	699b      	ldr	r3, [r3, #24]
3400cce8:	2b00      	cmp	r3, #0
3400ccea:	d003      	beq.n	3400ccf4 <RCC_PLL_Config+0xdc>
3400ccec:	683b      	ldr	r3, [r7, #0]
3400ccee:	699b      	ldr	r3, [r3, #24]
3400ccf0:	2b07      	cmp	r3, #7
3400ccf2:	d904      	bls.n	3400ccfe <RCC_PLL_Config+0xe6>
3400ccf4:	f240 71fd 	movw	r1, #2045	@ 0x7fd
3400ccf8:	4869      	ldr	r0, [pc, #420]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400ccfa:	f7f4 facd 	bl	34001298 <assert_failed>

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400ccfe:	4a69      	ldr	r2, [pc, #420]	@ (3400cea4 <RCC_PLL_Config+0x28c>)
3400cd00:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cd04:	687b      	ldr	r3, [r7, #4]
3400cd06:	fa01 f303 	lsl.w	r3, r1, r3
3400cd0a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400cd0e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400cd10:	f7fa fc66 	bl	340075e0 <HAL_GetTick>
3400cd14:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400cd16:	e008      	b.n	3400cd2a <RCC_PLL_Config+0x112>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400cd18:	f7fa fc62 	bl	340075e0 <HAL_GetTick>
3400cd1c:	4602      	mov	r2, r0
3400cd1e:	68fb      	ldr	r3, [r7, #12]
3400cd20:	1ad3      	subs	r3, r2, r3
3400cd22:	2b01      	cmp	r3, #1
3400cd24:	d901      	bls.n	3400cd2a <RCC_PLL_Config+0x112>
      {
        return HAL_TIMEOUT;
3400cd26:	2303      	movs	r3, #3
3400cd28:	e114      	b.n	3400cf54 <RCC_PLL_Config+0x33c>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400cd2a:	4b5e      	ldr	r3, [pc, #376]	@ (3400cea4 <RCC_PLL_Config+0x28c>)
3400cd2c:	685a      	ldr	r2, [r3, #4]
3400cd2e:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cd32:	687b      	ldr	r3, [r7, #4]
3400cd34:	fa01 f303 	lsl.w	r3, r1, r3
3400cd38:	401a      	ands	r2, r3
3400cd3a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cd3e:	687b      	ldr	r3, [r7, #4]
3400cd40:	fa01 f303 	lsl.w	r3, r1, r3
3400cd44:	429a      	cmp	r2, r3
3400cd46:	d0e7      	beq.n	3400cd18 <RCC_PLL_Config+0x100>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3400cd48:	693b      	ldr	r3, [r7, #16]
3400cd4a:	681b      	ldr	r3, [r3, #0]
3400cd4c:	f043 0204 	orr.w	r2, r3, #4
3400cd50:	693b      	ldr	r3, [r7, #16]
3400cd52:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3400cd54:	69bb      	ldr	r3, [r7, #24]
3400cd56:	681b      	ldr	r3, [r3, #0]
3400cd58:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3400cd5c:	69bb      	ldr	r3, [r7, #24]
3400cd5e:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3400cd60:	69bb      	ldr	r3, [r7, #24]
3400cd62:	681a      	ldr	r2, [r3, #0]
3400cd64:	4b50      	ldr	r3, [pc, #320]	@ (3400cea8 <RCC_PLL_Config+0x290>)
3400cd66:	4013      	ands	r3, r2
3400cd68:	683a      	ldr	r2, [r7, #0]
3400cd6a:	6851      	ldr	r1, [r2, #4]
3400cd6c:	683a      	ldr	r2, [r7, #0]
3400cd6e:	6892      	ldr	r2, [r2, #8]
3400cd70:	0512      	lsls	r2, r2, #20
3400cd72:	4311      	orrs	r1, r2
3400cd74:	683a      	ldr	r2, [r7, #0]
3400cd76:	6912      	ldr	r2, [r2, #16]
3400cd78:	0212      	lsls	r2, r2, #8
3400cd7a:	430a      	orrs	r2, r1
3400cd7c:	431a      	orrs	r2, r3
3400cd7e:	69bb      	ldr	r3, [r7, #24]
3400cd80:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3400cd82:	693b      	ldr	r3, [r7, #16]
3400cd84:	681b      	ldr	r3, [r3, #0]
3400cd86:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
3400cd8a:	683b      	ldr	r3, [r7, #0]
3400cd8c:	695b      	ldr	r3, [r3, #20]
3400cd8e:	06d9      	lsls	r1, r3, #27
3400cd90:	683b      	ldr	r3, [r7, #0]
3400cd92:	699b      	ldr	r3, [r3, #24]
3400cd94:	061b      	lsls	r3, r3, #24
3400cd96:	430b      	orrs	r3, r1
3400cd98:	431a      	orrs	r2, r3
3400cd9a:	693b      	ldr	r3, [r7, #16]
3400cd9c:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3400cd9e:	697b      	ldr	r3, [r7, #20]
3400cda0:	681b      	ldr	r3, [r3, #0]
3400cda2:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3400cda6:	683b      	ldr	r3, [r7, #0]
3400cda8:	68db      	ldr	r3, [r3, #12]
3400cdaa:	431a      	orrs	r2, r3
3400cdac:	697b      	ldr	r3, [r7, #20]
3400cdae:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
3400cdb0:	693b      	ldr	r3, [r7, #16]
3400cdb2:	681b      	ldr	r3, [r3, #0]
3400cdb4:	f023 0208 	bic.w	r2, r3, #8
3400cdb8:	693b      	ldr	r3, [r7, #16]
3400cdba:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
3400cdbc:	683b      	ldr	r3, [r7, #0]
3400cdbe:	68db      	ldr	r3, [r3, #12]
3400cdc0:	2b00      	cmp	r3, #0
3400cdc2:	d005      	beq.n	3400cdd0 <RCC_PLL_Config+0x1b8>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3400cdc4:	693b      	ldr	r3, [r7, #16]
3400cdc6:	681b      	ldr	r3, [r3, #0]
3400cdc8:	f043 020a 	orr.w	r2, r3, #10
3400cdcc:	693b      	ldr	r3, [r7, #16]
3400cdce:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3400cdd0:	693b      	ldr	r3, [r7, #16]
3400cdd2:	681b      	ldr	r3, [r3, #0]
3400cdd4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3400cdd8:	f043 0301 	orr.w	r3, r3, #1
3400cddc:	693a      	ldr	r2, [r7, #16]
3400cdde:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3400cde0:	4a30      	ldr	r2, [pc, #192]	@ (3400cea4 <RCC_PLL_Config+0x28c>)
3400cde2:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cde6:	687b      	ldr	r3, [r7, #4]
3400cde8:	fa01 f303 	lsl.w	r3, r1, r3
3400cdec:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400cdf0:	f7fa fbf6 	bl	340075e0 <HAL_GetTick>
3400cdf4:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400cdf6:	e008      	b.n	3400ce0a <RCC_PLL_Config+0x1f2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400cdf8:	f7fa fbf2 	bl	340075e0 <HAL_GetTick>
3400cdfc:	4602      	mov	r2, r0
3400cdfe:	68fb      	ldr	r3, [r7, #12]
3400ce00:	1ad3      	subs	r3, r2, r3
3400ce02:	2b01      	cmp	r3, #1
3400ce04:	d901      	bls.n	3400ce0a <RCC_PLL_Config+0x1f2>
      {
        return HAL_TIMEOUT;
3400ce06:	2303      	movs	r3, #3
3400ce08:	e0a4      	b.n	3400cf54 <RCC_PLL_Config+0x33c>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400ce0a:	4b26      	ldr	r3, [pc, #152]	@ (3400cea4 <RCC_PLL_Config+0x28c>)
3400ce0c:	685a      	ldr	r2, [r3, #4]
3400ce0e:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ce12:	687b      	ldr	r3, [r7, #4]
3400ce14:	fa01 f303 	lsl.w	r3, r1, r3
3400ce18:	4013      	ands	r3, r2
3400ce1a:	2b00      	cmp	r3, #0
3400ce1c:	d0ec      	beq.n	3400cdf8 <RCC_PLL_Config+0x1e0>
3400ce1e:	e098      	b.n	3400cf52 <RCC_PLL_Config+0x33a>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3400ce20:	683b      	ldr	r3, [r7, #0]
3400ce22:	681b      	ldr	r3, [r3, #0]
3400ce24:	2b03      	cmp	r3, #3
3400ce26:	d15f      	bne.n	3400cee8 <RCC_PLL_Config+0x2d0>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
3400ce28:	683b      	ldr	r3, [r7, #0]
3400ce2a:	685b      	ldr	r3, [r3, #4]
3400ce2c:	2b00      	cmp	r3, #0
3400ce2e:	d013      	beq.n	3400ce58 <RCC_PLL_Config+0x240>
3400ce30:	683b      	ldr	r3, [r7, #0]
3400ce32:	685b      	ldr	r3, [r3, #4]
3400ce34:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ce38:	d00e      	beq.n	3400ce58 <RCC_PLL_Config+0x240>
3400ce3a:	683b      	ldr	r3, [r7, #0]
3400ce3c:	685b      	ldr	r3, [r3, #4]
3400ce3e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ce42:	d009      	beq.n	3400ce58 <RCC_PLL_Config+0x240>
3400ce44:	683b      	ldr	r3, [r7, #0]
3400ce46:	685b      	ldr	r3, [r3, #4]
3400ce48:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ce4c:	d004      	beq.n	3400ce58 <RCC_PLL_Config+0x240>
3400ce4e:	f640 013d 	movw	r1, #2109	@ 0x83d
3400ce52:	4813      	ldr	r0, [pc, #76]	@ (3400cea0 <RCC_PLL_Config+0x288>)
3400ce54:	f7f4 fa20 	bl	34001298 <assert_failed>

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
3400ce58:	683b      	ldr	r3, [r7, #0]
3400ce5a:	685b      	ldr	r3, [r3, #4]
3400ce5c:	4618      	mov	r0, r3
3400ce5e:	f000 f925 	bl	3400d0ac <RCC_PLL_Source_IsReady>
3400ce62:	4603      	mov	r3, r0
3400ce64:	2b01      	cmp	r3, #1
3400ce66:	d13c      	bne.n	3400cee2 <RCC_PLL_Config+0x2ca>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400ce68:	4a0e      	ldr	r2, [pc, #56]	@ (3400cea4 <RCC_PLL_Config+0x28c>)
3400ce6a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ce6e:	687b      	ldr	r3, [r7, #4]
3400ce70:	fa01 f303 	lsl.w	r3, r1, r3
3400ce74:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400ce78:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400ce7a:	f7fa fbb1 	bl	340075e0 <HAL_GetTick>
3400ce7e:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400ce80:	e014      	b.n	3400ceac <RCC_PLL_Config+0x294>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400ce82:	f7fa fbad 	bl	340075e0 <HAL_GetTick>
3400ce86:	4602      	mov	r2, r0
3400ce88:	68fb      	ldr	r3, [r7, #12]
3400ce8a:	1ad3      	subs	r3, r2, r3
3400ce8c:	2b01      	cmp	r3, #1
3400ce8e:	d90d      	bls.n	3400ceac <RCC_PLL_Config+0x294>
        {
          return HAL_TIMEOUT;
3400ce90:	2303      	movs	r3, #3
3400ce92:	e05f      	b.n	3400cf54 <RCC_PLL_Config+0x33c>
3400ce94:	56028080 	.word	0x56028080
3400ce98:	56028084 	.word	0x56028084
3400ce9c:	56028088 	.word	0x56028088
3400cea0:	340243dc 	.word	0x340243dc
3400cea4:	56028000 	.word	0x56028000
3400cea8:	8c0000ff 	.word	0x8c0000ff
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400ceac:	4b2b      	ldr	r3, [pc, #172]	@ (3400cf5c <RCC_PLL_Config+0x344>)
3400ceae:	685a      	ldr	r2, [r3, #4]
3400ceb0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ceb4:	687b      	ldr	r3, [r7, #4]
3400ceb6:	fa01 f303 	lsl.w	r3, r1, r3
3400ceba:	401a      	ands	r2, r3
3400cebc:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cec0:	687b      	ldr	r3, [r7, #4]
3400cec2:	fa01 f303 	lsl.w	r3, r1, r3
3400cec6:	429a      	cmp	r2, r3
3400cec8:	d0db      	beq.n	3400ce82 <RCC_PLL_Config+0x26a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3400ceca:	69bb      	ldr	r3, [r7, #24]
3400cecc:	681b      	ldr	r3, [r3, #0]
3400cece:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
3400ced2:	683b      	ldr	r3, [r7, #0]
3400ced4:	685b      	ldr	r3, [r3, #4]
3400ced6:	4313      	orrs	r3, r2
3400ced8:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3400cedc:	69bb      	ldr	r3, [r7, #24]
3400cede:	601a      	str	r2, [r3, #0]
3400cee0:	e037      	b.n	3400cf52 <RCC_PLL_Config+0x33a>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
3400cee2:	2301      	movs	r3, #1
3400cee4:	77fb      	strb	r3, [r7, #31]
3400cee6:	e034      	b.n	3400cf52 <RCC_PLL_Config+0x33a>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
3400cee8:	683b      	ldr	r3, [r7, #0]
3400ceea:	681b      	ldr	r3, [r3, #0]
3400ceec:	2b01      	cmp	r3, #1
3400ceee:	d130      	bne.n	3400cf52 <RCC_PLL_Config+0x33a>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
3400cef0:	693b      	ldr	r3, [r7, #16]
3400cef2:	681b      	ldr	r3, [r3, #0]
3400cef4:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3400cef8:	693b      	ldr	r3, [r7, #16]
3400cefa:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400cefc:	4a17      	ldr	r2, [pc, #92]	@ (3400cf5c <RCC_PLL_Config+0x344>)
3400cefe:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cf02:	687b      	ldr	r3, [r7, #4]
3400cf04:	fa01 f303 	lsl.w	r3, r1, r3
3400cf08:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400cf0c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400cf0e:	f7fa fb67 	bl	340075e0 <HAL_GetTick>
3400cf12:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400cf14:	e008      	b.n	3400cf28 <RCC_PLL_Config+0x310>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400cf16:	f7fa fb63 	bl	340075e0 <HAL_GetTick>
3400cf1a:	4602      	mov	r2, r0
3400cf1c:	68fb      	ldr	r3, [r7, #12]
3400cf1e:	1ad3      	subs	r3, r2, r3
3400cf20:	2b01      	cmp	r3, #1
3400cf22:	d901      	bls.n	3400cf28 <RCC_PLL_Config+0x310>
      {
        return HAL_TIMEOUT;
3400cf24:	2303      	movs	r3, #3
3400cf26:	e015      	b.n	3400cf54 <RCC_PLL_Config+0x33c>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400cf28:	4b0c      	ldr	r3, [pc, #48]	@ (3400cf5c <RCC_PLL_Config+0x344>)
3400cf2a:	685a      	ldr	r2, [r3, #4]
3400cf2c:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cf30:	687b      	ldr	r3, [r7, #4]
3400cf32:	fa01 f303 	lsl.w	r3, r1, r3
3400cf36:	401a      	ands	r2, r3
3400cf38:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cf3c:	687b      	ldr	r3, [r7, #4]
3400cf3e:	fa01 f303 	lsl.w	r3, r1, r3
3400cf42:	429a      	cmp	r2, r3
3400cf44:	d0e7      	beq.n	3400cf16 <RCC_PLL_Config+0x2fe>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3400cf46:	69bb      	ldr	r3, [r7, #24]
3400cf48:	681b      	ldr	r3, [r3, #0]
3400cf4a:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3400cf4e:	69bb      	ldr	r3, [r7, #24]
3400cf50:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
3400cf52:	7ffb      	ldrb	r3, [r7, #31]
}
3400cf54:	4618      	mov	r0, r3
3400cf56:	3720      	adds	r7, #32
3400cf58:	46bd      	mov	sp, r7
3400cf5a:	bd80      	pop	{r7, pc}
3400cf5c:	56028000 	.word	0x56028000

3400cf60 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
3400cf60:	b580      	push	{r7, lr}
3400cf62:	b084      	sub	sp, #16
3400cf64:	af00      	add	r7, sp, #0
3400cf66:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
3400cf68:	2300      	movs	r3, #0
3400cf6a:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3400cf6c:	4a11      	ldr	r2, [pc, #68]	@ (3400cfb4 <RCC_PLL_Enable+0x54>)
3400cf6e:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cf72:	687b      	ldr	r3, [r7, #4]
3400cf74:	fa01 f303 	lsl.w	r3, r1, r3
3400cf78:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
3400cf7c:	f7fa fb30 	bl	340075e0 <HAL_GetTick>
3400cf80:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400cf82:	e008      	b.n	3400cf96 <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400cf84:	f7fa fb2c 	bl	340075e0 <HAL_GetTick>
3400cf88:	4602      	mov	r2, r0
3400cf8a:	68bb      	ldr	r3, [r7, #8]
3400cf8c:	1ad3      	subs	r3, r2, r3
3400cf8e:	2b01      	cmp	r3, #1
3400cf90:	d901      	bls.n	3400cf96 <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
3400cf92:	2303      	movs	r3, #3
3400cf94:	e00a      	b.n	3400cfac <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400cf96:	4b07      	ldr	r3, [pc, #28]	@ (3400cfb4 <RCC_PLL_Enable+0x54>)
3400cf98:	685a      	ldr	r2, [r3, #4]
3400cf9a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400cf9e:	687b      	ldr	r3, [r7, #4]
3400cfa0:	fa01 f303 	lsl.w	r3, r1, r3
3400cfa4:	4013      	ands	r3, r2
3400cfa6:	2b00      	cmp	r3, #0
3400cfa8:	d0ec      	beq.n	3400cf84 <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3400cfaa:	7bfb      	ldrb	r3, [r7, #15]
}
3400cfac:	4618      	mov	r0, r3
3400cfae:	3710      	adds	r7, #16
3400cfb0:	46bd      	mov	sp, r7
3400cfb2:	bd80      	pop	{r7, pc}
3400cfb4:	56028000 	.word	0x56028000

3400cfb8 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3400cfb8:	b480      	push	{r7}
3400cfba:	b089      	sub	sp, #36	@ 0x24
3400cfbc:	af00      	add	r7, sp, #0
3400cfbe:	6078      	str	r0, [r7, #4]
3400cfc0:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
3400cfc2:	2300      	movs	r3, #0
3400cfc4:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3400cfc6:	687b      	ldr	r3, [r7, #4]
3400cfc8:	011a      	lsls	r2, r3, #4
3400cfca:	4b34      	ldr	r3, [pc, #208]	@ (3400d09c <RCC_PLL_IsNewConfig+0xe4>)
3400cfcc:	4413      	add	r3, r2
3400cfce:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3400cfd0:	687b      	ldr	r3, [r7, #4]
3400cfd2:	011a      	lsls	r2, r3, #4
3400cfd4:	4b32      	ldr	r3, [pc, #200]	@ (3400d0a0 <RCC_PLL_IsNewConfig+0xe8>)
3400cfd6:	4413      	add	r3, r2
3400cfd8:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3400cfda:	687b      	ldr	r3, [r7, #4]
3400cfdc:	011a      	lsls	r2, r3, #4
3400cfde:	4b31      	ldr	r3, [pc, #196]	@ (3400d0a4 <RCC_PLL_IsNewConfig+0xec>)
3400cfe0:	4413      	add	r3, r2
3400cfe2:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400cfe4:	697b      	ldr	r3, [r7, #20]
3400cfe6:	681b      	ldr	r3, [r3, #0]
3400cfe8:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
3400cfec:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
3400cff0:	683a      	ldr	r2, [r7, #0]
3400cff2:	6851      	ldr	r1, [r2, #4]
3400cff4:	683a      	ldr	r2, [r7, #0]
3400cff6:	6892      	ldr	r2, [r2, #8]
3400cff8:	0512      	lsls	r2, r2, #20
3400cffa:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3400cffc:	683a      	ldr	r2, [r7, #0]
3400cffe:	6912      	ldr	r2, [r2, #16]
3400d000:	0212      	lsls	r2, r2, #8
3400d002:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400d004:	4293      	cmp	r3, r2
3400d006:	d002      	beq.n	3400d00e <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
3400d008:	2301      	movs	r3, #1
3400d00a:	61fb      	str	r3, [r7, #28]
3400d00c:	e03e      	b.n	3400d08c <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3400d00e:	693b      	ldr	r3, [r7, #16]
3400d010:	681b      	ldr	r3, [r3, #0]
3400d012:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
3400d016:	683b      	ldr	r3, [r7, #0]
3400d018:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3400d01a:	429a      	cmp	r2, r3
3400d01c:	d002      	beq.n	3400d024 <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
3400d01e:	2301      	movs	r3, #1
3400d020:	61fb      	str	r3, [r7, #28]
3400d022:	e033      	b.n	3400d08c <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400d024:	68fb      	ldr	r3, [r7, #12]
3400d026:	681b      	ldr	r3, [r3, #0]
3400d028:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3400d02c:	683b      	ldr	r3, [r7, #0]
3400d02e:	695b      	ldr	r3, [r3, #20]
3400d030:	06d9      	lsls	r1, r3, #27
3400d032:	683b      	ldr	r3, [r7, #0]
3400d034:	699b      	ldr	r3, [r3, #24]
3400d036:	061b      	lsls	r3, r3, #24
3400d038:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400d03a:	429a      	cmp	r2, r3
3400d03c:	d002      	beq.n	3400d044 <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
3400d03e:	2301      	movs	r3, #1
3400d040:	61fb      	str	r3, [r7, #28]
3400d042:	e023      	b.n	3400d08c <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400d044:	4b18      	ldr	r3, [pc, #96]	@ (3400d0a8 <RCC_PLL_IsNewConfig+0xf0>)
3400d046:	685a      	ldr	r2, [r3, #4]
3400d048:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400d04c:	687b      	ldr	r3, [r7, #4]
3400d04e:	fa01 f303 	lsl.w	r3, r1, r3
3400d052:	401a      	ands	r2, r3
3400d054:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400d058:	687b      	ldr	r3, [r7, #4]
3400d05a:	fa01 f303 	lsl.w	r3, r1, r3
3400d05e:	429a      	cmp	r2, r3
3400d060:	d102      	bne.n	3400d068 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
3400d062:	2302      	movs	r3, #2
3400d064:	61bb      	str	r3, [r7, #24]
3400d066:	e00a      	b.n	3400d07e <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
3400d068:	697b      	ldr	r3, [r7, #20]
3400d06a:	681b      	ldr	r3, [r3, #0]
3400d06c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400d070:	2b00      	cmp	r3, #0
3400d072:	d002      	beq.n	3400d07a <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
3400d074:	2303      	movs	r3, #3
3400d076:	61bb      	str	r3, [r7, #24]
3400d078:	e001      	b.n	3400d07e <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
3400d07a:	2301      	movs	r3, #1
3400d07c:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
3400d07e:	683b      	ldr	r3, [r7, #0]
3400d080:	681b      	ldr	r3, [r3, #0]
3400d082:	69ba      	ldr	r2, [r7, #24]
3400d084:	429a      	cmp	r2, r3
3400d086:	d001      	beq.n	3400d08c <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
3400d088:	2301      	movs	r3, #1
3400d08a:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
3400d08c:	69fb      	ldr	r3, [r7, #28]
}
3400d08e:	4618      	mov	r0, r3
3400d090:	3724      	adds	r7, #36	@ 0x24
3400d092:	46bd      	mov	sp, r7
3400d094:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d098:	4770      	bx	lr
3400d09a:	bf00      	nop
3400d09c:	56028080 	.word	0x56028080
3400d0a0:	56028084 	.word	0x56028084
3400d0a4:	56028088 	.word	0x56028088
3400d0a8:	56028000 	.word	0x56028000

3400d0ac <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
3400d0ac:	b580      	push	{r7, lr}
3400d0ae:	b084      	sub	sp, #16
3400d0b0:	af00      	add	r7, sp, #0
3400d0b2:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3400d0b4:	2301      	movs	r3, #1
3400d0b6:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
3400d0b8:	687b      	ldr	r3, [r7, #4]
3400d0ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d0be:	d01b      	beq.n	3400d0f8 <RCC_PLL_Source_IsReady+0x4c>
3400d0c0:	687b      	ldr	r3, [r7, #4]
3400d0c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d0c6:	d81f      	bhi.n	3400d108 <RCC_PLL_Source_IsReady+0x5c>
3400d0c8:	687b      	ldr	r3, [r7, #4]
3400d0ca:	2b00      	cmp	r3, #0
3400d0cc:	d004      	beq.n	3400d0d8 <RCC_PLL_Source_IsReady+0x2c>
3400d0ce:	687b      	ldr	r3, [r7, #4]
3400d0d0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d0d4:	d008      	beq.n	3400d0e8 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3400d0d6:	e017      	b.n	3400d108 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
3400d0d8:	f7fe f8b6 	bl	3400b248 <LL_RCC_HSI_IsReady>
3400d0dc:	4603      	mov	r3, r0
3400d0de:	2b00      	cmp	r3, #0
3400d0e0:	d114      	bne.n	3400d10c <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
3400d0e2:	2300      	movs	r3, #0
3400d0e4:	60fb      	str	r3, [r7, #12]
      break;
3400d0e6:	e011      	b.n	3400d10c <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
3400d0e8:	f7fe f916 	bl	3400b318 <LL_RCC_MSI_IsReady>
3400d0ec:	4603      	mov	r3, r0
3400d0ee:	2b00      	cmp	r3, #0
3400d0f0:	d10e      	bne.n	3400d110 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
3400d0f2:	2300      	movs	r3, #0
3400d0f4:	60fb      	str	r3, [r7, #12]
      break;
3400d0f6:	e00b      	b.n	3400d110 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
3400d0f8:	f7fe f876 	bl	3400b1e8 <LL_RCC_HSE_IsReady>
3400d0fc:	4603      	mov	r3, r0
3400d0fe:	2b00      	cmp	r3, #0
3400d100:	d108      	bne.n	3400d114 <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
3400d102:	2300      	movs	r3, #0
3400d104:	60fb      	str	r3, [r7, #12]
      break;
3400d106:	e005      	b.n	3400d114 <RCC_PLL_Source_IsReady+0x68>
      break;
3400d108:	bf00      	nop
3400d10a:	e004      	b.n	3400d116 <RCC_PLL_Source_IsReady+0x6a>
      break;
3400d10c:	bf00      	nop
3400d10e:	e002      	b.n	3400d116 <RCC_PLL_Source_IsReady+0x6a>
      break;
3400d110:	bf00      	nop
3400d112:	e000      	b.n	3400d116 <RCC_PLL_Source_IsReady+0x6a>
      break;
3400d114:	bf00      	nop
  }

  return ret;
3400d116:	68fb      	ldr	r3, [r7, #12]
}
3400d118:	4618      	mov	r0, r3
3400d11a:	3710      	adds	r7, #16
3400d11c:	46bd      	mov	sp, r7
3400d11e:	bd80      	pop	{r7, pc}

3400d120 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
3400d120:	b580      	push	{r7, lr}
3400d122:	b084      	sub	sp, #16
3400d124:	af00      	add	r7, sp, #0
3400d126:	6078      	str	r0, [r7, #4]
3400d128:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
3400d12a:	2301      	movs	r3, #1
3400d12c:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
3400d12e:	687b      	ldr	r3, [r7, #4]
3400d130:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d134:	d03a      	beq.n	3400d1ac <RCC_IC_CheckPLLSources+0x8c>
3400d136:	687b      	ldr	r3, [r7, #4]
3400d138:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d13c:	d843      	bhi.n	3400d1c6 <RCC_IC_CheckPLLSources+0xa6>
3400d13e:	687b      	ldr	r3, [r7, #4]
3400d140:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d144:	d025      	beq.n	3400d192 <RCC_IC_CheckPLLSources+0x72>
3400d146:	687b      	ldr	r3, [r7, #4]
3400d148:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d14c:	d83b      	bhi.n	3400d1c6 <RCC_IC_CheckPLLSources+0xa6>
3400d14e:	687b      	ldr	r3, [r7, #4]
3400d150:	2b00      	cmp	r3, #0
3400d152:	d004      	beq.n	3400d15e <RCC_IC_CheckPLLSources+0x3e>
3400d154:	687b      	ldr	r3, [r7, #4]
3400d156:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d15a:	d00d      	beq.n	3400d178 <RCC_IC_CheckPLLSources+0x58>
3400d15c:	e033      	b.n	3400d1c6 <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3400d15e:	f7fe f98d 	bl	3400b47c <LL_RCC_PLL1_IsReady>
3400d162:	4603      	mov	r3, r0
3400d164:	2b00      	cmp	r3, #0
3400d166:	d131      	bne.n	3400d1cc <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3400d168:	f7fe f99c 	bl	3400b4a4 <LL_RCC_PLL1_IsEnabledBypass>
3400d16c:	4603      	mov	r3, r0
3400d16e:	2b00      	cmp	r3, #0
3400d170:	d12c      	bne.n	3400d1cc <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
3400d172:	2300      	movs	r3, #0
3400d174:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d176:	e029      	b.n	3400d1cc <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3400d178:	f7fe f9b6 	bl	3400b4e8 <LL_RCC_PLL2_IsReady>
3400d17c:	4603      	mov	r3, r0
3400d17e:	2b00      	cmp	r3, #0
3400d180:	d126      	bne.n	3400d1d0 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3400d182:	f7fe f9c5 	bl	3400b510 <LL_RCC_PLL2_IsEnabledBypass>
3400d186:	4603      	mov	r3, r0
3400d188:	2b00      	cmp	r3, #0
3400d18a:	d121      	bne.n	3400d1d0 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
3400d18c:	2300      	movs	r3, #0
3400d18e:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d190:	e01e      	b.n	3400d1d0 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3400d192:	f7fe f9df 	bl	3400b554 <LL_RCC_PLL3_IsReady>
3400d196:	4603      	mov	r3, r0
3400d198:	2b00      	cmp	r3, #0
3400d19a:	d11b      	bne.n	3400d1d4 <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3400d19c:	f7fe f9ee 	bl	3400b57c <LL_RCC_PLL3_IsEnabledBypass>
3400d1a0:	4603      	mov	r3, r0
3400d1a2:	2b00      	cmp	r3, #0
3400d1a4:	d116      	bne.n	3400d1d4 <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3400d1a6:	2300      	movs	r3, #0
3400d1a8:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d1aa:	e013      	b.n	3400d1d4 <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3400d1ac:	f7fe fa08 	bl	3400b5c0 <LL_RCC_PLL4_IsReady>
3400d1b0:	4603      	mov	r3, r0
3400d1b2:	2b00      	cmp	r3, #0
3400d1b4:	d110      	bne.n	3400d1d8 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3400d1b6:	f7fe fa17 	bl	3400b5e8 <LL_RCC_PLL4_IsEnabledBypass>
3400d1ba:	4603      	mov	r3, r0
3400d1bc:	2b00      	cmp	r3, #0
3400d1be:	d10b      	bne.n	3400d1d8 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
3400d1c0:	2300      	movs	r3, #0
3400d1c2:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d1c4:	e008      	b.n	3400d1d8 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3400d1c6:	2300      	movs	r3, #0
3400d1c8:	60fb      	str	r3, [r7, #12]
      break;
3400d1ca:	e006      	b.n	3400d1da <RCC_IC_CheckPLLSources+0xba>
      break;
3400d1cc:	bf00      	nop
3400d1ce:	e004      	b.n	3400d1da <RCC_IC_CheckPLLSources+0xba>
      break;
3400d1d0:	bf00      	nop
3400d1d2:	e002      	b.n	3400d1da <RCC_IC_CheckPLLSources+0xba>
      break;
3400d1d4:	bf00      	nop
3400d1d6:	e000      	b.n	3400d1da <RCC_IC_CheckPLLSources+0xba>
      break;
3400d1d8:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3400d1da:	683b      	ldr	r3, [r7, #0]
3400d1dc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d1e0:	d03a      	beq.n	3400d258 <RCC_IC_CheckPLLSources+0x138>
3400d1e2:	683b      	ldr	r3, [r7, #0]
3400d1e4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d1e8:	d843      	bhi.n	3400d272 <RCC_IC_CheckPLLSources+0x152>
3400d1ea:	683b      	ldr	r3, [r7, #0]
3400d1ec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d1f0:	d025      	beq.n	3400d23e <RCC_IC_CheckPLLSources+0x11e>
3400d1f2:	683b      	ldr	r3, [r7, #0]
3400d1f4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d1f8:	d83b      	bhi.n	3400d272 <RCC_IC_CheckPLLSources+0x152>
3400d1fa:	683b      	ldr	r3, [r7, #0]
3400d1fc:	2b00      	cmp	r3, #0
3400d1fe:	d004      	beq.n	3400d20a <RCC_IC_CheckPLLSources+0xea>
3400d200:	683b      	ldr	r3, [r7, #0]
3400d202:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400d206:	d00d      	beq.n	3400d224 <RCC_IC_CheckPLLSources+0x104>
3400d208:	e033      	b.n	3400d272 <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3400d20a:	f7fe f937 	bl	3400b47c <LL_RCC_PLL1_IsReady>
3400d20e:	4603      	mov	r3, r0
3400d210:	2b00      	cmp	r3, #0
3400d212:	d131      	bne.n	3400d278 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3400d214:	f7fe f946 	bl	3400b4a4 <LL_RCC_PLL1_IsEnabledBypass>
3400d218:	4603      	mov	r3, r0
3400d21a:	2b00      	cmp	r3, #0
3400d21c:	d12c      	bne.n	3400d278 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
3400d21e:	2300      	movs	r3, #0
3400d220:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d222:	e029      	b.n	3400d278 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3400d224:	f7fe f960 	bl	3400b4e8 <LL_RCC_PLL2_IsReady>
3400d228:	4603      	mov	r3, r0
3400d22a:	2b00      	cmp	r3, #0
3400d22c:	d126      	bne.n	3400d27c <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3400d22e:	f7fe f96f 	bl	3400b510 <LL_RCC_PLL2_IsEnabledBypass>
3400d232:	4603      	mov	r3, r0
3400d234:	2b00      	cmp	r3, #0
3400d236:	d121      	bne.n	3400d27c <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
3400d238:	2300      	movs	r3, #0
3400d23a:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d23c:	e01e      	b.n	3400d27c <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3400d23e:	f7fe f989 	bl	3400b554 <LL_RCC_PLL3_IsReady>
3400d242:	4603      	mov	r3, r0
3400d244:	2b00      	cmp	r3, #0
3400d246:	d11b      	bne.n	3400d280 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3400d248:	f7fe f998 	bl	3400b57c <LL_RCC_PLL3_IsEnabledBypass>
3400d24c:	4603      	mov	r3, r0
3400d24e:	2b00      	cmp	r3, #0
3400d250:	d116      	bne.n	3400d280 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
3400d252:	2300      	movs	r3, #0
3400d254:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d256:	e013      	b.n	3400d280 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3400d258:	f7fe f9b2 	bl	3400b5c0 <LL_RCC_PLL4_IsReady>
3400d25c:	4603      	mov	r3, r0
3400d25e:	2b00      	cmp	r3, #0
3400d260:	d110      	bne.n	3400d284 <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3400d262:	f7fe f9c1 	bl	3400b5e8 <LL_RCC_PLL4_IsEnabledBypass>
3400d266:	4603      	mov	r3, r0
3400d268:	2b00      	cmp	r3, #0
3400d26a:	d10b      	bne.n	3400d284 <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
3400d26c:	2300      	movs	r3, #0
3400d26e:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400d270:	e008      	b.n	3400d284 <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
3400d272:	2300      	movs	r3, #0
3400d274:	60fb      	str	r3, [r7, #12]
      break;
3400d276:	e006      	b.n	3400d286 <RCC_IC_CheckPLLSources+0x166>
      break;
3400d278:	bf00      	nop
3400d27a:	e004      	b.n	3400d286 <RCC_IC_CheckPLLSources+0x166>
      break;
3400d27c:	bf00      	nop
3400d27e:	e002      	b.n	3400d286 <RCC_IC_CheckPLLSources+0x166>
      break;
3400d280:	bf00      	nop
3400d282:	e000      	b.n	3400d286 <RCC_IC_CheckPLLSources+0x166>
      break;
3400d284:	bf00      	nop
  }

  return ret;
3400d286:	68fb      	ldr	r3, [r7, #12]
}
3400d288:	4618      	mov	r0, r3
3400d28a:	3710      	adds	r7, #16
3400d28c:	46bd      	mov	sp, r7
3400d28e:	bd80      	pop	{r7, pc}

3400d290 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
3400d290:	b480      	push	{r7}
3400d292:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400d294:	4b05      	ldr	r3, [pc, #20]	@ (3400d2ac <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3400d296:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400d298:	4a04      	ldr	r2, [pc, #16]	@ (3400d2ac <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3400d29a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400d29e:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400d2a0:	bf00      	nop
3400d2a2:	46bd      	mov	sp, r7
3400d2a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d2a8:	4770      	bx	lr
3400d2aa:	bf00      	nop
3400d2ac:	56028000 	.word	0x56028000

3400d2b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
3400d2b0:	b480      	push	{r7}
3400d2b2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400d2b4:	4b05      	ldr	r3, [pc, #20]	@ (3400d2cc <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3400d2b6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400d2b8:	4a04      	ldr	r2, [pc, #16]	@ (3400d2cc <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3400d2ba:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400d2be:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400d2c0:	bf00      	nop
3400d2c2:	46bd      	mov	sp, r7
3400d2c4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d2c8:	4770      	bx	lr
3400d2ca:	bf00      	nop
3400d2cc:	56028000 	.word	0x56028000

3400d2d0 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
{
3400d2d0:	b480      	push	{r7}
3400d2d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400d2d4:	4b06      	ldr	r3, [pc, #24]	@ (3400d2f0 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x20>)
3400d2d6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400d2d8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400d2dc:	2b40      	cmp	r3, #64	@ 0x40
3400d2de:	d101      	bne.n	3400d2e4 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x14>
3400d2e0:	2301      	movs	r3, #1
3400d2e2:	e000      	b.n	3400d2e6 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x16>
3400d2e4:	2300      	movs	r3, #0
}
3400d2e6:	4618      	mov	r0, r3
3400d2e8:	46bd      	mov	sp, r7
3400d2ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d2ee:	4770      	bx	lr
3400d2f0:	56028000 	.word	0x56028000

3400d2f4 <LL_RCC_HSE_IsReady>:
{
3400d2f4:	b480      	push	{r7}
3400d2f6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400d2f8:	4b06      	ldr	r3, [pc, #24]	@ (3400d314 <LL_RCC_HSE_IsReady+0x20>)
3400d2fa:	685b      	ldr	r3, [r3, #4]
3400d2fc:	f003 0310 	and.w	r3, r3, #16
3400d300:	2b00      	cmp	r3, #0
3400d302:	d001      	beq.n	3400d308 <LL_RCC_HSE_IsReady+0x14>
3400d304:	2301      	movs	r3, #1
3400d306:	e000      	b.n	3400d30a <LL_RCC_HSE_IsReady+0x16>
3400d308:	2300      	movs	r3, #0
}
3400d30a:	4618      	mov	r0, r3
3400d30c:	46bd      	mov	sp, r7
3400d30e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d312:	4770      	bx	lr
3400d314:	56028000 	.word	0x56028000

3400d318 <LL_RCC_HSI_IsReady>:
{
3400d318:	b480      	push	{r7}
3400d31a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400d31c:	4b06      	ldr	r3, [pc, #24]	@ (3400d338 <LL_RCC_HSI_IsReady+0x20>)
3400d31e:	685b      	ldr	r3, [r3, #4]
3400d320:	f003 0308 	and.w	r3, r3, #8
3400d324:	2b00      	cmp	r3, #0
3400d326:	d001      	beq.n	3400d32c <LL_RCC_HSI_IsReady+0x14>
3400d328:	2301      	movs	r3, #1
3400d32a:	e000      	b.n	3400d32e <LL_RCC_HSI_IsReady+0x16>
3400d32c:	2300      	movs	r3, #0
}
3400d32e:	4618      	mov	r0, r3
3400d330:	46bd      	mov	sp, r7
3400d332:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d336:	4770      	bx	lr
3400d338:	56028000 	.word	0x56028000

3400d33c <LL_RCC_HSI_GetDivider>:
{
3400d33c:	b480      	push	{r7}
3400d33e:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400d340:	4b04      	ldr	r3, [pc, #16]	@ (3400d354 <LL_RCC_HSI_GetDivider+0x18>)
3400d342:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d344:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3400d348:	4618      	mov	r0, r3
3400d34a:	46bd      	mov	sp, r7
3400d34c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d350:	4770      	bx	lr
3400d352:	bf00      	nop
3400d354:	56028000 	.word	0x56028000

3400d358 <LL_RCC_MSI_IsReady>:
{
3400d358:	b480      	push	{r7}
3400d35a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400d35c:	4b06      	ldr	r3, [pc, #24]	@ (3400d378 <LL_RCC_MSI_IsReady+0x20>)
3400d35e:	685b      	ldr	r3, [r3, #4]
3400d360:	f003 0304 	and.w	r3, r3, #4
3400d364:	2b00      	cmp	r3, #0
3400d366:	d001      	beq.n	3400d36c <LL_RCC_MSI_IsReady+0x14>
3400d368:	2301      	movs	r3, #1
3400d36a:	e000      	b.n	3400d36e <LL_RCC_MSI_IsReady+0x16>
3400d36c:	2300      	movs	r3, #0
}
3400d36e:	4618      	mov	r0, r3
3400d370:	46bd      	mov	sp, r7
3400d372:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d376:	4770      	bx	lr
3400d378:	56028000 	.word	0x56028000

3400d37c <LL_RCC_MSI_GetFrequency>:
{
3400d37c:	b480      	push	{r7}
3400d37e:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400d380:	4b04      	ldr	r3, [pc, #16]	@ (3400d394 <LL_RCC_MSI_GetFrequency+0x18>)
3400d382:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400d384:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3400d388:	4618      	mov	r0, r3
3400d38a:	46bd      	mov	sp, r7
3400d38c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d390:	4770      	bx	lr
3400d392:	bf00      	nop
3400d394:	56028000 	.word	0x56028000

3400d398 <LL_RCC_LSE_IsReady>:
{
3400d398:	b480      	push	{r7}
3400d39a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400d39c:	4b06      	ldr	r3, [pc, #24]	@ (3400d3b8 <LL_RCC_LSE_IsReady+0x20>)
3400d39e:	685b      	ldr	r3, [r3, #4]
3400d3a0:	f003 0302 	and.w	r3, r3, #2
3400d3a4:	2b00      	cmp	r3, #0
3400d3a6:	d001      	beq.n	3400d3ac <LL_RCC_LSE_IsReady+0x14>
3400d3a8:	2301      	movs	r3, #1
3400d3aa:	e000      	b.n	3400d3ae <LL_RCC_LSE_IsReady+0x16>
3400d3ac:	2300      	movs	r3, #0
}
3400d3ae:	4618      	mov	r0, r3
3400d3b0:	46bd      	mov	sp, r7
3400d3b2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d3b6:	4770      	bx	lr
3400d3b8:	56028000 	.word	0x56028000

3400d3bc <LL_RCC_LSI_IsReady>:
{
3400d3bc:	b480      	push	{r7}
3400d3be:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400d3c0:	4b04      	ldr	r3, [pc, #16]	@ (3400d3d4 <LL_RCC_LSI_IsReady+0x18>)
3400d3c2:	685b      	ldr	r3, [r3, #4]
3400d3c4:	f003 0301 	and.w	r3, r3, #1
}
3400d3c8:	4618      	mov	r0, r3
3400d3ca:	46bd      	mov	sp, r7
3400d3cc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d3d0:	4770      	bx	lr
3400d3d2:	bf00      	nop
3400d3d4:	56028000 	.word	0x56028000

3400d3d8 <LL_RCC_GetAHBPrescaler>:
{
3400d3d8:	b480      	push	{r7}
3400d3da:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400d3dc:	4b04      	ldr	r3, [pc, #16]	@ (3400d3f0 <LL_RCC_GetAHBPrescaler+0x18>)
3400d3de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400d3e0:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3400d3e4:	4618      	mov	r0, r3
3400d3e6:	46bd      	mov	sp, r7
3400d3e8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d3ec:	4770      	bx	lr
3400d3ee:	bf00      	nop
3400d3f0:	56028000 	.word	0x56028000

3400d3f4 <LL_RCC_GetAPB1Prescaler>:
{
3400d3f4:	b480      	push	{r7}
3400d3f6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400d3f8:	4b04      	ldr	r3, [pc, #16]	@ (3400d40c <LL_RCC_GetAPB1Prescaler+0x18>)
3400d3fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400d3fc:	f003 0307 	and.w	r3, r3, #7
}
3400d400:	4618      	mov	r0, r3
3400d402:	46bd      	mov	sp, r7
3400d404:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d408:	4770      	bx	lr
3400d40a:	bf00      	nop
3400d40c:	56028000 	.word	0x56028000

3400d410 <LL_RCC_GetAPB2Prescaler>:
{
3400d410:	b480      	push	{r7}
3400d412:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400d414:	4b04      	ldr	r3, [pc, #16]	@ (3400d428 <LL_RCC_GetAPB2Prescaler+0x18>)
3400d416:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400d418:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3400d41c:	4618      	mov	r0, r3
3400d41e:	46bd      	mov	sp, r7
3400d420:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d424:	4770      	bx	lr
3400d426:	bf00      	nop
3400d428:	56028000 	.word	0x56028000

3400d42c <LL_RCC_GetAPB4Prescaler>:
{
3400d42c:	b480      	push	{r7}
3400d42e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400d430:	4b04      	ldr	r3, [pc, #16]	@ (3400d444 <LL_RCC_GetAPB4Prescaler+0x18>)
3400d432:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400d434:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
}
3400d438:	4618      	mov	r0, r3
3400d43a:	46bd      	mov	sp, r7
3400d43c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d440:	4770      	bx	lr
3400d442:	bf00      	nop
3400d444:	56028000 	.word	0x56028000

3400d448 <LL_RCC_GetAPB5Prescaler>:
{
3400d448:	b480      	push	{r7}
3400d44a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3400d44c:	4b04      	ldr	r3, [pc, #16]	@ (3400d460 <LL_RCC_GetAPB5Prescaler+0x18>)
3400d44e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400d450:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3400d454:	4618      	mov	r0, r3
3400d456:	46bd      	mov	sp, r7
3400d458:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d45c:	4770      	bx	lr
3400d45e:	bf00      	nop
3400d460:	56028000 	.word	0x56028000

3400d464 <LL_RCC_SetClockSource>:
{
3400d464:	b480      	push	{r7}
3400d466:	b085      	sub	sp, #20
3400d468:	af00      	add	r7, sp, #0
3400d46a:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400d46c:	687b      	ldr	r3, [r7, #4]
3400d46e:	b2da      	uxtb	r2, r3
3400d470:	4b10      	ldr	r3, [pc, #64]	@ (3400d4b4 <LL_RCC_SetClockSource+0x50>)
3400d472:	4413      	add	r3, r2
3400d474:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3400d476:	68fb      	ldr	r3, [r7, #12]
3400d478:	681a      	ldr	r2, [r3, #0]
3400d47a:	687b      	ldr	r3, [r7, #4]
3400d47c:	0e19      	lsrs	r1, r3, #24
3400d47e:	687b      	ldr	r3, [r7, #4]
3400d480:	0a1b      	lsrs	r3, r3, #8
3400d482:	f003 031f 	and.w	r3, r3, #31
3400d486:	fa01 f303 	lsl.w	r3, r1, r3
3400d48a:	43db      	mvns	r3, r3
3400d48c:	401a      	ands	r2, r3
3400d48e:	687b      	ldr	r3, [r7, #4]
3400d490:	0c1b      	lsrs	r3, r3, #16
3400d492:	b2d9      	uxtb	r1, r3
3400d494:	687b      	ldr	r3, [r7, #4]
3400d496:	0a1b      	lsrs	r3, r3, #8
3400d498:	f003 031f 	and.w	r3, r3, #31
3400d49c:	fa01 f303 	lsl.w	r3, r1, r3
3400d4a0:	431a      	orrs	r2, r3
3400d4a2:	68fb      	ldr	r3, [r7, #12]
3400d4a4:	601a      	str	r2, [r3, #0]
}
3400d4a6:	bf00      	nop
3400d4a8:	3714      	adds	r7, #20
3400d4aa:	46bd      	mov	sp, r7
3400d4ac:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d4b0:	4770      	bx	lr
3400d4b2:	bf00      	nop
3400d4b4:	56028144 	.word	0x56028144

3400d4b8 <LL_RCC_GetADCPrescaler>:
{
3400d4b8:	b480      	push	{r7}
3400d4ba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3400d4bc:	4b04      	ldr	r3, [pc, #16]	@ (3400d4d0 <LL_RCC_GetADCPrescaler+0x18>)
3400d4be:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400d4c2:	0a1b      	lsrs	r3, r3, #8
3400d4c4:	b2db      	uxtb	r3, r3
}
3400d4c6:	4618      	mov	r0, r3
3400d4c8:	46bd      	mov	sp, r7
3400d4ca:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d4ce:	4770      	bx	lr
3400d4d0:	56028000 	.word	0x56028000

3400d4d4 <LL_RCC_SetADFClockSource>:
{
3400d4d4:	b480      	push	{r7}
3400d4d6:	b083      	sub	sp, #12
3400d4d8:	af00      	add	r7, sp, #0
3400d4da:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3400d4dc:	4b07      	ldr	r3, [pc, #28]	@ (3400d4fc <LL_RCC_SetADFClockSource+0x28>)
3400d4de:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400d4e2:	f023 0207 	bic.w	r2, r3, #7
3400d4e6:	4905      	ldr	r1, [pc, #20]	@ (3400d4fc <LL_RCC_SetADFClockSource+0x28>)
3400d4e8:	687b      	ldr	r3, [r7, #4]
3400d4ea:	4313      	orrs	r3, r2
3400d4ec:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3400d4f0:	bf00      	nop
3400d4f2:	370c      	adds	r7, #12
3400d4f4:	46bd      	mov	sp, r7
3400d4f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d4fa:	4770      	bx	lr
3400d4fc:	56028000 	.word	0x56028000

3400d500 <LL_RCC_SetCLKPClockSource>:
{
3400d500:	b480      	push	{r7}
3400d502:	b083      	sub	sp, #12
3400d504:	af00      	add	r7, sp, #0
3400d506:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3400d508:	4b07      	ldr	r3, [pc, #28]	@ (3400d528 <LL_RCC_SetCLKPClockSource+0x28>)
3400d50a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400d50e:	f023 0207 	bic.w	r2, r3, #7
3400d512:	4905      	ldr	r1, [pc, #20]	@ (3400d528 <LL_RCC_SetCLKPClockSource+0x28>)
3400d514:	687b      	ldr	r3, [r7, #4]
3400d516:	4313      	orrs	r3, r2
3400d518:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400d51c:	bf00      	nop
3400d51e:	370c      	adds	r7, #12
3400d520:	46bd      	mov	sp, r7
3400d522:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d526:	4770      	bx	lr
3400d528:	56028000 	.word	0x56028000

3400d52c <LL_RCC_SetDCMIPPClockSource>:
{
3400d52c:	b480      	push	{r7}
3400d52e:	b083      	sub	sp, #12
3400d530:	af00      	add	r7, sp, #0
3400d532:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3400d534:	4b07      	ldr	r3, [pc, #28]	@ (3400d554 <LL_RCC_SetDCMIPPClockSource+0x28>)
3400d536:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400d53a:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
3400d53e:	4905      	ldr	r1, [pc, #20]	@ (3400d554 <LL_RCC_SetDCMIPPClockSource+0x28>)
3400d540:	687b      	ldr	r3, [r7, #4]
3400d542:	4313      	orrs	r3, r2
3400d544:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3400d548:	bf00      	nop
3400d54a:	370c      	adds	r7, #12
3400d54c:	46bd      	mov	sp, r7
3400d54e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d552:	4770      	bx	lr
3400d554:	56028000 	.word	0x56028000

3400d558 <LL_RCC_SetETHClockSource>:
{
3400d558:	b480      	push	{r7}
3400d55a:	b083      	sub	sp, #12
3400d55c:	af00      	add	r7, sp, #0
3400d55e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3400d560:	4b07      	ldr	r3, [pc, #28]	@ (3400d580 <LL_RCC_SetETHClockSource+0x28>)
3400d562:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d566:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3400d56a:	4905      	ldr	r1, [pc, #20]	@ (3400d580 <LL_RCC_SetETHClockSource+0x28>)
3400d56c:	687b      	ldr	r3, [r7, #4]
3400d56e:	4313      	orrs	r3, r2
3400d570:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400d574:	bf00      	nop
3400d576:	370c      	adds	r7, #12
3400d578:	46bd      	mov	sp, r7
3400d57a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d57e:	4770      	bx	lr
3400d580:	56028000 	.word	0x56028000

3400d584 <LL_RCC_SetETHPHYInterface>:
{
3400d584:	b480      	push	{r7}
3400d586:	b083      	sub	sp, #12
3400d588:	af00      	add	r7, sp, #0
3400d58a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3400d58c:	4b07      	ldr	r3, [pc, #28]	@ (3400d5ac <LL_RCC_SetETHPHYInterface+0x28>)
3400d58e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d592:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400d596:	4905      	ldr	r1, [pc, #20]	@ (3400d5ac <LL_RCC_SetETHPHYInterface+0x28>)
3400d598:	687b      	ldr	r3, [r7, #4]
3400d59a:	4313      	orrs	r3, r2
3400d59c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400d5a0:	bf00      	nop
3400d5a2:	370c      	adds	r7, #12
3400d5a4:	46bd      	mov	sp, r7
3400d5a6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d5aa:	4770      	bx	lr
3400d5ac:	56028000 	.word	0x56028000

3400d5b0 <LL_RCC_GetETH1PTPDivider>:
{
3400d5b0:	b480      	push	{r7}
3400d5b2:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3400d5b4:	4b04      	ldr	r3, [pc, #16]	@ (3400d5c8 <LL_RCC_GetETH1PTPDivider+0x18>)
3400d5b6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d5ba:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
}
3400d5be:	4618      	mov	r0, r3
3400d5c0:	46bd      	mov	sp, r7
3400d5c2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d5c6:	4770      	bx	lr
3400d5c8:	56028000 	.word	0x56028000

3400d5cc <LL_RCC_SetETHREFRXClockSource>:
{
3400d5cc:	b480      	push	{r7}
3400d5ce:	b083      	sub	sp, #12
3400d5d0:	af00      	add	r7, sp, #0
3400d5d2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400d5d4:	4b07      	ldr	r3, [pc, #28]	@ (3400d5f4 <LL_RCC_SetETHREFRXClockSource+0x28>)
3400d5d6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d5da:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
3400d5de:	4905      	ldr	r1, [pc, #20]	@ (3400d5f4 <LL_RCC_SetETHREFRXClockSource+0x28>)
3400d5e0:	687b      	ldr	r3, [r7, #4]
3400d5e2:	4313      	orrs	r3, r2
3400d5e4:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400d5e8:	bf00      	nop
3400d5ea:	370c      	adds	r7, #12
3400d5ec:	46bd      	mov	sp, r7
3400d5ee:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d5f2:	4770      	bx	lr
3400d5f4:	56028000 	.word	0x56028000

3400d5f8 <LL_RCC_SetETHREFTXClockSource>:
{
3400d5f8:	b480      	push	{r7}
3400d5fa:	b083      	sub	sp, #12
3400d5fc:	af00      	add	r7, sp, #0
3400d5fe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3400d600:	4b07      	ldr	r3, [pc, #28]	@ (3400d620 <LL_RCC_SetETHREFTXClockSource+0x28>)
3400d602:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d606:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400d60a:	4905      	ldr	r1, [pc, #20]	@ (3400d620 <LL_RCC_SetETHREFTXClockSource+0x28>)
3400d60c:	687b      	ldr	r3, [r7, #4]
3400d60e:	4313      	orrs	r3, r2
3400d610:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400d614:	bf00      	nop
3400d616:	370c      	adds	r7, #12
3400d618:	46bd      	mov	sp, r7
3400d61a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d61e:	4770      	bx	lr
3400d620:	56028000 	.word	0x56028000

3400d624 <LL_RCC_SetFDCANClockSource>:
{
3400d624:	b480      	push	{r7}
3400d626:	b083      	sub	sp, #12
3400d628:	af00      	add	r7, sp, #0
3400d62a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3400d62c:	4b07      	ldr	r3, [pc, #28]	@ (3400d64c <LL_RCC_SetFDCANClockSource+0x28>)
3400d62e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400d632:	f023 0203 	bic.w	r2, r3, #3
3400d636:	4905      	ldr	r1, [pc, #20]	@ (3400d64c <LL_RCC_SetFDCANClockSource+0x28>)
3400d638:	687b      	ldr	r3, [r7, #4]
3400d63a:	4313      	orrs	r3, r2
3400d63c:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3400d640:	bf00      	nop
3400d642:	370c      	adds	r7, #12
3400d644:	46bd      	mov	sp, r7
3400d646:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d64a:	4770      	bx	lr
3400d64c:	56028000 	.word	0x56028000

3400d650 <LL_RCC_SetFMCClockSource>:
{
3400d650:	b480      	push	{r7}
3400d652:	b083      	sub	sp, #12
3400d654:	af00      	add	r7, sp, #0
3400d656:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3400d658:	4b07      	ldr	r3, [pc, #28]	@ (3400d678 <LL_RCC_SetFMCClockSource+0x28>)
3400d65a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400d65e:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400d662:	4905      	ldr	r1, [pc, #20]	@ (3400d678 <LL_RCC_SetFMCClockSource+0x28>)
3400d664:	687b      	ldr	r3, [r7, #4]
3400d666:	4313      	orrs	r3, r2
3400d668:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3400d66c:	bf00      	nop
3400d66e:	370c      	adds	r7, #12
3400d670:	46bd      	mov	sp, r7
3400d672:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d676:	4770      	bx	lr
3400d678:	56028000 	.word	0x56028000

3400d67c <LL_RCC_SetI2CClockSource>:
{
3400d67c:	b580      	push	{r7, lr}
3400d67e:	b082      	sub	sp, #8
3400d680:	af00      	add	r7, sp, #0
3400d682:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d684:	6878      	ldr	r0, [r7, #4]
3400d686:	f7ff feed 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d68a:	bf00      	nop
3400d68c:	3708      	adds	r7, #8
3400d68e:	46bd      	mov	sp, r7
3400d690:	bd80      	pop	{r7, pc}

3400d692 <LL_RCC_SetI3CClockSource>:
{
3400d692:	b580      	push	{r7, lr}
3400d694:	b082      	sub	sp, #8
3400d696:	af00      	add	r7, sp, #0
3400d698:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d69a:	6878      	ldr	r0, [r7, #4]
3400d69c:	f7ff fee2 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d6a0:	bf00      	nop
3400d6a2:	3708      	adds	r7, #8
3400d6a4:	46bd      	mov	sp, r7
3400d6a6:	bd80      	pop	{r7, pc}

3400d6a8 <LL_RCC_SetLPTIMClockSource>:
{
3400d6a8:	b580      	push	{r7, lr}
3400d6aa:	b082      	sub	sp, #8
3400d6ac:	af00      	add	r7, sp, #0
3400d6ae:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d6b0:	6878      	ldr	r0, [r7, #4]
3400d6b2:	f7ff fed7 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d6b6:	bf00      	nop
3400d6b8:	3708      	adds	r7, #8
3400d6ba:	46bd      	mov	sp, r7
3400d6bc:	bd80      	pop	{r7, pc}
	...

3400d6c0 <LL_RCC_SetLPUARTClockSource>:
{
3400d6c0:	b480      	push	{r7}
3400d6c2:	b083      	sub	sp, #12
3400d6c4:	af00      	add	r7, sp, #0
3400d6c6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3400d6c8:	4b07      	ldr	r3, [pc, #28]	@ (3400d6e8 <LL_RCC_SetLPUARTClockSource+0x28>)
3400d6ca:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400d6ce:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
3400d6d2:	4905      	ldr	r1, [pc, #20]	@ (3400d6e8 <LL_RCC_SetLPUARTClockSource+0x28>)
3400d6d4:	687b      	ldr	r3, [r7, #4]
3400d6d6:	4313      	orrs	r3, r2
3400d6d8:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
3400d6dc:	bf00      	nop
3400d6de:	370c      	adds	r7, #12
3400d6e0:	46bd      	mov	sp, r7
3400d6e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d6e6:	4770      	bx	lr
3400d6e8:	56028000 	.word	0x56028000

3400d6ec <LL_RCC_SetLTDCClockSource>:
{
3400d6ec:	b480      	push	{r7}
3400d6ee:	b083      	sub	sp, #12
3400d6f0:	af00      	add	r7, sp, #0
3400d6f2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3400d6f4:	4b07      	ldr	r3, [pc, #28]	@ (3400d714 <LL_RCC_SetLTDCClockSource+0x28>)
3400d6f6:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400d6fa:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3400d6fe:	4905      	ldr	r1, [pc, #20]	@ (3400d714 <LL_RCC_SetLTDCClockSource+0x28>)
3400d700:	687b      	ldr	r3, [r7, #4]
3400d702:	4313      	orrs	r3, r2
3400d704:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
3400d708:	bf00      	nop
3400d70a:	370c      	adds	r7, #12
3400d70c:	46bd      	mov	sp, r7
3400d70e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d712:	4770      	bx	lr
3400d714:	56028000 	.word	0x56028000

3400d718 <LL_RCC_SetMDFClockSource>:
{
3400d718:	b480      	push	{r7}
3400d71a:	b083      	sub	sp, #12
3400d71c:	af00      	add	r7, sp, #0
3400d71e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3400d720:	4b07      	ldr	r3, [pc, #28]	@ (3400d740 <LL_RCC_SetMDFClockSource+0x28>)
3400d722:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400d726:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400d72a:	4905      	ldr	r1, [pc, #20]	@ (3400d740 <LL_RCC_SetMDFClockSource+0x28>)
3400d72c:	687b      	ldr	r3, [r7, #4]
3400d72e:	4313      	orrs	r3, r2
3400d730:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
3400d734:	bf00      	nop
3400d736:	370c      	adds	r7, #12
3400d738:	46bd      	mov	sp, r7
3400d73a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d73e:	4770      	bx	lr
3400d740:	56028000 	.word	0x56028000

3400d744 <LL_RCC_SetOTGPHYClockSource>:
{
3400d744:	b580      	push	{r7, lr}
3400d746:	b082      	sub	sp, #8
3400d748:	af00      	add	r7, sp, #0
3400d74a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d74c:	6878      	ldr	r0, [r7, #4]
3400d74e:	f7ff fe89 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d752:	bf00      	nop
3400d754:	3708      	adds	r7, #8
3400d756:	46bd      	mov	sp, r7
3400d758:	bd80      	pop	{r7, pc}

3400d75a <LL_RCC_SetOTGPHYCKREFClockSource>:
{
3400d75a:	b580      	push	{r7, lr}
3400d75c:	b082      	sub	sp, #8
3400d75e:	af00      	add	r7, sp, #0
3400d760:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d762:	6878      	ldr	r0, [r7, #4]
3400d764:	f7ff fe7e 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d768:	bf00      	nop
3400d76a:	3708      	adds	r7, #8
3400d76c:	46bd      	mov	sp, r7
3400d76e:	bd80      	pop	{r7, pc}

3400d770 <LL_RCC_SetPSSIClockSource>:
{
3400d770:	b480      	push	{r7}
3400d772:	b083      	sub	sp, #12
3400d774:	af00      	add	r7, sp, #0
3400d776:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3400d778:	4b07      	ldr	r3, [pc, #28]	@ (3400d798 <LL_RCC_SetPSSIClockSource+0x28>)
3400d77a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400d77e:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400d782:	4905      	ldr	r1, [pc, #20]	@ (3400d798 <LL_RCC_SetPSSIClockSource+0x28>)
3400d784:	687b      	ldr	r3, [r7, #4]
3400d786:	4313      	orrs	r3, r2
3400d788:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400d78c:	bf00      	nop
3400d78e:	370c      	adds	r7, #12
3400d790:	46bd      	mov	sp, r7
3400d792:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d796:	4770      	bx	lr
3400d798:	56028000 	.word	0x56028000

3400d79c <LL_RCC_SetSAIClockSource>:
{
3400d79c:	b580      	push	{r7, lr}
3400d79e:	b082      	sub	sp, #8
3400d7a0:	af00      	add	r7, sp, #0
3400d7a2:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d7a4:	6878      	ldr	r0, [r7, #4]
3400d7a6:	f7ff fe5d 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d7aa:	bf00      	nop
3400d7ac:	3708      	adds	r7, #8
3400d7ae:	46bd      	mov	sp, r7
3400d7b0:	bd80      	pop	{r7, pc}

3400d7b2 <LL_RCC_SetSDMMCClockSource>:
{
3400d7b2:	b580      	push	{r7, lr}
3400d7b4:	b082      	sub	sp, #8
3400d7b6:	af00      	add	r7, sp, #0
3400d7b8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d7ba:	6878      	ldr	r0, [r7, #4]
3400d7bc:	f7ff fe52 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d7c0:	bf00      	nop
3400d7c2:	3708      	adds	r7, #8
3400d7c4:	46bd      	mov	sp, r7
3400d7c6:	bd80      	pop	{r7, pc}

3400d7c8 <LL_RCC_SetSPDIFRXClockSource>:
{
3400d7c8:	b480      	push	{r7}
3400d7ca:	b083      	sub	sp, #12
3400d7cc:	af00      	add	r7, sp, #0
3400d7ce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3400d7d0:	4b07      	ldr	r3, [pc, #28]	@ (3400d7f0 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3400d7d2:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400d7d6:	f023 0207 	bic.w	r2, r3, #7
3400d7da:	4905      	ldr	r1, [pc, #20]	@ (3400d7f0 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3400d7dc:	687b      	ldr	r3, [r7, #4]
3400d7de:	4313      	orrs	r3, r2
3400d7e0:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
3400d7e4:	bf00      	nop
3400d7e6:	370c      	adds	r7, #12
3400d7e8:	46bd      	mov	sp, r7
3400d7ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d7ee:	4770      	bx	lr
3400d7f0:	56028000 	.word	0x56028000

3400d7f4 <LL_RCC_SetSPIClockSource>:
{
3400d7f4:	b580      	push	{r7, lr}
3400d7f6:	b082      	sub	sp, #8
3400d7f8:	af00      	add	r7, sp, #0
3400d7fa:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d7fc:	6878      	ldr	r0, [r7, #4]
3400d7fe:	f7ff fe31 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d802:	bf00      	nop
3400d804:	3708      	adds	r7, #8
3400d806:	46bd      	mov	sp, r7
3400d808:	bd80      	pop	{r7, pc}

3400d80a <LL_RCC_SetUSARTClockSource>:
{
3400d80a:	b580      	push	{r7, lr}
3400d80c:	b082      	sub	sp, #8
3400d80e:	af00      	add	r7, sp, #0
3400d810:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d812:	6878      	ldr	r0, [r7, #4]
3400d814:	f7ff fe26 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d818:	bf00      	nop
3400d81a:	3708      	adds	r7, #8
3400d81c:	46bd      	mov	sp, r7
3400d81e:	bd80      	pop	{r7, pc}

3400d820 <LL_RCC_SetXSPIClockSource>:
{
3400d820:	b580      	push	{r7, lr}
3400d822:	b082      	sub	sp, #8
3400d824:	af00      	add	r7, sp, #0
3400d826:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400d828:	6878      	ldr	r0, [r7, #4]
3400d82a:	f7ff fe1b 	bl	3400d464 <LL_RCC_SetClockSource>
}
3400d82e:	bf00      	nop
3400d830:	3708      	adds	r7, #8
3400d832:	46bd      	mov	sp, r7
3400d834:	bd80      	pop	{r7, pc}
	...

3400d838 <LL_RCC_GetClockSource>:
{
3400d838:	b480      	push	{r7}
3400d83a:	b085      	sub	sp, #20
3400d83c:	af00      	add	r7, sp, #0
3400d83e:	6078      	str	r0, [r7, #4]
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3400d840:	687b      	ldr	r3, [r7, #4]
3400d842:	b2da      	uxtb	r2, r3
3400d844:	4b0e      	ldr	r3, [pc, #56]	@ (3400d880 <LL_RCC_GetClockSource+0x48>)
3400d846:	4413      	add	r3, r2
3400d848:	60fb      	str	r3, [r7, #12]
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3400d84a:	68fb      	ldr	r3, [r7, #12]
3400d84c:	681a      	ldr	r2, [r3, #0]
3400d84e:	687b      	ldr	r3, [r7, #4]
3400d850:	0e19      	lsrs	r1, r3, #24
3400d852:	687b      	ldr	r3, [r7, #4]
3400d854:	0a1b      	lsrs	r3, r3, #8
3400d856:	f003 031f 	and.w	r3, r3, #31
3400d85a:	fa01 f303 	lsl.w	r3, r1, r3
3400d85e:	401a      	ands	r2, r3
3400d860:	687b      	ldr	r3, [r7, #4]
3400d862:	0a1b      	lsrs	r3, r3, #8
3400d864:	f003 031f 	and.w	r3, r3, #31
3400d868:	fa22 f303 	lsr.w	r3, r2, r3
3400d86c:	041a      	lsls	r2, r3, #16
3400d86e:	687b      	ldr	r3, [r7, #4]
3400d870:	4313      	orrs	r3, r2
}
3400d872:	4618      	mov	r0, r3
3400d874:	3714      	adds	r7, #20
3400d876:	46bd      	mov	sp, r7
3400d878:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d87c:	4770      	bx	lr
3400d87e:	bf00      	nop
3400d880:	56028144 	.word	0x56028144

3400d884 <LL_RCC_GetADCClockSource>:
{
3400d884:	b480      	push	{r7}
3400d886:	b083      	sub	sp, #12
3400d888:	af00      	add	r7, sp, #0
3400d88a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3400d88c:	4b05      	ldr	r3, [pc, #20]	@ (3400d8a4 <LL_RCC_GetADCClockSource+0x20>)
3400d88e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400d892:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3400d896:	4618      	mov	r0, r3
3400d898:	370c      	adds	r7, #12
3400d89a:	46bd      	mov	sp, r7
3400d89c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8a0:	4770      	bx	lr
3400d8a2:	bf00      	nop
3400d8a4:	56028000 	.word	0x56028000

3400d8a8 <LL_RCC_GetADFClockSource>:
{
3400d8a8:	b480      	push	{r7}
3400d8aa:	b083      	sub	sp, #12
3400d8ac:	af00      	add	r7, sp, #0
3400d8ae:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3400d8b0:	4b05      	ldr	r3, [pc, #20]	@ (3400d8c8 <LL_RCC_GetADFClockSource+0x20>)
3400d8b2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400d8b6:	f003 0307 	and.w	r3, r3, #7
}
3400d8ba:	4618      	mov	r0, r3
3400d8bc:	370c      	adds	r7, #12
3400d8be:	46bd      	mov	sp, r7
3400d8c0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8c4:	4770      	bx	lr
3400d8c6:	bf00      	nop
3400d8c8:	56028000 	.word	0x56028000

3400d8cc <LL_RCC_GetCLKPClockSource>:
{
3400d8cc:	b480      	push	{r7}
3400d8ce:	b083      	sub	sp, #12
3400d8d0:	af00      	add	r7, sp, #0
3400d8d2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3400d8d4:	4b05      	ldr	r3, [pc, #20]	@ (3400d8ec <LL_RCC_GetCLKPClockSource+0x20>)
3400d8d6:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400d8da:	f003 0307 	and.w	r3, r3, #7
}
3400d8de:	4618      	mov	r0, r3
3400d8e0:	370c      	adds	r7, #12
3400d8e2:	46bd      	mov	sp, r7
3400d8e4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8e8:	4770      	bx	lr
3400d8ea:	bf00      	nop
3400d8ec:	56028000 	.word	0x56028000

3400d8f0 <LL_RCC_GetDCMIPPClockSource>:
{
3400d8f0:	b480      	push	{r7}
3400d8f2:	b083      	sub	sp, #12
3400d8f4:	af00      	add	r7, sp, #0
3400d8f6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3400d8f8:	4b05      	ldr	r3, [pc, #20]	@ (3400d910 <LL_RCC_GetDCMIPPClockSource+0x20>)
3400d8fa:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400d8fe:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3400d902:	4618      	mov	r0, r3
3400d904:	370c      	adds	r7, #12
3400d906:	46bd      	mov	sp, r7
3400d908:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d90c:	4770      	bx	lr
3400d90e:	bf00      	nop
3400d910:	56028000 	.word	0x56028000

3400d914 <LL_RCC_GetETHClockSource>:
{
3400d914:	b480      	push	{r7}
3400d916:	b083      	sub	sp, #12
3400d918:	af00      	add	r7, sp, #0
3400d91a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3400d91c:	4b05      	ldr	r3, [pc, #20]	@ (3400d934 <LL_RCC_GetETHClockSource+0x20>)
3400d91e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d922:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
}
3400d926:	4618      	mov	r0, r3
3400d928:	370c      	adds	r7, #12
3400d92a:	46bd      	mov	sp, r7
3400d92c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d930:	4770      	bx	lr
3400d932:	bf00      	nop
3400d934:	56028000 	.word	0x56028000

3400d938 <LL_RCC_GetETHPTPClockSource>:
{
3400d938:	b480      	push	{r7}
3400d93a:	b083      	sub	sp, #12
3400d93c:	af00      	add	r7, sp, #0
3400d93e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3400d940:	4b05      	ldr	r3, [pc, #20]	@ (3400d958 <LL_RCC_GetETHPTPClockSource+0x20>)
3400d942:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400d946:	f003 0303 	and.w	r3, r3, #3
}
3400d94a:	4618      	mov	r0, r3
3400d94c:	370c      	adds	r7, #12
3400d94e:	46bd      	mov	sp, r7
3400d950:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d954:	4770      	bx	lr
3400d956:	bf00      	nop
3400d958:	56028000 	.word	0x56028000

3400d95c <LL_RCC_GetFDCANClockSource>:
{
3400d95c:	b480      	push	{r7}
3400d95e:	b083      	sub	sp, #12
3400d960:	af00      	add	r7, sp, #0
3400d962:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3400d964:	4b05      	ldr	r3, [pc, #20]	@ (3400d97c <LL_RCC_GetFDCANClockSource+0x20>)
3400d966:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400d96a:	f003 0303 	and.w	r3, r3, #3
}
3400d96e:	4618      	mov	r0, r3
3400d970:	370c      	adds	r7, #12
3400d972:	46bd      	mov	sp, r7
3400d974:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d978:	4770      	bx	lr
3400d97a:	bf00      	nop
3400d97c:	56028000 	.word	0x56028000

3400d980 <LL_RCC_GetFMCClockSource>:
{
3400d980:	b480      	push	{r7}
3400d982:	b083      	sub	sp, #12
3400d984:	af00      	add	r7, sp, #0
3400d986:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3400d988:	4b05      	ldr	r3, [pc, #20]	@ (3400d9a0 <LL_RCC_GetFMCClockSource+0x20>)
3400d98a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400d98e:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3400d992:	4618      	mov	r0, r3
3400d994:	370c      	adds	r7, #12
3400d996:	46bd      	mov	sp, r7
3400d998:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d99c:	4770      	bx	lr
3400d99e:	bf00      	nop
3400d9a0:	56028000 	.word	0x56028000

3400d9a4 <LL_RCC_GetI2CClockSource>:
{
3400d9a4:	b580      	push	{r7, lr}
3400d9a6:	b082      	sub	sp, #8
3400d9a8:	af00      	add	r7, sp, #0
3400d9aa:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400d9ac:	6878      	ldr	r0, [r7, #4]
3400d9ae:	f7ff ff43 	bl	3400d838 <LL_RCC_GetClockSource>
3400d9b2:	4603      	mov	r3, r0
}
3400d9b4:	4618      	mov	r0, r3
3400d9b6:	3708      	adds	r7, #8
3400d9b8:	46bd      	mov	sp, r7
3400d9ba:	bd80      	pop	{r7, pc}

3400d9bc <LL_RCC_GetI3CClockSource>:
{
3400d9bc:	b580      	push	{r7, lr}
3400d9be:	b082      	sub	sp, #8
3400d9c0:	af00      	add	r7, sp, #0
3400d9c2:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400d9c4:	6878      	ldr	r0, [r7, #4]
3400d9c6:	f7ff ff37 	bl	3400d838 <LL_RCC_GetClockSource>
3400d9ca:	4603      	mov	r3, r0
}
3400d9cc:	4618      	mov	r0, r3
3400d9ce:	3708      	adds	r7, #8
3400d9d0:	46bd      	mov	sp, r7
3400d9d2:	bd80      	pop	{r7, pc}

3400d9d4 <LL_RCC_GetLPTIMClockSource>:
{
3400d9d4:	b580      	push	{r7, lr}
3400d9d6:	b082      	sub	sp, #8
3400d9d8:	af00      	add	r7, sp, #0
3400d9da:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400d9dc:	6878      	ldr	r0, [r7, #4]
3400d9de:	f7ff ff2b 	bl	3400d838 <LL_RCC_GetClockSource>
3400d9e2:	4603      	mov	r3, r0
}
3400d9e4:	4618      	mov	r0, r3
3400d9e6:	3708      	adds	r7, #8
3400d9e8:	46bd      	mov	sp, r7
3400d9ea:	bd80      	pop	{r7, pc}

3400d9ec <LL_RCC_GetLPUARTClockSource>:
{
3400d9ec:	b480      	push	{r7}
3400d9ee:	b083      	sub	sp, #12
3400d9f0:	af00      	add	r7, sp, #0
3400d9f2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3400d9f4:	4b05      	ldr	r3, [pc, #20]	@ (3400da0c <LL_RCC_GetLPUARTClockSource+0x20>)
3400d9f6:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400d9fa:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
}
3400d9fe:	4618      	mov	r0, r3
3400da00:	370c      	adds	r7, #12
3400da02:	46bd      	mov	sp, r7
3400da04:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da08:	4770      	bx	lr
3400da0a:	bf00      	nop
3400da0c:	56028000 	.word	0x56028000

3400da10 <LL_RCC_GetLTDCClockSource>:
{
3400da10:	b480      	push	{r7}
3400da12:	b083      	sub	sp, #12
3400da14:	af00      	add	r7, sp, #0
3400da16:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3400da18:	4b05      	ldr	r3, [pc, #20]	@ (3400da30 <LL_RCC_GetLTDCClockSource+0x20>)
3400da1a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400da1e:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
}
3400da22:	4618      	mov	r0, r3
3400da24:	370c      	adds	r7, #12
3400da26:	46bd      	mov	sp, r7
3400da28:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da2c:	4770      	bx	lr
3400da2e:	bf00      	nop
3400da30:	56028000 	.word	0x56028000

3400da34 <LL_RCC_GetMDFClockSource>:
{
3400da34:	b480      	push	{r7}
3400da36:	b083      	sub	sp, #12
3400da38:	af00      	add	r7, sp, #0
3400da3a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3400da3c:	4b05      	ldr	r3, [pc, #20]	@ (3400da54 <LL_RCC_GetMDFClockSource+0x20>)
3400da3e:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400da42:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3400da46:	4618      	mov	r0, r3
3400da48:	370c      	adds	r7, #12
3400da4a:	46bd      	mov	sp, r7
3400da4c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da50:	4770      	bx	lr
3400da52:	bf00      	nop
3400da54:	56028000 	.word	0x56028000

3400da58 <LL_RCC_GetPSSIClockSource>:
{
3400da58:	b480      	push	{r7}
3400da5a:	b083      	sub	sp, #12
3400da5c:	af00      	add	r7, sp, #0
3400da5e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3400da60:	4b05      	ldr	r3, [pc, #20]	@ (3400da78 <LL_RCC_GetPSSIClockSource+0x20>)
3400da62:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400da66:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3400da6a:	4618      	mov	r0, r3
3400da6c:	370c      	adds	r7, #12
3400da6e:	46bd      	mov	sp, r7
3400da70:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da74:	4770      	bx	lr
3400da76:	bf00      	nop
3400da78:	56028000 	.word	0x56028000

3400da7c <LL_RCC_GetSAIClockSource>:
{
3400da7c:	b580      	push	{r7, lr}
3400da7e:	b082      	sub	sp, #8
3400da80:	af00      	add	r7, sp, #0
3400da82:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400da84:	6878      	ldr	r0, [r7, #4]
3400da86:	f7ff fed7 	bl	3400d838 <LL_RCC_GetClockSource>
3400da8a:	4603      	mov	r3, r0
}
3400da8c:	4618      	mov	r0, r3
3400da8e:	3708      	adds	r7, #8
3400da90:	46bd      	mov	sp, r7
3400da92:	bd80      	pop	{r7, pc}

3400da94 <LL_RCC_GetSDMMCClockSource>:
{
3400da94:	b580      	push	{r7, lr}
3400da96:	b082      	sub	sp, #8
3400da98:	af00      	add	r7, sp, #0
3400da9a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400da9c:	6878      	ldr	r0, [r7, #4]
3400da9e:	f7ff fecb 	bl	3400d838 <LL_RCC_GetClockSource>
3400daa2:	4603      	mov	r3, r0
}
3400daa4:	4618      	mov	r0, r3
3400daa6:	3708      	adds	r7, #8
3400daa8:	46bd      	mov	sp, r7
3400daaa:	bd80      	pop	{r7, pc}

3400daac <LL_RCC_GetSPDIFRXClockSource>:
{
3400daac:	b480      	push	{r7}
3400daae:	b083      	sub	sp, #12
3400dab0:	af00      	add	r7, sp, #0
3400dab2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3400dab4:	4b05      	ldr	r3, [pc, #20]	@ (3400dacc <LL_RCC_GetSPDIFRXClockSource+0x20>)
3400dab6:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400daba:	f003 0307 	and.w	r3, r3, #7
}
3400dabe:	4618      	mov	r0, r3
3400dac0:	370c      	adds	r7, #12
3400dac2:	46bd      	mov	sp, r7
3400dac4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dac8:	4770      	bx	lr
3400daca:	bf00      	nop
3400dacc:	56028000 	.word	0x56028000

3400dad0 <LL_RCC_GetSPIClockSource>:
{
3400dad0:	b580      	push	{r7, lr}
3400dad2:	b082      	sub	sp, #8
3400dad4:	af00      	add	r7, sp, #0
3400dad6:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400dad8:	6878      	ldr	r0, [r7, #4]
3400dada:	f7ff fead 	bl	3400d838 <LL_RCC_GetClockSource>
3400dade:	4603      	mov	r3, r0
}
3400dae0:	4618      	mov	r0, r3
3400dae2:	3708      	adds	r7, #8
3400dae4:	46bd      	mov	sp, r7
3400dae6:	bd80      	pop	{r7, pc}

3400dae8 <LL_RCC_GetUSARTClockSource>:
{
3400dae8:	b580      	push	{r7, lr}
3400daea:	b082      	sub	sp, #8
3400daec:	af00      	add	r7, sp, #0
3400daee:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400daf0:	6878      	ldr	r0, [r7, #4]
3400daf2:	f7ff fea1 	bl	3400d838 <LL_RCC_GetClockSource>
3400daf6:	4603      	mov	r3, r0
}
3400daf8:	4618      	mov	r0, r3
3400dafa:	3708      	adds	r7, #8
3400dafc:	46bd      	mov	sp, r7
3400dafe:	bd80      	pop	{r7, pc}

3400db00 <LL_RCC_GetUARTClockSource>:
{
3400db00:	b580      	push	{r7, lr}
3400db02:	b082      	sub	sp, #8
3400db04:	af00      	add	r7, sp, #0
3400db06:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400db08:	6878      	ldr	r0, [r7, #4]
3400db0a:	f7ff fe95 	bl	3400d838 <LL_RCC_GetClockSource>
3400db0e:	4603      	mov	r3, r0
}
3400db10:	4618      	mov	r0, r3
3400db12:	3708      	adds	r7, #8
3400db14:	46bd      	mov	sp, r7
3400db16:	bd80      	pop	{r7, pc}

3400db18 <LL_RCC_GetUSBClockSource>:
{
3400db18:	b580      	push	{r7, lr}
3400db1a:	b082      	sub	sp, #8
3400db1c:	af00      	add	r7, sp, #0
3400db1e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400db20:	6878      	ldr	r0, [r7, #4]
3400db22:	f7ff fe89 	bl	3400d838 <LL_RCC_GetClockSource>
3400db26:	4603      	mov	r3, r0
}
3400db28:	4618      	mov	r0, r3
3400db2a:	3708      	adds	r7, #8
3400db2c:	46bd      	mov	sp, r7
3400db2e:	bd80      	pop	{r7, pc}

3400db30 <LL_RCC_GetXSPIClockSource>:
{
3400db30:	b580      	push	{r7, lr}
3400db32:	b082      	sub	sp, #8
3400db34:	af00      	add	r7, sp, #0
3400db36:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400db38:	6878      	ldr	r0, [r7, #4]
3400db3a:	f7ff fe7d 	bl	3400d838 <LL_RCC_GetClockSource>
3400db3e:	4603      	mov	r3, r0
}
3400db40:	4618      	mov	r0, r3
3400db42:	3708      	adds	r7, #8
3400db44:	46bd      	mov	sp, r7
3400db46:	bd80      	pop	{r7, pc}

3400db48 <LL_RCC_SetRTCClockSource>:
{
3400db48:	b480      	push	{r7}
3400db4a:	b083      	sub	sp, #12
3400db4c:	af00      	add	r7, sp, #0
3400db4e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400db50:	4b07      	ldr	r3, [pc, #28]	@ (3400db70 <LL_RCC_SetRTCClockSource+0x28>)
3400db52:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400db56:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
3400db5a:	4905      	ldr	r1, [pc, #20]	@ (3400db70 <LL_RCC_SetRTCClockSource+0x28>)
3400db5c:	687b      	ldr	r3, [r7, #4]
3400db5e:	4313      	orrs	r3, r2
3400db60:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400db64:	bf00      	nop
3400db66:	370c      	adds	r7, #12
3400db68:	46bd      	mov	sp, r7
3400db6a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400db6e:	4770      	bx	lr
3400db70:	56028000 	.word	0x56028000

3400db74 <LL_RCC_GetRTCClockSource>:
{
3400db74:	b480      	push	{r7}
3400db76:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400db78:	4b04      	ldr	r3, [pc, #16]	@ (3400db8c <LL_RCC_GetRTCClockSource+0x18>)
3400db7a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400db7e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
3400db82:	4618      	mov	r0, r3
3400db84:	46bd      	mov	sp, r7
3400db86:	f85d 7b04 	ldr.w	r7, [sp], #4
3400db8a:	4770      	bx	lr
3400db8c:	56028000 	.word	0x56028000

3400db90 <LL_RCC_SetRTC_HSEPrescaler>:
{
3400db90:	b480      	push	{r7}
3400db92:	b083      	sub	sp, #12
3400db94:	af00      	add	r7, sp, #0
3400db96:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3400db98:	4b07      	ldr	r3, [pc, #28]	@ (3400dbb8 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3400db9a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400db9e:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
3400dba2:	4905      	ldr	r1, [pc, #20]	@ (3400dbb8 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3400dba4:	687b      	ldr	r3, [r7, #4]
3400dba6:	4313      	orrs	r3, r2
3400dba8:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400dbac:	bf00      	nop
3400dbae:	370c      	adds	r7, #12
3400dbb0:	46bd      	mov	sp, r7
3400dbb2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dbb6:	4770      	bx	lr
3400dbb8:	56028000 	.word	0x56028000

3400dbbc <LL_RCC_SetTIMPrescaler>:
{
3400dbbc:	b480      	push	{r7}
3400dbbe:	b083      	sub	sp, #12
3400dbc0:	af00      	add	r7, sp, #0
3400dbc2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400dbc4:	4b07      	ldr	r3, [pc, #28]	@ (3400dbe4 <LL_RCC_SetTIMPrescaler+0x28>)
3400dbc6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400dbc8:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3400dbcc:	687b      	ldr	r3, [r7, #4]
3400dbce:	061b      	lsls	r3, r3, #24
3400dbd0:	4904      	ldr	r1, [pc, #16]	@ (3400dbe4 <LL_RCC_SetTIMPrescaler+0x28>)
3400dbd2:	4313      	orrs	r3, r2
3400dbd4:	624b      	str	r3, [r1, #36]	@ 0x24
}
3400dbd6:	bf00      	nop
3400dbd8:	370c      	adds	r7, #12
3400dbda:	46bd      	mov	sp, r7
3400dbdc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dbe0:	4770      	bx	lr
3400dbe2:	bf00      	nop
3400dbe4:	56028000 	.word	0x56028000

3400dbe8 <LL_RCC_GetTIMPrescaler>:
{
3400dbe8:	b480      	push	{r7}
3400dbea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400dbec:	4b04      	ldr	r3, [pc, #16]	@ (3400dc00 <LL_RCC_GetTIMPrescaler+0x18>)
3400dbee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400dbf0:	0e1b      	lsrs	r3, r3, #24
3400dbf2:	f003 0303 	and.w	r3, r3, #3
}
3400dbf6:	4618      	mov	r0, r3
3400dbf8:	46bd      	mov	sp, r7
3400dbfa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dbfe:	4770      	bx	lr
3400dc00:	56028000 	.word	0x56028000

3400dc04 <LL_RCC_PLL1_GetSource>:
{
3400dc04:	b480      	push	{r7}
3400dc06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400dc08:	4b04      	ldr	r3, [pc, #16]	@ (3400dc1c <LL_RCC_PLL1_GetSource+0x18>)
3400dc0a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400dc0e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dc12:	4618      	mov	r0, r3
3400dc14:	46bd      	mov	sp, r7
3400dc16:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc1a:	4770      	bx	lr
3400dc1c:	56028000 	.word	0x56028000

3400dc20 <LL_RCC_PLL1_IsReady>:
{
3400dc20:	b480      	push	{r7}
3400dc22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400dc24:	4b07      	ldr	r3, [pc, #28]	@ (3400dc44 <LL_RCC_PLL1_IsReady+0x24>)
3400dc26:	685b      	ldr	r3, [r3, #4]
3400dc28:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400dc2c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400dc30:	d101      	bne.n	3400dc36 <LL_RCC_PLL1_IsReady+0x16>
3400dc32:	2301      	movs	r3, #1
3400dc34:	e000      	b.n	3400dc38 <LL_RCC_PLL1_IsReady+0x18>
3400dc36:	2300      	movs	r3, #0
}
3400dc38:	4618      	mov	r0, r3
3400dc3a:	46bd      	mov	sp, r7
3400dc3c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc40:	4770      	bx	lr
3400dc42:	bf00      	nop
3400dc44:	56028000 	.word	0x56028000

3400dc48 <LL_RCC_PLL1_IsEnabledBypass>:
{
3400dc48:	b480      	push	{r7}
3400dc4a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400dc4c:	4b07      	ldr	r3, [pc, #28]	@ (3400dc6c <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3400dc4e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400dc52:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400dc56:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400dc5a:	d101      	bne.n	3400dc60 <LL_RCC_PLL1_IsEnabledBypass+0x18>
3400dc5c:	2301      	movs	r3, #1
3400dc5e:	e000      	b.n	3400dc62 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3400dc60:	2300      	movs	r3, #0
}
3400dc62:	4618      	mov	r0, r3
3400dc64:	46bd      	mov	sp, r7
3400dc66:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc6a:	4770      	bx	lr
3400dc6c:	56028000 	.word	0x56028000

3400dc70 <LL_RCC_PLL1_GetN>:
{
3400dc70:	b480      	push	{r7}
3400dc72:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3400dc74:	4b05      	ldr	r3, [pc, #20]	@ (3400dc8c <LL_RCC_PLL1_GetN+0x1c>)
3400dc76:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400dc7a:	0a1b      	lsrs	r3, r3, #8
3400dc7c:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400dc80:	4618      	mov	r0, r3
3400dc82:	46bd      	mov	sp, r7
3400dc84:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc88:	4770      	bx	lr
3400dc8a:	bf00      	nop
3400dc8c:	56028000 	.word	0x56028000

3400dc90 <LL_RCC_PLL1_GetM>:
{
3400dc90:	b480      	push	{r7}
3400dc92:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3400dc94:	4b05      	ldr	r3, [pc, #20]	@ (3400dcac <LL_RCC_PLL1_GetM+0x1c>)
3400dc96:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400dc9a:	0d1b      	lsrs	r3, r3, #20
3400dc9c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400dca0:	4618      	mov	r0, r3
3400dca2:	46bd      	mov	sp, r7
3400dca4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dca8:	4770      	bx	lr
3400dcaa:	bf00      	nop
3400dcac:	56028000 	.word	0x56028000

3400dcb0 <LL_RCC_PLL1_GetP1>:
{
3400dcb0:	b480      	push	{r7}
3400dcb2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400dcb4:	4b05      	ldr	r3, [pc, #20]	@ (3400dccc <LL_RCC_PLL1_GetP1+0x1c>)
3400dcb6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400dcba:	0edb      	lsrs	r3, r3, #27
3400dcbc:	f003 0307 	and.w	r3, r3, #7
}
3400dcc0:	4618      	mov	r0, r3
3400dcc2:	46bd      	mov	sp, r7
3400dcc4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dcc8:	4770      	bx	lr
3400dcca:	bf00      	nop
3400dccc:	56028000 	.word	0x56028000

3400dcd0 <LL_RCC_PLL1_GetP2>:
{
3400dcd0:	b480      	push	{r7}
3400dcd2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400dcd4:	4b05      	ldr	r3, [pc, #20]	@ (3400dcec <LL_RCC_PLL1_GetP2+0x1c>)
3400dcd6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400dcda:	0e1b      	lsrs	r3, r3, #24
3400dcdc:	f003 0307 	and.w	r3, r3, #7
}
3400dce0:	4618      	mov	r0, r3
3400dce2:	46bd      	mov	sp, r7
3400dce4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dce8:	4770      	bx	lr
3400dcea:	bf00      	nop
3400dcec:	56028000 	.word	0x56028000

3400dcf0 <LL_RCC_PLL1P_IsEnabled>:
{
3400dcf0:	b480      	push	{r7}
3400dcf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3400dcf4:	4b07      	ldr	r3, [pc, #28]	@ (3400dd14 <LL_RCC_PLL1P_IsEnabled+0x24>)
3400dcf6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400dcfa:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400dcfe:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400dd02:	d101      	bne.n	3400dd08 <LL_RCC_PLL1P_IsEnabled+0x18>
3400dd04:	2301      	movs	r3, #1
3400dd06:	e000      	b.n	3400dd0a <LL_RCC_PLL1P_IsEnabled+0x1a>
3400dd08:	2300      	movs	r3, #0
}
3400dd0a:	4618      	mov	r0, r3
3400dd0c:	46bd      	mov	sp, r7
3400dd0e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd12:	4770      	bx	lr
3400dd14:	56028000 	.word	0x56028000

3400dd18 <LL_RCC_PLL1_GetFRACN>:
{
3400dd18:	b480      	push	{r7}
3400dd1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3400dd1c:	4b04      	ldr	r3, [pc, #16]	@ (3400dd30 <LL_RCC_PLL1_GetFRACN+0x18>)
3400dd1e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400dd22:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400dd26:	4618      	mov	r0, r3
3400dd28:	46bd      	mov	sp, r7
3400dd2a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd2e:	4770      	bx	lr
3400dd30:	56028000 	.word	0x56028000

3400dd34 <LL_RCC_PLL2_GetSource>:
{
3400dd34:	b480      	push	{r7}
3400dd36:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400dd38:	4b04      	ldr	r3, [pc, #16]	@ (3400dd4c <LL_RCC_PLL2_GetSource+0x18>)
3400dd3a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400dd3e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dd42:	4618      	mov	r0, r3
3400dd44:	46bd      	mov	sp, r7
3400dd46:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd4a:	4770      	bx	lr
3400dd4c:	56028000 	.word	0x56028000

3400dd50 <LL_RCC_PLL2_IsReady>:
{
3400dd50:	b480      	push	{r7}
3400dd52:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400dd54:	4b07      	ldr	r3, [pc, #28]	@ (3400dd74 <LL_RCC_PLL2_IsReady+0x24>)
3400dd56:	685b      	ldr	r3, [r3, #4]
3400dd58:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400dd5c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400dd60:	d101      	bne.n	3400dd66 <LL_RCC_PLL2_IsReady+0x16>
3400dd62:	2301      	movs	r3, #1
3400dd64:	e000      	b.n	3400dd68 <LL_RCC_PLL2_IsReady+0x18>
3400dd66:	2300      	movs	r3, #0
}
3400dd68:	4618      	mov	r0, r3
3400dd6a:	46bd      	mov	sp, r7
3400dd6c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd70:	4770      	bx	lr
3400dd72:	bf00      	nop
3400dd74:	56028000 	.word	0x56028000

3400dd78 <LL_RCC_PLL2_IsEnabledBypass>:
{
3400dd78:	b480      	push	{r7}
3400dd7a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400dd7c:	4b07      	ldr	r3, [pc, #28]	@ (3400dd9c <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3400dd7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400dd82:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400dd86:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400dd8a:	d101      	bne.n	3400dd90 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3400dd8c:	2301      	movs	r3, #1
3400dd8e:	e000      	b.n	3400dd92 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3400dd90:	2300      	movs	r3, #0
}
3400dd92:	4618      	mov	r0, r3
3400dd94:	46bd      	mov	sp, r7
3400dd96:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd9a:	4770      	bx	lr
3400dd9c:	56028000 	.word	0x56028000

3400dda0 <LL_RCC_PLL2_GetN>:
{
3400dda0:	b480      	push	{r7}
3400dda2:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3400dda4:	4b05      	ldr	r3, [pc, #20]	@ (3400ddbc <LL_RCC_PLL2_GetN+0x1c>)
3400dda6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400ddaa:	0a1b      	lsrs	r3, r3, #8
3400ddac:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400ddb0:	4618      	mov	r0, r3
3400ddb2:	46bd      	mov	sp, r7
3400ddb4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ddb8:	4770      	bx	lr
3400ddba:	bf00      	nop
3400ddbc:	56028000 	.word	0x56028000

3400ddc0 <LL_RCC_PLL2_GetM>:
{
3400ddc0:	b480      	push	{r7}
3400ddc2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3400ddc4:	4b05      	ldr	r3, [pc, #20]	@ (3400dddc <LL_RCC_PLL2_GetM+0x1c>)
3400ddc6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400ddca:	0d1b      	lsrs	r3, r3, #20
3400ddcc:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400ddd0:	4618      	mov	r0, r3
3400ddd2:	46bd      	mov	sp, r7
3400ddd4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ddd8:	4770      	bx	lr
3400ddda:	bf00      	nop
3400dddc:	56028000 	.word	0x56028000

3400dde0 <LL_RCC_PLL2_GetP1>:
{
3400dde0:	b480      	push	{r7}
3400dde2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400dde4:	4b05      	ldr	r3, [pc, #20]	@ (3400ddfc <LL_RCC_PLL2_GetP1+0x1c>)
3400dde6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400ddea:	0edb      	lsrs	r3, r3, #27
3400ddec:	f003 0307 	and.w	r3, r3, #7
}
3400ddf0:	4618      	mov	r0, r3
3400ddf2:	46bd      	mov	sp, r7
3400ddf4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ddf8:	4770      	bx	lr
3400ddfa:	bf00      	nop
3400ddfc:	56028000 	.word	0x56028000

3400de00 <LL_RCC_PLL2_GetP2>:
{
3400de00:	b480      	push	{r7}
3400de02:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400de04:	4b05      	ldr	r3, [pc, #20]	@ (3400de1c <LL_RCC_PLL2_GetP2+0x1c>)
3400de06:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400de0a:	0e1b      	lsrs	r3, r3, #24
3400de0c:	f003 0307 	and.w	r3, r3, #7
}
3400de10:	4618      	mov	r0, r3
3400de12:	46bd      	mov	sp, r7
3400de14:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de18:	4770      	bx	lr
3400de1a:	bf00      	nop
3400de1c:	56028000 	.word	0x56028000

3400de20 <LL_RCC_PLL2P_IsEnabled>:
{
3400de20:	b480      	push	{r7}
3400de22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3400de24:	4b07      	ldr	r3, [pc, #28]	@ (3400de44 <LL_RCC_PLL2P_IsEnabled+0x24>)
3400de26:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400de2a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400de2e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400de32:	d101      	bne.n	3400de38 <LL_RCC_PLL2P_IsEnabled+0x18>
3400de34:	2301      	movs	r3, #1
3400de36:	e000      	b.n	3400de3a <LL_RCC_PLL2P_IsEnabled+0x1a>
3400de38:	2300      	movs	r3, #0
}
3400de3a:	4618      	mov	r0, r3
3400de3c:	46bd      	mov	sp, r7
3400de3e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de42:	4770      	bx	lr
3400de44:	56028000 	.word	0x56028000

3400de48 <LL_RCC_PLL2_GetFRACN>:
{
3400de48:	b480      	push	{r7}
3400de4a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3400de4c:	4b04      	ldr	r3, [pc, #16]	@ (3400de60 <LL_RCC_PLL2_GetFRACN+0x18>)
3400de4e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400de52:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400de56:	4618      	mov	r0, r3
3400de58:	46bd      	mov	sp, r7
3400de5a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de5e:	4770      	bx	lr
3400de60:	56028000 	.word	0x56028000

3400de64 <LL_RCC_PLL3_GetSource>:
{
3400de64:	b480      	push	{r7}
3400de66:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400de68:	4b04      	ldr	r3, [pc, #16]	@ (3400de7c <LL_RCC_PLL3_GetSource+0x18>)
3400de6a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400de6e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400de72:	4618      	mov	r0, r3
3400de74:	46bd      	mov	sp, r7
3400de76:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de7a:	4770      	bx	lr
3400de7c:	56028000 	.word	0x56028000

3400de80 <LL_RCC_PLL3_IsReady>:
{
3400de80:	b480      	push	{r7}
3400de82:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400de84:	4b07      	ldr	r3, [pc, #28]	@ (3400dea4 <LL_RCC_PLL3_IsReady+0x24>)
3400de86:	685b      	ldr	r3, [r3, #4]
3400de88:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400de8c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400de90:	d101      	bne.n	3400de96 <LL_RCC_PLL3_IsReady+0x16>
3400de92:	2301      	movs	r3, #1
3400de94:	e000      	b.n	3400de98 <LL_RCC_PLL3_IsReady+0x18>
3400de96:	2300      	movs	r3, #0
}
3400de98:	4618      	mov	r0, r3
3400de9a:	46bd      	mov	sp, r7
3400de9c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dea0:	4770      	bx	lr
3400dea2:	bf00      	nop
3400dea4:	56028000 	.word	0x56028000

3400dea8 <LL_RCC_PLL3_IsEnabledBypass>:
{
3400dea8:	b480      	push	{r7}
3400deaa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400deac:	4b07      	ldr	r3, [pc, #28]	@ (3400decc <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3400deae:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400deb2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400deb6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400deba:	d101      	bne.n	3400dec0 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3400debc:	2301      	movs	r3, #1
3400debe:	e000      	b.n	3400dec2 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3400dec0:	2300      	movs	r3, #0
}
3400dec2:	4618      	mov	r0, r3
3400dec4:	46bd      	mov	sp, r7
3400dec6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400deca:	4770      	bx	lr
3400decc:	56028000 	.word	0x56028000

3400ded0 <LL_RCC_PLL3_GetN>:
{
3400ded0:	b480      	push	{r7}
3400ded2:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3400ded4:	4b05      	ldr	r3, [pc, #20]	@ (3400deec <LL_RCC_PLL3_GetN+0x1c>)
3400ded6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400deda:	0a1b      	lsrs	r3, r3, #8
3400dedc:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400dee0:	4618      	mov	r0, r3
3400dee2:	46bd      	mov	sp, r7
3400dee4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dee8:	4770      	bx	lr
3400deea:	bf00      	nop
3400deec:	56028000 	.word	0x56028000

3400def0 <LL_RCC_PLL3_GetM>:
{
3400def0:	b480      	push	{r7}
3400def2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3400def4:	4b05      	ldr	r3, [pc, #20]	@ (3400df0c <LL_RCC_PLL3_GetM+0x1c>)
3400def6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400defa:	0d1b      	lsrs	r3, r3, #20
3400defc:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400df00:	4618      	mov	r0, r3
3400df02:	46bd      	mov	sp, r7
3400df04:	f85d 7b04 	ldr.w	r7, [sp], #4
3400df08:	4770      	bx	lr
3400df0a:	bf00      	nop
3400df0c:	56028000 	.word	0x56028000

3400df10 <LL_RCC_PLL3_GetP1>:
{
3400df10:	b480      	push	{r7}
3400df12:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400df14:	4b05      	ldr	r3, [pc, #20]	@ (3400df2c <LL_RCC_PLL3_GetP1+0x1c>)
3400df16:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400df1a:	0edb      	lsrs	r3, r3, #27
3400df1c:	f003 0307 	and.w	r3, r3, #7
}
3400df20:	4618      	mov	r0, r3
3400df22:	46bd      	mov	sp, r7
3400df24:	f85d 7b04 	ldr.w	r7, [sp], #4
3400df28:	4770      	bx	lr
3400df2a:	bf00      	nop
3400df2c:	56028000 	.word	0x56028000

3400df30 <LL_RCC_PLL3_GetP2>:
{
3400df30:	b480      	push	{r7}
3400df32:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400df34:	4b05      	ldr	r3, [pc, #20]	@ (3400df4c <LL_RCC_PLL3_GetP2+0x1c>)
3400df36:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400df3a:	0e1b      	lsrs	r3, r3, #24
3400df3c:	f003 0307 	and.w	r3, r3, #7
}
3400df40:	4618      	mov	r0, r3
3400df42:	46bd      	mov	sp, r7
3400df44:	f85d 7b04 	ldr.w	r7, [sp], #4
3400df48:	4770      	bx	lr
3400df4a:	bf00      	nop
3400df4c:	56028000 	.word	0x56028000

3400df50 <LL_RCC_PLL3P_IsEnabled>:
{
3400df50:	b480      	push	{r7}
3400df52:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3400df54:	4b07      	ldr	r3, [pc, #28]	@ (3400df74 <LL_RCC_PLL3P_IsEnabled+0x24>)
3400df56:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400df5a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400df5e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400df62:	d101      	bne.n	3400df68 <LL_RCC_PLL3P_IsEnabled+0x18>
3400df64:	2301      	movs	r3, #1
3400df66:	e000      	b.n	3400df6a <LL_RCC_PLL3P_IsEnabled+0x1a>
3400df68:	2300      	movs	r3, #0
}
3400df6a:	4618      	mov	r0, r3
3400df6c:	46bd      	mov	sp, r7
3400df6e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400df72:	4770      	bx	lr
3400df74:	56028000 	.word	0x56028000

3400df78 <LL_RCC_PLL3_GetFRACN>:
{
3400df78:	b480      	push	{r7}
3400df7a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3400df7c:	4b04      	ldr	r3, [pc, #16]	@ (3400df90 <LL_RCC_PLL3_GetFRACN+0x18>)
3400df7e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400df82:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400df86:	4618      	mov	r0, r3
3400df88:	46bd      	mov	sp, r7
3400df8a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400df8e:	4770      	bx	lr
3400df90:	56028000 	.word	0x56028000

3400df94 <LL_RCC_PLL4_GetSource>:
{
3400df94:	b480      	push	{r7}
3400df96:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3400df98:	4b04      	ldr	r3, [pc, #16]	@ (3400dfac <LL_RCC_PLL4_GetSource+0x18>)
3400df9a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400df9e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dfa2:	4618      	mov	r0, r3
3400dfa4:	46bd      	mov	sp, r7
3400dfa6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dfaa:	4770      	bx	lr
3400dfac:	56028000 	.word	0x56028000

3400dfb0 <LL_RCC_PLL4_IsReady>:
{
3400dfb0:	b480      	push	{r7}
3400dfb2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400dfb4:	4b07      	ldr	r3, [pc, #28]	@ (3400dfd4 <LL_RCC_PLL4_IsReady+0x24>)
3400dfb6:	685b      	ldr	r3, [r3, #4]
3400dfb8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400dfbc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400dfc0:	d101      	bne.n	3400dfc6 <LL_RCC_PLL4_IsReady+0x16>
3400dfc2:	2301      	movs	r3, #1
3400dfc4:	e000      	b.n	3400dfc8 <LL_RCC_PLL4_IsReady+0x18>
3400dfc6:	2300      	movs	r3, #0
}
3400dfc8:	4618      	mov	r0, r3
3400dfca:	46bd      	mov	sp, r7
3400dfcc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dfd0:	4770      	bx	lr
3400dfd2:	bf00      	nop
3400dfd4:	56028000 	.word	0x56028000

3400dfd8 <LL_RCC_PLL4_IsEnabledBypass>:
{
3400dfd8:	b480      	push	{r7}
3400dfda:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400dfdc:	4b07      	ldr	r3, [pc, #28]	@ (3400dffc <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3400dfde:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400dfe2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400dfe6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400dfea:	d101      	bne.n	3400dff0 <LL_RCC_PLL4_IsEnabledBypass+0x18>
3400dfec:	2301      	movs	r3, #1
3400dfee:	e000      	b.n	3400dff2 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3400dff0:	2300      	movs	r3, #0
}
3400dff2:	4618      	mov	r0, r3
3400dff4:	46bd      	mov	sp, r7
3400dff6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dffa:	4770      	bx	lr
3400dffc:	56028000 	.word	0x56028000

3400e000 <LL_RCC_PLL4_GetN>:
{
3400e000:	b480      	push	{r7}
3400e002:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3400e004:	4b05      	ldr	r3, [pc, #20]	@ (3400e01c <LL_RCC_PLL4_GetN+0x1c>)
3400e006:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400e00a:	0a1b      	lsrs	r3, r3, #8
3400e00c:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400e010:	4618      	mov	r0, r3
3400e012:	46bd      	mov	sp, r7
3400e014:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e018:	4770      	bx	lr
3400e01a:	bf00      	nop
3400e01c:	56028000 	.word	0x56028000

3400e020 <LL_RCC_PLL4_GetM>:
{
3400e020:	b480      	push	{r7}
3400e022:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3400e024:	4b05      	ldr	r3, [pc, #20]	@ (3400e03c <LL_RCC_PLL4_GetM+0x1c>)
3400e026:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400e02a:	0d1b      	lsrs	r3, r3, #20
3400e02c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400e030:	4618      	mov	r0, r3
3400e032:	46bd      	mov	sp, r7
3400e034:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e038:	4770      	bx	lr
3400e03a:	bf00      	nop
3400e03c:	56028000 	.word	0x56028000

3400e040 <LL_RCC_PLL4_GetP1>:
{
3400e040:	b480      	push	{r7}
3400e042:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400e044:	4b05      	ldr	r3, [pc, #20]	@ (3400e05c <LL_RCC_PLL4_GetP1+0x1c>)
3400e046:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400e04a:	0edb      	lsrs	r3, r3, #27
3400e04c:	f003 0307 	and.w	r3, r3, #7
}
3400e050:	4618      	mov	r0, r3
3400e052:	46bd      	mov	sp, r7
3400e054:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e058:	4770      	bx	lr
3400e05a:	bf00      	nop
3400e05c:	56028000 	.word	0x56028000

3400e060 <LL_RCC_PLL4_GetP2>:
{
3400e060:	b480      	push	{r7}
3400e062:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400e064:	4b05      	ldr	r3, [pc, #20]	@ (3400e07c <LL_RCC_PLL4_GetP2+0x1c>)
3400e066:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400e06a:	0e1b      	lsrs	r3, r3, #24
3400e06c:	f003 0307 	and.w	r3, r3, #7
}
3400e070:	4618      	mov	r0, r3
3400e072:	46bd      	mov	sp, r7
3400e074:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e078:	4770      	bx	lr
3400e07a:	bf00      	nop
3400e07c:	56028000 	.word	0x56028000

3400e080 <LL_RCC_PLL4P_IsEnabled>:
{
3400e080:	b480      	push	{r7}
3400e082:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3400e084:	4b07      	ldr	r3, [pc, #28]	@ (3400e0a4 <LL_RCC_PLL4P_IsEnabled+0x24>)
3400e086:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400e08a:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400e08e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400e092:	d101      	bne.n	3400e098 <LL_RCC_PLL4P_IsEnabled+0x18>
3400e094:	2301      	movs	r3, #1
3400e096:	e000      	b.n	3400e09a <LL_RCC_PLL4P_IsEnabled+0x1a>
3400e098:	2300      	movs	r3, #0
}
3400e09a:	4618      	mov	r0, r3
3400e09c:	46bd      	mov	sp, r7
3400e09e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e0a2:	4770      	bx	lr
3400e0a4:	56028000 	.word	0x56028000

3400e0a8 <LL_RCC_PLL4_GetFRACN>:
{
3400e0a8:	b480      	push	{r7}
3400e0aa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3400e0ac:	4b04      	ldr	r3, [pc, #16]	@ (3400e0c0 <LL_RCC_PLL4_GetFRACN+0x18>)
3400e0ae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400e0b2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400e0b6:	4618      	mov	r0, r3
3400e0b8:	46bd      	mov	sp, r7
3400e0ba:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e0be:	4770      	bx	lr
3400e0c0:	56028000 	.word	0x56028000

3400e0c4 <LL_RCC_IC3_Enable>:
{
3400e0c4:	b480      	push	{r7}
3400e0c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400e0c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e0dc <LL_RCC_IC3_Enable+0x18>)
3400e0ca:	2204      	movs	r2, #4
3400e0cc:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e0d0:	bf00      	nop
3400e0d2:	46bd      	mov	sp, r7
3400e0d4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e0d8:	4770      	bx	lr
3400e0da:	bf00      	nop
3400e0dc:	56028000 	.word	0x56028000

3400e0e0 <LL_RCC_IC3_IsEnabled>:
{
3400e0e0:	b480      	push	{r7}
3400e0e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400e0e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e104 <LL_RCC_IC3_IsEnabled+0x24>)
3400e0e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e0ea:	f003 0304 	and.w	r3, r3, #4
3400e0ee:	2b04      	cmp	r3, #4
3400e0f0:	d101      	bne.n	3400e0f6 <LL_RCC_IC3_IsEnabled+0x16>
3400e0f2:	2301      	movs	r3, #1
3400e0f4:	e000      	b.n	3400e0f8 <LL_RCC_IC3_IsEnabled+0x18>
3400e0f6:	2300      	movs	r3, #0
}
3400e0f8:	4618      	mov	r0, r3
3400e0fa:	46bd      	mov	sp, r7
3400e0fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e100:	4770      	bx	lr
3400e102:	bf00      	nop
3400e104:	56028000 	.word	0x56028000

3400e108 <LL_RCC_IC3_GetSource>:
{
3400e108:	b480      	push	{r7}
3400e10a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400e10c:	4b04      	ldr	r3, [pc, #16]	@ (3400e120 <LL_RCC_IC3_GetSource+0x18>)
3400e10e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400e112:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e116:	4618      	mov	r0, r3
3400e118:	46bd      	mov	sp, r7
3400e11a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e11e:	4770      	bx	lr
3400e120:	56028000 	.word	0x56028000

3400e124 <LL_RCC_IC3_GetDivider>:
{
3400e124:	b480      	push	{r7}
3400e126:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400e128:	4b05      	ldr	r3, [pc, #20]	@ (3400e140 <LL_RCC_IC3_GetDivider+0x1c>)
3400e12a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400e12e:	0c1b      	lsrs	r3, r3, #16
3400e130:	b2db      	uxtb	r3, r3
3400e132:	3301      	adds	r3, #1
}
3400e134:	4618      	mov	r0, r3
3400e136:	46bd      	mov	sp, r7
3400e138:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e13c:	4770      	bx	lr
3400e13e:	bf00      	nop
3400e140:	56028000 	.word	0x56028000

3400e144 <LL_RCC_IC4_Enable>:
{
3400e144:	b480      	push	{r7}
3400e146:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400e148:	4b04      	ldr	r3, [pc, #16]	@ (3400e15c <LL_RCC_IC4_Enable+0x18>)
3400e14a:	2208      	movs	r2, #8
3400e14c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e150:	bf00      	nop
3400e152:	46bd      	mov	sp, r7
3400e154:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e158:	4770      	bx	lr
3400e15a:	bf00      	nop
3400e15c:	56028000 	.word	0x56028000

3400e160 <LL_RCC_IC4_IsEnabled>:
{
3400e160:	b480      	push	{r7}
3400e162:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400e164:	4b07      	ldr	r3, [pc, #28]	@ (3400e184 <LL_RCC_IC4_IsEnabled+0x24>)
3400e166:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e16a:	f003 0308 	and.w	r3, r3, #8
3400e16e:	2b08      	cmp	r3, #8
3400e170:	d101      	bne.n	3400e176 <LL_RCC_IC4_IsEnabled+0x16>
3400e172:	2301      	movs	r3, #1
3400e174:	e000      	b.n	3400e178 <LL_RCC_IC4_IsEnabled+0x18>
3400e176:	2300      	movs	r3, #0
}
3400e178:	4618      	mov	r0, r3
3400e17a:	46bd      	mov	sp, r7
3400e17c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e180:	4770      	bx	lr
3400e182:	bf00      	nop
3400e184:	56028000 	.word	0x56028000

3400e188 <LL_RCC_IC4_GetSource>:
{
3400e188:	b480      	push	{r7}
3400e18a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400e18c:	4b04      	ldr	r3, [pc, #16]	@ (3400e1a0 <LL_RCC_IC4_GetSource+0x18>)
3400e18e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400e192:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e196:	4618      	mov	r0, r3
3400e198:	46bd      	mov	sp, r7
3400e19a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e19e:	4770      	bx	lr
3400e1a0:	56028000 	.word	0x56028000

3400e1a4 <LL_RCC_IC4_GetDivider>:
{
3400e1a4:	b480      	push	{r7}
3400e1a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e1a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e1c0 <LL_RCC_IC4_GetDivider+0x1c>)
3400e1aa:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400e1ae:	0c1b      	lsrs	r3, r3, #16
3400e1b0:	b2db      	uxtb	r3, r3
3400e1b2:	3301      	adds	r3, #1
}
3400e1b4:	4618      	mov	r0, r3
3400e1b6:	46bd      	mov	sp, r7
3400e1b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e1bc:	4770      	bx	lr
3400e1be:	bf00      	nop
3400e1c0:	56028000 	.word	0x56028000

3400e1c4 <LL_RCC_IC5_Enable>:
{
3400e1c4:	b480      	push	{r7}
3400e1c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400e1c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e1dc <LL_RCC_IC5_Enable+0x18>)
3400e1ca:	2210      	movs	r2, #16
3400e1cc:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e1d0:	bf00      	nop
3400e1d2:	46bd      	mov	sp, r7
3400e1d4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e1d8:	4770      	bx	lr
3400e1da:	bf00      	nop
3400e1dc:	56028000 	.word	0x56028000

3400e1e0 <LL_RCC_IC5_IsEnabled>:
{
3400e1e0:	b480      	push	{r7}
3400e1e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400e1e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e204 <LL_RCC_IC5_IsEnabled+0x24>)
3400e1e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e1ea:	f003 0310 	and.w	r3, r3, #16
3400e1ee:	2b10      	cmp	r3, #16
3400e1f0:	d101      	bne.n	3400e1f6 <LL_RCC_IC5_IsEnabled+0x16>
3400e1f2:	2301      	movs	r3, #1
3400e1f4:	e000      	b.n	3400e1f8 <LL_RCC_IC5_IsEnabled+0x18>
3400e1f6:	2300      	movs	r3, #0
}
3400e1f8:	4618      	mov	r0, r3
3400e1fa:	46bd      	mov	sp, r7
3400e1fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e200:	4770      	bx	lr
3400e202:	bf00      	nop
3400e204:	56028000 	.word	0x56028000

3400e208 <LL_RCC_IC5_GetSource>:
{
3400e208:	b480      	push	{r7}
3400e20a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e20c:	4b04      	ldr	r3, [pc, #16]	@ (3400e220 <LL_RCC_IC5_GetSource+0x18>)
3400e20e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400e212:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e216:	4618      	mov	r0, r3
3400e218:	46bd      	mov	sp, r7
3400e21a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e21e:	4770      	bx	lr
3400e220:	56028000 	.word	0x56028000

3400e224 <LL_RCC_IC5_GetDivider>:
{
3400e224:	b480      	push	{r7}
3400e226:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400e228:	4b05      	ldr	r3, [pc, #20]	@ (3400e240 <LL_RCC_IC5_GetDivider+0x1c>)
3400e22a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400e22e:	0c1b      	lsrs	r3, r3, #16
3400e230:	b2db      	uxtb	r3, r3
3400e232:	3301      	adds	r3, #1
}
3400e234:	4618      	mov	r0, r3
3400e236:	46bd      	mov	sp, r7
3400e238:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e23c:	4770      	bx	lr
3400e23e:	bf00      	nop
3400e240:	56028000 	.word	0x56028000

3400e244 <LL_RCC_IC7_Enable>:
{
3400e244:	b480      	push	{r7}
3400e246:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400e248:	4b04      	ldr	r3, [pc, #16]	@ (3400e25c <LL_RCC_IC7_Enable+0x18>)
3400e24a:	2240      	movs	r2, #64	@ 0x40
3400e24c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e250:	bf00      	nop
3400e252:	46bd      	mov	sp, r7
3400e254:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e258:	4770      	bx	lr
3400e25a:	bf00      	nop
3400e25c:	56028000 	.word	0x56028000

3400e260 <LL_RCC_IC7_IsEnabled>:
{
3400e260:	b480      	push	{r7}
3400e262:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3400e264:	4b07      	ldr	r3, [pc, #28]	@ (3400e284 <LL_RCC_IC7_IsEnabled+0x24>)
3400e266:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e26a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400e26e:	2b40      	cmp	r3, #64	@ 0x40
3400e270:	d101      	bne.n	3400e276 <LL_RCC_IC7_IsEnabled+0x16>
3400e272:	2301      	movs	r3, #1
3400e274:	e000      	b.n	3400e278 <LL_RCC_IC7_IsEnabled+0x18>
3400e276:	2300      	movs	r3, #0
}
3400e278:	4618      	mov	r0, r3
3400e27a:	46bd      	mov	sp, r7
3400e27c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e280:	4770      	bx	lr
3400e282:	bf00      	nop
3400e284:	56028000 	.word	0x56028000

3400e288 <LL_RCC_IC7_GetSource>:
{
3400e288:	b480      	push	{r7}
3400e28a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400e28c:	4b04      	ldr	r3, [pc, #16]	@ (3400e2a0 <LL_RCC_IC7_GetSource+0x18>)
3400e28e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400e292:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e296:	4618      	mov	r0, r3
3400e298:	46bd      	mov	sp, r7
3400e29a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e29e:	4770      	bx	lr
3400e2a0:	56028000 	.word	0x56028000

3400e2a4 <LL_RCC_IC7_GetDivider>:
{
3400e2a4:	b480      	push	{r7}
3400e2a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3400e2a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e2c0 <LL_RCC_IC7_GetDivider+0x1c>)
3400e2aa:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400e2ae:	0c1b      	lsrs	r3, r3, #16
3400e2b0:	b2db      	uxtb	r3, r3
3400e2b2:	3301      	adds	r3, #1
}
3400e2b4:	4618      	mov	r0, r3
3400e2b6:	46bd      	mov	sp, r7
3400e2b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e2bc:	4770      	bx	lr
3400e2be:	bf00      	nop
3400e2c0:	56028000 	.word	0x56028000

3400e2c4 <LL_RCC_IC8_Enable>:
{
3400e2c4:	b480      	push	{r7}
3400e2c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400e2c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e2dc <LL_RCC_IC8_Enable+0x18>)
3400e2ca:	2280      	movs	r2, #128	@ 0x80
3400e2cc:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e2d0:	bf00      	nop
3400e2d2:	46bd      	mov	sp, r7
3400e2d4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e2d8:	4770      	bx	lr
3400e2da:	bf00      	nop
3400e2dc:	56028000 	.word	0x56028000

3400e2e0 <LL_RCC_IC8_IsEnabled>:
{
3400e2e0:	b480      	push	{r7}
3400e2e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3400e2e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e304 <LL_RCC_IC8_IsEnabled+0x24>)
3400e2e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e2ea:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400e2ee:	2b80      	cmp	r3, #128	@ 0x80
3400e2f0:	d101      	bne.n	3400e2f6 <LL_RCC_IC8_IsEnabled+0x16>
3400e2f2:	2301      	movs	r3, #1
3400e2f4:	e000      	b.n	3400e2f8 <LL_RCC_IC8_IsEnabled+0x18>
3400e2f6:	2300      	movs	r3, #0
}
3400e2f8:	4618      	mov	r0, r3
3400e2fa:	46bd      	mov	sp, r7
3400e2fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e300:	4770      	bx	lr
3400e302:	bf00      	nop
3400e304:	56028000 	.word	0x56028000

3400e308 <LL_RCC_IC8_GetSource>:
{
3400e308:	b480      	push	{r7}
3400e30a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e30c:	4b04      	ldr	r3, [pc, #16]	@ (3400e320 <LL_RCC_IC8_GetSource+0x18>)
3400e30e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e312:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e316:	4618      	mov	r0, r3
3400e318:	46bd      	mov	sp, r7
3400e31a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e31e:	4770      	bx	lr
3400e320:	56028000 	.word	0x56028000

3400e324 <LL_RCC_IC8_GetDivider>:
{
3400e324:	b480      	push	{r7}
3400e326:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3400e328:	4b05      	ldr	r3, [pc, #20]	@ (3400e340 <LL_RCC_IC8_GetDivider+0x1c>)
3400e32a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e32e:	0c1b      	lsrs	r3, r3, #16
3400e330:	b2db      	uxtb	r3, r3
3400e332:	3301      	adds	r3, #1
}
3400e334:	4618      	mov	r0, r3
3400e336:	46bd      	mov	sp, r7
3400e338:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e33c:	4770      	bx	lr
3400e33e:	bf00      	nop
3400e340:	56028000 	.word	0x56028000

3400e344 <LL_RCC_IC9_Enable>:
{
3400e344:	b480      	push	{r7}
3400e346:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400e348:	4b04      	ldr	r3, [pc, #16]	@ (3400e35c <LL_RCC_IC9_Enable+0x18>)
3400e34a:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400e34e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e352:	bf00      	nop
3400e354:	46bd      	mov	sp, r7
3400e356:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e35a:	4770      	bx	lr
3400e35c:	56028000 	.word	0x56028000

3400e360 <LL_RCC_IC9_IsEnabled>:
{
3400e360:	b480      	push	{r7}
3400e362:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3400e364:	4b07      	ldr	r3, [pc, #28]	@ (3400e384 <LL_RCC_IC9_IsEnabled+0x24>)
3400e366:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e36a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400e36e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400e372:	d101      	bne.n	3400e378 <LL_RCC_IC9_IsEnabled+0x18>
3400e374:	2301      	movs	r3, #1
3400e376:	e000      	b.n	3400e37a <LL_RCC_IC9_IsEnabled+0x1a>
3400e378:	2300      	movs	r3, #0
}
3400e37a:	4618      	mov	r0, r3
3400e37c:	46bd      	mov	sp, r7
3400e37e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e382:	4770      	bx	lr
3400e384:	56028000 	.word	0x56028000

3400e388 <LL_RCC_IC9_GetSource>:
{
3400e388:	b480      	push	{r7}
3400e38a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400e38c:	4b04      	ldr	r3, [pc, #16]	@ (3400e3a0 <LL_RCC_IC9_GetSource+0x18>)
3400e38e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e392:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e396:	4618      	mov	r0, r3
3400e398:	46bd      	mov	sp, r7
3400e39a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e39e:	4770      	bx	lr
3400e3a0:	56028000 	.word	0x56028000

3400e3a4 <LL_RCC_IC9_GetDivider>:
{
3400e3a4:	b480      	push	{r7}
3400e3a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3400e3a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e3c0 <LL_RCC_IC9_GetDivider+0x1c>)
3400e3aa:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400e3ae:	0c1b      	lsrs	r3, r3, #16
3400e3b0:	b2db      	uxtb	r3, r3
3400e3b2:	3301      	adds	r3, #1
}
3400e3b4:	4618      	mov	r0, r3
3400e3b6:	46bd      	mov	sp, r7
3400e3b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e3bc:	4770      	bx	lr
3400e3be:	bf00      	nop
3400e3c0:	56028000 	.word	0x56028000

3400e3c4 <LL_RCC_IC10_Enable>:
{
3400e3c4:	b480      	push	{r7}
3400e3c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400e3c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e3dc <LL_RCC_IC10_Enable+0x18>)
3400e3ca:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400e3ce:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e3d2:	bf00      	nop
3400e3d4:	46bd      	mov	sp, r7
3400e3d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e3da:	4770      	bx	lr
3400e3dc:	56028000 	.word	0x56028000

3400e3e0 <LL_RCC_IC10_IsEnabled>:
{
3400e3e0:	b480      	push	{r7}
3400e3e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400e3e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e404 <LL_RCC_IC10_IsEnabled+0x24>)
3400e3e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e3ea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400e3ee:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400e3f2:	d101      	bne.n	3400e3f8 <LL_RCC_IC10_IsEnabled+0x18>
3400e3f4:	2301      	movs	r3, #1
3400e3f6:	e000      	b.n	3400e3fa <LL_RCC_IC10_IsEnabled+0x1a>
3400e3f8:	2300      	movs	r3, #0
}
3400e3fa:	4618      	mov	r0, r3
3400e3fc:	46bd      	mov	sp, r7
3400e3fe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e402:	4770      	bx	lr
3400e404:	56028000 	.word	0x56028000

3400e408 <LL_RCC_IC10_GetSource>:
{
3400e408:	b480      	push	{r7}
3400e40a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400e40c:	4b04      	ldr	r3, [pc, #16]	@ (3400e420 <LL_RCC_IC10_GetSource+0x18>)
3400e40e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400e412:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e416:	4618      	mov	r0, r3
3400e418:	46bd      	mov	sp, r7
3400e41a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e41e:	4770      	bx	lr
3400e420:	56028000 	.word	0x56028000

3400e424 <LL_RCC_IC10_GetDivider>:
{
3400e424:	b480      	push	{r7}
3400e426:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e428:	4b05      	ldr	r3, [pc, #20]	@ (3400e440 <LL_RCC_IC10_GetDivider+0x1c>)
3400e42a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400e42e:	0c1b      	lsrs	r3, r3, #16
3400e430:	b2db      	uxtb	r3, r3
3400e432:	3301      	adds	r3, #1
}
3400e434:	4618      	mov	r0, r3
3400e436:	46bd      	mov	sp, r7
3400e438:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e43c:	4770      	bx	lr
3400e43e:	bf00      	nop
3400e440:	56028000 	.word	0x56028000

3400e444 <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
3400e444:	b480      	push	{r7}
3400e446:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3400e448:	4b04      	ldr	r3, [pc, #16]	@ (3400e45c <LL_RCC_IC12_Enable+0x18>)
3400e44a:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3400e44e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e452:	bf00      	nop
3400e454:	46bd      	mov	sp, r7
3400e456:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e45a:	4770      	bx	lr
3400e45c:	56028000 	.word	0x56028000

3400e460 <LL_RCC_IC12_IsEnabled>:
  * @brief  Check if IC12 is enabled
  * @rmtoll DIVENR       IC12EN         LL_RCC_IC12_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_IsEnabled(void)
{
3400e460:	b480      	push	{r7}
3400e462:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3400e464:	4b07      	ldr	r3, [pc, #28]	@ (3400e484 <LL_RCC_IC12_IsEnabled+0x24>)
3400e466:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e46a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400e46e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400e472:	d101      	bne.n	3400e478 <LL_RCC_IC12_IsEnabled+0x18>
3400e474:	2301      	movs	r3, #1
3400e476:	e000      	b.n	3400e47a <LL_RCC_IC12_IsEnabled+0x1a>
3400e478:	2300      	movs	r3, #0
}
3400e47a:	4618      	mov	r0, r3
3400e47c:	46bd      	mov	sp, r7
3400e47e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e482:	4770      	bx	lr
3400e484:	56028000 	.word	0x56028000

3400e488 <LL_RCC_IC12_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetSource(void)
{
3400e488:	b480      	push	{r7}
3400e48a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400e48c:	4b04      	ldr	r3, [pc, #16]	@ (3400e4a0 <LL_RCC_IC12_GetSource+0x18>)
3400e48e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3400e492:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e496:	4618      	mov	r0, r3
3400e498:	46bd      	mov	sp, r7
3400e49a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e49e:	4770      	bx	lr
3400e4a0:	56028000 	.word	0x56028000

3400e4a4 <LL_RCC_IC12_GetDivider>:
  * @brief  Get IC12 divider
  * @rmtoll IC12CFGR      IC12INT        LL_RCC_IC12_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetDivider(void)
{
3400e4a4:	b480      	push	{r7}
3400e4a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400e4a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e4c0 <LL_RCC_IC12_GetDivider+0x1c>)
3400e4aa:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3400e4ae:	0c1b      	lsrs	r3, r3, #16
3400e4b0:	b2db      	uxtb	r3, r3
3400e4b2:	3301      	adds	r3, #1
}
3400e4b4:	4618      	mov	r0, r3
3400e4b6:	46bd      	mov	sp, r7
3400e4b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e4bc:	4770      	bx	lr
3400e4be:	bf00      	nop
3400e4c0:	56028000 	.word	0x56028000

3400e4c4 <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
3400e4c4:	b480      	push	{r7}
3400e4c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3400e4c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e4dc <LL_RCC_IC13_Enable+0x18>)
3400e4ca:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400e4ce:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e4d2:	bf00      	nop
3400e4d4:	46bd      	mov	sp, r7
3400e4d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e4da:	4770      	bx	lr
3400e4dc:	56028000 	.word	0x56028000

3400e4e0 <LL_RCC_IC13_IsEnabled>:
  * @brief  Check if IC13 is enabled
  * @rmtoll DIVENR       IC13EN         LL_RCC_IC13_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_IsEnabled(void)
{
3400e4e0:	b480      	push	{r7}
3400e4e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3400e4e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e504 <LL_RCC_IC13_IsEnabled+0x24>)
3400e4e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e4ea:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400e4ee:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400e4f2:	d101      	bne.n	3400e4f8 <LL_RCC_IC13_IsEnabled+0x18>
3400e4f4:	2301      	movs	r3, #1
3400e4f6:	e000      	b.n	3400e4fa <LL_RCC_IC13_IsEnabled+0x1a>
3400e4f8:	2300      	movs	r3, #0
}
3400e4fa:	4618      	mov	r0, r3
3400e4fc:	46bd      	mov	sp, r7
3400e4fe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e502:	4770      	bx	lr
3400e504:	56028000 	.word	0x56028000

3400e508 <LL_RCC_IC13_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetSource(void)
{
3400e508:	b480      	push	{r7}
3400e50a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400e50c:	4b04      	ldr	r3, [pc, #16]	@ (3400e520 <LL_RCC_IC13_GetSource+0x18>)
3400e50e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400e512:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e516:	4618      	mov	r0, r3
3400e518:	46bd      	mov	sp, r7
3400e51a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e51e:	4770      	bx	lr
3400e520:	56028000 	.word	0x56028000

3400e524 <LL_RCC_IC13_GetDivider>:
  * @brief  Get IC13 divider
  * @rmtoll IC13CFGR      IC13INT        LL_RCC_IC13_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetDivider(void)
{
3400e524:	b480      	push	{r7}
3400e526:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400e528:	4b05      	ldr	r3, [pc, #20]	@ (3400e540 <LL_RCC_IC13_GetDivider+0x1c>)
3400e52a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400e52e:	0c1b      	lsrs	r3, r3, #16
3400e530:	b2db      	uxtb	r3, r3
3400e532:	3301      	adds	r3, #1
}
3400e534:	4618      	mov	r0, r3
3400e536:	46bd      	mov	sp, r7
3400e538:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e53c:	4770      	bx	lr
3400e53e:	bf00      	nop
3400e540:	56028000 	.word	0x56028000

3400e544 <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
3400e544:	b480      	push	{r7}
3400e546:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400e548:	4b04      	ldr	r3, [pc, #16]	@ (3400e55c <LL_RCC_IC14_Enable+0x18>)
3400e54a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3400e54e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e552:	bf00      	nop
3400e554:	46bd      	mov	sp, r7
3400e556:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e55a:	4770      	bx	lr
3400e55c:	56028000 	.word	0x56028000

3400e560 <LL_RCC_IC14_IsEnabled>:
  * @brief  Check if IC14 is enabled
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
3400e560:	b480      	push	{r7}
3400e562:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3400e564:	4b07      	ldr	r3, [pc, #28]	@ (3400e584 <LL_RCC_IC14_IsEnabled+0x24>)
3400e566:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e56a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400e56e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400e572:	d101      	bne.n	3400e578 <LL_RCC_IC14_IsEnabled+0x18>
3400e574:	2301      	movs	r3, #1
3400e576:	e000      	b.n	3400e57a <LL_RCC_IC14_IsEnabled+0x1a>
3400e578:	2300      	movs	r3, #0
}
3400e57a:	4618      	mov	r0, r3
3400e57c:	46bd      	mov	sp, r7
3400e57e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e582:	4770      	bx	lr
3400e584:	56028000 	.word	0x56028000

3400e588 <LL_RCC_IC14_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetSource(void)
{
3400e588:	b480      	push	{r7}
3400e58a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400e58c:	4b04      	ldr	r3, [pc, #16]	@ (3400e5a0 <LL_RCC_IC14_GetSource+0x18>)
3400e58e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400e592:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e596:	4618      	mov	r0, r3
3400e598:	46bd      	mov	sp, r7
3400e59a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e59e:	4770      	bx	lr
3400e5a0:	56028000 	.word	0x56028000

3400e5a4 <LL_RCC_IC14_GetDivider>:
  * @brief  Get IC14 divider
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
3400e5a4:	b480      	push	{r7}
3400e5a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3400e5a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e5c0 <LL_RCC_IC14_GetDivider+0x1c>)
3400e5aa:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400e5ae:	0c1b      	lsrs	r3, r3, #16
3400e5b0:	b2db      	uxtb	r3, r3
3400e5b2:	3301      	adds	r3, #1
}
3400e5b4:	4618      	mov	r0, r3
3400e5b6:	46bd      	mov	sp, r7
3400e5b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e5bc:	4770      	bx	lr
3400e5be:	bf00      	nop
3400e5c0:	56028000 	.word	0x56028000

3400e5c4 <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
3400e5c4:	b480      	push	{r7}
3400e5c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400e5c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e5dc <LL_RCC_IC15_Enable+0x18>)
3400e5ca:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3400e5ce:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e5d2:	bf00      	nop
3400e5d4:	46bd      	mov	sp, r7
3400e5d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e5da:	4770      	bx	lr
3400e5dc:	56028000 	.word	0x56028000

3400e5e0 <LL_RCC_IC15_IsEnabled>:
  * @brief  Check if IC15 is enabled
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
3400e5e0:	b480      	push	{r7}
3400e5e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3400e5e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e604 <LL_RCC_IC15_IsEnabled+0x24>)
3400e5e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e5ea:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400e5ee:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400e5f2:	d101      	bne.n	3400e5f8 <LL_RCC_IC15_IsEnabled+0x18>
3400e5f4:	2301      	movs	r3, #1
3400e5f6:	e000      	b.n	3400e5fa <LL_RCC_IC15_IsEnabled+0x1a>
3400e5f8:	2300      	movs	r3, #0
}
3400e5fa:	4618      	mov	r0, r3
3400e5fc:	46bd      	mov	sp, r7
3400e5fe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e602:	4770      	bx	lr
3400e604:	56028000 	.word	0x56028000

3400e608 <LL_RCC_IC15_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetSource(void)
{
3400e608:	b480      	push	{r7}
3400e60a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e60c:	4b04      	ldr	r3, [pc, #16]	@ (3400e620 <LL_RCC_IC15_GetSource+0x18>)
3400e60e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e612:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e616:	4618      	mov	r0, r3
3400e618:	46bd      	mov	sp, r7
3400e61a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e61e:	4770      	bx	lr
3400e620:	56028000 	.word	0x56028000

3400e624 <LL_RCC_IC15_GetDivider>:
  * @brief  Get IC15 divider
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
3400e624:	b480      	push	{r7}
3400e626:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3400e628:	4b05      	ldr	r3, [pc, #20]	@ (3400e640 <LL_RCC_IC15_GetDivider+0x1c>)
3400e62a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e62e:	0c1b      	lsrs	r3, r3, #16
3400e630:	b2db      	uxtb	r3, r3
3400e632:	3301      	adds	r3, #1
}
3400e634:	4618      	mov	r0, r3
3400e636:	46bd      	mov	sp, r7
3400e638:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e63c:	4770      	bx	lr
3400e63e:	bf00      	nop
3400e640:	56028000 	.word	0x56028000

3400e644 <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
3400e644:	b480      	push	{r7}
3400e646:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3400e648:	4b04      	ldr	r3, [pc, #16]	@ (3400e65c <LL_RCC_IC16_Enable+0x18>)
3400e64a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3400e64e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e652:	bf00      	nop
3400e654:	46bd      	mov	sp, r7
3400e656:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e65a:	4770      	bx	lr
3400e65c:	56028000 	.word	0x56028000

3400e660 <LL_RCC_IC16_IsEnabled>:
  * @brief  Check if IC16 is enabled
  * @rmtoll DIVENR       IC16EN         LL_RCC_IC16_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_IsEnabled(void)
{
3400e660:	b480      	push	{r7}
3400e662:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3400e664:	4b07      	ldr	r3, [pc, #28]	@ (3400e684 <LL_RCC_IC16_IsEnabled+0x24>)
3400e666:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e66a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400e66e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3400e672:	d101      	bne.n	3400e678 <LL_RCC_IC16_IsEnabled+0x18>
3400e674:	2301      	movs	r3, #1
3400e676:	e000      	b.n	3400e67a <LL_RCC_IC16_IsEnabled+0x1a>
3400e678:	2300      	movs	r3, #0
}
3400e67a:	4618      	mov	r0, r3
3400e67c:	46bd      	mov	sp, r7
3400e67e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e682:	4770      	bx	lr
3400e684:	56028000 	.word	0x56028000

3400e688 <LL_RCC_IC16_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetSource(void)
{
3400e688:	b480      	push	{r7}
3400e68a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400e68c:	4b04      	ldr	r3, [pc, #16]	@ (3400e6a0 <LL_RCC_IC16_GetSource+0x18>)
3400e68e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3400e692:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e696:	4618      	mov	r0, r3
3400e698:	46bd      	mov	sp, r7
3400e69a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e69e:	4770      	bx	lr
3400e6a0:	56028000 	.word	0x56028000

3400e6a4 <LL_RCC_IC16_GetDivider>:
  * @brief  Get IC16 divider
  * @rmtoll IC16CFGR      IC16INT        LL_RCC_IC16_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetDivider(void)
{
3400e6a4:	b480      	push	{r7}
3400e6a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400e6a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e6c0 <LL_RCC_IC16_GetDivider+0x1c>)
3400e6aa:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3400e6ae:	0c1b      	lsrs	r3, r3, #16
3400e6b0:	b2db      	uxtb	r3, r3
3400e6b2:	3301      	adds	r3, #1
}
3400e6b4:	4618      	mov	r0, r3
3400e6b6:	46bd      	mov	sp, r7
3400e6b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e6bc:	4770      	bx	lr
3400e6be:	bf00      	nop
3400e6c0:	56028000 	.word	0x56028000

3400e6c4 <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
3400e6c4:	b480      	push	{r7}
3400e6c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3400e6c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e6dc <LL_RCC_IC17_Enable+0x18>)
3400e6ca:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400e6ce:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e6d2:	bf00      	nop
3400e6d4:	46bd      	mov	sp, r7
3400e6d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e6da:	4770      	bx	lr
3400e6dc:	56028000 	.word	0x56028000

3400e6e0 <LL_RCC_IC17_IsEnabled>:
  * @brief  Check if IC17 is enabled
  * @rmtoll DIVENR       IC17EN         LL_RCC_IC17_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_IsEnabled(void)
{
3400e6e0:	b480      	push	{r7}
3400e6e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3400e6e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e704 <LL_RCC_IC17_IsEnabled+0x24>)
3400e6e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e6ea:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400e6ee:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400e6f2:	d101      	bne.n	3400e6f8 <LL_RCC_IC17_IsEnabled+0x18>
3400e6f4:	2301      	movs	r3, #1
3400e6f6:	e000      	b.n	3400e6fa <LL_RCC_IC17_IsEnabled+0x1a>
3400e6f8:	2300      	movs	r3, #0
}
3400e6fa:	4618      	mov	r0, r3
3400e6fc:	46bd      	mov	sp, r7
3400e6fe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e702:	4770      	bx	lr
3400e704:	56028000 	.word	0x56028000

3400e708 <LL_RCC_IC17_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetSource(void)
{
3400e708:	b480      	push	{r7}
3400e70a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400e70c:	4b04      	ldr	r3, [pc, #16]	@ (3400e720 <LL_RCC_IC17_GetSource+0x18>)
3400e70e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3400e712:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e716:	4618      	mov	r0, r3
3400e718:	46bd      	mov	sp, r7
3400e71a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e71e:	4770      	bx	lr
3400e720:	56028000 	.word	0x56028000

3400e724 <LL_RCC_IC17_GetDivider>:
  * @brief  Get IC17 divider
  * @rmtoll IC17CFGR      IC17INT        LL_RCC_IC17_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetDivider(void)
{
3400e724:	b480      	push	{r7}
3400e726:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400e728:	4b05      	ldr	r3, [pc, #20]	@ (3400e740 <LL_RCC_IC17_GetDivider+0x1c>)
3400e72a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3400e72e:	0c1b      	lsrs	r3, r3, #16
3400e730:	b2db      	uxtb	r3, r3
3400e732:	3301      	adds	r3, #1
}
3400e734:	4618      	mov	r0, r3
3400e736:	46bd      	mov	sp, r7
3400e738:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e73c:	4770      	bx	lr
3400e73e:	bf00      	nop
3400e740:	56028000 	.word	0x56028000

3400e744 <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
3400e744:	b480      	push	{r7}
3400e746:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3400e748:	4b04      	ldr	r3, [pc, #16]	@ (3400e75c <LL_RCC_IC18_Enable+0x18>)
3400e74a:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
3400e74e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e752:	bf00      	nop
3400e754:	46bd      	mov	sp, r7
3400e756:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e75a:	4770      	bx	lr
3400e75c:	56028000 	.word	0x56028000

3400e760 <LL_RCC_IC18_IsEnabled>:
  * @brief  Check if IC18 is enabled
  * @rmtoll DIVENR       IC18EN         LL_RCC_IC18_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_IsEnabled(void)
{
3400e760:	b480      	push	{r7}
3400e762:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3400e764:	4b07      	ldr	r3, [pc, #28]	@ (3400e784 <LL_RCC_IC18_IsEnabled+0x24>)
3400e766:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e76a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400e76e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400e772:	d101      	bne.n	3400e778 <LL_RCC_IC18_IsEnabled+0x18>
3400e774:	2301      	movs	r3, #1
3400e776:	e000      	b.n	3400e77a <LL_RCC_IC18_IsEnabled+0x1a>
3400e778:	2300      	movs	r3, #0
}
3400e77a:	4618      	mov	r0, r3
3400e77c:	46bd      	mov	sp, r7
3400e77e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e782:	4770      	bx	lr
3400e784:	56028000 	.word	0x56028000

3400e788 <LL_RCC_IC18_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetSource(void)
{
3400e788:	b480      	push	{r7}
3400e78a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3400e78c:	4b04      	ldr	r3, [pc, #16]	@ (3400e7a0 <LL_RCC_IC18_GetSource+0x18>)
3400e78e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400e792:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e796:	4618      	mov	r0, r3
3400e798:	46bd      	mov	sp, r7
3400e79a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e79e:	4770      	bx	lr
3400e7a0:	56028000 	.word	0x56028000

3400e7a4 <LL_RCC_IC18_GetDivider>:
  * @brief  Get IC18 divider
  * @rmtoll IC18CFGR      IC18INT        LL_RCC_IC18_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetDivider(void)
{
3400e7a4:	b480      	push	{r7}
3400e7a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400e7a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e7c0 <LL_RCC_IC18_GetDivider+0x1c>)
3400e7aa:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400e7ae:	0c1b      	lsrs	r3, r3, #16
3400e7b0:	b2db      	uxtb	r3, r3
3400e7b2:	3301      	adds	r3, #1
}
3400e7b4:	4618      	mov	r0, r3
3400e7b6:	46bd      	mov	sp, r7
3400e7b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e7bc:	4770      	bx	lr
3400e7be:	bf00      	nop
3400e7c0:	56028000 	.word	0x56028000

3400e7c4 <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
3400e7c4:	b480      	push	{r7}
3400e7c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400e7c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e7dc <LL_RCC_IC19_Enable+0x18>)
3400e7ca:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
3400e7ce:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e7d2:	bf00      	nop
3400e7d4:	46bd      	mov	sp, r7
3400e7d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e7da:	4770      	bx	lr
3400e7dc:	56028000 	.word	0x56028000

3400e7e0 <LL_RCC_IC19_IsEnabled>:
  * @brief  Check if IC19 is enabled
  * @rmtoll DIVENR       IC19EN         LL_RCC_IC19_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_IsEnabled(void)
{
3400e7e0:	b480      	push	{r7}
3400e7e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400e7e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e804 <LL_RCC_IC19_IsEnabled+0x24>)
3400e7e6:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e7ea:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400e7ee:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400e7f2:	d101      	bne.n	3400e7f8 <LL_RCC_IC19_IsEnabled+0x18>
3400e7f4:	2301      	movs	r3, #1
3400e7f6:	e000      	b.n	3400e7fa <LL_RCC_IC19_IsEnabled+0x1a>
3400e7f8:	2300      	movs	r3, #0
}
3400e7fa:	4618      	mov	r0, r3
3400e7fc:	46bd      	mov	sp, r7
3400e7fe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e802:	4770      	bx	lr
3400e804:	56028000 	.word	0x56028000

3400e808 <LL_RCC_IC19_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetSource(void)
{
3400e808:	b480      	push	{r7}
3400e80a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400e80c:	4b04      	ldr	r3, [pc, #16]	@ (3400e820 <LL_RCC_IC19_GetSource+0x18>)
3400e80e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400e812:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e816:	4618      	mov	r0, r3
3400e818:	46bd      	mov	sp, r7
3400e81a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e81e:	4770      	bx	lr
3400e820:	56028000 	.word	0x56028000

3400e824 <LL_RCC_IC19_GetDivider>:
  * @brief  Get IC19 divider
  * @rmtoll IC19CFGR      IC19INT        LL_RCC_IC19_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetDivider(void)
{
3400e824:	b480      	push	{r7}
3400e826:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400e828:	4b05      	ldr	r3, [pc, #20]	@ (3400e840 <LL_RCC_IC19_GetDivider+0x1c>)
3400e82a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400e82e:	0c1b      	lsrs	r3, r3, #16
3400e830:	b2db      	uxtb	r3, r3
3400e832:	3301      	adds	r3, #1
}
3400e834:	4618      	mov	r0, r3
3400e836:	46bd      	mov	sp, r7
3400e838:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e83c:	4770      	bx	lr
3400e83e:	bf00      	nop
3400e840:	56028000 	.word	0x56028000

3400e844 <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
3400e844:	b480      	push	{r7}
3400e846:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400e848:	4b04      	ldr	r3, [pc, #16]	@ (3400e85c <LL_RCC_IC20_Enable+0x18>)
3400e84a:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3400e84e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400e852:	bf00      	nop
3400e854:	46bd      	mov	sp, r7
3400e856:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e85a:	4770      	bx	lr
3400e85c:	56028000 	.word	0x56028000

3400e860 <LL_RCC_IC20_IsEnabled>:
  * @brief  Check if IC20 is enabled
  * @rmtoll DIVENR       IC20EN         LL_RCC_IC20_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_IsEnabled(void)
{
3400e860:	b480      	push	{r7}
3400e862:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400e864:	4b07      	ldr	r3, [pc, #28]	@ (3400e884 <LL_RCC_IC20_IsEnabled+0x24>)
3400e866:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3400e86a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3400e86e:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
3400e872:	d101      	bne.n	3400e878 <LL_RCC_IC20_IsEnabled+0x18>
3400e874:	2301      	movs	r3, #1
3400e876:	e000      	b.n	3400e87a <LL_RCC_IC20_IsEnabled+0x1a>
3400e878:	2300      	movs	r3, #0
}
3400e87a:	4618      	mov	r0, r3
3400e87c:	46bd      	mov	sp, r7
3400e87e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e882:	4770      	bx	lr
3400e884:	56028000 	.word	0x56028000

3400e888 <LL_RCC_IC20_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetSource(void)
{
3400e888:	b480      	push	{r7}
3400e88a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400e88c:	4b04      	ldr	r3, [pc, #16]	@ (3400e8a0 <LL_RCC_IC20_GetSource+0x18>)
3400e88e:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400e892:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400e896:	4618      	mov	r0, r3
3400e898:	46bd      	mov	sp, r7
3400e89a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e89e:	4770      	bx	lr
3400e8a0:	56028000 	.word	0x56028000

3400e8a4 <LL_RCC_IC20_GetDivider>:
  * @brief  Get IC20 divider
  * @rmtoll IC20CFGR      IC20INT        LL_RCC_IC20_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetDivider(void)
{
3400e8a4:	b480      	push	{r7}
3400e8a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400e8a8:	4b05      	ldr	r3, [pc, #20]	@ (3400e8c0 <LL_RCC_IC20_GetDivider+0x1c>)
3400e8aa:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400e8ae:	0c1b      	lsrs	r3, r3, #16
3400e8b0:	b2db      	uxtb	r3, r3
3400e8b2:	3301      	adds	r3, #1
}
3400e8b4:	4618      	mov	r0, r3
3400e8b6:	46bd      	mov	sp, r7
3400e8b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e8bc:	4770      	bx	lr
3400e8be:	bf00      	nop
3400e8c0:	56028000 	.word	0x56028000

3400e8c4 <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
3400e8c4:	b480      	push	{r7}
3400e8c6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400e8c8:	4b04      	ldr	r3, [pc, #16]	@ (3400e8dc <LL_RCC_CLKP_Enable+0x18>)
3400e8ca:	2240      	movs	r2, #64	@ 0x40
3400e8cc:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
3400e8d0:	bf00      	nop
3400e8d2:	46bd      	mov	sp, r7
3400e8d4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e8d8:	4770      	bx	lr
3400e8da:	bf00      	nop
3400e8dc:	56028000 	.word	0x56028000

3400e8e0 <LL_RCC_CLKP_IsEnabled>:
  * @brief  Check if CLKP is enabled
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
3400e8e0:	b480      	push	{r7}
3400e8e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3400e8e4:	4b07      	ldr	r3, [pc, #28]	@ (3400e904 <LL_RCC_CLKP_IsEnabled+0x24>)
3400e8e6:	f8d3 3248 	ldr.w	r3, [r3, #584]	@ 0x248
3400e8ea:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400e8ee:	2b40      	cmp	r3, #64	@ 0x40
3400e8f0:	d101      	bne.n	3400e8f6 <LL_RCC_CLKP_IsEnabled+0x16>
3400e8f2:	2301      	movs	r3, #1
3400e8f4:	e000      	b.n	3400e8f8 <LL_RCC_CLKP_IsEnabled+0x18>
3400e8f6:	2300      	movs	r3, #0
}
3400e8f8:	4618      	mov	r0, r3
3400e8fa:	46bd      	mov	sp, r7
3400e8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e900:	4770      	bx	lr
3400e902:	bf00      	nop
3400e904:	56028000 	.word	0x56028000

3400e908 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
3400e908:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3400e90c:	f5ad 7d64 	sub.w	sp, sp, #912	@ 0x390
3400e910:	af00      	add	r7, sp, #0
3400e912:	f8c7 037c 	str.w	r0, [r7, #892]	@ 0x37c
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
3400e916:	2300      	movs	r3, #0
3400e918:	f887 338f 	strb.w	r3, [r7, #911]	@ 0x38f
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3400e91c:	2300      	movs	r3, #0
3400e91e:	f887 338e 	strb.w	r3, [r7, #910]	@ 0x38e

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400e922:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e926:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e92a:	f402 6400 	and.w	r4, r2, #2048	@ 0x800
3400e92e:	2500      	movs	r5, #0
3400e930:	ea54 0305 	orrs.w	r3, r4, r5
3400e934:	f040 83e0 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e938:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e93c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e940:	f04f 0800 	mov.w	r8, #0
3400e944:	f403 0980 	and.w	r9, r3, #4194304	@ 0x400000
3400e948:	ea58 0309 	orrs.w	r3, r8, r9
3400e94c:	f040 83d4 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e950:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e954:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e958:	f04f 0a00 	mov.w	sl, #0
3400e95c:	f403 0b00 	and.w	fp, r3, #8388608	@ 0x800000
3400e960:	ea5a 030b 	orrs.w	r3, sl, fp
3400e964:	f040 83c8 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e968:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e96c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e970:	2100      	movs	r1, #0
3400e972:	f8c7 1370 	str.w	r1, [r7, #880]	@ 0x370
3400e976:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3400e97a:	f8c7 3374 	str.w	r3, [r7, #884]	@ 0x374
3400e97e:	e9d7 01dc 	ldrd	r0, r1, [r7, #880]	@ 0x370
3400e982:	4603      	mov	r3, r0
3400e984:	460a      	mov	r2, r1
3400e986:	4313      	orrs	r3, r2
3400e988:	f040 83b6 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e98c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e990:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e994:	f002 0304 	and.w	r3, r2, #4
3400e998:	f8c7 3368 	str.w	r3, [r7, #872]	@ 0x368
3400e99c:	2300      	movs	r3, #0
3400e99e:	f8c7 336c 	str.w	r3, [r7, #876]	@ 0x36c
3400e9a2:	e9d7 01da 	ldrd	r0, r1, [r7, #872]	@ 0x368
3400e9a6:	4603      	mov	r3, r0
3400e9a8:	460a      	mov	r2, r1
3400e9aa:	4313      	orrs	r3, r2
3400e9ac:	f040 83a4 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e9b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e9b4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e9b8:	f002 0301 	and.w	r3, r2, #1
3400e9bc:	f8c7 3360 	str.w	r3, [r7, #864]	@ 0x360
3400e9c0:	2300      	movs	r3, #0
3400e9c2:	f8c7 3364 	str.w	r3, [r7, #868]	@ 0x364
3400e9c6:	e9d7 01d8 	ldrd	r0, r1, [r7, #864]	@ 0x360
3400e9ca:	4603      	mov	r3, r0
3400e9cc:	460a      	mov	r2, r1
3400e9ce:	4313      	orrs	r3, r2
3400e9d0:	f040 8392 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e9d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e9d8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400e9dc:	f002 0302 	and.w	r3, r2, #2
3400e9e0:	f8c7 3358 	str.w	r3, [r7, #856]	@ 0x358
3400e9e4:	2300      	movs	r3, #0
3400e9e6:	f8c7 335c 	str.w	r3, [r7, #860]	@ 0x35c
3400e9ea:	e9d7 01d6 	ldrd	r0, r1, [r7, #856]	@ 0x358
3400e9ee:	4603      	mov	r3, r0
3400e9f0:	460a      	mov	r2, r1
3400e9f2:	4313      	orrs	r3, r2
3400e9f4:	f040 8380 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400e9f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400e9fc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ea00:	f002 0308 	and.w	r3, r2, #8
3400ea04:	f8c7 3350 	str.w	r3, [r7, #848]	@ 0x350
3400ea08:	2300      	movs	r3, #0
3400ea0a:	f8c7 3354 	str.w	r3, [r7, #852]	@ 0x354
3400ea0e:	e9d7 01d4 	ldrd	r0, r1, [r7, #848]	@ 0x350
3400ea12:	4603      	mov	r3, r0
3400ea14:	460a      	mov	r2, r1
3400ea16:	4313      	orrs	r3, r2
3400ea18:	f040 836e 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ea1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea20:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ea24:	f002 0310 	and.w	r3, r2, #16
3400ea28:	f8c7 3348 	str.w	r3, [r7, #840]	@ 0x348
3400ea2c:	2300      	movs	r3, #0
3400ea2e:	f8c7 334c 	str.w	r3, [r7, #844]	@ 0x34c
3400ea32:	e9d7 01d2 	ldrd	r0, r1, [r7, #840]	@ 0x348
3400ea36:	4603      	mov	r3, r0
3400ea38:	460a      	mov	r2, r1
3400ea3a:	4313      	orrs	r3, r2
3400ea3c:	f040 835c 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ea40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea44:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ea48:	f002 0320 	and.w	r3, r2, #32
3400ea4c:	f8c7 3340 	str.w	r3, [r7, #832]	@ 0x340
3400ea50:	2300      	movs	r3, #0
3400ea52:	f8c7 3344 	str.w	r3, [r7, #836]	@ 0x344
3400ea56:	e9d7 01d0 	ldrd	r0, r1, [r7, #832]	@ 0x340
3400ea5a:	4603      	mov	r3, r0
3400ea5c:	460a      	mov	r2, r1
3400ea5e:	4313      	orrs	r3, r2
3400ea60:	f040 834a 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ea64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea68:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ea6c:	f002 0340 	and.w	r3, r2, #64	@ 0x40
3400ea70:	f8c7 3338 	str.w	r3, [r7, #824]	@ 0x338
3400ea74:	2300      	movs	r3, #0
3400ea76:	f8c7 333c 	str.w	r3, [r7, #828]	@ 0x33c
3400ea7a:	e9d7 01ce 	ldrd	r0, r1, [r7, #824]	@ 0x338
3400ea7e:	4603      	mov	r3, r0
3400ea80:	460a      	mov	r2, r1
3400ea82:	4313      	orrs	r3, r2
3400ea84:	f040 8338 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ea88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ea8c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ea90:	f002 0380 	and.w	r3, r2, #128	@ 0x80
3400ea94:	f8c7 3330 	str.w	r3, [r7, #816]	@ 0x330
3400ea98:	2300      	movs	r3, #0
3400ea9a:	f8c7 3334 	str.w	r3, [r7, #820]	@ 0x334
3400ea9e:	e9d7 01cc 	ldrd	r0, r1, [r7, #816]	@ 0x330
3400eaa2:	4603      	mov	r3, r0
3400eaa4:	460a      	mov	r2, r1
3400eaa6:	4313      	orrs	r3, r2
3400eaa8:	f040 8326 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eaac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eab0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eab4:	f402 7380 	and.w	r3, r2, #256	@ 0x100
3400eab8:	f8c7 3328 	str.w	r3, [r7, #808]	@ 0x328
3400eabc:	2300      	movs	r3, #0
3400eabe:	f8c7 332c 	str.w	r3, [r7, #812]	@ 0x32c
3400eac2:	e9d7 01ca 	ldrd	r0, r1, [r7, #808]	@ 0x328
3400eac6:	4603      	mov	r3, r0
3400eac8:	460a      	mov	r2, r1
3400eaca:	4313      	orrs	r3, r2
3400eacc:	f040 8314 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ead0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ead4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ead8:	f402 7300 	and.w	r3, r2, #512	@ 0x200
3400eadc:	f8c7 3320 	str.w	r3, [r7, #800]	@ 0x320
3400eae0:	2300      	movs	r3, #0
3400eae2:	f8c7 3324 	str.w	r3, [r7, #804]	@ 0x324
3400eae6:	e9d7 01c8 	ldrd	r0, r1, [r7, #800]	@ 0x320
3400eaea:	4603      	mov	r3, r0
3400eaec:	460a      	mov	r2, r1
3400eaee:	4313      	orrs	r3, r2
3400eaf0:	f040 8302 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eaf4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eaf8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eafc:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
3400eb00:	f8c7 3318 	str.w	r3, [r7, #792]	@ 0x318
3400eb04:	2300      	movs	r3, #0
3400eb06:	f8c7 331c 	str.w	r3, [r7, #796]	@ 0x31c
3400eb0a:	e9d7 01c6 	ldrd	r0, r1, [r7, #792]	@ 0x318
3400eb0e:	4603      	mov	r3, r0
3400eb10:	460a      	mov	r2, r1
3400eb12:	4313      	orrs	r3, r2
3400eb14:	f040 82f0 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eb18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb1c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eb20:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
3400eb24:	f8c7 3310 	str.w	r3, [r7, #784]	@ 0x310
3400eb28:	2300      	movs	r3, #0
3400eb2a:	f8c7 3314 	str.w	r3, [r7, #788]	@ 0x314
3400eb2e:	e9d7 01c4 	ldrd	r0, r1, [r7, #784]	@ 0x310
3400eb32:	4603      	mov	r3, r0
3400eb34:	460a      	mov	r2, r1
3400eb36:	4313      	orrs	r3, r2
3400eb38:	f040 82de 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eb3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb40:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eb44:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
3400eb48:	f8c7 3308 	str.w	r3, [r7, #776]	@ 0x308
3400eb4c:	2300      	movs	r3, #0
3400eb4e:	f8c7 330c 	str.w	r3, [r7, #780]	@ 0x30c
3400eb52:	e9d7 01c2 	ldrd	r0, r1, [r7, #776]	@ 0x308
3400eb56:	4603      	mov	r3, r0
3400eb58:	460a      	mov	r2, r1
3400eb5a:	4313      	orrs	r3, r2
3400eb5c:	f040 82cc 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eb60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb64:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eb68:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
3400eb6c:	f8c7 3300 	str.w	r3, [r7, #768]	@ 0x300
3400eb70:	2300      	movs	r3, #0
3400eb72:	f8c7 3304 	str.w	r3, [r7, #772]	@ 0x304
3400eb76:	e9d7 01c0 	ldrd	r0, r1, [r7, #768]	@ 0x300
3400eb7a:	4603      	mov	r3, r0
3400eb7c:	460a      	mov	r2, r1
3400eb7e:	4313      	orrs	r3, r2
3400eb80:	f040 82ba 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eb84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eb88:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eb8c:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
3400eb90:	f8c7 32f8 	str.w	r3, [r7, #760]	@ 0x2f8
3400eb94:	2300      	movs	r3, #0
3400eb96:	f8c7 32fc 	str.w	r3, [r7, #764]	@ 0x2fc
3400eb9a:	e9d7 01be 	ldrd	r0, r1, [r7, #760]	@ 0x2f8
3400eb9e:	4603      	mov	r3, r0
3400eba0:	460a      	mov	r2, r1
3400eba2:	4313      	orrs	r3, r2
3400eba4:	f040 82a8 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eba8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ebac:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ebb0:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3400ebb4:	f8c7 32f0 	str.w	r3, [r7, #752]	@ 0x2f0
3400ebb8:	2300      	movs	r3, #0
3400ebba:	f8c7 32f4 	str.w	r3, [r7, #756]	@ 0x2f4
3400ebbe:	e9d7 01bc 	ldrd	r0, r1, [r7, #752]	@ 0x2f0
3400ebc2:	4603      	mov	r3, r0
3400ebc4:	460a      	mov	r2, r1
3400ebc6:	4313      	orrs	r3, r2
3400ebc8:	f040 8296 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ebcc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ebd0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ebd4:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
3400ebd8:	f8c7 32e8 	str.w	r3, [r7, #744]	@ 0x2e8
3400ebdc:	2300      	movs	r3, #0
3400ebde:	f8c7 32ec 	str.w	r3, [r7, #748]	@ 0x2ec
3400ebe2:	e9d7 01ba 	ldrd	r0, r1, [r7, #744]	@ 0x2e8
3400ebe6:	4603      	mov	r3, r0
3400ebe8:	460a      	mov	r2, r1
3400ebea:	4313      	orrs	r3, r2
3400ebec:	f040 8284 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ebf0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ebf4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ebf8:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
3400ebfc:	f8c7 32e0 	str.w	r3, [r7, #736]	@ 0x2e0
3400ec00:	2300      	movs	r3, #0
3400ec02:	f8c7 32e4 	str.w	r3, [r7, #740]	@ 0x2e4
3400ec06:	e9d7 01b8 	ldrd	r0, r1, [r7, #736]	@ 0x2e0
3400ec0a:	4603      	mov	r3, r0
3400ec0c:	460a      	mov	r2, r1
3400ec0e:	4313      	orrs	r3, r2
3400ec10:	f040 8272 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ec14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec18:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ec1c:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
3400ec20:	f8c7 32d8 	str.w	r3, [r7, #728]	@ 0x2d8
3400ec24:	2300      	movs	r3, #0
3400ec26:	f8c7 32dc 	str.w	r3, [r7, #732]	@ 0x2dc
3400ec2a:	e9d7 01b6 	ldrd	r0, r1, [r7, #728]	@ 0x2d8
3400ec2e:	4603      	mov	r3, r0
3400ec30:	460a      	mov	r2, r1
3400ec32:	4313      	orrs	r3, r2
3400ec34:	f040 8260 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ec38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec3c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ec40:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
3400ec44:	f8c7 32d0 	str.w	r3, [r7, #720]	@ 0x2d0
3400ec48:	2300      	movs	r3, #0
3400ec4a:	f8c7 32d4 	str.w	r3, [r7, #724]	@ 0x2d4
3400ec4e:	e9d7 01b4 	ldrd	r0, r1, [r7, #720]	@ 0x2d0
3400ec52:	4603      	mov	r3, r0
3400ec54:	460a      	mov	r2, r1
3400ec56:	4313      	orrs	r3, r2
3400ec58:	f040 824e 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ec5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec60:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ec64:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
3400ec68:	f8c7 32c8 	str.w	r3, [r7, #712]	@ 0x2c8
3400ec6c:	2300      	movs	r3, #0
3400ec6e:	f8c7 32cc 	str.w	r3, [r7, #716]	@ 0x2cc
3400ec72:	e9d7 01b2 	ldrd	r0, r1, [r7, #712]	@ 0x2c8
3400ec76:	4603      	mov	r3, r0
3400ec78:	460a      	mov	r2, r1
3400ec7a:	4313      	orrs	r3, r2
3400ec7c:	f040 823c 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ec80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ec84:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ec88:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
3400ec8c:	f8c7 32c0 	str.w	r3, [r7, #704]	@ 0x2c0
3400ec90:	2300      	movs	r3, #0
3400ec92:	f8c7 32c4 	str.w	r3, [r7, #708]	@ 0x2c4
3400ec96:	e9d7 01b0 	ldrd	r0, r1, [r7, #704]	@ 0x2c0
3400ec9a:	4603      	mov	r3, r0
3400ec9c:	460a      	mov	r2, r1
3400ec9e:	4313      	orrs	r3, r2
3400eca0:	f040 822a 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eca4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eca8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ecac:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
3400ecb0:	f8c7 32b8 	str.w	r3, [r7, #696]	@ 0x2b8
3400ecb4:	2300      	movs	r3, #0
3400ecb6:	f8c7 32bc 	str.w	r3, [r7, #700]	@ 0x2bc
3400ecba:	e9d7 01ae 	ldrd	r0, r1, [r7, #696]	@ 0x2b8
3400ecbe:	4603      	mov	r3, r0
3400ecc0:	460a      	mov	r2, r1
3400ecc2:	4313      	orrs	r3, r2
3400ecc4:	f040 8218 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ecc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eccc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ecd0:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
3400ecd4:	f8c7 32b0 	str.w	r3, [r7, #688]	@ 0x2b0
3400ecd8:	2300      	movs	r3, #0
3400ecda:	f8c7 32b4 	str.w	r3, [r7, #692]	@ 0x2b4
3400ecde:	e9d7 01ac 	ldrd	r0, r1, [r7, #688]	@ 0x2b0
3400ece2:	4603      	mov	r3, r0
3400ece4:	460a      	mov	r2, r1
3400ece6:	4313      	orrs	r3, r2
3400ece8:	f040 8206 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ecec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ecf0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ecf4:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
3400ecf8:	f8c7 32a8 	str.w	r3, [r7, #680]	@ 0x2a8
3400ecfc:	2300      	movs	r3, #0
3400ecfe:	f8c7 32ac 	str.w	r3, [r7, #684]	@ 0x2ac
3400ed02:	e9d7 01aa 	ldrd	r0, r1, [r7, #680]	@ 0x2a8
3400ed06:	4603      	mov	r3, r0
3400ed08:	460a      	mov	r2, r1
3400ed0a:	4313      	orrs	r3, r2
3400ed0c:	f040 81f4 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ed10:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed14:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ed18:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
3400ed1c:	f8c7 32a0 	str.w	r3, [r7, #672]	@ 0x2a0
3400ed20:	2300      	movs	r3, #0
3400ed22:	f8c7 32a4 	str.w	r3, [r7, #676]	@ 0x2a4
3400ed26:	e9d7 01a8 	ldrd	r0, r1, [r7, #672]	@ 0x2a0
3400ed2a:	4603      	mov	r3, r0
3400ed2c:	460a      	mov	r2, r1
3400ed2e:	4313      	orrs	r3, r2
3400ed30:	f040 81e2 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ed34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed38:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ed3c:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
3400ed40:	f8c7 3298 	str.w	r3, [r7, #664]	@ 0x298
3400ed44:	2300      	movs	r3, #0
3400ed46:	f8c7 329c 	str.w	r3, [r7, #668]	@ 0x29c
3400ed4a:	e9d7 01a6 	ldrd	r0, r1, [r7, #664]	@ 0x298
3400ed4e:	4603      	mov	r3, r0
3400ed50:	460a      	mov	r2, r1
3400ed52:	4313      	orrs	r3, r2
3400ed54:	f040 81d0 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ed58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed5c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ed60:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3400ed64:	f8c7 3290 	str.w	r3, [r7, #656]	@ 0x290
3400ed68:	2300      	movs	r3, #0
3400ed6a:	f8c7 3294 	str.w	r3, [r7, #660]	@ 0x294
3400ed6e:	e9d7 01a4 	ldrd	r0, r1, [r7, #656]	@ 0x290
3400ed72:	4603      	mov	r3, r0
3400ed74:	460a      	mov	r2, r1
3400ed76:	4313      	orrs	r3, r2
3400ed78:	f040 81be 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ed7c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ed80:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ed84:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
3400ed88:	f8c7 3288 	str.w	r3, [r7, #648]	@ 0x288
3400ed8c:	2300      	movs	r3, #0
3400ed8e:	f8c7 328c 	str.w	r3, [r7, #652]	@ 0x28c
3400ed92:	e9d7 01a2 	ldrd	r0, r1, [r7, #648]	@ 0x288
3400ed96:	4603      	mov	r3, r0
3400ed98:	460a      	mov	r2, r1
3400ed9a:	4313      	orrs	r3, r2
3400ed9c:	f040 81ac 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eda0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eda4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eda8:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
3400edac:	f8c7 3280 	str.w	r3, [r7, #640]	@ 0x280
3400edb0:	2300      	movs	r3, #0
3400edb2:	f8c7 3284 	str.w	r3, [r7, #644]	@ 0x284
3400edb6:	e9d7 01a0 	ldrd	r0, r1, [r7, #640]	@ 0x280
3400edba:	4603      	mov	r3, r0
3400edbc:	460a      	mov	r2, r1
3400edbe:	4313      	orrs	r3, r2
3400edc0:	f040 819a 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400edc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400edc8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400edcc:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3400edd0:	f8c7 3278 	str.w	r3, [r7, #632]	@ 0x278
3400edd4:	2300      	movs	r3, #0
3400edd6:	f8c7 327c 	str.w	r3, [r7, #636]	@ 0x27c
3400edda:	e9d7 019e 	ldrd	r0, r1, [r7, #632]	@ 0x278
3400edde:	4603      	mov	r3, r0
3400ede0:	460a      	mov	r2, r1
3400ede2:	4313      	orrs	r3, r2
3400ede4:	f040 8188 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ede8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400edec:	e9d3 2300 	ldrd	r2, r3, [r3]
3400edf0:	2100      	movs	r1, #0
3400edf2:	f8c7 1270 	str.w	r1, [r7, #624]	@ 0x270
3400edf6:	f003 0301 	and.w	r3, r3, #1
3400edfa:	f8c7 3274 	str.w	r3, [r7, #628]	@ 0x274
3400edfe:	e9d7 019c 	ldrd	r0, r1, [r7, #624]	@ 0x270
3400ee02:	4603      	mov	r3, r0
3400ee04:	460a      	mov	r2, r1
3400ee06:	4313      	orrs	r3, r2
3400ee08:	f040 8176 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ee0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee10:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ee14:	2100      	movs	r1, #0
3400ee16:	f8c7 1268 	str.w	r1, [r7, #616]	@ 0x268
3400ee1a:	f003 0302 	and.w	r3, r3, #2
3400ee1e:	f8c7 326c 	str.w	r3, [r7, #620]	@ 0x26c
3400ee22:	e9d7 019a 	ldrd	r0, r1, [r7, #616]	@ 0x268
3400ee26:	4603      	mov	r3, r0
3400ee28:	460a      	mov	r2, r1
3400ee2a:	4313      	orrs	r3, r2
3400ee2c:	f040 8164 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ee30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee34:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ee38:	2100      	movs	r1, #0
3400ee3a:	f8c7 1260 	str.w	r1, [r7, #608]	@ 0x260
3400ee3e:	f003 0304 	and.w	r3, r3, #4
3400ee42:	f8c7 3264 	str.w	r3, [r7, #612]	@ 0x264
3400ee46:	e9d7 0198 	ldrd	r0, r1, [r7, #608]	@ 0x260
3400ee4a:	4603      	mov	r3, r0
3400ee4c:	460a      	mov	r2, r1
3400ee4e:	4313      	orrs	r3, r2
3400ee50:	f040 8152 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ee54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee58:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ee5c:	2100      	movs	r1, #0
3400ee5e:	f8c7 1258 	str.w	r1, [r7, #600]	@ 0x258
3400ee62:	f003 0308 	and.w	r3, r3, #8
3400ee66:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
3400ee6a:	e9d7 0196 	ldrd	r0, r1, [r7, #600]	@ 0x258
3400ee6e:	4603      	mov	r3, r0
3400ee70:	460a      	mov	r2, r1
3400ee72:	4313      	orrs	r3, r2
3400ee74:	f040 8140 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ee78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ee7c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ee80:	2100      	movs	r1, #0
3400ee82:	f8c7 1250 	str.w	r1, [r7, #592]	@ 0x250
3400ee86:	f003 0310 	and.w	r3, r3, #16
3400ee8a:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
3400ee8e:	e9d7 0194 	ldrd	r0, r1, [r7, #592]	@ 0x250
3400ee92:	4603      	mov	r3, r0
3400ee94:	460a      	mov	r2, r1
3400ee96:	4313      	orrs	r3, r2
3400ee98:	f040 812e 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ee9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eea0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eea4:	2100      	movs	r1, #0
3400eea6:	f8c7 1248 	str.w	r1, [r7, #584]	@ 0x248
3400eeaa:	f003 0320 	and.w	r3, r3, #32
3400eeae:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
3400eeb2:	e9d7 0192 	ldrd	r0, r1, [r7, #584]	@ 0x248
3400eeb6:	4603      	mov	r3, r0
3400eeb8:	460a      	mov	r2, r1
3400eeba:	4313      	orrs	r3, r2
3400eebc:	f040 811c 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eec0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eec4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eec8:	2100      	movs	r1, #0
3400eeca:	f8c7 1240 	str.w	r1, [r7, #576]	@ 0x240
3400eece:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400eed2:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
3400eed6:	e9d7 0190 	ldrd	r0, r1, [r7, #576]	@ 0x240
3400eeda:	4603      	mov	r3, r0
3400eedc:	460a      	mov	r2, r1
3400eede:	4313      	orrs	r3, r2
3400eee0:	f040 810a 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400eee4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400eee8:	e9d3 2300 	ldrd	r2, r3, [r3]
3400eeec:	2100      	movs	r1, #0
3400eeee:	f8c7 1238 	str.w	r1, [r7, #568]	@ 0x238
3400eef2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400eef6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
3400eefa:	e9d7 018e 	ldrd	r0, r1, [r7, #568]	@ 0x238
3400eefe:	4603      	mov	r3, r0
3400ef00:	460a      	mov	r2, r1
3400ef02:	4313      	orrs	r3, r2
3400ef04:	f040 80f8 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ef08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef0c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ef10:	2100      	movs	r1, #0
3400ef12:	f8c7 1230 	str.w	r1, [r7, #560]	@ 0x230
3400ef16:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400ef1a:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
3400ef1e:	e9d7 018c 	ldrd	r0, r1, [r7, #560]	@ 0x230
3400ef22:	4603      	mov	r3, r0
3400ef24:	460a      	mov	r2, r1
3400ef26:	4313      	orrs	r3, r2
3400ef28:	f040 80e6 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ef2c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef30:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ef34:	2100      	movs	r1, #0
3400ef36:	f8c7 1228 	str.w	r1, [r7, #552]	@ 0x228
3400ef3a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400ef3e:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
3400ef42:	e9d7 018a 	ldrd	r0, r1, [r7, #552]	@ 0x228
3400ef46:	4603      	mov	r3, r0
3400ef48:	460a      	mov	r2, r1
3400ef4a:	4313      	orrs	r3, r2
3400ef4c:	f040 80d4 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ef50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef54:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ef58:	2100      	movs	r1, #0
3400ef5a:	f8c7 1220 	str.w	r1, [r7, #544]	@ 0x220
3400ef5e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400ef62:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
3400ef66:	e9d7 0188 	ldrd	r0, r1, [r7, #544]	@ 0x220
3400ef6a:	4603      	mov	r3, r0
3400ef6c:	460a      	mov	r2, r1
3400ef6e:	4313      	orrs	r3, r2
3400ef70:	f040 80c2 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ef74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef78:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ef7c:	2100      	movs	r1, #0
3400ef7e:	f8c7 1218 	str.w	r1, [r7, #536]	@ 0x218
3400ef82:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400ef86:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
3400ef8a:	e9d7 0186 	ldrd	r0, r1, [r7, #536]	@ 0x218
3400ef8e:	4603      	mov	r3, r0
3400ef90:	460a      	mov	r2, r1
3400ef92:	4313      	orrs	r3, r2
3400ef94:	f040 80b0 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400ef98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ef9c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400efa0:	2100      	movs	r1, #0
3400efa2:	f8c7 1210 	str.w	r1, [r7, #528]	@ 0x210
3400efa6:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400efaa:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
3400efae:	e9d7 0184 	ldrd	r0, r1, [r7, #528]	@ 0x210
3400efb2:	4603      	mov	r3, r0
3400efb4:	460a      	mov	r2, r1
3400efb6:	4313      	orrs	r3, r2
3400efb8:	f040 809e 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400efbc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400efc0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400efc4:	2100      	movs	r1, #0
3400efc6:	f8c7 1208 	str.w	r1, [r7, #520]	@ 0x208
3400efca:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400efce:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
3400efd2:	e9d7 0182 	ldrd	r0, r1, [r7, #520]	@ 0x208
3400efd6:	4603      	mov	r3, r0
3400efd8:	460a      	mov	r2, r1
3400efda:	4313      	orrs	r3, r2
3400efdc:	f040 808c 	bne.w	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400efe0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400efe4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400efe8:	2100      	movs	r1, #0
3400efea:	f8c7 1200 	str.w	r1, [r7, #512]	@ 0x200
3400efee:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400eff2:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
3400eff6:	e9d7 0180 	ldrd	r0, r1, [r7, #512]	@ 0x200
3400effa:	4603      	mov	r3, r0
3400effc:	460a      	mov	r2, r1
3400effe:	4313      	orrs	r3, r2
3400f000:	d17a      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f002:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f006:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f00a:	2100      	movs	r1, #0
3400f00c:	f8c7 11f8 	str.w	r1, [r7, #504]	@ 0x1f8
3400f010:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400f014:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
3400f018:	e9d7 017e 	ldrd	r0, r1, [r7, #504]	@ 0x1f8
3400f01c:	4603      	mov	r3, r0
3400f01e:	460a      	mov	r2, r1
3400f020:	4313      	orrs	r3, r2
3400f022:	d169      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f024:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f028:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f02c:	2100      	movs	r1, #0
3400f02e:	f8c7 11f0 	str.w	r1, [r7, #496]	@ 0x1f0
3400f032:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400f036:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
3400f03a:	e9d7 017c 	ldrd	r0, r1, [r7, #496]	@ 0x1f0
3400f03e:	4603      	mov	r3, r0
3400f040:	460a      	mov	r2, r1
3400f042:	4313      	orrs	r3, r2
3400f044:	d158      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f046:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f04a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f04e:	2100      	movs	r1, #0
3400f050:	f8c7 11e8 	str.w	r1, [r7, #488]	@ 0x1e8
3400f054:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400f058:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
3400f05c:	e9d7 017a 	ldrd	r0, r1, [r7, #488]	@ 0x1e8
3400f060:	4603      	mov	r3, r0
3400f062:	460a      	mov	r2, r1
3400f064:	4313      	orrs	r3, r2
3400f066:	d147      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f068:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f06c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f070:	2100      	movs	r1, #0
3400f072:	f8c7 11e0 	str.w	r1, [r7, #480]	@ 0x1e0
3400f076:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400f07a:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
3400f07e:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
3400f082:	4603      	mov	r3, r0
3400f084:	460a      	mov	r2, r1
3400f086:	4313      	orrs	r3, r2
3400f088:	d136      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f08a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f08e:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f092:	2100      	movs	r1, #0
3400f094:	f8c7 11d8 	str.w	r1, [r7, #472]	@ 0x1d8
3400f098:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3400f09c:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
3400f0a0:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
3400f0a4:	4603      	mov	r3, r0
3400f0a6:	460a      	mov	r2, r1
3400f0a8:	4313      	orrs	r3, r2
3400f0aa:	d125      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f0ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0b0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f0b4:	2100      	movs	r1, #0
3400f0b6:	f8c7 11d0 	str.w	r1, [r7, #464]	@ 0x1d0
3400f0ba:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3400f0be:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
3400f0c2:	e9d7 0174 	ldrd	r0, r1, [r7, #464]	@ 0x1d0
3400f0c6:	4603      	mov	r3, r0
3400f0c8:	460a      	mov	r2, r1
3400f0ca:	4313      	orrs	r3, r2
3400f0cc:	d114      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f0ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0d2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f0d6:	2100      	movs	r1, #0
3400f0d8:	f8c7 11c8 	str.w	r1, [r7, #456]	@ 0x1c8
3400f0dc:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400f0e0:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
3400f0e4:	e9d7 0172 	ldrd	r0, r1, [r7, #456]	@ 0x1c8
3400f0e8:	4603      	mov	r3, r0
3400f0ea:	460a      	mov	r2, r1
3400f0ec:	4313      	orrs	r3, r2
3400f0ee:	d103      	bne.n	3400f0f8 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
3400f0f0:	2193      	movs	r1, #147	@ 0x93
3400f0f2:	48d3      	ldr	r0, [pc, #844]	@ (3400f440 <HAL_RCCEx_PeriphCLKConfig+0xb38>)
3400f0f4:	f7f2 f8d0 	bl	34001298 <assert_failed>

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400f0f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f0fc:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f100:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
3400f104:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
3400f108:	2300      	movs	r3, #0
3400f10a:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
3400f10e:	e9d7 0170 	ldrd	r0, r1, [r7, #448]	@ 0x1c0
3400f112:	4603      	mov	r3, r0
3400f114:	460a      	mov	r2, r1
3400f116:	4313      	orrs	r3, r2
3400f118:	f000 82b5 	beq.w	3400f686 <HAL_RCCEx_PeriphCLKConfig+0xd7e>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
3400f11c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f120:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f124:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f128:	f000 8240 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f12c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f130:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f134:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400f138:	f000 8238 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f13c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f140:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f144:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400f148:	f000 8230 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f14c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f150:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f154:	f5b3 5f98 	cmp.w	r3, #4864	@ 0x1300
3400f158:	f000 8228 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f15c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f160:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f164:	f5b3 5f0c 	cmp.w	r3, #8960	@ 0x2300
3400f168:	f000 8220 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f16c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f170:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f174:	f5b3 5f4c 	cmp.w	r3, #13056	@ 0x3300
3400f178:	f000 8218 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f17c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f180:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f184:	f5b3 4f86 	cmp.w	r3, #17152	@ 0x4300
3400f188:	f000 8210 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f18c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f190:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f194:	f5b3 4fa6 	cmp.w	r3, #21248	@ 0x5300
3400f198:	f000 8208 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f19c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1a0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f1a4:	f5b3 4fc6 	cmp.w	r3, #25344	@ 0x6300
3400f1a8:	f000 8200 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f1ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1b0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f1b4:	f5b3 4fe6 	cmp.w	r3, #29440	@ 0x7300
3400f1b8:	f000 81f8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f1bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1c0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f1c4:	f5b3 4f03 	cmp.w	r3, #33536	@ 0x8300
3400f1c8:	f000 81f0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f1cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1d0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f1d4:	f5b3 4f13 	cmp.w	r3, #37632	@ 0x9300
3400f1d8:	f000 81e8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f1dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1e0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f1e4:	f5b3 4f23 	cmp.w	r3, #41728	@ 0xa300
3400f1e8:	f000 81e0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f1ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f1f0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f1f4:	f5b3 4f33 	cmp.w	r3, #45824	@ 0xb300
3400f1f8:	f000 81d8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f1fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f200:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f204:	f5b3 4f43 	cmp.w	r3, #49920	@ 0xc300
3400f208:	f000 81d0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f20c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f210:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f214:	f5b3 4f53 	cmp.w	r3, #54016	@ 0xd300
3400f218:	f000 81c8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f21c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f220:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f224:	f5b3 4f63 	cmp.w	r3, #58112	@ 0xe300
3400f228:	f000 81c0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f22c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f230:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f234:	f5b3 4f73 	cmp.w	r3, #62208	@ 0xf300
3400f238:	f000 81b8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f23c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f240:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f244:	4b7f      	ldr	r3, [pc, #508]	@ (3400f444 <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
3400f246:	429a      	cmp	r2, r3
3400f248:	f000 81b0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f24c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f250:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f254:	4b7c      	ldr	r3, [pc, #496]	@ (3400f448 <HAL_RCCEx_PeriphCLKConfig+0xb40>)
3400f256:	429a      	cmp	r2, r3
3400f258:	f000 81a8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f25c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f260:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f264:	4b79      	ldr	r3, [pc, #484]	@ (3400f44c <HAL_RCCEx_PeriphCLKConfig+0xb44>)
3400f266:	429a      	cmp	r2, r3
3400f268:	f000 81a0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f26c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f270:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f274:	4b76      	ldr	r3, [pc, #472]	@ (3400f450 <HAL_RCCEx_PeriphCLKConfig+0xb48>)
3400f276:	429a      	cmp	r2, r3
3400f278:	f000 8198 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f27c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f280:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f284:	4b73      	ldr	r3, [pc, #460]	@ (3400f454 <HAL_RCCEx_PeriphCLKConfig+0xb4c>)
3400f286:	429a      	cmp	r2, r3
3400f288:	f000 8190 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f28c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f290:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f294:	4b70      	ldr	r3, [pc, #448]	@ (3400f458 <HAL_RCCEx_PeriphCLKConfig+0xb50>)
3400f296:	429a      	cmp	r2, r3
3400f298:	f000 8188 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f29c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2a0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f2a4:	4b6d      	ldr	r3, [pc, #436]	@ (3400f45c <HAL_RCCEx_PeriphCLKConfig+0xb54>)
3400f2a6:	429a      	cmp	r2, r3
3400f2a8:	f000 8180 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f2ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2b0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f2b4:	4b6a      	ldr	r3, [pc, #424]	@ (3400f460 <HAL_RCCEx_PeriphCLKConfig+0xb58>)
3400f2b6:	429a      	cmp	r2, r3
3400f2b8:	f000 8178 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f2bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2c0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f2c4:	4b67      	ldr	r3, [pc, #412]	@ (3400f464 <HAL_RCCEx_PeriphCLKConfig+0xb5c>)
3400f2c6:	429a      	cmp	r2, r3
3400f2c8:	f000 8170 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f2cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2d0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f2d4:	4b64      	ldr	r3, [pc, #400]	@ (3400f468 <HAL_RCCEx_PeriphCLKConfig+0xb60>)
3400f2d6:	429a      	cmp	r2, r3
3400f2d8:	f000 8168 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f2dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2e0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f2e4:	4b61      	ldr	r3, [pc, #388]	@ (3400f46c <HAL_RCCEx_PeriphCLKConfig+0xb64>)
3400f2e6:	429a      	cmp	r2, r3
3400f2e8:	f000 8160 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f2ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f2f0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f2f4:	4b5e      	ldr	r3, [pc, #376]	@ (3400f470 <HAL_RCCEx_PeriphCLKConfig+0xb68>)
3400f2f6:	429a      	cmp	r2, r3
3400f2f8:	f000 8158 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f2fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f300:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f304:	4b5b      	ldr	r3, [pc, #364]	@ (3400f474 <HAL_RCCEx_PeriphCLKConfig+0xb6c>)
3400f306:	429a      	cmp	r2, r3
3400f308:	f000 8150 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f30c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f310:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f314:	4b58      	ldr	r3, [pc, #352]	@ (3400f478 <HAL_RCCEx_PeriphCLKConfig+0xb70>)
3400f316:	429a      	cmp	r2, r3
3400f318:	f000 8148 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f31c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f320:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f324:	4b55      	ldr	r3, [pc, #340]	@ (3400f47c <HAL_RCCEx_PeriphCLKConfig+0xb74>)
3400f326:	429a      	cmp	r2, r3
3400f328:	f000 8140 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f32c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f330:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f334:	4b52      	ldr	r3, [pc, #328]	@ (3400f480 <HAL_RCCEx_PeriphCLKConfig+0xb78>)
3400f336:	429a      	cmp	r2, r3
3400f338:	f000 8138 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f33c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f340:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f344:	4b4f      	ldr	r3, [pc, #316]	@ (3400f484 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
3400f346:	429a      	cmp	r2, r3
3400f348:	f000 8130 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f34c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f350:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f354:	4b4c      	ldr	r3, [pc, #304]	@ (3400f488 <HAL_RCCEx_PeriphCLKConfig+0xb80>)
3400f356:	429a      	cmp	r2, r3
3400f358:	f000 8128 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f35c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f360:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f364:	4b49      	ldr	r3, [pc, #292]	@ (3400f48c <HAL_RCCEx_PeriphCLKConfig+0xb84>)
3400f366:	429a      	cmp	r2, r3
3400f368:	f000 8120 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f36c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f370:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f374:	4b46      	ldr	r3, [pc, #280]	@ (3400f490 <HAL_RCCEx_PeriphCLKConfig+0xb88>)
3400f376:	429a      	cmp	r2, r3
3400f378:	f000 8118 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f37c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f380:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f384:	4b43      	ldr	r3, [pc, #268]	@ (3400f494 <HAL_RCCEx_PeriphCLKConfig+0xb8c>)
3400f386:	429a      	cmp	r2, r3
3400f388:	f000 8110 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f38c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f390:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f394:	4b40      	ldr	r3, [pc, #256]	@ (3400f498 <HAL_RCCEx_PeriphCLKConfig+0xb90>)
3400f396:	429a      	cmp	r2, r3
3400f398:	f000 8108 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f39c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3a0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f3a4:	4b3d      	ldr	r3, [pc, #244]	@ (3400f49c <HAL_RCCEx_PeriphCLKConfig+0xb94>)
3400f3a6:	429a      	cmp	r2, r3
3400f3a8:	f000 8100 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f3ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3b0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f3b4:	4b3a      	ldr	r3, [pc, #232]	@ (3400f4a0 <HAL_RCCEx_PeriphCLKConfig+0xb98>)
3400f3b6:	429a      	cmp	r2, r3
3400f3b8:	f000 80f8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f3bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3c0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f3c4:	4b37      	ldr	r3, [pc, #220]	@ (3400f4a4 <HAL_RCCEx_PeriphCLKConfig+0xb9c>)
3400f3c6:	429a      	cmp	r2, r3
3400f3c8:	f000 80f0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f3cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3d0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f3d4:	4b34      	ldr	r3, [pc, #208]	@ (3400f4a8 <HAL_RCCEx_PeriphCLKConfig+0xba0>)
3400f3d6:	429a      	cmp	r2, r3
3400f3d8:	f000 80e8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f3dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3e0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f3e4:	4b31      	ldr	r3, [pc, #196]	@ (3400f4ac <HAL_RCCEx_PeriphCLKConfig+0xba4>)
3400f3e6:	429a      	cmp	r2, r3
3400f3e8:	f000 80e0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f3ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f3f0:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f3f4:	4b2e      	ldr	r3, [pc, #184]	@ (3400f4b0 <HAL_RCCEx_PeriphCLKConfig+0xba8>)
3400f3f6:	429a      	cmp	r2, r3
3400f3f8:	f000 80d8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f3fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f400:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f404:	4b2b      	ldr	r3, [pc, #172]	@ (3400f4b4 <HAL_RCCEx_PeriphCLKConfig+0xbac>)
3400f406:	429a      	cmp	r2, r3
3400f408:	f000 80d0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f40c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f410:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f414:	4b28      	ldr	r3, [pc, #160]	@ (3400f4b8 <HAL_RCCEx_PeriphCLKConfig+0xbb0>)
3400f416:	429a      	cmp	r2, r3
3400f418:	f000 80c8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f41c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f420:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f424:	4b25      	ldr	r3, [pc, #148]	@ (3400f4bc <HAL_RCCEx_PeriphCLKConfig+0xbb4>)
3400f426:	429a      	cmp	r2, r3
3400f428:	f000 80c0 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f42c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f430:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f434:	4b22      	ldr	r3, [pc, #136]	@ (3400f4c0 <HAL_RCCEx_PeriphCLKConfig+0xbb8>)
3400f436:	429a      	cmp	r2, r3
3400f438:	f000 80b8 	beq.w	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f43c:	e042      	b.n	3400f4c4 <HAL_RCCEx_PeriphCLKConfig+0xbbc>
3400f43e:	bf00      	nop
3400f440:	3402444c 	.word	0x3402444c
3400f444:	00010300 	.word	0x00010300
3400f448:	00011300 	.word	0x00011300
3400f44c:	00012300 	.word	0x00012300
3400f450:	00013300 	.word	0x00013300
3400f454:	00014300 	.word	0x00014300
3400f458:	00015300 	.word	0x00015300
3400f45c:	00016300 	.word	0x00016300
3400f460:	00017300 	.word	0x00017300
3400f464:	00018300 	.word	0x00018300
3400f468:	00019300 	.word	0x00019300
3400f46c:	0001a300 	.word	0x0001a300
3400f470:	0001b300 	.word	0x0001b300
3400f474:	0001c300 	.word	0x0001c300
3400f478:	0001d300 	.word	0x0001d300
3400f47c:	0001e300 	.word	0x0001e300
3400f480:	0001f300 	.word	0x0001f300
3400f484:	00020300 	.word	0x00020300
3400f488:	00021300 	.word	0x00021300
3400f48c:	00022300 	.word	0x00022300
3400f490:	00023300 	.word	0x00023300
3400f494:	00024300 	.word	0x00024300
3400f498:	00025300 	.word	0x00025300
3400f49c:	00026300 	.word	0x00026300
3400f4a0:	00027300 	.word	0x00027300
3400f4a4:	00028300 	.word	0x00028300
3400f4a8:	00029300 	.word	0x00029300
3400f4ac:	0002a300 	.word	0x0002a300
3400f4b0:	0002b300 	.word	0x0002b300
3400f4b4:	0002c300 	.word	0x0002c300
3400f4b8:	0002d300 	.word	0x0002d300
3400f4bc:	0002e300 	.word	0x0002e300
3400f4c0:	0002f300 	.word	0x0002f300
3400f4c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4c8:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f4cc:	4bb4      	ldr	r3, [pc, #720]	@ (3400f7a0 <HAL_RCCEx_PeriphCLKConfig+0xe98>)
3400f4ce:	429a      	cmp	r2, r3
3400f4d0:	d06c      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f4d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4d6:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f4da:	4bb2      	ldr	r3, [pc, #712]	@ (3400f7a4 <HAL_RCCEx_PeriphCLKConfig+0xe9c>)
3400f4dc:	429a      	cmp	r2, r3
3400f4de:	d065      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f4e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4e4:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f4e8:	4baf      	ldr	r3, [pc, #700]	@ (3400f7a8 <HAL_RCCEx_PeriphCLKConfig+0xea0>)
3400f4ea:	429a      	cmp	r2, r3
3400f4ec:	d05e      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f4ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f4f2:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f4f6:	4bad      	ldr	r3, [pc, #692]	@ (3400f7ac <HAL_RCCEx_PeriphCLKConfig+0xea4>)
3400f4f8:	429a      	cmp	r2, r3
3400f4fa:	d057      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f4fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f500:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f504:	4baa      	ldr	r3, [pc, #680]	@ (3400f7b0 <HAL_RCCEx_PeriphCLKConfig+0xea8>)
3400f506:	429a      	cmp	r2, r3
3400f508:	d050      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f50a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f50e:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f512:	4ba8      	ldr	r3, [pc, #672]	@ (3400f7b4 <HAL_RCCEx_PeriphCLKConfig+0xeac>)
3400f514:	429a      	cmp	r2, r3
3400f516:	d049      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f518:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f51c:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f520:	4ba5      	ldr	r3, [pc, #660]	@ (3400f7b8 <HAL_RCCEx_PeriphCLKConfig+0xeb0>)
3400f522:	429a      	cmp	r2, r3
3400f524:	d042      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f526:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f52a:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f52e:	4ba3      	ldr	r3, [pc, #652]	@ (3400f7bc <HAL_RCCEx_PeriphCLKConfig+0xeb4>)
3400f530:	429a      	cmp	r2, r3
3400f532:	d03b      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f534:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f538:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f53c:	4ba0      	ldr	r3, [pc, #640]	@ (3400f7c0 <HAL_RCCEx_PeriphCLKConfig+0xeb8>)
3400f53e:	429a      	cmp	r2, r3
3400f540:	d034      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f542:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f546:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f54a:	4b9e      	ldr	r3, [pc, #632]	@ (3400f7c4 <HAL_RCCEx_PeriphCLKConfig+0xebc>)
3400f54c:	429a      	cmp	r2, r3
3400f54e:	d02d      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f550:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f554:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f558:	4b9b      	ldr	r3, [pc, #620]	@ (3400f7c8 <HAL_RCCEx_PeriphCLKConfig+0xec0>)
3400f55a:	429a      	cmp	r2, r3
3400f55c:	d026      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f55e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f562:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f566:	4b99      	ldr	r3, [pc, #612]	@ (3400f7cc <HAL_RCCEx_PeriphCLKConfig+0xec4>)
3400f568:	429a      	cmp	r2, r3
3400f56a:	d01f      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f56c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f570:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f574:	4b96      	ldr	r3, [pc, #600]	@ (3400f7d0 <HAL_RCCEx_PeriphCLKConfig+0xec8>)
3400f576:	429a      	cmp	r2, r3
3400f578:	d018      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f57a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f57e:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f582:	4b94      	ldr	r3, [pc, #592]	@ (3400f7d4 <HAL_RCCEx_PeriphCLKConfig+0xecc>)
3400f584:	429a      	cmp	r2, r3
3400f586:	d011      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f588:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f58c:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f590:	4b91      	ldr	r3, [pc, #580]	@ (3400f7d8 <HAL_RCCEx_PeriphCLKConfig+0xed0>)
3400f592:	429a      	cmp	r2, r3
3400f594:	d00a      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f596:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f59a:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
3400f59e:	4b8f      	ldr	r3, [pc, #572]	@ (3400f7dc <HAL_RCCEx_PeriphCLKConfig+0xed4>)
3400f5a0:	429a      	cmp	r2, r3
3400f5a2:	d003      	beq.n	3400f5ac <HAL_RCCEx_PeriphCLKConfig+0xca4>
3400f5a4:	2199      	movs	r1, #153	@ 0x99
3400f5a6:	488e      	ldr	r0, [pc, #568]	@ (3400f7e0 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400f5a8:	f7f1 fe76 	bl	34001298 <assert_failed>

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
3400f5ac:	f7fe fae2 	bl	3400db74 <LL_RCC_GetRTCClockSource>
3400f5b0:	f8c7 0388 	str.w	r0, [r7, #904]	@ 0x388

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400f5b4:	f8d7 3388 	ldr.w	r3, [r7, #904]	@ 0x388
3400f5b8:	2b00      	cmp	r3, #0
3400f5ba:	d018      	beq.n	3400f5ee <HAL_RCCEx_PeriphCLKConfig+0xce6>
3400f5bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f5c0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f5c4:	f403 7240 	and.w	r2, r3, #768	@ 0x300
3400f5c8:	f8d7 3388 	ldr.w	r3, [r7, #904]	@ 0x388
3400f5cc:	4293      	cmp	r3, r2
3400f5ce:	d00e      	beq.n	3400f5ee <HAL_RCCEx_PeriphCLKConfig+0xce6>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3400f5d0:	4b84      	ldr	r3, [pc, #528]	@ (3400f7e4 <HAL_RCCEx_PeriphCLKConfig+0xedc>)
3400f5d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400f5d4:	4a83      	ldr	r2, [pc, #524]	@ (3400f7e4 <HAL_RCCEx_PeriphCLKConfig+0xedc>)
3400f5d6:	f043 0301 	orr.w	r3, r3, #1
3400f5da:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3400f5dc:	4b81      	ldr	r3, [pc, #516]	@ (3400f7e4 <HAL_RCCEx_PeriphCLKConfig+0xedc>)
3400f5de:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400f5e0:	f003 0301 	and.w	r3, r3, #1
3400f5e4:	2b00      	cmp	r3, #0
3400f5e6:	d102      	bne.n	3400f5ee <HAL_RCCEx_PeriphCLKConfig+0xce6>
      {
        ret = HAL_ERROR;
3400f5e8:	2301      	movs	r3, #1
3400f5ea:	f887 338f 	strb.w	r3, [r7, #911]	@ 0x38f
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
3400f5ee:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400f5f2:	2b00      	cmp	r3, #0
3400f5f4:	d143      	bne.n	3400f67e <HAL_RCCEx_PeriphCLKConfig+0xd76>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3400f5f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f5fa:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f5fe:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f602:	d117      	bne.n	3400f634 <HAL_RCCEx_PeriphCLKConfig+0xd2c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400f604:	f7f7 ffec 	bl	340075e0 <HAL_GetTick>
3400f608:	f8c7 0384 	str.w	r0, [r7, #900]	@ 0x384

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
3400f60c:	e00d      	b.n	3400f62a <HAL_RCCEx_PeriphCLKConfig+0xd22>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400f60e:	f7f7 ffe7 	bl	340075e0 <HAL_GetTick>
3400f612:	4602      	mov	r2, r0
3400f614:	f8d7 3384 	ldr.w	r3, [r7, #900]	@ 0x384
3400f618:	1ad2      	subs	r2, r2, r3
3400f61a:	f241 3388 	movw	r3, #5000	@ 0x1388
3400f61e:	429a      	cmp	r2, r3
3400f620:	d903      	bls.n	3400f62a <HAL_RCCEx_PeriphCLKConfig+0xd22>
          {
            ret = HAL_TIMEOUT;
3400f622:	2303      	movs	r3, #3
3400f624:	f887 338f 	strb.w	r3, [r7, #911]	@ 0x38f
            break;
3400f628:	e004      	b.n	3400f634 <HAL_RCCEx_PeriphCLKConfig+0xd2c>
        while (LL_RCC_LSE_IsReady() == 0U)
3400f62a:	f7fd feb5 	bl	3400d398 <LL_RCC_LSE_IsReady>
3400f62e:	4603      	mov	r3, r0
3400f630:	2b00      	cmp	r3, #0
3400f632:	d0ec      	beq.n	3400f60e <HAL_RCCEx_PeriphCLKConfig+0xd06>
          }
        }
      }

      if (ret == HAL_OK)
3400f634:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400f638:	2b00      	cmp	r3, #0
3400f63a:	d11b      	bne.n	3400f674 <HAL_RCCEx_PeriphCLKConfig+0xd6c>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3400f63c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f640:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f644:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3400f648:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400f64c:	d108      	bne.n	3400f660 <HAL_RCCEx_PeriphCLKConfig+0xd58>
3400f64e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f652:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f656:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400f65a:	4618      	mov	r0, r3
3400f65c:	f7fe fa98 	bl	3400db90 <LL_RCC_SetRTC_HSEPrescaler>
3400f660:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f664:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400f668:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3400f66c:	4618      	mov	r0, r3
3400f66e:	f7fe fa6b 	bl	3400db48 <LL_RCC_SetRTCClockSource>
3400f672:	e008      	b.n	3400f686 <HAL_RCCEx_PeriphCLKConfig+0xd7e>
      }
      else
      {
        /* set overall return value */
        status = ret;
3400f674:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400f678:	f887 338e 	strb.w	r3, [r7, #910]	@ 0x38e
3400f67c:	e003      	b.n	3400f686 <HAL_RCCEx_PeriphCLKConfig+0xd7e>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
3400f67e:	f897 338f 	ldrb.w	r3, [r7, #911]	@ 0x38f
3400f682:	f887 338e 	strb.w	r3, [r7, #910]	@ 0x38e
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3400f686:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f68a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400f68e:	f002 0304 	and.w	r3, r2, #4
3400f692:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
3400f696:	2300      	movs	r3, #0
3400f698:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
3400f69c:	e9d7 016e 	ldrd	r0, r1, [r7, #440]	@ 0x1b8
3400f6a0:	4603      	mov	r3, r0
3400f6a2:	460a      	mov	r2, r1
3400f6a4:	4313      	orrs	r3, r2
3400f6a6:	f000 81dc 	beq.w	3400fa62 <HAL_RCCEx_PeriphCLKConfig+0x115a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));
3400f6aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6ae:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6b2:	2b00      	cmp	r3, #0
3400f6b4:	d02d      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6ba:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6be:	2b01      	cmp	r3, #1
3400f6c0:	d027      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6c6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6ca:	2b02      	cmp	r3, #2
3400f6cc:	d021      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6d2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6d6:	2b03      	cmp	r3, #3
3400f6d8:	d01b      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6de:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6e2:	2b04      	cmp	r3, #4
3400f6e4:	d015      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6ea:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6ee:	2b05      	cmp	r3, #5
3400f6f0:	d00f      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f6f6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f6fa:	2b06      	cmp	r3, #6
3400f6fc:	d009      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f6fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f702:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f706:	2b07      	cmp	r3, #7
3400f708:	d003      	beq.n	3400f712 <HAL_RCCEx_PeriphCLKConfig+0xe0a>
3400f70a:	21df      	movs	r1, #223	@ 0xdf
3400f70c:	4834      	ldr	r0, [pc, #208]	@ (3400f7e0 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400f70e:	f7f1 fdc3 	bl	34001298 <assert_failed>

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3400f712:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f716:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f71a:	2b04      	cmp	r3, #4
3400f71c:	d166      	bne.n	3400f7ec <HAL_RCCEx_PeriphCLKConfig+0xee4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400f71e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f722:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400f724:	2b00      	cmp	r3, #0
3400f726:	d015      	beq.n	3400f754 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400f728:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f72c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400f72e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f732:	d00f      	beq.n	3400f754 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400f734:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f738:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400f73a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f73e:	d009      	beq.n	3400f754 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400f740:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f744:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400f746:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f74a:	d003      	beq.n	3400f754 <HAL_RCCEx_PeriphCLKConfig+0xe4c>
3400f74c:	21e4      	movs	r1, #228	@ 0xe4
3400f74e:	4824      	ldr	r0, [pc, #144]	@ (3400f7e0 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400f750:	f7f1 fda2 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400f754:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f758:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400f75a:	2b00      	cmp	r3, #0
3400f75c:	d005      	beq.n	3400f76a <HAL_RCCEx_PeriphCLKConfig+0xe62>
3400f75e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f762:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400f764:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f768:	d903      	bls.n	3400f772 <HAL_RCCEx_PeriphCLKConfig+0xe6a>
3400f76a:	21e5      	movs	r1, #229	@ 0xe5
3400f76c:	481c      	ldr	r0, [pc, #112]	@ (3400f7e0 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
3400f76e:	f7f1 fd93 	bl	34001298 <assert_failed>

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400f772:	4b1d      	ldr	r3, [pc, #116]	@ (3400f7e8 <HAL_RCCEx_PeriphCLKConfig+0xee0>)
3400f774:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400f778:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f77c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f780:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f784:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400f786:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f78a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400f78c:	3b01      	subs	r3, #1
3400f78e:	041b      	lsls	r3, r3, #16
3400f790:	4313      	orrs	r3, r2
3400f792:	4a15      	ldr	r2, [pc, #84]	@ (3400f7e8 <HAL_RCCEx_PeriphCLKConfig+0xee0>)
3400f794:	430b      	orrs	r3, r1
3400f796:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3400f79a:	f7fe fd13 	bl	3400e1c4 <LL_RCC_IC5_Enable>
3400f79e:	e159      	b.n	3400fa54 <HAL_RCCEx_PeriphCLKConfig+0x114c>
3400f7a0:	00030300 	.word	0x00030300
3400f7a4:	00031300 	.word	0x00031300
3400f7a8:	00032300 	.word	0x00032300
3400f7ac:	00033300 	.word	0x00033300
3400f7b0:	00034300 	.word	0x00034300
3400f7b4:	00035300 	.word	0x00035300
3400f7b8:	00036300 	.word	0x00036300
3400f7bc:	00037300 	.word	0x00037300
3400f7c0:	00038300 	.word	0x00038300
3400f7c4:	00039300 	.word	0x00039300
3400f7c8:	0003a300 	.word	0x0003a300
3400f7cc:	0003b300 	.word	0x0003b300
3400f7d0:	0003c300 	.word	0x0003c300
3400f7d4:	0003d300 	.word	0x0003d300
3400f7d8:	0003e300 	.word	0x0003e300
3400f7dc:	0003f300 	.word	0x0003f300
3400f7e0:	3402444c 	.word	0x3402444c
3400f7e4:	56024800 	.word	0x56024800
3400f7e8:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
3400f7ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f7f0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f7f4:	2b05      	cmp	r3, #5
3400f7f6:	d140      	bne.n	3400f87a <HAL_RCCEx_PeriphCLKConfig+0xf72>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400f7f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f7fc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400f7fe:	2b00      	cmp	r3, #0
3400f800:	d015      	beq.n	3400f82e <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400f802:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f806:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400f808:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f80c:	d00f      	beq.n	3400f82e <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400f80e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f812:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400f814:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f818:	d009      	beq.n	3400f82e <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400f81a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f81e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400f820:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f824:	d003      	beq.n	3400f82e <HAL_RCCEx_PeriphCLKConfig+0xf26>
3400f826:	21f1      	movs	r1, #241	@ 0xf1
3400f828:	4860      	ldr	r0, [pc, #384]	@ (3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400f82a:	f7f1 fd35 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400f82e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f832:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400f834:	2b00      	cmp	r3, #0
3400f836:	d005      	beq.n	3400f844 <HAL_RCCEx_PeriphCLKConfig+0xf3c>
3400f838:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f83c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400f83e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f842:	d903      	bls.n	3400f84c <HAL_RCCEx_PeriphCLKConfig+0xf44>
3400f844:	21f2      	movs	r1, #242	@ 0xf2
3400f846:	4859      	ldr	r0, [pc, #356]	@ (3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400f848:	f7f1 fd26 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400f84c:	4b58      	ldr	r3, [pc, #352]	@ (3400f9b0 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400f84e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400f852:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f856:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f85a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f85e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400f860:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f864:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400f866:	3b01      	subs	r3, #1
3400f868:	041b      	lsls	r3, r3, #16
3400f86a:	4313      	orrs	r3, r2
3400f86c:	4a50      	ldr	r2, [pc, #320]	@ (3400f9b0 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400f86e:	430b      	orrs	r3, r1
3400f870:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400f874:	f7fe fda6 	bl	3400e3c4 <LL_RCC_IC10_Enable>
3400f878:	e0ec      	b.n	3400fa54 <HAL_RCCEx_PeriphCLKConfig+0x114c>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
3400f87a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f87e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f882:	2b06      	cmp	r3, #6
3400f884:	d140      	bne.n	3400f908 <HAL_RCCEx_PeriphCLKConfig+0x1000>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400f886:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f88a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400f88c:	2b00      	cmp	r3, #0
3400f88e:	d015      	beq.n	3400f8bc <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400f890:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f894:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400f896:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f89a:	d00f      	beq.n	3400f8bc <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400f89c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8a0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400f8a2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f8a6:	d009      	beq.n	3400f8bc <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400f8a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8ac:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400f8ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f8b2:	d003      	beq.n	3400f8bc <HAL_RCCEx_PeriphCLKConfig+0xfb4>
3400f8b4:	21fe      	movs	r1, #254	@ 0xfe
3400f8b6:	483d      	ldr	r0, [pc, #244]	@ (3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400f8b8:	f7f1 fcee 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400f8bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8c0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400f8c2:	2b00      	cmp	r3, #0
3400f8c4:	d005      	beq.n	3400f8d2 <HAL_RCCEx_PeriphCLKConfig+0xfca>
3400f8c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8ca:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400f8cc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f8d0:	d903      	bls.n	3400f8da <HAL_RCCEx_PeriphCLKConfig+0xfd2>
3400f8d2:	21ff      	movs	r1, #255	@ 0xff
3400f8d4:	4835      	ldr	r0, [pc, #212]	@ (3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400f8d6:	f7f1 fcdf 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400f8da:	4b35      	ldr	r3, [pc, #212]	@ (3400f9b0 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400f8dc:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400f8e0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f8e4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f8e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8ec:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400f8ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f8f2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400f8f4:	3b01      	subs	r3, #1
3400f8f6:	041b      	lsls	r3, r3, #16
3400f8f8:	4313      	orrs	r3, r2
3400f8fa:	4a2d      	ldr	r2, [pc, #180]	@ (3400f9b0 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400f8fc:	430b      	orrs	r3, r1
3400f8fe:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400f902:	f7fe fe5f 	bl	3400e5c4 <LL_RCC_IC15_Enable>
3400f906:	e0a5      	b.n	3400fa54 <HAL_RCCEx_PeriphCLKConfig+0x114c>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
3400f908:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f90c:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f910:	2b03      	cmp	r3, #3
3400f912:	d14f      	bne.n	3400f9b4 <HAL_RCCEx_PeriphCLKConfig+0x10ac>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400f914:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f918:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400f91c:	2b00      	cmp	r3, #0
3400f91e:	d019      	beq.n	3400f954 <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400f920:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f924:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400f928:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f92c:	d012      	beq.n	3400f954 <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400f92e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f932:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400f936:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f93a:	d00b      	beq.n	3400f954 <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400f93c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f940:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400f944:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f948:	d004      	beq.n	3400f954 <HAL_RCCEx_PeriphCLKConfig+0x104c>
3400f94a:	f240 110b 	movw	r1, #267	@ 0x10b
3400f94e:	4817      	ldr	r0, [pc, #92]	@ (3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400f950:	f7f1 fca2 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400f954:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f958:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400f95c:	2b00      	cmp	r3, #0
3400f95e:	d006      	beq.n	3400f96e <HAL_RCCEx_PeriphCLKConfig+0x1066>
3400f960:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f964:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400f968:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400f96c:	d904      	bls.n	3400f978 <HAL_RCCEx_PeriphCLKConfig+0x1070>
3400f96e:	f44f 7186 	mov.w	r1, #268	@ 0x10c
3400f972:	480e      	ldr	r0, [pc, #56]	@ (3400f9ac <HAL_RCCEx_PeriphCLKConfig+0x10a4>)
3400f974:	f7f1 fc90 	bl	34001298 <assert_failed>

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400f978:	4b0d      	ldr	r3, [pc, #52]	@ (3400f9b0 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400f97a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400f97e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400f982:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400f986:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f98a:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3400f98e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f992:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3400f996:	3b01      	subs	r3, #1
3400f998:	041b      	lsls	r3, r3, #16
3400f99a:	4313      	orrs	r3, r2
3400f99c:	4a04      	ldr	r2, [pc, #16]	@ (3400f9b0 <HAL_RCCEx_PeriphCLKConfig+0x10a8>)
3400f99e:	430b      	orrs	r3, r1
3400f9a0:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3400f9a4:	f7fe ff0e 	bl	3400e7c4 <LL_RCC_IC19_Enable>
3400f9a8:	e054      	b.n	3400fa54 <HAL_RCCEx_PeriphCLKConfig+0x114c>
3400f9aa:	bf00      	nop
3400f9ac:	3402444c 	.word	0x3402444c
3400f9b0:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3400f9b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9b8:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400f9bc:	2b07      	cmp	r3, #7
3400f9be:	d149      	bne.n	3400fa54 <HAL_RCCEx_PeriphCLKConfig+0x114c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400f9c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9c4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400f9c8:	2b00      	cmp	r3, #0
3400f9ca:	d019      	beq.n	3400fa00 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400f9cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9d0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400f9d4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f9d8:	d012      	beq.n	3400fa00 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400f9da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9de:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400f9e2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f9e6:	d00b      	beq.n	3400fa00 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400f9e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400f9ec:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400f9f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f9f4:	d004      	beq.n	3400fa00 <HAL_RCCEx_PeriphCLKConfig+0x10f8>
3400f9f6:	f44f 718c 	mov.w	r1, #280	@ 0x118
3400f9fa:	487d      	ldr	r0, [pc, #500]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400f9fc:	f7f1 fc4c 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400fa00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa04:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400fa08:	2b00      	cmp	r3, #0
3400fa0a:	d006      	beq.n	3400fa1a <HAL_RCCEx_PeriphCLKConfig+0x1112>
3400fa0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa10:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400fa14:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fa18:	d904      	bls.n	3400fa24 <HAL_RCCEx_PeriphCLKConfig+0x111c>
3400fa1a:	f240 1119 	movw	r1, #281	@ 0x119
3400fa1e:	4874      	ldr	r0, [pc, #464]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400fa20:	f7f1 fc3a 	bl	34001298 <assert_failed>

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400fa24:	4b73      	ldr	r3, [pc, #460]	@ (3400fbf4 <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400fa26:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400fa2a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fa2e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fa32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa36:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
3400fa3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa3e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400fa42:	3b01      	subs	r3, #1
3400fa44:	041b      	lsls	r3, r3, #16
3400fa46:	4313      	orrs	r3, r2
3400fa48:	4a6a      	ldr	r2, [pc, #424]	@ (3400fbf4 <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400fa4a:	430b      	orrs	r3, r1
3400fa4c:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3400fa50:	f7fe fef8 	bl	3400e844 <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3400fa54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa58:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400fa5c:	4618      	mov	r0, r3
3400fa5e:	f7fd fd4f 	bl	3400d500 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3400fa62:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa66:	e9d3 2300 	ldrd	r2, r3, [r3]
3400fa6a:	2100      	movs	r1, #0
3400fa6c:	f8c7 11b0 	str.w	r1, [r7, #432]	@ 0x1b0
3400fa70:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
3400fa74:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
3400fa78:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	@ 0x1b0
3400fa7c:	4603      	mov	r3, r0
3400fa7e:	460a      	mov	r2, r1
3400fa80:	4313      	orrs	r3, r2
3400fa82:	f000 80d1 	beq.w	3400fc28 <HAL_RCCEx_PeriphCLKConfig+0x1320>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));
3400fa86:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa8a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400fa8e:	4b5a      	ldr	r3, [pc, #360]	@ (3400fbf8 <HAL_RCCEx_PeriphCLKConfig+0x12f0>)
3400fa90:	429a      	cmp	r2, r3
3400fa92:	d019      	beq.n	3400fac8 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400fa94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fa98:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400fa9c:	4b57      	ldr	r3, [pc, #348]	@ (3400fbfc <HAL_RCCEx_PeriphCLKConfig+0x12f4>)
3400fa9e:	429a      	cmp	r2, r3
3400faa0:	d012      	beq.n	3400fac8 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400faa2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400faa6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400faaa:	4b55      	ldr	r3, [pc, #340]	@ (3400fc00 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
3400faac:	429a      	cmp	r2, r3
3400faae:	d00b      	beq.n	3400fac8 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400fab0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fab4:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400fab8:	4b52      	ldr	r3, [pc, #328]	@ (3400fc04 <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
3400faba:	429a      	cmp	r2, r3
3400fabc:	d004      	beq.n	3400fac8 <HAL_RCCEx_PeriphCLKConfig+0x11c0>
3400fabe:	f240 112f 	movw	r1, #303	@ 0x12f
3400fac2:	484b      	ldr	r0, [pc, #300]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400fac4:	f7f1 fbe8 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400fac8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400facc:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400fad0:	4b4b      	ldr	r3, [pc, #300]	@ (3400fc00 <HAL_RCCEx_PeriphCLKConfig+0x12f8>)
3400fad2:	429a      	cmp	r2, r3
3400fad4:	d142      	bne.n	3400fb5c <HAL_RCCEx_PeriphCLKConfig+0x1254>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400fad6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fada:	699b      	ldr	r3, [r3, #24]
3400fadc:	2b00      	cmp	r3, #0
3400fade:	d016      	beq.n	3400fb0e <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400fae0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fae4:	699b      	ldr	r3, [r3, #24]
3400fae6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400faea:	d010      	beq.n	3400fb0e <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400faec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400faf0:	699b      	ldr	r3, [r3, #24]
3400faf2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400faf6:	d00a      	beq.n	3400fb0e <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400faf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fafc:	699b      	ldr	r3, [r3, #24]
3400fafe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fb02:	d004      	beq.n	3400fb0e <HAL_RCCEx_PeriphCLKConfig+0x1206>
3400fb04:	f44f 719a 	mov.w	r1, #308	@ 0x134
3400fb08:	4839      	ldr	r0, [pc, #228]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400fb0a:	f7f1 fbc5 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400fb0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb12:	69db      	ldr	r3, [r3, #28]
3400fb14:	2b00      	cmp	r3, #0
3400fb16:	d005      	beq.n	3400fb24 <HAL_RCCEx_PeriphCLKConfig+0x121c>
3400fb18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb1c:	69db      	ldr	r3, [r3, #28]
3400fb1e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fb22:	d904      	bls.n	3400fb2e <HAL_RCCEx_PeriphCLKConfig+0x1226>
3400fb24:	f240 1135 	movw	r1, #309	@ 0x135
3400fb28:	4831      	ldr	r0, [pc, #196]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400fb2a:	f7f1 fbb5 	bl	34001298 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400fb2e:	4b31      	ldr	r3, [pc, #196]	@ (3400fbf4 <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400fb30:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400fb34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fb38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fb3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb40:	699a      	ldr	r2, [r3, #24]
3400fb42:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb46:	69db      	ldr	r3, [r3, #28]
3400fb48:	3b01      	subs	r3, #1
3400fb4a:	041b      	lsls	r3, r3, #16
3400fb4c:	4313      	orrs	r3, r2
3400fb4e:	4a29      	ldr	r2, [pc, #164]	@ (3400fbf4 <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400fb50:	430b      	orrs	r3, r1
3400fb52:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400fb56:	f7fe fab5 	bl	3400e0c4 <LL_RCC_IC3_Enable>
3400fb5a:	e05e      	b.n	3400fc1a <HAL_RCCEx_PeriphCLKConfig+0x1312>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3400fb5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb60:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400fb64:	4b27      	ldr	r3, [pc, #156]	@ (3400fc04 <HAL_RCCEx_PeriphCLKConfig+0x12fc>)
3400fb66:	429a      	cmp	r2, r3
3400fb68:	d14e      	bne.n	3400fc08 <HAL_RCCEx_PeriphCLKConfig+0x1300>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400fb6a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb6e:	6a1b      	ldr	r3, [r3, #32]
3400fb70:	2b00      	cmp	r3, #0
3400fb72:	d016      	beq.n	3400fba2 <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400fb74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb78:	6a1b      	ldr	r3, [r3, #32]
3400fb7a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fb7e:	d010      	beq.n	3400fba2 <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400fb80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb84:	6a1b      	ldr	r3, [r3, #32]
3400fb86:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fb8a:	d00a      	beq.n	3400fba2 <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400fb8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fb90:	6a1b      	ldr	r3, [r3, #32]
3400fb92:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fb96:	d004      	beq.n	3400fba2 <HAL_RCCEx_PeriphCLKConfig+0x129a>
3400fb98:	f240 1141 	movw	r1, #321	@ 0x141
3400fb9c:	4814      	ldr	r0, [pc, #80]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400fb9e:	f7f1 fb7b 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400fba2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fba6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fba8:	2b00      	cmp	r3, #0
3400fbaa:	d005      	beq.n	3400fbb8 <HAL_RCCEx_PeriphCLKConfig+0x12b0>
3400fbac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbb0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fbb2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fbb6:	d904      	bls.n	3400fbc2 <HAL_RCCEx_PeriphCLKConfig+0x12ba>
3400fbb8:	f44f 71a1 	mov.w	r1, #322	@ 0x142
3400fbbc:	480c      	ldr	r0, [pc, #48]	@ (3400fbf0 <HAL_RCCEx_PeriphCLKConfig+0x12e8>)
3400fbbe:	f7f1 fb6b 	bl	34001298 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400fbc2:	4b0c      	ldr	r3, [pc, #48]	@ (3400fbf4 <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400fbc4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400fbc8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fbcc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fbd0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbd4:	6a1a      	ldr	r2, [r3, #32]
3400fbd6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fbda:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fbdc:	3b01      	subs	r3, #1
3400fbde:	041b      	lsls	r3, r3, #16
3400fbe0:	4313      	orrs	r3, r2
3400fbe2:	4a04      	ldr	r2, [pc, #16]	@ (3400fbf4 <HAL_RCCEx_PeriphCLKConfig+0x12ec>)
3400fbe4:	430b      	orrs	r3, r1
3400fbe6:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400fbea:	f7fe faab 	bl	3400e144 <LL_RCC_IC4_Enable>
3400fbee:	e014      	b.n	3400fc1a <HAL_RCCEx_PeriphCLKConfig+0x1312>
3400fbf0:	3402444c 	.word	0x3402444c
3400fbf4:	56028000 	.word	0x56028000
3400fbf8:	03000014 	.word	0x03000014
3400fbfc:	03010014 	.word	0x03010014
3400fc00:	03020014 	.word	0x03020014
3400fc04:	03030014 	.word	0x03030014
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3400fc08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc0c:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400fc10:	4baf      	ldr	r3, [pc, #700]	@ (3400fed0 <HAL_RCCEx_PeriphCLKConfig+0x15c8>)
3400fc12:	429a      	cmp	r2, r3
3400fc14:	d101      	bne.n	3400fc1a <HAL_RCCEx_PeriphCLKConfig+0x1312>
    {
      LL_RCC_CLKP_Enable();
3400fc16:	f7fe fe55 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
3400fc1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc1e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3400fc22:	4618      	mov	r0, r3
3400fc24:	f7fd fdfc 	bl	3400d820 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3400fc28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc2c:	e9d3 2300 	ldrd	r2, r3, [r3]
3400fc30:	2100      	movs	r1, #0
3400fc32:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
3400fc36:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3400fc3a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
3400fc3e:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
3400fc42:	4603      	mov	r3, r0
3400fc44:	460a      	mov	r2, r1
3400fc46:	4313      	orrs	r3, r2
3400fc48:	f000 80c5 	beq.w	3400fdd6 <HAL_RCCEx_PeriphCLKConfig+0x14ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));
3400fc4c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc50:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fc54:	4b9f      	ldr	r3, [pc, #636]	@ (3400fed4 <HAL_RCCEx_PeriphCLKConfig+0x15cc>)
3400fc56:	429a      	cmp	r2, r3
3400fc58:	d019      	beq.n	3400fc8e <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400fc5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc5e:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fc62:	4b9d      	ldr	r3, [pc, #628]	@ (3400fed8 <HAL_RCCEx_PeriphCLKConfig+0x15d0>)
3400fc64:	429a      	cmp	r2, r3
3400fc66:	d012      	beq.n	3400fc8e <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400fc68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc6c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fc70:	4b9a      	ldr	r3, [pc, #616]	@ (3400fedc <HAL_RCCEx_PeriphCLKConfig+0x15d4>)
3400fc72:	429a      	cmp	r2, r3
3400fc74:	d00b      	beq.n	3400fc8e <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400fc76:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc7a:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fc7e:	4b98      	ldr	r3, [pc, #608]	@ (3400fee0 <HAL_RCCEx_PeriphCLKConfig+0x15d8>)
3400fc80:	429a      	cmp	r2, r3
3400fc82:	d004      	beq.n	3400fc8e <HAL_RCCEx_PeriphCLKConfig+0x1386>
3400fc84:	f44f 71ae 	mov.w	r1, #348	@ 0x15c
3400fc88:	4896      	ldr	r0, [pc, #600]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fc8a:	f7f1 fb05 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3400fc8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fc92:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fc96:	4b91      	ldr	r3, [pc, #580]	@ (3400fedc <HAL_RCCEx_PeriphCLKConfig+0x15d4>)
3400fc98:	429a      	cmp	r2, r3
3400fc9a:	d142      	bne.n	3400fd22 <HAL_RCCEx_PeriphCLKConfig+0x141a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400fc9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fca0:	699b      	ldr	r3, [r3, #24]
3400fca2:	2b00      	cmp	r3, #0
3400fca4:	d016      	beq.n	3400fcd4 <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400fca6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcaa:	699b      	ldr	r3, [r3, #24]
3400fcac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fcb0:	d010      	beq.n	3400fcd4 <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400fcb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcb6:	699b      	ldr	r3, [r3, #24]
3400fcb8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fcbc:	d00a      	beq.n	3400fcd4 <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400fcbe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcc2:	699b      	ldr	r3, [r3, #24]
3400fcc4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fcc8:	d004      	beq.n	3400fcd4 <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400fcca:	f240 1161 	movw	r1, #353	@ 0x161
3400fcce:	4885      	ldr	r0, [pc, #532]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fcd0:	f7f1 fae2 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400fcd4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fcd8:	69db      	ldr	r3, [r3, #28]
3400fcda:	2b00      	cmp	r3, #0
3400fcdc:	d005      	beq.n	3400fcea <HAL_RCCEx_PeriphCLKConfig+0x13e2>
3400fcde:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fce2:	69db      	ldr	r3, [r3, #28]
3400fce4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fce8:	d904      	bls.n	3400fcf4 <HAL_RCCEx_PeriphCLKConfig+0x13ec>
3400fcea:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3400fcee:	487d      	ldr	r0, [pc, #500]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fcf0:	f7f1 fad2 	bl	34001298 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400fcf4:	4b7c      	ldr	r3, [pc, #496]	@ (3400fee8 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400fcf6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400fcfa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fcfe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fd02:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd06:	699a      	ldr	r2, [r3, #24]
3400fd08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd0c:	69db      	ldr	r3, [r3, #28]
3400fd0e:	3b01      	subs	r3, #1
3400fd10:	041b      	lsls	r3, r3, #16
3400fd12:	4313      	orrs	r3, r2
3400fd14:	4a74      	ldr	r2, [pc, #464]	@ (3400fee8 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400fd16:	430b      	orrs	r3, r1
3400fd18:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400fd1c:	f7fe f9d2 	bl	3400e0c4 <LL_RCC_IC3_Enable>
3400fd20:	e052      	b.n	3400fdc8 <HAL_RCCEx_PeriphCLKConfig+0x14c0>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3400fd22:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd26:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fd2a:	4b6d      	ldr	r3, [pc, #436]	@ (3400fee0 <HAL_RCCEx_PeriphCLKConfig+0x15d8>)
3400fd2c:	429a      	cmp	r2, r3
3400fd2e:	d142      	bne.n	3400fdb6 <HAL_RCCEx_PeriphCLKConfig+0x14ae>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400fd30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd34:	6a1b      	ldr	r3, [r3, #32]
3400fd36:	2b00      	cmp	r3, #0
3400fd38:	d016      	beq.n	3400fd68 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400fd3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd3e:	6a1b      	ldr	r3, [r3, #32]
3400fd40:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fd44:	d010      	beq.n	3400fd68 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400fd46:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd4a:	6a1b      	ldr	r3, [r3, #32]
3400fd4c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fd50:	d00a      	beq.n	3400fd68 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400fd52:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd56:	6a1b      	ldr	r3, [r3, #32]
3400fd58:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fd5c:	d004      	beq.n	3400fd68 <HAL_RCCEx_PeriphCLKConfig+0x1460>
3400fd5e:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3400fd62:	4860      	ldr	r0, [pc, #384]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fd64:	f7f1 fa98 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400fd68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd6c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fd6e:	2b00      	cmp	r3, #0
3400fd70:	d005      	beq.n	3400fd7e <HAL_RCCEx_PeriphCLKConfig+0x1476>
3400fd72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd76:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fd78:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fd7c:	d904      	bls.n	3400fd88 <HAL_RCCEx_PeriphCLKConfig+0x1480>
3400fd7e:	f240 116f 	movw	r1, #367	@ 0x16f
3400fd82:	4858      	ldr	r0, [pc, #352]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fd84:	f7f1 fa88 	bl	34001298 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400fd88:	4b57      	ldr	r3, [pc, #348]	@ (3400fee8 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400fd8a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400fd8e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400fd92:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400fd96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fd9a:	6a1a      	ldr	r2, [r3, #32]
3400fd9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fda0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fda2:	3b01      	subs	r3, #1
3400fda4:	041b      	lsls	r3, r3, #16
3400fda6:	4313      	orrs	r3, r2
3400fda8:	4a4f      	ldr	r2, [pc, #316]	@ (3400fee8 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400fdaa:	430b      	orrs	r3, r1
3400fdac:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400fdb0:	f7fe f9c8 	bl	3400e144 <LL_RCC_IC4_Enable>
3400fdb4:	e008      	b.n	3400fdc8 <HAL_RCCEx_PeriphCLKConfig+0x14c0>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3400fdb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdba:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400fdbe:	4b46      	ldr	r3, [pc, #280]	@ (3400fed8 <HAL_RCCEx_PeriphCLKConfig+0x15d0>)
3400fdc0:	429a      	cmp	r2, r3
3400fdc2:	d101      	bne.n	3400fdc8 <HAL_RCCEx_PeriphCLKConfig+0x14c0>
    {
      LL_RCC_CLKP_Enable();
3400fdc4:	f7fe fd7e 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
3400fdc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdcc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400fdd0:	4618      	mov	r0, r3
3400fdd2:	f7fd fd25 	bl	3400d820 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3400fdd6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdda:	e9d3 2300 	ldrd	r2, r3, [r3]
3400fdde:	2100      	movs	r1, #0
3400fde0:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
3400fde4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3400fde8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
3400fdec:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
3400fdf0:	4603      	mov	r3, r0
3400fdf2:	460a      	mov	r2, r1
3400fdf4:	4313      	orrs	r3, r2
3400fdf6:	f000 80db 	beq.w	3400ffb0 <HAL_RCCEx_PeriphCLKConfig+0x16a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));
3400fdfa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fdfe:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400fe02:	4b3a      	ldr	r3, [pc, #232]	@ (3400feec <HAL_RCCEx_PeriphCLKConfig+0x15e4>)
3400fe04:	429a      	cmp	r2, r3
3400fe06:	d019      	beq.n	3400fe3c <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400fe08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe0c:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400fe10:	4b37      	ldr	r3, [pc, #220]	@ (3400fef0 <HAL_RCCEx_PeriphCLKConfig+0x15e8>)
3400fe12:	429a      	cmp	r2, r3
3400fe14:	d012      	beq.n	3400fe3c <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400fe16:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe1a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400fe1e:	4b35      	ldr	r3, [pc, #212]	@ (3400fef4 <HAL_RCCEx_PeriphCLKConfig+0x15ec>)
3400fe20:	429a      	cmp	r2, r3
3400fe22:	d00b      	beq.n	3400fe3c <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400fe24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe28:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400fe2c:	4b32      	ldr	r3, [pc, #200]	@ (3400fef8 <HAL_RCCEx_PeriphCLKConfig+0x15f0>)
3400fe2e:	429a      	cmp	r2, r3
3400fe30:	d004      	beq.n	3400fe3c <HAL_RCCEx_PeriphCLKConfig+0x1534>
3400fe32:	f240 1189 	movw	r1, #393	@ 0x189
3400fe36:	482b      	ldr	r0, [pc, #172]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fe38:	f7f1 fa2e 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3400fe3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe40:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400fe44:	4b2b      	ldr	r3, [pc, #172]	@ (3400fef4 <HAL_RCCEx_PeriphCLKConfig+0x15ec>)
3400fe46:	429a      	cmp	r2, r3
3400fe48:	d158      	bne.n	3400fefc <HAL_RCCEx_PeriphCLKConfig+0x15f4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400fe4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe4e:	699b      	ldr	r3, [r3, #24]
3400fe50:	2b00      	cmp	r3, #0
3400fe52:	d016      	beq.n	3400fe82 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400fe54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe58:	699b      	ldr	r3, [r3, #24]
3400fe5a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fe5e:	d010      	beq.n	3400fe82 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400fe60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe64:	699b      	ldr	r3, [r3, #24]
3400fe66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400fe6a:	d00a      	beq.n	3400fe82 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400fe6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe70:	699b      	ldr	r3, [r3, #24]
3400fe72:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400fe76:	d004      	beq.n	3400fe82 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400fe78:	f44f 71c7 	mov.w	r1, #398	@ 0x18e
3400fe7c:	4819      	ldr	r0, [pc, #100]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fe7e:	f7f1 fa0b 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400fe82:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe86:	69db      	ldr	r3, [r3, #28]
3400fe88:	2b00      	cmp	r3, #0
3400fe8a:	d005      	beq.n	3400fe98 <HAL_RCCEx_PeriphCLKConfig+0x1590>
3400fe8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fe90:	69db      	ldr	r3, [r3, #28]
3400fe92:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fe96:	d904      	bls.n	3400fea2 <HAL_RCCEx_PeriphCLKConfig+0x159a>
3400fe98:	f240 118f 	movw	r1, #399	@ 0x18f
3400fe9c:	4811      	ldr	r0, [pc, #68]	@ (3400fee4 <HAL_RCCEx_PeriphCLKConfig+0x15dc>)
3400fe9e:	f7f1 f9fb 	bl	34001298 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400fea2:	4b11      	ldr	r3, [pc, #68]	@ (3400fee8 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400fea4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400fea8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400feac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400feb0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400feb4:	699a      	ldr	r2, [r3, #24]
3400feb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400feba:	69db      	ldr	r3, [r3, #28]
3400febc:	3b01      	subs	r3, #1
3400febe:	041b      	lsls	r3, r3, #16
3400fec0:	4313      	orrs	r3, r2
3400fec2:	4a09      	ldr	r2, [pc, #36]	@ (3400fee8 <HAL_RCCEx_PeriphCLKConfig+0x15e0>)
3400fec4:	430b      	orrs	r3, r1
3400fec6:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400feca:	f7fe f8fb 	bl	3400e0c4 <LL_RCC_IC3_Enable>
3400fece:	e068      	b.n	3400ffa2 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400fed0:	03010014 	.word	0x03010014
3400fed4:	03000414 	.word	0x03000414
3400fed8:	03010414 	.word	0x03010414
3400fedc:	03020414 	.word	0x03020414
3400fee0:	03030414 	.word	0x03030414
3400fee4:	3402444c 	.word	0x3402444c
3400fee8:	56028000 	.word	0x56028000
3400feec:	03000814 	.word	0x03000814
3400fef0:	03010814 	.word	0x03010814
3400fef4:	03020814 	.word	0x03020814
3400fef8:	03030814 	.word	0x03030814
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3400fefc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff00:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400ff04:	4b8b      	ldr	r3, [pc, #556]	@ (34010134 <HAL_RCCEx_PeriphCLKConfig+0x182c>)
3400ff06:	429a      	cmp	r2, r3
3400ff08:	d142      	bne.n	3400ff90 <HAL_RCCEx_PeriphCLKConfig+0x1688>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400ff0a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff0e:	6a1b      	ldr	r3, [r3, #32]
3400ff10:	2b00      	cmp	r3, #0
3400ff12:	d016      	beq.n	3400ff42 <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400ff14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff18:	6a1b      	ldr	r3, [r3, #32]
3400ff1a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ff1e:	d010      	beq.n	3400ff42 <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400ff20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff24:	6a1b      	ldr	r3, [r3, #32]
3400ff26:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ff2a:	d00a      	beq.n	3400ff42 <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400ff2c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff30:	6a1b      	ldr	r3, [r3, #32]
3400ff32:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ff36:	d004      	beq.n	3400ff42 <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400ff38:	f240 119b 	movw	r1, #411	@ 0x19b
3400ff3c:	487e      	ldr	r0, [pc, #504]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400ff3e:	f7f1 f9ab 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400ff42:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ff48:	2b00      	cmp	r3, #0
3400ff4a:	d005      	beq.n	3400ff58 <HAL_RCCEx_PeriphCLKConfig+0x1650>
3400ff4c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff50:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ff52:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ff56:	d904      	bls.n	3400ff62 <HAL_RCCEx_PeriphCLKConfig+0x165a>
3400ff58:	f44f 71ce 	mov.w	r1, #412	@ 0x19c
3400ff5c:	4876      	ldr	r0, [pc, #472]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3400ff5e:	f7f1 f99b 	bl	34001298 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400ff62:	4b76      	ldr	r3, [pc, #472]	@ (3401013c <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400ff64:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400ff68:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400ff6c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400ff70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff74:	6a1a      	ldr	r2, [r3, #32]
3400ff76:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff7a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ff7c:	3b01      	subs	r3, #1
3400ff7e:	041b      	lsls	r3, r3, #16
3400ff80:	4313      	orrs	r3, r2
3400ff82:	4a6e      	ldr	r2, [pc, #440]	@ (3401013c <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3400ff84:	430b      	orrs	r3, r1
3400ff86:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400ff8a:	f7fe f8db 	bl	3400e144 <LL_RCC_IC4_Enable>
3400ff8e:	e008      	b.n	3400ffa2 <HAL_RCCEx_PeriphCLKConfig+0x169a>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3400ff90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ff94:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400ff98:	4b69      	ldr	r3, [pc, #420]	@ (34010140 <HAL_RCCEx_PeriphCLKConfig+0x1838>)
3400ff9a:	429a      	cmp	r2, r3
3400ff9c:	d101      	bne.n	3400ffa2 <HAL_RCCEx_PeriphCLKConfig+0x169a>
    {
      LL_RCC_CLKP_Enable();
3400ff9e:	f7fe fc91 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
3400ffa2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffa6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400ffaa:	4618      	mov	r0, r3
3400ffac:	f7fd fc38 	bl	3400d820 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3400ffb0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffb4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ffb8:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3400ffbc:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
3400ffc0:	2300      	movs	r3, #0
3400ffc2:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
3400ffc6:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
3400ffca:	4603      	mov	r3, r0
3400ffcc:	460a      	mov	r2, r1
3400ffce:	4313      	orrs	r3, r2
3400ffd0:	f000 80c7 	beq.w	34010162 <HAL_RCCEx_PeriphCLKConfig+0x185a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));
3400ffd4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffd8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400ffdc:	2b00      	cmp	r3, #0
3400ffde:	d016      	beq.n	3401000e <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400ffe0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400ffe4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400ffe8:	2b10      	cmp	r3, #16
3400ffea:	d010      	beq.n	3401000e <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400ffec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fff0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400fff4:	2b20      	cmp	r3, #32
3400fff6:	d00a      	beq.n	3401000e <HAL_RCCEx_PeriphCLKConfig+0x1706>
3400fff8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3400fffc:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34010000:	2b30      	cmp	r3, #48	@ 0x30
34010002:	d004      	beq.n	3401000e <HAL_RCCEx_PeriphCLKConfig+0x1706>
34010004:	f44f 71db 	mov.w	r1, #438	@ 0x1b6
34010008:	484b      	ldr	r0, [pc, #300]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3401000a:	f7f1 f945 	bl	34001298 <assert_failed>

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3401000e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010012:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34010016:	2b20      	cmp	r3, #32
34010018:	d142      	bne.n	340100a0 <HAL_RCCEx_PeriphCLKConfig+0x1798>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3401001a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401001e:	699b      	ldr	r3, [r3, #24]
34010020:	2b00      	cmp	r3, #0
34010022:	d016      	beq.n	34010052 <HAL_RCCEx_PeriphCLKConfig+0x174a>
34010024:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010028:	699b      	ldr	r3, [r3, #24]
3401002a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401002e:	d010      	beq.n	34010052 <HAL_RCCEx_PeriphCLKConfig+0x174a>
34010030:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010034:	699b      	ldr	r3, [r3, #24]
34010036:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401003a:	d00a      	beq.n	34010052 <HAL_RCCEx_PeriphCLKConfig+0x174a>
3401003c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010040:	699b      	ldr	r3, [r3, #24]
34010042:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010046:	d004      	beq.n	34010052 <HAL_RCCEx_PeriphCLKConfig+0x174a>
34010048:	f240 11bb 	movw	r1, #443	@ 0x1bb
3401004c:	483a      	ldr	r0, [pc, #232]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3401004e:	f7f1 f923 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
34010052:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010056:	69db      	ldr	r3, [r3, #28]
34010058:	2b00      	cmp	r3, #0
3401005a:	d005      	beq.n	34010068 <HAL_RCCEx_PeriphCLKConfig+0x1760>
3401005c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010060:	69db      	ldr	r3, [r3, #28]
34010062:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010066:	d904      	bls.n	34010072 <HAL_RCCEx_PeriphCLKConfig+0x176a>
34010068:	f44f 71de 	mov.w	r1, #444	@ 0x1bc
3401006c:	4832      	ldr	r0, [pc, #200]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3401006e:	f7f1 f913 	bl	34001298 <assert_failed>

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34010072:	4b32      	ldr	r3, [pc, #200]	@ (3401013c <HAL_RCCEx_PeriphCLKConfig+0x1834>)
34010074:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010078:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401007c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010080:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010084:	699a      	ldr	r2, [r3, #24]
34010086:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401008a:	69db      	ldr	r3, [r3, #28]
3401008c:	3b01      	subs	r3, #1
3401008e:	041b      	lsls	r3, r3, #16
34010090:	4313      	orrs	r3, r2
34010092:	4a2a      	ldr	r2, [pc, #168]	@ (3401013c <HAL_RCCEx_PeriphCLKConfig+0x1834>)
34010094:	430b      	orrs	r3, r1
34010096:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3401009a:	f7fe f813 	bl	3400e0c4 <LL_RCC_IC3_Enable>
3401009e:	e059      	b.n	34010154 <HAL_RCCEx_PeriphCLKConfig+0x184c>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
340100a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100a4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340100a8:	2b30      	cmp	r3, #48	@ 0x30
340100aa:	d14b      	bne.n	34010144 <HAL_RCCEx_PeriphCLKConfig+0x183c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
340100ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100b0:	6a1b      	ldr	r3, [r3, #32]
340100b2:	2b00      	cmp	r3, #0
340100b4:	d016      	beq.n	340100e4 <HAL_RCCEx_PeriphCLKConfig+0x17dc>
340100b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100ba:	6a1b      	ldr	r3, [r3, #32]
340100bc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340100c0:	d010      	beq.n	340100e4 <HAL_RCCEx_PeriphCLKConfig+0x17dc>
340100c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100c6:	6a1b      	ldr	r3, [r3, #32]
340100c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340100cc:	d00a      	beq.n	340100e4 <HAL_RCCEx_PeriphCLKConfig+0x17dc>
340100ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100d2:	6a1b      	ldr	r3, [r3, #32]
340100d4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340100d8:	d004      	beq.n	340100e4 <HAL_RCCEx_PeriphCLKConfig+0x17dc>
340100da:	f44f 71e4 	mov.w	r1, #456	@ 0x1c8
340100de:	4816      	ldr	r0, [pc, #88]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
340100e0:	f7f1 f8da 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
340100e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340100ea:	2b00      	cmp	r3, #0
340100ec:	d005      	beq.n	340100fa <HAL_RCCEx_PeriphCLKConfig+0x17f2>
340100ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340100f2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340100f4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340100f8:	d904      	bls.n	34010104 <HAL_RCCEx_PeriphCLKConfig+0x17fc>
340100fa:	f240 11c9 	movw	r1, #457	@ 0x1c9
340100fe:	480e      	ldr	r0, [pc, #56]	@ (34010138 <HAL_RCCEx_PeriphCLKConfig+0x1830>)
34010100:	f7f1 f8ca 	bl	34001298 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010104:	4b0d      	ldr	r3, [pc, #52]	@ (3401013c <HAL_RCCEx_PeriphCLKConfig+0x1834>)
34010106:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3401010a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401010e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010112:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010116:	6a1a      	ldr	r2, [r3, #32]
34010118:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401011c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401011e:	3b01      	subs	r3, #1
34010120:	041b      	lsls	r3, r3, #16
34010122:	4313      	orrs	r3, r2
34010124:	4a05      	ldr	r2, [pc, #20]	@ (3401013c <HAL_RCCEx_PeriphCLKConfig+0x1834>)
34010126:	430b      	orrs	r3, r1
34010128:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3401012c:	f7fe f80a 	bl	3400e144 <LL_RCC_IC4_Enable>
34010130:	e010      	b.n	34010154 <HAL_RCCEx_PeriphCLKConfig+0x184c>
34010132:	bf00      	nop
34010134:	03030814 	.word	0x03030814
34010138:	3402444c 	.word	0x3402444c
3401013c:	56028000 	.word	0x56028000
34010140:	03010814 	.word	0x03010814
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
34010144:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010148:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3401014c:	2b10      	cmp	r3, #16
3401014e:	d101      	bne.n	34010154 <HAL_RCCEx_PeriphCLKConfig+0x184c>
    {
      LL_RCC_CLKP_Enable();
34010150:	f7fe fbb8 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
34010154:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010158:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3401015c:	4618      	mov	r0, r3
3401015e:	f7fd fa77 	bl	3400d650 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
34010162:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010166:	e9d3 2300 	ldrd	r2, r3, [r3]
3401016a:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
3401016e:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
34010172:	2300      	movs	r3, #0
34010174:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
34010178:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
3401017c:	4603      	mov	r3, r0
3401017e:	460a      	mov	r2, r1
34010180:	4313      	orrs	r3, r2
34010182:	f000 80c5 	beq.w	34010310 <HAL_RCCEx_PeriphCLKConfig+0x1a08>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
34010186:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401018a:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3401018e:	4b9f      	ldr	r3, [pc, #636]	@ (3401040c <HAL_RCCEx_PeriphCLKConfig+0x1b04>)
34010190:	429a      	cmp	r2, r3
34010192:	d019      	beq.n	340101c8 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
34010194:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010198:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3401019c:	4b9c      	ldr	r3, [pc, #624]	@ (34010410 <HAL_RCCEx_PeriphCLKConfig+0x1b08>)
3401019e:	429a      	cmp	r2, r3
340101a0:	d012      	beq.n	340101c8 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
340101a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101a6:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340101aa:	4b9a      	ldr	r3, [pc, #616]	@ (34010414 <HAL_RCCEx_PeriphCLKConfig+0x1b0c>)
340101ac:	429a      	cmp	r2, r3
340101ae:	d00b      	beq.n	340101c8 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
340101b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101b4:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340101b8:	4b97      	ldr	r3, [pc, #604]	@ (34010418 <HAL_RCCEx_PeriphCLKConfig+0x1b10>)
340101ba:	429a      	cmp	r2, r3
340101bc:	d004      	beq.n	340101c8 <HAL_RCCEx_PeriphCLKConfig+0x18c0>
340101be:	f240 11e3 	movw	r1, #483	@ 0x1e3
340101c2:	4896      	ldr	r0, [pc, #600]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
340101c4:	f7f1 f868 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
340101c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101cc:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340101d0:	4b90      	ldr	r3, [pc, #576]	@ (34010414 <HAL_RCCEx_PeriphCLKConfig+0x1b0c>)
340101d2:	429a      	cmp	r2, r3
340101d4:	d142      	bne.n	3401025c <HAL_RCCEx_PeriphCLKConfig+0x1954>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
340101d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101da:	6a1b      	ldr	r3, [r3, #32]
340101dc:	2b00      	cmp	r3, #0
340101de:	d016      	beq.n	3401020e <HAL_RCCEx_PeriphCLKConfig+0x1906>
340101e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101e4:	6a1b      	ldr	r3, [r3, #32]
340101e6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340101ea:	d010      	beq.n	3401020e <HAL_RCCEx_PeriphCLKConfig+0x1906>
340101ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101f0:	6a1b      	ldr	r3, [r3, #32]
340101f2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340101f6:	d00a      	beq.n	3401020e <HAL_RCCEx_PeriphCLKConfig+0x1906>
340101f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340101fc:	6a1b      	ldr	r3, [r3, #32]
340101fe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010202:	d004      	beq.n	3401020e <HAL_RCCEx_PeriphCLKConfig+0x1906>
34010204:	f44f 71f4 	mov.w	r1, #488	@ 0x1e8
34010208:	4884      	ldr	r0, [pc, #528]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3401020a:	f7f1 f845 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3401020e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010212:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010214:	2b00      	cmp	r3, #0
34010216:	d005      	beq.n	34010224 <HAL_RCCEx_PeriphCLKConfig+0x191c>
34010218:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401021c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401021e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010222:	d904      	bls.n	3401022e <HAL_RCCEx_PeriphCLKConfig+0x1926>
34010224:	f240 11e9 	movw	r1, #489	@ 0x1e9
34010228:	487c      	ldr	r0, [pc, #496]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3401022a:	f7f1 f835 	bl	34001298 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3401022e:	4b7c      	ldr	r3, [pc, #496]	@ (34010420 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
34010230:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010234:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010238:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401023c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010240:	6a1a      	ldr	r2, [r3, #32]
34010242:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010246:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010248:	3b01      	subs	r3, #1
3401024a:	041b      	lsls	r3, r3, #16
3401024c:	4313      	orrs	r3, r2
3401024e:	4a74      	ldr	r2, [pc, #464]	@ (34010420 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
34010250:	430b      	orrs	r3, r1
34010252:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010256:	f7fd ff75 	bl	3400e144 <LL_RCC_IC4_Enable>
3401025a:	e052      	b.n	34010302 <HAL_RCCEx_PeriphCLKConfig+0x19fa>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3401025c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010260:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34010264:	4b6c      	ldr	r3, [pc, #432]	@ (34010418 <HAL_RCCEx_PeriphCLKConfig+0x1b10>)
34010266:	429a      	cmp	r2, r3
34010268:	d142      	bne.n	340102f0 <HAL_RCCEx_PeriphCLKConfig+0x19e8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3401026a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401026e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34010270:	2b00      	cmp	r3, #0
34010272:	d016      	beq.n	340102a2 <HAL_RCCEx_PeriphCLKConfig+0x199a>
34010274:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010278:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401027a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401027e:	d010      	beq.n	340102a2 <HAL_RCCEx_PeriphCLKConfig+0x199a>
34010280:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010284:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34010286:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401028a:	d00a      	beq.n	340102a2 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3401028c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010290:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34010292:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010296:	d004      	beq.n	340102a2 <HAL_RCCEx_PeriphCLKConfig+0x199a>
34010298:	f240 11f5 	movw	r1, #501	@ 0x1f5
3401029c:	485f      	ldr	r0, [pc, #380]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
3401029e:	f7f0 fffb 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
340102a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102a6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340102a8:	2b00      	cmp	r3, #0
340102aa:	d005      	beq.n	340102b8 <HAL_RCCEx_PeriphCLKConfig+0x19b0>
340102ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340102b2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340102b6:	d904      	bls.n	340102c2 <HAL_RCCEx_PeriphCLKConfig+0x19ba>
340102b8:	f44f 71fb 	mov.w	r1, #502	@ 0x1f6
340102bc:	4857      	ldr	r0, [pc, #348]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
340102be:	f7f0 ffeb 	bl	34001298 <assert_failed>

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
340102c2:	4b57      	ldr	r3, [pc, #348]	@ (34010420 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
340102c4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
340102c8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340102cc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340102d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102d4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
340102d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340102dc:	3b01      	subs	r3, #1
340102de:	041b      	lsls	r3, r3, #16
340102e0:	4313      	orrs	r3, r2
340102e2:	4a4f      	ldr	r2, [pc, #316]	@ (34010420 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
340102e4:	430b      	orrs	r3, r1
340102e6:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
340102ea:	f7fd ff6b 	bl	3400e1c4 <LL_RCC_IC5_Enable>
340102ee:	e008      	b.n	34010302 <HAL_RCCEx_PeriphCLKConfig+0x19fa>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
340102f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340102f4:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340102f8:	4b45      	ldr	r3, [pc, #276]	@ (34010410 <HAL_RCCEx_PeriphCLKConfig+0x1b08>)
340102fa:	429a      	cmp	r2, r3
340102fc:	d101      	bne.n	34010302 <HAL_RCCEx_PeriphCLKConfig+0x19fa>
    {
      LL_RCC_CLKP_Enable();
340102fe:	f7fe fae1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
34010302:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010306:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
3401030a:	4618      	mov	r0, r3
3401030c:	f7fd fa51 	bl	3400d7b2 <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34010310:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010314:	e9d3 2300 	ldrd	r2, r3, [r3]
34010318:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3401031c:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34010320:	2300      	movs	r3, #0
34010322:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34010326:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
3401032a:	4603      	mov	r3, r0
3401032c:	460a      	mov	r2, r1
3401032e:	4313      	orrs	r3, r2
34010330:	f000 80da 	beq.w	340104e8 <HAL_RCCEx_PeriphCLKConfig+0x1be0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));
34010334:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010338:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3401033c:	4b39      	ldr	r3, [pc, #228]	@ (34010424 <HAL_RCCEx_PeriphCLKConfig+0x1b1c>)
3401033e:	429a      	cmp	r2, r3
34010340:	d019      	beq.n	34010376 <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
34010342:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010346:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3401034a:	4b37      	ldr	r3, [pc, #220]	@ (34010428 <HAL_RCCEx_PeriphCLKConfig+0x1b20>)
3401034c:	429a      	cmp	r2, r3
3401034e:	d012      	beq.n	34010376 <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
34010350:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010354:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34010358:	4b34      	ldr	r3, [pc, #208]	@ (3401042c <HAL_RCCEx_PeriphCLKConfig+0x1b24>)
3401035a:	429a      	cmp	r2, r3
3401035c:	d00b      	beq.n	34010376 <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
3401035e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010362:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34010366:	4b32      	ldr	r3, [pc, #200]	@ (34010430 <HAL_RCCEx_PeriphCLKConfig+0x1b28>)
34010368:	429a      	cmp	r2, r3
3401036a:	d004      	beq.n	34010376 <HAL_RCCEx_PeriphCLKConfig+0x1a6e>
3401036c:	f44f 7104 	mov.w	r1, #528	@ 0x210
34010370:	482a      	ldr	r0, [pc, #168]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
34010372:	f7f0 ff91 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34010376:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401037a:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3401037e:	4b2b      	ldr	r3, [pc, #172]	@ (3401042c <HAL_RCCEx_PeriphCLKConfig+0x1b24>)
34010380:	429a      	cmp	r2, r3
34010382:	d157      	bne.n	34010434 <HAL_RCCEx_PeriphCLKConfig+0x1b2c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
34010384:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010388:	6a1b      	ldr	r3, [r3, #32]
3401038a:	2b00      	cmp	r3, #0
3401038c:	d016      	beq.n	340103bc <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
3401038e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010392:	6a1b      	ldr	r3, [r3, #32]
34010394:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010398:	d010      	beq.n	340103bc <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
3401039a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401039e:	6a1b      	ldr	r3, [r3, #32]
340103a0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340103a4:	d00a      	beq.n	340103bc <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
340103a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103aa:	6a1b      	ldr	r3, [r3, #32]
340103ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340103b0:	d004      	beq.n	340103bc <HAL_RCCEx_PeriphCLKConfig+0x1ab4>
340103b2:	f240 2115 	movw	r1, #533	@ 0x215
340103b6:	4819      	ldr	r0, [pc, #100]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
340103b8:	f7f0 ff6e 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
340103bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340103c2:	2b00      	cmp	r3, #0
340103c4:	d005      	beq.n	340103d2 <HAL_RCCEx_PeriphCLKConfig+0x1aca>
340103c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103ca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340103cc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340103d0:	d904      	bls.n	340103dc <HAL_RCCEx_PeriphCLKConfig+0x1ad4>
340103d2:	f240 2116 	movw	r1, #534	@ 0x216
340103d6:	4811      	ldr	r0, [pc, #68]	@ (3401041c <HAL_RCCEx_PeriphCLKConfig+0x1b14>)
340103d8:	f7f0 ff5e 	bl	34001298 <assert_failed>

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340103dc:	4b10      	ldr	r3, [pc, #64]	@ (34010420 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
340103de:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340103e2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340103e6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340103ea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103ee:	6a1a      	ldr	r2, [r3, #32]
340103f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340103f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340103f6:	3b01      	subs	r3, #1
340103f8:	041b      	lsls	r3, r3, #16
340103fa:	4313      	orrs	r3, r2
340103fc:	4a08      	ldr	r2, [pc, #32]	@ (34010420 <HAL_RCCEx_PeriphCLKConfig+0x1b18>)
340103fe:	430b      	orrs	r3, r1
34010400:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010404:	f7fd fe9e 	bl	3400e144 <LL_RCC_IC4_Enable>
34010408:	e067      	b.n	340104da <HAL_RCCEx_PeriphCLKConfig+0x1bd2>
3401040a:	bf00      	nop
3401040c:	0300001c 	.word	0x0300001c
34010410:	0301001c 	.word	0x0301001c
34010414:	0302001c 	.word	0x0302001c
34010418:	0303001c 	.word	0x0303001c
3401041c:	3402444c 	.word	0x3402444c
34010420:	56028000 	.word	0x56028000
34010424:	0300041c 	.word	0x0300041c
34010428:	0301041c 	.word	0x0301041c
3401042c:	0302041c 	.word	0x0302041c
34010430:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
34010434:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010438:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3401043c:	4ba0      	ldr	r3, [pc, #640]	@ (340106c0 <HAL_RCCEx_PeriphCLKConfig+0x1db8>)
3401043e:	429a      	cmp	r2, r3
34010440:	d142      	bne.n	340104c8 <HAL_RCCEx_PeriphCLKConfig+0x1bc0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
34010442:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010446:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34010448:	2b00      	cmp	r3, #0
3401044a:	d016      	beq.n	3401047a <HAL_RCCEx_PeriphCLKConfig+0x1b72>
3401044c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010450:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34010452:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010456:	d010      	beq.n	3401047a <HAL_RCCEx_PeriphCLKConfig+0x1b72>
34010458:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401045c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401045e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010462:	d00a      	beq.n	3401047a <HAL_RCCEx_PeriphCLKConfig+0x1b72>
34010464:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010468:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401046a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401046e:	d004      	beq.n	3401047a <HAL_RCCEx_PeriphCLKConfig+0x1b72>
34010470:	f240 2122 	movw	r1, #546	@ 0x222
34010474:	4893      	ldr	r0, [pc, #588]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
34010476:	f7f0 ff0f 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3401047a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401047e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34010480:	2b00      	cmp	r3, #0
34010482:	d005      	beq.n	34010490 <HAL_RCCEx_PeriphCLKConfig+0x1b88>
34010484:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010488:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401048a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401048e:	d904      	bls.n	3401049a <HAL_RCCEx_PeriphCLKConfig+0x1b92>
34010490:	f240 2123 	movw	r1, #547	@ 0x223
34010494:	488b      	ldr	r0, [pc, #556]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
34010496:	f7f0 feff 	bl	34001298 <assert_failed>

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3401049a:	4b8b      	ldr	r3, [pc, #556]	@ (340106c8 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
3401049c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
340104a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340104a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340104a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104ac:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
340104ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340104b4:	3b01      	subs	r3, #1
340104b6:	041b      	lsls	r3, r3, #16
340104b8:	4313      	orrs	r3, r2
340104ba:	4a83      	ldr	r2, [pc, #524]	@ (340106c8 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
340104bc:	430b      	orrs	r3, r1
340104be:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
340104c2:	f7fd fe7f 	bl	3400e1c4 <LL_RCC_IC5_Enable>
340104c6:	e008      	b.n	340104da <HAL_RCCEx_PeriphCLKConfig+0x1bd2>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
340104c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104cc:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
340104d0:	4b7e      	ldr	r3, [pc, #504]	@ (340106cc <HAL_RCCEx_PeriphCLKConfig+0x1dc4>)
340104d2:	429a      	cmp	r2, r3
340104d4:	d101      	bne.n	340104da <HAL_RCCEx_PeriphCLKConfig+0x1bd2>
    {
      LL_RCC_CLKP_Enable();
340104d6:	f7fe f9f5 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
340104da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104de:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
340104e2:	4618      	mov	r0, r3
340104e4:	f7fd f965 	bl	3400d7b2 <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
340104e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340104ec:	e9d3 2300 	ldrd	r2, r3, [r3]
340104f0:	f002 0301 	and.w	r3, r2, #1
340104f4:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
340104f8:	2300      	movs	r3, #0
340104fa:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
340104fe:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
34010502:	4603      	mov	r3, r0
34010504:	460a      	mov	r2, r1
34010506:	4313      	orrs	r3, r2
34010508:	f000 8100 	beq.w	3401070c <HAL_RCCEx_PeriphCLKConfig+0x1e04>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
3401050c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010510:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010514:	2b00      	cmp	r3, #0
34010516:	d02e      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
34010518:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401051c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010520:	2b10      	cmp	r3, #16
34010522:	d028      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
34010524:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010528:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3401052c:	2b20      	cmp	r3, #32
3401052e:	d022      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
34010530:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010534:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010538:	2b30      	cmp	r3, #48	@ 0x30
3401053a:	d01c      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3401053c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010540:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010544:	2b40      	cmp	r3, #64	@ 0x40
34010546:	d016      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
34010548:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401054c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010550:	2b50      	cmp	r3, #80	@ 0x50
34010552:	d010      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
34010554:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010558:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3401055c:	2b60      	cmp	r3, #96	@ 0x60
3401055e:	d00a      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
34010560:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010564:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010568:	2b70      	cmp	r3, #112	@ 0x70
3401056a:	d004      	beq.n	34010576 <HAL_RCCEx_PeriphCLKConfig+0x1c6e>
3401056c:	f240 213d 	movw	r1, #573	@ 0x23d
34010570:	4854      	ldr	r0, [pc, #336]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
34010572:	f7f0 fe91 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));
34010576:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401057a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
3401057e:	2b00      	cmp	r3, #0
34010580:	d006      	beq.n	34010590 <HAL_RCCEx_PeriphCLKConfig+0x1c88>
34010582:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010586:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
3401058a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401058e:	d904      	bls.n	3401059a <HAL_RCCEx_PeriphCLKConfig+0x1c92>
34010590:	f240 213e 	movw	r1, #574	@ 0x23e
34010594:	484b      	ldr	r0, [pc, #300]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
34010596:	f7f0 fe7f 	bl	34001298 <assert_failed>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3401059a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401059e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340105a2:	2b20      	cmp	r3, #32
340105a4:	d142      	bne.n	3401062c <HAL_RCCEx_PeriphCLKConfig+0x1d24>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
340105a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105aa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340105ac:	2b00      	cmp	r3, #0
340105ae:	d016      	beq.n	340105de <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
340105b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340105b6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340105ba:	d010      	beq.n	340105de <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
340105bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340105c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340105c6:	d00a      	beq.n	340105de <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
340105c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105cc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340105ce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340105d2:	d004      	beq.n	340105de <HAL_RCCEx_PeriphCLKConfig+0x1cd6>
340105d4:	f240 2143 	movw	r1, #579	@ 0x243
340105d8:	483a      	ldr	r0, [pc, #232]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
340105da:	f7f0 fe5d 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
340105de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340105e4:	2b00      	cmp	r3, #0
340105e6:	d005      	beq.n	340105f4 <HAL_RCCEx_PeriphCLKConfig+0x1cec>
340105e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340105ec:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340105ee:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340105f2:	d904      	bls.n	340105fe <HAL_RCCEx_PeriphCLKConfig+0x1cf6>
340105f4:	f44f 7111 	mov.w	r1, #580	@ 0x244
340105f8:	4832      	ldr	r0, [pc, #200]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
340105fa:	f7f0 fe4d 	bl	34001298 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340105fe:	4b32      	ldr	r3, [pc, #200]	@ (340106c8 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
34010600:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010604:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010608:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401060c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010610:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34010612:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010616:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34010618:	3b01      	subs	r3, #1
3401061a:	041b      	lsls	r3, r3, #16
3401061c:	4313      	orrs	r3, r2
3401061e:	4a2a      	ldr	r2, [pc, #168]	@ (340106c8 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
34010620:	430b      	orrs	r3, r1
34010622:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34010626:	f7fd fe0d 	bl	3400e244 <LL_RCC_IC7_Enable>
3401062a:	e059      	b.n	340106e0 <HAL_RCCEx_PeriphCLKConfig+0x1dd8>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3401062c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010630:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010634:	2b30      	cmp	r3, #48	@ 0x30
34010636:	d14b      	bne.n	340106d0 <HAL_RCCEx_PeriphCLKConfig+0x1dc8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
34010638:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401063c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401063e:	2b00      	cmp	r3, #0
34010640:	d016      	beq.n	34010670 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
34010642:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010646:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34010648:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401064c:	d010      	beq.n	34010670 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
3401064e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010652:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34010654:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010658:	d00a      	beq.n	34010670 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
3401065a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401065e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34010660:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010664:	d004      	beq.n	34010670 <HAL_RCCEx_PeriphCLKConfig+0x1d68>
34010666:	f44f 7114 	mov.w	r1, #592	@ 0x250
3401066a:	4816      	ldr	r0, [pc, #88]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3401066c:	f7f0 fe14 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34010670:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010674:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34010676:	2b00      	cmp	r3, #0
34010678:	d005      	beq.n	34010686 <HAL_RCCEx_PeriphCLKConfig+0x1d7e>
3401067a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401067e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34010680:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010684:	d904      	bls.n	34010690 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
34010686:	f240 2151 	movw	r1, #593	@ 0x251
3401068a:	480e      	ldr	r0, [pc, #56]	@ (340106c4 <HAL_RCCEx_PeriphCLKConfig+0x1dbc>)
3401068c:	f7f0 fe04 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34010690:	4b0d      	ldr	r3, [pc, #52]	@ (340106c8 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
34010692:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34010696:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401069a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401069e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340106a2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340106a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340106a8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340106aa:	3b01      	subs	r3, #1
340106ac:	041b      	lsls	r3, r3, #16
340106ae:	4313      	orrs	r3, r2
340106b0:	4a05      	ldr	r2, [pc, #20]	@ (340106c8 <HAL_RCCEx_PeriphCLKConfig+0x1dc0>)
340106b2:	430b      	orrs	r3, r1
340106b4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340106b8:	f7fd fe04 	bl	3400e2c4 <LL_RCC_IC8_Enable>
340106bc:	e010      	b.n	340106e0 <HAL_RCCEx_PeriphCLKConfig+0x1dd8>
340106be:	bf00      	nop
340106c0:	0303041c 	.word	0x0303041c
340106c4:	3402444c 	.word	0x3402444c
340106c8:	56028000 	.word	0x56028000
340106cc:	0301041c 	.word	0x0301041c
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
340106d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340106d4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340106d8:	2b10      	cmp	r3, #16
340106da:	d101      	bne.n	340106e0 <HAL_RCCEx_PeriphCLKConfig+0x1dd8>
    {
      LL_RCC_CLKP_Enable();
340106dc:	f7fe f8f2 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
340106e0:	4b77      	ldr	r3, [pc, #476]	@ (340108c0 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
340106e2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
340106e6:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
340106ea:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
340106ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340106f2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
340106f6:	3b01      	subs	r3, #1
340106f8:	021a      	lsls	r2, r3, #8
340106fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340106fe:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34010702:	4313      	orrs	r3, r2
34010704:	4a6e      	ldr	r2, [pc, #440]	@ (340108c0 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
34010706:	430b      	orrs	r3, r1
34010708:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3401070c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010710:	e9d3 2300 	ldrd	r2, r3, [r3]
34010714:	f002 0302 	and.w	r3, r2, #2
34010718:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
3401071c:	2300      	movs	r3, #0
3401071e:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
34010722:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
34010726:	4603      	mov	r3, r0
34010728:	460a      	mov	r2, r1
3401072a:	4313      	orrs	r3, r2
3401072c:	f000 80db 	beq.w	340108e6 <HAL_RCCEx_PeriphCLKConfig+0x1fde>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));
34010730:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010734:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010738:	2b00      	cmp	r3, #0
3401073a:	d02e      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3401073c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010740:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010744:	2b01      	cmp	r3, #1
34010746:	d028      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
34010748:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401074c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010750:	2b02      	cmp	r3, #2
34010752:	d022      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
34010754:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010758:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3401075c:	2b03      	cmp	r3, #3
3401075e:	d01c      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
34010760:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010764:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010768:	2b04      	cmp	r3, #4
3401076a:	d016      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
3401076c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010770:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010774:	2b05      	cmp	r3, #5
34010776:	d010      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
34010778:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401077c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010780:	2b06      	cmp	r3, #6
34010782:	d00a      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
34010784:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010788:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3401078c:	2b07      	cmp	r3, #7
3401078e:	d004      	beq.n	3401079a <HAL_RCCEx_PeriphCLKConfig+0x1e92>
34010790:	f44f 711b 	mov.w	r1, #620	@ 0x26c
34010794:	484b      	ldr	r0, [pc, #300]	@ (340108c4 <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
34010796:	f7f0 fd7f 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3401079a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401079e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340107a2:	2b02      	cmp	r3, #2
340107a4:	d142      	bne.n	3401082c <HAL_RCCEx_PeriphCLKConfig+0x1f24>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
340107a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340107aa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340107ac:	2b00      	cmp	r3, #0
340107ae:	d016      	beq.n	340107de <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
340107b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340107b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340107b6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340107ba:	d010      	beq.n	340107de <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
340107bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340107c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340107c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340107c6:	d00a      	beq.n	340107de <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
340107c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340107cc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340107ce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340107d2:	d004      	beq.n	340107de <HAL_RCCEx_PeriphCLKConfig+0x1ed6>
340107d4:	f240 2171 	movw	r1, #625	@ 0x271
340107d8:	483a      	ldr	r0, [pc, #232]	@ (340108c4 <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
340107da:	f7f0 fd5d 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
340107de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340107e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340107e4:	2b00      	cmp	r3, #0
340107e6:	d005      	beq.n	340107f4 <HAL_RCCEx_PeriphCLKConfig+0x1eec>
340107e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340107ec:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340107ee:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340107f2:	d904      	bls.n	340107fe <HAL_RCCEx_PeriphCLKConfig+0x1ef6>
340107f4:	f240 2172 	movw	r1, #626	@ 0x272
340107f8:	4832      	ldr	r0, [pc, #200]	@ (340108c4 <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
340107fa:	f7f0 fd4d 	bl	34001298 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340107fe:	4b30      	ldr	r3, [pc, #192]	@ (340108c0 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
34010800:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010804:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010808:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401080c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010810:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34010812:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010816:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34010818:	3b01      	subs	r3, #1
3401081a:	041b      	lsls	r3, r3, #16
3401081c:	4313      	orrs	r3, r2
3401081e:	4a28      	ldr	r2, [pc, #160]	@ (340108c0 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
34010820:	430b      	orrs	r3, r1
34010822:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34010826:	f7fd fd0d 	bl	3400e244 <LL_RCC_IC7_Enable>
3401082a:	e055      	b.n	340108d8 <HAL_RCCEx_PeriphCLKConfig+0x1fd0>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3401082c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010830:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34010834:	2b03      	cmp	r3, #3
34010836:	d147      	bne.n	340108c8 <HAL_RCCEx_PeriphCLKConfig+0x1fc0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
34010838:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401083c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401083e:	2b00      	cmp	r3, #0
34010840:	d016      	beq.n	34010870 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
34010842:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010846:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34010848:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401084c:	d010      	beq.n	34010870 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
3401084e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010852:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34010854:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010858:	d00a      	beq.n	34010870 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
3401085a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401085e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34010860:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010864:	d004      	beq.n	34010870 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
34010866:	f240 217e 	movw	r1, #638	@ 0x27e
3401086a:	4816      	ldr	r0, [pc, #88]	@ (340108c4 <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3401086c:	f7f0 fd14 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34010870:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010874:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34010876:	2b00      	cmp	r3, #0
34010878:	d005      	beq.n	34010886 <HAL_RCCEx_PeriphCLKConfig+0x1f7e>
3401087a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401087e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34010880:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010884:	d904      	bls.n	34010890 <HAL_RCCEx_PeriphCLKConfig+0x1f88>
34010886:	f240 217f 	movw	r1, #639	@ 0x27f
3401088a:	480e      	ldr	r0, [pc, #56]	@ (340108c4 <HAL_RCCEx_PeriphCLKConfig+0x1fbc>)
3401088c:	f7f0 fd04 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34010890:	4b0b      	ldr	r3, [pc, #44]	@ (340108c0 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
34010892:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34010896:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401089a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401089e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340108a2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340108a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340108a8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340108aa:	3b01      	subs	r3, #1
340108ac:	041b      	lsls	r3, r3, #16
340108ae:	4313      	orrs	r3, r2
340108b0:	4a03      	ldr	r2, [pc, #12]	@ (340108c0 <HAL_RCCEx_PeriphCLKConfig+0x1fb8>)
340108b2:	430b      	orrs	r3, r1
340108b4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340108b8:	f7fd fd04 	bl	3400e2c4 <LL_RCC_IC8_Enable>
340108bc:	e00c      	b.n	340108d8 <HAL_RCCEx_PeriphCLKConfig+0x1fd0>
340108be:	bf00      	nop
340108c0:	56028000 	.word	0x56028000
340108c4:	3402444c 	.word	0x3402444c
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
340108c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340108cc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340108d0:	2b01      	cmp	r3, #1
340108d2:	d101      	bne.n	340108d8 <HAL_RCCEx_PeriphCLKConfig+0x1fd0>
    {
      LL_RCC_CLKP_Enable();
340108d4:	f7fd fff6 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
340108d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340108dc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340108e0:	4618      	mov	r0, r3
340108e2:	f7fc fdf7 	bl	3400d4d4 <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
340108e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340108ea:	e9d3 2300 	ldrd	r2, r3, [r3]
340108ee:	f002 0308 	and.w	r3, r2, #8
340108f2:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
340108f6:	2300      	movs	r3, #0
340108f8:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
340108fc:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34010900:	4603      	mov	r3, r0
34010902:	460a      	mov	r2, r1
34010904:	4313      	orrs	r3, r2
34010906:	d049      	beq.n	3401099c <HAL_RCCEx_PeriphCLKConfig+0x2094>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
34010908:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401090c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34010910:	2b00      	cmp	r3, #0
34010912:	d019      	beq.n	34010948 <HAL_RCCEx_PeriphCLKConfig+0x2040>
34010914:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010918:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3401091c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010920:	d012      	beq.n	34010948 <HAL_RCCEx_PeriphCLKConfig+0x2040>
34010922:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010926:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3401092a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401092e:	d00b      	beq.n	34010948 <HAL_RCCEx_PeriphCLKConfig+0x2040>
34010930:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010934:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34010938:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401093c:	d004      	beq.n	34010948 <HAL_RCCEx_PeriphCLKConfig+0x2040>
3401093e:	f240 2199 	movw	r1, #665	@ 0x299
34010942:	489e      	ldr	r0, [pc, #632]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010944:	f7f0 fca8 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));
34010948:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401094c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34010950:	2b00      	cmp	r3, #0
34010952:	d006      	beq.n	34010962 <HAL_RCCEx_PeriphCLKConfig+0x205a>
34010954:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010958:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3401095c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010960:	d904      	bls.n	3401096c <HAL_RCCEx_PeriphCLKConfig+0x2064>
34010962:	f240 219a 	movw	r1, #666	@ 0x29a
34010966:	4895      	ldr	r0, [pc, #596]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010968:	f7f0 fc96 	bl	34001298 <assert_failed>

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3401096c:	4b94      	ldr	r3, [pc, #592]	@ (34010bc0 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
3401096e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34010972:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010976:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401097a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401097e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34010982:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010986:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3401098a:	3b01      	subs	r3, #1
3401098c:	041b      	lsls	r3, r3, #16
3401098e:	4313      	orrs	r3, r2
34010990:	4a8b      	ldr	r2, [pc, #556]	@ (34010bc0 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
34010992:	430b      	orrs	r3, r1
34010994:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
34010998:	f7fd fed4 	bl	3400e744 <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3401099c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340109a0:	e9d3 2300 	ldrd	r2, r3, [r3]
340109a4:	f002 0310 	and.w	r3, r2, #16
340109a8:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
340109ac:	2300      	movs	r3, #0
340109ae:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
340109b2:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
340109b6:	4603      	mov	r3, r0
340109b8:	460a      	mov	r2, r1
340109ba:	4313      	orrs	r3, r2
340109bc:	f000 8082 	beq.w	34010ac4 <HAL_RCCEx_PeriphCLKConfig+0x21bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));
340109c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340109c4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
340109c8:	2b00      	cmp	r3, #0
340109ca:	d019      	beq.n	34010a00 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
340109cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340109d0:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
340109d4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
340109d8:	d012      	beq.n	34010a00 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
340109da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340109de:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
340109e2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340109e6:	d00b      	beq.n	34010a00 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
340109e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340109ec:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
340109f0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340109f4:	d004      	beq.n	34010a00 <HAL_RCCEx_PeriphCLKConfig+0x20f8>
340109f6:	f44f 712a 	mov.w	r1, #680	@ 0x2a8
340109fa:	4870      	ldr	r0, [pc, #448]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
340109fc:	f7f0 fc4c 	bl	34001298 <assert_failed>

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
34010a00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a04:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34010a08:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34010a0c:	d14a      	bne.n	34010aa4 <HAL_RCCEx_PeriphCLKConfig+0x219c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
34010a0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a12:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34010a16:	2b00      	cmp	r3, #0
34010a18:	d019      	beq.n	34010a4e <HAL_RCCEx_PeriphCLKConfig+0x2146>
34010a1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a1e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34010a22:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010a26:	d012      	beq.n	34010a4e <HAL_RCCEx_PeriphCLKConfig+0x2146>
34010a28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a2c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34010a30:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010a34:	d00b      	beq.n	34010a4e <HAL_RCCEx_PeriphCLKConfig+0x2146>
34010a36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a3a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34010a3e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010a42:	d004      	beq.n	34010a4e <HAL_RCCEx_PeriphCLKConfig+0x2146>
34010a44:	f240 21ad 	movw	r1, #685	@ 0x2ad
34010a48:	485c      	ldr	r0, [pc, #368]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010a4a:	f7f0 fc25 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));
34010a4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a52:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34010a56:	2b00      	cmp	r3, #0
34010a58:	d006      	beq.n	34010a68 <HAL_RCCEx_PeriphCLKConfig+0x2160>
34010a5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a5e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34010a62:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010a66:	d904      	bls.n	34010a72 <HAL_RCCEx_PeriphCLKConfig+0x216a>
34010a68:	f240 21ae 	movw	r1, #686	@ 0x2ae
34010a6c:	4853      	ldr	r0, [pc, #332]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010a6e:	f7f0 fc13 	bl	34001298 <assert_failed>

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
34010a72:	4b53      	ldr	r3, [pc, #332]	@ (34010bc0 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
34010a74:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34010a78:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010a7c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010a80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a84:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34010a88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010a8c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34010a90:	3b01      	subs	r3, #1
34010a92:	041b      	lsls	r3, r3, #16
34010a94:	4313      	orrs	r3, r2
34010a96:	4a4a      	ldr	r2, [pc, #296]	@ (34010bc0 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
34010a98:	430b      	orrs	r3, r1
34010a9a:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34010a9e:	f7fd fe11 	bl	3400e6c4 <LL_RCC_IC17_Enable>
34010aa2:	e008      	b.n	34010ab6 <HAL_RCCEx_PeriphCLKConfig+0x21ae>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
34010aa4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010aa8:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34010aac:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34010ab0:	d101      	bne.n	34010ab6 <HAL_RCCEx_PeriphCLKConfig+0x21ae>
    {
      LL_RCC_CLKP_Enable();
34010ab2:	f7fd ff07 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
34010ab6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010aba:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34010abe:	4618      	mov	r0, r3
34010ac0:	f7fc fd34 	bl	3400d52c <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
34010ac4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ac8:	e9d3 2300 	ldrd	r2, r3, [r3]
34010acc:	f002 0320 	and.w	r3, r2, #32
34010ad0:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
34010ad4:	2300      	movs	r3, #0
34010ad6:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
34010ada:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
34010ade:	4603      	mov	r3, r0
34010ae0:	460a      	mov	r2, r1
34010ae2:	4313      	orrs	r3, r2
34010ae4:	d07e      	beq.n	34010be4 <HAL_RCCEx_PeriphCLKConfig+0x22dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));
34010ae6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010aea:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010aee:	2b00      	cmp	r3, #0
34010af0:	d019      	beq.n	34010b26 <HAL_RCCEx_PeriphCLKConfig+0x221e>
34010af2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010af6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010afa:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34010afe:	d012      	beq.n	34010b26 <HAL_RCCEx_PeriphCLKConfig+0x221e>
34010b00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b04:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010b08:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34010b0c:	d00b      	beq.n	34010b26 <HAL_RCCEx_PeriphCLKConfig+0x221e>
34010b0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b12:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010b16:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34010b1a:	d004      	beq.n	34010b26 <HAL_RCCEx_PeriphCLKConfig+0x221e>
34010b1c:	f44f 7132 	mov.w	r1, #712	@ 0x2c8
34010b20:	4826      	ldr	r0, [pc, #152]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010b22:	f7f0 fbb9 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
34010b26:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b2a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010b2e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34010b32:	d147      	bne.n	34010bc4 <HAL_RCCEx_PeriphCLKConfig+0x22bc>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
34010b34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b38:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34010b3a:	2b00      	cmp	r3, #0
34010b3c:	d016      	beq.n	34010b6c <HAL_RCCEx_PeriphCLKConfig+0x2264>
34010b3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b42:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34010b44:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010b48:	d010      	beq.n	34010b6c <HAL_RCCEx_PeriphCLKConfig+0x2264>
34010b4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b4e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34010b50:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010b54:	d00a      	beq.n	34010b6c <HAL_RCCEx_PeriphCLKConfig+0x2264>
34010b56:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b5a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34010b5c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010b60:	d004      	beq.n	34010b6c <HAL_RCCEx_PeriphCLKConfig+0x2264>
34010b62:	f240 21cd 	movw	r1, #717	@ 0x2cd
34010b66:	4815      	ldr	r0, [pc, #84]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010b68:	f7f0 fb96 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));
34010b6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b70:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34010b72:	2b00      	cmp	r3, #0
34010b74:	d005      	beq.n	34010b82 <HAL_RCCEx_PeriphCLKConfig+0x227a>
34010b76:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b7a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34010b7c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010b80:	d904      	bls.n	34010b8c <HAL_RCCEx_PeriphCLKConfig+0x2284>
34010b82:	f240 21ce 	movw	r1, #718	@ 0x2ce
34010b86:	480d      	ldr	r0, [pc, #52]	@ (34010bbc <HAL_RCCEx_PeriphCLKConfig+0x22b4>)
34010b88:	f7f0 fb86 	bl	34001298 <assert_failed>

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
34010b8c:	4b0c      	ldr	r3, [pc, #48]	@ (34010bc0 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
34010b8e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34010b92:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010b96:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010b9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010b9e:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
34010ba0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ba4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34010ba6:	3b01      	subs	r3, #1
34010ba8:	041b      	lsls	r3, r3, #16
34010baa:	4313      	orrs	r3, r2
34010bac:	4a04      	ldr	r2, [pc, #16]	@ (34010bc0 <HAL_RCCEx_PeriphCLKConfig+0x22b8>)
34010bae:	430b      	orrs	r3, r1
34010bb0:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
34010bb4:	f7fd fc46 	bl	3400e444 <LL_RCC_IC12_Enable>
34010bb8:	e00d      	b.n	34010bd6 <HAL_RCCEx_PeriphCLKConfig+0x22ce>
34010bba:	bf00      	nop
34010bbc:	3402444c 	.word	0x3402444c
34010bc0:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
34010bc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010bc8:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010bcc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34010bd0:	d101      	bne.n	34010bd6 <HAL_RCCEx_PeriphCLKConfig+0x22ce>
    {
      LL_RCC_CLKP_Enable();
34010bd2:	f7fd fe77 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
34010bd6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010bda:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010bde:	4618      	mov	r0, r3
34010be0:	f7fc fcba 	bl	3400d558 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34010be4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010be8:	e9d3 2300 	ldrd	r2, r3, [r3]
34010bec:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34010bf0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
34010bf4:	2300      	movs	r3, #0
34010bf6:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
34010bfa:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
34010bfe:	4603      	mov	r3, r0
34010c00:	460a      	mov	r2, r1
34010c02:	4313      	orrs	r3, r2
34010c04:	d01f      	beq.n	34010c46 <HAL_RCCEx_PeriphCLKConfig+0x233e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));
34010c06:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c0a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010c0e:	2b00      	cmp	r3, #0
34010c10:	d012      	beq.n	34010c38 <HAL_RCCEx_PeriphCLKConfig+0x2330>
34010c12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c16:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010c1a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34010c1e:	d00b      	beq.n	34010c38 <HAL_RCCEx_PeriphCLKConfig+0x2330>
34010c20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c24:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010c28:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34010c2c:	d004      	beq.n	34010c38 <HAL_RCCEx_PeriphCLKConfig+0x2330>
34010c2e:	f44f 713a 	mov.w	r1, #744	@ 0x2e8
34010c32:	48c1      	ldr	r0, [pc, #772]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010c34:	f7f0 fb30 	bl	34001298 <assert_failed>

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
34010c38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c3c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010c40:	4618      	mov	r0, r3
34010c42:	f7fc fc9f 	bl	3400d584 <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34010c46:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c4a:	e9d3 2300 	ldrd	r2, r3, [r3]
34010c4e:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34010c52:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34010c56:	2300      	movs	r3, #0
34010c58:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34010c5c:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
34010c60:	4603      	mov	r3, r0
34010c62:	460a      	mov	r2, r1
34010c64:	4313      	orrs	r3, r2
34010c66:	d018      	beq.n	34010c9a <HAL_RCCEx_PeriphCLKConfig+0x2392>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));
34010c68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c6c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010c70:	2b00      	cmp	r3, #0
34010c72:	d00b      	beq.n	34010c8c <HAL_RCCEx_PeriphCLKConfig+0x2384>
34010c74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c78:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010c7c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34010c80:	d004      	beq.n	34010c8c <HAL_RCCEx_PeriphCLKConfig+0x2384>
34010c82:	f240 21f2 	movw	r1, #754	@ 0x2f2
34010c86:	48ac      	ldr	r0, [pc, #688]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010c88:	f7f0 fb06 	bl	34001298 <assert_failed>

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34010c8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c90:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010c94:	4618      	mov	r0, r3
34010c96:	f7fc fc99 	bl	3400d5cc <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34010c9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010c9e:	e9d3 2300 	ldrd	r2, r3, [r3]
34010ca2:	f402 7380 	and.w	r3, r2, #256	@ 0x100
34010ca6:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34010caa:	2300      	movs	r3, #0
34010cac:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34010cb0:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
34010cb4:	4603      	mov	r3, r0
34010cb6:	460a      	mov	r2, r1
34010cb8:	4313      	orrs	r3, r2
34010cba:	d018      	beq.n	34010cee <HAL_RCCEx_PeriphCLKConfig+0x23e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));
34010cbc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010cc0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34010cc4:	2b00      	cmp	r3, #0
34010cc6:	d00b      	beq.n	34010ce0 <HAL_RCCEx_PeriphCLKConfig+0x23d8>
34010cc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ccc:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34010cd0:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34010cd4:	d004      	beq.n	34010ce0 <HAL_RCCEx_PeriphCLKConfig+0x23d8>
34010cd6:	f44f 713f 	mov.w	r1, #764	@ 0x2fc
34010cda:	4897      	ldr	r0, [pc, #604]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010cdc:	f7f0 fadc 	bl	34001298 <assert_failed>

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
34010ce0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ce4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34010ce8:	4618      	mov	r0, r3
34010cea:	f7fc fc85 	bl	3400d5f8 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34010cee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010cf2:	e9d3 2300 	ldrd	r2, r3, [r3]
34010cf6:	f402 7300 	and.w	r3, r2, #512	@ 0x200
34010cfa:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34010cfe:	2300      	movs	r3, #0
34010d00:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34010d04:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
34010d08:	4603      	mov	r3, r0
34010d0a:	460a      	mov	r2, r1
34010d0c:	4313      	orrs	r3, r2
34010d0e:	f000 8093 	beq.w	34010e38 <HAL_RCCEx_PeriphCLKConfig+0x2530>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
34010d12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d16:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010d1a:	2b00      	cmp	r3, #0
34010d1c:	d016      	beq.n	34010d4c <HAL_RCCEx_PeriphCLKConfig+0x2444>
34010d1e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d22:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010d26:	2b01      	cmp	r3, #1
34010d28:	d010      	beq.n	34010d4c <HAL_RCCEx_PeriphCLKConfig+0x2444>
34010d2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d2e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010d32:	2b02      	cmp	r3, #2
34010d34:	d00a      	beq.n	34010d4c <HAL_RCCEx_PeriphCLKConfig+0x2444>
34010d36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d3a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010d3e:	2b03      	cmp	r3, #3
34010d40:	d004      	beq.n	34010d4c <HAL_RCCEx_PeriphCLKConfig+0x2444>
34010d42:	f240 3106 	movw	r1, #774	@ 0x306
34010d46:	487c      	ldr	r0, [pc, #496]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010d48:	f7f0 faa6 	bl	34001298 <assert_failed>
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));
34010d4c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d50:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34010d54:	2b00      	cmp	r3, #0
34010d56:	d005      	beq.n	34010d64 <HAL_RCCEx_PeriphCLKConfig+0x245c>
34010d58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d5c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34010d60:	2b10      	cmp	r3, #16
34010d62:	d904      	bls.n	34010d6e <HAL_RCCEx_PeriphCLKConfig+0x2466>
34010d64:	f240 3107 	movw	r1, #775	@ 0x307
34010d68:	4873      	ldr	r0, [pc, #460]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010d6a:	f7f0 fa95 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
34010d6e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d72:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010d76:	2b02      	cmp	r3, #2
34010d78:	d142      	bne.n	34010e00 <HAL_RCCEx_PeriphCLKConfig+0x24f8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
34010d7a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d7e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34010d80:	2b00      	cmp	r3, #0
34010d82:	d016      	beq.n	34010db2 <HAL_RCCEx_PeriphCLKConfig+0x24aa>
34010d84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d88:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34010d8a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010d8e:	d010      	beq.n	34010db2 <HAL_RCCEx_PeriphCLKConfig+0x24aa>
34010d90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010d94:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34010d96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010d9a:	d00a      	beq.n	34010db2 <HAL_RCCEx_PeriphCLKConfig+0x24aa>
34010d9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010da0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34010da2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010da6:	d004      	beq.n	34010db2 <HAL_RCCEx_PeriphCLKConfig+0x24aa>
34010da8:	f44f 7143 	mov.w	r1, #780	@ 0x30c
34010dac:	4862      	ldr	r0, [pc, #392]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010dae:	f7f0 fa73 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));
34010db2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010db6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34010db8:	2b00      	cmp	r3, #0
34010dba:	d005      	beq.n	34010dc8 <HAL_RCCEx_PeriphCLKConfig+0x24c0>
34010dbc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010dc0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34010dc2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010dc6:	d904      	bls.n	34010dd2 <HAL_RCCEx_PeriphCLKConfig+0x24ca>
34010dc8:	f240 310d 	movw	r1, #781	@ 0x30d
34010dcc:	485a      	ldr	r0, [pc, #360]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010dce:	f7f0 fa63 	bl	34001298 <assert_failed>

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34010dd2:	4b5a      	ldr	r3, [pc, #360]	@ (34010f3c <HAL_RCCEx_PeriphCLKConfig+0x2634>)
34010dd4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34010dd8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010ddc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010de0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010de4:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
34010de6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010dea:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34010dec:	3b01      	subs	r3, #1
34010dee:	041b      	lsls	r3, r3, #16
34010df0:	4313      	orrs	r3, r2
34010df2:	4a52      	ldr	r2, [pc, #328]	@ (34010f3c <HAL_RCCEx_PeriphCLKConfig+0x2634>)
34010df4:	430b      	orrs	r3, r1
34010df6:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
34010dfa:	f7fd fb63 	bl	3400e4c4 <LL_RCC_IC13_Enable>
34010dfe:	e007      	b.n	34010e10 <HAL_RCCEx_PeriphCLKConfig+0x2508>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
34010e00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e04:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010e08:	2b01      	cmp	r3, #1
34010e0a:	d101      	bne.n	34010e10 <HAL_RCCEx_PeriphCLKConfig+0x2508>
    {
      LL_RCC_CLKP_Enable();
34010e0c:	f7fd fd5a 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34010e10:	4b4a      	ldr	r3, [pc, #296]	@ (34010f3c <HAL_RCCEx_PeriphCLKConfig+0x2634>)
34010e12:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34010e16:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
34010e1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e1e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34010e22:	3b01      	subs	r3, #1
34010e24:	011a      	lsls	r2, r3, #4
34010e26:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e2a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010e2e:	4313      	orrs	r3, r2
34010e30:	4a42      	ldr	r2, [pc, #264]	@ (34010f3c <HAL_RCCEx_PeriphCLKConfig+0x2634>)
34010e32:	430b      	orrs	r3, r1
34010e34:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
34010e38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e3c:	e9d3 2300 	ldrd	r2, r3, [r3]
34010e40:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34010e44:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34010e48:	2300      	movs	r3, #0
34010e4a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
34010e4e:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34010e52:	4603      	mov	r3, r0
34010e54:	460a      	mov	r2, r1
34010e56:	4313      	orrs	r3, r2
34010e58:	f000 8081 	beq.w	34010f5e <HAL_RCCEx_PeriphCLKConfig+0x2656>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));
34010e5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e60:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010e64:	2b00      	cmp	r3, #0
34010e66:	d016      	beq.n	34010e96 <HAL_RCCEx_PeriphCLKConfig+0x258e>
34010e68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e6c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010e70:	2b01      	cmp	r3, #1
34010e72:	d010      	beq.n	34010e96 <HAL_RCCEx_PeriphCLKConfig+0x258e>
34010e74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e78:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010e7c:	2b02      	cmp	r3, #2
34010e7e:	d00a      	beq.n	34010e96 <HAL_RCCEx_PeriphCLKConfig+0x258e>
34010e80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e84:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010e88:	2b03      	cmp	r3, #3
34010e8a:	d004      	beq.n	34010e96 <HAL_RCCEx_PeriphCLKConfig+0x258e>
34010e8c:	f44f 714a 	mov.w	r1, #808	@ 0x328
34010e90:	4829      	ldr	r0, [pc, #164]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010e92:	f7f0 fa01 	bl	34001298 <assert_failed>

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
34010e96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010e9a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010e9e:	2b02      	cmp	r3, #2
34010ea0:	d14e      	bne.n	34010f40 <HAL_RCCEx_PeriphCLKConfig+0x2638>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
34010ea2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ea6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34010eaa:	2b00      	cmp	r3, #0
34010eac:	d019      	beq.n	34010ee2 <HAL_RCCEx_PeriphCLKConfig+0x25da>
34010eae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010eb2:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34010eb6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34010eba:	d012      	beq.n	34010ee2 <HAL_RCCEx_PeriphCLKConfig+0x25da>
34010ebc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ec0:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34010ec4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34010ec8:	d00b      	beq.n	34010ee2 <HAL_RCCEx_PeriphCLKConfig+0x25da>
34010eca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ece:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34010ed2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34010ed6:	d004      	beq.n	34010ee2 <HAL_RCCEx_PeriphCLKConfig+0x25da>
34010ed8:	f240 312d 	movw	r1, #813	@ 0x32d
34010edc:	4816      	ldr	r0, [pc, #88]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010ede:	f7f0 f9db 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
34010ee2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ee6:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34010eea:	2b00      	cmp	r3, #0
34010eec:	d006      	beq.n	34010efc <HAL_RCCEx_PeriphCLKConfig+0x25f4>
34010eee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ef2:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34010ef6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34010efa:	d904      	bls.n	34010f06 <HAL_RCCEx_PeriphCLKConfig+0x25fe>
34010efc:	f240 312e 	movw	r1, #814	@ 0x32e
34010f00:	480d      	ldr	r0, [pc, #52]	@ (34010f38 <HAL_RCCEx_PeriphCLKConfig+0x2630>)
34010f02:	f7f0 f9c9 	bl	34001298 <assert_failed>

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34010f06:	4b0d      	ldr	r3, [pc, #52]	@ (34010f3c <HAL_RCCEx_PeriphCLKConfig+0x2634>)
34010f08:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34010f0c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010f10:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010f14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f18:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34010f1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f20:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34010f24:	3b01      	subs	r3, #1
34010f26:	041b      	lsls	r3, r3, #16
34010f28:	4313      	orrs	r3, r2
34010f2a:	4a04      	ldr	r2, [pc, #16]	@ (34010f3c <HAL_RCCEx_PeriphCLKConfig+0x2634>)
34010f2c:	430b      	orrs	r3, r1
34010f2e:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34010f32:	f7fd fc47 	bl	3400e7c4 <LL_RCC_IC19_Enable>
34010f36:	e00b      	b.n	34010f50 <HAL_RCCEx_PeriphCLKConfig+0x2648>
34010f38:	3402444c 	.word	0x3402444c
34010f3c:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
34010f40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f44:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010f48:	2b01      	cmp	r3, #1
34010f4a:	d101      	bne.n	34010f50 <HAL_RCCEx_PeriphCLKConfig+0x2648>
    {
      LL_RCC_CLKP_Enable();
34010f4c:	f7fd fcba 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
34010f50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f54:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010f58:	4618      	mov	r0, r3
34010f5a:	f7fc fb63 	bl	3400d624 <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
34010f5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f62:	e9d3 2300 	ldrd	r2, r3, [r3]
34010f66:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
34010f6a:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
34010f6e:	2300      	movs	r3, #0
34010f70:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
34010f74:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34010f78:	4603      	mov	r3, r0
34010f7a:	460a      	mov	r2, r1
34010f7c:	4313      	orrs	r3, r2
34010f7e:	f000 80d3 	beq.w	34011128 <HAL_RCCEx_PeriphCLKConfig+0x2820>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
34010f82:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f86:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010f8a:	4bad      	ldr	r3, [pc, #692]	@ (34011240 <HAL_RCCEx_PeriphCLKConfig+0x2938>)
34010f8c:	429a      	cmp	r2, r3
34010f8e:	d027      	beq.n	34010fe0 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
34010f90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010f94:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010f98:	4baa      	ldr	r3, [pc, #680]	@ (34011244 <HAL_RCCEx_PeriphCLKConfig+0x293c>)
34010f9a:	429a      	cmp	r2, r3
34010f9c:	d020      	beq.n	34010fe0 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
34010f9e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010fa2:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010fa6:	4ba8      	ldr	r3, [pc, #672]	@ (34011248 <HAL_RCCEx_PeriphCLKConfig+0x2940>)
34010fa8:	429a      	cmp	r2, r3
34010faa:	d019      	beq.n	34010fe0 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
34010fac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010fb0:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010fb4:	4ba5      	ldr	r3, [pc, #660]	@ (3401124c <HAL_RCCEx_PeriphCLKConfig+0x2944>)
34010fb6:	429a      	cmp	r2, r3
34010fb8:	d012      	beq.n	34010fe0 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
34010fba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010fbe:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010fc2:	4ba3      	ldr	r3, [pc, #652]	@ (34011250 <HAL_RCCEx_PeriphCLKConfig+0x2948>)
34010fc4:	429a      	cmp	r2, r3
34010fc6:	d00b      	beq.n	34010fe0 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
34010fc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010fcc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010fd0:	4ba0      	ldr	r3, [pc, #640]	@ (34011254 <HAL_RCCEx_PeriphCLKConfig+0x294c>)
34010fd2:	429a      	cmp	r2, r3
34010fd4:	d004      	beq.n	34010fe0 <HAL_RCCEx_PeriphCLKConfig+0x26d8>
34010fd6:	f44f 7152 	mov.w	r1, #840	@ 0x348
34010fda:	489f      	ldr	r0, [pc, #636]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
34010fdc:	f7f0 f95c 	bl	34001298 <assert_failed>

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
34010fe0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010fe4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34010fe8:	4b97      	ldr	r3, [pc, #604]	@ (34011248 <HAL_RCCEx_PeriphCLKConfig+0x2940>)
34010fea:	429a      	cmp	r2, r3
34010fec:	d142      	bne.n	34011074 <HAL_RCCEx_PeriphCLKConfig+0x276c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
34010fee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ff2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34010ff4:	2b00      	cmp	r3, #0
34010ff6:	d016      	beq.n	34011026 <HAL_RCCEx_PeriphCLKConfig+0x271e>
34010ff8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34010ffc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34010ffe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011002:	d010      	beq.n	34011026 <HAL_RCCEx_PeriphCLKConfig+0x271e>
34011004:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011008:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3401100a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401100e:	d00a      	beq.n	34011026 <HAL_RCCEx_PeriphCLKConfig+0x271e>
34011010:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011014:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34011016:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401101a:	d004      	beq.n	34011026 <HAL_RCCEx_PeriphCLKConfig+0x271e>
3401101c:	f240 314d 	movw	r1, #845	@ 0x34d
34011020:	488d      	ldr	r0, [pc, #564]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
34011022:	f7f0 f939 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
34011026:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401102a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401102c:	2b00      	cmp	r3, #0
3401102e:	d005      	beq.n	3401103c <HAL_RCCEx_PeriphCLKConfig+0x2734>
34011030:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011034:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011036:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401103a:	d904      	bls.n	34011046 <HAL_RCCEx_PeriphCLKConfig+0x273e>
3401103c:	f240 314e 	movw	r1, #846	@ 0x34e
34011040:	4885      	ldr	r0, [pc, #532]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
34011042:	f7f0 f929 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011046:	4b85      	ldr	r3, [pc, #532]	@ (3401125c <HAL_RCCEx_PeriphCLKConfig+0x2954>)
34011048:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401104c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011050:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011054:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011058:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3401105a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401105e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011060:	3b01      	subs	r3, #1
34011062:	041b      	lsls	r3, r3, #16
34011064:	4313      	orrs	r3, r2
34011066:	4a7d      	ldr	r2, [pc, #500]	@ (3401125c <HAL_RCCEx_PeriphCLKConfig+0x2954>)
34011068:	430b      	orrs	r3, r1
3401106a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3401106e:	f7fd f9a9 	bl	3400e3c4 <LL_RCC_IC10_Enable>
34011072:	e052      	b.n	3401111a <HAL_RCCEx_PeriphCLKConfig+0x2812>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
34011074:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011078:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3401107c:	4b73      	ldr	r3, [pc, #460]	@ (3401124c <HAL_RCCEx_PeriphCLKConfig+0x2944>)
3401107e:	429a      	cmp	r2, r3
34011080:	d142      	bne.n	34011108 <HAL_RCCEx_PeriphCLKConfig+0x2800>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011082:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011086:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011088:	2b00      	cmp	r3, #0
3401108a:	d016      	beq.n	340110ba <HAL_RCCEx_PeriphCLKConfig+0x27b2>
3401108c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011090:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011092:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011096:	d010      	beq.n	340110ba <HAL_RCCEx_PeriphCLKConfig+0x27b2>
34011098:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401109c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401109e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340110a2:	d00a      	beq.n	340110ba <HAL_RCCEx_PeriphCLKConfig+0x27b2>
340110a4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340110a8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340110aa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340110ae:	d004      	beq.n	340110ba <HAL_RCCEx_PeriphCLKConfig+0x27b2>
340110b0:	f240 315a 	movw	r1, #858	@ 0x35a
340110b4:	4868      	ldr	r0, [pc, #416]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
340110b6:	f7f0 f8ef 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
340110ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340110be:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340110c0:	2b00      	cmp	r3, #0
340110c2:	d005      	beq.n	340110d0 <HAL_RCCEx_PeriphCLKConfig+0x27c8>
340110c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340110c8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340110ca:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340110ce:	d904      	bls.n	340110da <HAL_RCCEx_PeriphCLKConfig+0x27d2>
340110d0:	f240 315b 	movw	r1, #859	@ 0x35b
340110d4:	4860      	ldr	r0, [pc, #384]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
340110d6:	f7f0 f8df 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340110da:	4b60      	ldr	r3, [pc, #384]	@ (3401125c <HAL_RCCEx_PeriphCLKConfig+0x2954>)
340110dc:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340110e0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340110e4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340110e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340110ec:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340110ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340110f2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340110f4:	3b01      	subs	r3, #1
340110f6:	041b      	lsls	r3, r3, #16
340110f8:	4313      	orrs	r3, r2
340110fa:	4a58      	ldr	r2, [pc, #352]	@ (3401125c <HAL_RCCEx_PeriphCLKConfig+0x2954>)
340110fc:	430b      	orrs	r3, r1
340110fe:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011102:	f7fd fa5f 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34011106:	e008      	b.n	3401111a <HAL_RCCEx_PeriphCLKConfig+0x2812>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34011108:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401110c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34011110:	4b4c      	ldr	r3, [pc, #304]	@ (34011244 <HAL_RCCEx_PeriphCLKConfig+0x293c>)
34011112:	429a      	cmp	r2, r3
34011114:	d101      	bne.n	3401111a <HAL_RCCEx_PeriphCLKConfig+0x2812>
    {
      LL_RCC_CLKP_Enable();
34011116:	f7fd fbd5 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
3401111a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401111e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34011122:	4618      	mov	r0, r3
34011124:	f7fc faaa 	bl	3400d67c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
34011128:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401112c:	e9d3 2300 	ldrd	r2, r3, [r3]
34011130:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
34011134:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
34011138:	2300      	movs	r3, #0
3401113a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
3401113e:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
34011142:	4603      	mov	r3, r0
34011144:	460a      	mov	r2, r1
34011146:	4313      	orrs	r3, r2
34011148:	f000 80f0 	beq.w	3401132c <HAL_RCCEx_PeriphCLKConfig+0x2a24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
3401114c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011150:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34011154:	4b42      	ldr	r3, [pc, #264]	@ (34011260 <HAL_RCCEx_PeriphCLKConfig+0x2958>)
34011156:	429a      	cmp	r2, r3
34011158:	d027      	beq.n	340111aa <HAL_RCCEx_PeriphCLKConfig+0x28a2>
3401115a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401115e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34011162:	4b40      	ldr	r3, [pc, #256]	@ (34011264 <HAL_RCCEx_PeriphCLKConfig+0x295c>)
34011164:	429a      	cmp	r2, r3
34011166:	d020      	beq.n	340111aa <HAL_RCCEx_PeriphCLKConfig+0x28a2>
34011168:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401116c:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34011170:	4b3d      	ldr	r3, [pc, #244]	@ (34011268 <HAL_RCCEx_PeriphCLKConfig+0x2960>)
34011172:	429a      	cmp	r2, r3
34011174:	d019      	beq.n	340111aa <HAL_RCCEx_PeriphCLKConfig+0x28a2>
34011176:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401117a:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3401117e:	4b3b      	ldr	r3, [pc, #236]	@ (3401126c <HAL_RCCEx_PeriphCLKConfig+0x2964>)
34011180:	429a      	cmp	r2, r3
34011182:	d012      	beq.n	340111aa <HAL_RCCEx_PeriphCLKConfig+0x28a2>
34011184:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011188:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3401118c:	4b38      	ldr	r3, [pc, #224]	@ (34011270 <HAL_RCCEx_PeriphCLKConfig+0x2968>)
3401118e:	429a      	cmp	r2, r3
34011190:	d00b      	beq.n	340111aa <HAL_RCCEx_PeriphCLKConfig+0x28a2>
34011192:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011196:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3401119a:	4b36      	ldr	r3, [pc, #216]	@ (34011274 <HAL_RCCEx_PeriphCLKConfig+0x296c>)
3401119c:	429a      	cmp	r2, r3
3401119e:	d004      	beq.n	340111aa <HAL_RCCEx_PeriphCLKConfig+0x28a2>
340111a0:	f240 3175 	movw	r1, #885	@ 0x375
340111a4:	482c      	ldr	r0, [pc, #176]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
340111a6:	f7f0 f877 	bl	34001298 <assert_failed>

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
340111aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111ae:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
340111b2:	4b2d      	ldr	r3, [pc, #180]	@ (34011268 <HAL_RCCEx_PeriphCLKConfig+0x2960>)
340111b4:	429a      	cmp	r2, r3
340111b6:	d15f      	bne.n	34011278 <HAL_RCCEx_PeriphCLKConfig+0x2970>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
340111b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111bc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340111be:	2b00      	cmp	r3, #0
340111c0:	d016      	beq.n	340111f0 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
340111c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111c6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340111c8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340111cc:	d010      	beq.n	340111f0 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
340111ce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111d2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340111d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340111d8:	d00a      	beq.n	340111f0 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
340111da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111de:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340111e0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340111e4:	d004      	beq.n	340111f0 <HAL_RCCEx_PeriphCLKConfig+0x28e8>
340111e6:	f240 317a 	movw	r1, #890	@ 0x37a
340111ea:	481b      	ldr	r0, [pc, #108]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
340111ec:	f7f0 f854 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
340111f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111f4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340111f6:	2b00      	cmp	r3, #0
340111f8:	d005      	beq.n	34011206 <HAL_RCCEx_PeriphCLKConfig+0x28fe>
340111fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340111fe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011200:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011204:	d904      	bls.n	34011210 <HAL_RCCEx_PeriphCLKConfig+0x2908>
34011206:	f240 317b 	movw	r1, #891	@ 0x37b
3401120a:	4813      	ldr	r0, [pc, #76]	@ (34011258 <HAL_RCCEx_PeriphCLKConfig+0x2950>)
3401120c:	f7f0 f844 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011210:	4b12      	ldr	r3, [pc, #72]	@ (3401125c <HAL_RCCEx_PeriphCLKConfig+0x2954>)
34011212:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34011216:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401121a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401121e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011222:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34011224:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011228:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401122a:	3b01      	subs	r3, #1
3401122c:	041b      	lsls	r3, r3, #16
3401122e:	4313      	orrs	r3, r2
34011230:	4a0a      	ldr	r2, [pc, #40]	@ (3401125c <HAL_RCCEx_PeriphCLKConfig+0x2954>)
34011232:	430b      	orrs	r3, r1
34011234:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34011238:	f7fd f8c4 	bl	3400e3c4 <LL_RCC_IC10_Enable>
3401123c:	e06f      	b.n	3401131e <HAL_RCCEx_PeriphCLKConfig+0x2a16>
3401123e:	bf00      	nop
34011240:	0700000c 	.word	0x0700000c
34011244:	0701000c 	.word	0x0701000c
34011248:	0702000c 	.word	0x0702000c
3401124c:	0703000c 	.word	0x0703000c
34011250:	0704000c 	.word	0x0704000c
34011254:	0705000c 	.word	0x0705000c
34011258:	3402444c 	.word	0x3402444c
3401125c:	56028000 	.word	0x56028000
34011260:	0700040c 	.word	0x0700040c
34011264:	0701040c 	.word	0x0701040c
34011268:	0702040c 	.word	0x0702040c
3401126c:	0703040c 	.word	0x0703040c
34011270:	0704040c 	.word	0x0704040c
34011274:	0705040c 	.word	0x0705040c
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
34011278:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401127c:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34011280:	4b95      	ldr	r3, [pc, #596]	@ (340114d8 <HAL_RCCEx_PeriphCLKConfig+0x2bd0>)
34011282:	429a      	cmp	r2, r3
34011284:	d142      	bne.n	3401130c <HAL_RCCEx_PeriphCLKConfig+0x2a04>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011286:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401128a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401128c:	2b00      	cmp	r3, #0
3401128e:	d016      	beq.n	340112be <HAL_RCCEx_PeriphCLKConfig+0x29b6>
34011290:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011294:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011296:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401129a:	d010      	beq.n	340112be <HAL_RCCEx_PeriphCLKConfig+0x29b6>
3401129c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340112a0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340112a2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340112a6:	d00a      	beq.n	340112be <HAL_RCCEx_PeriphCLKConfig+0x29b6>
340112a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340112ac:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340112ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340112b2:	d004      	beq.n	340112be <HAL_RCCEx_PeriphCLKConfig+0x29b6>
340112b4:	f240 3187 	movw	r1, #903	@ 0x387
340112b8:	4888      	ldr	r0, [pc, #544]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
340112ba:	f7ef ffed 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
340112be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340112c2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340112c4:	2b00      	cmp	r3, #0
340112c6:	d005      	beq.n	340112d4 <HAL_RCCEx_PeriphCLKConfig+0x29cc>
340112c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340112cc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340112ce:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340112d2:	d904      	bls.n	340112de <HAL_RCCEx_PeriphCLKConfig+0x29d6>
340112d4:	f44f 7162 	mov.w	r1, #904	@ 0x388
340112d8:	4880      	ldr	r0, [pc, #512]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
340112da:	f7ef ffdd 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340112de:	4b80      	ldr	r3, [pc, #512]	@ (340114e0 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
340112e0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340112e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340112e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340112ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340112f0:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340112f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340112f6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340112f8:	3b01      	subs	r3, #1
340112fa:	041b      	lsls	r3, r3, #16
340112fc:	4313      	orrs	r3, r2
340112fe:	4a78      	ldr	r2, [pc, #480]	@ (340114e0 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
34011300:	430b      	orrs	r3, r1
34011302:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011306:	f7fd f95d 	bl	3400e5c4 <LL_RCC_IC15_Enable>
3401130a:	e008      	b.n	3401131e <HAL_RCCEx_PeriphCLKConfig+0x2a16>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3401130c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011310:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34011314:	4b73      	ldr	r3, [pc, #460]	@ (340114e4 <HAL_RCCEx_PeriphCLKConfig+0x2bdc>)
34011316:	429a      	cmp	r2, r3
34011318:	d101      	bne.n	3401131e <HAL_RCCEx_PeriphCLKConfig+0x2a16>
    {
      LL_RCC_CLKP_Enable();
3401131a:	f7fd fad3 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
3401131e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011322:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34011326:	4618      	mov	r0, r3
34011328:	f7fc f9a8 	bl	3400d67c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3401132c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011330:	e9d3 2300 	ldrd	r2, r3, [r3]
34011334:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34011338:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
3401133c:	2300      	movs	r3, #0
3401133e:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34011342:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34011346:	4603      	mov	r3, r0
34011348:	460a      	mov	r2, r1
3401134a:	4313      	orrs	r3, r2
3401134c:	f000 80e8 	beq.w	34011520 <HAL_RCCEx_PeriphCLKConfig+0x2c18>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
34011350:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011354:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011358:	4b63      	ldr	r3, [pc, #396]	@ (340114e8 <HAL_RCCEx_PeriphCLKConfig+0x2be0>)
3401135a:	429a      	cmp	r2, r3
3401135c:	d027      	beq.n	340113ae <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3401135e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011362:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011366:	4b61      	ldr	r3, [pc, #388]	@ (340114ec <HAL_RCCEx_PeriphCLKConfig+0x2be4>)
34011368:	429a      	cmp	r2, r3
3401136a:	d020      	beq.n	340113ae <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3401136c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011370:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011374:	4b5e      	ldr	r3, [pc, #376]	@ (340114f0 <HAL_RCCEx_PeriphCLKConfig+0x2be8>)
34011376:	429a      	cmp	r2, r3
34011378:	d019      	beq.n	340113ae <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
3401137a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401137e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011382:	4b5c      	ldr	r3, [pc, #368]	@ (340114f4 <HAL_RCCEx_PeriphCLKConfig+0x2bec>)
34011384:	429a      	cmp	r2, r3
34011386:	d012      	beq.n	340113ae <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
34011388:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401138c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011390:	4b59      	ldr	r3, [pc, #356]	@ (340114f8 <HAL_RCCEx_PeriphCLKConfig+0x2bf0>)
34011392:	429a      	cmp	r2, r3
34011394:	d00b      	beq.n	340113ae <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
34011396:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401139a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3401139e:	4b57      	ldr	r3, [pc, #348]	@ (340114fc <HAL_RCCEx_PeriphCLKConfig+0x2bf4>)
340113a0:	429a      	cmp	r2, r3
340113a2:	d004      	beq.n	340113ae <HAL_RCCEx_PeriphCLKConfig+0x2aa6>
340113a4:	f240 31a2 	movw	r1, #930	@ 0x3a2
340113a8:	484c      	ldr	r0, [pc, #304]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
340113aa:	f7ef ff75 	bl	34001298 <assert_failed>

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
340113ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340113b2:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
340113b6:	4b4e      	ldr	r3, [pc, #312]	@ (340114f0 <HAL_RCCEx_PeriphCLKConfig+0x2be8>)
340113b8:	429a      	cmp	r2, r3
340113ba:	d142      	bne.n	34011442 <HAL_RCCEx_PeriphCLKConfig+0x2b3a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
340113bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340113c0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340113c2:	2b00      	cmp	r3, #0
340113c4:	d016      	beq.n	340113f4 <HAL_RCCEx_PeriphCLKConfig+0x2aec>
340113c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340113ca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340113cc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340113d0:	d010      	beq.n	340113f4 <HAL_RCCEx_PeriphCLKConfig+0x2aec>
340113d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340113d6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340113d8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340113dc:	d00a      	beq.n	340113f4 <HAL_RCCEx_PeriphCLKConfig+0x2aec>
340113de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340113e2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340113e4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340113e8:	d004      	beq.n	340113f4 <HAL_RCCEx_PeriphCLKConfig+0x2aec>
340113ea:	f240 31a7 	movw	r1, #935	@ 0x3a7
340113ee:	483b      	ldr	r0, [pc, #236]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
340113f0:	f7ef ff52 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
340113f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340113f8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340113fa:	2b00      	cmp	r3, #0
340113fc:	d005      	beq.n	3401140a <HAL_RCCEx_PeriphCLKConfig+0x2b02>
340113fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011402:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011404:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011408:	d904      	bls.n	34011414 <HAL_RCCEx_PeriphCLKConfig+0x2b0c>
3401140a:	f44f 716a 	mov.w	r1, #936	@ 0x3a8
3401140e:	4833      	ldr	r0, [pc, #204]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
34011410:	f7ef ff42 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011414:	4b32      	ldr	r3, [pc, #200]	@ (340114e0 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
34011416:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401141a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401141e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011422:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011426:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34011428:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401142c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401142e:	3b01      	subs	r3, #1
34011430:	041b      	lsls	r3, r3, #16
34011432:	4313      	orrs	r3, r2
34011434:	4a2a      	ldr	r2, [pc, #168]	@ (340114e0 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
34011436:	430b      	orrs	r3, r1
34011438:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3401143c:	f7fc ffc2 	bl	3400e3c4 <LL_RCC_IC10_Enable>
34011440:	e067      	b.n	34011512 <HAL_RCCEx_PeriphCLKConfig+0x2c0a>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
34011442:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011446:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3401144a:	4b2a      	ldr	r3, [pc, #168]	@ (340114f4 <HAL_RCCEx_PeriphCLKConfig+0x2bec>)
3401144c:	429a      	cmp	r2, r3
3401144e:	d157      	bne.n	34011500 <HAL_RCCEx_PeriphCLKConfig+0x2bf8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011450:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011454:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011456:	2b00      	cmp	r3, #0
34011458:	d016      	beq.n	34011488 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
3401145a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401145e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011460:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011464:	d010      	beq.n	34011488 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
34011466:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401146a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401146c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011470:	d00a      	beq.n	34011488 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
34011472:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011476:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011478:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401147c:	d004      	beq.n	34011488 <HAL_RCCEx_PeriphCLKConfig+0x2b80>
3401147e:	f44f 716d 	mov.w	r1, #948	@ 0x3b4
34011482:	4816      	ldr	r0, [pc, #88]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
34011484:	f7ef ff08 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34011488:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401148c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401148e:	2b00      	cmp	r3, #0
34011490:	d005      	beq.n	3401149e <HAL_RCCEx_PeriphCLKConfig+0x2b96>
34011492:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011496:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011498:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401149c:	d904      	bls.n	340114a8 <HAL_RCCEx_PeriphCLKConfig+0x2ba0>
3401149e:	f240 31b5 	movw	r1, #949	@ 0x3b5
340114a2:	480e      	ldr	r0, [pc, #56]	@ (340114dc <HAL_RCCEx_PeriphCLKConfig+0x2bd4>)
340114a4:	f7ef fef8 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340114a8:	4b0d      	ldr	r3, [pc, #52]	@ (340114e0 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
340114aa:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340114ae:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340114b2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340114b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340114ba:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340114bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340114c0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340114c2:	3b01      	subs	r3, #1
340114c4:	041b      	lsls	r3, r3, #16
340114c6:	4313      	orrs	r3, r2
340114c8:	4a05      	ldr	r2, [pc, #20]	@ (340114e0 <HAL_RCCEx_PeriphCLKConfig+0x2bd8>)
340114ca:	430b      	orrs	r3, r1
340114cc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340114d0:	f7fd f878 	bl	3400e5c4 <LL_RCC_IC15_Enable>
340114d4:	e01d      	b.n	34011512 <HAL_RCCEx_PeriphCLKConfig+0x2c0a>
340114d6:	bf00      	nop
340114d8:	0703040c 	.word	0x0703040c
340114dc:	3402444c 	.word	0x3402444c
340114e0:	56028000 	.word	0x56028000
340114e4:	0701040c 	.word	0x0701040c
340114e8:	0700080c 	.word	0x0700080c
340114ec:	0701080c 	.word	0x0701080c
340114f0:	0702080c 	.word	0x0702080c
340114f4:	0703080c 	.word	0x0703080c
340114f8:	0704080c 	.word	0x0704080c
340114fc:	0705080c 	.word	0x0705080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
34011500:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011504:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011508:	4b70      	ldr	r3, [pc, #448]	@ (340116cc <HAL_RCCEx_PeriphCLKConfig+0x2dc4>)
3401150a:	429a      	cmp	r2, r3
3401150c:	d101      	bne.n	34011512 <HAL_RCCEx_PeriphCLKConfig+0x2c0a>
    {
      LL_RCC_CLKP_Enable();
3401150e:	f7fd f9d9 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
34011512:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011516:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3401151a:	4618      	mov	r0, r3
3401151c:	f7fc f8ae 	bl	3400d67c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34011520:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011524:	e9d3 2300 	ldrd	r2, r3, [r3]
34011528:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
3401152c:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34011530:	2300      	movs	r3, #0
34011532:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
34011536:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
3401153a:	4603      	mov	r3, r0
3401153c:	460a      	mov	r2, r1
3401153e:	4313      	orrs	r3, r2
34011540:	f000 80e6 	beq.w	34011710 <HAL_RCCEx_PeriphCLKConfig+0x2e08>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
34011544:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011548:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3401154c:	4b60      	ldr	r3, [pc, #384]	@ (340116d0 <HAL_RCCEx_PeriphCLKConfig+0x2dc8>)
3401154e:	429a      	cmp	r2, r3
34011550:	d027      	beq.n	340115a2 <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
34011552:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011556:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3401155a:	4b5e      	ldr	r3, [pc, #376]	@ (340116d4 <HAL_RCCEx_PeriphCLKConfig+0x2dcc>)
3401155c:	429a      	cmp	r2, r3
3401155e:	d020      	beq.n	340115a2 <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
34011560:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011564:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34011568:	4b5b      	ldr	r3, [pc, #364]	@ (340116d8 <HAL_RCCEx_PeriphCLKConfig+0x2dd0>)
3401156a:	429a      	cmp	r2, r3
3401156c:	d019      	beq.n	340115a2 <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3401156e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011572:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34011576:	4b59      	ldr	r3, [pc, #356]	@ (340116dc <HAL_RCCEx_PeriphCLKConfig+0x2dd4>)
34011578:	429a      	cmp	r2, r3
3401157a:	d012      	beq.n	340115a2 <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3401157c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011580:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34011584:	4b56      	ldr	r3, [pc, #344]	@ (340116e0 <HAL_RCCEx_PeriphCLKConfig+0x2dd8>)
34011586:	429a      	cmp	r2, r3
34011588:	d00b      	beq.n	340115a2 <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
3401158a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401158e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34011592:	4b54      	ldr	r3, [pc, #336]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0x2ddc>)
34011594:	429a      	cmp	r2, r3
34011596:	d004      	beq.n	340115a2 <HAL_RCCEx_PeriphCLKConfig+0x2c9a>
34011598:	f240 31cf 	movw	r1, #975	@ 0x3cf
3401159c:	4852      	ldr	r0, [pc, #328]	@ (340116e8 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
3401159e:	f7ef fe7b 	bl	34001298 <assert_failed>

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
340115a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115a6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
340115aa:	4b4b      	ldr	r3, [pc, #300]	@ (340116d8 <HAL_RCCEx_PeriphCLKConfig+0x2dd0>)
340115ac:	429a      	cmp	r2, r3
340115ae:	d142      	bne.n	34011636 <HAL_RCCEx_PeriphCLKConfig+0x2d2e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
340115b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115b4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340115b6:	2b00      	cmp	r3, #0
340115b8:	d016      	beq.n	340115e8 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
340115ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115be:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340115c0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340115c4:	d010      	beq.n	340115e8 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
340115c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115ca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340115cc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340115d0:	d00a      	beq.n	340115e8 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
340115d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115d6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340115d8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340115dc:	d004      	beq.n	340115e8 <HAL_RCCEx_PeriphCLKConfig+0x2ce0>
340115de:	f44f 7175 	mov.w	r1, #980	@ 0x3d4
340115e2:	4841      	ldr	r0, [pc, #260]	@ (340116e8 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
340115e4:	f7ef fe58 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
340115e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115ec:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340115ee:	2b00      	cmp	r3, #0
340115f0:	d005      	beq.n	340115fe <HAL_RCCEx_PeriphCLKConfig+0x2cf6>
340115f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340115f6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340115f8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340115fc:	d904      	bls.n	34011608 <HAL_RCCEx_PeriphCLKConfig+0x2d00>
340115fe:	f240 31d5 	movw	r1, #981	@ 0x3d5
34011602:	4839      	ldr	r0, [pc, #228]	@ (340116e8 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
34011604:	f7ef fe48 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011608:	4b38      	ldr	r3, [pc, #224]	@ (340116ec <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3401160a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401160e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011612:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011616:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401161a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3401161c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011620:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011622:	3b01      	subs	r3, #1
34011624:	041b      	lsls	r3, r3, #16
34011626:	4313      	orrs	r3, r2
34011628:	4a30      	ldr	r2, [pc, #192]	@ (340116ec <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3401162a:	430b      	orrs	r3, r1
3401162c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34011630:	f7fc fec8 	bl	3400e3c4 <LL_RCC_IC10_Enable>
34011634:	e065      	b.n	34011702 <HAL_RCCEx_PeriphCLKConfig+0x2dfa>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
34011636:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401163a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3401163e:	4b27      	ldr	r3, [pc, #156]	@ (340116dc <HAL_RCCEx_PeriphCLKConfig+0x2dd4>)
34011640:	429a      	cmp	r2, r3
34011642:	d155      	bne.n	340116f0 <HAL_RCCEx_PeriphCLKConfig+0x2de8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011644:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011648:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401164a:	2b00      	cmp	r3, #0
3401164c:	d016      	beq.n	3401167c <HAL_RCCEx_PeriphCLKConfig+0x2d74>
3401164e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011652:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011654:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011658:	d010      	beq.n	3401167c <HAL_RCCEx_PeriphCLKConfig+0x2d74>
3401165a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401165e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011660:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011664:	d00a      	beq.n	3401167c <HAL_RCCEx_PeriphCLKConfig+0x2d74>
34011666:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401166a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401166c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011670:	d004      	beq.n	3401167c <HAL_RCCEx_PeriphCLKConfig+0x2d74>
34011672:	f240 31e1 	movw	r1, #993	@ 0x3e1
34011676:	481c      	ldr	r0, [pc, #112]	@ (340116e8 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
34011678:	f7ef fe0e 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3401167c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011680:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011682:	2b00      	cmp	r3, #0
34011684:	d005      	beq.n	34011692 <HAL_RCCEx_PeriphCLKConfig+0x2d8a>
34011686:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401168a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401168c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011690:	d904      	bls.n	3401169c <HAL_RCCEx_PeriphCLKConfig+0x2d94>
34011692:	f240 31e2 	movw	r1, #994	@ 0x3e2
34011696:	4814      	ldr	r0, [pc, #80]	@ (340116e8 <HAL_RCCEx_PeriphCLKConfig+0x2de0>)
34011698:	f7ef fdfe 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3401169c:	4b13      	ldr	r3, [pc, #76]	@ (340116ec <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
3401169e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340116a2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340116a6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340116aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340116ae:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340116b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340116b4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340116b6:	3b01      	subs	r3, #1
340116b8:	041b      	lsls	r3, r3, #16
340116ba:	4313      	orrs	r3, r2
340116bc:	4a0b      	ldr	r2, [pc, #44]	@ (340116ec <HAL_RCCEx_PeriphCLKConfig+0x2de4>)
340116be:	430b      	orrs	r3, r1
340116c0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340116c4:	f7fc ff7e 	bl	3400e5c4 <LL_RCC_IC15_Enable>
340116c8:	e01b      	b.n	34011702 <HAL_RCCEx_PeriphCLKConfig+0x2dfa>
340116ca:	bf00      	nop
340116cc:	0701080c 	.word	0x0701080c
340116d0:	07000c0c 	.word	0x07000c0c
340116d4:	07010c0c 	.word	0x07010c0c
340116d8:	07020c0c 	.word	0x07020c0c
340116dc:	07030c0c 	.word	0x07030c0c
340116e0:	07040c0c 	.word	0x07040c0c
340116e4:	07050c0c 	.word	0x07050c0c
340116e8:	3402444c 	.word	0x3402444c
340116ec:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
340116f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340116f4:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
340116f8:	4b70      	ldr	r3, [pc, #448]	@ (340118bc <HAL_RCCEx_PeriphCLKConfig+0x2fb4>)
340116fa:	429a      	cmp	r2, r3
340116fc:	d101      	bne.n	34011702 <HAL_RCCEx_PeriphCLKConfig+0x2dfa>
    {
      LL_RCC_CLKP_Enable();
340116fe:	f7fd f8e1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
34011702:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011706:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3401170a:	4618      	mov	r0, r3
3401170c:	f7fb ffb6 	bl	3400d67c <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
34011710:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011714:	e9d3 2300 	ldrd	r2, r3, [r3]
34011718:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3401171c:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
34011720:	2300      	movs	r3, #0
34011722:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
34011726:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
3401172a:	4603      	mov	r3, r0
3401172c:	460a      	mov	r2, r1
3401172e:	4313      	orrs	r3, r2
34011730:	f000 80e6 	beq.w	34011900 <HAL_RCCEx_PeriphCLKConfig+0x2ff8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));
34011734:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011738:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3401173c:	4b60      	ldr	r3, [pc, #384]	@ (340118c0 <HAL_RCCEx_PeriphCLKConfig+0x2fb8>)
3401173e:	429a      	cmp	r2, r3
34011740:	d027      	beq.n	34011792 <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
34011742:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011746:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3401174a:	4b5e      	ldr	r3, [pc, #376]	@ (340118c4 <HAL_RCCEx_PeriphCLKConfig+0x2fbc>)
3401174c:	429a      	cmp	r2, r3
3401174e:	d020      	beq.n	34011792 <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
34011750:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011754:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34011758:	4b5b      	ldr	r3, [pc, #364]	@ (340118c8 <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3401175a:	429a      	cmp	r2, r3
3401175c:	d019      	beq.n	34011792 <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3401175e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011762:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34011766:	4b59      	ldr	r3, [pc, #356]	@ (340118cc <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
34011768:	429a      	cmp	r2, r3
3401176a:	d012      	beq.n	34011792 <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3401176c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011770:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34011774:	4b56      	ldr	r3, [pc, #344]	@ (340118d0 <HAL_RCCEx_PeriphCLKConfig+0x2fc8>)
34011776:	429a      	cmp	r2, r3
34011778:	d00b      	beq.n	34011792 <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
3401177a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401177e:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34011782:	4b54      	ldr	r3, [pc, #336]	@ (340118d4 <HAL_RCCEx_PeriphCLKConfig+0x2fcc>)
34011784:	429a      	cmp	r2, r3
34011786:	d004      	beq.n	34011792 <HAL_RCCEx_PeriphCLKConfig+0x2e8a>
34011788:	f44f 717f 	mov.w	r1, #1020	@ 0x3fc
3401178c:	4852      	ldr	r0, [pc, #328]	@ (340118d8 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
3401178e:	f7ef fd83 	bl	34001298 <assert_failed>

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
34011792:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011796:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3401179a:	4b4b      	ldr	r3, [pc, #300]	@ (340118c8 <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3401179c:	429a      	cmp	r2, r3
3401179e:	d142      	bne.n	34011826 <HAL_RCCEx_PeriphCLKConfig+0x2f1e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
340117a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340117a4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340117a6:	2b00      	cmp	r3, #0
340117a8:	d016      	beq.n	340117d8 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
340117aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340117ae:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340117b0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340117b4:	d010      	beq.n	340117d8 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
340117b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340117ba:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340117bc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340117c0:	d00a      	beq.n	340117d8 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
340117c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340117c6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340117c8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340117cc:	d004      	beq.n	340117d8 <HAL_RCCEx_PeriphCLKConfig+0x2ed0>
340117ce:	f240 4101 	movw	r1, #1025	@ 0x401
340117d2:	4841      	ldr	r0, [pc, #260]	@ (340118d8 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
340117d4:	f7ef fd60 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
340117d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340117dc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340117de:	2b00      	cmp	r3, #0
340117e0:	d005      	beq.n	340117ee <HAL_RCCEx_PeriphCLKConfig+0x2ee6>
340117e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340117e6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340117e8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340117ec:	d904      	bls.n	340117f8 <HAL_RCCEx_PeriphCLKConfig+0x2ef0>
340117ee:	f240 4102 	movw	r1, #1026	@ 0x402
340117f2:	4839      	ldr	r0, [pc, #228]	@ (340118d8 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
340117f4:	f7ef fd50 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340117f8:	4b38      	ldr	r3, [pc, #224]	@ (340118dc <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
340117fa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340117fe:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011802:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011806:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401180a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3401180c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011810:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011812:	3b01      	subs	r3, #1
34011814:	041b      	lsls	r3, r3, #16
34011816:	4313      	orrs	r3, r2
34011818:	4a30      	ldr	r2, [pc, #192]	@ (340118dc <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
3401181a:	430b      	orrs	r3, r1
3401181c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34011820:	f7fc fdd0 	bl	3400e3c4 <LL_RCC_IC10_Enable>
34011824:	e065      	b.n	340118f2 <HAL_RCCEx_PeriphCLKConfig+0x2fea>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34011826:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401182a:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3401182e:	4b27      	ldr	r3, [pc, #156]	@ (340118cc <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
34011830:	429a      	cmp	r2, r3
34011832:	d155      	bne.n	340118e0 <HAL_RCCEx_PeriphCLKConfig+0x2fd8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011834:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011838:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401183a:	2b00      	cmp	r3, #0
3401183c:	d016      	beq.n	3401186c <HAL_RCCEx_PeriphCLKConfig+0x2f64>
3401183e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011842:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011844:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011848:	d010      	beq.n	3401186c <HAL_RCCEx_PeriphCLKConfig+0x2f64>
3401184a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401184e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011850:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011854:	d00a      	beq.n	3401186c <HAL_RCCEx_PeriphCLKConfig+0x2f64>
34011856:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401185a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401185c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011860:	d004      	beq.n	3401186c <HAL_RCCEx_PeriphCLKConfig+0x2f64>
34011862:	f240 410e 	movw	r1, #1038	@ 0x40e
34011866:	481c      	ldr	r0, [pc, #112]	@ (340118d8 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
34011868:	f7ef fd16 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3401186c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011870:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011872:	2b00      	cmp	r3, #0
34011874:	d005      	beq.n	34011882 <HAL_RCCEx_PeriphCLKConfig+0x2f7a>
34011876:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401187a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401187c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011880:	d904      	bls.n	3401188c <HAL_RCCEx_PeriphCLKConfig+0x2f84>
34011882:	f240 410f 	movw	r1, #1039	@ 0x40f
34011886:	4814      	ldr	r0, [pc, #80]	@ (340118d8 <HAL_RCCEx_PeriphCLKConfig+0x2fd0>)
34011888:	f7ef fd06 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3401188c:	4b13      	ldr	r3, [pc, #76]	@ (340118dc <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
3401188e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011892:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011896:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401189a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401189e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340118a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340118a4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340118a6:	3b01      	subs	r3, #1
340118a8:	041b      	lsls	r3, r3, #16
340118aa:	4313      	orrs	r3, r2
340118ac:	4a0b      	ldr	r2, [pc, #44]	@ (340118dc <HAL_RCCEx_PeriphCLKConfig+0x2fd4>)
340118ae:	430b      	orrs	r3, r1
340118b0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340118b4:	f7fc fe86 	bl	3400e5c4 <LL_RCC_IC15_Enable>
340118b8:	e01b      	b.n	340118f2 <HAL_RCCEx_PeriphCLKConfig+0x2fea>
340118ba:	bf00      	nop
340118bc:	07010c0c 	.word	0x07010c0c
340118c0:	0700100c 	.word	0x0700100c
340118c4:	0701100c 	.word	0x0701100c
340118c8:	0702100c 	.word	0x0702100c
340118cc:	0703100c 	.word	0x0703100c
340118d0:	0704100c 	.word	0x0704100c
340118d4:	0705100c 	.word	0x0705100c
340118d8:	3402444c 	.word	0x3402444c
340118dc:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
340118e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340118e4:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
340118e8:	4b70      	ldr	r3, [pc, #448]	@ (34011aac <HAL_RCCEx_PeriphCLKConfig+0x31a4>)
340118ea:	429a      	cmp	r2, r3
340118ec:	d101      	bne.n	340118f2 <HAL_RCCEx_PeriphCLKConfig+0x2fea>
    {
      LL_RCC_CLKP_Enable();
340118ee:	f7fc ffe9 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
340118f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340118f6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340118fa:	4618      	mov	r0, r3
340118fc:	f7fb fec9 	bl	3400d692 <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
34011900:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011904:	e9d3 2300 	ldrd	r2, r3, [r3]
34011908:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
3401190c:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
34011910:	2300      	movs	r3, #0
34011912:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
34011916:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
3401191a:	4603      	mov	r3, r0
3401191c:	460a      	mov	r2, r1
3401191e:	4313      	orrs	r3, r2
34011920:	f000 80e6 	beq.w	34011af0 <HAL_RCCEx_PeriphCLKConfig+0x31e8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));
34011924:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011928:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3401192c:	4b60      	ldr	r3, [pc, #384]	@ (34011ab0 <HAL_RCCEx_PeriphCLKConfig+0x31a8>)
3401192e:	429a      	cmp	r2, r3
34011930:	d027      	beq.n	34011982 <HAL_RCCEx_PeriphCLKConfig+0x307a>
34011932:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011936:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3401193a:	4b5e      	ldr	r3, [pc, #376]	@ (34011ab4 <HAL_RCCEx_PeriphCLKConfig+0x31ac>)
3401193c:	429a      	cmp	r2, r3
3401193e:	d020      	beq.n	34011982 <HAL_RCCEx_PeriphCLKConfig+0x307a>
34011940:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011944:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011948:	4b5b      	ldr	r3, [pc, #364]	@ (34011ab8 <HAL_RCCEx_PeriphCLKConfig+0x31b0>)
3401194a:	429a      	cmp	r2, r3
3401194c:	d019      	beq.n	34011982 <HAL_RCCEx_PeriphCLKConfig+0x307a>
3401194e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011952:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011956:	4b59      	ldr	r3, [pc, #356]	@ (34011abc <HAL_RCCEx_PeriphCLKConfig+0x31b4>)
34011958:	429a      	cmp	r2, r3
3401195a:	d012      	beq.n	34011982 <HAL_RCCEx_PeriphCLKConfig+0x307a>
3401195c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011960:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011964:	4b56      	ldr	r3, [pc, #344]	@ (34011ac0 <HAL_RCCEx_PeriphCLKConfig+0x31b8>)
34011966:	429a      	cmp	r2, r3
34011968:	d00b      	beq.n	34011982 <HAL_RCCEx_PeriphCLKConfig+0x307a>
3401196a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401196e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011972:	4b54      	ldr	r3, [pc, #336]	@ (34011ac4 <HAL_RCCEx_PeriphCLKConfig+0x31bc>)
34011974:	429a      	cmp	r2, r3
34011976:	d004      	beq.n	34011982 <HAL_RCCEx_PeriphCLKConfig+0x307a>
34011978:	f240 4129 	movw	r1, #1065	@ 0x429
3401197c:	4852      	ldr	r0, [pc, #328]	@ (34011ac8 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
3401197e:	f7ef fc8b 	bl	34001298 <assert_failed>

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
34011982:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011986:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3401198a:	4b4b      	ldr	r3, [pc, #300]	@ (34011ab8 <HAL_RCCEx_PeriphCLKConfig+0x31b0>)
3401198c:	429a      	cmp	r2, r3
3401198e:	d142      	bne.n	34011a16 <HAL_RCCEx_PeriphCLKConfig+0x310e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
34011990:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011994:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34011996:	2b00      	cmp	r3, #0
34011998:	d016      	beq.n	340119c8 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
3401199a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401199e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340119a0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340119a4:	d010      	beq.n	340119c8 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
340119a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340119aa:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340119ac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340119b0:	d00a      	beq.n	340119c8 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
340119b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340119b6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340119b8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340119bc:	d004      	beq.n	340119c8 <HAL_RCCEx_PeriphCLKConfig+0x30c0>
340119be:	f240 412e 	movw	r1, #1070	@ 0x42e
340119c2:	4841      	ldr	r0, [pc, #260]	@ (34011ac8 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
340119c4:	f7ef fc68 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
340119c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340119cc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340119ce:	2b00      	cmp	r3, #0
340119d0:	d005      	beq.n	340119de <HAL_RCCEx_PeriphCLKConfig+0x30d6>
340119d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340119d6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340119d8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340119dc:	d904      	bls.n	340119e8 <HAL_RCCEx_PeriphCLKConfig+0x30e0>
340119de:	f240 412f 	movw	r1, #1071	@ 0x42f
340119e2:	4839      	ldr	r0, [pc, #228]	@ (34011ac8 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
340119e4:	f7ef fc58 	bl	34001298 <assert_failed>

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340119e8:	4b38      	ldr	r3, [pc, #224]	@ (34011acc <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
340119ea:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340119ee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340119f2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340119f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340119fa:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340119fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a00:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011a02:	3b01      	subs	r3, #1
34011a04:	041b      	lsls	r3, r3, #16
34011a06:	4313      	orrs	r3, r2
34011a08:	4a30      	ldr	r2, [pc, #192]	@ (34011acc <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
34011a0a:	430b      	orrs	r3, r1
34011a0c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34011a10:	f7fc fcd8 	bl	3400e3c4 <LL_RCC_IC10_Enable>
34011a14:	e065      	b.n	34011ae2 <HAL_RCCEx_PeriphCLKConfig+0x31da>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
34011a16:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a1a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011a1e:	4b27      	ldr	r3, [pc, #156]	@ (34011abc <HAL_RCCEx_PeriphCLKConfig+0x31b4>)
34011a20:	429a      	cmp	r2, r3
34011a22:	d155      	bne.n	34011ad0 <HAL_RCCEx_PeriphCLKConfig+0x31c8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011a24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a28:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011a2a:	2b00      	cmp	r3, #0
34011a2c:	d016      	beq.n	34011a5c <HAL_RCCEx_PeriphCLKConfig+0x3154>
34011a2e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a32:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011a34:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011a38:	d010      	beq.n	34011a5c <HAL_RCCEx_PeriphCLKConfig+0x3154>
34011a3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a3e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011a40:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011a44:	d00a      	beq.n	34011a5c <HAL_RCCEx_PeriphCLKConfig+0x3154>
34011a46:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a4a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011a4c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011a50:	d004      	beq.n	34011a5c <HAL_RCCEx_PeriphCLKConfig+0x3154>
34011a52:	f240 413b 	movw	r1, #1083	@ 0x43b
34011a56:	481c      	ldr	r0, [pc, #112]	@ (34011ac8 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
34011a58:	f7ef fc1e 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34011a5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a60:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011a62:	2b00      	cmp	r3, #0
34011a64:	d005      	beq.n	34011a72 <HAL_RCCEx_PeriphCLKConfig+0x316a>
34011a66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a6a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011a6c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011a70:	d904      	bls.n	34011a7c <HAL_RCCEx_PeriphCLKConfig+0x3174>
34011a72:	f240 413c 	movw	r1, #1084	@ 0x43c
34011a76:	4814      	ldr	r0, [pc, #80]	@ (34011ac8 <HAL_RCCEx_PeriphCLKConfig+0x31c0>)
34011a78:	f7ef fc0e 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011a7c:	4b13      	ldr	r3, [pc, #76]	@ (34011acc <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
34011a7e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011a82:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011a86:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011a8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a8e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011a90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011a94:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011a96:	3b01      	subs	r3, #1
34011a98:	041b      	lsls	r3, r3, #16
34011a9a:	4313      	orrs	r3, r2
34011a9c:	4a0b      	ldr	r2, [pc, #44]	@ (34011acc <HAL_RCCEx_PeriphCLKConfig+0x31c4>)
34011a9e:	430b      	orrs	r3, r1
34011aa0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011aa4:	f7fc fd8e 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34011aa8:	e01b      	b.n	34011ae2 <HAL_RCCEx_PeriphCLKConfig+0x31da>
34011aaa:	bf00      	nop
34011aac:	0701100c 	.word	0x0701100c
34011ab0:	0700140c 	.word	0x0700140c
34011ab4:	0701140c 	.word	0x0701140c
34011ab8:	0702140c 	.word	0x0702140c
34011abc:	0703140c 	.word	0x0703140c
34011ac0:	0704140c 	.word	0x0704140c
34011ac4:	0705140c 	.word	0x0705140c
34011ac8:	3402444c 	.word	0x3402444c
34011acc:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
34011ad0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ad4:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011ad8:	4b98      	ldr	r3, [pc, #608]	@ (34011d3c <HAL_RCCEx_PeriphCLKConfig+0x3434>)
34011ada:	429a      	cmp	r2, r3
34011adc:	d101      	bne.n	34011ae2 <HAL_RCCEx_PeriphCLKConfig+0x31da>
    {
      LL_RCC_CLKP_Enable();
34011ade:	f7fc fef1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
34011ae2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ae6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011aea:	4618      	mov	r0, r3
34011aec:	f7fb fdd1 	bl	3400d692 <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
34011af0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011af4:	e9d3 2300 	ldrd	r2, r3, [r3]
34011af8:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
34011afc:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
34011b00:	2300      	movs	r3, #0
34011b02:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
34011b06:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34011b0a:	4603      	mov	r3, r0
34011b0c:	460a      	mov	r2, r1
34011b0e:	4313      	orrs	r3, r2
34011b10:	f000 8089 	beq.w	34011c26 <HAL_RCCEx_PeriphCLKConfig+0x331e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));
34011b14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b18:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b1c:	4b88      	ldr	r3, [pc, #544]	@ (34011d40 <HAL_RCCEx_PeriphCLKConfig+0x3438>)
34011b1e:	429a      	cmp	r2, r3
34011b20:	d027      	beq.n	34011b72 <HAL_RCCEx_PeriphCLKConfig+0x326a>
34011b22:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b26:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b2a:	4b86      	ldr	r3, [pc, #536]	@ (34011d44 <HAL_RCCEx_PeriphCLKConfig+0x343c>)
34011b2c:	429a      	cmp	r2, r3
34011b2e:	d020      	beq.n	34011b72 <HAL_RCCEx_PeriphCLKConfig+0x326a>
34011b30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b34:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b38:	4b83      	ldr	r3, [pc, #524]	@ (34011d48 <HAL_RCCEx_PeriphCLKConfig+0x3440>)
34011b3a:	429a      	cmp	r2, r3
34011b3c:	d019      	beq.n	34011b72 <HAL_RCCEx_PeriphCLKConfig+0x326a>
34011b3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b42:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b46:	4b81      	ldr	r3, [pc, #516]	@ (34011d4c <HAL_RCCEx_PeriphCLKConfig+0x3444>)
34011b48:	429a      	cmp	r2, r3
34011b4a:	d012      	beq.n	34011b72 <HAL_RCCEx_PeriphCLKConfig+0x326a>
34011b4c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b50:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b54:	4b7e      	ldr	r3, [pc, #504]	@ (34011d50 <HAL_RCCEx_PeriphCLKConfig+0x3448>)
34011b56:	429a      	cmp	r2, r3
34011b58:	d00b      	beq.n	34011b72 <HAL_RCCEx_PeriphCLKConfig+0x326a>
34011b5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b5e:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b62:	4b7c      	ldr	r3, [pc, #496]	@ (34011d54 <HAL_RCCEx_PeriphCLKConfig+0x344c>)
34011b64:	429a      	cmp	r2, r3
34011b66:	d004      	beq.n	34011b72 <HAL_RCCEx_PeriphCLKConfig+0x326a>
34011b68:	f240 4156 	movw	r1, #1110	@ 0x456
34011b6c:	487a      	ldr	r0, [pc, #488]	@ (34011d58 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
34011b6e:	f7ef fb93 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34011b72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b76:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011b7a:	4b73      	ldr	r3, [pc, #460]	@ (34011d48 <HAL_RCCEx_PeriphCLKConfig+0x3440>)
34011b7c:	429a      	cmp	r2, r3
34011b7e:	d142      	bne.n	34011c06 <HAL_RCCEx_PeriphCLKConfig+0x32fe>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011b80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b84:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011b86:	2b00      	cmp	r3, #0
34011b88:	d016      	beq.n	34011bb8 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
34011b8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b8e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011b90:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011b94:	d010      	beq.n	34011bb8 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
34011b96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011b9a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011b9c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011ba0:	d00a      	beq.n	34011bb8 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
34011ba2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ba6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011ba8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011bac:	d004      	beq.n	34011bb8 <HAL_RCCEx_PeriphCLKConfig+0x32b0>
34011bae:	f240 415b 	movw	r1, #1115	@ 0x45b
34011bb2:	4869      	ldr	r0, [pc, #420]	@ (34011d58 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
34011bb4:	f7ef fb70 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34011bb8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011bbc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011bbe:	2b00      	cmp	r3, #0
34011bc0:	d005      	beq.n	34011bce <HAL_RCCEx_PeriphCLKConfig+0x32c6>
34011bc2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011bc6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011bc8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011bcc:	d904      	bls.n	34011bd8 <HAL_RCCEx_PeriphCLKConfig+0x32d0>
34011bce:	f240 415c 	movw	r1, #1116	@ 0x45c
34011bd2:	4861      	ldr	r0, [pc, #388]	@ (34011d58 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
34011bd4:	f7ef fb60 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011bd8:	4b60      	ldr	r3, [pc, #384]	@ (34011d5c <HAL_RCCEx_PeriphCLKConfig+0x3454>)
34011bda:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011bde:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011be2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011be6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011bea:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011bec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011bf0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011bf2:	3b01      	subs	r3, #1
34011bf4:	041b      	lsls	r3, r3, #16
34011bf6:	4313      	orrs	r3, r2
34011bf8:	4a58      	ldr	r2, [pc, #352]	@ (34011d5c <HAL_RCCEx_PeriphCLKConfig+0x3454>)
34011bfa:	430b      	orrs	r3, r1
34011bfc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011c00:	f7fc fce0 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34011c04:	e008      	b.n	34011c18 <HAL_RCCEx_PeriphCLKConfig+0x3310>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
34011c06:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c0a:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011c0e:	4b4d      	ldr	r3, [pc, #308]	@ (34011d44 <HAL_RCCEx_PeriphCLKConfig+0x343c>)
34011c10:	429a      	cmp	r2, r3
34011c12:	d101      	bne.n	34011c18 <HAL_RCCEx_PeriphCLKConfig+0x3310>
    {
      LL_RCC_CLKP_Enable();
34011c14:	f7fc fe56 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
34011c18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c1c:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34011c20:	4618      	mov	r0, r3
34011c22:	f7fb fd41 	bl	3400d6a8 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
34011c26:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c2a:	e9d3 2300 	ldrd	r2, r3, [r3]
34011c2e:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
34011c32:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
34011c36:	2300      	movs	r3, #0
34011c38:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
34011c3c:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
34011c40:	4603      	mov	r3, r0
34011c42:	460a      	mov	r2, r1
34011c44:	4313      	orrs	r3, r2
34011c46:	f000 80a7 	beq.w	34011d98 <HAL_RCCEx_PeriphCLKConfig+0x3490>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));
34011c4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c4e:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011c52:	4b43      	ldr	r3, [pc, #268]	@ (34011d60 <HAL_RCCEx_PeriphCLKConfig+0x3458>)
34011c54:	429a      	cmp	r2, r3
34011c56:	d027      	beq.n	34011ca8 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
34011c58:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c5c:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011c60:	4b40      	ldr	r3, [pc, #256]	@ (34011d64 <HAL_RCCEx_PeriphCLKConfig+0x345c>)
34011c62:	429a      	cmp	r2, r3
34011c64:	d020      	beq.n	34011ca8 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
34011c66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c6a:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011c6e:	4b3e      	ldr	r3, [pc, #248]	@ (34011d68 <HAL_RCCEx_PeriphCLKConfig+0x3460>)
34011c70:	429a      	cmp	r2, r3
34011c72:	d019      	beq.n	34011ca8 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
34011c74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c78:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011c7c:	4b3b      	ldr	r3, [pc, #236]	@ (34011d6c <HAL_RCCEx_PeriphCLKConfig+0x3464>)
34011c7e:	429a      	cmp	r2, r3
34011c80:	d012      	beq.n	34011ca8 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
34011c82:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c86:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011c8a:	4b39      	ldr	r3, [pc, #228]	@ (34011d70 <HAL_RCCEx_PeriphCLKConfig+0x3468>)
34011c8c:	429a      	cmp	r2, r3
34011c8e:	d00b      	beq.n	34011ca8 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
34011c90:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011c94:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011c98:	4b36      	ldr	r3, [pc, #216]	@ (34011d74 <HAL_RCCEx_PeriphCLKConfig+0x346c>)
34011c9a:	429a      	cmp	r2, r3
34011c9c:	d004      	beq.n	34011ca8 <HAL_RCCEx_PeriphCLKConfig+0x33a0>
34011c9e:	f240 4176 	movw	r1, #1142	@ 0x476
34011ca2:	482d      	ldr	r0, [pc, #180]	@ (34011d58 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
34011ca4:	f7ef faf8 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
34011ca8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cac:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011cb0:	4b2d      	ldr	r3, [pc, #180]	@ (34011d68 <HAL_RCCEx_PeriphCLKConfig+0x3460>)
34011cb2:	429a      	cmp	r2, r3
34011cb4:	d160      	bne.n	34011d78 <HAL_RCCEx_PeriphCLKConfig+0x3470>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011cb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cba:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011cbc:	2b00      	cmp	r3, #0
34011cbe:	d016      	beq.n	34011cee <HAL_RCCEx_PeriphCLKConfig+0x33e6>
34011cc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cc4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011cc6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011cca:	d010      	beq.n	34011cee <HAL_RCCEx_PeriphCLKConfig+0x33e6>
34011ccc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cd0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011cd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011cd6:	d00a      	beq.n	34011cee <HAL_RCCEx_PeriphCLKConfig+0x33e6>
34011cd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cdc:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011cde:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011ce2:	d004      	beq.n	34011cee <HAL_RCCEx_PeriphCLKConfig+0x33e6>
34011ce4:	f240 417b 	movw	r1, #1147	@ 0x47b
34011ce8:	481b      	ldr	r0, [pc, #108]	@ (34011d58 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
34011cea:	f7ef fad5 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34011cee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cf2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011cf4:	2b00      	cmp	r3, #0
34011cf6:	d005      	beq.n	34011d04 <HAL_RCCEx_PeriphCLKConfig+0x33fc>
34011cf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011cfc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011cfe:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011d02:	d904      	bls.n	34011d0e <HAL_RCCEx_PeriphCLKConfig+0x3406>
34011d04:	f240 417c 	movw	r1, #1148	@ 0x47c
34011d08:	4813      	ldr	r0, [pc, #76]	@ (34011d58 <HAL_RCCEx_PeriphCLKConfig+0x3450>)
34011d0a:	f7ef fac5 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011d0e:	4b13      	ldr	r3, [pc, #76]	@ (34011d5c <HAL_RCCEx_PeriphCLKConfig+0x3454>)
34011d10:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011d14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011d18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011d1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011d20:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011d22:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011d26:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011d28:	3b01      	subs	r3, #1
34011d2a:	041b      	lsls	r3, r3, #16
34011d2c:	4313      	orrs	r3, r2
34011d2e:	4a0b      	ldr	r2, [pc, #44]	@ (34011d5c <HAL_RCCEx_PeriphCLKConfig+0x3454>)
34011d30:	430b      	orrs	r3, r1
34011d32:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011d36:	f7fc fc45 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34011d3a:	e026      	b.n	34011d8a <HAL_RCCEx_PeriphCLKConfig+0x3482>
34011d3c:	0701140c 	.word	0x0701140c
34011d40:	0700082c 	.word	0x0700082c
34011d44:	0701082c 	.word	0x0701082c
34011d48:	0702082c 	.word	0x0702082c
34011d4c:	0703082c 	.word	0x0703082c
34011d50:	0704082c 	.word	0x0704082c
34011d54:	0705082c 	.word	0x0705082c
34011d58:	3402444c 	.word	0x3402444c
34011d5c:	56028000 	.word	0x56028000
34011d60:	07000c2c 	.word	0x07000c2c
34011d64:	07010c2c 	.word	0x07010c2c
34011d68:	07020c2c 	.word	0x07020c2c
34011d6c:	07030c2c 	.word	0x07030c2c
34011d70:	07040c2c 	.word	0x07040c2c
34011d74:	07050c2c 	.word	0x07050c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34011d78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011d7c:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011d80:	4b98      	ldr	r3, [pc, #608]	@ (34011fe4 <HAL_RCCEx_PeriphCLKConfig+0x36dc>)
34011d82:	429a      	cmp	r2, r3
34011d84:	d101      	bne.n	34011d8a <HAL_RCCEx_PeriphCLKConfig+0x3482>
    {
      LL_RCC_CLKP_Enable();
34011d86:	f7fc fd9d 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
34011d8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011d8e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34011d92:	4618      	mov	r0, r3
34011d94:	f7fb fc88 	bl	3400d6a8 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34011d98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011d9c:	e9d3 2300 	ldrd	r2, r3, [r3]
34011da0:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
34011da4:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34011da8:	2300      	movs	r3, #0
34011daa:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
34011dae:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
34011db2:	4603      	mov	r3, r0
34011db4:	460a      	mov	r2, r1
34011db6:	4313      	orrs	r3, r2
34011db8:	f000 8089 	beq.w	34011ece <HAL_RCCEx_PeriphCLKConfig+0x35c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));
34011dbc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011dc0:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011dc4:	4b88      	ldr	r3, [pc, #544]	@ (34011fe8 <HAL_RCCEx_PeriphCLKConfig+0x36e0>)
34011dc6:	429a      	cmp	r2, r3
34011dc8:	d027      	beq.n	34011e1a <HAL_RCCEx_PeriphCLKConfig+0x3512>
34011dca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011dce:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011dd2:	4b86      	ldr	r3, [pc, #536]	@ (34011fec <HAL_RCCEx_PeriphCLKConfig+0x36e4>)
34011dd4:	429a      	cmp	r2, r3
34011dd6:	d020      	beq.n	34011e1a <HAL_RCCEx_PeriphCLKConfig+0x3512>
34011dd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ddc:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011de0:	4b83      	ldr	r3, [pc, #524]	@ (34011ff0 <HAL_RCCEx_PeriphCLKConfig+0x36e8>)
34011de2:	429a      	cmp	r2, r3
34011de4:	d019      	beq.n	34011e1a <HAL_RCCEx_PeriphCLKConfig+0x3512>
34011de6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011dea:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011dee:	4b81      	ldr	r3, [pc, #516]	@ (34011ff4 <HAL_RCCEx_PeriphCLKConfig+0x36ec>)
34011df0:	429a      	cmp	r2, r3
34011df2:	d012      	beq.n	34011e1a <HAL_RCCEx_PeriphCLKConfig+0x3512>
34011df4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011df8:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011dfc:	4b7e      	ldr	r3, [pc, #504]	@ (34011ff8 <HAL_RCCEx_PeriphCLKConfig+0x36f0>)
34011dfe:	429a      	cmp	r2, r3
34011e00:	d00b      	beq.n	34011e1a <HAL_RCCEx_PeriphCLKConfig+0x3512>
34011e02:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e06:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011e0a:	4b7c      	ldr	r3, [pc, #496]	@ (34011ffc <HAL_RCCEx_PeriphCLKConfig+0x36f4>)
34011e0c:	429a      	cmp	r2, r3
34011e0e:	d004      	beq.n	34011e1a <HAL_RCCEx_PeriphCLKConfig+0x3512>
34011e10:	f240 4196 	movw	r1, #1174	@ 0x496
34011e14:	487a      	ldr	r0, [pc, #488]	@ (34012000 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
34011e16:	f7ef fa3f 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34011e1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e1e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011e22:	4b73      	ldr	r3, [pc, #460]	@ (34011ff0 <HAL_RCCEx_PeriphCLKConfig+0x36e8>)
34011e24:	429a      	cmp	r2, r3
34011e26:	d142      	bne.n	34011eae <HAL_RCCEx_PeriphCLKConfig+0x35a6>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011e28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e2c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011e2e:	2b00      	cmp	r3, #0
34011e30:	d016      	beq.n	34011e60 <HAL_RCCEx_PeriphCLKConfig+0x3558>
34011e32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e36:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011e38:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011e3c:	d010      	beq.n	34011e60 <HAL_RCCEx_PeriphCLKConfig+0x3558>
34011e3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e42:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011e44:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011e48:	d00a      	beq.n	34011e60 <HAL_RCCEx_PeriphCLKConfig+0x3558>
34011e4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e4e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011e50:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011e54:	d004      	beq.n	34011e60 <HAL_RCCEx_PeriphCLKConfig+0x3558>
34011e56:	f240 419b 	movw	r1, #1179	@ 0x49b
34011e5a:	4869      	ldr	r0, [pc, #420]	@ (34012000 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
34011e5c:	f7ef fa1c 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34011e60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e64:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011e66:	2b00      	cmp	r3, #0
34011e68:	d005      	beq.n	34011e76 <HAL_RCCEx_PeriphCLKConfig+0x356e>
34011e6a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e6e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011e70:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011e74:	d904      	bls.n	34011e80 <HAL_RCCEx_PeriphCLKConfig+0x3578>
34011e76:	f240 419c 	movw	r1, #1180	@ 0x49c
34011e7a:	4861      	ldr	r0, [pc, #388]	@ (34012000 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
34011e7c:	f7ef fa0c 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011e80:	4b60      	ldr	r3, [pc, #384]	@ (34012004 <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
34011e82:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011e86:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011e8a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011e8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e92:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011e94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011e98:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011e9a:	3b01      	subs	r3, #1
34011e9c:	041b      	lsls	r3, r3, #16
34011e9e:	4313      	orrs	r3, r2
34011ea0:	4a58      	ldr	r2, [pc, #352]	@ (34012004 <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
34011ea2:	430b      	orrs	r3, r1
34011ea4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011ea8:	f7fc fb8c 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34011eac:	e008      	b.n	34011ec0 <HAL_RCCEx_PeriphCLKConfig+0x35b8>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
34011eae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011eb2:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011eb6:	4b4d      	ldr	r3, [pc, #308]	@ (34011fec <HAL_RCCEx_PeriphCLKConfig+0x36e4>)
34011eb8:	429a      	cmp	r2, r3
34011eba:	d101      	bne.n	34011ec0 <HAL_RCCEx_PeriphCLKConfig+0x35b8>
    {
      LL_RCC_CLKP_Enable();
34011ebc:	f7fc fd02 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
34011ec0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ec4:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34011ec8:	4618      	mov	r0, r3
34011eca:	f7fb fbed 	bl	3400d6a8 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
34011ece:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ed2:	e9d3 2300 	ldrd	r2, r3, [r3]
34011ed6:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
34011eda:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
34011ede:	2300      	movs	r3, #0
34011ee0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
34011ee4:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
34011ee8:	4603      	mov	r3, r0
34011eea:	460a      	mov	r2, r1
34011eec:	4313      	orrs	r3, r2
34011eee:	f000 80a7 	beq.w	34012040 <HAL_RCCEx_PeriphCLKConfig+0x3738>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));
34011ef2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011ef6:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011efa:	4b43      	ldr	r3, [pc, #268]	@ (34012008 <HAL_RCCEx_PeriphCLKConfig+0x3700>)
34011efc:	429a      	cmp	r2, r3
34011efe:	d027      	beq.n	34011f50 <HAL_RCCEx_PeriphCLKConfig+0x3648>
34011f00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f04:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011f08:	4b40      	ldr	r3, [pc, #256]	@ (3401200c <HAL_RCCEx_PeriphCLKConfig+0x3704>)
34011f0a:	429a      	cmp	r2, r3
34011f0c:	d020      	beq.n	34011f50 <HAL_RCCEx_PeriphCLKConfig+0x3648>
34011f0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f12:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011f16:	4b3e      	ldr	r3, [pc, #248]	@ (34012010 <HAL_RCCEx_PeriphCLKConfig+0x3708>)
34011f18:	429a      	cmp	r2, r3
34011f1a:	d019      	beq.n	34011f50 <HAL_RCCEx_PeriphCLKConfig+0x3648>
34011f1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f20:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011f24:	4b3b      	ldr	r3, [pc, #236]	@ (34012014 <HAL_RCCEx_PeriphCLKConfig+0x370c>)
34011f26:	429a      	cmp	r2, r3
34011f28:	d012      	beq.n	34011f50 <HAL_RCCEx_PeriphCLKConfig+0x3648>
34011f2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f2e:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011f32:	4b39      	ldr	r3, [pc, #228]	@ (34012018 <HAL_RCCEx_PeriphCLKConfig+0x3710>)
34011f34:	429a      	cmp	r2, r3
34011f36:	d00b      	beq.n	34011f50 <HAL_RCCEx_PeriphCLKConfig+0x3648>
34011f38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f3c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011f40:	4b36      	ldr	r3, [pc, #216]	@ (3401201c <HAL_RCCEx_PeriphCLKConfig+0x3714>)
34011f42:	429a      	cmp	r2, r3
34011f44:	d004      	beq.n	34011f50 <HAL_RCCEx_PeriphCLKConfig+0x3648>
34011f46:	f240 41b6 	movw	r1, #1206	@ 0x4b6
34011f4a:	482d      	ldr	r0, [pc, #180]	@ (34012000 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
34011f4c:	f7ef f9a4 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
34011f50:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f54:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011f58:	4b2d      	ldr	r3, [pc, #180]	@ (34012010 <HAL_RCCEx_PeriphCLKConfig+0x3708>)
34011f5a:	429a      	cmp	r2, r3
34011f5c:	d160      	bne.n	34012020 <HAL_RCCEx_PeriphCLKConfig+0x3718>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34011f5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f62:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011f64:	2b00      	cmp	r3, #0
34011f66:	d016      	beq.n	34011f96 <HAL_RCCEx_PeriphCLKConfig+0x368e>
34011f68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f6c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011f6e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34011f72:	d010      	beq.n	34011f96 <HAL_RCCEx_PeriphCLKConfig+0x368e>
34011f74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f78:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011f7a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34011f7e:	d00a      	beq.n	34011f96 <HAL_RCCEx_PeriphCLKConfig+0x368e>
34011f80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f84:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34011f86:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34011f8a:	d004      	beq.n	34011f96 <HAL_RCCEx_PeriphCLKConfig+0x368e>
34011f8c:	f240 41bb 	movw	r1, #1211	@ 0x4bb
34011f90:	481b      	ldr	r0, [pc, #108]	@ (34012000 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
34011f92:	f7ef f981 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34011f96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011f9a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011f9c:	2b00      	cmp	r3, #0
34011f9e:	d005      	beq.n	34011fac <HAL_RCCEx_PeriphCLKConfig+0x36a4>
34011fa0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011fa4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011fa6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011faa:	d904      	bls.n	34011fb6 <HAL_RCCEx_PeriphCLKConfig+0x36ae>
34011fac:	f240 41bc 	movw	r1, #1212	@ 0x4bc
34011fb0:	4813      	ldr	r0, [pc, #76]	@ (34012000 <HAL_RCCEx_PeriphCLKConfig+0x36f8>)
34011fb2:	f7ef f971 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011fb6:	4b13      	ldr	r3, [pc, #76]	@ (34012004 <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
34011fb8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011fbc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011fc0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011fc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011fc8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011fca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34011fce:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011fd0:	3b01      	subs	r3, #1
34011fd2:	041b      	lsls	r3, r3, #16
34011fd4:	4313      	orrs	r3, r2
34011fd6:	4a0b      	ldr	r2, [pc, #44]	@ (34012004 <HAL_RCCEx_PeriphCLKConfig+0x36fc>)
34011fd8:	430b      	orrs	r3, r1
34011fda:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011fde:	f7fc faf1 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34011fe2:	e026      	b.n	34012032 <HAL_RCCEx_PeriphCLKConfig+0x372a>
34011fe4:	07010c2c 	.word	0x07010c2c
34011fe8:	0700102c 	.word	0x0700102c
34011fec:	0701102c 	.word	0x0701102c
34011ff0:	0702102c 	.word	0x0702102c
34011ff4:	0703102c 	.word	0x0703102c
34011ff8:	0704102c 	.word	0x0704102c
34011ffc:	0705102c 	.word	0x0705102c
34012000:	3402444c 	.word	0x3402444c
34012004:	56028000 	.word	0x56028000
34012008:	0700142c 	.word	0x0700142c
3401200c:	0701142c 	.word	0x0701142c
34012010:	0702142c 	.word	0x0702142c
34012014:	0703142c 	.word	0x0703142c
34012018:	0704142c 	.word	0x0704142c
3401201c:	0705142c 	.word	0x0705142c
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34012020:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012024:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34012028:	4b9b      	ldr	r3, [pc, #620]	@ (34012298 <HAL_RCCEx_PeriphCLKConfig+0x3990>)
3401202a:	429a      	cmp	r2, r3
3401202c:	d101      	bne.n	34012032 <HAL_RCCEx_PeriphCLKConfig+0x372a>
    {
      LL_RCC_CLKP_Enable();
3401202e:	f7fc fc49 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
34012032:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012036:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3401203a:	4618      	mov	r0, r3
3401203c:	f7fb fb34 	bl	3400d6a8 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
34012040:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012044:	e9d3 2300 	ldrd	r2, r3, [r3]
34012048:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
3401204c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
34012050:	2300      	movs	r3, #0
34012052:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34012056:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3401205a:	4603      	mov	r3, r0
3401205c:	460a      	mov	r2, r1
3401205e:	4313      	orrs	r3, r2
34012060:	f000 8089 	beq.w	34012176 <HAL_RCCEx_PeriphCLKConfig+0x386e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));
34012064:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012068:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3401206c:	4b8b      	ldr	r3, [pc, #556]	@ (3401229c <HAL_RCCEx_PeriphCLKConfig+0x3994>)
3401206e:	429a      	cmp	r2, r3
34012070:	d027      	beq.n	340120c2 <HAL_RCCEx_PeriphCLKConfig+0x37ba>
34012072:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012076:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3401207a:	4b89      	ldr	r3, [pc, #548]	@ (340122a0 <HAL_RCCEx_PeriphCLKConfig+0x3998>)
3401207c:	429a      	cmp	r2, r3
3401207e:	d020      	beq.n	340120c2 <HAL_RCCEx_PeriphCLKConfig+0x37ba>
34012080:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012084:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34012088:	4b86      	ldr	r3, [pc, #536]	@ (340122a4 <HAL_RCCEx_PeriphCLKConfig+0x399c>)
3401208a:	429a      	cmp	r2, r3
3401208c:	d019      	beq.n	340120c2 <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3401208e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012092:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34012096:	4b84      	ldr	r3, [pc, #528]	@ (340122a8 <HAL_RCCEx_PeriphCLKConfig+0x39a0>)
34012098:	429a      	cmp	r2, r3
3401209a:	d012      	beq.n	340120c2 <HAL_RCCEx_PeriphCLKConfig+0x37ba>
3401209c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120a0:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
340120a4:	4b81      	ldr	r3, [pc, #516]	@ (340122ac <HAL_RCCEx_PeriphCLKConfig+0x39a4>)
340120a6:	429a      	cmp	r2, r3
340120a8:	d00b      	beq.n	340120c2 <HAL_RCCEx_PeriphCLKConfig+0x37ba>
340120aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120ae:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
340120b2:	4b7f      	ldr	r3, [pc, #508]	@ (340122b0 <HAL_RCCEx_PeriphCLKConfig+0x39a8>)
340120b4:	429a      	cmp	r2, r3
340120b6:	d004      	beq.n	340120c2 <HAL_RCCEx_PeriphCLKConfig+0x37ba>
340120b8:	f240 41d6 	movw	r1, #1238	@ 0x4d6
340120bc:	487d      	ldr	r0, [pc, #500]	@ (340122b4 <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
340120be:	f7ef f8eb 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
340120c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120c6:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
340120ca:	4b76      	ldr	r3, [pc, #472]	@ (340122a4 <HAL_RCCEx_PeriphCLKConfig+0x399c>)
340120cc:	429a      	cmp	r2, r3
340120ce:	d142      	bne.n	34012156 <HAL_RCCEx_PeriphCLKConfig+0x384e>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
340120d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120d4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340120d6:	2b00      	cmp	r3, #0
340120d8:	d016      	beq.n	34012108 <HAL_RCCEx_PeriphCLKConfig+0x3800>
340120da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120de:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340120e0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340120e4:	d010      	beq.n	34012108 <HAL_RCCEx_PeriphCLKConfig+0x3800>
340120e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120ea:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340120ec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340120f0:	d00a      	beq.n	34012108 <HAL_RCCEx_PeriphCLKConfig+0x3800>
340120f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340120f6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
340120f8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340120fc:	d004      	beq.n	34012108 <HAL_RCCEx_PeriphCLKConfig+0x3800>
340120fe:	f240 41db 	movw	r1, #1243	@ 0x4db
34012102:	486c      	ldr	r0, [pc, #432]	@ (340122b4 <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
34012104:	f7ef f8c8 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34012108:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401210c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401210e:	2b00      	cmp	r3, #0
34012110:	d005      	beq.n	3401211e <HAL_RCCEx_PeriphCLKConfig+0x3816>
34012112:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012116:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34012118:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401211c:	d904      	bls.n	34012128 <HAL_RCCEx_PeriphCLKConfig+0x3820>
3401211e:	f240 41dc 	movw	r1, #1244	@ 0x4dc
34012122:	4864      	ldr	r0, [pc, #400]	@ (340122b4 <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
34012124:	f7ef f8b8 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34012128:	4b63      	ldr	r3, [pc, #396]	@ (340122b8 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3401212a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401212e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012132:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012136:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401213a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3401213c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012140:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34012142:	3b01      	subs	r3, #1
34012144:	041b      	lsls	r3, r3, #16
34012146:	4313      	orrs	r3, r2
34012148:	4a5b      	ldr	r2, [pc, #364]	@ (340122b8 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3401214a:	430b      	orrs	r3, r1
3401214c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34012150:	f7fc fa38 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34012154:	e008      	b.n	34012168 <HAL_RCCEx_PeriphCLKConfig+0x3860>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
34012156:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401215a:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3401215e:	4b50      	ldr	r3, [pc, #320]	@ (340122a0 <HAL_RCCEx_PeriphCLKConfig+0x3998>)
34012160:	429a      	cmp	r2, r3
34012162:	d101      	bne.n	34012168 <HAL_RCCEx_PeriphCLKConfig+0x3860>
    {
      LL_RCC_CLKP_Enable();
34012164:	f7fc fbae 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
34012168:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401216c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34012170:	4618      	mov	r0, r3
34012172:	f7fb fa99 	bl	3400d6a8 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
34012176:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401217a:	e9d3 2300 	ldrd	r2, r3, [r3]
3401217e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
34012182:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
34012186:	2300      	movs	r3, #0
34012188:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3401218c:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
34012190:	4603      	mov	r3, r0
34012192:	460a      	mov	r2, r1
34012194:	4313      	orrs	r3, r2
34012196:	f000 80eb 	beq.w	34012370 <HAL_RCCEx_PeriphCLKConfig+0x3a68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
3401219a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401219e:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121a2:	2b00      	cmp	r3, #0
340121a4:	d02e      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340121aa:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121ae:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340121b2:	d027      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340121b8:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121bc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340121c0:	d020      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340121c6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121ca:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340121ce:	d019      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340121d4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121d8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340121dc:	d012      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340121e2:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121e6:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
340121ea:	d00b      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340121f0:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340121f4:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340121f8:	d004      	beq.n	34012204 <HAL_RCCEx_PeriphCLKConfig+0x38fc>
340121fa:	f240 41f6 	movw	r1, #1270	@ 0x4f6
340121fe:	482d      	ldr	r0, [pc, #180]	@ (340122b4 <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
34012200:	f7ef f84a 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
34012204:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012208:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3401220c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34012210:	d154      	bne.n	340122bc <HAL_RCCEx_PeriphCLKConfig+0x39b4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34012212:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012216:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34012218:	2b00      	cmp	r3, #0
3401221a:	d016      	beq.n	3401224a <HAL_RCCEx_PeriphCLKConfig+0x3942>
3401221c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012220:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34012222:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012226:	d010      	beq.n	3401224a <HAL_RCCEx_PeriphCLKConfig+0x3942>
34012228:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401222c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401222e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012232:	d00a      	beq.n	3401224a <HAL_RCCEx_PeriphCLKConfig+0x3942>
34012234:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012238:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401223a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401223e:	d004      	beq.n	3401224a <HAL_RCCEx_PeriphCLKConfig+0x3942>
34012240:	f240 41fb 	movw	r1, #1275	@ 0x4fb
34012244:	481b      	ldr	r0, [pc, #108]	@ (340122b4 <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
34012246:	f7ef f827 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3401224a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401224e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012250:	2b00      	cmp	r3, #0
34012252:	d005      	beq.n	34012260 <HAL_RCCEx_PeriphCLKConfig+0x3958>
34012254:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012258:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401225a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401225e:	d904      	bls.n	3401226a <HAL_RCCEx_PeriphCLKConfig+0x3962>
34012260:	f240 41fc 	movw	r1, #1276	@ 0x4fc
34012264:	4813      	ldr	r0, [pc, #76]	@ (340122b4 <HAL_RCCEx_PeriphCLKConfig+0x39ac>)
34012266:	f7ef f817 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401226a:	4b13      	ldr	r3, [pc, #76]	@ (340122b8 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3401226c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012270:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012274:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012278:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401227c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401227e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012282:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012284:	3b01      	subs	r3, #1
34012286:	041b      	lsls	r3, r3, #16
34012288:	4313      	orrs	r3, r2
3401228a:	4a0b      	ldr	r2, [pc, #44]	@ (340122b8 <HAL_RCCEx_PeriphCLKConfig+0x39b0>)
3401228c:	430b      	orrs	r3, r1
3401228e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012292:	f7fc f857 	bl	3400e344 <LL_RCC_IC9_Enable>
34012296:	e064      	b.n	34012362 <HAL_RCCEx_PeriphCLKConfig+0x3a5a>
34012298:	0701142c 	.word	0x0701142c
3401229c:	0700182c 	.word	0x0700182c
340122a0:	0701182c 	.word	0x0701182c
340122a4:	0702182c 	.word	0x0702182c
340122a8:	0703182c 	.word	0x0703182c
340122ac:	0704182c 	.word	0x0704182c
340122b0:	0705182c 	.word	0x0705182c
340122b4:	3402444c 	.word	0x3402444c
340122b8:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
340122bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340122c0:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340122c4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340122c8:	d142      	bne.n	34012350 <HAL_RCCEx_PeriphCLKConfig+0x3a48>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340122ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340122ce:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340122d0:	2b00      	cmp	r3, #0
340122d2:	d016      	beq.n	34012302 <HAL_RCCEx_PeriphCLKConfig+0x39fa>
340122d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340122d8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340122da:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340122de:	d010      	beq.n	34012302 <HAL_RCCEx_PeriphCLKConfig+0x39fa>
340122e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340122e4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340122e6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340122ea:	d00a      	beq.n	34012302 <HAL_RCCEx_PeriphCLKConfig+0x39fa>
340122ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340122f0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340122f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340122f6:	d004      	beq.n	34012302 <HAL_RCCEx_PeriphCLKConfig+0x39fa>
340122f8:	f44f 61a1 	mov.w	r1, #1288	@ 0x508
340122fc:	48b2      	ldr	r0, [pc, #712]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
340122fe:	f7ee ffcb 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34012302:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012306:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012308:	2b00      	cmp	r3, #0
3401230a:	d005      	beq.n	34012318 <HAL_RCCEx_PeriphCLKConfig+0x3a10>
3401230c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012310:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012312:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012316:	d904      	bls.n	34012322 <HAL_RCCEx_PeriphCLKConfig+0x3a1a>
34012318:	f240 5109 	movw	r1, #1289	@ 0x509
3401231c:	48aa      	ldr	r0, [pc, #680]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3401231e:	f7ee ffbb 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012322:	4baa      	ldr	r3, [pc, #680]	@ (340125cc <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
34012324:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012328:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401232c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012330:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012334:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34012336:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401233a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401233c:	3b01      	subs	r3, #1
3401233e:	041b      	lsls	r3, r3, #16
34012340:	4313      	orrs	r3, r2
34012342:	4aa2      	ldr	r2, [pc, #648]	@ (340125cc <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
34012344:	430b      	orrs	r3, r1
34012346:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401234a:	f7fc f8fb 	bl	3400e544 <LL_RCC_IC14_Enable>
3401234e:	e008      	b.n	34012362 <HAL_RCCEx_PeriphCLKConfig+0x3a5a>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34012350:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012354:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34012358:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401235c:	d101      	bne.n	34012362 <HAL_RCCEx_PeriphCLKConfig+0x3a5a>
    {
      LL_RCC_CLKP_Enable();
3401235e:	f7fc fab1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
34012362:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012366:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3401236a:	4618      	mov	r0, r3
3401236c:	f7fb f9a8 	bl	3400d6c0 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34012370:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012374:	e9d3 2300 	ldrd	r2, r3, [r3]
34012378:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
3401237c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
34012380:	2300      	movs	r3, #0
34012382:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
34012386:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
3401238a:	4603      	mov	r3, r0
3401238c:	460a      	mov	r2, r1
3401238e:	4313      	orrs	r3, r2
34012390:	f000 8082 	beq.w	34012498 <HAL_RCCEx_PeriphCLKConfig+0x3b90>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
34012394:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012398:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3401239c:	2b00      	cmp	r3, #0
3401239e:	d019      	beq.n	340123d4 <HAL_RCCEx_PeriphCLKConfig+0x3acc>
340123a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340123a4:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
340123a8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340123ac:	d012      	beq.n	340123d4 <HAL_RCCEx_PeriphCLKConfig+0x3acc>
340123ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340123b2:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
340123b6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340123ba:	d00b      	beq.n	340123d4 <HAL_RCCEx_PeriphCLKConfig+0x3acc>
340123bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340123c0:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
340123c4:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340123c8:	d004      	beq.n	340123d4 <HAL_RCCEx_PeriphCLKConfig+0x3acc>
340123ca:	f240 5123 	movw	r1, #1315	@ 0x523
340123ce:	487e      	ldr	r0, [pc, #504]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
340123d0:	f7ee ff62 	bl	34001298 <assert_failed>

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
340123d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340123d8:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
340123dc:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340123e0:	d14a      	bne.n	34012478 <HAL_RCCEx_PeriphCLKConfig+0x3b70>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
340123e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340123e6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340123ea:	2b00      	cmp	r3, #0
340123ec:	d019      	beq.n	34012422 <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
340123ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340123f2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340123f6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340123fa:	d012      	beq.n	34012422 <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
340123fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012400:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34012404:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012408:	d00b      	beq.n	34012422 <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
3401240a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401240e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34012412:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012416:	d004      	beq.n	34012422 <HAL_RCCEx_PeriphCLKConfig+0x3b1a>
34012418:	f44f 61a5 	mov.w	r1, #1320	@ 0x528
3401241c:	486a      	ldr	r0, [pc, #424]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
3401241e:	f7ee ff3b 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));
34012422:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012426:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3401242a:	2b00      	cmp	r3, #0
3401242c:	d006      	beq.n	3401243c <HAL_RCCEx_PeriphCLKConfig+0x3b34>
3401242e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012432:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34012436:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401243a:	d904      	bls.n	34012446 <HAL_RCCEx_PeriphCLKConfig+0x3b3e>
3401243c:	f240 5129 	movw	r1, #1321	@ 0x529
34012440:	4861      	ldr	r0, [pc, #388]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
34012442:	f7ee ff29 	bl	34001298 <assert_failed>

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34012446:	4b61      	ldr	r3, [pc, #388]	@ (340125cc <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
34012448:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401244c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012450:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012454:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012458:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3401245c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012460:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34012464:	3b01      	subs	r3, #1
34012466:	041b      	lsls	r3, r3, #16
34012468:	4313      	orrs	r3, r2
3401246a:	4a58      	ldr	r2, [pc, #352]	@ (340125cc <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3401246c:	430b      	orrs	r3, r1
3401246e:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
34012472:	f7fc f8e7 	bl	3400e644 <LL_RCC_IC16_Enable>
34012476:	e008      	b.n	3401248a <HAL_RCCEx_PeriphCLKConfig+0x3b82>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
34012478:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401247c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34012480:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34012484:	d101      	bne.n	3401248a <HAL_RCCEx_PeriphCLKConfig+0x3b82>
    {
      LL_RCC_CLKP_Enable();
34012486:	f7fc fa1d 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
3401248a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401248e:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34012492:	4618      	mov	r0, r3
34012494:	f7fb f92a 	bl	3400d6ec <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
34012498:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401249c:	e9d3 2300 	ldrd	r2, r3, [r3]
340124a0:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
340124a4:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
340124a8:	2300      	movs	r3, #0
340124aa:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
340124ae:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
340124b2:	4603      	mov	r3, r0
340124b4:	460a      	mov	r2, r1
340124b6:	4313      	orrs	r3, r2
340124b8:	f000 80e4 	beq.w	34012684 <HAL_RCCEx_PeriphCLKConfig+0x3d7c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));
340124bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340124c0:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340124c4:	2b00      	cmp	r3, #0
340124c6:	d035      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
340124c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340124cc:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340124d0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340124d4:	d02e      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
340124d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340124da:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340124de:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340124e2:	d027      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
340124e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340124e8:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340124ec:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340124f0:	d020      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
340124f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340124f6:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340124fa:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340124fe:	d019      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
34012500:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012504:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34012508:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3401250c:	d012      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3401250e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012512:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34012516:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3401251a:	d00b      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3401251c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012520:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34012524:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34012528:	d004      	beq.n	34012534 <HAL_RCCEx_PeriphCLKConfig+0x3c2c>
3401252a:	f240 5143 	movw	r1, #1347	@ 0x543
3401252e:	4826      	ldr	r0, [pc, #152]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
34012530:	f7ee feb2 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
34012534:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012538:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3401253c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34012540:	d146      	bne.n	340125d0 <HAL_RCCEx_PeriphCLKConfig+0x3cc8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
34012542:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012546:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012548:	2b00      	cmp	r3, #0
3401254a:	d016      	beq.n	3401257a <HAL_RCCEx_PeriphCLKConfig+0x3c72>
3401254c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012550:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012552:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012556:	d010      	beq.n	3401257a <HAL_RCCEx_PeriphCLKConfig+0x3c72>
34012558:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401255c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401255e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012562:	d00a      	beq.n	3401257a <HAL_RCCEx_PeriphCLKConfig+0x3c72>
34012564:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012568:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401256a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401256e:	d004      	beq.n	3401257a <HAL_RCCEx_PeriphCLKConfig+0x3c72>
34012570:	f44f 61a9 	mov.w	r1, #1352	@ 0x548
34012574:	4814      	ldr	r0, [pc, #80]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
34012576:	f7ee fe8f 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3401257a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401257e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012580:	2b00      	cmp	r3, #0
34012582:	d005      	beq.n	34012590 <HAL_RCCEx_PeriphCLKConfig+0x3c88>
34012584:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012588:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401258a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401258e:	d904      	bls.n	3401259a <HAL_RCCEx_PeriphCLKConfig+0x3c92>
34012590:	f240 5149 	movw	r1, #1353	@ 0x549
34012594:	480c      	ldr	r0, [pc, #48]	@ (340125c8 <HAL_RCCEx_PeriphCLKConfig+0x3cc0>)
34012596:	f7ee fe7f 	bl	34001298 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3401259a:	4b0c      	ldr	r3, [pc, #48]	@ (340125cc <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
3401259c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340125a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340125a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340125a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340125ac:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340125ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340125b2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340125b4:	3b01      	subs	r3, #1
340125b6:	041b      	lsls	r3, r3, #16
340125b8:	4313      	orrs	r3, r2
340125ba:	4a04      	ldr	r2, [pc, #16]	@ (340125cc <HAL_RCCEx_PeriphCLKConfig+0x3cc4>)
340125bc:	430b      	orrs	r3, r1
340125be:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
340125c2:	f7fb fe3f 	bl	3400e244 <LL_RCC_IC7_Enable>
340125c6:	e056      	b.n	34012676 <HAL_RCCEx_PeriphCLKConfig+0x3d6e>
340125c8:	3402444c 	.word	0x3402444c
340125cc:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
340125d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340125d4:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340125d8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340125dc:	d142      	bne.n	34012664 <HAL_RCCEx_PeriphCLKConfig+0x3d5c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
340125de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340125e2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340125e4:	2b00      	cmp	r3, #0
340125e6:	d016      	beq.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
340125e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340125ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340125ee:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340125f2:	d010      	beq.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
340125f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340125f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340125fa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340125fe:	d00a      	beq.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
34012600:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012604:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012606:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401260a:	d004      	beq.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x3d0e>
3401260c:	f240 5155 	movw	r1, #1365	@ 0x555
34012610:	48b0      	ldr	r0, [pc, #704]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
34012612:	f7ee fe41 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34012616:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401261a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401261c:	2b00      	cmp	r3, #0
3401261e:	d005      	beq.n	3401262c <HAL_RCCEx_PeriphCLKConfig+0x3d24>
34012620:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012624:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012626:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401262a:	d904      	bls.n	34012636 <HAL_RCCEx_PeriphCLKConfig+0x3d2e>
3401262c:	f240 5156 	movw	r1, #1366	@ 0x556
34012630:	48a8      	ldr	r0, [pc, #672]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
34012632:	f7ee fe31 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012636:	4ba8      	ldr	r3, [pc, #672]	@ (340128d8 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
34012638:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3401263c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012640:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012644:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012648:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3401264a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401264e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012650:	3b01      	subs	r3, #1
34012652:	041b      	lsls	r3, r3, #16
34012654:	4313      	orrs	r3, r2
34012656:	4aa0      	ldr	r2, [pc, #640]	@ (340128d8 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
34012658:	430b      	orrs	r3, r1
3401265a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3401265e:	f7fb fe31 	bl	3400e2c4 <LL_RCC_IC8_Enable>
34012662:	e008      	b.n	34012676 <HAL_RCCEx_PeriphCLKConfig+0x3d6e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34012664:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012668:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3401266c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34012670:	d101      	bne.n	34012676 <HAL_RCCEx_PeriphCLKConfig+0x3d6e>
    {
      LL_RCC_CLKP_Enable();
34012672:	f7fc f927 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
34012676:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401267a:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3401267e:	4618      	mov	r0, r3
34012680:	f7fb f84a 	bl	3400d718 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
34012684:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012688:	e9d3 2300 	ldrd	r2, r3, [r3]
3401268c:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
34012690:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34012694:	2300      	movs	r3, #0
34012696:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3401269a:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
3401269e:	4603      	mov	r3, r0
340126a0:	460a      	mov	r2, r1
340126a2:	4313      	orrs	r3, r2
340126a4:	d07c      	beq.n	340127a0 <HAL_RCCEx_PeriphCLKConfig+0x3e98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));
340126a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126aa:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340126ae:	2b00      	cmp	r3, #0
340126b0:	d016      	beq.n	340126e0 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
340126b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126b6:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340126ba:	2b10      	cmp	r3, #16
340126bc:	d010      	beq.n	340126e0 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
340126be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126c2:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340126c6:	2b20      	cmp	r3, #32
340126c8:	d00a      	beq.n	340126e0 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
340126ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126ce:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340126d2:	2b30      	cmp	r3, #48	@ 0x30
340126d4:	d004      	beq.n	340126e0 <HAL_RCCEx_PeriphCLKConfig+0x3dd8>
340126d6:	f44f 61ae 	mov.w	r1, #1392	@ 0x570
340126da:	487e      	ldr	r0, [pc, #504]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
340126dc:	f7ee fddc 	bl	34001298 <assert_failed>

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
340126e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126e4:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340126e8:	2b20      	cmp	r3, #32
340126ea:	d14a      	bne.n	34012782 <HAL_RCCEx_PeriphCLKConfig+0x3e7a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
340126ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126f0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340126f4:	2b00      	cmp	r3, #0
340126f6:	d019      	beq.n	3401272c <HAL_RCCEx_PeriphCLKConfig+0x3e24>
340126f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340126fc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34012700:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012704:	d012      	beq.n	3401272c <HAL_RCCEx_PeriphCLKConfig+0x3e24>
34012706:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401270a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3401270e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012712:	d00b      	beq.n	3401272c <HAL_RCCEx_PeriphCLKConfig+0x3e24>
34012714:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012718:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3401271c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012720:	d004      	beq.n	3401272c <HAL_RCCEx_PeriphCLKConfig+0x3e24>
34012722:	f240 5175 	movw	r1, #1397	@ 0x575
34012726:	486b      	ldr	r0, [pc, #428]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
34012728:	f7ee fdb6 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3401272c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012730:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34012734:	2b00      	cmp	r3, #0
34012736:	d006      	beq.n	34012746 <HAL_RCCEx_PeriphCLKConfig+0x3e3e>
34012738:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401273c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34012740:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012744:	d904      	bls.n	34012750 <HAL_RCCEx_PeriphCLKConfig+0x3e48>
34012746:	f240 5176 	movw	r1, #1398	@ 0x576
3401274a:	4862      	ldr	r0, [pc, #392]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3401274c:	f7ee fda4 	bl	34001298 <assert_failed>

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34012750:	4b61      	ldr	r3, [pc, #388]	@ (340128d8 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
34012752:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34012756:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401275a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401275e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012762:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34012766:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401276a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3401276e:	3b01      	subs	r3, #1
34012770:	041b      	lsls	r3, r3, #16
34012772:	4313      	orrs	r3, r2
34012774:	4a58      	ldr	r2, [pc, #352]	@ (340128d8 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
34012776:	430b      	orrs	r3, r1
34012778:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3401277c:	f7fc f862 	bl	3400e844 <LL_RCC_IC20_Enable>
34012780:	e007      	b.n	34012792 <HAL_RCCEx_PeriphCLKConfig+0x3e8a>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34012782:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012786:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3401278a:	2b10      	cmp	r3, #16
3401278c:	d101      	bne.n	34012792 <HAL_RCCEx_PeriphCLKConfig+0x3e8a>
    {
      LL_RCC_CLKP_Enable();
3401278e:	f7fc f899 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34012792:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012796:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3401279a:	4618      	mov	r0, r3
3401279c:	f7fa ffe8 	bl	3400d770 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
340127a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340127a4:	e9d3 2300 	ldrd	r2, r3, [r3]
340127a8:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
340127ac:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
340127b0:	2300      	movs	r3, #0
340127b2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
340127b6:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
340127ba:	4603      	mov	r3, r0
340127bc:	460a      	mov	r2, r1
340127be:	4313      	orrs	r3, r2
340127c0:	f000 80f6 	beq.w	340129b0 <HAL_RCCEx_PeriphCLKConfig+0x40a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
340127c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340127c8:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
340127cc:	4b43      	ldr	r3, [pc, #268]	@ (340128dc <HAL_RCCEx_PeriphCLKConfig+0x3fd4>)
340127ce:	429a      	cmp	r2, r3
340127d0:	d035      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
340127d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340127d6:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
340127da:	4b41      	ldr	r3, [pc, #260]	@ (340128e0 <HAL_RCCEx_PeriphCLKConfig+0x3fd8>)
340127dc:	429a      	cmp	r2, r3
340127de:	d02e      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
340127e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340127e4:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
340127e8:	4b3e      	ldr	r3, [pc, #248]	@ (340128e4 <HAL_RCCEx_PeriphCLKConfig+0x3fdc>)
340127ea:	429a      	cmp	r2, r3
340127ec:	d027      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
340127ee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340127f2:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
340127f6:	4b3c      	ldr	r3, [pc, #240]	@ (340128e8 <HAL_RCCEx_PeriphCLKConfig+0x3fe0>)
340127f8:	429a      	cmp	r2, r3
340127fa:	d020      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
340127fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012800:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34012804:	4b39      	ldr	r3, [pc, #228]	@ (340128ec <HAL_RCCEx_PeriphCLKConfig+0x3fe4>)
34012806:	429a      	cmp	r2, r3
34012808:	d019      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
3401280a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401280e:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34012812:	4b37      	ldr	r3, [pc, #220]	@ (340128f0 <HAL_RCCEx_PeriphCLKConfig+0x3fe8>)
34012814:	429a      	cmp	r2, r3
34012816:	d012      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
34012818:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401281c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34012820:	4b34      	ldr	r3, [pc, #208]	@ (340128f4 <HAL_RCCEx_PeriphCLKConfig+0x3fec>)
34012822:	429a      	cmp	r2, r3
34012824:	d00b      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
34012826:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401282a:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3401282e:	4b32      	ldr	r3, [pc, #200]	@ (340128f8 <HAL_RCCEx_PeriphCLKConfig+0x3ff0>)
34012830:	429a      	cmp	r2, r3
34012832:	d004      	beq.n	3401283e <HAL_RCCEx_PeriphCLKConfig+0x3f36>
34012834:	f44f 61b2 	mov.w	r1, #1424	@ 0x590
34012838:	4826      	ldr	r0, [pc, #152]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
3401283a:	f7ee fd2d 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3401283e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012842:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34012846:	4b27      	ldr	r3, [pc, #156]	@ (340128e4 <HAL_RCCEx_PeriphCLKConfig+0x3fdc>)
34012848:	429a      	cmp	r2, r3
3401284a:	d157      	bne.n	340128fc <HAL_RCCEx_PeriphCLKConfig+0x3ff4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3401284c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012850:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012852:	2b00      	cmp	r3, #0
34012854:	d016      	beq.n	34012884 <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
34012856:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401285a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401285c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012860:	d010      	beq.n	34012884 <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
34012862:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012866:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012868:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401286c:	d00a      	beq.n	34012884 <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
3401286e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012872:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012874:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012878:	d004      	beq.n	34012884 <HAL_RCCEx_PeriphCLKConfig+0x3f7c>
3401287a:	f240 5195 	movw	r1, #1429	@ 0x595
3401287e:	4815      	ldr	r0, [pc, #84]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
34012880:	f7ee fd0a 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
34012884:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012888:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401288a:	2b00      	cmp	r3, #0
3401288c:	d005      	beq.n	3401289a <HAL_RCCEx_PeriphCLKConfig+0x3f92>
3401288e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012892:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012894:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012898:	d904      	bls.n	340128a4 <HAL_RCCEx_PeriphCLKConfig+0x3f9c>
3401289a:	f240 5196 	movw	r1, #1430	@ 0x596
3401289e:	480d      	ldr	r0, [pc, #52]	@ (340128d4 <HAL_RCCEx_PeriphCLKConfig+0x3fcc>)
340128a0:	f7ee fcfa 	bl	34001298 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340128a4:	4b0c      	ldr	r3, [pc, #48]	@ (340128d8 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
340128a6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340128aa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340128ae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340128b2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340128b6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340128b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340128bc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340128be:	3b01      	subs	r3, #1
340128c0:	041b      	lsls	r3, r3, #16
340128c2:	4313      	orrs	r3, r2
340128c4:	4a04      	ldr	r2, [pc, #16]	@ (340128d8 <HAL_RCCEx_PeriphCLKConfig+0x3fd0>)
340128c6:	430b      	orrs	r3, r1
340128c8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
340128cc:	f7fb fcba 	bl	3400e244 <LL_RCC_IC7_Enable>
340128d0:	e067      	b.n	340129a2 <HAL_RCCEx_PeriphCLKConfig+0x409a>
340128d2:	bf00      	nop
340128d4:	3402444c 	.word	0x3402444c
340128d8:	56028000 	.word	0x56028000
340128dc:	07001418 	.word	0x07001418
340128e0:	07011418 	.word	0x07011418
340128e4:	07021418 	.word	0x07021418
340128e8:	07031418 	.word	0x07031418
340128ec:	07041418 	.word	0x07041418
340128f0:	07051418 	.word	0x07051418
340128f4:	07061418 	.word	0x07061418
340128f8:	07071418 	.word	0x07071418
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
340128fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012900:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34012904:	4b9c      	ldr	r3, [pc, #624]	@ (34012b78 <HAL_RCCEx_PeriphCLKConfig+0x4270>)
34012906:	429a      	cmp	r2, r3
34012908:	d142      	bne.n	34012990 <HAL_RCCEx_PeriphCLKConfig+0x4088>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3401290a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401290e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012910:	2b00      	cmp	r3, #0
34012912:	d016      	beq.n	34012942 <HAL_RCCEx_PeriphCLKConfig+0x403a>
34012914:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012918:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401291a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401291e:	d010      	beq.n	34012942 <HAL_RCCEx_PeriphCLKConfig+0x403a>
34012920:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012924:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012926:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401292a:	d00a      	beq.n	34012942 <HAL_RCCEx_PeriphCLKConfig+0x403a>
3401292c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012930:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012932:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012936:	d004      	beq.n	34012942 <HAL_RCCEx_PeriphCLKConfig+0x403a>
34012938:	f240 51a2 	movw	r1, #1442	@ 0x5a2
3401293c:	488f      	ldr	r0, [pc, #572]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3401293e:	f7ee fcab 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34012942:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012946:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012948:	2b00      	cmp	r3, #0
3401294a:	d005      	beq.n	34012958 <HAL_RCCEx_PeriphCLKConfig+0x4050>
3401294c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012950:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012952:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012956:	d904      	bls.n	34012962 <HAL_RCCEx_PeriphCLKConfig+0x405a>
34012958:	f240 51a3 	movw	r1, #1443	@ 0x5a3
3401295c:	4887      	ldr	r0, [pc, #540]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
3401295e:	f7ee fc9b 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012962:	4b87      	ldr	r3, [pc, #540]	@ (34012b80 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
34012964:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34012968:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401296c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012970:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012974:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34012976:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401297a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401297c:	3b01      	subs	r3, #1
3401297e:	041b      	lsls	r3, r3, #16
34012980:	4313      	orrs	r3, r2
34012982:	4a7f      	ldr	r2, [pc, #508]	@ (34012b80 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
34012984:	430b      	orrs	r3, r1
34012986:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3401298a:	f7fb fc9b 	bl	3400e2c4 <LL_RCC_IC8_Enable>
3401298e:	e008      	b.n	340129a2 <HAL_RCCEx_PeriphCLKConfig+0x409a>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
34012990:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012994:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34012998:	4b7a      	ldr	r3, [pc, #488]	@ (34012b84 <HAL_RCCEx_PeriphCLKConfig+0x427c>)
3401299a:	429a      	cmp	r2, r3
3401299c:	d101      	bne.n	340129a2 <HAL_RCCEx_PeriphCLKConfig+0x409a>
    {
      LL_RCC_CLKP_Enable();
3401299e:	f7fb ff91 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
340129a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340129a6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
340129aa:	4618      	mov	r0, r3
340129ac:	f7fa fef6 	bl	3400d79c <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
340129b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340129b4:	e9d3 2300 	ldrd	r2, r3, [r3]
340129b8:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
340129bc:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
340129c0:	2300      	movs	r3, #0
340129c2:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
340129c6:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
340129ca:	4603      	mov	r3, r0
340129cc:	460a      	mov	r2, r1
340129ce:	4313      	orrs	r3, r2
340129d0:	f000 80fa 	beq.w	34012bc8 <HAL_RCCEx_PeriphCLKConfig+0x42c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
340129d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340129d8:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
340129dc:	4b6a      	ldr	r3, [pc, #424]	@ (34012b88 <HAL_RCCEx_PeriphCLKConfig+0x4280>)
340129de:	429a      	cmp	r2, r3
340129e0:	d035      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
340129e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340129e6:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
340129ea:	4b68      	ldr	r3, [pc, #416]	@ (34012b8c <HAL_RCCEx_PeriphCLKConfig+0x4284>)
340129ec:	429a      	cmp	r2, r3
340129ee:	d02e      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
340129f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340129f4:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
340129f8:	4b65      	ldr	r3, [pc, #404]	@ (34012b90 <HAL_RCCEx_PeriphCLKConfig+0x4288>)
340129fa:	429a      	cmp	r2, r3
340129fc:	d027      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
340129fe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a02:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012a06:	4b63      	ldr	r3, [pc, #396]	@ (34012b94 <HAL_RCCEx_PeriphCLKConfig+0x428c>)
34012a08:	429a      	cmp	r2, r3
34012a0a:	d020      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
34012a0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a10:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012a14:	4b60      	ldr	r3, [pc, #384]	@ (34012b98 <HAL_RCCEx_PeriphCLKConfig+0x4290>)
34012a16:	429a      	cmp	r2, r3
34012a18:	d019      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
34012a1a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a1e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012a22:	4b5e      	ldr	r3, [pc, #376]	@ (34012b9c <HAL_RCCEx_PeriphCLKConfig+0x4294>)
34012a24:	429a      	cmp	r2, r3
34012a26:	d012      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
34012a28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a2c:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012a30:	4b5b      	ldr	r3, [pc, #364]	@ (34012ba0 <HAL_RCCEx_PeriphCLKConfig+0x4298>)
34012a32:	429a      	cmp	r2, r3
34012a34:	d00b      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
34012a36:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a3a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012a3e:	4b59      	ldr	r3, [pc, #356]	@ (34012ba4 <HAL_RCCEx_PeriphCLKConfig+0x429c>)
34012a40:	429a      	cmp	r2, r3
34012a42:	d004      	beq.n	34012a4e <HAL_RCCEx_PeriphCLKConfig+0x4146>
34012a44:	f240 51bd 	movw	r1, #1469	@ 0x5bd
34012a48:	484c      	ldr	r0, [pc, #304]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
34012a4a:	f7ee fc25 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34012a4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a52:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012a56:	4b4e      	ldr	r3, [pc, #312]	@ (34012b90 <HAL_RCCEx_PeriphCLKConfig+0x4288>)
34012a58:	429a      	cmp	r2, r3
34012a5a:	d142      	bne.n	34012ae2 <HAL_RCCEx_PeriphCLKConfig+0x41da>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
34012a5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a60:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012a62:	2b00      	cmp	r3, #0
34012a64:	d016      	beq.n	34012a94 <HAL_RCCEx_PeriphCLKConfig+0x418c>
34012a66:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a6a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012a6c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012a70:	d010      	beq.n	34012a94 <HAL_RCCEx_PeriphCLKConfig+0x418c>
34012a72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a76:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012a78:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012a7c:	d00a      	beq.n	34012a94 <HAL_RCCEx_PeriphCLKConfig+0x418c>
34012a7e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a82:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012a84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012a88:	d004      	beq.n	34012a94 <HAL_RCCEx_PeriphCLKConfig+0x418c>
34012a8a:	f240 51c2 	movw	r1, #1474	@ 0x5c2
34012a8e:	483b      	ldr	r0, [pc, #236]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
34012a90:	f7ee fc02 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
34012a94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012a98:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012a9a:	2b00      	cmp	r3, #0
34012a9c:	d005      	beq.n	34012aaa <HAL_RCCEx_PeriphCLKConfig+0x41a2>
34012a9e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012aa2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012aa4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012aa8:	d904      	bls.n	34012ab4 <HAL_RCCEx_PeriphCLKConfig+0x41ac>
34012aaa:	f240 51c3 	movw	r1, #1475	@ 0x5c3
34012aae:	4833      	ldr	r0, [pc, #204]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
34012ab0:	f7ee fbf2 	bl	34001298 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34012ab4:	4b32      	ldr	r3, [pc, #200]	@ (34012b80 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
34012ab6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34012aba:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012abe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012ac2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ac6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34012ac8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012acc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012ace:	3b01      	subs	r3, #1
34012ad0:	041b      	lsls	r3, r3, #16
34012ad2:	4313      	orrs	r3, r2
34012ad4:	4a2a      	ldr	r2, [pc, #168]	@ (34012b80 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
34012ad6:	430b      	orrs	r3, r1
34012ad8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34012adc:	f7fb fbb2 	bl	3400e244 <LL_RCC_IC7_Enable>
34012ae0:	e06b      	b.n	34012bba <HAL_RCCEx_PeriphCLKConfig+0x42b2>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34012ae2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ae6:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012aea:	4b2a      	ldr	r3, [pc, #168]	@ (34012b94 <HAL_RCCEx_PeriphCLKConfig+0x428c>)
34012aec:	429a      	cmp	r2, r3
34012aee:	d15b      	bne.n	34012ba8 <HAL_RCCEx_PeriphCLKConfig+0x42a0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
34012af0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012af4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012af6:	2b00      	cmp	r3, #0
34012af8:	d016      	beq.n	34012b28 <HAL_RCCEx_PeriphCLKConfig+0x4220>
34012afa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012afe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012b00:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012b04:	d010      	beq.n	34012b28 <HAL_RCCEx_PeriphCLKConfig+0x4220>
34012b06:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012b0a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012b0c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012b10:	d00a      	beq.n	34012b28 <HAL_RCCEx_PeriphCLKConfig+0x4220>
34012b12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012b16:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012b18:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012b1c:	d004      	beq.n	34012b28 <HAL_RCCEx_PeriphCLKConfig+0x4220>
34012b1e:	f240 51cf 	movw	r1, #1487	@ 0x5cf
34012b22:	4816      	ldr	r0, [pc, #88]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
34012b24:	f7ee fbb8 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34012b28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012b2c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012b2e:	2b00      	cmp	r3, #0
34012b30:	d005      	beq.n	34012b3e <HAL_RCCEx_PeriphCLKConfig+0x4236>
34012b32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012b36:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012b38:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012b3c:	d904      	bls.n	34012b48 <HAL_RCCEx_PeriphCLKConfig+0x4240>
34012b3e:	f44f 61ba 	mov.w	r1, #1488	@ 0x5d0
34012b42:	480e      	ldr	r0, [pc, #56]	@ (34012b7c <HAL_RCCEx_PeriphCLKConfig+0x4274>)
34012b44:	f7ee fba8 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012b48:	4b0d      	ldr	r3, [pc, #52]	@ (34012b80 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
34012b4a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34012b4e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012b52:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012b56:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012b5a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34012b5c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012b60:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012b62:	3b01      	subs	r3, #1
34012b64:	041b      	lsls	r3, r3, #16
34012b66:	4313      	orrs	r3, r2
34012b68:	4a05      	ldr	r2, [pc, #20]	@ (34012b80 <HAL_RCCEx_PeriphCLKConfig+0x4278>)
34012b6a:	430b      	orrs	r3, r1
34012b6c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34012b70:	f7fb fba8 	bl	3400e2c4 <LL_RCC_IC8_Enable>
34012b74:	e021      	b.n	34012bba <HAL_RCCEx_PeriphCLKConfig+0x42b2>
34012b76:	bf00      	nop
34012b78:	07031418 	.word	0x07031418
34012b7c:	3402444c 	.word	0x3402444c
34012b80:	56028000 	.word	0x56028000
34012b84:	07011418 	.word	0x07011418
34012b88:	07001818 	.word	0x07001818
34012b8c:	07011818 	.word	0x07011818
34012b90:	07021818 	.word	0x07021818
34012b94:	07031818 	.word	0x07031818
34012b98:	07041818 	.word	0x07041818
34012b9c:	07051818 	.word	0x07051818
34012ba0:	07061818 	.word	0x07061818
34012ba4:	07071818 	.word	0x07071818
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34012ba8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012bac:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34012bb0:	4b6f      	ldr	r3, [pc, #444]	@ (34012d70 <HAL_RCCEx_PeriphCLKConfig+0x4468>)
34012bb2:	429a      	cmp	r2, r3
34012bb4:	d101      	bne.n	34012bba <HAL_RCCEx_PeriphCLKConfig+0x42b2>
    {
      LL_RCC_CLKP_Enable();
34012bb6:	f7fb fe85 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34012bba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012bbe:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
34012bc2:	4618      	mov	r0, r3
34012bc4:	f7fa fdea 	bl	3400d79c <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
34012bc8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012bcc:	e9d3 2300 	ldrd	r2, r3, [r3]
34012bd0:	2100      	movs	r1, #0
34012bd2:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
34012bd6:	f003 0301 	and.w	r3, r3, #1
34012bda:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34012bde:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
34012be2:	4603      	mov	r3, r0
34012be4:	460a      	mov	r2, r1
34012be6:	4313      	orrs	r3, r2
34012be8:	f000 80d7 	beq.w	34012d9a <HAL_RCCEx_PeriphCLKConfig+0x4492>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));
34012bec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012bf0:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012bf4:	2b00      	cmp	r3, #0
34012bf6:	d028      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012bf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012bfc:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c00:	2b01      	cmp	r3, #1
34012c02:	d022      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012c04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c08:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c0c:	2b02      	cmp	r3, #2
34012c0e:	d01c      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012c10:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c14:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c18:	2b03      	cmp	r3, #3
34012c1a:	d016      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012c1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c20:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c24:	2b04      	cmp	r3, #4
34012c26:	d010      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012c28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c2c:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c30:	2b05      	cmp	r3, #5
34012c32:	d00a      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012c34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c38:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c3c:	2b06      	cmp	r3, #6
34012c3e:	d004      	beq.n	34012c4a <HAL_RCCEx_PeriphCLKConfig+0x4342>
34012c40:	f240 51ea 	movw	r1, #1514	@ 0x5ea
34012c44:	484b      	ldr	r0, [pc, #300]	@ (34012d74 <HAL_RCCEx_PeriphCLKConfig+0x446c>)
34012c46:	f7ee fb27 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34012c4a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c4e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012c52:	2b02      	cmp	r3, #2
34012c54:	d142      	bne.n	34012cdc <HAL_RCCEx_PeriphCLKConfig+0x43d4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
34012c56:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c5a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012c5c:	2b00      	cmp	r3, #0
34012c5e:	d016      	beq.n	34012c8e <HAL_RCCEx_PeriphCLKConfig+0x4386>
34012c60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c64:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012c66:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012c6a:	d010      	beq.n	34012c8e <HAL_RCCEx_PeriphCLKConfig+0x4386>
34012c6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c70:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012c72:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012c76:	d00a      	beq.n	34012c8e <HAL_RCCEx_PeriphCLKConfig+0x4386>
34012c78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c7c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34012c7e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012c82:	d004      	beq.n	34012c8e <HAL_RCCEx_PeriphCLKConfig+0x4386>
34012c84:	f240 51ef 	movw	r1, #1519	@ 0x5ef
34012c88:	483a      	ldr	r0, [pc, #232]	@ (34012d74 <HAL_RCCEx_PeriphCLKConfig+0x446c>)
34012c8a:	f7ee fb05 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
34012c8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c92:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012c94:	2b00      	cmp	r3, #0
34012c96:	d005      	beq.n	34012ca4 <HAL_RCCEx_PeriphCLKConfig+0x439c>
34012c98:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012c9c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012c9e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012ca2:	d904      	bls.n	34012cae <HAL_RCCEx_PeriphCLKConfig+0x43a6>
34012ca4:	f44f 61be 	mov.w	r1, #1520	@ 0x5f0
34012ca8:	4832      	ldr	r0, [pc, #200]	@ (34012d74 <HAL_RCCEx_PeriphCLKConfig+0x446c>)
34012caa:	f7ee faf5 	bl	34001298 <assert_failed>

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34012cae:	4b32      	ldr	r3, [pc, #200]	@ (34012d78 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
34012cb0:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34012cb4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012cb8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012cbc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012cc0:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34012cc2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012cc6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012cc8:	3b01      	subs	r3, #1
34012cca:	041b      	lsls	r3, r3, #16
34012ccc:	4313      	orrs	r3, r2
34012cce:	4a2a      	ldr	r2, [pc, #168]	@ (34012d78 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
34012cd0:	430b      	orrs	r3, r1
34012cd2:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34012cd6:	f7fb fab5 	bl	3400e244 <LL_RCC_IC7_Enable>
34012cda:	e057      	b.n	34012d8c <HAL_RCCEx_PeriphCLKConfig+0x4484>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
34012cdc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ce0:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012ce4:	2b03      	cmp	r3, #3
34012ce6:	d149      	bne.n	34012d7c <HAL_RCCEx_PeriphCLKConfig+0x4474>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
34012ce8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012cec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012cee:	2b00      	cmp	r3, #0
34012cf0:	d016      	beq.n	34012d20 <HAL_RCCEx_PeriphCLKConfig+0x4418>
34012cf2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012cf6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012cf8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012cfc:	d010      	beq.n	34012d20 <HAL_RCCEx_PeriphCLKConfig+0x4418>
34012cfe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d02:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012d04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012d08:	d00a      	beq.n	34012d20 <HAL_RCCEx_PeriphCLKConfig+0x4418>
34012d0a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d0e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012d10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012d14:	d004      	beq.n	34012d20 <HAL_RCCEx_PeriphCLKConfig+0x4418>
34012d16:	f240 51fc 	movw	r1, #1532	@ 0x5fc
34012d1a:	4816      	ldr	r0, [pc, #88]	@ (34012d74 <HAL_RCCEx_PeriphCLKConfig+0x446c>)
34012d1c:	f7ee fabc 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34012d20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d24:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012d26:	2b00      	cmp	r3, #0
34012d28:	d005      	beq.n	34012d36 <HAL_RCCEx_PeriphCLKConfig+0x442e>
34012d2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d2e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012d30:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012d34:	d904      	bls.n	34012d40 <HAL_RCCEx_PeriphCLKConfig+0x4438>
34012d36:	f240 51fd 	movw	r1, #1533	@ 0x5fd
34012d3a:	480e      	ldr	r0, [pc, #56]	@ (34012d74 <HAL_RCCEx_PeriphCLKConfig+0x446c>)
34012d3c:	f7ee faac 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012d40:	4b0d      	ldr	r3, [pc, #52]	@ (34012d78 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
34012d42:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34012d46:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012d4a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012d4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d52:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34012d54:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d58:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012d5a:	3b01      	subs	r3, #1
34012d5c:	041b      	lsls	r3, r3, #16
34012d5e:	4313      	orrs	r3, r2
34012d60:	4a05      	ldr	r2, [pc, #20]	@ (34012d78 <HAL_RCCEx_PeriphCLKConfig+0x4470>)
34012d62:	430b      	orrs	r3, r1
34012d64:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34012d68:	f7fb faac 	bl	3400e2c4 <LL_RCC_IC8_Enable>
34012d6c:	e00e      	b.n	34012d8c <HAL_RCCEx_PeriphCLKConfig+0x4484>
34012d6e:	bf00      	nop
34012d70:	07011818 	.word	0x07011818
34012d74:	3402444c 	.word	0x3402444c
34012d78:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34012d7c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d80:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012d84:	2b01      	cmp	r3, #1
34012d86:	d101      	bne.n	34012d8c <HAL_RCCEx_PeriphCLKConfig+0x4484>
    {
      LL_RCC_CLKP_Enable();
34012d88:	f7fb fd9c 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
34012d8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d90:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012d94:	4618      	mov	r0, r3
34012d96:	f7fa fd17 	bl	3400d7c8 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34012d9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012d9e:	e9d3 2300 	ldrd	r2, r3, [r3]
34012da2:	2100      	movs	r1, #0
34012da4:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
34012da8:	f003 0302 	and.w	r3, r3, #2
34012dac:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34012db0:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34012db4:	4603      	mov	r3, r0
34012db6:	460a      	mov	r2, r1
34012db8:	4313      	orrs	r3, r2
34012dba:	f000 80da 	beq.w	34012f72 <HAL_RCCEx_PeriphCLKConfig+0x466a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));
34012dbe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012dc2:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012dc6:	4bb4      	ldr	r3, [pc, #720]	@ (34013098 <HAL_RCCEx_PeriphCLKConfig+0x4790>)
34012dc8:	429a      	cmp	r2, r3
34012dca:	d02e      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012dcc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012dd0:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012dd4:	4bb1      	ldr	r3, [pc, #708]	@ (3401309c <HAL_RCCEx_PeriphCLKConfig+0x4794>)
34012dd6:	429a      	cmp	r2, r3
34012dd8:	d027      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012dda:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012dde:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012de2:	4baf      	ldr	r3, [pc, #700]	@ (340130a0 <HAL_RCCEx_PeriphCLKConfig+0x4798>)
34012de4:	429a      	cmp	r2, r3
34012de6:	d020      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012de8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012dec:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012df0:	4bac      	ldr	r3, [pc, #688]	@ (340130a4 <HAL_RCCEx_PeriphCLKConfig+0x479c>)
34012df2:	429a      	cmp	r2, r3
34012df4:	d019      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012df6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012dfa:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012dfe:	4baa      	ldr	r3, [pc, #680]	@ (340130a8 <HAL_RCCEx_PeriphCLKConfig+0x47a0>)
34012e00:	429a      	cmp	r2, r3
34012e02:	d012      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012e04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e08:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012e0c:	4ba7      	ldr	r3, [pc, #668]	@ (340130ac <HAL_RCCEx_PeriphCLKConfig+0x47a4>)
34012e0e:	429a      	cmp	r2, r3
34012e10:	d00b      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012e12:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e16:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012e1a:	4ba5      	ldr	r3, [pc, #660]	@ (340130b0 <HAL_RCCEx_PeriphCLKConfig+0x47a8>)
34012e1c:	429a      	cmp	r2, r3
34012e1e:	d004      	beq.n	34012e2a <HAL_RCCEx_PeriphCLKConfig+0x4522>
34012e20:	f240 6117 	movw	r1, #1559	@ 0x617
34012e24:	48a3      	ldr	r0, [pc, #652]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34012e26:	f7ee fa37 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34012e2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e2e:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012e32:	4b9b      	ldr	r3, [pc, #620]	@ (340130a0 <HAL_RCCEx_PeriphCLKConfig+0x4798>)
34012e34:	429a      	cmp	r2, r3
34012e36:	d142      	bne.n	34012ebe <HAL_RCCEx_PeriphCLKConfig+0x45b6>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
34012e38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e3c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012e3e:	2b00      	cmp	r3, #0
34012e40:	d016      	beq.n	34012e70 <HAL_RCCEx_PeriphCLKConfig+0x4568>
34012e42:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e46:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012e48:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012e4c:	d010      	beq.n	34012e70 <HAL_RCCEx_PeriphCLKConfig+0x4568>
34012e4e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e52:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012e54:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012e58:	d00a      	beq.n	34012e70 <HAL_RCCEx_PeriphCLKConfig+0x4568>
34012e5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e5e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34012e60:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012e64:	d004      	beq.n	34012e70 <HAL_RCCEx_PeriphCLKConfig+0x4568>
34012e66:	f240 611c 	movw	r1, #1564	@ 0x61c
34012e6a:	4892      	ldr	r0, [pc, #584]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34012e6c:	f7ee fa14 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34012e70:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e74:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012e76:	2b00      	cmp	r3, #0
34012e78:	d005      	beq.n	34012e86 <HAL_RCCEx_PeriphCLKConfig+0x457e>
34012e7a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012e7e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012e80:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012e84:	d904      	bls.n	34012e90 <HAL_RCCEx_PeriphCLKConfig+0x4588>
34012e86:	f240 611d 	movw	r1, #1565	@ 0x61d
34012e8a:	488a      	ldr	r0, [pc, #552]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34012e8c:	f7ee fa04 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012e90:	4b89      	ldr	r3, [pc, #548]	@ (340130b8 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
34012e92:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34012e96:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012e9a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012e9e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ea2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34012ea4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ea8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012eaa:	3b01      	subs	r3, #1
34012eac:	041b      	lsls	r3, r3, #16
34012eae:	4313      	orrs	r3, r2
34012eb0:	4a81      	ldr	r2, [pc, #516]	@ (340130b8 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
34012eb2:	430b      	orrs	r3, r1
34012eb4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34012eb8:	f7fb fa04 	bl	3400e2c4 <LL_RCC_IC8_Enable>
34012ebc:	e052      	b.n	34012f64 <HAL_RCCEx_PeriphCLKConfig+0x465c>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
34012ebe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ec2:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012ec6:	4b77      	ldr	r3, [pc, #476]	@ (340130a4 <HAL_RCCEx_PeriphCLKConfig+0x479c>)
34012ec8:	429a      	cmp	r2, r3
34012eca:	d142      	bne.n	34012f52 <HAL_RCCEx_PeriphCLKConfig+0x464a>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34012ecc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ed0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34012ed2:	2b00      	cmp	r3, #0
34012ed4:	d016      	beq.n	34012f04 <HAL_RCCEx_PeriphCLKConfig+0x45fc>
34012ed6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012eda:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34012edc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34012ee0:	d010      	beq.n	34012f04 <HAL_RCCEx_PeriphCLKConfig+0x45fc>
34012ee2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ee6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34012ee8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34012eec:	d00a      	beq.n	34012f04 <HAL_RCCEx_PeriphCLKConfig+0x45fc>
34012eee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012ef2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34012ef4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34012ef8:	d004      	beq.n	34012f04 <HAL_RCCEx_PeriphCLKConfig+0x45fc>
34012efa:	f240 6129 	movw	r1, #1577	@ 0x629
34012efe:	486d      	ldr	r0, [pc, #436]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34012f00:	f7ee f9ca 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34012f04:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f08:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012f0a:	2b00      	cmp	r3, #0
34012f0c:	d005      	beq.n	34012f1a <HAL_RCCEx_PeriphCLKConfig+0x4612>
34012f0e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f12:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012f14:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34012f18:	d904      	bls.n	34012f24 <HAL_RCCEx_PeriphCLKConfig+0x461c>
34012f1a:	f240 612a 	movw	r1, #1578	@ 0x62a
34012f1e:	4865      	ldr	r0, [pc, #404]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34012f20:	f7ee f9ba 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012f24:	4b64      	ldr	r3, [pc, #400]	@ (340130b8 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
34012f26:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012f2a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012f2e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012f32:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f36:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012f38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f3c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012f3e:	3b01      	subs	r3, #1
34012f40:	041b      	lsls	r3, r3, #16
34012f42:	4313      	orrs	r3, r2
34012f44:	4a5c      	ldr	r2, [pc, #368]	@ (340130b8 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
34012f46:	430b      	orrs	r3, r1
34012f48:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012f4c:	f7fb f9fa 	bl	3400e344 <LL_RCC_IC9_Enable>
34012f50:	e008      	b.n	34012f64 <HAL_RCCEx_PeriphCLKConfig+0x465c>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
34012f52:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f56:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012f5a:	4b50      	ldr	r3, [pc, #320]	@ (3401309c <HAL_RCCEx_PeriphCLKConfig+0x4794>)
34012f5c:	429a      	cmp	r2, r3
34012f5e:	d101      	bne.n	34012f64 <HAL_RCCEx_PeriphCLKConfig+0x465c>
    {
      LL_RCC_CLKP_Enable();
34012f60:	f7fb fcb0 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
34012f64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f68:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34012f6c:	4618      	mov	r0, r3
34012f6e:	f7fa fc41 	bl	3400d7f4 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
34012f72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f76:	e9d3 2300 	ldrd	r2, r3, [r3]
34012f7a:	2100      	movs	r1, #0
34012f7c:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
34012f80:	f003 0304 	and.w	r3, r3, #4
34012f84:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34012f88:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
34012f8c:	4603      	mov	r3, r0
34012f8e:	460a      	mov	r2, r1
34012f90:	4313      	orrs	r3, r2
34012f92:	f000 80fb 	beq.w	3401318c <HAL_RCCEx_PeriphCLKConfig+0x4884>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));
34012f96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012f9a:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012f9e:	4b47      	ldr	r3, [pc, #284]	@ (340130bc <HAL_RCCEx_PeriphCLKConfig+0x47b4>)
34012fa0:	429a      	cmp	r2, r3
34012fa2:	d02e      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012fa4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012fa8:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012fac:	4b44      	ldr	r3, [pc, #272]	@ (340130c0 <HAL_RCCEx_PeriphCLKConfig+0x47b8>)
34012fae:	429a      	cmp	r2, r3
34012fb0:	d027      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012fb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012fb6:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012fba:	4b42      	ldr	r3, [pc, #264]	@ (340130c4 <HAL_RCCEx_PeriphCLKConfig+0x47bc>)
34012fbc:	429a      	cmp	r2, r3
34012fbe:	d020      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012fc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012fc4:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012fc8:	4b3f      	ldr	r3, [pc, #252]	@ (340130c8 <HAL_RCCEx_PeriphCLKConfig+0x47c0>)
34012fca:	429a      	cmp	r2, r3
34012fcc:	d019      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012fce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012fd2:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012fd6:	4b3d      	ldr	r3, [pc, #244]	@ (340130cc <HAL_RCCEx_PeriphCLKConfig+0x47c4>)
34012fd8:	429a      	cmp	r2, r3
34012fda:	d012      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012fdc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012fe0:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012fe4:	4b3a      	ldr	r3, [pc, #232]	@ (340130d0 <HAL_RCCEx_PeriphCLKConfig+0x47c8>)
34012fe6:	429a      	cmp	r2, r3
34012fe8:	d00b      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012fea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34012fee:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34012ff2:	4b38      	ldr	r3, [pc, #224]	@ (340130d4 <HAL_RCCEx_PeriphCLKConfig+0x47cc>)
34012ff4:	429a      	cmp	r2, r3
34012ff6:	d004      	beq.n	34013002 <HAL_RCCEx_PeriphCLKConfig+0x46fa>
34012ff8:	f240 6144 	movw	r1, #1604	@ 0x644
34012ffc:	482d      	ldr	r0, [pc, #180]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34012ffe:	f7ee f94b 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
34013002:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013006:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3401300a:	4b2e      	ldr	r3, [pc, #184]	@ (340130c4 <HAL_RCCEx_PeriphCLKConfig+0x47bc>)
3401300c:	429a      	cmp	r2, r3
3401300e:	d163      	bne.n	340130d8 <HAL_RCCEx_PeriphCLKConfig+0x47d0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
34013010:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013014:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013016:	2b00      	cmp	r3, #0
34013018:	d016      	beq.n	34013048 <HAL_RCCEx_PeriphCLKConfig+0x4740>
3401301a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401301e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013020:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013024:	d010      	beq.n	34013048 <HAL_RCCEx_PeriphCLKConfig+0x4740>
34013026:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401302a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401302c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013030:	d00a      	beq.n	34013048 <HAL_RCCEx_PeriphCLKConfig+0x4740>
34013032:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013036:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013038:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401303c:	d004      	beq.n	34013048 <HAL_RCCEx_PeriphCLKConfig+0x4740>
3401303e:	f240 6149 	movw	r1, #1609	@ 0x649
34013042:	481c      	ldr	r0, [pc, #112]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34013044:	f7ee f928 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34013048:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401304c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401304e:	2b00      	cmp	r3, #0
34013050:	d005      	beq.n	3401305e <HAL_RCCEx_PeriphCLKConfig+0x4756>
34013052:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013056:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34013058:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401305c:	d904      	bls.n	34013068 <HAL_RCCEx_PeriphCLKConfig+0x4760>
3401305e:	f240 614a 	movw	r1, #1610	@ 0x64a
34013062:	4814      	ldr	r0, [pc, #80]	@ (340130b4 <HAL_RCCEx_PeriphCLKConfig+0x47ac>)
34013064:	f7ee f918 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34013068:	4b13      	ldr	r3, [pc, #76]	@ (340130b8 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3401306a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3401306e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013072:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013076:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401307a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3401307c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013080:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34013082:	3b01      	subs	r3, #1
34013084:	041b      	lsls	r3, r3, #16
34013086:	4313      	orrs	r3, r2
34013088:	4a0b      	ldr	r2, [pc, #44]	@ (340130b8 <HAL_RCCEx_PeriphCLKConfig+0x47b0>)
3401308a:	430b      	orrs	r3, r1
3401308c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34013090:	f7fb f918 	bl	3400e2c4 <LL_RCC_IC8_Enable>
34013094:	e073      	b.n	3401317e <HAL_RCCEx_PeriphCLKConfig+0x4876>
34013096:	bf00      	nop
34013098:	07000420 	.word	0x07000420
3401309c:	07010420 	.word	0x07010420
340130a0:	07020420 	.word	0x07020420
340130a4:	07030420 	.word	0x07030420
340130a8:	07040420 	.word	0x07040420
340130ac:	07050420 	.word	0x07050420
340130b0:	07060420 	.word	0x07060420
340130b4:	3402444c 	.word	0x3402444c
340130b8:	56028000 	.word	0x56028000
340130bc:	07000820 	.word	0x07000820
340130c0:	07010820 	.word	0x07010820
340130c4:	07020820 	.word	0x07020820
340130c8:	07030820 	.word	0x07030820
340130cc:	07040820 	.word	0x07040820
340130d0:	07050820 	.word	0x07050820
340130d4:	07060820 	.word	0x07060820
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
340130d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340130dc:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
340130e0:	4b98      	ldr	r3, [pc, #608]	@ (34013344 <HAL_RCCEx_PeriphCLKConfig+0x4a3c>)
340130e2:	429a      	cmp	r2, r3
340130e4:	d142      	bne.n	3401316c <HAL_RCCEx_PeriphCLKConfig+0x4864>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
340130e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340130ea:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340130ec:	2b00      	cmp	r3, #0
340130ee:	d016      	beq.n	3401311e <HAL_RCCEx_PeriphCLKConfig+0x4816>
340130f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340130f4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340130f6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340130fa:	d010      	beq.n	3401311e <HAL_RCCEx_PeriphCLKConfig+0x4816>
340130fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013100:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013102:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013106:	d00a      	beq.n	3401311e <HAL_RCCEx_PeriphCLKConfig+0x4816>
34013108:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401310c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401310e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013112:	d004      	beq.n	3401311e <HAL_RCCEx_PeriphCLKConfig+0x4816>
34013114:	f240 6156 	movw	r1, #1622	@ 0x656
34013118:	488b      	ldr	r0, [pc, #556]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3401311a:	f7ee f8bd 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3401311e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013122:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013124:	2b00      	cmp	r3, #0
34013126:	d005      	beq.n	34013134 <HAL_RCCEx_PeriphCLKConfig+0x482c>
34013128:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401312c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401312e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013132:	d904      	bls.n	3401313e <HAL_RCCEx_PeriphCLKConfig+0x4836>
34013134:	f240 6157 	movw	r1, #1623	@ 0x657
34013138:	4883      	ldr	r0, [pc, #524]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3401313a:	f7ee f8ad 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401313e:	4b83      	ldr	r3, [pc, #524]	@ (3401334c <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
34013140:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34013144:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013148:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401314c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013150:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34013152:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013156:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013158:	3b01      	subs	r3, #1
3401315a:	041b      	lsls	r3, r3, #16
3401315c:	4313      	orrs	r3, r2
3401315e:	4a7b      	ldr	r2, [pc, #492]	@ (3401334c <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
34013160:	430b      	orrs	r3, r1
34013162:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34013166:	f7fb f8ed 	bl	3400e344 <LL_RCC_IC9_Enable>
3401316a:	e008      	b.n	3401317e <HAL_RCCEx_PeriphCLKConfig+0x4876>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3401316c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013170:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34013174:	4b76      	ldr	r3, [pc, #472]	@ (34013350 <HAL_RCCEx_PeriphCLKConfig+0x4a48>)
34013176:	429a      	cmp	r2, r3
34013178:	d101      	bne.n	3401317e <HAL_RCCEx_PeriphCLKConfig+0x4876>
    {
      LL_RCC_CLKP_Enable();
3401317a:	f7fb fba3 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
3401317e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013182:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
34013186:	4618      	mov	r0, r3
34013188:	f7fa fb34 	bl	3400d7f4 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3401318c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013190:	e9d3 2300 	ldrd	r2, r3, [r3]
34013194:	2100      	movs	r1, #0
34013196:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
3401319a:	f003 0308 	and.w	r3, r3, #8
3401319e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
340131a2:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
340131a6:	4603      	mov	r3, r0
340131a8:	460a      	mov	r2, r1
340131aa:	4313      	orrs	r3, r2
340131ac:	f000 80f0 	beq.w	34013390 <HAL_RCCEx_PeriphCLKConfig+0x4a88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));
340131b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340131b4:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340131b8:	4b66      	ldr	r3, [pc, #408]	@ (34013354 <HAL_RCCEx_PeriphCLKConfig+0x4a4c>)
340131ba:	429a      	cmp	r2, r3
340131bc:	d02e      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
340131be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340131c2:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340131c6:	4b64      	ldr	r3, [pc, #400]	@ (34013358 <HAL_RCCEx_PeriphCLKConfig+0x4a50>)
340131c8:	429a      	cmp	r2, r3
340131ca:	d027      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
340131cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340131d0:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340131d4:	4b61      	ldr	r3, [pc, #388]	@ (3401335c <HAL_RCCEx_PeriphCLKConfig+0x4a54>)
340131d6:	429a      	cmp	r2, r3
340131d8:	d020      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
340131da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340131de:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340131e2:	4b5f      	ldr	r3, [pc, #380]	@ (34013360 <HAL_RCCEx_PeriphCLKConfig+0x4a58>)
340131e4:	429a      	cmp	r2, r3
340131e6:	d019      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
340131e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340131ec:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340131f0:	4b5c      	ldr	r3, [pc, #368]	@ (34013364 <HAL_RCCEx_PeriphCLKConfig+0x4a5c>)
340131f2:	429a      	cmp	r2, r3
340131f4:	d012      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
340131f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340131fa:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340131fe:	4b5a      	ldr	r3, [pc, #360]	@ (34013368 <HAL_RCCEx_PeriphCLKConfig+0x4a60>)
34013200:	429a      	cmp	r2, r3
34013202:	d00b      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
34013204:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013208:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3401320c:	4b57      	ldr	r3, [pc, #348]	@ (3401336c <HAL_RCCEx_PeriphCLKConfig+0x4a64>)
3401320e:	429a      	cmp	r2, r3
34013210:	d004      	beq.n	3401321c <HAL_RCCEx_PeriphCLKConfig+0x4914>
34013212:	f240 6171 	movw	r1, #1649	@ 0x671
34013216:	484c      	ldr	r0, [pc, #304]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
34013218:	f7ee f83e 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3401321c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013220:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34013224:	4b4d      	ldr	r3, [pc, #308]	@ (3401335c <HAL_RCCEx_PeriphCLKConfig+0x4a54>)
34013226:	429a      	cmp	r2, r3
34013228:	d142      	bne.n	340132b0 <HAL_RCCEx_PeriphCLKConfig+0x49a8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3401322a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401322e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013230:	2b00      	cmp	r3, #0
34013232:	d016      	beq.n	34013262 <HAL_RCCEx_PeriphCLKConfig+0x495a>
34013234:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013238:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401323a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401323e:	d010      	beq.n	34013262 <HAL_RCCEx_PeriphCLKConfig+0x495a>
34013240:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013244:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013246:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401324a:	d00a      	beq.n	34013262 <HAL_RCCEx_PeriphCLKConfig+0x495a>
3401324c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013250:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013252:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013256:	d004      	beq.n	34013262 <HAL_RCCEx_PeriphCLKConfig+0x495a>
34013258:	f240 6176 	movw	r1, #1654	@ 0x676
3401325c:	483a      	ldr	r0, [pc, #232]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3401325e:	f7ee f81b 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34013262:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013266:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34013268:	2b00      	cmp	r3, #0
3401326a:	d005      	beq.n	34013278 <HAL_RCCEx_PeriphCLKConfig+0x4970>
3401326c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013270:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34013272:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013276:	d904      	bls.n	34013282 <HAL_RCCEx_PeriphCLKConfig+0x497a>
34013278:	f240 6177 	movw	r1, #1655	@ 0x677
3401327c:	4832      	ldr	r0, [pc, #200]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
3401327e:	f7ee f80b 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34013282:	4b32      	ldr	r3, [pc, #200]	@ (3401334c <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
34013284:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34013288:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401328c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013290:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013294:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34013296:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401329a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401329c:	3b01      	subs	r3, #1
3401329e:	041b      	lsls	r3, r3, #16
340132a0:	4313      	orrs	r3, r2
340132a2:	4a2a      	ldr	r2, [pc, #168]	@ (3401334c <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
340132a4:	430b      	orrs	r3, r1
340132a6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340132aa:	f7fb f80b 	bl	3400e2c4 <LL_RCC_IC8_Enable>
340132ae:	e068      	b.n	34013382 <HAL_RCCEx_PeriphCLKConfig+0x4a7a>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
340132b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340132b4:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340132b8:	4b29      	ldr	r3, [pc, #164]	@ (34013360 <HAL_RCCEx_PeriphCLKConfig+0x4a58>)
340132ba:	429a      	cmp	r2, r3
340132bc:	d158      	bne.n	34013370 <HAL_RCCEx_PeriphCLKConfig+0x4a68>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
340132be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340132c2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340132c4:	2b00      	cmp	r3, #0
340132c6:	d016      	beq.n	340132f6 <HAL_RCCEx_PeriphCLKConfig+0x49ee>
340132c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340132cc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340132ce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340132d2:	d010      	beq.n	340132f6 <HAL_RCCEx_PeriphCLKConfig+0x49ee>
340132d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340132d8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340132da:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340132de:	d00a      	beq.n	340132f6 <HAL_RCCEx_PeriphCLKConfig+0x49ee>
340132e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340132e4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340132e6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340132ea:	d004      	beq.n	340132f6 <HAL_RCCEx_PeriphCLKConfig+0x49ee>
340132ec:	f240 6183 	movw	r1, #1667	@ 0x683
340132f0:	4815      	ldr	r0, [pc, #84]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
340132f2:	f7ed ffd1 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
340132f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340132fa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340132fc:	2b00      	cmp	r3, #0
340132fe:	d005      	beq.n	3401330c <HAL_RCCEx_PeriphCLKConfig+0x4a04>
34013300:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013304:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013306:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401330a:	d904      	bls.n	34013316 <HAL_RCCEx_PeriphCLKConfig+0x4a0e>
3401330c:	f240 6184 	movw	r1, #1668	@ 0x684
34013310:	480d      	ldr	r0, [pc, #52]	@ (34013348 <HAL_RCCEx_PeriphCLKConfig+0x4a40>)
34013312:	f7ed ffc1 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013316:	4b0d      	ldr	r3, [pc, #52]	@ (3401334c <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
34013318:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401331c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013320:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013324:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013328:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401332a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401332e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013330:	3b01      	subs	r3, #1
34013332:	041b      	lsls	r3, r3, #16
34013334:	4313      	orrs	r3, r2
34013336:	4a05      	ldr	r2, [pc, #20]	@ (3401334c <HAL_RCCEx_PeriphCLKConfig+0x4a44>)
34013338:	430b      	orrs	r3, r1
3401333a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401333e:	f7fb f801 	bl	3400e344 <LL_RCC_IC9_Enable>
34013342:	e01e      	b.n	34013382 <HAL_RCCEx_PeriphCLKConfig+0x4a7a>
34013344:	07030820 	.word	0x07030820
34013348:	3402444c 	.word	0x3402444c
3401334c:	56028000 	.word	0x56028000
34013350:	07010820 	.word	0x07010820
34013354:	07000c20 	.word	0x07000c20
34013358:	07010c20 	.word	0x07010c20
3401335c:	07020c20 	.word	0x07020c20
34013360:	07030c20 	.word	0x07030c20
34013364:	07040c20 	.word	0x07040c20
34013368:	07050c20 	.word	0x07050c20
3401336c:	07060c20 	.word	0x07060c20
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
34013370:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013374:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34013378:	4b73      	ldr	r3, [pc, #460]	@ (34013548 <HAL_RCCEx_PeriphCLKConfig+0x4c40>)
3401337a:	429a      	cmp	r2, r3
3401337c:	d101      	bne.n	34013382 <HAL_RCCEx_PeriphCLKConfig+0x4a7a>
    {
      LL_RCC_CLKP_Enable();
3401337e:	f7fb faa1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
34013382:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013386:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3401338a:	4618      	mov	r0, r3
3401338c:	f7fa fa32 	bl	3400d7f4 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
34013390:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013394:	e9d3 2300 	ldrd	r2, r3, [r3]
34013398:	2100      	movs	r1, #0
3401339a:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
3401339e:	f003 0310 	and.w	r3, r3, #16
340133a2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
340133a6:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
340133aa:	4603      	mov	r3, r0
340133ac:	460a      	mov	r2, r1
340133ae:	4313      	orrs	r3, r2
340133b0:	f000 80ee 	beq.w	34013590 <HAL_RCCEx_PeriphCLKConfig+0x4c88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));
340133b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340133b8:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340133bc:	4b63      	ldr	r3, [pc, #396]	@ (3401354c <HAL_RCCEx_PeriphCLKConfig+0x4c44>)
340133be:	429a      	cmp	r2, r3
340133c0:	d02e      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
340133c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340133c6:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340133ca:	4b61      	ldr	r3, [pc, #388]	@ (34013550 <HAL_RCCEx_PeriphCLKConfig+0x4c48>)
340133cc:	429a      	cmp	r2, r3
340133ce:	d027      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
340133d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340133d4:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340133d8:	4b5e      	ldr	r3, [pc, #376]	@ (34013554 <HAL_RCCEx_PeriphCLKConfig+0x4c4c>)
340133da:	429a      	cmp	r2, r3
340133dc:	d020      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
340133de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340133e2:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340133e6:	4b5c      	ldr	r3, [pc, #368]	@ (34013558 <HAL_RCCEx_PeriphCLKConfig+0x4c50>)
340133e8:	429a      	cmp	r2, r3
340133ea:	d019      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
340133ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340133f0:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340133f4:	4b59      	ldr	r3, [pc, #356]	@ (3401355c <HAL_RCCEx_PeriphCLKConfig+0x4c54>)
340133f6:	429a      	cmp	r2, r3
340133f8:	d012      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
340133fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340133fe:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34013402:	4b57      	ldr	r3, [pc, #348]	@ (34013560 <HAL_RCCEx_PeriphCLKConfig+0x4c58>)
34013404:	429a      	cmp	r2, r3
34013406:	d00b      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
34013408:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401340c:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34013410:	4b54      	ldr	r3, [pc, #336]	@ (34013564 <HAL_RCCEx_PeriphCLKConfig+0x4c5c>)
34013412:	429a      	cmp	r2, r3
34013414:	d004      	beq.n	34013420 <HAL_RCCEx_PeriphCLKConfig+0x4b18>
34013416:	f240 619e 	movw	r1, #1694	@ 0x69e
3401341a:	4853      	ldr	r0, [pc, #332]	@ (34013568 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
3401341c:	f7ed ff3c 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
34013420:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013424:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34013428:	4b4a      	ldr	r3, [pc, #296]	@ (34013554 <HAL_RCCEx_PeriphCLKConfig+0x4c4c>)
3401342a:	429a      	cmp	r2, r3
3401342c:	d142      	bne.n	340134b4 <HAL_RCCEx_PeriphCLKConfig+0x4bac>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3401342e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013432:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013434:	2b00      	cmp	r3, #0
34013436:	d016      	beq.n	34013466 <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
34013438:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401343c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401343e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013442:	d010      	beq.n	34013466 <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
34013444:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013448:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401344a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401344e:	d00a      	beq.n	34013466 <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
34013450:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013454:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013456:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401345a:	d004      	beq.n	34013466 <HAL_RCCEx_PeriphCLKConfig+0x4b5e>
3401345c:	f240 61a3 	movw	r1, #1699	@ 0x6a3
34013460:	4841      	ldr	r0, [pc, #260]	@ (34013568 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
34013462:	f7ed ff19 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34013466:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401346a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401346c:	2b00      	cmp	r3, #0
3401346e:	d005      	beq.n	3401347c <HAL_RCCEx_PeriphCLKConfig+0x4b74>
34013470:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013474:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013476:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401347a:	d904      	bls.n	34013486 <HAL_RCCEx_PeriphCLKConfig+0x4b7e>
3401347c:	f240 61a4 	movw	r1, #1700	@ 0x6a4
34013480:	4839      	ldr	r0, [pc, #228]	@ (34013568 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
34013482:	f7ed ff09 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013486:	4b39      	ldr	r3, [pc, #228]	@ (3401356c <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
34013488:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401348c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013490:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013494:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013498:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401349a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401349e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340134a0:	3b01      	subs	r3, #1
340134a2:	041b      	lsls	r3, r3, #16
340134a4:	4313      	orrs	r3, r2
340134a6:	4a31      	ldr	r2, [pc, #196]	@ (3401356c <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
340134a8:	430b      	orrs	r3, r1
340134aa:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340134ae:	f7fa ff49 	bl	3400e344 <LL_RCC_IC9_Enable>
340134b2:	e066      	b.n	34013582 <HAL_RCCEx_PeriphCLKConfig+0x4c7a>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
340134b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340134b8:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340134bc:	4b26      	ldr	r3, [pc, #152]	@ (34013558 <HAL_RCCEx_PeriphCLKConfig+0x4c50>)
340134be:	429a      	cmp	r2, r3
340134c0:	d156      	bne.n	34013570 <HAL_RCCEx_PeriphCLKConfig+0x4c68>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340134c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340134c6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340134c8:	2b00      	cmp	r3, #0
340134ca:	d016      	beq.n	340134fa <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
340134cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340134d0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340134d2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340134d6:	d010      	beq.n	340134fa <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
340134d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340134dc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340134de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340134e2:	d00a      	beq.n	340134fa <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
340134e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340134e8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340134ea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340134ee:	d004      	beq.n	340134fa <HAL_RCCEx_PeriphCLKConfig+0x4bf2>
340134f0:	f44f 61d6 	mov.w	r1, #1712	@ 0x6b0
340134f4:	481c      	ldr	r0, [pc, #112]	@ (34013568 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
340134f6:	f7ed fecf 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340134fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340134fe:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013500:	2b00      	cmp	r3, #0
34013502:	d005      	beq.n	34013510 <HAL_RCCEx_PeriphCLKConfig+0x4c08>
34013504:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013508:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401350a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401350e:	d904      	bls.n	3401351a <HAL_RCCEx_PeriphCLKConfig+0x4c12>
34013510:	f240 61b1 	movw	r1, #1713	@ 0x6b1
34013514:	4814      	ldr	r0, [pc, #80]	@ (34013568 <HAL_RCCEx_PeriphCLKConfig+0x4c60>)
34013516:	f7ed febf 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3401351a:	4b14      	ldr	r3, [pc, #80]	@ (3401356c <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
3401351c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34013520:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013524:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013528:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401352c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401352e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013532:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013534:	3b01      	subs	r3, #1
34013536:	041b      	lsls	r3, r3, #16
34013538:	4313      	orrs	r3, r2
3401353a:	4a0c      	ldr	r2, [pc, #48]	@ (3401356c <HAL_RCCEx_PeriphCLKConfig+0x4c64>)
3401353c:	430b      	orrs	r3, r1
3401353e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34013542:	f7fa ffff 	bl	3400e544 <LL_RCC_IC14_Enable>
34013546:	e01c      	b.n	34013582 <HAL_RCCEx_PeriphCLKConfig+0x4c7a>
34013548:	07010c20 	.word	0x07010c20
3401354c:	07001020 	.word	0x07001020
34013550:	07011020 	.word	0x07011020
34013554:	07021020 	.word	0x07021020
34013558:	07031020 	.word	0x07031020
3401355c:	07041020 	.word	0x07041020
34013560:	07051020 	.word	0x07051020
34013564:	07061020 	.word	0x07061020
34013568:	3402444c 	.word	0x3402444c
3401356c:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
34013570:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013574:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34013578:	4b73      	ldr	r3, [pc, #460]	@ (34013748 <HAL_RCCEx_PeriphCLKConfig+0x4e40>)
3401357a:	429a      	cmp	r2, r3
3401357c:	d101      	bne.n	34013582 <HAL_RCCEx_PeriphCLKConfig+0x4c7a>
    {
      LL_RCC_CLKP_Enable();
3401357e:	f7fb f9a1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
34013582:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013586:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
3401358a:	4618      	mov	r0, r3
3401358c:	f7fa f932 	bl	3400d7f4 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
34013590:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013594:	e9d3 2300 	ldrd	r2, r3, [r3]
34013598:	2100      	movs	r1, #0
3401359a:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
3401359e:	f003 0320 	and.w	r3, r3, #32
340135a2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
340135a6:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
340135aa:	4603      	mov	r3, r0
340135ac:	460a      	mov	r2, r1
340135ae:	4313      	orrs	r3, r2
340135b0:	f000 80ee 	beq.w	34013790 <HAL_RCCEx_PeriphCLKConfig+0x4e88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));
340135b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340135b8:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340135bc:	4b63      	ldr	r3, [pc, #396]	@ (3401374c <HAL_RCCEx_PeriphCLKConfig+0x4e44>)
340135be:	429a      	cmp	r2, r3
340135c0:	d02e      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
340135c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340135c6:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340135ca:	4b61      	ldr	r3, [pc, #388]	@ (34013750 <HAL_RCCEx_PeriphCLKConfig+0x4e48>)
340135cc:	429a      	cmp	r2, r3
340135ce:	d027      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
340135d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340135d4:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340135d8:	4b5e      	ldr	r3, [pc, #376]	@ (34013754 <HAL_RCCEx_PeriphCLKConfig+0x4e4c>)
340135da:	429a      	cmp	r2, r3
340135dc:	d020      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
340135de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340135e2:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340135e6:	4b5c      	ldr	r3, [pc, #368]	@ (34013758 <HAL_RCCEx_PeriphCLKConfig+0x4e50>)
340135e8:	429a      	cmp	r2, r3
340135ea:	d019      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
340135ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340135f0:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340135f4:	4b59      	ldr	r3, [pc, #356]	@ (3401375c <HAL_RCCEx_PeriphCLKConfig+0x4e54>)
340135f6:	429a      	cmp	r2, r3
340135f8:	d012      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
340135fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340135fe:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34013602:	4b57      	ldr	r3, [pc, #348]	@ (34013760 <HAL_RCCEx_PeriphCLKConfig+0x4e58>)
34013604:	429a      	cmp	r2, r3
34013606:	d00b      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
34013608:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401360c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34013610:	4b54      	ldr	r3, [pc, #336]	@ (34013764 <HAL_RCCEx_PeriphCLKConfig+0x4e5c>)
34013612:	429a      	cmp	r2, r3
34013614:	d004      	beq.n	34013620 <HAL_RCCEx_PeriphCLKConfig+0x4d18>
34013616:	f240 61cb 	movw	r1, #1739	@ 0x6cb
3401361a:	4853      	ldr	r0, [pc, #332]	@ (34013768 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
3401361c:	f7ed fe3c 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
34013620:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013624:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34013628:	4b4a      	ldr	r3, [pc, #296]	@ (34013754 <HAL_RCCEx_PeriphCLKConfig+0x4e4c>)
3401362a:	429a      	cmp	r2, r3
3401362c:	d142      	bne.n	340136b4 <HAL_RCCEx_PeriphCLKConfig+0x4dac>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3401362e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013632:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013634:	2b00      	cmp	r3, #0
34013636:	d016      	beq.n	34013666 <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
34013638:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401363c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401363e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013642:	d010      	beq.n	34013666 <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
34013644:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013648:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401364a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401364e:	d00a      	beq.n	34013666 <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
34013650:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013654:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013656:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401365a:	d004      	beq.n	34013666 <HAL_RCCEx_PeriphCLKConfig+0x4d5e>
3401365c:	f44f 61da 	mov.w	r1, #1744	@ 0x6d0
34013660:	4841      	ldr	r0, [pc, #260]	@ (34013768 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
34013662:	f7ed fe19 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34013666:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401366a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401366c:	2b00      	cmp	r3, #0
3401366e:	d005      	beq.n	3401367c <HAL_RCCEx_PeriphCLKConfig+0x4d74>
34013670:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013674:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013676:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401367a:	d904      	bls.n	34013686 <HAL_RCCEx_PeriphCLKConfig+0x4d7e>
3401367c:	f240 61d1 	movw	r1, #1745	@ 0x6d1
34013680:	4839      	ldr	r0, [pc, #228]	@ (34013768 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
34013682:	f7ed fe09 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013686:	4b39      	ldr	r3, [pc, #228]	@ (3401376c <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
34013688:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401368c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013690:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013694:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013698:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401369a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401369e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340136a0:	3b01      	subs	r3, #1
340136a2:	041b      	lsls	r3, r3, #16
340136a4:	4313      	orrs	r3, r2
340136a6:	4a31      	ldr	r2, [pc, #196]	@ (3401376c <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
340136a8:	430b      	orrs	r3, r1
340136aa:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340136ae:	f7fa fe49 	bl	3400e344 <LL_RCC_IC9_Enable>
340136b2:	e066      	b.n	34013782 <HAL_RCCEx_PeriphCLKConfig+0x4e7a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
340136b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340136b8:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340136bc:	4b26      	ldr	r3, [pc, #152]	@ (34013758 <HAL_RCCEx_PeriphCLKConfig+0x4e50>)
340136be:	429a      	cmp	r2, r3
340136c0:	d156      	bne.n	34013770 <HAL_RCCEx_PeriphCLKConfig+0x4e68>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340136c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340136c6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340136c8:	2b00      	cmp	r3, #0
340136ca:	d016      	beq.n	340136fa <HAL_RCCEx_PeriphCLKConfig+0x4df2>
340136cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340136d0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340136d2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340136d6:	d010      	beq.n	340136fa <HAL_RCCEx_PeriphCLKConfig+0x4df2>
340136d8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340136dc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340136de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340136e2:	d00a      	beq.n	340136fa <HAL_RCCEx_PeriphCLKConfig+0x4df2>
340136e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340136e8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340136ea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340136ee:	d004      	beq.n	340136fa <HAL_RCCEx_PeriphCLKConfig+0x4df2>
340136f0:	f240 61dd 	movw	r1, #1757	@ 0x6dd
340136f4:	481c      	ldr	r0, [pc, #112]	@ (34013768 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
340136f6:	f7ed fdcf 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340136fa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340136fe:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013700:	2b00      	cmp	r3, #0
34013702:	d005      	beq.n	34013710 <HAL_RCCEx_PeriphCLKConfig+0x4e08>
34013704:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013708:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401370a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401370e:	d904      	bls.n	3401371a <HAL_RCCEx_PeriphCLKConfig+0x4e12>
34013710:	f240 61de 	movw	r1, #1758	@ 0x6de
34013714:	4814      	ldr	r0, [pc, #80]	@ (34013768 <HAL_RCCEx_PeriphCLKConfig+0x4e60>)
34013716:	f7ed fdbf 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3401371a:	4b14      	ldr	r3, [pc, #80]	@ (3401376c <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
3401371c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34013720:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013724:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013728:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401372c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401372e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013732:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013734:	3b01      	subs	r3, #1
34013736:	041b      	lsls	r3, r3, #16
34013738:	4313      	orrs	r3, r2
3401373a:	4a0c      	ldr	r2, [pc, #48]	@ (3401376c <HAL_RCCEx_PeriphCLKConfig+0x4e64>)
3401373c:	430b      	orrs	r3, r1
3401373e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34013742:	f7fa feff 	bl	3400e544 <LL_RCC_IC14_Enable>
34013746:	e01c      	b.n	34013782 <HAL_RCCEx_PeriphCLKConfig+0x4e7a>
34013748:	07011020 	.word	0x07011020
3401374c:	07001420 	.word	0x07001420
34013750:	07011420 	.word	0x07011420
34013754:	07021420 	.word	0x07021420
34013758:	07031420 	.word	0x07031420
3401375c:	07041420 	.word	0x07041420
34013760:	07051420 	.word	0x07051420
34013764:	07061420 	.word	0x07061420
34013768:	3402444c 	.word	0x3402444c
3401376c:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
34013770:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013774:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34013778:	4b72      	ldr	r3, [pc, #456]	@ (34013944 <HAL_RCCEx_PeriphCLKConfig+0x503c>)
3401377a:	429a      	cmp	r2, r3
3401377c:	d101      	bne.n	34013782 <HAL_RCCEx_PeriphCLKConfig+0x4e7a>
    {
      LL_RCC_CLKP_Enable();
3401377e:	f7fb f8a1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
34013782:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013786:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3401378a:	4618      	mov	r0, r3
3401378c:	f7fa f832 	bl	3400d7f4 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
34013790:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013794:	e9d3 2300 	ldrd	r2, r3, [r3]
34013798:	2100      	movs	r1, #0
3401379a:	67b9      	str	r1, [r7, #120]	@ 0x78
3401379c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340137a0:	67fb      	str	r3, [r7, #124]	@ 0x7c
340137a2:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
340137a6:	4603      	mov	r3, r0
340137a8:	460a      	mov	r2, r1
340137aa:	4313      	orrs	r3, r2
340137ac:	f000 80ee 	beq.w	3401398c <HAL_RCCEx_PeriphCLKConfig+0x5084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));
340137b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340137b4:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340137b8:	4b63      	ldr	r3, [pc, #396]	@ (34013948 <HAL_RCCEx_PeriphCLKConfig+0x5040>)
340137ba:	429a      	cmp	r2, r3
340137bc:	d02e      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
340137be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340137c2:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340137c6:	4b61      	ldr	r3, [pc, #388]	@ (3401394c <HAL_RCCEx_PeriphCLKConfig+0x5044>)
340137c8:	429a      	cmp	r2, r3
340137ca:	d027      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
340137cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340137d0:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340137d4:	4b5e      	ldr	r3, [pc, #376]	@ (34013950 <HAL_RCCEx_PeriphCLKConfig+0x5048>)
340137d6:	429a      	cmp	r2, r3
340137d8:	d020      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
340137da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340137de:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340137e2:	4b5c      	ldr	r3, [pc, #368]	@ (34013954 <HAL_RCCEx_PeriphCLKConfig+0x504c>)
340137e4:	429a      	cmp	r2, r3
340137e6:	d019      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
340137e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340137ec:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340137f0:	4b59      	ldr	r3, [pc, #356]	@ (34013958 <HAL_RCCEx_PeriphCLKConfig+0x5050>)
340137f2:	429a      	cmp	r2, r3
340137f4:	d012      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
340137f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340137fa:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340137fe:	4b57      	ldr	r3, [pc, #348]	@ (3401395c <HAL_RCCEx_PeriphCLKConfig+0x5054>)
34013800:	429a      	cmp	r2, r3
34013802:	d00b      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
34013804:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013808:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3401380c:	4b54      	ldr	r3, [pc, #336]	@ (34013960 <HAL_RCCEx_PeriphCLKConfig+0x5058>)
3401380e:	429a      	cmp	r2, r3
34013810:	d004      	beq.n	3401381c <HAL_RCCEx_PeriphCLKConfig+0x4f14>
34013812:	f44f 61df 	mov.w	r1, #1784	@ 0x6f8
34013816:	4853      	ldr	r0, [pc, #332]	@ (34013964 <HAL_RCCEx_PeriphCLKConfig+0x505c>)
34013818:	f7ed fd3e 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3401381c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013820:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34013824:	4b4a      	ldr	r3, [pc, #296]	@ (34013950 <HAL_RCCEx_PeriphCLKConfig+0x5048>)
34013826:	429a      	cmp	r2, r3
34013828:	d142      	bne.n	340138b0 <HAL_RCCEx_PeriphCLKConfig+0x4fa8>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3401382a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401382e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013830:	2b00      	cmp	r3, #0
34013832:	d016      	beq.n	34013862 <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
34013834:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013838:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401383a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401383e:	d010      	beq.n	34013862 <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
34013840:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013844:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013846:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401384a:	d00a      	beq.n	34013862 <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
3401384c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013850:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34013852:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013856:	d004      	beq.n	34013862 <HAL_RCCEx_PeriphCLKConfig+0x4f5a>
34013858:	f240 61fd 	movw	r1, #1789	@ 0x6fd
3401385c:	4841      	ldr	r0, [pc, #260]	@ (34013964 <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3401385e:	f7ed fd1b 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
34013862:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013866:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34013868:	2b00      	cmp	r3, #0
3401386a:	d005      	beq.n	34013878 <HAL_RCCEx_PeriphCLKConfig+0x4f70>
3401386c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013870:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34013872:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013876:	d904      	bls.n	34013882 <HAL_RCCEx_PeriphCLKConfig+0x4f7a>
34013878:	f240 61fe 	movw	r1, #1790	@ 0x6fe
3401387c:	4839      	ldr	r0, [pc, #228]	@ (34013964 <HAL_RCCEx_PeriphCLKConfig+0x505c>)
3401387e:	f7ed fd0b 	bl	34001298 <assert_failed>

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34013882:	4b39      	ldr	r3, [pc, #228]	@ (34013968 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
34013884:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34013888:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401388c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013890:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013894:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34013896:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401389a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401389c:	3b01      	subs	r3, #1
3401389e:	041b      	lsls	r3, r3, #16
340138a0:	4313      	orrs	r3, r2
340138a2:	4a31      	ldr	r2, [pc, #196]	@ (34013968 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
340138a4:	430b      	orrs	r3, r1
340138a6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340138aa:	f7fa fd0b 	bl	3400e2c4 <LL_RCC_IC8_Enable>
340138ae:	e066      	b.n	3401397e <HAL_RCCEx_PeriphCLKConfig+0x5076>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
340138b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340138b4:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340138b8:	4b26      	ldr	r3, [pc, #152]	@ (34013954 <HAL_RCCEx_PeriphCLKConfig+0x504c>)
340138ba:	429a      	cmp	r2, r3
340138bc:	d156      	bne.n	3401396c <HAL_RCCEx_PeriphCLKConfig+0x5064>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
340138be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340138c2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340138c4:	2b00      	cmp	r3, #0
340138c6:	d016      	beq.n	340138f6 <HAL_RCCEx_PeriphCLKConfig+0x4fee>
340138c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340138cc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340138ce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340138d2:	d010      	beq.n	340138f6 <HAL_RCCEx_PeriphCLKConfig+0x4fee>
340138d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340138d8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340138da:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340138de:	d00a      	beq.n	340138f6 <HAL_RCCEx_PeriphCLKConfig+0x4fee>
340138e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340138e4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340138e6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340138ea:	d004      	beq.n	340138f6 <HAL_RCCEx_PeriphCLKConfig+0x4fee>
340138ec:	f240 710a 	movw	r1, #1802	@ 0x70a
340138f0:	481c      	ldr	r0, [pc, #112]	@ (34013964 <HAL_RCCEx_PeriphCLKConfig+0x505c>)
340138f2:	f7ed fcd1 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
340138f6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340138fa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340138fc:	2b00      	cmp	r3, #0
340138fe:	d005      	beq.n	3401390c <HAL_RCCEx_PeriphCLKConfig+0x5004>
34013900:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013904:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013906:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401390a:	d904      	bls.n	34013916 <HAL_RCCEx_PeriphCLKConfig+0x500e>
3401390c:	f240 710b 	movw	r1, #1803	@ 0x70b
34013910:	4814      	ldr	r0, [pc, #80]	@ (34013964 <HAL_RCCEx_PeriphCLKConfig+0x505c>)
34013912:	f7ed fcc1 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013916:	4b14      	ldr	r3, [pc, #80]	@ (34013968 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
34013918:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401391c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013920:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013924:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013928:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401392a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401392e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013930:	3b01      	subs	r3, #1
34013932:	041b      	lsls	r3, r3, #16
34013934:	4313      	orrs	r3, r2
34013936:	4a0c      	ldr	r2, [pc, #48]	@ (34013968 <HAL_RCCEx_PeriphCLKConfig+0x5060>)
34013938:	430b      	orrs	r3, r1
3401393a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401393e:	f7fa fd01 	bl	3400e344 <LL_RCC_IC9_Enable>
34013942:	e01c      	b.n	3401397e <HAL_RCCEx_PeriphCLKConfig+0x5076>
34013944:	07011420 	.word	0x07011420
34013948:	07001820 	.word	0x07001820
3401394c:	07011820 	.word	0x07011820
34013950:	07021820 	.word	0x07021820
34013954:	07031820 	.word	0x07031820
34013958:	07041820 	.word	0x07041820
3401395c:	07051820 	.word	0x07051820
34013960:	07061820 	.word	0x07061820
34013964:	3402444c 	.word	0x3402444c
34013968:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3401396c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013970:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34013974:	4b72      	ldr	r3, [pc, #456]	@ (34013b40 <HAL_RCCEx_PeriphCLKConfig+0x5238>)
34013976:	429a      	cmp	r2, r3
34013978:	d101      	bne.n	3401397e <HAL_RCCEx_PeriphCLKConfig+0x5076>
    {
      LL_RCC_CLKP_Enable();
3401397a:	f7fa ffa3 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
3401397e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013982:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34013986:	4618      	mov	r0, r3
34013988:	f7f9 ff34 	bl	3400d7f4 <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3401398c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013990:	e9d3 2300 	ldrd	r2, r3, [r3]
34013994:	2100      	movs	r1, #0
34013996:	6739      	str	r1, [r7, #112]	@ 0x70
34013998:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3401399c:	677b      	str	r3, [r7, #116]	@ 0x74
3401399e:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
340139a2:	4603      	mov	r3, r0
340139a4:	460a      	mov	r2, r1
340139a6:	4313      	orrs	r3, r2
340139a8:	f000 80ee 	beq.w	34013b88 <HAL_RCCEx_PeriphCLKConfig+0x5280>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
340139ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340139b0:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340139b4:	4b63      	ldr	r3, [pc, #396]	@ (34013b44 <HAL_RCCEx_PeriphCLKConfig+0x523c>)
340139b6:	429a      	cmp	r2, r3
340139b8:	d02e      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
340139ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340139be:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340139c2:	4b61      	ldr	r3, [pc, #388]	@ (34013b48 <HAL_RCCEx_PeriphCLKConfig+0x5240>)
340139c4:	429a      	cmp	r2, r3
340139c6:	d027      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
340139c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340139cc:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340139d0:	4b5e      	ldr	r3, [pc, #376]	@ (34013b4c <HAL_RCCEx_PeriphCLKConfig+0x5244>)
340139d2:	429a      	cmp	r2, r3
340139d4:	d020      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
340139d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340139da:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340139de:	4b5c      	ldr	r3, [pc, #368]	@ (34013b50 <HAL_RCCEx_PeriphCLKConfig+0x5248>)
340139e0:	429a      	cmp	r2, r3
340139e2:	d019      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
340139e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340139e8:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340139ec:	4b59      	ldr	r3, [pc, #356]	@ (34013b54 <HAL_RCCEx_PeriphCLKConfig+0x524c>)
340139ee:	429a      	cmp	r2, r3
340139f0:	d012      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
340139f2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340139f6:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340139fa:	4b57      	ldr	r3, [pc, #348]	@ (34013b58 <HAL_RCCEx_PeriphCLKConfig+0x5250>)
340139fc:	429a      	cmp	r2, r3
340139fe:	d00b      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
34013a00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a04:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34013a08:	4b54      	ldr	r3, [pc, #336]	@ (34013b5c <HAL_RCCEx_PeriphCLKConfig+0x5254>)
34013a0a:	429a      	cmp	r2, r3
34013a0c:	d004      	beq.n	34013a18 <HAL_RCCEx_PeriphCLKConfig+0x5110>
34013a0e:	f240 7125 	movw	r1, #1829	@ 0x725
34013a12:	4853      	ldr	r0, [pc, #332]	@ (34013b60 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
34013a14:	f7ed fc40 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
34013a18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a1c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34013a20:	4b4a      	ldr	r3, [pc, #296]	@ (34013b4c <HAL_RCCEx_PeriphCLKConfig+0x5244>)
34013a22:	429a      	cmp	r2, r3
34013a24:	d142      	bne.n	34013aac <HAL_RCCEx_PeriphCLKConfig+0x51a4>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34013a26:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a2a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013a2c:	2b00      	cmp	r3, #0
34013a2e:	d016      	beq.n	34013a5e <HAL_RCCEx_PeriphCLKConfig+0x5156>
34013a30:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a34:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013a36:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013a3a:	d010      	beq.n	34013a5e <HAL_RCCEx_PeriphCLKConfig+0x5156>
34013a3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a40:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013a42:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013a46:	d00a      	beq.n	34013a5e <HAL_RCCEx_PeriphCLKConfig+0x5156>
34013a48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a4c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013a4e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013a52:	d004      	beq.n	34013a5e <HAL_RCCEx_PeriphCLKConfig+0x5156>
34013a54:	f240 712a 	movw	r1, #1834	@ 0x72a
34013a58:	4841      	ldr	r0, [pc, #260]	@ (34013b60 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
34013a5a:	f7ed fc1d 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34013a5e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a62:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013a64:	2b00      	cmp	r3, #0
34013a66:	d005      	beq.n	34013a74 <HAL_RCCEx_PeriphCLKConfig+0x516c>
34013a68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a6c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013a6e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013a72:	d904      	bls.n	34013a7e <HAL_RCCEx_PeriphCLKConfig+0x5176>
34013a74:	f240 712b 	movw	r1, #1835	@ 0x72b
34013a78:	4839      	ldr	r0, [pc, #228]	@ (34013b60 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
34013a7a:	f7ed fc0d 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013a7e:	4b39      	ldr	r3, [pc, #228]	@ (34013b64 <HAL_RCCEx_PeriphCLKConfig+0x525c>)
34013a80:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34013a84:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013a88:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013a8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a90:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34013a92:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013a96:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013a98:	3b01      	subs	r3, #1
34013a9a:	041b      	lsls	r3, r3, #16
34013a9c:	4313      	orrs	r3, r2
34013a9e:	4a31      	ldr	r2, [pc, #196]	@ (34013b64 <HAL_RCCEx_PeriphCLKConfig+0x525c>)
34013aa0:	430b      	orrs	r3, r1
34013aa2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34013aa6:	f7fa fc4d 	bl	3400e344 <LL_RCC_IC9_Enable>
34013aaa:	e066      	b.n	34013b7a <HAL_RCCEx_PeriphCLKConfig+0x5272>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
34013aac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ab0:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34013ab4:	4b26      	ldr	r3, [pc, #152]	@ (34013b50 <HAL_RCCEx_PeriphCLKConfig+0x5248>)
34013ab6:	429a      	cmp	r2, r3
34013ab8:	d156      	bne.n	34013b68 <HAL_RCCEx_PeriphCLKConfig+0x5260>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
34013aba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013abe:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013ac0:	2b00      	cmp	r3, #0
34013ac2:	d016      	beq.n	34013af2 <HAL_RCCEx_PeriphCLKConfig+0x51ea>
34013ac4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ac8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013aca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013ace:	d010      	beq.n	34013af2 <HAL_RCCEx_PeriphCLKConfig+0x51ea>
34013ad0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ad4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013ad6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013ada:	d00a      	beq.n	34013af2 <HAL_RCCEx_PeriphCLKConfig+0x51ea>
34013adc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ae0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013ae2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013ae6:	d004      	beq.n	34013af2 <HAL_RCCEx_PeriphCLKConfig+0x51ea>
34013ae8:	f240 7137 	movw	r1, #1847	@ 0x737
34013aec:	481c      	ldr	r0, [pc, #112]	@ (34013b60 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
34013aee:	f7ed fbd3 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34013af2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013af6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013af8:	2b00      	cmp	r3, #0
34013afa:	d005      	beq.n	34013b08 <HAL_RCCEx_PeriphCLKConfig+0x5200>
34013afc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013b00:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013b02:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013b06:	d904      	bls.n	34013b12 <HAL_RCCEx_PeriphCLKConfig+0x520a>
34013b08:	f44f 61e7 	mov.w	r1, #1848	@ 0x738
34013b0c:	4814      	ldr	r0, [pc, #80]	@ (34013b60 <HAL_RCCEx_PeriphCLKConfig+0x5258>)
34013b0e:	f7ed fbc3 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34013b12:	4b14      	ldr	r3, [pc, #80]	@ (34013b64 <HAL_RCCEx_PeriphCLKConfig+0x525c>)
34013b14:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34013b18:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013b1c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013b20:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013b24:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34013b26:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013b2a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013b2c:	3b01      	subs	r3, #1
34013b2e:	041b      	lsls	r3, r3, #16
34013b30:	4313      	orrs	r3, r2
34013b32:	4a0c      	ldr	r2, [pc, #48]	@ (34013b64 <HAL_RCCEx_PeriphCLKConfig+0x525c>)
34013b34:	430b      	orrs	r3, r1
34013b36:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34013b3a:	f7fa fd03 	bl	3400e544 <LL_RCC_IC14_Enable>
34013b3e:	e01c      	b.n	34013b7a <HAL_RCCEx_PeriphCLKConfig+0x5272>
34013b40:	07011820 	.word	0x07011820
34013b44:	07000030 	.word	0x07000030
34013b48:	07010030 	.word	0x07010030
34013b4c:	07020030 	.word	0x07020030
34013b50:	07030030 	.word	0x07030030
34013b54:	07040030 	.word	0x07040030
34013b58:	07050030 	.word	0x07050030
34013b5c:	07060030 	.word	0x07060030
34013b60:	3402444c 	.word	0x3402444c
34013b64:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34013b68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013b6c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34013b70:	4b72      	ldr	r3, [pc, #456]	@ (34013d3c <HAL_RCCEx_PeriphCLKConfig+0x5434>)
34013b72:	429a      	cmp	r2, r3
34013b74:	d101      	bne.n	34013b7a <HAL_RCCEx_PeriphCLKConfig+0x5272>
    {
      LL_RCC_CLKP_Enable();
34013b76:	f7fa fea5 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34013b7a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013b7e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34013b82:	4618      	mov	r0, r3
34013b84:	f7f9 fe41 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34013b88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013b8c:	e9d3 2300 	ldrd	r2, r3, [r3]
34013b90:	2100      	movs	r1, #0
34013b92:	66b9      	str	r1, [r7, #104]	@ 0x68
34013b94:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34013b98:	66fb      	str	r3, [r7, #108]	@ 0x6c
34013b9a:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
34013b9e:	4603      	mov	r3, r0
34013ba0:	460a      	mov	r2, r1
34013ba2:	4313      	orrs	r3, r2
34013ba4:	f000 80ee 	beq.w	34013d84 <HAL_RCCEx_PeriphCLKConfig+0x547c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
34013ba8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013bac:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013bb0:	4b63      	ldr	r3, [pc, #396]	@ (34013d40 <HAL_RCCEx_PeriphCLKConfig+0x5438>)
34013bb2:	429a      	cmp	r2, r3
34013bb4:	d02e      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013bb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013bba:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013bbe:	4b61      	ldr	r3, [pc, #388]	@ (34013d44 <HAL_RCCEx_PeriphCLKConfig+0x543c>)
34013bc0:	429a      	cmp	r2, r3
34013bc2:	d027      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013bc4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013bc8:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013bcc:	4b5e      	ldr	r3, [pc, #376]	@ (34013d48 <HAL_RCCEx_PeriphCLKConfig+0x5440>)
34013bce:	429a      	cmp	r2, r3
34013bd0:	d020      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013bd2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013bd6:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013bda:	4b5c      	ldr	r3, [pc, #368]	@ (34013d4c <HAL_RCCEx_PeriphCLKConfig+0x5444>)
34013bdc:	429a      	cmp	r2, r3
34013bde:	d019      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013be0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013be4:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013be8:	4b59      	ldr	r3, [pc, #356]	@ (34013d50 <HAL_RCCEx_PeriphCLKConfig+0x5448>)
34013bea:	429a      	cmp	r2, r3
34013bec:	d012      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013bee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013bf2:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013bf6:	4b57      	ldr	r3, [pc, #348]	@ (34013d54 <HAL_RCCEx_PeriphCLKConfig+0x544c>)
34013bf8:	429a      	cmp	r2, r3
34013bfa:	d00b      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013bfc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c00:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013c04:	4b54      	ldr	r3, [pc, #336]	@ (34013d58 <HAL_RCCEx_PeriphCLKConfig+0x5450>)
34013c06:	429a      	cmp	r2, r3
34013c08:	d004      	beq.n	34013c14 <HAL_RCCEx_PeriphCLKConfig+0x530c>
34013c0a:	f240 7152 	movw	r1, #1874	@ 0x752
34013c0e:	4853      	ldr	r0, [pc, #332]	@ (34013d5c <HAL_RCCEx_PeriphCLKConfig+0x5454>)
34013c10:	f7ed fb42 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34013c14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c18:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013c1c:	4b4a      	ldr	r3, [pc, #296]	@ (34013d48 <HAL_RCCEx_PeriphCLKConfig+0x5440>)
34013c1e:	429a      	cmp	r2, r3
34013c20:	d142      	bne.n	34013ca8 <HAL_RCCEx_PeriphCLKConfig+0x53a0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34013c22:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c26:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013c28:	2b00      	cmp	r3, #0
34013c2a:	d016      	beq.n	34013c5a <HAL_RCCEx_PeriphCLKConfig+0x5352>
34013c2c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c30:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013c32:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013c36:	d010      	beq.n	34013c5a <HAL_RCCEx_PeriphCLKConfig+0x5352>
34013c38:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c3c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013c3e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013c42:	d00a      	beq.n	34013c5a <HAL_RCCEx_PeriphCLKConfig+0x5352>
34013c44:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c48:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013c4a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013c4e:	d004      	beq.n	34013c5a <HAL_RCCEx_PeriphCLKConfig+0x5352>
34013c50:	f240 7157 	movw	r1, #1879	@ 0x757
34013c54:	4841      	ldr	r0, [pc, #260]	@ (34013d5c <HAL_RCCEx_PeriphCLKConfig+0x5454>)
34013c56:	f7ed fb1f 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34013c5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c5e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013c60:	2b00      	cmp	r3, #0
34013c62:	d005      	beq.n	34013c70 <HAL_RCCEx_PeriphCLKConfig+0x5368>
34013c64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c68:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013c6a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013c6e:	d904      	bls.n	34013c7a <HAL_RCCEx_PeriphCLKConfig+0x5372>
34013c70:	f44f 61eb 	mov.w	r1, #1880	@ 0x758
34013c74:	4839      	ldr	r0, [pc, #228]	@ (34013d5c <HAL_RCCEx_PeriphCLKConfig+0x5454>)
34013c76:	f7ed fb0f 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013c7a:	4b39      	ldr	r3, [pc, #228]	@ (34013d60 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
34013c7c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34013c80:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013c84:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013c88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c8c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34013c8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013c92:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013c94:	3b01      	subs	r3, #1
34013c96:	041b      	lsls	r3, r3, #16
34013c98:	4313      	orrs	r3, r2
34013c9a:	4a31      	ldr	r2, [pc, #196]	@ (34013d60 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
34013c9c:	430b      	orrs	r3, r1
34013c9e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34013ca2:	f7fa fb4f 	bl	3400e344 <LL_RCC_IC9_Enable>
34013ca6:	e066      	b.n	34013d76 <HAL_RCCEx_PeriphCLKConfig+0x546e>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
34013ca8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cac:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013cb0:	4b26      	ldr	r3, [pc, #152]	@ (34013d4c <HAL_RCCEx_PeriphCLKConfig+0x5444>)
34013cb2:	429a      	cmp	r2, r3
34013cb4:	d156      	bne.n	34013d64 <HAL_RCCEx_PeriphCLKConfig+0x545c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
34013cb6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cba:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013cbc:	2b00      	cmp	r3, #0
34013cbe:	d016      	beq.n	34013cee <HAL_RCCEx_PeriphCLKConfig+0x53e6>
34013cc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cc4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013cc6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013cca:	d010      	beq.n	34013cee <HAL_RCCEx_PeriphCLKConfig+0x53e6>
34013ccc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cd0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013cd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013cd6:	d00a      	beq.n	34013cee <HAL_RCCEx_PeriphCLKConfig+0x53e6>
34013cd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cdc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013cde:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013ce2:	d004      	beq.n	34013cee <HAL_RCCEx_PeriphCLKConfig+0x53e6>
34013ce4:	f240 7164 	movw	r1, #1892	@ 0x764
34013ce8:	481c      	ldr	r0, [pc, #112]	@ (34013d5c <HAL_RCCEx_PeriphCLKConfig+0x5454>)
34013cea:	f7ed fad5 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34013cee:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cf2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013cf4:	2b00      	cmp	r3, #0
34013cf6:	d005      	beq.n	34013d04 <HAL_RCCEx_PeriphCLKConfig+0x53fc>
34013cf8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013cfc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013cfe:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013d02:	d904      	bls.n	34013d0e <HAL_RCCEx_PeriphCLKConfig+0x5406>
34013d04:	f240 7165 	movw	r1, #1893	@ 0x765
34013d08:	4814      	ldr	r0, [pc, #80]	@ (34013d5c <HAL_RCCEx_PeriphCLKConfig+0x5454>)
34013d0a:	f7ed fac5 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34013d0e:	4b14      	ldr	r3, [pc, #80]	@ (34013d60 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
34013d10:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34013d14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013d18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013d1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013d20:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34013d22:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013d26:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013d28:	3b01      	subs	r3, #1
34013d2a:	041b      	lsls	r3, r3, #16
34013d2c:	4313      	orrs	r3, r2
34013d2e:	4a0c      	ldr	r2, [pc, #48]	@ (34013d60 <HAL_RCCEx_PeriphCLKConfig+0x5458>)
34013d30:	430b      	orrs	r3, r1
34013d32:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34013d36:	f7fa fc05 	bl	3400e544 <LL_RCC_IC14_Enable>
34013d3a:	e01c      	b.n	34013d76 <HAL_RCCEx_PeriphCLKConfig+0x546e>
34013d3c:	07010030 	.word	0x07010030
34013d40:	07000430 	.word	0x07000430
34013d44:	07010430 	.word	0x07010430
34013d48:	07020430 	.word	0x07020430
34013d4c:	07030430 	.word	0x07030430
34013d50:	07040430 	.word	0x07040430
34013d54:	07050430 	.word	0x07050430
34013d58:	07060430 	.word	0x07060430
34013d5c:	3402444c 	.word	0x3402444c
34013d60:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
34013d64:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013d68:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34013d6c:	4b72      	ldr	r3, [pc, #456]	@ (34013f38 <HAL_RCCEx_PeriphCLKConfig+0x5630>)
34013d6e:	429a      	cmp	r2, r3
34013d70:	d101      	bne.n	34013d76 <HAL_RCCEx_PeriphCLKConfig+0x546e>
    {
      LL_RCC_CLKP_Enable();
34013d72:	f7fa fda7 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
34013d76:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013d7a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34013d7e:	4618      	mov	r0, r3
34013d80:	f7f9 fd43 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
34013d84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013d88:	e9d3 2300 	ldrd	r2, r3, [r3]
34013d8c:	2100      	movs	r1, #0
34013d8e:	6639      	str	r1, [r7, #96]	@ 0x60
34013d90:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34013d94:	667b      	str	r3, [r7, #100]	@ 0x64
34013d96:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
34013d9a:	4603      	mov	r3, r0
34013d9c:	460a      	mov	r2, r1
34013d9e:	4313      	orrs	r3, r2
34013da0:	f000 80ee 	beq.w	34013f80 <HAL_RCCEx_PeriphCLKConfig+0x5678>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
34013da4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013da8:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013dac:	4b63      	ldr	r3, [pc, #396]	@ (34013f3c <HAL_RCCEx_PeriphCLKConfig+0x5634>)
34013dae:	429a      	cmp	r2, r3
34013db0:	d02e      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013db2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013db6:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013dba:	4b61      	ldr	r3, [pc, #388]	@ (34013f40 <HAL_RCCEx_PeriphCLKConfig+0x5638>)
34013dbc:	429a      	cmp	r2, r3
34013dbe:	d027      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013dc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013dc4:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013dc8:	4b5e      	ldr	r3, [pc, #376]	@ (34013f44 <HAL_RCCEx_PeriphCLKConfig+0x563c>)
34013dca:	429a      	cmp	r2, r3
34013dcc:	d020      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013dce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013dd2:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013dd6:	4b5c      	ldr	r3, [pc, #368]	@ (34013f48 <HAL_RCCEx_PeriphCLKConfig+0x5640>)
34013dd8:	429a      	cmp	r2, r3
34013dda:	d019      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013ddc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013de0:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013de4:	4b59      	ldr	r3, [pc, #356]	@ (34013f4c <HAL_RCCEx_PeriphCLKConfig+0x5644>)
34013de6:	429a      	cmp	r2, r3
34013de8:	d012      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013dea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013dee:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013df2:	4b57      	ldr	r3, [pc, #348]	@ (34013f50 <HAL_RCCEx_PeriphCLKConfig+0x5648>)
34013df4:	429a      	cmp	r2, r3
34013df6:	d00b      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013df8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013dfc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013e00:	4b54      	ldr	r3, [pc, #336]	@ (34013f54 <HAL_RCCEx_PeriphCLKConfig+0x564c>)
34013e02:	429a      	cmp	r2, r3
34013e04:	d004      	beq.n	34013e10 <HAL_RCCEx_PeriphCLKConfig+0x5508>
34013e06:	f240 717f 	movw	r1, #1919	@ 0x77f
34013e0a:	4853      	ldr	r0, [pc, #332]	@ (34013f58 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
34013e0c:	f7ed fa44 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34013e10:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e14:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013e18:	4b4a      	ldr	r3, [pc, #296]	@ (34013f44 <HAL_RCCEx_PeriphCLKConfig+0x563c>)
34013e1a:	429a      	cmp	r2, r3
34013e1c:	d142      	bne.n	34013ea4 <HAL_RCCEx_PeriphCLKConfig+0x559c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34013e1e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e22:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013e24:	2b00      	cmp	r3, #0
34013e26:	d016      	beq.n	34013e56 <HAL_RCCEx_PeriphCLKConfig+0x554e>
34013e28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e2c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013e2e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013e32:	d010      	beq.n	34013e56 <HAL_RCCEx_PeriphCLKConfig+0x554e>
34013e34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e38:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013e3a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013e3e:	d00a      	beq.n	34013e56 <HAL_RCCEx_PeriphCLKConfig+0x554e>
34013e40:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e44:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34013e46:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013e4a:	d004      	beq.n	34013e56 <HAL_RCCEx_PeriphCLKConfig+0x554e>
34013e4c:	f240 7184 	movw	r1, #1924	@ 0x784
34013e50:	4841      	ldr	r0, [pc, #260]	@ (34013f58 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
34013e52:	f7ed fa21 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34013e56:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e5a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013e5c:	2b00      	cmp	r3, #0
34013e5e:	d005      	beq.n	34013e6c <HAL_RCCEx_PeriphCLKConfig+0x5564>
34013e60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e64:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013e66:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013e6a:	d904      	bls.n	34013e76 <HAL_RCCEx_PeriphCLKConfig+0x556e>
34013e6c:	f240 7185 	movw	r1, #1925	@ 0x785
34013e70:	4839      	ldr	r0, [pc, #228]	@ (34013f58 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
34013e72:	f7ed fa11 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34013e76:	4b39      	ldr	r3, [pc, #228]	@ (34013f5c <HAL_RCCEx_PeriphCLKConfig+0x5654>)
34013e78:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34013e7c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013e80:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013e84:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e88:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34013e8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013e8e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34013e90:	3b01      	subs	r3, #1
34013e92:	041b      	lsls	r3, r3, #16
34013e94:	4313      	orrs	r3, r2
34013e96:	4a31      	ldr	r2, [pc, #196]	@ (34013f5c <HAL_RCCEx_PeriphCLKConfig+0x5654>)
34013e98:	430b      	orrs	r3, r1
34013e9a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34013e9e:	f7fa fa51 	bl	3400e344 <LL_RCC_IC9_Enable>
34013ea2:	e066      	b.n	34013f72 <HAL_RCCEx_PeriphCLKConfig+0x566a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34013ea4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ea8:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013eac:	4b26      	ldr	r3, [pc, #152]	@ (34013f48 <HAL_RCCEx_PeriphCLKConfig+0x5640>)
34013eae:	429a      	cmp	r2, r3
34013eb0:	d156      	bne.n	34013f60 <HAL_RCCEx_PeriphCLKConfig+0x5658>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
34013eb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013eb6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013eb8:	2b00      	cmp	r3, #0
34013eba:	d016      	beq.n	34013eea <HAL_RCCEx_PeriphCLKConfig+0x55e2>
34013ebc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ec0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013ec2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013ec6:	d010      	beq.n	34013eea <HAL_RCCEx_PeriphCLKConfig+0x55e2>
34013ec8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ecc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013ece:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013ed2:	d00a      	beq.n	34013eea <HAL_RCCEx_PeriphCLKConfig+0x55e2>
34013ed4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ed8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34013eda:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013ede:	d004      	beq.n	34013eea <HAL_RCCEx_PeriphCLKConfig+0x55e2>
34013ee0:	f240 7191 	movw	r1, #1937	@ 0x791
34013ee4:	481c      	ldr	r0, [pc, #112]	@ (34013f58 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
34013ee6:	f7ed f9d7 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34013eea:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013eee:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013ef0:	2b00      	cmp	r3, #0
34013ef2:	d005      	beq.n	34013f00 <HAL_RCCEx_PeriphCLKConfig+0x55f8>
34013ef4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ef8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013efa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34013efe:	d904      	bls.n	34013f0a <HAL_RCCEx_PeriphCLKConfig+0x5602>
34013f00:	f240 7192 	movw	r1, #1938	@ 0x792
34013f04:	4814      	ldr	r0, [pc, #80]	@ (34013f58 <HAL_RCCEx_PeriphCLKConfig+0x5650>)
34013f06:	f7ed f9c7 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34013f0a:	4b14      	ldr	r3, [pc, #80]	@ (34013f5c <HAL_RCCEx_PeriphCLKConfig+0x5654>)
34013f0c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34013f10:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34013f14:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34013f18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013f1c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34013f1e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013f22:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34013f24:	3b01      	subs	r3, #1
34013f26:	041b      	lsls	r3, r3, #16
34013f28:	4313      	orrs	r3, r2
34013f2a:	4a0c      	ldr	r2, [pc, #48]	@ (34013f5c <HAL_RCCEx_PeriphCLKConfig+0x5654>)
34013f2c:	430b      	orrs	r3, r1
34013f2e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34013f32:	f7fa fb07 	bl	3400e544 <LL_RCC_IC14_Enable>
34013f36:	e01c      	b.n	34013f72 <HAL_RCCEx_PeriphCLKConfig+0x566a>
34013f38:	07010430 	.word	0x07010430
34013f3c:	07000830 	.word	0x07000830
34013f40:	07010830 	.word	0x07010830
34013f44:	07020830 	.word	0x07020830
34013f48:	07030830 	.word	0x07030830
34013f4c:	07040830 	.word	0x07040830
34013f50:	07050830 	.word	0x07050830
34013f54:	07060830 	.word	0x07060830
34013f58:	3402444c 	.word	0x3402444c
34013f5c:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
34013f60:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013f64:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34013f68:	4b72      	ldr	r3, [pc, #456]	@ (34014134 <HAL_RCCEx_PeriphCLKConfig+0x582c>)
34013f6a:	429a      	cmp	r2, r3
34013f6c:	d101      	bne.n	34013f72 <HAL_RCCEx_PeriphCLKConfig+0x566a>
    {
      LL_RCC_CLKP_Enable();
34013f6e:	f7fa fca9 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
34013f72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013f76:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
34013f7a:	4618      	mov	r0, r3
34013f7c:	f7f9 fc45 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
34013f80:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013f84:	e9d3 2300 	ldrd	r2, r3, [r3]
34013f88:	2100      	movs	r1, #0
34013f8a:	65b9      	str	r1, [r7, #88]	@ 0x58
34013f8c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34013f90:	65fb      	str	r3, [r7, #92]	@ 0x5c
34013f92:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
34013f96:	4603      	mov	r3, r0
34013f98:	460a      	mov	r2, r1
34013f9a:	4313      	orrs	r3, r2
34013f9c:	f000 80ee 	beq.w	3401417c <HAL_RCCEx_PeriphCLKConfig+0x5874>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
34013fa0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013fa4:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013fa8:	4b63      	ldr	r3, [pc, #396]	@ (34014138 <HAL_RCCEx_PeriphCLKConfig+0x5830>)
34013faa:	429a      	cmp	r2, r3
34013fac:	d02e      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34013fae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013fb2:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013fb6:	4b61      	ldr	r3, [pc, #388]	@ (3401413c <HAL_RCCEx_PeriphCLKConfig+0x5834>)
34013fb8:	429a      	cmp	r2, r3
34013fba:	d027      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34013fbc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013fc0:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013fc4:	4b5e      	ldr	r3, [pc, #376]	@ (34014140 <HAL_RCCEx_PeriphCLKConfig+0x5838>)
34013fc6:	429a      	cmp	r2, r3
34013fc8:	d020      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34013fca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013fce:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013fd2:	4b5c      	ldr	r3, [pc, #368]	@ (34014144 <HAL_RCCEx_PeriphCLKConfig+0x583c>)
34013fd4:	429a      	cmp	r2, r3
34013fd6:	d019      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34013fd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013fdc:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013fe0:	4b59      	ldr	r3, [pc, #356]	@ (34014148 <HAL_RCCEx_PeriphCLKConfig+0x5840>)
34013fe2:	429a      	cmp	r2, r3
34013fe4:	d012      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34013fe6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013fea:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013fee:	4b57      	ldr	r3, [pc, #348]	@ (3401414c <HAL_RCCEx_PeriphCLKConfig+0x5844>)
34013ff0:	429a      	cmp	r2, r3
34013ff2:	d00b      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34013ff4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34013ff8:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34013ffc:	4b54      	ldr	r3, [pc, #336]	@ (34014150 <HAL_RCCEx_PeriphCLKConfig+0x5848>)
34013ffe:	429a      	cmp	r2, r3
34014000:	d004      	beq.n	3401400c <HAL_RCCEx_PeriphCLKConfig+0x5704>
34014002:	f240 71ac 	movw	r1, #1964	@ 0x7ac
34014006:	4853      	ldr	r0, [pc, #332]	@ (34014154 <HAL_RCCEx_PeriphCLKConfig+0x584c>)
34014008:	f7ed f946 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3401400c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014010:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34014014:	4b4a      	ldr	r3, [pc, #296]	@ (34014140 <HAL_RCCEx_PeriphCLKConfig+0x5838>)
34014016:	429a      	cmp	r2, r3
34014018:	d142      	bne.n	340140a0 <HAL_RCCEx_PeriphCLKConfig+0x5798>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3401401a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401401e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014020:	2b00      	cmp	r3, #0
34014022:	d016      	beq.n	34014052 <HAL_RCCEx_PeriphCLKConfig+0x574a>
34014024:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014028:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401402a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401402e:	d010      	beq.n	34014052 <HAL_RCCEx_PeriphCLKConfig+0x574a>
34014030:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014034:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014036:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401403a:	d00a      	beq.n	34014052 <HAL_RCCEx_PeriphCLKConfig+0x574a>
3401403c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014040:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014042:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014046:	d004      	beq.n	34014052 <HAL_RCCEx_PeriphCLKConfig+0x574a>
34014048:	f240 71b1 	movw	r1, #1969	@ 0x7b1
3401404c:	4841      	ldr	r0, [pc, #260]	@ (34014154 <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3401404e:	f7ed f923 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34014052:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014056:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014058:	2b00      	cmp	r3, #0
3401405a:	d005      	beq.n	34014068 <HAL_RCCEx_PeriphCLKConfig+0x5760>
3401405c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014060:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014062:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014066:	d904      	bls.n	34014072 <HAL_RCCEx_PeriphCLKConfig+0x576a>
34014068:	f240 71b2 	movw	r1, #1970	@ 0x7b2
3401406c:	4839      	ldr	r0, [pc, #228]	@ (34014154 <HAL_RCCEx_PeriphCLKConfig+0x584c>)
3401406e:	f7ed f913 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34014072:	4b39      	ldr	r3, [pc, #228]	@ (34014158 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
34014074:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34014078:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401407c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014080:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014084:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34014086:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401408a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401408c:	3b01      	subs	r3, #1
3401408e:	041b      	lsls	r3, r3, #16
34014090:	4313      	orrs	r3, r2
34014092:	4a31      	ldr	r2, [pc, #196]	@ (34014158 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
34014094:	430b      	orrs	r3, r1
34014096:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401409a:	f7fa f953 	bl	3400e344 <LL_RCC_IC9_Enable>
3401409e:	e066      	b.n	3401416e <HAL_RCCEx_PeriphCLKConfig+0x5866>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
340140a0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140a4:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
340140a8:	4b26      	ldr	r3, [pc, #152]	@ (34014144 <HAL_RCCEx_PeriphCLKConfig+0x583c>)
340140aa:	429a      	cmp	r2, r3
340140ac:	d156      	bne.n	3401415c <HAL_RCCEx_PeriphCLKConfig+0x5854>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340140ae:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140b2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340140b4:	2b00      	cmp	r3, #0
340140b6:	d016      	beq.n	340140e6 <HAL_RCCEx_PeriphCLKConfig+0x57de>
340140b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140bc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340140be:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340140c2:	d010      	beq.n	340140e6 <HAL_RCCEx_PeriphCLKConfig+0x57de>
340140c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140c8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340140ca:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340140ce:	d00a      	beq.n	340140e6 <HAL_RCCEx_PeriphCLKConfig+0x57de>
340140d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140d4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340140d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340140da:	d004      	beq.n	340140e6 <HAL_RCCEx_PeriphCLKConfig+0x57de>
340140dc:	f240 71be 	movw	r1, #1982	@ 0x7be
340140e0:	481c      	ldr	r0, [pc, #112]	@ (34014154 <HAL_RCCEx_PeriphCLKConfig+0x584c>)
340140e2:	f7ed f8d9 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340140e6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140ea:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340140ec:	2b00      	cmp	r3, #0
340140ee:	d005      	beq.n	340140fc <HAL_RCCEx_PeriphCLKConfig+0x57f4>
340140f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340140f4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340140f6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340140fa:	d904      	bls.n	34014106 <HAL_RCCEx_PeriphCLKConfig+0x57fe>
340140fc:	f240 71bf 	movw	r1, #1983	@ 0x7bf
34014100:	4814      	ldr	r0, [pc, #80]	@ (34014154 <HAL_RCCEx_PeriphCLKConfig+0x584c>)
34014102:	f7ed f8c9 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34014106:	4b14      	ldr	r3, [pc, #80]	@ (34014158 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
34014108:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401410c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014110:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014114:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014118:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401411a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401411e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014120:	3b01      	subs	r3, #1
34014122:	041b      	lsls	r3, r3, #16
34014124:	4313      	orrs	r3, r2
34014126:	4a0c      	ldr	r2, [pc, #48]	@ (34014158 <HAL_RCCEx_PeriphCLKConfig+0x5850>)
34014128:	430b      	orrs	r3, r1
3401412a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401412e:	f7fa fa09 	bl	3400e544 <LL_RCC_IC14_Enable>
34014132:	e01c      	b.n	3401416e <HAL_RCCEx_PeriphCLKConfig+0x5866>
34014134:	07010830 	.word	0x07010830
34014138:	07000c30 	.word	0x07000c30
3401413c:	07010c30 	.word	0x07010c30
34014140:	07020c30 	.word	0x07020c30
34014144:	07030c30 	.word	0x07030c30
34014148:	07040c30 	.word	0x07040c30
3401414c:	07050c30 	.word	0x07050c30
34014150:	07060c30 	.word	0x07060c30
34014154:	3402444c 	.word	0x3402444c
34014158:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3401415c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014160:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34014164:	4b72      	ldr	r3, [pc, #456]	@ (34014330 <HAL_RCCEx_PeriphCLKConfig+0x5a28>)
34014166:	429a      	cmp	r2, r3
34014168:	d101      	bne.n	3401416e <HAL_RCCEx_PeriphCLKConfig+0x5866>
    {
      LL_RCC_CLKP_Enable();
3401416a:	f7fa fbab 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
3401416e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014172:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34014176:	4618      	mov	r0, r3
34014178:	f7f9 fb47 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3401417c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014180:	e9d3 2300 	ldrd	r2, r3, [r3]
34014184:	2100      	movs	r1, #0
34014186:	6539      	str	r1, [r7, #80]	@ 0x50
34014188:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3401418c:	657b      	str	r3, [r7, #84]	@ 0x54
3401418e:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
34014192:	4603      	mov	r3, r0
34014194:	460a      	mov	r2, r1
34014196:	4313      	orrs	r3, r2
34014198:	f000 80ee 	beq.w	34014378 <HAL_RCCEx_PeriphCLKConfig+0x5a70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
3401419c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141a0:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141a4:	4b63      	ldr	r3, [pc, #396]	@ (34014334 <HAL_RCCEx_PeriphCLKConfig+0x5a2c>)
340141a6:	429a      	cmp	r2, r3
340141a8:	d02e      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141ae:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141b2:	4b61      	ldr	r3, [pc, #388]	@ (34014338 <HAL_RCCEx_PeriphCLKConfig+0x5a30>)
340141b4:	429a      	cmp	r2, r3
340141b6:	d027      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141bc:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141c0:	4b5e      	ldr	r3, [pc, #376]	@ (3401433c <HAL_RCCEx_PeriphCLKConfig+0x5a34>)
340141c2:	429a      	cmp	r2, r3
340141c4:	d020      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141c6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141ca:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141ce:	4b5c      	ldr	r3, [pc, #368]	@ (34014340 <HAL_RCCEx_PeriphCLKConfig+0x5a38>)
340141d0:	429a      	cmp	r2, r3
340141d2:	d019      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141d4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141d8:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141dc:	4b59      	ldr	r3, [pc, #356]	@ (34014344 <HAL_RCCEx_PeriphCLKConfig+0x5a3c>)
340141de:	429a      	cmp	r2, r3
340141e0:	d012      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141e6:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141ea:	4b57      	ldr	r3, [pc, #348]	@ (34014348 <HAL_RCCEx_PeriphCLKConfig+0x5a40>)
340141ec:	429a      	cmp	r2, r3
340141ee:	d00b      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141f0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340141f4:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340141f8:	4b54      	ldr	r3, [pc, #336]	@ (3401434c <HAL_RCCEx_PeriphCLKConfig+0x5a44>)
340141fa:	429a      	cmp	r2, r3
340141fc:	d004      	beq.n	34014208 <HAL_RCCEx_PeriphCLKConfig+0x5900>
340141fe:	f240 71d9 	movw	r1, #2009	@ 0x7d9
34014202:	4853      	ldr	r0, [pc, #332]	@ (34014350 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
34014204:	f7ed f848 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
34014208:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401420c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34014210:	4b4a      	ldr	r3, [pc, #296]	@ (3401433c <HAL_RCCEx_PeriphCLKConfig+0x5a34>)
34014212:	429a      	cmp	r2, r3
34014214:	d142      	bne.n	3401429c <HAL_RCCEx_PeriphCLKConfig+0x5994>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34014216:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401421a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401421c:	2b00      	cmp	r3, #0
3401421e:	d016      	beq.n	3401424e <HAL_RCCEx_PeriphCLKConfig+0x5946>
34014220:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014224:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014226:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401422a:	d010      	beq.n	3401424e <HAL_RCCEx_PeriphCLKConfig+0x5946>
3401422c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014230:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014232:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014236:	d00a      	beq.n	3401424e <HAL_RCCEx_PeriphCLKConfig+0x5946>
34014238:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401423c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401423e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014242:	d004      	beq.n	3401424e <HAL_RCCEx_PeriphCLKConfig+0x5946>
34014244:	f240 71de 	movw	r1, #2014	@ 0x7de
34014248:	4841      	ldr	r0, [pc, #260]	@ (34014350 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3401424a:	f7ed f825 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3401424e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014252:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014254:	2b00      	cmp	r3, #0
34014256:	d005      	beq.n	34014264 <HAL_RCCEx_PeriphCLKConfig+0x595c>
34014258:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401425c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401425e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014262:	d904      	bls.n	3401426e <HAL_RCCEx_PeriphCLKConfig+0x5966>
34014264:	f240 71df 	movw	r1, #2015	@ 0x7df
34014268:	4839      	ldr	r0, [pc, #228]	@ (34014350 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
3401426a:	f7ed f815 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401426e:	4b39      	ldr	r3, [pc, #228]	@ (34014354 <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
34014270:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34014274:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014278:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401427c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014280:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34014282:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014286:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014288:	3b01      	subs	r3, #1
3401428a:	041b      	lsls	r3, r3, #16
3401428c:	4313      	orrs	r3, r2
3401428e:	4a31      	ldr	r2, [pc, #196]	@ (34014354 <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
34014290:	430b      	orrs	r3, r1
34014292:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34014296:	f7fa f855 	bl	3400e344 <LL_RCC_IC9_Enable>
3401429a:	e066      	b.n	3401436a <HAL_RCCEx_PeriphCLKConfig+0x5a62>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3401429c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142a0:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340142a4:	4b26      	ldr	r3, [pc, #152]	@ (34014340 <HAL_RCCEx_PeriphCLKConfig+0x5a38>)
340142a6:	429a      	cmp	r2, r3
340142a8:	d156      	bne.n	34014358 <HAL_RCCEx_PeriphCLKConfig+0x5a50>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340142aa:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142ae:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340142b0:	2b00      	cmp	r3, #0
340142b2:	d016      	beq.n	340142e2 <HAL_RCCEx_PeriphCLKConfig+0x59da>
340142b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142b8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340142ba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340142be:	d010      	beq.n	340142e2 <HAL_RCCEx_PeriphCLKConfig+0x59da>
340142c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142c4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340142c6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340142ca:	d00a      	beq.n	340142e2 <HAL_RCCEx_PeriphCLKConfig+0x59da>
340142cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142d0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340142d2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340142d6:	d004      	beq.n	340142e2 <HAL_RCCEx_PeriphCLKConfig+0x59da>
340142d8:	f240 71eb 	movw	r1, #2027	@ 0x7eb
340142dc:	481c      	ldr	r0, [pc, #112]	@ (34014350 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
340142de:	f7ec ffdb 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340142e2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142e6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340142e8:	2b00      	cmp	r3, #0
340142ea:	d005      	beq.n	340142f8 <HAL_RCCEx_PeriphCLKConfig+0x59f0>
340142ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340142f0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340142f2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340142f6:	d904      	bls.n	34014302 <HAL_RCCEx_PeriphCLKConfig+0x59fa>
340142f8:	f240 71ec 	movw	r1, #2028	@ 0x7ec
340142fc:	4814      	ldr	r0, [pc, #80]	@ (34014350 <HAL_RCCEx_PeriphCLKConfig+0x5a48>)
340142fe:	f7ec ffcb 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34014302:	4b14      	ldr	r3, [pc, #80]	@ (34014354 <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
34014304:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34014308:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401430c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014310:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014314:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34014316:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401431a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401431c:	3b01      	subs	r3, #1
3401431e:	041b      	lsls	r3, r3, #16
34014320:	4313      	orrs	r3, r2
34014322:	4a0c      	ldr	r2, [pc, #48]	@ (34014354 <HAL_RCCEx_PeriphCLKConfig+0x5a4c>)
34014324:	430b      	orrs	r3, r1
34014326:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401432a:	f7fa f90b 	bl	3400e544 <LL_RCC_IC14_Enable>
3401432e:	e01c      	b.n	3401436a <HAL_RCCEx_PeriphCLKConfig+0x5a62>
34014330:	07010c30 	.word	0x07010c30
34014334:	07001030 	.word	0x07001030
34014338:	07011030 	.word	0x07011030
3401433c:	07021030 	.word	0x07021030
34014340:	07031030 	.word	0x07031030
34014344:	07041030 	.word	0x07041030
34014348:	07051030 	.word	0x07051030
3401434c:	07061030 	.word	0x07061030
34014350:	3402444c 	.word	0x3402444c
34014354:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34014358:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401435c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34014360:	4b72      	ldr	r3, [pc, #456]	@ (3401452c <HAL_RCCEx_PeriphCLKConfig+0x5c24>)
34014362:	429a      	cmp	r2, r3
34014364:	d101      	bne.n	3401436a <HAL_RCCEx_PeriphCLKConfig+0x5a62>
    {
      LL_RCC_CLKP_Enable();
34014366:	f7fa faad 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
3401436a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401436e:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
34014372:	4618      	mov	r0, r3
34014374:	f7f9 fa49 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
34014378:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401437c:	e9d3 2300 	ldrd	r2, r3, [r3]
34014380:	2100      	movs	r1, #0
34014382:	64b9      	str	r1, [r7, #72]	@ 0x48
34014384:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34014388:	64fb      	str	r3, [r7, #76]	@ 0x4c
3401438a:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
3401438e:	4603      	mov	r3, r0
34014390:	460a      	mov	r2, r1
34014392:	4313      	orrs	r3, r2
34014394:	f000 80ee 	beq.w	34014574 <HAL_RCCEx_PeriphCLKConfig+0x5c6c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
34014398:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401439c:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143a0:	4b63      	ldr	r3, [pc, #396]	@ (34014530 <HAL_RCCEx_PeriphCLKConfig+0x5c28>)
340143a2:	429a      	cmp	r2, r3
340143a4:	d02e      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340143aa:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143ae:	4b61      	ldr	r3, [pc, #388]	@ (34014534 <HAL_RCCEx_PeriphCLKConfig+0x5c2c>)
340143b0:	429a      	cmp	r2, r3
340143b2:	d027      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340143b8:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143bc:	4b5e      	ldr	r3, [pc, #376]	@ (34014538 <HAL_RCCEx_PeriphCLKConfig+0x5c30>)
340143be:	429a      	cmp	r2, r3
340143c0:	d020      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143c2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340143c6:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143ca:	4b5c      	ldr	r3, [pc, #368]	@ (3401453c <HAL_RCCEx_PeriphCLKConfig+0x5c34>)
340143cc:	429a      	cmp	r2, r3
340143ce:	d019      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143d0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340143d4:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143d8:	4b59      	ldr	r3, [pc, #356]	@ (34014540 <HAL_RCCEx_PeriphCLKConfig+0x5c38>)
340143da:	429a      	cmp	r2, r3
340143dc:	d012      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340143e2:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143e6:	4b57      	ldr	r3, [pc, #348]	@ (34014544 <HAL_RCCEx_PeriphCLKConfig+0x5c3c>)
340143e8:	429a      	cmp	r2, r3
340143ea:	d00b      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143ec:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340143f0:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340143f4:	4b54      	ldr	r3, [pc, #336]	@ (34014548 <HAL_RCCEx_PeriphCLKConfig+0x5c40>)
340143f6:	429a      	cmp	r2, r3
340143f8:	d004      	beq.n	34014404 <HAL_RCCEx_PeriphCLKConfig+0x5afc>
340143fa:	f640 0106 	movw	r1, #2054	@ 0x806
340143fe:	4853      	ldr	r0, [pc, #332]	@ (3401454c <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
34014400:	f7ec ff4a 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
34014404:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014408:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3401440c:	4b4a      	ldr	r3, [pc, #296]	@ (34014538 <HAL_RCCEx_PeriphCLKConfig+0x5c30>)
3401440e:	429a      	cmp	r2, r3
34014410:	d142      	bne.n	34014498 <HAL_RCCEx_PeriphCLKConfig+0x5b90>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34014412:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014416:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014418:	2b00      	cmp	r3, #0
3401441a:	d016      	beq.n	3401444a <HAL_RCCEx_PeriphCLKConfig+0x5b42>
3401441c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014420:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014422:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014426:	d010      	beq.n	3401444a <HAL_RCCEx_PeriphCLKConfig+0x5b42>
34014428:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401442c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401442e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014432:	d00a      	beq.n	3401444a <HAL_RCCEx_PeriphCLKConfig+0x5b42>
34014434:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014438:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401443a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401443e:	d004      	beq.n	3401444a <HAL_RCCEx_PeriphCLKConfig+0x5b42>
34014440:	f640 010b 	movw	r1, #2059	@ 0x80b
34014444:	4841      	ldr	r0, [pc, #260]	@ (3401454c <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
34014446:	f7ec ff27 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3401444a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401444e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014450:	2b00      	cmp	r3, #0
34014452:	d005      	beq.n	34014460 <HAL_RCCEx_PeriphCLKConfig+0x5b58>
34014454:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014458:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401445a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401445e:	d904      	bls.n	3401446a <HAL_RCCEx_PeriphCLKConfig+0x5b62>
34014460:	f640 010c 	movw	r1, #2060	@ 0x80c
34014464:	4839      	ldr	r0, [pc, #228]	@ (3401454c <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
34014466:	f7ec ff17 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401446a:	4b39      	ldr	r3, [pc, #228]	@ (34014550 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
3401446c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34014470:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014474:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014478:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401447c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401447e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014482:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014484:	3b01      	subs	r3, #1
34014486:	041b      	lsls	r3, r3, #16
34014488:	4313      	orrs	r3, r2
3401448a:	4a31      	ldr	r2, [pc, #196]	@ (34014550 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
3401448c:	430b      	orrs	r3, r1
3401448e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34014492:	f7f9 ff57 	bl	3400e344 <LL_RCC_IC9_Enable>
34014496:	e066      	b.n	34014566 <HAL_RCCEx_PeriphCLKConfig+0x5c5e>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
34014498:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401449c:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340144a0:	4b26      	ldr	r3, [pc, #152]	@ (3401453c <HAL_RCCEx_PeriphCLKConfig+0x5c34>)
340144a2:	429a      	cmp	r2, r3
340144a4:	d156      	bne.n	34014554 <HAL_RCCEx_PeriphCLKConfig+0x5c4c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340144a6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340144aa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340144ac:	2b00      	cmp	r3, #0
340144ae:	d016      	beq.n	340144de <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
340144b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340144b4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340144b6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340144ba:	d010      	beq.n	340144de <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
340144bc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340144c0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340144c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340144c6:	d00a      	beq.n	340144de <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
340144c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340144cc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340144ce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340144d2:	d004      	beq.n	340144de <HAL_RCCEx_PeriphCLKConfig+0x5bd6>
340144d4:	f640 0118 	movw	r1, #2072	@ 0x818
340144d8:	481c      	ldr	r0, [pc, #112]	@ (3401454c <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
340144da:	f7ec fedd 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340144de:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340144e2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340144e4:	2b00      	cmp	r3, #0
340144e6:	d005      	beq.n	340144f4 <HAL_RCCEx_PeriphCLKConfig+0x5bec>
340144e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340144ec:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340144ee:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340144f2:	d904      	bls.n	340144fe <HAL_RCCEx_PeriphCLKConfig+0x5bf6>
340144f4:	f640 0119 	movw	r1, #2073	@ 0x819
340144f8:	4814      	ldr	r0, [pc, #80]	@ (3401454c <HAL_RCCEx_PeriphCLKConfig+0x5c44>)
340144fa:	f7ec fecd 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340144fe:	4b14      	ldr	r3, [pc, #80]	@ (34014550 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
34014500:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34014504:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014508:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401450c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014510:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34014512:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014516:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014518:	3b01      	subs	r3, #1
3401451a:	041b      	lsls	r3, r3, #16
3401451c:	4313      	orrs	r3, r2
3401451e:	4a0c      	ldr	r2, [pc, #48]	@ (34014550 <HAL_RCCEx_PeriphCLKConfig+0x5c48>)
34014520:	430b      	orrs	r3, r1
34014522:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34014526:	f7fa f80d 	bl	3400e544 <LL_RCC_IC14_Enable>
3401452a:	e01c      	b.n	34014566 <HAL_RCCEx_PeriphCLKConfig+0x5c5e>
3401452c:	07011030 	.word	0x07011030
34014530:	07001430 	.word	0x07001430
34014534:	07011430 	.word	0x07011430
34014538:	07021430 	.word	0x07021430
3401453c:	07031430 	.word	0x07031430
34014540:	07041430 	.word	0x07041430
34014544:	07051430 	.word	0x07051430
34014548:	07061430 	.word	0x07061430
3401454c:	3402444c 	.word	0x3402444c
34014550:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
34014554:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014558:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3401455c:	4b72      	ldr	r3, [pc, #456]	@ (34014728 <HAL_RCCEx_PeriphCLKConfig+0x5e20>)
3401455e:	429a      	cmp	r2, r3
34014560:	d101      	bne.n	34014566 <HAL_RCCEx_PeriphCLKConfig+0x5c5e>
    {
      LL_RCC_CLKP_Enable();
34014562:	f7fa f9af 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
34014566:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401456a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3401456e:	4618      	mov	r0, r3
34014570:	f7f9 f94b 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
34014574:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014578:	e9d3 2300 	ldrd	r2, r3, [r3]
3401457c:	2100      	movs	r1, #0
3401457e:	6439      	str	r1, [r7, #64]	@ 0x40
34014580:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34014584:	647b      	str	r3, [r7, #68]	@ 0x44
34014586:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
3401458a:	4603      	mov	r3, r0
3401458c:	460a      	mov	r2, r1
3401458e:	4313      	orrs	r3, r2
34014590:	f000 80ee 	beq.w	34014770 <HAL_RCCEx_PeriphCLKConfig+0x5e68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
34014594:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014598:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3401459c:	4b63      	ldr	r3, [pc, #396]	@ (3401472c <HAL_RCCEx_PeriphCLKConfig+0x5e24>)
3401459e:	429a      	cmp	r2, r3
340145a0:	d02e      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340145a6:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340145aa:	4b61      	ldr	r3, [pc, #388]	@ (34014730 <HAL_RCCEx_PeriphCLKConfig+0x5e28>)
340145ac:	429a      	cmp	r2, r3
340145ae:	d027      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145b0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340145b4:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340145b8:	4b5e      	ldr	r3, [pc, #376]	@ (34014734 <HAL_RCCEx_PeriphCLKConfig+0x5e2c>)
340145ba:	429a      	cmp	r2, r3
340145bc:	d020      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145be:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340145c2:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340145c6:	4b5c      	ldr	r3, [pc, #368]	@ (34014738 <HAL_RCCEx_PeriphCLKConfig+0x5e30>)
340145c8:	429a      	cmp	r2, r3
340145ca:	d019      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145cc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340145d0:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340145d4:	4b59      	ldr	r3, [pc, #356]	@ (3401473c <HAL_RCCEx_PeriphCLKConfig+0x5e34>)
340145d6:	429a      	cmp	r2, r3
340145d8:	d012      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340145de:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340145e2:	4b57      	ldr	r3, [pc, #348]	@ (34014740 <HAL_RCCEx_PeriphCLKConfig+0x5e38>)
340145e4:	429a      	cmp	r2, r3
340145e6:	d00b      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145e8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340145ec:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340145f0:	4b54      	ldr	r3, [pc, #336]	@ (34014744 <HAL_RCCEx_PeriphCLKConfig+0x5e3c>)
340145f2:	429a      	cmp	r2, r3
340145f4:	d004      	beq.n	34014600 <HAL_RCCEx_PeriphCLKConfig+0x5cf8>
340145f6:	f640 0133 	movw	r1, #2099	@ 0x833
340145fa:	4853      	ldr	r0, [pc, #332]	@ (34014748 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
340145fc:	f7ec fe4c 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
34014600:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014604:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34014608:	4b4a      	ldr	r3, [pc, #296]	@ (34014734 <HAL_RCCEx_PeriphCLKConfig+0x5e2c>)
3401460a:	429a      	cmp	r2, r3
3401460c:	d142      	bne.n	34014694 <HAL_RCCEx_PeriphCLKConfig+0x5d8c>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3401460e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014612:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014614:	2b00      	cmp	r3, #0
34014616:	d016      	beq.n	34014646 <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
34014618:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401461c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401461e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014622:	d010      	beq.n	34014646 <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
34014624:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014628:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401462a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401462e:	d00a      	beq.n	34014646 <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
34014630:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014634:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014636:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401463a:	d004      	beq.n	34014646 <HAL_RCCEx_PeriphCLKConfig+0x5d3e>
3401463c:	f640 0138 	movw	r1, #2104	@ 0x838
34014640:	4841      	ldr	r0, [pc, #260]	@ (34014748 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
34014642:	f7ec fe29 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34014646:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401464a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401464c:	2b00      	cmp	r3, #0
3401464e:	d005      	beq.n	3401465c <HAL_RCCEx_PeriphCLKConfig+0x5d54>
34014650:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014654:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014656:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401465a:	d904      	bls.n	34014666 <HAL_RCCEx_PeriphCLKConfig+0x5d5e>
3401465c:	f640 0139 	movw	r1, #2105	@ 0x839
34014660:	4839      	ldr	r0, [pc, #228]	@ (34014748 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
34014662:	f7ec fe19 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34014666:	4b39      	ldr	r3, [pc, #228]	@ (3401474c <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
34014668:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401466c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014670:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014674:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014678:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401467a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401467e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014680:	3b01      	subs	r3, #1
34014682:	041b      	lsls	r3, r3, #16
34014684:	4313      	orrs	r3, r2
34014686:	4a31      	ldr	r2, [pc, #196]	@ (3401474c <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
34014688:	430b      	orrs	r3, r1
3401468a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401468e:	f7f9 fe59 	bl	3400e344 <LL_RCC_IC9_Enable>
34014692:	e066      	b.n	34014762 <HAL_RCCEx_PeriphCLKConfig+0x5e5a>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
34014694:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014698:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3401469c:	4b26      	ldr	r3, [pc, #152]	@ (34014738 <HAL_RCCEx_PeriphCLKConfig+0x5e30>)
3401469e:	429a      	cmp	r2, r3
340146a0:	d156      	bne.n	34014750 <HAL_RCCEx_PeriphCLKConfig+0x5e48>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
340146a2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340146a6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340146a8:	2b00      	cmp	r3, #0
340146aa:	d016      	beq.n	340146da <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
340146ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340146b0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340146b2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340146b6:	d010      	beq.n	340146da <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
340146b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340146bc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340146be:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340146c2:	d00a      	beq.n	340146da <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
340146c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340146c8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340146ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340146ce:	d004      	beq.n	340146da <HAL_RCCEx_PeriphCLKConfig+0x5dd2>
340146d0:	f640 0145 	movw	r1, #2117	@ 0x845
340146d4:	481c      	ldr	r0, [pc, #112]	@ (34014748 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
340146d6:	f7ec fddf 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340146da:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340146de:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340146e0:	2b00      	cmp	r3, #0
340146e2:	d005      	beq.n	340146f0 <HAL_RCCEx_PeriphCLKConfig+0x5de8>
340146e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340146e8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340146ea:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340146ee:	d904      	bls.n	340146fa <HAL_RCCEx_PeriphCLKConfig+0x5df2>
340146f0:	f640 0146 	movw	r1, #2118	@ 0x846
340146f4:	4814      	ldr	r0, [pc, #80]	@ (34014748 <HAL_RCCEx_PeriphCLKConfig+0x5e40>)
340146f6:	f7ec fdcf 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340146fa:	4b14      	ldr	r3, [pc, #80]	@ (3401474c <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
340146fc:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34014700:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014704:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014708:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401470c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401470e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014712:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014714:	3b01      	subs	r3, #1
34014716:	041b      	lsls	r3, r3, #16
34014718:	4313      	orrs	r3, r2
3401471a:	4a0c      	ldr	r2, [pc, #48]	@ (3401474c <HAL_RCCEx_PeriphCLKConfig+0x5e44>)
3401471c:	430b      	orrs	r3, r1
3401471e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34014722:	f7f9 ff0f 	bl	3400e544 <LL_RCC_IC14_Enable>
34014726:	e01c      	b.n	34014762 <HAL_RCCEx_PeriphCLKConfig+0x5e5a>
34014728:	07011430 	.word	0x07011430
3401472c:	07001830 	.word	0x07001830
34014730:	07011830 	.word	0x07011830
34014734:	07021830 	.word	0x07021830
34014738:	07031830 	.word	0x07031830
3401473c:	07041830 	.word	0x07041830
34014740:	07051830 	.word	0x07051830
34014744:	07061830 	.word	0x07061830
34014748:	3402444c 	.word	0x3402444c
3401474c:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34014750:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014754:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34014758:	4b72      	ldr	r3, [pc, #456]	@ (34014924 <HAL_RCCEx_PeriphCLKConfig+0x601c>)
3401475a:	429a      	cmp	r2, r3
3401475c:	d101      	bne.n	34014762 <HAL_RCCEx_PeriphCLKConfig+0x5e5a>
    {
      LL_RCC_CLKP_Enable();
3401475e:	f7fa f8b1 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
34014762:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014766:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
3401476a:	4618      	mov	r0, r3
3401476c:	f7f9 f84d 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34014770:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014774:	e9d3 2300 	ldrd	r2, r3, [r3]
34014778:	2100      	movs	r1, #0
3401477a:	63b9      	str	r1, [r7, #56]	@ 0x38
3401477c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34014780:	63fb      	str	r3, [r7, #60]	@ 0x3c
34014782:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
34014786:	4603      	mov	r3, r0
34014788:	460a      	mov	r2, r1
3401478a:	4313      	orrs	r3, r2
3401478c:	f000 80ee 	beq.w	3401496c <HAL_RCCEx_PeriphCLKConfig+0x6064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
34014790:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014794:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34014798:	4b63      	ldr	r3, [pc, #396]	@ (34014928 <HAL_RCCEx_PeriphCLKConfig+0x6020>)
3401479a:	429a      	cmp	r2, r3
3401479c:	d02e      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
3401479e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340147a2:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
340147a6:	4b61      	ldr	r3, [pc, #388]	@ (3401492c <HAL_RCCEx_PeriphCLKConfig+0x6024>)
340147a8:	429a      	cmp	r2, r3
340147aa:	d027      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
340147ac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340147b0:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
340147b4:	4b5e      	ldr	r3, [pc, #376]	@ (34014930 <HAL_RCCEx_PeriphCLKConfig+0x6028>)
340147b6:	429a      	cmp	r2, r3
340147b8:	d020      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
340147ba:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340147be:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
340147c2:	4b5c      	ldr	r3, [pc, #368]	@ (34014934 <HAL_RCCEx_PeriphCLKConfig+0x602c>)
340147c4:	429a      	cmp	r2, r3
340147c6:	d019      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
340147c8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340147cc:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
340147d0:	4b59      	ldr	r3, [pc, #356]	@ (34014938 <HAL_RCCEx_PeriphCLKConfig+0x6030>)
340147d2:	429a      	cmp	r2, r3
340147d4:	d012      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
340147d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340147da:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
340147de:	4b57      	ldr	r3, [pc, #348]	@ (3401493c <HAL_RCCEx_PeriphCLKConfig+0x6034>)
340147e0:	429a      	cmp	r2, r3
340147e2:	d00b      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
340147e4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340147e8:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
340147ec:	4b54      	ldr	r3, [pc, #336]	@ (34014940 <HAL_RCCEx_PeriphCLKConfig+0x6038>)
340147ee:	429a      	cmp	r2, r3
340147f0:	d004      	beq.n	340147fc <HAL_RCCEx_PeriphCLKConfig+0x5ef4>
340147f2:	f44f 6106 	mov.w	r1, #2144	@ 0x860
340147f6:	4853      	ldr	r0, [pc, #332]	@ (34014944 <HAL_RCCEx_PeriphCLKConfig+0x603c>)
340147f8:	f7ec fd4e 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
340147fc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014800:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34014804:	4b4a      	ldr	r3, [pc, #296]	@ (34014930 <HAL_RCCEx_PeriphCLKConfig+0x6028>)
34014806:	429a      	cmp	r2, r3
34014808:	d142      	bne.n	34014890 <HAL_RCCEx_PeriphCLKConfig+0x5f88>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3401480a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401480e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014810:	2b00      	cmp	r3, #0
34014812:	d016      	beq.n	34014842 <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
34014814:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014818:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401481a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401481e:	d010      	beq.n	34014842 <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
34014820:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014824:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014826:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401482a:	d00a      	beq.n	34014842 <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
3401482c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014830:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014832:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014836:	d004      	beq.n	34014842 <HAL_RCCEx_PeriphCLKConfig+0x5f3a>
34014838:	f640 0165 	movw	r1, #2149	@ 0x865
3401483c:	4841      	ldr	r0, [pc, #260]	@ (34014944 <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3401483e:	f7ec fd2b 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34014842:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014846:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014848:	2b00      	cmp	r3, #0
3401484a:	d005      	beq.n	34014858 <HAL_RCCEx_PeriphCLKConfig+0x5f50>
3401484c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014850:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014852:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014856:	d904      	bls.n	34014862 <HAL_RCCEx_PeriphCLKConfig+0x5f5a>
34014858:	f640 0166 	movw	r1, #2150	@ 0x866
3401485c:	4839      	ldr	r0, [pc, #228]	@ (34014944 <HAL_RCCEx_PeriphCLKConfig+0x603c>)
3401485e:	f7ec fd1b 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34014862:	4b39      	ldr	r3, [pc, #228]	@ (34014948 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
34014864:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34014868:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401486c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014870:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014874:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34014876:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401487a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401487c:	3b01      	subs	r3, #1
3401487e:	041b      	lsls	r3, r3, #16
34014880:	4313      	orrs	r3, r2
34014882:	4a31      	ldr	r2, [pc, #196]	@ (34014948 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
34014884:	430b      	orrs	r3, r1
34014886:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401488a:	f7f9 fd5b 	bl	3400e344 <LL_RCC_IC9_Enable>
3401488e:	e066      	b.n	3401495e <HAL_RCCEx_PeriphCLKConfig+0x6056>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
34014890:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014894:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34014898:	4b26      	ldr	r3, [pc, #152]	@ (34014934 <HAL_RCCEx_PeriphCLKConfig+0x602c>)
3401489a:	429a      	cmp	r2, r3
3401489c:	d156      	bne.n	3401494c <HAL_RCCEx_PeriphCLKConfig+0x6044>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3401489e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340148a2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340148a4:	2b00      	cmp	r3, #0
340148a6:	d016      	beq.n	340148d6 <HAL_RCCEx_PeriphCLKConfig+0x5fce>
340148a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340148ac:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340148ae:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340148b2:	d010      	beq.n	340148d6 <HAL_RCCEx_PeriphCLKConfig+0x5fce>
340148b4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340148b8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340148ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340148be:	d00a      	beq.n	340148d6 <HAL_RCCEx_PeriphCLKConfig+0x5fce>
340148c0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340148c4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340148c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340148ca:	d004      	beq.n	340148d6 <HAL_RCCEx_PeriphCLKConfig+0x5fce>
340148cc:	f640 0172 	movw	r1, #2162	@ 0x872
340148d0:	481c      	ldr	r0, [pc, #112]	@ (34014944 <HAL_RCCEx_PeriphCLKConfig+0x603c>)
340148d2:	f7ec fce1 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
340148d6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340148da:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340148dc:	2b00      	cmp	r3, #0
340148de:	d005      	beq.n	340148ec <HAL_RCCEx_PeriphCLKConfig+0x5fe4>
340148e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340148e4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340148e6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340148ea:	d904      	bls.n	340148f6 <HAL_RCCEx_PeriphCLKConfig+0x5fee>
340148ec:	f640 0173 	movw	r1, #2163	@ 0x873
340148f0:	4814      	ldr	r0, [pc, #80]	@ (34014944 <HAL_RCCEx_PeriphCLKConfig+0x603c>)
340148f2:	f7ec fcd1 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340148f6:	4b14      	ldr	r3, [pc, #80]	@ (34014948 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
340148f8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340148fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014900:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014904:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014908:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401490a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401490e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014910:	3b01      	subs	r3, #1
34014912:	041b      	lsls	r3, r3, #16
34014914:	4313      	orrs	r3, r2
34014916:	4a0c      	ldr	r2, [pc, #48]	@ (34014948 <HAL_RCCEx_PeriphCLKConfig+0x6040>)
34014918:	430b      	orrs	r3, r1
3401491a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401491e:	f7f9 fe11 	bl	3400e544 <LL_RCC_IC14_Enable>
34014922:	e01c      	b.n	3401495e <HAL_RCCEx_PeriphCLKConfig+0x6056>
34014924:	07011830 	.word	0x07011830
34014928:	07001c30 	.word	0x07001c30
3401492c:	07011c30 	.word	0x07011c30
34014930:	07021c30 	.word	0x07021c30
34014934:	07031c30 	.word	0x07031c30
34014938:	07041c30 	.word	0x07041c30
3401493c:	07051c30 	.word	0x07051c30
34014940:	07061c30 	.word	0x07061c30
34014944:	3402444c 	.word	0x3402444c
34014948:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3401494c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014950:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34014954:	4b72      	ldr	r3, [pc, #456]	@ (34014b20 <HAL_RCCEx_PeriphCLKConfig+0x6218>)
34014956:	429a      	cmp	r2, r3
34014958:	d101      	bne.n	3401495e <HAL_RCCEx_PeriphCLKConfig+0x6056>
    {
      LL_RCC_CLKP_Enable();
3401495a:	f7f9 ffb3 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
3401495e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014962:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
34014966:	4618      	mov	r0, r3
34014968:	f7f8 ff4f 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3401496c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014970:	e9d3 2300 	ldrd	r2, r3, [r3]
34014974:	2100      	movs	r1, #0
34014976:	6339      	str	r1, [r7, #48]	@ 0x30
34014978:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3401497c:	637b      	str	r3, [r7, #52]	@ 0x34
3401497e:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34014982:	4603      	mov	r3, r0
34014984:	460a      	mov	r2, r1
34014986:	4313      	orrs	r3, r2
34014988:	f000 80ee 	beq.w	34014b68 <HAL_RCCEx_PeriphCLKConfig+0x6260>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));
3401498c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014990:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34014994:	4a63      	ldr	r2, [pc, #396]	@ (34014b24 <HAL_RCCEx_PeriphCLKConfig+0x621c>)
34014996:	4293      	cmp	r3, r2
34014998:	d02e      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
3401499a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401499e:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340149a2:	4a61      	ldr	r2, [pc, #388]	@ (34014b28 <HAL_RCCEx_PeriphCLKConfig+0x6220>)
340149a4:	4293      	cmp	r3, r2
340149a6:	d027      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
340149a8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340149ac:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340149b0:	4a5e      	ldr	r2, [pc, #376]	@ (34014b2c <HAL_RCCEx_PeriphCLKConfig+0x6224>)
340149b2:	4293      	cmp	r3, r2
340149b4:	d020      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
340149b6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340149ba:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340149be:	4a5c      	ldr	r2, [pc, #368]	@ (34014b30 <HAL_RCCEx_PeriphCLKConfig+0x6228>)
340149c0:	4293      	cmp	r3, r2
340149c2:	d019      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
340149c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340149c8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340149cc:	4a59      	ldr	r2, [pc, #356]	@ (34014b34 <HAL_RCCEx_PeriphCLKConfig+0x622c>)
340149ce:	4293      	cmp	r3, r2
340149d0:	d012      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
340149d2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340149d6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340149da:	4a57      	ldr	r2, [pc, #348]	@ (34014b38 <HAL_RCCEx_PeriphCLKConfig+0x6230>)
340149dc:	4293      	cmp	r3, r2
340149de:	d00b      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
340149e0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340149e4:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340149e8:	4a54      	ldr	r2, [pc, #336]	@ (34014b3c <HAL_RCCEx_PeriphCLKConfig+0x6234>)
340149ea:	4293      	cmp	r3, r2
340149ec:	d004      	beq.n	340149f8 <HAL_RCCEx_PeriphCLKConfig+0x60f0>
340149ee:	f640 018d 	movw	r1, #2189	@ 0x88d
340149f2:	4853      	ldr	r0, [pc, #332]	@ (34014b40 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
340149f4:	f7ec fc50 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
340149f8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340149fc:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34014a00:	4a4a      	ldr	r2, [pc, #296]	@ (34014b2c <HAL_RCCEx_PeriphCLKConfig+0x6224>)
34014a02:	4293      	cmp	r3, r2
34014a04:	d142      	bne.n	34014a8c <HAL_RCCEx_PeriphCLKConfig+0x6184>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34014a06:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a0a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014a0c:	2b00      	cmp	r3, #0
34014a0e:	d016      	beq.n	34014a3e <HAL_RCCEx_PeriphCLKConfig+0x6136>
34014a10:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a14:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014a16:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014a1a:	d010      	beq.n	34014a3e <HAL_RCCEx_PeriphCLKConfig+0x6136>
34014a1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a20:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014a22:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014a26:	d00a      	beq.n	34014a3e <HAL_RCCEx_PeriphCLKConfig+0x6136>
34014a28:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a2c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014a2e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014a32:	d004      	beq.n	34014a3e <HAL_RCCEx_PeriphCLKConfig+0x6136>
34014a34:	f640 0192 	movw	r1, #2194	@ 0x892
34014a38:	4841      	ldr	r0, [pc, #260]	@ (34014b40 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
34014a3a:	f7ec fc2d 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34014a3e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a42:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014a44:	2b00      	cmp	r3, #0
34014a46:	d005      	beq.n	34014a54 <HAL_RCCEx_PeriphCLKConfig+0x614c>
34014a48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a4c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014a4e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014a52:	d904      	bls.n	34014a5e <HAL_RCCEx_PeriphCLKConfig+0x6156>
34014a54:	f640 0193 	movw	r1, #2195	@ 0x893
34014a58:	4839      	ldr	r0, [pc, #228]	@ (34014b40 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
34014a5a:	f7ec fc1d 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34014a5e:	4b39      	ldr	r3, [pc, #228]	@ (34014b44 <HAL_RCCEx_PeriphCLKConfig+0x623c>)
34014a60:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34014a64:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014a68:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014a6c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a70:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34014a72:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a76:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014a78:	3b01      	subs	r3, #1
34014a7a:	041b      	lsls	r3, r3, #16
34014a7c:	4313      	orrs	r3, r2
34014a7e:	4a31      	ldr	r2, [pc, #196]	@ (34014b44 <HAL_RCCEx_PeriphCLKConfig+0x623c>)
34014a80:	430b      	orrs	r3, r1
34014a82:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34014a86:	f7f9 fc5d 	bl	3400e344 <LL_RCC_IC9_Enable>
34014a8a:	e066      	b.n	34014b5a <HAL_RCCEx_PeriphCLKConfig+0x6252>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34014a8c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a90:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34014a94:	4a26      	ldr	r2, [pc, #152]	@ (34014b30 <HAL_RCCEx_PeriphCLKConfig+0x6228>)
34014a96:	4293      	cmp	r3, r2
34014a98:	d156      	bne.n	34014b48 <HAL_RCCEx_PeriphCLKConfig+0x6240>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
34014a9a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014a9e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014aa0:	2b00      	cmp	r3, #0
34014aa2:	d016      	beq.n	34014ad2 <HAL_RCCEx_PeriphCLKConfig+0x61ca>
34014aa4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014aa8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014aaa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014aae:	d010      	beq.n	34014ad2 <HAL_RCCEx_PeriphCLKConfig+0x61ca>
34014ab0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ab4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014ab6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014aba:	d00a      	beq.n	34014ad2 <HAL_RCCEx_PeriphCLKConfig+0x61ca>
34014abc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ac0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014ac2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014ac6:	d004      	beq.n	34014ad2 <HAL_RCCEx_PeriphCLKConfig+0x61ca>
34014ac8:	f640 019f 	movw	r1, #2207	@ 0x89f
34014acc:	481c      	ldr	r0, [pc, #112]	@ (34014b40 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
34014ace:	f7ec fbe3 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34014ad2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ad6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014ad8:	2b00      	cmp	r3, #0
34014ada:	d005      	beq.n	34014ae8 <HAL_RCCEx_PeriphCLKConfig+0x61e0>
34014adc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ae0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014ae2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014ae6:	d904      	bls.n	34014af2 <HAL_RCCEx_PeriphCLKConfig+0x61ea>
34014ae8:	f44f 610a 	mov.w	r1, #2208	@ 0x8a0
34014aec:	4814      	ldr	r0, [pc, #80]	@ (34014b40 <HAL_RCCEx_PeriphCLKConfig+0x6238>)
34014aee:	f7ec fbd3 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34014af2:	4b14      	ldr	r3, [pc, #80]	@ (34014b44 <HAL_RCCEx_PeriphCLKConfig+0x623c>)
34014af4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34014af8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34014afc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34014b00:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b04:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34014b06:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b0a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014b0c:	3b01      	subs	r3, #1
34014b0e:	041b      	lsls	r3, r3, #16
34014b10:	4313      	orrs	r3, r2
34014b12:	4a0c      	ldr	r2, [pc, #48]	@ (34014b44 <HAL_RCCEx_PeriphCLKConfig+0x623c>)
34014b14:	430b      	orrs	r3, r1
34014b16:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34014b1a:	f7f9 fd13 	bl	3400e544 <LL_RCC_IC14_Enable>
34014b1e:	e01c      	b.n	34014b5a <HAL_RCCEx_PeriphCLKConfig+0x6252>
34014b20:	07011c30 	.word	0x07011c30
34014b24:	07000034 	.word	0x07000034
34014b28:	07010034 	.word	0x07010034
34014b2c:	07020034 	.word	0x07020034
34014b30:	07030034 	.word	0x07030034
34014b34:	07040034 	.word	0x07040034
34014b38:	07050034 	.word	0x07050034
34014b3c:	07060034 	.word	0x07060034
34014b40:	3402444c 	.word	0x3402444c
34014b44:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34014b48:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b4c:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34014b50:	4ab7      	ldr	r2, [pc, #732]	@ (34014e30 <HAL_RCCEx_PeriphCLKConfig+0x6528>)
34014b52:	4293      	cmp	r3, r2
34014b54:	d101      	bne.n	34014b5a <HAL_RCCEx_PeriphCLKConfig+0x6252>
    {
      LL_RCC_CLKP_Enable();
34014b56:	f7f9 feb5 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
34014b5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b5e:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34014b62:	4618      	mov	r0, r3
34014b64:	f7f8 fe51 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
34014b68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b6c:	e9d3 2300 	ldrd	r2, r3, [r3]
34014b70:	2100      	movs	r1, #0
34014b72:	62b9      	str	r1, [r7, #40]	@ 0x28
34014b74:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34014b78:	62fb      	str	r3, [r7, #44]	@ 0x2c
34014b7a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
34014b7e:	4603      	mov	r3, r0
34014b80:	460a      	mov	r2, r1
34014b82:	4313      	orrs	r3, r2
34014b84:	f000 80da 	beq.w	34014d3c <HAL_RCCEx_PeriphCLKConfig+0x6434>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));
34014b88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b8c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014b90:	4aa8      	ldr	r2, [pc, #672]	@ (34014e34 <HAL_RCCEx_PeriphCLKConfig+0x652c>)
34014b92:	4293      	cmp	r3, r2
34014b94:	d02e      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014b96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014b9a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014b9e:	4aa6      	ldr	r2, [pc, #664]	@ (34014e38 <HAL_RCCEx_PeriphCLKConfig+0x6530>)
34014ba0:	4293      	cmp	r3, r2
34014ba2:	d027      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014ba4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ba8:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014bac:	4aa3      	ldr	r2, [pc, #652]	@ (34014e3c <HAL_RCCEx_PeriphCLKConfig+0x6534>)
34014bae:	4293      	cmp	r3, r2
34014bb0:	d020      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014bb2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014bb6:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014bba:	4aa1      	ldr	r2, [pc, #644]	@ (34014e40 <HAL_RCCEx_PeriphCLKConfig+0x6538>)
34014bbc:	4293      	cmp	r3, r2
34014bbe:	d019      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014bc0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014bc4:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014bc8:	4a9e      	ldr	r2, [pc, #632]	@ (34014e44 <HAL_RCCEx_PeriphCLKConfig+0x653c>)
34014bca:	4293      	cmp	r3, r2
34014bcc:	d012      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014bce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014bd2:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014bd6:	4a9c      	ldr	r2, [pc, #624]	@ (34014e48 <HAL_RCCEx_PeriphCLKConfig+0x6540>)
34014bd8:	4293      	cmp	r3, r2
34014bda:	d00b      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014bdc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014be0:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014be4:	4a99      	ldr	r2, [pc, #612]	@ (34014e4c <HAL_RCCEx_PeriphCLKConfig+0x6544>)
34014be6:	4293      	cmp	r3, r2
34014be8:	d004      	beq.n	34014bf4 <HAL_RCCEx_PeriphCLKConfig+0x62ec>
34014bea:	f640 01ba 	movw	r1, #2234	@ 0x8ba
34014bee:	4898      	ldr	r0, [pc, #608]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014bf0:	f7ec fb52 	bl	34001298 <assert_failed>

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
34014bf4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014bf8:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014bfc:	4a8f      	ldr	r2, [pc, #572]	@ (34014e3c <HAL_RCCEx_PeriphCLKConfig+0x6534>)
34014bfe:	4293      	cmp	r3, r2
34014c00:	d142      	bne.n	34014c88 <HAL_RCCEx_PeriphCLKConfig+0x6380>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
34014c02:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c06:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014c08:	2b00      	cmp	r3, #0
34014c0a:	d016      	beq.n	34014c3a <HAL_RCCEx_PeriphCLKConfig+0x6332>
34014c0c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c10:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014c12:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014c16:	d010      	beq.n	34014c3a <HAL_RCCEx_PeriphCLKConfig+0x6332>
34014c18:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c1c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014c1e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014c22:	d00a      	beq.n	34014c3a <HAL_RCCEx_PeriphCLKConfig+0x6332>
34014c24:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c28:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34014c2a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014c2e:	d004      	beq.n	34014c3a <HAL_RCCEx_PeriphCLKConfig+0x6332>
34014c30:	f640 01bf 	movw	r1, #2239	@ 0x8bf
34014c34:	4886      	ldr	r0, [pc, #536]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014c36:	f7ec fb2f 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
34014c3a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c3e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014c40:	2b00      	cmp	r3, #0
34014c42:	d005      	beq.n	34014c50 <HAL_RCCEx_PeriphCLKConfig+0x6348>
34014c44:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c48:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34014c4a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014c4e:	d904      	bls.n	34014c5a <HAL_RCCEx_PeriphCLKConfig+0x6352>
34014c50:	f44f 610c 	mov.w	r1, #2240	@ 0x8c0
34014c54:	487e      	ldr	r0, [pc, #504]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014c56:	f7ec fb1f 	bl	34001298 <assert_failed>

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34014c5a:	4b7e      	ldr	r3, [pc, #504]	@ (34014e54 <HAL_RCCEx_PeriphCLKConfig+0x654c>)
34014c5c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34014c60:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34014c64:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34014c68:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34014c6c:	6c91      	ldr	r1, [r2, #72]	@ 0x48
34014c6e:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34014c72:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
34014c74:	3a01      	subs	r2, #1
34014c76:	0412      	lsls	r2, r2, #16
34014c78:	430a      	orrs	r2, r1
34014c7a:	4976      	ldr	r1, [pc, #472]	@ (34014e54 <HAL_RCCEx_PeriphCLKConfig+0x654c>)
34014c7c:	4313      	orrs	r3, r2
34014c7e:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34014c82:	f7f9 fb5f 	bl	3400e344 <LL_RCC_IC9_Enable>
34014c86:	e052      	b.n	34014d2e <HAL_RCCEx_PeriphCLKConfig+0x6426>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
34014c88:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c8c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014c90:	4a6b      	ldr	r2, [pc, #428]	@ (34014e40 <HAL_RCCEx_PeriphCLKConfig+0x6538>)
34014c92:	4293      	cmp	r3, r2
34014c94:	d142      	bne.n	34014d1c <HAL_RCCEx_PeriphCLKConfig+0x6414>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
34014c96:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014c9a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014c9c:	2b00      	cmp	r3, #0
34014c9e:	d016      	beq.n	34014cce <HAL_RCCEx_PeriphCLKConfig+0x63c6>
34014ca0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ca4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014ca6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014caa:	d010      	beq.n	34014cce <HAL_RCCEx_PeriphCLKConfig+0x63c6>
34014cac:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014cb0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014cb2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014cb6:	d00a      	beq.n	34014cce <HAL_RCCEx_PeriphCLKConfig+0x63c6>
34014cb8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014cbc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34014cbe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014cc2:	d004      	beq.n	34014cce <HAL_RCCEx_PeriphCLKConfig+0x63c6>
34014cc4:	f640 01cc 	movw	r1, #2252	@ 0x8cc
34014cc8:	4861      	ldr	r0, [pc, #388]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014cca:	f7ec fae5 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
34014cce:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014cd2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014cd4:	2b00      	cmp	r3, #0
34014cd6:	d005      	beq.n	34014ce4 <HAL_RCCEx_PeriphCLKConfig+0x63dc>
34014cd8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014cdc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34014cde:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014ce2:	d904      	bls.n	34014cee <HAL_RCCEx_PeriphCLKConfig+0x63e6>
34014ce4:	f640 01cd 	movw	r1, #2253	@ 0x8cd
34014ce8:	4859      	ldr	r0, [pc, #356]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014cea:	f7ec fad5 	bl	34001298 <assert_failed>

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34014cee:	4b59      	ldr	r3, [pc, #356]	@ (34014e54 <HAL_RCCEx_PeriphCLKConfig+0x654c>)
34014cf0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34014cf4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34014cf8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34014cfc:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34014d00:	6f11      	ldr	r1, [r2, #112]	@ 0x70
34014d02:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34014d06:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34014d08:	3a01      	subs	r2, #1
34014d0a:	0412      	lsls	r2, r2, #16
34014d0c:	430a      	orrs	r2, r1
34014d0e:	4951      	ldr	r1, [pc, #324]	@ (34014e54 <HAL_RCCEx_PeriphCLKConfig+0x654c>)
34014d10:	4313      	orrs	r3, r2
34014d12:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34014d16:	f7f9 fc15 	bl	3400e544 <LL_RCC_IC14_Enable>
34014d1a:	e008      	b.n	34014d2e <HAL_RCCEx_PeriphCLKConfig+0x6426>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
34014d1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d20:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014d24:	4a44      	ldr	r2, [pc, #272]	@ (34014e38 <HAL_RCCEx_PeriphCLKConfig+0x6530>)
34014d26:	4293      	cmp	r3, r2
34014d28:	d101      	bne.n	34014d2e <HAL_RCCEx_PeriphCLKConfig+0x6426>
    {
      LL_RCC_CLKP_Enable();
34014d2a:	f7f9 fdcb 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
34014d2e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d32:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34014d36:	4618      	mov	r0, r3
34014d38:	f7f8 fd67 	bl	3400d80a <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
34014d3c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d40:	e9d3 2300 	ldrd	r2, r3, [r3]
34014d44:	2100      	movs	r1, #0
34014d46:	6239      	str	r1, [r7, #32]
34014d48:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34014d4c:	627b      	str	r3, [r7, #36]	@ 0x24
34014d4e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34014d52:	4603      	mov	r3, r0
34014d54:	460a      	mov	r2, r1
34014d56:	4313      	orrs	r3, r2
34014d58:	d02e      	beq.n	34014db8 <HAL_RCCEx_PeriphCLKConfig+0x64b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));
34014d5a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d5e:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34014d62:	4a3d      	ldr	r2, [pc, #244]	@ (34014e58 <HAL_RCCEx_PeriphCLKConfig+0x6550>)
34014d64:	4293      	cmp	r3, r2
34014d66:	d012      	beq.n	34014d8e <HAL_RCCEx_PeriphCLKConfig+0x6486>
34014d68:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d6c:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34014d70:	4a3a      	ldr	r2, [pc, #232]	@ (34014e5c <HAL_RCCEx_PeriphCLKConfig+0x6554>)
34014d72:	4293      	cmp	r3, r2
34014d74:	d00b      	beq.n	34014d8e <HAL_RCCEx_PeriphCLKConfig+0x6486>
34014d76:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d7a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34014d7e:	4a38      	ldr	r2, [pc, #224]	@ (34014e60 <HAL_RCCEx_PeriphCLKConfig+0x6558>)
34014d80:	4293      	cmp	r3, r2
34014d82:	d004      	beq.n	34014d8e <HAL_RCCEx_PeriphCLKConfig+0x6486>
34014d84:	f640 01e7 	movw	r1, #2279	@ 0x8e7
34014d88:	4831      	ldr	r0, [pc, #196]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014d8a:	f7ec fa85 	bl	34001298 <assert_failed>

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34014d8e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014d92:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34014d96:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34014d9a:	4618      	mov	r0, r3
34014d9c:	f7f8 fcdd 	bl	3400d75a <LL_RCC_SetOTGPHYCKREFClockSource>
34014da0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014da4:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34014da8:	0fdb      	lsrs	r3, r3, #31
34014daa:	2b01      	cmp	r3, #1
34014dac:	d102      	bne.n	34014db4 <HAL_RCCEx_PeriphCLKConfig+0x64ac>
34014dae:	f7f8 fa7f 	bl	3400d2b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34014db2:	e001      	b.n	34014db8 <HAL_RCCEx_PeriphCLKConfig+0x64b0>
34014db4:	f7f8 fa6c 	bl	3400d290 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
34014db8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014dbc:	e9d3 2300 	ldrd	r2, r3, [r3]
34014dc0:	2100      	movs	r1, #0
34014dc2:	61b9      	str	r1, [r7, #24]
34014dc4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34014dc8:	61fb      	str	r3, [r7, #28]
34014dca:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34014dce:	4603      	mov	r3, r0
34014dd0:	460a      	mov	r2, r1
34014dd2:	4313      	orrs	r3, r2
34014dd4:	d04e      	beq.n	34014e74 <HAL_RCCEx_PeriphCLKConfig+0x656c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));
34014dd6:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014dda:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34014dde:	4a21      	ldr	r2, [pc, #132]	@ (34014e64 <HAL_RCCEx_PeriphCLKConfig+0x655c>)
34014de0:	4293      	cmp	r3, r2
34014de2:	d012      	beq.n	34014e0a <HAL_RCCEx_PeriphCLKConfig+0x6502>
34014de4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014de8:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34014dec:	4a1e      	ldr	r2, [pc, #120]	@ (34014e68 <HAL_RCCEx_PeriphCLKConfig+0x6560>)
34014dee:	4293      	cmp	r3, r2
34014df0:	d00b      	beq.n	34014e0a <HAL_RCCEx_PeriphCLKConfig+0x6502>
34014df2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014df6:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34014dfa:	4a1c      	ldr	r2, [pc, #112]	@ (34014e6c <HAL_RCCEx_PeriphCLKConfig+0x6564>)
34014dfc:	4293      	cmp	r3, r2
34014dfe:	d004      	beq.n	34014e0a <HAL_RCCEx_PeriphCLKConfig+0x6502>
34014e00:	f640 01f1 	movw	r1, #2289	@ 0x8f1
34014e04:	4812      	ldr	r0, [pc, #72]	@ (34014e50 <HAL_RCCEx_PeriphCLKConfig+0x6548>)
34014e06:	f7ec fa47 	bl	34001298 <assert_failed>

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34014e0a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014e0e:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34014e12:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34014e16:	4618      	mov	r0, r3
34014e18:	f7f8 fc9f 	bl	3400d75a <LL_RCC_SetOTGPHYCKREFClockSource>
34014e1c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014e20:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34014e24:	0fdb      	lsrs	r3, r3, #31
34014e26:	2b01      	cmp	r3, #1
34014e28:	d122      	bne.n	34014e70 <HAL_RCCEx_PeriphCLKConfig+0x6568>
34014e2a:	f7f8 fa41 	bl	3400d2b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34014e2e:	e021      	b.n	34014e74 <HAL_RCCEx_PeriphCLKConfig+0x656c>
34014e30:	07010034 	.word	0x07010034
34014e34:	07000434 	.word	0x07000434
34014e38:	07010434 	.word	0x07010434
34014e3c:	07020434 	.word	0x07020434
34014e40:	07030434 	.word	0x07030434
34014e44:	07040434 	.word	0x07040434
34014e48:	07050434 	.word	0x07050434
34014e4c:	07060434 	.word	0x07060434
34014e50:	3402444c 	.word	0x3402444c
34014e54:	56028000 	.word	0x56028000
34014e58:	01001014 	.word	0x01001014
34014e5c:	01011014 	.word	0x01011014
34014e60:	81011014 	.word	0x81011014
34014e64:	01001814 	.word	0x01001814
34014e68:	01011814 	.word	0x01011814
34014e6c:	81011814 	.word	0x81011814
34014e70:	f7f8 fa0e 	bl	3400d290 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
34014e74:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014e78:	e9d3 2300 	ldrd	r2, r3, [r3]
34014e7c:	2100      	movs	r1, #0
34014e7e:	6139      	str	r1, [r7, #16]
34014e80:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34014e84:	617b      	str	r3, [r7, #20]
34014e86:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34014e8a:	4603      	mov	r3, r0
34014e8c:	460a      	mov	r2, r1
34014e8e:	4313      	orrs	r3, r2
34014e90:	f000 8090 	beq.w	34014fb4 <HAL_RCCEx_PeriphCLKConfig+0x66ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));
34014e94:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014e98:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014e9c:	4ab5      	ldr	r2, [pc, #724]	@ (34015174 <HAL_RCCEx_PeriphCLKConfig+0x686c>)
34014e9e:	4293      	cmp	r3, r2
34014ea0:	d020      	beq.n	34014ee4 <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34014ea2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ea6:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014eaa:	4ab3      	ldr	r2, [pc, #716]	@ (34015178 <HAL_RCCEx_PeriphCLKConfig+0x6870>)
34014eac:	4293      	cmp	r3, r2
34014eae:	d019      	beq.n	34014ee4 <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34014eb0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014eb4:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014eb8:	4ab0      	ldr	r2, [pc, #704]	@ (3401517c <HAL_RCCEx_PeriphCLKConfig+0x6874>)
34014eba:	4293      	cmp	r3, r2
34014ebc:	d012      	beq.n	34014ee4 <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34014ebe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ec2:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014ec6:	4aae      	ldr	r2, [pc, #696]	@ (34015180 <HAL_RCCEx_PeriphCLKConfig+0x6878>)
34014ec8:	4293      	cmp	r3, r2
34014eca:	d00b      	beq.n	34014ee4 <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34014ecc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ed0:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014ed4:	4aab      	ldr	r2, [pc, #684]	@ (34015184 <HAL_RCCEx_PeriphCLKConfig+0x687c>)
34014ed6:	4293      	cmp	r3, r2
34014ed8:	d004      	beq.n	34014ee4 <HAL_RCCEx_PeriphCLKConfig+0x65dc>
34014eda:	f640 01fb 	movw	r1, #2299	@ 0x8fb
34014ede:	48aa      	ldr	r0, [pc, #680]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34014ee0:	f7ec f9da 	bl	34001298 <assert_failed>

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
34014ee4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ee8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014eec:	4aa3      	ldr	r2, [pc, #652]	@ (3401517c <HAL_RCCEx_PeriphCLKConfig+0x6874>)
34014eee:	4293      	cmp	r3, r2
34014ef0:	d142      	bne.n	34014f78 <HAL_RCCEx_PeriphCLKConfig+0x6670>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34014ef2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ef6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34014ef8:	2b00      	cmp	r3, #0
34014efa:	d016      	beq.n	34014f2a <HAL_RCCEx_PeriphCLKConfig+0x6622>
34014efc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f00:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34014f02:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014f06:	d010      	beq.n	34014f2a <HAL_RCCEx_PeriphCLKConfig+0x6622>
34014f08:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f0c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34014f0e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014f12:	d00a      	beq.n	34014f2a <HAL_RCCEx_PeriphCLKConfig+0x6622>
34014f14:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f18:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34014f1a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014f1e:	d004      	beq.n	34014f2a <HAL_RCCEx_PeriphCLKConfig+0x6622>
34014f20:	f44f 6110 	mov.w	r1, #2304	@ 0x900
34014f24:	4898      	ldr	r0, [pc, #608]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34014f26:	f7ec f9b7 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
34014f2a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f2e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34014f30:	2b00      	cmp	r3, #0
34014f32:	d005      	beq.n	34014f40 <HAL_RCCEx_PeriphCLKConfig+0x6638>
34014f34:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f38:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34014f3a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34014f3e:	d904      	bls.n	34014f4a <HAL_RCCEx_PeriphCLKConfig+0x6642>
34014f40:	f640 1101 	movw	r1, #2305	@ 0x901
34014f44:	4890      	ldr	r0, [pc, #576]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34014f46:	f7ec f9a7 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34014f4a:	4b90      	ldr	r3, [pc, #576]	@ (3401518c <HAL_RCCEx_PeriphCLKConfig+0x6884>)
34014f4c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34014f50:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34014f54:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34014f58:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34014f5c:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34014f5e:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
34014f62:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34014f64:	3a01      	subs	r2, #1
34014f66:	0412      	lsls	r2, r2, #16
34014f68:	430a      	orrs	r2, r1
34014f6a:	4988      	ldr	r1, [pc, #544]	@ (3401518c <HAL_RCCEx_PeriphCLKConfig+0x6884>)
34014f6c:	4313      	orrs	r3, r2
34014f6e:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34014f72:	f7f9 fb27 	bl	3400e5c4 <LL_RCC_IC15_Enable>
34014f76:	e008      	b.n	34014f8a <HAL_RCCEx_PeriphCLKConfig+0x6682>
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
34014f78:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f7c:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014f80:	4a7d      	ldr	r2, [pc, #500]	@ (34015178 <HAL_RCCEx_PeriphCLKConfig+0x6870>)
34014f82:	4293      	cmp	r3, r2
34014f84:	d101      	bne.n	34014f8a <HAL_RCCEx_PeriphCLKConfig+0x6682>
    {
      LL_RCC_CLKP_Enable();
34014f86:	f7f9 fc9d 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
34014f8a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014f8e:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014f92:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34014f96:	4618      	mov	r0, r3
34014f98:	f7f8 fbd4 	bl	3400d744 <LL_RCC_SetOTGPHYClockSource>
34014f9c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014fa0:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34014fa4:	0fdb      	lsrs	r3, r3, #31
34014fa6:	2b01      	cmp	r3, #1
34014fa8:	d102      	bne.n	34014fb0 <HAL_RCCEx_PeriphCLKConfig+0x66a8>
34014faa:	f7f8 f981 	bl	3400d2b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34014fae:	e001      	b.n	34014fb4 <HAL_RCCEx_PeriphCLKConfig+0x66ac>
34014fb0:	f7f8 f96e 	bl	3400d290 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
34014fb4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014fb8:	e9d3 2300 	ldrd	r2, r3, [r3]
34014fbc:	2100      	movs	r1, #0
34014fbe:	60b9      	str	r1, [r7, #8]
34014fc0:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34014fc4:	60fb      	str	r3, [r7, #12]
34014fc6:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34014fca:	4603      	mov	r3, r0
34014fcc:	460a      	mov	r2, r1
34014fce:	4313      	orrs	r3, r2
34014fd0:	f000 8090 	beq.w	340150f4 <HAL_RCCEx_PeriphCLKConfig+0x67ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));
34014fd4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014fd8:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34014fdc:	4a6c      	ldr	r2, [pc, #432]	@ (34015190 <HAL_RCCEx_PeriphCLKConfig+0x6888>)
34014fde:	4293      	cmp	r3, r2
34014fe0:	d020      	beq.n	34015024 <HAL_RCCEx_PeriphCLKConfig+0x671c>
34014fe2:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014fe6:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34014fea:	4a6a      	ldr	r2, [pc, #424]	@ (34015194 <HAL_RCCEx_PeriphCLKConfig+0x688c>)
34014fec:	4293      	cmp	r3, r2
34014fee:	d019      	beq.n	34015024 <HAL_RCCEx_PeriphCLKConfig+0x671c>
34014ff0:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34014ff4:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34014ff8:	4a67      	ldr	r2, [pc, #412]	@ (34015198 <HAL_RCCEx_PeriphCLKConfig+0x6890>)
34014ffa:	4293      	cmp	r3, r2
34014ffc:	d012      	beq.n	34015024 <HAL_RCCEx_PeriphCLKConfig+0x671c>
34014ffe:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015002:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34015006:	4a65      	ldr	r2, [pc, #404]	@ (3401519c <HAL_RCCEx_PeriphCLKConfig+0x6894>)
34015008:	4293      	cmp	r3, r2
3401500a:	d00b      	beq.n	34015024 <HAL_RCCEx_PeriphCLKConfig+0x671c>
3401500c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015010:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34015014:	4a62      	ldr	r2, [pc, #392]	@ (340151a0 <HAL_RCCEx_PeriphCLKConfig+0x6898>)
34015016:	4293      	cmp	r3, r2
34015018:	d004      	beq.n	34015024 <HAL_RCCEx_PeriphCLKConfig+0x671c>
3401501a:	f640 111b 	movw	r1, #2331	@ 0x91b
3401501e:	485a      	ldr	r0, [pc, #360]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34015020:	f7ec f93a 	bl	34001298 <assert_failed>

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
34015024:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015028:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3401502c:	4a5a      	ldr	r2, [pc, #360]	@ (34015198 <HAL_RCCEx_PeriphCLKConfig+0x6890>)
3401502e:	4293      	cmp	r3, r2
34015030:	d142      	bne.n	340150b8 <HAL_RCCEx_PeriphCLKConfig+0x67b0>
    {
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
34015032:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015036:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34015038:	2b00      	cmp	r3, #0
3401503a:	d016      	beq.n	3401506a <HAL_RCCEx_PeriphCLKConfig+0x6762>
3401503c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015040:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34015042:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015046:	d010      	beq.n	3401506a <HAL_RCCEx_PeriphCLKConfig+0x6762>
34015048:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401504c:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401504e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015052:	d00a      	beq.n	3401506a <HAL_RCCEx_PeriphCLKConfig+0x6762>
34015054:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015058:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3401505a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401505e:	d004      	beq.n	3401506a <HAL_RCCEx_PeriphCLKConfig+0x6762>
34015060:	f44f 6112 	mov.w	r1, #2336	@ 0x920
34015064:	4848      	ldr	r0, [pc, #288]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34015066:	f7ec f917 	bl	34001298 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3401506a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401506e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34015070:	2b00      	cmp	r3, #0
34015072:	d005      	beq.n	34015080 <HAL_RCCEx_PeriphCLKConfig+0x6778>
34015074:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015078:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401507a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401507e:	d904      	bls.n	3401508a <HAL_RCCEx_PeriphCLKConfig+0x6782>
34015080:	f640 1121 	movw	r1, #2337	@ 0x921
34015084:	4840      	ldr	r0, [pc, #256]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34015086:	f7ec f907 	bl	34001298 <assert_failed>

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3401508a:	4b40      	ldr	r3, [pc, #256]	@ (3401518c <HAL_RCCEx_PeriphCLKConfig+0x6884>)
3401508c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34015090:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34015094:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34015098:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
3401509c:	6f91      	ldr	r1, [r2, #120]	@ 0x78
3401509e:	f8d7 237c 	ldr.w	r2, [r7, #892]	@ 0x37c
340150a2:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
340150a4:	3a01      	subs	r2, #1
340150a6:	0412      	lsls	r2, r2, #16
340150a8:	430a      	orrs	r2, r1
340150aa:	4938      	ldr	r1, [pc, #224]	@ (3401518c <HAL_RCCEx_PeriphCLKConfig+0x6884>)
340150ac:	4313      	orrs	r3, r2
340150ae:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340150b2:	f7f9 fa87 	bl	3400e5c4 <LL_RCC_IC15_Enable>
340150b6:	e008      	b.n	340150ca <HAL_RCCEx_PeriphCLKConfig+0x67c2>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
340150b8:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340150bc:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
340150c0:	4a34      	ldr	r2, [pc, #208]	@ (34015194 <HAL_RCCEx_PeriphCLKConfig+0x688c>)
340150c2:	4293      	cmp	r3, r2
340150c4:	d101      	bne.n	340150ca <HAL_RCCEx_PeriphCLKConfig+0x67c2>
    {
      LL_RCC_CLKP_Enable();
340150c6:	f7f9 fbfd 	bl	3400e8c4 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
340150ca:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340150ce:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
340150d2:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
340150d6:	4618      	mov	r0, r3
340150d8:	f7f8 fb34 	bl	3400d744 <LL_RCC_SetOTGPHYClockSource>
340150dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340150e0:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
340150e4:	0fdb      	lsrs	r3, r3, #31
340150e6:	2b01      	cmp	r3, #1
340150e8:	d102      	bne.n	340150f0 <HAL_RCCEx_PeriphCLKConfig+0x67e8>
340150ea:	f7f8 f8e1 	bl	3400d2b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
340150ee:	e001      	b.n	340150f4 <HAL_RCCEx_PeriphCLKConfig+0x67ec>
340150f0:	f7f8 f8ce 	bl	3400d290 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
340150f4:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
340150f8:	e9d3 2300 	ldrd	r2, r3, [r3]
340150fc:	2100      	movs	r1, #0
340150fe:	6039      	str	r1, [r7, #0]
34015100:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34015104:	607b      	str	r3, [r7, #4]
34015106:	e9d7 0100 	ldrd	r0, r1, [r7]
3401510a:	4603      	mov	r3, r0
3401510c:	460a      	mov	r2, r1
3401510e:	4313      	orrs	r3, r2
34015110:	d023      	beq.n	3401515a <HAL_RCCEx_PeriphCLKConfig+0x6852>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
34015112:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015116:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
3401511a:	2b00      	cmp	r3, #0
3401511c:	d016      	beq.n	3401514c <HAL_RCCEx_PeriphCLKConfig+0x6844>
3401511e:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015122:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34015126:	2b01      	cmp	r3, #1
34015128:	d010      	beq.n	3401514c <HAL_RCCEx_PeriphCLKConfig+0x6844>
3401512a:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401512e:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34015132:	2b02      	cmp	r3, #2
34015134:	d00a      	beq.n	3401514c <HAL_RCCEx_PeriphCLKConfig+0x6844>
34015136:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
3401513a:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
3401513e:	2b03      	cmp	r3, #3
34015140:	d004      	beq.n	3401514c <HAL_RCCEx_PeriphCLKConfig+0x6844>
34015142:	f640 113b 	movw	r1, #2363	@ 0x93b
34015146:	4810      	ldr	r0, [pc, #64]	@ (34015188 <HAL_RCCEx_PeriphCLKConfig+0x6880>)
34015148:	f7ec f8a6 	bl	34001298 <assert_failed>

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
3401514c:	f8d7 337c 	ldr.w	r3, [r7, #892]	@ 0x37c
34015150:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34015154:	4618      	mov	r0, r3
34015156:	f7f8 fd31 	bl	3400dbbc <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
3401515a:	f897 338e 	ldrb.w	r3, [r7, #910]	@ 0x38e
3401515e:	2b00      	cmp	r3, #0
34015160:	d101      	bne.n	34015166 <HAL_RCCEx_PeriphCLKConfig+0x685e>
  {
    return HAL_OK;
34015162:	2300      	movs	r3, #0
34015164:	e000      	b.n	34015168 <HAL_RCCEx_PeriphCLKConfig+0x6860>
  }
  return HAL_ERROR;
34015166:	2301      	movs	r3, #1
}
34015168:	4618      	mov	r0, r3
3401516a:	f507 7764 	add.w	r7, r7, #912	@ 0x390
3401516e:	46bd      	mov	sp, r7
34015170:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34015174:	03000c14 	.word	0x03000c14
34015178:	03010c14 	.word	0x03010c14
3401517c:	03020c14 	.word	0x03020c14
34015180:	03030c14 	.word	0x03030c14
34015184:	83030c14 	.word	0x83030c14
34015188:	3402444c 	.word	0x3402444c
3401518c:	56028000 	.word	0x56028000
34015190:	03001414 	.word	0x03001414
34015194:	03011414 	.word	0x03011414
34015198:	03021414 	.word	0x03021414
3401519c:	03031414 	.word	0x03031414
340151a0:	83031414 	.word	0x83031414

340151a4 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_XSPI2    : XSPI2 peripheral clock
  *            @arg RCC_PERIPHCLK_XSPI3    : XSPI3 peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
340151a4:	b590      	push	{r4, r7, lr}
340151a6:	b085      	sub	sp, #20
340151a8:	af00      	add	r7, sp, #0
340151aa:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t frequency = 0;   /* Set to 0 for returned value if no source clock */
340151ae:	2100      	movs	r1, #0
340151b0:	60f9      	str	r1, [r7, #12]

  switch (PeriphClk)
340151b2:	e9d7 0100 	ldrd	r0, r1, [r7]
340151b6:	f101 447f 	add.w	r4, r1, #4278190080	@ 0xff000000
340151ba:	ea50 0104 	orrs.w	r1, r0, r4
340151be:	f000 8436 	beq.w	34015a2e <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
340151c2:	e9d7 0100 	ldrd	r0, r1, [r7]
340151c6:	2801      	cmp	r0, #1
340151c8:	f171 7180 	sbcs.w	r1, r1, #16777216	@ 0x1000000
340151cc:	f080 8434 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340151d0:	e9d7 0100 	ldrd	r0, r1, [r7]
340151d4:	f5a1 0400 	sub.w	r4, r1, #8388608	@ 0x800000
340151d8:	ea50 0104 	orrs.w	r1, r0, r4
340151dc:	f000 8422 	beq.w	34015a24 <HAL_RCCEx_GetPeriphCLKFreq+0x880>
340151e0:	e9d7 0100 	ldrd	r0, r1, [r7]
340151e4:	2801      	cmp	r0, #1
340151e6:	f571 0100 	sbcs.w	r1, r1, #8388608	@ 0x800000
340151ea:	f080 8425 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340151ee:	e9d7 0100 	ldrd	r0, r1, [r7]
340151f2:	f5a1 0480 	sub.w	r4, r1, #4194304	@ 0x400000
340151f6:	ea50 0104 	orrs.w	r1, r0, r4
340151fa:	f000 840e 	beq.w	34015a1a <HAL_RCCEx_GetPeriphCLKFreq+0x876>
340151fe:	e9d7 0100 	ldrd	r0, r1, [r7]
34015202:	2801      	cmp	r0, #1
34015204:	f571 0180 	sbcs.w	r1, r1, #4194304	@ 0x400000
34015208:	f080 8416 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401520c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015210:	f5a1 1400 	sub.w	r4, r1, #2097152	@ 0x200000
34015214:	ea50 0104 	orrs.w	r1, r0, r4
34015218:	f000 83fa 	beq.w	34015a10 <HAL_RCCEx_GetPeriphCLKFreq+0x86c>
3401521c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015220:	2801      	cmp	r0, #1
34015222:	f571 1100 	sbcs.w	r1, r1, #2097152	@ 0x200000
34015226:	f080 8407 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401522a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401522e:	f5a1 1480 	sub.w	r4, r1, #1048576	@ 0x100000
34015232:	ea50 0104 	orrs.w	r1, r0, r4
34015236:	f000 83e6 	beq.w	34015a06 <HAL_RCCEx_GetPeriphCLKFreq+0x862>
3401523a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401523e:	2801      	cmp	r0, #1
34015240:	f571 1180 	sbcs.w	r1, r1, #1048576	@ 0x100000
34015244:	f080 83f8 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015248:	e9d7 0100 	ldrd	r0, r1, [r7]
3401524c:	f5a1 2400 	sub.w	r4, r1, #524288	@ 0x80000
34015250:	ea50 0104 	orrs.w	r1, r0, r4
34015254:	f000 83d2 	beq.w	340159fc <HAL_RCCEx_GetPeriphCLKFreq+0x858>
34015258:	e9d7 0100 	ldrd	r0, r1, [r7]
3401525c:	2801      	cmp	r0, #1
3401525e:	f571 2100 	sbcs.w	r1, r1, #524288	@ 0x80000
34015262:	f080 83e9 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015266:	e9d7 0100 	ldrd	r0, r1, [r7]
3401526a:	f5a1 2480 	sub.w	r4, r1, #262144	@ 0x40000
3401526e:	ea50 0104 	orrs.w	r1, r0, r4
34015272:	f000 83be 	beq.w	340159f2 <HAL_RCCEx_GetPeriphCLKFreq+0x84e>
34015276:	e9d7 0100 	ldrd	r0, r1, [r7]
3401527a:	2801      	cmp	r0, #1
3401527c:	f571 2180 	sbcs.w	r1, r1, #262144	@ 0x40000
34015280:	f080 83da 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015284:	e9d7 0100 	ldrd	r0, r1, [r7]
34015288:	f5a1 3400 	sub.w	r4, r1, #131072	@ 0x20000
3401528c:	ea50 0104 	orrs.w	r1, r0, r4
34015290:	f000 83aa 	beq.w	340159e8 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
34015294:	e9d7 0100 	ldrd	r0, r1, [r7]
34015298:	2801      	cmp	r0, #1
3401529a:	f571 3100 	sbcs.w	r1, r1, #131072	@ 0x20000
3401529e:	f080 83cb 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340152a2:	e9d7 0100 	ldrd	r0, r1, [r7]
340152a6:	f5a1 3480 	sub.w	r4, r1, #65536	@ 0x10000
340152aa:	ea50 0104 	orrs.w	r1, r0, r4
340152ae:	f000 8396 	beq.w	340159de <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
340152b2:	e9d7 0100 	ldrd	r0, r1, [r7]
340152b6:	2801      	cmp	r0, #1
340152b8:	f571 3180 	sbcs.w	r1, r1, #65536	@ 0x10000
340152bc:	f080 83bc 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340152c0:	e9d7 0100 	ldrd	r0, r1, [r7]
340152c4:	f5a1 4400 	sub.w	r4, r1, #32768	@ 0x8000
340152c8:	ea50 0104 	orrs.w	r1, r0, r4
340152cc:	f000 8382 	beq.w	340159d4 <HAL_RCCEx_GetPeriphCLKFreq+0x830>
340152d0:	e9d7 0100 	ldrd	r0, r1, [r7]
340152d4:	2801      	cmp	r0, #1
340152d6:	f571 4100 	sbcs.w	r1, r1, #32768	@ 0x8000
340152da:	f080 83ad 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340152de:	e9d7 0100 	ldrd	r0, r1, [r7]
340152e2:	f5a1 4480 	sub.w	r4, r1, #16384	@ 0x4000
340152e6:	ea50 0104 	orrs.w	r1, r0, r4
340152ea:	f000 836e 	beq.w	340159ca <HAL_RCCEx_GetPeriphCLKFreq+0x826>
340152ee:	e9d7 0100 	ldrd	r0, r1, [r7]
340152f2:	2801      	cmp	r0, #1
340152f4:	f571 4180 	sbcs.w	r1, r1, #16384	@ 0x4000
340152f8:	f080 839e 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340152fc:	e9d7 0100 	ldrd	r0, r1, [r7]
34015300:	f5a1 5400 	sub.w	r4, r1, #8192	@ 0x2000
34015304:	ea50 0104 	orrs.w	r1, r0, r4
34015308:	f000 835a 	beq.w	340159c0 <HAL_RCCEx_GetPeriphCLKFreq+0x81c>
3401530c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015310:	2801      	cmp	r0, #1
34015312:	f571 5100 	sbcs.w	r1, r1, #8192	@ 0x2000
34015316:	f080 838f 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401531a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401531e:	f5a1 5480 	sub.w	r4, r1, #4096	@ 0x1000
34015322:	ea50 0104 	orrs.w	r1, r0, r4
34015326:	f000 8346 	beq.w	340159b6 <HAL_RCCEx_GetPeriphCLKFreq+0x812>
3401532a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401532e:	2801      	cmp	r0, #1
34015330:	f571 5180 	sbcs.w	r1, r1, #4096	@ 0x1000
34015334:	f080 8380 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015338:	e9d7 0100 	ldrd	r0, r1, [r7]
3401533c:	f5a1 6400 	sub.w	r4, r1, #2048	@ 0x800
34015340:	ea50 0104 	orrs.w	r1, r0, r4
34015344:	f000 8332 	beq.w	340159ac <HAL_RCCEx_GetPeriphCLKFreq+0x808>
34015348:	e9d7 0100 	ldrd	r0, r1, [r7]
3401534c:	2801      	cmp	r0, #1
3401534e:	f571 6100 	sbcs.w	r1, r1, #2048	@ 0x800
34015352:	f080 8371 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015356:	e9d7 0100 	ldrd	r0, r1, [r7]
3401535a:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
3401535e:	ea50 0104 	orrs.w	r1, r0, r4
34015362:	f000 831e 	beq.w	340159a2 <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
34015366:	e9d7 0100 	ldrd	r0, r1, [r7]
3401536a:	2801      	cmp	r0, #1
3401536c:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
34015370:	f080 8362 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015374:	e9d7 0100 	ldrd	r0, r1, [r7]
34015378:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
3401537c:	ea50 0104 	orrs.w	r1, r0, r4
34015380:	f000 830a 	beq.w	34015998 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
34015384:	e9d7 0100 	ldrd	r0, r1, [r7]
34015388:	2801      	cmp	r0, #1
3401538a:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
3401538e:	f080 8353 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015392:	e9d7 0100 	ldrd	r0, r1, [r7]
34015396:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
3401539a:	ea50 0104 	orrs.w	r1, r0, r4
3401539e:	f000 82f6 	beq.w	3401598e <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
340153a2:	e9d7 0100 	ldrd	r0, r1, [r7]
340153a6:	2801      	cmp	r0, #1
340153a8:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
340153ac:	f080 8344 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340153b0:	e9d7 0100 	ldrd	r0, r1, [r7]
340153b4:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
340153b8:	ea50 0104 	orrs.w	r1, r0, r4
340153bc:	f000 82e2 	beq.w	34015984 <HAL_RCCEx_GetPeriphCLKFreq+0x7e0>
340153c0:	e9d7 0100 	ldrd	r0, r1, [r7]
340153c4:	2801      	cmp	r0, #1
340153c6:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
340153ca:	f080 8335 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340153ce:	e9d7 0100 	ldrd	r0, r1, [r7]
340153d2:	f1a1 0420 	sub.w	r4, r1, #32
340153d6:	ea50 0104 	orrs.w	r1, r0, r4
340153da:	f000 82ce 	beq.w	3401597a <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
340153de:	e9d7 0100 	ldrd	r0, r1, [r7]
340153e2:	2801      	cmp	r0, #1
340153e4:	f171 0120 	sbcs.w	r1, r1, #32
340153e8:	f080 8326 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340153ec:	e9d7 0100 	ldrd	r0, r1, [r7]
340153f0:	f1a1 0410 	sub.w	r4, r1, #16
340153f4:	ea50 0104 	orrs.w	r1, r0, r4
340153f8:	f000 82ba 	beq.w	34015970 <HAL_RCCEx_GetPeriphCLKFreq+0x7cc>
340153fc:	e9d7 0100 	ldrd	r0, r1, [r7]
34015400:	2801      	cmp	r0, #1
34015402:	f171 0110 	sbcs.w	r1, r1, #16
34015406:	f080 8317 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401540a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401540e:	f1a1 0408 	sub.w	r4, r1, #8
34015412:	ea50 0104 	orrs.w	r1, r0, r4
34015416:	f000 82a6 	beq.w	34015966 <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
3401541a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401541e:	2801      	cmp	r0, #1
34015420:	f171 0108 	sbcs.w	r1, r1, #8
34015424:	f080 8308 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015428:	e9d7 0100 	ldrd	r0, r1, [r7]
3401542c:	1f0c      	subs	r4, r1, #4
3401542e:	ea50 0104 	orrs.w	r1, r0, r4
34015432:	f000 8293 	beq.w	3401595c <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
34015436:	e9d7 0100 	ldrd	r0, r1, [r7]
3401543a:	2801      	cmp	r0, #1
3401543c:	f171 0104 	sbcs.w	r1, r1, #4
34015440:	f080 82fa 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015444:	e9d7 0100 	ldrd	r0, r1, [r7]
34015448:	1e8c      	subs	r4, r1, #2
3401544a:	ea50 0104 	orrs.w	r1, r0, r4
3401544e:	f000 8280 	beq.w	34015952 <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
34015452:	e9d7 0100 	ldrd	r0, r1, [r7]
34015456:	2801      	cmp	r0, #1
34015458:	f171 0102 	sbcs.w	r1, r1, #2
3401545c:	f080 82ec 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015460:	e9d7 0100 	ldrd	r0, r1, [r7]
34015464:	1e4c      	subs	r4, r1, #1
34015466:	ea50 0104 	orrs.w	r1, r0, r4
3401546a:	f000 826d 	beq.w	34015948 <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
3401546e:	e9d7 0100 	ldrd	r0, r1, [r7]
34015472:	2801      	cmp	r0, #1
34015474:	f171 0101 	sbcs.w	r1, r1, #1
34015478:	f080 82de 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401547c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015480:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
34015484:	4321      	orrs	r1, r4
34015486:	f000 825a 	beq.w	3401593e <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
3401548a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401548e:	4cda      	ldr	r4, [pc, #872]	@ (340157f8 <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
34015490:	42a0      	cmp	r0, r4
34015492:	f171 0100 	sbcs.w	r1, r1, #0
34015496:	f080 82cf 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401549a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401549e:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
340154a2:	4321      	orrs	r1, r4
340154a4:	f000 8246 	beq.w	34015934 <HAL_RCCEx_GetPeriphCLKFreq+0x790>
340154a8:	e9d7 0100 	ldrd	r0, r1, [r7]
340154ac:	4cd3      	ldr	r4, [pc, #844]	@ (340157fc <HAL_RCCEx_GetPeriphCLKFreq+0x658>)
340154ae:	42a0      	cmp	r0, r4
340154b0:	f171 0100 	sbcs.w	r1, r1, #0
340154b4:	f080 82c0 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340154b8:	e9d7 0100 	ldrd	r0, r1, [r7]
340154bc:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
340154c0:	4321      	orrs	r1, r4
340154c2:	f000 8232 	beq.w	3401592a <HAL_RCCEx_GetPeriphCLKFreq+0x786>
340154c6:	e9d7 0100 	ldrd	r0, r1, [r7]
340154ca:	4ccd      	ldr	r4, [pc, #820]	@ (34015800 <HAL_RCCEx_GetPeriphCLKFreq+0x65c>)
340154cc:	42a0      	cmp	r0, r4
340154ce:	f171 0100 	sbcs.w	r1, r1, #0
340154d2:	f080 82b1 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340154d6:	e9d7 0100 	ldrd	r0, r1, [r7]
340154da:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
340154de:	4321      	orrs	r1, r4
340154e0:	f000 821e 	beq.w	34015920 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
340154e4:	e9d7 0100 	ldrd	r0, r1, [r7]
340154e8:	4cc6      	ldr	r4, [pc, #792]	@ (34015804 <HAL_RCCEx_GetPeriphCLKFreq+0x660>)
340154ea:	42a0      	cmp	r0, r4
340154ec:	f171 0100 	sbcs.w	r1, r1, #0
340154f0:	f080 82a2 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340154f4:	e9d7 0100 	ldrd	r0, r1, [r7]
340154f8:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
340154fc:	4321      	orrs	r1, r4
340154fe:	f000 820b 	beq.w	34015918 <HAL_RCCEx_GetPeriphCLKFreq+0x774>
34015502:	e9d7 0100 	ldrd	r0, r1, [r7]
34015506:	4cc0      	ldr	r4, [pc, #768]	@ (34015808 <HAL_RCCEx_GetPeriphCLKFreq+0x664>)
34015508:	42a0      	cmp	r0, r4
3401550a:	f171 0100 	sbcs.w	r1, r1, #0
3401550e:	f080 8293 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015512:	e9d7 0100 	ldrd	r0, r1, [r7]
34015516:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
3401551a:	4321      	orrs	r1, r4
3401551c:	f000 81f7 	beq.w	3401590e <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
34015520:	e9d7 0100 	ldrd	r0, r1, [r7]
34015524:	4cb9      	ldr	r4, [pc, #740]	@ (3401580c <HAL_RCCEx_GetPeriphCLKFreq+0x668>)
34015526:	42a0      	cmp	r0, r4
34015528:	f171 0100 	sbcs.w	r1, r1, #0
3401552c:	f080 8284 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015530:	e9d7 0100 	ldrd	r0, r1, [r7]
34015534:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
34015538:	4321      	orrs	r1, r4
3401553a:	f000 81e2 	beq.w	34015902 <HAL_RCCEx_GetPeriphCLKFreq+0x75e>
3401553e:	e9d7 0100 	ldrd	r0, r1, [r7]
34015542:	4cb3      	ldr	r4, [pc, #716]	@ (34015810 <HAL_RCCEx_GetPeriphCLKFreq+0x66c>)
34015544:	42a0      	cmp	r0, r4
34015546:	f171 0100 	sbcs.w	r1, r1, #0
3401554a:	f080 8275 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401554e:	e9d7 0100 	ldrd	r0, r1, [r7]
34015552:	f100 447f 	add.w	r4, r0, #4278190080	@ 0xff000000
34015556:	4321      	orrs	r1, r4
34015558:	f000 81cd 	beq.w	340158f6 <HAL_RCCEx_GetPeriphCLKFreq+0x752>
3401555c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015560:	4cac      	ldr	r4, [pc, #688]	@ (34015814 <HAL_RCCEx_GetPeriphCLKFreq+0x670>)
34015562:	42a0      	cmp	r0, r4
34015564:	f171 0100 	sbcs.w	r1, r1, #0
34015568:	f080 8266 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401556c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015570:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
34015574:	4321      	orrs	r1, r4
34015576:	f000 81b8 	beq.w	340158ea <HAL_RCCEx_GetPeriphCLKFreq+0x746>
3401557a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401557e:	4ca6      	ldr	r4, [pc, #664]	@ (34015818 <HAL_RCCEx_GetPeriphCLKFreq+0x674>)
34015580:	42a0      	cmp	r0, r4
34015582:	f171 0100 	sbcs.w	r1, r1, #0
34015586:	f080 8257 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401558a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401558e:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
34015592:	4321      	orrs	r1, r4
34015594:	f000 81a4 	beq.w	340158e0 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
34015598:	e9d7 0100 	ldrd	r0, r1, [r7]
3401559c:	4c9f      	ldr	r4, [pc, #636]	@ (3401581c <HAL_RCCEx_GetPeriphCLKFreq+0x678>)
3401559e:	42a0      	cmp	r0, r4
340155a0:	f171 0100 	sbcs.w	r1, r1, #0
340155a4:	f080 8248 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340155a8:	e9d7 0100 	ldrd	r0, r1, [r7]
340155ac:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
340155b0:	4321      	orrs	r1, r4
340155b2:	f000 8190 	beq.w	340158d6 <HAL_RCCEx_GetPeriphCLKFreq+0x732>
340155b6:	e9d7 0100 	ldrd	r0, r1, [r7]
340155ba:	4c99      	ldr	r4, [pc, #612]	@ (34015820 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>)
340155bc:	42a0      	cmp	r0, r4
340155be:	f171 0100 	sbcs.w	r1, r1, #0
340155c2:	f080 8239 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340155c6:	e9d7 0100 	ldrd	r0, r1, [r7]
340155ca:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
340155ce:	4321      	orrs	r1, r4
340155d0:	f000 817c 	beq.w	340158cc <HAL_RCCEx_GetPeriphCLKFreq+0x728>
340155d4:	e9d7 0100 	ldrd	r0, r1, [r7]
340155d8:	4c92      	ldr	r4, [pc, #584]	@ (34015824 <HAL_RCCEx_GetPeriphCLKFreq+0x680>)
340155da:	42a0      	cmp	r0, r4
340155dc:	f171 0100 	sbcs.w	r1, r1, #0
340155e0:	f080 822a 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340155e4:	e9d7 0100 	ldrd	r0, r1, [r7]
340155e8:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
340155ec:	4321      	orrs	r1, r4
340155ee:	f000 8168 	beq.w	340158c2 <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
340155f2:	e9d7 0100 	ldrd	r0, r1, [r7]
340155f6:	4c8c      	ldr	r4, [pc, #560]	@ (34015828 <HAL_RCCEx_GetPeriphCLKFreq+0x684>)
340155f8:	42a0      	cmp	r0, r4
340155fa:	f171 0100 	sbcs.w	r1, r1, #0
340155fe:	f080 821b 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015602:	e9d7 0100 	ldrd	r0, r1, [r7]
34015606:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
3401560a:	4321      	orrs	r1, r4
3401560c:	f000 8154 	beq.w	340158b8 <HAL_RCCEx_GetPeriphCLKFreq+0x714>
34015610:	e9d7 0100 	ldrd	r0, r1, [r7]
34015614:	4c85      	ldr	r4, [pc, #532]	@ (3401582c <HAL_RCCEx_GetPeriphCLKFreq+0x688>)
34015616:	42a0      	cmp	r0, r4
34015618:	f171 0100 	sbcs.w	r1, r1, #0
3401561c:	f080 820c 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015620:	e9d7 0100 	ldrd	r0, r1, [r7]
34015624:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
34015628:	4321      	orrs	r1, r4
3401562a:	f000 8140 	beq.w	340158ae <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
3401562e:	e9d7 0100 	ldrd	r0, r1, [r7]
34015632:	4c7f      	ldr	r4, [pc, #508]	@ (34015830 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>)
34015634:	42a0      	cmp	r0, r4
34015636:	f171 0100 	sbcs.w	r1, r1, #0
3401563a:	f080 81fd 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401563e:	e9d7 0100 	ldrd	r0, r1, [r7]
34015642:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
34015646:	4321      	orrs	r1, r4
34015648:	f000 812c 	beq.w	340158a4 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
3401564c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015650:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
34015654:	f171 0100 	sbcs.w	r1, r1, #0
34015658:	f080 81ee 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401565c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015660:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
34015664:	4321      	orrs	r1, r4
34015666:	f000 8118 	beq.w	3401589a <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
3401566a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401566e:	f248 0401 	movw	r4, #32769	@ 0x8001
34015672:	42a0      	cmp	r0, r4
34015674:	f171 0100 	sbcs.w	r1, r1, #0
34015678:	f080 81de 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401567c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015680:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
34015684:	4321      	orrs	r1, r4
34015686:	f000 8103 	beq.w	34015890 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3401568a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401568e:	f244 0401 	movw	r4, #16385	@ 0x4001
34015692:	42a0      	cmp	r0, r4
34015694:	f171 0100 	sbcs.w	r1, r1, #0
34015698:	f080 81ce 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401569c:	e9d7 0100 	ldrd	r0, r1, [r7]
340156a0:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
340156a4:	4321      	orrs	r1, r4
340156a6:	f000 80ee 	beq.w	34015886 <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
340156aa:	e9d7 0100 	ldrd	r0, r1, [r7]
340156ae:	f242 0401 	movw	r4, #8193	@ 0x2001
340156b2:	42a0      	cmp	r0, r4
340156b4:	f171 0100 	sbcs.w	r1, r1, #0
340156b8:	f080 81be 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340156bc:	e9d7 0100 	ldrd	r0, r1, [r7]
340156c0:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
340156c4:	4321      	orrs	r1, r4
340156c6:	f000 80d9 	beq.w	3401587c <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
340156ca:	e9d7 0100 	ldrd	r0, r1, [r7]
340156ce:	f241 0401 	movw	r4, #4097	@ 0x1001
340156d2:	42a0      	cmp	r0, r4
340156d4:	f171 0100 	sbcs.w	r1, r1, #0
340156d8:	f080 81ae 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340156dc:	e9d7 0100 	ldrd	r0, r1, [r7]
340156e0:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
340156e4:	4321      	orrs	r1, r4
340156e6:	f000 80c4 	beq.w	34015872 <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
340156ea:	e9d7 0100 	ldrd	r0, r1, [r7]
340156ee:	f640 0401 	movw	r4, #2049	@ 0x801
340156f2:	42a0      	cmp	r0, r4
340156f4:	f171 0100 	sbcs.w	r1, r1, #0
340156f8:	f080 819e 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340156fc:	e9d7 0100 	ldrd	r0, r1, [r7]
34015700:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
34015704:	4321      	orrs	r1, r4
34015706:	f000 80af 	beq.w	34015868 <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
3401570a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401570e:	f240 4401 	movw	r4, #1025	@ 0x401
34015712:	42a0      	cmp	r0, r4
34015714:	f171 0100 	sbcs.w	r1, r1, #0
34015718:	f080 818e 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401571c:	e9d7 0100 	ldrd	r0, r1, [r7]
34015720:	2821      	cmp	r0, #33	@ 0x21
34015722:	f171 0100 	sbcs.w	r1, r1, #0
34015726:	d255      	bcs.n	340157d4 <HAL_RCCEx_GetPeriphCLKFreq+0x630>
34015728:	e9d7 0100 	ldrd	r0, r1, [r7]
3401572c:	4301      	orrs	r1, r0
3401572e:	f000 8183 	beq.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015732:	e9d7 0100 	ldrd	r0, r1, [r7]
34015736:	1e42      	subs	r2, r0, #1
34015738:	f141 33ff 	adc.w	r3, r1, #4294967295
3401573c:	2a20      	cmp	r2, #32
3401573e:	f173 0100 	sbcs.w	r1, r3, #0
34015742:	f080 8179 	bcs.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34015746:	2a1f      	cmp	r2, #31
34015748:	f200 8176 	bhi.w	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401574c:	a101      	add	r1, pc, #4	@ (adr r1, 34015754 <HAL_RCCEx_GetPeriphCLKFreq+0x5b0>)
3401574e:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
34015752:	bf00      	nop
34015754:	340157e3 	.word	0x340157e3
34015758:	340157ed 	.word	0x340157ed
3401575c:	34015a39 	.word	0x34015a39
34015760:	3401583d 	.word	0x3401583d
34015764:	34015a39 	.word	0x34015a39
34015768:	34015a39 	.word	0x34015a39
3401576c:	34015a39 	.word	0x34015a39
34015770:	34015835 	.word	0x34015835
34015774:	34015a39 	.word	0x34015a39
34015778:	34015a39 	.word	0x34015a39
3401577c:	34015a39 	.word	0x34015a39
34015780:	34015a39 	.word	0x34015a39
34015784:	34015a39 	.word	0x34015a39
34015788:	34015a39 	.word	0x34015a39
3401578c:	34015a39 	.word	0x34015a39
34015790:	34015847 	.word	0x34015847
34015794:	34015a39 	.word	0x34015a39
34015798:	34015a39 	.word	0x34015a39
3401579c:	34015a39 	.word	0x34015a39
340157a0:	34015a39 	.word	0x34015a39
340157a4:	34015a39 	.word	0x34015a39
340157a8:	34015a39 	.word	0x34015a39
340157ac:	34015a39 	.word	0x34015a39
340157b0:	34015a39 	.word	0x34015a39
340157b4:	34015a39 	.word	0x34015a39
340157b8:	34015a39 	.word	0x34015a39
340157bc:	34015a39 	.word	0x34015a39
340157c0:	34015a39 	.word	0x34015a39
340157c4:	34015a39 	.word	0x34015a39
340157c8:	34015a39 	.word	0x34015a39
340157cc:	34015a39 	.word	0x34015a39
340157d0:	34015853 	.word	0x34015853
340157d4:	e9d7 2300 	ldrd	r2, r3, [r7]
340157d8:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
340157dc:	430b      	orrs	r3, r1
340157de:	d03e      	beq.n	3401585e <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
      break;

    default:
      /* Unexpected case, frequency is by default set to 0 */
      break;
340157e0:	e12a      	b.n	34015a38 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
      frequency = RCCEx_GetADCCLKFreq(LL_RCC_ADC_CLKSOURCE);
340157e2:	2070      	movs	r0, #112	@ 0x70
340157e4:	f000 fb90 	bl	34015f08 <RCCEx_GetADCCLKFreq>
340157e8:	60f8      	str	r0, [r7, #12]
      break;
340157ea:	e126      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetADFCLKFreq(LL_RCC_ADF1_CLKSOURCE);
340157ec:	2007      	movs	r0, #7
340157ee:	f000 fc8d 	bl	3401610c <RCCEx_GetADFCLKFreq>
340157f2:	60f8      	str	r0, [r7, #12]
      break;
340157f4:	e121      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
340157f6:	bf00      	nop
340157f8:	80000001 	.word	0x80000001
340157fc:	40000001 	.word	0x40000001
34015800:	20000001 	.word	0x20000001
34015804:	10000001 	.word	0x10000001
34015808:	08000001 	.word	0x08000001
3401580c:	04000001 	.word	0x04000001
34015810:	02000001 	.word	0x02000001
34015814:	01000001 	.word	0x01000001
34015818:	00800001 	.word	0x00800001
3401581c:	00400001 	.word	0x00400001
34015820:	00200001 	.word	0x00200001
34015824:	00100001 	.word	0x00100001
34015828:	00080001 	.word	0x00080001
3401582c:	00040001 	.word	0x00040001
34015830:	00020001 	.word	0x00020001
      frequency = RCCEx_GetCSICLKFreq();
34015834:	f000 ff0c 	bl	34016650 <RCCEx_GetCSICLKFreq>
34015838:	60f8      	str	r0, [r7, #12]
      break;
3401583a:	e0fe      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401583c:	2007      	movs	r0, #7
3401583e:	f000 fd51 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34015842:	60f8      	str	r0, [r7, #12]
      break;
34015844:	e0f9      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetDCMIPPCLKFreq(LL_RCC_DCMIPP_CLKSOURCE);
34015846:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
3401584a:	f000 ff4d 	bl	340166e8 <RCCEx_GetDCMIPPCLKFreq>
3401584e:	60f8      	str	r0, [r7, #12]
      break;
34015850:	e0f3      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1CLKFreq(LL_RCC_ETH1_CLKSOURCE);
34015852:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
34015856:	f000 ffd1 	bl	340167fc <RCCEx_GetETH1CLKFreq>
3401585a:	60f8      	str	r0, [r7, #12]
      break;
3401585c:	e0ed      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1PTPCLKFreq(LL_RCC_ETH1PTP_CLKSOURCE);
3401585e:	2003      	movs	r0, #3
34015860:	f001 f84c 	bl	340168fc <RCCEx_GetETH1PTPCLKFreq>
34015864:	60f8      	str	r0, [r7, #12]
      break;
34015866:	e0e8      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFDCANCLKFreq(LL_RCC_FDCAN_CLKSOURCE);
34015868:	2003      	movs	r0, #3
3401586a:	f001 f8cb 	bl	34016a04 <RCCEx_GetFDCANCLKFreq>
3401586e:	60f8      	str	r0, [r7, #12]
      break;
34015870:	e0e3      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFMCCLKFreq(LL_RCC_FMC_CLKSOURCE);
34015872:	2030      	movs	r0, #48	@ 0x30
34015874:	f001 f946 	bl	34016b04 <RCCEx_GetFMCCLKFreq>
34015878:	60f8      	str	r0, [r7, #12]
      break;
3401587a:	e0de      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
3401587c:	4871      	ldr	r0, [pc, #452]	@ (34015a44 <HAL_RCCEx_GetPeriphCLKFreq+0x8a0>)
3401587e:	f001 f9f9 	bl	34016c74 <RCCEx_GetI2CCLKFreq>
34015882:	60f8      	str	r0, [r7, #12]
      break;
34015884:	e0d9      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
34015886:	4870      	ldr	r0, [pc, #448]	@ (34015a48 <HAL_RCCEx_GetPeriphCLKFreq+0x8a4>)
34015888:	f001 f9f4 	bl	34016c74 <RCCEx_GetI2CCLKFreq>
3401588c:	60f8      	str	r0, [r7, #12]
      break;
3401588e:	e0d4      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34015890:	486e      	ldr	r0, [pc, #440]	@ (34015a4c <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
34015892:	f001 f9ef 	bl	34016c74 <RCCEx_GetI2CCLKFreq>
34015896:	60f8      	str	r0, [r7, #12]
      break;
34015898:	e0cf      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3401589a:	486d      	ldr	r0, [pc, #436]	@ (34015a50 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>)
3401589c:	f001 f9ea 	bl	34016c74 <RCCEx_GetI2CCLKFreq>
340158a0:	60f8      	str	r0, [r7, #12]
      break;
340158a2:	e0ca      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
340158a4:	486b      	ldr	r0, [pc, #428]	@ (34015a54 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>)
340158a6:	f001 fb8d 	bl	34016fc4 <RCCEx_GetI3CCLKFreq>
340158aa:	60f8      	str	r0, [r7, #12]
      break;
340158ac:	e0c5      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
340158ae:	486a      	ldr	r0, [pc, #424]	@ (34015a58 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>)
340158b0:	f001 fb88 	bl	34016fc4 <RCCEx_GetI3CCLKFreq>
340158b4:	60f8      	str	r0, [r7, #12]
      break;
340158b6:	e0c0      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
340158b8:	4868      	ldr	r0, [pc, #416]	@ (34015a5c <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>)
340158ba:	f001 fcb7 	bl	3401722c <RCCEx_GetLPTIMCLKFreq>
340158be:	60f8      	str	r0, [r7, #12]
      break;
340158c0:	e0bb      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
340158c2:	4867      	ldr	r0, [pc, #412]	@ (34015a60 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
340158c4:	f001 fcb2 	bl	3401722c <RCCEx_GetLPTIMCLKFreq>
340158c8:	60f8      	str	r0, [r7, #12]
      break;
340158ca:	e0b6      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
340158cc:	4865      	ldr	r0, [pc, #404]	@ (34015a64 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
340158ce:	f001 fcad 	bl	3401722c <RCCEx_GetLPTIMCLKFreq>
340158d2:	60f8      	str	r0, [r7, #12]
      break;
340158d4:	e0b1      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
340158d6:	4864      	ldr	r0, [pc, #400]	@ (34015a68 <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
340158d8:	f001 fca8 	bl	3401722c <RCCEx_GetLPTIMCLKFreq>
340158dc:	60f8      	str	r0, [r7, #12]
      break;
340158de:	e0ac      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
340158e0:	4862      	ldr	r0, [pc, #392]	@ (34015a6c <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
340158e2:	f001 fca3 	bl	3401722c <RCCEx_GetLPTIMCLKFreq>
340158e6:	60f8      	str	r0, [r7, #12]
      break;
340158e8:	e0a7      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPUARTCLKFreq(LL_RCC_LPUART1_CLKSOURCE);
340158ea:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
340158ee:	f001 fe47 	bl	34017580 <RCCEx_GetLPUARTCLKFreq>
340158f2:	60f8      	str	r0, [r7, #12]
      break;
340158f4:	e0a1      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLTDCCLKFreq(LL_RCC_LTDC_CLKSOURCE);
340158f6:	f04f 7040 	mov.w	r0, #50331648	@ 0x3000000
340158fa:	f001 ff43 	bl	34017784 <RCCEx_GetLTDCCLKFreq>
340158fe:	60f8      	str	r0, [r7, #12]
      break;
34015900:	e09b      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetMDFCLKFreq(LL_RCC_MDF1_CLKSOURCE);
34015902:	f44f 20e0 	mov.w	r0, #458752	@ 0x70000
34015906:	f001 ffc7 	bl	34017898 <RCCEx_GetMDFCLKFreq>
3401590a:	60f8      	str	r0, [r7, #12]
      break;
3401590c:	e095      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetPSSICLKFreq(LL_RCC_PSSI_CLKSOURCE);
3401590e:	2030      	movs	r0, #48	@ 0x30
34015910:	f002 f8cc 	bl	34017aac <RCCEx_GetPSSICLKFreq>
34015914:	60f8      	str	r0, [r7, #12]
      break;
34015916:	e090      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetRTCCLKFreq();
34015918:	f002 f94a 	bl	34017bb0 <RCCEx_GetRTCCLKFreq>
3401591c:	60f8      	str	r0, [r7, #12]
      break;
3401591e:	e08c      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
34015920:	4853      	ldr	r0, [pc, #332]	@ (34015a70 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
34015922:	f002 f997 	bl	34017c54 <RCCEx_GetSAICLKFreq>
34015926:	60f8      	str	r0, [r7, #12]
      break;
34015928:	e087      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3401592a:	4852      	ldr	r0, [pc, #328]	@ (34015a74 <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>)
3401592c:	f002 f992 	bl	34017c54 <RCCEx_GetSAICLKFreq>
34015930:	60f8      	str	r0, [r7, #12]
      break;
34015932:	e082      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
34015934:	4850      	ldr	r0, [pc, #320]	@ (34015a78 <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>)
34015936:	f002 faf3 	bl	34017f20 <RCCEx_GetSDMMCCLKFreq>
3401593a:	60f8      	str	r0, [r7, #12]
      break;
3401593c:	e07d      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3401593e:	484f      	ldr	r0, [pc, #316]	@ (34015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x8d8>)
34015940:	f002 faee 	bl	34017f20 <RCCEx_GetSDMMCCLKFreq>
34015944:	60f8      	str	r0, [r7, #12]
      break;
34015946:	e078      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34015948:	2007      	movs	r0, #7
3401594a:	f002 fbd3 	bl	340180f4 <RCCEx_GetSPDIFRXCLKFreq>
3401594e:	60f8      	str	r0, [r7, #12]
      break;
34015950:	e073      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
34015952:	484b      	ldr	r0, [pc, #300]	@ (34015a80 <HAL_RCCEx_GetPeriphCLKFreq+0x8dc>)
34015954:	f002 fcb2 	bl	340182bc <RCCEx_GetSPICLKFreq>
34015958:	60f8      	str	r0, [r7, #12]
      break;
3401595a:	e06e      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
3401595c:	4849      	ldr	r0, [pc, #292]	@ (34015a84 <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>)
3401595e:	f002 fcad 	bl	340182bc <RCCEx_GetSPICLKFreq>
34015962:	60f8      	str	r0, [r7, #12]
      break;
34015964:	e069      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
34015966:	4848      	ldr	r0, [pc, #288]	@ (34015a88 <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>)
34015968:	f002 fca8 	bl	340182bc <RCCEx_GetSPICLKFreq>
3401596c:	60f8      	str	r0, [r7, #12]
      break;
3401596e:	e064      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34015970:	4846      	ldr	r0, [pc, #280]	@ (34015a8c <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>)
34015972:	f002 fca3 	bl	340182bc <RCCEx_GetSPICLKFreq>
34015976:	60f8      	str	r0, [r7, #12]
      break;
34015978:	e05f      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3401597a:	4845      	ldr	r0, [pc, #276]	@ (34015a90 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>)
3401597c:	f002 fc9e 	bl	340182bc <RCCEx_GetSPICLKFreq>
34015980:	60f8      	str	r0, [r7, #12]
      break;
34015982:	e05a      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34015984:	4843      	ldr	r0, [pc, #268]	@ (34015a94 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>)
34015986:	f002 fc99 	bl	340182bc <RCCEx_GetSPICLKFreq>
3401598a:	60f8      	str	r0, [r7, #12]
      break;
3401598c:	e055      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
3401598e:	4842      	ldr	r0, [pc, #264]	@ (34015a98 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>)
34015990:	f003 f990 	bl	34018cb4 <RCCEx_GetUSARTCLKFreq>
34015994:	60f8      	str	r0, [r7, #12]
      break;
34015996:	e050      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
34015998:	4840      	ldr	r0, [pc, #256]	@ (34015a9c <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>)
3401599a:	f003 f98b 	bl	34018cb4 <RCCEx_GetUSARTCLKFreq>
3401599e:	60f8      	str	r0, [r7, #12]
      break;
340159a0:	e04b      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
340159a2:	483f      	ldr	r0, [pc, #252]	@ (34015aa0 <HAL_RCCEx_GetPeriphCLKFreq+0x8fc>)
340159a4:	f003 f986 	bl	34018cb4 <RCCEx_GetUSARTCLKFreq>
340159a8:	60f8      	str	r0, [r7, #12]
      break;
340159aa:	e046      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
340159ac:	483d      	ldr	r0, [pc, #244]	@ (34015aa4 <HAL_RCCEx_GetPeriphCLKFreq+0x900>)
340159ae:	f002 ff57 	bl	34018860 <RCCEx_GetUARTCLKFreq>
340159b2:	60f8      	str	r0, [r7, #12]
      break;
340159b4:	e041      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
340159b6:	483c      	ldr	r0, [pc, #240]	@ (34015aa8 <HAL_RCCEx_GetPeriphCLKFreq+0x904>)
340159b8:	f002 ff52 	bl	34018860 <RCCEx_GetUARTCLKFreq>
340159bc:	60f8      	str	r0, [r7, #12]
      break;
340159be:	e03c      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
340159c0:	483a      	ldr	r0, [pc, #232]	@ (34015aac <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
340159c2:	f003 f977 	bl	34018cb4 <RCCEx_GetUSARTCLKFreq>
340159c6:	60f8      	str	r0, [r7, #12]
      break;
340159c8:	e037      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
340159ca:	4839      	ldr	r0, [pc, #228]	@ (34015ab0 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
340159cc:	f002 ff48 	bl	34018860 <RCCEx_GetUARTCLKFreq>
340159d0:	60f8      	str	r0, [r7, #12]
      break;
340159d2:	e032      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
340159d4:	4837      	ldr	r0, [pc, #220]	@ (34015ab4 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
340159d6:	f002 ff43 	bl	34018860 <RCCEx_GetUARTCLKFreq>
340159da:	60f8      	str	r0, [r7, #12]
      break;
340159dc:	e02d      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
340159de:	4836      	ldr	r0, [pc, #216]	@ (34015ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
340159e0:	f002 ff3e 	bl	34018860 <RCCEx_GetUARTCLKFreq>
340159e4:	60f8      	str	r0, [r7, #12]
      break;
340159e6:	e028      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
340159e8:	4834      	ldr	r0, [pc, #208]	@ (34015abc <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
340159ea:	f003 f963 	bl	34018cb4 <RCCEx_GetUSARTCLKFreq>
340159ee:	60f8      	str	r0, [r7, #12]
      break;
340159f0:	e023      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
340159f2:	4833      	ldr	r0, [pc, #204]	@ (34015ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
340159f4:	f003 fc3e 	bl	34019274 <RCCEx_GetOTGPHYCKREFCLKFreq>
340159f8:	60f8      	str	r0, [r7, #12]
      break;
340159fa:	e01e      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
340159fc:	4831      	ldr	r0, [pc, #196]	@ (34015ac4 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
340159fe:	f003 fb83 	bl	34019108 <RCCEx_GetOTGPHYCLKFreq>
34015a02:	60f8      	str	r0, [r7, #12]
      break;
34015a04:	e019      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
34015a06:	4830      	ldr	r0, [pc, #192]	@ (34015ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
34015a08:	f003 fc34 	bl	34019274 <RCCEx_GetOTGPHYCKREFCLKFreq>
34015a0c:	60f8      	str	r0, [r7, #12]
      break;
34015a0e:	e014      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34015a10:	482e      	ldr	r0, [pc, #184]	@ (34015acc <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
34015a12:	f003 fb79 	bl	34019108 <RCCEx_GetOTGPHYCLKFreq>
34015a16:	60f8      	str	r0, [r7, #12]
      break;
34015a18:	e00f      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
34015a1a:	482d      	ldr	r0, [pc, #180]	@ (34015ad0 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
34015a1c:	f003 fc7a 	bl	34019314 <RCCEx_GetXSPICLKFreq>
34015a20:	60f8      	str	r0, [r7, #12]
      break;
34015a22:	e00a      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
34015a24:	482b      	ldr	r0, [pc, #172]	@ (34015ad4 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
34015a26:	f003 fc75 	bl	34019314 <RCCEx_GetXSPICLKFreq>
34015a2a:	60f8      	str	r0, [r7, #12]
      break;
34015a2c:	e005      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
34015a2e:	482a      	ldr	r0, [pc, #168]	@ (34015ad8 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
34015a30:	f003 fc70 	bl	34019314 <RCCEx_GetXSPICLKFreq>
34015a34:	60f8      	str	r0, [r7, #12]
      break;
34015a36:	e000      	b.n	34015a3a <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      break;
34015a38:	bf00      	nop
  }

  return frequency;
34015a3a:	68fb      	ldr	r3, [r7, #12]
}
34015a3c:	4618      	mov	r0, r3
34015a3e:	3714      	adds	r7, #20
34015a40:	46bd      	mov	sp, r7
34015a42:	bd90      	pop	{r4, r7, pc}
34015a44:	0700000c 	.word	0x0700000c
34015a48:	0700040c 	.word	0x0700040c
34015a4c:	0700080c 	.word	0x0700080c
34015a50:	07000c0c 	.word	0x07000c0c
34015a54:	0700100c 	.word	0x0700100c
34015a58:	0700140c 	.word	0x0700140c
34015a5c:	0700082c 	.word	0x0700082c
34015a60:	07000c2c 	.word	0x07000c2c
34015a64:	0700102c 	.word	0x0700102c
34015a68:	0700142c 	.word	0x0700142c
34015a6c:	0700182c 	.word	0x0700182c
34015a70:	07001418 	.word	0x07001418
34015a74:	07001818 	.word	0x07001818
34015a78:	0300001c 	.word	0x0300001c
34015a7c:	0300041c 	.word	0x0300041c
34015a80:	07000420 	.word	0x07000420
34015a84:	07000820 	.word	0x07000820
34015a88:	07000c20 	.word	0x07000c20
34015a8c:	07001020 	.word	0x07001020
34015a90:	07001420 	.word	0x07001420
34015a94:	07001820 	.word	0x07001820
34015a98:	07000030 	.word	0x07000030
34015a9c:	07000430 	.word	0x07000430
34015aa0:	07000830 	.word	0x07000830
34015aa4:	07000c30 	.word	0x07000c30
34015aa8:	07001030 	.word	0x07001030
34015aac:	07001430 	.word	0x07001430
34015ab0:	07001830 	.word	0x07001830
34015ab4:	07001c30 	.word	0x07001c30
34015ab8:	07000034 	.word	0x07000034
34015abc:	07000434 	.word	0x07000434
34015ac0:	01001014 	.word	0x01001014
34015ac4:	03000c14 	.word	0x03000c14
34015ac8:	01001814 	.word	0x01001814
34015acc:	03001414 	.word	0x03001414
34015ad0:	03000014 	.word	0x03000014
34015ad4:	03000414 	.word	0x03000414
34015ad8:	03000814 	.word	0x03000814

34015adc <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34015adc:	b5f0      	push	{r4, r5, r6, r7, lr}
34015ade:	b087      	sub	sp, #28
34015ae0:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34015ae2:	2300      	movs	r3, #0
34015ae4:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
34015ae6:	f7f8 f89b 	bl	3400dc20 <LL_RCC_PLL1_IsReady>
34015aea:	4603      	mov	r3, r0
34015aec:	2b00      	cmp	r3, #0
34015aee:	d02a      	beq.n	34015b46 <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34015af0:	f7f8 f8fe 	bl	3400dcf0 <LL_RCC_PLL1P_IsEnabled>
34015af4:	4603      	mov	r3, r0
34015af6:	2b00      	cmp	r3, #0
34015af8:	d031      	beq.n	34015b5e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34015afa:	f7f8 f883 	bl	3400dc04 <LL_RCC_PLL1_GetSource>
34015afe:	4603      	mov	r3, r0
34015b00:	4618      	mov	r0, r3
34015b02:	f000 f957 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015b06:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34015b08:	68bb      	ldr	r3, [r7, #8]
34015b0a:	2b00      	cmp	r3, #0
34015b0c:	d027      	beq.n	34015b5e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL1_GetM();
34015b0e:	f7f8 f8bf 	bl	3400dc90 <LL_RCC_PLL1_GetM>
34015b12:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34015b14:	687b      	ldr	r3, [r7, #4]
34015b16:	2b00      	cmp	r3, #0
34015b18:	d021      	beq.n	34015b5e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
34015b1a:	f7f8 f8a9 	bl	3400dc70 <LL_RCC_PLL1_GetN>
34015b1e:	4605      	mov	r5, r0
34015b20:	f7f8 f8fa 	bl	3400dd18 <LL_RCC_PLL1_GetFRACN>
34015b24:	4606      	mov	r6, r0
34015b26:	f7f8 f8c3 	bl	3400dcb0 <LL_RCC_PLL1_GetP1>
34015b2a:	4604      	mov	r4, r0
34015b2c:	f7f8 f8d0 	bl	3400dcd0 <LL_RCC_PLL1_GetP2>
34015b30:	4603      	mov	r3, r0
34015b32:	9301      	str	r3, [sp, #4]
34015b34:	9400      	str	r4, [sp, #0]
34015b36:	4633      	mov	r3, r6
34015b38:	462a      	mov	r2, r5
34015b3a:	6879      	ldr	r1, [r7, #4]
34015b3c:	68b8      	ldr	r0, [r7, #8]
34015b3e:	f000 f997 	bl	34015e70 <RCCEx_CalcPLLFreq>
34015b42:	60f8      	str	r0, [r7, #12]
34015b44:	e00b      	b.n	34015b5e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
34015b46:	f7f8 f87f 	bl	3400dc48 <LL_RCC_PLL1_IsEnabledBypass>
34015b4a:	4603      	mov	r3, r0
34015b4c:	2b00      	cmp	r3, #0
34015b4e:	d006      	beq.n	34015b5e <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34015b50:	f7f8 f858 	bl	3400dc04 <LL_RCC_PLL1_GetSource>
34015b54:	4603      	mov	r3, r0
34015b56:	4618      	mov	r0, r3
34015b58:	f000 f92c 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015b5c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34015b5e:	68fb      	ldr	r3, [r7, #12]
}
34015b60:	4618      	mov	r0, r3
34015b62:	3714      	adds	r7, #20
34015b64:	46bd      	mov	sp, r7
34015b66:	bdf0      	pop	{r4, r5, r6, r7, pc}

34015b68 <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
34015b68:	b5f0      	push	{r4, r5, r6, r7, lr}
34015b6a:	b087      	sub	sp, #28
34015b6c:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34015b6e:	2300      	movs	r3, #0
34015b70:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34015b72:	f7f8 f8ed 	bl	3400dd50 <LL_RCC_PLL2_IsReady>
34015b76:	4603      	mov	r3, r0
34015b78:	2b00      	cmp	r3, #0
34015b7a:	d02a      	beq.n	34015bd2 <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34015b7c:	f7f8 f950 	bl	3400de20 <LL_RCC_PLL2P_IsEnabled>
34015b80:	4603      	mov	r3, r0
34015b82:	2b00      	cmp	r3, #0
34015b84:	d031      	beq.n	34015bea <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34015b86:	f7f8 f8d5 	bl	3400dd34 <LL_RCC_PLL2_GetSource>
34015b8a:	4603      	mov	r3, r0
34015b8c:	4618      	mov	r0, r3
34015b8e:	f000 f911 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015b92:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34015b94:	68bb      	ldr	r3, [r7, #8]
34015b96:	2b00      	cmp	r3, #0
34015b98:	d027      	beq.n	34015bea <HAL_RCCEx_GetPLL2CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL2_GetM();
34015b9a:	f7f8 f911 	bl	3400ddc0 <LL_RCC_PLL2_GetM>
34015b9e:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34015ba0:	687b      	ldr	r3, [r7, #4]
34015ba2:	2b00      	cmp	r3, #0
34015ba4:	d021      	beq.n	34015bea <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
34015ba6:	f7f8 f8fb 	bl	3400dda0 <LL_RCC_PLL2_GetN>
34015baa:	4605      	mov	r5, r0
34015bac:	f7f8 f94c 	bl	3400de48 <LL_RCC_PLL2_GetFRACN>
34015bb0:	4606      	mov	r6, r0
34015bb2:	f7f8 f915 	bl	3400dde0 <LL_RCC_PLL2_GetP1>
34015bb6:	4604      	mov	r4, r0
34015bb8:	f7f8 f922 	bl	3400de00 <LL_RCC_PLL2_GetP2>
34015bbc:	4603      	mov	r3, r0
34015bbe:	9301      	str	r3, [sp, #4]
34015bc0:	9400      	str	r4, [sp, #0]
34015bc2:	4633      	mov	r3, r6
34015bc4:	462a      	mov	r2, r5
34015bc6:	6879      	ldr	r1, [r7, #4]
34015bc8:	68b8      	ldr	r0, [r7, #8]
34015bca:	f000 f951 	bl	34015e70 <RCCEx_CalcPLLFreq>
34015bce:	60f8      	str	r0, [r7, #12]
34015bd0:	e00b      	b.n	34015bea <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
34015bd2:	f7f8 f8d1 	bl	3400dd78 <LL_RCC_PLL2_IsEnabledBypass>
34015bd6:	4603      	mov	r3, r0
34015bd8:	2b00      	cmp	r3, #0
34015bda:	d006      	beq.n	34015bea <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34015bdc:	f7f8 f8aa 	bl	3400dd34 <LL_RCC_PLL2_GetSource>
34015be0:	4603      	mov	r3, r0
34015be2:	4618      	mov	r0, r3
34015be4:	f000 f8e6 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015be8:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34015bea:	68fb      	ldr	r3, [r7, #12]
}
34015bec:	4618      	mov	r0, r3
34015bee:	3714      	adds	r7, #20
34015bf0:	46bd      	mov	sp, r7
34015bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}

34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
34015bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
34015bf6:	b087      	sub	sp, #28
34015bf8:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34015bfa:	2300      	movs	r3, #0
34015bfc:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34015bfe:	f7f8 f93f 	bl	3400de80 <LL_RCC_PLL3_IsReady>
34015c02:	4603      	mov	r3, r0
34015c04:	2b00      	cmp	r3, #0
34015c06:	d02a      	beq.n	34015c5e <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
34015c08:	f7f8 f9a2 	bl	3400df50 <LL_RCC_PLL3P_IsEnabled>
34015c0c:	4603      	mov	r3, r0
34015c0e:	2b00      	cmp	r3, #0
34015c10:	d031      	beq.n	34015c76 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34015c12:	f7f8 f927 	bl	3400de64 <LL_RCC_PLL3_GetSource>
34015c16:	4603      	mov	r3, r0
34015c18:	4618      	mov	r0, r3
34015c1a:	f000 f8cb 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015c1e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34015c20:	68bb      	ldr	r3, [r7, #8]
34015c22:	2b00      	cmp	r3, #0
34015c24:	d027      	beq.n	34015c76 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL3_GetM();
34015c26:	f7f8 f963 	bl	3400def0 <LL_RCC_PLL3_GetM>
34015c2a:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34015c2c:	687b      	ldr	r3, [r7, #4]
34015c2e:	2b00      	cmp	r3, #0
34015c30:	d021      	beq.n	34015c76 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
34015c32:	f7f8 f94d 	bl	3400ded0 <LL_RCC_PLL3_GetN>
34015c36:	4605      	mov	r5, r0
34015c38:	f7f8 f99e 	bl	3400df78 <LL_RCC_PLL3_GetFRACN>
34015c3c:	4606      	mov	r6, r0
34015c3e:	f7f8 f967 	bl	3400df10 <LL_RCC_PLL3_GetP1>
34015c42:	4604      	mov	r4, r0
34015c44:	f7f8 f974 	bl	3400df30 <LL_RCC_PLL3_GetP2>
34015c48:	4603      	mov	r3, r0
34015c4a:	9301      	str	r3, [sp, #4]
34015c4c:	9400      	str	r4, [sp, #0]
34015c4e:	4633      	mov	r3, r6
34015c50:	462a      	mov	r2, r5
34015c52:	6879      	ldr	r1, [r7, #4]
34015c54:	68b8      	ldr	r0, [r7, #8]
34015c56:	f000 f90b 	bl	34015e70 <RCCEx_CalcPLLFreq>
34015c5a:	60f8      	str	r0, [r7, #12]
34015c5c:	e00b      	b.n	34015c76 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
34015c5e:	f7f8 f923 	bl	3400dea8 <LL_RCC_PLL3_IsEnabledBypass>
34015c62:	4603      	mov	r3, r0
34015c64:	2b00      	cmp	r3, #0
34015c66:	d006      	beq.n	34015c76 <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34015c68:	f7f8 f8fc 	bl	3400de64 <LL_RCC_PLL3_GetSource>
34015c6c:	4603      	mov	r3, r0
34015c6e:	4618      	mov	r0, r3
34015c70:	f000 f8a0 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015c74:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34015c76:	68fb      	ldr	r3, [r7, #12]
}
34015c78:	4618      	mov	r0, r3
34015c7a:	3714      	adds	r7, #20
34015c7c:	46bd      	mov	sp, r7
34015c7e:	bdf0      	pop	{r4, r5, r6, r7, pc}

34015c80 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34015c80:	b5f0      	push	{r4, r5, r6, r7, lr}
34015c82:	b087      	sub	sp, #28
34015c84:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34015c86:	2300      	movs	r3, #0
34015c88:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
34015c8a:	f7f8 f991 	bl	3400dfb0 <LL_RCC_PLL4_IsReady>
34015c8e:	4603      	mov	r3, r0
34015c90:	2b00      	cmp	r3, #0
34015c92:	d02a      	beq.n	34015cea <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34015c94:	f7f8 f9f4 	bl	3400e080 <LL_RCC_PLL4P_IsEnabled>
34015c98:	4603      	mov	r3, r0
34015c9a:	2b00      	cmp	r3, #0
34015c9c:	d031      	beq.n	34015d02 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34015c9e:	f7f8 f979 	bl	3400df94 <LL_RCC_PLL4_GetSource>
34015ca2:	4603      	mov	r3, r0
34015ca4:	4618      	mov	r0, r3
34015ca6:	f000 f885 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015caa:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34015cac:	68bb      	ldr	r3, [r7, #8]
34015cae:	2b00      	cmp	r3, #0
34015cb0:	d027      	beq.n	34015d02 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL4_GetM();
34015cb2:	f7f8 f9b5 	bl	3400e020 <LL_RCC_PLL4_GetM>
34015cb6:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34015cb8:	687b      	ldr	r3, [r7, #4]
34015cba:	2b00      	cmp	r3, #0
34015cbc:	d021      	beq.n	34015d02 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34015cbe:	f7f8 f99f 	bl	3400e000 <LL_RCC_PLL4_GetN>
34015cc2:	4605      	mov	r5, r0
34015cc4:	f7f8 f9f0 	bl	3400e0a8 <LL_RCC_PLL4_GetFRACN>
34015cc8:	4606      	mov	r6, r0
34015cca:	f7f8 f9b9 	bl	3400e040 <LL_RCC_PLL4_GetP1>
34015cce:	4604      	mov	r4, r0
34015cd0:	f7f8 f9c6 	bl	3400e060 <LL_RCC_PLL4_GetP2>
34015cd4:	4603      	mov	r3, r0
34015cd6:	9301      	str	r3, [sp, #4]
34015cd8:	9400      	str	r4, [sp, #0]
34015cda:	4633      	mov	r3, r6
34015cdc:	462a      	mov	r2, r5
34015cde:	6879      	ldr	r1, [r7, #4]
34015ce0:	68b8      	ldr	r0, [r7, #8]
34015ce2:	f000 f8c5 	bl	34015e70 <RCCEx_CalcPLLFreq>
34015ce6:	60f8      	str	r0, [r7, #12]
34015ce8:	e00b      	b.n	34015d02 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34015cea:	f7f8 f975 	bl	3400dfd8 <LL_RCC_PLL4_IsEnabledBypass>
34015cee:	4603      	mov	r3, r0
34015cf0:	2b00      	cmp	r3, #0
34015cf2:	d006      	beq.n	34015d02 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34015cf4:	f7f8 f94e 	bl	3400df94 <LL_RCC_PLL4_GetSource>
34015cf8:	4603      	mov	r3, r0
34015cfa:	4618      	mov	r0, r3
34015cfc:	f000 f85a 	bl	34015db4 <RCCEx_GetPLLSourceFreq>
34015d00:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34015d02:	68fb      	ldr	r3, [r7, #12]
}
34015d04:	4618      	mov	r0, r3
34015d06:	3714      	adds	r7, #20
34015d08:	46bd      	mov	sp, r7
34015d0a:	bdf0      	pop	{r4, r5, r6, r7, pc}

34015d0c <RCCEx_GetHCLKFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
34015d0c:	b580      	push	{r7, lr}
34015d0e:	b082      	sub	sp, #8
34015d10:	af00      	add	r7, sp, #0
34015d12:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
34015d14:	f7f7 fb60 	bl	3400d3d8 <LL_RCC_GetAHBPrescaler>
34015d18:	4603      	mov	r3, r0
34015d1a:	0d1b      	lsrs	r3, r3, #20
34015d1c:	f003 0307 	and.w	r3, r3, #7
34015d20:	687a      	ldr	r2, [r7, #4]
34015d22:	fa22 f303 	lsr.w	r3, r2, r3
}
34015d26:	4618      	mov	r0, r3
34015d28:	3708      	adds	r7, #8
34015d2a:	46bd      	mov	sp, r7
34015d2c:	bd80      	pop	{r7, pc}

34015d2e <RCCEx_GetPCLK1Freq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK1Freq(uint32_t HCLK_Frequency)
{
34015d2e:	b580      	push	{r7, lr}
34015d30:	b082      	sub	sp, #8
34015d32:	af00      	add	r7, sp, #0
34015d34:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
34015d36:	f7f7 fb5d 	bl	3400d3f4 <LL_RCC_GetAPB1Prescaler>
34015d3a:	4603      	mov	r3, r0
34015d3c:	f003 0307 	and.w	r3, r3, #7
34015d40:	687a      	ldr	r2, [r7, #4]
34015d42:	fa22 f303 	lsr.w	r3, r2, r3
}
34015d46:	4618      	mov	r0, r3
34015d48:	3708      	adds	r7, #8
34015d4a:	46bd      	mov	sp, r7
34015d4c:	bd80      	pop	{r7, pc}

34015d4e <RCCEx_GetPCLK2Freq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK2Freq(uint32_t HCLK_Frequency)
{
34015d4e:	b580      	push	{r7, lr}
34015d50:	b082      	sub	sp, #8
34015d52:	af00      	add	r7, sp, #0
34015d54:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
34015d56:	f7f7 fb5b 	bl	3400d410 <LL_RCC_GetAPB2Prescaler>
34015d5a:	4603      	mov	r3, r0
34015d5c:	091b      	lsrs	r3, r3, #4
34015d5e:	f003 0307 	and.w	r3, r3, #7
34015d62:	687a      	ldr	r2, [r7, #4]
34015d64:	fa22 f303 	lsr.w	r3, r2, r3
}
34015d68:	4618      	mov	r0, r3
34015d6a:	3708      	adds	r7, #8
34015d6c:	46bd      	mov	sp, r7
34015d6e:	bd80      	pop	{r7, pc}

34015d70 <RCCEx_GetPCLK4Freq>:
  * @brief  Return PCLK4 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK4 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK4Freq(uint32_t HCLK_Frequency)
{
34015d70:	b580      	push	{r7, lr}
34015d72:	b082      	sub	sp, #8
34015d74:	af00      	add	r7, sp, #0
34015d76:	6078      	str	r0, [r7, #4]
  /* PCLK4 clock frequency */
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34015d78:	f7f7 fb58 	bl	3400d42c <LL_RCC_GetAPB4Prescaler>
34015d7c:	4603      	mov	r3, r0
34015d7e:	0b1b      	lsrs	r3, r3, #12
34015d80:	f003 0307 	and.w	r3, r3, #7
34015d84:	687a      	ldr	r2, [r7, #4]
34015d86:	fa22 f303 	lsr.w	r3, r2, r3
}
34015d8a:	4618      	mov	r0, r3
34015d8c:	3708      	adds	r7, #8
34015d8e:	46bd      	mov	sp, r7
34015d90:	bd80      	pop	{r7, pc}

34015d92 <RCCEx_GetPCLK5Freq>:
  * @brief  Return PCLK5 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK5 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK5Freq(uint32_t HCLK_Frequency)
{
34015d92:	b580      	push	{r7, lr}
34015d94:	b082      	sub	sp, #8
34015d96:	af00      	add	r7, sp, #0
34015d98:	6078      	str	r0, [r7, #4]
  /* PCLK5 clock frequency */
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
34015d9a:	f7f7 fb55 	bl	3400d448 <LL_RCC_GetAPB5Prescaler>
34015d9e:	4603      	mov	r3, r0
34015da0:	0c1b      	lsrs	r3, r3, #16
34015da2:	f003 0307 	and.w	r3, r3, #7
34015da6:	687a      	ldr	r2, [r7, #4]
34015da8:	fa22 f303 	lsr.w	r3, r2, r3
}
34015dac:	4618      	mov	r0, r3
34015dae:	3708      	adds	r7, #8
34015db0:	46bd      	mov	sp, r7
34015db2:	bd80      	pop	{r7, pc}

34015db4 <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
34015db4:	b580      	push	{r7, lr}
34015db6:	b084      	sub	sp, #16
34015db8:	af00      	add	r7, sp, #0
34015dba:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34015dbc:	2300      	movs	r3, #0
34015dbe:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34015dc0:	687b      	ldr	r3, [r7, #4]
34015dc2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015dc6:	d039      	beq.n	34015e3c <RCCEx_GetPLLSourceFreq+0x88>
34015dc8:	687b      	ldr	r3, [r7, #4]
34015dca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015dce:	d838      	bhi.n	34015e42 <RCCEx_GetPLLSourceFreq+0x8e>
34015dd0:	687b      	ldr	r3, [r7, #4]
34015dd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015dd6:	d029      	beq.n	34015e2c <RCCEx_GetPLLSourceFreq+0x78>
34015dd8:	687b      	ldr	r3, [r7, #4]
34015dda:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015dde:	d830      	bhi.n	34015e42 <RCCEx_GetPLLSourceFreq+0x8e>
34015de0:	687b      	ldr	r3, [r7, #4]
34015de2:	2b00      	cmp	r3, #0
34015de4:	d004      	beq.n	34015df0 <RCCEx_GetPLLSourceFreq+0x3c>
34015de6:	687b      	ldr	r3, [r7, #4]
34015de8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015dec:	d00e      	beq.n	34015e0c <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34015dee:	e028      	b.n	34015e42 <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34015df0:	f7f7 fa92 	bl	3400d318 <LL_RCC_HSI_IsReady>
34015df4:	4603      	mov	r3, r0
34015df6:	2b00      	cmp	r3, #0
34015df8:	d025      	beq.n	34015e46 <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34015dfa:	f7f7 fa9f 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34015dfe:	4603      	mov	r3, r0
34015e00:	09db      	lsrs	r3, r3, #7
34015e02:	4a16      	ldr	r2, [pc, #88]	@ (34015e5c <RCCEx_GetPLLSourceFreq+0xa8>)
34015e04:	fa22 f303 	lsr.w	r3, r2, r3
34015e08:	60fb      	str	r3, [r7, #12]
      break;
34015e0a:	e01c      	b.n	34015e46 <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34015e0c:	f7f7 faa4 	bl	3400d358 <LL_RCC_MSI_IsReady>
34015e10:	4603      	mov	r3, r0
34015e12:	2b00      	cmp	r3, #0
34015e14:	d019      	beq.n	34015e4a <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34015e16:	f7f7 fab1 	bl	3400d37c <LL_RCC_MSI_GetFrequency>
34015e1a:	4603      	mov	r3, r0
34015e1c:	2b00      	cmp	r3, #0
34015e1e:	d102      	bne.n	34015e26 <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34015e20:	4b0f      	ldr	r3, [pc, #60]	@ (34015e60 <RCCEx_GetPLLSourceFreq+0xac>)
34015e22:	60fb      	str	r3, [r7, #12]
      break;
34015e24:	e011      	b.n	34015e4a <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
34015e26:	4b0f      	ldr	r3, [pc, #60]	@ (34015e64 <RCCEx_GetPLLSourceFreq+0xb0>)
34015e28:	60fb      	str	r3, [r7, #12]
      break;
34015e2a:	e00e      	b.n	34015e4a <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34015e2c:	f7f7 fa62 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
34015e30:	4603      	mov	r3, r0
34015e32:	2b00      	cmp	r3, #0
34015e34:	d00b      	beq.n	34015e4e <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
34015e36:	4b0c      	ldr	r3, [pc, #48]	@ (34015e68 <RCCEx_GetPLLSourceFreq+0xb4>)
34015e38:	60fb      	str	r3, [r7, #12]
      break;
34015e3a:	e008      	b.n	34015e4e <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34015e3c:	4b0b      	ldr	r3, [pc, #44]	@ (34015e6c <RCCEx_GetPLLSourceFreq+0xb8>)
34015e3e:	60fb      	str	r3, [r7, #12]
      break;
34015e40:	e006      	b.n	34015e50 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34015e42:	bf00      	nop
34015e44:	e004      	b.n	34015e50 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34015e46:	bf00      	nop
34015e48:	e002      	b.n	34015e50 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34015e4a:	bf00      	nop
34015e4c:	e000      	b.n	34015e50 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34015e4e:	bf00      	nop
  }

  return pllinputfreq;
34015e50:	68fb      	ldr	r3, [r7, #12]
}
34015e52:	4618      	mov	r0, r3
34015e54:	3710      	adds	r7, #16
34015e56:	46bd      	mov	sp, r7
34015e58:	bd80      	pop	{r7, pc}
34015e5a:	bf00      	nop
34015e5c:	03d09000 	.word	0x03d09000
34015e60:	003d0900 	.word	0x003d0900
34015e64:	00f42400 	.word	0x00f42400
34015e68:	02dc6c00 	.word	0x02dc6c00
34015e6c:	00bb8000 	.word	0x00bb8000

34015e70 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34015e70:	b480      	push	{r7}
34015e72:	b087      	sub	sp, #28
34015e74:	af00      	add	r7, sp, #0
34015e76:	60f8      	str	r0, [r7, #12]
34015e78:	60b9      	str	r1, [r7, #8]
34015e7a:	607a      	str	r2, [r7, #4]
34015e7c:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34015e7e:	68fb      	ldr	r3, [r7, #12]
34015e80:	ee07 3a90 	vmov	s15, r3
34015e84:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34015e88:	687b      	ldr	r3, [r7, #4]
34015e8a:	ee07 3a90 	vmov	s15, r3
34015e8e:	eef8 6a67 	vcvt.f32.u32	s13, s15
34015e92:	683b      	ldr	r3, [r7, #0]
34015e94:	ee07 3a90 	vmov	s15, r3
34015e98:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34015e9c:	eddf 5a19 	vldr	s11, [pc, #100]	@ 34015f04 <RCCEx_CalcPLLFreq+0x94>
34015ea0:	eec6 7a25 	vdiv.f32	s15, s12, s11
34015ea4:	ee76 7aa7 	vadd.f32	s15, s13, s15
34015ea8:	ee67 6a27 	vmul.f32	s13, s14, s15
34015eac:	68bb      	ldr	r3, [r7, #8]
34015eae:	ee07 3a90 	vmov	s15, r3
34015eb2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34015eb6:	eec6 7a87 	vdiv.f32	s15, s13, s14
34015eba:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
34015ebe:	6a3b      	ldr	r3, [r7, #32]
34015ec0:	ee07 3a90 	vmov	s15, r3
34015ec4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34015ec8:	edd7 6a05 	vldr	s13, [r7, #20]
34015ecc:	eec6 7a87 	vdiv.f32	s15, s13, s14
34015ed0:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
34015ed4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34015ed6:	ee07 3a90 	vmov	s15, r3
34015eda:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34015ede:	edd7 6a05 	vldr	s13, [r7, #20]
34015ee2:	eec6 7a87 	vdiv.f32	s15, s13, s14
34015ee6:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34015eea:	edd7 7a05 	vldr	s15, [r7, #20]
34015eee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34015ef2:	ee17 3a90 	vmov	r3, s15
}
34015ef6:	4618      	mov	r0, r3
34015ef8:	371c      	adds	r7, #28
34015efa:	46bd      	mov	sp, r7
34015efc:	f85d 7b04 	ldr.w	r7, [sp], #4
34015f00:	4770      	bx	lr
34015f02:	bf00      	nop
34015f04:	4b800000 	.word	0x4b800000

34015f08 <RCCEx_GetADCCLKFreq>:
  *         @arg @ref RCCEx_ADC_Clock_Source
  * @retval ADC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADCCLKFreq(uint32_t ADCxSource)
{
34015f08:	b590      	push	{r4, r7, lr}
34015f0a:	b085      	sub	sp, #20
34015f0c:	af00      	add	r7, sp, #0
34015f0e:	6078      	str	r0, [r7, #4]
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34015f10:	2300      	movs	r3, #0
34015f12:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADCClockSource(ADCxSource))
34015f14:	6878      	ldr	r0, [r7, #4]
34015f16:	f7f7 fcb5 	bl	3400d884 <LL_RCC_GetADCClockSource>
34015f1a:	4603      	mov	r3, r0
34015f1c:	2b70      	cmp	r3, #112	@ 0x70
34015f1e:	f000 80d1 	beq.w	340160c4 <RCCEx_GetADCCLKFreq+0x1bc>
34015f22:	2b70      	cmp	r3, #112	@ 0x70
34015f24:	f200 80d8 	bhi.w	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
34015f28:	2b60      	cmp	r3, #96	@ 0x60
34015f2a:	f000 80c8 	beq.w	340160be <RCCEx_GetADCCLKFreq+0x1b6>
34015f2e:	2b60      	cmp	r3, #96	@ 0x60
34015f30:	f200 80d2 	bhi.w	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
34015f34:	2b50      	cmp	r3, #80	@ 0x50
34015f36:	f000 80ac 	beq.w	34016092 <RCCEx_GetADCCLKFreq+0x18a>
34015f3a:	2b50      	cmp	r3, #80	@ 0x50
34015f3c:	f200 80cc 	bhi.w	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
34015f40:	2b40      	cmp	r3, #64	@ 0x40
34015f42:	f000 80b4 	beq.w	340160ae <RCCEx_GetADCCLKFreq+0x1a6>
34015f46:	2b40      	cmp	r3, #64	@ 0x40
34015f48:	f200 80c6 	bhi.w	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
34015f4c:	2b30      	cmp	r3, #48	@ 0x30
34015f4e:	d05d      	beq.n	3401600c <RCCEx_GetADCCLKFreq+0x104>
34015f50:	2b30      	cmp	r3, #48	@ 0x30
34015f52:	f200 80c1 	bhi.w	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
34015f56:	2b20      	cmp	r3, #32
34015f58:	d014      	beq.n	34015f84 <RCCEx_GetADCCLKFreq+0x7c>
34015f5a:	2b20      	cmp	r3, #32
34015f5c:	f200 80bc 	bhi.w	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
34015f60:	2b00      	cmp	r3, #0
34015f62:	d002      	beq.n	34015f6a <RCCEx_GetADCCLKFreq+0x62>
34015f64:	2b10      	cmp	r3, #16
34015f66:	d008      	beq.n	34015f7a <RCCEx_GetADCCLKFreq+0x72>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34015f68:	e0b6      	b.n	340160d8 <RCCEx_GetADCCLKFreq+0x1d0>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34015f6a:	f7f6 fdd7 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34015f6e:	4603      	mov	r3, r0
34015f70:	4618      	mov	r0, r3
34015f72:	f7ff fecb 	bl	34015d0c <RCCEx_GetHCLKFreq>
34015f76:	60f8      	str	r0, [r7, #12]
      break;
34015f78:	e0b7      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34015f7a:	2007      	movs	r0, #7
34015f7c:	f000 f9b2 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34015f80:	60f8      	str	r0, [r7, #12]
      break;
34015f82:	e0b2      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34015f84:	f7f8 f96c 	bl	3400e260 <LL_RCC_IC7_IsEnabled>
34015f88:	4603      	mov	r3, r0
34015f8a:	2b00      	cmp	r3, #0
34015f8c:	f000 80a6 	beq.w	340160dc <RCCEx_GetADCCLKFreq+0x1d4>
        ic_divider = LL_RCC_IC7_GetDivider();
34015f90:	f7f8 f988 	bl	3400e2a4 <LL_RCC_IC7_GetDivider>
34015f94:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34015f96:	f7f8 f977 	bl	3400e288 <LL_RCC_IC7_GetSource>
34015f9a:	4603      	mov	r3, r0
34015f9c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015fa0:	d029      	beq.n	34015ff6 <RCCEx_GetADCCLKFreq+0xee>
34015fa2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015fa6:	d82f      	bhi.n	34016008 <RCCEx_GetADCCLKFreq+0x100>
34015fa8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015fac:	d01a      	beq.n	34015fe4 <RCCEx_GetADCCLKFreq+0xdc>
34015fae:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015fb2:	d829      	bhi.n	34016008 <RCCEx_GetADCCLKFreq+0x100>
34015fb4:	2b00      	cmp	r3, #0
34015fb6:	d003      	beq.n	34015fc0 <RCCEx_GetADCCLKFreq+0xb8>
34015fb8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015fbc:	d009      	beq.n	34015fd2 <RCCEx_GetADCCLKFreq+0xca>
            break;
34015fbe:	e023      	b.n	34016008 <RCCEx_GetADCCLKFreq+0x100>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015fc0:	f7ff fd8c 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34015fc4:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34015fc6:	68fa      	ldr	r2, [r7, #12]
34015fc8:	68bb      	ldr	r3, [r7, #8]
34015fca:	fbb2 f3f3 	udiv	r3, r2, r3
34015fce:	60fb      	str	r3, [r7, #12]
            break;
34015fd0:	e01b      	b.n	3401600a <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015fd2:	f7ff fdc9 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34015fd6:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34015fd8:	68fa      	ldr	r2, [r7, #12]
34015fda:	68bb      	ldr	r3, [r7, #8]
34015fdc:	fbb2 f3f3 	udiv	r3, r2, r3
34015fe0:	60fb      	str	r3, [r7, #12]
            break;
34015fe2:	e012      	b.n	3401600a <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015fe4:	f7ff fe06 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34015fe8:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34015fea:	68fa      	ldr	r2, [r7, #12]
34015fec:	68bb      	ldr	r3, [r7, #8]
34015fee:	fbb2 f3f3 	udiv	r3, r2, r3
34015ff2:	60fb      	str	r3, [r7, #12]
            break;
34015ff4:	e009      	b.n	3401600a <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015ff6:	f7ff fe43 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34015ffa:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34015ffc:	68fa      	ldr	r2, [r7, #12]
34015ffe:	68bb      	ldr	r3, [r7, #8]
34016000:	fbb2 f3f3 	udiv	r3, r2, r3
34016004:	60fb      	str	r3, [r7, #12]
            break;
34016006:	e000      	b.n	3401600a <RCCEx_GetADCCLKFreq+0x102>
            break;
34016008:	bf00      	nop
      break;
3401600a:	e067      	b.n	340160dc <RCCEx_GetADCCLKFreq+0x1d4>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3401600c:	f7f8 f968 	bl	3400e2e0 <LL_RCC_IC8_IsEnabled>
34016010:	4603      	mov	r3, r0
34016012:	2b00      	cmp	r3, #0
34016014:	d064      	beq.n	340160e0 <RCCEx_GetADCCLKFreq+0x1d8>
        ic_divider = LL_RCC_IC8_GetDivider();
34016016:	f7f8 f985 	bl	3400e324 <LL_RCC_IC8_GetDivider>
3401601a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3401601c:	f7f8 f974 	bl	3400e308 <LL_RCC_IC8_GetSource>
34016020:	4603      	mov	r3, r0
34016022:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016026:	d029      	beq.n	3401607c <RCCEx_GetADCCLKFreq+0x174>
34016028:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401602c:	d82f      	bhi.n	3401608e <RCCEx_GetADCCLKFreq+0x186>
3401602e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016032:	d01a      	beq.n	3401606a <RCCEx_GetADCCLKFreq+0x162>
34016034:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016038:	d829      	bhi.n	3401608e <RCCEx_GetADCCLKFreq+0x186>
3401603a:	2b00      	cmp	r3, #0
3401603c:	d003      	beq.n	34016046 <RCCEx_GetADCCLKFreq+0x13e>
3401603e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016042:	d009      	beq.n	34016058 <RCCEx_GetADCCLKFreq+0x150>
            break;
34016044:	e023      	b.n	3401608e <RCCEx_GetADCCLKFreq+0x186>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016046:	f7ff fd49 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401604a:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
3401604c:	68fa      	ldr	r2, [r7, #12]
3401604e:	68bb      	ldr	r3, [r7, #8]
34016050:	fbb2 f3f3 	udiv	r3, r2, r3
34016054:	60fb      	str	r3, [r7, #12]
            break;
34016056:	e01b      	b.n	34016090 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016058:	f7ff fd86 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401605c:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
3401605e:	68fa      	ldr	r2, [r7, #12]
34016060:	68bb      	ldr	r3, [r7, #8]
34016062:	fbb2 f3f3 	udiv	r3, r2, r3
34016066:	60fb      	str	r3, [r7, #12]
            break;
34016068:	e012      	b.n	34016090 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401606a:	f7ff fdc3 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401606e:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34016070:	68fa      	ldr	r2, [r7, #12]
34016072:	68bb      	ldr	r3, [r7, #8]
34016074:	fbb2 f3f3 	udiv	r3, r2, r3
34016078:	60fb      	str	r3, [r7, #12]
            break;
3401607a:	e009      	b.n	34016090 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401607c:	f7ff fe00 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016080:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34016082:	68fa      	ldr	r2, [r7, #12]
34016084:	68bb      	ldr	r3, [r7, #8]
34016086:	fbb2 f3f3 	udiv	r3, r2, r3
3401608a:	60fb      	str	r3, [r7, #12]
            break;
3401608c:	e000      	b.n	34016090 <RCCEx_GetADCCLKFreq+0x188>
            break;
3401608e:	bf00      	nop
      break;
34016090:	e026      	b.n	340160e0 <RCCEx_GetADCCLKFreq+0x1d8>
      if (LL_RCC_HSI_IsReady() != 0U)
34016092:	f7f7 f941 	bl	3400d318 <LL_RCC_HSI_IsReady>
34016096:	4603      	mov	r3, r0
34016098:	2b00      	cmp	r3, #0
3401609a:	d023      	beq.n	340160e4 <RCCEx_GetADCCLKFreq+0x1dc>
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3401609c:	f7f7 f94e 	bl	3400d33c <LL_RCC_HSI_GetDivider>
340160a0:	4603      	mov	r3, r0
340160a2:	09db      	lsrs	r3, r3, #7
340160a4:	4a16      	ldr	r2, [pc, #88]	@ (34016100 <RCCEx_GetADCCLKFreq+0x1f8>)
340160a6:	fa22 f303 	lsr.w	r3, r2, r3
340160aa:	60fb      	str	r3, [r7, #12]
      break;
340160ac:	e01a      	b.n	340160e4 <RCCEx_GetADCCLKFreq+0x1dc>
      if (LL_RCC_MSI_IsReady() != 0U)
340160ae:	f7f7 f953 	bl	3400d358 <LL_RCC_MSI_IsReady>
340160b2:	4603      	mov	r3, r0
340160b4:	2b00      	cmp	r3, #0
340160b6:	d017      	beq.n	340160e8 <RCCEx_GetADCCLKFreq+0x1e0>
        adc_frequency = MSI_VALUE;
340160b8:	4b12      	ldr	r3, [pc, #72]	@ (34016104 <RCCEx_GetADCCLKFreq+0x1fc>)
340160ba:	60fb      	str	r3, [r7, #12]
      break;
340160bc:	e014      	b.n	340160e8 <RCCEx_GetADCCLKFreq+0x1e0>
      adc_frequency = EXTERNAL_CLOCK_VALUE;
340160be:	4b12      	ldr	r3, [pc, #72]	@ (34016108 <RCCEx_GetADCCLKFreq+0x200>)
340160c0:	60fb      	str	r3, [r7, #12]
      break;
340160c2:	e012      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
340160c4:	f7f6 fd2a 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
340160c8:	4604      	mov	r4, r0
340160ca:	f7f7 fd8d 	bl	3400dbe8 <LL_RCC_GetTIMPrescaler>
340160ce:	4603      	mov	r3, r0
340160d0:	fa24 f303 	lsr.w	r3, r4, r3
340160d4:	60fb      	str	r3, [r7, #12]
      break;
340160d6:	e008      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      break;
340160d8:	bf00      	nop
340160da:	e006      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      break;
340160dc:	bf00      	nop
340160de:	e004      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      break;
340160e0:	bf00      	nop
340160e2:	e002      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      break;
340160e4:	bf00      	nop
340160e6:	e000      	b.n	340160ea <RCCEx_GetADCCLKFreq+0x1e2>
      break;
340160e8:	bf00      	nop
  }

  return (adc_frequency / __HAL_RCC_GET_ADC_DIVIDER());
340160ea:	f7f7 f9e5 	bl	3400d4b8 <LL_RCC_GetADCPrescaler>
340160ee:	4603      	mov	r3, r0
340160f0:	3301      	adds	r3, #1
340160f2:	68fa      	ldr	r2, [r7, #12]
340160f4:	fbb2 f3f3 	udiv	r3, r2, r3
}
340160f8:	4618      	mov	r0, r3
340160fa:	3714      	adds	r7, #20
340160fc:	46bd      	mov	sp, r7
340160fe:	bd90      	pop	{r4, r7, pc}
34016100:	03d09000 	.word	0x03d09000
34016104:	003d0900 	.word	0x003d0900
34016108:	00bb8000 	.word	0x00bb8000

3401610c <RCCEx_GetADFCLKFreq>:
  *         @arg @ref RCCEx_ADF1_Clock_Source
  * @retval ADF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADFCLKFreq(uint32_t ADFxSource)
{
3401610c:	b590      	push	{r4, r7, lr}
3401610e:	b085      	sub	sp, #20
34016110:	af00      	add	r7, sp, #0
34016112:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34016114:	2300      	movs	r3, #0
34016116:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADFClockSource(ADFxSource))
34016118:	6878      	ldr	r0, [r7, #4]
3401611a:	f7f7 fbc5 	bl	3400d8a8 <LL_RCC_GetADFClockSource>
3401611e:	4603      	mov	r3, r0
34016120:	2b07      	cmp	r3, #7
34016122:	f200 80ca 	bhi.w	340162ba <RCCEx_GetADFCLKFreq+0x1ae>
34016126:	a201      	add	r2, pc, #4	@ (adr r2, 3401612c <RCCEx_GetADFCLKFreq+0x20>)
34016128:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401612c:	3401614d 	.word	0x3401614d
34016130:	3401615d 	.word	0x3401615d
34016134:	34016167 	.word	0x34016167
34016138:	340161ef 	.word	0x340161ef
3401613c:	34016291 	.word	0x34016291
34016140:	34016275 	.word	0x34016275
34016144:	340162a1 	.word	0x340162a1
34016148:	340162a7 	.word	0x340162a7
  {
    case LL_RCC_ADF1_CLKSOURCE_HCLK:
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3401614c:	f7f6 fce6 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016150:	4603      	mov	r3, r0
34016152:	4618      	mov	r0, r3
34016154:	f7ff fdda 	bl	34015d0c <RCCEx_GetHCLKFreq>
34016158:	60f8      	str	r0, [r7, #12]
      break;
3401615a:	e0b7      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_CLKP:
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401615c:	2007      	movs	r0, #7
3401615e:	f000 f8c1 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34016162:	60f8      	str	r0, [r7, #12]
      break;
34016164:	e0b2      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34016166:	f7f8 f87b 	bl	3400e260 <LL_RCC_IC7_IsEnabled>
3401616a:	4603      	mov	r3, r0
3401616c:	2b00      	cmp	r3, #0
3401616e:	f000 80a6 	beq.w	340162be <RCCEx_GetADFCLKFreq+0x1b2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34016172:	f7f8 f897 	bl	3400e2a4 <LL_RCC_IC7_GetDivider>
34016176:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34016178:	f7f8 f886 	bl	3400e288 <LL_RCC_IC7_GetSource>
3401617c:	4603      	mov	r3, r0
3401617e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016182:	d029      	beq.n	340161d8 <RCCEx_GetADFCLKFreq+0xcc>
34016184:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016188:	d82f      	bhi.n	340161ea <RCCEx_GetADFCLKFreq+0xde>
3401618a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401618e:	d01a      	beq.n	340161c6 <RCCEx_GetADFCLKFreq+0xba>
34016190:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016194:	d829      	bhi.n	340161ea <RCCEx_GetADFCLKFreq+0xde>
34016196:	2b00      	cmp	r3, #0
34016198:	d003      	beq.n	340161a2 <RCCEx_GetADFCLKFreq+0x96>
3401619a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401619e:	d009      	beq.n	340161b4 <RCCEx_GetADFCLKFreq+0xa8>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340161a0:	e023      	b.n	340161ea <RCCEx_GetADFCLKFreq+0xde>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340161a2:	f7ff fc9b 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340161a6:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340161a8:	68fa      	ldr	r2, [r7, #12]
340161aa:	68bb      	ldr	r3, [r7, #8]
340161ac:	fbb2 f3f3 	udiv	r3, r2, r3
340161b0:	60fb      	str	r3, [r7, #12]
            break;
340161b2:	e01b      	b.n	340161ec <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340161b4:	f7ff fcd8 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340161b8:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340161ba:	68fa      	ldr	r2, [r7, #12]
340161bc:	68bb      	ldr	r3, [r7, #8]
340161be:	fbb2 f3f3 	udiv	r3, r2, r3
340161c2:	60fb      	str	r3, [r7, #12]
            break;
340161c4:	e012      	b.n	340161ec <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340161c6:	f7ff fd15 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340161ca:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340161cc:	68fa      	ldr	r2, [r7, #12]
340161ce:	68bb      	ldr	r3, [r7, #8]
340161d0:	fbb2 f3f3 	udiv	r3, r2, r3
340161d4:	60fb      	str	r3, [r7, #12]
            break;
340161d6:	e009      	b.n	340161ec <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340161d8:	f7ff fd52 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340161dc:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340161de:	68fa      	ldr	r2, [r7, #12]
340161e0:	68bb      	ldr	r3, [r7, #8]
340161e2:	fbb2 f3f3 	udiv	r3, r2, r3
340161e6:	60fb      	str	r3, [r7, #12]
            break;
340161e8:	e000      	b.n	340161ec <RCCEx_GetADFCLKFreq+0xe0>
            break;
340161ea:	bf00      	nop
        }
      }
      break;
340161ec:	e067      	b.n	340162be <RCCEx_GetADFCLKFreq+0x1b2>

    case LL_RCC_ADF1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
340161ee:	f7f8 f877 	bl	3400e2e0 <LL_RCC_IC8_IsEnabled>
340161f2:	4603      	mov	r3, r0
340161f4:	2b00      	cmp	r3, #0
340161f6:	d064      	beq.n	340162c2 <RCCEx_GetADFCLKFreq+0x1b6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
340161f8:	f7f8 f894 	bl	3400e324 <LL_RCC_IC8_GetDivider>
340161fc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
340161fe:	f7f8 f883 	bl	3400e308 <LL_RCC_IC8_GetSource>
34016202:	4603      	mov	r3, r0
34016204:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016208:	d029      	beq.n	3401625e <RCCEx_GetADFCLKFreq+0x152>
3401620a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401620e:	d82f      	bhi.n	34016270 <RCCEx_GetADFCLKFreq+0x164>
34016210:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016214:	d01a      	beq.n	3401624c <RCCEx_GetADFCLKFreq+0x140>
34016216:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401621a:	d829      	bhi.n	34016270 <RCCEx_GetADFCLKFreq+0x164>
3401621c:	2b00      	cmp	r3, #0
3401621e:	d003      	beq.n	34016228 <RCCEx_GetADFCLKFreq+0x11c>
34016220:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016224:	d009      	beq.n	3401623a <RCCEx_GetADFCLKFreq+0x12e>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016226:	e023      	b.n	34016270 <RCCEx_GetADFCLKFreq+0x164>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016228:	f7ff fc58 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401622c:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3401622e:	68fa      	ldr	r2, [r7, #12]
34016230:	68bb      	ldr	r3, [r7, #8]
34016232:	fbb2 f3f3 	udiv	r3, r2, r3
34016236:	60fb      	str	r3, [r7, #12]
            break;
34016238:	e01b      	b.n	34016272 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401623a:	f7ff fc95 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401623e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34016240:	68fa      	ldr	r2, [r7, #12]
34016242:	68bb      	ldr	r3, [r7, #8]
34016244:	fbb2 f3f3 	udiv	r3, r2, r3
34016248:	60fb      	str	r3, [r7, #12]
            break;
3401624a:	e012      	b.n	34016272 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401624c:	f7ff fcd2 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016250:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34016252:	68fa      	ldr	r2, [r7, #12]
34016254:	68bb      	ldr	r3, [r7, #8]
34016256:	fbb2 f3f3 	udiv	r3, r2, r3
3401625a:	60fb      	str	r3, [r7, #12]
            break;
3401625c:	e009      	b.n	34016272 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401625e:	f7ff fd0f 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016262:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34016264:	68fa      	ldr	r2, [r7, #12]
34016266:	68bb      	ldr	r3, [r7, #8]
34016268:	fbb2 f3f3 	udiv	r3, r2, r3
3401626c:	60fb      	str	r3, [r7, #12]
            break;
3401626e:	e000      	b.n	34016272 <RCCEx_GetADFCLKFreq+0x166>
            break;
34016270:	bf00      	nop
        }
      }
      break;
34016272:	e026      	b.n	340162c2 <RCCEx_GetADFCLKFreq+0x1b6>

    case LL_RCC_ADF1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34016274:	f7f7 f850 	bl	3400d318 <LL_RCC_HSI_IsReady>
34016278:	4603      	mov	r3, r0
3401627a:	2b00      	cmp	r3, #0
3401627c:	d023      	beq.n	340162c6 <RCCEx_GetADFCLKFreq+0x1ba>
      {
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3401627e:	f7f7 f85d 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34016282:	4603      	mov	r3, r0
34016284:	09db      	lsrs	r3, r3, #7
34016286:	4a14      	ldr	r2, [pc, #80]	@ (340162d8 <RCCEx_GetADFCLKFreq+0x1cc>)
34016288:	fa22 f303 	lsr.w	r3, r2, r3
3401628c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401628e:	e01a      	b.n	340162c6 <RCCEx_GetADFCLKFreq+0x1ba>

    case LL_RCC_ADF1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34016290:	f7f7 f862 	bl	3400d358 <LL_RCC_MSI_IsReady>
34016294:	4603      	mov	r3, r0
34016296:	2b00      	cmp	r3, #0
34016298:	d017      	beq.n	340162ca <RCCEx_GetADFCLKFreq+0x1be>
      {
        adf_frequency = MSI_VALUE;
3401629a:	4b10      	ldr	r3, [pc, #64]	@ (340162dc <RCCEx_GetADFCLKFreq+0x1d0>)
3401629c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401629e:	e014      	b.n	340162ca <RCCEx_GetADFCLKFreq+0x1be>

    case LL_RCC_ADF1_CLKSOURCE_I2S_CKIN:
      adf_frequency = EXTERNAL_CLOCK_VALUE;
340162a0:	4b0f      	ldr	r3, [pc, #60]	@ (340162e0 <RCCEx_GetADFCLKFreq+0x1d4>)
340162a2:	60fb      	str	r3, [r7, #12]
      break;
340162a4:	e012      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_TIMG:
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
340162a6:	f7f6 fc39 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
340162aa:	4604      	mov	r4, r0
340162ac:	f7f7 fc9c 	bl	3400dbe8 <LL_RCC_GetTIMPrescaler>
340162b0:	4603      	mov	r3, r0
340162b2:	fa24 f303 	lsr.w	r3, r4, r3
340162b6:	60fb      	str	r3, [r7, #12]
      break;
340162b8:	e008      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>

    default:
      /* Unexpected case */
      break;
340162ba:	bf00      	nop
340162bc:	e006      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340162be:	bf00      	nop
340162c0:	e004      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340162c2:	bf00      	nop
340162c4:	e002      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340162c6:	bf00      	nop
340162c8:	e000      	b.n	340162cc <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340162ca:	bf00      	nop
  }

  return adf_frequency;
340162cc:	68fb      	ldr	r3, [r7, #12]
}
340162ce:	4618      	mov	r0, r3
340162d0:	3714      	adds	r7, #20
340162d2:	46bd      	mov	sp, r7
340162d4:	bd90      	pop	{r4, r7, pc}
340162d6:	bf00      	nop
340162d8:	03d09000 	.word	0x03d09000
340162dc:	003d0900 	.word	0x003d0900
340162e0:	00bb8000 	.word	0x00bb8000

340162e4 <RCCEx_GetCLKPCLKFreq>:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
{
340162e4:	b580      	push	{r7, lr}
340162e6:	b084      	sub	sp, #16
340162e8:	af00      	add	r7, sp, #0
340162ea:	6078      	str	r0, [r7, #4]
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
340162ec:	2300      	movs	r3, #0
340162ee:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
340162f0:	f7f8 faf6 	bl	3400e8e0 <LL_RCC_CLKP_IsEnabled>
340162f4:	4603      	mov	r3, r0
340162f6:	2b01      	cmp	r3, #1
340162f8:	f040 81a5 	bne.w	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
340162fc:	6878      	ldr	r0, [r7, #4]
340162fe:	f7f7 fae5 	bl	3400d8cc <LL_RCC_GetCLKPClockSource>
34016302:	4603      	mov	r3, r0
34016304:	2b07      	cmp	r3, #7
34016306:	f200 818d 	bhi.w	34016624 <RCCEx_GetCLKPCLKFreq+0x340>
3401630a:	a201      	add	r2, pc, #4	@ (adr r2, 34016310 <RCCEx_GetCLKPCLKFreq+0x2c>)
3401630c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34016310:	34016331 	.word	0x34016331
34016314:	3401634f 	.word	0x3401634f
34016318:	34016361 	.word	0x34016361
3401631c:	3401650b 	.word	0x3401650b
34016320:	34016373 	.word	0x34016373
34016324:	340163fb 	.word	0x340163fb
34016328:	34016483 	.word	0x34016483
3401632c:	34016593 	.word	0x34016593
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
34016330:	f7f6 fff2 	bl	3400d318 <LL_RCC_HSI_IsReady>
34016334:	4603      	mov	r3, r0
34016336:	2b00      	cmp	r3, #0
34016338:	f000 8176 	beq.w	34016628 <RCCEx_GetCLKPCLKFreq+0x344>
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3401633c:	f7f6 fffe 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34016340:	4603      	mov	r3, r0
34016342:	09db      	lsrs	r3, r3, #7
34016344:	4aa1      	ldr	r2, [pc, #644]	@ (340165cc <RCCEx_GetCLKPCLKFreq+0x2e8>)
34016346:	fa22 f303 	lsr.w	r3, r2, r3
3401634a:	60fb      	str	r3, [r7, #12]
        }
        break;
3401634c:	e16c      	b.n	34016628 <RCCEx_GetCLKPCLKFreq+0x344>

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
3401634e:	f7f7 f803 	bl	3400d358 <LL_RCC_MSI_IsReady>
34016352:	4603      	mov	r3, r0
34016354:	2b00      	cmp	r3, #0
34016356:	f000 8169 	beq.w	3401662c <RCCEx_GetCLKPCLKFreq+0x348>
        {
          clkp_frequency = MSI_VALUE;
3401635a:	4b9d      	ldr	r3, [pc, #628]	@ (340165d0 <RCCEx_GetCLKPCLKFreq+0x2ec>)
3401635c:	60fb      	str	r3, [r7, #12]
        }
        break;
3401635e:	e165      	b.n	3401662c <RCCEx_GetCLKPCLKFreq+0x348>

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
34016360:	f7f6 ffc8 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
34016364:	4603      	mov	r3, r0
34016366:	2b00      	cmp	r3, #0
34016368:	f000 8162 	beq.w	34016630 <RCCEx_GetCLKPCLKFreq+0x34c>
        {
          clkp_frequency = HSE_VALUE;
3401636c:	4b99      	ldr	r3, [pc, #612]	@ (340165d4 <RCCEx_GetCLKPCLKFreq+0x2f0>)
3401636e:	60fb      	str	r3, [r7, #12]
        }
        break;
34016370:	e15e      	b.n	34016630 <RCCEx_GetCLKPCLKFreq+0x34c>

      case LL_RCC_CLKP_CLKSOURCE_IC5:
        if (LL_RCC_IC5_IsEnabled() != 0U)
34016372:	f7f7 ff35 	bl	3400e1e0 <LL_RCC_IC5_IsEnabled>
34016376:	4603      	mov	r3, r0
34016378:	2b00      	cmp	r3, #0
3401637a:	f000 815b 	beq.w	34016634 <RCCEx_GetCLKPCLKFreq+0x350>
        {
          ic_divider = LL_RCC_IC5_GetDivider();
3401637e:	f7f7 ff51 	bl	3400e224 <LL_RCC_IC5_GetDivider>
34016382:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC5_GetSource())
34016384:	f7f7 ff40 	bl	3400e208 <LL_RCC_IC5_GetSource>
34016388:	4603      	mov	r3, r0
3401638a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401638e:	d029      	beq.n	340163e4 <RCCEx_GetCLKPCLKFreq+0x100>
34016390:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016394:	d82f      	bhi.n	340163f6 <RCCEx_GetCLKPCLKFreq+0x112>
34016396:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401639a:	d01a      	beq.n	340163d2 <RCCEx_GetCLKPCLKFreq+0xee>
3401639c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340163a0:	d829      	bhi.n	340163f6 <RCCEx_GetCLKPCLKFreq+0x112>
340163a2:	2b00      	cmp	r3, #0
340163a4:	d003      	beq.n	340163ae <RCCEx_GetCLKPCLKFreq+0xca>
340163a6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340163aa:	d009      	beq.n	340163c0 <RCCEx_GetCLKPCLKFreq+0xdc>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340163ac:	e023      	b.n	340163f6 <RCCEx_GetCLKPCLKFreq+0x112>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340163ae:	f7ff fb95 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340163b2:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340163b4:	68fa      	ldr	r2, [r7, #12]
340163b6:	68bb      	ldr	r3, [r7, #8]
340163b8:	fbb2 f3f3 	udiv	r3, r2, r3
340163bc:	60fb      	str	r3, [r7, #12]
              break;
340163be:	e01b      	b.n	340163f8 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340163c0:	f7ff fbd2 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340163c4:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340163c6:	68fa      	ldr	r2, [r7, #12]
340163c8:	68bb      	ldr	r3, [r7, #8]
340163ca:	fbb2 f3f3 	udiv	r3, r2, r3
340163ce:	60fb      	str	r3, [r7, #12]
              break;
340163d0:	e012      	b.n	340163f8 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340163d2:	f7ff fc0f 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340163d6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340163d8:	68fa      	ldr	r2, [r7, #12]
340163da:	68bb      	ldr	r3, [r7, #8]
340163dc:	fbb2 f3f3 	udiv	r3, r2, r3
340163e0:	60fb      	str	r3, [r7, #12]
              break;
340163e2:	e009      	b.n	340163f8 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340163e4:	f7ff fc4c 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340163e8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340163ea:	68fa      	ldr	r2, [r7, #12]
340163ec:	68bb      	ldr	r3, [r7, #8]
340163ee:	fbb2 f3f3 	udiv	r3, r2, r3
340163f2:	60fb      	str	r3, [r7, #12]
              break;
340163f4:	e000      	b.n	340163f8 <RCCEx_GetCLKPCLKFreq+0x114>
              break;
340163f6:	bf00      	nop
          }
        }
        break;
340163f8:	e11c      	b.n	34016634 <RCCEx_GetCLKPCLKFreq+0x350>

      case LL_RCC_CLKP_CLKSOURCE_IC10:
        if (LL_RCC_IC10_IsEnabled() != 0U)
340163fa:	f7f7 fff1 	bl	3400e3e0 <LL_RCC_IC10_IsEnabled>
340163fe:	4603      	mov	r3, r0
34016400:	2b00      	cmp	r3, #0
34016402:	f000 8119 	beq.w	34016638 <RCCEx_GetCLKPCLKFreq+0x354>
        {
          ic_divider = LL_RCC_IC10_GetDivider();
34016406:	f7f8 f80d 	bl	3400e424 <LL_RCC_IC10_GetDivider>
3401640a:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC10_GetSource())
3401640c:	f7f7 fffc 	bl	3400e408 <LL_RCC_IC10_GetSource>
34016410:	4603      	mov	r3, r0
34016412:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016416:	d029      	beq.n	3401646c <RCCEx_GetCLKPCLKFreq+0x188>
34016418:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401641c:	d82f      	bhi.n	3401647e <RCCEx_GetCLKPCLKFreq+0x19a>
3401641e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016422:	d01a      	beq.n	3401645a <RCCEx_GetCLKPCLKFreq+0x176>
34016424:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016428:	d829      	bhi.n	3401647e <RCCEx_GetCLKPCLKFreq+0x19a>
3401642a:	2b00      	cmp	r3, #0
3401642c:	d003      	beq.n	34016436 <RCCEx_GetCLKPCLKFreq+0x152>
3401642e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016432:	d009      	beq.n	34016448 <RCCEx_GetCLKPCLKFreq+0x164>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34016434:	e023      	b.n	3401647e <RCCEx_GetCLKPCLKFreq+0x19a>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016436:	f7ff fb51 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401643a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401643c:	68fa      	ldr	r2, [r7, #12]
3401643e:	68bb      	ldr	r3, [r7, #8]
34016440:	fbb2 f3f3 	udiv	r3, r2, r3
34016444:	60fb      	str	r3, [r7, #12]
              break;
34016446:	e01b      	b.n	34016480 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016448:	f7ff fb8e 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401644c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401644e:	68fa      	ldr	r2, [r7, #12]
34016450:	68bb      	ldr	r3, [r7, #8]
34016452:	fbb2 f3f3 	udiv	r3, r2, r3
34016456:	60fb      	str	r3, [r7, #12]
              break;
34016458:	e012      	b.n	34016480 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401645a:	f7ff fbcb 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401645e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34016460:	68fa      	ldr	r2, [r7, #12]
34016462:	68bb      	ldr	r3, [r7, #8]
34016464:	fbb2 f3f3 	udiv	r3, r2, r3
34016468:	60fb      	str	r3, [r7, #12]
              break;
3401646a:	e009      	b.n	34016480 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401646c:	f7ff fc08 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016470:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34016472:	68fa      	ldr	r2, [r7, #12]
34016474:	68bb      	ldr	r3, [r7, #8]
34016476:	fbb2 f3f3 	udiv	r3, r2, r3
3401647a:	60fb      	str	r3, [r7, #12]
              break;
3401647c:	e000      	b.n	34016480 <RCCEx_GetCLKPCLKFreq+0x19c>
              break;
3401647e:	bf00      	nop
          }
        }
        break;
34016480:	e0da      	b.n	34016638 <RCCEx_GetCLKPCLKFreq+0x354>

      case LL_RCC_CLKP_CLKSOURCE_IC15:
        if (LL_RCC_IC15_IsEnabled() != 0U)
34016482:	f7f8 f8ad 	bl	3400e5e0 <LL_RCC_IC15_IsEnabled>
34016486:	4603      	mov	r3, r0
34016488:	2b00      	cmp	r3, #0
3401648a:	f000 80d7 	beq.w	3401663c <RCCEx_GetCLKPCLKFreq+0x358>
        {
          ic_divider = LL_RCC_IC15_GetDivider();
3401648e:	f7f8 f8c9 	bl	3400e624 <LL_RCC_IC15_GetDivider>
34016492:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC15_GetSource())
34016494:	f7f8 f8b8 	bl	3400e608 <LL_RCC_IC15_GetSource>
34016498:	4603      	mov	r3, r0
3401649a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401649e:	d029      	beq.n	340164f4 <RCCEx_GetCLKPCLKFreq+0x210>
340164a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340164a4:	d82f      	bhi.n	34016506 <RCCEx_GetCLKPCLKFreq+0x222>
340164a6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340164aa:	d01a      	beq.n	340164e2 <RCCEx_GetCLKPCLKFreq+0x1fe>
340164ac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340164b0:	d829      	bhi.n	34016506 <RCCEx_GetCLKPCLKFreq+0x222>
340164b2:	2b00      	cmp	r3, #0
340164b4:	d003      	beq.n	340164be <RCCEx_GetCLKPCLKFreq+0x1da>
340164b6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340164ba:	d009      	beq.n	340164d0 <RCCEx_GetCLKPCLKFreq+0x1ec>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340164bc:	e023      	b.n	34016506 <RCCEx_GetCLKPCLKFreq+0x222>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340164be:	f7ff fb0d 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340164c2:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340164c4:	68fa      	ldr	r2, [r7, #12]
340164c6:	68bb      	ldr	r3, [r7, #8]
340164c8:	fbb2 f3f3 	udiv	r3, r2, r3
340164cc:	60fb      	str	r3, [r7, #12]
              break;
340164ce:	e01b      	b.n	34016508 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340164d0:	f7ff fb4a 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340164d4:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340164d6:	68fa      	ldr	r2, [r7, #12]
340164d8:	68bb      	ldr	r3, [r7, #8]
340164da:	fbb2 f3f3 	udiv	r3, r2, r3
340164de:	60fb      	str	r3, [r7, #12]
              break;
340164e0:	e012      	b.n	34016508 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340164e2:	f7ff fb87 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340164e6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340164e8:	68fa      	ldr	r2, [r7, #12]
340164ea:	68bb      	ldr	r3, [r7, #8]
340164ec:	fbb2 f3f3 	udiv	r3, r2, r3
340164f0:	60fb      	str	r3, [r7, #12]
              break;
340164f2:	e009      	b.n	34016508 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340164f4:	f7ff fbc4 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340164f8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340164fa:	68fa      	ldr	r2, [r7, #12]
340164fc:	68bb      	ldr	r3, [r7, #8]
340164fe:	fbb2 f3f3 	udiv	r3, r2, r3
34016502:	60fb      	str	r3, [r7, #12]
              break;
34016504:	e000      	b.n	34016508 <RCCEx_GetCLKPCLKFreq+0x224>
              break;
34016506:	bf00      	nop
          }
        }
        break;
34016508:	e098      	b.n	3401663c <RCCEx_GetCLKPCLKFreq+0x358>

      case LL_RCC_CLKP_CLKSOURCE_IC19:
        if (LL_RCC_IC19_IsEnabled() != 0U)
3401650a:	f7f8 f969 	bl	3400e7e0 <LL_RCC_IC19_IsEnabled>
3401650e:	4603      	mov	r3, r0
34016510:	2b00      	cmp	r3, #0
34016512:	f000 8095 	beq.w	34016640 <RCCEx_GetCLKPCLKFreq+0x35c>
        {
          ic_divider = LL_RCC_IC19_GetDivider();
34016516:	f7f8 f985 	bl	3400e824 <LL_RCC_IC19_GetDivider>
3401651a:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC19_GetSource())
3401651c:	f7f8 f974 	bl	3400e808 <LL_RCC_IC19_GetSource>
34016520:	4603      	mov	r3, r0
34016522:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016526:	d029      	beq.n	3401657c <RCCEx_GetCLKPCLKFreq+0x298>
34016528:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401652c:	d82f      	bhi.n	3401658e <RCCEx_GetCLKPCLKFreq+0x2aa>
3401652e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016532:	d01a      	beq.n	3401656a <RCCEx_GetCLKPCLKFreq+0x286>
34016534:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016538:	d829      	bhi.n	3401658e <RCCEx_GetCLKPCLKFreq+0x2aa>
3401653a:	2b00      	cmp	r3, #0
3401653c:	d003      	beq.n	34016546 <RCCEx_GetCLKPCLKFreq+0x262>
3401653e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016542:	d009      	beq.n	34016558 <RCCEx_GetCLKPCLKFreq+0x274>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34016544:	e023      	b.n	3401658e <RCCEx_GetCLKPCLKFreq+0x2aa>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016546:	f7ff fac9 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401654a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401654c:	68fa      	ldr	r2, [r7, #12]
3401654e:	68bb      	ldr	r3, [r7, #8]
34016550:	fbb2 f3f3 	udiv	r3, r2, r3
34016554:	60fb      	str	r3, [r7, #12]
              break;
34016556:	e01b      	b.n	34016590 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016558:	f7ff fb06 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401655c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401655e:	68fa      	ldr	r2, [r7, #12]
34016560:	68bb      	ldr	r3, [r7, #8]
34016562:	fbb2 f3f3 	udiv	r3, r2, r3
34016566:	60fb      	str	r3, [r7, #12]
              break;
34016568:	e012      	b.n	34016590 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401656a:	f7ff fb43 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401656e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34016570:	68fa      	ldr	r2, [r7, #12]
34016572:	68bb      	ldr	r3, [r7, #8]
34016574:	fbb2 f3f3 	udiv	r3, r2, r3
34016578:	60fb      	str	r3, [r7, #12]
              break;
3401657a:	e009      	b.n	34016590 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401657c:	f7ff fb80 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016580:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34016582:	68fa      	ldr	r2, [r7, #12]
34016584:	68bb      	ldr	r3, [r7, #8]
34016586:	fbb2 f3f3 	udiv	r3, r2, r3
3401658a:	60fb      	str	r3, [r7, #12]
              break;
3401658c:	e000      	b.n	34016590 <RCCEx_GetCLKPCLKFreq+0x2ac>
              break;
3401658e:	bf00      	nop
          }
        }
        break;
34016590:	e056      	b.n	34016640 <RCCEx_GetCLKPCLKFreq+0x35c>

      case LL_RCC_CLKP_CLKSOURCE_IC20:
        if (LL_RCC_IC20_IsEnabled() != 0U)
34016592:	f7f8 f965 	bl	3400e860 <LL_RCC_IC20_IsEnabled>
34016596:	4603      	mov	r3, r0
34016598:	2b00      	cmp	r3, #0
3401659a:	d053      	beq.n	34016644 <RCCEx_GetCLKPCLKFreq+0x360>
        {
          ic_divider = LL_RCC_IC20_GetDivider();
3401659c:	f7f8 f982 	bl	3400e8a4 <LL_RCC_IC20_GetDivider>
340165a0:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC20_GetSource())
340165a2:	f7f8 f971 	bl	3400e888 <LL_RCC_IC20_GetSource>
340165a6:	4603      	mov	r3, r0
340165a8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340165ac:	d02f      	beq.n	3401660e <RCCEx_GetCLKPCLKFreq+0x32a>
340165ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340165b2:	d835      	bhi.n	34016620 <RCCEx_GetCLKPCLKFreq+0x33c>
340165b4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340165b8:	d020      	beq.n	340165fc <RCCEx_GetCLKPCLKFreq+0x318>
340165ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340165be:	d82f      	bhi.n	34016620 <RCCEx_GetCLKPCLKFreq+0x33c>
340165c0:	2b00      	cmp	r3, #0
340165c2:	d009      	beq.n	340165d8 <RCCEx_GetCLKPCLKFreq+0x2f4>
340165c4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340165c8:	d00f      	beq.n	340165ea <RCCEx_GetCLKPCLKFreq+0x306>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340165ca:	e029      	b.n	34016620 <RCCEx_GetCLKPCLKFreq+0x33c>
340165cc:	03d09000 	.word	0x03d09000
340165d0:	003d0900 	.word	0x003d0900
340165d4:	02dc6c00 	.word	0x02dc6c00
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340165d8:	f7ff fa80 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340165dc:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340165de:	68fa      	ldr	r2, [r7, #12]
340165e0:	68bb      	ldr	r3, [r7, #8]
340165e2:	fbb2 f3f3 	udiv	r3, r2, r3
340165e6:	60fb      	str	r3, [r7, #12]
              break;
340165e8:	e01b      	b.n	34016622 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340165ea:	f7ff fabd 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340165ee:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340165f0:	68fa      	ldr	r2, [r7, #12]
340165f2:	68bb      	ldr	r3, [r7, #8]
340165f4:	fbb2 f3f3 	udiv	r3, r2, r3
340165f8:	60fb      	str	r3, [r7, #12]
              break;
340165fa:	e012      	b.n	34016622 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340165fc:	f7ff fafa 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016600:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34016602:	68fa      	ldr	r2, [r7, #12]
34016604:	68bb      	ldr	r3, [r7, #8]
34016606:	fbb2 f3f3 	udiv	r3, r2, r3
3401660a:	60fb      	str	r3, [r7, #12]
              break;
3401660c:	e009      	b.n	34016622 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401660e:	f7ff fb37 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016612:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34016614:	68fa      	ldr	r2, [r7, #12]
34016616:	68bb      	ldr	r3, [r7, #8]
34016618:	fbb2 f3f3 	udiv	r3, r2, r3
3401661c:	60fb      	str	r3, [r7, #12]
              break;
3401661e:	e000      	b.n	34016622 <RCCEx_GetCLKPCLKFreq+0x33e>
              break;
34016620:	bf00      	nop
          }
        }
        break;
34016622:	e00f      	b.n	34016644 <RCCEx_GetCLKPCLKFreq+0x360>

      default:
        /* Unexpected case */
        break;
34016624:	bf00      	nop
34016626:	e00e      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34016628:	bf00      	nop
3401662a:	e00c      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
3401662c:	bf00      	nop
3401662e:	e00a      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34016630:	bf00      	nop
34016632:	e008      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34016634:	bf00      	nop
34016636:	e006      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34016638:	bf00      	nop
3401663a:	e004      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
3401663c:	bf00      	nop
3401663e:	e002      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34016640:	bf00      	nop
34016642:	e000      	b.n	34016646 <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34016644:	bf00      	nop
    }
  }

  return clkp_frequency;
34016646:	68fb      	ldr	r3, [r7, #12]
}
34016648:	4618      	mov	r0, r3
3401664a:	3710      	adds	r7, #16
3401664c:	46bd      	mov	sp, r7
3401664e:	bd80      	pop	{r7, pc}

34016650 <RCCEx_GetCSICLKFreq>:
  * @brief  Return CSI clock frequency
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCSICLKFreq(void)
{
34016650:	b580      	push	{r7, lr}
34016652:	b082      	sub	sp, #8
34016654:	af00      	add	r7, sp, #0
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34016656:	2300      	movs	r3, #0
34016658:	607b      	str	r3, [r7, #4]

  if (LL_RCC_IC18_IsEnabled() != 0U)
3401665a:	f7f8 f881 	bl	3400e760 <LL_RCC_IC18_IsEnabled>
3401665e:	4603      	mov	r3, r0
34016660:	2b00      	cmp	r3, #0
34016662:	d03c      	beq.n	340166de <RCCEx_GetCSICLKFreq+0x8e>
  {
    uint32_t ic_divider = LL_RCC_IC18_GetDivider();
34016664:	f7f8 f89e 	bl	3400e7a4 <LL_RCC_IC18_GetDivider>
34016668:	6038      	str	r0, [r7, #0]
    switch (LL_RCC_IC18_GetSource())
3401666a:	f7f8 f88d 	bl	3400e788 <LL_RCC_IC18_GetSource>
3401666e:	4603      	mov	r3, r0
34016670:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016674:	d029      	beq.n	340166ca <RCCEx_GetCSICLKFreq+0x7a>
34016676:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401667a:	d82f      	bhi.n	340166dc <RCCEx_GetCSICLKFreq+0x8c>
3401667c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016680:	d01a      	beq.n	340166b8 <RCCEx_GetCSICLKFreq+0x68>
34016682:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016686:	d829      	bhi.n	340166dc <RCCEx_GetCSICLKFreq+0x8c>
34016688:	2b00      	cmp	r3, #0
3401668a:	d003      	beq.n	34016694 <RCCEx_GetCSICLKFreq+0x44>
3401668c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016690:	d009      	beq.n	340166a6 <RCCEx_GetCSICLKFreq+0x56>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
        clkp_frequency = clkp_frequency / ic_divider;
        break;
      default:
        /* Unexpected case */
        break;
34016692:	e023      	b.n	340166dc <RCCEx_GetCSICLKFreq+0x8c>
        clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016694:	f7ff fa22 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016698:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
3401669a:	687a      	ldr	r2, [r7, #4]
3401669c:	683b      	ldr	r3, [r7, #0]
3401669e:	fbb2 f3f3 	udiv	r3, r2, r3
340166a2:	607b      	str	r3, [r7, #4]
        break;
340166a4:	e01b      	b.n	340166de <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340166a6:	f7ff fa5f 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340166aa:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340166ac:	687a      	ldr	r2, [r7, #4]
340166ae:	683b      	ldr	r3, [r7, #0]
340166b0:	fbb2 f3f3 	udiv	r3, r2, r3
340166b4:	607b      	str	r3, [r7, #4]
        break;
340166b6:	e012      	b.n	340166de <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340166b8:	f7ff fa9c 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340166bc:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340166be:	687a      	ldr	r2, [r7, #4]
340166c0:	683b      	ldr	r3, [r7, #0]
340166c2:	fbb2 f3f3 	udiv	r3, r2, r3
340166c6:	607b      	str	r3, [r7, #4]
        break;
340166c8:	e009      	b.n	340166de <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340166ca:	f7ff fad9 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340166ce:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340166d0:	687a      	ldr	r2, [r7, #4]
340166d2:	683b      	ldr	r3, [r7, #0]
340166d4:	fbb2 f3f3 	udiv	r3, r2, r3
340166d8:	607b      	str	r3, [r7, #4]
        break;
340166da:	e000      	b.n	340166de <RCCEx_GetCSICLKFreq+0x8e>
        break;
340166dc:	bf00      	nop
    }
  }

  return clkp_frequency;
340166de:	687b      	ldr	r3, [r7, #4]
}
340166e0:	4618      	mov	r0, r3
340166e2:	3708      	adds	r7, #8
340166e4:	46bd      	mov	sp, r7
340166e6:	bd80      	pop	{r7, pc}

340166e8 <RCCEx_GetDCMIPPCLKFreq>:
  *         @arg @ref RCCEx_DCMIPP_Clock_Source
  * @retval DCMIPP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetDCMIPPCLKFreq(uint32_t DCMIPPxSource)
{
340166e8:	b580      	push	{r7, lr}
340166ea:	b084      	sub	sp, #16
340166ec:	af00      	add	r7, sp, #0
340166ee:	6078      	str	r0, [r7, #4]
  uint32_t dcmipp_frequency = RCC_PERIPH_FREQUENCY_NO;
340166f0:	2300      	movs	r3, #0
340166f2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
340166f4:	6878      	ldr	r0, [r7, #4]
340166f6:	f7f7 f8fb 	bl	3400d8f0 <LL_RCC_GetDCMIPPClockSource>
340166fa:	4603      	mov	r3, r0
340166fc:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34016700:	d062      	beq.n	340167c8 <RCCEx_GetDCMIPPCLKFreq+0xe0>
34016702:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34016706:	d86d      	bhi.n	340167e4 <RCCEx_GetDCMIPPCLKFreq+0xfc>
34016708:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3401670c:	d019      	beq.n	34016742 <RCCEx_GetDCMIPPCLKFreq+0x5a>
3401670e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34016712:	d867      	bhi.n	340167e4 <RCCEx_GetDCMIPPCLKFreq+0xfc>
34016714:	2b00      	cmp	r3, #0
34016716:	d003      	beq.n	34016720 <RCCEx_GetDCMIPPCLKFreq+0x38>
34016718:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401671c:	d00c      	beq.n	34016738 <RCCEx_GetDCMIPPCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
3401671e:	e061      	b.n	340167e4 <RCCEx_GetDCMIPPCLKFreq+0xfc>
      dcmipp_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34016720:	f7f6 f9fc 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016724:	4603      	mov	r3, r0
34016726:	4618      	mov	r0, r3
34016728:	f7ff faf0 	bl	34015d0c <RCCEx_GetHCLKFreq>
3401672c:	4603      	mov	r3, r0
3401672e:	4618      	mov	r0, r3
34016730:	f7ff fb2f 	bl	34015d92 <RCCEx_GetPCLK5Freq>
34016734:	60f8      	str	r0, [r7, #12]
      break;
34016736:	e05a      	b.n	340167ee <RCCEx_GetDCMIPPCLKFreq+0x106>
      dcmipp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016738:	2007      	movs	r0, #7
3401673a:	f7ff fdd3 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401673e:	60f8      	str	r0, [r7, #12]
      break;
34016740:	e055      	b.n	340167ee <RCCEx_GetDCMIPPCLKFreq+0x106>
      if (LL_RCC_IC17_IsEnabled() != 0U)
34016742:	f7f7 ffcd 	bl	3400e6e0 <LL_RCC_IC17_IsEnabled>
34016746:	4603      	mov	r3, r0
34016748:	2b00      	cmp	r3, #0
3401674a:	d04d      	beq.n	340167e8 <RCCEx_GetDCMIPPCLKFreq+0x100>
        ic_divider = LL_RCC_IC17_GetDivider();
3401674c:	f7f7 ffea 	bl	3400e724 <LL_RCC_IC17_GetDivider>
34016750:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC17_GetSource())
34016752:	f7f7 ffd9 	bl	3400e708 <LL_RCC_IC17_GetSource>
34016756:	4603      	mov	r3, r0
34016758:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401675c:	d029      	beq.n	340167b2 <RCCEx_GetDCMIPPCLKFreq+0xca>
3401675e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016762:	d82f      	bhi.n	340167c4 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34016764:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016768:	d01a      	beq.n	340167a0 <RCCEx_GetDCMIPPCLKFreq+0xb8>
3401676a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401676e:	d829      	bhi.n	340167c4 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34016770:	2b00      	cmp	r3, #0
34016772:	d003      	beq.n	3401677c <RCCEx_GetDCMIPPCLKFreq+0x94>
34016774:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016778:	d009      	beq.n	3401678e <RCCEx_GetDCMIPPCLKFreq+0xa6>
            break;
3401677a:	e023      	b.n	340167c4 <RCCEx_GetDCMIPPCLKFreq+0xdc>
            dcmipp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401677c:	f7ff f9ae 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016780:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34016782:	68fa      	ldr	r2, [r7, #12]
34016784:	68bb      	ldr	r3, [r7, #8]
34016786:	fbb2 f3f3 	udiv	r3, r2, r3
3401678a:	60fb      	str	r3, [r7, #12]
            break;
3401678c:	e01b      	b.n	340167c6 <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401678e:	f7ff f9eb 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016792:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34016794:	68fa      	ldr	r2, [r7, #12]
34016796:	68bb      	ldr	r3, [r7, #8]
34016798:	fbb2 f3f3 	udiv	r3, r2, r3
3401679c:	60fb      	str	r3, [r7, #12]
            break;
3401679e:	e012      	b.n	340167c6 <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340167a0:	f7ff fa28 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340167a4:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
340167a6:	68fa      	ldr	r2, [r7, #12]
340167a8:	68bb      	ldr	r3, [r7, #8]
340167aa:	fbb2 f3f3 	udiv	r3, r2, r3
340167ae:	60fb      	str	r3, [r7, #12]
            break;
340167b0:	e009      	b.n	340167c6 <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340167b2:	f7ff fa65 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340167b6:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
340167b8:	68fa      	ldr	r2, [r7, #12]
340167ba:	68bb      	ldr	r3, [r7, #8]
340167bc:	fbb2 f3f3 	udiv	r3, r2, r3
340167c0:	60fb      	str	r3, [r7, #12]
            break;
340167c2:	e000      	b.n	340167c6 <RCCEx_GetDCMIPPCLKFreq+0xde>
            break;
340167c4:	bf00      	nop
      break;
340167c6:	e00f      	b.n	340167e8 <RCCEx_GetDCMIPPCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
340167c8:	f7f6 fda6 	bl	3400d318 <LL_RCC_HSI_IsReady>
340167cc:	4603      	mov	r3, r0
340167ce:	2b00      	cmp	r3, #0
340167d0:	d00c      	beq.n	340167ec <RCCEx_GetDCMIPPCLKFreq+0x104>
        dcmipp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340167d2:	f7f6 fdb3 	bl	3400d33c <LL_RCC_HSI_GetDivider>
340167d6:	4603      	mov	r3, r0
340167d8:	09db      	lsrs	r3, r3, #7
340167da:	4a07      	ldr	r2, [pc, #28]	@ (340167f8 <RCCEx_GetDCMIPPCLKFreq+0x110>)
340167dc:	fa22 f303 	lsr.w	r3, r2, r3
340167e0:	60fb      	str	r3, [r7, #12]
      break;
340167e2:	e003      	b.n	340167ec <RCCEx_GetDCMIPPCLKFreq+0x104>
      break;
340167e4:	bf00      	nop
340167e6:	e002      	b.n	340167ee <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
340167e8:	bf00      	nop
340167ea:	e000      	b.n	340167ee <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
340167ec:	bf00      	nop
  }

  return dcmipp_frequency;
340167ee:	68fb      	ldr	r3, [r7, #12]
}
340167f0:	4618      	mov	r0, r3
340167f2:	3710      	adds	r7, #16
340167f4:	46bd      	mov	sp, r7
340167f6:	bd80      	pop	{r7, pc}
340167f8:	03d09000 	.word	0x03d09000

340167fc <RCCEx_GetETH1CLKFreq>:
  *         @arg @ref RCCEx_ETH1_Clock_Source
  * @retval ETH1 clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1CLKFreq(uint32_t ETH1xSource)
{
340167fc:	b580      	push	{r7, lr}
340167fe:	b084      	sub	sp, #16
34016800:	af00      	add	r7, sp, #0
34016802:	6078      	str	r0, [r7, #4]
  uint32_t eth1_frequency = RCC_PERIPH_FREQUENCY_NO;
34016804:	2300      	movs	r3, #0
34016806:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHClockSource(ETH1xSource))
34016808:	6878      	ldr	r0, [r7, #4]
3401680a:	f7f7 f883 	bl	3400d914 <LL_RCC_GetETHClockSource>
3401680e:	4603      	mov	r3, r0
34016810:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34016814:	d05e      	beq.n	340168d4 <RCCEx_GetETH1CLKFreq+0xd8>
34016816:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3401681a:	d863      	bhi.n	340168e4 <RCCEx_GetETH1CLKFreq+0xe8>
3401681c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34016820:	d015      	beq.n	3401684e <RCCEx_GetETH1CLKFreq+0x52>
34016822:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34016826:	d85d      	bhi.n	340168e4 <RCCEx_GetETH1CLKFreq+0xe8>
34016828:	2b00      	cmp	r3, #0
3401682a:	d003      	beq.n	34016834 <RCCEx_GetETH1CLKFreq+0x38>
3401682c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34016830:	d008      	beq.n	34016844 <RCCEx_GetETH1CLKFreq+0x48>
      }
      break;

    default:
      /* Unexpected case */
      break;
34016832:	e057      	b.n	340168e4 <RCCEx_GetETH1CLKFreq+0xe8>
      eth1_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34016834:	f7f6 f972 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016838:	4603      	mov	r3, r0
3401683a:	4618      	mov	r0, r3
3401683c:	f7ff fa66 	bl	34015d0c <RCCEx_GetHCLKFreq>
34016840:	60f8      	str	r0, [r7, #12]
      break;
34016842:	e054      	b.n	340168ee <RCCEx_GetETH1CLKFreq+0xf2>
      eth1_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016844:	2007      	movs	r0, #7
34016846:	f7ff fd4d 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401684a:	60f8      	str	r0, [r7, #12]
      break;
3401684c:	e04f      	b.n	340168ee <RCCEx_GetETH1CLKFreq+0xf2>
      if (LL_RCC_IC12_IsEnabled() != 0U)
3401684e:	f7f7 fe07 	bl	3400e460 <LL_RCC_IC12_IsEnabled>
34016852:	4603      	mov	r3, r0
34016854:	2b00      	cmp	r3, #0
34016856:	d047      	beq.n	340168e8 <RCCEx_GetETH1CLKFreq+0xec>
        ic_divider = LL_RCC_IC12_GetDivider();
34016858:	f7f7 fe24 	bl	3400e4a4 <LL_RCC_IC12_GetDivider>
3401685c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC12_GetSource())
3401685e:	f7f7 fe13 	bl	3400e488 <LL_RCC_IC12_GetSource>
34016862:	4603      	mov	r3, r0
34016864:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016868:	d029      	beq.n	340168be <RCCEx_GetETH1CLKFreq+0xc2>
3401686a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401686e:	d82f      	bhi.n	340168d0 <RCCEx_GetETH1CLKFreq+0xd4>
34016870:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016874:	d01a      	beq.n	340168ac <RCCEx_GetETH1CLKFreq+0xb0>
34016876:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401687a:	d829      	bhi.n	340168d0 <RCCEx_GetETH1CLKFreq+0xd4>
3401687c:	2b00      	cmp	r3, #0
3401687e:	d003      	beq.n	34016888 <RCCEx_GetETH1CLKFreq+0x8c>
34016880:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016884:	d009      	beq.n	3401689a <RCCEx_GetETH1CLKFreq+0x9e>
            break;
34016886:	e023      	b.n	340168d0 <RCCEx_GetETH1CLKFreq+0xd4>
            eth1_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016888:	f7ff f928 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401688c:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
3401688e:	68fa      	ldr	r2, [r7, #12]
34016890:	68bb      	ldr	r3, [r7, #8]
34016892:	fbb2 f3f3 	udiv	r3, r2, r3
34016896:	60fb      	str	r3, [r7, #12]
            break;
34016898:	e01b      	b.n	340168d2 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401689a:	f7ff f965 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401689e:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
340168a0:	68fa      	ldr	r2, [r7, #12]
340168a2:	68bb      	ldr	r3, [r7, #8]
340168a4:	fbb2 f3f3 	udiv	r3, r2, r3
340168a8:	60fb      	str	r3, [r7, #12]
            break;
340168aa:	e012      	b.n	340168d2 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340168ac:	f7ff f9a2 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340168b0:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
340168b2:	68fa      	ldr	r2, [r7, #12]
340168b4:	68bb      	ldr	r3, [r7, #8]
340168b6:	fbb2 f3f3 	udiv	r3, r2, r3
340168ba:	60fb      	str	r3, [r7, #12]
            break;
340168bc:	e009      	b.n	340168d2 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340168be:	f7ff f9df 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340168c2:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
340168c4:	68fa      	ldr	r2, [r7, #12]
340168c6:	68bb      	ldr	r3, [r7, #8]
340168c8:	fbb2 f3f3 	udiv	r3, r2, r3
340168cc:	60fb      	str	r3, [r7, #12]
            break;
340168ce:	e000      	b.n	340168d2 <RCCEx_GetETH1CLKFreq+0xd6>
            break;
340168d0:	bf00      	nop
      break;
340168d2:	e009      	b.n	340168e8 <RCCEx_GetETH1CLKFreq+0xec>
      if (LL_RCC_HSE_IsReady() != 0U)
340168d4:	f7f6 fd0e 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
340168d8:	4603      	mov	r3, r0
340168da:	2b00      	cmp	r3, #0
340168dc:	d006      	beq.n	340168ec <RCCEx_GetETH1CLKFreq+0xf0>
        eth1_frequency = HSE_VALUE;
340168de:	4b06      	ldr	r3, [pc, #24]	@ (340168f8 <RCCEx_GetETH1CLKFreq+0xfc>)
340168e0:	60fb      	str	r3, [r7, #12]
      break;
340168e2:	e003      	b.n	340168ec <RCCEx_GetETH1CLKFreq+0xf0>
      break;
340168e4:	bf00      	nop
340168e6:	e002      	b.n	340168ee <RCCEx_GetETH1CLKFreq+0xf2>
      break;
340168e8:	bf00      	nop
340168ea:	e000      	b.n	340168ee <RCCEx_GetETH1CLKFreq+0xf2>
      break;
340168ec:	bf00      	nop
  }

  return eth1_frequency;
340168ee:	68fb      	ldr	r3, [r7, #12]
}
340168f0:	4618      	mov	r0, r3
340168f2:	3710      	adds	r7, #16
340168f4:	46bd      	mov	sp, r7
340168f6:	bd80      	pop	{r7, pc}
340168f8:	02dc6c00 	.word	0x02dc6c00

340168fc <RCCEx_GetETH1PTPCLKFreq>:
  *         @arg @ref RCCEx_ETH1_PTP_Clock_Source
  * @retval ETH1PTP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1PTPCLKFreq(uint32_t ETH1PTPxSource)
{
340168fc:	b580      	push	{r7, lr}
340168fe:	b084      	sub	sp, #16
34016900:	af00      	add	r7, sp, #0
34016902:	6078      	str	r0, [r7, #4]
  uint32_t eth1ptp_frequency = RCC_PERIPH_FREQUENCY_NO;
34016904:	2300      	movs	r3, #0
34016906:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
34016908:	6878      	ldr	r0, [r7, #4]
3401690a:	f7f7 f815 	bl	3400d938 <LL_RCC_GetETHPTPClockSource>
3401690e:	4603      	mov	r3, r0
34016910:	2b03      	cmp	r3, #3
34016912:	d863      	bhi.n	340169dc <RCCEx_GetETH1PTPCLKFreq+0xe0>
34016914:	a201      	add	r2, pc, #4	@ (adr r2, 3401691c <RCCEx_GetETH1PTPCLKFreq+0x20>)
34016916:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401691a:	bf00      	nop
3401691c:	3401692d 	.word	0x3401692d
34016920:	3401693d 	.word	0x3401693d
34016924:	34016947 	.word	0x34016947
34016928:	340169cd 	.word	0x340169cd
  {
    case LL_RCC_ETH1PTP_CLKSOURCE_HCLK:
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3401692c:	f7f6 f8f6 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016930:	4603      	mov	r3, r0
34016932:	4618      	mov	r0, r3
34016934:	f7ff f9ea 	bl	34015d0c <RCCEx_GetHCLKFreq>
34016938:	60f8      	str	r0, [r7, #12]
      break;
3401693a:	e054      	b.n	340169e6 <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_CLKP:
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401693c:	2007      	movs	r0, #7
3401693e:	f7ff fcd1 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34016942:	60f8      	str	r0, [r7, #12]
      break;
34016944:	e04f      	b.n	340169e6 <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_IC13:
      if (LL_RCC_IC13_IsEnabled() != 0U)
34016946:	f7f7 fdcb 	bl	3400e4e0 <LL_RCC_IC13_IsEnabled>
3401694a:	4603      	mov	r3, r0
3401694c:	2b00      	cmp	r3, #0
3401694e:	d047      	beq.n	340169e0 <RCCEx_GetETH1PTPCLKFreq+0xe4>
      {
        ic_divider = LL_RCC_IC13_GetDivider();
34016950:	f7f7 fde8 	bl	3400e524 <LL_RCC_IC13_GetDivider>
34016954:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC13_GetSource())
34016956:	f7f7 fdd7 	bl	3400e508 <LL_RCC_IC13_GetSource>
3401695a:	4603      	mov	r3, r0
3401695c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016960:	d029      	beq.n	340169b6 <RCCEx_GetETH1PTPCLKFreq+0xba>
34016962:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016966:	d82f      	bhi.n	340169c8 <RCCEx_GetETH1PTPCLKFreq+0xcc>
34016968:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401696c:	d01a      	beq.n	340169a4 <RCCEx_GetETH1PTPCLKFreq+0xa8>
3401696e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016972:	d829      	bhi.n	340169c8 <RCCEx_GetETH1PTPCLKFreq+0xcc>
34016974:	2b00      	cmp	r3, #0
34016976:	d003      	beq.n	34016980 <RCCEx_GetETH1PTPCLKFreq+0x84>
34016978:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401697c:	d009      	beq.n	34016992 <RCCEx_GetETH1PTPCLKFreq+0x96>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401697e:	e023      	b.n	340169c8 <RCCEx_GetETH1PTPCLKFreq+0xcc>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016980:	f7ff f8ac 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016984:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34016986:	68fa      	ldr	r2, [r7, #12]
34016988:	68bb      	ldr	r3, [r7, #8]
3401698a:	fbb2 f3f3 	udiv	r3, r2, r3
3401698e:	60fb      	str	r3, [r7, #12]
            break;
34016990:	e01b      	b.n	340169ca <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016992:	f7ff f8e9 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016996:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34016998:	68fa      	ldr	r2, [r7, #12]
3401699a:	68bb      	ldr	r3, [r7, #8]
3401699c:	fbb2 f3f3 	udiv	r3, r2, r3
340169a0:	60fb      	str	r3, [r7, #12]
            break;
340169a2:	e012      	b.n	340169ca <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340169a4:	f7ff f926 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340169a8:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
340169aa:	68fa      	ldr	r2, [r7, #12]
340169ac:	68bb      	ldr	r3, [r7, #8]
340169ae:	fbb2 f3f3 	udiv	r3, r2, r3
340169b2:	60fb      	str	r3, [r7, #12]
            break;
340169b4:	e009      	b.n	340169ca <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340169b6:	f7ff f963 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340169ba:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
340169bc:	68fa      	ldr	r2, [r7, #12]
340169be:	68bb      	ldr	r3, [r7, #8]
340169c0:	fbb2 f3f3 	udiv	r3, r2, r3
340169c4:	60fb      	str	r3, [r7, #12]
            break;
340169c6:	e000      	b.n	340169ca <RCCEx_GetETH1PTPCLKFreq+0xce>
            break;
340169c8:	bf00      	nop
        }
      }
      break;
340169ca:	e009      	b.n	340169e0 <RCCEx_GetETH1PTPCLKFreq+0xe4>

    case LL_RCC_ETH1PTP_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
340169cc:	f7f6 fc92 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
340169d0:	4603      	mov	r3, r0
340169d2:	2b00      	cmp	r3, #0
340169d4:	d006      	beq.n	340169e4 <RCCEx_GetETH1PTPCLKFreq+0xe8>
      {
        eth1ptp_frequency = HSE_VALUE;
340169d6:	4b0a      	ldr	r3, [pc, #40]	@ (34016a00 <RCCEx_GetETH1PTPCLKFreq+0x104>)
340169d8:	60fb      	str	r3, [r7, #12]
      }
      break;
340169da:	e003      	b.n	340169e4 <RCCEx_GetETH1PTPCLKFreq+0xe8>

    default:
      /* Unexpected case */
      break;
340169dc:	bf00      	nop
340169de:	e002      	b.n	340169e6 <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
340169e0:	bf00      	nop
340169e2:	e000      	b.n	340169e6 <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
340169e4:	bf00      	nop
  }

  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
340169e6:	f7f6 fde3 	bl	3400d5b0 <LL_RCC_GetETH1PTPDivider>
340169ea:	4603      	mov	r3, r0
340169ec:	091b      	lsrs	r3, r3, #4
340169ee:	3301      	adds	r3, #1
340169f0:	68fa      	ldr	r2, [r7, #12]
340169f2:	fbb2 f3f3 	udiv	r3, r2, r3
}
340169f6:	4618      	mov	r0, r3
340169f8:	3710      	adds	r7, #16
340169fa:	46bd      	mov	sp, r7
340169fc:	bd80      	pop	{r7, pc}
340169fe:	bf00      	nop
34016a00:	02dc6c00 	.word	0x02dc6c00

34016a04 <RCCEx_GetFDCANCLKFreq>:
  *         @arg @ref RCCEx_FDCAN_Clock_Source
  * @retval FDCAN clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFDCANCLKFreq(uint32_t FDCANxSource)
{
34016a04:	b580      	push	{r7, lr}
34016a06:	b084      	sub	sp, #16
34016a08:	af00      	add	r7, sp, #0
34016a0a:	6078      	str	r0, [r7, #4]
  uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
34016a0c:	2300      	movs	r3, #0
34016a0e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
34016a10:	6878      	ldr	r0, [r7, #4]
34016a12:	f7f6 ffa3 	bl	3400d95c <LL_RCC_GetFDCANClockSource>
34016a16:	4603      	mov	r3, r0
34016a18:	2b03      	cmp	r3, #3
34016a1a:	d867      	bhi.n	34016aec <RCCEx_GetFDCANCLKFreq+0xe8>
34016a1c:	a201      	add	r2, pc, #4	@ (adr r2, 34016a24 <RCCEx_GetFDCANCLKFreq+0x20>)
34016a1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34016a22:	bf00      	nop
34016a24:	34016a35 	.word	0x34016a35
34016a28:	34016a4d 	.word	0x34016a4d
34016a2c:	34016a57 	.word	0x34016a57
34016a30:	34016add 	.word	0x34016add
  {
    case LL_RCC_FDCAN_CLKSOURCE_PCLK1:
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34016a34:	f7f6 f872 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016a38:	4603      	mov	r3, r0
34016a3a:	4618      	mov	r0, r3
34016a3c:	f7ff f966 	bl	34015d0c <RCCEx_GetHCLKFreq>
34016a40:	4603      	mov	r3, r0
34016a42:	4618      	mov	r0, r3
34016a44:	f7ff f973 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34016a48:	60f8      	str	r0, [r7, #12]
      break;
34016a4a:	e054      	b.n	34016af6 <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_CLKP:
      fdcan_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016a4c:	2007      	movs	r0, #7
34016a4e:	f7ff fc49 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34016a52:	60f8      	str	r0, [r7, #12]
      break;
34016a54:	e04f      	b.n	34016af6 <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_IC19:
      if (LL_RCC_IC19_IsEnabled() != 0U)
34016a56:	f7f7 fec3 	bl	3400e7e0 <LL_RCC_IC19_IsEnabled>
34016a5a:	4603      	mov	r3, r0
34016a5c:	2b00      	cmp	r3, #0
34016a5e:	d047      	beq.n	34016af0 <RCCEx_GetFDCANCLKFreq+0xec>
      {
        ic_divider = LL_RCC_IC19_GetDivider();
34016a60:	f7f7 fee0 	bl	3400e824 <LL_RCC_IC19_GetDivider>
34016a64:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC19_GetSource())
34016a66:	f7f7 fecf 	bl	3400e808 <LL_RCC_IC19_GetSource>
34016a6a:	4603      	mov	r3, r0
34016a6c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016a70:	d029      	beq.n	34016ac6 <RCCEx_GetFDCANCLKFreq+0xc2>
34016a72:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016a76:	d82f      	bhi.n	34016ad8 <RCCEx_GetFDCANCLKFreq+0xd4>
34016a78:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016a7c:	d01a      	beq.n	34016ab4 <RCCEx_GetFDCANCLKFreq+0xb0>
34016a7e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016a82:	d829      	bhi.n	34016ad8 <RCCEx_GetFDCANCLKFreq+0xd4>
34016a84:	2b00      	cmp	r3, #0
34016a86:	d003      	beq.n	34016a90 <RCCEx_GetFDCANCLKFreq+0x8c>
34016a88:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016a8c:	d009      	beq.n	34016aa2 <RCCEx_GetFDCANCLKFreq+0x9e>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            fdcan_frequency = fdcan_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016a8e:	e023      	b.n	34016ad8 <RCCEx_GetFDCANCLKFreq+0xd4>
            fdcan_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016a90:	f7ff f824 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016a94:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34016a96:	68fa      	ldr	r2, [r7, #12]
34016a98:	68bb      	ldr	r3, [r7, #8]
34016a9a:	fbb2 f3f3 	udiv	r3, r2, r3
34016a9e:	60fb      	str	r3, [r7, #12]
            break;
34016aa0:	e01b      	b.n	34016ada <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016aa2:	f7ff f861 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016aa6:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34016aa8:	68fa      	ldr	r2, [r7, #12]
34016aaa:	68bb      	ldr	r3, [r7, #8]
34016aac:	fbb2 f3f3 	udiv	r3, r2, r3
34016ab0:	60fb      	str	r3, [r7, #12]
            break;
34016ab2:	e012      	b.n	34016ada <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016ab4:	f7ff f89e 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016ab8:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34016aba:	68fa      	ldr	r2, [r7, #12]
34016abc:	68bb      	ldr	r3, [r7, #8]
34016abe:	fbb2 f3f3 	udiv	r3, r2, r3
34016ac2:	60fb      	str	r3, [r7, #12]
            break;
34016ac4:	e009      	b.n	34016ada <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016ac6:	f7ff f8db 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016aca:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34016acc:	68fa      	ldr	r2, [r7, #12]
34016ace:	68bb      	ldr	r3, [r7, #8]
34016ad0:	fbb2 f3f3 	udiv	r3, r2, r3
34016ad4:	60fb      	str	r3, [r7, #12]
            break;
34016ad6:	e000      	b.n	34016ada <RCCEx_GetFDCANCLKFreq+0xd6>
            break;
34016ad8:	bf00      	nop
        }
      }
      break;
34016ada:	e009      	b.n	34016af0 <RCCEx_GetFDCANCLKFreq+0xec>

    case LL_RCC_FDCAN_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34016adc:	f7f6 fc0a 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
34016ae0:	4603      	mov	r3, r0
34016ae2:	2b00      	cmp	r3, #0
34016ae4:	d006      	beq.n	34016af4 <RCCEx_GetFDCANCLKFreq+0xf0>
      {
        fdcan_frequency = HSE_VALUE;
34016ae6:	4b06      	ldr	r3, [pc, #24]	@ (34016b00 <RCCEx_GetFDCANCLKFreq+0xfc>)
34016ae8:	60fb      	str	r3, [r7, #12]
      }
      break;
34016aea:	e003      	b.n	34016af4 <RCCEx_GetFDCANCLKFreq+0xf0>

    default:
      /* Unexpected case */
      break;
34016aec:	bf00      	nop
34016aee:	e002      	b.n	34016af6 <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34016af0:	bf00      	nop
34016af2:	e000      	b.n	34016af6 <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34016af4:	bf00      	nop
  }

  return fdcan_frequency;
34016af6:	68fb      	ldr	r3, [r7, #12]
}
34016af8:	4618      	mov	r0, r3
34016afa:	3710      	adds	r7, #16
34016afc:	46bd      	mov	sp, r7
34016afe:	bd80      	pop	{r7, pc}
34016b00:	02dc6c00 	.word	0x02dc6c00

34016b04 <RCCEx_GetFMCCLKFreq>:
  *         @arg @ref RCCEx_FMC_Clock_Source
  * @retval FMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFMCCLKFreq(uint32_t FMCxSource)
{
34016b04:	b580      	push	{r7, lr}
34016b06:	b084      	sub	sp, #16
34016b08:	af00      	add	r7, sp, #0
34016b0a:	6078      	str	r0, [r7, #4]
  uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34016b0c:	2300      	movs	r3, #0
34016b0e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFMCClockSource(FMCxSource))
34016b10:	6878      	ldr	r0, [r7, #4]
34016b12:	f7f6 ff35 	bl	3400d980 <LL_RCC_GetFMCClockSource>
34016b16:	4603      	mov	r3, r0
34016b18:	2b30      	cmp	r3, #48	@ 0x30
34016b1a:	d05d      	beq.n	34016bd8 <RCCEx_GetFMCCLKFreq+0xd4>
34016b1c:	2b30      	cmp	r3, #48	@ 0x30
34016b1e:	f200 809e 	bhi.w	34016c5e <RCCEx_GetFMCCLKFreq+0x15a>
34016b22:	2b20      	cmp	r3, #32
34016b24:	d014      	beq.n	34016b50 <RCCEx_GetFMCCLKFreq+0x4c>
34016b26:	2b20      	cmp	r3, #32
34016b28:	f200 8099 	bhi.w	34016c5e <RCCEx_GetFMCCLKFreq+0x15a>
34016b2c:	2b00      	cmp	r3, #0
34016b2e:	d002      	beq.n	34016b36 <RCCEx_GetFMCCLKFreq+0x32>
34016b30:	2b10      	cmp	r3, #16
34016b32:	d008      	beq.n	34016b46 <RCCEx_GetFMCCLKFreq+0x42>
      }
      break;

    default:
      /* Unexpected case */
      break;
34016b34:	e093      	b.n	34016c5e <RCCEx_GetFMCCLKFreq+0x15a>
      fmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34016b36:	f7f5 fff1 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016b3a:	4603      	mov	r3, r0
34016b3c:	4618      	mov	r0, r3
34016b3e:	f7ff f8e5 	bl	34015d0c <RCCEx_GetHCLKFreq>
34016b42:	60f8      	str	r0, [r7, #12]
      break;
34016b44:	e090      	b.n	34016c68 <RCCEx_GetFMCCLKFreq+0x164>
      fmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016b46:	2007      	movs	r0, #7
34016b48:	f7ff fbcc 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34016b4c:	60f8      	str	r0, [r7, #12]
      break;
34016b4e:	e08b      	b.n	34016c68 <RCCEx_GetFMCCLKFreq+0x164>
      if (LL_RCC_IC3_IsEnabled() != 0U)
34016b50:	f7f7 fac6 	bl	3400e0e0 <LL_RCC_IC3_IsEnabled>
34016b54:	4603      	mov	r3, r0
34016b56:	2b00      	cmp	r3, #0
34016b58:	f000 8083 	beq.w	34016c62 <RCCEx_GetFMCCLKFreq+0x15e>
        ic_divider = LL_RCC_IC3_GetDivider();
34016b5c:	f7f7 fae2 	bl	3400e124 <LL_RCC_IC3_GetDivider>
34016b60:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34016b62:	f7f7 fad1 	bl	3400e108 <LL_RCC_IC3_GetSource>
34016b66:	4603      	mov	r3, r0
34016b68:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016b6c:	d029      	beq.n	34016bc2 <RCCEx_GetFMCCLKFreq+0xbe>
34016b6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016b72:	d82f      	bhi.n	34016bd4 <RCCEx_GetFMCCLKFreq+0xd0>
34016b74:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016b78:	d01a      	beq.n	34016bb0 <RCCEx_GetFMCCLKFreq+0xac>
34016b7a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016b7e:	d829      	bhi.n	34016bd4 <RCCEx_GetFMCCLKFreq+0xd0>
34016b80:	2b00      	cmp	r3, #0
34016b82:	d003      	beq.n	34016b8c <RCCEx_GetFMCCLKFreq+0x88>
34016b84:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016b88:	d009      	beq.n	34016b9e <RCCEx_GetFMCCLKFreq+0x9a>
            break;
34016b8a:	e023      	b.n	34016bd4 <RCCEx_GetFMCCLKFreq+0xd0>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016b8c:	f7fe ffa6 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016b90:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016b92:	68fa      	ldr	r2, [r7, #12]
34016b94:	68bb      	ldr	r3, [r7, #8]
34016b96:	fbb2 f3f3 	udiv	r3, r2, r3
34016b9a:	60fb      	str	r3, [r7, #12]
            break;
34016b9c:	e01b      	b.n	34016bd6 <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016b9e:	f7fe ffe3 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016ba2:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016ba4:	68fa      	ldr	r2, [r7, #12]
34016ba6:	68bb      	ldr	r3, [r7, #8]
34016ba8:	fbb2 f3f3 	udiv	r3, r2, r3
34016bac:	60fb      	str	r3, [r7, #12]
            break;
34016bae:	e012      	b.n	34016bd6 <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016bb0:	f7ff f820 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016bb4:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016bb6:	68fa      	ldr	r2, [r7, #12]
34016bb8:	68bb      	ldr	r3, [r7, #8]
34016bba:	fbb2 f3f3 	udiv	r3, r2, r3
34016bbe:	60fb      	str	r3, [r7, #12]
            break;
34016bc0:	e009      	b.n	34016bd6 <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016bc2:	f7ff f85d 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016bc6:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016bc8:	68fa      	ldr	r2, [r7, #12]
34016bca:	68bb      	ldr	r3, [r7, #8]
34016bcc:	fbb2 f3f3 	udiv	r3, r2, r3
34016bd0:	60fb      	str	r3, [r7, #12]
            break;
34016bd2:	e000      	b.n	34016bd6 <RCCEx_GetFMCCLKFreq+0xd2>
            break;
34016bd4:	bf00      	nop
      break;
34016bd6:	e044      	b.n	34016c62 <RCCEx_GetFMCCLKFreq+0x15e>
      if (LL_RCC_IC4_IsEnabled() != 0U)
34016bd8:	f7f7 fac2 	bl	3400e160 <LL_RCC_IC4_IsEnabled>
34016bdc:	4603      	mov	r3, r0
34016bde:	2b00      	cmp	r3, #0
34016be0:	d041      	beq.n	34016c66 <RCCEx_GetFMCCLKFreq+0x162>
        ic_divider = LL_RCC_IC4_GetDivider();
34016be2:	f7f7 fadf 	bl	3400e1a4 <LL_RCC_IC4_GetDivider>
34016be6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34016be8:	f7f7 face 	bl	3400e188 <LL_RCC_IC4_GetSource>
34016bec:	4603      	mov	r3, r0
34016bee:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016bf2:	d029      	beq.n	34016c48 <RCCEx_GetFMCCLKFreq+0x144>
34016bf4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016bf8:	d82f      	bhi.n	34016c5a <RCCEx_GetFMCCLKFreq+0x156>
34016bfa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016bfe:	d01a      	beq.n	34016c36 <RCCEx_GetFMCCLKFreq+0x132>
34016c00:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016c04:	d829      	bhi.n	34016c5a <RCCEx_GetFMCCLKFreq+0x156>
34016c06:	2b00      	cmp	r3, #0
34016c08:	d003      	beq.n	34016c12 <RCCEx_GetFMCCLKFreq+0x10e>
34016c0a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016c0e:	d009      	beq.n	34016c24 <RCCEx_GetFMCCLKFreq+0x120>
            break;
34016c10:	e023      	b.n	34016c5a <RCCEx_GetFMCCLKFreq+0x156>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016c12:	f7fe ff63 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016c16:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016c18:	68fa      	ldr	r2, [r7, #12]
34016c1a:	68bb      	ldr	r3, [r7, #8]
34016c1c:	fbb2 f3f3 	udiv	r3, r2, r3
34016c20:	60fb      	str	r3, [r7, #12]
            break;
34016c22:	e01b      	b.n	34016c5c <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016c24:	f7fe ffa0 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016c28:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016c2a:	68fa      	ldr	r2, [r7, #12]
34016c2c:	68bb      	ldr	r3, [r7, #8]
34016c2e:	fbb2 f3f3 	udiv	r3, r2, r3
34016c32:	60fb      	str	r3, [r7, #12]
            break;
34016c34:	e012      	b.n	34016c5c <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016c36:	f7fe ffdd 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016c3a:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016c3c:	68fa      	ldr	r2, [r7, #12]
34016c3e:	68bb      	ldr	r3, [r7, #8]
34016c40:	fbb2 f3f3 	udiv	r3, r2, r3
34016c44:	60fb      	str	r3, [r7, #12]
            break;
34016c46:	e009      	b.n	34016c5c <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016c48:	f7ff f81a 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016c4c:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34016c4e:	68fa      	ldr	r2, [r7, #12]
34016c50:	68bb      	ldr	r3, [r7, #8]
34016c52:	fbb2 f3f3 	udiv	r3, r2, r3
34016c56:	60fb      	str	r3, [r7, #12]
            break;
34016c58:	e000      	b.n	34016c5c <RCCEx_GetFMCCLKFreq+0x158>
            break;
34016c5a:	bf00      	nop
      break;
34016c5c:	e003      	b.n	34016c66 <RCCEx_GetFMCCLKFreq+0x162>
      break;
34016c5e:	bf00      	nop
34016c60:	e002      	b.n	34016c68 <RCCEx_GetFMCCLKFreq+0x164>
      break;
34016c62:	bf00      	nop
34016c64:	e000      	b.n	34016c68 <RCCEx_GetFMCCLKFreq+0x164>
      break;
34016c66:	bf00      	nop
  }

  return fmc_frequency;
34016c68:	68fb      	ldr	r3, [r7, #12]
}
34016c6a:	4618      	mov	r0, r3
34016c6c:	3710      	adds	r7, #16
34016c6e:	46bd      	mov	sp, r7
34016c70:	bd80      	pop	{r7, pc}
	...

34016c74 <RCCEx_GetI2CCLKFreq>:
  *         @arg @ref RCCEx_I2C4_Clock_Source
  * @retval I2C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI2CCLKFreq(uint32_t I2CxSource)
{
34016c74:	b580      	push	{r7, lr}
34016c76:	b084      	sub	sp, #16
34016c78:	af00      	add	r7, sp, #0
34016c7a:	6078      	str	r0, [r7, #4]
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
34016c7c:	2300      	movs	r3, #0
34016c7e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34016c80:	6878      	ldr	r0, [r7, #4]
34016c82:	f7f6 fe8f 	bl	3400d9a4 <LL_RCC_GetI2CClockSource>
34016c86:	4603      	mov	r3, r0
34016c88:	4aa2      	ldr	r2, [pc, #648]	@ (34016f14 <RCCEx_GetI2CCLKFreq+0x2a0>)
34016c8a:	4293      	cmp	r3, r2
34016c8c:	f000 8172 	beq.w	34016f74 <RCCEx_GetI2CCLKFreq+0x300>
34016c90:	4aa0      	ldr	r2, [pc, #640]	@ (34016f14 <RCCEx_GetI2CCLKFreq+0x2a0>)
34016c92:	4293      	cmp	r3, r2
34016c94:	f200 8184 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016c98:	4a9f      	ldr	r2, [pc, #636]	@ (34016f18 <RCCEx_GetI2CCLKFreq+0x2a4>)
34016c9a:	4293      	cmp	r3, r2
34016c9c:	f000 816a 	beq.w	34016f74 <RCCEx_GetI2CCLKFreq+0x300>
34016ca0:	4a9d      	ldr	r2, [pc, #628]	@ (34016f18 <RCCEx_GetI2CCLKFreq+0x2a4>)
34016ca2:	4293      	cmp	r3, r2
34016ca4:	f200 817c 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016ca8:	4a9c      	ldr	r2, [pc, #624]	@ (34016f1c <RCCEx_GetI2CCLKFreq+0x2a8>)
34016caa:	4293      	cmp	r3, r2
34016cac:	f000 8162 	beq.w	34016f74 <RCCEx_GetI2CCLKFreq+0x300>
34016cb0:	4a9a      	ldr	r2, [pc, #616]	@ (34016f1c <RCCEx_GetI2CCLKFreq+0x2a8>)
34016cb2:	4293      	cmp	r3, r2
34016cb4:	f200 8174 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016cb8:	4a99      	ldr	r2, [pc, #612]	@ (34016f20 <RCCEx_GetI2CCLKFreq+0x2ac>)
34016cba:	4293      	cmp	r3, r2
34016cbc:	f000 815a 	beq.w	34016f74 <RCCEx_GetI2CCLKFreq+0x300>
34016cc0:	4a97      	ldr	r2, [pc, #604]	@ (34016f20 <RCCEx_GetI2CCLKFreq+0x2ac>)
34016cc2:	4293      	cmp	r3, r2
34016cc4:	f200 816c 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016cc8:	4a96      	ldr	r2, [pc, #600]	@ (34016f24 <RCCEx_GetI2CCLKFreq+0x2b0>)
34016cca:	4293      	cmp	r3, r2
34016ccc:	f000 8160 	beq.w	34016f90 <RCCEx_GetI2CCLKFreq+0x31c>
34016cd0:	4a94      	ldr	r2, [pc, #592]	@ (34016f24 <RCCEx_GetI2CCLKFreq+0x2b0>)
34016cd2:	4293      	cmp	r3, r2
34016cd4:	f200 8164 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016cd8:	4a93      	ldr	r2, [pc, #588]	@ (34016f28 <RCCEx_GetI2CCLKFreq+0x2b4>)
34016cda:	4293      	cmp	r3, r2
34016cdc:	f000 8158 	beq.w	34016f90 <RCCEx_GetI2CCLKFreq+0x31c>
34016ce0:	4a91      	ldr	r2, [pc, #580]	@ (34016f28 <RCCEx_GetI2CCLKFreq+0x2b4>)
34016ce2:	4293      	cmp	r3, r2
34016ce4:	f200 815c 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016ce8:	4a90      	ldr	r2, [pc, #576]	@ (34016f2c <RCCEx_GetI2CCLKFreq+0x2b8>)
34016cea:	4293      	cmp	r3, r2
34016cec:	f000 8150 	beq.w	34016f90 <RCCEx_GetI2CCLKFreq+0x31c>
34016cf0:	4a8e      	ldr	r2, [pc, #568]	@ (34016f2c <RCCEx_GetI2CCLKFreq+0x2b8>)
34016cf2:	4293      	cmp	r3, r2
34016cf4:	f200 8154 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016cf8:	4a8d      	ldr	r2, [pc, #564]	@ (34016f30 <RCCEx_GetI2CCLKFreq+0x2bc>)
34016cfa:	4293      	cmp	r3, r2
34016cfc:	f000 8148 	beq.w	34016f90 <RCCEx_GetI2CCLKFreq+0x31c>
34016d00:	4a8b      	ldr	r2, [pc, #556]	@ (34016f30 <RCCEx_GetI2CCLKFreq+0x2bc>)
34016d02:	4293      	cmp	r3, r2
34016d04:	f200 814c 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d08:	4a8a      	ldr	r2, [pc, #552]	@ (34016f34 <RCCEx_GetI2CCLKFreq+0x2c0>)
34016d0a:	4293      	cmp	r3, r2
34016d0c:	f000 80be 	beq.w	34016e8c <RCCEx_GetI2CCLKFreq+0x218>
34016d10:	4a88      	ldr	r2, [pc, #544]	@ (34016f34 <RCCEx_GetI2CCLKFreq+0x2c0>)
34016d12:	4293      	cmp	r3, r2
34016d14:	f200 8144 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d18:	4a87      	ldr	r2, [pc, #540]	@ (34016f38 <RCCEx_GetI2CCLKFreq+0x2c4>)
34016d1a:	4293      	cmp	r3, r2
34016d1c:	f000 80b6 	beq.w	34016e8c <RCCEx_GetI2CCLKFreq+0x218>
34016d20:	4a85      	ldr	r2, [pc, #532]	@ (34016f38 <RCCEx_GetI2CCLKFreq+0x2c4>)
34016d22:	4293      	cmp	r3, r2
34016d24:	f200 813c 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d28:	4a84      	ldr	r2, [pc, #528]	@ (34016f3c <RCCEx_GetI2CCLKFreq+0x2c8>)
34016d2a:	4293      	cmp	r3, r2
34016d2c:	f000 80ae 	beq.w	34016e8c <RCCEx_GetI2CCLKFreq+0x218>
34016d30:	4a82      	ldr	r2, [pc, #520]	@ (34016f3c <RCCEx_GetI2CCLKFreq+0x2c8>)
34016d32:	4293      	cmp	r3, r2
34016d34:	f200 8134 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d38:	4a81      	ldr	r2, [pc, #516]	@ (34016f40 <RCCEx_GetI2CCLKFreq+0x2cc>)
34016d3a:	4293      	cmp	r3, r2
34016d3c:	f000 80a6 	beq.w	34016e8c <RCCEx_GetI2CCLKFreq+0x218>
34016d40:	4a7f      	ldr	r2, [pc, #508]	@ (34016f40 <RCCEx_GetI2CCLKFreq+0x2cc>)
34016d42:	4293      	cmp	r3, r2
34016d44:	f200 812c 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d48:	4a7e      	ldr	r2, [pc, #504]	@ (34016f44 <RCCEx_GetI2CCLKFreq+0x2d0>)
34016d4a:	4293      	cmp	r3, r2
34016d4c:	d05a      	beq.n	34016e04 <RCCEx_GetI2CCLKFreq+0x190>
34016d4e:	4a7d      	ldr	r2, [pc, #500]	@ (34016f44 <RCCEx_GetI2CCLKFreq+0x2d0>)
34016d50:	4293      	cmp	r3, r2
34016d52:	f200 8125 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d56:	4a7c      	ldr	r2, [pc, #496]	@ (34016f48 <RCCEx_GetI2CCLKFreq+0x2d4>)
34016d58:	4293      	cmp	r3, r2
34016d5a:	d053      	beq.n	34016e04 <RCCEx_GetI2CCLKFreq+0x190>
34016d5c:	4a7a      	ldr	r2, [pc, #488]	@ (34016f48 <RCCEx_GetI2CCLKFreq+0x2d4>)
34016d5e:	4293      	cmp	r3, r2
34016d60:	f200 811e 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d64:	4a79      	ldr	r2, [pc, #484]	@ (34016f4c <RCCEx_GetI2CCLKFreq+0x2d8>)
34016d66:	4293      	cmp	r3, r2
34016d68:	d04c      	beq.n	34016e04 <RCCEx_GetI2CCLKFreq+0x190>
34016d6a:	4a78      	ldr	r2, [pc, #480]	@ (34016f4c <RCCEx_GetI2CCLKFreq+0x2d8>)
34016d6c:	4293      	cmp	r3, r2
34016d6e:	f200 8117 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d72:	4a77      	ldr	r2, [pc, #476]	@ (34016f50 <RCCEx_GetI2CCLKFreq+0x2dc>)
34016d74:	4293      	cmp	r3, r2
34016d76:	d045      	beq.n	34016e04 <RCCEx_GetI2CCLKFreq+0x190>
34016d78:	4a75      	ldr	r2, [pc, #468]	@ (34016f50 <RCCEx_GetI2CCLKFreq+0x2dc>)
34016d7a:	4293      	cmp	r3, r2
34016d7c:	f200 8110 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d80:	4a74      	ldr	r2, [pc, #464]	@ (34016f54 <RCCEx_GetI2CCLKFreq+0x2e0>)
34016d82:	4293      	cmp	r3, r2
34016d84:	d039      	beq.n	34016dfa <RCCEx_GetI2CCLKFreq+0x186>
34016d86:	4a73      	ldr	r2, [pc, #460]	@ (34016f54 <RCCEx_GetI2CCLKFreq+0x2e0>)
34016d88:	4293      	cmp	r3, r2
34016d8a:	f200 8109 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d8e:	4a72      	ldr	r2, [pc, #456]	@ (34016f58 <RCCEx_GetI2CCLKFreq+0x2e4>)
34016d90:	4293      	cmp	r3, r2
34016d92:	d032      	beq.n	34016dfa <RCCEx_GetI2CCLKFreq+0x186>
34016d94:	4a70      	ldr	r2, [pc, #448]	@ (34016f58 <RCCEx_GetI2CCLKFreq+0x2e4>)
34016d96:	4293      	cmp	r3, r2
34016d98:	f200 8102 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016d9c:	4a6f      	ldr	r2, [pc, #444]	@ (34016f5c <RCCEx_GetI2CCLKFreq+0x2e8>)
34016d9e:	4293      	cmp	r3, r2
34016da0:	d02b      	beq.n	34016dfa <RCCEx_GetI2CCLKFreq+0x186>
34016da2:	4a6e      	ldr	r2, [pc, #440]	@ (34016f5c <RCCEx_GetI2CCLKFreq+0x2e8>)
34016da4:	4293      	cmp	r3, r2
34016da6:	f200 80fb 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016daa:	4a6d      	ldr	r2, [pc, #436]	@ (34016f60 <RCCEx_GetI2CCLKFreq+0x2ec>)
34016dac:	4293      	cmp	r3, r2
34016dae:	d024      	beq.n	34016dfa <RCCEx_GetI2CCLKFreq+0x186>
34016db0:	4a6b      	ldr	r2, [pc, #428]	@ (34016f60 <RCCEx_GetI2CCLKFreq+0x2ec>)
34016db2:	4293      	cmp	r3, r2
34016db4:	f200 80f4 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016db8:	4a6a      	ldr	r2, [pc, #424]	@ (34016f64 <RCCEx_GetI2CCLKFreq+0x2f0>)
34016dba:	4293      	cmp	r3, r2
34016dbc:	d011      	beq.n	34016de2 <RCCEx_GetI2CCLKFreq+0x16e>
34016dbe:	4a69      	ldr	r2, [pc, #420]	@ (34016f64 <RCCEx_GetI2CCLKFreq+0x2f0>)
34016dc0:	4293      	cmp	r3, r2
34016dc2:	f200 80ed 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016dc6:	4a68      	ldr	r2, [pc, #416]	@ (34016f68 <RCCEx_GetI2CCLKFreq+0x2f4>)
34016dc8:	4293      	cmp	r3, r2
34016dca:	d00a      	beq.n	34016de2 <RCCEx_GetI2CCLKFreq+0x16e>
34016dcc:	4a66      	ldr	r2, [pc, #408]	@ (34016f68 <RCCEx_GetI2CCLKFreq+0x2f4>)
34016dce:	4293      	cmp	r3, r2
34016dd0:	f200 80e6 	bhi.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
34016dd4:	4a65      	ldr	r2, [pc, #404]	@ (34016f6c <RCCEx_GetI2CCLKFreq+0x2f8>)
34016dd6:	4293      	cmp	r3, r2
34016dd8:	d003      	beq.n	34016de2 <RCCEx_GetI2CCLKFreq+0x16e>
34016dda:	4a65      	ldr	r2, [pc, #404]	@ (34016f70 <RCCEx_GetI2CCLKFreq+0x2fc>)
34016ddc:	4293      	cmp	r3, r2
34016dde:	f040 80df 	bne.w	34016fa0 <RCCEx_GetI2CCLKFreq+0x32c>
  {
    case LL_RCC_I2C1_CLKSOURCE_PCLK1:
    case LL_RCC_I2C2_CLKSOURCE_PCLK1:
    case LL_RCC_I2C3_CLKSOURCE_PCLK1:
    case LL_RCC_I2C4_CLKSOURCE_PCLK1:
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34016de2:	f7f5 fe9b 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34016de6:	4603      	mov	r3, r0
34016de8:	4618      	mov	r0, r3
34016dea:	f7fe ff8f 	bl	34015d0c <RCCEx_GetHCLKFreq>
34016dee:	4603      	mov	r3, r0
34016df0:	4618      	mov	r0, r3
34016df2:	f7fe ff9c 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34016df6:	60f8      	str	r0, [r7, #12]
      break;
34016df8:	e0db      	b.n	34016fb2 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_CLKP:
    case LL_RCC_I2C2_CLKSOURCE_CLKP:
    case LL_RCC_I2C3_CLKSOURCE_CLKP:
    case LL_RCC_I2C4_CLKSOURCE_CLKP:
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016dfa:	2007      	movs	r0, #7
34016dfc:	f7ff fa72 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34016e00:	60f8      	str	r0, [r7, #12]
      break;
34016e02:	e0d6      	b.n	34016fb2 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_IC10:
    case LL_RCC_I2C2_CLKSOURCE_IC10:
    case LL_RCC_I2C3_CLKSOURCE_IC10:
    case LL_RCC_I2C4_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34016e04:	f7f7 faec 	bl	3400e3e0 <LL_RCC_IC10_IsEnabled>
34016e08:	4603      	mov	r3, r0
34016e0a:	2b00      	cmp	r3, #0
34016e0c:	f000 80ca 	beq.w	34016fa4 <RCCEx_GetI2CCLKFreq+0x330>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34016e10:	f7f7 fb08 	bl	3400e424 <LL_RCC_IC10_GetDivider>
34016e14:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34016e16:	f7f7 faf7 	bl	3400e408 <LL_RCC_IC10_GetSource>
34016e1a:	4603      	mov	r3, r0
34016e1c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016e20:	d029      	beq.n	34016e76 <RCCEx_GetI2CCLKFreq+0x202>
34016e22:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016e26:	d82f      	bhi.n	34016e88 <RCCEx_GetI2CCLKFreq+0x214>
34016e28:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016e2c:	d01a      	beq.n	34016e64 <RCCEx_GetI2CCLKFreq+0x1f0>
34016e2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016e32:	d829      	bhi.n	34016e88 <RCCEx_GetI2CCLKFreq+0x214>
34016e34:	2b00      	cmp	r3, #0
34016e36:	d003      	beq.n	34016e40 <RCCEx_GetI2CCLKFreq+0x1cc>
34016e38:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016e3c:	d009      	beq.n	34016e52 <RCCEx_GetI2CCLKFreq+0x1de>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016e3e:	e023      	b.n	34016e88 <RCCEx_GetI2CCLKFreq+0x214>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016e40:	f7fe fe4c 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016e44:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016e46:	68fa      	ldr	r2, [r7, #12]
34016e48:	68bb      	ldr	r3, [r7, #8]
34016e4a:	fbb2 f3f3 	udiv	r3, r2, r3
34016e4e:	60fb      	str	r3, [r7, #12]
            break;
34016e50:	e01b      	b.n	34016e8a <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016e52:	f7fe fe89 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016e56:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016e58:	68fa      	ldr	r2, [r7, #12]
34016e5a:	68bb      	ldr	r3, [r7, #8]
34016e5c:	fbb2 f3f3 	udiv	r3, r2, r3
34016e60:	60fb      	str	r3, [r7, #12]
            break;
34016e62:	e012      	b.n	34016e8a <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016e64:	f7fe fec6 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016e68:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016e6a:	68fa      	ldr	r2, [r7, #12]
34016e6c:	68bb      	ldr	r3, [r7, #8]
34016e6e:	fbb2 f3f3 	udiv	r3, r2, r3
34016e72:	60fb      	str	r3, [r7, #12]
            break;
34016e74:	e009      	b.n	34016e8a <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016e76:	f7fe ff03 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016e7a:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016e7c:	68fa      	ldr	r2, [r7, #12]
34016e7e:	68bb      	ldr	r3, [r7, #8]
34016e80:	fbb2 f3f3 	udiv	r3, r2, r3
34016e84:	60fb      	str	r3, [r7, #12]
            break;
34016e86:	e000      	b.n	34016e8a <RCCEx_GetI2CCLKFreq+0x216>
            break;
34016e88:	bf00      	nop
        }
      }
      break;
34016e8a:	e08b      	b.n	34016fa4 <RCCEx_GetI2CCLKFreq+0x330>

    case LL_RCC_I2C1_CLKSOURCE_IC15:
    case LL_RCC_I2C2_CLKSOURCE_IC15:
    case LL_RCC_I2C3_CLKSOURCE_IC15:
    case LL_RCC_I2C4_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34016e8c:	f7f7 fba8 	bl	3400e5e0 <LL_RCC_IC15_IsEnabled>
34016e90:	4603      	mov	r3, r0
34016e92:	2b00      	cmp	r3, #0
34016e94:	f000 8088 	beq.w	34016fa8 <RCCEx_GetI2CCLKFreq+0x334>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34016e98:	f7f7 fbc4 	bl	3400e624 <LL_RCC_IC15_GetDivider>
34016e9c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34016e9e:	f7f7 fbb3 	bl	3400e608 <LL_RCC_IC15_GetSource>
34016ea2:	4603      	mov	r3, r0
34016ea4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016ea8:	d029      	beq.n	34016efe <RCCEx_GetI2CCLKFreq+0x28a>
34016eaa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016eae:	d82f      	bhi.n	34016f10 <RCCEx_GetI2CCLKFreq+0x29c>
34016eb0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016eb4:	d01a      	beq.n	34016eec <RCCEx_GetI2CCLKFreq+0x278>
34016eb6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016eba:	d829      	bhi.n	34016f10 <RCCEx_GetI2CCLKFreq+0x29c>
34016ebc:	2b00      	cmp	r3, #0
34016ebe:	d003      	beq.n	34016ec8 <RCCEx_GetI2CCLKFreq+0x254>
34016ec0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016ec4:	d009      	beq.n	34016eda <RCCEx_GetI2CCLKFreq+0x266>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016ec6:	e023      	b.n	34016f10 <RCCEx_GetI2CCLKFreq+0x29c>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016ec8:	f7fe fe08 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34016ecc:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016ece:	68fa      	ldr	r2, [r7, #12]
34016ed0:	68bb      	ldr	r3, [r7, #8]
34016ed2:	fbb2 f3f3 	udiv	r3, r2, r3
34016ed6:	60fb      	str	r3, [r7, #12]
            break;
34016ed8:	e01b      	b.n	34016f12 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016eda:	f7fe fe45 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34016ede:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016ee0:	68fa      	ldr	r2, [r7, #12]
34016ee2:	68bb      	ldr	r3, [r7, #8]
34016ee4:	fbb2 f3f3 	udiv	r3, r2, r3
34016ee8:	60fb      	str	r3, [r7, #12]
            break;
34016eea:	e012      	b.n	34016f12 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016eec:	f7fe fe82 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34016ef0:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016ef2:	68fa      	ldr	r2, [r7, #12]
34016ef4:	68bb      	ldr	r3, [r7, #8]
34016ef6:	fbb2 f3f3 	udiv	r3, r2, r3
34016efa:	60fb      	str	r3, [r7, #12]
            break;
34016efc:	e009      	b.n	34016f12 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016efe:	f7fe febf 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34016f02:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34016f04:	68fa      	ldr	r2, [r7, #12]
34016f06:	68bb      	ldr	r3, [r7, #8]
34016f08:	fbb2 f3f3 	udiv	r3, r2, r3
34016f0c:	60fb      	str	r3, [r7, #12]
            break;
34016f0e:	e000      	b.n	34016f12 <RCCEx_GetI2CCLKFreq+0x29e>
            break;
34016f10:	bf00      	nop
        }
      }
      break;
34016f12:	e049      	b.n	34016fa8 <RCCEx_GetI2CCLKFreq+0x334>
34016f14:	07050c0c 	.word	0x07050c0c
34016f18:	0705080c 	.word	0x0705080c
34016f1c:	0705040c 	.word	0x0705040c
34016f20:	0705000c 	.word	0x0705000c
34016f24:	07040c0c 	.word	0x07040c0c
34016f28:	0704080c 	.word	0x0704080c
34016f2c:	0704040c 	.word	0x0704040c
34016f30:	0704000c 	.word	0x0704000c
34016f34:	07030c0c 	.word	0x07030c0c
34016f38:	0703080c 	.word	0x0703080c
34016f3c:	0703040c 	.word	0x0703040c
34016f40:	0703000c 	.word	0x0703000c
34016f44:	07020c0c 	.word	0x07020c0c
34016f48:	0702080c 	.word	0x0702080c
34016f4c:	0702040c 	.word	0x0702040c
34016f50:	0702000c 	.word	0x0702000c
34016f54:	07010c0c 	.word	0x07010c0c
34016f58:	0701080c 	.word	0x0701080c
34016f5c:	0701040c 	.word	0x0701040c
34016f60:	0701000c 	.word	0x0701000c
34016f64:	07000c0c 	.word	0x07000c0c
34016f68:	0700080c 	.word	0x0700080c
34016f6c:	0700000c 	.word	0x0700000c
34016f70:	0700040c 	.word	0x0700040c

    case LL_RCC_I2C1_CLKSOURCE_HSI:
    case LL_RCC_I2C2_CLKSOURCE_HSI:
    case LL_RCC_I2C3_CLKSOURCE_HSI:
    case LL_RCC_I2C4_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34016f74:	f7f6 f9d0 	bl	3400d318 <LL_RCC_HSI_IsReady>
34016f78:	4603      	mov	r3, r0
34016f7a:	2b00      	cmp	r3, #0
34016f7c:	d016      	beq.n	34016fac <RCCEx_GetI2CCLKFreq+0x338>
      {
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34016f7e:	f7f6 f9dd 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34016f82:	4603      	mov	r3, r0
34016f84:	09db      	lsrs	r3, r3, #7
34016f86:	4a0d      	ldr	r2, [pc, #52]	@ (34016fbc <RCCEx_GetI2CCLKFreq+0x348>)
34016f88:	fa22 f303 	lsr.w	r3, r2, r3
34016f8c:	60fb      	str	r3, [r7, #12]
      }
      break;
34016f8e:	e00d      	b.n	34016fac <RCCEx_GetI2CCLKFreq+0x338>

    case LL_RCC_I2C1_CLKSOURCE_MSI:
    case LL_RCC_I2C2_CLKSOURCE_MSI:
    case LL_RCC_I2C3_CLKSOURCE_MSI:
    case LL_RCC_I2C4_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34016f90:	f7f6 f9e2 	bl	3400d358 <LL_RCC_MSI_IsReady>
34016f94:	4603      	mov	r3, r0
34016f96:	2b00      	cmp	r3, #0
34016f98:	d00a      	beq.n	34016fb0 <RCCEx_GetI2CCLKFreq+0x33c>
      {
        i2c_frequency = MSI_VALUE;
34016f9a:	4b09      	ldr	r3, [pc, #36]	@ (34016fc0 <RCCEx_GetI2CCLKFreq+0x34c>)
34016f9c:	60fb      	str	r3, [r7, #12]
      }
      break;
34016f9e:	e007      	b.n	34016fb0 <RCCEx_GetI2CCLKFreq+0x33c>

    default:
      /* Unexpected case */
      break;
34016fa0:	bf00      	nop
34016fa2:	e006      	b.n	34016fb2 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34016fa4:	bf00      	nop
34016fa6:	e004      	b.n	34016fb2 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34016fa8:	bf00      	nop
34016faa:	e002      	b.n	34016fb2 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34016fac:	bf00      	nop
34016fae:	e000      	b.n	34016fb2 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34016fb0:	bf00      	nop
  }

  return i2c_frequency;
34016fb2:	68fb      	ldr	r3, [r7, #12]
}
34016fb4:	4618      	mov	r0, r3
34016fb6:	3710      	adds	r7, #16
34016fb8:	46bd      	mov	sp, r7
34016fba:	bd80      	pop	{r7, pc}
34016fbc:	03d09000 	.word	0x03d09000
34016fc0:	003d0900 	.word	0x003d0900

34016fc4 <RCCEx_GetI3CCLKFreq>:
  *         @arg @ref RCCEx_I3C2_Clock_Source
  * @retval I3C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI3CCLKFreq(uint32_t I3CxSource)
{
34016fc4:	b580      	push	{r7, lr}
34016fc6:	b084      	sub	sp, #16
34016fc8:	af00      	add	r7, sp, #0
34016fca:	6078      	str	r0, [r7, #4]
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
34016fcc:	2300      	movs	r3, #0
34016fce:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34016fd0:	6878      	ldr	r0, [r7, #4]
34016fd2:	f7f6 fcf3 	bl	3400d9bc <LL_RCC_GetI3CClockSource>
34016fd6:	4603      	mov	r3, r0
34016fd8:	4a86      	ldr	r2, [pc, #536]	@ (340171f4 <RCCEx_GetI3CCLKFreq+0x230>)
34016fda:	4293      	cmp	r3, r2
34016fdc:	f000 80e6 	beq.w	340171ac <RCCEx_GetI3CCLKFreq+0x1e8>
34016fe0:	4a84      	ldr	r2, [pc, #528]	@ (340171f4 <RCCEx_GetI3CCLKFreq+0x230>)
34016fe2:	4293      	cmp	r3, r2
34016fe4:	f200 80f8 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34016fe8:	4a83      	ldr	r2, [pc, #524]	@ (340171f8 <RCCEx_GetI3CCLKFreq+0x234>)
34016fea:	4293      	cmp	r3, r2
34016fec:	f000 80de 	beq.w	340171ac <RCCEx_GetI3CCLKFreq+0x1e8>
34016ff0:	4a81      	ldr	r2, [pc, #516]	@ (340171f8 <RCCEx_GetI3CCLKFreq+0x234>)
34016ff2:	4293      	cmp	r3, r2
34016ff4:	f200 80f0 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34016ff8:	4a80      	ldr	r2, [pc, #512]	@ (340171fc <RCCEx_GetI3CCLKFreq+0x238>)
34016ffa:	4293      	cmp	r3, r2
34016ffc:	f000 80e4 	beq.w	340171c8 <RCCEx_GetI3CCLKFreq+0x204>
34017000:	4a7e      	ldr	r2, [pc, #504]	@ (340171fc <RCCEx_GetI3CCLKFreq+0x238>)
34017002:	4293      	cmp	r3, r2
34017004:	f200 80e8 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017008:	4a7d      	ldr	r2, [pc, #500]	@ (34017200 <RCCEx_GetI3CCLKFreq+0x23c>)
3401700a:	4293      	cmp	r3, r2
3401700c:	f000 80dc 	beq.w	340171c8 <RCCEx_GetI3CCLKFreq+0x204>
34017010:	4a7b      	ldr	r2, [pc, #492]	@ (34017200 <RCCEx_GetI3CCLKFreq+0x23c>)
34017012:	4293      	cmp	r3, r2
34017014:	f200 80e0 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017018:	4a7a      	ldr	r2, [pc, #488]	@ (34017204 <RCCEx_GetI3CCLKFreq+0x240>)
3401701a:	4293      	cmp	r3, r2
3401701c:	f000 8083 	beq.w	34017126 <RCCEx_GetI3CCLKFreq+0x162>
34017020:	4a78      	ldr	r2, [pc, #480]	@ (34017204 <RCCEx_GetI3CCLKFreq+0x240>)
34017022:	4293      	cmp	r3, r2
34017024:	f200 80d8 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017028:	4a77      	ldr	r2, [pc, #476]	@ (34017208 <RCCEx_GetI3CCLKFreq+0x244>)
3401702a:	4293      	cmp	r3, r2
3401702c:	d07b      	beq.n	34017126 <RCCEx_GetI3CCLKFreq+0x162>
3401702e:	4a76      	ldr	r2, [pc, #472]	@ (34017208 <RCCEx_GetI3CCLKFreq+0x244>)
34017030:	4293      	cmp	r3, r2
34017032:	f200 80d1 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017036:	4a75      	ldr	r2, [pc, #468]	@ (3401720c <RCCEx_GetI3CCLKFreq+0x248>)
34017038:	4293      	cmp	r3, r2
3401703a:	d030      	beq.n	3401709e <RCCEx_GetI3CCLKFreq+0xda>
3401703c:	4a73      	ldr	r2, [pc, #460]	@ (3401720c <RCCEx_GetI3CCLKFreq+0x248>)
3401703e:	4293      	cmp	r3, r2
34017040:	f200 80ca 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017044:	4a72      	ldr	r2, [pc, #456]	@ (34017210 <RCCEx_GetI3CCLKFreq+0x24c>)
34017046:	4293      	cmp	r3, r2
34017048:	d029      	beq.n	3401709e <RCCEx_GetI3CCLKFreq+0xda>
3401704a:	4a71      	ldr	r2, [pc, #452]	@ (34017210 <RCCEx_GetI3CCLKFreq+0x24c>)
3401704c:	4293      	cmp	r3, r2
3401704e:	f200 80c3 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017052:	4a70      	ldr	r2, [pc, #448]	@ (34017214 <RCCEx_GetI3CCLKFreq+0x250>)
34017054:	4293      	cmp	r3, r2
34017056:	d01d      	beq.n	34017094 <RCCEx_GetI3CCLKFreq+0xd0>
34017058:	4a6e      	ldr	r2, [pc, #440]	@ (34017214 <RCCEx_GetI3CCLKFreq+0x250>)
3401705a:	4293      	cmp	r3, r2
3401705c:	f200 80bc 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
34017060:	4a6d      	ldr	r2, [pc, #436]	@ (34017218 <RCCEx_GetI3CCLKFreq+0x254>)
34017062:	4293      	cmp	r3, r2
34017064:	d016      	beq.n	34017094 <RCCEx_GetI3CCLKFreq+0xd0>
34017066:	4a6c      	ldr	r2, [pc, #432]	@ (34017218 <RCCEx_GetI3CCLKFreq+0x254>)
34017068:	4293      	cmp	r3, r2
3401706a:	f200 80b5 	bhi.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
3401706e:	4a6b      	ldr	r2, [pc, #428]	@ (3401721c <RCCEx_GetI3CCLKFreq+0x258>)
34017070:	4293      	cmp	r3, r2
34017072:	d003      	beq.n	3401707c <RCCEx_GetI3CCLKFreq+0xb8>
34017074:	4a6a      	ldr	r2, [pc, #424]	@ (34017220 <RCCEx_GetI3CCLKFreq+0x25c>)
34017076:	4293      	cmp	r3, r2
34017078:	f040 80ae 	bne.w	340171d8 <RCCEx_GetI3CCLKFreq+0x214>
  {
    case LL_RCC_I3C1_CLKSOURCE_PCLK1:
    case LL_RCC_I3C2_CLKSOURCE_PCLK1:
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3401707c:	f7f5 fd4e 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017080:	4603      	mov	r3, r0
34017082:	4618      	mov	r0, r3
34017084:	f7fe fe42 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017088:	4603      	mov	r3, r0
3401708a:	4618      	mov	r0, r3
3401708c:	f7fe fe4f 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34017090:	60f8      	str	r0, [r7, #12]
      break;
34017092:	e0aa      	b.n	340171ea <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_CLKP:
    case LL_RCC_I3C2_CLKSOURCE_CLKP:
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017094:	2007      	movs	r0, #7
34017096:	f7ff f925 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401709a:	60f8      	str	r0, [r7, #12]
      break;
3401709c:	e0a5      	b.n	340171ea <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_IC10:
    case LL_RCC_I3C2_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
3401709e:	f7f7 f99f 	bl	3400e3e0 <LL_RCC_IC10_IsEnabled>
340170a2:	4603      	mov	r3, r0
340170a4:	2b00      	cmp	r3, #0
340170a6:	f000 8099 	beq.w	340171dc <RCCEx_GetI3CCLKFreq+0x218>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
340170aa:	f7f7 f9bb 	bl	3400e424 <LL_RCC_IC10_GetDivider>
340170ae:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
340170b0:	f7f7 f9aa 	bl	3400e408 <LL_RCC_IC10_GetSource>
340170b4:	4603      	mov	r3, r0
340170b6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340170ba:	d029      	beq.n	34017110 <RCCEx_GetI3CCLKFreq+0x14c>
340170bc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340170c0:	d82f      	bhi.n	34017122 <RCCEx_GetI3CCLKFreq+0x15e>
340170c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340170c6:	d01a      	beq.n	340170fe <RCCEx_GetI3CCLKFreq+0x13a>
340170c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340170cc:	d829      	bhi.n	34017122 <RCCEx_GetI3CCLKFreq+0x15e>
340170ce:	2b00      	cmp	r3, #0
340170d0:	d003      	beq.n	340170da <RCCEx_GetI3CCLKFreq+0x116>
340170d2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340170d6:	d009      	beq.n	340170ec <RCCEx_GetI3CCLKFreq+0x128>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340170d8:	e023      	b.n	34017122 <RCCEx_GetI3CCLKFreq+0x15e>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340170da:	f7fe fcff 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340170de:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340170e0:	68fa      	ldr	r2, [r7, #12]
340170e2:	68bb      	ldr	r3, [r7, #8]
340170e4:	fbb2 f3f3 	udiv	r3, r2, r3
340170e8:	60fb      	str	r3, [r7, #12]
            break;
340170ea:	e01b      	b.n	34017124 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340170ec:	f7fe fd3c 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340170f0:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340170f2:	68fa      	ldr	r2, [r7, #12]
340170f4:	68bb      	ldr	r3, [r7, #8]
340170f6:	fbb2 f3f3 	udiv	r3, r2, r3
340170fa:	60fb      	str	r3, [r7, #12]
            break;
340170fc:	e012      	b.n	34017124 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340170fe:	f7fe fd79 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017102:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34017104:	68fa      	ldr	r2, [r7, #12]
34017106:	68bb      	ldr	r3, [r7, #8]
34017108:	fbb2 f3f3 	udiv	r3, r2, r3
3401710c:	60fb      	str	r3, [r7, #12]
            break;
3401710e:	e009      	b.n	34017124 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017110:	f7fe fdb6 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017114:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34017116:	68fa      	ldr	r2, [r7, #12]
34017118:	68bb      	ldr	r3, [r7, #8]
3401711a:	fbb2 f3f3 	udiv	r3, r2, r3
3401711e:	60fb      	str	r3, [r7, #12]
            break;
34017120:	e000      	b.n	34017124 <RCCEx_GetI3CCLKFreq+0x160>
            break;
34017122:	bf00      	nop
        }
      }
      break;
34017124:	e05a      	b.n	340171dc <RCCEx_GetI3CCLKFreq+0x218>

    case LL_RCC_I3C1_CLKSOURCE_IC15:
    case LL_RCC_I3C2_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34017126:	f7f7 fa5b 	bl	3400e5e0 <LL_RCC_IC15_IsEnabled>
3401712a:	4603      	mov	r3, r0
3401712c:	2b00      	cmp	r3, #0
3401712e:	d057      	beq.n	340171e0 <RCCEx_GetI3CCLKFreq+0x21c>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34017130:	f7f7 fa78 	bl	3400e624 <LL_RCC_IC15_GetDivider>
34017134:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34017136:	f7f7 fa67 	bl	3400e608 <LL_RCC_IC15_GetSource>
3401713a:	4603      	mov	r3, r0
3401713c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017140:	d029      	beq.n	34017196 <RCCEx_GetI3CCLKFreq+0x1d2>
34017142:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017146:	d82f      	bhi.n	340171a8 <RCCEx_GetI3CCLKFreq+0x1e4>
34017148:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401714c:	d01a      	beq.n	34017184 <RCCEx_GetI3CCLKFreq+0x1c0>
3401714e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017152:	d829      	bhi.n	340171a8 <RCCEx_GetI3CCLKFreq+0x1e4>
34017154:	2b00      	cmp	r3, #0
34017156:	d003      	beq.n	34017160 <RCCEx_GetI3CCLKFreq+0x19c>
34017158:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401715c:	d009      	beq.n	34017172 <RCCEx_GetI3CCLKFreq+0x1ae>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401715e:	e023      	b.n	340171a8 <RCCEx_GetI3CCLKFreq+0x1e4>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017160:	f7fe fcbc 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34017164:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34017166:	68fa      	ldr	r2, [r7, #12]
34017168:	68bb      	ldr	r3, [r7, #8]
3401716a:	fbb2 f3f3 	udiv	r3, r2, r3
3401716e:	60fb      	str	r3, [r7, #12]
            break;
34017170:	e01b      	b.n	340171aa <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34017172:	f7fe fcf9 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017176:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34017178:	68fa      	ldr	r2, [r7, #12]
3401717a:	68bb      	ldr	r3, [r7, #8]
3401717c:	fbb2 f3f3 	udiv	r3, r2, r3
34017180:	60fb      	str	r3, [r7, #12]
            break;
34017182:	e012      	b.n	340171aa <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34017184:	f7fe fd36 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017188:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3401718a:	68fa      	ldr	r2, [r7, #12]
3401718c:	68bb      	ldr	r3, [r7, #8]
3401718e:	fbb2 f3f3 	udiv	r3, r2, r3
34017192:	60fb      	str	r3, [r7, #12]
            break;
34017194:	e009      	b.n	340171aa <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017196:	f7fe fd73 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
3401719a:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3401719c:	68fa      	ldr	r2, [r7, #12]
3401719e:	68bb      	ldr	r3, [r7, #8]
340171a0:	fbb2 f3f3 	udiv	r3, r2, r3
340171a4:	60fb      	str	r3, [r7, #12]
            break;
340171a6:	e000      	b.n	340171aa <RCCEx_GetI3CCLKFreq+0x1e6>
            break;
340171a8:	bf00      	nop
        }
      }
      break;
340171aa:	e019      	b.n	340171e0 <RCCEx_GetI3CCLKFreq+0x21c>

    case LL_RCC_I3C1_CLKSOURCE_HSI:
    case LL_RCC_I3C2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340171ac:	f7f6 f8b4 	bl	3400d318 <LL_RCC_HSI_IsReady>
340171b0:	4603      	mov	r3, r0
340171b2:	2b00      	cmp	r3, #0
340171b4:	d016      	beq.n	340171e4 <RCCEx_GetI3CCLKFreq+0x220>
      {
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340171b6:	f7f6 f8c1 	bl	3400d33c <LL_RCC_HSI_GetDivider>
340171ba:	4603      	mov	r3, r0
340171bc:	09db      	lsrs	r3, r3, #7
340171be:	4a19      	ldr	r2, [pc, #100]	@ (34017224 <RCCEx_GetI3CCLKFreq+0x260>)
340171c0:	fa22 f303 	lsr.w	r3, r2, r3
340171c4:	60fb      	str	r3, [r7, #12]
      }
      break;
340171c6:	e00d      	b.n	340171e4 <RCCEx_GetI3CCLKFreq+0x220>

    case LL_RCC_I3C1_CLKSOURCE_MSI:
    case LL_RCC_I3C2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340171c8:	f7f6 f8c6 	bl	3400d358 <LL_RCC_MSI_IsReady>
340171cc:	4603      	mov	r3, r0
340171ce:	2b00      	cmp	r3, #0
340171d0:	d00a      	beq.n	340171e8 <RCCEx_GetI3CCLKFreq+0x224>
      {
        i3c_frequency = MSI_VALUE;
340171d2:	4b15      	ldr	r3, [pc, #84]	@ (34017228 <RCCEx_GetI3CCLKFreq+0x264>)
340171d4:	60fb      	str	r3, [r7, #12]
      }
      break;
340171d6:	e007      	b.n	340171e8 <RCCEx_GetI3CCLKFreq+0x224>

    default:
      /* Unexpected case */
      break;
340171d8:	bf00      	nop
340171da:	e006      	b.n	340171ea <RCCEx_GetI3CCLKFreq+0x226>
      break;
340171dc:	bf00      	nop
340171de:	e004      	b.n	340171ea <RCCEx_GetI3CCLKFreq+0x226>
      break;
340171e0:	bf00      	nop
340171e2:	e002      	b.n	340171ea <RCCEx_GetI3CCLKFreq+0x226>
      break;
340171e4:	bf00      	nop
340171e6:	e000      	b.n	340171ea <RCCEx_GetI3CCLKFreq+0x226>
      break;
340171e8:	bf00      	nop
  }

  return i3c_frequency;
340171ea:	68fb      	ldr	r3, [r7, #12]
}
340171ec:	4618      	mov	r0, r3
340171ee:	3710      	adds	r7, #16
340171f0:	46bd      	mov	sp, r7
340171f2:	bd80      	pop	{r7, pc}
340171f4:	0705140c 	.word	0x0705140c
340171f8:	0705100c 	.word	0x0705100c
340171fc:	0704140c 	.word	0x0704140c
34017200:	0704100c 	.word	0x0704100c
34017204:	0703140c 	.word	0x0703140c
34017208:	0703100c 	.word	0x0703100c
3401720c:	0702140c 	.word	0x0702140c
34017210:	0702100c 	.word	0x0702100c
34017214:	0701140c 	.word	0x0701140c
34017218:	0701100c 	.word	0x0701100c
3401721c:	0700100c 	.word	0x0700100c
34017220:	0700140c 	.word	0x0700140c
34017224:	03d09000 	.word	0x03d09000
34017228:	003d0900 	.word	0x003d0900

3401722c <RCCEx_GetLPTIMCLKFreq>:
  *         @arg @ref RCCEx_LPTIM5_Clock_Source
  * @retval LPTIM clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPTIMCLKFreq(uint32_t LPTIMxSource)
{
3401722c:	b590      	push	{r4, r7, lr}
3401722e:	b085      	sub	sp, #20
34017230:	af00      	add	r7, sp, #0
34017232:	6078      	str	r0, [r7, #4]
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
34017234:	2300      	movs	r3, #0
34017236:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34017238:	6878      	ldr	r0, [r7, #4]
3401723a:	f7f6 fbcb 	bl	3400d9d4 <LL_RCC_GetLPTIMClockSource>
3401723e:	4603      	mov	r3, r0
34017240:	4aa1      	ldr	r2, [pc, #644]	@ (340174c8 <RCCEx_GetLPTIMCLKFreq+0x29c>)
34017242:	4293      	cmp	r3, r2
34017244:	f000 8185 	beq.w	34017552 <RCCEx_GetLPTIMCLKFreq+0x326>
34017248:	4a9f      	ldr	r2, [pc, #636]	@ (340174c8 <RCCEx_GetLPTIMCLKFreq+0x29c>)
3401724a:	4293      	cmp	r3, r2
3401724c:	f200 818b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017250:	4a9e      	ldr	r2, [pc, #632]	@ (340174cc <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34017252:	4293      	cmp	r3, r2
34017254:	f000 817d 	beq.w	34017552 <RCCEx_GetLPTIMCLKFreq+0x326>
34017258:	4a9c      	ldr	r2, [pc, #624]	@ (340174cc <RCCEx_GetLPTIMCLKFreq+0x2a0>)
3401725a:	4293      	cmp	r3, r2
3401725c:	f200 8183 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017260:	4a9b      	ldr	r2, [pc, #620]	@ (340174d0 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34017262:	4293      	cmp	r3, r2
34017264:	f000 8175 	beq.w	34017552 <RCCEx_GetLPTIMCLKFreq+0x326>
34017268:	4a99      	ldr	r2, [pc, #612]	@ (340174d0 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
3401726a:	4293      	cmp	r3, r2
3401726c:	f200 817b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017270:	4a98      	ldr	r2, [pc, #608]	@ (340174d4 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
34017272:	4293      	cmp	r3, r2
34017274:	f000 816d 	beq.w	34017552 <RCCEx_GetLPTIMCLKFreq+0x326>
34017278:	4a96      	ldr	r2, [pc, #600]	@ (340174d4 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
3401727a:	4293      	cmp	r3, r2
3401727c:	f200 8173 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017280:	4a95      	ldr	r2, [pc, #596]	@ (340174d8 <RCCEx_GetLPTIMCLKFreq+0x2ac>)
34017282:	4293      	cmp	r3, r2
34017284:	f000 8165 	beq.w	34017552 <RCCEx_GetLPTIMCLKFreq+0x326>
34017288:	4a93      	ldr	r2, [pc, #588]	@ (340174d8 <RCCEx_GetLPTIMCLKFreq+0x2ac>)
3401728a:	4293      	cmp	r3, r2
3401728c:	f200 816b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017290:	4a92      	ldr	r2, [pc, #584]	@ (340174dc <RCCEx_GetLPTIMCLKFreq+0x2b0>)
34017292:	4293      	cmp	r3, r2
34017294:	f000 8154 	beq.w	34017540 <RCCEx_GetLPTIMCLKFreq+0x314>
34017298:	4a90      	ldr	r2, [pc, #576]	@ (340174dc <RCCEx_GetLPTIMCLKFreq+0x2b0>)
3401729a:	4293      	cmp	r3, r2
3401729c:	f200 8163 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340172a0:	4a8f      	ldr	r2, [pc, #572]	@ (340174e0 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
340172a2:	4293      	cmp	r3, r2
340172a4:	f000 814c 	beq.w	34017540 <RCCEx_GetLPTIMCLKFreq+0x314>
340172a8:	4a8d      	ldr	r2, [pc, #564]	@ (340174e0 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
340172aa:	4293      	cmp	r3, r2
340172ac:	f200 815b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340172b0:	4a8c      	ldr	r2, [pc, #560]	@ (340174e4 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
340172b2:	4293      	cmp	r3, r2
340172b4:	f000 8144 	beq.w	34017540 <RCCEx_GetLPTIMCLKFreq+0x314>
340172b8:	4a8a      	ldr	r2, [pc, #552]	@ (340174e4 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
340172ba:	4293      	cmp	r3, r2
340172bc:	f200 8153 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340172c0:	4a89      	ldr	r2, [pc, #548]	@ (340174e8 <RCCEx_GetLPTIMCLKFreq+0x2bc>)
340172c2:	4293      	cmp	r3, r2
340172c4:	f000 813c 	beq.w	34017540 <RCCEx_GetLPTIMCLKFreq+0x314>
340172c8:	4a87      	ldr	r2, [pc, #540]	@ (340174e8 <RCCEx_GetLPTIMCLKFreq+0x2bc>)
340172ca:	4293      	cmp	r3, r2
340172cc:	f200 814b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340172d0:	4a86      	ldr	r2, [pc, #536]	@ (340174ec <RCCEx_GetLPTIMCLKFreq+0x2c0>)
340172d2:	4293      	cmp	r3, r2
340172d4:	f000 8134 	beq.w	34017540 <RCCEx_GetLPTIMCLKFreq+0x314>
340172d8:	4a84      	ldr	r2, [pc, #528]	@ (340174ec <RCCEx_GetLPTIMCLKFreq+0x2c0>)
340172da:	4293      	cmp	r3, r2
340172dc:	f200 8143 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340172e0:	4a83      	ldr	r2, [pc, #524]	@ (340174f0 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
340172e2:	4293      	cmp	r3, r2
340172e4:	f000 80e7 	beq.w	340174b6 <RCCEx_GetLPTIMCLKFreq+0x28a>
340172e8:	4a81      	ldr	r2, [pc, #516]	@ (340174f0 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
340172ea:	4293      	cmp	r3, r2
340172ec:	f200 813b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340172f0:	4a80      	ldr	r2, [pc, #512]	@ (340174f4 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
340172f2:	4293      	cmp	r3, r2
340172f4:	f000 80df 	beq.w	340174b6 <RCCEx_GetLPTIMCLKFreq+0x28a>
340172f8:	4a7e      	ldr	r2, [pc, #504]	@ (340174f4 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
340172fa:	4293      	cmp	r3, r2
340172fc:	f200 8133 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017300:	4a7d      	ldr	r2, [pc, #500]	@ (340174f8 <RCCEx_GetLPTIMCLKFreq+0x2cc>)
34017302:	4293      	cmp	r3, r2
34017304:	f000 80d7 	beq.w	340174b6 <RCCEx_GetLPTIMCLKFreq+0x28a>
34017308:	4a7b      	ldr	r2, [pc, #492]	@ (340174f8 <RCCEx_GetLPTIMCLKFreq+0x2cc>)
3401730a:	4293      	cmp	r3, r2
3401730c:	f200 812b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017310:	4a7a      	ldr	r2, [pc, #488]	@ (340174fc <RCCEx_GetLPTIMCLKFreq+0x2d0>)
34017312:	4293      	cmp	r3, r2
34017314:	f000 80cf 	beq.w	340174b6 <RCCEx_GetLPTIMCLKFreq+0x28a>
34017318:	4a78      	ldr	r2, [pc, #480]	@ (340174fc <RCCEx_GetLPTIMCLKFreq+0x2d0>)
3401731a:	4293      	cmp	r3, r2
3401731c:	f200 8123 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017320:	4a77      	ldr	r2, [pc, #476]	@ (34017500 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
34017322:	4293      	cmp	r3, r2
34017324:	f000 80c7 	beq.w	340174b6 <RCCEx_GetLPTIMCLKFreq+0x28a>
34017328:	4a75      	ldr	r2, [pc, #468]	@ (34017500 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
3401732a:	4293      	cmp	r3, r2
3401732c:	f200 811b 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017330:	4a74      	ldr	r2, [pc, #464]	@ (34017504 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
34017332:	4293      	cmp	r3, r2
34017334:	d07b      	beq.n	3401742e <RCCEx_GetLPTIMCLKFreq+0x202>
34017336:	4a73      	ldr	r2, [pc, #460]	@ (34017504 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
34017338:	4293      	cmp	r3, r2
3401733a:	f200 8114 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
3401733e:	4a72      	ldr	r2, [pc, #456]	@ (34017508 <RCCEx_GetLPTIMCLKFreq+0x2dc>)
34017340:	4293      	cmp	r3, r2
34017342:	d074      	beq.n	3401742e <RCCEx_GetLPTIMCLKFreq+0x202>
34017344:	4a70      	ldr	r2, [pc, #448]	@ (34017508 <RCCEx_GetLPTIMCLKFreq+0x2dc>)
34017346:	4293      	cmp	r3, r2
34017348:	f200 810d 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
3401734c:	4a6f      	ldr	r2, [pc, #444]	@ (3401750c <RCCEx_GetLPTIMCLKFreq+0x2e0>)
3401734e:	4293      	cmp	r3, r2
34017350:	d06d      	beq.n	3401742e <RCCEx_GetLPTIMCLKFreq+0x202>
34017352:	4a6e      	ldr	r2, [pc, #440]	@ (3401750c <RCCEx_GetLPTIMCLKFreq+0x2e0>)
34017354:	4293      	cmp	r3, r2
34017356:	f200 8106 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
3401735a:	4a6d      	ldr	r2, [pc, #436]	@ (34017510 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
3401735c:	4293      	cmp	r3, r2
3401735e:	d066      	beq.n	3401742e <RCCEx_GetLPTIMCLKFreq+0x202>
34017360:	4a6b      	ldr	r2, [pc, #428]	@ (34017510 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
34017362:	4293      	cmp	r3, r2
34017364:	f200 80ff 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017368:	4a6a      	ldr	r2, [pc, #424]	@ (34017514 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
3401736a:	4293      	cmp	r3, r2
3401736c:	d05f      	beq.n	3401742e <RCCEx_GetLPTIMCLKFreq+0x202>
3401736e:	4a69      	ldr	r2, [pc, #420]	@ (34017514 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34017370:	4293      	cmp	r3, r2
34017372:	f200 80f8 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017376:	4a68      	ldr	r2, [pc, #416]	@ (34017518 <RCCEx_GetLPTIMCLKFreq+0x2ec>)
34017378:	4293      	cmp	r3, r2
3401737a:	d053      	beq.n	34017424 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3401737c:	4a66      	ldr	r2, [pc, #408]	@ (34017518 <RCCEx_GetLPTIMCLKFreq+0x2ec>)
3401737e:	4293      	cmp	r3, r2
34017380:	f200 80f1 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017384:	4a65      	ldr	r2, [pc, #404]	@ (3401751c <RCCEx_GetLPTIMCLKFreq+0x2f0>)
34017386:	4293      	cmp	r3, r2
34017388:	d04c      	beq.n	34017424 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3401738a:	4a64      	ldr	r2, [pc, #400]	@ (3401751c <RCCEx_GetLPTIMCLKFreq+0x2f0>)
3401738c:	4293      	cmp	r3, r2
3401738e:	f200 80ea 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
34017392:	4a63      	ldr	r2, [pc, #396]	@ (34017520 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
34017394:	4293      	cmp	r3, r2
34017396:	d045      	beq.n	34017424 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34017398:	4a61      	ldr	r2, [pc, #388]	@ (34017520 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
3401739a:	4293      	cmp	r3, r2
3401739c:	f200 80e3 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340173a0:	4a60      	ldr	r2, [pc, #384]	@ (34017524 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
340173a2:	4293      	cmp	r3, r2
340173a4:	d03e      	beq.n	34017424 <RCCEx_GetLPTIMCLKFreq+0x1f8>
340173a6:	4a5f      	ldr	r2, [pc, #380]	@ (34017524 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
340173a8:	4293      	cmp	r3, r2
340173aa:	f200 80dc 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340173ae:	4a5e      	ldr	r2, [pc, #376]	@ (34017528 <RCCEx_GetLPTIMCLKFreq+0x2fc>)
340173b0:	4293      	cmp	r3, r2
340173b2:	d037      	beq.n	34017424 <RCCEx_GetLPTIMCLKFreq+0x1f8>
340173b4:	4a5c      	ldr	r2, [pc, #368]	@ (34017528 <RCCEx_GetLPTIMCLKFreq+0x2fc>)
340173b6:	4293      	cmp	r3, r2
340173b8:	f200 80d5 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340173bc:	4a5b      	ldr	r2, [pc, #364]	@ (3401752c <RCCEx_GetLPTIMCLKFreq+0x300>)
340173be:	4293      	cmp	r3, r2
340173c0:	d024      	beq.n	3401740c <RCCEx_GetLPTIMCLKFreq+0x1e0>
340173c2:	4a5a      	ldr	r2, [pc, #360]	@ (3401752c <RCCEx_GetLPTIMCLKFreq+0x300>)
340173c4:	4293      	cmp	r3, r2
340173c6:	f200 80ce 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340173ca:	4a59      	ldr	r2, [pc, #356]	@ (34017530 <RCCEx_GetLPTIMCLKFreq+0x304>)
340173cc:	4293      	cmp	r3, r2
340173ce:	d01d      	beq.n	3401740c <RCCEx_GetLPTIMCLKFreq+0x1e0>
340173d0:	4a57      	ldr	r2, [pc, #348]	@ (34017530 <RCCEx_GetLPTIMCLKFreq+0x304>)
340173d2:	4293      	cmp	r3, r2
340173d4:	f200 80c7 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340173d8:	4a56      	ldr	r2, [pc, #344]	@ (34017534 <RCCEx_GetLPTIMCLKFreq+0x308>)
340173da:	4293      	cmp	r3, r2
340173dc:	d016      	beq.n	3401740c <RCCEx_GetLPTIMCLKFreq+0x1e0>
340173de:	4a55      	ldr	r2, [pc, #340]	@ (34017534 <RCCEx_GetLPTIMCLKFreq+0x308>)
340173e0:	4293      	cmp	r3, r2
340173e2:	f200 80c0 	bhi.w	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
340173e6:	4a54      	ldr	r2, [pc, #336]	@ (34017538 <RCCEx_GetLPTIMCLKFreq+0x30c>)
340173e8:	4293      	cmp	r3, r2
340173ea:	d003      	beq.n	340173f4 <RCCEx_GetLPTIMCLKFreq+0x1c8>
340173ec:	4a53      	ldr	r2, [pc, #332]	@ (3401753c <RCCEx_GetLPTIMCLKFreq+0x310>)
340173ee:	4293      	cmp	r3, r2
340173f0:	d00c      	beq.n	3401740c <RCCEx_GetLPTIMCLKFreq+0x1e0>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
340173f2:	e0b8      	b.n	34017566 <RCCEx_GetLPTIMCLKFreq+0x33a>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340173f4:	f7f5 fb92 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
340173f8:	4603      	mov	r3, r0
340173fa:	4618      	mov	r0, r3
340173fc:	f7fe fc86 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017400:	4603      	mov	r3, r0
34017402:	4618      	mov	r0, r3
34017404:	f7fe fc93 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34017408:	60f8      	str	r0, [r7, #12]
      break;
3401740a:	e0b3      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3401740c:	f7f5 fb86 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017410:	4603      	mov	r3, r0
34017412:	4618      	mov	r0, r3
34017414:	f7fe fc7a 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017418:	4603      	mov	r3, r0
3401741a:	4618      	mov	r0, r3
3401741c:	f7fe fca8 	bl	34015d70 <RCCEx_GetPCLK4Freq>
34017420:	60f8      	str	r0, [r7, #12]
      break;
34017422:	e0a7      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017424:	2007      	movs	r0, #7
34017426:	f7fe ff5d 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401742a:	60f8      	str	r0, [r7, #12]
      break;
3401742c:	e0a2      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3401742e:	f7f7 f8d7 	bl	3400e5e0 <LL_RCC_IC15_IsEnabled>
34017432:	4603      	mov	r3, r0
34017434:	2b00      	cmp	r3, #0
34017436:	f000 8098 	beq.w	3401756a <RCCEx_GetLPTIMCLKFreq+0x33e>
        ic_divider = LL_RCC_IC15_GetDivider();
3401743a:	f7f7 f8f3 	bl	3400e624 <LL_RCC_IC15_GetDivider>
3401743e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34017440:	f7f7 f8e2 	bl	3400e608 <LL_RCC_IC15_GetSource>
34017444:	4603      	mov	r3, r0
34017446:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401744a:	d029      	beq.n	340174a0 <RCCEx_GetLPTIMCLKFreq+0x274>
3401744c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017450:	d82f      	bhi.n	340174b2 <RCCEx_GetLPTIMCLKFreq+0x286>
34017452:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017456:	d01a      	beq.n	3401748e <RCCEx_GetLPTIMCLKFreq+0x262>
34017458:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401745c:	d829      	bhi.n	340174b2 <RCCEx_GetLPTIMCLKFreq+0x286>
3401745e:	2b00      	cmp	r3, #0
34017460:	d003      	beq.n	3401746a <RCCEx_GetLPTIMCLKFreq+0x23e>
34017462:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017466:	d009      	beq.n	3401747c <RCCEx_GetLPTIMCLKFreq+0x250>
            break;
34017468:	e023      	b.n	340174b2 <RCCEx_GetLPTIMCLKFreq+0x286>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401746a:	f7fe fb37 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401746e:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34017470:	68fa      	ldr	r2, [r7, #12]
34017472:	68bb      	ldr	r3, [r7, #8]
34017474:	fbb2 f3f3 	udiv	r3, r2, r3
34017478:	60fb      	str	r3, [r7, #12]
            break;
3401747a:	e01b      	b.n	340174b4 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401747c:	f7fe fb74 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017480:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34017482:	68fa      	ldr	r2, [r7, #12]
34017484:	68bb      	ldr	r3, [r7, #8]
34017486:	fbb2 f3f3 	udiv	r3, r2, r3
3401748a:	60fb      	str	r3, [r7, #12]
            break;
3401748c:	e012      	b.n	340174b4 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401748e:	f7fe fbb1 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017492:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34017494:	68fa      	ldr	r2, [r7, #12]
34017496:	68bb      	ldr	r3, [r7, #8]
34017498:	fbb2 f3f3 	udiv	r3, r2, r3
3401749c:	60fb      	str	r3, [r7, #12]
            break;
3401749e:	e009      	b.n	340174b4 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340174a0:	f7fe fbee 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340174a4:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340174a6:	68fa      	ldr	r2, [r7, #12]
340174a8:	68bb      	ldr	r3, [r7, #8]
340174aa:	fbb2 f3f3 	udiv	r3, r2, r3
340174ae:	60fb      	str	r3, [r7, #12]
            break;
340174b0:	e000      	b.n	340174b4 <RCCEx_GetLPTIMCLKFreq+0x288>
            break;
340174b2:	bf00      	nop
      break;
340174b4:	e059      	b.n	3401756a <RCCEx_GetLPTIMCLKFreq+0x33e>
      if (LL_RCC_LSE_IsReady() != 0U)
340174b6:	f7f5 ff6f 	bl	3400d398 <LL_RCC_LSE_IsReady>
340174ba:	4603      	mov	r3, r0
340174bc:	2b00      	cmp	r3, #0
340174be:	d056      	beq.n	3401756e <RCCEx_GetLPTIMCLKFreq+0x342>
        lptim_frequency = LSE_VALUE;
340174c0:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
340174c4:	60fb      	str	r3, [r7, #12]
      break;
340174c6:	e052      	b.n	3401756e <RCCEx_GetLPTIMCLKFreq+0x342>
340174c8:	0705182c 	.word	0x0705182c
340174cc:	0705142c 	.word	0x0705142c
340174d0:	0705102c 	.word	0x0705102c
340174d4:	07050c2c 	.word	0x07050c2c
340174d8:	0705082c 	.word	0x0705082c
340174dc:	0704182c 	.word	0x0704182c
340174e0:	0704142c 	.word	0x0704142c
340174e4:	0704102c 	.word	0x0704102c
340174e8:	07040c2c 	.word	0x07040c2c
340174ec:	0704082c 	.word	0x0704082c
340174f0:	0703182c 	.word	0x0703182c
340174f4:	0703142c 	.word	0x0703142c
340174f8:	0703102c 	.word	0x0703102c
340174fc:	07030c2c 	.word	0x07030c2c
34017500:	0703082c 	.word	0x0703082c
34017504:	0702182c 	.word	0x0702182c
34017508:	0702142c 	.word	0x0702142c
3401750c:	0702102c 	.word	0x0702102c
34017510:	07020c2c 	.word	0x07020c2c
34017514:	0702082c 	.word	0x0702082c
34017518:	0701182c 	.word	0x0701182c
3401751c:	0701142c 	.word	0x0701142c
34017520:	0701102c 	.word	0x0701102c
34017524:	07010c2c 	.word	0x07010c2c
34017528:	0701082c 	.word	0x0701082c
3401752c:	0700182c 	.word	0x0700182c
34017530:	0700142c 	.word	0x0700142c
34017534:	0700102c 	.word	0x0700102c
34017538:	0700082c 	.word	0x0700082c
3401753c:	07000c2c 	.word	0x07000c2c
      if (LL_RCC_LSI_IsReady() != 0U)
34017540:	f7f5 ff3c 	bl	3400d3bc <LL_RCC_LSI_IsReady>
34017544:	4603      	mov	r3, r0
34017546:	2b00      	cmp	r3, #0
34017548:	d013      	beq.n	34017572 <RCCEx_GetLPTIMCLKFreq+0x346>
        lptim_frequency = LSI_VALUE;
3401754a:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
3401754e:	60fb      	str	r3, [r7, #12]
      break;
34017550:	e00f      	b.n	34017572 <RCCEx_GetLPTIMCLKFreq+0x346>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
34017552:	f7f5 fae3 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017556:	4604      	mov	r4, r0
34017558:	f7f6 fb46 	bl	3400dbe8 <LL_RCC_GetTIMPrescaler>
3401755c:	4603      	mov	r3, r0
3401755e:	fa24 f303 	lsr.w	r3, r4, r3
34017562:	60fb      	str	r3, [r7, #12]
      break;
34017564:	e006      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34017566:	bf00      	nop
34017568:	e004      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
3401756a:	bf00      	nop
3401756c:	e002      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
3401756e:	bf00      	nop
34017570:	e000      	b.n	34017574 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34017572:	bf00      	nop
  }

  return lptim_frequency;
34017574:	68fb      	ldr	r3, [r7, #12]
}
34017576:	4618      	mov	r0, r3
34017578:	3714      	adds	r7, #20
3401757a:	46bd      	mov	sp, r7
3401757c:	bd90      	pop	{r4, r7, pc}
3401757e:	bf00      	nop

34017580 <RCCEx_GetLPUARTCLKFreq>:
  *         @arg @ref RCCEx_LPUART1_Clock_Source
  * @retval LPUART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPUARTCLKFreq(uint32_t LPUARTxSource)
{
34017580:	b580      	push	{r7, lr}
34017582:	b084      	sub	sp, #16
34017584:	af00      	add	r7, sp, #0
34017586:	6078      	str	r0, [r7, #4]
  uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
34017588:	2300      	movs	r3, #0
3401758a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3401758c:	6878      	ldr	r0, [r7, #4]
3401758e:	f7f6 fa2d 	bl	3400d9ec <LL_RCC_GetLPUARTClockSource>
34017592:	4603      	mov	r3, r0
34017594:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34017598:	f000 80c0 	beq.w	3401771c <RCCEx_GetLPUARTCLKFreq+0x19c>
3401759c:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340175a0:	f200 80db 	bhi.w	3401775a <RCCEx_GetLPUARTCLKFreq+0x1da>
340175a4:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
340175a8:	f000 80c6 	beq.w	34017738 <RCCEx_GetLPUARTCLKFreq+0x1b8>
340175ac:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
340175b0:	f200 80d3 	bhi.w	3401775a <RCCEx_GetLPUARTCLKFreq+0x1da>
340175b4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340175b8:	f000 80c6 	beq.w	34017748 <RCCEx_GetLPUARTCLKFreq+0x1c8>
340175bc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340175c0:	f200 80cb 	bhi.w	3401775a <RCCEx_GetLPUARTCLKFreq+0x1da>
340175c4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340175c8:	d065      	beq.n	34017696 <RCCEx_GetLPUARTCLKFreq+0x116>
340175ca:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340175ce:	f200 80c4 	bhi.w	3401775a <RCCEx_GetLPUARTCLKFreq+0x1da>
340175d2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340175d6:	d01a      	beq.n	3401760e <RCCEx_GetLPUARTCLKFreq+0x8e>
340175d8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340175dc:	f200 80bd 	bhi.w	3401775a <RCCEx_GetLPUARTCLKFreq+0x1da>
340175e0:	2b00      	cmp	r3, #0
340175e2:	d003      	beq.n	340175ec <RCCEx_GetLPUARTCLKFreq+0x6c>
340175e4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340175e8:	d00c      	beq.n	34017604 <RCCEx_GetLPUARTCLKFreq+0x84>
      }
      break;

    default:
      /* Unexpected case */
      break;
340175ea:	e0b6      	b.n	3401775a <RCCEx_GetLPUARTCLKFreq+0x1da>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340175ec:	f7f5 fa96 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
340175f0:	4603      	mov	r3, r0
340175f2:	4618      	mov	r0, r3
340175f4:	f7fe fb8a 	bl	34015d0c <RCCEx_GetHCLKFreq>
340175f8:	4603      	mov	r3, r0
340175fa:	4618      	mov	r0, r3
340175fc:	f7fe fbb8 	bl	34015d70 <RCCEx_GetPCLK4Freq>
34017600:	60f8      	str	r0, [r7, #12]
      break;
34017602:	e0b5      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      lpuart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017604:	2007      	movs	r0, #7
34017606:	f7fe fe6d 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401760a:	60f8      	str	r0, [r7, #12]
      break;
3401760c:	e0b0      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3401760e:	f7f6 fea7 	bl	3400e360 <LL_RCC_IC9_IsEnabled>
34017612:	4603      	mov	r3, r0
34017614:	2b00      	cmp	r3, #0
34017616:	f000 80a2 	beq.w	3401775e <RCCEx_GetLPUARTCLKFreq+0x1de>
        ic_divider = LL_RCC_IC9_GetDivider();
3401761a:	f7f6 fec3 	bl	3400e3a4 <LL_RCC_IC9_GetDivider>
3401761e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34017620:	f7f6 feb2 	bl	3400e388 <LL_RCC_IC9_GetSource>
34017624:	4603      	mov	r3, r0
34017626:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401762a:	d029      	beq.n	34017680 <RCCEx_GetLPUARTCLKFreq+0x100>
3401762c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017630:	d82f      	bhi.n	34017692 <RCCEx_GetLPUARTCLKFreq+0x112>
34017632:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017636:	d01a      	beq.n	3401766e <RCCEx_GetLPUARTCLKFreq+0xee>
34017638:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401763c:	d829      	bhi.n	34017692 <RCCEx_GetLPUARTCLKFreq+0x112>
3401763e:	2b00      	cmp	r3, #0
34017640:	d003      	beq.n	3401764a <RCCEx_GetLPUARTCLKFreq+0xca>
34017642:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017646:	d009      	beq.n	3401765c <RCCEx_GetLPUARTCLKFreq+0xdc>
            break;
34017648:	e023      	b.n	34017692 <RCCEx_GetLPUARTCLKFreq+0x112>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401764a:	f7fe fa47 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401764e:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34017650:	68fa      	ldr	r2, [r7, #12]
34017652:	68bb      	ldr	r3, [r7, #8]
34017654:	fbb2 f3f3 	udiv	r3, r2, r3
34017658:	60fb      	str	r3, [r7, #12]
            break;
3401765a:	e01b      	b.n	34017694 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401765c:	f7fe fa84 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017660:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34017662:	68fa      	ldr	r2, [r7, #12]
34017664:	68bb      	ldr	r3, [r7, #8]
34017666:	fbb2 f3f3 	udiv	r3, r2, r3
3401766a:	60fb      	str	r3, [r7, #12]
            break;
3401766c:	e012      	b.n	34017694 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401766e:	f7fe fac1 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017672:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34017674:	68fa      	ldr	r2, [r7, #12]
34017676:	68bb      	ldr	r3, [r7, #8]
34017678:	fbb2 f3f3 	udiv	r3, r2, r3
3401767c:	60fb      	str	r3, [r7, #12]
            break;
3401767e:	e009      	b.n	34017694 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017680:	f7fe fafe 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017684:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34017686:	68fa      	ldr	r2, [r7, #12]
34017688:	68bb      	ldr	r3, [r7, #8]
3401768a:	fbb2 f3f3 	udiv	r3, r2, r3
3401768e:	60fb      	str	r3, [r7, #12]
            break;
34017690:	e000      	b.n	34017694 <RCCEx_GetLPUARTCLKFreq+0x114>
            break;
34017692:	bf00      	nop
      break;
34017694:	e063      	b.n	3401775e <RCCEx_GetLPUARTCLKFreq+0x1de>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34017696:	f7f6 ff63 	bl	3400e560 <LL_RCC_IC14_IsEnabled>
3401769a:	4603      	mov	r3, r0
3401769c:	2b00      	cmp	r3, #0
3401769e:	d060      	beq.n	34017762 <RCCEx_GetLPUARTCLKFreq+0x1e2>
        ic_divider = LL_RCC_IC14_GetDivider();
340176a0:	f7f6 ff80 	bl	3400e5a4 <LL_RCC_IC14_GetDivider>
340176a4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
340176a6:	f7f6 ff6f 	bl	3400e588 <LL_RCC_IC14_GetSource>
340176aa:	4603      	mov	r3, r0
340176ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340176b0:	d029      	beq.n	34017706 <RCCEx_GetLPUARTCLKFreq+0x186>
340176b2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340176b6:	d82f      	bhi.n	34017718 <RCCEx_GetLPUARTCLKFreq+0x198>
340176b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340176bc:	d01a      	beq.n	340176f4 <RCCEx_GetLPUARTCLKFreq+0x174>
340176be:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340176c2:	d829      	bhi.n	34017718 <RCCEx_GetLPUARTCLKFreq+0x198>
340176c4:	2b00      	cmp	r3, #0
340176c6:	d003      	beq.n	340176d0 <RCCEx_GetLPUARTCLKFreq+0x150>
340176c8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340176cc:	d009      	beq.n	340176e2 <RCCEx_GetLPUARTCLKFreq+0x162>
            break;
340176ce:	e023      	b.n	34017718 <RCCEx_GetLPUARTCLKFreq+0x198>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340176d0:	f7fe fa04 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340176d4:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340176d6:	68fa      	ldr	r2, [r7, #12]
340176d8:	68bb      	ldr	r3, [r7, #8]
340176da:	fbb2 f3f3 	udiv	r3, r2, r3
340176de:	60fb      	str	r3, [r7, #12]
            break;
340176e0:	e01b      	b.n	3401771a <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340176e2:	f7fe fa41 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340176e6:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340176e8:	68fa      	ldr	r2, [r7, #12]
340176ea:	68bb      	ldr	r3, [r7, #8]
340176ec:	fbb2 f3f3 	udiv	r3, r2, r3
340176f0:	60fb      	str	r3, [r7, #12]
            break;
340176f2:	e012      	b.n	3401771a <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340176f4:	f7fe fa7e 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340176f8:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340176fa:	68fa      	ldr	r2, [r7, #12]
340176fc:	68bb      	ldr	r3, [r7, #8]
340176fe:	fbb2 f3f3 	udiv	r3, r2, r3
34017702:	60fb      	str	r3, [r7, #12]
            break;
34017704:	e009      	b.n	3401771a <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017706:	f7fe fabb 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
3401770a:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3401770c:	68fa      	ldr	r2, [r7, #12]
3401770e:	68bb      	ldr	r3, [r7, #8]
34017710:	fbb2 f3f3 	udiv	r3, r2, r3
34017714:	60fb      	str	r3, [r7, #12]
            break;
34017716:	e000      	b.n	3401771a <RCCEx_GetLPUARTCLKFreq+0x19a>
            break;
34017718:	bf00      	nop
      break;
3401771a:	e022      	b.n	34017762 <RCCEx_GetLPUARTCLKFreq+0x1e2>
      if (LL_RCC_HSI_IsReady() != 0U)
3401771c:	f7f5 fdfc 	bl	3400d318 <LL_RCC_HSI_IsReady>
34017720:	4603      	mov	r3, r0
34017722:	2b00      	cmp	r3, #0
34017724:	d01f      	beq.n	34017766 <RCCEx_GetLPUARTCLKFreq+0x1e6>
        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34017726:	f7f5 fe09 	bl	3400d33c <LL_RCC_HSI_GetDivider>
3401772a:	4603      	mov	r3, r0
3401772c:	09db      	lsrs	r3, r3, #7
3401772e:	4a13      	ldr	r2, [pc, #76]	@ (3401777c <RCCEx_GetLPUARTCLKFreq+0x1fc>)
34017730:	fa22 f303 	lsr.w	r3, r2, r3
34017734:	60fb      	str	r3, [r7, #12]
      break;
34017736:	e016      	b.n	34017766 <RCCEx_GetLPUARTCLKFreq+0x1e6>
      if (LL_RCC_MSI_IsReady() != 0U)
34017738:	f7f5 fe0e 	bl	3400d358 <LL_RCC_MSI_IsReady>
3401773c:	4603      	mov	r3, r0
3401773e:	2b00      	cmp	r3, #0
34017740:	d013      	beq.n	3401776a <RCCEx_GetLPUARTCLKFreq+0x1ea>
        lpuart_frequency = MSI_VALUE;
34017742:	4b0f      	ldr	r3, [pc, #60]	@ (34017780 <RCCEx_GetLPUARTCLKFreq+0x200>)
34017744:	60fb      	str	r3, [r7, #12]
      break;
34017746:	e010      	b.n	3401776a <RCCEx_GetLPUARTCLKFreq+0x1ea>
      if (LL_RCC_LSE_IsReady() != 0U)
34017748:	f7f5 fe26 	bl	3400d398 <LL_RCC_LSE_IsReady>
3401774c:	4603      	mov	r3, r0
3401774e:	2b00      	cmp	r3, #0
34017750:	d00d      	beq.n	3401776e <RCCEx_GetLPUARTCLKFreq+0x1ee>
        lpuart_frequency = LSE_VALUE;
34017752:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34017756:	60fb      	str	r3, [r7, #12]
      break;
34017758:	e009      	b.n	3401776e <RCCEx_GetLPUARTCLKFreq+0x1ee>
      break;
3401775a:	bf00      	nop
3401775c:	e008      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3401775e:	bf00      	nop
34017760:	e006      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34017762:	bf00      	nop
34017764:	e004      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34017766:	bf00      	nop
34017768:	e002      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3401776a:	bf00      	nop
3401776c:	e000      	b.n	34017770 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3401776e:	bf00      	nop
  }

  return lpuart_frequency;
34017770:	68fb      	ldr	r3, [r7, #12]
}
34017772:	4618      	mov	r0, r3
34017774:	3710      	adds	r7, #16
34017776:	46bd      	mov	sp, r7
34017778:	bd80      	pop	{r7, pc}
3401777a:	bf00      	nop
3401777c:	03d09000 	.word	0x03d09000
34017780:	003d0900 	.word	0x003d0900

34017784 <RCCEx_GetLTDCCLKFreq>:
  *         @arg @ref RCCEx_LTDC_Clock_Source
  * @retval LTDC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLTDCCLKFreq(uint32_t LTDCxSource)
{
34017784:	b580      	push	{r7, lr}
34017786:	b084      	sub	sp, #16
34017788:	af00      	add	r7, sp, #0
3401778a:	6078      	str	r0, [r7, #4]
  uint32_t ltdc_frequency = RCC_PERIPH_FREQUENCY_NO;
3401778c:	2300      	movs	r3, #0
3401778e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
34017790:	6878      	ldr	r0, [r7, #4]
34017792:	f7f6 f93d 	bl	3400da10 <LL_RCC_GetLTDCClockSource>
34017796:	4603      	mov	r3, r0
34017798:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3401779c:	d062      	beq.n	34017864 <RCCEx_GetLTDCCLKFreq+0xe0>
3401779e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340177a2:	d86d      	bhi.n	34017880 <RCCEx_GetLTDCCLKFreq+0xfc>
340177a4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340177a8:	d019      	beq.n	340177de <RCCEx_GetLTDCCLKFreq+0x5a>
340177aa:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340177ae:	d867      	bhi.n	34017880 <RCCEx_GetLTDCCLKFreq+0xfc>
340177b0:	2b00      	cmp	r3, #0
340177b2:	d003      	beq.n	340177bc <RCCEx_GetLTDCCLKFreq+0x38>
340177b4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340177b8:	d00c      	beq.n	340177d4 <RCCEx_GetLTDCCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
340177ba:	e061      	b.n	34017880 <RCCEx_GetLTDCCLKFreq+0xfc>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340177bc:	f7f5 f9ae 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
340177c0:	4603      	mov	r3, r0
340177c2:	4618      	mov	r0, r3
340177c4:	f7fe faa2 	bl	34015d0c <RCCEx_GetHCLKFreq>
340177c8:	4603      	mov	r3, r0
340177ca:	4618      	mov	r0, r3
340177cc:	f7fe fae1 	bl	34015d92 <RCCEx_GetPCLK5Freq>
340177d0:	60f8      	str	r0, [r7, #12]
      break;
340177d2:	e05a      	b.n	3401788a <RCCEx_GetLTDCCLKFreq+0x106>
      ltdc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340177d4:	2007      	movs	r0, #7
340177d6:	f7fe fd85 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
340177da:	60f8      	str	r0, [r7, #12]
      break;
340177dc:	e055      	b.n	3401788a <RCCEx_GetLTDCCLKFreq+0x106>
      if (LL_RCC_IC16_IsEnabled() != 0U)
340177de:	f7f6 ff3f 	bl	3400e660 <LL_RCC_IC16_IsEnabled>
340177e2:	4603      	mov	r3, r0
340177e4:	2b00      	cmp	r3, #0
340177e6:	d04d      	beq.n	34017884 <RCCEx_GetLTDCCLKFreq+0x100>
        ic_divider = LL_RCC_IC16_GetDivider();
340177e8:	f7f6 ff5c 	bl	3400e6a4 <LL_RCC_IC16_GetDivider>
340177ec:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC16_GetSource())
340177ee:	f7f6 ff4b 	bl	3400e688 <LL_RCC_IC16_GetSource>
340177f2:	4603      	mov	r3, r0
340177f4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340177f8:	d029      	beq.n	3401784e <RCCEx_GetLTDCCLKFreq+0xca>
340177fa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340177fe:	d82f      	bhi.n	34017860 <RCCEx_GetLTDCCLKFreq+0xdc>
34017800:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017804:	d01a      	beq.n	3401783c <RCCEx_GetLTDCCLKFreq+0xb8>
34017806:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401780a:	d829      	bhi.n	34017860 <RCCEx_GetLTDCCLKFreq+0xdc>
3401780c:	2b00      	cmp	r3, #0
3401780e:	d003      	beq.n	34017818 <RCCEx_GetLTDCCLKFreq+0x94>
34017810:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017814:	d009      	beq.n	3401782a <RCCEx_GetLTDCCLKFreq+0xa6>
            break;
34017816:	e023      	b.n	34017860 <RCCEx_GetLTDCCLKFreq+0xdc>
            ltdc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017818:	f7fe f960 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401781c:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
3401781e:	68fa      	ldr	r2, [r7, #12]
34017820:	68bb      	ldr	r3, [r7, #8]
34017822:	fbb2 f3f3 	udiv	r3, r2, r3
34017826:	60fb      	str	r3, [r7, #12]
            break;
34017828:	e01b      	b.n	34017862 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401782a:	f7fe f99d 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401782e:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34017830:	68fa      	ldr	r2, [r7, #12]
34017832:	68bb      	ldr	r3, [r7, #8]
34017834:	fbb2 f3f3 	udiv	r3, r2, r3
34017838:	60fb      	str	r3, [r7, #12]
            break;
3401783a:	e012      	b.n	34017862 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401783c:	f7fe f9da 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017840:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34017842:	68fa      	ldr	r2, [r7, #12]
34017844:	68bb      	ldr	r3, [r7, #8]
34017846:	fbb2 f3f3 	udiv	r3, r2, r3
3401784a:	60fb      	str	r3, [r7, #12]
            break;
3401784c:	e009      	b.n	34017862 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401784e:	f7fe fa17 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017852:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34017854:	68fa      	ldr	r2, [r7, #12]
34017856:	68bb      	ldr	r3, [r7, #8]
34017858:	fbb2 f3f3 	udiv	r3, r2, r3
3401785c:	60fb      	str	r3, [r7, #12]
            break;
3401785e:	e000      	b.n	34017862 <RCCEx_GetLTDCCLKFreq+0xde>
            break;
34017860:	bf00      	nop
      break;
34017862:	e00f      	b.n	34017884 <RCCEx_GetLTDCCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
34017864:	f7f5 fd58 	bl	3400d318 <LL_RCC_HSI_IsReady>
34017868:	4603      	mov	r3, r0
3401786a:	2b00      	cmp	r3, #0
3401786c:	d00c      	beq.n	34017888 <RCCEx_GetLTDCCLKFreq+0x104>
        ltdc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3401786e:	f7f5 fd65 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34017872:	4603      	mov	r3, r0
34017874:	09db      	lsrs	r3, r3, #7
34017876:	4a07      	ldr	r2, [pc, #28]	@ (34017894 <RCCEx_GetLTDCCLKFreq+0x110>)
34017878:	fa22 f303 	lsr.w	r3, r2, r3
3401787c:	60fb      	str	r3, [r7, #12]
      break;
3401787e:	e003      	b.n	34017888 <RCCEx_GetLTDCCLKFreq+0x104>
      break;
34017880:	bf00      	nop
34017882:	e002      	b.n	3401788a <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34017884:	bf00      	nop
34017886:	e000      	b.n	3401788a <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34017888:	bf00      	nop
  }

  return ltdc_frequency;
3401788a:	68fb      	ldr	r3, [r7, #12]
}
3401788c:	4618      	mov	r0, r3
3401788e:	3710      	adds	r7, #16
34017890:	46bd      	mov	sp, r7
34017892:	bd80      	pop	{r7, pc}
34017894:	03d09000 	.word	0x03d09000

34017898 <RCCEx_GetMDFCLKFreq>:
  *         @arg @ref RCCEx_MDF1_Clock_Source
  * @retval MDF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetMDFCLKFreq(uint32_t MDFxSource)
{
34017898:	b590      	push	{r4, r7, lr}
3401789a:	b085      	sub	sp, #20
3401789c:	af00      	add	r7, sp, #0
3401789e:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
340178a0:	2300      	movs	r3, #0
340178a2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetMDFClockSource(MDFxSource))
340178a4:	6878      	ldr	r0, [r7, #4]
340178a6:	f7f6 f8c5 	bl	3400da34 <LL_RCC_GetMDFClockSource>
340178aa:	4603      	mov	r3, r0
340178ac:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
340178b0:	f000 80dd 	beq.w	34017a6e <RCCEx_GetMDFCLKFreq+0x1d6>
340178b4:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
340178b8:	f200 80e3 	bhi.w	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
340178bc:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
340178c0:	f000 80d2 	beq.w	34017a68 <RCCEx_GetMDFCLKFreq+0x1d0>
340178c4:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
340178c8:	f200 80db 	bhi.w	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
340178cc:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
340178d0:	f000 80b4 	beq.w	34017a3c <RCCEx_GetMDFCLKFreq+0x1a4>
340178d4:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
340178d8:	f200 80d3 	bhi.w	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
340178dc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340178e0:	f000 80ba 	beq.w	34017a58 <RCCEx_GetMDFCLKFreq+0x1c0>
340178e4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
340178e8:	f200 80cb 	bhi.w	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
340178ec:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340178f0:	d061      	beq.n	340179b6 <RCCEx_GetMDFCLKFreq+0x11e>
340178f2:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340178f6:	f200 80c4 	bhi.w	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
340178fa:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340178fe:	d016      	beq.n	3401792e <RCCEx_GetMDFCLKFreq+0x96>
34017900:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34017904:	f200 80bd 	bhi.w	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
34017908:	2b00      	cmp	r3, #0
3401790a:	d003      	beq.n	34017914 <RCCEx_GetMDFCLKFreq+0x7c>
3401790c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34017910:	d008      	beq.n	34017924 <RCCEx_GetMDFCLKFreq+0x8c>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34017912:	e0b6      	b.n	34017a82 <RCCEx_GetMDFCLKFreq+0x1ea>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34017914:	f7f5 f902 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017918:	4603      	mov	r3, r0
3401791a:	4618      	mov	r0, r3
3401791c:	f7fe f9f6 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017920:	60f8      	str	r0, [r7, #12]
      break;
34017922:	e0b7      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017924:	2007      	movs	r0, #7
34017926:	f7fe fcdd 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401792a:	60f8      	str	r0, [r7, #12]
      break;
3401792c:	e0b2      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3401792e:	f7f6 fc97 	bl	3400e260 <LL_RCC_IC7_IsEnabled>
34017932:	4603      	mov	r3, r0
34017934:	2b00      	cmp	r3, #0
34017936:	f000 80a6 	beq.w	34017a86 <RCCEx_GetMDFCLKFreq+0x1ee>
        ic_divider = LL_RCC_IC7_GetDivider();
3401793a:	f7f6 fcb3 	bl	3400e2a4 <LL_RCC_IC7_GetDivider>
3401793e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34017940:	f7f6 fca2 	bl	3400e288 <LL_RCC_IC7_GetSource>
34017944:	4603      	mov	r3, r0
34017946:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401794a:	d029      	beq.n	340179a0 <RCCEx_GetMDFCLKFreq+0x108>
3401794c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017950:	d82f      	bhi.n	340179b2 <RCCEx_GetMDFCLKFreq+0x11a>
34017952:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017956:	d01a      	beq.n	3401798e <RCCEx_GetMDFCLKFreq+0xf6>
34017958:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401795c:	d829      	bhi.n	340179b2 <RCCEx_GetMDFCLKFreq+0x11a>
3401795e:	2b00      	cmp	r3, #0
34017960:	d003      	beq.n	3401796a <RCCEx_GetMDFCLKFreq+0xd2>
34017962:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017966:	d009      	beq.n	3401797c <RCCEx_GetMDFCLKFreq+0xe4>
            break;
34017968:	e023      	b.n	340179b2 <RCCEx_GetMDFCLKFreq+0x11a>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401796a:	f7fe f8b7 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401796e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34017970:	68fa      	ldr	r2, [r7, #12]
34017972:	68bb      	ldr	r3, [r7, #8]
34017974:	fbb2 f3f3 	udiv	r3, r2, r3
34017978:	60fb      	str	r3, [r7, #12]
            break;
3401797a:	e01b      	b.n	340179b4 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401797c:	f7fe f8f4 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017980:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34017982:	68fa      	ldr	r2, [r7, #12]
34017984:	68bb      	ldr	r3, [r7, #8]
34017986:	fbb2 f3f3 	udiv	r3, r2, r3
3401798a:	60fb      	str	r3, [r7, #12]
            break;
3401798c:	e012      	b.n	340179b4 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401798e:	f7fe f931 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017992:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34017994:	68fa      	ldr	r2, [r7, #12]
34017996:	68bb      	ldr	r3, [r7, #8]
34017998:	fbb2 f3f3 	udiv	r3, r2, r3
3401799c:	60fb      	str	r3, [r7, #12]
            break;
3401799e:	e009      	b.n	340179b4 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340179a0:	f7fe f96e 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340179a4:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340179a6:	68fa      	ldr	r2, [r7, #12]
340179a8:	68bb      	ldr	r3, [r7, #8]
340179aa:	fbb2 f3f3 	udiv	r3, r2, r3
340179ae:	60fb      	str	r3, [r7, #12]
            break;
340179b0:	e000      	b.n	340179b4 <RCCEx_GetMDFCLKFreq+0x11c>
            break;
340179b2:	bf00      	nop
      break;
340179b4:	e067      	b.n	34017a86 <RCCEx_GetMDFCLKFreq+0x1ee>
      if (LL_RCC_IC8_IsEnabled() != 0U)
340179b6:	f7f6 fc93 	bl	3400e2e0 <LL_RCC_IC8_IsEnabled>
340179ba:	4603      	mov	r3, r0
340179bc:	2b00      	cmp	r3, #0
340179be:	d064      	beq.n	34017a8a <RCCEx_GetMDFCLKFreq+0x1f2>
        ic_divider = LL_RCC_IC8_GetDivider();
340179c0:	f7f6 fcb0 	bl	3400e324 <LL_RCC_IC8_GetDivider>
340179c4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
340179c6:	f7f6 fc9f 	bl	3400e308 <LL_RCC_IC8_GetSource>
340179ca:	4603      	mov	r3, r0
340179cc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340179d0:	d029      	beq.n	34017a26 <RCCEx_GetMDFCLKFreq+0x18e>
340179d2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340179d6:	d82f      	bhi.n	34017a38 <RCCEx_GetMDFCLKFreq+0x1a0>
340179d8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340179dc:	d01a      	beq.n	34017a14 <RCCEx_GetMDFCLKFreq+0x17c>
340179de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340179e2:	d829      	bhi.n	34017a38 <RCCEx_GetMDFCLKFreq+0x1a0>
340179e4:	2b00      	cmp	r3, #0
340179e6:	d003      	beq.n	340179f0 <RCCEx_GetMDFCLKFreq+0x158>
340179e8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340179ec:	d009      	beq.n	34017a02 <RCCEx_GetMDFCLKFreq+0x16a>
            break;
340179ee:	e023      	b.n	34017a38 <RCCEx_GetMDFCLKFreq+0x1a0>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340179f0:	f7fe f874 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340179f4:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340179f6:	68fa      	ldr	r2, [r7, #12]
340179f8:	68bb      	ldr	r3, [r7, #8]
340179fa:	fbb2 f3f3 	udiv	r3, r2, r3
340179fe:	60fb      	str	r3, [r7, #12]
            break;
34017a00:	e01b      	b.n	34017a3a <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34017a02:	f7fe f8b1 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017a06:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34017a08:	68fa      	ldr	r2, [r7, #12]
34017a0a:	68bb      	ldr	r3, [r7, #8]
34017a0c:	fbb2 f3f3 	udiv	r3, r2, r3
34017a10:	60fb      	str	r3, [r7, #12]
            break;
34017a12:	e012      	b.n	34017a3a <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34017a14:	f7fe f8ee 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017a18:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34017a1a:	68fa      	ldr	r2, [r7, #12]
34017a1c:	68bb      	ldr	r3, [r7, #8]
34017a1e:	fbb2 f3f3 	udiv	r3, r2, r3
34017a22:	60fb      	str	r3, [r7, #12]
            break;
34017a24:	e009      	b.n	34017a3a <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017a26:	f7fe f92b 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017a2a:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34017a2c:	68fa      	ldr	r2, [r7, #12]
34017a2e:	68bb      	ldr	r3, [r7, #8]
34017a30:	fbb2 f3f3 	udiv	r3, r2, r3
34017a34:	60fb      	str	r3, [r7, #12]
            break;
34017a36:	e000      	b.n	34017a3a <RCCEx_GetMDFCLKFreq+0x1a2>
            break;
34017a38:	bf00      	nop
      break;
34017a3a:	e026      	b.n	34017a8a <RCCEx_GetMDFCLKFreq+0x1f2>
      if (LL_RCC_HSI_IsReady() != 0U)
34017a3c:	f7f5 fc6c 	bl	3400d318 <LL_RCC_HSI_IsReady>
34017a40:	4603      	mov	r3, r0
34017a42:	2b00      	cmp	r3, #0
34017a44:	d023      	beq.n	34017a8e <RCCEx_GetMDFCLKFreq+0x1f6>
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34017a46:	f7f5 fc79 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34017a4a:	4603      	mov	r3, r0
34017a4c:	09db      	lsrs	r3, r3, #7
34017a4e:	4a14      	ldr	r2, [pc, #80]	@ (34017aa0 <RCCEx_GetMDFCLKFreq+0x208>)
34017a50:	fa22 f303 	lsr.w	r3, r2, r3
34017a54:	60fb      	str	r3, [r7, #12]
      break;
34017a56:	e01a      	b.n	34017a8e <RCCEx_GetMDFCLKFreq+0x1f6>
      if (LL_RCC_MSI_IsReady() != 0U)
34017a58:	f7f5 fc7e 	bl	3400d358 <LL_RCC_MSI_IsReady>
34017a5c:	4603      	mov	r3, r0
34017a5e:	2b00      	cmp	r3, #0
34017a60:	d017      	beq.n	34017a92 <RCCEx_GetMDFCLKFreq+0x1fa>
        adf_frequency = MSI_VALUE;
34017a62:	4b10      	ldr	r3, [pc, #64]	@ (34017aa4 <RCCEx_GetMDFCLKFreq+0x20c>)
34017a64:	60fb      	str	r3, [r7, #12]
      break;
34017a66:	e014      	b.n	34017a92 <RCCEx_GetMDFCLKFreq+0x1fa>
      adf_frequency = EXTERNAL_CLOCK_VALUE;
34017a68:	4b0f      	ldr	r3, [pc, #60]	@ (34017aa8 <RCCEx_GetMDFCLKFreq+0x210>)
34017a6a:	60fb      	str	r3, [r7, #12]
      break;
34017a6c:	e012      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
34017a6e:	f7f5 f855 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017a72:	4604      	mov	r4, r0
34017a74:	f7f6 f8b8 	bl	3400dbe8 <LL_RCC_GetTIMPrescaler>
34017a78:	4603      	mov	r3, r0
34017a7a:	fa24 f303 	lsr.w	r3, r4, r3
34017a7e:	60fb      	str	r3, [r7, #12]
      break;
34017a80:	e008      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34017a82:	bf00      	nop
34017a84:	e006      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34017a86:	bf00      	nop
34017a88:	e004      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34017a8a:	bf00      	nop
34017a8c:	e002      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34017a8e:	bf00      	nop
34017a90:	e000      	b.n	34017a94 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34017a92:	bf00      	nop
  }

  return adf_frequency;
34017a94:	68fb      	ldr	r3, [r7, #12]
}
34017a96:	4618      	mov	r0, r3
34017a98:	3714      	adds	r7, #20
34017a9a:	46bd      	mov	sp, r7
34017a9c:	bd90      	pop	{r4, r7, pc}
34017a9e:	bf00      	nop
34017aa0:	03d09000 	.word	0x03d09000
34017aa4:	003d0900 	.word	0x003d0900
34017aa8:	00bb8000 	.word	0x00bb8000

34017aac <RCCEx_GetPSSICLKFreq>:
  *         @arg @ref RCCEx_PSSI_Clock_Source
  * @retval PSSI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetPSSICLKFreq(uint32_t PSSIxSource)
{
34017aac:	b580      	push	{r7, lr}
34017aae:	b084      	sub	sp, #16
34017ab0:	af00      	add	r7, sp, #0
34017ab2:	6078      	str	r0, [r7, #4]
  uint32_t pssi_frequency = RCC_PERIPH_FREQUENCY_NO;
34017ab4:	2300      	movs	r3, #0
34017ab6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
34017ab8:	6878      	ldr	r0, [r7, #4]
34017aba:	f7f5 ffcd 	bl	3400da58 <LL_RCC_GetPSSIClockSource>
34017abe:	4603      	mov	r3, r0
34017ac0:	2b30      	cmp	r3, #48	@ 0x30
34017ac2:	d05a      	beq.n	34017b7a <RCCEx_GetPSSICLKFreq+0xce>
34017ac4:	2b30      	cmp	r3, #48	@ 0x30
34017ac6:	d866      	bhi.n	34017b96 <RCCEx_GetPSSICLKFreq+0xea>
34017ac8:	2b20      	cmp	r3, #32
34017aca:	d013      	beq.n	34017af4 <RCCEx_GetPSSICLKFreq+0x48>
34017acc:	2b20      	cmp	r3, #32
34017ace:	d862      	bhi.n	34017b96 <RCCEx_GetPSSICLKFreq+0xea>
34017ad0:	2b00      	cmp	r3, #0
34017ad2:	d002      	beq.n	34017ada <RCCEx_GetPSSICLKFreq+0x2e>
34017ad4:	2b10      	cmp	r3, #16
34017ad6:	d008      	beq.n	34017aea <RCCEx_GetPSSICLKFreq+0x3e>
      }
      break;

    default:
      /* Unexpected case */
      break;
34017ad8:	e05d      	b.n	34017b96 <RCCEx_GetPSSICLKFreq+0xea>
      pssi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34017ada:	f7f5 f81f 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017ade:	4603      	mov	r3, r0
34017ae0:	4618      	mov	r0, r3
34017ae2:	f7fe f913 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017ae6:	60f8      	str	r0, [r7, #12]
      break;
34017ae8:	e05a      	b.n	34017ba0 <RCCEx_GetPSSICLKFreq+0xf4>
      pssi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017aea:	2007      	movs	r0, #7
34017aec:	f7fe fbfa 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34017af0:	60f8      	str	r0, [r7, #12]
      break;
34017af2:	e055      	b.n	34017ba0 <RCCEx_GetPSSICLKFreq+0xf4>
      if (LL_RCC_IC20_IsEnabled() != 0U)
34017af4:	f7f6 feb4 	bl	3400e860 <LL_RCC_IC20_IsEnabled>
34017af8:	4603      	mov	r3, r0
34017afa:	2b00      	cmp	r3, #0
34017afc:	d04d      	beq.n	34017b9a <RCCEx_GetPSSICLKFreq+0xee>
        ic_divider = LL_RCC_IC20_GetDivider();
34017afe:	f7f6 fed1 	bl	3400e8a4 <LL_RCC_IC20_GetDivider>
34017b02:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC20_GetSource())
34017b04:	f7f6 fec0 	bl	3400e888 <LL_RCC_IC20_GetSource>
34017b08:	4603      	mov	r3, r0
34017b0a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017b0e:	d029      	beq.n	34017b64 <RCCEx_GetPSSICLKFreq+0xb8>
34017b10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017b14:	d82f      	bhi.n	34017b76 <RCCEx_GetPSSICLKFreq+0xca>
34017b16:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017b1a:	d01a      	beq.n	34017b52 <RCCEx_GetPSSICLKFreq+0xa6>
34017b1c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017b20:	d829      	bhi.n	34017b76 <RCCEx_GetPSSICLKFreq+0xca>
34017b22:	2b00      	cmp	r3, #0
34017b24:	d003      	beq.n	34017b2e <RCCEx_GetPSSICLKFreq+0x82>
34017b26:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017b2a:	d009      	beq.n	34017b40 <RCCEx_GetPSSICLKFreq+0x94>
            break;
34017b2c:	e023      	b.n	34017b76 <RCCEx_GetPSSICLKFreq+0xca>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017b2e:	f7fd ffd5 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34017b32:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34017b34:	68fa      	ldr	r2, [r7, #12]
34017b36:	68bb      	ldr	r3, [r7, #8]
34017b38:	fbb2 f3f3 	udiv	r3, r2, r3
34017b3c:	60fb      	str	r3, [r7, #12]
            break;
34017b3e:	e01b      	b.n	34017b78 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34017b40:	f7fe f812 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017b44:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34017b46:	68fa      	ldr	r2, [r7, #12]
34017b48:	68bb      	ldr	r3, [r7, #8]
34017b4a:	fbb2 f3f3 	udiv	r3, r2, r3
34017b4e:	60fb      	str	r3, [r7, #12]
            break;
34017b50:	e012      	b.n	34017b78 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34017b52:	f7fe f84f 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017b56:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34017b58:	68fa      	ldr	r2, [r7, #12]
34017b5a:	68bb      	ldr	r3, [r7, #8]
34017b5c:	fbb2 f3f3 	udiv	r3, r2, r3
34017b60:	60fb      	str	r3, [r7, #12]
            break;
34017b62:	e009      	b.n	34017b78 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017b64:	f7fe f88c 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017b68:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34017b6a:	68fa      	ldr	r2, [r7, #12]
34017b6c:	68bb      	ldr	r3, [r7, #8]
34017b6e:	fbb2 f3f3 	udiv	r3, r2, r3
34017b72:	60fb      	str	r3, [r7, #12]
            break;
34017b74:	e000      	b.n	34017b78 <RCCEx_GetPSSICLKFreq+0xcc>
            break;
34017b76:	bf00      	nop
      break;
34017b78:	e00f      	b.n	34017b9a <RCCEx_GetPSSICLKFreq+0xee>
      if (LL_RCC_HSI_IsReady() != 0U)
34017b7a:	f7f5 fbcd 	bl	3400d318 <LL_RCC_HSI_IsReady>
34017b7e:	4603      	mov	r3, r0
34017b80:	2b00      	cmp	r3, #0
34017b82:	d00c      	beq.n	34017b9e <RCCEx_GetPSSICLKFreq+0xf2>
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34017b84:	f7f5 fbda 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34017b88:	4603      	mov	r3, r0
34017b8a:	09db      	lsrs	r3, r3, #7
34017b8c:	4a07      	ldr	r2, [pc, #28]	@ (34017bac <RCCEx_GetPSSICLKFreq+0x100>)
34017b8e:	fa22 f303 	lsr.w	r3, r2, r3
34017b92:	60fb      	str	r3, [r7, #12]
      break;
34017b94:	e003      	b.n	34017b9e <RCCEx_GetPSSICLKFreq+0xf2>
      break;
34017b96:	bf00      	nop
34017b98:	e002      	b.n	34017ba0 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34017b9a:	bf00      	nop
34017b9c:	e000      	b.n	34017ba0 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34017b9e:	bf00      	nop
  }

  return pssi_frequency;
34017ba0:	68fb      	ldr	r3, [r7, #12]
}
34017ba2:	4618      	mov	r0, r3
34017ba4:	3710      	adds	r7, #16
34017ba6:	46bd      	mov	sp, r7
34017ba8:	bd80      	pop	{r7, pc}
34017baa:	bf00      	nop
34017bac:	03d09000 	.word	0x03d09000

34017bb0 <RCCEx_GetRTCCLKFreq>:
  * @brief  Return RTC clock frequency
  * @retval RTC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetRTCCLKFreq()
{
34017bb0:	b580      	push	{r7, lr}
34017bb2:	b082      	sub	sp, #8
34017bb4:	af00      	add	r7, sp, #0
  uint32_t rtc_frequency = RCC_PERIPH_FREQUENCY_NO;
34017bb6:	2300      	movs	r3, #0
34017bb8:	607b      	str	r3, [r7, #4]

  switch (LL_RCC_GetRTCClockSource())
34017bba:	f7f5 ffdb 	bl	3400db74 <LL_RCC_GetRTCClockSource>
34017bbe:	4603      	mov	r3, r0
34017bc0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34017bc4:	d020      	beq.n	34017c08 <RCCEx_GetRTCCLKFreq+0x58>
34017bc6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34017bca:	d830      	bhi.n	34017c2e <RCCEx_GetRTCCLKFreq+0x7e>
34017bcc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34017bd0:	d011      	beq.n	34017bf6 <RCCEx_GetRTCCLKFreq+0x46>
34017bd2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34017bd6:	d82a      	bhi.n	34017c2e <RCCEx_GetRTCCLKFreq+0x7e>
34017bd8:	2b00      	cmp	r3, #0
34017bda:	d02a      	beq.n	34017c32 <RCCEx_GetRTCCLKFreq+0x82>
34017bdc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34017be0:	d000      	beq.n	34017be4 <RCCEx_GetRTCCLKFreq+0x34>
      }
      break;

    default:
      /* Unexpected case */
      break;
34017be2:	e024      	b.n	34017c2e <RCCEx_GetRTCCLKFreq+0x7e>
      if (LL_RCC_LSE_IsReady() != 0U)
34017be4:	f7f5 fbd8 	bl	3400d398 <LL_RCC_LSE_IsReady>
34017be8:	4603      	mov	r3, r0
34017bea:	2b00      	cmp	r3, #0
34017bec:	d023      	beq.n	34017c36 <RCCEx_GetRTCCLKFreq+0x86>
        rtc_frequency = LSE_VALUE;
34017bee:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34017bf2:	607b      	str	r3, [r7, #4]
      break;
34017bf4:	e01f      	b.n	34017c36 <RCCEx_GetRTCCLKFreq+0x86>
      if (LL_RCC_LSI_IsReady() != 0U)
34017bf6:	f7f5 fbe1 	bl	3400d3bc <LL_RCC_LSI_IsReady>
34017bfa:	4603      	mov	r3, r0
34017bfc:	2b00      	cmp	r3, #0
34017bfe:	d01c      	beq.n	34017c3a <RCCEx_GetRTCCLKFreq+0x8a>
        rtc_frequency = LSI_VALUE;
34017c00:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
34017c04:	607b      	str	r3, [r7, #4]
      break;
34017c06:	e018      	b.n	34017c3a <RCCEx_GetRTCCLKFreq+0x8a>
      if (LL_RCC_HSE_IsReady() != 0U)
34017c08:	f7f5 fb74 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
34017c0c:	4603      	mov	r3, r0
34017c0e:	2b00      	cmp	r3, #0
34017c10:	d015      	beq.n	34017c3e <RCCEx_GetRTCCLKFreq+0x8e>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
34017c12:	4b0e      	ldr	r3, [pc, #56]	@ (34017c4c <RCCEx_GetRTCCLKFreq+0x9c>)
34017c14:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34017c18:	0b1b      	lsrs	r3, r3, #12
34017c1a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34017c1e:	3301      	adds	r3, #1
34017c20:	603b      	str	r3, [r7, #0]
        rtc_frequency = HSE_VALUE / prescaler;
34017c22:	4a0b      	ldr	r2, [pc, #44]	@ (34017c50 <RCCEx_GetRTCCLKFreq+0xa0>)
34017c24:	683b      	ldr	r3, [r7, #0]
34017c26:	fbb2 f3f3 	udiv	r3, r2, r3
34017c2a:	607b      	str	r3, [r7, #4]
      break;
34017c2c:	e007      	b.n	34017c3e <RCCEx_GetRTCCLKFreq+0x8e>
      break;
34017c2e:	bf00      	nop
34017c30:	e006      	b.n	34017c40 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34017c32:	bf00      	nop
34017c34:	e004      	b.n	34017c40 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34017c36:	bf00      	nop
34017c38:	e002      	b.n	34017c40 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34017c3a:	bf00      	nop
34017c3c:	e000      	b.n	34017c40 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34017c3e:	bf00      	nop
  }

  return rtc_frequency;
34017c40:	687b      	ldr	r3, [r7, #4]
}
34017c42:	4618      	mov	r0, r3
34017c44:	3708      	adds	r7, #8
34017c46:	46bd      	mov	sp, r7
34017c48:	bd80      	pop	{r7, pc}
34017c4a:	bf00      	nop
34017c4c:	56028000 	.word	0x56028000
34017c50:	02dc6c00 	.word	0x02dc6c00

34017c54 <RCCEx_GetSAICLKFreq>:
  *         @arg @ref RCCEx_SAI2_Clock_Source
  * @retval SAI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSAICLKFreq(uint32_t SAIxSource)
{
34017c54:	b580      	push	{r7, lr}
34017c56:	b084      	sub	sp, #16
34017c58:	af00      	add	r7, sp, #0
34017c5a:	6078      	str	r0, [r7, #4]
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
34017c5c:	2300      	movs	r3, #0
34017c5e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34017c60:	6878      	ldr	r0, [r7, #4]
34017c62:	f7f5 ff0b 	bl	3400da7c <LL_RCC_GetSAIClockSource>
34017c66:	4603      	mov	r3, r0
34017c68:	4a9a      	ldr	r2, [pc, #616]	@ (34017ed4 <RCCEx_GetSAICLKFreq+0x280>)
34017c6a:	4293      	cmp	r3, r2
34017c6c:	f000 811f 	beq.w	34017eae <RCCEx_GetSAICLKFreq+0x25a>
34017c70:	4a98      	ldr	r2, [pc, #608]	@ (34017ed4 <RCCEx_GetSAICLKFreq+0x280>)
34017c72:	4293      	cmp	r3, r2
34017c74:	f200 8120 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017c78:	4a97      	ldr	r2, [pc, #604]	@ (34017ed8 <RCCEx_GetSAICLKFreq+0x284>)
34017c7a:	4293      	cmp	r3, r2
34017c7c:	f000 8117 	beq.w	34017eae <RCCEx_GetSAICLKFreq+0x25a>
34017c80:	4a95      	ldr	r2, [pc, #596]	@ (34017ed8 <RCCEx_GetSAICLKFreq+0x284>)
34017c82:	4293      	cmp	r3, r2
34017c84:	f200 8118 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017c88:	4a94      	ldr	r2, [pc, #592]	@ (34017edc <RCCEx_GetSAICLKFreq+0x288>)
34017c8a:	4293      	cmp	r3, r2
34017c8c:	f000 810c 	beq.w	34017ea8 <RCCEx_GetSAICLKFreq+0x254>
34017c90:	4a92      	ldr	r2, [pc, #584]	@ (34017edc <RCCEx_GetSAICLKFreq+0x288>)
34017c92:	4293      	cmp	r3, r2
34017c94:	f200 8110 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017c98:	4a91      	ldr	r2, [pc, #580]	@ (34017ee0 <RCCEx_GetSAICLKFreq+0x28c>)
34017c9a:	4293      	cmp	r3, r2
34017c9c:	f000 8104 	beq.w	34017ea8 <RCCEx_GetSAICLKFreq+0x254>
34017ca0:	4a8f      	ldr	r2, [pc, #572]	@ (34017ee0 <RCCEx_GetSAICLKFreq+0x28c>)
34017ca2:	4293      	cmp	r3, r2
34017ca4:	f200 8108 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017ca8:	4a8e      	ldr	r2, [pc, #568]	@ (34017ee4 <RCCEx_GetSAICLKFreq+0x290>)
34017caa:	4293      	cmp	r3, r2
34017cac:	f000 80e6 	beq.w	34017e7c <RCCEx_GetSAICLKFreq+0x228>
34017cb0:	4a8c      	ldr	r2, [pc, #560]	@ (34017ee4 <RCCEx_GetSAICLKFreq+0x290>)
34017cb2:	4293      	cmp	r3, r2
34017cb4:	f200 8100 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017cb8:	4a8b      	ldr	r2, [pc, #556]	@ (34017ee8 <RCCEx_GetSAICLKFreq+0x294>)
34017cba:	4293      	cmp	r3, r2
34017cbc:	f000 80de 	beq.w	34017e7c <RCCEx_GetSAICLKFreq+0x228>
34017cc0:	4a89      	ldr	r2, [pc, #548]	@ (34017ee8 <RCCEx_GetSAICLKFreq+0x294>)
34017cc2:	4293      	cmp	r3, r2
34017cc4:	f200 80f8 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017cc8:	4a88      	ldr	r2, [pc, #544]	@ (34017eec <RCCEx_GetSAICLKFreq+0x298>)
34017cca:	4293      	cmp	r3, r2
34017ccc:	f000 80e4 	beq.w	34017e98 <RCCEx_GetSAICLKFreq+0x244>
34017cd0:	4a86      	ldr	r2, [pc, #536]	@ (34017eec <RCCEx_GetSAICLKFreq+0x298>)
34017cd2:	4293      	cmp	r3, r2
34017cd4:	f200 80f0 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017cd8:	4a85      	ldr	r2, [pc, #532]	@ (34017ef0 <RCCEx_GetSAICLKFreq+0x29c>)
34017cda:	4293      	cmp	r3, r2
34017cdc:	f000 80dc 	beq.w	34017e98 <RCCEx_GetSAICLKFreq+0x244>
34017ce0:	4a83      	ldr	r2, [pc, #524]	@ (34017ef0 <RCCEx_GetSAICLKFreq+0x29c>)
34017ce2:	4293      	cmp	r3, r2
34017ce4:	f200 80e8 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017ce8:	4a82      	ldr	r2, [pc, #520]	@ (34017ef4 <RCCEx_GetSAICLKFreq+0x2a0>)
34017cea:	4293      	cmp	r3, r2
34017cec:	f000 8083 	beq.w	34017df6 <RCCEx_GetSAICLKFreq+0x1a2>
34017cf0:	4a80      	ldr	r2, [pc, #512]	@ (34017ef4 <RCCEx_GetSAICLKFreq+0x2a0>)
34017cf2:	4293      	cmp	r3, r2
34017cf4:	f200 80e0 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017cf8:	4a7f      	ldr	r2, [pc, #508]	@ (34017ef8 <RCCEx_GetSAICLKFreq+0x2a4>)
34017cfa:	4293      	cmp	r3, r2
34017cfc:	d07b      	beq.n	34017df6 <RCCEx_GetSAICLKFreq+0x1a2>
34017cfe:	4a7e      	ldr	r2, [pc, #504]	@ (34017ef8 <RCCEx_GetSAICLKFreq+0x2a4>)
34017d00:	4293      	cmp	r3, r2
34017d02:	f200 80d9 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017d06:	4a7d      	ldr	r2, [pc, #500]	@ (34017efc <RCCEx_GetSAICLKFreq+0x2a8>)
34017d08:	4293      	cmp	r3, r2
34017d0a:	d030      	beq.n	34017d6e <RCCEx_GetSAICLKFreq+0x11a>
34017d0c:	4a7b      	ldr	r2, [pc, #492]	@ (34017efc <RCCEx_GetSAICLKFreq+0x2a8>)
34017d0e:	4293      	cmp	r3, r2
34017d10:	f200 80d2 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017d14:	4a7a      	ldr	r2, [pc, #488]	@ (34017f00 <RCCEx_GetSAICLKFreq+0x2ac>)
34017d16:	4293      	cmp	r3, r2
34017d18:	d029      	beq.n	34017d6e <RCCEx_GetSAICLKFreq+0x11a>
34017d1a:	4a79      	ldr	r2, [pc, #484]	@ (34017f00 <RCCEx_GetSAICLKFreq+0x2ac>)
34017d1c:	4293      	cmp	r3, r2
34017d1e:	f200 80cb 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017d22:	4a78      	ldr	r2, [pc, #480]	@ (34017f04 <RCCEx_GetSAICLKFreq+0x2b0>)
34017d24:	4293      	cmp	r3, r2
34017d26:	d01d      	beq.n	34017d64 <RCCEx_GetSAICLKFreq+0x110>
34017d28:	4a76      	ldr	r2, [pc, #472]	@ (34017f04 <RCCEx_GetSAICLKFreq+0x2b0>)
34017d2a:	4293      	cmp	r3, r2
34017d2c:	f200 80c4 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017d30:	4a75      	ldr	r2, [pc, #468]	@ (34017f08 <RCCEx_GetSAICLKFreq+0x2b4>)
34017d32:	4293      	cmp	r3, r2
34017d34:	d016      	beq.n	34017d64 <RCCEx_GetSAICLKFreq+0x110>
34017d36:	4a74      	ldr	r2, [pc, #464]	@ (34017f08 <RCCEx_GetSAICLKFreq+0x2b4>)
34017d38:	4293      	cmp	r3, r2
34017d3a:	f200 80bd 	bhi.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
34017d3e:	4a73      	ldr	r2, [pc, #460]	@ (34017f0c <RCCEx_GetSAICLKFreq+0x2b8>)
34017d40:	4293      	cmp	r3, r2
34017d42:	d003      	beq.n	34017d4c <RCCEx_GetSAICLKFreq+0xf8>
34017d44:	4a72      	ldr	r2, [pc, #456]	@ (34017f10 <RCCEx_GetSAICLKFreq+0x2bc>)
34017d46:	4293      	cmp	r3, r2
34017d48:	f040 80b6 	bne.w	34017eb8 <RCCEx_GetSAICLKFreq+0x264>
  {
    case LL_RCC_SAI1_CLKSOURCE_PCLK2:
    case LL_RCC_SAI2_CLKSOURCE_PCLK2:
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34017d4c:	f7f4 fee6 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017d50:	4603      	mov	r3, r0
34017d52:	4618      	mov	r0, r3
34017d54:	f7fd ffda 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017d58:	4603      	mov	r3, r0
34017d5a:	4618      	mov	r0, r3
34017d5c:	f7fd fff7 	bl	34015d4e <RCCEx_GetPCLK2Freq>
34017d60:	60f8      	str	r0, [r7, #12]
      break;
34017d62:	e0b2      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_CLKP:
    case LL_RCC_SAI2_CLKSOURCE_CLKP:
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017d64:	2007      	movs	r0, #7
34017d66:	f7fe fabd 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34017d6a:	60f8      	str	r0, [r7, #12]
      break;
34017d6c:	e0ad      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_IC7:
    case LL_RCC_SAI2_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34017d6e:	f7f6 fa77 	bl	3400e260 <LL_RCC_IC7_IsEnabled>
34017d72:	4603      	mov	r3, r0
34017d74:	2b00      	cmp	r3, #0
34017d76:	f000 80a1 	beq.w	34017ebc <RCCEx_GetSAICLKFreq+0x268>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34017d7a:	f7f6 fa93 	bl	3400e2a4 <LL_RCC_IC7_GetDivider>
34017d7e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34017d80:	f7f6 fa82 	bl	3400e288 <LL_RCC_IC7_GetSource>
34017d84:	4603      	mov	r3, r0
34017d86:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017d8a:	d029      	beq.n	34017de0 <RCCEx_GetSAICLKFreq+0x18c>
34017d8c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017d90:	d82f      	bhi.n	34017df2 <RCCEx_GetSAICLKFreq+0x19e>
34017d92:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017d96:	d01a      	beq.n	34017dce <RCCEx_GetSAICLKFreq+0x17a>
34017d98:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017d9c:	d829      	bhi.n	34017df2 <RCCEx_GetSAICLKFreq+0x19e>
34017d9e:	2b00      	cmp	r3, #0
34017da0:	d003      	beq.n	34017daa <RCCEx_GetSAICLKFreq+0x156>
34017da2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017da6:	d009      	beq.n	34017dbc <RCCEx_GetSAICLKFreq+0x168>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34017da8:	e023      	b.n	34017df2 <RCCEx_GetSAICLKFreq+0x19e>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017daa:	f7fd fe97 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34017dae:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017db0:	68fa      	ldr	r2, [r7, #12]
34017db2:	68bb      	ldr	r3, [r7, #8]
34017db4:	fbb2 f3f3 	udiv	r3, r2, r3
34017db8:	60fb      	str	r3, [r7, #12]
            break;
34017dba:	e01b      	b.n	34017df4 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34017dbc:	f7fd fed4 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017dc0:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017dc2:	68fa      	ldr	r2, [r7, #12]
34017dc4:	68bb      	ldr	r3, [r7, #8]
34017dc6:	fbb2 f3f3 	udiv	r3, r2, r3
34017dca:	60fb      	str	r3, [r7, #12]
            break;
34017dcc:	e012      	b.n	34017df4 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34017dce:	f7fd ff11 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017dd2:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017dd4:	68fa      	ldr	r2, [r7, #12]
34017dd6:	68bb      	ldr	r3, [r7, #8]
34017dd8:	fbb2 f3f3 	udiv	r3, r2, r3
34017ddc:	60fb      	str	r3, [r7, #12]
            break;
34017dde:	e009      	b.n	34017df4 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017de0:	f7fd ff4e 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017de4:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017de6:	68fa      	ldr	r2, [r7, #12]
34017de8:	68bb      	ldr	r3, [r7, #8]
34017dea:	fbb2 f3f3 	udiv	r3, r2, r3
34017dee:	60fb      	str	r3, [r7, #12]
            break;
34017df0:	e000      	b.n	34017df4 <RCCEx_GetSAICLKFreq+0x1a0>
            break;
34017df2:	bf00      	nop
        }
      }
      break;
34017df4:	e062      	b.n	34017ebc <RCCEx_GetSAICLKFreq+0x268>

    case LL_RCC_SAI1_CLKSOURCE_IC8:
    case LL_RCC_SAI2_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34017df6:	f7f6 fa73 	bl	3400e2e0 <LL_RCC_IC8_IsEnabled>
34017dfa:	4603      	mov	r3, r0
34017dfc:	2b00      	cmp	r3, #0
34017dfe:	d05f      	beq.n	34017ec0 <RCCEx_GetSAICLKFreq+0x26c>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34017e00:	f7f6 fa90 	bl	3400e324 <LL_RCC_IC8_GetDivider>
34017e04:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34017e06:	f7f6 fa7f 	bl	3400e308 <LL_RCC_IC8_GetSource>
34017e0a:	4603      	mov	r3, r0
34017e0c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017e10:	d029      	beq.n	34017e66 <RCCEx_GetSAICLKFreq+0x212>
34017e12:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017e16:	d82f      	bhi.n	34017e78 <RCCEx_GetSAICLKFreq+0x224>
34017e18:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017e1c:	d01a      	beq.n	34017e54 <RCCEx_GetSAICLKFreq+0x200>
34017e1e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017e22:	d829      	bhi.n	34017e78 <RCCEx_GetSAICLKFreq+0x224>
34017e24:	2b00      	cmp	r3, #0
34017e26:	d003      	beq.n	34017e30 <RCCEx_GetSAICLKFreq+0x1dc>
34017e28:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017e2c:	d009      	beq.n	34017e42 <RCCEx_GetSAICLKFreq+0x1ee>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34017e2e:	e023      	b.n	34017e78 <RCCEx_GetSAICLKFreq+0x224>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017e30:	f7fd fe54 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34017e34:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017e36:	68fa      	ldr	r2, [r7, #12]
34017e38:	68bb      	ldr	r3, [r7, #8]
34017e3a:	fbb2 f3f3 	udiv	r3, r2, r3
34017e3e:	60fb      	str	r3, [r7, #12]
            break;
34017e40:	e01b      	b.n	34017e7a <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34017e42:	f7fd fe91 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34017e46:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017e48:	68fa      	ldr	r2, [r7, #12]
34017e4a:	68bb      	ldr	r3, [r7, #8]
34017e4c:	fbb2 f3f3 	udiv	r3, r2, r3
34017e50:	60fb      	str	r3, [r7, #12]
            break;
34017e52:	e012      	b.n	34017e7a <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34017e54:	f7fd fece 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34017e58:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017e5a:	68fa      	ldr	r2, [r7, #12]
34017e5c:	68bb      	ldr	r3, [r7, #8]
34017e5e:	fbb2 f3f3 	udiv	r3, r2, r3
34017e62:	60fb      	str	r3, [r7, #12]
            break;
34017e64:	e009      	b.n	34017e7a <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34017e66:	f7fd ff0b 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34017e6a:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34017e6c:	68fa      	ldr	r2, [r7, #12]
34017e6e:	68bb      	ldr	r3, [r7, #8]
34017e70:	fbb2 f3f3 	udiv	r3, r2, r3
34017e74:	60fb      	str	r3, [r7, #12]
            break;
34017e76:	e000      	b.n	34017e7a <RCCEx_GetSAICLKFreq+0x226>
            break;
34017e78:	bf00      	nop
        }
      }
      break;
34017e7a:	e021      	b.n	34017ec0 <RCCEx_GetSAICLKFreq+0x26c>

    case LL_RCC_SAI1_CLKSOURCE_HSI:
    case LL_RCC_SAI2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34017e7c:	f7f5 fa4c 	bl	3400d318 <LL_RCC_HSI_IsReady>
34017e80:	4603      	mov	r3, r0
34017e82:	2b00      	cmp	r3, #0
34017e84:	d01e      	beq.n	34017ec4 <RCCEx_GetSAICLKFreq+0x270>
      {
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34017e86:	f7f5 fa59 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34017e8a:	4603      	mov	r3, r0
34017e8c:	09db      	lsrs	r3, r3, #7
34017e8e:	4a21      	ldr	r2, [pc, #132]	@ (34017f14 <RCCEx_GetSAICLKFreq+0x2c0>)
34017e90:	fa22 f303 	lsr.w	r3, r2, r3
34017e94:	60fb      	str	r3, [r7, #12]
      }
      break;
34017e96:	e015      	b.n	34017ec4 <RCCEx_GetSAICLKFreq+0x270>

    case LL_RCC_SAI1_CLKSOURCE_MSI:
    case LL_RCC_SAI2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34017e98:	f7f5 fa5e 	bl	3400d358 <LL_RCC_MSI_IsReady>
34017e9c:	4603      	mov	r3, r0
34017e9e:	2b00      	cmp	r3, #0
34017ea0:	d012      	beq.n	34017ec8 <RCCEx_GetSAICLKFreq+0x274>
      {
        sai_frequency = MSI_VALUE;
34017ea2:	4b1d      	ldr	r3, [pc, #116]	@ (34017f18 <RCCEx_GetSAICLKFreq+0x2c4>)
34017ea4:	60fb      	str	r3, [r7, #12]
      }
      break;
34017ea6:	e00f      	b.n	34017ec8 <RCCEx_GetSAICLKFreq+0x274>

    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SAI2_CLKSOURCE_I2S_CKIN:
      sai_frequency = EXTERNAL_CLOCK_VALUE;
34017ea8:	4b1c      	ldr	r3, [pc, #112]	@ (34017f1c <RCCEx_GetSAICLKFreq+0x2c8>)
34017eaa:	60fb      	str	r3, [r7, #12]
      break;
34017eac:	e00d      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_SPDIFRX1:
    case LL_RCC_SAI2_CLKSOURCE_SPDIFRX1:
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34017eae:	2007      	movs	r0, #7
34017eb0:	f000 f920 	bl	340180f4 <RCCEx_GetSPDIFRXCLKFreq>
34017eb4:	60f8      	str	r0, [r7, #12]
      break;
34017eb6:	e008      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>

    default:
      /* Unexpected case */
      break;
34017eb8:	bf00      	nop
34017eba:	e006      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>
      break;
34017ebc:	bf00      	nop
34017ebe:	e004      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>
      break;
34017ec0:	bf00      	nop
34017ec2:	e002      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>
      break;
34017ec4:	bf00      	nop
34017ec6:	e000      	b.n	34017eca <RCCEx_GetSAICLKFreq+0x276>
      break;
34017ec8:	bf00      	nop
  }

  return sai_frequency;
34017eca:	68fb      	ldr	r3, [r7, #12]
}
34017ecc:	4618      	mov	r0, r3
34017ece:	3710      	adds	r7, #16
34017ed0:	46bd      	mov	sp, r7
34017ed2:	bd80      	pop	{r7, pc}
34017ed4:	07071818 	.word	0x07071818
34017ed8:	07071418 	.word	0x07071418
34017edc:	07061818 	.word	0x07061818
34017ee0:	07061418 	.word	0x07061418
34017ee4:	07051818 	.word	0x07051818
34017ee8:	07051418 	.word	0x07051418
34017eec:	07041818 	.word	0x07041818
34017ef0:	07041418 	.word	0x07041418
34017ef4:	07031818 	.word	0x07031818
34017ef8:	07031418 	.word	0x07031418
34017efc:	07021818 	.word	0x07021818
34017f00:	07021418 	.word	0x07021418
34017f04:	07011818 	.word	0x07011818
34017f08:	07011418 	.word	0x07011418
34017f0c:	07001418 	.word	0x07001418
34017f10:	07001818 	.word	0x07001818
34017f14:	03d09000 	.word	0x03d09000
34017f18:	003d0900 	.word	0x003d0900
34017f1c:	00bb8000 	.word	0x00bb8000

34017f20 <RCCEx_GetSDMMCCLKFreq>:
  *         @arg @ref RCCEx_SDMMC2_Clock_Source
  * @retval SDMMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSDMMCCLKFreq(uint32_t SDMMCxSource)
{
34017f20:	b580      	push	{r7, lr}
34017f22:	b084      	sub	sp, #16
34017f24:	af00      	add	r7, sp, #0
34017f26:	6078      	str	r0, [r7, #4]
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34017f28:	2300      	movs	r3, #0
34017f2a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34017f2c:	6878      	ldr	r0, [r7, #4]
34017f2e:	f7f5 fdb1 	bl	3400da94 <LL_RCC_GetSDMMCClockSource>
34017f32:	4603      	mov	r3, r0
34017f34:	4a67      	ldr	r2, [pc, #412]	@ (340180d4 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34017f36:	4293      	cmp	r3, r2
34017f38:	d07e      	beq.n	34018038 <RCCEx_GetSDMMCCLKFreq+0x118>
34017f3a:	4a66      	ldr	r2, [pc, #408]	@ (340180d4 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34017f3c:	4293      	cmp	r3, r2
34017f3e:	f200 80be 	bhi.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
34017f42:	4a65      	ldr	r2, [pc, #404]	@ (340180d8 <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34017f44:	4293      	cmp	r3, r2
34017f46:	d077      	beq.n	34018038 <RCCEx_GetSDMMCCLKFreq+0x118>
34017f48:	4a63      	ldr	r2, [pc, #396]	@ (340180d8 <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34017f4a:	4293      	cmp	r3, r2
34017f4c:	f200 80b7 	bhi.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
34017f50:	4a62      	ldr	r2, [pc, #392]	@ (340180dc <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34017f52:	4293      	cmp	r3, r2
34017f54:	d02c      	beq.n	34017fb0 <RCCEx_GetSDMMCCLKFreq+0x90>
34017f56:	4a61      	ldr	r2, [pc, #388]	@ (340180dc <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34017f58:	4293      	cmp	r3, r2
34017f5a:	f200 80b0 	bhi.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
34017f5e:	4a60      	ldr	r2, [pc, #384]	@ (340180e0 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34017f60:	4293      	cmp	r3, r2
34017f62:	d025      	beq.n	34017fb0 <RCCEx_GetSDMMCCLKFreq+0x90>
34017f64:	4a5e      	ldr	r2, [pc, #376]	@ (340180e0 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34017f66:	4293      	cmp	r3, r2
34017f68:	f200 80a9 	bhi.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
34017f6c:	4a5d      	ldr	r2, [pc, #372]	@ (340180e4 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34017f6e:	4293      	cmp	r3, r2
34017f70:	d019      	beq.n	34017fa6 <RCCEx_GetSDMMCCLKFreq+0x86>
34017f72:	4a5c      	ldr	r2, [pc, #368]	@ (340180e4 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34017f74:	4293      	cmp	r3, r2
34017f76:	f200 80a2 	bhi.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
34017f7a:	4a5b      	ldr	r2, [pc, #364]	@ (340180e8 <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34017f7c:	4293      	cmp	r3, r2
34017f7e:	d012      	beq.n	34017fa6 <RCCEx_GetSDMMCCLKFreq+0x86>
34017f80:	4a59      	ldr	r2, [pc, #356]	@ (340180e8 <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34017f82:	4293      	cmp	r3, r2
34017f84:	f200 809b 	bhi.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
34017f88:	4a58      	ldr	r2, [pc, #352]	@ (340180ec <RCCEx_GetSDMMCCLKFreq+0x1cc>)
34017f8a:	4293      	cmp	r3, r2
34017f8c:	d003      	beq.n	34017f96 <RCCEx_GetSDMMCCLKFreq+0x76>
34017f8e:	4a58      	ldr	r2, [pc, #352]	@ (340180f0 <RCCEx_GetSDMMCCLKFreq+0x1d0>)
34017f90:	4293      	cmp	r3, r2
34017f92:	f040 8094 	bne.w	340180be <RCCEx_GetSDMMCCLKFreq+0x19e>
  {
    case LL_RCC_SDMMC1_CLKSOURCE_HCLK:
    case LL_RCC_SDMMC2_CLKSOURCE_HCLK:
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34017f96:	f7f4 fdc1 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34017f9a:	4603      	mov	r3, r0
34017f9c:	4618      	mov	r0, r3
34017f9e:	f7fd feb5 	bl	34015d0c <RCCEx_GetHCLKFreq>
34017fa2:	60f8      	str	r0, [r7, #12]
      break;
34017fa4:	e090      	b.n	340180c8 <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_CLKP:
    case LL_RCC_SDMMC2_CLKSOURCE_CLKP:
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34017fa6:	2007      	movs	r0, #7
34017fa8:	f7fe f99c 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34017fac:	60f8      	str	r0, [r7, #12]
      break;
34017fae:	e08b      	b.n	340180c8 <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_IC4:
    case LL_RCC_SDMMC2_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
34017fb0:	f7f6 f8d6 	bl	3400e160 <LL_RCC_IC4_IsEnabled>
34017fb4:	4603      	mov	r3, r0
34017fb6:	2b00      	cmp	r3, #0
34017fb8:	f000 8083 	beq.w	340180c2 <RCCEx_GetSDMMCCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34017fbc:	f7f6 f8f2 	bl	3400e1a4 <LL_RCC_IC4_GetDivider>
34017fc0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34017fc2:	f7f6 f8e1 	bl	3400e188 <LL_RCC_IC4_GetSource>
34017fc6:	4603      	mov	r3, r0
34017fc8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017fcc:	d029      	beq.n	34018022 <RCCEx_GetSDMMCCLKFreq+0x102>
34017fce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017fd2:	d82f      	bhi.n	34018034 <RCCEx_GetSDMMCCLKFreq+0x114>
34017fd4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017fd8:	d01a      	beq.n	34018010 <RCCEx_GetSDMMCCLKFreq+0xf0>
34017fda:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017fde:	d829      	bhi.n	34018034 <RCCEx_GetSDMMCCLKFreq+0x114>
34017fe0:	2b00      	cmp	r3, #0
34017fe2:	d003      	beq.n	34017fec <RCCEx_GetSDMMCCLKFreq+0xcc>
34017fe4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017fe8:	d009      	beq.n	34017ffe <RCCEx_GetSDMMCCLKFreq+0xde>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34017fea:	e023      	b.n	34018034 <RCCEx_GetSDMMCCLKFreq+0x114>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017fec:	f7fd fd76 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34017ff0:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34017ff2:	68fa      	ldr	r2, [r7, #12]
34017ff4:	68bb      	ldr	r3, [r7, #8]
34017ff6:	fbb2 f3f3 	udiv	r3, r2, r3
34017ffa:	60fb      	str	r3, [r7, #12]
            break;
34017ffc:	e01b      	b.n	34018036 <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34017ffe:	f7fd fdb3 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34018002:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34018004:	68fa      	ldr	r2, [r7, #12]
34018006:	68bb      	ldr	r3, [r7, #8]
34018008:	fbb2 f3f3 	udiv	r3, r2, r3
3401800c:	60fb      	str	r3, [r7, #12]
            break;
3401800e:	e012      	b.n	34018036 <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34018010:	f7fd fdf0 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34018014:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34018016:	68fa      	ldr	r2, [r7, #12]
34018018:	68bb      	ldr	r3, [r7, #8]
3401801a:	fbb2 f3f3 	udiv	r3, r2, r3
3401801e:	60fb      	str	r3, [r7, #12]
            break;
34018020:	e009      	b.n	34018036 <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34018022:	f7fd fe2d 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34018026:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34018028:	68fa      	ldr	r2, [r7, #12]
3401802a:	68bb      	ldr	r3, [r7, #8]
3401802c:	fbb2 f3f3 	udiv	r3, r2, r3
34018030:	60fb      	str	r3, [r7, #12]
            break;
34018032:	e000      	b.n	34018036 <RCCEx_GetSDMMCCLKFreq+0x116>
            break;
34018034:	bf00      	nop
        }
      }
      break;
34018036:	e044      	b.n	340180c2 <RCCEx_GetSDMMCCLKFreq+0x1a2>

    case LL_RCC_SDMMC1_CLKSOURCE_IC5:
    case LL_RCC_SDMMC2_CLKSOURCE_IC5:
      if (LL_RCC_IC5_IsEnabled() != 0U)
34018038:	f7f6 f8d2 	bl	3400e1e0 <LL_RCC_IC5_IsEnabled>
3401803c:	4603      	mov	r3, r0
3401803e:	2b00      	cmp	r3, #0
34018040:	d041      	beq.n	340180c6 <RCCEx_GetSDMMCCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC5_GetDivider();
34018042:	f7f6 f8ef 	bl	3400e224 <LL_RCC_IC5_GetDivider>
34018046:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC5_GetSource())
34018048:	f7f6 f8de 	bl	3400e208 <LL_RCC_IC5_GetSource>
3401804c:	4603      	mov	r3, r0
3401804e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018052:	d029      	beq.n	340180a8 <RCCEx_GetSDMMCCLKFreq+0x188>
34018054:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018058:	d82f      	bhi.n	340180ba <RCCEx_GetSDMMCCLKFreq+0x19a>
3401805a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401805e:	d01a      	beq.n	34018096 <RCCEx_GetSDMMCCLKFreq+0x176>
34018060:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018064:	d829      	bhi.n	340180ba <RCCEx_GetSDMMCCLKFreq+0x19a>
34018066:	2b00      	cmp	r3, #0
34018068:	d003      	beq.n	34018072 <RCCEx_GetSDMMCCLKFreq+0x152>
3401806a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401806e:	d009      	beq.n	34018084 <RCCEx_GetSDMMCCLKFreq+0x164>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34018070:	e023      	b.n	340180ba <RCCEx_GetSDMMCCLKFreq+0x19a>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34018072:	f7fd fd33 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018076:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34018078:	68fa      	ldr	r2, [r7, #12]
3401807a:	68bb      	ldr	r3, [r7, #8]
3401807c:	fbb2 f3f3 	udiv	r3, r2, r3
34018080:	60fb      	str	r3, [r7, #12]
            break;
34018082:	e01b      	b.n	340180bc <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34018084:	f7fd fd70 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34018088:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3401808a:	68fa      	ldr	r2, [r7, #12]
3401808c:	68bb      	ldr	r3, [r7, #8]
3401808e:	fbb2 f3f3 	udiv	r3, r2, r3
34018092:	60fb      	str	r3, [r7, #12]
            break;
34018094:	e012      	b.n	340180bc <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34018096:	f7fd fdad 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401809a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3401809c:	68fa      	ldr	r2, [r7, #12]
3401809e:	68bb      	ldr	r3, [r7, #8]
340180a0:	fbb2 f3f3 	udiv	r3, r2, r3
340180a4:	60fb      	str	r3, [r7, #12]
            break;
340180a6:	e009      	b.n	340180bc <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340180a8:	f7fd fdea 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340180ac:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
340180ae:	68fa      	ldr	r2, [r7, #12]
340180b0:	68bb      	ldr	r3, [r7, #8]
340180b2:	fbb2 f3f3 	udiv	r3, r2, r3
340180b6:	60fb      	str	r3, [r7, #12]
            break;
340180b8:	e000      	b.n	340180bc <RCCEx_GetSDMMCCLKFreq+0x19c>
            break;
340180ba:	bf00      	nop
        }
      }
      break;
340180bc:	e003      	b.n	340180c6 <RCCEx_GetSDMMCCLKFreq+0x1a6>

    default:
      /* Unexpected case */
      break;
340180be:	bf00      	nop
340180c0:	e002      	b.n	340180c8 <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
340180c2:	bf00      	nop
340180c4:	e000      	b.n	340180c8 <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
340180c6:	bf00      	nop
  }

  return sdmmc_frequency;
340180c8:	68fb      	ldr	r3, [r7, #12]
}
340180ca:	4618      	mov	r0, r3
340180cc:	3710      	adds	r7, #16
340180ce:	46bd      	mov	sp, r7
340180d0:	bd80      	pop	{r7, pc}
340180d2:	bf00      	nop
340180d4:	0303041c 	.word	0x0303041c
340180d8:	0303001c 	.word	0x0303001c
340180dc:	0302041c 	.word	0x0302041c
340180e0:	0302001c 	.word	0x0302001c
340180e4:	0301041c 	.word	0x0301041c
340180e8:	0301001c 	.word	0x0301001c
340180ec:	0300001c 	.word	0x0300001c
340180f0:	0300041c 	.word	0x0300041c

340180f4 <RCCEx_GetSPDIFRXCLKFreq>:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
{
340180f4:	b580      	push	{r7, lr}
340180f6:	b084      	sub	sp, #16
340180f8:	af00      	add	r7, sp, #0
340180fa:	6078      	str	r0, [r7, #4]
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
340180fc:	2300      	movs	r3, #0
340180fe:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
34018100:	6878      	ldr	r0, [r7, #4]
34018102:	f7f5 fcd3 	bl	3400daac <LL_RCC_GetSPDIFRXClockSource>
34018106:	4603      	mov	r3, r0
34018108:	2b06      	cmp	r3, #6
3401810a:	f200 80c2 	bhi.w	34018292 <RCCEx_GetSPDIFRXCLKFreq+0x19e>
3401810e:	a201      	add	r2, pc, #4	@ (adr r2, 34018114 <RCCEx_GetSPDIFRXCLKFreq+0x20>)
34018110:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34018114:	34018131 	.word	0x34018131
34018118:	34018149 	.word	0x34018149
3401811c:	34018153 	.word	0x34018153
34018120:	340181db 	.word	0x340181db
34018124:	3401827d 	.word	0x3401827d
34018128:	34018261 	.word	0x34018261
3401812c:	3401828d 	.word	0x3401828d
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018130:	f7f4 fcf4 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34018134:	4603      	mov	r3, r0
34018136:	4618      	mov	r0, r3
34018138:	f7fd fde8 	bl	34015d0c <RCCEx_GetHCLKFreq>
3401813c:	4603      	mov	r3, r0
3401813e:	4618      	mov	r0, r3
34018140:	f7fd fdf5 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34018144:	60f8      	str	r0, [r7, #12]
      break;
34018146:	e0ad      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_CLKP:
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34018148:	2007      	movs	r0, #7
3401814a:	f7fe f8cb 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401814e:	60f8      	str	r0, [r7, #12]
      break;
34018150:	e0a8      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34018152:	f7f6 f885 	bl	3400e260 <LL_RCC_IC7_IsEnabled>
34018156:	4603      	mov	r3, r0
34018158:	2b00      	cmp	r3, #0
3401815a:	f000 809c 	beq.w	34018296 <RCCEx_GetSPDIFRXCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
3401815e:	f7f6 f8a1 	bl	3400e2a4 <LL_RCC_IC7_GetDivider>
34018162:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34018164:	f7f6 f890 	bl	3400e288 <LL_RCC_IC7_GetSource>
34018168:	4603      	mov	r3, r0
3401816a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401816e:	d029      	beq.n	340181c4 <RCCEx_GetSPDIFRXCLKFreq+0xd0>
34018170:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018174:	d82f      	bhi.n	340181d6 <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34018176:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401817a:	d01a      	beq.n	340181b2 <RCCEx_GetSPDIFRXCLKFreq+0xbe>
3401817c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018180:	d829      	bhi.n	340181d6 <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34018182:	2b00      	cmp	r3, #0
34018184:	d003      	beq.n	3401818e <RCCEx_GetSPDIFRXCLKFreq+0x9a>
34018186:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401818a:	d009      	beq.n	340181a0 <RCCEx_GetSPDIFRXCLKFreq+0xac>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401818c:	e023      	b.n	340181d6 <RCCEx_GetSPDIFRXCLKFreq+0xe2>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401818e:	f7fd fca5 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018192:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34018194:	68fa      	ldr	r2, [r7, #12]
34018196:	68bb      	ldr	r3, [r7, #8]
34018198:	fbb2 f3f3 	udiv	r3, r2, r3
3401819c:	60fb      	str	r3, [r7, #12]
            break;
3401819e:	e01b      	b.n	340181d8 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340181a0:	f7fd fce2 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340181a4:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340181a6:	68fa      	ldr	r2, [r7, #12]
340181a8:	68bb      	ldr	r3, [r7, #8]
340181aa:	fbb2 f3f3 	udiv	r3, r2, r3
340181ae:	60fb      	str	r3, [r7, #12]
            break;
340181b0:	e012      	b.n	340181d8 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340181b2:	f7fd fd1f 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340181b6:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340181b8:	68fa      	ldr	r2, [r7, #12]
340181ba:	68bb      	ldr	r3, [r7, #8]
340181bc:	fbb2 f3f3 	udiv	r3, r2, r3
340181c0:	60fb      	str	r3, [r7, #12]
            break;
340181c2:	e009      	b.n	340181d8 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340181c4:	f7fd fd5c 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340181c8:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
340181ca:	68fa      	ldr	r2, [r7, #12]
340181cc:	68bb      	ldr	r3, [r7, #8]
340181ce:	fbb2 f3f3 	udiv	r3, r2, r3
340181d2:	60fb      	str	r3, [r7, #12]
            break;
340181d4:	e000      	b.n	340181d8 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            break;
340181d6:	bf00      	nop
        }
      }
      break;
340181d8:	e05d      	b.n	34018296 <RCCEx_GetSPDIFRXCLKFreq+0x1a2>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
340181da:	f7f6 f881 	bl	3400e2e0 <LL_RCC_IC8_IsEnabled>
340181de:	4603      	mov	r3, r0
340181e0:	2b00      	cmp	r3, #0
340181e2:	d05a      	beq.n	3401829a <RCCEx_GetSPDIFRXCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
340181e4:	f7f6 f89e 	bl	3400e324 <LL_RCC_IC8_GetDivider>
340181e8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
340181ea:	f7f6 f88d 	bl	3400e308 <LL_RCC_IC8_GetSource>
340181ee:	4603      	mov	r3, r0
340181f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340181f4:	d029      	beq.n	3401824a <RCCEx_GetSPDIFRXCLKFreq+0x156>
340181f6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340181fa:	d82f      	bhi.n	3401825c <RCCEx_GetSPDIFRXCLKFreq+0x168>
340181fc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018200:	d01a      	beq.n	34018238 <RCCEx_GetSPDIFRXCLKFreq+0x144>
34018202:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018206:	d829      	bhi.n	3401825c <RCCEx_GetSPDIFRXCLKFreq+0x168>
34018208:	2b00      	cmp	r3, #0
3401820a:	d003      	beq.n	34018214 <RCCEx_GetSPDIFRXCLKFreq+0x120>
3401820c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018210:	d009      	beq.n	34018226 <RCCEx_GetSPDIFRXCLKFreq+0x132>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34018212:	e023      	b.n	3401825c <RCCEx_GetSPDIFRXCLKFreq+0x168>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34018214:	f7fd fc62 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018218:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3401821a:	68fa      	ldr	r2, [r7, #12]
3401821c:	68bb      	ldr	r3, [r7, #8]
3401821e:	fbb2 f3f3 	udiv	r3, r2, r3
34018222:	60fb      	str	r3, [r7, #12]
            break;
34018224:	e01b      	b.n	3401825e <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34018226:	f7fd fc9f 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401822a:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3401822c:	68fa      	ldr	r2, [r7, #12]
3401822e:	68bb      	ldr	r3, [r7, #8]
34018230:	fbb2 f3f3 	udiv	r3, r2, r3
34018234:	60fb      	str	r3, [r7, #12]
            break;
34018236:	e012      	b.n	3401825e <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34018238:	f7fd fcdc 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401823c:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3401823e:	68fa      	ldr	r2, [r7, #12]
34018240:	68bb      	ldr	r3, [r7, #8]
34018242:	fbb2 f3f3 	udiv	r3, r2, r3
34018246:	60fb      	str	r3, [r7, #12]
            break;
34018248:	e009      	b.n	3401825e <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401824a:	f7fd fd19 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
3401824e:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34018250:	68fa      	ldr	r2, [r7, #12]
34018252:	68bb      	ldr	r3, [r7, #8]
34018254:	fbb2 f3f3 	udiv	r3, r2, r3
34018258:	60fb      	str	r3, [r7, #12]
            break;
3401825a:	e000      	b.n	3401825e <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            break;
3401825c:	bf00      	nop
        }
      }
      break;
3401825e:	e01c      	b.n	3401829a <RCCEx_GetSPDIFRXCLKFreq+0x1a6>

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34018260:	f7f5 f85a 	bl	3400d318 <LL_RCC_HSI_IsReady>
34018264:	4603      	mov	r3, r0
34018266:	2b00      	cmp	r3, #0
34018268:	d019      	beq.n	3401829e <RCCEx_GetSPDIFRXCLKFreq+0x1aa>
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3401826a:	f7f5 f867 	bl	3400d33c <LL_RCC_HSI_GetDivider>
3401826e:	4603      	mov	r3, r0
34018270:	09db      	lsrs	r3, r3, #7
34018272:	4a0f      	ldr	r2, [pc, #60]	@ (340182b0 <RCCEx_GetSPDIFRXCLKFreq+0x1bc>)
34018274:	fa22 f303 	lsr.w	r3, r2, r3
34018278:	60fb      	str	r3, [r7, #12]
      }
      break;
3401827a:	e010      	b.n	3401829e <RCCEx_GetSPDIFRXCLKFreq+0x1aa>

    case LL_RCC_SPDIFRX1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3401827c:	f7f5 f86c 	bl	3400d358 <LL_RCC_MSI_IsReady>
34018280:	4603      	mov	r3, r0
34018282:	2b00      	cmp	r3, #0
34018284:	d00d      	beq.n	340182a2 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>
      {
        spdifrx_frequency = MSI_VALUE;
34018286:	4b0b      	ldr	r3, [pc, #44]	@ (340182b4 <RCCEx_GetSPDIFRXCLKFreq+0x1c0>)
34018288:	60fb      	str	r3, [r7, #12]
      }
      break;
3401828a:	e00a      	b.n	340182a2 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>

    case LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN:
      spdifrx_frequency = EXTERNAL_CLOCK_VALUE;
3401828c:	4b0a      	ldr	r3, [pc, #40]	@ (340182b8 <RCCEx_GetSPDIFRXCLKFreq+0x1c4>)
3401828e:	60fb      	str	r3, [r7, #12]
      break;
34018290:	e008      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    default:
      /* Unexpected case */
      break;
34018292:	bf00      	nop
34018294:	e006      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34018296:	bf00      	nop
34018298:	e004      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3401829a:	bf00      	nop
3401829c:	e002      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3401829e:	bf00      	nop
340182a0:	e000      	b.n	340182a4 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
340182a2:	bf00      	nop
  }

  return spdifrx_frequency;
340182a4:	68fb      	ldr	r3, [r7, #12]
}
340182a6:	4618      	mov	r0, r3
340182a8:	3710      	adds	r7, #16
340182aa:	46bd      	mov	sp, r7
340182ac:	bd80      	pop	{r7, pc}
340182ae:	bf00      	nop
340182b0:	03d09000 	.word	0x03d09000
340182b4:	003d0900 	.word	0x003d0900
340182b8:	00bb8000 	.word	0x00bb8000

340182bc <RCCEx_GetSPICLKFreq>:
  *         @arg @ref RCCEx_SPI6_Clock_Source
  * @retval SPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPICLKFreq(uint32_t SPIxSource)
{
340182bc:	b580      	push	{r7, lr}
340182be:	b084      	sub	sp, #16
340182c0:	af00      	add	r7, sp, #0
340182c2:	6078      	str	r0, [r7, #4]
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
340182c4:	2300      	movs	r3, #0
340182c6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPIClockSource(SPIxSource))
340182c8:	6878      	ldr	r0, [r7, #4]
340182ca:	f7f5 fc01 	bl	3400dad0 <LL_RCC_GetSPIClockSource>
340182ce:	4603      	mov	r3, r0
340182d0:	4aa7      	ldr	r2, [pc, #668]	@ (34018570 <RCCEx_GetSPICLKFreq+0x2b4>)
340182d2:	4293      	cmp	r3, r2
340182d4:	f000 829e 	beq.w	34018814 <RCCEx_GetSPICLKFreq+0x558>
340182d8:	4aa5      	ldr	r2, [pc, #660]	@ (34018570 <RCCEx_GetSPICLKFreq+0x2b4>)
340182da:	4293      	cmp	r3, r2
340182dc:	f200 82a5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340182e0:	4aa4      	ldr	r2, [pc, #656]	@ (34018574 <RCCEx_GetSPICLKFreq+0x2b8>)
340182e2:	4293      	cmp	r3, r2
340182e4:	f000 8299 	beq.w	3401881a <RCCEx_GetSPICLKFreq+0x55e>
340182e8:	4aa2      	ldr	r2, [pc, #648]	@ (34018574 <RCCEx_GetSPICLKFreq+0x2b8>)
340182ea:	4293      	cmp	r3, r2
340182ec:	f200 829d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340182f0:	4aa1      	ldr	r2, [pc, #644]	@ (34018578 <RCCEx_GetSPICLKFreq+0x2bc>)
340182f2:	4293      	cmp	r3, r2
340182f4:	f000 8291 	beq.w	3401881a <RCCEx_GetSPICLKFreq+0x55e>
340182f8:	4a9f      	ldr	r2, [pc, #636]	@ (34018578 <RCCEx_GetSPICLKFreq+0x2bc>)
340182fa:	4293      	cmp	r3, r2
340182fc:	f200 8295 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018300:	4a9e      	ldr	r2, [pc, #632]	@ (3401857c <RCCEx_GetSPICLKFreq+0x2c0>)
34018302:	4293      	cmp	r3, r2
34018304:	f000 8286 	beq.w	34018814 <RCCEx_GetSPICLKFreq+0x558>
34018308:	4a9c      	ldr	r2, [pc, #624]	@ (3401857c <RCCEx_GetSPICLKFreq+0x2c0>)
3401830a:	4293      	cmp	r3, r2
3401830c:	f200 828d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018310:	4a9b      	ldr	r2, [pc, #620]	@ (34018580 <RCCEx_GetSPICLKFreq+0x2c4>)
34018312:	4293      	cmp	r3, r2
34018314:	f000 827e 	beq.w	34018814 <RCCEx_GetSPICLKFreq+0x558>
34018318:	4a99      	ldr	r2, [pc, #612]	@ (34018580 <RCCEx_GetSPICLKFreq+0x2c4>)
3401831a:	4293      	cmp	r3, r2
3401831c:	f200 8285 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018320:	4a98      	ldr	r2, [pc, #608]	@ (34018584 <RCCEx_GetSPICLKFreq+0x2c8>)
34018322:	4293      	cmp	r3, r2
34018324:	f000 8276 	beq.w	34018814 <RCCEx_GetSPICLKFreq+0x558>
34018328:	4a96      	ldr	r2, [pc, #600]	@ (34018584 <RCCEx_GetSPICLKFreq+0x2c8>)
3401832a:	4293      	cmp	r3, r2
3401832c:	f200 827d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018330:	4a95      	ldr	r2, [pc, #596]	@ (34018588 <RCCEx_GetSPICLKFreq+0x2cc>)
34018332:	4293      	cmp	r3, r2
34018334:	f000 8258 	beq.w	340187e8 <RCCEx_GetSPICLKFreq+0x52c>
34018338:	4a93      	ldr	r2, [pc, #588]	@ (34018588 <RCCEx_GetSPICLKFreq+0x2cc>)
3401833a:	4293      	cmp	r3, r2
3401833c:	f200 8275 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018340:	4a92      	ldr	r2, [pc, #584]	@ (3401858c <RCCEx_GetSPICLKFreq+0x2d0>)
34018342:	4293      	cmp	r3, r2
34018344:	f000 8250 	beq.w	340187e8 <RCCEx_GetSPICLKFreq+0x52c>
34018348:	4a90      	ldr	r2, [pc, #576]	@ (3401858c <RCCEx_GetSPICLKFreq+0x2d0>)
3401834a:	4293      	cmp	r3, r2
3401834c:	f200 826d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018350:	4a8f      	ldr	r2, [pc, #572]	@ (34018590 <RCCEx_GetSPICLKFreq+0x2d4>)
34018352:	4293      	cmp	r3, r2
34018354:	f000 8248 	beq.w	340187e8 <RCCEx_GetSPICLKFreq+0x52c>
34018358:	4a8d      	ldr	r2, [pc, #564]	@ (34018590 <RCCEx_GetSPICLKFreq+0x2d4>)
3401835a:	4293      	cmp	r3, r2
3401835c:	f200 8265 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018360:	4a8c      	ldr	r2, [pc, #560]	@ (34018594 <RCCEx_GetSPICLKFreq+0x2d8>)
34018362:	4293      	cmp	r3, r2
34018364:	f000 8240 	beq.w	340187e8 <RCCEx_GetSPICLKFreq+0x52c>
34018368:	4a8a      	ldr	r2, [pc, #552]	@ (34018594 <RCCEx_GetSPICLKFreq+0x2d8>)
3401836a:	4293      	cmp	r3, r2
3401836c:	f200 825d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018370:	4a89      	ldr	r2, [pc, #548]	@ (34018598 <RCCEx_GetSPICLKFreq+0x2dc>)
34018372:	4293      	cmp	r3, r2
34018374:	f000 8238 	beq.w	340187e8 <RCCEx_GetSPICLKFreq+0x52c>
34018378:	4a87      	ldr	r2, [pc, #540]	@ (34018598 <RCCEx_GetSPICLKFreq+0x2dc>)
3401837a:	4293      	cmp	r3, r2
3401837c:	f200 8255 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018380:	4a86      	ldr	r2, [pc, #536]	@ (3401859c <RCCEx_GetSPICLKFreq+0x2e0>)
34018382:	4293      	cmp	r3, r2
34018384:	f000 8230 	beq.w	340187e8 <RCCEx_GetSPICLKFreq+0x52c>
34018388:	4a84      	ldr	r2, [pc, #528]	@ (3401859c <RCCEx_GetSPICLKFreq+0x2e0>)
3401838a:	4293      	cmp	r3, r2
3401838c:	f200 824d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018390:	4a83      	ldr	r2, [pc, #524]	@ (340185a0 <RCCEx_GetSPICLKFreq+0x2e4>)
34018392:	4293      	cmp	r3, r2
34018394:	f000 8236 	beq.w	34018804 <RCCEx_GetSPICLKFreq+0x548>
34018398:	4a81      	ldr	r2, [pc, #516]	@ (340185a0 <RCCEx_GetSPICLKFreq+0x2e4>)
3401839a:	4293      	cmp	r3, r2
3401839c:	f200 8245 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340183a0:	4a80      	ldr	r2, [pc, #512]	@ (340185a4 <RCCEx_GetSPICLKFreq+0x2e8>)
340183a2:	4293      	cmp	r3, r2
340183a4:	f000 822e 	beq.w	34018804 <RCCEx_GetSPICLKFreq+0x548>
340183a8:	4a7e      	ldr	r2, [pc, #504]	@ (340185a4 <RCCEx_GetSPICLKFreq+0x2e8>)
340183aa:	4293      	cmp	r3, r2
340183ac:	f200 823d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340183b0:	4a7d      	ldr	r2, [pc, #500]	@ (340185a8 <RCCEx_GetSPICLKFreq+0x2ec>)
340183b2:	4293      	cmp	r3, r2
340183b4:	f000 8226 	beq.w	34018804 <RCCEx_GetSPICLKFreq+0x548>
340183b8:	4a7b      	ldr	r2, [pc, #492]	@ (340185a8 <RCCEx_GetSPICLKFreq+0x2ec>)
340183ba:	4293      	cmp	r3, r2
340183bc:	f200 8235 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340183c0:	4a7a      	ldr	r2, [pc, #488]	@ (340185ac <RCCEx_GetSPICLKFreq+0x2f0>)
340183c2:	4293      	cmp	r3, r2
340183c4:	f000 821e 	beq.w	34018804 <RCCEx_GetSPICLKFreq+0x548>
340183c8:	4a78      	ldr	r2, [pc, #480]	@ (340185ac <RCCEx_GetSPICLKFreq+0x2f0>)
340183ca:	4293      	cmp	r3, r2
340183cc:	f200 822d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340183d0:	4a77      	ldr	r2, [pc, #476]	@ (340185b0 <RCCEx_GetSPICLKFreq+0x2f4>)
340183d2:	4293      	cmp	r3, r2
340183d4:	f000 8216 	beq.w	34018804 <RCCEx_GetSPICLKFreq+0x548>
340183d8:	4a75      	ldr	r2, [pc, #468]	@ (340185b0 <RCCEx_GetSPICLKFreq+0x2f4>)
340183da:	4293      	cmp	r3, r2
340183dc:	f200 8225 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340183e0:	4a74      	ldr	r2, [pc, #464]	@ (340185b4 <RCCEx_GetSPICLKFreq+0x2f8>)
340183e2:	4293      	cmp	r3, r2
340183e4:	f000 820e 	beq.w	34018804 <RCCEx_GetSPICLKFreq+0x548>
340183e8:	4a72      	ldr	r2, [pc, #456]	@ (340185b4 <RCCEx_GetSPICLKFreq+0x2f8>)
340183ea:	4293      	cmp	r3, r2
340183ec:	f200 821d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340183f0:	4a71      	ldr	r2, [pc, #452]	@ (340185b8 <RCCEx_GetSPICLKFreq+0x2fc>)
340183f2:	4293      	cmp	r3, r2
340183f4:	f000 8171 	beq.w	340186da <RCCEx_GetSPICLKFreq+0x41e>
340183f8:	4a6f      	ldr	r2, [pc, #444]	@ (340185b8 <RCCEx_GetSPICLKFreq+0x2fc>)
340183fa:	4293      	cmp	r3, r2
340183fc:	f200 8215 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018400:	4a6e      	ldr	r2, [pc, #440]	@ (340185bc <RCCEx_GetSPICLKFreq+0x300>)
34018402:	4293      	cmp	r3, r2
34018404:	f000 81ad 	beq.w	34018762 <RCCEx_GetSPICLKFreq+0x4a6>
34018408:	4a6c      	ldr	r2, [pc, #432]	@ (340185bc <RCCEx_GetSPICLKFreq+0x300>)
3401840a:	4293      	cmp	r3, r2
3401840c:	f200 820d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018410:	4a6b      	ldr	r2, [pc, #428]	@ (340185c0 <RCCEx_GetSPICLKFreq+0x304>)
34018412:	4293      	cmp	r3, r2
34018414:	f000 81a5 	beq.w	34018762 <RCCEx_GetSPICLKFreq+0x4a6>
34018418:	4a69      	ldr	r2, [pc, #420]	@ (340185c0 <RCCEx_GetSPICLKFreq+0x304>)
3401841a:	4293      	cmp	r3, r2
3401841c:	f200 8205 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018420:	4a68      	ldr	r2, [pc, #416]	@ (340185c4 <RCCEx_GetSPICLKFreq+0x308>)
34018422:	4293      	cmp	r3, r2
34018424:	f000 8159 	beq.w	340186da <RCCEx_GetSPICLKFreq+0x41e>
34018428:	4a66      	ldr	r2, [pc, #408]	@ (340185c4 <RCCEx_GetSPICLKFreq+0x308>)
3401842a:	4293      	cmp	r3, r2
3401842c:	f200 81fd 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018430:	4a65      	ldr	r2, [pc, #404]	@ (340185c8 <RCCEx_GetSPICLKFreq+0x30c>)
34018432:	4293      	cmp	r3, r2
34018434:	f000 8151 	beq.w	340186da <RCCEx_GetSPICLKFreq+0x41e>
34018438:	4a63      	ldr	r2, [pc, #396]	@ (340185c8 <RCCEx_GetSPICLKFreq+0x30c>)
3401843a:	4293      	cmp	r3, r2
3401843c:	f200 81f5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018440:	4a62      	ldr	r2, [pc, #392]	@ (340185cc <RCCEx_GetSPICLKFreq+0x310>)
34018442:	4293      	cmp	r3, r2
34018444:	f000 8149 	beq.w	340186da <RCCEx_GetSPICLKFreq+0x41e>
34018448:	4a60      	ldr	r2, [pc, #384]	@ (340185cc <RCCEx_GetSPICLKFreq+0x310>)
3401844a:	4293      	cmp	r3, r2
3401844c:	f200 81ed 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018450:	4a5f      	ldr	r2, [pc, #380]	@ (340185d0 <RCCEx_GetSPICLKFreq+0x314>)
34018452:	4293      	cmp	r3, r2
34018454:	f000 80fd 	beq.w	34018652 <RCCEx_GetSPICLKFreq+0x396>
34018458:	4a5d      	ldr	r2, [pc, #372]	@ (340185d0 <RCCEx_GetSPICLKFreq+0x314>)
3401845a:	4293      	cmp	r3, r2
3401845c:	f200 81e5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018460:	4a5c      	ldr	r2, [pc, #368]	@ (340185d4 <RCCEx_GetSPICLKFreq+0x318>)
34018462:	4293      	cmp	r3, r2
34018464:	f000 8139 	beq.w	340186da <RCCEx_GetSPICLKFreq+0x41e>
34018468:	4a5a      	ldr	r2, [pc, #360]	@ (340185d4 <RCCEx_GetSPICLKFreq+0x318>)
3401846a:	4293      	cmp	r3, r2
3401846c:	f200 81dd 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018470:	4a59      	ldr	r2, [pc, #356]	@ (340185d8 <RCCEx_GetSPICLKFreq+0x31c>)
34018472:	4293      	cmp	r3, r2
34018474:	f000 8131 	beq.w	340186da <RCCEx_GetSPICLKFreq+0x41e>
34018478:	4a57      	ldr	r2, [pc, #348]	@ (340185d8 <RCCEx_GetSPICLKFreq+0x31c>)
3401847a:	4293      	cmp	r3, r2
3401847c:	f200 81d5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018480:	4a56      	ldr	r2, [pc, #344]	@ (340185dc <RCCEx_GetSPICLKFreq+0x320>)
34018482:	4293      	cmp	r3, r2
34018484:	f000 80e5 	beq.w	34018652 <RCCEx_GetSPICLKFreq+0x396>
34018488:	4a54      	ldr	r2, [pc, #336]	@ (340185dc <RCCEx_GetSPICLKFreq+0x320>)
3401848a:	4293      	cmp	r3, r2
3401848c:	f200 81cd 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018490:	4a53      	ldr	r2, [pc, #332]	@ (340185e0 <RCCEx_GetSPICLKFreq+0x324>)
34018492:	4293      	cmp	r3, r2
34018494:	f000 80dd 	beq.w	34018652 <RCCEx_GetSPICLKFreq+0x396>
34018498:	4a51      	ldr	r2, [pc, #324]	@ (340185e0 <RCCEx_GetSPICLKFreq+0x324>)
3401849a:	4293      	cmp	r3, r2
3401849c:	f200 81c5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340184a0:	4a50      	ldr	r2, [pc, #320]	@ (340185e4 <RCCEx_GetSPICLKFreq+0x328>)
340184a2:	4293      	cmp	r3, r2
340184a4:	f000 80d5 	beq.w	34018652 <RCCEx_GetSPICLKFreq+0x396>
340184a8:	4a4e      	ldr	r2, [pc, #312]	@ (340185e4 <RCCEx_GetSPICLKFreq+0x328>)
340184aa:	4293      	cmp	r3, r2
340184ac:	f200 81bd 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340184b0:	4a4d      	ldr	r2, [pc, #308]	@ (340185e8 <RCCEx_GetSPICLKFreq+0x32c>)
340184b2:	4293      	cmp	r3, r2
340184b4:	f000 80c8 	beq.w	34018648 <RCCEx_GetSPICLKFreq+0x38c>
340184b8:	4a4b      	ldr	r2, [pc, #300]	@ (340185e8 <RCCEx_GetSPICLKFreq+0x32c>)
340184ba:	4293      	cmp	r3, r2
340184bc:	f200 81b5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340184c0:	4a4a      	ldr	r2, [pc, #296]	@ (340185ec <RCCEx_GetSPICLKFreq+0x330>)
340184c2:	4293      	cmp	r3, r2
340184c4:	f000 80c0 	beq.w	34018648 <RCCEx_GetSPICLKFreq+0x38c>
340184c8:	4a48      	ldr	r2, [pc, #288]	@ (340185ec <RCCEx_GetSPICLKFreq+0x330>)
340184ca:	4293      	cmp	r3, r2
340184cc:	f200 81ad 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340184d0:	4a47      	ldr	r2, [pc, #284]	@ (340185f0 <RCCEx_GetSPICLKFreq+0x334>)
340184d2:	4293      	cmp	r3, r2
340184d4:	f000 80b8 	beq.w	34018648 <RCCEx_GetSPICLKFreq+0x38c>
340184d8:	4a45      	ldr	r2, [pc, #276]	@ (340185f0 <RCCEx_GetSPICLKFreq+0x334>)
340184da:	4293      	cmp	r3, r2
340184dc:	f200 81a5 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340184e0:	4a44      	ldr	r2, [pc, #272]	@ (340185f4 <RCCEx_GetSPICLKFreq+0x338>)
340184e2:	4293      	cmp	r3, r2
340184e4:	f000 80b0 	beq.w	34018648 <RCCEx_GetSPICLKFreq+0x38c>
340184e8:	4a42      	ldr	r2, [pc, #264]	@ (340185f4 <RCCEx_GetSPICLKFreq+0x338>)
340184ea:	4293      	cmp	r3, r2
340184ec:	f200 819d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
340184f0:	4a41      	ldr	r2, [pc, #260]	@ (340185f8 <RCCEx_GetSPICLKFreq+0x33c>)
340184f2:	4293      	cmp	r3, r2
340184f4:	f000 80a8 	beq.w	34018648 <RCCEx_GetSPICLKFreq+0x38c>
340184f8:	4a3f      	ldr	r2, [pc, #252]	@ (340185f8 <RCCEx_GetSPICLKFreq+0x33c>)
340184fa:	4293      	cmp	r3, r2
340184fc:	f200 8195 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018500:	4a3e      	ldr	r2, [pc, #248]	@ (340185fc <RCCEx_GetSPICLKFreq+0x340>)
34018502:	4293      	cmp	r3, r2
34018504:	f000 80a0 	beq.w	34018648 <RCCEx_GetSPICLKFreq+0x38c>
34018508:	4a3c      	ldr	r2, [pc, #240]	@ (340185fc <RCCEx_GetSPICLKFreq+0x340>)
3401850a:	4293      	cmp	r3, r2
3401850c:	f200 818d 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018510:	4a3b      	ldr	r2, [pc, #236]	@ (34018600 <RCCEx_GetSPICLKFreq+0x344>)
34018512:	4293      	cmp	r3, r2
34018514:	f000 808c 	beq.w	34018630 <RCCEx_GetSPICLKFreq+0x374>
34018518:	4a39      	ldr	r2, [pc, #228]	@ (34018600 <RCCEx_GetSPICLKFreq+0x344>)
3401851a:	4293      	cmp	r3, r2
3401851c:	f200 8185 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
34018520:	4a38      	ldr	r2, [pc, #224]	@ (34018604 <RCCEx_GetSPICLKFreq+0x348>)
34018522:	4293      	cmp	r3, r2
34018524:	d078      	beq.n	34018618 <RCCEx_GetSPICLKFreq+0x35c>
34018526:	4a37      	ldr	r2, [pc, #220]	@ (34018604 <RCCEx_GetSPICLKFreq+0x348>)
34018528:	4293      	cmp	r3, r2
3401852a:	f200 817e 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
3401852e:	4a36      	ldr	r2, [pc, #216]	@ (34018608 <RCCEx_GetSPICLKFreq+0x34c>)
34018530:	4293      	cmp	r3, r2
34018532:	d071      	beq.n	34018618 <RCCEx_GetSPICLKFreq+0x35c>
34018534:	4a34      	ldr	r2, [pc, #208]	@ (34018608 <RCCEx_GetSPICLKFreq+0x34c>)
34018536:	4293      	cmp	r3, r2
34018538:	f200 8177 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
3401853c:	4a33      	ldr	r2, [pc, #204]	@ (3401860c <RCCEx_GetSPICLKFreq+0x350>)
3401853e:	4293      	cmp	r3, r2
34018540:	d00a      	beq.n	34018558 <RCCEx_GetSPICLKFreq+0x29c>
34018542:	4a32      	ldr	r2, [pc, #200]	@ (3401860c <RCCEx_GetSPICLKFreq+0x350>)
34018544:	4293      	cmp	r3, r2
34018546:	f200 8170 	bhi.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
3401854a:	4a31      	ldr	r2, [pc, #196]	@ (34018610 <RCCEx_GetSPICLKFreq+0x354>)
3401854c:	4293      	cmp	r3, r2
3401854e:	d063      	beq.n	34018618 <RCCEx_GetSPICLKFreq+0x35c>
34018550:	4a30      	ldr	r2, [pc, #192]	@ (34018614 <RCCEx_GetSPICLKFreq+0x358>)
34018552:	4293      	cmp	r3, r2
34018554:	f040 8169 	bne.w	3401882a <RCCEx_GetSPICLKFreq+0x56e>
  {
    case LL_RCC_SPI2_CLKSOURCE_PCLK1:
    case LL_RCC_SPI3_CLKSOURCE_PCLK1:
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018558:	f7f4 fae0 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
3401855c:	4603      	mov	r3, r0
3401855e:	4618      	mov	r0, r3
34018560:	f7fd fbd4 	bl	34015d0c <RCCEx_GetHCLKFreq>
34018564:	4603      	mov	r3, r0
34018566:	4618      	mov	r0, r3
34018568:	f7fd fbe1 	bl	34015d2e <RCCEx_GetPCLK1Freq>
3401856c:	60f8      	str	r0, [r7, #12]
      break;
3401856e:	e169      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
34018570:	07061820 	.word	0x07061820
34018574:	07061420 	.word	0x07061420
34018578:	07061020 	.word	0x07061020
3401857c:	07060c20 	.word	0x07060c20
34018580:	07060820 	.word	0x07060820
34018584:	07060420 	.word	0x07060420
34018588:	07051820 	.word	0x07051820
3401858c:	07051420 	.word	0x07051420
34018590:	07051020 	.word	0x07051020
34018594:	07050c20 	.word	0x07050c20
34018598:	07050820 	.word	0x07050820
3401859c:	07050420 	.word	0x07050420
340185a0:	07041820 	.word	0x07041820
340185a4:	07041420 	.word	0x07041420
340185a8:	07041020 	.word	0x07041020
340185ac:	07040c20 	.word	0x07040c20
340185b0:	07040820 	.word	0x07040820
340185b4:	07040420 	.word	0x07040420
340185b8:	07031820 	.word	0x07031820
340185bc:	07031420 	.word	0x07031420
340185c0:	07031020 	.word	0x07031020
340185c4:	07030c20 	.word	0x07030c20
340185c8:	07030820 	.word	0x07030820
340185cc:	07030420 	.word	0x07030420
340185d0:	07021820 	.word	0x07021820
340185d4:	07021420 	.word	0x07021420
340185d8:	07021020 	.word	0x07021020
340185dc:	07020c20 	.word	0x07020c20
340185e0:	07020820 	.word	0x07020820
340185e4:	07020420 	.word	0x07020420
340185e8:	07011820 	.word	0x07011820
340185ec:	07011420 	.word	0x07011420
340185f0:	07011020 	.word	0x07011020
340185f4:	07010c20 	.word	0x07010c20
340185f8:	07010820 	.word	0x07010820
340185fc:	07010420 	.word	0x07010420
34018600:	07001820 	.word	0x07001820
34018604:	07001420 	.word	0x07001420
34018608:	07001020 	.word	0x07001020
3401860c:	07000c20 	.word	0x07000c20
34018610:	07000420 	.word	0x07000420
34018614:	07000820 	.word	0x07000820

    case LL_RCC_SPI1_CLKSOURCE_PCLK2:
    case LL_RCC_SPI4_CLKSOURCE_PCLK2:
    case LL_RCC_SPI5_CLKSOURCE_PCLK2:
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018618:	f7f4 fa80 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
3401861c:	4603      	mov	r3, r0
3401861e:	4618      	mov	r0, r3
34018620:	f7fd fb74 	bl	34015d0c <RCCEx_GetHCLKFreq>
34018624:	4603      	mov	r3, r0
34018626:	4618      	mov	r0, r3
34018628:	f7fd fb91 	bl	34015d4e <RCCEx_GetPCLK2Freq>
3401862c:	60f8      	str	r0, [r7, #12]
      break;
3401862e:	e109      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI6_CLKSOURCE_PCLK4:
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018630:	f7f4 fa74 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34018634:	4603      	mov	r3, r0
34018636:	4618      	mov	r0, r3
34018638:	f7fd fb68 	bl	34015d0c <RCCEx_GetHCLKFreq>
3401863c:	4603      	mov	r3, r0
3401863e:	4618      	mov	r0, r3
34018640:	f7fd fb96 	bl	34015d70 <RCCEx_GetPCLK4Freq>
34018644:	60f8      	str	r0, [r7, #12]
      break;
34018646:	e0fd      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
    case LL_RCC_SPI2_CLKSOURCE_CLKP:
    case LL_RCC_SPI3_CLKSOURCE_CLKP:
    case LL_RCC_SPI4_CLKSOURCE_CLKP:
    case LL_RCC_SPI5_CLKSOURCE_CLKP:
    case LL_RCC_SPI6_CLKSOURCE_CLKP:
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34018648:	2007      	movs	r0, #7
3401864a:	f7fd fe4b 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401864e:	60f8      	str	r0, [r7, #12]
      break;
34018650:	e0f8      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI1_CLKSOURCE_IC8:
    case LL_RCC_SPI2_CLKSOURCE_IC8:
    case LL_RCC_SPI3_CLKSOURCE_IC8:
    case LL_RCC_SPI6_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34018652:	f7f5 fe45 	bl	3400e2e0 <LL_RCC_IC8_IsEnabled>
34018656:	4603      	mov	r3, r0
34018658:	2b00      	cmp	r3, #0
3401865a:	f000 80e8 	beq.w	3401882e <RCCEx_GetSPICLKFreq+0x572>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
3401865e:	f7f5 fe61 	bl	3400e324 <LL_RCC_IC8_GetDivider>
34018662:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34018664:	f7f5 fe50 	bl	3400e308 <LL_RCC_IC8_GetSource>
34018668:	4603      	mov	r3, r0
3401866a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401866e:	d029      	beq.n	340186c4 <RCCEx_GetSPICLKFreq+0x408>
34018670:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018674:	d82f      	bhi.n	340186d6 <RCCEx_GetSPICLKFreq+0x41a>
34018676:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401867a:	d01a      	beq.n	340186b2 <RCCEx_GetSPICLKFreq+0x3f6>
3401867c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018680:	d829      	bhi.n	340186d6 <RCCEx_GetSPICLKFreq+0x41a>
34018682:	2b00      	cmp	r3, #0
34018684:	d003      	beq.n	3401868e <RCCEx_GetSPICLKFreq+0x3d2>
34018686:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401868a:	d009      	beq.n	340186a0 <RCCEx_GetSPICLKFreq+0x3e4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401868c:	e023      	b.n	340186d6 <RCCEx_GetSPICLKFreq+0x41a>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401868e:	f7fd fa25 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018692:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34018694:	68fa      	ldr	r2, [r7, #12]
34018696:	68bb      	ldr	r3, [r7, #8]
34018698:	fbb2 f3f3 	udiv	r3, r2, r3
3401869c:	60fb      	str	r3, [r7, #12]
            break;
3401869e:	e01b      	b.n	340186d8 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340186a0:	f7fd fa62 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340186a4:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340186a6:	68fa      	ldr	r2, [r7, #12]
340186a8:	68bb      	ldr	r3, [r7, #8]
340186aa:	fbb2 f3f3 	udiv	r3, r2, r3
340186ae:	60fb      	str	r3, [r7, #12]
            break;
340186b0:	e012      	b.n	340186d8 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340186b2:	f7fd fa9f 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340186b6:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340186b8:	68fa      	ldr	r2, [r7, #12]
340186ba:	68bb      	ldr	r3, [r7, #8]
340186bc:	fbb2 f3f3 	udiv	r3, r2, r3
340186c0:	60fb      	str	r3, [r7, #12]
            break;
340186c2:	e009      	b.n	340186d8 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340186c4:	f7fd fadc 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340186c8:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340186ca:	68fa      	ldr	r2, [r7, #12]
340186cc:	68bb      	ldr	r3, [r7, #8]
340186ce:	fbb2 f3f3 	udiv	r3, r2, r3
340186d2:	60fb      	str	r3, [r7, #12]
            break;
340186d4:	e000      	b.n	340186d8 <RCCEx_GetSPICLKFreq+0x41c>
            break;
340186d6:	bf00      	nop
        }
      }
      break;
340186d8:	e0a9      	b.n	3401882e <RCCEx_GetSPICLKFreq+0x572>
    case LL_RCC_SPI2_CLKSOURCE_IC9:
    case LL_RCC_SPI3_CLKSOURCE_IC9:
    case LL_RCC_SPI4_CLKSOURCE_IC9:
    case LL_RCC_SPI5_CLKSOURCE_IC9:
    case LL_RCC_SPI6_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
340186da:	f7f5 fe41 	bl	3400e360 <LL_RCC_IC9_IsEnabled>
340186de:	4603      	mov	r3, r0
340186e0:	2b00      	cmp	r3, #0
340186e2:	f000 80a6 	beq.w	34018832 <RCCEx_GetSPICLKFreq+0x576>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
340186e6:	f7f5 fe5d 	bl	3400e3a4 <LL_RCC_IC9_GetDivider>
340186ea:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
340186ec:	f7f5 fe4c 	bl	3400e388 <LL_RCC_IC9_GetSource>
340186f0:	4603      	mov	r3, r0
340186f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340186f6:	d029      	beq.n	3401874c <RCCEx_GetSPICLKFreq+0x490>
340186f8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340186fc:	d82f      	bhi.n	3401875e <RCCEx_GetSPICLKFreq+0x4a2>
340186fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018702:	d01a      	beq.n	3401873a <RCCEx_GetSPICLKFreq+0x47e>
34018704:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018708:	d829      	bhi.n	3401875e <RCCEx_GetSPICLKFreq+0x4a2>
3401870a:	2b00      	cmp	r3, #0
3401870c:	d003      	beq.n	34018716 <RCCEx_GetSPICLKFreq+0x45a>
3401870e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018712:	d009      	beq.n	34018728 <RCCEx_GetSPICLKFreq+0x46c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34018714:	e023      	b.n	3401875e <RCCEx_GetSPICLKFreq+0x4a2>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34018716:	f7fd f9e1 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
3401871a:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401871c:	68fa      	ldr	r2, [r7, #12]
3401871e:	68bb      	ldr	r3, [r7, #8]
34018720:	fbb2 f3f3 	udiv	r3, r2, r3
34018724:	60fb      	str	r3, [r7, #12]
            break;
34018726:	e01b      	b.n	34018760 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34018728:	f7fd fa1e 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401872c:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401872e:	68fa      	ldr	r2, [r7, #12]
34018730:	68bb      	ldr	r3, [r7, #8]
34018732:	fbb2 f3f3 	udiv	r3, r2, r3
34018736:	60fb      	str	r3, [r7, #12]
            break;
34018738:	e012      	b.n	34018760 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401873a:	f7fd fa5b 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401873e:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34018740:	68fa      	ldr	r2, [r7, #12]
34018742:	68bb      	ldr	r3, [r7, #8]
34018744:	fbb2 f3f3 	udiv	r3, r2, r3
34018748:	60fb      	str	r3, [r7, #12]
            break;
3401874a:	e009      	b.n	34018760 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401874c:	f7fd fa98 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34018750:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34018752:	68fa      	ldr	r2, [r7, #12]
34018754:	68bb      	ldr	r3, [r7, #8]
34018756:	fbb2 f3f3 	udiv	r3, r2, r3
3401875a:	60fb      	str	r3, [r7, #12]
            break;
3401875c:	e000      	b.n	34018760 <RCCEx_GetSPICLKFreq+0x4a4>
            break;
3401875e:	bf00      	nop
        }
      }
      break;
34018760:	e067      	b.n	34018832 <RCCEx_GetSPICLKFreq+0x576>

    case LL_RCC_SPI4_CLKSOURCE_IC14:
    case LL_RCC_SPI5_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
34018762:	f7f5 fefd 	bl	3400e560 <LL_RCC_IC14_IsEnabled>
34018766:	4603      	mov	r3, r0
34018768:	2b00      	cmp	r3, #0
3401876a:	d064      	beq.n	34018836 <RCCEx_GetSPICLKFreq+0x57a>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
3401876c:	f7f5 ff1a 	bl	3400e5a4 <LL_RCC_IC14_GetDivider>
34018770:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34018772:	f7f5 ff09 	bl	3400e588 <LL_RCC_IC14_GetSource>
34018776:	4603      	mov	r3, r0
34018778:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401877c:	d029      	beq.n	340187d2 <RCCEx_GetSPICLKFreq+0x516>
3401877e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018782:	d82f      	bhi.n	340187e4 <RCCEx_GetSPICLKFreq+0x528>
34018784:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018788:	d01a      	beq.n	340187c0 <RCCEx_GetSPICLKFreq+0x504>
3401878a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401878e:	d829      	bhi.n	340187e4 <RCCEx_GetSPICLKFreq+0x528>
34018790:	2b00      	cmp	r3, #0
34018792:	d003      	beq.n	3401879c <RCCEx_GetSPICLKFreq+0x4e0>
34018794:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018798:	d009      	beq.n	340187ae <RCCEx_GetSPICLKFreq+0x4f2>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401879a:	e023      	b.n	340187e4 <RCCEx_GetSPICLKFreq+0x528>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401879c:	f7fd f99e 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340187a0:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340187a2:	68fa      	ldr	r2, [r7, #12]
340187a4:	68bb      	ldr	r3, [r7, #8]
340187a6:	fbb2 f3f3 	udiv	r3, r2, r3
340187aa:	60fb      	str	r3, [r7, #12]
            break;
340187ac:	e01b      	b.n	340187e6 <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340187ae:	f7fd f9db 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340187b2:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340187b4:	68fa      	ldr	r2, [r7, #12]
340187b6:	68bb      	ldr	r3, [r7, #8]
340187b8:	fbb2 f3f3 	udiv	r3, r2, r3
340187bc:	60fb      	str	r3, [r7, #12]
            break;
340187be:	e012      	b.n	340187e6 <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340187c0:	f7fd fa18 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340187c4:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340187c6:	68fa      	ldr	r2, [r7, #12]
340187c8:	68bb      	ldr	r3, [r7, #8]
340187ca:	fbb2 f3f3 	udiv	r3, r2, r3
340187ce:	60fb      	str	r3, [r7, #12]
            break;
340187d0:	e009      	b.n	340187e6 <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340187d2:	f7fd fa55 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340187d6:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340187d8:	68fa      	ldr	r2, [r7, #12]
340187da:	68bb      	ldr	r3, [r7, #8]
340187dc:	fbb2 f3f3 	udiv	r3, r2, r3
340187e0:	60fb      	str	r3, [r7, #12]
            break;
340187e2:	e000      	b.n	340187e6 <RCCEx_GetSPICLKFreq+0x52a>
            break;
340187e4:	bf00      	nop
        }
      }
      break;
340187e6:	e026      	b.n	34018836 <RCCEx_GetSPICLKFreq+0x57a>
    case LL_RCC_SPI2_CLKSOURCE_HSI:
    case LL_RCC_SPI3_CLKSOURCE_HSI:
    case LL_RCC_SPI4_CLKSOURCE_HSI:
    case LL_RCC_SPI5_CLKSOURCE_HSI:
    case LL_RCC_SPI6_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340187e8:	f7f4 fd96 	bl	3400d318 <LL_RCC_HSI_IsReady>
340187ec:	4603      	mov	r3, r0
340187ee:	2b00      	cmp	r3, #0
340187f0:	d023      	beq.n	3401883a <RCCEx_GetSPICLKFreq+0x57e>
      {
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340187f2:	f7f4 fda3 	bl	3400d33c <LL_RCC_HSI_GetDivider>
340187f6:	4603      	mov	r3, r0
340187f8:	09db      	lsrs	r3, r3, #7
340187fa:	4a15      	ldr	r2, [pc, #84]	@ (34018850 <RCCEx_GetSPICLKFreq+0x594>)
340187fc:	fa22 f303 	lsr.w	r3, r2, r3
34018800:	60fb      	str	r3, [r7, #12]
      }
      break;
34018802:	e01a      	b.n	3401883a <RCCEx_GetSPICLKFreq+0x57e>
    case LL_RCC_SPI2_CLKSOURCE_MSI:
    case LL_RCC_SPI3_CLKSOURCE_MSI:
    case LL_RCC_SPI4_CLKSOURCE_MSI:
    case LL_RCC_SPI5_CLKSOURCE_MSI:
    case LL_RCC_SPI6_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34018804:	f7f4 fda8 	bl	3400d358 <LL_RCC_MSI_IsReady>
34018808:	4603      	mov	r3, r0
3401880a:	2b00      	cmp	r3, #0
3401880c:	d017      	beq.n	3401883e <RCCEx_GetSPICLKFreq+0x582>
      {
        spi_frequency = MSI_VALUE;
3401880e:	4b11      	ldr	r3, [pc, #68]	@ (34018854 <RCCEx_GetSPICLKFreq+0x598>)
34018810:	60fb      	str	r3, [r7, #12]
      }
      break;
34018812:	e014      	b.n	3401883e <RCCEx_GetSPICLKFreq+0x582>

    case LL_RCC_SPI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI2_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI3_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:
      spi_frequency = EXTERNAL_CLOCK_VALUE;
34018814:	4b10      	ldr	r3, [pc, #64]	@ (34018858 <RCCEx_GetSPICLKFreq+0x59c>)
34018816:	60fb      	str	r3, [r7, #12]
      break;
34018818:	e014      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI4_CLKSOURCE_HSE:
    case LL_RCC_SPI5_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
3401881a:	f7f4 fd6b 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
3401881e:	4603      	mov	r3, r0
34018820:	2b00      	cmp	r3, #0
34018822:	d00e      	beq.n	34018842 <RCCEx_GetSPICLKFreq+0x586>
      {
        spi_frequency = HSE_VALUE;
34018824:	4b0d      	ldr	r3, [pc, #52]	@ (3401885c <RCCEx_GetSPICLKFreq+0x5a0>)
34018826:	60fb      	str	r3, [r7, #12]
      }
      break;
34018828:	e00b      	b.n	34018842 <RCCEx_GetSPICLKFreq+0x586>

    default:
      /* Unexpected case */
      break;
3401882a:	bf00      	nop
3401882c:	e00a      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
      break;
3401882e:	bf00      	nop
34018830:	e008      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
      break;
34018832:	bf00      	nop
34018834:	e006      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
      break;
34018836:	bf00      	nop
34018838:	e004      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
      break;
3401883a:	bf00      	nop
3401883c:	e002      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
      break;
3401883e:	bf00      	nop
34018840:	e000      	b.n	34018844 <RCCEx_GetSPICLKFreq+0x588>
      break;
34018842:	bf00      	nop
  }

  return spi_frequency;
34018844:	68fb      	ldr	r3, [r7, #12]
}
34018846:	4618      	mov	r0, r3
34018848:	3710      	adds	r7, #16
3401884a:	46bd      	mov	sp, r7
3401884c:	bd80      	pop	{r7, pc}
3401884e:	bf00      	nop
34018850:	03d09000 	.word	0x03d09000
34018854:	003d0900 	.word	0x003d0900
34018858:	00bb8000 	.word	0x00bb8000
3401885c:	02dc6c00 	.word	0x02dc6c00

34018860 <RCCEx_GetUARTCLKFreq>:
  *         @arg @ref RCCEx_UART9_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUARTCLKFreq(uint32_t UARTxSource)
{
34018860:	b580      	push	{r7, lr}
34018862:	b084      	sub	sp, #16
34018864:	af00      	add	r7, sp, #0
34018866:	6078      	str	r0, [r7, #4]
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
34018868:	2300      	movs	r3, #0
3401886a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3401886c:	6878      	ldr	r0, [r7, #4]
3401886e:	f7f5 f947 	bl	3400db00 <LL_RCC_GetUARTClockSource>
34018872:	4603      	mov	r3, r0
34018874:	4aa2      	ldr	r2, [pc, #648]	@ (34018b00 <RCCEx_GetUARTCLKFreq+0x2a0>)
34018876:	4293      	cmp	r3, r2
34018878:	f000 81e8 	beq.w	34018c4c <RCCEx_GetUARTCLKFreq+0x3ec>
3401887c:	4aa0      	ldr	r2, [pc, #640]	@ (34018b00 <RCCEx_GetUARTCLKFreq+0x2a0>)
3401887e:	4293      	cmp	r3, r2
34018880:	f200 8203 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018884:	4a9f      	ldr	r2, [pc, #636]	@ (34018b04 <RCCEx_GetUARTCLKFreq+0x2a4>)
34018886:	4293      	cmp	r3, r2
34018888:	f000 81e0 	beq.w	34018c4c <RCCEx_GetUARTCLKFreq+0x3ec>
3401888c:	4a9d      	ldr	r2, [pc, #628]	@ (34018b04 <RCCEx_GetUARTCLKFreq+0x2a4>)
3401888e:	4293      	cmp	r3, r2
34018890:	f200 81fb 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018894:	4a9c      	ldr	r2, [pc, #624]	@ (34018b08 <RCCEx_GetUARTCLKFreq+0x2a8>)
34018896:	4293      	cmp	r3, r2
34018898:	f000 81d8 	beq.w	34018c4c <RCCEx_GetUARTCLKFreq+0x3ec>
3401889c:	4a9a      	ldr	r2, [pc, #616]	@ (34018b08 <RCCEx_GetUARTCLKFreq+0x2a8>)
3401889e:	4293      	cmp	r3, r2
340188a0:	f200 81f3 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340188a4:	4a99      	ldr	r2, [pc, #612]	@ (34018b0c <RCCEx_GetUARTCLKFreq+0x2ac>)
340188a6:	4293      	cmp	r3, r2
340188a8:	f000 81d0 	beq.w	34018c4c <RCCEx_GetUARTCLKFreq+0x3ec>
340188ac:	4a97      	ldr	r2, [pc, #604]	@ (34018b0c <RCCEx_GetUARTCLKFreq+0x2ac>)
340188ae:	4293      	cmp	r3, r2
340188b0:	f200 81eb 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340188b4:	4a96      	ldr	r2, [pc, #600]	@ (34018b10 <RCCEx_GetUARTCLKFreq+0x2b0>)
340188b6:	4293      	cmp	r3, r2
340188b8:	f000 81c8 	beq.w	34018c4c <RCCEx_GetUARTCLKFreq+0x3ec>
340188bc:	4a94      	ldr	r2, [pc, #592]	@ (34018b10 <RCCEx_GetUARTCLKFreq+0x2b0>)
340188be:	4293      	cmp	r3, r2
340188c0:	f200 81e3 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340188c4:	4a93      	ldr	r2, [pc, #588]	@ (34018b14 <RCCEx_GetUARTCLKFreq+0x2b4>)
340188c6:	4293      	cmp	r3, r2
340188c8:	f000 81ce 	beq.w	34018c68 <RCCEx_GetUARTCLKFreq+0x408>
340188cc:	4a91      	ldr	r2, [pc, #580]	@ (34018b14 <RCCEx_GetUARTCLKFreq+0x2b4>)
340188ce:	4293      	cmp	r3, r2
340188d0:	f200 81db 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340188d4:	4a90      	ldr	r2, [pc, #576]	@ (34018b18 <RCCEx_GetUARTCLKFreq+0x2b8>)
340188d6:	4293      	cmp	r3, r2
340188d8:	f000 81c6 	beq.w	34018c68 <RCCEx_GetUARTCLKFreq+0x408>
340188dc:	4a8e      	ldr	r2, [pc, #568]	@ (34018b18 <RCCEx_GetUARTCLKFreq+0x2b8>)
340188de:	4293      	cmp	r3, r2
340188e0:	f200 81d3 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340188e4:	4a8d      	ldr	r2, [pc, #564]	@ (34018b1c <RCCEx_GetUARTCLKFreq+0x2bc>)
340188e6:	4293      	cmp	r3, r2
340188e8:	f000 81be 	beq.w	34018c68 <RCCEx_GetUARTCLKFreq+0x408>
340188ec:	4a8b      	ldr	r2, [pc, #556]	@ (34018b1c <RCCEx_GetUARTCLKFreq+0x2bc>)
340188ee:	4293      	cmp	r3, r2
340188f0:	f200 81cb 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340188f4:	4a8a      	ldr	r2, [pc, #552]	@ (34018b20 <RCCEx_GetUARTCLKFreq+0x2c0>)
340188f6:	4293      	cmp	r3, r2
340188f8:	f000 81b6 	beq.w	34018c68 <RCCEx_GetUARTCLKFreq+0x408>
340188fc:	4a88      	ldr	r2, [pc, #544]	@ (34018b20 <RCCEx_GetUARTCLKFreq+0x2c0>)
340188fe:	4293      	cmp	r3, r2
34018900:	f200 81c3 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018904:	4a87      	ldr	r2, [pc, #540]	@ (34018b24 <RCCEx_GetUARTCLKFreq+0x2c4>)
34018906:	4293      	cmp	r3, r2
34018908:	f000 81ae 	beq.w	34018c68 <RCCEx_GetUARTCLKFreq+0x408>
3401890c:	4a85      	ldr	r2, [pc, #532]	@ (34018b24 <RCCEx_GetUARTCLKFreq+0x2c4>)
3401890e:	4293      	cmp	r3, r2
34018910:	f200 81bb 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018914:	4a84      	ldr	r2, [pc, #528]	@ (34018b28 <RCCEx_GetUARTCLKFreq+0x2c8>)
34018916:	4293      	cmp	r3, r2
34018918:	f000 81ae 	beq.w	34018c78 <RCCEx_GetUARTCLKFreq+0x418>
3401891c:	4a82      	ldr	r2, [pc, #520]	@ (34018b28 <RCCEx_GetUARTCLKFreq+0x2c8>)
3401891e:	4293      	cmp	r3, r2
34018920:	f200 81b3 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018924:	4a81      	ldr	r2, [pc, #516]	@ (34018b2c <RCCEx_GetUARTCLKFreq+0x2cc>)
34018926:	4293      	cmp	r3, r2
34018928:	f000 81a6 	beq.w	34018c78 <RCCEx_GetUARTCLKFreq+0x418>
3401892c:	4a7f      	ldr	r2, [pc, #508]	@ (34018b2c <RCCEx_GetUARTCLKFreq+0x2cc>)
3401892e:	4293      	cmp	r3, r2
34018930:	f200 81ab 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018934:	4a7e      	ldr	r2, [pc, #504]	@ (34018b30 <RCCEx_GetUARTCLKFreq+0x2d0>)
34018936:	4293      	cmp	r3, r2
34018938:	f000 819e 	beq.w	34018c78 <RCCEx_GetUARTCLKFreq+0x418>
3401893c:	4a7c      	ldr	r2, [pc, #496]	@ (34018b30 <RCCEx_GetUARTCLKFreq+0x2d0>)
3401893e:	4293      	cmp	r3, r2
34018940:	f200 81a3 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018944:	4a7b      	ldr	r2, [pc, #492]	@ (34018b34 <RCCEx_GetUARTCLKFreq+0x2d4>)
34018946:	4293      	cmp	r3, r2
34018948:	f000 8196 	beq.w	34018c78 <RCCEx_GetUARTCLKFreq+0x418>
3401894c:	4a79      	ldr	r2, [pc, #484]	@ (34018b34 <RCCEx_GetUARTCLKFreq+0x2d4>)
3401894e:	4293      	cmp	r3, r2
34018950:	f200 819b 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018954:	4a78      	ldr	r2, [pc, #480]	@ (34018b38 <RCCEx_GetUARTCLKFreq+0x2d8>)
34018956:	4293      	cmp	r3, r2
34018958:	f000 818e 	beq.w	34018c78 <RCCEx_GetUARTCLKFreq+0x418>
3401895c:	4a76      	ldr	r2, [pc, #472]	@ (34018b38 <RCCEx_GetUARTCLKFreq+0x2d8>)
3401895e:	4293      	cmp	r3, r2
34018960:	f200 8193 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018964:	4a75      	ldr	r2, [pc, #468]	@ (34018b3c <RCCEx_GetUARTCLKFreq+0x2dc>)
34018966:	4293      	cmp	r3, r2
34018968:	f000 812d 	beq.w	34018bc6 <RCCEx_GetUARTCLKFreq+0x366>
3401896c:	4a73      	ldr	r2, [pc, #460]	@ (34018b3c <RCCEx_GetUARTCLKFreq+0x2dc>)
3401896e:	4293      	cmp	r3, r2
34018970:	f200 818b 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018974:	4a72      	ldr	r2, [pc, #456]	@ (34018b40 <RCCEx_GetUARTCLKFreq+0x2e0>)
34018976:	4293      	cmp	r3, r2
34018978:	f000 8125 	beq.w	34018bc6 <RCCEx_GetUARTCLKFreq+0x366>
3401897c:	4a70      	ldr	r2, [pc, #448]	@ (34018b40 <RCCEx_GetUARTCLKFreq+0x2e0>)
3401897e:	4293      	cmp	r3, r2
34018980:	f200 8183 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018984:	4a6f      	ldr	r2, [pc, #444]	@ (34018b44 <RCCEx_GetUARTCLKFreq+0x2e4>)
34018986:	4293      	cmp	r3, r2
34018988:	f000 811d 	beq.w	34018bc6 <RCCEx_GetUARTCLKFreq+0x366>
3401898c:	4a6d      	ldr	r2, [pc, #436]	@ (34018b44 <RCCEx_GetUARTCLKFreq+0x2e4>)
3401898e:	4293      	cmp	r3, r2
34018990:	f200 817b 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018994:	4a6c      	ldr	r2, [pc, #432]	@ (34018b48 <RCCEx_GetUARTCLKFreq+0x2e8>)
34018996:	4293      	cmp	r3, r2
34018998:	f000 8115 	beq.w	34018bc6 <RCCEx_GetUARTCLKFreq+0x366>
3401899c:	4a6a      	ldr	r2, [pc, #424]	@ (34018b48 <RCCEx_GetUARTCLKFreq+0x2e8>)
3401899e:	4293      	cmp	r3, r2
340189a0:	f200 8173 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189a4:	4a69      	ldr	r2, [pc, #420]	@ (34018b4c <RCCEx_GetUARTCLKFreq+0x2ec>)
340189a6:	4293      	cmp	r3, r2
340189a8:	f000 810d 	beq.w	34018bc6 <RCCEx_GetUARTCLKFreq+0x366>
340189ac:	4a67      	ldr	r2, [pc, #412]	@ (34018b4c <RCCEx_GetUARTCLKFreq+0x2ec>)
340189ae:	4293      	cmp	r3, r2
340189b0:	f200 816b 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189b4:	4a66      	ldr	r2, [pc, #408]	@ (34018b50 <RCCEx_GetUARTCLKFreq+0x2f0>)
340189b6:	4293      	cmp	r3, r2
340189b8:	d07b      	beq.n	34018ab2 <RCCEx_GetUARTCLKFreq+0x252>
340189ba:	4a65      	ldr	r2, [pc, #404]	@ (34018b50 <RCCEx_GetUARTCLKFreq+0x2f0>)
340189bc:	4293      	cmp	r3, r2
340189be:	f200 8164 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189c2:	4a64      	ldr	r2, [pc, #400]	@ (34018b54 <RCCEx_GetUARTCLKFreq+0x2f4>)
340189c4:	4293      	cmp	r3, r2
340189c6:	d074      	beq.n	34018ab2 <RCCEx_GetUARTCLKFreq+0x252>
340189c8:	4a62      	ldr	r2, [pc, #392]	@ (34018b54 <RCCEx_GetUARTCLKFreq+0x2f4>)
340189ca:	4293      	cmp	r3, r2
340189cc:	f200 815d 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189d0:	4a61      	ldr	r2, [pc, #388]	@ (34018b58 <RCCEx_GetUARTCLKFreq+0x2f8>)
340189d2:	4293      	cmp	r3, r2
340189d4:	d06d      	beq.n	34018ab2 <RCCEx_GetUARTCLKFreq+0x252>
340189d6:	4a60      	ldr	r2, [pc, #384]	@ (34018b58 <RCCEx_GetUARTCLKFreq+0x2f8>)
340189d8:	4293      	cmp	r3, r2
340189da:	f200 8156 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189de:	4a5f      	ldr	r2, [pc, #380]	@ (34018b5c <RCCEx_GetUARTCLKFreq+0x2fc>)
340189e0:	4293      	cmp	r3, r2
340189e2:	d066      	beq.n	34018ab2 <RCCEx_GetUARTCLKFreq+0x252>
340189e4:	4a5d      	ldr	r2, [pc, #372]	@ (34018b5c <RCCEx_GetUARTCLKFreq+0x2fc>)
340189e6:	4293      	cmp	r3, r2
340189e8:	f200 814f 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189ec:	4a5c      	ldr	r2, [pc, #368]	@ (34018b60 <RCCEx_GetUARTCLKFreq+0x300>)
340189ee:	4293      	cmp	r3, r2
340189f0:	d05f      	beq.n	34018ab2 <RCCEx_GetUARTCLKFreq+0x252>
340189f2:	4a5b      	ldr	r2, [pc, #364]	@ (34018b60 <RCCEx_GetUARTCLKFreq+0x300>)
340189f4:	4293      	cmp	r3, r2
340189f6:	f200 8148 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
340189fa:	4a5a      	ldr	r2, [pc, #360]	@ (34018b64 <RCCEx_GetUARTCLKFreq+0x304>)
340189fc:	4293      	cmp	r3, r2
340189fe:	d053      	beq.n	34018aa8 <RCCEx_GetUARTCLKFreq+0x248>
34018a00:	4a58      	ldr	r2, [pc, #352]	@ (34018b64 <RCCEx_GetUARTCLKFreq+0x304>)
34018a02:	4293      	cmp	r3, r2
34018a04:	f200 8141 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a08:	4a57      	ldr	r2, [pc, #348]	@ (34018b68 <RCCEx_GetUARTCLKFreq+0x308>)
34018a0a:	4293      	cmp	r3, r2
34018a0c:	d04c      	beq.n	34018aa8 <RCCEx_GetUARTCLKFreq+0x248>
34018a0e:	4a56      	ldr	r2, [pc, #344]	@ (34018b68 <RCCEx_GetUARTCLKFreq+0x308>)
34018a10:	4293      	cmp	r3, r2
34018a12:	f200 813a 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a16:	4a55      	ldr	r2, [pc, #340]	@ (34018b6c <RCCEx_GetUARTCLKFreq+0x30c>)
34018a18:	4293      	cmp	r3, r2
34018a1a:	d045      	beq.n	34018aa8 <RCCEx_GetUARTCLKFreq+0x248>
34018a1c:	4a53      	ldr	r2, [pc, #332]	@ (34018b6c <RCCEx_GetUARTCLKFreq+0x30c>)
34018a1e:	4293      	cmp	r3, r2
34018a20:	f200 8133 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a24:	4a52      	ldr	r2, [pc, #328]	@ (34018b70 <RCCEx_GetUARTCLKFreq+0x310>)
34018a26:	4293      	cmp	r3, r2
34018a28:	d03e      	beq.n	34018aa8 <RCCEx_GetUARTCLKFreq+0x248>
34018a2a:	4a51      	ldr	r2, [pc, #324]	@ (34018b70 <RCCEx_GetUARTCLKFreq+0x310>)
34018a2c:	4293      	cmp	r3, r2
34018a2e:	f200 812c 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a32:	4a50      	ldr	r2, [pc, #320]	@ (34018b74 <RCCEx_GetUARTCLKFreq+0x314>)
34018a34:	4293      	cmp	r3, r2
34018a36:	d037      	beq.n	34018aa8 <RCCEx_GetUARTCLKFreq+0x248>
34018a38:	4a4e      	ldr	r2, [pc, #312]	@ (34018b74 <RCCEx_GetUARTCLKFreq+0x314>)
34018a3a:	4293      	cmp	r3, r2
34018a3c:	f200 8125 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a40:	4a4d      	ldr	r2, [pc, #308]	@ (34018b78 <RCCEx_GetUARTCLKFreq+0x318>)
34018a42:	4293      	cmp	r3, r2
34018a44:	d018      	beq.n	34018a78 <RCCEx_GetUARTCLKFreq+0x218>
34018a46:	4a4c      	ldr	r2, [pc, #304]	@ (34018b78 <RCCEx_GetUARTCLKFreq+0x318>)
34018a48:	4293      	cmp	r3, r2
34018a4a:	f200 811e 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a4e:	4a4b      	ldr	r2, [pc, #300]	@ (34018b7c <RCCEx_GetUARTCLKFreq+0x31c>)
34018a50:	4293      	cmp	r3, r2
34018a52:	d011      	beq.n	34018a78 <RCCEx_GetUARTCLKFreq+0x218>
34018a54:	4a49      	ldr	r2, [pc, #292]	@ (34018b7c <RCCEx_GetUARTCLKFreq+0x31c>)
34018a56:	4293      	cmp	r3, r2
34018a58:	f200 8117 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a5c:	4a48      	ldr	r2, [pc, #288]	@ (34018b80 <RCCEx_GetUARTCLKFreq+0x320>)
34018a5e:	4293      	cmp	r3, r2
34018a60:	d00a      	beq.n	34018a78 <RCCEx_GetUARTCLKFreq+0x218>
34018a62:	4a47      	ldr	r2, [pc, #284]	@ (34018b80 <RCCEx_GetUARTCLKFreq+0x320>)
34018a64:	4293      	cmp	r3, r2
34018a66:	f200 8110 	bhi.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
34018a6a:	4a46      	ldr	r2, [pc, #280]	@ (34018b84 <RCCEx_GetUARTCLKFreq+0x324>)
34018a6c:	4293      	cmp	r3, r2
34018a6e:	d00f      	beq.n	34018a90 <RCCEx_GetUARTCLKFreq+0x230>
34018a70:	4a45      	ldr	r2, [pc, #276]	@ (34018b88 <RCCEx_GetUARTCLKFreq+0x328>)
34018a72:	4293      	cmp	r3, r2
34018a74:	f040 8109 	bne.w	34018c8a <RCCEx_GetUARTCLKFreq+0x42a>
  {
    case LL_RCC_UART4_CLKSOURCE_PCLK1:
    case LL_RCC_UART5_CLKSOURCE_PCLK1:
    case LL_RCC_UART7_CLKSOURCE_PCLK1:
    case LL_RCC_UART8_CLKSOURCE_PCLK1:
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018a78:	f7f4 f850 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34018a7c:	4603      	mov	r3, r0
34018a7e:	4618      	mov	r0, r3
34018a80:	f7fd f944 	bl	34015d0c <RCCEx_GetHCLKFreq>
34018a84:	4603      	mov	r3, r0
34018a86:	4618      	mov	r0, r3
34018a88:	f7fd f951 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34018a8c:	60f8      	str	r0, [r7, #12]
      break;
34018a8e:	e107      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>

    case LL_RCC_UART9_CLKSOURCE_PCLK2:
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018a90:	f7f4 f844 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34018a94:	4603      	mov	r3, r0
34018a96:	4618      	mov	r0, r3
34018a98:	f7fd f938 	bl	34015d0c <RCCEx_GetHCLKFreq>
34018a9c:	4603      	mov	r3, r0
34018a9e:	4618      	mov	r0, r3
34018aa0:	f7fd f955 	bl	34015d4e <RCCEx_GetPCLK2Freq>
34018aa4:	60f8      	str	r0, [r7, #12]
      break;
34018aa6:	e0fb      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_CLKP:
    case LL_RCC_UART5_CLKSOURCE_CLKP:
    case LL_RCC_UART7_CLKSOURCE_CLKP:
    case LL_RCC_UART8_CLKSOURCE_CLKP:
    case LL_RCC_UART9_CLKSOURCE_CLKP:
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34018aa8:	2007      	movs	r0, #7
34018aaa:	f7fd fc1b 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34018aae:	60f8      	str	r0, [r7, #12]
      break;
34018ab0:	e0f6      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_IC9:
    case LL_RCC_UART5_CLKSOURCE_IC9:
    case LL_RCC_UART7_CLKSOURCE_IC9:
    case LL_RCC_UART8_CLKSOURCE_IC9:
    case LL_RCC_UART9_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
34018ab2:	f7f5 fc55 	bl	3400e360 <LL_RCC_IC9_IsEnabled>
34018ab6:	4603      	mov	r3, r0
34018ab8:	2b00      	cmp	r3, #0
34018aba:	f000 80e8 	beq.w	34018c8e <RCCEx_GetUARTCLKFreq+0x42e>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
34018abe:	f7f5 fc71 	bl	3400e3a4 <LL_RCC_IC9_GetDivider>
34018ac2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34018ac4:	f7f5 fc60 	bl	3400e388 <LL_RCC_IC9_GetSource>
34018ac8:	4603      	mov	r3, r0
34018aca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018ace:	d06f      	beq.n	34018bb0 <RCCEx_GetUARTCLKFreq+0x350>
34018ad0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018ad4:	d875      	bhi.n	34018bc2 <RCCEx_GetUARTCLKFreq+0x362>
34018ad6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018ada:	d060      	beq.n	34018b9e <RCCEx_GetUARTCLKFreq+0x33e>
34018adc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018ae0:	d86f      	bhi.n	34018bc2 <RCCEx_GetUARTCLKFreq+0x362>
34018ae2:	2b00      	cmp	r3, #0
34018ae4:	d003      	beq.n	34018aee <RCCEx_GetUARTCLKFreq+0x28e>
34018ae6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018aea:	d04f      	beq.n	34018b8c <RCCEx_GetUARTCLKFreq+0x32c>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34018aec:	e069      	b.n	34018bc2 <RCCEx_GetUARTCLKFreq+0x362>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34018aee:	f7fc fff5 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018af2:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018af4:	68fa      	ldr	r2, [r7, #12]
34018af6:	68bb      	ldr	r3, [r7, #8]
34018af8:	fbb2 f3f3 	udiv	r3, r2, r3
34018afc:	60fb      	str	r3, [r7, #12]
            break;
34018afe:	e061      	b.n	34018bc4 <RCCEx_GetUARTCLKFreq+0x364>
34018b00:	07061c30 	.word	0x07061c30
34018b04:	07061830 	.word	0x07061830
34018b08:	07061030 	.word	0x07061030
34018b0c:	07060c30 	.word	0x07060c30
34018b10:	07060034 	.word	0x07060034
34018b14:	07051c30 	.word	0x07051c30
34018b18:	07051830 	.word	0x07051830
34018b1c:	07051030 	.word	0x07051030
34018b20:	07050c30 	.word	0x07050c30
34018b24:	07050034 	.word	0x07050034
34018b28:	07041c30 	.word	0x07041c30
34018b2c:	07041830 	.word	0x07041830
34018b30:	07041030 	.word	0x07041030
34018b34:	07040c30 	.word	0x07040c30
34018b38:	07040034 	.word	0x07040034
34018b3c:	07031c30 	.word	0x07031c30
34018b40:	07031830 	.word	0x07031830
34018b44:	07031030 	.word	0x07031030
34018b48:	07030c30 	.word	0x07030c30
34018b4c:	07030034 	.word	0x07030034
34018b50:	07021c30 	.word	0x07021c30
34018b54:	07021830 	.word	0x07021830
34018b58:	07021030 	.word	0x07021030
34018b5c:	07020c30 	.word	0x07020c30
34018b60:	07020034 	.word	0x07020034
34018b64:	07011c30 	.word	0x07011c30
34018b68:	07011830 	.word	0x07011830
34018b6c:	07011030 	.word	0x07011030
34018b70:	07010c30 	.word	0x07010c30
34018b74:	07010034 	.word	0x07010034
34018b78:	07001c30 	.word	0x07001c30
34018b7c:	07001830 	.word	0x07001830
34018b80:	07001030 	.word	0x07001030
34018b84:	07000034 	.word	0x07000034
34018b88:	07000c30 	.word	0x07000c30
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34018b8c:	f7fc ffec 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34018b90:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018b92:	68fa      	ldr	r2, [r7, #12]
34018b94:	68bb      	ldr	r3, [r7, #8]
34018b96:	fbb2 f3f3 	udiv	r3, r2, r3
34018b9a:	60fb      	str	r3, [r7, #12]
            break;
34018b9c:	e012      	b.n	34018bc4 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34018b9e:	f7fd f829 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34018ba2:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018ba4:	68fa      	ldr	r2, [r7, #12]
34018ba6:	68bb      	ldr	r3, [r7, #8]
34018ba8:	fbb2 f3f3 	udiv	r3, r2, r3
34018bac:	60fb      	str	r3, [r7, #12]
            break;
34018bae:	e009      	b.n	34018bc4 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34018bb0:	f7fd f866 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34018bb4:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018bb6:	68fa      	ldr	r2, [r7, #12]
34018bb8:	68bb      	ldr	r3, [r7, #8]
34018bba:	fbb2 f3f3 	udiv	r3, r2, r3
34018bbe:	60fb      	str	r3, [r7, #12]
            break;
34018bc0:	e000      	b.n	34018bc4 <RCCEx_GetUARTCLKFreq+0x364>
            break;
34018bc2:	bf00      	nop
        }
      }
      break;
34018bc4:	e063      	b.n	34018c8e <RCCEx_GetUARTCLKFreq+0x42e>
    case LL_RCC_UART4_CLKSOURCE_IC14:
    case LL_RCC_UART5_CLKSOURCE_IC14:
    case LL_RCC_UART7_CLKSOURCE_IC14:
    case LL_RCC_UART8_CLKSOURCE_IC14:
    case LL_RCC_UART9_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
34018bc6:	f7f5 fccb 	bl	3400e560 <LL_RCC_IC14_IsEnabled>
34018bca:	4603      	mov	r3, r0
34018bcc:	2b00      	cmp	r3, #0
34018bce:	d060      	beq.n	34018c92 <RCCEx_GetUARTCLKFreq+0x432>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34018bd0:	f7f5 fce8 	bl	3400e5a4 <LL_RCC_IC14_GetDivider>
34018bd4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34018bd6:	f7f5 fcd7 	bl	3400e588 <LL_RCC_IC14_GetSource>
34018bda:	4603      	mov	r3, r0
34018bdc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018be0:	d029      	beq.n	34018c36 <RCCEx_GetUARTCLKFreq+0x3d6>
34018be2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018be6:	d82f      	bhi.n	34018c48 <RCCEx_GetUARTCLKFreq+0x3e8>
34018be8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018bec:	d01a      	beq.n	34018c24 <RCCEx_GetUARTCLKFreq+0x3c4>
34018bee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018bf2:	d829      	bhi.n	34018c48 <RCCEx_GetUARTCLKFreq+0x3e8>
34018bf4:	2b00      	cmp	r3, #0
34018bf6:	d003      	beq.n	34018c00 <RCCEx_GetUARTCLKFreq+0x3a0>
34018bf8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018bfc:	d009      	beq.n	34018c12 <RCCEx_GetUARTCLKFreq+0x3b2>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34018bfe:	e023      	b.n	34018c48 <RCCEx_GetUARTCLKFreq+0x3e8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34018c00:	f7fc ff6c 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018c04:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018c06:	68fa      	ldr	r2, [r7, #12]
34018c08:	68bb      	ldr	r3, [r7, #8]
34018c0a:	fbb2 f3f3 	udiv	r3, r2, r3
34018c0e:	60fb      	str	r3, [r7, #12]
            break;
34018c10:	e01b      	b.n	34018c4a <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34018c12:	f7fc ffa9 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34018c16:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018c18:	68fa      	ldr	r2, [r7, #12]
34018c1a:	68bb      	ldr	r3, [r7, #8]
34018c1c:	fbb2 f3f3 	udiv	r3, r2, r3
34018c20:	60fb      	str	r3, [r7, #12]
            break;
34018c22:	e012      	b.n	34018c4a <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34018c24:	f7fc ffe6 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34018c28:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018c2a:	68fa      	ldr	r2, [r7, #12]
34018c2c:	68bb      	ldr	r3, [r7, #8]
34018c2e:	fbb2 f3f3 	udiv	r3, r2, r3
34018c32:	60fb      	str	r3, [r7, #12]
            break;
34018c34:	e009      	b.n	34018c4a <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34018c36:	f7fd f823 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34018c3a:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34018c3c:	68fa      	ldr	r2, [r7, #12]
34018c3e:	68bb      	ldr	r3, [r7, #8]
34018c40:	fbb2 f3f3 	udiv	r3, r2, r3
34018c44:	60fb      	str	r3, [r7, #12]
            break;
34018c46:	e000      	b.n	34018c4a <RCCEx_GetUARTCLKFreq+0x3ea>
            break;
34018c48:	bf00      	nop
        }
      }
      break;
34018c4a:	e022      	b.n	34018c92 <RCCEx_GetUARTCLKFreq+0x432>
    case LL_RCC_UART4_CLKSOURCE_HSI:
    case LL_RCC_UART5_CLKSOURCE_HSI:
    case LL_RCC_UART7_CLKSOURCE_HSI:
    case LL_RCC_UART8_CLKSOURCE_HSI:
    case LL_RCC_UART9_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34018c4c:	f7f4 fb64 	bl	3400d318 <LL_RCC_HSI_IsReady>
34018c50:	4603      	mov	r3, r0
34018c52:	2b00      	cmp	r3, #0
34018c54:	d01f      	beq.n	34018c96 <RCCEx_GetUARTCLKFreq+0x436>
      {
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34018c56:	f7f4 fb71 	bl	3400d33c <LL_RCC_HSI_GetDivider>
34018c5a:	4603      	mov	r3, r0
34018c5c:	09db      	lsrs	r3, r3, #7
34018c5e:	4a13      	ldr	r2, [pc, #76]	@ (34018cac <RCCEx_GetUARTCLKFreq+0x44c>)
34018c60:	fa22 f303 	lsr.w	r3, r2, r3
34018c64:	60fb      	str	r3, [r7, #12]
      }
      break;
34018c66:	e016      	b.n	34018c96 <RCCEx_GetUARTCLKFreq+0x436>
    case LL_RCC_UART4_CLKSOURCE_MSI:
    case LL_RCC_UART5_CLKSOURCE_MSI:
    case LL_RCC_UART7_CLKSOURCE_MSI:
    case LL_RCC_UART8_CLKSOURCE_MSI:
    case LL_RCC_UART9_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34018c68:	f7f4 fb76 	bl	3400d358 <LL_RCC_MSI_IsReady>
34018c6c:	4603      	mov	r3, r0
34018c6e:	2b00      	cmp	r3, #0
34018c70:	d013      	beq.n	34018c9a <RCCEx_GetUARTCLKFreq+0x43a>
      {
        uart_frequency = MSI_VALUE;
34018c72:	4b0f      	ldr	r3, [pc, #60]	@ (34018cb0 <RCCEx_GetUARTCLKFreq+0x450>)
34018c74:	60fb      	str	r3, [r7, #12]
      }
      break;
34018c76:	e010      	b.n	34018c9a <RCCEx_GetUARTCLKFreq+0x43a>
    case LL_RCC_UART4_CLKSOURCE_LSE:
    case LL_RCC_UART5_CLKSOURCE_LSE:
    case LL_RCC_UART7_CLKSOURCE_LSE:
    case LL_RCC_UART8_CLKSOURCE_LSE:
    case LL_RCC_UART9_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
34018c78:	f7f4 fb8e 	bl	3400d398 <LL_RCC_LSE_IsReady>
34018c7c:	4603      	mov	r3, r0
34018c7e:	2b00      	cmp	r3, #0
34018c80:	d00d      	beq.n	34018c9e <RCCEx_GetUARTCLKFreq+0x43e>
      {
        uart_frequency = LSE_VALUE;
34018c82:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34018c86:	60fb      	str	r3, [r7, #12]
      }
      break;
34018c88:	e009      	b.n	34018c9e <RCCEx_GetUARTCLKFreq+0x43e>

    default:
      /* Unexpected case */
      break;
34018c8a:	bf00      	nop
34018c8c:	e008      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34018c8e:	bf00      	nop
34018c90:	e006      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34018c92:	bf00      	nop
34018c94:	e004      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34018c96:	bf00      	nop
34018c98:	e002      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34018c9a:	bf00      	nop
34018c9c:	e000      	b.n	34018ca0 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34018c9e:	bf00      	nop
  }

  return uart_frequency;
34018ca0:	68fb      	ldr	r3, [r7, #12]
}
34018ca2:	4618      	mov	r0, r3
34018ca4:	3710      	adds	r7, #16
34018ca6:	46bd      	mov	sp, r7
34018ca8:	bd80      	pop	{r7, pc}
34018caa:	bf00      	nop
34018cac:	03d09000 	.word	0x03d09000
34018cb0:	003d0900 	.word	0x003d0900

34018cb4 <RCCEx_GetUSARTCLKFreq>:
  *         @arg @ref RCCEx_USART10_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUSARTCLKFreq(uint32_t USARTxSource)
{
34018cb4:	b580      	push	{r7, lr}
34018cb6:	b084      	sub	sp, #16
34018cb8:	af00      	add	r7, sp, #0
34018cba:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
34018cbc:	2300      	movs	r3, #0
34018cbe:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34018cc0:	6878      	ldr	r0, [r7, #4]
34018cc2:	f7f4 ff11 	bl	3400dae8 <LL_RCC_GetUSARTClockSource>
34018cc6:	4603      	mov	r3, r0
34018cc8:	4aa2      	ldr	r2, [pc, #648]	@ (34018f54 <RCCEx_GetUSARTCLKFreq+0x2a0>)
34018cca:	4293      	cmp	r3, r2
34018ccc:	f000 81e8 	beq.w	340190a0 <RCCEx_GetUSARTCLKFreq+0x3ec>
34018cd0:	4aa0      	ldr	r2, [pc, #640]	@ (34018f54 <RCCEx_GetUSARTCLKFreq+0x2a0>)
34018cd2:	4293      	cmp	r3, r2
34018cd4:	f200 8203 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018cd8:	4a9f      	ldr	r2, [pc, #636]	@ (34018f58 <RCCEx_GetUSARTCLKFreq+0x2a4>)
34018cda:	4293      	cmp	r3, r2
34018cdc:	f000 81e0 	beq.w	340190a0 <RCCEx_GetUSARTCLKFreq+0x3ec>
34018ce0:	4a9d      	ldr	r2, [pc, #628]	@ (34018f58 <RCCEx_GetUSARTCLKFreq+0x2a4>)
34018ce2:	4293      	cmp	r3, r2
34018ce4:	f200 81fb 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018ce8:	4a9c      	ldr	r2, [pc, #624]	@ (34018f5c <RCCEx_GetUSARTCLKFreq+0x2a8>)
34018cea:	4293      	cmp	r3, r2
34018cec:	f000 81d8 	beq.w	340190a0 <RCCEx_GetUSARTCLKFreq+0x3ec>
34018cf0:	4a9a      	ldr	r2, [pc, #616]	@ (34018f5c <RCCEx_GetUSARTCLKFreq+0x2a8>)
34018cf2:	4293      	cmp	r3, r2
34018cf4:	f200 81f3 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018cf8:	4a99      	ldr	r2, [pc, #612]	@ (34018f60 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34018cfa:	4293      	cmp	r3, r2
34018cfc:	f000 81d0 	beq.w	340190a0 <RCCEx_GetUSARTCLKFreq+0x3ec>
34018d00:	4a97      	ldr	r2, [pc, #604]	@ (34018f60 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34018d02:	4293      	cmp	r3, r2
34018d04:	f200 81eb 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d08:	4a96      	ldr	r2, [pc, #600]	@ (34018f64 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34018d0a:	4293      	cmp	r3, r2
34018d0c:	f000 81c8 	beq.w	340190a0 <RCCEx_GetUSARTCLKFreq+0x3ec>
34018d10:	4a94      	ldr	r2, [pc, #592]	@ (34018f64 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34018d12:	4293      	cmp	r3, r2
34018d14:	f200 81e3 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d18:	4a93      	ldr	r2, [pc, #588]	@ (34018f68 <RCCEx_GetUSARTCLKFreq+0x2b4>)
34018d1a:	4293      	cmp	r3, r2
34018d1c:	f000 81ce 	beq.w	340190bc <RCCEx_GetUSARTCLKFreq+0x408>
34018d20:	4a91      	ldr	r2, [pc, #580]	@ (34018f68 <RCCEx_GetUSARTCLKFreq+0x2b4>)
34018d22:	4293      	cmp	r3, r2
34018d24:	f200 81db 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d28:	4a90      	ldr	r2, [pc, #576]	@ (34018f6c <RCCEx_GetUSARTCLKFreq+0x2b8>)
34018d2a:	4293      	cmp	r3, r2
34018d2c:	f000 81c6 	beq.w	340190bc <RCCEx_GetUSARTCLKFreq+0x408>
34018d30:	4a8e      	ldr	r2, [pc, #568]	@ (34018f6c <RCCEx_GetUSARTCLKFreq+0x2b8>)
34018d32:	4293      	cmp	r3, r2
34018d34:	f200 81d3 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d38:	4a8d      	ldr	r2, [pc, #564]	@ (34018f70 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34018d3a:	4293      	cmp	r3, r2
34018d3c:	f000 81be 	beq.w	340190bc <RCCEx_GetUSARTCLKFreq+0x408>
34018d40:	4a8b      	ldr	r2, [pc, #556]	@ (34018f70 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34018d42:	4293      	cmp	r3, r2
34018d44:	f200 81cb 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d48:	4a8a      	ldr	r2, [pc, #552]	@ (34018f74 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34018d4a:	4293      	cmp	r3, r2
34018d4c:	f000 81b6 	beq.w	340190bc <RCCEx_GetUSARTCLKFreq+0x408>
34018d50:	4a88      	ldr	r2, [pc, #544]	@ (34018f74 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34018d52:	4293      	cmp	r3, r2
34018d54:	f200 81c3 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d58:	4a87      	ldr	r2, [pc, #540]	@ (34018f78 <RCCEx_GetUSARTCLKFreq+0x2c4>)
34018d5a:	4293      	cmp	r3, r2
34018d5c:	f000 81ae 	beq.w	340190bc <RCCEx_GetUSARTCLKFreq+0x408>
34018d60:	4a85      	ldr	r2, [pc, #532]	@ (34018f78 <RCCEx_GetUSARTCLKFreq+0x2c4>)
34018d62:	4293      	cmp	r3, r2
34018d64:	f200 81bb 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d68:	4a84      	ldr	r2, [pc, #528]	@ (34018f7c <RCCEx_GetUSARTCLKFreq+0x2c8>)
34018d6a:	4293      	cmp	r3, r2
34018d6c:	f000 81ae 	beq.w	340190cc <RCCEx_GetUSARTCLKFreq+0x418>
34018d70:	4a82      	ldr	r2, [pc, #520]	@ (34018f7c <RCCEx_GetUSARTCLKFreq+0x2c8>)
34018d72:	4293      	cmp	r3, r2
34018d74:	f200 81b3 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d78:	4a81      	ldr	r2, [pc, #516]	@ (34018f80 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34018d7a:	4293      	cmp	r3, r2
34018d7c:	f000 81a6 	beq.w	340190cc <RCCEx_GetUSARTCLKFreq+0x418>
34018d80:	4a7f      	ldr	r2, [pc, #508]	@ (34018f80 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34018d82:	4293      	cmp	r3, r2
34018d84:	f200 81ab 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d88:	4a7e      	ldr	r2, [pc, #504]	@ (34018f84 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34018d8a:	4293      	cmp	r3, r2
34018d8c:	f000 819e 	beq.w	340190cc <RCCEx_GetUSARTCLKFreq+0x418>
34018d90:	4a7c      	ldr	r2, [pc, #496]	@ (34018f84 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34018d92:	4293      	cmp	r3, r2
34018d94:	f200 81a3 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018d98:	4a7b      	ldr	r2, [pc, #492]	@ (34018f88 <RCCEx_GetUSARTCLKFreq+0x2d4>)
34018d9a:	4293      	cmp	r3, r2
34018d9c:	f000 8196 	beq.w	340190cc <RCCEx_GetUSARTCLKFreq+0x418>
34018da0:	4a79      	ldr	r2, [pc, #484]	@ (34018f88 <RCCEx_GetUSARTCLKFreq+0x2d4>)
34018da2:	4293      	cmp	r3, r2
34018da4:	f200 819b 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018da8:	4a78      	ldr	r2, [pc, #480]	@ (34018f8c <RCCEx_GetUSARTCLKFreq+0x2d8>)
34018daa:	4293      	cmp	r3, r2
34018dac:	f000 818e 	beq.w	340190cc <RCCEx_GetUSARTCLKFreq+0x418>
34018db0:	4a76      	ldr	r2, [pc, #472]	@ (34018f8c <RCCEx_GetUSARTCLKFreq+0x2d8>)
34018db2:	4293      	cmp	r3, r2
34018db4:	f200 8193 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018db8:	4a75      	ldr	r2, [pc, #468]	@ (34018f90 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34018dba:	4293      	cmp	r3, r2
34018dbc:	f000 812d 	beq.w	3401901a <RCCEx_GetUSARTCLKFreq+0x366>
34018dc0:	4a73      	ldr	r2, [pc, #460]	@ (34018f90 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34018dc2:	4293      	cmp	r3, r2
34018dc4:	f200 818b 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018dc8:	4a72      	ldr	r2, [pc, #456]	@ (34018f94 <RCCEx_GetUSARTCLKFreq+0x2e0>)
34018dca:	4293      	cmp	r3, r2
34018dcc:	f000 8125 	beq.w	3401901a <RCCEx_GetUSARTCLKFreq+0x366>
34018dd0:	4a70      	ldr	r2, [pc, #448]	@ (34018f94 <RCCEx_GetUSARTCLKFreq+0x2e0>)
34018dd2:	4293      	cmp	r3, r2
34018dd4:	f200 8183 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018dd8:	4a6f      	ldr	r2, [pc, #444]	@ (34018f98 <RCCEx_GetUSARTCLKFreq+0x2e4>)
34018dda:	4293      	cmp	r3, r2
34018ddc:	f000 811d 	beq.w	3401901a <RCCEx_GetUSARTCLKFreq+0x366>
34018de0:	4a6d      	ldr	r2, [pc, #436]	@ (34018f98 <RCCEx_GetUSARTCLKFreq+0x2e4>)
34018de2:	4293      	cmp	r3, r2
34018de4:	f200 817b 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018de8:	4a6c      	ldr	r2, [pc, #432]	@ (34018f9c <RCCEx_GetUSARTCLKFreq+0x2e8>)
34018dea:	4293      	cmp	r3, r2
34018dec:	f000 8115 	beq.w	3401901a <RCCEx_GetUSARTCLKFreq+0x366>
34018df0:	4a6a      	ldr	r2, [pc, #424]	@ (34018f9c <RCCEx_GetUSARTCLKFreq+0x2e8>)
34018df2:	4293      	cmp	r3, r2
34018df4:	f200 8173 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018df8:	4a69      	ldr	r2, [pc, #420]	@ (34018fa0 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34018dfa:	4293      	cmp	r3, r2
34018dfc:	f000 810d 	beq.w	3401901a <RCCEx_GetUSARTCLKFreq+0x366>
34018e00:	4a67      	ldr	r2, [pc, #412]	@ (34018fa0 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34018e02:	4293      	cmp	r3, r2
34018e04:	f200 816b 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e08:	4a66      	ldr	r2, [pc, #408]	@ (34018fa4 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34018e0a:	4293      	cmp	r3, r2
34018e0c:	d07b      	beq.n	34018f06 <RCCEx_GetUSARTCLKFreq+0x252>
34018e0e:	4a65      	ldr	r2, [pc, #404]	@ (34018fa4 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34018e10:	4293      	cmp	r3, r2
34018e12:	f200 8164 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e16:	4a64      	ldr	r2, [pc, #400]	@ (34018fa8 <RCCEx_GetUSARTCLKFreq+0x2f4>)
34018e18:	4293      	cmp	r3, r2
34018e1a:	d074      	beq.n	34018f06 <RCCEx_GetUSARTCLKFreq+0x252>
34018e1c:	4a62      	ldr	r2, [pc, #392]	@ (34018fa8 <RCCEx_GetUSARTCLKFreq+0x2f4>)
34018e1e:	4293      	cmp	r3, r2
34018e20:	f200 815d 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e24:	4a61      	ldr	r2, [pc, #388]	@ (34018fac <RCCEx_GetUSARTCLKFreq+0x2f8>)
34018e26:	4293      	cmp	r3, r2
34018e28:	d06d      	beq.n	34018f06 <RCCEx_GetUSARTCLKFreq+0x252>
34018e2a:	4a60      	ldr	r2, [pc, #384]	@ (34018fac <RCCEx_GetUSARTCLKFreq+0x2f8>)
34018e2c:	4293      	cmp	r3, r2
34018e2e:	f200 8156 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e32:	4a5f      	ldr	r2, [pc, #380]	@ (34018fb0 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34018e34:	4293      	cmp	r3, r2
34018e36:	d066      	beq.n	34018f06 <RCCEx_GetUSARTCLKFreq+0x252>
34018e38:	4a5d      	ldr	r2, [pc, #372]	@ (34018fb0 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34018e3a:	4293      	cmp	r3, r2
34018e3c:	f200 814f 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e40:	4a5c      	ldr	r2, [pc, #368]	@ (34018fb4 <RCCEx_GetUSARTCLKFreq+0x300>)
34018e42:	4293      	cmp	r3, r2
34018e44:	d05f      	beq.n	34018f06 <RCCEx_GetUSARTCLKFreq+0x252>
34018e46:	4a5b      	ldr	r2, [pc, #364]	@ (34018fb4 <RCCEx_GetUSARTCLKFreq+0x300>)
34018e48:	4293      	cmp	r3, r2
34018e4a:	f200 8148 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e4e:	4a5a      	ldr	r2, [pc, #360]	@ (34018fb8 <RCCEx_GetUSARTCLKFreq+0x304>)
34018e50:	4293      	cmp	r3, r2
34018e52:	d053      	beq.n	34018efc <RCCEx_GetUSARTCLKFreq+0x248>
34018e54:	4a58      	ldr	r2, [pc, #352]	@ (34018fb8 <RCCEx_GetUSARTCLKFreq+0x304>)
34018e56:	4293      	cmp	r3, r2
34018e58:	f200 8141 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e5c:	4a57      	ldr	r2, [pc, #348]	@ (34018fbc <RCCEx_GetUSARTCLKFreq+0x308>)
34018e5e:	4293      	cmp	r3, r2
34018e60:	d04c      	beq.n	34018efc <RCCEx_GetUSARTCLKFreq+0x248>
34018e62:	4a56      	ldr	r2, [pc, #344]	@ (34018fbc <RCCEx_GetUSARTCLKFreq+0x308>)
34018e64:	4293      	cmp	r3, r2
34018e66:	f200 813a 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e6a:	4a55      	ldr	r2, [pc, #340]	@ (34018fc0 <RCCEx_GetUSARTCLKFreq+0x30c>)
34018e6c:	4293      	cmp	r3, r2
34018e6e:	d045      	beq.n	34018efc <RCCEx_GetUSARTCLKFreq+0x248>
34018e70:	4a53      	ldr	r2, [pc, #332]	@ (34018fc0 <RCCEx_GetUSARTCLKFreq+0x30c>)
34018e72:	4293      	cmp	r3, r2
34018e74:	f200 8133 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e78:	4a52      	ldr	r2, [pc, #328]	@ (34018fc4 <RCCEx_GetUSARTCLKFreq+0x310>)
34018e7a:	4293      	cmp	r3, r2
34018e7c:	d03e      	beq.n	34018efc <RCCEx_GetUSARTCLKFreq+0x248>
34018e7e:	4a51      	ldr	r2, [pc, #324]	@ (34018fc4 <RCCEx_GetUSARTCLKFreq+0x310>)
34018e80:	4293      	cmp	r3, r2
34018e82:	f200 812c 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e86:	4a50      	ldr	r2, [pc, #320]	@ (34018fc8 <RCCEx_GetUSARTCLKFreq+0x314>)
34018e88:	4293      	cmp	r3, r2
34018e8a:	d037      	beq.n	34018efc <RCCEx_GetUSARTCLKFreq+0x248>
34018e8c:	4a4e      	ldr	r2, [pc, #312]	@ (34018fc8 <RCCEx_GetUSARTCLKFreq+0x314>)
34018e8e:	4293      	cmp	r3, r2
34018e90:	f200 8125 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018e94:	4a4d      	ldr	r2, [pc, #308]	@ (34018fcc <RCCEx_GetUSARTCLKFreq+0x318>)
34018e96:	4293      	cmp	r3, r2
34018e98:	d018      	beq.n	34018ecc <RCCEx_GetUSARTCLKFreq+0x218>
34018e9a:	4a4c      	ldr	r2, [pc, #304]	@ (34018fcc <RCCEx_GetUSARTCLKFreq+0x318>)
34018e9c:	4293      	cmp	r3, r2
34018e9e:	f200 811e 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018ea2:	4a4b      	ldr	r2, [pc, #300]	@ (34018fd0 <RCCEx_GetUSARTCLKFreq+0x31c>)
34018ea4:	4293      	cmp	r3, r2
34018ea6:	d01d      	beq.n	34018ee4 <RCCEx_GetUSARTCLKFreq+0x230>
34018ea8:	4a49      	ldr	r2, [pc, #292]	@ (34018fd0 <RCCEx_GetUSARTCLKFreq+0x31c>)
34018eaa:	4293      	cmp	r3, r2
34018eac:	f200 8117 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018eb0:	4a48      	ldr	r2, [pc, #288]	@ (34018fd4 <RCCEx_GetUSARTCLKFreq+0x320>)
34018eb2:	4293      	cmp	r3, r2
34018eb4:	d00a      	beq.n	34018ecc <RCCEx_GetUSARTCLKFreq+0x218>
34018eb6:	4a47      	ldr	r2, [pc, #284]	@ (34018fd4 <RCCEx_GetUSARTCLKFreq+0x320>)
34018eb8:	4293      	cmp	r3, r2
34018eba:	f200 8110 	bhi.w	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
34018ebe:	4a46      	ldr	r2, [pc, #280]	@ (34018fd8 <RCCEx_GetUSARTCLKFreq+0x324>)
34018ec0:	4293      	cmp	r3, r2
34018ec2:	d003      	beq.n	34018ecc <RCCEx_GetUSARTCLKFreq+0x218>
34018ec4:	4a45      	ldr	r2, [pc, #276]	@ (34018fdc <RCCEx_GetUSARTCLKFreq+0x328>)
34018ec6:	4293      	cmp	r3, r2
34018ec8:	d00c      	beq.n	34018ee4 <RCCEx_GetUSARTCLKFreq+0x230>
      }
      break;

    default:
      /* Unexpected case */
      break;
34018eca:	e108      	b.n	340190de <RCCEx_GetUSARTCLKFreq+0x42a>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018ecc:	f7f3 fe26 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34018ed0:	4603      	mov	r3, r0
34018ed2:	4618      	mov	r0, r3
34018ed4:	f7fc ff1a 	bl	34015d0c <RCCEx_GetHCLKFreq>
34018ed8:	4603      	mov	r3, r0
34018eda:	4618      	mov	r0, r3
34018edc:	f7fc ff37 	bl	34015d4e <RCCEx_GetPCLK2Freq>
34018ee0:	60f8      	str	r0, [r7, #12]
      break;
34018ee2:	e107      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34018ee4:	f7f3 fe1a 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
34018ee8:	4603      	mov	r3, r0
34018eea:	4618      	mov	r0, r3
34018eec:	f7fc ff0e 	bl	34015d0c <RCCEx_GetHCLKFreq>
34018ef0:	4603      	mov	r3, r0
34018ef2:	4618      	mov	r0, r3
34018ef4:	f7fc ff1b 	bl	34015d2e <RCCEx_GetPCLK1Freq>
34018ef8:	60f8      	str	r0, [r7, #12]
      break;
34018efa:	e0fb      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34018efc:	2007      	movs	r0, #7
34018efe:	f7fd f9f1 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
34018f02:	60f8      	str	r0, [r7, #12]
      break;
34018f04:	e0f6      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34018f06:	f7f5 fa2b 	bl	3400e360 <LL_RCC_IC9_IsEnabled>
34018f0a:	4603      	mov	r3, r0
34018f0c:	2b00      	cmp	r3, #0
34018f0e:	f000 80e8 	beq.w	340190e2 <RCCEx_GetUSARTCLKFreq+0x42e>
        ic_divider = LL_RCC_IC9_GetDivider();
34018f12:	f7f5 fa47 	bl	3400e3a4 <LL_RCC_IC9_GetDivider>
34018f16:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34018f18:	f7f5 fa36 	bl	3400e388 <LL_RCC_IC9_GetSource>
34018f1c:	4603      	mov	r3, r0
34018f1e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018f22:	d06f      	beq.n	34019004 <RCCEx_GetUSARTCLKFreq+0x350>
34018f24:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34018f28:	d875      	bhi.n	34019016 <RCCEx_GetUSARTCLKFreq+0x362>
34018f2a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018f2e:	d060      	beq.n	34018ff2 <RCCEx_GetUSARTCLKFreq+0x33e>
34018f30:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34018f34:	d86f      	bhi.n	34019016 <RCCEx_GetUSARTCLKFreq+0x362>
34018f36:	2b00      	cmp	r3, #0
34018f38:	d003      	beq.n	34018f42 <RCCEx_GetUSARTCLKFreq+0x28e>
34018f3a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018f3e:	d04f      	beq.n	34018fe0 <RCCEx_GetUSARTCLKFreq+0x32c>
            break;
34018f40:	e069      	b.n	34019016 <RCCEx_GetUSARTCLKFreq+0x362>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34018f42:	f7fc fdcb 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34018f46:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34018f48:	68fa      	ldr	r2, [r7, #12]
34018f4a:	68bb      	ldr	r3, [r7, #8]
34018f4c:	fbb2 f3f3 	udiv	r3, r2, r3
34018f50:	60fb      	str	r3, [r7, #12]
            break;
34018f52:	e061      	b.n	34019018 <RCCEx_GetUSARTCLKFreq+0x364>
34018f54:	07061430 	.word	0x07061430
34018f58:	07060830 	.word	0x07060830
34018f5c:	07060434 	.word	0x07060434
34018f60:	07060430 	.word	0x07060430
34018f64:	07060030 	.word	0x07060030
34018f68:	07051430 	.word	0x07051430
34018f6c:	07050830 	.word	0x07050830
34018f70:	07050434 	.word	0x07050434
34018f74:	07050430 	.word	0x07050430
34018f78:	07050030 	.word	0x07050030
34018f7c:	07041430 	.word	0x07041430
34018f80:	07040830 	.word	0x07040830
34018f84:	07040434 	.word	0x07040434
34018f88:	07040430 	.word	0x07040430
34018f8c:	07040030 	.word	0x07040030
34018f90:	07031430 	.word	0x07031430
34018f94:	07030830 	.word	0x07030830
34018f98:	07030434 	.word	0x07030434
34018f9c:	07030430 	.word	0x07030430
34018fa0:	07030030 	.word	0x07030030
34018fa4:	07021430 	.word	0x07021430
34018fa8:	07020830 	.word	0x07020830
34018fac:	07020434 	.word	0x07020434
34018fb0:	07020430 	.word	0x07020430
34018fb4:	07020030 	.word	0x07020030
34018fb8:	07011430 	.word	0x07011430
34018fbc:	07010830 	.word	0x07010830
34018fc0:	07010434 	.word	0x07010434
34018fc4:	07010430 	.word	0x07010430
34018fc8:	07010030 	.word	0x07010030
34018fcc:	07001430 	.word	0x07001430
34018fd0:	07000830 	.word	0x07000830
34018fd4:	07000434 	.word	0x07000434
34018fd8:	07000030 	.word	0x07000030
34018fdc:	07000430 	.word	0x07000430
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34018fe0:	f7fc fdc2 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34018fe4:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34018fe6:	68fa      	ldr	r2, [r7, #12]
34018fe8:	68bb      	ldr	r3, [r7, #8]
34018fea:	fbb2 f3f3 	udiv	r3, r2, r3
34018fee:	60fb      	str	r3, [r7, #12]
            break;
34018ff0:	e012      	b.n	34019018 <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34018ff2:	f7fc fdff 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34018ff6:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34018ff8:	68fa      	ldr	r2, [r7, #12]
34018ffa:	68bb      	ldr	r3, [r7, #8]
34018ffc:	fbb2 f3f3 	udiv	r3, r2, r3
34019000:	60fb      	str	r3, [r7, #12]
            break;
34019002:	e009      	b.n	34019018 <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34019004:	f7fc fe3c 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34019008:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3401900a:	68fa      	ldr	r2, [r7, #12]
3401900c:	68bb      	ldr	r3, [r7, #8]
3401900e:	fbb2 f3f3 	udiv	r3, r2, r3
34019012:	60fb      	str	r3, [r7, #12]
            break;
34019014:	e000      	b.n	34019018 <RCCEx_GetUSARTCLKFreq+0x364>
            break;
34019016:	bf00      	nop
      break;
34019018:	e063      	b.n	340190e2 <RCCEx_GetUSARTCLKFreq+0x42e>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3401901a:	f7f5 faa1 	bl	3400e560 <LL_RCC_IC14_IsEnabled>
3401901e:	4603      	mov	r3, r0
34019020:	2b00      	cmp	r3, #0
34019022:	d060      	beq.n	340190e6 <RCCEx_GetUSARTCLKFreq+0x432>
        ic_divider = LL_RCC_IC14_GetDivider();
34019024:	f7f5 fabe 	bl	3400e5a4 <LL_RCC_IC14_GetDivider>
34019028:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3401902a:	f7f5 faad 	bl	3400e588 <LL_RCC_IC14_GetSource>
3401902e:	4603      	mov	r3, r0
34019030:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34019034:	d029      	beq.n	3401908a <RCCEx_GetUSARTCLKFreq+0x3d6>
34019036:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401903a:	d82f      	bhi.n	3401909c <RCCEx_GetUSARTCLKFreq+0x3e8>
3401903c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34019040:	d01a      	beq.n	34019078 <RCCEx_GetUSARTCLKFreq+0x3c4>
34019042:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34019046:	d829      	bhi.n	3401909c <RCCEx_GetUSARTCLKFreq+0x3e8>
34019048:	2b00      	cmp	r3, #0
3401904a:	d003      	beq.n	34019054 <RCCEx_GetUSARTCLKFreq+0x3a0>
3401904c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34019050:	d009      	beq.n	34019066 <RCCEx_GetUSARTCLKFreq+0x3b2>
            break;
34019052:	e023      	b.n	3401909c <RCCEx_GetUSARTCLKFreq+0x3e8>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34019054:	f7fc fd42 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34019058:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3401905a:	68fa      	ldr	r2, [r7, #12]
3401905c:	68bb      	ldr	r3, [r7, #8]
3401905e:	fbb2 f3f3 	udiv	r3, r2, r3
34019062:	60fb      	str	r3, [r7, #12]
            break;
34019064:	e01b      	b.n	3401909e <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34019066:	f7fc fd7f 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
3401906a:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3401906c:	68fa      	ldr	r2, [r7, #12]
3401906e:	68bb      	ldr	r3, [r7, #8]
34019070:	fbb2 f3f3 	udiv	r3, r2, r3
34019074:	60fb      	str	r3, [r7, #12]
            break;
34019076:	e012      	b.n	3401909e <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34019078:	f7fc fdbc 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
3401907c:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3401907e:	68fa      	ldr	r2, [r7, #12]
34019080:	68bb      	ldr	r3, [r7, #8]
34019082:	fbb2 f3f3 	udiv	r3, r2, r3
34019086:	60fb      	str	r3, [r7, #12]
            break;
34019088:	e009      	b.n	3401909e <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401908a:	f7fc fdf9 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
3401908e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34019090:	68fa      	ldr	r2, [r7, #12]
34019092:	68bb      	ldr	r3, [r7, #8]
34019094:	fbb2 f3f3 	udiv	r3, r2, r3
34019098:	60fb      	str	r3, [r7, #12]
            break;
3401909a:	e000      	b.n	3401909e <RCCEx_GetUSARTCLKFreq+0x3ea>
            break;
3401909c:	bf00      	nop
      break;
3401909e:	e022      	b.n	340190e6 <RCCEx_GetUSARTCLKFreq+0x432>
      if (LL_RCC_HSI_IsReady() != 0U)
340190a0:	f7f4 f93a 	bl	3400d318 <LL_RCC_HSI_IsReady>
340190a4:	4603      	mov	r3, r0
340190a6:	2b00      	cmp	r3, #0
340190a8:	d01f      	beq.n	340190ea <RCCEx_GetUSARTCLKFreq+0x436>
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340190aa:	f7f4 f947 	bl	3400d33c <LL_RCC_HSI_GetDivider>
340190ae:	4603      	mov	r3, r0
340190b0:	09db      	lsrs	r3, r3, #7
340190b2:	4a13      	ldr	r2, [pc, #76]	@ (34019100 <RCCEx_GetUSARTCLKFreq+0x44c>)
340190b4:	fa22 f303 	lsr.w	r3, r2, r3
340190b8:	60fb      	str	r3, [r7, #12]
      break;
340190ba:	e016      	b.n	340190ea <RCCEx_GetUSARTCLKFreq+0x436>
      if (LL_RCC_MSI_IsReady() != 0U)
340190bc:	f7f4 f94c 	bl	3400d358 <LL_RCC_MSI_IsReady>
340190c0:	4603      	mov	r3, r0
340190c2:	2b00      	cmp	r3, #0
340190c4:	d013      	beq.n	340190ee <RCCEx_GetUSARTCLKFreq+0x43a>
        usart_frequency = MSI_VALUE;
340190c6:	4b0f      	ldr	r3, [pc, #60]	@ (34019104 <RCCEx_GetUSARTCLKFreq+0x450>)
340190c8:	60fb      	str	r3, [r7, #12]
      break;
340190ca:	e010      	b.n	340190ee <RCCEx_GetUSARTCLKFreq+0x43a>
      if (LL_RCC_LSE_IsReady() != 0U)
340190cc:	f7f4 f964 	bl	3400d398 <LL_RCC_LSE_IsReady>
340190d0:	4603      	mov	r3, r0
340190d2:	2b00      	cmp	r3, #0
340190d4:	d00d      	beq.n	340190f2 <RCCEx_GetUSARTCLKFreq+0x43e>
        usart_frequency = LSE_VALUE;
340190d6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
340190da:	60fb      	str	r3, [r7, #12]
      break;
340190dc:	e009      	b.n	340190f2 <RCCEx_GetUSARTCLKFreq+0x43e>
      break;
340190de:	bf00      	nop
340190e0:	e008      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
340190e2:	bf00      	nop
340190e4:	e006      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
340190e6:	bf00      	nop
340190e8:	e004      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
340190ea:	bf00      	nop
340190ec:	e002      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
340190ee:	bf00      	nop
340190f0:	e000      	b.n	340190f4 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
340190f2:	bf00      	nop
  }

  return usart_frequency;
340190f4:	68fb      	ldr	r3, [r7, #12]
}
340190f6:	4618      	mov	r0, r3
340190f8:	3710      	adds	r7, #16
340190fa:	46bd      	mov	sp, r7
340190fc:	bd80      	pop	{r7, pc}
340190fe:	bf00      	nop
34019100:	03d09000 	.word	0x03d09000
34019104:	003d0900 	.word	0x003d0900

34019108 <RCCEx_GetOTGPHYCLKFreq>:
  *         @arg @ref RCCEx_USB_OTGHS2_Clock_Source
  * @retval OTGPHY clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCLKFreq(uint32_t OTGPHYxSource)
{
34019108:	b580      	push	{r7, lr}
3401910a:	b084      	sub	sp, #16
3401910c:	af00      	add	r7, sp, #0
3401910e:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34019110:	2300      	movs	r3, #0
34019112:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
34019114:	6878      	ldr	r0, [r7, #4]
34019116:	f7f4 fcff 	bl	3400db18 <LL_RCC_GetUSBClockSource>
3401911a:	4603      	mov	r3, r0
3401911c:	4a4b      	ldr	r2, [pc, #300]	@ (3401924c <RCCEx_GetOTGPHYCLKFreq+0x144>)
3401911e:	4293      	cmp	r3, r2
34019120:	d035      	beq.n	3401918e <RCCEx_GetOTGPHYCLKFreq+0x86>
34019122:	4a4a      	ldr	r2, [pc, #296]	@ (3401924c <RCCEx_GetOTGPHYCLKFreq+0x144>)
34019124:	4293      	cmp	r3, r2
34019126:	f200 8085 	bhi.w	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
3401912a:	4a49      	ldr	r2, [pc, #292]	@ (34019250 <RCCEx_GetOTGPHYCLKFreq+0x148>)
3401912c:	4293      	cmp	r3, r2
3401912e:	d02e      	beq.n	3401918e <RCCEx_GetOTGPHYCLKFreq+0x86>
34019130:	4a47      	ldr	r2, [pc, #284]	@ (34019250 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34019132:	4293      	cmp	r3, r2
34019134:	d87e      	bhi.n	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34019136:	4a47      	ldr	r2, [pc, #284]	@ (34019254 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34019138:	4293      	cmp	r3, r2
3401913a:	d038      	beq.n	340191ae <RCCEx_GetOTGPHYCLKFreq+0xa6>
3401913c:	4a45      	ldr	r2, [pc, #276]	@ (34019254 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
3401913e:	4293      	cmp	r3, r2
34019140:	d878      	bhi.n	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34019142:	4a45      	ldr	r2, [pc, #276]	@ (34019258 <RCCEx_GetOTGPHYCLKFreq+0x150>)
34019144:	4293      	cmp	r3, r2
34019146:	d032      	beq.n	340191ae <RCCEx_GetOTGPHYCLKFreq+0xa6>
34019148:	4a43      	ldr	r2, [pc, #268]	@ (34019258 <RCCEx_GetOTGPHYCLKFreq+0x150>)
3401914a:	4293      	cmp	r3, r2
3401914c:	d872      	bhi.n	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
3401914e:	4a43      	ldr	r2, [pc, #268]	@ (3401925c <RCCEx_GetOTGPHYCLKFreq+0x154>)
34019150:	4293      	cmp	r3, r2
34019152:	d00f      	beq.n	34019174 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34019154:	4a41      	ldr	r2, [pc, #260]	@ (3401925c <RCCEx_GetOTGPHYCLKFreq+0x154>)
34019156:	4293      	cmp	r3, r2
34019158:	d86c      	bhi.n	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
3401915a:	4a41      	ldr	r2, [pc, #260]	@ (34019260 <RCCEx_GetOTGPHYCLKFreq+0x158>)
3401915c:	4293      	cmp	r3, r2
3401915e:	d009      	beq.n	34019174 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34019160:	4a3f      	ldr	r2, [pc, #252]	@ (34019260 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34019162:	4293      	cmp	r3, r2
34019164:	d866      	bhi.n	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34019166:	4a3f      	ldr	r2, [pc, #252]	@ (34019264 <RCCEx_GetOTGPHYCLKFreq+0x15c>)
34019168:	4293      	cmp	r3, r2
3401916a:	d008      	beq.n	3401917e <RCCEx_GetOTGPHYCLKFreq+0x76>
3401916c:	4a3e      	ldr	r2, [pc, #248]	@ (34019268 <RCCEx_GetOTGPHYCLKFreq+0x160>)
3401916e:	4293      	cmp	r3, r2
34019170:	d005      	beq.n	3401917e <RCCEx_GetOTGPHYCLKFreq+0x76>
      }
      break;

    default:
      /* Unexpected case */
      break;
34019172:	e05f      	b.n	34019234 <RCCEx_GetOTGPHYCLKFreq+0x12c>
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34019174:	2007      	movs	r0, #7
34019176:	f7fd f8b5 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
3401917a:	60f8      	str	r0, [r7, #12]
      break;
3401917c:	e061      	b.n	34019242 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      if (LL_RCC_HSE_IsReady() != 0U)
3401917e:	f7f4 f8b9 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
34019182:	4603      	mov	r3, r0
34019184:	2b00      	cmp	r3, #0
34019186:	d057      	beq.n	34019238 <RCCEx_GetOTGPHYCLKFreq+0x130>
        usb_frequency = HSE_VALUE / 2U;
34019188:	4b38      	ldr	r3, [pc, #224]	@ (3401926c <RCCEx_GetOTGPHYCLKFreq+0x164>)
3401918a:	60fb      	str	r3, [r7, #12]
      break;
3401918c:	e054      	b.n	34019238 <RCCEx_GetOTGPHYCLKFreq+0x130>
      if (LL_RCC_HSE_IsReady() != 0U)
3401918e:	f7f4 f8b1 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
34019192:	4603      	mov	r3, r0
34019194:	2b00      	cmp	r3, #0
34019196:	d051      	beq.n	3401923c <RCCEx_GetOTGPHYCLKFreq+0x134>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34019198:	f7f4 f89a 	bl	3400d2d0 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3401919c:	4603      	mov	r3, r0
3401919e:	2b00      	cmp	r3, #0
340191a0:	d102      	bne.n	340191a8 <RCCEx_GetOTGPHYCLKFreq+0xa0>
          usb_frequency = HSE_VALUE;
340191a2:	4b33      	ldr	r3, [pc, #204]	@ (34019270 <RCCEx_GetOTGPHYCLKFreq+0x168>)
340191a4:	60fb      	str	r3, [r7, #12]
      break;
340191a6:	e049      	b.n	3401923c <RCCEx_GetOTGPHYCLKFreq+0x134>
          usb_frequency = HSE_VALUE / 2U;
340191a8:	4b30      	ldr	r3, [pc, #192]	@ (3401926c <RCCEx_GetOTGPHYCLKFreq+0x164>)
340191aa:	60fb      	str	r3, [r7, #12]
      break;
340191ac:	e046      	b.n	3401923c <RCCEx_GetOTGPHYCLKFreq+0x134>
      if (LL_RCC_IC15_IsEnabled() != 0U)
340191ae:	f7f5 fa17 	bl	3400e5e0 <LL_RCC_IC15_IsEnabled>
340191b2:	4603      	mov	r3, r0
340191b4:	2b00      	cmp	r3, #0
340191b6:	d043      	beq.n	34019240 <RCCEx_GetOTGPHYCLKFreq+0x138>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
340191b8:	f7f5 fa34 	bl	3400e624 <LL_RCC_IC15_GetDivider>
340191bc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
340191be:	f7f5 fa23 	bl	3400e608 <LL_RCC_IC15_GetSource>
340191c2:	4603      	mov	r3, r0
340191c4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340191c8:	d029      	beq.n	3401921e <RCCEx_GetOTGPHYCLKFreq+0x116>
340191ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340191ce:	d82f      	bhi.n	34019230 <RCCEx_GetOTGPHYCLKFreq+0x128>
340191d0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340191d4:	d01a      	beq.n	3401920c <RCCEx_GetOTGPHYCLKFreq+0x104>
340191d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340191da:	d829      	bhi.n	34019230 <RCCEx_GetOTGPHYCLKFreq+0x128>
340191dc:	2b00      	cmp	r3, #0
340191de:	d003      	beq.n	340191e8 <RCCEx_GetOTGPHYCLKFreq+0xe0>
340191e0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340191e4:	d009      	beq.n	340191fa <RCCEx_GetOTGPHYCLKFreq+0xf2>
            break;
340191e6:	e023      	b.n	34019230 <RCCEx_GetOTGPHYCLKFreq+0x128>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340191e8:	f7fc fc78 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340191ec:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
340191ee:	68fa      	ldr	r2, [r7, #12]
340191f0:	68bb      	ldr	r3, [r7, #8]
340191f2:	fbb2 f3f3 	udiv	r3, r2, r3
340191f6:	60fb      	str	r3, [r7, #12]
            break;
340191f8:	e01b      	b.n	34019232 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340191fa:	f7fc fcb5 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340191fe:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34019200:	68fa      	ldr	r2, [r7, #12]
34019202:	68bb      	ldr	r3, [r7, #8]
34019204:	fbb2 f3f3 	udiv	r3, r2, r3
34019208:	60fb      	str	r3, [r7, #12]
            break;
3401920a:	e012      	b.n	34019232 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401920c:	f7fc fcf2 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34019210:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34019212:	68fa      	ldr	r2, [r7, #12]
34019214:	68bb      	ldr	r3, [r7, #8]
34019216:	fbb2 f3f3 	udiv	r3, r2, r3
3401921a:	60fb      	str	r3, [r7, #12]
            break;
3401921c:	e009      	b.n	34019232 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401921e:	f7fc fd2f 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34019222:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34019224:	68fa      	ldr	r2, [r7, #12]
34019226:	68bb      	ldr	r3, [r7, #8]
34019228:	fbb2 f3f3 	udiv	r3, r2, r3
3401922c:	60fb      	str	r3, [r7, #12]
            break;
3401922e:	e000      	b.n	34019232 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            break;
34019230:	bf00      	nop
      break;
34019232:	e005      	b.n	34019240 <RCCEx_GetOTGPHYCLKFreq+0x138>
      break;
34019234:	bf00      	nop
34019236:	e004      	b.n	34019242 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34019238:	bf00      	nop
3401923a:	e002      	b.n	34019242 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
3401923c:	bf00      	nop
3401923e:	e000      	b.n	34019242 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34019240:	bf00      	nop
  }

  return usb_frequency;
34019242:	68fb      	ldr	r3, [r7, #12]
}
34019244:	4618      	mov	r0, r3
34019246:	3710      	adds	r7, #16
34019248:	46bd      	mov	sp, r7
3401924a:	bd80      	pop	{r7, pc}
3401924c:	03031414 	.word	0x03031414
34019250:	03030c14 	.word	0x03030c14
34019254:	03021414 	.word	0x03021414
34019258:	03020c14 	.word	0x03020c14
3401925c:	03011414 	.word	0x03011414
34019260:	03010c14 	.word	0x03010c14
34019264:	03000c14 	.word	0x03000c14
34019268:	03001414 	.word	0x03001414
3401926c:	016e3600 	.word	0x016e3600
34019270:	02dc6c00 	.word	0x02dc6c00

34019274 <RCCEx_GetOTGPHYCKREFCLKFreq>:
  *         @arg @ref RCCEx_USBPHY2_Clock_Source
  * @retval OTGPHYCKREF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCKREFCLKFreq(uint32_t OTGPHYxCKREFSource)
{
34019274:	b580      	push	{r7, lr}
34019276:	b084      	sub	sp, #16
34019278:	af00      	add	r7, sp, #0
3401927a:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3401927c:	2300      	movs	r3, #0
3401927e:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
34019280:	6878      	ldr	r0, [r7, #4]
34019282:	f7f4 fc49 	bl	3400db18 <LL_RCC_GetUSBClockSource>
34019286:	4603      	mov	r3, r0
34019288:	4a1a      	ldr	r2, [pc, #104]	@ (340192f4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
3401928a:	4293      	cmp	r3, r2
3401928c:	d00f      	beq.n	340192ae <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
3401928e:	4a19      	ldr	r2, [pc, #100]	@ (340192f4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
34019290:	4293      	cmp	r3, r2
34019292:	d826      	bhi.n	340192e2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34019294:	4a18      	ldr	r2, [pc, #96]	@ (340192f8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
34019296:	4293      	cmp	r3, r2
34019298:	d009      	beq.n	340192ae <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
3401929a:	4a17      	ldr	r2, [pc, #92]	@ (340192f8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
3401929c:	4293      	cmp	r3, r2
3401929e:	d820      	bhi.n	340192e2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
340192a0:	4a16      	ldr	r2, [pc, #88]	@ (340192fc <RCCEx_GetOTGPHYCKREFCLKFreq+0x88>)
340192a2:	4293      	cmp	r3, r2
340192a4:	d013      	beq.n	340192ce <RCCEx_GetOTGPHYCKREFCLKFreq+0x5a>
340192a6:	4a16      	ldr	r2, [pc, #88]	@ (34019300 <RCCEx_GetOTGPHYCKREFCLKFreq+0x8c>)
340192a8:	4293      	cmp	r3, r2
340192aa:	d015      	beq.n	340192d8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x64>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
      break;

    default:
      /* Unexpected case */
      break;
340192ac:	e019      	b.n	340192e2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
      if (LL_RCC_HSE_IsReady() != 0U)
340192ae:	f7f4 f821 	bl	3400d2f4 <LL_RCC_HSE_IsReady>
340192b2:	4603      	mov	r3, r0
340192b4:	2b00      	cmp	r3, #0
340192b6:	d016      	beq.n	340192e6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
340192b8:	f7f4 f80a 	bl	3400d2d0 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
340192bc:	4603      	mov	r3, r0
340192be:	2b00      	cmp	r3, #0
340192c0:	d102      	bne.n	340192c8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>
          usb_frequency = HSE_VALUE;
340192c2:	4b10      	ldr	r3, [pc, #64]	@ (34019304 <RCCEx_GetOTGPHYCKREFCLKFreq+0x90>)
340192c4:	60fb      	str	r3, [r7, #12]
      break;
340192c6:	e00e      	b.n	340192e6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
          usb_frequency = HSE_VALUE / 2U;
340192c8:	4b0f      	ldr	r3, [pc, #60]	@ (34019308 <RCCEx_GetOTGPHYCKREFCLKFreq+0x94>)
340192ca:	60fb      	str	r3, [r7, #12]
      break;
340192cc:	e00b      	b.n	340192e6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
340192ce:	480f      	ldr	r0, [pc, #60]	@ (3401930c <RCCEx_GetOTGPHYCKREFCLKFreq+0x98>)
340192d0:	f7ff ff1a 	bl	34019108 <RCCEx_GetOTGPHYCLKFreq>
340192d4:	60f8      	str	r0, [r7, #12]
      break;
340192d6:	e007      	b.n	340192e8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
340192d8:	480d      	ldr	r0, [pc, #52]	@ (34019310 <RCCEx_GetOTGPHYCKREFCLKFreq+0x9c>)
340192da:	f7ff ff15 	bl	34019108 <RCCEx_GetOTGPHYCLKFreq>
340192de:	60f8      	str	r0, [r7, #12]
      break;
340192e0:	e002      	b.n	340192e8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
340192e2:	bf00      	nop
340192e4:	e000      	b.n	340192e8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
340192e6:	bf00      	nop
  }

  return usb_frequency;
340192e8:	68fb      	ldr	r3, [r7, #12]
}
340192ea:	4618      	mov	r0, r3
340192ec:	3710      	adds	r7, #16
340192ee:	46bd      	mov	sp, r7
340192f0:	bd80      	pop	{r7, pc}
340192f2:	bf00      	nop
340192f4:	01011814 	.word	0x01011814
340192f8:	01011014 	.word	0x01011014
340192fc:	01001014 	.word	0x01001014
34019300:	01001814 	.word	0x01001814
34019304:	02dc6c00 	.word	0x02dc6c00
34019308:	016e3600 	.word	0x016e3600
3401930c:	03000c14 	.word	0x03000c14
34019310:	03001414 	.word	0x03001414

34019314 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
34019314:	b580      	push	{r7, lr}
34019316:	b084      	sub	sp, #16
34019318:	af00      	add	r7, sp, #0
3401931a:	6078      	str	r0, [r7, #4]
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
3401931c:	2300      	movs	r3, #0
3401931e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
34019320:	6878      	ldr	r0, [r7, #4]
34019322:	f7f4 fc05 	bl	3400db30 <LL_RCC_GetXSPIClockSource>
34019326:	4603      	mov	r3, r0
34019328:	4a76      	ldr	r2, [pc, #472]	@ (34019504 <RCCEx_GetXSPICLKFreq+0x1f0>)
3401932a:	4293      	cmp	r3, r2
3401932c:	f000 809d 	beq.w	3401946a <RCCEx_GetXSPICLKFreq+0x156>
34019330:	4a74      	ldr	r2, [pc, #464]	@ (34019504 <RCCEx_GetXSPICLKFreq+0x1f0>)
34019332:	4293      	cmp	r3, r2
34019334:	f200 80dc 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019338:	4a73      	ldr	r2, [pc, #460]	@ (34019508 <RCCEx_GetXSPICLKFreq+0x1f4>)
3401933a:	4293      	cmp	r3, r2
3401933c:	f000 8095 	beq.w	3401946a <RCCEx_GetXSPICLKFreq+0x156>
34019340:	4a71      	ldr	r2, [pc, #452]	@ (34019508 <RCCEx_GetXSPICLKFreq+0x1f4>)
34019342:	4293      	cmp	r3, r2
34019344:	f200 80d4 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019348:	4a70      	ldr	r2, [pc, #448]	@ (3401950c <RCCEx_GetXSPICLKFreq+0x1f8>)
3401934a:	4293      	cmp	r3, r2
3401934c:	f000 808d 	beq.w	3401946a <RCCEx_GetXSPICLKFreq+0x156>
34019350:	4a6e      	ldr	r2, [pc, #440]	@ (3401950c <RCCEx_GetXSPICLKFreq+0x1f8>)
34019352:	4293      	cmp	r3, r2
34019354:	f200 80cc 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019358:	4a6d      	ldr	r2, [pc, #436]	@ (34019510 <RCCEx_GetXSPICLKFreq+0x1fc>)
3401935a:	4293      	cmp	r3, r2
3401935c:	d041      	beq.n	340193e2 <RCCEx_GetXSPICLKFreq+0xce>
3401935e:	4a6c      	ldr	r2, [pc, #432]	@ (34019510 <RCCEx_GetXSPICLKFreq+0x1fc>)
34019360:	4293      	cmp	r3, r2
34019362:	f200 80c5 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019366:	4a6b      	ldr	r2, [pc, #428]	@ (34019514 <RCCEx_GetXSPICLKFreq+0x200>)
34019368:	4293      	cmp	r3, r2
3401936a:	d03a      	beq.n	340193e2 <RCCEx_GetXSPICLKFreq+0xce>
3401936c:	4a69      	ldr	r2, [pc, #420]	@ (34019514 <RCCEx_GetXSPICLKFreq+0x200>)
3401936e:	4293      	cmp	r3, r2
34019370:	f200 80be 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019374:	4a68      	ldr	r2, [pc, #416]	@ (34019518 <RCCEx_GetXSPICLKFreq+0x204>)
34019376:	4293      	cmp	r3, r2
34019378:	d033      	beq.n	340193e2 <RCCEx_GetXSPICLKFreq+0xce>
3401937a:	4a67      	ldr	r2, [pc, #412]	@ (34019518 <RCCEx_GetXSPICLKFreq+0x204>)
3401937c:	4293      	cmp	r3, r2
3401937e:	f200 80b7 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019382:	4a66      	ldr	r2, [pc, #408]	@ (3401951c <RCCEx_GetXSPICLKFreq+0x208>)
34019384:	4293      	cmp	r3, r2
34019386:	d027      	beq.n	340193d8 <RCCEx_GetXSPICLKFreq+0xc4>
34019388:	4a64      	ldr	r2, [pc, #400]	@ (3401951c <RCCEx_GetXSPICLKFreq+0x208>)
3401938a:	4293      	cmp	r3, r2
3401938c:	f200 80b0 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
34019390:	4a63      	ldr	r2, [pc, #396]	@ (34019520 <RCCEx_GetXSPICLKFreq+0x20c>)
34019392:	4293      	cmp	r3, r2
34019394:	d020      	beq.n	340193d8 <RCCEx_GetXSPICLKFreq+0xc4>
34019396:	4a62      	ldr	r2, [pc, #392]	@ (34019520 <RCCEx_GetXSPICLKFreq+0x20c>)
34019398:	4293      	cmp	r3, r2
3401939a:	f200 80a9 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
3401939e:	4a61      	ldr	r2, [pc, #388]	@ (34019524 <RCCEx_GetXSPICLKFreq+0x210>)
340193a0:	4293      	cmp	r3, r2
340193a2:	d019      	beq.n	340193d8 <RCCEx_GetXSPICLKFreq+0xc4>
340193a4:	4a5f      	ldr	r2, [pc, #380]	@ (34019524 <RCCEx_GetXSPICLKFreq+0x210>)
340193a6:	4293      	cmp	r3, r2
340193a8:	f200 80a2 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
340193ac:	4a5e      	ldr	r2, [pc, #376]	@ (34019528 <RCCEx_GetXSPICLKFreq+0x214>)
340193ae:	4293      	cmp	r3, r2
340193b0:	d00a      	beq.n	340193c8 <RCCEx_GetXSPICLKFreq+0xb4>
340193b2:	4a5d      	ldr	r2, [pc, #372]	@ (34019528 <RCCEx_GetXSPICLKFreq+0x214>)
340193b4:	4293      	cmp	r3, r2
340193b6:	f200 809b 	bhi.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
340193ba:	4a5c      	ldr	r2, [pc, #368]	@ (3401952c <RCCEx_GetXSPICLKFreq+0x218>)
340193bc:	4293      	cmp	r3, r2
340193be:	d003      	beq.n	340193c8 <RCCEx_GetXSPICLKFreq+0xb4>
340193c0:	4a5b      	ldr	r2, [pc, #364]	@ (34019530 <RCCEx_GetXSPICLKFreq+0x21c>)
340193c2:	4293      	cmp	r3, r2
340193c4:	f040 8094 	bne.w	340194f0 <RCCEx_GetXSPICLKFreq+0x1dc>
  {
    case LL_RCC_XSPI1_CLKSOURCE_HCLK:
    case LL_RCC_XSPI2_CLKSOURCE_HCLK:
    case LL_RCC_XSPI3_CLKSOURCE_HCLK:
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340193c8:	f7f3 fba8 	bl	3400cb1c <HAL_RCC_GetSysClockFreq>
340193cc:	4603      	mov	r3, r0
340193ce:	4618      	mov	r0, r3
340193d0:	f7fc fc9c 	bl	34015d0c <RCCEx_GetHCLKFreq>
340193d4:	60f8      	str	r0, [r7, #12]
      break;
340193d6:	e090      	b.n	340194fa <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_CLKP:
    case LL_RCC_XSPI2_CLKSOURCE_CLKP:
    case LL_RCC_XSPI3_CLKSOURCE_CLKP:
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340193d8:	2007      	movs	r0, #7
340193da:	f7fc ff83 	bl	340162e4 <RCCEx_GetCLKPCLKFreq>
340193de:	60f8      	str	r0, [r7, #12]
      break;
340193e0:	e08b      	b.n	340194fa <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_IC3:
    case LL_RCC_XSPI2_CLKSOURCE_IC3:
    case LL_RCC_XSPI3_CLKSOURCE_IC3:
      if (LL_RCC_IC3_IsEnabled() != 0U)
340193e2:	f7f4 fe7d 	bl	3400e0e0 <LL_RCC_IC3_IsEnabled>
340193e6:	4603      	mov	r3, r0
340193e8:	2b00      	cmp	r3, #0
340193ea:	f000 8083 	beq.w	340194f4 <RCCEx_GetXSPICLKFreq+0x1e0>
      {
        ic_divider = LL_RCC_IC3_GetDivider();
340193ee:	f7f4 fe99 	bl	3400e124 <LL_RCC_IC3_GetDivider>
340193f2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
340193f4:	f7f4 fe88 	bl	3400e108 <LL_RCC_IC3_GetSource>
340193f8:	4603      	mov	r3, r0
340193fa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340193fe:	d029      	beq.n	34019454 <RCCEx_GetXSPICLKFreq+0x140>
34019400:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34019404:	d82f      	bhi.n	34019466 <RCCEx_GetXSPICLKFreq+0x152>
34019406:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401940a:	d01a      	beq.n	34019442 <RCCEx_GetXSPICLKFreq+0x12e>
3401940c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34019410:	d829      	bhi.n	34019466 <RCCEx_GetXSPICLKFreq+0x152>
34019412:	2b00      	cmp	r3, #0
34019414:	d003      	beq.n	3401941e <RCCEx_GetXSPICLKFreq+0x10a>
34019416:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401941a:	d009      	beq.n	34019430 <RCCEx_GetXSPICLKFreq+0x11c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401941c:	e023      	b.n	34019466 <RCCEx_GetXSPICLKFreq+0x152>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401941e:	f7fc fb5d 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
34019422:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34019424:	68fa      	ldr	r2, [r7, #12]
34019426:	68bb      	ldr	r3, [r7, #8]
34019428:	fbb2 f3f3 	udiv	r3, r2, r3
3401942c:	60fb      	str	r3, [r7, #12]
            break;
3401942e:	e01b      	b.n	34019468 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34019430:	f7fc fb9a 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
34019434:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34019436:	68fa      	ldr	r2, [r7, #12]
34019438:	68bb      	ldr	r3, [r7, #8]
3401943a:	fbb2 f3f3 	udiv	r3, r2, r3
3401943e:	60fb      	str	r3, [r7, #12]
            break;
34019440:	e012      	b.n	34019468 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34019442:	f7fc fbd7 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
34019446:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34019448:	68fa      	ldr	r2, [r7, #12]
3401944a:	68bb      	ldr	r3, [r7, #8]
3401944c:	fbb2 f3f3 	udiv	r3, r2, r3
34019450:	60fb      	str	r3, [r7, #12]
            break;
34019452:	e009      	b.n	34019468 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34019454:	f7fc fc14 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
34019458:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3401945a:	68fa      	ldr	r2, [r7, #12]
3401945c:	68bb      	ldr	r3, [r7, #8]
3401945e:	fbb2 f3f3 	udiv	r3, r2, r3
34019462:	60fb      	str	r3, [r7, #12]
            break;
34019464:	e000      	b.n	34019468 <RCCEx_GetXSPICLKFreq+0x154>
            break;
34019466:	bf00      	nop
        }
      }
      break;
34019468:	e044      	b.n	340194f4 <RCCEx_GetXSPICLKFreq+0x1e0>

    case LL_RCC_XSPI1_CLKSOURCE_IC4:
    case LL_RCC_XSPI2_CLKSOURCE_IC4:
    case LL_RCC_XSPI3_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
3401946a:	f7f4 fe79 	bl	3400e160 <LL_RCC_IC4_IsEnabled>
3401946e:	4603      	mov	r3, r0
34019470:	2b00      	cmp	r3, #0
34019472:	d041      	beq.n	340194f8 <RCCEx_GetXSPICLKFreq+0x1e4>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34019474:	f7f4 fe96 	bl	3400e1a4 <LL_RCC_IC4_GetDivider>
34019478:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3401947a:	f7f4 fe85 	bl	3400e188 <LL_RCC_IC4_GetSource>
3401947e:	4603      	mov	r3, r0
34019480:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34019484:	d029      	beq.n	340194da <RCCEx_GetXSPICLKFreq+0x1c6>
34019486:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401948a:	d82f      	bhi.n	340194ec <RCCEx_GetXSPICLKFreq+0x1d8>
3401948c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34019490:	d01a      	beq.n	340194c8 <RCCEx_GetXSPICLKFreq+0x1b4>
34019492:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34019496:	d829      	bhi.n	340194ec <RCCEx_GetXSPICLKFreq+0x1d8>
34019498:	2b00      	cmp	r3, #0
3401949a:	d003      	beq.n	340194a4 <RCCEx_GetXSPICLKFreq+0x190>
3401949c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340194a0:	d009      	beq.n	340194b6 <RCCEx_GetXSPICLKFreq+0x1a2>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340194a2:	e023      	b.n	340194ec <RCCEx_GetXSPICLKFreq+0x1d8>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340194a4:	f7fc fb1a 	bl	34015adc <HAL_RCCEx_GetPLL1CLKFreq>
340194a8:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340194aa:	68fa      	ldr	r2, [r7, #12]
340194ac:	68bb      	ldr	r3, [r7, #8]
340194ae:	fbb2 f3f3 	udiv	r3, r2, r3
340194b2:	60fb      	str	r3, [r7, #12]
            break;
340194b4:	e01b      	b.n	340194ee <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340194b6:	f7fc fb57 	bl	34015b68 <HAL_RCCEx_GetPLL2CLKFreq>
340194ba:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340194bc:	68fa      	ldr	r2, [r7, #12]
340194be:	68bb      	ldr	r3, [r7, #8]
340194c0:	fbb2 f3f3 	udiv	r3, r2, r3
340194c4:	60fb      	str	r3, [r7, #12]
            break;
340194c6:	e012      	b.n	340194ee <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340194c8:	f7fc fb94 	bl	34015bf4 <HAL_RCCEx_GetPLL3CLKFreq>
340194cc:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340194ce:	68fa      	ldr	r2, [r7, #12]
340194d0:	68bb      	ldr	r3, [r7, #8]
340194d2:	fbb2 f3f3 	udiv	r3, r2, r3
340194d6:	60fb      	str	r3, [r7, #12]
            break;
340194d8:	e009      	b.n	340194ee <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340194da:	f7fc fbd1 	bl	34015c80 <HAL_RCCEx_GetPLL4CLKFreq>
340194de:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340194e0:	68fa      	ldr	r2, [r7, #12]
340194e2:	68bb      	ldr	r3, [r7, #8]
340194e4:	fbb2 f3f3 	udiv	r3, r2, r3
340194e8:	60fb      	str	r3, [r7, #12]
            break;
340194ea:	e000      	b.n	340194ee <RCCEx_GetXSPICLKFreq+0x1da>
            break;
340194ec:	bf00      	nop
        }
      }
      break;
340194ee:	e003      	b.n	340194f8 <RCCEx_GetXSPICLKFreq+0x1e4>

    default:
      /* Nothing to do */
      break;
340194f0:	bf00      	nop
340194f2:	e002      	b.n	340194fa <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
340194f4:	bf00      	nop
340194f6:	e000      	b.n	340194fa <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
340194f8:	bf00      	nop
  }

  return xspi_frequency;
340194fa:	68fb      	ldr	r3, [r7, #12]
}
340194fc:	4618      	mov	r0, r3
340194fe:	3710      	adds	r7, #16
34019500:	46bd      	mov	sp, r7
34019502:	bd80      	pop	{r7, pc}
34019504:	03030814 	.word	0x03030814
34019508:	03030414 	.word	0x03030414
3401950c:	03030014 	.word	0x03030014
34019510:	03020814 	.word	0x03020814
34019514:	03020414 	.word	0x03020414
34019518:	03020014 	.word	0x03020014
3401951c:	03010814 	.word	0x03010814
34019520:	03010414 	.word	0x03010414
34019524:	03010014 	.word	0x03010014
34019528:	03000814 	.word	0x03000814
3401952c:	03000014 	.word	0x03000014
34019530:	03000414 	.word	0x03000414

34019534 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
34019534:	b580      	push	{r7, lr}
34019536:	b088      	sub	sp, #32
34019538:	af00      	add	r7, sp, #0
3401953a:	6078      	str	r0, [r7, #4]
3401953c:	6039      	str	r1, [r7, #0]
  uint32_t master_cid;
  uint32_t rimc_attr_val;

  /* Check the parameter */
  assert_param(pConfig != (void *)NULL);
3401953e:	683b      	ldr	r3, [r7, #0]
34019540:	2b00      	cmp	r3, #0
34019542:	d104      	bne.n	3401954e <HAL_RIF_RIMC_ConfigMasterAttributes+0x1a>
34019544:	f240 1111 	movw	r1, #273	@ 0x111
34019548:	484d      	ldr	r0, [pc, #308]	@ (34019680 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
3401954a:	f7e7 fea5 	bl	34001298 <assert_failed>
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
3401954e:	687b      	ldr	r3, [r7, #4]
34019550:	2b00      	cmp	r3, #0
34019552:	d028      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019554:	687b      	ldr	r3, [r7, #4]
34019556:	2b01      	cmp	r3, #1
34019558:	d025      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
3401955a:	687b      	ldr	r3, [r7, #4]
3401955c:	2b02      	cmp	r3, #2
3401955e:	d022      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019560:	687b      	ldr	r3, [r7, #4]
34019562:	2b03      	cmp	r3, #3
34019564:	d01f      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019566:	687b      	ldr	r3, [r7, #4]
34019568:	2b04      	cmp	r3, #4
3401956a:	d01c      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
3401956c:	687b      	ldr	r3, [r7, #4]
3401956e:	2b05      	cmp	r3, #5
34019570:	d019      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019572:	687b      	ldr	r3, [r7, #4]
34019574:	2b06      	cmp	r3, #6
34019576:	d016      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019578:	687b      	ldr	r3, [r7, #4]
3401957a:	2b07      	cmp	r3, #7
3401957c:	d013      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
3401957e:	687b      	ldr	r3, [r7, #4]
34019580:	2b08      	cmp	r3, #8
34019582:	d010      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019584:	687b      	ldr	r3, [r7, #4]
34019586:	2b09      	cmp	r3, #9
34019588:	d00d      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
3401958a:	687b      	ldr	r3, [r7, #4]
3401958c:	2b0a      	cmp	r3, #10
3401958e:	d00a      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019590:	687b      	ldr	r3, [r7, #4]
34019592:	2b0b      	cmp	r3, #11
34019594:	d007      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
34019596:	687b      	ldr	r3, [r7, #4]
34019598:	2b0c      	cmp	r3, #12
3401959a:	d004      	beq.n	340195a6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x72>
3401959c:	f44f 7189 	mov.w	r1, #274	@ 0x112
340195a0:	4837      	ldr	r0, [pc, #220]	@ (34019680 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
340195a2:	f7e7 fe79 	bl	34001298 <assert_failed>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
340195a6:	683b      	ldr	r3, [r7, #0]
340195a8:	681b      	ldr	r3, [r3, #0]
340195aa:	2b01      	cmp	r3, #1
340195ac:	d020      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195ae:	683b      	ldr	r3, [r7, #0]
340195b0:	681b      	ldr	r3, [r3, #0]
340195b2:	2b02      	cmp	r3, #2
340195b4:	d01c      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195b6:	683b      	ldr	r3, [r7, #0]
340195b8:	681b      	ldr	r3, [r3, #0]
340195ba:	2b04      	cmp	r3, #4
340195bc:	d018      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195be:	683b      	ldr	r3, [r7, #0]
340195c0:	681b      	ldr	r3, [r3, #0]
340195c2:	2b08      	cmp	r3, #8
340195c4:	d014      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195c6:	683b      	ldr	r3, [r7, #0]
340195c8:	681b      	ldr	r3, [r3, #0]
340195ca:	2b10      	cmp	r3, #16
340195cc:	d010      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195ce:	683b      	ldr	r3, [r7, #0]
340195d0:	681b      	ldr	r3, [r3, #0]
340195d2:	2b20      	cmp	r3, #32
340195d4:	d00c      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195d6:	683b      	ldr	r3, [r7, #0]
340195d8:	681b      	ldr	r3, [r3, #0]
340195da:	2b40      	cmp	r3, #64	@ 0x40
340195dc:	d008      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195de:	683b      	ldr	r3, [r7, #0]
340195e0:	681b      	ldr	r3, [r3, #0]
340195e2:	2b80      	cmp	r3, #128	@ 0x80
340195e4:	d004      	beq.n	340195f0 <HAL_RIF_RIMC_ConfigMasterAttributes+0xbc>
340195e6:	f240 1113 	movw	r1, #275	@ 0x113
340195ea:	4825      	ldr	r0, [pc, #148]	@ (34019680 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
340195ec:	f7e7 fe54 	bl	34001298 <assert_failed>
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
340195f0:	683b      	ldr	r3, [r7, #0]
340195f2:	681b      	ldr	r3, [r3, #0]
340195f4:	2b80      	cmp	r3, #128	@ 0x80
340195f6:	d003      	beq.n	34019600 <HAL_RIF_RIMC_ConfigMasterAttributes+0xcc>
340195f8:	683b      	ldr	r3, [r7, #0]
340195fa:	681b      	ldr	r3, [r3, #0]
340195fc:	2bff      	cmp	r3, #255	@ 0xff
340195fe:	d904      	bls.n	3401960a <HAL_RIF_RIMC_ConfigMasterAttributes+0xd6>
34019600:	f44f 718a 	mov.w	r1, #276	@ 0x114
34019604:	481e      	ldr	r0, [pc, #120]	@ (34019680 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
34019606:	f7e7 fe47 	bl	34001298 <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));
3401960a:	683b      	ldr	r3, [r7, #0]
3401960c:	685b      	ldr	r3, [r3, #4]
3401960e:	2b03      	cmp	r3, #3
34019610:	d904      	bls.n	3401961c <HAL_RIF_RIMC_ConfigMasterAttributes+0xe8>
34019612:	f240 1115 	movw	r1, #277	@ 0x115
34019616:	481a      	ldr	r0, [pc, #104]	@ (34019680 <HAL_RIF_RIMC_ConfigMasterAttributes+0x14c>)
34019618:	f7e7 fe3e 	bl	34001298 <assert_failed>

  master_cid = POSITION_VAL(pConfig->MasterCID);
3401961c:	683b      	ldr	r3, [r7, #0]
3401961e:	681b      	ldr	r3, [r3, #0]
34019620:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34019622:	693b      	ldr	r3, [r7, #16]
34019624:	fa93 f3a3 	rbit	r3, r3
34019628:	60fb      	str	r3, [r7, #12]
  return result;
3401962a:	68fb      	ldr	r3, [r7, #12]
3401962c:	617b      	str	r3, [r7, #20]
  if (value == 0U)
3401962e:	697b      	ldr	r3, [r7, #20]
34019630:	2b00      	cmp	r3, #0
34019632:	d101      	bne.n	34019638 <HAL_RIF_RIMC_ConfigMasterAttributes+0x104>
    return 32U;
34019634:	2320      	movs	r3, #32
34019636:	e003      	b.n	34019640 <HAL_RIF_RIMC_ConfigMasterAttributes+0x10c>
  return __builtin_clz(value);
34019638:	697b      	ldr	r3, [r7, #20]
3401963a:	fab3 f383 	clz	r3, r3
3401963e:	b2db      	uxtb	r3, r3
34019640:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
34019642:	4a10      	ldr	r2, [pc, #64]	@ (34019684 <HAL_RIF_RIMC_ConfigMasterAttributes+0x150>)
34019644:	687b      	ldr	r3, [r7, #4]
34019646:	f503 7341 	add.w	r3, r3, #772	@ 0x304
3401964a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3401964e:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
34019650:	69bb      	ldr	r3, [r7, #24]
34019652:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
34019656:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
34019658:	69fb      	ldr	r3, [r7, #28]
3401965a:	011a      	lsls	r2, r3, #4
3401965c:	683b      	ldr	r3, [r7, #0]
3401965e:	685b      	ldr	r3, [r3, #4]
34019660:	021b      	lsls	r3, r3, #8
34019662:	4313      	orrs	r3, r2
34019664:	69ba      	ldr	r2, [r7, #24]
34019666:	4313      	orrs	r3, r2
34019668:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
3401966a:	4906      	ldr	r1, [pc, #24]	@ (34019684 <HAL_RIF_RIMC_ConfigMasterAttributes+0x150>)
3401966c:	687b      	ldr	r3, [r7, #4]
3401966e:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34019672:	69ba      	ldr	r2, [r7, #24]
34019674:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34019678:	bf00      	nop
3401967a:	3720      	adds	r7, #32
3401967c:	46bd      	mov	sp, r7
3401967e:	bd80      	pop	{r7, pc}
34019680:	340244c0 	.word	0x340244c0
34019684:	54024000 	.word	0x54024000

34019688 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
34019688:	b580      	push	{r7, lr}
3401968a:	b084      	sub	sp, #16
3401968c:	af00      	add	r7, sp, #0
3401968e:	6078      	str	r0, [r7, #4]
34019690:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
34019692:	687b      	ldr	r3, [r7, #4]
34019694:	2b00      	cmp	r3, #0
34019696:	f000 82c6 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401969a:	687b      	ldr	r3, [r7, #4]
3401969c:	2b01      	cmp	r3, #1
3401969e:	f000 82c2 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196a2:	687b      	ldr	r3, [r7, #4]
340196a4:	2b02      	cmp	r3, #2
340196a6:	f000 82be 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196aa:	687b      	ldr	r3, [r7, #4]
340196ac:	2b03      	cmp	r3, #3
340196ae:	f000 82ba 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196b2:	687b      	ldr	r3, [r7, #4]
340196b4:	2b04      	cmp	r3, #4
340196b6:	f000 82b6 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196ba:	687b      	ldr	r3, [r7, #4]
340196bc:	2b05      	cmp	r3, #5
340196be:	f000 82b2 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196c2:	687b      	ldr	r3, [r7, #4]
340196c4:	2b06      	cmp	r3, #6
340196c6:	f000 82ae 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196ca:	687b      	ldr	r3, [r7, #4]
340196cc:	2b08      	cmp	r3, #8
340196ce:	f000 82aa 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196d2:	687b      	ldr	r3, [r7, #4]
340196d4:	2b09      	cmp	r3, #9
340196d6:	f000 82a6 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196da:	687b      	ldr	r3, [r7, #4]
340196dc:	2b0a      	cmp	r3, #10
340196de:	f000 82a2 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196e2:	687b      	ldr	r3, [r7, #4]
340196e4:	2b0b      	cmp	r3, #11
340196e6:	f000 829e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196ea:	687b      	ldr	r3, [r7, #4]
340196ec:	2b0c      	cmp	r3, #12
340196ee:	f000 829a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196f2:	687b      	ldr	r3, [r7, #4]
340196f4:	2b0d      	cmp	r3, #13
340196f6:	f000 8296 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340196fa:	687b      	ldr	r3, [r7, #4]
340196fc:	2b0e      	cmp	r3, #14
340196fe:	f000 8292 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019702:	687b      	ldr	r3, [r7, #4]
34019704:	2b0f      	cmp	r3, #15
34019706:	f000 828e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401970a:	687b      	ldr	r3, [r7, #4]
3401970c:	2b10      	cmp	r3, #16
3401970e:	f000 828a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019712:	687b      	ldr	r3, [r7, #4]
34019714:	2b11      	cmp	r3, #17
34019716:	f000 8286 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401971a:	687b      	ldr	r3, [r7, #4]
3401971c:	2b12      	cmp	r3, #18
3401971e:	f000 8282 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019722:	687b      	ldr	r3, [r7, #4]
34019724:	2b13      	cmp	r3, #19
34019726:	f000 827e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401972a:	687b      	ldr	r3, [r7, #4]
3401972c:	2b14      	cmp	r3, #20
3401972e:	f000 827a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019732:	687b      	ldr	r3, [r7, #4]
34019734:	2b15      	cmp	r3, #21
34019736:	f000 8276 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401973a:	687b      	ldr	r3, [r7, #4]
3401973c:	2b16      	cmp	r3, #22
3401973e:	f000 8272 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019742:	687b      	ldr	r3, [r7, #4]
34019744:	2b17      	cmp	r3, #23
34019746:	f000 826e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401974a:	687b      	ldr	r3, [r7, #4]
3401974c:	2b18      	cmp	r3, #24
3401974e:	f000 826a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019752:	687b      	ldr	r3, [r7, #4]
34019754:	2b19      	cmp	r3, #25
34019756:	f000 8266 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401975a:	687b      	ldr	r3, [r7, #4]
3401975c:	2b1a      	cmp	r3, #26
3401975e:	f000 8262 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019762:	687b      	ldr	r3, [r7, #4]
34019764:	2b1b      	cmp	r3, #27
34019766:	f000 825e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401976a:	687b      	ldr	r3, [r7, #4]
3401976c:	2b1c      	cmp	r3, #28
3401976e:	f000 825a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019772:	687b      	ldr	r3, [r7, #4]
34019774:	2b1d      	cmp	r3, #29
34019776:	f000 8256 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401977a:	687b      	ldr	r3, [r7, #4]
3401977c:	2b1e      	cmp	r3, #30
3401977e:	f000 8252 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019782:	687b      	ldr	r3, [r7, #4]
34019784:	2b1f      	cmp	r3, #31
34019786:	f000 824e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401978a:	687b      	ldr	r3, [r7, #4]
3401978c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34019790:	f000 8249 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019794:	687b      	ldr	r3, [r7, #4]
34019796:	4aa0      	ldr	r2, [pc, #640]	@ (34019a18 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x390>)
34019798:	4293      	cmp	r3, r2
3401979a:	f000 8244 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401979e:	687b      	ldr	r3, [r7, #4]
340197a0:	4a9e      	ldr	r2, [pc, #632]	@ (34019a1c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x394>)
340197a2:	4293      	cmp	r3, r2
340197a4:	f000 823f 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197a8:	687b      	ldr	r3, [r7, #4]
340197aa:	4a9d      	ldr	r2, [pc, #628]	@ (34019a20 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x398>)
340197ac:	4293      	cmp	r3, r2
340197ae:	f000 823a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197b2:	687b      	ldr	r3, [r7, #4]
340197b4:	4a9b      	ldr	r2, [pc, #620]	@ (34019a24 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x39c>)
340197b6:	4293      	cmp	r3, r2
340197b8:	f000 8235 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197bc:	687b      	ldr	r3, [r7, #4]
340197be:	4a9a      	ldr	r2, [pc, #616]	@ (34019a28 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a0>)
340197c0:	4293      	cmp	r3, r2
340197c2:	f000 8230 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197c6:	687b      	ldr	r3, [r7, #4]
340197c8:	4a98      	ldr	r2, [pc, #608]	@ (34019a2c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a4>)
340197ca:	4293      	cmp	r3, r2
340197cc:	f000 822b 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197d0:	687b      	ldr	r3, [r7, #4]
340197d2:	4a97      	ldr	r2, [pc, #604]	@ (34019a30 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a8>)
340197d4:	4293      	cmp	r3, r2
340197d6:	f000 8226 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197da:	687b      	ldr	r3, [r7, #4]
340197dc:	4a95      	ldr	r2, [pc, #596]	@ (34019a34 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3ac>)
340197de:	4293      	cmp	r3, r2
340197e0:	f000 8221 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197e4:	687b      	ldr	r3, [r7, #4]
340197e6:	4a94      	ldr	r2, [pc, #592]	@ (34019a38 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3b0>)
340197e8:	4293      	cmp	r3, r2
340197ea:	f000 821c 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197ee:	687b      	ldr	r3, [r7, #4]
340197f0:	4a92      	ldr	r2, [pc, #584]	@ (34019a3c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3b4>)
340197f2:	4293      	cmp	r3, r2
340197f4:	f000 8217 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340197f8:	687b      	ldr	r3, [r7, #4]
340197fa:	4a91      	ldr	r2, [pc, #580]	@ (34019a40 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3b8>)
340197fc:	4293      	cmp	r3, r2
340197fe:	f000 8212 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019802:	687b      	ldr	r3, [r7, #4]
34019804:	4a8f      	ldr	r2, [pc, #572]	@ (34019a44 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3bc>)
34019806:	4293      	cmp	r3, r2
34019808:	f000 820d 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401980c:	687b      	ldr	r3, [r7, #4]
3401980e:	4a8e      	ldr	r2, [pc, #568]	@ (34019a48 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3c0>)
34019810:	4293      	cmp	r3, r2
34019812:	f000 8208 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019816:	687b      	ldr	r3, [r7, #4]
34019818:	4a8c      	ldr	r2, [pc, #560]	@ (34019a4c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3c4>)
3401981a:	4293      	cmp	r3, r2
3401981c:	f000 8203 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019820:	687b      	ldr	r3, [r7, #4]
34019822:	4a8b      	ldr	r2, [pc, #556]	@ (34019a50 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3c8>)
34019824:	4293      	cmp	r3, r2
34019826:	f000 81fe 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401982a:	687b      	ldr	r3, [r7, #4]
3401982c:	4a89      	ldr	r2, [pc, #548]	@ (34019a54 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3cc>)
3401982e:	4293      	cmp	r3, r2
34019830:	f000 81f9 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019834:	687b      	ldr	r3, [r7, #4]
34019836:	4a88      	ldr	r2, [pc, #544]	@ (34019a58 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3d0>)
34019838:	4293      	cmp	r3, r2
3401983a:	f000 81f4 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401983e:	687b      	ldr	r3, [r7, #4]
34019840:	4a86      	ldr	r2, [pc, #536]	@ (34019a5c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3d4>)
34019842:	4293      	cmp	r3, r2
34019844:	f000 81ef 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019848:	687b      	ldr	r3, [r7, #4]
3401984a:	4a85      	ldr	r2, [pc, #532]	@ (34019a60 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3d8>)
3401984c:	4293      	cmp	r3, r2
3401984e:	f000 81ea 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019852:	687b      	ldr	r3, [r7, #4]
34019854:	4a83      	ldr	r2, [pc, #524]	@ (34019a64 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3dc>)
34019856:	4293      	cmp	r3, r2
34019858:	f000 81e5 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401985c:	687b      	ldr	r3, [r7, #4]
3401985e:	4a82      	ldr	r2, [pc, #520]	@ (34019a68 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3e0>)
34019860:	4293      	cmp	r3, r2
34019862:	f000 81e0 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019866:	687b      	ldr	r3, [r7, #4]
34019868:	4a80      	ldr	r2, [pc, #512]	@ (34019a6c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3e4>)
3401986a:	4293      	cmp	r3, r2
3401986c:	f000 81db 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019870:	687b      	ldr	r3, [r7, #4]
34019872:	4a7f      	ldr	r2, [pc, #508]	@ (34019a70 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3e8>)
34019874:	4293      	cmp	r3, r2
34019876:	f000 81d6 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401987a:	687b      	ldr	r3, [r7, #4]
3401987c:	4a7d      	ldr	r2, [pc, #500]	@ (34019a74 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3ec>)
3401987e:	4293      	cmp	r3, r2
34019880:	f000 81d1 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019884:	687b      	ldr	r3, [r7, #4]
34019886:	4a7c      	ldr	r2, [pc, #496]	@ (34019a78 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3f0>)
34019888:	4293      	cmp	r3, r2
3401988a:	f000 81cc 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401988e:	687b      	ldr	r3, [r7, #4]
34019890:	4a7a      	ldr	r2, [pc, #488]	@ (34019a7c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3f4>)
34019892:	4293      	cmp	r3, r2
34019894:	f000 81c7 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019898:	687b      	ldr	r3, [r7, #4]
3401989a:	4a79      	ldr	r2, [pc, #484]	@ (34019a80 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3f8>)
3401989c:	4293      	cmp	r3, r2
3401989e:	f000 81c2 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198a2:	687b      	ldr	r3, [r7, #4]
340198a4:	4a77      	ldr	r2, [pc, #476]	@ (34019a84 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3fc>)
340198a6:	4293      	cmp	r3, r2
340198a8:	f000 81bd 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198ac:	687b      	ldr	r3, [r7, #4]
340198ae:	4a76      	ldr	r2, [pc, #472]	@ (34019a88 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x400>)
340198b0:	4293      	cmp	r3, r2
340198b2:	f000 81b8 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198b6:	687b      	ldr	r3, [r7, #4]
340198b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340198bc:	f000 81b3 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198c0:	687b      	ldr	r3, [r7, #4]
340198c2:	4a72      	ldr	r2, [pc, #456]	@ (34019a8c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x404>)
340198c4:	4293      	cmp	r3, r2
340198c6:	f000 81ae 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198ca:	687b      	ldr	r3, [r7, #4]
340198cc:	4a70      	ldr	r2, [pc, #448]	@ (34019a90 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x408>)
340198ce:	4293      	cmp	r3, r2
340198d0:	f000 81a9 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198d4:	687b      	ldr	r3, [r7, #4]
340198d6:	4a6f      	ldr	r2, [pc, #444]	@ (34019a94 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x40c>)
340198d8:	4293      	cmp	r3, r2
340198da:	f000 81a4 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198de:	687b      	ldr	r3, [r7, #4]
340198e0:	4a6d      	ldr	r2, [pc, #436]	@ (34019a98 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x410>)
340198e2:	4293      	cmp	r3, r2
340198e4:	f000 819f 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198e8:	687b      	ldr	r3, [r7, #4]
340198ea:	4a6c      	ldr	r2, [pc, #432]	@ (34019a9c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x414>)
340198ec:	4293      	cmp	r3, r2
340198ee:	f000 819a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198f2:	687b      	ldr	r3, [r7, #4]
340198f4:	4a6a      	ldr	r2, [pc, #424]	@ (34019aa0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x418>)
340198f6:	4293      	cmp	r3, r2
340198f8:	f000 8195 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340198fc:	687b      	ldr	r3, [r7, #4]
340198fe:	4a69      	ldr	r2, [pc, #420]	@ (34019aa4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x41c>)
34019900:	4293      	cmp	r3, r2
34019902:	f000 8190 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019906:	687b      	ldr	r3, [r7, #4]
34019908:	4a67      	ldr	r2, [pc, #412]	@ (34019aa8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x420>)
3401990a:	4293      	cmp	r3, r2
3401990c:	f000 818b 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019910:	687b      	ldr	r3, [r7, #4]
34019912:	4a66      	ldr	r2, [pc, #408]	@ (34019aac <HAL_RIF_RISC_SetSlaveSecureAttributes+0x424>)
34019914:	4293      	cmp	r3, r2
34019916:	f000 8186 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401991a:	687b      	ldr	r3, [r7, #4]
3401991c:	4a64      	ldr	r2, [pc, #400]	@ (34019ab0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x428>)
3401991e:	4293      	cmp	r3, r2
34019920:	f000 8181 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019924:	687b      	ldr	r3, [r7, #4]
34019926:	4a63      	ldr	r2, [pc, #396]	@ (34019ab4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x42c>)
34019928:	4293      	cmp	r3, r2
3401992a:	f000 817c 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401992e:	687b      	ldr	r3, [r7, #4]
34019930:	4a61      	ldr	r2, [pc, #388]	@ (34019ab8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x430>)
34019932:	4293      	cmp	r3, r2
34019934:	f000 8177 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019938:	687b      	ldr	r3, [r7, #4]
3401993a:	4a60      	ldr	r2, [pc, #384]	@ (34019abc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x434>)
3401993c:	4293      	cmp	r3, r2
3401993e:	f000 8172 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019942:	687b      	ldr	r3, [r7, #4]
34019944:	4a5e      	ldr	r2, [pc, #376]	@ (34019ac0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x438>)
34019946:	4293      	cmp	r3, r2
34019948:	f000 816d 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401994c:	687b      	ldr	r3, [r7, #4]
3401994e:	4a5d      	ldr	r2, [pc, #372]	@ (34019ac4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x43c>)
34019950:	4293      	cmp	r3, r2
34019952:	f000 8168 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019956:	687b      	ldr	r3, [r7, #4]
34019958:	4a5b      	ldr	r2, [pc, #364]	@ (34019ac8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x440>)
3401995a:	4293      	cmp	r3, r2
3401995c:	f000 8163 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019960:	687b      	ldr	r3, [r7, #4]
34019962:	4a5a      	ldr	r2, [pc, #360]	@ (34019acc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x444>)
34019964:	4293      	cmp	r3, r2
34019966:	f000 815e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401996a:	687b      	ldr	r3, [r7, #4]
3401996c:	4a58      	ldr	r2, [pc, #352]	@ (34019ad0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x448>)
3401996e:	4293      	cmp	r3, r2
34019970:	f000 8159 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019974:	687b      	ldr	r3, [r7, #4]
34019976:	4a57      	ldr	r2, [pc, #348]	@ (34019ad4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x44c>)
34019978:	4293      	cmp	r3, r2
3401997a:	f000 8154 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401997e:	687b      	ldr	r3, [r7, #4]
34019980:	4a55      	ldr	r2, [pc, #340]	@ (34019ad8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x450>)
34019982:	4293      	cmp	r3, r2
34019984:	f000 814f 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019988:	687b      	ldr	r3, [r7, #4]
3401998a:	4a54      	ldr	r2, [pc, #336]	@ (34019adc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x454>)
3401998c:	4293      	cmp	r3, r2
3401998e:	f000 814a 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019992:	687b      	ldr	r3, [r7, #4]
34019994:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34019998:	f000 8145 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
3401999c:	687b      	ldr	r3, [r7, #4]
3401999e:	4a50      	ldr	r2, [pc, #320]	@ (34019ae0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x458>)
340199a0:	4293      	cmp	r3, r2
340199a2:	f000 8140 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199a6:	687b      	ldr	r3, [r7, #4]
340199a8:	4a4e      	ldr	r2, [pc, #312]	@ (34019ae4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x45c>)
340199aa:	4293      	cmp	r3, r2
340199ac:	f000 813b 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199b0:	687b      	ldr	r3, [r7, #4]
340199b2:	4a4d      	ldr	r2, [pc, #308]	@ (34019ae8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x460>)
340199b4:	4293      	cmp	r3, r2
340199b6:	f000 8136 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199ba:	687b      	ldr	r3, [r7, #4]
340199bc:	4a4b      	ldr	r2, [pc, #300]	@ (34019aec <HAL_RIF_RISC_SetSlaveSecureAttributes+0x464>)
340199be:	4293      	cmp	r3, r2
340199c0:	f000 8131 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199c4:	687b      	ldr	r3, [r7, #4]
340199c6:	4a4a      	ldr	r2, [pc, #296]	@ (34019af0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x468>)
340199c8:	4293      	cmp	r3, r2
340199ca:	f000 812c 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199ce:	687b      	ldr	r3, [r7, #4]
340199d0:	4a48      	ldr	r2, [pc, #288]	@ (34019af4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x46c>)
340199d2:	4293      	cmp	r3, r2
340199d4:	f000 8127 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199d8:	687b      	ldr	r3, [r7, #4]
340199da:	4a47      	ldr	r2, [pc, #284]	@ (34019af8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x470>)
340199dc:	4293      	cmp	r3, r2
340199de:	f000 8122 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199e2:	687b      	ldr	r3, [r7, #4]
340199e4:	4a45      	ldr	r2, [pc, #276]	@ (34019afc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x474>)
340199e6:	4293      	cmp	r3, r2
340199e8:	f000 811d 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199ec:	687b      	ldr	r3, [r7, #4]
340199ee:	4a44      	ldr	r2, [pc, #272]	@ (34019b00 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x478>)
340199f0:	4293      	cmp	r3, r2
340199f2:	f000 8118 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
340199f6:	687b      	ldr	r3, [r7, #4]
340199f8:	4a42      	ldr	r2, [pc, #264]	@ (34019b04 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x47c>)
340199fa:	4293      	cmp	r3, r2
340199fc:	f000 8113 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019a00:	687b      	ldr	r3, [r7, #4]
34019a02:	4a41      	ldr	r2, [pc, #260]	@ (34019b08 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x480>)
34019a04:	4293      	cmp	r3, r2
34019a06:	f000 810e 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019a0a:	687b      	ldr	r3, [r7, #4]
34019a0c:	4a3f      	ldr	r2, [pc, #252]	@ (34019b0c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x484>)
34019a0e:	4293      	cmp	r3, r2
34019a10:	f000 8109 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019a14:	e07c      	b.n	34019b10 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x488>
34019a16:	bf00      	nop
34019a18:	10000001 	.word	0x10000001
34019a1c:	10000002 	.word	0x10000002
34019a20:	10000003 	.word	0x10000003
34019a24:	10000004 	.word	0x10000004
34019a28:	10000005 	.word	0x10000005
34019a2c:	10000006 	.word	0x10000006
34019a30:	10000007 	.word	0x10000007
34019a34:	10000008 	.word	0x10000008
34019a38:	10000009 	.word	0x10000009
34019a3c:	1000000a 	.word	0x1000000a
34019a40:	1000000b 	.word	0x1000000b
34019a44:	1000000c 	.word	0x1000000c
34019a48:	1000000d 	.word	0x1000000d
34019a4c:	1000000e 	.word	0x1000000e
34019a50:	1000000f 	.word	0x1000000f
34019a54:	10000010 	.word	0x10000010
34019a58:	10000011 	.word	0x10000011
34019a5c:	10000012 	.word	0x10000012
34019a60:	10000013 	.word	0x10000013
34019a64:	10000014 	.word	0x10000014
34019a68:	10000015 	.word	0x10000015
34019a6c:	10000016 	.word	0x10000016
34019a70:	10000017 	.word	0x10000017
34019a74:	10000018 	.word	0x10000018
34019a78:	10000019 	.word	0x10000019
34019a7c:	1000001a 	.word	0x1000001a
34019a80:	1000001c 	.word	0x1000001c
34019a84:	1000001d 	.word	0x1000001d
34019a88:	1000001e 	.word	0x1000001e
34019a8c:	20000001 	.word	0x20000001
34019a90:	20000003 	.word	0x20000003
34019a94:	20000004 	.word	0x20000004
34019a98:	20000005 	.word	0x20000005
34019a9c:	2000000c 	.word	0x2000000c
34019aa0:	2000000d 	.word	0x2000000d
34019aa4:	2000000e 	.word	0x2000000e
34019aa8:	2000000f 	.word	0x2000000f
34019aac:	20000010 	.word	0x20000010
34019ab0:	20000011 	.word	0x20000011
34019ab4:	20000012 	.word	0x20000012
34019ab8:	20000013 	.word	0x20000013
34019abc:	20000014 	.word	0x20000014
34019ac0:	20000016 	.word	0x20000016
34019ac4:	20000017 	.word	0x20000017
34019ac8:	20000018 	.word	0x20000018
34019acc:	20000019 	.word	0x20000019
34019ad0:	2000001a 	.word	0x2000001a
34019ad4:	2000001c 	.word	0x2000001c
34019ad8:	2000001d 	.word	0x2000001d
34019adc:	2000001e 	.word	0x2000001e
34019ae0:	30000001 	.word	0x30000001
34019ae4:	30000002 	.word	0x30000002
34019ae8:	30000003 	.word	0x30000003
34019aec:	30000004 	.word	0x30000004
34019af0:	30000005 	.word	0x30000005
34019af4:	30000006 	.word	0x30000006
34019af8:	30000007 	.word	0x30000007
34019afc:	30000008 	.word	0x30000008
34019b00:	3000000a 	.word	0x3000000a
34019b04:	40000002 	.word	0x40000002
34019b08:	40000003 	.word	0x40000003
34019b0c:	40000005 	.word	0x40000005
34019b10:	687b      	ldr	r3, [r7, #4]
34019b12:	4a6d      	ldr	r2, [pc, #436]	@ (34019cc8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x640>)
34019b14:	4293      	cmp	r3, r2
34019b16:	f000 8086 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b1a:	687b      	ldr	r3, [r7, #4]
34019b1c:	4a6b      	ldr	r2, [pc, #428]	@ (34019ccc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x644>)
34019b1e:	4293      	cmp	r3, r2
34019b20:	f000 8081 	beq.w	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b24:	687b      	ldr	r3, [r7, #4]
34019b26:	4a6a      	ldr	r2, [pc, #424]	@ (34019cd0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x648>)
34019b28:	4293      	cmp	r3, r2
34019b2a:	d07c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b2c:	687b      	ldr	r3, [r7, #4]
34019b2e:	4a69      	ldr	r2, [pc, #420]	@ (34019cd4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x64c>)
34019b30:	4293      	cmp	r3, r2
34019b32:	d078      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b34:	687b      	ldr	r3, [r7, #4]
34019b36:	4a68      	ldr	r2, [pc, #416]	@ (34019cd8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x650>)
34019b38:	4293      	cmp	r3, r2
34019b3a:	d074      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b3c:	687b      	ldr	r3, [r7, #4]
34019b3e:	4a67      	ldr	r2, [pc, #412]	@ (34019cdc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x654>)
34019b40:	4293      	cmp	r3, r2
34019b42:	d070      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b44:	687b      	ldr	r3, [r7, #4]
34019b46:	4a66      	ldr	r2, [pc, #408]	@ (34019ce0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x658>)
34019b48:	4293      	cmp	r3, r2
34019b4a:	d06c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b4c:	687b      	ldr	r3, [r7, #4]
34019b4e:	4a65      	ldr	r2, [pc, #404]	@ (34019ce4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x65c>)
34019b50:	4293      	cmp	r3, r2
34019b52:	d068      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b54:	687b      	ldr	r3, [r7, #4]
34019b56:	4a64      	ldr	r2, [pc, #400]	@ (34019ce8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x660>)
34019b58:	4293      	cmp	r3, r2
34019b5a:	d064      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b5c:	687b      	ldr	r3, [r7, #4]
34019b5e:	4a63      	ldr	r2, [pc, #396]	@ (34019cec <HAL_RIF_RISC_SetSlaveSecureAttributes+0x664>)
34019b60:	4293      	cmp	r3, r2
34019b62:	d060      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b64:	687b      	ldr	r3, [r7, #4]
34019b66:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
34019b6a:	d05c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b6c:	687b      	ldr	r3, [r7, #4]
34019b6e:	4a60      	ldr	r2, [pc, #384]	@ (34019cf0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x668>)
34019b70:	4293      	cmp	r3, r2
34019b72:	d058      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b74:	687b      	ldr	r3, [r7, #4]
34019b76:	4a5f      	ldr	r2, [pc, #380]	@ (34019cf4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x66c>)
34019b78:	4293      	cmp	r3, r2
34019b7a:	d054      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b7c:	687b      	ldr	r3, [r7, #4]
34019b7e:	4a5e      	ldr	r2, [pc, #376]	@ (34019cf8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x670>)
34019b80:	4293      	cmp	r3, r2
34019b82:	d050      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b84:	687b      	ldr	r3, [r7, #4]
34019b86:	4a5d      	ldr	r2, [pc, #372]	@ (34019cfc <HAL_RIF_RISC_SetSlaveSecureAttributes+0x674>)
34019b88:	4293      	cmp	r3, r2
34019b8a:	d04c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b8c:	687b      	ldr	r3, [r7, #4]
34019b8e:	4a5c      	ldr	r2, [pc, #368]	@ (34019d00 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x678>)
34019b90:	4293      	cmp	r3, r2
34019b92:	d048      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b94:	687b      	ldr	r3, [r7, #4]
34019b96:	4a5b      	ldr	r2, [pc, #364]	@ (34019d04 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x67c>)
34019b98:	4293      	cmp	r3, r2
34019b9a:	d044      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019b9c:	687b      	ldr	r3, [r7, #4]
34019b9e:	4a5a      	ldr	r2, [pc, #360]	@ (34019d08 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x680>)
34019ba0:	4293      	cmp	r3, r2
34019ba2:	d040      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019ba4:	687b      	ldr	r3, [r7, #4]
34019ba6:	4a59      	ldr	r2, [pc, #356]	@ (34019d0c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x684>)
34019ba8:	4293      	cmp	r3, r2
34019baa:	d03c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bac:	687b      	ldr	r3, [r7, #4]
34019bae:	4a58      	ldr	r2, [pc, #352]	@ (34019d10 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x688>)
34019bb0:	4293      	cmp	r3, r2
34019bb2:	d038      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bb4:	687b      	ldr	r3, [r7, #4]
34019bb6:	4a57      	ldr	r2, [pc, #348]	@ (34019d14 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x68c>)
34019bb8:	4293      	cmp	r3, r2
34019bba:	d034      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bbc:	687b      	ldr	r3, [r7, #4]
34019bbe:	4a56      	ldr	r2, [pc, #344]	@ (34019d18 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x690>)
34019bc0:	4293      	cmp	r3, r2
34019bc2:	d030      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bc4:	687b      	ldr	r3, [r7, #4]
34019bc6:	4a55      	ldr	r2, [pc, #340]	@ (34019d1c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x694>)
34019bc8:	4293      	cmp	r3, r2
34019bca:	d02c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bcc:	687b      	ldr	r3, [r7, #4]
34019bce:	4a54      	ldr	r2, [pc, #336]	@ (34019d20 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x698>)
34019bd0:	4293      	cmp	r3, r2
34019bd2:	d028      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bd4:	687b      	ldr	r3, [r7, #4]
34019bd6:	4a53      	ldr	r2, [pc, #332]	@ (34019d24 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x69c>)
34019bd8:	4293      	cmp	r3, r2
34019bda:	d024      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bdc:	687b      	ldr	r3, [r7, #4]
34019bde:	4a52      	ldr	r2, [pc, #328]	@ (34019d28 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6a0>)
34019be0:	4293      	cmp	r3, r2
34019be2:	d020      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019be4:	687b      	ldr	r3, [r7, #4]
34019be6:	4a51      	ldr	r2, [pc, #324]	@ (34019d2c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6a4>)
34019be8:	4293      	cmp	r3, r2
34019bea:	d01c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bec:	687b      	ldr	r3, [r7, #4]
34019bee:	4a50      	ldr	r2, [pc, #320]	@ (34019d30 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6a8>)
34019bf0:	4293      	cmp	r3, r2
34019bf2:	d018      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bf4:	687b      	ldr	r3, [r7, #4]
34019bf6:	4a4f      	ldr	r2, [pc, #316]	@ (34019d34 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6ac>)
34019bf8:	4293      	cmp	r3, r2
34019bfa:	d014      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019bfc:	687b      	ldr	r3, [r7, #4]
34019bfe:	4a4e      	ldr	r2, [pc, #312]	@ (34019d38 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6b0>)
34019c00:	4293      	cmp	r3, r2
34019c02:	d010      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019c04:	687b      	ldr	r3, [r7, #4]
34019c06:	4a4d      	ldr	r2, [pc, #308]	@ (34019d3c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6b4>)
34019c08:	4293      	cmp	r3, r2
34019c0a:	d00c      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019c0c:	687b      	ldr	r3, [r7, #4]
34019c0e:	4a4c      	ldr	r2, [pc, #304]	@ (34019d40 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6b8>)
34019c10:	4293      	cmp	r3, r2
34019c12:	d008      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019c14:	687b      	ldr	r3, [r7, #4]
34019c16:	4a4b      	ldr	r2, [pc, #300]	@ (34019d44 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6bc>)
34019c18:	4293      	cmp	r3, r2
34019c1a:	d004      	beq.n	34019c26 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x59e>
34019c1c:	f240 1171 	movw	r1, #369	@ 0x171
34019c20:	4849      	ldr	r0, [pc, #292]	@ (34019d48 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c0>)
34019c22:	f7e7 fb39 	bl	34001298 <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));
34019c26:	683b      	ldr	r3, [r7, #0]
34019c28:	2b03      	cmp	r3, #3
34019c2a:	d904      	bls.n	34019c36 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x5ae>
34019c2c:	f44f 71b9 	mov.w	r1, #370	@ 0x172
34019c30:	4845      	ldr	r0, [pc, #276]	@ (34019d48 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c0>)
34019c32:	f7e7 fb31 	bl	34001298 <assert_failed>

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
34019c36:	4a45      	ldr	r2, [pc, #276]	@ (34019d4c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
34019c38:	687b      	ldr	r3, [r7, #4]
34019c3a:	0f1b      	lsrs	r3, r3, #28
34019c3c:	3304      	adds	r3, #4
34019c3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34019c42:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34019c44:	687b      	ldr	r3, [r7, #4]
34019c46:	f003 031f 	and.w	r3, r3, #31
34019c4a:	2201      	movs	r2, #1
34019c4c:	fa02 f303 	lsl.w	r3, r2, r3
34019c50:	43da      	mvns	r2, r3
34019c52:	68fb      	ldr	r3, [r7, #12]
34019c54:	4013      	ands	r3, r2
34019c56:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
34019c58:	683b      	ldr	r3, [r7, #0]
34019c5a:	f003 0201 	and.w	r2, r3, #1
34019c5e:	687b      	ldr	r3, [r7, #4]
34019c60:	f003 031f 	and.w	r3, r3, #31
34019c64:	409a      	lsls	r2, r3
34019c66:	68fb      	ldr	r3, [r7, #12]
34019c68:	4313      	orrs	r3, r2
34019c6a:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34019c6c:	4937      	ldr	r1, [pc, #220]	@ (34019d4c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
34019c6e:	687b      	ldr	r3, [r7, #4]
34019c70:	0f1b      	lsrs	r3, r3, #28
34019c72:	68fa      	ldr	r2, [r7, #12]
34019c74:	3304      	adds	r3, #4
34019c76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
34019c7a:	4a34      	ldr	r2, [pc, #208]	@ (34019d4c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
34019c7c:	687b      	ldr	r3, [r7, #4]
34019c7e:	0f1b      	lsrs	r3, r3, #28
34019c80:	330c      	adds	r3, #12
34019c82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34019c86:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34019c88:	687b      	ldr	r3, [r7, #4]
34019c8a:	f003 031f 	and.w	r3, r3, #31
34019c8e:	2201      	movs	r2, #1
34019c90:	fa02 f303 	lsl.w	r3, r2, r3
34019c94:	43da      	mvns	r2, r3
34019c96:	68fb      	ldr	r3, [r7, #12]
34019c98:	4013      	ands	r3, r2
34019c9a:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
34019c9c:	683b      	ldr	r3, [r7, #0]
34019c9e:	085b      	lsrs	r3, r3, #1
34019ca0:	f003 0201 	and.w	r2, r3, #1
34019ca4:	687b      	ldr	r3, [r7, #4]
34019ca6:	f003 031f 	and.w	r3, r3, #31
34019caa:	409a      	lsls	r2, r3
34019cac:	68fb      	ldr	r3, [r7, #12]
34019cae:	4313      	orrs	r3, r2
34019cb0:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34019cb2:	4926      	ldr	r1, [pc, #152]	@ (34019d4c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x6c4>)
34019cb4:	687b      	ldr	r3, [r7, #4]
34019cb6:	0f1b      	lsrs	r3, r3, #28
34019cb8:	68fa      	ldr	r2, [r7, #12]
34019cba:	330c      	adds	r3, #12
34019cbc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34019cc0:	bf00      	nop
34019cc2:	3710      	adds	r7, #16
34019cc4:	46bd      	mov	sp, r7
34019cc6:	bd80      	pop	{r7, pc}
34019cc8:	4000000c 	.word	0x4000000c
34019ccc:	4000000d 	.word	0x4000000d
34019cd0:	40000011 	.word	0x40000011
34019cd4:	40000012 	.word	0x40000012
34019cd8:	40000013 	.word	0x40000013
34019cdc:	40000019 	.word	0x40000019
34019ce0:	4000001b 	.word	0x4000001b
34019ce4:	4000001c 	.word	0x4000001c
34019ce8:	4000001d 	.word	0x4000001d
34019cec:	4000001f 	.word	0x4000001f
34019cf0:	50000001 	.word	0x50000001
34019cf4:	50000002 	.word	0x50000002
34019cf8:	50000003 	.word	0x50000003
34019cfc:	50000004 	.word	0x50000004
34019d00:	50000005 	.word	0x50000005
34019d04:	50000006 	.word	0x50000006
34019d08:	50000008 	.word	0x50000008
34019d0c:	50000009 	.word	0x50000009
34019d10:	5000000a 	.word	0x5000000a
34019d14:	5000000b 	.word	0x5000000b
34019d18:	5000000d 	.word	0x5000000d
34019d1c:	5000000e 	.word	0x5000000e
34019d20:	5000000f 	.word	0x5000000f
34019d24:	50000011 	.word	0x50000011
34019d28:	50000012 	.word	0x50000012
34019d2c:	50000013 	.word	0x50000013
34019d30:	50000014 	.word	0x50000014
34019d34:	50000016 	.word	0x50000016
34019d38:	50000017 	.word	0x50000017
34019d3c:	50000018 	.word	0x50000018
34019d40:	5000001b 	.word	0x5000001b
34019d44:	5000001e 	.word	0x5000001e
34019d48:	340244c0 	.word	0x340244c0
34019d4c:	54024000 	.word	0x54024000

34019d50 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
34019d50:	b580      	push	{r7, lr}
34019d52:	b082      	sub	sp, #8
34019d54:	af00      	add	r7, sp, #0
34019d56:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
34019d58:	687b      	ldr	r3, [r7, #4]
34019d5a:	2b00      	cmp	r3, #0
34019d5c:	d101      	bne.n	34019d62 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
34019d5e:	2301      	movs	r3, #1
34019d60:	e16e      	b.n	3401a040 <HAL_UART_Init+0x2f0>
  }

  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
34019d62:	687b      	ldr	r3, [r7, #4]
34019d64:	699b      	ldr	r3, [r3, #24]
34019d66:	2b00      	cmp	r3, #0
34019d68:	f000 8088 	beq.w	34019e7c <HAL_UART_Init+0x12c>
  {
    /* Check the parameters */
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
34019d6c:	687b      	ldr	r3, [r7, #4]
34019d6e:	681b      	ldr	r3, [r3, #0]
34019d70:	4a8f      	ldr	r2, [pc, #572]	@ (34019fb0 <HAL_UART_Init+0x260>)
34019d72:	4293      	cmp	r3, r2
34019d74:	f000 80f5 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019d78:	687b      	ldr	r3, [r7, #4]
34019d7a:	681b      	ldr	r3, [r3, #0]
34019d7c:	4a8d      	ldr	r2, [pc, #564]	@ (34019fb4 <HAL_UART_Init+0x264>)
34019d7e:	4293      	cmp	r3, r2
34019d80:	f000 80ef 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019d84:	687b      	ldr	r3, [r7, #4]
34019d86:	681b      	ldr	r3, [r3, #0]
34019d88:	4a8b      	ldr	r2, [pc, #556]	@ (34019fb8 <HAL_UART_Init+0x268>)
34019d8a:	4293      	cmp	r3, r2
34019d8c:	f000 80e9 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019d90:	687b      	ldr	r3, [r7, #4]
34019d92:	681b      	ldr	r3, [r3, #0]
34019d94:	4a89      	ldr	r2, [pc, #548]	@ (34019fbc <HAL_UART_Init+0x26c>)
34019d96:	4293      	cmp	r3, r2
34019d98:	f000 80e3 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019d9c:	687b      	ldr	r3, [r7, #4]
34019d9e:	681b      	ldr	r3, [r3, #0]
34019da0:	4a87      	ldr	r2, [pc, #540]	@ (34019fc0 <HAL_UART_Init+0x270>)
34019da2:	4293      	cmp	r3, r2
34019da4:	f000 80dd 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019da8:	687b      	ldr	r3, [r7, #4]
34019daa:	681b      	ldr	r3, [r3, #0]
34019dac:	4a85      	ldr	r2, [pc, #532]	@ (34019fc4 <HAL_UART_Init+0x274>)
34019dae:	4293      	cmp	r3, r2
34019db0:	f000 80d7 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019db4:	687b      	ldr	r3, [r7, #4]
34019db6:	681b      	ldr	r3, [r3, #0]
34019db8:	4a83      	ldr	r2, [pc, #524]	@ (34019fc8 <HAL_UART_Init+0x278>)
34019dba:	4293      	cmp	r3, r2
34019dbc:	f000 80d1 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019dc0:	687b      	ldr	r3, [r7, #4]
34019dc2:	681b      	ldr	r3, [r3, #0]
34019dc4:	4a81      	ldr	r2, [pc, #516]	@ (34019fcc <HAL_UART_Init+0x27c>)
34019dc6:	4293      	cmp	r3, r2
34019dc8:	f000 80cb 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019dcc:	687b      	ldr	r3, [r7, #4]
34019dce:	681b      	ldr	r3, [r3, #0]
34019dd0:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34019dd4:	f000 80c5 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019dd8:	687b      	ldr	r3, [r7, #4]
34019dda:	681b      	ldr	r3, [r3, #0]
34019ddc:	4a7c      	ldr	r2, [pc, #496]	@ (34019fd0 <HAL_UART_Init+0x280>)
34019dde:	4293      	cmp	r3, r2
34019de0:	f000 80bf 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019de4:	687b      	ldr	r3, [r7, #4]
34019de6:	681b      	ldr	r3, [r3, #0]
34019de8:	4a7a      	ldr	r2, [pc, #488]	@ (34019fd4 <HAL_UART_Init+0x284>)
34019dea:	4293      	cmp	r3, r2
34019dec:	f000 80b9 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019df0:	687b      	ldr	r3, [r7, #4]
34019df2:	681b      	ldr	r3, [r3, #0]
34019df4:	4a78      	ldr	r2, [pc, #480]	@ (34019fd8 <HAL_UART_Init+0x288>)
34019df6:	4293      	cmp	r3, r2
34019df8:	f000 80b3 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019dfc:	687b      	ldr	r3, [r7, #4]
34019dfe:	681b      	ldr	r3, [r3, #0]
34019e00:	4a76      	ldr	r2, [pc, #472]	@ (34019fdc <HAL_UART_Init+0x28c>)
34019e02:	4293      	cmp	r3, r2
34019e04:	f000 80ad 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e08:	687b      	ldr	r3, [r7, #4]
34019e0a:	681b      	ldr	r3, [r3, #0]
34019e0c:	4a74      	ldr	r2, [pc, #464]	@ (34019fe0 <HAL_UART_Init+0x290>)
34019e0e:	4293      	cmp	r3, r2
34019e10:	f000 80a7 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e14:	687b      	ldr	r3, [r7, #4]
34019e16:	681b      	ldr	r3, [r3, #0]
34019e18:	4a72      	ldr	r2, [pc, #456]	@ (34019fe4 <HAL_UART_Init+0x294>)
34019e1a:	4293      	cmp	r3, r2
34019e1c:	f000 80a1 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e20:	687b      	ldr	r3, [r7, #4]
34019e22:	681b      	ldr	r3, [r3, #0]
34019e24:	4a70      	ldr	r2, [pc, #448]	@ (34019fe8 <HAL_UART_Init+0x298>)
34019e26:	4293      	cmp	r3, r2
34019e28:	f000 809b 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e2c:	687b      	ldr	r3, [r7, #4]
34019e2e:	681b      	ldr	r3, [r3, #0]
34019e30:	4a6e      	ldr	r2, [pc, #440]	@ (34019fec <HAL_UART_Init+0x29c>)
34019e32:	4293      	cmp	r3, r2
34019e34:	f000 8095 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e38:	687b      	ldr	r3, [r7, #4]
34019e3a:	681b      	ldr	r3, [r3, #0]
34019e3c:	4a6c      	ldr	r2, [pc, #432]	@ (34019ff0 <HAL_UART_Init+0x2a0>)
34019e3e:	4293      	cmp	r3, r2
34019e40:	f000 808f 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e44:	687b      	ldr	r3, [r7, #4]
34019e46:	681b      	ldr	r3, [r3, #0]
34019e48:	4a6a      	ldr	r2, [pc, #424]	@ (34019ff4 <HAL_UART_Init+0x2a4>)
34019e4a:	4293      	cmp	r3, r2
34019e4c:	f000 8089 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e50:	687b      	ldr	r3, [r7, #4]
34019e52:	681b      	ldr	r3, [r3, #0]
34019e54:	4a68      	ldr	r2, [pc, #416]	@ (34019ff8 <HAL_UART_Init+0x2a8>)
34019e56:	4293      	cmp	r3, r2
34019e58:	f000 8083 	beq.w	34019f62 <HAL_UART_Init+0x212>
34019e5c:	687b      	ldr	r3, [r7, #4]
34019e5e:	681b      	ldr	r3, [r3, #0]
34019e60:	4a66      	ldr	r2, [pc, #408]	@ (34019ffc <HAL_UART_Init+0x2ac>)
34019e62:	4293      	cmp	r3, r2
34019e64:	d07d      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019e66:	687b      	ldr	r3, [r7, #4]
34019e68:	681b      	ldr	r3, [r3, #0]
34019e6a:	4a65      	ldr	r2, [pc, #404]	@ (3401a000 <HAL_UART_Init+0x2b0>)
34019e6c:	4293      	cmp	r3, r2
34019e6e:	d078      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019e70:	f44f 71a0 	mov.w	r1, #320	@ 0x140
34019e74:	4863      	ldr	r0, [pc, #396]	@ (3401a004 <HAL_UART_Init+0x2b4>)
34019e76:	f7e7 fa0f 	bl	34001298 <assert_failed>
34019e7a:	e072      	b.n	34019f62 <HAL_UART_Init+0x212>
  }
  else
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
34019e7c:	687b      	ldr	r3, [r7, #4]
34019e7e:	681b      	ldr	r3, [r3, #0]
34019e80:	4a4b      	ldr	r2, [pc, #300]	@ (34019fb0 <HAL_UART_Init+0x260>)
34019e82:	4293      	cmp	r3, r2
34019e84:	d06d      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019e86:	687b      	ldr	r3, [r7, #4]
34019e88:	681b      	ldr	r3, [r3, #0]
34019e8a:	4a4a      	ldr	r2, [pc, #296]	@ (34019fb4 <HAL_UART_Init+0x264>)
34019e8c:	4293      	cmp	r3, r2
34019e8e:	d068      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019e90:	687b      	ldr	r3, [r7, #4]
34019e92:	681b      	ldr	r3, [r3, #0]
34019e94:	4a48      	ldr	r2, [pc, #288]	@ (34019fb8 <HAL_UART_Init+0x268>)
34019e96:	4293      	cmp	r3, r2
34019e98:	d063      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019e9a:	687b      	ldr	r3, [r7, #4]
34019e9c:	681b      	ldr	r3, [r3, #0]
34019e9e:	4a47      	ldr	r2, [pc, #284]	@ (34019fbc <HAL_UART_Init+0x26c>)
34019ea0:	4293      	cmp	r3, r2
34019ea2:	d05e      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019ea4:	687b      	ldr	r3, [r7, #4]
34019ea6:	681b      	ldr	r3, [r3, #0]
34019ea8:	4a45      	ldr	r2, [pc, #276]	@ (34019fc0 <HAL_UART_Init+0x270>)
34019eaa:	4293      	cmp	r3, r2
34019eac:	d059      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019eae:	687b      	ldr	r3, [r7, #4]
34019eb0:	681b      	ldr	r3, [r3, #0]
34019eb2:	4a44      	ldr	r2, [pc, #272]	@ (34019fc4 <HAL_UART_Init+0x274>)
34019eb4:	4293      	cmp	r3, r2
34019eb6:	d054      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019eb8:	687b      	ldr	r3, [r7, #4]
34019eba:	681b      	ldr	r3, [r3, #0]
34019ebc:	4a42      	ldr	r2, [pc, #264]	@ (34019fc8 <HAL_UART_Init+0x278>)
34019ebe:	4293      	cmp	r3, r2
34019ec0:	d04f      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019ec2:	687b      	ldr	r3, [r7, #4]
34019ec4:	681b      	ldr	r3, [r3, #0]
34019ec6:	4a41      	ldr	r2, [pc, #260]	@ (34019fcc <HAL_UART_Init+0x27c>)
34019ec8:	4293      	cmp	r3, r2
34019eca:	d04a      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019ecc:	687b      	ldr	r3, [r7, #4]
34019ece:	681b      	ldr	r3, [r3, #0]
34019ed0:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
34019ed4:	d045      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019ed6:	687b      	ldr	r3, [r7, #4]
34019ed8:	681b      	ldr	r3, [r3, #0]
34019eda:	4a3d      	ldr	r2, [pc, #244]	@ (34019fd0 <HAL_UART_Init+0x280>)
34019edc:	4293      	cmp	r3, r2
34019ede:	d040      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019ee0:	687b      	ldr	r3, [r7, #4]
34019ee2:	681b      	ldr	r3, [r3, #0]
34019ee4:	4a3b      	ldr	r2, [pc, #236]	@ (34019fd4 <HAL_UART_Init+0x284>)
34019ee6:	4293      	cmp	r3, r2
34019ee8:	d03b      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019eea:	687b      	ldr	r3, [r7, #4]
34019eec:	681b      	ldr	r3, [r3, #0]
34019eee:	4a3a      	ldr	r2, [pc, #232]	@ (34019fd8 <HAL_UART_Init+0x288>)
34019ef0:	4293      	cmp	r3, r2
34019ef2:	d036      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019ef4:	687b      	ldr	r3, [r7, #4]
34019ef6:	681b      	ldr	r3, [r3, #0]
34019ef8:	4a38      	ldr	r2, [pc, #224]	@ (34019fdc <HAL_UART_Init+0x28c>)
34019efa:	4293      	cmp	r3, r2
34019efc:	d031      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019efe:	687b      	ldr	r3, [r7, #4]
34019f00:	681b      	ldr	r3, [r3, #0]
34019f02:	4a37      	ldr	r2, [pc, #220]	@ (34019fe0 <HAL_UART_Init+0x290>)
34019f04:	4293      	cmp	r3, r2
34019f06:	d02c      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f08:	687b      	ldr	r3, [r7, #4]
34019f0a:	681b      	ldr	r3, [r3, #0]
34019f0c:	4a35      	ldr	r2, [pc, #212]	@ (34019fe4 <HAL_UART_Init+0x294>)
34019f0e:	4293      	cmp	r3, r2
34019f10:	d027      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f12:	687b      	ldr	r3, [r7, #4]
34019f14:	681b      	ldr	r3, [r3, #0]
34019f16:	4a34      	ldr	r2, [pc, #208]	@ (34019fe8 <HAL_UART_Init+0x298>)
34019f18:	4293      	cmp	r3, r2
34019f1a:	d022      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f1c:	687b      	ldr	r3, [r7, #4]
34019f1e:	681b      	ldr	r3, [r3, #0]
34019f20:	4a32      	ldr	r2, [pc, #200]	@ (34019fec <HAL_UART_Init+0x29c>)
34019f22:	4293      	cmp	r3, r2
34019f24:	d01d      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f26:	687b      	ldr	r3, [r7, #4]
34019f28:	681b      	ldr	r3, [r3, #0]
34019f2a:	4a31      	ldr	r2, [pc, #196]	@ (34019ff0 <HAL_UART_Init+0x2a0>)
34019f2c:	4293      	cmp	r3, r2
34019f2e:	d018      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f30:	687b      	ldr	r3, [r7, #4]
34019f32:	681b      	ldr	r3, [r3, #0]
34019f34:	4a2f      	ldr	r2, [pc, #188]	@ (34019ff4 <HAL_UART_Init+0x2a4>)
34019f36:	4293      	cmp	r3, r2
34019f38:	d013      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f3a:	687b      	ldr	r3, [r7, #4]
34019f3c:	681b      	ldr	r3, [r3, #0]
34019f3e:	4a2e      	ldr	r2, [pc, #184]	@ (34019ff8 <HAL_UART_Init+0x2a8>)
34019f40:	4293      	cmp	r3, r2
34019f42:	d00e      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f44:	687b      	ldr	r3, [r7, #4]
34019f46:	681b      	ldr	r3, [r3, #0]
34019f48:	4a2c      	ldr	r2, [pc, #176]	@ (34019ffc <HAL_UART_Init+0x2ac>)
34019f4a:	4293      	cmp	r3, r2
34019f4c:	d009      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f4e:	687b      	ldr	r3, [r7, #4]
34019f50:	681b      	ldr	r3, [r3, #0]
34019f52:	4a2b      	ldr	r2, [pc, #172]	@ (3401a000 <HAL_UART_Init+0x2b0>)
34019f54:	4293      	cmp	r3, r2
34019f56:	d004      	beq.n	34019f62 <HAL_UART_Init+0x212>
34019f58:	f240 1145 	movw	r1, #325	@ 0x145
34019f5c:	4829      	ldr	r0, [pc, #164]	@ (3401a004 <HAL_UART_Init+0x2b4>)
34019f5e:	f7e7 f99b 	bl	34001298 <assert_failed>
  }

  if (huart->gState == HAL_UART_STATE_RESET)
34019f62:	687b      	ldr	r3, [r7, #4]
34019f64:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34019f68:	2b00      	cmp	r3, #0
34019f6a:	d106      	bne.n	34019f7a <HAL_UART_Init+0x22a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
34019f6c:	687b      	ldr	r3, [r7, #4]
34019f6e:	2200      	movs	r2, #0
34019f70:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
34019f74:	6878      	ldr	r0, [r7, #4]
34019f76:	f000 f867 	bl	3401a048 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
34019f7a:	687b      	ldr	r3, [r7, #4]
34019f7c:	2224      	movs	r2, #36	@ 0x24
34019f7e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
34019f82:	687b      	ldr	r3, [r7, #4]
34019f84:	681b      	ldr	r3, [r3, #0]
34019f86:	681a      	ldr	r2, [r3, #0]
34019f88:	687b      	ldr	r3, [r7, #4]
34019f8a:	681b      	ldr	r3, [r3, #0]
34019f8c:	f022 0201 	bic.w	r2, r2, #1
34019f90:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
34019f92:	687b      	ldr	r3, [r7, #4]
34019f94:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34019f96:	2b00      	cmp	r3, #0
34019f98:	d002      	beq.n	34019fa0 <HAL_UART_Init+0x250>
  {
    UART_AdvFeatureConfig(huart);
34019f9a:	6878      	ldr	r0, [r7, #4]
34019f9c:	f000 fc80 	bl	3401a8a0 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
34019fa0:	6878      	ldr	r0, [r7, #4]
34019fa2:	f000 f9b1 	bl	3401a308 <UART_SetConfig>
34019fa6:	4603      	mov	r3, r0
34019fa8:	2b01      	cmp	r3, #1
34019faa:	d12d      	bne.n	3401a008 <HAL_UART_Init+0x2b8>
  {
    return HAL_ERROR;
34019fac:	2301      	movs	r3, #1
34019fae:	e047      	b.n	3401a040 <HAL_UART_Init+0x2f0>
34019fb0:	52001000 	.word	0x52001000
34019fb4:	42001000 	.word	0x42001000
34019fb8:	50004400 	.word	0x50004400
34019fbc:	40004400 	.word	0x40004400
34019fc0:	50004800 	.word	0x50004800
34019fc4:	40004800 	.word	0x40004800
34019fc8:	50004c00 	.word	0x50004c00
34019fcc:	40004c00 	.word	0x40004c00
34019fd0:	40005000 	.word	0x40005000
34019fd4:	52001400 	.word	0x52001400
34019fd8:	42001400 	.word	0x42001400
34019fdc:	50007800 	.word	0x50007800
34019fe0:	40007800 	.word	0x40007800
34019fe4:	50007c00 	.word	0x50007c00
34019fe8:	40007c00 	.word	0x40007c00
34019fec:	52001800 	.word	0x52001800
34019ff0:	42001800 	.word	0x42001800
34019ff4:	52001c00 	.word	0x52001c00
34019ff8:	42001c00 	.word	0x42001c00
34019ffc:	56000c00 	.word	0x56000c00
3401a000:	46000c00 	.word	0x46000c00
3401a004:	34024530 	.word	0x34024530
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
3401a008:	687b      	ldr	r3, [r7, #4]
3401a00a:	681b      	ldr	r3, [r3, #0]
3401a00c:	685a      	ldr	r2, [r3, #4]
3401a00e:	687b      	ldr	r3, [r7, #4]
3401a010:	681b      	ldr	r3, [r3, #0]
3401a012:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
3401a016:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
3401a018:	687b      	ldr	r3, [r7, #4]
3401a01a:	681b      	ldr	r3, [r3, #0]
3401a01c:	689a      	ldr	r2, [r3, #8]
3401a01e:	687b      	ldr	r3, [r7, #4]
3401a020:	681b      	ldr	r3, [r3, #0]
3401a022:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
3401a026:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
3401a028:	687b      	ldr	r3, [r7, #4]
3401a02a:	681b      	ldr	r3, [r3, #0]
3401a02c:	681a      	ldr	r2, [r3, #0]
3401a02e:	687b      	ldr	r3, [r7, #4]
3401a030:	681b      	ldr	r3, [r3, #0]
3401a032:	f042 0201 	orr.w	r2, r2, #1
3401a036:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
3401a038:	6878      	ldr	r0, [r7, #4]
3401a03a:	f000 fdfb 	bl	3401ac34 <UART_CheckIdleState>
3401a03e:	4603      	mov	r3, r0
}
3401a040:	4618      	mov	r0, r3
3401a042:	3708      	adds	r7, #8
3401a044:	46bd      	mov	sp, r7
3401a046:	bd80      	pop	{r7, pc}

3401a048 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
3401a048:	b480      	push	{r7}
3401a04a:	b083      	sub	sp, #12
3401a04c:	af00      	add	r7, sp, #0
3401a04e:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
3401a050:	bf00      	nop
3401a052:	370c      	adds	r7, #12
3401a054:	46bd      	mov	sp, r7
3401a056:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a05a:	4770      	bx	lr

3401a05c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
3401a05c:	b580      	push	{r7, lr}
3401a05e:	b08a      	sub	sp, #40	@ 0x28
3401a060:	af02      	add	r7, sp, #8
3401a062:	60f8      	str	r0, [r7, #12]
3401a064:	60b9      	str	r1, [r7, #8]
3401a066:	603b      	str	r3, [r7, #0]
3401a068:	4613      	mov	r3, r2
3401a06a:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
3401a06c:	68fb      	ldr	r3, [r7, #12]
3401a06e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3401a072:	2b20      	cmp	r3, #32
3401a074:	d17b      	bne.n	3401a16e <HAL_UART_Transmit+0x112>
  {
    if ((pData == NULL) || (Size == 0U))
3401a076:	68bb      	ldr	r3, [r7, #8]
3401a078:	2b00      	cmp	r3, #0
3401a07a:	d002      	beq.n	3401a082 <HAL_UART_Transmit+0x26>
3401a07c:	88fb      	ldrh	r3, [r7, #6]
3401a07e:	2b00      	cmp	r3, #0
3401a080:	d101      	bne.n	3401a086 <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
3401a082:	2301      	movs	r3, #1
3401a084:	e074      	b.n	3401a170 <HAL_UART_Transmit+0x114>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
3401a086:	68fb      	ldr	r3, [r7, #12]
3401a088:	2200      	movs	r2, #0
3401a08a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
3401a08e:	68fb      	ldr	r3, [r7, #12]
3401a090:	2221      	movs	r2, #33	@ 0x21
3401a092:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
3401a096:	f7ed faa3 	bl	340075e0 <HAL_GetTick>
3401a09a:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
3401a09c:	68fb      	ldr	r3, [r7, #12]
3401a09e:	88fa      	ldrh	r2, [r7, #6]
3401a0a0:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
3401a0a4:	68fb      	ldr	r3, [r7, #12]
3401a0a6:	88fa      	ldrh	r2, [r7, #6]
3401a0a8:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3401a0ac:	68fb      	ldr	r3, [r7, #12]
3401a0ae:	689b      	ldr	r3, [r3, #8]
3401a0b0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401a0b4:	d108      	bne.n	3401a0c8 <HAL_UART_Transmit+0x6c>
3401a0b6:	68fb      	ldr	r3, [r7, #12]
3401a0b8:	691b      	ldr	r3, [r3, #16]
3401a0ba:	2b00      	cmp	r3, #0
3401a0bc:	d104      	bne.n	3401a0c8 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
3401a0be:	2300      	movs	r3, #0
3401a0c0:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
3401a0c2:	68bb      	ldr	r3, [r7, #8]
3401a0c4:	61bb      	str	r3, [r7, #24]
3401a0c6:	e003      	b.n	3401a0d0 <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
3401a0c8:	68bb      	ldr	r3, [r7, #8]
3401a0ca:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
3401a0cc:	2300      	movs	r3, #0
3401a0ce:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
3401a0d0:	e030      	b.n	3401a134 <HAL_UART_Transmit+0xd8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3401a0d2:	683b      	ldr	r3, [r7, #0]
3401a0d4:	9300      	str	r3, [sp, #0]
3401a0d6:	697b      	ldr	r3, [r7, #20]
3401a0d8:	2200      	movs	r2, #0
3401a0da:	2180      	movs	r1, #128	@ 0x80
3401a0dc:	68f8      	ldr	r0, [r7, #12]
3401a0de:	f000 fe53 	bl	3401ad88 <UART_WaitOnFlagUntilTimeout>
3401a0e2:	4603      	mov	r3, r0
3401a0e4:	2b00      	cmp	r3, #0
3401a0e6:	d005      	beq.n	3401a0f4 <HAL_UART_Transmit+0x98>
      {

        huart->gState = HAL_UART_STATE_READY;
3401a0e8:	68fb      	ldr	r3, [r7, #12]
3401a0ea:	2220      	movs	r2, #32
3401a0ec:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
3401a0f0:	2303      	movs	r3, #3
3401a0f2:	e03d      	b.n	3401a170 <HAL_UART_Transmit+0x114>
      }
      if (pdata8bits == NULL)
3401a0f4:	69fb      	ldr	r3, [r7, #28]
3401a0f6:	2b00      	cmp	r3, #0
3401a0f8:	d10b      	bne.n	3401a112 <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
3401a0fa:	69bb      	ldr	r3, [r7, #24]
3401a0fc:	881b      	ldrh	r3, [r3, #0]
3401a0fe:	461a      	mov	r2, r3
3401a100:	68fb      	ldr	r3, [r7, #12]
3401a102:	681b      	ldr	r3, [r3, #0]
3401a104:	f3c2 0208 	ubfx	r2, r2, #0, #9
3401a108:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
3401a10a:	69bb      	ldr	r3, [r7, #24]
3401a10c:	3302      	adds	r3, #2
3401a10e:	61bb      	str	r3, [r7, #24]
3401a110:	e007      	b.n	3401a122 <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
3401a112:	69fb      	ldr	r3, [r7, #28]
3401a114:	781a      	ldrb	r2, [r3, #0]
3401a116:	68fb      	ldr	r3, [r7, #12]
3401a118:	681b      	ldr	r3, [r3, #0]
3401a11a:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
3401a11c:	69fb      	ldr	r3, [r7, #28]
3401a11e:	3301      	adds	r3, #1
3401a120:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
3401a122:	68fb      	ldr	r3, [r7, #12]
3401a124:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
3401a128:	b29b      	uxth	r3, r3
3401a12a:	3b01      	subs	r3, #1
3401a12c:	b29a      	uxth	r2, r3
3401a12e:	68fb      	ldr	r3, [r7, #12]
3401a130:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
3401a134:	68fb      	ldr	r3, [r7, #12]
3401a136:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
3401a13a:	b29b      	uxth	r3, r3
3401a13c:	2b00      	cmp	r3, #0
3401a13e:	d1c8      	bne.n	3401a0d2 <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
3401a140:	683b      	ldr	r3, [r7, #0]
3401a142:	9300      	str	r3, [sp, #0]
3401a144:	697b      	ldr	r3, [r7, #20]
3401a146:	2200      	movs	r2, #0
3401a148:	2140      	movs	r1, #64	@ 0x40
3401a14a:	68f8      	ldr	r0, [r7, #12]
3401a14c:	f000 fe1c 	bl	3401ad88 <UART_WaitOnFlagUntilTimeout>
3401a150:	4603      	mov	r3, r0
3401a152:	2b00      	cmp	r3, #0
3401a154:	d005      	beq.n	3401a162 <HAL_UART_Transmit+0x106>
    {
      huart->gState = HAL_UART_STATE_READY;
3401a156:	68fb      	ldr	r3, [r7, #12]
3401a158:	2220      	movs	r2, #32
3401a15a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
3401a15e:	2303      	movs	r3, #3
3401a160:	e006      	b.n	3401a170 <HAL_UART_Transmit+0x114>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
3401a162:	68fb      	ldr	r3, [r7, #12]
3401a164:	2220      	movs	r2, #32
3401a166:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
3401a16a:	2300      	movs	r3, #0
3401a16c:	e000      	b.n	3401a170 <HAL_UART_Transmit+0x114>
  }
  else
  {
    return HAL_BUSY;
3401a16e:	2302      	movs	r3, #2
  }
}
3401a170:	4618      	mov	r0, r3
3401a172:	3720      	adds	r7, #32
3401a174:	46bd      	mov	sp, r7
3401a176:	bd80      	pop	{r7, pc}

3401a178 <HAL_UART_Receive>:
  * @param Size    Amount of data elements (u8 or u16) to be received.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
3401a178:	b580      	push	{r7, lr}
3401a17a:	b08a      	sub	sp, #40	@ 0x28
3401a17c:	af02      	add	r7, sp, #8
3401a17e:	60f8      	str	r0, [r7, #12]
3401a180:	60b9      	str	r1, [r7, #8]
3401a182:	603b      	str	r3, [r7, #0]
3401a184:	4613      	mov	r3, r2
3401a186:	80fb      	strh	r3, [r7, #6]
  uint16_t *pdata16bits;
  uint16_t uhMask;
  uint32_t tickstart;

  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
3401a188:	68fb      	ldr	r3, [r7, #12]
3401a18a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3401a18e:	2b20      	cmp	r3, #32
3401a190:	f040 80b5 	bne.w	3401a2fe <HAL_UART_Receive+0x186>
  {
    if ((pData == NULL) || (Size == 0U))
3401a194:	68bb      	ldr	r3, [r7, #8]
3401a196:	2b00      	cmp	r3, #0
3401a198:	d002      	beq.n	3401a1a0 <HAL_UART_Receive+0x28>
3401a19a:	88fb      	ldrh	r3, [r7, #6]
3401a19c:	2b00      	cmp	r3, #0
3401a19e:	d101      	bne.n	3401a1a4 <HAL_UART_Receive+0x2c>
    {
      return  HAL_ERROR;
3401a1a0:	2301      	movs	r3, #1
3401a1a2:	e0ad      	b.n	3401a300 <HAL_UART_Receive+0x188>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
3401a1a4:	68fb      	ldr	r3, [r7, #12]
3401a1a6:	2200      	movs	r2, #0
3401a1a8:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->RxState = HAL_UART_STATE_BUSY_RX;
3401a1ac:	68fb      	ldr	r3, [r7, #12]
3401a1ae:	2222      	movs	r2, #34	@ 0x22
3401a1b0:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3401a1b4:	68fb      	ldr	r3, [r7, #12]
3401a1b6:	2200      	movs	r2, #0
3401a1b8:	66da      	str	r2, [r3, #108]	@ 0x6c

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
3401a1ba:	f7ed fa11 	bl	340075e0 <HAL_GetTick>
3401a1be:	6178      	str	r0, [r7, #20]

    huart->RxXferSize  = Size;
3401a1c0:	68fb      	ldr	r3, [r7, #12]
3401a1c2:	88fa      	ldrh	r2, [r7, #6]
3401a1c4:	f8a3 205c 	strh.w	r2, [r3, #92]	@ 0x5c
    huart->RxXferCount = Size;
3401a1c8:	68fb      	ldr	r3, [r7, #12]
3401a1ca:	88fa      	ldrh	r2, [r7, #6]
3401a1cc:	f8a3 205e 	strh.w	r2, [r3, #94]	@ 0x5e

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
3401a1d0:	68fb      	ldr	r3, [r7, #12]
3401a1d2:	689b      	ldr	r3, [r3, #8]
3401a1d4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401a1d8:	d10e      	bne.n	3401a1f8 <HAL_UART_Receive+0x80>
3401a1da:	68fb      	ldr	r3, [r7, #12]
3401a1dc:	691b      	ldr	r3, [r3, #16]
3401a1de:	2b00      	cmp	r3, #0
3401a1e0:	d105      	bne.n	3401a1ee <HAL_UART_Receive+0x76>
3401a1e2:	68fb      	ldr	r3, [r7, #12]
3401a1e4:	f240 12ff 	movw	r2, #511	@ 0x1ff
3401a1e8:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
3401a1ec:	e02d      	b.n	3401a24a <HAL_UART_Receive+0xd2>
3401a1ee:	68fb      	ldr	r3, [r7, #12]
3401a1f0:	22ff      	movs	r2, #255	@ 0xff
3401a1f2:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
3401a1f6:	e028      	b.n	3401a24a <HAL_UART_Receive+0xd2>
3401a1f8:	68fb      	ldr	r3, [r7, #12]
3401a1fa:	689b      	ldr	r3, [r3, #8]
3401a1fc:	2b00      	cmp	r3, #0
3401a1fe:	d10d      	bne.n	3401a21c <HAL_UART_Receive+0xa4>
3401a200:	68fb      	ldr	r3, [r7, #12]
3401a202:	691b      	ldr	r3, [r3, #16]
3401a204:	2b00      	cmp	r3, #0
3401a206:	d104      	bne.n	3401a212 <HAL_UART_Receive+0x9a>
3401a208:	68fb      	ldr	r3, [r7, #12]
3401a20a:	22ff      	movs	r2, #255	@ 0xff
3401a20c:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
3401a210:	e01b      	b.n	3401a24a <HAL_UART_Receive+0xd2>
3401a212:	68fb      	ldr	r3, [r7, #12]
3401a214:	227f      	movs	r2, #127	@ 0x7f
3401a216:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
3401a21a:	e016      	b.n	3401a24a <HAL_UART_Receive+0xd2>
3401a21c:	68fb      	ldr	r3, [r7, #12]
3401a21e:	689b      	ldr	r3, [r3, #8]
3401a220:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401a224:	d10d      	bne.n	3401a242 <HAL_UART_Receive+0xca>
3401a226:	68fb      	ldr	r3, [r7, #12]
3401a228:	691b      	ldr	r3, [r3, #16]
3401a22a:	2b00      	cmp	r3, #0
3401a22c:	d104      	bne.n	3401a238 <HAL_UART_Receive+0xc0>
3401a22e:	68fb      	ldr	r3, [r7, #12]
3401a230:	227f      	movs	r2, #127	@ 0x7f
3401a232:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
3401a236:	e008      	b.n	3401a24a <HAL_UART_Receive+0xd2>
3401a238:	68fb      	ldr	r3, [r7, #12]
3401a23a:	223f      	movs	r2, #63	@ 0x3f
3401a23c:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
3401a240:	e003      	b.n	3401a24a <HAL_UART_Receive+0xd2>
3401a242:	68fb      	ldr	r3, [r7, #12]
3401a244:	2200      	movs	r2, #0
3401a246:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60
    uhMask = huart->Mask;
3401a24a:	68fb      	ldr	r3, [r7, #12]
3401a24c:	f8b3 3060 	ldrh.w	r3, [r3, #96]	@ 0x60
3401a250:	827b      	strh	r3, [r7, #18]

    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3401a252:	68fb      	ldr	r3, [r7, #12]
3401a254:	689b      	ldr	r3, [r3, #8]
3401a256:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401a25a:	d108      	bne.n	3401a26e <HAL_UART_Receive+0xf6>
3401a25c:	68fb      	ldr	r3, [r7, #12]
3401a25e:	691b      	ldr	r3, [r3, #16]
3401a260:	2b00      	cmp	r3, #0
3401a262:	d104      	bne.n	3401a26e <HAL_UART_Receive+0xf6>
    {
      pdata8bits  = NULL;
3401a264:	2300      	movs	r3, #0
3401a266:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
3401a268:	68bb      	ldr	r3, [r7, #8]
3401a26a:	61bb      	str	r3, [r7, #24]
3401a26c:	e003      	b.n	3401a276 <HAL_UART_Receive+0xfe>
    }
    else
    {
      pdata8bits  = pData;
3401a26e:	68bb      	ldr	r3, [r7, #8]
3401a270:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
3401a272:	2300      	movs	r3, #0
3401a274:	61bb      	str	r3, [r7, #24]
    }

    /* as long as data have to be received */
    while (huart->RxXferCount > 0U)
3401a276:	e036      	b.n	3401a2e6 <HAL_UART_Receive+0x16e>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
3401a278:	683b      	ldr	r3, [r7, #0]
3401a27a:	9300      	str	r3, [sp, #0]
3401a27c:	697b      	ldr	r3, [r7, #20]
3401a27e:	2200      	movs	r2, #0
3401a280:	2120      	movs	r1, #32
3401a282:	68f8      	ldr	r0, [r7, #12]
3401a284:	f000 fd80 	bl	3401ad88 <UART_WaitOnFlagUntilTimeout>
3401a288:	4603      	mov	r3, r0
3401a28a:	2b00      	cmp	r3, #0
3401a28c:	d005      	beq.n	3401a29a <HAL_UART_Receive+0x122>
      {
        huart->RxState = HAL_UART_STATE_READY;
3401a28e:	68fb      	ldr	r3, [r7, #12]
3401a290:	2220      	movs	r2, #32
3401a292:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

        return HAL_TIMEOUT;
3401a296:	2303      	movs	r3, #3
3401a298:	e032      	b.n	3401a300 <HAL_UART_Receive+0x188>
      }
      if (pdata8bits == NULL)
3401a29a:	69fb      	ldr	r3, [r7, #28]
3401a29c:	2b00      	cmp	r3, #0
3401a29e:	d10c      	bne.n	3401a2ba <HAL_UART_Receive+0x142>
      {
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
3401a2a0:	68fb      	ldr	r3, [r7, #12]
3401a2a2:	681b      	ldr	r3, [r3, #0]
3401a2a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a2a6:	b29a      	uxth	r2, r3
3401a2a8:	8a7b      	ldrh	r3, [r7, #18]
3401a2aa:	4013      	ands	r3, r2
3401a2ac:	b29a      	uxth	r2, r3
3401a2ae:	69bb      	ldr	r3, [r7, #24]
3401a2b0:	801a      	strh	r2, [r3, #0]
        pdata16bits++;
3401a2b2:	69bb      	ldr	r3, [r7, #24]
3401a2b4:	3302      	adds	r3, #2
3401a2b6:	61bb      	str	r3, [r7, #24]
3401a2b8:	e00c      	b.n	3401a2d4 <HAL_UART_Receive+0x15c>
      }
      else
      {
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
3401a2ba:	68fb      	ldr	r3, [r7, #12]
3401a2bc:	681b      	ldr	r3, [r3, #0]
3401a2be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a2c0:	b2da      	uxtb	r2, r3
3401a2c2:	8a7b      	ldrh	r3, [r7, #18]
3401a2c4:	b2db      	uxtb	r3, r3
3401a2c6:	4013      	ands	r3, r2
3401a2c8:	b2da      	uxtb	r2, r3
3401a2ca:	69fb      	ldr	r3, [r7, #28]
3401a2cc:	701a      	strb	r2, [r3, #0]
        pdata8bits++;
3401a2ce:	69fb      	ldr	r3, [r7, #28]
3401a2d0:	3301      	adds	r3, #1
3401a2d2:	61fb      	str	r3, [r7, #28]
      }
      huart->RxXferCount--;
3401a2d4:	68fb      	ldr	r3, [r7, #12]
3401a2d6:	f8b3 305e 	ldrh.w	r3, [r3, #94]	@ 0x5e
3401a2da:	b29b      	uxth	r3, r3
3401a2dc:	3b01      	subs	r3, #1
3401a2de:	b29a      	uxth	r2, r3
3401a2e0:	68fb      	ldr	r3, [r7, #12]
3401a2e2:	f8a3 205e 	strh.w	r2, [r3, #94]	@ 0x5e
    while (huart->RxXferCount > 0U)
3401a2e6:	68fb      	ldr	r3, [r7, #12]
3401a2e8:	f8b3 305e 	ldrh.w	r3, [r3, #94]	@ 0x5e
3401a2ec:	b29b      	uxth	r3, r3
3401a2ee:	2b00      	cmp	r3, #0
3401a2f0:	d1c2      	bne.n	3401a278 <HAL_UART_Receive+0x100>
    }

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
3401a2f2:	68fb      	ldr	r3, [r7, #12]
3401a2f4:	2220      	movs	r2, #32
3401a2f6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

    return HAL_OK;
3401a2fa:	2300      	movs	r3, #0
3401a2fc:	e000      	b.n	3401a300 <HAL_UART_Receive+0x188>
  }
  else
  {
    return HAL_BUSY;
3401a2fe:	2302      	movs	r3, #2
  }
}
3401a300:	4618      	mov	r0, r3
3401a302:	3720      	adds	r7, #32
3401a304:	46bd      	mov	sp, r7
3401a306:	bd80      	pop	{r7, pc}

3401a308 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
3401a308:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3401a30c:	b090      	sub	sp, #64	@ 0x40
3401a30e:	af00      	add	r7, sp, #0
3401a310:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint64_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
3401a312:	2300      	movs	r3, #0
3401a314:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint32_t lpuart_ker_ck_pres;
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
3401a318:	697b      	ldr	r3, [r7, #20]
3401a31a:	685b      	ldr	r3, [r3, #4]
3401a31c:	4a19      	ldr	r2, [pc, #100]	@ (3401a384 <UART_SetConfig+0x7c>)
3401a31e:	4293      	cmp	r3, r2
3401a320:	d904      	bls.n	3401a32c <UART_SetConfig+0x24>
3401a322:	f640 414c 	movw	r1, #3148	@ 0xc4c
3401a326:	4818      	ldr	r0, [pc, #96]	@ (3401a388 <UART_SetConfig+0x80>)
3401a328:	f7e6 ffb6 	bl	34001298 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
3401a32c:	697b      	ldr	r3, [r7, #20]
3401a32e:	689b      	ldr	r3, [r3, #8]
3401a330:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401a334:	d00d      	beq.n	3401a352 <UART_SetConfig+0x4a>
3401a336:	697b      	ldr	r3, [r7, #20]
3401a338:	689b      	ldr	r3, [r3, #8]
3401a33a:	2b00      	cmp	r3, #0
3401a33c:	d009      	beq.n	3401a352 <UART_SetConfig+0x4a>
3401a33e:	697b      	ldr	r3, [r7, #20]
3401a340:	689b      	ldr	r3, [r3, #8]
3401a342:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401a346:	d004      	beq.n	3401a352 <UART_SetConfig+0x4a>
3401a348:	f640 414d 	movw	r1, #3149	@ 0xc4d
3401a34c:	480e      	ldr	r0, [pc, #56]	@ (3401a388 <UART_SetConfig+0x80>)
3401a34e:	f7e6 ffa3 	bl	34001298 <assert_failed>
  if (UART_INSTANCE_LOWPOWER(huart))
3401a352:	697b      	ldr	r3, [r7, #20]
3401a354:	681b      	ldr	r3, [r3, #0]
3401a356:	4a0d      	ldr	r2, [pc, #52]	@ (3401a38c <UART_SetConfig+0x84>)
3401a358:	4293      	cmp	r3, r2
3401a35a:	d004      	beq.n	3401a366 <UART_SetConfig+0x5e>
3401a35c:	697b      	ldr	r3, [r7, #20]
3401a35e:	681b      	ldr	r3, [r3, #0]
3401a360:	4a0b      	ldr	r2, [pc, #44]	@ (3401a390 <UART_SetConfig+0x88>)
3401a362:	4293      	cmp	r3, r2
3401a364:	d116      	bne.n	3401a394 <UART_SetConfig+0x8c>
  {
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
3401a366:	697b      	ldr	r3, [r7, #20]
3401a368:	68db      	ldr	r3, [r3, #12]
3401a36a:	2b00      	cmp	r3, #0
3401a36c:	d038      	beq.n	3401a3e0 <UART_SetConfig+0xd8>
3401a36e:	697b      	ldr	r3, [r7, #20]
3401a370:	68db      	ldr	r3, [r3, #12]
3401a372:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3401a376:	d033      	beq.n	3401a3e0 <UART_SetConfig+0xd8>
3401a378:	f44f 6145 	mov.w	r1, #3152	@ 0xc50
3401a37c:	4802      	ldr	r0, [pc, #8]	@ (3401a388 <UART_SetConfig+0x80>)
3401a37e:	f7e6 ff8b 	bl	34001298 <assert_failed>
3401a382:	e02d      	b.n	3401a3e0 <UART_SetConfig+0xd8>
3401a384:	00bebc1f 	.word	0x00bebc1f
3401a388:	34024530 	.word	0x34024530
3401a38c:	56000c00 	.word	0x56000c00
3401a390:	46000c00 	.word	0x46000c00
  }
  else
  {
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
3401a394:	697b      	ldr	r3, [r7, #20]
3401a396:	68db      	ldr	r3, [r3, #12]
3401a398:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401a39c:	d012      	beq.n	3401a3c4 <UART_SetConfig+0xbc>
3401a39e:	697b      	ldr	r3, [r7, #20]
3401a3a0:	68db      	ldr	r3, [r3, #12]
3401a3a2:	2b00      	cmp	r3, #0
3401a3a4:	d00e      	beq.n	3401a3c4 <UART_SetConfig+0xbc>
3401a3a6:	697b      	ldr	r3, [r7, #20]
3401a3a8:	68db      	ldr	r3, [r3, #12]
3401a3aa:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3401a3ae:	d009      	beq.n	3401a3c4 <UART_SetConfig+0xbc>
3401a3b0:	697b      	ldr	r3, [r7, #20]
3401a3b2:	68db      	ldr	r3, [r3, #12]
3401a3b4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3401a3b8:	d004      	beq.n	3401a3c4 <UART_SetConfig+0xbc>
3401a3ba:	f640 4154 	movw	r1, #3156	@ 0xc54
3401a3be:	4896      	ldr	r0, [pc, #600]	@ (3401a618 <UART_SetConfig+0x310>)
3401a3c0:	f7e6 ff6a 	bl	34001298 <assert_failed>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
3401a3c4:	697b      	ldr	r3, [r7, #20]
3401a3c6:	6a1b      	ldr	r3, [r3, #32]
3401a3c8:	2b00      	cmp	r3, #0
3401a3ca:	d009      	beq.n	3401a3e0 <UART_SetConfig+0xd8>
3401a3cc:	697b      	ldr	r3, [r7, #20]
3401a3ce:	6a1b      	ldr	r3, [r3, #32]
3401a3d0:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3401a3d4:	d004      	beq.n	3401a3e0 <UART_SetConfig+0xd8>
3401a3d6:	f640 4155 	movw	r1, #3157	@ 0xc55
3401a3da:	488f      	ldr	r0, [pc, #572]	@ (3401a618 <UART_SetConfig+0x310>)
3401a3dc:	f7e6 ff5c 	bl	34001298 <assert_failed>
  }

  assert_param(IS_UART_PARITY(huart->Init.Parity));
3401a3e0:	697b      	ldr	r3, [r7, #20]
3401a3e2:	691b      	ldr	r3, [r3, #16]
3401a3e4:	2b00      	cmp	r3, #0
3401a3e6:	d00e      	beq.n	3401a406 <UART_SetConfig+0xfe>
3401a3e8:	697b      	ldr	r3, [r7, #20]
3401a3ea:	691b      	ldr	r3, [r3, #16]
3401a3ec:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3401a3f0:	d009      	beq.n	3401a406 <UART_SetConfig+0xfe>
3401a3f2:	697b      	ldr	r3, [r7, #20]
3401a3f4:	691b      	ldr	r3, [r3, #16]
3401a3f6:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3401a3fa:	d004      	beq.n	3401a406 <UART_SetConfig+0xfe>
3401a3fc:	f640 4158 	movw	r1, #3160	@ 0xc58
3401a400:	4885      	ldr	r0, [pc, #532]	@ (3401a618 <UART_SetConfig+0x310>)
3401a402:	f7e6 ff49 	bl	34001298 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
3401a406:	697b      	ldr	r3, [r7, #20]
3401a408:	695b      	ldr	r3, [r3, #20]
3401a40a:	f023 030c 	bic.w	r3, r3, #12
3401a40e:	2b00      	cmp	r3, #0
3401a410:	d103      	bne.n	3401a41a <UART_SetConfig+0x112>
3401a412:	697b      	ldr	r3, [r7, #20]
3401a414:	695b      	ldr	r3, [r3, #20]
3401a416:	2b00      	cmp	r3, #0
3401a418:	d104      	bne.n	3401a424 <UART_SetConfig+0x11c>
3401a41a:	f640 4159 	movw	r1, #3161	@ 0xc59
3401a41e:	487e      	ldr	r0, [pc, #504]	@ (3401a618 <UART_SetConfig+0x310>)
3401a420:	f7e6 ff3a 	bl	34001298 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
3401a424:	697b      	ldr	r3, [r7, #20]
3401a426:	699b      	ldr	r3, [r3, #24]
3401a428:	2b00      	cmp	r3, #0
3401a42a:	d013      	beq.n	3401a454 <UART_SetConfig+0x14c>
3401a42c:	697b      	ldr	r3, [r7, #20]
3401a42e:	699b      	ldr	r3, [r3, #24]
3401a430:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401a434:	d00e      	beq.n	3401a454 <UART_SetConfig+0x14c>
3401a436:	697b      	ldr	r3, [r7, #20]
3401a438:	699b      	ldr	r3, [r3, #24]
3401a43a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401a43e:	d009      	beq.n	3401a454 <UART_SetConfig+0x14c>
3401a440:	697b      	ldr	r3, [r7, #20]
3401a442:	699b      	ldr	r3, [r3, #24]
3401a444:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401a448:	d004      	beq.n	3401a454 <UART_SetConfig+0x14c>
3401a44a:	f640 415a 	movw	r1, #3162	@ 0xc5a
3401a44e:	4872      	ldr	r0, [pc, #456]	@ (3401a618 <UART_SetConfig+0x310>)
3401a450:	f7e6 ff22 	bl	34001298 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
3401a454:	697b      	ldr	r3, [r7, #20]
3401a456:	69db      	ldr	r3, [r3, #28]
3401a458:	2b00      	cmp	r3, #0
3401a45a:	d009      	beq.n	3401a470 <UART_SetConfig+0x168>
3401a45c:	697b      	ldr	r3, [r7, #20]
3401a45e:	69db      	ldr	r3, [r3, #28]
3401a460:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3401a464:	d004      	beq.n	3401a470 <UART_SetConfig+0x168>
3401a466:	f640 415b 	movw	r1, #3163	@ 0xc5b
3401a46a:	486b      	ldr	r0, [pc, #428]	@ (3401a618 <UART_SetConfig+0x310>)
3401a46c:	f7e6 ff14 	bl	34001298 <assert_failed>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
3401a470:	697b      	ldr	r3, [r7, #20]
3401a472:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a474:	2b00      	cmp	r3, #0
3401a476:	d030      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a478:	697b      	ldr	r3, [r7, #20]
3401a47a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a47c:	2b01      	cmp	r3, #1
3401a47e:	d02c      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a480:	697b      	ldr	r3, [r7, #20]
3401a482:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a484:	2b02      	cmp	r3, #2
3401a486:	d028      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a488:	697b      	ldr	r3, [r7, #20]
3401a48a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a48c:	2b03      	cmp	r3, #3
3401a48e:	d024      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a490:	697b      	ldr	r3, [r7, #20]
3401a492:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a494:	2b04      	cmp	r3, #4
3401a496:	d020      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a498:	697b      	ldr	r3, [r7, #20]
3401a49a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a49c:	2b05      	cmp	r3, #5
3401a49e:	d01c      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4a0:	697b      	ldr	r3, [r7, #20]
3401a4a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a4a4:	2b06      	cmp	r3, #6
3401a4a6:	d018      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4a8:	697b      	ldr	r3, [r7, #20]
3401a4aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a4ac:	2b07      	cmp	r3, #7
3401a4ae:	d014      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4b0:	697b      	ldr	r3, [r7, #20]
3401a4b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a4b4:	2b08      	cmp	r3, #8
3401a4b6:	d010      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4b8:	697b      	ldr	r3, [r7, #20]
3401a4ba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a4bc:	2b09      	cmp	r3, #9
3401a4be:	d00c      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4c0:	697b      	ldr	r3, [r7, #20]
3401a4c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a4c4:	2b0a      	cmp	r3, #10
3401a4c6:	d008      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4c8:	697b      	ldr	r3, [r7, #20]
3401a4ca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a4cc:	2b0b      	cmp	r3, #11
3401a4ce:	d004      	beq.n	3401a4da <UART_SetConfig+0x1d2>
3401a4d0:	f640 415c 	movw	r1, #3164	@ 0xc5c
3401a4d4:	4850      	ldr	r0, [pc, #320]	@ (3401a618 <UART_SetConfig+0x310>)
3401a4d6:	f7e6 fedf 	bl	34001298 <assert_failed>
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3401a4da:	697b      	ldr	r3, [r7, #20]
3401a4dc:	689a      	ldr	r2, [r3, #8]
3401a4de:	697b      	ldr	r3, [r7, #20]
3401a4e0:	691b      	ldr	r3, [r3, #16]
3401a4e2:	431a      	orrs	r2, r3
3401a4e4:	697b      	ldr	r3, [r7, #20]
3401a4e6:	695b      	ldr	r3, [r3, #20]
3401a4e8:	431a      	orrs	r2, r3
3401a4ea:	697b      	ldr	r3, [r7, #20]
3401a4ec:	69db      	ldr	r3, [r3, #28]
3401a4ee:	4313      	orrs	r3, r2
3401a4f0:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3401a4f2:	697b      	ldr	r3, [r7, #20]
3401a4f4:	681b      	ldr	r3, [r3, #0]
3401a4f6:	681a      	ldr	r2, [r3, #0]
3401a4f8:	4b48      	ldr	r3, [pc, #288]	@ (3401a61c <UART_SetConfig+0x314>)
3401a4fa:	4013      	ands	r3, r2
3401a4fc:	697a      	ldr	r2, [r7, #20]
3401a4fe:	6812      	ldr	r2, [r2, #0]
3401a500:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3401a502:	430b      	orrs	r3, r1
3401a504:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
3401a506:	697b      	ldr	r3, [r7, #20]
3401a508:	681b      	ldr	r3, [r3, #0]
3401a50a:	685b      	ldr	r3, [r3, #4]
3401a50c:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
3401a510:	697b      	ldr	r3, [r7, #20]
3401a512:	68da      	ldr	r2, [r3, #12]
3401a514:	697b      	ldr	r3, [r7, #20]
3401a516:	681b      	ldr	r3, [r3, #0]
3401a518:	430a      	orrs	r2, r1
3401a51a:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
3401a51c:	697b      	ldr	r3, [r7, #20]
3401a51e:	699b      	ldr	r3, [r3, #24]
3401a520:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
3401a522:	697b      	ldr	r3, [r7, #20]
3401a524:	681b      	ldr	r3, [r3, #0]
3401a526:	4a3e      	ldr	r2, [pc, #248]	@ (3401a620 <UART_SetConfig+0x318>)
3401a528:	4293      	cmp	r3, r2
3401a52a:	d009      	beq.n	3401a540 <UART_SetConfig+0x238>
3401a52c:	697b      	ldr	r3, [r7, #20]
3401a52e:	681b      	ldr	r3, [r3, #0]
3401a530:	4a3c      	ldr	r2, [pc, #240]	@ (3401a624 <UART_SetConfig+0x31c>)
3401a532:	4293      	cmp	r3, r2
3401a534:	d004      	beq.n	3401a540 <UART_SetConfig+0x238>
  {
    tmpreg |= huart->Init.OneBitSampling;
3401a536:	697b      	ldr	r3, [r7, #20]
3401a538:	6a1b      	ldr	r3, [r3, #32]
3401a53a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3401a53c:	4313      	orrs	r3, r2
3401a53e:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
3401a540:	697b      	ldr	r3, [r7, #20]
3401a542:	681b      	ldr	r3, [r3, #0]
3401a544:	689b      	ldr	r3, [r3, #8]
3401a546:	f023 436e 	bic.w	r3, r3, #3992977408	@ 0xee000000
3401a54a:	f423 6330 	bic.w	r3, r3, #2816	@ 0xb00
3401a54e:	697a      	ldr	r2, [r7, #20]
3401a550:	6812      	ldr	r2, [r2, #0]
3401a552:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3401a554:	430b      	orrs	r3, r1
3401a556:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
3401a558:	697b      	ldr	r3, [r7, #20]
3401a55a:	681b      	ldr	r3, [r3, #0]
3401a55c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401a55e:	f023 010f 	bic.w	r1, r3, #15
3401a562:	697b      	ldr	r3, [r7, #20]
3401a564:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401a566:	697b      	ldr	r3, [r7, #20]
3401a568:	681b      	ldr	r3, [r3, #0]
3401a56a:	430a      	orrs	r2, r1
3401a56c:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
3401a56e:	697b      	ldr	r3, [r7, #20]
3401a570:	681b      	ldr	r3, [r3, #0]
3401a572:	4a2d      	ldr	r2, [pc, #180]	@ (3401a628 <UART_SetConfig+0x320>)
3401a574:	4293      	cmp	r3, r2
3401a576:	d106      	bne.n	3401a586 <UART_SetConfig+0x27e>
3401a578:	f04f 0200 	mov.w	r2, #0
3401a57c:	f44f 7380 	mov.w	r3, #256	@ 0x100
3401a580:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a584:	e092      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a586:	697b      	ldr	r3, [r7, #20]
3401a588:	681b      	ldr	r3, [r3, #0]
3401a58a:	4a28      	ldr	r2, [pc, #160]	@ (3401a62c <UART_SetConfig+0x324>)
3401a58c:	4293      	cmp	r3, r2
3401a58e:	d106      	bne.n	3401a59e <UART_SetConfig+0x296>
3401a590:	f04f 0200 	mov.w	r2, #0
3401a594:	f44f 7300 	mov.w	r3, #512	@ 0x200
3401a598:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a59c:	e086      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a59e:	697b      	ldr	r3, [r7, #20]
3401a5a0:	681b      	ldr	r3, [r3, #0]
3401a5a2:	4a23      	ldr	r2, [pc, #140]	@ (3401a630 <UART_SetConfig+0x328>)
3401a5a4:	4293      	cmp	r3, r2
3401a5a6:	d106      	bne.n	3401a5b6 <UART_SetConfig+0x2ae>
3401a5a8:	f04f 0200 	mov.w	r2, #0
3401a5ac:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401a5b0:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a5b4:	e07a      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a5b6:	697b      	ldr	r3, [r7, #20]
3401a5b8:	681b      	ldr	r3, [r3, #0]
3401a5ba:	4a1e      	ldr	r2, [pc, #120]	@ (3401a634 <UART_SetConfig+0x32c>)
3401a5bc:	4293      	cmp	r3, r2
3401a5be:	d106      	bne.n	3401a5ce <UART_SetConfig+0x2c6>
3401a5c0:	f04f 0200 	mov.w	r2, #0
3401a5c4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3401a5c8:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a5cc:	e06e      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a5ce:	697b      	ldr	r3, [r7, #20]
3401a5d0:	681b      	ldr	r3, [r3, #0]
3401a5d2:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3401a5d6:	d106      	bne.n	3401a5e6 <UART_SetConfig+0x2de>
3401a5d8:	f04f 0200 	mov.w	r2, #0
3401a5dc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3401a5e0:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a5e4:	e062      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a5e6:	697b      	ldr	r3, [r7, #20]
3401a5e8:	681b      	ldr	r3, [r3, #0]
3401a5ea:	4a13      	ldr	r2, [pc, #76]	@ (3401a638 <UART_SetConfig+0x330>)
3401a5ec:	4293      	cmp	r3, r2
3401a5ee:	d106      	bne.n	3401a5fe <UART_SetConfig+0x2f6>
3401a5f0:	f04f 0200 	mov.w	r2, #0
3401a5f4:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3401a5f8:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a5fc:	e056      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a5fe:	697b      	ldr	r3, [r7, #20]
3401a600:	681b      	ldr	r3, [r3, #0]
3401a602:	4a0e      	ldr	r2, [pc, #56]	@ (3401a63c <UART_SetConfig+0x334>)
3401a604:	4293      	cmp	r3, r2
3401a606:	d11b      	bne.n	3401a640 <UART_SetConfig+0x338>
3401a608:	f04f 0200 	mov.w	r2, #0
3401a60c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3401a610:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a614:	e04a      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a616:	bf00      	nop
3401a618:	34024530 	.word	0x34024530
3401a61c:	cfff69f3 	.word	0xcfff69f3
3401a620:	56000c00 	.word	0x56000c00
3401a624:	46000c00 	.word	0x46000c00
3401a628:	52001000 	.word	0x52001000
3401a62c:	50004400 	.word	0x50004400
3401a630:	50004800 	.word	0x50004800
3401a634:	50004c00 	.word	0x50004c00
3401a638:	52001400 	.word	0x52001400
3401a63c:	50007800 	.word	0x50007800
3401a640:	697b      	ldr	r3, [r7, #20]
3401a642:	681b      	ldr	r3, [r3, #0]
3401a644:	4a90      	ldr	r2, [pc, #576]	@ (3401a888 <UART_SetConfig+0x580>)
3401a646:	4293      	cmp	r3, r2
3401a648:	d106      	bne.n	3401a658 <UART_SetConfig+0x350>
3401a64a:	f04f 0200 	mov.w	r2, #0
3401a64e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3401a652:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a656:	e029      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a658:	697b      	ldr	r3, [r7, #20]
3401a65a:	681b      	ldr	r3, [r3, #0]
3401a65c:	4a8b      	ldr	r2, [pc, #556]	@ (3401a88c <UART_SetConfig+0x584>)
3401a65e:	4293      	cmp	r3, r2
3401a660:	d106      	bne.n	3401a670 <UART_SetConfig+0x368>
3401a662:	f04f 0200 	mov.w	r2, #0
3401a666:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3401a66a:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a66e:	e01d      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a670:	697b      	ldr	r3, [r7, #20]
3401a672:	681b      	ldr	r3, [r3, #0]
3401a674:	4a86      	ldr	r2, [pc, #536]	@ (3401a890 <UART_SetConfig+0x588>)
3401a676:	4293      	cmp	r3, r2
3401a678:	d106      	bne.n	3401a688 <UART_SetConfig+0x380>
3401a67a:	f04f 0200 	mov.w	r2, #0
3401a67e:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3401a682:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a686:	e011      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a688:	697b      	ldr	r3, [r7, #20]
3401a68a:	681b      	ldr	r3, [r3, #0]
3401a68c:	4a81      	ldr	r2, [pc, #516]	@ (3401a894 <UART_SetConfig+0x58c>)
3401a68e:	4293      	cmp	r3, r2
3401a690:	d106      	bne.n	3401a6a0 <UART_SetConfig+0x398>
3401a692:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3401a696:	f04f 0300 	mov.w	r3, #0
3401a69a:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401a69e:	e005      	b.n	3401a6ac <UART_SetConfig+0x3a4>
3401a6a0:	f04f 0200 	mov.w	r2, #0
3401a6a4:	f04f 0300 	mov.w	r3, #0
3401a6a8:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
3401a6ac:	697b      	ldr	r3, [r7, #20]
3401a6ae:	681b      	ldr	r3, [r3, #0]
3401a6b0:	4a78      	ldr	r2, [pc, #480]	@ (3401a894 <UART_SetConfig+0x58c>)
3401a6b2:	4293      	cmp	r3, r2
3401a6b4:	d004      	beq.n	3401a6c0 <UART_SetConfig+0x3b8>
3401a6b6:	697b      	ldr	r3, [r7, #20]
3401a6b8:	681b      	ldr	r3, [r3, #0]
3401a6ba:	4a77      	ldr	r2, [pc, #476]	@ (3401a898 <UART_SetConfig+0x590>)
3401a6bc:	4293      	cmp	r3, r2
3401a6be:	d166      	bne.n	3401a78e <UART_SetConfig+0x486>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3401a6c0:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3401a6c4:	f7fa fd6e 	bl	340151a4 <HAL_RCCEx_GetPeriphCLKFreq>
3401a6c8:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* If proper clock source reported */
    if (pclk != 0U)
3401a6ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a6cc:	2b00      	cmp	r3, #0
3401a6ce:	f000 80c6 	beq.w	3401a85e <UART_SetConfig+0x556>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3401a6d2:	697b      	ldr	r3, [r7, #20]
3401a6d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a6d6:	4a71      	ldr	r2, [pc, #452]	@ (3401a89c <UART_SetConfig+0x594>)
3401a6d8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401a6dc:	461a      	mov	r2, r3
3401a6de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a6e0:	fbb3 f3f2 	udiv	r3, r3, r2
3401a6e4:	61fb      	str	r3, [r7, #28]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3401a6e6:	697b      	ldr	r3, [r7, #20]
3401a6e8:	685a      	ldr	r2, [r3, #4]
3401a6ea:	4613      	mov	r3, r2
3401a6ec:	005b      	lsls	r3, r3, #1
3401a6ee:	4413      	add	r3, r2
3401a6f0:	69fa      	ldr	r2, [r7, #28]
3401a6f2:	429a      	cmp	r2, r3
3401a6f4:	d305      	bcc.n	3401a702 <UART_SetConfig+0x3fa>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
3401a6f6:	697b      	ldr	r3, [r7, #20]
3401a6f8:	685b      	ldr	r3, [r3, #4]
3401a6fa:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3401a6fc:	69fa      	ldr	r2, [r7, #28]
3401a6fe:	429a      	cmp	r2, r3
3401a700:	d903      	bls.n	3401a70a <UART_SetConfig+0x402>
      {
        ret = HAL_ERROR;
3401a702:	2301      	movs	r3, #1
3401a704:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3401a708:	e040      	b.n	3401a78c <UART_SetConfig+0x484>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3401a70a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a70c:	2200      	movs	r2, #0
3401a70e:	60bb      	str	r3, [r7, #8]
3401a710:	60fa      	str	r2, [r7, #12]
3401a712:	697b      	ldr	r3, [r7, #20]
3401a714:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a716:	4a61      	ldr	r2, [pc, #388]	@ (3401a89c <UART_SetConfig+0x594>)
3401a718:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401a71c:	b29b      	uxth	r3, r3
3401a71e:	2200      	movs	r2, #0
3401a720:	603b      	str	r3, [r7, #0]
3401a722:	607a      	str	r2, [r7, #4]
3401a724:	e9d7 2300 	ldrd	r2, r3, [r7]
3401a728:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3401a72c:	f7e6 f838 	bl	340007a0 <__aeabi_uldivmod>
3401a730:	4602      	mov	r2, r0
3401a732:	460b      	mov	r3, r1
3401a734:	ea52 230f 	orrs.w	r3, r2, pc, lsl #8
3401a738:	6979      	ldr	r1, [r7, #20]
3401a73a:	6849      	ldr	r1, [r1, #4]
3401a73c:	0849      	lsrs	r1, r1, #1
3401a73e:	2000      	movs	r0, #0
3401a740:	460c      	mov	r4, r1
3401a742:	4605      	mov	r5, r0
3401a744:	eb12 0804 	adds.w	r8, r2, r4
3401a748:	eb43 0905 	adc.w	r9, r3, r5
3401a74c:	697b      	ldr	r3, [r7, #20]
3401a74e:	685b      	ldr	r3, [r3, #4]
3401a750:	2200      	movs	r2, #0
3401a752:	469a      	mov	sl, r3
3401a754:	4693      	mov	fp, r2
3401a756:	4652      	mov	r2, sl
3401a758:	465b      	mov	r3, fp
3401a75a:	4640      	mov	r0, r8
3401a75c:	4649      	mov	r1, r9
3401a75e:	f7e6 f81f 	bl	340007a0 <__aeabi_uldivmod>
3401a762:	4602      	mov	r2, r0
3401a764:	460b      	mov	r3, r1
3401a766:	4613      	mov	r3, r2
3401a768:	627b      	str	r3, [r7, #36]	@ 0x24
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
3401a76a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a76c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401a770:	d308      	bcc.n	3401a784 <UART_SetConfig+0x47c>
3401a772:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a774:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401a778:	d204      	bcs.n	3401a784 <UART_SetConfig+0x47c>
        {
          huart->Instance->BRR = usartdiv;
3401a77a:	697b      	ldr	r3, [r7, #20]
3401a77c:	681b      	ldr	r3, [r3, #0]
3401a77e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401a780:	60da      	str	r2, [r3, #12]
3401a782:	e003      	b.n	3401a78c <UART_SetConfig+0x484>
        }
        else
        {
          ret = HAL_ERROR;
3401a784:	2301      	movs	r3, #1
3401a786:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if (pclk != 0U)
3401a78a:	e068      	b.n	3401a85e <UART_SetConfig+0x556>
3401a78c:	e067      	b.n	3401a85e <UART_SetConfig+0x556>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
3401a78e:	697b      	ldr	r3, [r7, #20]
3401a790:	69db      	ldr	r3, [r3, #28]
3401a792:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3401a796:	d138      	bne.n	3401a80a <UART_SetConfig+0x502>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3401a798:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3401a79c:	f7fa fd02 	bl	340151a4 <HAL_RCCEx_GetPeriphCLKFreq>
3401a7a0:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
3401a7a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a7a4:	2b00      	cmp	r3, #0
3401a7a6:	d05a      	beq.n	3401a85e <UART_SetConfig+0x556>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3401a7a8:	697b      	ldr	r3, [r7, #20]
3401a7aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a7ac:	4a3b      	ldr	r2, [pc, #236]	@ (3401a89c <UART_SetConfig+0x594>)
3401a7ae:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401a7b2:	461a      	mov	r2, r3
3401a7b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a7b6:	fbb3 f3f2 	udiv	r3, r3, r2
3401a7ba:	005a      	lsls	r2, r3, #1
3401a7bc:	697b      	ldr	r3, [r7, #20]
3401a7be:	685b      	ldr	r3, [r3, #4]
3401a7c0:	085b      	lsrs	r3, r3, #1
3401a7c2:	441a      	add	r2, r3
3401a7c4:	697b      	ldr	r3, [r7, #20]
3401a7c6:	685b      	ldr	r3, [r3, #4]
3401a7c8:	fbb2 f3f3 	udiv	r3, r2, r3
3401a7cc:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3401a7ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a7d0:	2b0f      	cmp	r3, #15
3401a7d2:	d916      	bls.n	3401a802 <UART_SetConfig+0x4fa>
3401a7d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a7d6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401a7da:	d212      	bcs.n	3401a802 <UART_SetConfig+0x4fa>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3401a7dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a7de:	b29b      	uxth	r3, r3
3401a7e0:	f023 030f 	bic.w	r3, r3, #15
3401a7e4:	847b      	strh	r3, [r7, #34]	@ 0x22
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
3401a7e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a7e8:	085b      	lsrs	r3, r3, #1
3401a7ea:	b29b      	uxth	r3, r3
3401a7ec:	f003 0307 	and.w	r3, r3, #7
3401a7f0:	b29a      	uxth	r2, r3
3401a7f2:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
3401a7f4:	4313      	orrs	r3, r2
3401a7f6:	847b      	strh	r3, [r7, #34]	@ 0x22
        huart->Instance->BRR = brrtemp;
3401a7f8:	697b      	ldr	r3, [r7, #20]
3401a7fa:	681b      	ldr	r3, [r3, #0]
3401a7fc:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
3401a7fe:	60da      	str	r2, [r3, #12]
3401a800:	e02d      	b.n	3401a85e <UART_SetConfig+0x556>
      }
      else
      {
        ret = HAL_ERROR;
3401a802:	2301      	movs	r3, #1
3401a804:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3401a808:	e029      	b.n	3401a85e <UART_SetConfig+0x556>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3401a80a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3401a80e:	f7fa fcc9 	bl	340151a4 <HAL_RCCEx_GetPeriphCLKFreq>
3401a812:	62b8      	str	r0, [r7, #40]	@ 0x28

    if (pclk != 0U)
3401a814:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a816:	2b00      	cmp	r3, #0
3401a818:	d021      	beq.n	3401a85e <UART_SetConfig+0x556>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3401a81a:	697b      	ldr	r3, [r7, #20]
3401a81c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401a81e:	4a1f      	ldr	r2, [pc, #124]	@ (3401a89c <UART_SetConfig+0x594>)
3401a820:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401a824:	461a      	mov	r2, r3
3401a826:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401a828:	fbb3 f2f2 	udiv	r2, r3, r2
3401a82c:	697b      	ldr	r3, [r7, #20]
3401a82e:	685b      	ldr	r3, [r3, #4]
3401a830:	085b      	lsrs	r3, r3, #1
3401a832:	441a      	add	r2, r3
3401a834:	697b      	ldr	r3, [r7, #20]
3401a836:	685b      	ldr	r3, [r3, #4]
3401a838:	fbb2 f3f3 	udiv	r3, r2, r3
3401a83c:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3401a83e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a840:	2b0f      	cmp	r3, #15
3401a842:	d909      	bls.n	3401a858 <UART_SetConfig+0x550>
3401a844:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a846:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401a84a:	d205      	bcs.n	3401a858 <UART_SetConfig+0x550>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
3401a84c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401a84e:	b29a      	uxth	r2, r3
3401a850:	697b      	ldr	r3, [r7, #20]
3401a852:	681b      	ldr	r3, [r3, #0]
3401a854:	60da      	str	r2, [r3, #12]
3401a856:	e002      	b.n	3401a85e <UART_SetConfig+0x556>
      }
      else
      {
        ret = HAL_ERROR;
3401a858:	2301      	movs	r3, #1
3401a85a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
3401a85e:	697b      	ldr	r3, [r7, #20]
3401a860:	2201      	movs	r2, #1
3401a862:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
3401a866:	697b      	ldr	r3, [r7, #20]
3401a868:	2201      	movs	r2, #1
3401a86a:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
3401a86e:	697b      	ldr	r3, [r7, #20]
3401a870:	2200      	movs	r2, #0
3401a872:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
3401a874:	697b      	ldr	r3, [r7, #20]
3401a876:	2200      	movs	r2, #0
3401a878:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
3401a87a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
3401a87e:	4618      	mov	r0, r3
3401a880:	3740      	adds	r7, #64	@ 0x40
3401a882:	46bd      	mov	sp, r7
3401a884:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3401a888:	50007c00 	.word	0x50007c00
3401a88c:	52001800 	.word	0x52001800
3401a890:	52001c00 	.word	0x52001c00
3401a894:	56000c00 	.word	0x56000c00
3401a898:	46000c00 	.word	0x46000c00
3401a89c:	3403214c 	.word	0x3403214c

3401a8a0 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
3401a8a0:	b580      	push	{r7, lr}
3401a8a2:	b082      	sub	sp, #8
3401a8a4:	af00      	add	r7, sp, #0
3401a8a6:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3401a8a8:	687b      	ldr	r3, [r7, #4]
3401a8aa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a8ac:	2bff      	cmp	r3, #255	@ 0xff
3401a8ae:	d904      	bls.n	3401a8ba <UART_AdvFeatureConfig+0x1a>
3401a8b0:	f640 41e1 	movw	r1, #3297	@ 0xce1
3401a8b4:	4890      	ldr	r0, [pc, #576]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401a8b6:	f7e6 fcef 	bl	34001298 <assert_failed>

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
3401a8ba:	687b      	ldr	r3, [r7, #4]
3401a8bc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a8be:	f003 0308 	and.w	r3, r3, #8
3401a8c2:	2b00      	cmp	r3, #0
3401a8c4:	d018      	beq.n	3401a8f8 <UART_AdvFeatureConfig+0x58>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
3401a8c6:	687b      	ldr	r3, [r7, #4]
3401a8c8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401a8ca:	2b00      	cmp	r3, #0
3401a8cc:	d009      	beq.n	3401a8e2 <UART_AdvFeatureConfig+0x42>
3401a8ce:	687b      	ldr	r3, [r7, #4]
3401a8d0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401a8d2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3401a8d6:	d004      	beq.n	3401a8e2 <UART_AdvFeatureConfig+0x42>
3401a8d8:	f640 41e6 	movw	r1, #3302	@ 0xce6
3401a8dc:	4886      	ldr	r0, [pc, #536]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401a8de:	f7e6 fcdb 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
3401a8e2:	687b      	ldr	r3, [r7, #4]
3401a8e4:	681b      	ldr	r3, [r3, #0]
3401a8e6:	685b      	ldr	r3, [r3, #4]
3401a8e8:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
3401a8ec:	687b      	ldr	r3, [r7, #4]
3401a8ee:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3401a8f0:	687b      	ldr	r3, [r7, #4]
3401a8f2:	681b      	ldr	r3, [r3, #0]
3401a8f4:	430a      	orrs	r2, r1
3401a8f6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
3401a8f8:	687b      	ldr	r3, [r7, #4]
3401a8fa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a8fc:	f003 0301 	and.w	r3, r3, #1
3401a900:	2b00      	cmp	r3, #0
3401a902:	d018      	beq.n	3401a936 <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
3401a904:	687b      	ldr	r3, [r7, #4]
3401a906:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401a908:	2b00      	cmp	r3, #0
3401a90a:	d009      	beq.n	3401a920 <UART_AdvFeatureConfig+0x80>
3401a90c:	687b      	ldr	r3, [r7, #4]
3401a90e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401a910:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3401a914:	d004      	beq.n	3401a920 <UART_AdvFeatureConfig+0x80>
3401a916:	f640 41ed 	movw	r1, #3309	@ 0xced
3401a91a:	4877      	ldr	r0, [pc, #476]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401a91c:	f7e6 fcbc 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
3401a920:	687b      	ldr	r3, [r7, #4]
3401a922:	681b      	ldr	r3, [r3, #0]
3401a924:	685b      	ldr	r3, [r3, #4]
3401a926:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
3401a92a:	687b      	ldr	r3, [r7, #4]
3401a92c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3401a92e:	687b      	ldr	r3, [r7, #4]
3401a930:	681b      	ldr	r3, [r3, #0]
3401a932:	430a      	orrs	r2, r1
3401a934:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
3401a936:	687b      	ldr	r3, [r7, #4]
3401a938:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a93a:	f003 0302 	and.w	r3, r3, #2
3401a93e:	2b00      	cmp	r3, #0
3401a940:	d018      	beq.n	3401a974 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
3401a942:	687b      	ldr	r3, [r7, #4]
3401a944:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401a946:	2b00      	cmp	r3, #0
3401a948:	d009      	beq.n	3401a95e <UART_AdvFeatureConfig+0xbe>
3401a94a:	687b      	ldr	r3, [r7, #4]
3401a94c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401a94e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401a952:	d004      	beq.n	3401a95e <UART_AdvFeatureConfig+0xbe>
3401a954:	f640 41f4 	movw	r1, #3316	@ 0xcf4
3401a958:	4867      	ldr	r0, [pc, #412]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401a95a:	f7e6 fc9d 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
3401a95e:	687b      	ldr	r3, [r7, #4]
3401a960:	681b      	ldr	r3, [r3, #0]
3401a962:	685b      	ldr	r3, [r3, #4]
3401a964:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3401a968:	687b      	ldr	r3, [r7, #4]
3401a96a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3401a96c:	687b      	ldr	r3, [r7, #4]
3401a96e:	681b      	ldr	r3, [r3, #0]
3401a970:	430a      	orrs	r2, r1
3401a972:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
3401a974:	687b      	ldr	r3, [r7, #4]
3401a976:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a978:	f003 0304 	and.w	r3, r3, #4
3401a97c:	2b00      	cmp	r3, #0
3401a97e:	d018      	beq.n	3401a9b2 <UART_AdvFeatureConfig+0x112>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
3401a980:	687b      	ldr	r3, [r7, #4]
3401a982:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401a984:	2b00      	cmp	r3, #0
3401a986:	d009      	beq.n	3401a99c <UART_AdvFeatureConfig+0xfc>
3401a988:	687b      	ldr	r3, [r7, #4]
3401a98a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401a98c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3401a990:	d004      	beq.n	3401a99c <UART_AdvFeatureConfig+0xfc>
3401a992:	f640 41fb 	movw	r1, #3323	@ 0xcfb
3401a996:	4858      	ldr	r0, [pc, #352]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401a998:	f7e6 fc7e 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
3401a99c:	687b      	ldr	r3, [r7, #4]
3401a99e:	681b      	ldr	r3, [r3, #0]
3401a9a0:	685b      	ldr	r3, [r3, #4]
3401a9a2:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
3401a9a6:	687b      	ldr	r3, [r7, #4]
3401a9a8:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3401a9aa:	687b      	ldr	r3, [r7, #4]
3401a9ac:	681b      	ldr	r3, [r3, #0]
3401a9ae:	430a      	orrs	r2, r1
3401a9b0:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
3401a9b2:	687b      	ldr	r3, [r7, #4]
3401a9b4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a9b6:	f003 0310 	and.w	r3, r3, #16
3401a9ba:	2b00      	cmp	r3, #0
3401a9bc:	d018      	beq.n	3401a9f0 <UART_AdvFeatureConfig+0x150>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
3401a9be:	687b      	ldr	r3, [r7, #4]
3401a9c0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401a9c2:	2b00      	cmp	r3, #0
3401a9c4:	d009      	beq.n	3401a9da <UART_AdvFeatureConfig+0x13a>
3401a9c6:	687b      	ldr	r3, [r7, #4]
3401a9c8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401a9ca:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401a9ce:	d004      	beq.n	3401a9da <UART_AdvFeatureConfig+0x13a>
3401a9d0:	f640 5102 	movw	r1, #3330	@ 0xd02
3401a9d4:	4848      	ldr	r0, [pc, #288]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401a9d6:	f7e6 fc5f 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
3401a9da:	687b      	ldr	r3, [r7, #4]
3401a9dc:	681b      	ldr	r3, [r3, #0]
3401a9de:	689b      	ldr	r3, [r3, #8]
3401a9e0:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
3401a9e4:	687b      	ldr	r3, [r7, #4]
3401a9e6:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3401a9e8:	687b      	ldr	r3, [r7, #4]
3401a9ea:	681b      	ldr	r3, [r3, #0]
3401a9ec:	430a      	orrs	r2, r1
3401a9ee:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
3401a9f0:	687b      	ldr	r3, [r7, #4]
3401a9f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401a9f4:	f003 0320 	and.w	r3, r3, #32
3401a9f8:	2b00      	cmp	r3, #0
3401a9fa:	d018      	beq.n	3401aa2e <UART_AdvFeatureConfig+0x18e>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
3401a9fc:	687b      	ldr	r3, [r7, #4]
3401a9fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401aa00:	2b00      	cmp	r3, #0
3401aa02:	d009      	beq.n	3401aa18 <UART_AdvFeatureConfig+0x178>
3401aa04:	687b      	ldr	r3, [r7, #4]
3401aa06:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401aa08:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3401aa0c:	d004      	beq.n	3401aa18 <UART_AdvFeatureConfig+0x178>
3401aa0e:	f640 510a 	movw	r1, #3338	@ 0xd0a
3401aa12:	4839      	ldr	r0, [pc, #228]	@ (3401aaf8 <UART_AdvFeatureConfig+0x258>)
3401aa14:	f7e6 fc40 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
3401aa18:	687b      	ldr	r3, [r7, #4]
3401aa1a:	681b      	ldr	r3, [r3, #0]
3401aa1c:	689b      	ldr	r3, [r3, #8]
3401aa1e:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
3401aa22:	687b      	ldr	r3, [r7, #4]
3401aa24:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3401aa26:	687b      	ldr	r3, [r7, #4]
3401aa28:	681b      	ldr	r3, [r3, #0]
3401aa2a:	430a      	orrs	r2, r1
3401aa2c:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
3401aa2e:	687b      	ldr	r3, [r7, #4]
3401aa30:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401aa32:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401aa36:	2b00      	cmp	r3, #0
3401aa38:	f000 80d2 	beq.w	3401abe0 <UART_AdvFeatureConfig+0x340>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
3401aa3c:	687b      	ldr	r3, [r7, #4]
3401aa3e:	681b      	ldr	r3, [r3, #0]
3401aa40:	4a2e      	ldr	r2, [pc, #184]	@ (3401aafc <UART_AdvFeatureConfig+0x25c>)
3401aa42:	4293      	cmp	r3, r2
3401aa44:	f000 808b 	beq.w	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa48:	687b      	ldr	r3, [r7, #4]
3401aa4a:	681b      	ldr	r3, [r3, #0]
3401aa4c:	4a2c      	ldr	r2, [pc, #176]	@ (3401ab00 <UART_AdvFeatureConfig+0x260>)
3401aa4e:	4293      	cmp	r3, r2
3401aa50:	f000 8085 	beq.w	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa54:	687b      	ldr	r3, [r7, #4]
3401aa56:	681b      	ldr	r3, [r3, #0]
3401aa58:	4a2a      	ldr	r2, [pc, #168]	@ (3401ab04 <UART_AdvFeatureConfig+0x264>)
3401aa5a:	4293      	cmp	r3, r2
3401aa5c:	d07f      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa5e:	687b      	ldr	r3, [r7, #4]
3401aa60:	681b      	ldr	r3, [r3, #0]
3401aa62:	4a29      	ldr	r2, [pc, #164]	@ (3401ab08 <UART_AdvFeatureConfig+0x268>)
3401aa64:	4293      	cmp	r3, r2
3401aa66:	d07a      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa68:	687b      	ldr	r3, [r7, #4]
3401aa6a:	681b      	ldr	r3, [r3, #0]
3401aa6c:	4a27      	ldr	r2, [pc, #156]	@ (3401ab0c <UART_AdvFeatureConfig+0x26c>)
3401aa6e:	4293      	cmp	r3, r2
3401aa70:	d075      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa72:	687b      	ldr	r3, [r7, #4]
3401aa74:	681b      	ldr	r3, [r3, #0]
3401aa76:	4a26      	ldr	r2, [pc, #152]	@ (3401ab10 <UART_AdvFeatureConfig+0x270>)
3401aa78:	4293      	cmp	r3, r2
3401aa7a:	d070      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa7c:	687b      	ldr	r3, [r7, #4]
3401aa7e:	681b      	ldr	r3, [r3, #0]
3401aa80:	4a24      	ldr	r2, [pc, #144]	@ (3401ab14 <UART_AdvFeatureConfig+0x274>)
3401aa82:	4293      	cmp	r3, r2
3401aa84:	d06b      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa86:	687b      	ldr	r3, [r7, #4]
3401aa88:	681b      	ldr	r3, [r3, #0]
3401aa8a:	4a23      	ldr	r2, [pc, #140]	@ (3401ab18 <UART_AdvFeatureConfig+0x278>)
3401aa8c:	4293      	cmp	r3, r2
3401aa8e:	d066      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa90:	687b      	ldr	r3, [r7, #4]
3401aa92:	681b      	ldr	r3, [r3, #0]
3401aa94:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3401aa98:	d061      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aa9a:	687b      	ldr	r3, [r7, #4]
3401aa9c:	681b      	ldr	r3, [r3, #0]
3401aa9e:	4a1f      	ldr	r2, [pc, #124]	@ (3401ab1c <UART_AdvFeatureConfig+0x27c>)
3401aaa0:	4293      	cmp	r3, r2
3401aaa2:	d05c      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aaa4:	687b      	ldr	r3, [r7, #4]
3401aaa6:	681b      	ldr	r3, [r3, #0]
3401aaa8:	4a1d      	ldr	r2, [pc, #116]	@ (3401ab20 <UART_AdvFeatureConfig+0x280>)
3401aaaa:	4293      	cmp	r3, r2
3401aaac:	d057      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aaae:	687b      	ldr	r3, [r7, #4]
3401aab0:	681b      	ldr	r3, [r3, #0]
3401aab2:	4a1c      	ldr	r2, [pc, #112]	@ (3401ab24 <UART_AdvFeatureConfig+0x284>)
3401aab4:	4293      	cmp	r3, r2
3401aab6:	d052      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aab8:	687b      	ldr	r3, [r7, #4]
3401aaba:	681b      	ldr	r3, [r3, #0]
3401aabc:	4a1a      	ldr	r2, [pc, #104]	@ (3401ab28 <UART_AdvFeatureConfig+0x288>)
3401aabe:	4293      	cmp	r3, r2
3401aac0:	d04d      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aac2:	687b      	ldr	r3, [r7, #4]
3401aac4:	681b      	ldr	r3, [r3, #0]
3401aac6:	4a19      	ldr	r2, [pc, #100]	@ (3401ab2c <UART_AdvFeatureConfig+0x28c>)
3401aac8:	4293      	cmp	r3, r2
3401aaca:	d048      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aacc:	687b      	ldr	r3, [r7, #4]
3401aace:	681b      	ldr	r3, [r3, #0]
3401aad0:	4a17      	ldr	r2, [pc, #92]	@ (3401ab30 <UART_AdvFeatureConfig+0x290>)
3401aad2:	4293      	cmp	r3, r2
3401aad4:	d043      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aad6:	687b      	ldr	r3, [r7, #4]
3401aad8:	681b      	ldr	r3, [r3, #0]
3401aada:	4a16      	ldr	r2, [pc, #88]	@ (3401ab34 <UART_AdvFeatureConfig+0x294>)
3401aadc:	4293      	cmp	r3, r2
3401aade:	d03e      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aae0:	687b      	ldr	r3, [r7, #4]
3401aae2:	681b      	ldr	r3, [r3, #0]
3401aae4:	4a14      	ldr	r2, [pc, #80]	@ (3401ab38 <UART_AdvFeatureConfig+0x298>)
3401aae6:	4293      	cmp	r3, r2
3401aae8:	d039      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aaea:	687b      	ldr	r3, [r7, #4]
3401aaec:	681b      	ldr	r3, [r3, #0]
3401aaee:	4a13      	ldr	r2, [pc, #76]	@ (3401ab3c <UART_AdvFeatureConfig+0x29c>)
3401aaf0:	4293      	cmp	r3, r2
3401aaf2:	d034      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401aaf4:	e024      	b.n	3401ab40 <UART_AdvFeatureConfig+0x2a0>
3401aaf6:	bf00      	nop
3401aaf8:	34024530 	.word	0x34024530
3401aafc:	52001000 	.word	0x52001000
3401ab00:	42001000 	.word	0x42001000
3401ab04:	50004400 	.word	0x50004400
3401ab08:	40004400 	.word	0x40004400
3401ab0c:	50004800 	.word	0x50004800
3401ab10:	40004800 	.word	0x40004800
3401ab14:	50004c00 	.word	0x50004c00
3401ab18:	40004c00 	.word	0x40004c00
3401ab1c:	40005000 	.word	0x40005000
3401ab20:	52001400 	.word	0x52001400
3401ab24:	42001400 	.word	0x42001400
3401ab28:	50007800 	.word	0x50007800
3401ab2c:	40007800 	.word	0x40007800
3401ab30:	50007c00 	.word	0x50007c00
3401ab34:	40007c00 	.word	0x40007c00
3401ab38:	52001800 	.word	0x52001800
3401ab3c:	42001800 	.word	0x42001800
3401ab40:	687b      	ldr	r3, [r7, #4]
3401ab42:	681b      	ldr	r3, [r3, #0]
3401ab44:	4a38      	ldr	r2, [pc, #224]	@ (3401ac28 <UART_AdvFeatureConfig+0x388>)
3401ab46:	4293      	cmp	r3, r2
3401ab48:	d009      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401ab4a:	687b      	ldr	r3, [r7, #4]
3401ab4c:	681b      	ldr	r3, [r3, #0]
3401ab4e:	4a37      	ldr	r2, [pc, #220]	@ (3401ac2c <UART_AdvFeatureConfig+0x38c>)
3401ab50:	4293      	cmp	r3, r2
3401ab52:	d004      	beq.n	3401ab5e <UART_AdvFeatureConfig+0x2be>
3401ab54:	f640 5112 	movw	r1, #3346	@ 0xd12
3401ab58:	4835      	ldr	r0, [pc, #212]	@ (3401ac30 <UART_AdvFeatureConfig+0x390>)
3401ab5a:	f7e6 fb9d 	bl	34001298 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
3401ab5e:	687b      	ldr	r3, [r7, #4]
3401ab60:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401ab62:	2b00      	cmp	r3, #0
3401ab64:	d009      	beq.n	3401ab7a <UART_AdvFeatureConfig+0x2da>
3401ab66:	687b      	ldr	r3, [r7, #4]
3401ab68:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401ab6a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401ab6e:	d004      	beq.n	3401ab7a <UART_AdvFeatureConfig+0x2da>
3401ab70:	f640 5113 	movw	r1, #3347	@ 0xd13
3401ab74:	482e      	ldr	r0, [pc, #184]	@ (3401ac30 <UART_AdvFeatureConfig+0x390>)
3401ab76:	f7e6 fb8f 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
3401ab7a:	687b      	ldr	r3, [r7, #4]
3401ab7c:	681b      	ldr	r3, [r3, #0]
3401ab7e:	685b      	ldr	r3, [r3, #4]
3401ab80:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
3401ab84:	687b      	ldr	r3, [r7, #4]
3401ab86:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3401ab88:	687b      	ldr	r3, [r7, #4]
3401ab8a:	681b      	ldr	r3, [r3, #0]
3401ab8c:	430a      	orrs	r2, r1
3401ab8e:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3401ab90:	687b      	ldr	r3, [r7, #4]
3401ab92:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401ab94:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401ab98:	d122      	bne.n	3401abe0 <UART_AdvFeatureConfig+0x340>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
3401ab9a:	687b      	ldr	r3, [r7, #4]
3401ab9c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401ab9e:	2b00      	cmp	r3, #0
3401aba0:	d013      	beq.n	3401abca <UART_AdvFeatureConfig+0x32a>
3401aba2:	687b      	ldr	r3, [r7, #4]
3401aba4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401aba6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3401abaa:	d00e      	beq.n	3401abca <UART_AdvFeatureConfig+0x32a>
3401abac:	687b      	ldr	r3, [r7, #4]
3401abae:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401abb0:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3401abb4:	d009      	beq.n	3401abca <UART_AdvFeatureConfig+0x32a>
3401abb6:	687b      	ldr	r3, [r7, #4]
3401abb8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401abba:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
3401abbe:	d004      	beq.n	3401abca <UART_AdvFeatureConfig+0x32a>
3401abc0:	f640 5118 	movw	r1, #3352	@ 0xd18
3401abc4:	481a      	ldr	r0, [pc, #104]	@ (3401ac30 <UART_AdvFeatureConfig+0x390>)
3401abc6:	f7e6 fb67 	bl	34001298 <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
3401abca:	687b      	ldr	r3, [r7, #4]
3401abcc:	681b      	ldr	r3, [r3, #0]
3401abce:	685b      	ldr	r3, [r3, #4]
3401abd0:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
3401abd4:	687b      	ldr	r3, [r7, #4]
3401abd6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401abd8:	687b      	ldr	r3, [r7, #4]
3401abda:	681b      	ldr	r3, [r3, #0]
3401abdc:	430a      	orrs	r2, r1
3401abde:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
3401abe0:	687b      	ldr	r3, [r7, #4]
3401abe2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401abe4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3401abe8:	2b00      	cmp	r3, #0
3401abea:	d018      	beq.n	3401ac1e <UART_AdvFeatureConfig+0x37e>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
3401abec:	687b      	ldr	r3, [r7, #4]
3401abee:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401abf0:	2b00      	cmp	r3, #0
3401abf2:	d009      	beq.n	3401ac08 <UART_AdvFeatureConfig+0x368>
3401abf4:	687b      	ldr	r3, [r7, #4]
3401abf6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401abf8:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
3401abfc:	d004      	beq.n	3401ac08 <UART_AdvFeatureConfig+0x368>
3401abfe:	f44f 6152 	mov.w	r1, #3360	@ 0xd20
3401ac02:	480b      	ldr	r0, [pc, #44]	@ (3401ac30 <UART_AdvFeatureConfig+0x390>)
3401ac04:	f7e6 fb48 	bl	34001298 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
3401ac08:	687b      	ldr	r3, [r7, #4]
3401ac0a:	681b      	ldr	r3, [r3, #0]
3401ac0c:	685b      	ldr	r3, [r3, #4]
3401ac0e:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
3401ac12:	687b      	ldr	r3, [r7, #4]
3401ac14:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3401ac16:	687b      	ldr	r3, [r7, #4]
3401ac18:	681b      	ldr	r3, [r3, #0]
3401ac1a:	430a      	orrs	r2, r1
3401ac1c:	605a      	str	r2, [r3, #4]
  }
}
3401ac1e:	bf00      	nop
3401ac20:	3708      	adds	r7, #8
3401ac22:	46bd      	mov	sp, r7
3401ac24:	bd80      	pop	{r7, pc}
3401ac26:	bf00      	nop
3401ac28:	52001c00 	.word	0x52001c00
3401ac2c:	42001c00 	.word	0x42001c00
3401ac30:	34024530 	.word	0x34024530

3401ac34 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
3401ac34:	b580      	push	{r7, lr}
3401ac36:	b098      	sub	sp, #96	@ 0x60
3401ac38:	af02      	add	r7, sp, #8
3401ac3a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
3401ac3c:	687b      	ldr	r3, [r7, #4]
3401ac3e:	2200      	movs	r2, #0
3401ac40:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
3401ac44:	f7ec fccc 	bl	340075e0 <HAL_GetTick>
3401ac48:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
3401ac4a:	687b      	ldr	r3, [r7, #4]
3401ac4c:	681b      	ldr	r3, [r3, #0]
3401ac4e:	681b      	ldr	r3, [r3, #0]
3401ac50:	f003 0308 	and.w	r3, r3, #8
3401ac54:	2b08      	cmp	r3, #8
3401ac56:	d12f      	bne.n	3401acb8 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3401ac58:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3401ac5c:	9300      	str	r3, [sp, #0]
3401ac5e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401ac60:	2200      	movs	r2, #0
3401ac62:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
3401ac66:	6878      	ldr	r0, [r7, #4]
3401ac68:	f000 f88e 	bl	3401ad88 <UART_WaitOnFlagUntilTimeout>
3401ac6c:	4603      	mov	r3, r0
3401ac6e:	2b00      	cmp	r3, #0
3401ac70:	d022      	beq.n	3401acb8 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
3401ac72:	687b      	ldr	r3, [r7, #4]
3401ac74:	681b      	ldr	r3, [r3, #0]
3401ac76:	63bb      	str	r3, [r7, #56]	@ 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401ac78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3401ac7a:	e853 3f00 	ldrex	r3, [r3]
3401ac7e:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
3401ac80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3401ac82:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
3401ac86:	653b      	str	r3, [r7, #80]	@ 0x50
3401ac88:	687b      	ldr	r3, [r7, #4]
3401ac8a:	681b      	ldr	r3, [r3, #0]
3401ac8c:	461a      	mov	r2, r3
3401ac8e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3401ac90:	647b      	str	r3, [r7, #68]	@ 0x44
3401ac92:	643a      	str	r2, [r7, #64]	@ 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401ac94:	6c39      	ldr	r1, [r7, #64]	@ 0x40
3401ac96:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401ac98:	e841 2300 	strex	r3, r2, [r1]
3401ac9c:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
3401ac9e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401aca0:	2b00      	cmp	r3, #0
3401aca2:	d1e6      	bne.n	3401ac72 <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
3401aca4:	687b      	ldr	r3, [r7, #4]
3401aca6:	2220      	movs	r2, #32
3401aca8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
3401acac:	687b      	ldr	r3, [r7, #4]
3401acae:	2200      	movs	r2, #0
3401acb0:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
3401acb4:	2303      	movs	r3, #3
3401acb6:	e063      	b.n	3401ad80 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
3401acb8:	687b      	ldr	r3, [r7, #4]
3401acba:	681b      	ldr	r3, [r3, #0]
3401acbc:	681b      	ldr	r3, [r3, #0]
3401acbe:	f003 0304 	and.w	r3, r3, #4
3401acc2:	2b04      	cmp	r3, #4
3401acc4:	d149      	bne.n	3401ad5a <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3401acc6:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3401acca:	9300      	str	r3, [sp, #0]
3401accc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401acce:	2200      	movs	r2, #0
3401acd0:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
3401acd4:	6878      	ldr	r0, [r7, #4]
3401acd6:	f000 f857 	bl	3401ad88 <UART_WaitOnFlagUntilTimeout>
3401acda:	4603      	mov	r3, r0
3401acdc:	2b00      	cmp	r3, #0
3401acde:	d03c      	beq.n	3401ad5a <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3401ace0:	687b      	ldr	r3, [r7, #4]
3401ace2:	681b      	ldr	r3, [r3, #0]
3401ace4:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401ace6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401ace8:	e853 3f00 	ldrex	r3, [r3]
3401acec:	623b      	str	r3, [r7, #32]
   return(result);
3401acee:	6a3b      	ldr	r3, [r7, #32]
3401acf0:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
3401acf4:	64fb      	str	r3, [r7, #76]	@ 0x4c
3401acf6:	687b      	ldr	r3, [r7, #4]
3401acf8:	681b      	ldr	r3, [r3, #0]
3401acfa:	461a      	mov	r2, r3
3401acfc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401acfe:	633b      	str	r3, [r7, #48]	@ 0x30
3401ad00:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401ad02:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
3401ad04:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3401ad06:	e841 2300 	strex	r3, r2, [r1]
3401ad0a:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
3401ad0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401ad0e:	2b00      	cmp	r3, #0
3401ad10:	d1e6      	bne.n	3401ace0 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
3401ad12:	687b      	ldr	r3, [r7, #4]
3401ad14:	681b      	ldr	r3, [r3, #0]
3401ad16:	3308      	adds	r3, #8
3401ad18:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401ad1a:	693b      	ldr	r3, [r7, #16]
3401ad1c:	e853 3f00 	ldrex	r3, [r3]
3401ad20:	60fb      	str	r3, [r7, #12]
   return(result);
3401ad22:	68fb      	ldr	r3, [r7, #12]
3401ad24:	f023 0301 	bic.w	r3, r3, #1
3401ad28:	64bb      	str	r3, [r7, #72]	@ 0x48
3401ad2a:	687b      	ldr	r3, [r7, #4]
3401ad2c:	681b      	ldr	r3, [r3, #0]
3401ad2e:	3308      	adds	r3, #8
3401ad30:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3401ad32:	61fa      	str	r2, [r7, #28]
3401ad34:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401ad36:	69b9      	ldr	r1, [r7, #24]
3401ad38:	69fa      	ldr	r2, [r7, #28]
3401ad3a:	e841 2300 	strex	r3, r2, [r1]
3401ad3e:	617b      	str	r3, [r7, #20]
   return(result);
3401ad40:	697b      	ldr	r3, [r7, #20]
3401ad42:	2b00      	cmp	r3, #0
3401ad44:	d1e5      	bne.n	3401ad12 <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
3401ad46:	687b      	ldr	r3, [r7, #4]
3401ad48:	2220      	movs	r2, #32
3401ad4a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
3401ad4e:	687b      	ldr	r3, [r7, #4]
3401ad50:	2200      	movs	r2, #0
3401ad52:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
3401ad56:	2303      	movs	r3, #3
3401ad58:	e012      	b.n	3401ad80 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
3401ad5a:	687b      	ldr	r3, [r7, #4]
3401ad5c:	2220      	movs	r2, #32
3401ad5e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
3401ad62:	687b      	ldr	r3, [r7, #4]
3401ad64:	2220      	movs	r2, #32
3401ad66:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3401ad6a:	687b      	ldr	r3, [r7, #4]
3401ad6c:	2200      	movs	r2, #0
3401ad6e:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
3401ad70:	687b      	ldr	r3, [r7, #4]
3401ad72:	2200      	movs	r2, #0
3401ad74:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
3401ad76:	687b      	ldr	r3, [r7, #4]
3401ad78:	2200      	movs	r2, #0
3401ad7a:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
3401ad7e:	2300      	movs	r3, #0
}
3401ad80:	4618      	mov	r0, r3
3401ad82:	3758      	adds	r7, #88	@ 0x58
3401ad84:	46bd      	mov	sp, r7
3401ad86:	bd80      	pop	{r7, pc}

3401ad88 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
3401ad88:	b580      	push	{r7, lr}
3401ad8a:	b084      	sub	sp, #16
3401ad8c:	af00      	add	r7, sp, #0
3401ad8e:	60f8      	str	r0, [r7, #12]
3401ad90:	60b9      	str	r1, [r7, #8]
3401ad92:	603b      	str	r3, [r7, #0]
3401ad94:	4613      	mov	r3, r2
3401ad96:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
3401ad98:	e04f      	b.n	3401ae3a <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3401ad9a:	69bb      	ldr	r3, [r7, #24]
3401ad9c:	f1b3 3fff 	cmp.w	r3, #4294967295
3401ada0:	d04b      	beq.n	3401ae3a <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3401ada2:	f7ec fc1d 	bl	340075e0 <HAL_GetTick>
3401ada6:	4602      	mov	r2, r0
3401ada8:	683b      	ldr	r3, [r7, #0]
3401adaa:	1ad3      	subs	r3, r2, r3
3401adac:	69ba      	ldr	r2, [r7, #24]
3401adae:	429a      	cmp	r2, r3
3401adb0:	d302      	bcc.n	3401adb8 <UART_WaitOnFlagUntilTimeout+0x30>
3401adb2:	69bb      	ldr	r3, [r7, #24]
3401adb4:	2b00      	cmp	r3, #0
3401adb6:	d101      	bne.n	3401adbc <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
3401adb8:	2303      	movs	r3, #3
3401adba:	e04e      	b.n	3401ae5a <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
3401adbc:	68fb      	ldr	r3, [r7, #12]
3401adbe:	681b      	ldr	r3, [r3, #0]
3401adc0:	681b      	ldr	r3, [r3, #0]
3401adc2:	f003 0304 	and.w	r3, r3, #4
3401adc6:	2b00      	cmp	r3, #0
3401adc8:	d037      	beq.n	3401ae3a <UART_WaitOnFlagUntilTimeout+0xb2>
3401adca:	68bb      	ldr	r3, [r7, #8]
3401adcc:	2b80      	cmp	r3, #128	@ 0x80
3401adce:	d034      	beq.n	3401ae3a <UART_WaitOnFlagUntilTimeout+0xb2>
3401add0:	68bb      	ldr	r3, [r7, #8]
3401add2:	2b40      	cmp	r3, #64	@ 0x40
3401add4:	d031      	beq.n	3401ae3a <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
3401add6:	68fb      	ldr	r3, [r7, #12]
3401add8:	681b      	ldr	r3, [r3, #0]
3401adda:	69db      	ldr	r3, [r3, #28]
3401addc:	f003 0308 	and.w	r3, r3, #8
3401ade0:	2b08      	cmp	r3, #8
3401ade2:	d110      	bne.n	3401ae06 <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
3401ade4:	68fb      	ldr	r3, [r7, #12]
3401ade6:	681b      	ldr	r3, [r3, #0]
3401ade8:	2208      	movs	r2, #8
3401adea:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
3401adec:	68f8      	ldr	r0, [r7, #12]
3401adee:	f000 f838 	bl	3401ae62 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
3401adf2:	68fb      	ldr	r3, [r7, #12]
3401adf4:	2208      	movs	r2, #8
3401adf6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
3401adfa:	68fb      	ldr	r3, [r7, #12]
3401adfc:	2200      	movs	r2, #0
3401adfe:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
3401ae02:	2301      	movs	r3, #1
3401ae04:	e029      	b.n	3401ae5a <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
3401ae06:	68fb      	ldr	r3, [r7, #12]
3401ae08:	681b      	ldr	r3, [r3, #0]
3401ae0a:	69db      	ldr	r3, [r3, #28]
3401ae0c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3401ae10:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3401ae14:	d111      	bne.n	3401ae3a <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
3401ae16:	68fb      	ldr	r3, [r7, #12]
3401ae18:	681b      	ldr	r3, [r3, #0]
3401ae1a:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3401ae1e:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
3401ae20:	68f8      	ldr	r0, [r7, #12]
3401ae22:	f000 f81e 	bl	3401ae62 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
3401ae26:	68fb      	ldr	r3, [r7, #12]
3401ae28:	2220      	movs	r2, #32
3401ae2a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
3401ae2e:	68fb      	ldr	r3, [r7, #12]
3401ae30:	2200      	movs	r2, #0
3401ae32:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
3401ae36:	2303      	movs	r3, #3
3401ae38:	e00f      	b.n	3401ae5a <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
3401ae3a:	68fb      	ldr	r3, [r7, #12]
3401ae3c:	681b      	ldr	r3, [r3, #0]
3401ae3e:	69da      	ldr	r2, [r3, #28]
3401ae40:	68bb      	ldr	r3, [r7, #8]
3401ae42:	4013      	ands	r3, r2
3401ae44:	68ba      	ldr	r2, [r7, #8]
3401ae46:	429a      	cmp	r2, r3
3401ae48:	bf0c      	ite	eq
3401ae4a:	2301      	moveq	r3, #1
3401ae4c:	2300      	movne	r3, #0
3401ae4e:	b2db      	uxtb	r3, r3
3401ae50:	461a      	mov	r2, r3
3401ae52:	79fb      	ldrb	r3, [r7, #7]
3401ae54:	429a      	cmp	r2, r3
3401ae56:	d0a0      	beq.n	3401ad9a <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
3401ae58:	2300      	movs	r3, #0
}
3401ae5a:	4618      	mov	r0, r3
3401ae5c:	3710      	adds	r7, #16
3401ae5e:	46bd      	mov	sp, r7
3401ae60:	bd80      	pop	{r7, pc}

3401ae62 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
3401ae62:	b480      	push	{r7}
3401ae64:	b095      	sub	sp, #84	@ 0x54
3401ae66:	af00      	add	r7, sp, #0
3401ae68:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3401ae6a:	687b      	ldr	r3, [r7, #4]
3401ae6c:	681b      	ldr	r3, [r3, #0]
3401ae6e:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401ae70:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3401ae72:	e853 3f00 	ldrex	r3, [r3]
3401ae76:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
3401ae78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3401ae7a:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
3401ae7e:	64fb      	str	r3, [r7, #76]	@ 0x4c
3401ae80:	687b      	ldr	r3, [r7, #4]
3401ae82:	681b      	ldr	r3, [r3, #0]
3401ae84:	461a      	mov	r2, r3
3401ae86:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ae88:	643b      	str	r3, [r7, #64]	@ 0x40
3401ae8a:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401ae8c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3401ae8e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3401ae90:	e841 2300 	strex	r3, r2, [r1]
3401ae94:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
3401ae96:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3401ae98:	2b00      	cmp	r3, #0
3401ae9a:	d1e6      	bne.n	3401ae6a <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
3401ae9c:	687b      	ldr	r3, [r7, #4]
3401ae9e:	681b      	ldr	r3, [r3, #0]
3401aea0:	3308      	adds	r3, #8
3401aea2:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401aea4:	6a3b      	ldr	r3, [r7, #32]
3401aea6:	e853 3f00 	ldrex	r3, [r3]
3401aeaa:	61fb      	str	r3, [r7, #28]
   return(result);
3401aeac:	69fb      	ldr	r3, [r7, #28]
3401aeae:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
3401aeb2:	f023 0301 	bic.w	r3, r3, #1
3401aeb6:	64bb      	str	r3, [r7, #72]	@ 0x48
3401aeb8:	687b      	ldr	r3, [r7, #4]
3401aeba:	681b      	ldr	r3, [r3, #0]
3401aebc:	3308      	adds	r3, #8
3401aebe:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3401aec0:	62fa      	str	r2, [r7, #44]	@ 0x2c
3401aec2:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401aec4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3401aec6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3401aec8:	e841 2300 	strex	r3, r2, [r1]
3401aecc:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
3401aece:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401aed0:	2b00      	cmp	r3, #0
3401aed2:	d1e3      	bne.n	3401ae9c <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
3401aed4:	687b      	ldr	r3, [r7, #4]
3401aed6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3401aed8:	2b01      	cmp	r3, #1
3401aeda:	d118      	bne.n	3401af0e <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
3401aedc:	687b      	ldr	r3, [r7, #4]
3401aede:	681b      	ldr	r3, [r3, #0]
3401aee0:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3401aee2:	68fb      	ldr	r3, [r7, #12]
3401aee4:	e853 3f00 	ldrex	r3, [r3]
3401aee8:	60bb      	str	r3, [r7, #8]
   return(result);
3401aeea:	68bb      	ldr	r3, [r7, #8]
3401aeec:	f023 0310 	bic.w	r3, r3, #16
3401aef0:	647b      	str	r3, [r7, #68]	@ 0x44
3401aef2:	687b      	ldr	r3, [r7, #4]
3401aef4:	681b      	ldr	r3, [r3, #0]
3401aef6:	461a      	mov	r2, r3
3401aef8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401aefa:	61bb      	str	r3, [r7, #24]
3401aefc:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3401aefe:	6979      	ldr	r1, [r7, #20]
3401af00:	69ba      	ldr	r2, [r7, #24]
3401af02:	e841 2300 	strex	r3, r2, [r1]
3401af06:	613b      	str	r3, [r7, #16]
   return(result);
3401af08:	693b      	ldr	r3, [r7, #16]
3401af0a:	2b00      	cmp	r3, #0
3401af0c:	d1e6      	bne.n	3401aedc <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
3401af0e:	687b      	ldr	r3, [r7, #4]
3401af10:	2220      	movs	r2, #32
3401af12:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3401af16:	687b      	ldr	r3, [r7, #4]
3401af18:	2200      	movs	r2, #0
3401af1a:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
3401af1c:	687b      	ldr	r3, [r7, #4]
3401af1e:	2200      	movs	r2, #0
3401af20:	675a      	str	r2, [r3, #116]	@ 0x74
}
3401af22:	bf00      	nop
3401af24:	3754      	adds	r7, #84	@ 0x54
3401af26:	46bd      	mov	sp, r7
3401af28:	f85d 7b04 	ldr.w	r7, [sp], #4
3401af2c:	4770      	bx	lr
	...

3401af30 <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
3401af30:	b580      	push	{r7, lr}
3401af32:	b086      	sub	sp, #24
3401af34:	af02      	add	r7, sp, #8
3401af36:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3401af38:	2300      	movs	r3, #0
3401af3a:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
3401af3c:	f7ec fb50 	bl	340075e0 <HAL_GetTick>
3401af40:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
3401af42:	687b      	ldr	r3, [r7, #4]
3401af44:	2b00      	cmp	r3, #0
3401af46:	d102      	bne.n	3401af4e <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
3401af48:	2301      	movs	r3, #1
3401af4a:	73fb      	strb	r3, [r7, #15]
3401af4c:	e2c8      	b.n	3401b4e0 <HAL_XSPI_Init+0x5b0>
    /* No error code can be set set as the handler is null */
  }
  else
  {
    /* Check the parameters of the initialization structure */
    assert_param(IS_XSPI_MEMORY_MODE(hxspi->Init.MemoryMode));
3401af4e:	687b      	ldr	r3, [r7, #4]
3401af50:	689b      	ldr	r3, [r3, #8]
3401af52:	2b00      	cmp	r3, #0
3401af54:	d008      	beq.n	3401af68 <HAL_XSPI_Init+0x38>
3401af56:	687b      	ldr	r3, [r7, #4]
3401af58:	689b      	ldr	r3, [r3, #8]
3401af5a:	2b40      	cmp	r3, #64	@ 0x40
3401af5c:	d004      	beq.n	3401af68 <HAL_XSPI_Init+0x38>
3401af5e:	f240 1161 	movw	r1, #353	@ 0x161
3401af62:	488a      	ldr	r0, [pc, #552]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401af64:	f7e6 f998 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_MEMORY_TYPE(hxspi->Init.MemoryType));
3401af68:	687b      	ldr	r3, [r7, #4]
3401af6a:	68db      	ldr	r3, [r3, #12]
3401af6c:	2b00      	cmp	r3, #0
3401af6e:	d01d      	beq.n	3401afac <HAL_XSPI_Init+0x7c>
3401af70:	687b      	ldr	r3, [r7, #4]
3401af72:	68db      	ldr	r3, [r3, #12]
3401af74:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401af78:	d018      	beq.n	3401afac <HAL_XSPI_Init+0x7c>
3401af7a:	687b      	ldr	r3, [r7, #4]
3401af7c:	68db      	ldr	r3, [r3, #12]
3401af7e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3401af82:	d013      	beq.n	3401afac <HAL_XSPI_Init+0x7c>
3401af84:	687b      	ldr	r3, [r7, #4]
3401af86:	68db      	ldr	r3, [r3, #12]
3401af88:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3401af8c:	d00e      	beq.n	3401afac <HAL_XSPI_Init+0x7c>
3401af8e:	687b      	ldr	r3, [r7, #4]
3401af90:	68db      	ldr	r3, [r3, #12]
3401af92:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401af96:	d009      	beq.n	3401afac <HAL_XSPI_Init+0x7c>
3401af98:	687b      	ldr	r3, [r7, #4]
3401af9a:	68db      	ldr	r3, [r3, #12]
3401af9c:	f1b3 6fc0 	cmp.w	r3, #100663296	@ 0x6000000
3401afa0:	d004      	beq.n	3401afac <HAL_XSPI_Init+0x7c>
3401afa2:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3401afa6:	4879      	ldr	r0, [pc, #484]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401afa8:	f7e6 f976 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_MEMORY_SIZE(hxspi->Init.MemorySize));
3401afac:	687b      	ldr	r3, [r7, #4]
3401afae:	691b      	ldr	r3, [r3, #16]
3401afb0:	2b00      	cmp	r3, #0
3401afb2:	f000 8081 	beq.w	3401b0b8 <HAL_XSPI_Init+0x188>
3401afb6:	687b      	ldr	r3, [r7, #4]
3401afb8:	691b      	ldr	r3, [r3, #16]
3401afba:	2b01      	cmp	r3, #1
3401afbc:	d07c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afbe:	687b      	ldr	r3, [r7, #4]
3401afc0:	691b      	ldr	r3, [r3, #16]
3401afc2:	2b02      	cmp	r3, #2
3401afc4:	d078      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afc6:	687b      	ldr	r3, [r7, #4]
3401afc8:	691b      	ldr	r3, [r3, #16]
3401afca:	2b03      	cmp	r3, #3
3401afcc:	d074      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afce:	687b      	ldr	r3, [r7, #4]
3401afd0:	691b      	ldr	r3, [r3, #16]
3401afd2:	2b04      	cmp	r3, #4
3401afd4:	d070      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afd6:	687b      	ldr	r3, [r7, #4]
3401afd8:	691b      	ldr	r3, [r3, #16]
3401afda:	2b05      	cmp	r3, #5
3401afdc:	d06c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afde:	687b      	ldr	r3, [r7, #4]
3401afe0:	691b      	ldr	r3, [r3, #16]
3401afe2:	2b06      	cmp	r3, #6
3401afe4:	d068      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afe6:	687b      	ldr	r3, [r7, #4]
3401afe8:	691b      	ldr	r3, [r3, #16]
3401afea:	2b07      	cmp	r3, #7
3401afec:	d064      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401afee:	687b      	ldr	r3, [r7, #4]
3401aff0:	691b      	ldr	r3, [r3, #16]
3401aff2:	2b08      	cmp	r3, #8
3401aff4:	d060      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401aff6:	687b      	ldr	r3, [r7, #4]
3401aff8:	691b      	ldr	r3, [r3, #16]
3401affa:	2b09      	cmp	r3, #9
3401affc:	d05c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401affe:	687b      	ldr	r3, [r7, #4]
3401b000:	691b      	ldr	r3, [r3, #16]
3401b002:	2b0a      	cmp	r3, #10
3401b004:	d058      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b006:	687b      	ldr	r3, [r7, #4]
3401b008:	691b      	ldr	r3, [r3, #16]
3401b00a:	2b0b      	cmp	r3, #11
3401b00c:	d054      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b00e:	687b      	ldr	r3, [r7, #4]
3401b010:	691b      	ldr	r3, [r3, #16]
3401b012:	2b0c      	cmp	r3, #12
3401b014:	d050      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b016:	687b      	ldr	r3, [r7, #4]
3401b018:	691b      	ldr	r3, [r3, #16]
3401b01a:	2b0d      	cmp	r3, #13
3401b01c:	d04c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b01e:	687b      	ldr	r3, [r7, #4]
3401b020:	691b      	ldr	r3, [r3, #16]
3401b022:	2b0e      	cmp	r3, #14
3401b024:	d048      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b026:	687b      	ldr	r3, [r7, #4]
3401b028:	691b      	ldr	r3, [r3, #16]
3401b02a:	2b0f      	cmp	r3, #15
3401b02c:	d044      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b02e:	687b      	ldr	r3, [r7, #4]
3401b030:	691b      	ldr	r3, [r3, #16]
3401b032:	2b10      	cmp	r3, #16
3401b034:	d040      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b036:	687b      	ldr	r3, [r7, #4]
3401b038:	691b      	ldr	r3, [r3, #16]
3401b03a:	2b11      	cmp	r3, #17
3401b03c:	d03c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b03e:	687b      	ldr	r3, [r7, #4]
3401b040:	691b      	ldr	r3, [r3, #16]
3401b042:	2b12      	cmp	r3, #18
3401b044:	d038      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b046:	687b      	ldr	r3, [r7, #4]
3401b048:	691b      	ldr	r3, [r3, #16]
3401b04a:	2b13      	cmp	r3, #19
3401b04c:	d034      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b04e:	687b      	ldr	r3, [r7, #4]
3401b050:	691b      	ldr	r3, [r3, #16]
3401b052:	2b14      	cmp	r3, #20
3401b054:	d030      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b056:	687b      	ldr	r3, [r7, #4]
3401b058:	691b      	ldr	r3, [r3, #16]
3401b05a:	2b15      	cmp	r3, #21
3401b05c:	d02c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b05e:	687b      	ldr	r3, [r7, #4]
3401b060:	691b      	ldr	r3, [r3, #16]
3401b062:	2b16      	cmp	r3, #22
3401b064:	d028      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b066:	687b      	ldr	r3, [r7, #4]
3401b068:	691b      	ldr	r3, [r3, #16]
3401b06a:	2b17      	cmp	r3, #23
3401b06c:	d024      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b06e:	687b      	ldr	r3, [r7, #4]
3401b070:	691b      	ldr	r3, [r3, #16]
3401b072:	2b18      	cmp	r3, #24
3401b074:	d020      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b076:	687b      	ldr	r3, [r7, #4]
3401b078:	691b      	ldr	r3, [r3, #16]
3401b07a:	2b19      	cmp	r3, #25
3401b07c:	d01c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b07e:	687b      	ldr	r3, [r7, #4]
3401b080:	691b      	ldr	r3, [r3, #16]
3401b082:	2b1a      	cmp	r3, #26
3401b084:	d018      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b086:	687b      	ldr	r3, [r7, #4]
3401b088:	691b      	ldr	r3, [r3, #16]
3401b08a:	2b1b      	cmp	r3, #27
3401b08c:	d014      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b08e:	687b      	ldr	r3, [r7, #4]
3401b090:	691b      	ldr	r3, [r3, #16]
3401b092:	2b1c      	cmp	r3, #28
3401b094:	d010      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b096:	687b      	ldr	r3, [r7, #4]
3401b098:	691b      	ldr	r3, [r3, #16]
3401b09a:	2b1d      	cmp	r3, #29
3401b09c:	d00c      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b09e:	687b      	ldr	r3, [r7, #4]
3401b0a0:	691b      	ldr	r3, [r3, #16]
3401b0a2:	2b1e      	cmp	r3, #30
3401b0a4:	d008      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b0a6:	687b      	ldr	r3, [r7, #4]
3401b0a8:	691b      	ldr	r3, [r3, #16]
3401b0aa:	2b1f      	cmp	r3, #31
3401b0ac:	d004      	beq.n	3401b0b8 <HAL_XSPI_Init+0x188>
3401b0ae:	f240 1163 	movw	r1, #355	@ 0x163
3401b0b2:	4836      	ldr	r0, [pc, #216]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b0b4:	f7e6 f8f0 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_CS_HIGH_TIME_CYCLE(hxspi->Init.ChipSelectHighTimeCycle));
3401b0b8:	687b      	ldr	r3, [r7, #4]
3401b0ba:	695b      	ldr	r3, [r3, #20]
3401b0bc:	2b00      	cmp	r3, #0
3401b0be:	d003      	beq.n	3401b0c8 <HAL_XSPI_Init+0x198>
3401b0c0:	687b      	ldr	r3, [r7, #4]
3401b0c2:	695b      	ldr	r3, [r3, #20]
3401b0c4:	2b40      	cmp	r3, #64	@ 0x40
3401b0c6:	d904      	bls.n	3401b0d2 <HAL_XSPI_Init+0x1a2>
3401b0c8:	f44f 71b2 	mov.w	r1, #356	@ 0x164
3401b0cc:	482f      	ldr	r0, [pc, #188]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b0ce:	f7e6 f8e3 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_FREE_RUN_CLK(hxspi->Init.FreeRunningClock));
3401b0d2:	687b      	ldr	r3, [r7, #4]
3401b0d4:	699b      	ldr	r3, [r3, #24]
3401b0d6:	2b00      	cmp	r3, #0
3401b0d8:	d008      	beq.n	3401b0ec <HAL_XSPI_Init+0x1bc>
3401b0da:	687b      	ldr	r3, [r7, #4]
3401b0dc:	699b      	ldr	r3, [r3, #24]
3401b0de:	2b02      	cmp	r3, #2
3401b0e0:	d004      	beq.n	3401b0ec <HAL_XSPI_Init+0x1bc>
3401b0e2:	f240 1165 	movw	r1, #357	@ 0x165
3401b0e6:	4829      	ldr	r0, [pc, #164]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b0e8:	f7e6 f8d6 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_CLOCK_MODE(hxspi->Init.ClockMode));
3401b0ec:	687b      	ldr	r3, [r7, #4]
3401b0ee:	69db      	ldr	r3, [r3, #28]
3401b0f0:	2b00      	cmp	r3, #0
3401b0f2:	d008      	beq.n	3401b106 <HAL_XSPI_Init+0x1d6>
3401b0f4:	687b      	ldr	r3, [r7, #4]
3401b0f6:	69db      	ldr	r3, [r3, #28]
3401b0f8:	2b01      	cmp	r3, #1
3401b0fa:	d004      	beq.n	3401b106 <HAL_XSPI_Init+0x1d6>
3401b0fc:	f44f 71b3 	mov.w	r1, #358	@ 0x166
3401b100:	4822      	ldr	r0, [pc, #136]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b102:	f7e6 f8c9 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_WRAP_SIZE(hxspi->Init.WrapSize));
3401b106:	687b      	ldr	r3, [r7, #4]
3401b108:	6a1b      	ldr	r3, [r3, #32]
3401b10a:	2b00      	cmp	r3, #0
3401b10c:	d018      	beq.n	3401b140 <HAL_XSPI_Init+0x210>
3401b10e:	687b      	ldr	r3, [r7, #4]
3401b110:	6a1b      	ldr	r3, [r3, #32]
3401b112:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3401b116:	d013      	beq.n	3401b140 <HAL_XSPI_Init+0x210>
3401b118:	687b      	ldr	r3, [r7, #4]
3401b11a:	6a1b      	ldr	r3, [r3, #32]
3401b11c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3401b120:	d00e      	beq.n	3401b140 <HAL_XSPI_Init+0x210>
3401b122:	687b      	ldr	r3, [r7, #4]
3401b124:	6a1b      	ldr	r3, [r3, #32]
3401b126:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3401b12a:	d009      	beq.n	3401b140 <HAL_XSPI_Init+0x210>
3401b12c:	687b      	ldr	r3, [r7, #4]
3401b12e:	6a1b      	ldr	r3, [r3, #32]
3401b130:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3401b134:	d004      	beq.n	3401b140 <HAL_XSPI_Init+0x210>
3401b136:	f240 1167 	movw	r1, #359	@ 0x167
3401b13a:	4814      	ldr	r0, [pc, #80]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b13c:	f7e6 f8ac 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_CLK_PRESCALER(hxspi->Init.ClockPrescaler));
3401b140:	687b      	ldr	r3, [r7, #4]
3401b142:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401b144:	2bff      	cmp	r3, #255	@ 0xff
3401b146:	d904      	bls.n	3401b152 <HAL_XSPI_Init+0x222>
3401b148:	f44f 71b4 	mov.w	r1, #360	@ 0x168
3401b14c:	480f      	ldr	r0, [pc, #60]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b14e:	f7e6 f8a3 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_SAMPLE_SHIFTING(hxspi->Init.SampleShifting));
3401b152:	687b      	ldr	r3, [r7, #4]
3401b154:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401b156:	2b00      	cmp	r3, #0
3401b158:	d009      	beq.n	3401b16e <HAL_XSPI_Init+0x23e>
3401b15a:	687b      	ldr	r3, [r7, #4]
3401b15c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401b15e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3401b162:	d004      	beq.n	3401b16e <HAL_XSPI_Init+0x23e>
3401b164:	f240 1169 	movw	r1, #361	@ 0x169
3401b168:	4808      	ldr	r0, [pc, #32]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b16a:	f7e6 f895 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_DHQC(hxspi->Init.DelayHoldQuarterCycle));
3401b16e:	687b      	ldr	r3, [r7, #4]
3401b170:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b172:	2b00      	cmp	r3, #0
3401b174:	d00c      	beq.n	3401b190 <HAL_XSPI_Init+0x260>
3401b176:	687b      	ldr	r3, [r7, #4]
3401b178:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b17a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401b17e:	d007      	beq.n	3401b190 <HAL_XSPI_Init+0x260>
3401b180:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
3401b184:	4801      	ldr	r0, [pc, #4]	@ (3401b18c <HAL_XSPI_Init+0x25c>)
3401b186:	f7e6 f887 	bl	34001298 <assert_failed>
3401b18a:	e001      	b.n	3401b190 <HAL_XSPI_Init+0x260>
3401b18c:	340245a0 	.word	0x340245a0
    assert_param(IS_XSPI_CS_BOUND(hxspi->Init.ChipSelectBoundary));
3401b190:	687b      	ldr	r3, [r7, #4]
3401b192:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b194:	2b00      	cmp	r3, #0
3401b196:	f000 8081 	beq.w	3401b29c <HAL_XSPI_Init+0x36c>
3401b19a:	687b      	ldr	r3, [r7, #4]
3401b19c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b19e:	2b01      	cmp	r3, #1
3401b1a0:	d07c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1a2:	687b      	ldr	r3, [r7, #4]
3401b1a4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1a6:	2b02      	cmp	r3, #2
3401b1a8:	d078      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1aa:	687b      	ldr	r3, [r7, #4]
3401b1ac:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1ae:	2b03      	cmp	r3, #3
3401b1b0:	d074      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1b2:	687b      	ldr	r3, [r7, #4]
3401b1b4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1b6:	2b04      	cmp	r3, #4
3401b1b8:	d070      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1ba:	687b      	ldr	r3, [r7, #4]
3401b1bc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1be:	2b05      	cmp	r3, #5
3401b1c0:	d06c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1c2:	687b      	ldr	r3, [r7, #4]
3401b1c4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1c6:	2b06      	cmp	r3, #6
3401b1c8:	d068      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1ca:	687b      	ldr	r3, [r7, #4]
3401b1cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1ce:	2b07      	cmp	r3, #7
3401b1d0:	d064      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1d2:	687b      	ldr	r3, [r7, #4]
3401b1d4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1d6:	2b08      	cmp	r3, #8
3401b1d8:	d060      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1da:	687b      	ldr	r3, [r7, #4]
3401b1dc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1de:	2b09      	cmp	r3, #9
3401b1e0:	d05c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1e2:	687b      	ldr	r3, [r7, #4]
3401b1e4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1e6:	2b0a      	cmp	r3, #10
3401b1e8:	d058      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1ea:	687b      	ldr	r3, [r7, #4]
3401b1ec:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1ee:	2b0b      	cmp	r3, #11
3401b1f0:	d054      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1f2:	687b      	ldr	r3, [r7, #4]
3401b1f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1f6:	2b0c      	cmp	r3, #12
3401b1f8:	d050      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b1fa:	687b      	ldr	r3, [r7, #4]
3401b1fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b1fe:	2b0d      	cmp	r3, #13
3401b200:	d04c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b202:	687b      	ldr	r3, [r7, #4]
3401b204:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b206:	2b0e      	cmp	r3, #14
3401b208:	d048      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b20a:	687b      	ldr	r3, [r7, #4]
3401b20c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b20e:	2b0f      	cmp	r3, #15
3401b210:	d044      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b212:	687b      	ldr	r3, [r7, #4]
3401b214:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b216:	2b10      	cmp	r3, #16
3401b218:	d040      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b21a:	687b      	ldr	r3, [r7, #4]
3401b21c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b21e:	2b11      	cmp	r3, #17
3401b220:	d03c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b222:	687b      	ldr	r3, [r7, #4]
3401b224:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b226:	2b12      	cmp	r3, #18
3401b228:	d038      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b22a:	687b      	ldr	r3, [r7, #4]
3401b22c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b22e:	2b13      	cmp	r3, #19
3401b230:	d034      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b232:	687b      	ldr	r3, [r7, #4]
3401b234:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b236:	2b14      	cmp	r3, #20
3401b238:	d030      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b23a:	687b      	ldr	r3, [r7, #4]
3401b23c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b23e:	2b15      	cmp	r3, #21
3401b240:	d02c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b242:	687b      	ldr	r3, [r7, #4]
3401b244:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b246:	2b16      	cmp	r3, #22
3401b248:	d028      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b24a:	687b      	ldr	r3, [r7, #4]
3401b24c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b24e:	2b17      	cmp	r3, #23
3401b250:	d024      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b252:	687b      	ldr	r3, [r7, #4]
3401b254:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b256:	2b18      	cmp	r3, #24
3401b258:	d020      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b25a:	687b      	ldr	r3, [r7, #4]
3401b25c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b25e:	2b19      	cmp	r3, #25
3401b260:	d01c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b262:	687b      	ldr	r3, [r7, #4]
3401b264:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b266:	2b1a      	cmp	r3, #26
3401b268:	d018      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b26a:	687b      	ldr	r3, [r7, #4]
3401b26c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b26e:	2b1b      	cmp	r3, #27
3401b270:	d014      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b272:	687b      	ldr	r3, [r7, #4]
3401b274:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b276:	2b1c      	cmp	r3, #28
3401b278:	d010      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b27a:	687b      	ldr	r3, [r7, #4]
3401b27c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b27e:	2b1d      	cmp	r3, #29
3401b280:	d00c      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b282:	687b      	ldr	r3, [r7, #4]
3401b284:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b286:	2b1e      	cmp	r3, #30
3401b288:	d008      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b28a:	687b      	ldr	r3, [r7, #4]
3401b28c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b28e:	2b1f      	cmp	r3, #31
3401b290:	d004      	beq.n	3401b29c <HAL_XSPI_Init+0x36c>
3401b292:	f240 116b 	movw	r1, #363	@ 0x16b
3401b296:	4895      	ldr	r0, [pc, #596]	@ (3401b4ec <HAL_XSPI_Init+0x5bc>)
3401b298:	f7e5 fffe 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
3401b29c:	687b      	ldr	r3, [r7, #4]
3401b29e:	685b      	ldr	r3, [r3, #4]
3401b2a0:	2b00      	cmp	r3, #0
3401b2a2:	d003      	beq.n	3401b2ac <HAL_XSPI_Init+0x37c>
3401b2a4:	687b      	ldr	r3, [r7, #4]
3401b2a6:	685b      	ldr	r3, [r3, #4]
3401b2a8:	2b40      	cmp	r3, #64	@ 0x40
3401b2aa:	d904      	bls.n	3401b2b6 <HAL_XSPI_Init+0x386>
3401b2ac:	f44f 71b6 	mov.w	r1, #364	@ 0x16c
3401b2b0:	488e      	ldr	r0, [pc, #568]	@ (3401b4ec <HAL_XSPI_Init+0x5bc>)
3401b2b2:	f7e5 fff1 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
3401b2b6:	687b      	ldr	r3, [r7, #4]
3401b2b8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401b2ba:	2bff      	cmp	r3, #255	@ 0xff
3401b2bc:	d904      	bls.n	3401b2c8 <HAL_XSPI_Init+0x398>
3401b2be:	f240 116d 	movw	r1, #365	@ 0x16d
3401b2c2:	488a      	ldr	r0, [pc, #552]	@ (3401b4ec <HAL_XSPI_Init+0x5bc>)
3401b2c4:	f7e5 ffe8 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
3401b2c8:	687b      	ldr	r3, [r7, #4]
3401b2ca:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401b2cc:	2b00      	cmp	r3, #0
3401b2ce:	d009      	beq.n	3401b2e4 <HAL_XSPI_Init+0x3b4>
3401b2d0:	687b      	ldr	r3, [r7, #4]
3401b2d2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401b2d4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401b2d8:	d004      	beq.n	3401b2e4 <HAL_XSPI_Init+0x3b4>
3401b2da:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3401b2de:	4883      	ldr	r0, [pc, #524]	@ (3401b4ec <HAL_XSPI_Init+0x5bc>)
3401b2e0:	f7e5 ffda 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
3401b2e4:	687b      	ldr	r3, [r7, #4]
3401b2e6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b2e8:	2b00      	cmp	r3, #0
3401b2ea:	d009      	beq.n	3401b300 <HAL_XSPI_Init+0x3d0>
3401b2ec:	687b      	ldr	r3, [r7, #4]
3401b2ee:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b2f0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3401b2f4:	d004      	beq.n	3401b300 <HAL_XSPI_Init+0x3d0>
3401b2f6:	f240 116f 	movw	r1, #367	@ 0x16f
3401b2fa:	487c      	ldr	r0, [pc, #496]	@ (3401b4ec <HAL_XSPI_Init+0x5bc>)
3401b2fc:	f7e5 ffcc 	bl	34001298 <assert_failed>
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3401b300:	687b      	ldr	r3, [r7, #4]
3401b302:	2200      	movs	r2, #0
3401b304:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
3401b306:	687b      	ldr	r3, [r7, #4]
3401b308:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401b30a:	2b00      	cmp	r3, #0
3401b30c:	f040 80e8 	bne.w	3401b4e0 <HAL_XSPI_Init+0x5b0>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
3401b310:	6878      	ldr	r0, [r7, #4]
3401b312:	f000 f8fb 	bl	3401b50c <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
3401b316:	f241 3188 	movw	r1, #5000	@ 0x1388
3401b31a:	6878      	ldr	r0, [r7, #4]
3401b31c:	f000 fdc4 	bl	3401bea8 <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
3401b320:	687b      	ldr	r3, [r7, #4]
3401b322:	681b      	ldr	r3, [r3, #0]
3401b324:	689a      	ldr	r2, [r3, #8]
3401b326:	4b72      	ldr	r3, [pc, #456]	@ (3401b4f0 <HAL_XSPI_Init+0x5c0>)
3401b328:	4013      	ands	r3, r2
3401b32a:	687a      	ldr	r2, [r7, #4]
3401b32c:	68d1      	ldr	r1, [r2, #12]
3401b32e:	687a      	ldr	r2, [r7, #4]
3401b330:	6912      	ldr	r2, [r2, #16]
3401b332:	0412      	lsls	r2, r2, #16
3401b334:	4311      	orrs	r1, r2
3401b336:	687a      	ldr	r2, [r7, #4]
3401b338:	6952      	ldr	r2, [r2, #20]
3401b33a:	3a01      	subs	r2, #1
3401b33c:	0212      	lsls	r2, r2, #8
3401b33e:	4311      	orrs	r1, r2
3401b340:	687a      	ldr	r2, [r7, #4]
3401b342:	69d2      	ldr	r2, [r2, #28]
3401b344:	4311      	orrs	r1, r2
3401b346:	687a      	ldr	r2, [r7, #4]
3401b348:	6812      	ldr	r2, [r2, #0]
3401b34a:	430b      	orrs	r3, r1
3401b34c:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3401b34e:	687b      	ldr	r3, [r7, #4]
3401b350:	681b      	ldr	r3, [r3, #0]
3401b352:	68db      	ldr	r3, [r3, #12]
3401b354:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
3401b358:	687b      	ldr	r3, [r7, #4]
3401b35a:	6a1a      	ldr	r2, [r3, #32]
3401b35c:	687b      	ldr	r3, [r7, #4]
3401b35e:	681b      	ldr	r3, [r3, #0]
3401b360:	430a      	orrs	r2, r1
3401b362:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3401b364:	687b      	ldr	r3, [r7, #4]
3401b366:	681b      	ldr	r3, [r3, #0]
3401b368:	691b      	ldr	r3, [r3, #16]
3401b36a:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
3401b36e:	687b      	ldr	r3, [r7, #4]
3401b370:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b372:	041a      	lsls	r2, r3, #16
3401b374:	687b      	ldr	r3, [r7, #4]
3401b376:	681b      	ldr	r3, [r3, #0]
3401b378:	430a      	orrs	r2, r1
3401b37a:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3401b37c:	687b      	ldr	r3, [r7, #4]
3401b37e:	681b      	ldr	r3, [r3, #0]
3401b380:	691b      	ldr	r3, [r3, #16]
3401b382:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
3401b386:	687b      	ldr	r3, [r7, #4]
3401b388:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3401b38a:	687b      	ldr	r3, [r7, #4]
3401b38c:	681b      	ldr	r3, [r3, #0]
3401b38e:	430a      	orrs	r2, r1
3401b390:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3401b392:	687b      	ldr	r3, [r7, #4]
3401b394:	681b      	ldr	r3, [r3, #0]
3401b396:	687a      	ldr	r2, [r7, #4]
3401b398:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3401b39a:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3401b39c:	687b      	ldr	r3, [r7, #4]
3401b39e:	681b      	ldr	r3, [r3, #0]
3401b3a0:	681b      	ldr	r3, [r3, #0]
3401b3a2:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
3401b3a6:	687b      	ldr	r3, [r7, #4]
3401b3a8:	685b      	ldr	r3, [r3, #4]
3401b3aa:	3b01      	subs	r3, #1
3401b3ac:	021a      	lsls	r2, r3, #8
3401b3ae:	687b      	ldr	r3, [r7, #4]
3401b3b0:	681b      	ldr	r3, [r3, #0]
3401b3b2:	430a      	orrs	r2, r1
3401b3b4:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3401b3b6:	687b      	ldr	r3, [r7, #4]
3401b3b8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3401b3ba:	9300      	str	r3, [sp, #0]
3401b3bc:	68bb      	ldr	r3, [r7, #8]
3401b3be:	2200      	movs	r2, #0
3401b3c0:	2120      	movs	r1, #32
3401b3c2:	6878      	ldr	r0, [r7, #4]
3401b3c4:	f000 fd7f 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401b3c8:	4603      	mov	r3, r0
3401b3ca:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
3401b3cc:	7bfb      	ldrb	r3, [r7, #15]
3401b3ce:	2b00      	cmp	r3, #0
3401b3d0:	f040 8086 	bne.w	3401b4e0 <HAL_XSPI_Init+0x5b0>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3401b3d4:	687b      	ldr	r3, [r7, #4]
3401b3d6:	681b      	ldr	r3, [r3, #0]
3401b3d8:	68db      	ldr	r3, [r3, #12]
3401b3da:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
3401b3de:	687b      	ldr	r3, [r7, #4]
3401b3e0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401b3e2:	687b      	ldr	r3, [r7, #4]
3401b3e4:	681b      	ldr	r3, [r3, #0]
3401b3e6:	430a      	orrs	r2, r1
3401b3e8:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3401b3ea:	687b      	ldr	r3, [r7, #4]
3401b3ec:	681b      	ldr	r3, [r3, #0]
3401b3ee:	4a41      	ldr	r2, [pc, #260]	@ (3401b4f4 <HAL_XSPI_Init+0x5c4>)
3401b3f0:	4293      	cmp	r3, r2
3401b3f2:	d018      	beq.n	3401b426 <HAL_XSPI_Init+0x4f6>
3401b3f4:	687b      	ldr	r3, [r7, #4]
3401b3f6:	681b      	ldr	r3, [r3, #0]
3401b3f8:	4a3f      	ldr	r2, [pc, #252]	@ (3401b4f8 <HAL_XSPI_Init+0x5c8>)
3401b3fa:	4293      	cmp	r3, r2
3401b3fc:	d013      	beq.n	3401b426 <HAL_XSPI_Init+0x4f6>
3401b3fe:	687b      	ldr	r3, [r7, #4]
3401b400:	681b      	ldr	r3, [r3, #0]
3401b402:	4a3e      	ldr	r2, [pc, #248]	@ (3401b4fc <HAL_XSPI_Init+0x5cc>)
3401b404:	4293      	cmp	r3, r2
3401b406:	d00e      	beq.n	3401b426 <HAL_XSPI_Init+0x4f6>
3401b408:	687b      	ldr	r3, [r7, #4]
3401b40a:	681b      	ldr	r3, [r3, #0]
3401b40c:	4a3c      	ldr	r2, [pc, #240]	@ (3401b500 <HAL_XSPI_Init+0x5d0>)
3401b40e:	4293      	cmp	r3, r2
3401b410:	d009      	beq.n	3401b426 <HAL_XSPI_Init+0x4f6>
3401b412:	687b      	ldr	r3, [r7, #4]
3401b414:	681b      	ldr	r3, [r3, #0]
3401b416:	4a3b      	ldr	r2, [pc, #236]	@ (3401b504 <HAL_XSPI_Init+0x5d4>)
3401b418:	4293      	cmp	r3, r2
3401b41a:	d004      	beq.n	3401b426 <HAL_XSPI_Init+0x4f6>
3401b41c:	687b      	ldr	r3, [r7, #4]
3401b41e:	681b      	ldr	r3, [r3, #0]
3401b420:	4a39      	ldr	r2, [pc, #228]	@ (3401b508 <HAL_XSPI_Init+0x5d8>)
3401b422:	4293      	cmp	r3, r2
3401b424:	d10f      	bne.n	3401b446 <HAL_XSPI_Init+0x516>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3401b426:	687b      	ldr	r3, [r7, #4]
3401b428:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3401b42a:	9300      	str	r3, [sp, #0]
3401b42c:	68bb      	ldr	r3, [r7, #8]
3401b42e:	2200      	movs	r2, #0
3401b430:	2120      	movs	r1, #32
3401b432:	6878      	ldr	r0, [r7, #4]
3401b434:	f000 fd47 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401b438:	4603      	mov	r3, r0
3401b43a:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
3401b43c:	7bfb      	ldrb	r3, [r7, #15]
3401b43e:	2b00      	cmp	r3, #0
3401b440:	d001      	beq.n	3401b446 <HAL_XSPI_Init+0x516>
          {
            return status;
3401b442:	7bfb      	ldrb	r3, [r7, #15]
3401b444:	e04d      	b.n	3401b4e2 <HAL_XSPI_Init+0x5b2>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
3401b446:	687b      	ldr	r3, [r7, #4]
3401b448:	681b      	ldr	r3, [r3, #0]
3401b44a:	681b      	ldr	r3, [r3, #0]
3401b44c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3401b450:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3401b454:	687a      	ldr	r2, [r7, #4]
3401b456:	6891      	ldr	r1, [r2, #8]
3401b458:	687a      	ldr	r2, [r7, #4]
3401b45a:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
3401b45c:	4311      	orrs	r1, r2
3401b45e:	687a      	ldr	r2, [r7, #4]
3401b460:	6812      	ldr	r2, [r2, #0]
3401b462:	430b      	orrs	r3, r1
3401b464:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT | XSPI_TCR_DHQC),
3401b466:	687b      	ldr	r3, [r7, #4]
3401b468:	681b      	ldr	r3, [r3, #0]
3401b46a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3401b46e:	f023 41a0 	bic.w	r1, r3, #1342177280	@ 0x50000000
3401b472:	687b      	ldr	r3, [r7, #4]
3401b474:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3401b476:	687b      	ldr	r3, [r7, #4]
3401b478:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b47a:	431a      	orrs	r2, r3
3401b47c:	687b      	ldr	r3, [r7, #4]
3401b47e:	681b      	ldr	r3, [r3, #0]
3401b480:	430a      	orrs	r2, r1
3401b482:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
                   (hxspi->Init.SampleShifting | hxspi->Init.DelayHoldQuarterCycle));

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
3401b486:	687b      	ldr	r3, [r7, #4]
3401b488:	681b      	ldr	r3, [r3, #0]
3401b48a:	681a      	ldr	r2, [r3, #0]
3401b48c:	687b      	ldr	r3, [r7, #4]
3401b48e:	681b      	ldr	r3, [r3, #0]
3401b490:	f042 0201 	orr.w	r2, r2, #1
3401b494:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
3401b496:	687b      	ldr	r3, [r7, #4]
3401b498:	699b      	ldr	r3, [r3, #24]
3401b49a:	2b02      	cmp	r3, #2
3401b49c:	d107      	bne.n	3401b4ae <HAL_XSPI_Init+0x57e>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3401b49e:	687b      	ldr	r3, [r7, #4]
3401b4a0:	681b      	ldr	r3, [r3, #0]
3401b4a2:	689a      	ldr	r2, [r3, #8]
3401b4a4:	687b      	ldr	r3, [r7, #4]
3401b4a6:	681b      	ldr	r3, [r3, #0]
3401b4a8:	f042 0202 	orr.w	r2, r2, #2
3401b4ac:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3401b4ae:	687b      	ldr	r3, [r7, #4]
3401b4b0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b4b2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3401b4b6:	d107      	bne.n	3401b4c8 <HAL_XSPI_Init+0x598>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
3401b4b8:	687b      	ldr	r3, [r7, #4]
3401b4ba:	681b      	ldr	r3, [r3, #0]
3401b4bc:	689a      	ldr	r2, [r3, #8]
3401b4be:	687b      	ldr	r3, [r7, #4]
3401b4c0:	681b      	ldr	r3, [r3, #0]
3401b4c2:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
3401b4c6:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401b4c8:	687b      	ldr	r3, [r7, #4]
3401b4ca:	68db      	ldr	r3, [r3, #12]
3401b4cc:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401b4d0:	d103      	bne.n	3401b4da <HAL_XSPI_Init+0x5aa>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3401b4d2:	687b      	ldr	r3, [r7, #4]
3401b4d4:	2201      	movs	r2, #1
3401b4d6:	659a      	str	r2, [r3, #88]	@ 0x58
3401b4d8:	e002      	b.n	3401b4e0 <HAL_XSPI_Init+0x5b0>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
3401b4da:	687b      	ldr	r3, [r7, #4]
3401b4dc:	2202      	movs	r2, #2
3401b4de:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
3401b4e0:	7bfb      	ldrb	r3, [r7, #15]
}
3401b4e2:	4618      	mov	r0, r3
3401b4e4:	3710      	adds	r7, #16
3401b4e6:	46bd      	mov	sp, r7
3401b4e8:	bd80      	pop	{r7, pc}
3401b4ea:	bf00      	nop
3401b4ec:	340245a0 	.word	0x340245a0
3401b4f0:	f8e0c0fc 	.word	0xf8e0c0fc
3401b4f4:	58025000 	.word	0x58025000
3401b4f8:	48025000 	.word	0x48025000
3401b4fc:	5802a000 	.word	0x5802a000
3401b500:	4802a000 	.word	0x4802a000
3401b504:	5802d000 	.word	0x5802d000
3401b508:	4802d000 	.word	0x4802d000

3401b50c <HAL_XSPI_MspInit>:
  * @brief  Initialize the XSPI MSP.
  * @param  hxspi : XSPI handle
  * @retval None
  */
__weak void HAL_XSPI_MspInit(XSPI_HandleTypeDef *hxspi)
{
3401b50c:	b480      	push	{r7}
3401b50e:	b083      	sub	sp, #12
3401b510:	af00      	add	r7, sp, #0
3401b512:	6078      	str	r0, [r7, #4]
  UNUSED(hxspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_XSPI_MspInit can be implemented in the user file
   */
}
3401b514:	bf00      	nop
3401b516:	370c      	adds	r7, #12
3401b518:	46bd      	mov	sp, r7
3401b51a:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b51e:	4770      	bx	lr

3401b520 <HAL_XSPI_Command>:
  * @param  pCmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Command(XSPI_HandleTypeDef *hxspi, XSPI_RegularCmdTypeDef *const pCmd, uint32_t Timeout)
{
3401b520:	b580      	push	{r7, lr}
3401b522:	b08a      	sub	sp, #40	@ 0x28
3401b524:	af02      	add	r7, sp, #8
3401b526:	60f8      	str	r0, [r7, #12]
3401b528:	60b9      	str	r1, [r7, #8]
3401b52a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
3401b52c:	f7ec f858 	bl	340075e0 <HAL_GetTick>
3401b530:	61b8      	str	r0, [r7, #24]

  /* Check the parameters of the command structure */
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
3401b532:	68bb      	ldr	r3, [r7, #8]
3401b534:	681b      	ldr	r3, [r3, #0]
3401b536:	2b00      	cmp	r3, #0
3401b538:	d010      	beq.n	3401b55c <HAL_XSPI_Command+0x3c>
3401b53a:	68bb      	ldr	r3, [r7, #8]
3401b53c:	681b      	ldr	r3, [r3, #0]
3401b53e:	2b01      	cmp	r3, #1
3401b540:	d00c      	beq.n	3401b55c <HAL_XSPI_Command+0x3c>
3401b542:	68bb      	ldr	r3, [r7, #8]
3401b544:	681b      	ldr	r3, [r3, #0]
3401b546:	2b02      	cmp	r3, #2
3401b548:	d008      	beq.n	3401b55c <HAL_XSPI_Command+0x3c>
3401b54a:	68bb      	ldr	r3, [r7, #8]
3401b54c:	681b      	ldr	r3, [r3, #0]
3401b54e:	2b03      	cmp	r3, #3
3401b550:	d004      	beq.n	3401b55c <HAL_XSPI_Command+0x3c>
3401b552:	f240 313e 	movw	r1, #830	@ 0x33e
3401b556:	4887      	ldr	r0, [pc, #540]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b558:	f7e5 fe9e 	bl	34001298 <assert_failed>
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3401b55c:	68fb      	ldr	r3, [r7, #12]
3401b55e:	689b      	ldr	r3, [r3, #8]
3401b560:	2b00      	cmp	r3, #0
3401b562:	d120      	bne.n	3401b5a6 <HAL_XSPI_Command+0x86>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3401b564:	68bb      	ldr	r3, [r7, #8]
3401b566:	685b      	ldr	r3, [r3, #4]
3401b568:	2b00      	cmp	r3, #0
3401b56a:	d01c      	beq.n	3401b5a6 <HAL_XSPI_Command+0x86>
3401b56c:	68bb      	ldr	r3, [r7, #8]
3401b56e:	685b      	ldr	r3, [r3, #4]
3401b570:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3401b574:	d017      	beq.n	3401b5a6 <HAL_XSPI_Command+0x86>
3401b576:	68bb      	ldr	r3, [r7, #8]
3401b578:	685b      	ldr	r3, [r3, #4]
3401b57a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3401b57e:	d012      	beq.n	3401b5a6 <HAL_XSPI_Command+0x86>
3401b580:	68bb      	ldr	r3, [r7, #8]
3401b582:	685b      	ldr	r3, [r3, #4]
3401b584:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
3401b588:	d00d      	beq.n	3401b5a6 <HAL_XSPI_Command+0x86>
3401b58a:	68bb      	ldr	r3, [r7, #8]
3401b58c:	685b      	ldr	r3, [r3, #4]
3401b58e:	2b00      	cmp	r3, #0
3401b590:	d009      	beq.n	3401b5a6 <HAL_XSPI_Command+0x86>
3401b592:	68bb      	ldr	r3, [r7, #8]
3401b594:	685b      	ldr	r3, [r3, #4]
3401b596:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3401b59a:	d004      	beq.n	3401b5a6 <HAL_XSPI_Command+0x86>
3401b59c:	f240 3141 	movw	r1, #833	@ 0x341
3401b5a0:	4874      	ldr	r0, [pc, #464]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b5a2:	f7e5 fe79 	bl	34001298 <assert_failed>
  }

  assert_param(IS_XSPI_INSTRUCTION_MODE(pCmd->InstructionMode));
3401b5a6:	68bb      	ldr	r3, [r7, #8]
3401b5a8:	68db      	ldr	r3, [r3, #12]
3401b5aa:	2b00      	cmp	r3, #0
3401b5ac:	d014      	beq.n	3401b5d8 <HAL_XSPI_Command+0xb8>
3401b5ae:	68bb      	ldr	r3, [r7, #8]
3401b5b0:	68db      	ldr	r3, [r3, #12]
3401b5b2:	2b01      	cmp	r3, #1
3401b5b4:	d010      	beq.n	3401b5d8 <HAL_XSPI_Command+0xb8>
3401b5b6:	68bb      	ldr	r3, [r7, #8]
3401b5b8:	68db      	ldr	r3, [r3, #12]
3401b5ba:	2b02      	cmp	r3, #2
3401b5bc:	d00c      	beq.n	3401b5d8 <HAL_XSPI_Command+0xb8>
3401b5be:	68bb      	ldr	r3, [r7, #8]
3401b5c0:	68db      	ldr	r3, [r3, #12]
3401b5c2:	2b03      	cmp	r3, #3
3401b5c4:	d008      	beq.n	3401b5d8 <HAL_XSPI_Command+0xb8>
3401b5c6:	68bb      	ldr	r3, [r7, #8]
3401b5c8:	68db      	ldr	r3, [r3, #12]
3401b5ca:	2b04      	cmp	r3, #4
3401b5cc:	d004      	beq.n	3401b5d8 <HAL_XSPI_Command+0xb8>
3401b5ce:	f44f 7151 	mov.w	r1, #836	@ 0x344
3401b5d2:	4868      	ldr	r0, [pc, #416]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b5d4:	f7e5 fe60 	bl	34001298 <assert_failed>
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3401b5d8:	68bb      	ldr	r3, [r7, #8]
3401b5da:	68db      	ldr	r3, [r3, #12]
3401b5dc:	2b00      	cmp	r3, #0
3401b5de:	d021      	beq.n	3401b624 <HAL_XSPI_Command+0x104>
  {
    assert_param(IS_XSPI_INSTRUCTION_WIDTH(pCmd->InstructionWidth));
3401b5e0:	68bb      	ldr	r3, [r7, #8]
3401b5e2:	691b      	ldr	r3, [r3, #16]
3401b5e4:	2b00      	cmp	r3, #0
3401b5e6:	d010      	beq.n	3401b60a <HAL_XSPI_Command+0xea>
3401b5e8:	68bb      	ldr	r3, [r7, #8]
3401b5ea:	691b      	ldr	r3, [r3, #16]
3401b5ec:	2b10      	cmp	r3, #16
3401b5ee:	d00c      	beq.n	3401b60a <HAL_XSPI_Command+0xea>
3401b5f0:	68bb      	ldr	r3, [r7, #8]
3401b5f2:	691b      	ldr	r3, [r3, #16]
3401b5f4:	2b20      	cmp	r3, #32
3401b5f6:	d008      	beq.n	3401b60a <HAL_XSPI_Command+0xea>
3401b5f8:	68bb      	ldr	r3, [r7, #8]
3401b5fa:	691b      	ldr	r3, [r3, #16]
3401b5fc:	2b30      	cmp	r3, #48	@ 0x30
3401b5fe:	d004      	beq.n	3401b60a <HAL_XSPI_Command+0xea>
3401b600:	f240 3147 	movw	r1, #839	@ 0x347
3401b604:	485b      	ldr	r0, [pc, #364]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b606:	f7e5 fe47 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_INSTRUCTION_DTR_MODE(pCmd->InstructionDTRMode));
3401b60a:	68bb      	ldr	r3, [r7, #8]
3401b60c:	695b      	ldr	r3, [r3, #20]
3401b60e:	2b00      	cmp	r3, #0
3401b610:	d008      	beq.n	3401b624 <HAL_XSPI_Command+0x104>
3401b612:	68bb      	ldr	r3, [r7, #8]
3401b614:	695b      	ldr	r3, [r3, #20]
3401b616:	2b08      	cmp	r3, #8
3401b618:	d004      	beq.n	3401b624 <HAL_XSPI_Command+0x104>
3401b61a:	f44f 7152 	mov.w	r1, #840	@ 0x348
3401b61e:	4855      	ldr	r0, [pc, #340]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b620:	f7e5 fe3a 	bl	34001298 <assert_failed>
  }

  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
3401b624:	68bb      	ldr	r3, [r7, #8]
3401b626:	69db      	ldr	r3, [r3, #28]
3401b628:	2b00      	cmp	r3, #0
3401b62a:	d018      	beq.n	3401b65e <HAL_XSPI_Command+0x13e>
3401b62c:	68bb      	ldr	r3, [r7, #8]
3401b62e:	69db      	ldr	r3, [r3, #28]
3401b630:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401b634:	d013      	beq.n	3401b65e <HAL_XSPI_Command+0x13e>
3401b636:	68bb      	ldr	r3, [r7, #8]
3401b638:	69db      	ldr	r3, [r3, #28]
3401b63a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401b63e:	d00e      	beq.n	3401b65e <HAL_XSPI_Command+0x13e>
3401b640:	68bb      	ldr	r3, [r7, #8]
3401b642:	69db      	ldr	r3, [r3, #28]
3401b644:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401b648:	d009      	beq.n	3401b65e <HAL_XSPI_Command+0x13e>
3401b64a:	68bb      	ldr	r3, [r7, #8]
3401b64c:	69db      	ldr	r3, [r3, #28]
3401b64e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3401b652:	d004      	beq.n	3401b65e <HAL_XSPI_Command+0x13e>
3401b654:	f240 314b 	movw	r1, #843	@ 0x34b
3401b658:	4846      	ldr	r0, [pc, #280]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b65a:	f7e5 fe1d 	bl	34001298 <assert_failed>
  if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3401b65e:	68bb      	ldr	r3, [r7, #8]
3401b660:	69db      	ldr	r3, [r3, #28]
3401b662:	2b00      	cmp	r3, #0
3401b664:	d025      	beq.n	3401b6b2 <HAL_XSPI_Command+0x192>
  {
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
3401b666:	68bb      	ldr	r3, [r7, #8]
3401b668:	6a1b      	ldr	r3, [r3, #32]
3401b66a:	2b00      	cmp	r3, #0
3401b66c:	d013      	beq.n	3401b696 <HAL_XSPI_Command+0x176>
3401b66e:	68bb      	ldr	r3, [r7, #8]
3401b670:	6a1b      	ldr	r3, [r3, #32]
3401b672:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401b676:	d00e      	beq.n	3401b696 <HAL_XSPI_Command+0x176>
3401b678:	68bb      	ldr	r3, [r7, #8]
3401b67a:	6a1b      	ldr	r3, [r3, #32]
3401b67c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3401b680:	d009      	beq.n	3401b696 <HAL_XSPI_Command+0x176>
3401b682:	68bb      	ldr	r3, [r7, #8]
3401b684:	6a1b      	ldr	r3, [r3, #32]
3401b686:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3401b68a:	d004      	beq.n	3401b696 <HAL_XSPI_Command+0x176>
3401b68c:	f240 314e 	movw	r1, #846	@ 0x34e
3401b690:	4838      	ldr	r0, [pc, #224]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b692:	f7e5 fe01 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_ADDRESS_DTR_MODE(pCmd->AddressDTRMode));
3401b696:	68bb      	ldr	r3, [r7, #8]
3401b698:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401b69a:	2b00      	cmp	r3, #0
3401b69c:	d009      	beq.n	3401b6b2 <HAL_XSPI_Command+0x192>
3401b69e:	68bb      	ldr	r3, [r7, #8]
3401b6a0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401b6a2:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3401b6a6:	d004      	beq.n	3401b6b2 <HAL_XSPI_Command+0x192>
3401b6a8:	f240 314f 	movw	r1, #847	@ 0x34f
3401b6ac:	4831      	ldr	r0, [pc, #196]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b6ae:	f7e5 fdf3 	bl	34001298 <assert_failed>
  }

  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
3401b6b2:	68bb      	ldr	r3, [r7, #8]
3401b6b4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b6b6:	2b00      	cmp	r3, #0
3401b6b8:	d018      	beq.n	3401b6ec <HAL_XSPI_Command+0x1cc>
3401b6ba:	68bb      	ldr	r3, [r7, #8]
3401b6bc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b6be:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401b6c2:	d013      	beq.n	3401b6ec <HAL_XSPI_Command+0x1cc>
3401b6c4:	68bb      	ldr	r3, [r7, #8]
3401b6c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b6c8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3401b6cc:	d00e      	beq.n	3401b6ec <HAL_XSPI_Command+0x1cc>
3401b6ce:	68bb      	ldr	r3, [r7, #8]
3401b6d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b6d2:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3401b6d6:	d009      	beq.n	3401b6ec <HAL_XSPI_Command+0x1cc>
3401b6d8:	68bb      	ldr	r3, [r7, #8]
3401b6da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b6dc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3401b6e0:	d004      	beq.n	3401b6ec <HAL_XSPI_Command+0x1cc>
3401b6e2:	f240 3152 	movw	r1, #850	@ 0x352
3401b6e6:	4823      	ldr	r0, [pc, #140]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b6e8:	f7e5 fdd6 	bl	34001298 <assert_failed>
  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3401b6ec:	68bb      	ldr	r3, [r7, #8]
3401b6ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401b6f0:	2b00      	cmp	r3, #0
3401b6f2:	d025      	beq.n	3401b740 <HAL_XSPI_Command+0x220>
  {
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
3401b6f4:	68bb      	ldr	r3, [r7, #8]
3401b6f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b6f8:	2b00      	cmp	r3, #0
3401b6fa:	d013      	beq.n	3401b724 <HAL_XSPI_Command+0x204>
3401b6fc:	68bb      	ldr	r3, [r7, #8]
3401b6fe:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b700:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401b704:	d00e      	beq.n	3401b724 <HAL_XSPI_Command+0x204>
3401b706:	68bb      	ldr	r3, [r7, #8]
3401b708:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b70a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3401b70e:	d009      	beq.n	3401b724 <HAL_XSPI_Command+0x204>
3401b710:	68bb      	ldr	r3, [r7, #8]
3401b712:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b714:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3401b718:	d004      	beq.n	3401b724 <HAL_XSPI_Command+0x204>
3401b71a:	f240 3155 	movw	r1, #853	@ 0x355
3401b71e:	4815      	ldr	r0, [pc, #84]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b720:	f7e5 fdba 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
3401b724:	68bb      	ldr	r3, [r7, #8]
3401b726:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401b728:	2b00      	cmp	r3, #0
3401b72a:	d009      	beq.n	3401b740 <HAL_XSPI_Command+0x220>
3401b72c:	68bb      	ldr	r3, [r7, #8]
3401b72e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401b730:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
3401b734:	d004      	beq.n	3401b740 <HAL_XSPI_Command+0x220>
3401b736:	f240 3156 	movw	r1, #854	@ 0x356
3401b73a:	480e      	ldr	r0, [pc, #56]	@ (3401b774 <HAL_XSPI_Command+0x254>)
3401b73c:	f7e5 fdac 	bl	34001298 <assert_failed>
  }

  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
3401b740:	68fb      	ldr	r3, [r7, #12]
3401b742:	68db      	ldr	r3, [r3, #12]
3401b744:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401b748:	d116      	bne.n	3401b778 <HAL_XSPI_Command+0x258>
3401b74a:	68bb      	ldr	r3, [r7, #8]
3401b74c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b74e:	2b00      	cmp	r3, #0
3401b750:	d009      	beq.n	3401b766 <HAL_XSPI_Command+0x246>
3401b752:	68bb      	ldr	r3, [r7, #8]
3401b754:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b756:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401b75a:	d004      	beq.n	3401b766 <HAL_XSPI_Command+0x246>
3401b75c:	68bb      	ldr	r3, [r7, #8]
3401b75e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b760:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
3401b764:	d101      	bne.n	3401b76a <HAL_XSPI_Command+0x24a>
3401b766:	2301      	movs	r3, #1
3401b768:	e000      	b.n	3401b76c <HAL_XSPI_Command+0x24c>
3401b76a:	2300      	movs	r3, #0
3401b76c:	f003 0301 	and.w	r3, r3, #1
3401b770:	b2db      	uxtb	r3, r3
3401b772:	e024      	b.n	3401b7be <HAL_XSPI_Command+0x29e>
3401b774:	340245a0 	.word	0x340245a0
3401b778:	68bb      	ldr	r3, [r7, #8]
3401b77a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b77c:	2b00      	cmp	r3, #0
3401b77e:	d018      	beq.n	3401b7b2 <HAL_XSPI_Command+0x292>
3401b780:	68bb      	ldr	r3, [r7, #8]
3401b782:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b784:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401b788:	d013      	beq.n	3401b7b2 <HAL_XSPI_Command+0x292>
3401b78a:	68bb      	ldr	r3, [r7, #8]
3401b78c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b78e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3401b792:	d00e      	beq.n	3401b7b2 <HAL_XSPI_Command+0x292>
3401b794:	68bb      	ldr	r3, [r7, #8]
3401b796:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b798:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3401b79c:	d009      	beq.n	3401b7b2 <HAL_XSPI_Command+0x292>
3401b79e:	68bb      	ldr	r3, [r7, #8]
3401b7a0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b7a2:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401b7a6:	d004      	beq.n	3401b7b2 <HAL_XSPI_Command+0x292>
3401b7a8:	68bb      	ldr	r3, [r7, #8]
3401b7aa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b7ac:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
3401b7b0:	d101      	bne.n	3401b7b6 <HAL_XSPI_Command+0x296>
3401b7b2:	2301      	movs	r3, #1
3401b7b4:	e000      	b.n	3401b7b8 <HAL_XSPI_Command+0x298>
3401b7b6:	2300      	movs	r3, #0
3401b7b8:	f003 0301 	and.w	r3, r3, #1
3401b7bc:	b2db      	uxtb	r3, r3
3401b7be:	2b00      	cmp	r3, #0
3401b7c0:	d104      	bne.n	3401b7cc <HAL_XSPI_Command+0x2ac>
3401b7c2:	f240 3159 	movw	r1, #857	@ 0x359
3401b7c6:	485e      	ldr	r0, [pc, #376]	@ (3401b940 <HAL_XSPI_Command+0x420>)
3401b7c8:	f7e5 fd66 	bl	34001298 <assert_failed>

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3401b7cc:	68bb      	ldr	r3, [r7, #8]
3401b7ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b7d0:	2b00      	cmp	r3, #0
3401b7d2:	d023      	beq.n	3401b81c <HAL_XSPI_Command+0x2fc>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3401b7d4:	68bb      	ldr	r3, [r7, #8]
3401b7d6:	681b      	ldr	r3, [r3, #0]
3401b7d8:	2b00      	cmp	r3, #0
3401b7da:	d108      	bne.n	3401b7ee <HAL_XSPI_Command+0x2ce>
    {
      assert_param(IS_XSPI_DATA_LENGTH(pCmd->DataLength));
3401b7dc:	68bb      	ldr	r3, [r7, #8]
3401b7de:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401b7e0:	2b00      	cmp	r3, #0
3401b7e2:	d104      	bne.n	3401b7ee <HAL_XSPI_Command+0x2ce>
3401b7e4:	f240 315f 	movw	r1, #863	@ 0x35f
3401b7e8:	4855      	ldr	r0, [pc, #340]	@ (3401b940 <HAL_XSPI_Command+0x420>)
3401b7ea:	f7e5 fd55 	bl	34001298 <assert_failed>
    }
    assert_param(IS_XSPI_DATA_DTR_MODE(pCmd->DataDTRMode));
3401b7ee:	68bb      	ldr	r3, [r7, #8]
3401b7f0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b7f2:	2b00      	cmp	r3, #0
3401b7f4:	d009      	beq.n	3401b80a <HAL_XSPI_Command+0x2ea>
3401b7f6:	68bb      	ldr	r3, [r7, #8]
3401b7f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b7fa:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3401b7fe:	d004      	beq.n	3401b80a <HAL_XSPI_Command+0x2ea>
3401b800:	f240 3161 	movw	r1, #865	@ 0x361
3401b804:	484e      	ldr	r0, [pc, #312]	@ (3401b940 <HAL_XSPI_Command+0x420>)
3401b806:	f7e5 fd47 	bl	34001298 <assert_failed>
    assert_param(IS_XSPI_DUMMY_CYCLES(pCmd->DummyCycles));
3401b80a:	68bb      	ldr	r3, [r7, #8]
3401b80c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401b80e:	2b1f      	cmp	r3, #31
3401b810:	d904      	bls.n	3401b81c <HAL_XSPI_Command+0x2fc>
3401b812:	f240 3162 	movw	r1, #866	@ 0x362
3401b816:	484a      	ldr	r0, [pc, #296]	@ (3401b940 <HAL_XSPI_Command+0x420>)
3401b818:	f7e5 fd3e 	bl	34001298 <assert_failed>
  }

  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));
3401b81c:	68bb      	ldr	r3, [r7, #8]
3401b81e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401b820:	2b00      	cmp	r3, #0
3401b822:	d009      	beq.n	3401b838 <HAL_XSPI_Command+0x318>
3401b824:	68bb      	ldr	r3, [r7, #8]
3401b826:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401b828:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401b82c:	d004      	beq.n	3401b838 <HAL_XSPI_Command+0x318>
3401b82e:	f240 3165 	movw	r1, #869	@ 0x365
3401b832:	4843      	ldr	r0, [pc, #268]	@ (3401b940 <HAL_XSPI_Command+0x420>)
3401b834:	f7e5 fd30 	bl	34001298 <assert_failed>

  /* Check the state of the driver */
  state = hxspi->State;
3401b838:	68fb      	ldr	r3, [r7, #12]
3401b83a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401b83c:	617b      	str	r3, [r7, #20]
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
3401b83e:	697b      	ldr	r3, [r7, #20]
3401b840:	2b02      	cmp	r3, #2
3401b842:	d104      	bne.n	3401b84e <HAL_XSPI_Command+0x32e>
3401b844:	68fb      	ldr	r3, [r7, #12]
3401b846:	68db      	ldr	r3, [r3, #12]
3401b848:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401b84c:	d115      	bne.n	3401b87a <HAL_XSPI_Command+0x35a>
3401b84e:	697b      	ldr	r3, [r7, #20]
3401b850:	2b14      	cmp	r3, #20
3401b852:	d107      	bne.n	3401b864 <HAL_XSPI_Command+0x344>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
3401b854:	68bb      	ldr	r3, [r7, #8]
3401b856:	681b      	ldr	r3, [r3, #0]
3401b858:	2b02      	cmp	r3, #2
3401b85a:	d00e      	beq.n	3401b87a <HAL_XSPI_Command+0x35a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
3401b85c:	68bb      	ldr	r3, [r7, #8]
3401b85e:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
3401b860:	2b03      	cmp	r3, #3
3401b862:	d00a      	beq.n	3401b87a <HAL_XSPI_Command+0x35a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
3401b864:	697b      	ldr	r3, [r7, #20]
3401b866:	2b24      	cmp	r3, #36	@ 0x24
3401b868:	d15e      	bne.n	3401b928 <HAL_XSPI_Command+0x408>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
3401b86a:	68bb      	ldr	r3, [r7, #8]
3401b86c:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
3401b86e:	2b01      	cmp	r3, #1
3401b870:	d003      	beq.n	3401b87a <HAL_XSPI_Command+0x35a>
        (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))))
3401b872:	68bb      	ldr	r3, [r7, #8]
3401b874:	681b      	ldr	r3, [r3, #0]
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
3401b876:	2b03      	cmp	r3, #3
3401b878:	d156      	bne.n	3401b928 <HAL_XSPI_Command+0x408>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3401b87a:	687b      	ldr	r3, [r7, #4]
3401b87c:	9300      	str	r3, [sp, #0]
3401b87e:	69bb      	ldr	r3, [r7, #24]
3401b880:	2200      	movs	r2, #0
3401b882:	2120      	movs	r1, #32
3401b884:	68f8      	ldr	r0, [r7, #12]
3401b886:	f000 fb1e 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401b88a:	4603      	mov	r3, r0
3401b88c:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
3401b88e:	7ffb      	ldrb	r3, [r7, #31]
3401b890:	2b00      	cmp	r3, #0
3401b892:	d146      	bne.n	3401b922 <HAL_XSPI_Command+0x402>
    {
      /* Initialize error code */
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3401b894:	68fb      	ldr	r3, [r7, #12]
3401b896:	2200      	movs	r2, #0
3401b898:	65da      	str	r2, [r3, #92]	@ 0x5c

      /* Configure the registers */
      status = XSPI_ConfigCmd(hxspi, pCmd);
3401b89a:	68b9      	ldr	r1, [r7, #8]
3401b89c:	68f8      	ldr	r0, [r7, #12]
3401b89e:	f000 fb49 	bl	3401bf34 <XSPI_ConfigCmd>
3401b8a2:	4603      	mov	r3, r0
3401b8a4:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
3401b8a6:	7ffb      	ldrb	r3, [r7, #31]
3401b8a8:	2b00      	cmp	r3, #0
3401b8aa:	d143      	bne.n	3401b934 <HAL_XSPI_Command+0x414>
      {
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
3401b8ac:	68bb      	ldr	r3, [r7, #8]
3401b8ae:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b8b0:	2b00      	cmp	r3, #0
3401b8b2:	d10e      	bne.n	3401b8d2 <HAL_XSPI_Command+0x3b2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until TC flag is set to go back in idle state */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3401b8b4:	687b      	ldr	r3, [r7, #4]
3401b8b6:	9300      	str	r3, [sp, #0]
3401b8b8:	69bb      	ldr	r3, [r7, #24]
3401b8ba:	2201      	movs	r2, #1
3401b8bc:	2102      	movs	r1, #2
3401b8be:	68f8      	ldr	r0, [r7, #12]
3401b8c0:	f000 fb01 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401b8c4:	4603      	mov	r3, r0
3401b8c6:	77fb      	strb	r3, [r7, #31]

          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3401b8c8:	68fb      	ldr	r3, [r7, #12]
3401b8ca:	681b      	ldr	r3, [r3, #0]
3401b8cc:	2202      	movs	r2, #2
3401b8ce:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
3401b8d0:	e030      	b.n	3401b934 <HAL_XSPI_Command+0x414>
        }
        else
        {
          /* Update the state */
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3401b8d2:	68bb      	ldr	r3, [r7, #8]
3401b8d4:	681b      	ldr	r3, [r3, #0]
3401b8d6:	2b00      	cmp	r3, #0
3401b8d8:	d103      	bne.n	3401b8e2 <HAL_XSPI_Command+0x3c2>
          {
            hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3401b8da:	68fb      	ldr	r3, [r7, #12]
3401b8dc:	2204      	movs	r2, #4
3401b8de:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3401b8e0:	e028      	b.n	3401b934 <HAL_XSPI_Command+0x414>
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
3401b8e2:	68bb      	ldr	r3, [r7, #8]
3401b8e4:	681b      	ldr	r3, [r3, #0]
3401b8e6:	2b01      	cmp	r3, #1
3401b8e8:	d10b      	bne.n	3401b902 <HAL_XSPI_Command+0x3e2>
          {
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
3401b8ea:	68fb      	ldr	r3, [r7, #12]
3401b8ec:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401b8ee:	2b24      	cmp	r3, #36	@ 0x24
3401b8f0:	d103      	bne.n	3401b8fa <HAL_XSPI_Command+0x3da>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3401b8f2:	68fb      	ldr	r3, [r7, #12]
3401b8f4:	2204      	movs	r2, #4
3401b8f6:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3401b8f8:	e01c      	b.n	3401b934 <HAL_XSPI_Command+0x414>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
3401b8fa:	68fb      	ldr	r3, [r7, #12]
3401b8fc:	2214      	movs	r2, #20
3401b8fe:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3401b900:	e018      	b.n	3401b934 <HAL_XSPI_Command+0x414>
            }
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3401b902:	68bb      	ldr	r3, [r7, #8]
3401b904:	681b      	ldr	r3, [r3, #0]
3401b906:	2b02      	cmp	r3, #2
3401b908:	d114      	bne.n	3401b934 <HAL_XSPI_Command+0x414>
          {
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
3401b90a:	68fb      	ldr	r3, [r7, #12]
3401b90c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401b90e:	2b14      	cmp	r3, #20
3401b910:	d103      	bne.n	3401b91a <HAL_XSPI_Command+0x3fa>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3401b912:	68fb      	ldr	r3, [r7, #12]
3401b914:	2204      	movs	r2, #4
3401b916:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3401b918:	e00c      	b.n	3401b934 <HAL_XSPI_Command+0x414>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3401b91a:	68fb      	ldr	r3, [r7, #12]
3401b91c:	2224      	movs	r2, #36	@ 0x24
3401b91e:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3401b920:	e008      	b.n	3401b934 <HAL_XSPI_Command+0x414>
        }
      }
    }
    else
    {
      status = HAL_BUSY;
3401b922:	2302      	movs	r3, #2
3401b924:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
3401b926:	e005      	b.n	3401b934 <HAL_XSPI_Command+0x414>
    }
  }
  else
  {
    status = HAL_ERROR;
3401b928:	2301      	movs	r3, #1
3401b92a:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401b92c:	68fb      	ldr	r3, [r7, #12]
3401b92e:	2210      	movs	r2, #16
3401b930:	65da      	str	r2, [r3, #92]	@ 0x5c
3401b932:	e000      	b.n	3401b936 <HAL_XSPI_Command+0x416>
    if (status == HAL_OK)
3401b934:	bf00      	nop
  }

  return status;
3401b936:	7ffb      	ldrb	r3, [r7, #31]
}
3401b938:	4618      	mov	r0, r3
3401b93a:	3720      	adds	r7, #32
3401b93c:	46bd      	mov	sp, r7
3401b93e:	bd80      	pop	{r7, pc}
3401b940:	340245a0 	.word	0x340245a0

3401b944 <HAL_XSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Transmit(XSPI_HandleTypeDef *hxspi, const uint8_t *pData, uint32_t Timeout)
{
3401b944:	b580      	push	{r7, lr}
3401b946:	b08a      	sub	sp, #40	@ 0x28
3401b948:	af02      	add	r7, sp, #8
3401b94a:	60f8      	str	r0, [r7, #12]
3401b94c:	60b9      	str	r1, [r7, #8]
3401b94e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3401b950:	f7eb fe46 	bl	340075e0 <HAL_GetTick>
3401b954:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
3401b956:	68fb      	ldr	r3, [r7, #12]
3401b958:	681b      	ldr	r3, [r3, #0]
3401b95a:	3350      	adds	r3, #80	@ 0x50
3401b95c:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
3401b95e:	68bb      	ldr	r3, [r7, #8]
3401b960:	2b00      	cmp	r3, #0
3401b962:	d105      	bne.n	3401b970 <HAL_XSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
3401b964:	2301      	movs	r3, #1
3401b966:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401b968:	68fb      	ldr	r3, [r7, #12]
3401b96a:	2208      	movs	r2, #8
3401b96c:	65da      	str	r2, [r3, #92]	@ 0x5c
3401b96e:	e057      	b.n	3401ba20 <HAL_XSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3401b970:	68fb      	ldr	r3, [r7, #12]
3401b972:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401b974:	2b04      	cmp	r3, #4
3401b976:	d14e      	bne.n	3401ba16 <HAL_XSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401b978:	68fb      	ldr	r3, [r7, #12]
3401b97a:	681b      	ldr	r3, [r3, #0]
3401b97c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b97e:	1c5a      	adds	r2, r3, #1
3401b980:	68fb      	ldr	r3, [r7, #12]
3401b982:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
3401b984:	68fb      	ldr	r3, [r7, #12]
3401b986:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3401b988:	68fb      	ldr	r3, [r7, #12]
3401b98a:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = (uint8_t *)pData;
3401b98c:	68fb      	ldr	r3, [r7, #12]
3401b98e:	68ba      	ldr	r2, [r7, #8]
3401b990:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
3401b992:	68fb      	ldr	r3, [r7, #12]
3401b994:	681b      	ldr	r3, [r3, #0]
3401b996:	681a      	ldr	r2, [r3, #0]
3401b998:	68fb      	ldr	r3, [r7, #12]
3401b99a:	681b      	ldr	r3, [r3, #0]
3401b99c:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
3401b9a0:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
3401b9a2:	687b      	ldr	r3, [r7, #4]
3401b9a4:	9300      	str	r3, [sp, #0]
3401b9a6:	69bb      	ldr	r3, [r7, #24]
3401b9a8:	2201      	movs	r2, #1
3401b9aa:	2104      	movs	r1, #4
3401b9ac:	68f8      	ldr	r0, [r7, #12]
3401b9ae:	f000 fa8a 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401b9b2:	4603      	mov	r3, r0
3401b9b4:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
3401b9b6:	7ffb      	ldrb	r3, [r7, #31]
3401b9b8:	2b00      	cmp	r3, #0
3401b9ba:	d113      	bne.n	3401b9e4 <HAL_XSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
3401b9bc:	68fb      	ldr	r3, [r7, #12]
3401b9be:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401b9c0:	781a      	ldrb	r2, [r3, #0]
3401b9c2:	697b      	ldr	r3, [r7, #20]
3401b9c4:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
3401b9c6:	68fb      	ldr	r3, [r7, #12]
3401b9c8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401b9ca:	1c5a      	adds	r2, r3, #1
3401b9cc:	68fb      	ldr	r3, [r7, #12]
3401b9ce:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
3401b9d0:	68fb      	ldr	r3, [r7, #12]
3401b9d2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401b9d4:	1e5a      	subs	r2, r3, #1
3401b9d6:	68fb      	ldr	r3, [r7, #12]
3401b9d8:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
3401b9da:	68fb      	ldr	r3, [r7, #12]
3401b9dc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401b9de:	2b00      	cmp	r3, #0
3401b9e0:	d1df      	bne.n	3401b9a2 <HAL_XSPI_Transmit+0x5e>
3401b9e2:	e000      	b.n	3401b9e6 <HAL_XSPI_Transmit+0xa2>
          break;
3401b9e4:	bf00      	nop

      if (status == HAL_OK)
3401b9e6:	7ffb      	ldrb	r3, [r7, #31]
3401b9e8:	2b00      	cmp	r3, #0
3401b9ea:	d119      	bne.n	3401ba20 <HAL_XSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3401b9ec:	687b      	ldr	r3, [r7, #4]
3401b9ee:	9300      	str	r3, [sp, #0]
3401b9f0:	69bb      	ldr	r3, [r7, #24]
3401b9f2:	2201      	movs	r2, #1
3401b9f4:	2102      	movs	r1, #2
3401b9f6:	68f8      	ldr	r0, [r7, #12]
3401b9f8:	f000 fa65 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401b9fc:	4603      	mov	r3, r0
3401b9fe:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
3401ba00:	7ffb      	ldrb	r3, [r7, #31]
3401ba02:	2b00      	cmp	r3, #0
3401ba04:	d10c      	bne.n	3401ba20 <HAL_XSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3401ba06:	68fb      	ldr	r3, [r7, #12]
3401ba08:	681b      	ldr	r3, [r3, #0]
3401ba0a:	2202      	movs	r2, #2
3401ba0c:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3401ba0e:	68fb      	ldr	r3, [r7, #12]
3401ba10:	2202      	movs	r2, #2
3401ba12:	659a      	str	r2, [r3, #88]	@ 0x58
3401ba14:	e004      	b.n	3401ba20 <HAL_XSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
3401ba16:	2301      	movs	r3, #1
3401ba18:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401ba1a:	68fb      	ldr	r3, [r7, #12]
3401ba1c:	2210      	movs	r2, #16
3401ba1e:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
3401ba20:	7ffb      	ldrb	r3, [r7, #31]
}
3401ba22:	4618      	mov	r0, r3
3401ba24:	3720      	adds	r7, #32
3401ba26:	46bd      	mov	sp, r7
3401ba28:	bd80      	pop	{r7, pc}

3401ba2a <HAL_XSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Receive(XSPI_HandleTypeDef *hxspi, uint8_t *const pData, uint32_t Timeout)
{
3401ba2a:	b580      	push	{r7, lr}
3401ba2c:	b08c      	sub	sp, #48	@ 0x30
3401ba2e:	af02      	add	r7, sp, #8
3401ba30:	60f8      	str	r0, [r7, #12]
3401ba32:	60b9      	str	r1, [r7, #8]
3401ba34:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3401ba36:	f7eb fdd3 	bl	340075e0 <HAL_GetTick>
3401ba3a:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
3401ba3c:	68fb      	ldr	r3, [r7, #12]
3401ba3e:	681b      	ldr	r3, [r3, #0]
3401ba40:	3350      	adds	r3, #80	@ 0x50
3401ba42:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hxspi->Instance->AR;
3401ba44:	68fb      	ldr	r3, [r7, #12]
3401ba46:	681b      	ldr	r3, [r3, #0]
3401ba48:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401ba4a:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hxspi->Instance->IR;
3401ba4c:	68fb      	ldr	r3, [r7, #12]
3401ba4e:	681b      	ldr	r3, [r3, #0]
3401ba50:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3401ba54:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
3401ba56:	68bb      	ldr	r3, [r7, #8]
3401ba58:	2b00      	cmp	r3, #0
3401ba5a:	d106      	bne.n	3401ba6a <HAL_XSPI_Receive+0x40>
  {
    status = HAL_ERROR;
3401ba5c:	2301      	movs	r3, #1
3401ba5e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401ba62:	68fb      	ldr	r3, [r7, #12]
3401ba64:	2208      	movs	r2, #8
3401ba66:	65da      	str	r2, [r3, #92]	@ 0x5c
3401ba68:	e07c      	b.n	3401bb64 <HAL_XSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3401ba6a:	68fb      	ldr	r3, [r7, #12]
3401ba6c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401ba6e:	2b04      	cmp	r3, #4
3401ba70:	d172      	bne.n	3401bb58 <HAL_XSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401ba72:	68fb      	ldr	r3, [r7, #12]
3401ba74:	681b      	ldr	r3, [r3, #0]
3401ba76:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401ba78:	1c5a      	adds	r2, r3, #1
3401ba7a:	68fb      	ldr	r3, [r7, #12]
3401ba7c:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
3401ba7e:	68fb      	ldr	r3, [r7, #12]
3401ba80:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3401ba82:	68fb      	ldr	r3, [r7, #12]
3401ba84:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = pData;
3401ba86:	68fb      	ldr	r3, [r7, #12]
3401ba88:	68ba      	ldr	r2, [r7, #8]
3401ba8a:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
3401ba8c:	68fb      	ldr	r3, [r7, #12]
3401ba8e:	681b      	ldr	r3, [r3, #0]
3401ba90:	681b      	ldr	r3, [r3, #0]
3401ba92:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
3401ba96:	68fb      	ldr	r3, [r7, #12]
3401ba98:	681b      	ldr	r3, [r3, #0]
3401ba9a:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
3401ba9e:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401baa0:	68fb      	ldr	r3, [r7, #12]
3401baa2:	68db      	ldr	r3, [r3, #12]
3401baa4:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401baa8:	d104      	bne.n	3401bab4 <HAL_XSPI_Receive+0x8a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
3401baaa:	68fb      	ldr	r3, [r7, #12]
3401baac:	681b      	ldr	r3, [r3, #0]
3401baae:	69ba      	ldr	r2, [r7, #24]
3401bab0:	649a      	str	r2, [r3, #72]	@ 0x48
3401bab2:	e011      	b.n	3401bad8 <HAL_XSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
3401bab4:	68fb      	ldr	r3, [r7, #12]
3401bab6:	681b      	ldr	r3, [r3, #0]
3401bab8:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401babc:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
3401bac0:	2b00      	cmp	r3, #0
3401bac2:	d004      	beq.n	3401bace <HAL_XSPI_Receive+0xa4>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
3401bac4:	68fb      	ldr	r3, [r7, #12]
3401bac6:	681b      	ldr	r3, [r3, #0]
3401bac8:	69ba      	ldr	r2, [r7, #24]
3401baca:	649a      	str	r2, [r3, #72]	@ 0x48
3401bacc:	e004      	b.n	3401bad8 <HAL_XSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401bace:	68fb      	ldr	r3, [r7, #12]
3401bad0:	681b      	ldr	r3, [r3, #0]
3401bad2:	697a      	ldr	r2, [r7, #20]
3401bad4:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
3401bad8:	687b      	ldr	r3, [r7, #4]
3401bada:	9300      	str	r3, [sp, #0]
3401badc:	6a3b      	ldr	r3, [r7, #32]
3401bade:	2201      	movs	r2, #1
3401bae0:	2106      	movs	r1, #6
3401bae2:	68f8      	ldr	r0, [r7, #12]
3401bae4:	f000 f9ef 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401bae8:	4603      	mov	r3, r0
3401baea:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status != HAL_OK)
3401baee:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401baf2:	2b00      	cmp	r3, #0
3401baf4:	d114      	bne.n	3401bb20 <HAL_XSPI_Receive+0xf6>
        {
          break;
        }

        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
3401baf6:	68fb      	ldr	r3, [r7, #12]
3401baf8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401bafa:	69fa      	ldr	r2, [r7, #28]
3401bafc:	7812      	ldrb	r2, [r2, #0]
3401bafe:	b2d2      	uxtb	r2, r2
3401bb00:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
3401bb02:	68fb      	ldr	r3, [r7, #12]
3401bb04:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401bb06:	1c5a      	adds	r2, r3, #1
3401bb08:	68fb      	ldr	r3, [r7, #12]
3401bb0a:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
3401bb0c:	68fb      	ldr	r3, [r7, #12]
3401bb0e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401bb10:	1e5a      	subs	r2, r3, #1
3401bb12:	68fb      	ldr	r3, [r7, #12]
3401bb14:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
3401bb16:	68fb      	ldr	r3, [r7, #12]
3401bb18:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401bb1a:	2b00      	cmp	r3, #0
3401bb1c:	d1dc      	bne.n	3401bad8 <HAL_XSPI_Receive+0xae>
3401bb1e:	e000      	b.n	3401bb22 <HAL_XSPI_Receive+0xf8>
          break;
3401bb20:	bf00      	nop

      if (status == HAL_OK)
3401bb22:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401bb26:	2b00      	cmp	r3, #0
3401bb28:	d11c      	bne.n	3401bb64 <HAL_XSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3401bb2a:	687b      	ldr	r3, [r7, #4]
3401bb2c:	9300      	str	r3, [sp, #0]
3401bb2e:	6a3b      	ldr	r3, [r7, #32]
3401bb30:	2201      	movs	r2, #1
3401bb32:	2102      	movs	r1, #2
3401bb34:	68f8      	ldr	r0, [r7, #12]
3401bb36:	f000 f9c6 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401bb3a:	4603      	mov	r3, r0
3401bb3c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status == HAL_OK)
3401bb40:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401bb44:	2b00      	cmp	r3, #0
3401bb46:	d10d      	bne.n	3401bb64 <HAL_XSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3401bb48:	68fb      	ldr	r3, [r7, #12]
3401bb4a:	681b      	ldr	r3, [r3, #0]
3401bb4c:	2202      	movs	r2, #2
3401bb4e:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3401bb50:	68fb      	ldr	r3, [r7, #12]
3401bb52:	2202      	movs	r2, #2
3401bb54:	659a      	str	r2, [r3, #88]	@ 0x58
3401bb56:	e005      	b.n	3401bb64 <HAL_XSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
3401bb58:	2301      	movs	r3, #1
3401bb5a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401bb5e:	68fb      	ldr	r3, [r7, #12]
3401bb60:	2210      	movs	r2, #16
3401bb62:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
3401bb64:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
3401bb68:	4618      	mov	r0, r3
3401bb6a:	3728      	adds	r7, #40	@ 0x28
3401bb6c:	46bd      	mov	sp, r7
3401bb6e:	bd80      	pop	{r7, pc}

3401bb70 <HAL_XSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_AutoPolling(XSPI_HandleTypeDef *hxspi, XSPI_AutoPollingTypeDef *const pCfg,
                                       uint32_t Timeout)
{
3401bb70:	b580      	push	{r7, lr}
3401bb72:	b08c      	sub	sp, #48	@ 0x30
3401bb74:	af02      	add	r7, sp, #8
3401bb76:	60f8      	str	r0, [r7, #12]
3401bb78:	60b9      	str	r1, [r7, #8]
3401bb7a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3401bb7c:	f7eb fd30 	bl	340075e0 <HAL_GetTick>
3401bb80:	6238      	str	r0, [r7, #32]
  uint32_t addr_reg = hxspi->Instance->AR;
3401bb82:	68fb      	ldr	r3, [r7, #12]
3401bb84:	681b      	ldr	r3, [r3, #0]
3401bb86:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401bb88:	61fb      	str	r3, [r7, #28]
  uint32_t ir_reg = hxspi->Instance->IR;
3401bb8a:	68fb      	ldr	r3, [r7, #12]
3401bb8c:	681b      	ldr	r3, [r3, #0]
3401bb8e:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3401bb92:	61bb      	str	r3, [r7, #24]
#ifdef USE_FULL_ASSERT
  uint32_t dlr_reg = hxspi->Instance->DLR;
3401bb94:	68fb      	ldr	r3, [r7, #12]
3401bb96:	681b      	ldr	r3, [r3, #0]
3401bb98:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401bb9a:	617b      	str	r3, [r7, #20]
#endif /* USE_FULL_ASSERT */

  /* Check the parameters of the autopolling configuration structure */
  assert_param(IS_XSPI_MATCH_MODE(pCfg->MatchMode));
3401bb9c:	68bb      	ldr	r3, [r7, #8]
3401bb9e:	689b      	ldr	r3, [r3, #8]
3401bba0:	2b00      	cmp	r3, #0
3401bba2:	d009      	beq.n	3401bbb8 <HAL_XSPI_AutoPolling+0x48>
3401bba4:	68bb      	ldr	r3, [r7, #8]
3401bba6:	689b      	ldr	r3, [r3, #8]
3401bba8:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
3401bbac:	d004      	beq.n	3401bbb8 <HAL_XSPI_AutoPolling+0x48>
3401bbae:	f240 7133 	movw	r1, #1843	@ 0x733
3401bbb2:	4853      	ldr	r0, [pc, #332]	@ (3401bd00 <HAL_XSPI_AutoPolling+0x190>)
3401bbb4:	f7e5 fb70 	bl	34001298 <assert_failed>
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
3401bbb8:	68bb      	ldr	r3, [r7, #8]
3401bbba:	68db      	ldr	r3, [r3, #12]
3401bbbc:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3401bbc0:	d008      	beq.n	3401bbd4 <HAL_XSPI_AutoPolling+0x64>
3401bbc2:	68bb      	ldr	r3, [r7, #8]
3401bbc4:	68db      	ldr	r3, [r3, #12]
3401bbc6:	2b00      	cmp	r3, #0
3401bbc8:	d004      	beq.n	3401bbd4 <HAL_XSPI_AutoPolling+0x64>
3401bbca:	f240 7134 	movw	r1, #1844	@ 0x734
3401bbce:	484c      	ldr	r0, [pc, #304]	@ (3401bd00 <HAL_XSPI_AutoPolling+0x190>)
3401bbd0:	f7e5 fb62 	bl	34001298 <assert_failed>
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
3401bbd4:	68bb      	ldr	r3, [r7, #8]
3401bbd6:	691b      	ldr	r3, [r3, #16]
3401bbd8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401bbdc:	d304      	bcc.n	3401bbe8 <HAL_XSPI_AutoPolling+0x78>
3401bbde:	f240 7135 	movw	r1, #1845	@ 0x735
3401bbe2:	4847      	ldr	r0, [pc, #284]	@ (3401bd00 <HAL_XSPI_AutoPolling+0x190>)
3401bbe4:	f7e5 fb58 	bl	34001298 <assert_failed>
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));
3401bbe8:	697b      	ldr	r3, [r7, #20]
3401bbea:	f1b3 3fff 	cmp.w	r3, #4294967295
3401bbee:	d003      	beq.n	3401bbf8 <HAL_XSPI_AutoPolling+0x88>
3401bbf0:	697b      	ldr	r3, [r7, #20]
3401bbf2:	3301      	adds	r3, #1
3401bbf4:	2b04      	cmp	r3, #4
3401bbf6:	d904      	bls.n	3401bc02 <HAL_XSPI_AutoPolling+0x92>
3401bbf8:	f240 7136 	movw	r1, #1846	@ 0x736
3401bbfc:	4840      	ldr	r0, [pc, #256]	@ (3401bd00 <HAL_XSPI_AutoPolling+0x190>)
3401bbfe:	f7e5 fb4b 	bl	34001298 <assert_failed>

  /* Check the state */
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
3401bc02:	68fb      	ldr	r3, [r7, #12]
3401bc04:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401bc06:	2b04      	cmp	r3, #4
3401bc08:	d16c      	bne.n	3401bce4 <HAL_XSPI_AutoPolling+0x174>
3401bc0a:	68bb      	ldr	r3, [r7, #8]
3401bc0c:	68db      	ldr	r3, [r3, #12]
3401bc0e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3401bc12:	d167      	bne.n	3401bce4 <HAL_XSPI_AutoPolling+0x174>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3401bc14:	687b      	ldr	r3, [r7, #4]
3401bc16:	9300      	str	r3, [sp, #0]
3401bc18:	6a3b      	ldr	r3, [r7, #32]
3401bc1a:	2200      	movs	r2, #0
3401bc1c:	2120      	movs	r1, #32
3401bc1e:	68f8      	ldr	r0, [r7, #12]
3401bc20:	f000 f951 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401bc24:	4603      	mov	r3, r0
3401bc26:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

    if (status == HAL_OK)
3401bc2a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401bc2e:	2b00      	cmp	r3, #0
3401bc30:	d154      	bne.n	3401bcdc <HAL_XSPI_AutoPolling+0x16c>
    {
      /* Configure registers */
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
3401bc32:	68fb      	ldr	r3, [r7, #12]
3401bc34:	681b      	ldr	r3, [r3, #0]
3401bc36:	68ba      	ldr	r2, [r7, #8]
3401bc38:	6812      	ldr	r2, [r2, #0]
3401bc3a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
3401bc3e:	68fb      	ldr	r3, [r7, #12]
3401bc40:	681b      	ldr	r3, [r3, #0]
3401bc42:	68ba      	ldr	r2, [r7, #8]
3401bc44:	6852      	ldr	r2, [r2, #4]
3401bc46:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
3401bc4a:	68fb      	ldr	r3, [r7, #12]
3401bc4c:	681b      	ldr	r3, [r3, #0]
3401bc4e:	68ba      	ldr	r2, [r7, #8]
3401bc50:	6912      	ldr	r2, [r2, #16]
3401bc52:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
3401bc56:	68fb      	ldr	r3, [r7, #12]
3401bc58:	681b      	ldr	r3, [r3, #0]
3401bc5a:	681b      	ldr	r3, [r3, #0]
3401bc5c:	f023 5243 	bic.w	r2, r3, #817889280	@ 0x30c00000
3401bc60:	68bb      	ldr	r3, [r7, #8]
3401bc62:	6899      	ldr	r1, [r3, #8]
3401bc64:	68bb      	ldr	r3, [r7, #8]
3401bc66:	68db      	ldr	r3, [r3, #12]
3401bc68:	430b      	orrs	r3, r1
3401bc6a:	431a      	orrs	r2, r3
3401bc6c:	68fb      	ldr	r3, [r7, #12]
3401bc6e:	681b      	ldr	r3, [r3, #0]
3401bc70:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
3401bc74:	601a      	str	r2, [r3, #0]
                 (pCfg->MatchMode | pCfg->AutomaticStop | XSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401bc76:	68fb      	ldr	r3, [r7, #12]
3401bc78:	68db      	ldr	r3, [r3, #12]
3401bc7a:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401bc7e:	d104      	bne.n	3401bc8a <HAL_XSPI_AutoPolling+0x11a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
3401bc80:	68fb      	ldr	r3, [r7, #12]
3401bc82:	681b      	ldr	r3, [r3, #0]
3401bc84:	69fa      	ldr	r2, [r7, #28]
3401bc86:	649a      	str	r2, [r3, #72]	@ 0x48
3401bc88:	e011      	b.n	3401bcae <HAL_XSPI_AutoPolling+0x13e>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
3401bc8a:	68fb      	ldr	r3, [r7, #12]
3401bc8c:	681b      	ldr	r3, [r3, #0]
3401bc8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401bc92:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
3401bc96:	2b00      	cmp	r3, #0
3401bc98:	d004      	beq.n	3401bca4 <HAL_XSPI_AutoPolling+0x134>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
3401bc9a:	68fb      	ldr	r3, [r7, #12]
3401bc9c:	681b      	ldr	r3, [r3, #0]
3401bc9e:	69fa      	ldr	r2, [r7, #28]
3401bca0:	649a      	str	r2, [r3, #72]	@ 0x48
3401bca2:	e004      	b.n	3401bcae <HAL_XSPI_AutoPolling+0x13e>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401bca4:	68fb      	ldr	r3, [r7, #12]
3401bca6:	681b      	ldr	r3, [r3, #0]
3401bca8:	69ba      	ldr	r2, [r7, #24]
3401bcaa:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
3401bcae:	687b      	ldr	r3, [r7, #4]
3401bcb0:	9300      	str	r3, [sp, #0]
3401bcb2:	6a3b      	ldr	r3, [r7, #32]
3401bcb4:	2201      	movs	r2, #1
3401bcb6:	2108      	movs	r1, #8
3401bcb8:	68f8      	ldr	r0, [r7, #12]
3401bcba:	f000 f904 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401bcbe:	4603      	mov	r3, r0
3401bcc0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

      if (status == HAL_OK)
3401bcc4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401bcc8:	2b00      	cmp	r3, #0
3401bcca:	d112      	bne.n	3401bcf2 <HAL_XSPI_AutoPolling+0x182>
      {
        /* Clear status match flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
3401bccc:	68fb      	ldr	r3, [r7, #12]
3401bcce:	681b      	ldr	r3, [r3, #0]
3401bcd0:	2208      	movs	r2, #8
3401bcd2:	625a      	str	r2, [r3, #36]	@ 0x24

        hxspi->State = HAL_XSPI_STATE_READY;
3401bcd4:	68fb      	ldr	r3, [r7, #12]
3401bcd6:	2202      	movs	r2, #2
3401bcd8:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3401bcda:	e00a      	b.n	3401bcf2 <HAL_XSPI_AutoPolling+0x182>
      }
    }
    else
    {
      status = HAL_BUSY;
3401bcdc:	2302      	movs	r3, #2
3401bcde:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (status == HAL_OK)
3401bce2:	e006      	b.n	3401bcf2 <HAL_XSPI_AutoPolling+0x182>
    }
  }
  else
  {
    status = HAL_ERROR;
3401bce4:	2301      	movs	r3, #1
3401bce6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401bcea:	68fb      	ldr	r3, [r7, #12]
3401bcec:	2210      	movs	r2, #16
3401bcee:	65da      	str	r2, [r3, #92]	@ 0x5c
3401bcf0:	e000      	b.n	3401bcf4 <HAL_XSPI_AutoPolling+0x184>
    if (status == HAL_OK)
3401bcf2:	bf00      	nop
  }

  return status;
3401bcf4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
3401bcf8:	4618      	mov	r0, r3
3401bcfa:	3728      	adds	r7, #40	@ 0x28
3401bcfc:	46bd      	mov	sp, r7
3401bcfe:	bd80      	pop	{r7, pc}
3401bd00:	340245a0 	.word	0x340245a0

3401bd04 <HAL_XSPI_MemoryMapped>:
  * @param  pCfg   : Pointer to structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_MemoryMapped(XSPI_HandleTypeDef *hxspi, XSPI_MemoryMappedTypeDef *const pCfg)
{
3401bd04:	b580      	push	{r7, lr}
3401bd06:	b086      	sub	sp, #24
3401bd08:	af02      	add	r7, sp, #8
3401bd0a:	6078      	str	r0, [r7, #4]
3401bd0c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3401bd0e:	f7eb fc67 	bl	340075e0 <HAL_GetTick>
3401bd12:	60b8      	str	r0, [r7, #8]

  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
3401bd14:	683b      	ldr	r3, [r7, #0]
3401bd16:	681b      	ldr	r3, [r3, #0]
3401bd18:	2b00      	cmp	r3, #0
3401bd1a:	d008      	beq.n	3401bd2e <HAL_XSPI_MemoryMapped+0x2a>
3401bd1c:	683b      	ldr	r3, [r7, #0]
3401bd1e:	681b      	ldr	r3, [r3, #0]
3401bd20:	2b08      	cmp	r3, #8
3401bd22:	d004      	beq.n	3401bd2e <HAL_XSPI_MemoryMapped+0x2a>
3401bd24:	f240 71c7 	movw	r1, #1991	@ 0x7c7
3401bd28:	4846      	ldr	r0, [pc, #280]	@ (3401be44 <HAL_XSPI_MemoryMapped+0x140>)
3401bd2a:	f7e5 fab5 	bl	34001298 <assert_failed>
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));
3401bd2e:	683b      	ldr	r3, [r7, #0]
3401bd30:	689b      	ldr	r3, [r3, #8]
3401bd32:	2b00      	cmp	r3, #0
3401bd34:	d009      	beq.n	3401bd4a <HAL_XSPI_MemoryMapped+0x46>
3401bd36:	683b      	ldr	r3, [r7, #0]
3401bd38:	689b      	ldr	r3, [r3, #8]
3401bd3a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3401bd3e:	d004      	beq.n	3401bd4a <HAL_XSPI_MemoryMapped+0x46>
3401bd40:	f44f 61f9 	mov.w	r1, #1992	@ 0x7c8
3401bd44:	483f      	ldr	r0, [pc, #252]	@ (3401be44 <HAL_XSPI_MemoryMapped+0x140>)
3401bd46:	f7e5 faa7 	bl	34001298 <assert_failed>

  /* Check the state */
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3401bd4a:	687b      	ldr	r3, [r7, #4]
3401bd4c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401bd4e:	2b04      	cmp	r3, #4
3401bd50:	d16d      	bne.n	3401be2e <HAL_XSPI_MemoryMapped+0x12a>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3401bd52:	687b      	ldr	r3, [r7, #4]
3401bd54:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3401bd56:	9300      	str	r3, [sp, #0]
3401bd58:	68bb      	ldr	r3, [r7, #8]
3401bd5a:	2200      	movs	r2, #0
3401bd5c:	2120      	movs	r1, #32
3401bd5e:	6878      	ldr	r0, [r7, #4]
3401bd60:	f000 f8b1 	bl	3401bec6 <XSPI_WaitFlagStateUntilTimeout>
3401bd64:	4603      	mov	r3, r0
3401bd66:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
3401bd68:	7bfb      	ldrb	r3, [r7, #15]
3401bd6a:	2b00      	cmp	r3, #0
3401bd6c:	d164      	bne.n	3401be38 <HAL_XSPI_MemoryMapped+0x134>
    {
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
3401bd6e:	687b      	ldr	r3, [r7, #4]
3401bd70:	2288      	movs	r2, #136	@ 0x88
3401bd72:	659a      	str	r2, [r3, #88]	@ 0x58

      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
3401bd74:	683b      	ldr	r3, [r7, #0]
3401bd76:	689b      	ldr	r3, [r3, #8]
3401bd78:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3401bd7c:	d10b      	bne.n	3401bd96 <HAL_XSPI_MemoryMapped+0x92>
      {
        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
3401bd7e:	687b      	ldr	r3, [r7, #4]
3401bd80:	681b      	ldr	r3, [r3, #0]
3401bd82:	681b      	ldr	r3, [r3, #0]
3401bd84:	f023 7100 	bic.w	r1, r3, #33554432	@ 0x2000000
3401bd88:	683b      	ldr	r3, [r7, #0]
3401bd8a:	689a      	ldr	r2, [r3, #8]
3401bd8c:	687b      	ldr	r3, [r7, #4]
3401bd8e:	681b      	ldr	r3, [r3, #0]
3401bd90:	430a      	orrs	r2, r1
3401bd92:	601a      	str	r2, [r3, #0]
3401bd94:	e01b      	b.n	3401bdce <HAL_XSPI_MemoryMapped+0xca>
      }

      else
      {
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));
3401bd96:	683b      	ldr	r3, [r7, #0]
3401bd98:	68db      	ldr	r3, [r3, #12]
3401bd9a:	2b00      	cmp	r3, #0
3401bd9c:	d009      	beq.n	3401bdb2 <HAL_XSPI_MemoryMapped+0xae>
3401bd9e:	683b      	ldr	r3, [r7, #0]
3401bda0:	68db      	ldr	r3, [r3, #12]
3401bda2:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401bda6:	d004      	beq.n	3401bdb2 <HAL_XSPI_MemoryMapped+0xae>
3401bda8:	f240 71dc 	movw	r1, #2012	@ 0x7dc
3401bdac:	4825      	ldr	r0, [pc, #148]	@ (3401be44 <HAL_XSPI_MemoryMapped+0x140>)
3401bdae:	f7e5 fa73 	bl	34001298 <assert_failed>

        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
3401bdb2:	687b      	ldr	r3, [r7, #4]
3401bdb4:	681b      	ldr	r3, [r3, #0]
3401bdb6:	681b      	ldr	r3, [r3, #0]
3401bdb8:	f023 61c0 	bic.w	r1, r3, #100663296	@ 0x6000000
3401bdbc:	683b      	ldr	r3, [r7, #0]
3401bdbe:	689a      	ldr	r2, [r3, #8]
3401bdc0:	683b      	ldr	r3, [r7, #0]
3401bdc2:	68db      	ldr	r3, [r3, #12]
3401bdc4:	431a      	orrs	r2, r3
3401bdc6:	687b      	ldr	r3, [r7, #4]
3401bdc8:	681b      	ldr	r3, [r3, #0]
3401bdca:	430a      	orrs	r2, r1
3401bdcc:	601a      	str	r2, [r3, #0]
                   (pCfg->NoPrefetchData | pCfg->NoPrefetchAXI));
      }
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
3401bdce:	683b      	ldr	r3, [r7, #0]
3401bdd0:	681b      	ldr	r3, [r3, #0]
3401bdd2:	2b08      	cmp	r3, #8
3401bdd4:	d11b      	bne.n	3401be0e <HAL_XSPI_MemoryMapped+0x10a>
      {
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));
3401bdd6:	683b      	ldr	r3, [r7, #0]
3401bdd8:	685b      	ldr	r3, [r3, #4]
3401bdda:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401bdde:	d304      	bcc.n	3401bdea <HAL_XSPI_MemoryMapped+0xe6>
3401bde0:	f240 71e4 	movw	r1, #2020	@ 0x7e4
3401bde4:	4817      	ldr	r0, [pc, #92]	@ (3401be44 <HAL_XSPI_MemoryMapped+0x140>)
3401bde6:	f7e5 fa57 	bl	34001298 <assert_failed>

        /* Configure register */
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
3401bdea:	687b      	ldr	r3, [r7, #4]
3401bdec:	681b      	ldr	r3, [r3, #0]
3401bdee:	683a      	ldr	r2, [r7, #0]
3401bdf0:	6852      	ldr	r2, [r2, #4]
3401bdf2:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

        /* Clear flags related to interrupt */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
3401bdf6:	687b      	ldr	r3, [r7, #4]
3401bdf8:	681b      	ldr	r3, [r3, #0]
3401bdfa:	2210      	movs	r2, #16
3401bdfc:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Enable the timeout interrupt */
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
3401bdfe:	687b      	ldr	r3, [r7, #4]
3401be00:	681b      	ldr	r3, [r3, #0]
3401be02:	681a      	ldr	r2, [r3, #0]
3401be04:	687b      	ldr	r3, [r7, #4]
3401be06:	681b      	ldr	r3, [r3, #0]
3401be08:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
3401be0c:	601a      	str	r2, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
3401be0e:	687b      	ldr	r3, [r7, #4]
3401be10:	681b      	ldr	r3, [r3, #0]
3401be12:	681b      	ldr	r3, [r3, #0]
3401be14:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3401be18:	f023 0308 	bic.w	r3, r3, #8
3401be1c:	683a      	ldr	r2, [r7, #0]
3401be1e:	6812      	ldr	r2, [r2, #0]
3401be20:	431a      	orrs	r2, r3
3401be22:	687b      	ldr	r3, [r7, #4]
3401be24:	681b      	ldr	r3, [r3, #0]
3401be26:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
3401be2a:	601a      	str	r2, [r3, #0]
3401be2c:	e004      	b.n	3401be38 <HAL_XSPI_MemoryMapped+0x134>
                 (pCfg->TimeOutActivation | XSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
3401be2e:	2301      	movs	r3, #1
3401be30:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401be32:	687b      	ldr	r3, [r7, #4]
3401be34:	2210      	movs	r2, #16
3401be36:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
3401be38:	7bfb      	ldrb	r3, [r7, #15]
}
3401be3a:	4618      	mov	r0, r3
3401be3c:	3710      	adds	r7, #16
3401be3e:	46bd      	mov	sp, r7
3401be40:	bd80      	pop	{r7, pc}
3401be42:	bf00      	nop
3401be44:	340245a0 	.word	0x340245a0

3401be48 <HAL_XSPI_SetClockPrescaler>:
  * @param  hxspi     : XSPI handle.
  * @param  Prescaler : Clock prescaler.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_SetClockPrescaler(XSPI_HandleTypeDef *hxspi, uint32_t Prescaler)
{
3401be48:	b580      	push	{r7, lr}
3401be4a:	b084      	sub	sp, #16
3401be4c:	af00      	add	r7, sp, #0
3401be4e:	6078      	str	r0, [r7, #4]
3401be50:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
3401be52:	2300      	movs	r3, #0
3401be54:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
3401be56:	683b      	ldr	r3, [r7, #0]
3401be58:	2bff      	cmp	r3, #255	@ 0xff
3401be5a:	d904      	bls.n	3401be66 <HAL_XSPI_SetClockPrescaler+0x1e>
3401be5c:	f640 2192 	movw	r1, #2706	@ 0xa92
3401be60:	4810      	ldr	r0, [pc, #64]	@ (3401bea4 <HAL_XSPI_SetClockPrescaler+0x5c>)
3401be62:	f7e5 fa19 	bl	34001298 <assert_failed>

  /* Check the state */
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
3401be66:	687b      	ldr	r3, [r7, #4]
3401be68:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401be6a:	f003 0308 	and.w	r3, r3, #8
3401be6e:	2b00      	cmp	r3, #0
3401be70:	d10e      	bne.n	3401be90 <HAL_XSPI_SetClockPrescaler+0x48>
  {
    /* Synchronize initialization structure with the new clock prescaler value */
    hxspi->Init.ClockPrescaler = Prescaler;
3401be72:	687b      	ldr	r3, [r7, #4]
3401be74:	683a      	ldr	r2, [r7, #0]
3401be76:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Configure clock prescaler */
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3401be78:	687b      	ldr	r3, [r7, #4]
3401be7a:	681b      	ldr	r3, [r3, #0]
3401be7c:	68db      	ldr	r3, [r3, #12]
3401be7e:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
3401be82:	687b      	ldr	r3, [r7, #4]
3401be84:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401be86:	687b      	ldr	r3, [r7, #4]
3401be88:	681b      	ldr	r3, [r3, #0]
3401be8a:	430a      	orrs	r2, r1
3401be8c:	60da      	str	r2, [r3, #12]
3401be8e:	e004      	b.n	3401be9a <HAL_XSPI_SetClockPrescaler+0x52>
               ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));
  }
  else
  {
    status = HAL_ERROR;
3401be90:	2301      	movs	r3, #1
3401be92:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401be94:	687b      	ldr	r3, [r7, #4]
3401be96:	2210      	movs	r2, #16
3401be98:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
3401be9a:	7bfb      	ldrb	r3, [r7, #15]
}
3401be9c:	4618      	mov	r0, r3
3401be9e:	3710      	adds	r7, #16
3401bea0:	46bd      	mov	sp, r7
3401bea2:	bd80      	pop	{r7, pc}
3401bea4:	340245a0 	.word	0x340245a0

3401bea8 <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
3401bea8:	b480      	push	{r7}
3401beaa:	b083      	sub	sp, #12
3401beac:	af00      	add	r7, sp, #0
3401beae:	6078      	str	r0, [r7, #4]
3401beb0:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
3401beb2:	687b      	ldr	r3, [r7, #4]
3401beb4:	683a      	ldr	r2, [r7, #0]
3401beb6:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
3401beb8:	2300      	movs	r3, #0
}
3401beba:	4618      	mov	r0, r3
3401bebc:	370c      	adds	r7, #12
3401bebe:	46bd      	mov	sp, r7
3401bec0:	f85d 7b04 	ldr.w	r7, [sp], #4
3401bec4:	4770      	bx	lr

3401bec6 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
3401bec6:	b580      	push	{r7, lr}
3401bec8:	b084      	sub	sp, #16
3401beca:	af00      	add	r7, sp, #0
3401becc:	60f8      	str	r0, [r7, #12]
3401bece:	60b9      	str	r1, [r7, #8]
3401bed0:	603b      	str	r3, [r7, #0]
3401bed2:	4613      	mov	r3, r2
3401bed4:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3401bed6:	e019      	b.n	3401bf0c <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3401bed8:	69bb      	ldr	r3, [r7, #24]
3401beda:	f1b3 3fff 	cmp.w	r3, #4294967295
3401bede:	d015      	beq.n	3401bf0c <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3401bee0:	f7eb fb7e 	bl	340075e0 <HAL_GetTick>
3401bee4:	4602      	mov	r2, r0
3401bee6:	683b      	ldr	r3, [r7, #0]
3401bee8:	1ad3      	subs	r3, r2, r3
3401beea:	69ba      	ldr	r2, [r7, #24]
3401beec:	429a      	cmp	r2, r3
3401beee:	d302      	bcc.n	3401bef6 <XSPI_WaitFlagStateUntilTimeout+0x30>
3401bef0:	69bb      	ldr	r3, [r7, #24]
3401bef2:	2b00      	cmp	r3, #0
3401bef4:	d10a      	bne.n	3401bf0c <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
3401bef6:	68fb      	ldr	r3, [r7, #12]
3401bef8:	2202      	movs	r2, #2
3401befa:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3401befc:	68fb      	ldr	r3, [r7, #12]
3401befe:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3401bf00:	f043 0201 	orr.w	r2, r3, #1
3401bf04:	68fb      	ldr	r3, [r7, #12]
3401bf06:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
3401bf08:	2303      	movs	r3, #3
3401bf0a:	e00e      	b.n	3401bf2a <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3401bf0c:	68fb      	ldr	r3, [r7, #12]
3401bf0e:	681b      	ldr	r3, [r3, #0]
3401bf10:	6a1a      	ldr	r2, [r3, #32]
3401bf12:	68bb      	ldr	r3, [r7, #8]
3401bf14:	4013      	ands	r3, r2
3401bf16:	2b00      	cmp	r3, #0
3401bf18:	bf14      	ite	ne
3401bf1a:	2301      	movne	r3, #1
3401bf1c:	2300      	moveq	r3, #0
3401bf1e:	b2db      	uxtb	r3, r3
3401bf20:	461a      	mov	r2, r3
3401bf22:	79fb      	ldrb	r3, [r7, #7]
3401bf24:	429a      	cmp	r2, r3
3401bf26:	d1d7      	bne.n	3401bed8 <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
3401bf28:	2300      	movs	r3, #0
}
3401bf2a:	4618      	mov	r0, r3
3401bf2c:	3710      	adds	r7, #16
3401bf2e:	46bd      	mov	sp, r7
3401bf30:	bd80      	pop	{r7, pc}
	...

3401bf34 <XSPI_ConfigCmd>:
  * @param  hxspi : XSPI handle
  * @param  pCmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_ConfigCmd(XSPI_HandleTypeDef *hxspi, XSPI_RegularCmdTypeDef *pCmd)
{
3401bf34:	b580      	push	{r7, lr}
3401bf36:	b088      	sub	sp, #32
3401bf38:	af00      	add	r7, sp, #0
3401bf3a:	6078      	str	r0, [r7, #4]
3401bf3c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
3401bf3e:	2300      	movs	r3, #0
3401bf40:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3401bf42:	687b      	ldr	r3, [r7, #4]
3401bf44:	681b      	ldr	r3, [r3, #0]
3401bf46:	681a      	ldr	r2, [r3, #0]
3401bf48:	687b      	ldr	r3, [r7, #4]
3401bf4a:	681b      	ldr	r3, [r3, #0]
3401bf4c:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
3401bf50:	601a      	str	r2, [r3, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3401bf52:	687b      	ldr	r3, [r7, #4]
3401bf54:	689b      	ldr	r3, [r3, #8]
3401bf56:	2b00      	cmp	r3, #0
3401bf58:	d12b      	bne.n	3401bfb2 <XSPI_ConfigCmd+0x7e>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3401bf5a:	683b      	ldr	r3, [r7, #0]
3401bf5c:	685b      	ldr	r3, [r3, #4]
3401bf5e:	2b00      	cmp	r3, #0
3401bf60:	d01c      	beq.n	3401bf9c <XSPI_ConfigCmd+0x68>
3401bf62:	683b      	ldr	r3, [r7, #0]
3401bf64:	685b      	ldr	r3, [r3, #4]
3401bf66:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3401bf6a:	d017      	beq.n	3401bf9c <XSPI_ConfigCmd+0x68>
3401bf6c:	683b      	ldr	r3, [r7, #0]
3401bf6e:	685b      	ldr	r3, [r3, #4]
3401bf70:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3401bf74:	d012      	beq.n	3401bf9c <XSPI_ConfigCmd+0x68>
3401bf76:	683b      	ldr	r3, [r7, #0]
3401bf78:	685b      	ldr	r3, [r3, #4]
3401bf7a:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
3401bf7e:	d00d      	beq.n	3401bf9c <XSPI_ConfigCmd+0x68>
3401bf80:	683b      	ldr	r3, [r7, #0]
3401bf82:	685b      	ldr	r3, [r3, #4]
3401bf84:	2b00      	cmp	r3, #0
3401bf86:	d009      	beq.n	3401bf9c <XSPI_ConfigCmd+0x68>
3401bf88:	683b      	ldr	r3, [r7, #0]
3401bf8a:	685b      	ldr	r3, [r3, #4]
3401bf8c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3401bf90:	d004      	beq.n	3401bf9c <XSPI_ConfigCmd+0x68>
3401bf92:	f640 41a3 	movw	r1, #3235	@ 0xca3
3401bf96:	4892      	ldr	r0, [pc, #584]	@ (3401c1e0 <XSPI_ConfigCmd+0x2ac>)
3401bf98:	f7e5 f97e 	bl	34001298 <assert_failed>
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
3401bf9c:	687b      	ldr	r3, [r7, #4]
3401bf9e:	681b      	ldr	r3, [r3, #0]
3401bfa0:	681b      	ldr	r3, [r3, #0]
3401bfa2:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
3401bfa6:	683b      	ldr	r3, [r7, #0]
3401bfa8:	685a      	ldr	r2, [r3, #4]
3401bfaa:	687b      	ldr	r3, [r7, #4]
3401bfac:	681b      	ldr	r3, [r3, #0]
3401bfae:	430a      	orrs	r2, r1
3401bfb0:	601a      	str	r2, [r3, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3401bfb2:	683b      	ldr	r3, [r7, #0]
3401bfb4:	681b      	ldr	r3, [r3, #0]
3401bfb6:	2b02      	cmp	r3, #2
3401bfb8:	d114      	bne.n	3401bfe4 <XSPI_ConfigCmd+0xb0>
  {
    ccr_reg = &(hxspi->Instance->WCCR);
3401bfba:	687b      	ldr	r3, [r7, #4]
3401bfbc:	681b      	ldr	r3, [r3, #0]
3401bfbe:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
3401bfc2:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WTCR);
3401bfc4:	687b      	ldr	r3, [r7, #4]
3401bfc6:	681b      	ldr	r3, [r3, #0]
3401bfc8:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
3401bfcc:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WIR);
3401bfce:	687b      	ldr	r3, [r7, #4]
3401bfd0:	681b      	ldr	r3, [r3, #0]
3401bfd2:	f503 73c8 	add.w	r3, r3, #400	@ 0x190
3401bfd6:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WABR);
3401bfd8:	687b      	ldr	r3, [r7, #4]
3401bfda:	681b      	ldr	r3, [r3, #0]
3401bfdc:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
3401bfe0:	60fb      	str	r3, [r7, #12]
3401bfe2:	e02c      	b.n	3401c03e <XSPI_ConfigCmd+0x10a>
  }
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
3401bfe4:	683b      	ldr	r3, [r7, #0]
3401bfe6:	681b      	ldr	r3, [r3, #0]
3401bfe8:	2b03      	cmp	r3, #3
3401bfea:	d114      	bne.n	3401c016 <XSPI_ConfigCmd+0xe2>
  {
    ccr_reg = &(hxspi->Instance->WPCCR);
3401bfec:	687b      	ldr	r3, [r7, #4]
3401bfee:	681b      	ldr	r3, [r3, #0]
3401bff0:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
3401bff4:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WPTCR);
3401bff6:	687b      	ldr	r3, [r7, #4]
3401bff8:	681b      	ldr	r3, [r3, #0]
3401bffa:	f503 73a4 	add.w	r3, r3, #328	@ 0x148
3401bffe:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WPIR);
3401c000:	687b      	ldr	r3, [r7, #4]
3401c002:	681b      	ldr	r3, [r3, #0]
3401c004:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
3401c008:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WPABR);
3401c00a:	687b      	ldr	r3, [r7, #4]
3401c00c:	681b      	ldr	r3, [r3, #0]
3401c00e:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
3401c012:	60fb      	str	r3, [r7, #12]
3401c014:	e013      	b.n	3401c03e <XSPI_ConfigCmd+0x10a>
  }
  else
  {
    ccr_reg = &(hxspi->Instance->CCR);
3401c016:	687b      	ldr	r3, [r7, #4]
3401c018:	681b      	ldr	r3, [r3, #0]
3401c01a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3401c01e:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->TCR);
3401c020:	687b      	ldr	r3, [r7, #4]
3401c022:	681b      	ldr	r3, [r3, #0]
3401c024:	f503 7384 	add.w	r3, r3, #264	@ 0x108
3401c028:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->IR);
3401c02a:	687b      	ldr	r3, [r7, #4]
3401c02c:	681b      	ldr	r3, [r3, #0]
3401c02e:	f503 7388 	add.w	r3, r3, #272	@ 0x110
3401c032:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->ABR);
3401c034:	687b      	ldr	r3, [r7, #4]
3401c036:	681b      	ldr	r3, [r3, #0]
3401c038:	f503 7390 	add.w	r3, r3, #288	@ 0x120
3401c03c:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
3401c03e:	683b      	ldr	r3, [r7, #0]
3401c040:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401c042:	69bb      	ldr	r3, [r7, #24]
3401c044:	601a      	str	r2, [r3, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3401c046:	683b      	ldr	r3, [r7, #0]
3401c048:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401c04a:	2b00      	cmp	r3, #0
3401c04c:	d012      	beq.n	3401c074 <XSPI_ConfigCmd+0x140>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
3401c04e:	683b      	ldr	r3, [r7, #0]
3401c050:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3401c052:	68fb      	ldr	r3, [r7, #12]
3401c054:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
3401c056:	69bb      	ldr	r3, [r7, #24]
3401c058:	681b      	ldr	r3, [r3, #0]
3401c05a:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
3401c05e:	683b      	ldr	r3, [r7, #0]
3401c060:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
3401c062:	683b      	ldr	r3, [r7, #0]
3401c064:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401c066:	4319      	orrs	r1, r3
3401c068:	683b      	ldr	r3, [r7, #0]
3401c06a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401c06c:	430b      	orrs	r3, r1
3401c06e:	431a      	orrs	r2, r3
3401c070:	69bb      	ldr	r3, [r7, #24]
3401c072:	601a      	str	r2, [r3, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
3401c074:	697b      	ldr	r3, [r7, #20]
3401c076:	681b      	ldr	r3, [r3, #0]
3401c078:	f023 021f 	bic.w	r2, r3, #31
3401c07c:	683b      	ldr	r3, [r7, #0]
3401c07e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401c080:	431a      	orrs	r2, r3
3401c082:	697b      	ldr	r3, [r7, #20]
3401c084:	601a      	str	r2, [r3, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3401c086:	683b      	ldr	r3, [r7, #0]
3401c088:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401c08a:	2b00      	cmp	r3, #0
3401c08c:	d009      	beq.n	3401c0a2 <XSPI_ConfigCmd+0x16e>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3401c08e:	683b      	ldr	r3, [r7, #0]
3401c090:	681b      	ldr	r3, [r3, #0]
3401c092:	2b00      	cmp	r3, #0
3401c094:	d105      	bne.n	3401c0a2 <XSPI_ConfigCmd+0x16e>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
3401c096:	683b      	ldr	r3, [r7, #0]
3401c098:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3401c09a:	687b      	ldr	r3, [r7, #4]
3401c09c:	681b      	ldr	r3, [r3, #0]
3401c09e:	3a01      	subs	r2, #1
3401c0a0:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3401c0a2:	683b      	ldr	r3, [r7, #0]
3401c0a4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401c0a6:	2b00      	cmp	r3, #0
3401c0a8:	d01e      	beq.n	3401c0e8 <XSPI_ConfigCmd+0x1b4>
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
3401c0aa:	683b      	ldr	r3, [r7, #0]
3401c0ac:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401c0ae:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3401c0b2:	d10a      	bne.n	3401c0ca <XSPI_ConfigCmd+0x196>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3401c0b4:	687b      	ldr	r3, [r7, #4]
3401c0b6:	681b      	ldr	r3, [r3, #0]
3401c0b8:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3401c0bc:	687b      	ldr	r3, [r7, #4]
3401c0be:	681b      	ldr	r3, [r3, #0]
3401c0c0:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
3401c0c4:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
3401c0c8:	e00e      	b.n	3401c0e8 <XSPI_ConfigCmd+0x1b4>
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
3401c0ca:	687b      	ldr	r3, [r7, #4]
3401c0cc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401c0ce:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3401c0d2:	d109      	bne.n	3401c0e8 <XSPI_ConfigCmd+0x1b4>
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3401c0d4:	687b      	ldr	r3, [r7, #4]
3401c0d6:	681b      	ldr	r3, [r3, #0]
3401c0d8:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3401c0dc:	687b      	ldr	r3, [r7, #4]
3401c0de:	681b      	ldr	r3, [r3, #0]
3401c0e0:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
3401c0e4:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3401c0e8:	683b      	ldr	r3, [r7, #0]
3401c0ea:	68db      	ldr	r3, [r3, #12]
3401c0ec:	2b00      	cmp	r3, #0
3401c0ee:	f000 809e 	beq.w	3401c22e <XSPI_ConfigCmd+0x2fa>
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3401c0f2:	683b      	ldr	r3, [r7, #0]
3401c0f4:	69db      	ldr	r3, [r3, #28]
3401c0f6:	2b00      	cmp	r3, #0
3401c0f8:	d055      	beq.n	3401c1a6 <XSPI_ConfigCmd+0x272>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3401c0fa:	683b      	ldr	r3, [r7, #0]
3401c0fc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401c0fe:	2b00      	cmp	r3, #0
3401c100:	d01e      	beq.n	3401c140 <XSPI_ConfigCmd+0x20c>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3401c102:	69bb      	ldr	r3, [r7, #24]
3401c104:	681a      	ldr	r2, [r3, #0]
3401c106:	4b37      	ldr	r3, [pc, #220]	@ (3401c1e4 <XSPI_ConfigCmd+0x2b0>)
3401c108:	4013      	ands	r3, r2
3401c10a:	683a      	ldr	r2, [r7, #0]
3401c10c:	68d1      	ldr	r1, [r2, #12]
3401c10e:	683a      	ldr	r2, [r7, #0]
3401c110:	6952      	ldr	r2, [r2, #20]
3401c112:	4311      	orrs	r1, r2
3401c114:	683a      	ldr	r2, [r7, #0]
3401c116:	6912      	ldr	r2, [r2, #16]
3401c118:	4311      	orrs	r1, r2
3401c11a:	683a      	ldr	r2, [r7, #0]
3401c11c:	69d2      	ldr	r2, [r2, #28]
3401c11e:	4311      	orrs	r1, r2
3401c120:	683a      	ldr	r2, [r7, #0]
3401c122:	6a52      	ldr	r2, [r2, #36]	@ 0x24
3401c124:	4311      	orrs	r1, r2
3401c126:	683a      	ldr	r2, [r7, #0]
3401c128:	6a12      	ldr	r2, [r2, #32]
3401c12a:	4311      	orrs	r1, r2
3401c12c:	683a      	ldr	r2, [r7, #0]
3401c12e:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3401c130:	4311      	orrs	r1, r2
3401c132:	683a      	ldr	r2, [r7, #0]
3401c134:	6c12      	ldr	r2, [r2, #64]	@ 0x40
3401c136:	430a      	orrs	r2, r1
3401c138:	431a      	orrs	r2, r3
3401c13a:	69bb      	ldr	r3, [r7, #24]
3401c13c:	601a      	str	r2, [r3, #0]
3401c13e:	e028      	b.n	3401c192 <XSPI_ConfigCmd+0x25e>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3401c140:	69bb      	ldr	r3, [r7, #24]
3401c142:	681b      	ldr	r3, [r3, #0]
3401c144:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3401c148:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
3401c14c:	683a      	ldr	r2, [r7, #0]
3401c14e:	68d1      	ldr	r1, [r2, #12]
3401c150:	683a      	ldr	r2, [r7, #0]
3401c152:	6952      	ldr	r2, [r2, #20]
3401c154:	4311      	orrs	r1, r2
3401c156:	683a      	ldr	r2, [r7, #0]
3401c158:	6912      	ldr	r2, [r2, #16]
3401c15a:	4311      	orrs	r1, r2
3401c15c:	683a      	ldr	r2, [r7, #0]
3401c15e:	69d2      	ldr	r2, [r2, #28]
3401c160:	4311      	orrs	r1, r2
3401c162:	683a      	ldr	r2, [r7, #0]
3401c164:	6a52      	ldr	r2, [r2, #36]	@ 0x24
3401c166:	4311      	orrs	r1, r2
3401c168:	683a      	ldr	r2, [r7, #0]
3401c16a:	6a12      	ldr	r2, [r2, #32]
3401c16c:	430a      	orrs	r2, r1
3401c16e:	431a      	orrs	r2, r3
3401c170:	69bb      	ldr	r3, [r7, #24]
3401c172:	601a      	str	r2, [r3, #0]
                                XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth |
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3401c174:	687b      	ldr	r3, [r7, #4]
3401c176:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401c178:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401c17c:	d109      	bne.n	3401c192 <XSPI_ConfigCmd+0x25e>
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
3401c17e:	683b      	ldr	r3, [r7, #0]
3401c180:	695b      	ldr	r3, [r3, #20]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3401c182:	2b08      	cmp	r3, #8
3401c184:	d105      	bne.n	3401c192 <XSPI_ConfigCmd+0x25e>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3401c186:	69bb      	ldr	r3, [r7, #24]
3401c188:	681b      	ldr	r3, [r3, #0]
3401c18a:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3401c18e:	69bb      	ldr	r3, [r7, #24]
3401c190:	601a      	str	r2, [r3, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
3401c192:	683b      	ldr	r3, [r7, #0]
3401c194:	689a      	ldr	r2, [r3, #8]
3401c196:	693b      	ldr	r3, [r7, #16]
3401c198:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
3401c19a:	687b      	ldr	r3, [r7, #4]
3401c19c:	681b      	ldr	r3, [r3, #0]
3401c19e:	683a      	ldr	r2, [r7, #0]
3401c1a0:	6992      	ldr	r2, [r2, #24]
3401c1a2:	649a      	str	r2, [r3, #72]	@ 0x48
3401c1a4:	e07d      	b.n	3401c2a2 <XSPI_ConfigCmd+0x36e>
    }
    else
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3401c1a6:	683b      	ldr	r3, [r7, #0]
3401c1a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401c1aa:	2b00      	cmp	r3, #0
3401c1ac:	d01c      	beq.n	3401c1e8 <XSPI_ConfigCmd+0x2b4>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3401c1ae:	69bb      	ldr	r3, [r7, #24]
3401c1b0:	681b      	ldr	r3, [r3, #0]
3401c1b2:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
3401c1b6:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
3401c1ba:	683a      	ldr	r2, [r7, #0]
3401c1bc:	68d1      	ldr	r1, [r2, #12]
3401c1be:	683a      	ldr	r2, [r7, #0]
3401c1c0:	6952      	ldr	r2, [r2, #20]
3401c1c2:	4311      	orrs	r1, r2
3401c1c4:	683a      	ldr	r2, [r7, #0]
3401c1c6:	6912      	ldr	r2, [r2, #16]
3401c1c8:	4311      	orrs	r1, r2
3401c1ca:	683a      	ldr	r2, [r7, #0]
3401c1cc:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3401c1ce:	4311      	orrs	r1, r2
3401c1d0:	683a      	ldr	r2, [r7, #0]
3401c1d2:	6c12      	ldr	r2, [r2, #64]	@ 0x40
3401c1d4:	430a      	orrs	r2, r1
3401c1d6:	431a      	orrs	r2, r3
3401c1d8:	69bb      	ldr	r3, [r7, #24]
3401c1da:	601a      	str	r2, [r3, #0]
3401c1dc:	e022      	b.n	3401c224 <XSPI_ConfigCmd+0x2f0>
3401c1de:	bf00      	nop
3401c1e0:	340245a0 	.word	0x340245a0
3401c1e4:	f0ffc0c0 	.word	0xf0ffc0c0
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
3401c1e8:	69bb      	ldr	r3, [r7, #24]
3401c1ea:	681b      	ldr	r3, [r3, #0]
3401c1ec:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
3401c1f0:	683b      	ldr	r3, [r7, #0]
3401c1f2:	68d9      	ldr	r1, [r3, #12]
3401c1f4:	683b      	ldr	r3, [r7, #0]
3401c1f6:	695b      	ldr	r3, [r3, #20]
3401c1f8:	4319      	orrs	r1, r3
3401c1fa:	683b      	ldr	r3, [r7, #0]
3401c1fc:	691b      	ldr	r3, [r3, #16]
3401c1fe:	430b      	orrs	r3, r1
3401c200:	431a      	orrs	r2, r3
3401c202:	69bb      	ldr	r3, [r7, #24]
3401c204:	601a      	str	r2, [r3, #0]
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3401c206:	687b      	ldr	r3, [r7, #4]
3401c208:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401c20a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401c20e:	d109      	bne.n	3401c224 <XSPI_ConfigCmd+0x2f0>
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
3401c210:	683b      	ldr	r3, [r7, #0]
3401c212:	695b      	ldr	r3, [r3, #20]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3401c214:	2b08      	cmp	r3, #8
3401c216:	d105      	bne.n	3401c224 <XSPI_ConfigCmd+0x2f0>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3401c218:	69bb      	ldr	r3, [r7, #24]
3401c21a:	681b      	ldr	r3, [r3, #0]
3401c21c:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3401c220:	69bb      	ldr	r3, [r7, #24]
3401c222:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
3401c224:	683b      	ldr	r3, [r7, #0]
3401c226:	689a      	ldr	r2, [r3, #8]
3401c228:	693b      	ldr	r3, [r7, #16]
3401c22a:	601a      	str	r2, [r3, #0]
3401c22c:	e039      	b.n	3401c2a2 <XSPI_ConfigCmd+0x36e>

    }
  }
  else
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3401c22e:	683b      	ldr	r3, [r7, #0]
3401c230:	69db      	ldr	r3, [r3, #28]
3401c232:	2b00      	cmp	r3, #0
3401c234:	d030      	beq.n	3401c298 <XSPI_ConfigCmd+0x364>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3401c236:	683b      	ldr	r3, [r7, #0]
3401c238:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401c23a:	2b00      	cmp	r3, #0
3401c23c:	d017      	beq.n	3401c26e <XSPI_ConfigCmd+0x33a>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
3401c23e:	69bb      	ldr	r3, [r7, #24]
3401c240:	681b      	ldr	r3, [r3, #0]
3401c242:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
3401c246:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3401c24a:	683a      	ldr	r2, [r7, #0]
3401c24c:	69d1      	ldr	r1, [r2, #28]
3401c24e:	683a      	ldr	r2, [r7, #0]
3401c250:	6a52      	ldr	r2, [r2, #36]	@ 0x24
3401c252:	4311      	orrs	r1, r2
3401c254:	683a      	ldr	r2, [r7, #0]
3401c256:	6a12      	ldr	r2, [r2, #32]
3401c258:	4311      	orrs	r1, r2
3401c25a:	683a      	ldr	r2, [r7, #0]
3401c25c:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3401c25e:	4311      	orrs	r1, r2
3401c260:	683a      	ldr	r2, [r7, #0]
3401c262:	6c12      	ldr	r2, [r2, #64]	@ 0x40
3401c264:	430a      	orrs	r2, r1
3401c266:	431a      	orrs	r2, r3
3401c268:	69bb      	ldr	r3, [r7, #24]
3401c26a:	601a      	str	r2, [r3, #0]
3401c26c:	e00e      	b.n	3401c28c <XSPI_ConfigCmd+0x358>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
3401c26e:	69bb      	ldr	r3, [r7, #24]
3401c270:	681b      	ldr	r3, [r3, #0]
3401c272:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
3401c276:	683b      	ldr	r3, [r7, #0]
3401c278:	69d9      	ldr	r1, [r3, #28]
3401c27a:	683b      	ldr	r3, [r7, #0]
3401c27c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c27e:	4319      	orrs	r1, r3
3401c280:	683b      	ldr	r3, [r7, #0]
3401c282:	6a1b      	ldr	r3, [r3, #32]
3401c284:	430b      	orrs	r3, r1
3401c286:	431a      	orrs	r2, r3
3401c288:	69bb      	ldr	r3, [r7, #24]
3401c28a:	601a      	str	r2, [r3, #0]
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
3401c28c:	687b      	ldr	r3, [r7, #4]
3401c28e:	681b      	ldr	r3, [r3, #0]
3401c290:	683a      	ldr	r2, [r7, #0]
3401c292:	6992      	ldr	r2, [r2, #24]
3401c294:	649a      	str	r2, [r3, #72]	@ 0x48
3401c296:	e004      	b.n	3401c2a2 <XSPI_ConfigCmd+0x36e>
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
3401c298:	2301      	movs	r3, #1
3401c29a:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401c29c:	687b      	ldr	r3, [r7, #4]
3401c29e:	2208      	movs	r2, #8
3401c2a0:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
3401c2a2:	7ffb      	ldrb	r3, [r7, #31]
}
3401c2a4:	4618      	mov	r0, r3
3401c2a6:	3720      	adds	r7, #32
3401c2a8:	46bd      	mov	sp, r7
3401c2aa:	bd80      	pop	{r7, pc}

3401c2ac <CMW_CAMERA_GetDCMIPPHandle>:
static void CMW_CAMERA_PwrDown(void);
static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch);
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName);

DCMIPP_HandleTypeDef* CMW_CAMERA_GetDCMIPPHandle(void)
{
3401c2ac:	b480      	push	{r7}
3401c2ae:	af00      	add	r7, sp, #0
    return &hcamera_dcmipp;
3401c2b0:	4b02      	ldr	r3, [pc, #8]	@ (3401c2bc <CMW_CAMERA_GetDCMIPPHandle+0x10>)
}
3401c2b2:	4618      	mov	r0, r3
3401c2b4:	46bd      	mov	sp, r7
3401c2b6:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c2ba:	4770      	bx	lr
3401c2bc:	34053bcc 	.word	0x34053bcc

3401c2c0 <CMW_CAMERA_PIPE_VsyncEventCallback>:
 * @brief  Vsync Event callback on pipe
 * @param  Pipe  Pipe receiving the callback
 * @retval None
 */
__weak int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
{
3401c2c0:	b480      	push	{r7}
3401c2c2:	b083      	sub	sp, #12
3401c2c4:	af00      	add	r7, sp, #0
3401c2c6:	6078      	str	r0, [r7, #4]
  UNUSED(pipe);

  return HAL_OK;
3401c2c8:	2300      	movs	r3, #0
}
3401c2ca:	4618      	mov	r0, r3
3401c2cc:	370c      	adds	r7, #12
3401c2ce:	46bd      	mov	sp, r7
3401c2d0:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c2d4:	4770      	bx	lr
	...

3401c2d8 <HAL_DCMIPP_PIPE_VsyncEventCallback>:
 * @param  hdcmipp DCMIPP device handle
 *         Pipe    Pipe receiving the callback
 * @retval None
 */
void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3401c2d8:	b580      	push	{r7, lr}
3401c2da:	b082      	sub	sp, #8
3401c2dc:	af00      	add	r7, sp, #0
3401c2de:	6078      	str	r0, [r7, #4]
3401c2e0:	6039      	str	r1, [r7, #0]
  UNUSED(hdcmipp);
  if(Camera_Drv.VsyncEventCallback != NULL)
3401c2e2:	4b08      	ldr	r3, [pc, #32]	@ (3401c304 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x2c>)
3401c2e4:	691b      	ldr	r3, [r3, #16]
3401c2e6:	2b00      	cmp	r3, #0
3401c2e8:	d004      	beq.n	3401c2f4 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>
  {
      Camera_Drv.VsyncEventCallback(&camera_bsp, Pipe);
3401c2ea:	4b06      	ldr	r3, [pc, #24]	@ (3401c304 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x2c>)
3401c2ec:	691b      	ldr	r3, [r3, #16]
3401c2ee:	6839      	ldr	r1, [r7, #0]
3401c2f0:	4805      	ldr	r0, [pc, #20]	@ (3401c308 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x30>)
3401c2f2:	4798      	blx	r3
  }
  CMW_CAMERA_PIPE_VsyncEventCallback(Pipe);
3401c2f4:	6838      	ldr	r0, [r7, #0]
3401c2f6:	f7ff ffe3 	bl	3401c2c0 <CMW_CAMERA_PIPE_VsyncEventCallback>
}
3401c2fa:	bf00      	nop
3401c2fc:	3708      	adds	r7, #8
3401c2fe:	46bd      	mov	sp, r7
3401c300:	bd80      	pop	{r7, pc}
3401c302:	bf00      	nop
3401c304:	34053bd8 	.word	0x34053bd8
3401c308:	34053c38 	.word	0x34053c38

3401c30c <HAL_DCMIPP_PIPE_FrameEventCallback>:
 * @param  hdcmipp DCMIPP device handle
 *         Pipe    Pipe receiving the callback
 * @retval None
 */
void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3401c30c:	b580      	push	{r7, lr}
3401c30e:	b082      	sub	sp, #8
3401c310:	af00      	add	r7, sp, #0
3401c312:	6078      	str	r0, [r7, #4]
3401c314:	6039      	str	r1, [r7, #0]
  UNUSED(hdcmipp);
  if(Camera_Drv.FrameEventCallback != NULL)
3401c316:	4b08      	ldr	r3, [pc, #32]	@ (3401c338 <HAL_DCMIPP_PIPE_FrameEventCallback+0x2c>)
3401c318:	695b      	ldr	r3, [r3, #20]
3401c31a:	2b00      	cmp	r3, #0
3401c31c:	d004      	beq.n	3401c328 <HAL_DCMIPP_PIPE_FrameEventCallback+0x1c>
  {
      Camera_Drv.FrameEventCallback(&camera_bsp, Pipe);
3401c31e:	4b06      	ldr	r3, [pc, #24]	@ (3401c338 <HAL_DCMIPP_PIPE_FrameEventCallback+0x2c>)
3401c320:	695b      	ldr	r3, [r3, #20]
3401c322:	6839      	ldr	r1, [r7, #0]
3401c324:	4805      	ldr	r0, [pc, #20]	@ (3401c33c <HAL_DCMIPP_PIPE_FrameEventCallback+0x30>)
3401c326:	4798      	blx	r3
  }
  CMW_CAMERA_PIPE_FrameEventCallback(Pipe);
3401c328:	6838      	ldr	r0, [r7, #0]
3401c32a:	f7e4 fbf7 	bl	34000b1c <CMW_CAMERA_PIPE_FrameEventCallback>
}
3401c32e:	bf00      	nop
3401c330:	3708      	adds	r7, #8
3401c332:	46bd      	mov	sp, r7
3401c334:	bd80      	pop	{r7, pc}
3401c336:	bf00      	nop
3401c338:	34053bd8 	.word	0x34053bd8
3401c33c:	34053c38 	.word	0x34053c38

3401c340 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
3401c340:	b580      	push	{r7, lr}
3401c342:	b082      	sub	sp, #8
3401c344:	af00      	add	r7, sp, #0
3401c346:	6078      	str	r0, [r7, #4]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
3401c348:	687b      	ldr	r3, [r7, #4]
3401c34a:	681b      	ldr	r3, [r3, #0]
3401c34c:	4a22      	ldr	r2, [pc, #136]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c34e:	6013      	str	r3, [r2, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
3401c350:	687b      	ldr	r3, [r7, #4]
3401c352:	685b      	ldr	r3, [r3, #4]
3401c354:	4a20      	ldr	r2, [pc, #128]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c356:	6053      	str	r3, [r2, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
3401c358:	687b      	ldr	r3, [r7, #4]
3401c35a:	689b      	ldr	r3, [r3, #8]
3401c35c:	4a1e      	ldr	r2, [pc, #120]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c35e:	6093      	str	r3, [r2, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
3401c360:	687b      	ldr	r3, [r7, #4]
3401c362:	68db      	ldr	r3, [r3, #12]
3401c364:	4a1c      	ldr	r2, [pc, #112]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c366:	60d3      	str	r3, [r2, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
3401c368:	687b      	ldr	r3, [r7, #4]
3401c36a:	691b      	ldr	r3, [r3, #16]
3401c36c:	4a1a      	ldr	r2, [pc, #104]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c36e:	6113      	str	r3, [r2, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
3401c370:	687b      	ldr	r3, [r7, #4]
3401c372:	695b      	ldr	r3, [r3, #20]
3401c374:	4a18      	ldr	r2, [pc, #96]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c376:	6153      	str	r3, [r2, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
3401c378:	687b      	ldr	r3, [r7, #4]
3401c37a:	699b      	ldr	r3, [r3, #24]
3401c37c:	4a16      	ldr	r2, [pc, #88]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c37e:	6193      	str	r3, [r2, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
3401c380:	687b      	ldr	r3, [r7, #4]
3401c382:	69db      	ldr	r3, [r3, #28]
3401c384:	4a14      	ldr	r2, [pc, #80]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c386:	61d3      	str	r3, [r2, #28]
  FuncDriver.GetYSize       = pDrv->GetYSize;
3401c388:	687b      	ldr	r3, [r7, #4]
3401c38a:	6a1b      	ldr	r3, [r3, #32]
3401c38c:	4a12      	ldr	r2, [pc, #72]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c38e:	6213      	str	r3, [r2, #32]
  FuncDriver.SetLayer       = pDrv->SetLayer;
3401c390:	687b      	ldr	r3, [r7, #4]
3401c392:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c394:	4a10      	ldr	r2, [pc, #64]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c396:	6253      	str	r3, [r2, #36]	@ 0x24
  FuncDriver.GetFormat      = pDrv->GetFormat;
3401c398:	687b      	ldr	r3, [r7, #4]
3401c39a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401c39c:	4a0e      	ldr	r2, [pc, #56]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c39e:	6293      	str	r3, [r2, #40]	@ 0x28

  DrawProp->LcdLayer = 0;
3401c3a0:	4b0e      	ldr	r3, [pc, #56]	@ (3401c3dc <UTIL_LCD_SetFuncDriver+0x9c>)
3401c3a2:	2200      	movs	r2, #0
3401c3a4:	60da      	str	r2, [r3, #12]
  DrawProp->LcdDevice = 0;
3401c3a6:	4b0d      	ldr	r3, [pc, #52]	@ (3401c3dc <UTIL_LCD_SetFuncDriver+0x9c>)
3401c3a8:	2200      	movs	r2, #0
3401c3aa:	611a      	str	r2, [r3, #16]
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
3401c3ac:	4b0a      	ldr	r3, [pc, #40]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c3ae:	69db      	ldr	r3, [r3, #28]
3401c3b0:	4a0b      	ldr	r2, [pc, #44]	@ (3401c3e0 <UTIL_LCD_SetFuncDriver+0xa0>)
3401c3b2:	4611      	mov	r1, r2
3401c3b4:	2000      	movs	r0, #0
3401c3b6:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp->LcdYsize);
3401c3b8:	4b07      	ldr	r3, [pc, #28]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c3ba:	6a1b      	ldr	r3, [r3, #32]
3401c3bc:	4a09      	ldr	r2, [pc, #36]	@ (3401c3e4 <UTIL_LCD_SetFuncDriver+0xa4>)
3401c3be:	4611      	mov	r1, r2
3401c3c0:	2000      	movs	r0, #0
3401c3c2:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
3401c3c4:	4b04      	ldr	r3, [pc, #16]	@ (3401c3d8 <UTIL_LCD_SetFuncDriver+0x98>)
3401c3c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401c3c8:	4a07      	ldr	r2, [pc, #28]	@ (3401c3e8 <UTIL_LCD_SetFuncDriver+0xa8>)
3401c3ca:	4611      	mov	r1, r2
3401c3cc:	2000      	movs	r0, #0
3401c3ce:	4798      	blx	r3
}
3401c3d0:	bf00      	nop
3401c3d2:	3708      	adds	r7, #8
3401c3d4:	46bd      	mov	sp, r7
3401c3d6:	bd80      	pop	{r7, pc}
3401c3d8:	34053d7c 	.word	0x34053d7c
3401c3dc:	34053d3c 	.word	0x34053d3c
3401c3e0:	34053d50 	.word	0x34053d50
3401c3e4:	34053d54 	.word	0x34053d54
3401c3e8:	34053d58 	.word	0x34053d58

3401c3ec <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
3401c3ec:	b580      	push	{r7, lr}
3401c3ee:	b082      	sub	sp, #8
3401c3f0:	af00      	add	r7, sp, #0
3401c3f2:	6078      	str	r0, [r7, #4]
  if(FuncDriver.SetLayer != NULL)
3401c3f4:	4b1d      	ldr	r3, [pc, #116]	@ (3401c46c <UTIL_LCD_SetLayer+0x80>)
3401c3f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c3f8:	2b00      	cmp	r3, #0
3401c3fa:	d032      	beq.n	3401c462 <UTIL_LCD_SetLayer+0x76>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
3401c3fc:	4b1b      	ldr	r3, [pc, #108]	@ (3401c46c <UTIL_LCD_SetLayer+0x80>)
3401c3fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c400:	4a1b      	ldr	r2, [pc, #108]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c402:	6912      	ldr	r2, [r2, #16]
3401c404:	6879      	ldr	r1, [r7, #4]
3401c406:	4610      	mov	r0, r2
3401c408:	4798      	blx	r3
3401c40a:	4603      	mov	r3, r0
3401c40c:	2b00      	cmp	r3, #0
3401c40e:	d128      	bne.n	3401c462 <UTIL_LCD_SetLayer+0x76>
    {
      DrawProp->LcdLayer = Layer;
3401c410:	4a17      	ldr	r2, [pc, #92]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c412:	687b      	ldr	r3, [r7, #4]
3401c414:	60d3      	str	r3, [r2, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
3401c416:	4b15      	ldr	r3, [pc, #84]	@ (3401c46c <UTIL_LCD_SetLayer+0x80>)
3401c418:	69db      	ldr	r3, [r3, #28]
3401c41a:	4a15      	ldr	r2, [pc, #84]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c41c:	6910      	ldr	r0, [r2, #16]
3401c41e:	4a14      	ldr	r2, [pc, #80]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c420:	68d2      	ldr	r2, [r2, #12]
3401c422:	0152      	lsls	r2, r2, #5
3401c424:	3210      	adds	r2, #16
3401c426:	4912      	ldr	r1, [pc, #72]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c428:	440a      	add	r2, r1
3401c42a:	3204      	adds	r2, #4
3401c42c:	4611      	mov	r1, r2
3401c42e:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
3401c430:	4b0e      	ldr	r3, [pc, #56]	@ (3401c46c <UTIL_LCD_SetLayer+0x80>)
3401c432:	6a1b      	ldr	r3, [r3, #32]
3401c434:	4a0e      	ldr	r2, [pc, #56]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c436:	6910      	ldr	r0, [r2, #16]
3401c438:	4a0d      	ldr	r2, [pc, #52]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c43a:	68d2      	ldr	r2, [r2, #12]
3401c43c:	0152      	lsls	r2, r2, #5
3401c43e:	3218      	adds	r2, #24
3401c440:	490b      	ldr	r1, [pc, #44]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c442:	440a      	add	r2, r1
3401c444:	4611      	mov	r1, r2
3401c446:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
3401c448:	4b08      	ldr	r3, [pc, #32]	@ (3401c46c <UTIL_LCD_SetLayer+0x80>)
3401c44a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401c44c:	4a08      	ldr	r2, [pc, #32]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c44e:	6910      	ldr	r0, [r2, #16]
3401c450:	4a07      	ldr	r2, [pc, #28]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c452:	68d2      	ldr	r2, [r2, #12]
3401c454:	0152      	lsls	r2, r2, #5
3401c456:	3218      	adds	r2, #24
3401c458:	4905      	ldr	r1, [pc, #20]	@ (3401c470 <UTIL_LCD_SetLayer+0x84>)
3401c45a:	440a      	add	r2, r1
3401c45c:	3204      	adds	r2, #4
3401c45e:	4611      	mov	r1, r2
3401c460:	4798      	blx	r3
    }
  }
}
3401c462:	bf00      	nop
3401c464:	3708      	adds	r7, #8
3401c466:	46bd      	mov	sp, r7
3401c468:	bd80      	pop	{r7, pc}
3401c46a:	bf00      	nop
3401c46c:	34053d7c 	.word	0x34053d7c
3401c470:	34053d3c 	.word	0x34053d3c

3401c474 <UTIL_LCD_SetTextColor>:
/**
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
3401c474:	b480      	push	{r7}
3401c476:	b083      	sub	sp, #12
3401c478:	af00      	add	r7, sp, #0
3401c47a:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
3401c47c:	4b06      	ldr	r3, [pc, #24]	@ (3401c498 <UTIL_LCD_SetTextColor+0x24>)
3401c47e:	68db      	ldr	r3, [r3, #12]
3401c480:	4a05      	ldr	r2, [pc, #20]	@ (3401c498 <UTIL_LCD_SetTextColor+0x24>)
3401c482:	015b      	lsls	r3, r3, #5
3401c484:	4413      	add	r3, r2
3401c486:	687a      	ldr	r2, [r7, #4]
3401c488:	601a      	str	r2, [r3, #0]
}
3401c48a:	bf00      	nop
3401c48c:	370c      	adds	r7, #12
3401c48e:	46bd      	mov	sp, r7
3401c490:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c494:	4770      	bx	lr
3401c496:	bf00      	nop
3401c498:	34053d3c 	.word	0x34053d3c

3401c49c <UTIL_LCD_SetFont>:
/**
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
3401c49c:	b480      	push	{r7}
3401c49e:	b083      	sub	sp, #12
3401c4a0:	af00      	add	r7, sp, #0
3401c4a2:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
3401c4a4:	4b06      	ldr	r3, [pc, #24]	@ (3401c4c0 <UTIL_LCD_SetFont+0x24>)
3401c4a6:	68db      	ldr	r3, [r3, #12]
3401c4a8:	4a05      	ldr	r2, [pc, #20]	@ (3401c4c0 <UTIL_LCD_SetFont+0x24>)
3401c4aa:	015b      	lsls	r3, r3, #5
3401c4ac:	4413      	add	r3, r2
3401c4ae:	3308      	adds	r3, #8
3401c4b0:	687a      	ldr	r2, [r7, #4]
3401c4b2:	601a      	str	r2, [r3, #0]
}
3401c4b4:	bf00      	nop
3401c4b6:	370c      	adds	r7, #12
3401c4b8:	46bd      	mov	sp, r7
3401c4ba:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c4be:	4770      	bx	lr
3401c4c0:	34053d3c 	.word	0x34053d3c

3401c4c4 <UTIL_LCD_Clear>:
/**
  * @brief  Clears the whole currently active layer of LTDC.
  * @param  Color  Color of the background
  */
void UTIL_LCD_Clear(uint32_t Color)
{
3401c4c4:	b580      	push	{r7, lr}
3401c4c6:	b084      	sub	sp, #16
3401c4c8:	af02      	add	r7, sp, #8
3401c4ca:	6078      	str	r0, [r7, #4]
  /* Clear the LCD */
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
3401c4cc:	4b0c      	ldr	r3, [pc, #48]	@ (3401c500 <UTIL_LCD_Clear+0x3c>)
3401c4ce:	68db      	ldr	r3, [r3, #12]
3401c4d0:	4a0b      	ldr	r2, [pc, #44]	@ (3401c500 <UTIL_LCD_Clear+0x3c>)
3401c4d2:	015b      	lsls	r3, r3, #5
3401c4d4:	4413      	add	r3, r2
3401c4d6:	3314      	adds	r3, #20
3401c4d8:	681a      	ldr	r2, [r3, #0]
3401c4da:	4b09      	ldr	r3, [pc, #36]	@ (3401c500 <UTIL_LCD_Clear+0x3c>)
3401c4dc:	68db      	ldr	r3, [r3, #12]
3401c4de:	4908      	ldr	r1, [pc, #32]	@ (3401c500 <UTIL_LCD_Clear+0x3c>)
3401c4e0:	015b      	lsls	r3, r3, #5
3401c4e2:	440b      	add	r3, r1
3401c4e4:	3318      	adds	r3, #24
3401c4e6:	6819      	ldr	r1, [r3, #0]
3401c4e8:	687b      	ldr	r3, [r7, #4]
3401c4ea:	9300      	str	r3, [sp, #0]
3401c4ec:	460b      	mov	r3, r1
3401c4ee:	2100      	movs	r1, #0
3401c4f0:	2000      	movs	r0, #0
3401c4f2:	f000 f807 	bl	3401c504 <UTIL_LCD_FillRect>
}
3401c4f6:	bf00      	nop
3401c4f8:	3708      	adds	r7, #8
3401c4fa:	46bd      	mov	sp, r7
3401c4fc:	bd80      	pop	{r7, pc}
3401c4fe:	bf00      	nop
3401c500:	34053d3c 	.word	0x34053d3c

3401c504 <UTIL_LCD_FillRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_FillRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
3401c504:	b590      	push	{r4, r7, lr}
3401c506:	b087      	sub	sp, #28
3401c508:	af02      	add	r7, sp, #8
3401c50a:	60f8      	str	r0, [r7, #12]
3401c50c:	60b9      	str	r1, [r7, #8]
3401c50e:	607a      	str	r2, [r7, #4]
3401c510:	603b      	str	r3, [r7, #0]
  /* Fill the rectangle */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401c512:	4b37      	ldr	r3, [pc, #220]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c514:	68db      	ldr	r3, [r3, #12]
3401c516:	4a36      	ldr	r2, [pc, #216]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c518:	015b      	lsls	r3, r3, #5
3401c51a:	4413      	add	r3, r2
3401c51c:	331c      	adds	r3, #28
3401c51e:	681b      	ldr	r3, [r3, #0]
3401c520:	2b02      	cmp	r3, #2
3401c522:	d11a      	bne.n	3401c55a <UTIL_LCD_FillRect+0x56>
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
3401c524:	4b33      	ldr	r3, [pc, #204]	@ (3401c5f4 <UTIL_LCD_FillRect+0xf0>)
3401c526:	691c      	ldr	r4, [r3, #16]
3401c528:	4b31      	ldr	r3, [pc, #196]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c52a:	6918      	ldr	r0, [r3, #16]
3401c52c:	6a3b      	ldr	r3, [r7, #32]
3401c52e:	08db      	lsrs	r3, r3, #3
3401c530:	f003 021f 	and.w	r2, r3, #31
3401c534:	6a3b      	ldr	r3, [r7, #32]
3401c536:	0a9b      	lsrs	r3, r3, #10
3401c538:	015b      	lsls	r3, r3, #5
3401c53a:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
3401c53e:	431a      	orrs	r2, r3
3401c540:	6a3b      	ldr	r3, [r7, #32]
3401c542:	0cdb      	lsrs	r3, r3, #19
3401c544:	02db      	lsls	r3, r3, #11
3401c546:	b29b      	uxth	r3, r3
3401c548:	4313      	orrs	r3, r2
3401c54a:	9301      	str	r3, [sp, #4]
3401c54c:	683b      	ldr	r3, [r7, #0]
3401c54e:	9300      	str	r3, [sp, #0]
3401c550:	687b      	ldr	r3, [r7, #4]
3401c552:	68ba      	ldr	r2, [r7, #8]
3401c554:	68f9      	ldr	r1, [r7, #12]
3401c556:	47a0      	blx	r4
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
  }
}
3401c558:	e046      	b.n	3401c5e8 <UTIL_LCD_FillRect+0xe4>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3401c55a:	4b25      	ldr	r3, [pc, #148]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c55c:	69db      	ldr	r3, [r3, #28]
3401c55e:	2b01      	cmp	r3, #1
3401c560:	d10e      	bne.n	3401c580 <UTIL_LCD_FillRect+0x7c>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
3401c562:	4b24      	ldr	r3, [pc, #144]	@ (3401c5f4 <UTIL_LCD_FillRect+0xf0>)
3401c564:	691c      	ldr	r4, [r3, #16]
3401c566:	4b22      	ldr	r3, [pc, #136]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c568:	6918      	ldr	r0, [r3, #16]
3401c56a:	6a3b      	ldr	r3, [r7, #32]
3401c56c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3401c570:	9301      	str	r3, [sp, #4]
3401c572:	683b      	ldr	r3, [r7, #0]
3401c574:	9300      	str	r3, [sp, #0]
3401c576:	687b      	ldr	r3, [r7, #4]
3401c578:	68ba      	ldr	r2, [r7, #8]
3401c57a:	68f9      	ldr	r1, [r7, #12]
3401c57c:	47a0      	blx	r4
}
3401c57e:	e033      	b.n	3401c5e8 <UTIL_LCD_FillRect+0xe4>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
3401c580:	4b1b      	ldr	r3, [pc, #108]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c582:	68db      	ldr	r3, [r3, #12]
3401c584:	4a1a      	ldr	r2, [pc, #104]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c586:	015b      	lsls	r3, r3, #5
3401c588:	4413      	add	r3, r2
3401c58a:	331c      	adds	r3, #28
3401c58c:	681b      	ldr	r3, [r3, #0]
3401c58e:	2b04      	cmp	r3, #4
3401c590:	d11e      	bne.n	3401c5d0 <UTIL_LCD_FillRect+0xcc>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
3401c592:	4b18      	ldr	r3, [pc, #96]	@ (3401c5f4 <UTIL_LCD_FillRect+0xf0>)
3401c594:	691c      	ldr	r4, [r3, #16]
3401c596:	4b16      	ldr	r3, [pc, #88]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c598:	6918      	ldr	r0, [r3, #16]
3401c59a:	6a3b      	ldr	r3, [r7, #32]
3401c59c:	091b      	lsrs	r3, r3, #4
3401c59e:	f003 020f 	and.w	r2, r3, #15
3401c5a2:	6a3b      	ldr	r3, [r7, #32]
3401c5a4:	0b1b      	lsrs	r3, r3, #12
3401c5a6:	011b      	lsls	r3, r3, #4
3401c5a8:	b2db      	uxtb	r3, r3
3401c5aa:	431a      	orrs	r2, r3
3401c5ac:	6a3b      	ldr	r3, [r7, #32]
3401c5ae:	0d1b      	lsrs	r3, r3, #20
3401c5b0:	021b      	lsls	r3, r3, #8
3401c5b2:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401c5b6:	431a      	orrs	r2, r3
3401c5b8:	6a3b      	ldr	r3, [r7, #32]
3401c5ba:	0f1b      	lsrs	r3, r3, #28
3401c5bc:	031b      	lsls	r3, r3, #12
3401c5be:	4313      	orrs	r3, r2
3401c5c0:	9301      	str	r3, [sp, #4]
3401c5c2:	683b      	ldr	r3, [r7, #0]
3401c5c4:	9300      	str	r3, [sp, #0]
3401c5c6:	687b      	ldr	r3, [r7, #4]
3401c5c8:	68ba      	ldr	r2, [r7, #8]
3401c5ca:	68f9      	ldr	r1, [r7, #12]
3401c5cc:	47a0      	blx	r4
}
3401c5ce:	e00b      	b.n	3401c5e8 <UTIL_LCD_FillRect+0xe4>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
3401c5d0:	4b08      	ldr	r3, [pc, #32]	@ (3401c5f4 <UTIL_LCD_FillRect+0xf0>)
3401c5d2:	691c      	ldr	r4, [r3, #16]
3401c5d4:	4b06      	ldr	r3, [pc, #24]	@ (3401c5f0 <UTIL_LCD_FillRect+0xec>)
3401c5d6:	6918      	ldr	r0, [r3, #16]
3401c5d8:	6a3b      	ldr	r3, [r7, #32]
3401c5da:	9301      	str	r3, [sp, #4]
3401c5dc:	683b      	ldr	r3, [r7, #0]
3401c5de:	9300      	str	r3, [sp, #0]
3401c5e0:	687b      	ldr	r3, [r7, #4]
3401c5e2:	68ba      	ldr	r2, [r7, #8]
3401c5e4:	68f9      	ldr	r1, [r7, #12]
3401c5e6:	47a0      	blx	r4
}
3401c5e8:	bf00      	nop
3401c5ea:	3714      	adds	r7, #20
3401c5ec:	46bd      	mov	sp, r7
3401c5ee:	bd90      	pop	{r4, r7, pc}
3401c5f0:	34053d3c 	.word	0x34053d3c
3401c5f4:	34053d7c 	.word	0x34053d7c

3401c5f8 <yolov2_nms_comparator>:
/* Can't be removed if qsort is not re-written... */
static int32_t AI_YOLOV2_PP_SORT_CLASS;


int32_t yolov2_nms_comparator(const void *pa, const void *pb)
{
3401c5f8:	b480      	push	{r7}
3401c5fa:	b087      	sub	sp, #28
3401c5fc:	af00      	add	r7, sp, #0
3401c5fe:	6078      	str	r0, [r7, #4]
3401c600:	6039      	str	r1, [r7, #0]
    float32_t a = *((float32_t *)pa + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
3401c602:	4b1a      	ldr	r3, [pc, #104]	@ (3401c66c <yolov2_nms_comparator+0x74>)
3401c604:	681b      	ldr	r3, [r3, #0]
3401c606:	3305      	adds	r3, #5
3401c608:	009b      	lsls	r3, r3, #2
3401c60a:	687a      	ldr	r2, [r7, #4]
3401c60c:	4413      	add	r3, r2
3401c60e:	681b      	ldr	r3, [r3, #0]
3401c610:	617b      	str	r3, [r7, #20]
    float32_t b = *((float32_t *)pb + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
3401c612:	4b16      	ldr	r3, [pc, #88]	@ (3401c66c <yolov2_nms_comparator+0x74>)
3401c614:	681b      	ldr	r3, [r3, #0]
3401c616:	3305      	adds	r3, #5
3401c618:	009b      	lsls	r3, r3, #2
3401c61a:	683a      	ldr	r2, [r7, #0]
3401c61c:	4413      	add	r3, r2
3401c61e:	681b      	ldr	r3, [r3, #0]
3401c620:	613b      	str	r3, [r7, #16]
    float32_t diff = 0;
3401c622:	f04f 0300 	mov.w	r3, #0
3401c626:	60fb      	str	r3, [r7, #12]

    diff = a - b;
3401c628:	ed97 7a05 	vldr	s14, [r7, #20]
3401c62c:	edd7 7a04 	vldr	s15, [r7, #16]
3401c630:	ee77 7a67 	vsub.f32	s15, s14, s15
3401c634:	edc7 7a03 	vstr	s15, [r7, #12]

    if (diff < 0) return 1;
3401c638:	edd7 7a03 	vldr	s15, [r7, #12]
3401c63c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401c640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c644:	d501      	bpl.n	3401c64a <yolov2_nms_comparator+0x52>
3401c646:	2301      	movs	r3, #1
3401c648:	e00a      	b.n	3401c660 <yolov2_nms_comparator+0x68>
    else if (diff > 0) return -1;
3401c64a:	edd7 7a03 	vldr	s15, [r7, #12]
3401c64e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401c652:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c656:	dd02      	ble.n	3401c65e <yolov2_nms_comparator+0x66>
3401c658:	f04f 33ff 	mov.w	r3, #4294967295
3401c65c:	e000      	b.n	3401c660 <yolov2_nms_comparator+0x68>
    return 0;
3401c65e:	2300      	movs	r3, #0
}
3401c660:	4618      	mov	r0, r3
3401c662:	371c      	adds	r7, #28
3401c664:	46bd      	mov	sp, r7
3401c666:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c66a:	4770      	bx	lr
3401c66c:	34053da8 	.word	0x34053da8

3401c670 <yolov2_pp_nmsFiltering_centroid>:


int32_t yolov2_pp_nmsFiltering_centroid(yolov2_pp_in_t  *pInput,
                                        yolov2_pp_static_param_t *pInput_static_param)
{
3401c670:	b580      	push	{r7, lr}
3401c672:	b08c      	sub	sp, #48	@ 0x30
3401c674:	af00      	add	r7, sp, #0
3401c676:	6078      	str	r0, [r7, #4]
3401c678:	6039      	str	r1, [r7, #0]
    int32_t i, j, k, limit_counter;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401c67a:	683b      	ldr	r3, [r7, #0]
3401c67c:	681b      	ldr	r3, [r3, #0]
3401c67e:	3305      	adds	r3, #5
3401c680:	61bb      	str	r3, [r7, #24]
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
3401c682:	687b      	ldr	r3, [r7, #4]
3401c684:	681b      	ldr	r3, [r3, #0]
3401c686:	617b      	str	r3, [r7, #20]

    for (k = 0; k < pInput_static_param->nb_classes; ++k)
3401c688:	2300      	movs	r3, #0
3401c68a:	627b      	str	r3, [r7, #36]	@ 0x24
3401c68c:	e092      	b.n	3401c7b4 <yolov2_pp_nmsFiltering_centroid+0x144>
    {
        limit_counter = 0;
3401c68e:	2300      	movs	r3, #0
3401c690:	623b      	str	r3, [r7, #32]
        AI_YOLOV2_PP_SORT_CLASS = k;
3401c692:	4a4e      	ldr	r2, [pc, #312]	@ (3401c7cc <yolov2_pp_nmsFiltering_centroid+0x15c>)
3401c694:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c696:	6013      	str	r3, [r2, #0]

        qsort(pInbuff,
              pInput_static_param->nb_detect,
3401c698:	683b      	ldr	r3, [r7, #0]
3401c69a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
        qsort(pInbuff,
3401c69c:	4619      	mov	r1, r3
3401c69e:	69bb      	ldr	r3, [r7, #24]
              anch_stride * sizeof(float32_t),
3401c6a0:	009a      	lsls	r2, r3, #2
        qsort(pInbuff,
3401c6a2:	4b4b      	ldr	r3, [pc, #300]	@ (3401c7d0 <yolov2_pp_nmsFiltering_centroid+0x160>)
3401c6a4:	6978      	ldr	r0, [r7, #20]
3401c6a6:	f003 fefe 	bl	340204a6 <qsort>
              (_Cmpfun *)yolov2_nms_comparator);
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
3401c6aa:	2300      	movs	r3, #0
3401c6ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
3401c6ae:	e046      	b.n	3401c73e <yolov2_pp_nmsFiltering_centroid+0xce>
        {
            if (pInbuff[i + AI_YOLOV2_PP_CLASSPROB + k] == 0) continue;
3401c6b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401c6b2:	1d5a      	adds	r2, r3, #5
3401c6b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c6b6:	4413      	add	r3, r2
3401c6b8:	009b      	lsls	r3, r3, #2
3401c6ba:	697a      	ldr	r2, [r7, #20]
3401c6bc:	4413      	add	r3, r2
3401c6be:	edd3 7a00 	vldr	s15, [r3]
3401c6c2:	eef5 7a40 	vcmp.f32	s15, #0.0
3401c6c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c6ca:	d033      	beq.n	3401c734 <yolov2_pp_nmsFiltering_centroid+0xc4>
            float32_t *a = &(pInbuff[i + AI_YOLOV2_PP_XCENTER]);
3401c6cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401c6ce:	009b      	lsls	r3, r3, #2
3401c6d0:	697a      	ldr	r2, [r7, #20]
3401c6d2:	4413      	add	r3, r2
3401c6d4:	613b      	str	r3, [r7, #16]
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
3401c6d6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3401c6d8:	69bb      	ldr	r3, [r7, #24]
3401c6da:	4413      	add	r3, r2
3401c6dc:	62bb      	str	r3, [r7, #40]	@ 0x28
3401c6de:	e020      	b.n	3401c722 <yolov2_pp_nmsFiltering_centroid+0xb2>
            {
                float32_t *b = &(pInbuff[j + AI_YOLOV2_PP_XCENTER]);
3401c6e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c6e2:	009b      	lsls	r3, r3, #2
3401c6e4:	697a      	ldr	r2, [r7, #20]
3401c6e6:	4413      	add	r3, r2
3401c6e8:	60fb      	str	r3, [r7, #12]
                if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
3401c6ea:	68f9      	ldr	r1, [r7, #12]
3401c6ec:	6938      	ldr	r0, [r7, #16]
3401c6ee:	f000 fe09 	bl	3401d304 <vision_models_box_iou>
3401c6f2:	eeb0 7a40 	vmov.f32	s14, s0
3401c6f6:	683b      	ldr	r3, [r7, #0]
3401c6f8:	edd3 7a07 	vldr	s15, [r3, #28]
3401c6fc:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401c700:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c704:	dd09      	ble.n	3401c71a <yolov2_pp_nmsFiltering_centroid+0xaa>
                {
                    pInbuff[j + AI_YOLOV2_PP_CLASSPROB + k] = 0;
3401c706:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c708:	1d5a      	adds	r2, r3, #5
3401c70a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c70c:	4413      	add	r3, r2
3401c70e:	009b      	lsls	r3, r3, #2
3401c710:	697a      	ldr	r2, [r7, #20]
3401c712:	4413      	add	r3, r2
3401c714:	f04f 0200 	mov.w	r2, #0
3401c718:	601a      	str	r2, [r3, #0]
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
3401c71a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3401c71c:	69bb      	ldr	r3, [r7, #24]
3401c71e:	4413      	add	r3, r2
3401c720:	62bb      	str	r3, [r7, #40]	@ 0x28
3401c722:	683b      	ldr	r3, [r7, #0]
3401c724:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c726:	69ba      	ldr	r2, [r7, #24]
3401c728:	fb02 f303 	mul.w	r3, r2, r3
3401c72c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3401c72e:	429a      	cmp	r2, r3
3401c730:	dbd6      	blt.n	3401c6e0 <yolov2_pp_nmsFiltering_centroid+0x70>
3401c732:	e000      	b.n	3401c736 <yolov2_pp_nmsFiltering_centroid+0xc6>
            if (pInbuff[i + AI_YOLOV2_PP_CLASSPROB + k] == 0) continue;
3401c734:	bf00      	nop
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
3401c736:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3401c738:	69bb      	ldr	r3, [r7, #24]
3401c73a:	4413      	add	r3, r2
3401c73c:	62fb      	str	r3, [r7, #44]	@ 0x2c
3401c73e:	683b      	ldr	r3, [r7, #0]
3401c740:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c742:	69ba      	ldr	r2, [r7, #24]
3401c744:	fb02 f303 	mul.w	r3, r2, r3
3401c748:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3401c74a:	429a      	cmp	r2, r3
3401c74c:	dbb0      	blt.n	3401c6b0 <yolov2_pp_nmsFiltering_centroid+0x40>
                }
            }
        }
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
3401c74e:	2300      	movs	r3, #0
3401c750:	61fb      	str	r3, [r7, #28]
3401c752:	e024      	b.n	3401c79e <yolov2_pp_nmsFiltering_centroid+0x12e>
        {
            if ((limit_counter < pInput_static_param->max_boxes_limit) &&
3401c754:	683b      	ldr	r3, [r7, #0]
3401c756:	695b      	ldr	r3, [r3, #20]
3401c758:	6a3a      	ldr	r2, [r7, #32]
3401c75a:	429a      	cmp	r2, r3
3401c75c:	da11      	bge.n	3401c782 <yolov2_pp_nmsFiltering_centroid+0x112>
                (pInbuff[y + AI_YOLOV2_PP_CLASSPROB + k] != 0))
3401c75e:	69fb      	ldr	r3, [r7, #28]
3401c760:	1d5a      	adds	r2, r3, #5
3401c762:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c764:	4413      	add	r3, r2
3401c766:	009b      	lsls	r3, r3, #2
3401c768:	697a      	ldr	r2, [r7, #20]
3401c76a:	4413      	add	r3, r2
3401c76c:	edd3 7a00 	vldr	s15, [r3]
            if ((limit_counter < pInput_static_param->max_boxes_limit) &&
3401c770:	eef5 7a40 	vcmp.f32	s15, #0.0
3401c774:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c778:	d003      	beq.n	3401c782 <yolov2_pp_nmsFiltering_centroid+0x112>
            {
                limit_counter++;
3401c77a:	6a3b      	ldr	r3, [r7, #32]
3401c77c:	3301      	adds	r3, #1
3401c77e:	623b      	str	r3, [r7, #32]
3401c780:	e009      	b.n	3401c796 <yolov2_pp_nmsFiltering_centroid+0x126>
            }
            else
            {
                pInbuff[y + AI_YOLOV2_PP_CLASSPROB + k] = 0;
3401c782:	69fb      	ldr	r3, [r7, #28]
3401c784:	1d5a      	adds	r2, r3, #5
3401c786:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c788:	4413      	add	r3, r2
3401c78a:	009b      	lsls	r3, r3, #2
3401c78c:	697a      	ldr	r2, [r7, #20]
3401c78e:	4413      	add	r3, r2
3401c790:	f04f 0200 	mov.w	r2, #0
3401c794:	601a      	str	r2, [r3, #0]
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
3401c796:	69fa      	ldr	r2, [r7, #28]
3401c798:	69bb      	ldr	r3, [r7, #24]
3401c79a:	4413      	add	r3, r2
3401c79c:	61fb      	str	r3, [r7, #28]
3401c79e:	683b      	ldr	r3, [r7, #0]
3401c7a0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c7a2:	69ba      	ldr	r2, [r7, #24]
3401c7a4:	fb02 f303 	mul.w	r3, r2, r3
3401c7a8:	69fa      	ldr	r2, [r7, #28]
3401c7aa:	429a      	cmp	r2, r3
3401c7ac:	ddd2      	ble.n	3401c754 <yolov2_pp_nmsFiltering_centroid+0xe4>
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
3401c7ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c7b0:	3301      	adds	r3, #1
3401c7b2:	627b      	str	r3, [r7, #36]	@ 0x24
3401c7b4:	683b      	ldr	r3, [r7, #0]
3401c7b6:	681b      	ldr	r3, [r3, #0]
3401c7b8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c7ba:	429a      	cmp	r2, r3
3401c7bc:	f6ff af67 	blt.w	3401c68e <yolov2_pp_nmsFiltering_centroid+0x1e>
            }
        }
    }

    return (AI_OD_POSTPROCESS_ERROR_NO);
3401c7c0:	2300      	movs	r3, #0
}
3401c7c2:	4618      	mov	r0, r3
3401c7c4:	3730      	adds	r7, #48	@ 0x30
3401c7c6:	46bd      	mov	sp, r7
3401c7c8:	bd80      	pop	{r7, pc}
3401c7ca:	bf00      	nop
3401c7cc:	34053da8 	.word	0x34053da8
3401c7d0:	3401c5f9 	.word	0x3401c5f9

3401c7d4 <yolov2_pp_scoreFiltering_centroid>:


int32_t yolov2_pp_scoreFiltering_centroid(yolov2_pp_in_t *pInput,
                                          od_pp_out_t *pOutput,
                                          yolov2_pp_static_param_t *pInput_static_param)
{
3401c7d4:	b580      	push	{r7, lr}
3401c7d6:	b08a      	sub	sp, #40	@ 0x28
3401c7d8:	af00      	add	r7, sp, #0
3401c7da:	60f8      	str	r0, [r7, #12]
3401c7dc:	60b9      	str	r1, [r7, #8]
3401c7de:	607a      	str	r2, [r7, #4]
    float32_t best_score;
    uint32_t class_index;
    int32_t det_count = 0;
3401c7e0:	2300      	movs	r3, #0
3401c7e2:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401c7e4:	687b      	ldr	r3, [r7, #4]
3401c7e6:	681b      	ldr	r3, [r3, #0]
3401c7e8:	3305      	adds	r3, #5
3401c7ea:	61fb      	str	r3, [r7, #28]

    if (pOutput->pOutBuff == NULL)
3401c7ec:	68bb      	ldr	r3, [r7, #8]
3401c7ee:	681b      	ldr	r3, [r3, #0]
3401c7f0:	2b00      	cmp	r3, #0
3401c7f2:	d103      	bne.n	3401c7fc <yolov2_pp_scoreFiltering_centroid+0x28>
    {
      pOutput->pOutBuff = (od_pp_outBuffer_t *)pInput->pRaw_detections;
3401c7f4:	68fb      	ldr	r3, [r7, #12]
3401c7f6:	681a      	ldr	r2, [r3, #0]
3401c7f8:	68bb      	ldr	r3, [r7, #8]
3401c7fa:	601a      	str	r2, [r3, #0]
    }
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
3401c7fc:	68fb      	ldr	r3, [r7, #12]
3401c7fe:	681b      	ldr	r3, [r3, #0]
3401c800:	61bb      	str	r3, [r7, #24]

    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
3401c802:	2300      	movs	r3, #0
3401c804:	623b      	str	r3, [r7, #32]
3401c806:	e06e      	b.n	3401c8e6 <yolov2_pp_scoreFiltering_centroid+0x112>
    {
        vision_models_maxi_if32ou32(&pInbuff[i + AI_YOLOV2_PP_CLASSPROB],
3401c808:	6a3b      	ldr	r3, [r7, #32]
3401c80a:	3305      	adds	r3, #5
3401c80c:	009b      	lsls	r3, r3, #2
3401c80e:	69ba      	ldr	r2, [r7, #24]
3401c810:	18d0      	adds	r0, r2, r3
             pInput_static_param->nb_classes,
3401c812:	687b      	ldr	r3, [r7, #4]
3401c814:	681b      	ldr	r3, [r3, #0]
        vision_models_maxi_if32ou32(&pInbuff[i + AI_YOLOV2_PP_CLASSPROB],
3401c816:	4619      	mov	r1, r3
3401c818:	f107 0310 	add.w	r3, r7, #16
3401c81c:	f107 0214 	add.w	r2, r7, #20
3401c820:	f000 fa39 	bl	3401cc96 <vision_models_maxi_if32ou32>
             &best_score,
             &class_index);

        if (best_score >= pInput_static_param->conf_threshold)
3401c824:	687b      	ldr	r3, [r7, #4]
3401c826:	ed93 7a06 	vldr	s14, [r3, #24]
3401c82a:	edd7 7a05 	vldr	s15, [r7, #20]
3401c82e:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401c832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c836:	d852      	bhi.n	3401c8de <yolov2_pp_scoreFiltering_centroid+0x10a>
        {
            pOutput->pOutBuff[det_count].x_center = pInbuff[i + AI_YOLOV2_PP_XCENTER];
3401c838:	6a3b      	ldr	r3, [r7, #32]
3401c83a:	009b      	lsls	r3, r3, #2
3401c83c:	69ba      	ldr	r2, [r7, #24]
3401c83e:	18d1      	adds	r1, r2, r3
3401c840:	68bb      	ldr	r3, [r7, #8]
3401c842:	6818      	ldr	r0, [r3, #0]
3401c844:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c846:	4613      	mov	r3, r2
3401c848:	005b      	lsls	r3, r3, #1
3401c84a:	4413      	add	r3, r2
3401c84c:	00db      	lsls	r3, r3, #3
3401c84e:	4403      	add	r3, r0
3401c850:	680a      	ldr	r2, [r1, #0]
3401c852:	601a      	str	r2, [r3, #0]
            pOutput->pOutBuff[det_count].y_center = pInbuff[i + AI_YOLOV2_PP_YCENTER];
3401c854:	6a3b      	ldr	r3, [r7, #32]
3401c856:	3301      	adds	r3, #1
3401c858:	009b      	lsls	r3, r3, #2
3401c85a:	69ba      	ldr	r2, [r7, #24]
3401c85c:	18d1      	adds	r1, r2, r3
3401c85e:	68bb      	ldr	r3, [r7, #8]
3401c860:	6818      	ldr	r0, [r3, #0]
3401c862:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c864:	4613      	mov	r3, r2
3401c866:	005b      	lsls	r3, r3, #1
3401c868:	4413      	add	r3, r2
3401c86a:	00db      	lsls	r3, r3, #3
3401c86c:	4403      	add	r3, r0
3401c86e:	680a      	ldr	r2, [r1, #0]
3401c870:	605a      	str	r2, [r3, #4]
            pOutput->pOutBuff[det_count].width = pInbuff[i + AI_YOLOV2_PP_WIDTHREL];
3401c872:	6a3b      	ldr	r3, [r7, #32]
3401c874:	3302      	adds	r3, #2
3401c876:	009b      	lsls	r3, r3, #2
3401c878:	69ba      	ldr	r2, [r7, #24]
3401c87a:	18d1      	adds	r1, r2, r3
3401c87c:	68bb      	ldr	r3, [r7, #8]
3401c87e:	6818      	ldr	r0, [r3, #0]
3401c880:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c882:	4613      	mov	r3, r2
3401c884:	005b      	lsls	r3, r3, #1
3401c886:	4413      	add	r3, r2
3401c888:	00db      	lsls	r3, r3, #3
3401c88a:	4403      	add	r3, r0
3401c88c:	680a      	ldr	r2, [r1, #0]
3401c88e:	609a      	str	r2, [r3, #8]
            pOutput->pOutBuff[det_count].height = pInbuff[i + AI_YOLOV2_PP_HEIGHTREL];
3401c890:	6a3b      	ldr	r3, [r7, #32]
3401c892:	3303      	adds	r3, #3
3401c894:	009b      	lsls	r3, r3, #2
3401c896:	69ba      	ldr	r2, [r7, #24]
3401c898:	18d1      	adds	r1, r2, r3
3401c89a:	68bb      	ldr	r3, [r7, #8]
3401c89c:	6818      	ldr	r0, [r3, #0]
3401c89e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c8a0:	4613      	mov	r3, r2
3401c8a2:	005b      	lsls	r3, r3, #1
3401c8a4:	4413      	add	r3, r2
3401c8a6:	00db      	lsls	r3, r3, #3
3401c8a8:	4403      	add	r3, r0
3401c8aa:	680a      	ldr	r2, [r1, #0]
3401c8ac:	60da      	str	r2, [r3, #12]
            pOutput->pOutBuff[det_count].class_index = class_index;
3401c8ae:	6938      	ldr	r0, [r7, #16]
3401c8b0:	68bb      	ldr	r3, [r7, #8]
3401c8b2:	6819      	ldr	r1, [r3, #0]
3401c8b4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c8b6:	4613      	mov	r3, r2
3401c8b8:	005b      	lsls	r3, r3, #1
3401c8ba:	4413      	add	r3, r2
3401c8bc:	00db      	lsls	r3, r3, #3
3401c8be:	440b      	add	r3, r1
3401c8c0:	4602      	mov	r2, r0
3401c8c2:	615a      	str	r2, [r3, #20]
            pOutput->pOutBuff[det_count].conf = best_score;
3401c8c4:	68bb      	ldr	r3, [r7, #8]
3401c8c6:	6819      	ldr	r1, [r3, #0]
3401c8c8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c8ca:	4613      	mov	r3, r2
3401c8cc:	005b      	lsls	r3, r3, #1
3401c8ce:	4413      	add	r3, r2
3401c8d0:	00db      	lsls	r3, r3, #3
3401c8d2:	440b      	add	r3, r1
3401c8d4:	697a      	ldr	r2, [r7, #20]
3401c8d6:	611a      	str	r2, [r3, #16]
            det_count++;
3401c8d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401c8da:	3301      	adds	r3, #1
3401c8dc:	627b      	str	r3, [r7, #36]	@ 0x24
    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
3401c8de:	6a3a      	ldr	r2, [r7, #32]
3401c8e0:	69fb      	ldr	r3, [r7, #28]
3401c8e2:	4413      	add	r3, r2
3401c8e4:	623b      	str	r3, [r7, #32]
3401c8e6:	687b      	ldr	r3, [r7, #4]
3401c8e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401c8ea:	69fa      	ldr	r2, [r7, #28]
3401c8ec:	fb02 f303 	mul.w	r3, r2, r3
3401c8f0:	6a3a      	ldr	r2, [r7, #32]
3401c8f2:	429a      	cmp	r2, r3
3401c8f4:	db88      	blt.n	3401c808 <yolov2_pp_scoreFiltering_centroid+0x34>
        }
    }
    pOutput->nb_detect = det_count;
3401c8f6:	68bb      	ldr	r3, [r7, #8]
3401c8f8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c8fa:	605a      	str	r2, [r3, #4]

    return (AI_OD_POSTPROCESS_ERROR_NO);
3401c8fc:	2300      	movs	r3, #0
}
3401c8fe:	4618      	mov	r0, r3
3401c900:	3728      	adds	r7, #40	@ 0x28
3401c902:	46bd      	mov	sp, r7
3401c904:	bd80      	pop	{r7, pc}

3401c906 <yolov2_pp_getNNBoxes_centroid>:


int32_t yolov2_pp_getNNBoxes_centroid(yolov2_pp_in_t *pInput,
                                      yolov2_pp_static_param_t *pInput_static_param)
{
3401c906:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3401c90a:	ed2d 8b02 	vpush	{d8}
3401c90e:	b096      	sub	sp, #88	@ 0x58
3401c910:	af00      	add	r7, sp, #0
3401c912:	6078      	str	r0, [r7, #4]
3401c914:	6039      	str	r1, [r7, #0]
3401c916:	466b      	mov	r3, sp
3401c918:	461d      	mov	r5, r3
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;
3401c91a:	2300      	movs	r3, #0
3401c91c:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t count = 0;
3401c91e:	2300      	movs	r3, #0
3401c920:	657b      	str	r3, [r7, #84]	@ 0x54
    int32_t count_detect = 0;
3401c922:	2300      	movs	r3, #0
3401c924:	653b      	str	r3, [r7, #80]	@ 0x50
    float32_t best_score=0;
3401c926:	f04f 0300 	mov.w	r3, #0
3401c92a:	613b      	str	r3, [r7, #16]
    uint32_t class_index;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401c92c:	683b      	ldr	r3, [r7, #0]
3401c92e:	681b      	ldr	r3, [r3, #0]
3401c930:	3305      	adds	r3, #5
3401c932:	633b      	str	r3, [r7, #48]	@ 0x30

    yolov2_pp_in_t *pOutput = pInput;
3401c934:	687b      	ldr	r3, [r7, #4]
3401c936:	62fb      	str	r3, [r7, #44]	@ 0x2c
    float32_t grid_width_inv = 1.0f / pInput_static_param->grid_width;
3401c938:	683b      	ldr	r3, [r7, #0]
3401c93a:	689b      	ldr	r3, [r3, #8]
3401c93c:	ee07 3a90 	vmov	s15, r3
3401c940:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3401c944:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
3401c948:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c94c:	edc7 7a0a 	vstr	s15, [r7, #40]	@ 0x28
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
3401c950:	683b      	ldr	r3, [r7, #0]
3401c952:	68db      	ldr	r3, [r3, #12]
3401c954:	ee07 3a90 	vmov	s15, r3
3401c958:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3401c95c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
3401c960:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c964:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
    float32_t tmp_a[pInput_static_param->nb_classes];
3401c968:	683b      	ldr	r3, [r7, #0]
3401c96a:	681b      	ldr	r3, [r3, #0]
3401c96c:	1e5a      	subs	r2, r3, #1
3401c96e:	623a      	str	r2, [r7, #32]
3401c970:	4619      	mov	r1, r3
3401c972:	2200      	movs	r2, #0
3401c974:	468a      	mov	sl, r1
3401c976:	4693      	mov	fp, r2
3401c978:	4619      	mov	r1, r3
3401c97a:	2200      	movs	r2, #0
3401c97c:	4688      	mov	r8, r1
3401c97e:	4691      	mov	r9, r2
3401c980:	009b      	lsls	r3, r3, #2
3401c982:	3307      	adds	r3, #7
3401c984:	08db      	lsrs	r3, r3, #3
3401c986:	00db      	lsls	r3, r3, #3
3401c988:	ebad 0d03 	sub.w	sp, sp, r3
3401c98c:	466b      	mov	r3, sp
3401c98e:	3303      	adds	r3, #3
3401c990:	089b      	lsrs	r3, r3, #2
3401c992:	009b      	lsls	r3, r3, #2
3401c994:	61fb      	str	r3, [r7, #28]
    int32_t el_offset = 0;
3401c996:	2300      	movs	r3, #0
3401c998:	64fb      	str	r3, [r7, #76]	@ 0x4c
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
3401c99a:	687b      	ldr	r3, [r7, #4]
3401c99c:	681b      	ldr	r3, [r3, #0]
3401c99e:	61bb      	str	r3, [r7, #24]
    float32_t *pOutbuff = (float32_t *)pOutput->pRaw_detections;
3401c9a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3401c9a2:	681b      	ldr	r3, [r3, #0]
3401c9a4:	617b      	str	r3, [r7, #20]
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
3401c9a6:	2300      	movs	r3, #0
3401c9a8:	64bb      	str	r3, [r7, #72]	@ 0x48
3401c9aa:	e12d      	b.n	3401cc08 <yolov2_pp_getNNBoxes_centroid+0x302>
    {
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
3401c9ac:	2300      	movs	r3, #0
3401c9ae:	647b      	str	r3, [r7, #68]	@ 0x44
3401c9b0:	e121      	b.n	3401cbf6 <yolov2_pp_getNNBoxes_centroid+0x2f0>
        {
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
3401c9b2:	2300      	movs	r3, #0
3401c9b4:	643b      	str	r3, [r7, #64]	@ 0x40
3401c9b6:	e115      	b.n	3401cbe4 <yolov2_pp_getNNBoxes_centroid+0x2de>
            {
                /* read and activate objectness */
                pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] = vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS]);
3401c9b8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401c9ba:	3304      	adds	r3, #4
3401c9bc:	009b      	lsls	r3, r3, #2
3401c9be:	69ba      	ldr	r2, [r7, #24]
3401c9c0:	4413      	add	r3, r2
3401c9c2:	edd3 7a00 	vldr	s15, [r3]
3401c9c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401c9c8:	3304      	adds	r3, #4
3401c9ca:	009b      	lsls	r3, r3, #2
3401c9cc:	697a      	ldr	r2, [r7, #20]
3401c9ce:	18d4      	adds	r4, r2, r3
3401c9d0:	eeb0 0a67 	vmov.f32	s0, s15
3401c9d4:	f000 fb2b 	bl	3401d02e <vision_models_sigmoid_f>
3401c9d8:	eef0 7a40 	vmov.f32	s15, s0
3401c9dc:	edc4 7a00 	vstr	s15, [r4]

                /* activate array of classes pred */
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401c9e0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401c9e2:	3305      	adds	r3, #5
3401c9e4:	009b      	lsls	r3, r3, #2
3401c9e6:	69ba      	ldr	r2, [r7, #24]
3401c9e8:	18d0      	adds	r0, r2, r3
                        &pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401c9ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401c9ec:	3305      	adds	r3, #5
3401c9ee:	009b      	lsls	r3, r3, #2
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401c9f0:	697a      	ldr	r2, [r7, #20]
3401c9f2:	18d1      	adds	r1, r2, r3
3401c9f4:	683b      	ldr	r3, [r7, #0]
3401c9f6:	681a      	ldr	r2, [r3, #0]
3401c9f8:	69fb      	ldr	r3, [r7, #28]
3401c9fa:	f000 fb36 	bl	3401d06a <vision_models_softmax_f>
                        pInput_static_param->nb_classes,
                        tmp_a);
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
3401c9fe:	2300      	movs	r3, #0
3401ca00:	63fb      	str	r3, [r7, #60]	@ 0x3c
3401ca02:	e01d      	b.n	3401ca40 <yolov2_pp_getNNBoxes_centroid+0x13a>
                {
                    pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] *
3401ca04:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ca06:	3304      	adds	r3, #4
3401ca08:	009b      	lsls	r3, r3, #2
3401ca0a:	697a      	ldr	r2, [r7, #20]
3401ca0c:	4413      	add	r3, r2
3401ca0e:	ed93 7a00 	vldr	s14, [r3]
                                                                       pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
3401ca12:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ca14:	1d5a      	adds	r2, r3, #5
3401ca16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401ca18:	4413      	add	r3, r2
3401ca1a:	009b      	lsls	r3, r3, #2
3401ca1c:	697a      	ldr	r2, [r7, #20]
3401ca1e:	4413      	add	r3, r2
3401ca20:	edd3 7a00 	vldr	s15, [r3]
                    pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] *
3401ca24:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ca26:	1d5a      	adds	r2, r3, #5
3401ca28:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401ca2a:	4413      	add	r3, r2
3401ca2c:	009b      	lsls	r3, r3, #2
3401ca2e:	697a      	ldr	r2, [r7, #20]
3401ca30:	4413      	add	r3, r2
3401ca32:	ee67 7a27 	vmul.f32	s15, s14, s15
3401ca36:	edc3 7a00 	vstr	s15, [r3]
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
3401ca3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401ca3c:	3301      	adds	r3, #1
3401ca3e:	63fb      	str	r3, [r7, #60]	@ 0x3c
3401ca40:	683b      	ldr	r3, [r7, #0]
3401ca42:	681b      	ldr	r3, [r3, #0]
3401ca44:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3401ca46:	429a      	cmp	r2, r3
3401ca48:	dbdc      	blt.n	3401ca04 <yolov2_pp_getNNBoxes_centroid+0xfe>
                }

                vision_models_maxi_if32ou32(&pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401ca4a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ca4c:	3305      	adds	r3, #5
3401ca4e:	009b      	lsls	r3, r3, #2
3401ca50:	697a      	ldr	r2, [r7, #20]
3401ca52:	18d0      	adds	r0, r2, r3
                     pInput_static_param->nb_classes,
3401ca54:	683b      	ldr	r3, [r7, #0]
3401ca56:	681b      	ldr	r3, [r3, #0]
                vision_models_maxi_if32ou32(&pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401ca58:	4619      	mov	r1, r3
3401ca5a:	f107 030c 	add.w	r3, r7, #12
3401ca5e:	f107 0210 	add.w	r2, r7, #16
3401ca62:	f000 f918 	bl	3401cc96 <vision_models_maxi_if32ou32>
                     &best_score,
                     &class_index);

                if (best_score >= pInput_static_param->conf_threshold)
3401ca66:	683b      	ldr	r3, [r7, #0]
3401ca68:	ed93 7a06 	vldr	s14, [r3, #24]
3401ca6c:	edd7 7a04 	vldr	s15, [r7, #16]
3401ca70:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401ca74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ca78:	f200 80ad 	bhi.w	3401cbd6 <yolov2_pp_getNNBoxes_centroid+0x2d0>
                {
                    pOutbuff[count + AI_YOLOV2_PP_OBJECTNESS] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS];
3401ca7c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ca7e:	3304      	adds	r3, #4
3401ca80:	009b      	lsls	r3, r3, #2
3401ca82:	697a      	ldr	r2, [r7, #20]
3401ca84:	441a      	add	r2, r3
3401ca86:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401ca88:	3304      	adds	r3, #4
3401ca8a:	009b      	lsls	r3, r3, #2
3401ca8c:	6979      	ldr	r1, [r7, #20]
3401ca8e:	440b      	add	r3, r1
3401ca90:	6812      	ldr	r2, [r2, #0]
3401ca92:	601a      	str	r2, [r3, #0]
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
3401ca94:	2300      	movs	r3, #0
3401ca96:	63bb      	str	r3, [r7, #56]	@ 0x38
3401ca98:	e012      	b.n	3401cac0 <yolov2_pp_getNNBoxes_centroid+0x1ba>
                    {
                        pOutbuff[count + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
3401ca9a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401ca9c:	1d5a      	adds	r2, r3, #5
3401ca9e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3401caa0:	4413      	add	r3, r2
3401caa2:	009b      	lsls	r3, r3, #2
3401caa4:	697a      	ldr	r2, [r7, #20]
3401caa6:	441a      	add	r2, r3
3401caa8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401caaa:	1d59      	adds	r1, r3, #5
3401caac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3401caae:	440b      	add	r3, r1
3401cab0:	009b      	lsls	r3, r3, #2
3401cab2:	6979      	ldr	r1, [r7, #20]
3401cab4:	440b      	add	r3, r1
3401cab6:	6812      	ldr	r2, [r2, #0]
3401cab8:	601a      	str	r2, [r3, #0]
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
3401caba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3401cabc:	3301      	adds	r3, #1
3401cabe:	63bb      	str	r3, [r7, #56]	@ 0x38
3401cac0:	683b      	ldr	r3, [r7, #0]
3401cac2:	681b      	ldr	r3, [r3, #0]
3401cac4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3401cac6:	429a      	cmp	r2, r3
3401cac8:	dbe7      	blt.n	3401ca9a <yolov2_pp_getNNBoxes_centroid+0x194>
                    }

                    pOutbuff[count + AI_YOLOV2_PP_XCENTER] = (col + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_XCENTER])) * grid_width_inv;
3401caca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401cacc:	ee07 3a90 	vmov	s15, r3
3401cad0:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
3401cad4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401cad6:	009b      	lsls	r3, r3, #2
3401cad8:	69ba      	ldr	r2, [r7, #24]
3401cada:	4413      	add	r3, r2
3401cadc:	edd3 7a00 	vldr	s15, [r3]
3401cae0:	eeb0 0a67 	vmov.f32	s0, s15
3401cae4:	f000 faa3 	bl	3401d02e <vision_models_sigmoid_f>
3401cae8:	eef0 7a40 	vmov.f32	s15, s0
3401caec:	ee38 7a27 	vadd.f32	s14, s16, s15
3401caf0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401caf2:	009b      	lsls	r3, r3, #2
3401caf4:	697a      	ldr	r2, [r7, #20]
3401caf6:	4413      	add	r3, r2
3401caf8:	edd7 7a0a 	vldr	s15, [r7, #40]	@ 0x28
3401cafc:	ee67 7a27 	vmul.f32	s15, s14, s15
3401cb00:	edc3 7a00 	vstr	s15, [r3]
                    pOutbuff[count + AI_YOLOV2_PP_YCENTER] = (row + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_YCENTER])) * grid_height_inv;
3401cb04:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3401cb06:	ee07 3a90 	vmov	s15, r3
3401cb0a:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
3401cb0e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401cb10:	3301      	adds	r3, #1
3401cb12:	009b      	lsls	r3, r3, #2
3401cb14:	69ba      	ldr	r2, [r7, #24]
3401cb16:	4413      	add	r3, r2
3401cb18:	edd3 7a00 	vldr	s15, [r3]
3401cb1c:	eeb0 0a67 	vmov.f32	s0, s15
3401cb20:	f000 fa85 	bl	3401d02e <vision_models_sigmoid_f>
3401cb24:	eef0 7a40 	vmov.f32	s15, s0
3401cb28:	ee38 7a27 	vadd.f32	s14, s16, s15
3401cb2c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401cb2e:	3301      	adds	r3, #1
3401cb30:	009b      	lsls	r3, r3, #2
3401cb32:	697a      	ldr	r2, [r7, #20]
3401cb34:	4413      	add	r3, r2
3401cb36:	edd7 7a09 	vldr	s15, [r7, #36]	@ 0x24
3401cb3a:	ee67 7a27 	vmul.f32	s15, s14, s15
3401cb3e:	edc3 7a00 	vstr	s15, [r3]
                    pOutbuff[count + AI_YOLOV2_PP_WIDTHREL] = (pInput_static_param->pAnchors[2 * anch] * expf(pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL])) * grid_width_inv;
3401cb42:	683b      	ldr	r3, [r7, #0]
3401cb44:	6a1a      	ldr	r2, [r3, #32]
3401cb46:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401cb48:	00db      	lsls	r3, r3, #3
3401cb4a:	4413      	add	r3, r2
3401cb4c:	ed93 8a00 	vldr	s16, [r3]
3401cb50:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401cb52:	3302      	adds	r3, #2
3401cb54:	009b      	lsls	r3, r3, #2
3401cb56:	69ba      	ldr	r2, [r7, #24]
3401cb58:	4413      	add	r3, r2
3401cb5a:	edd3 7a00 	vldr	s15, [r3]
3401cb5e:	eeb0 0a67 	vmov.f32	s0, s15
3401cb62:	f006 fd31 	bl	340235c8 <expf>
3401cb66:	eef0 7a40 	vmov.f32	s15, s0
3401cb6a:	ee28 7a27 	vmul.f32	s14, s16, s15
3401cb6e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401cb70:	3302      	adds	r3, #2
3401cb72:	009b      	lsls	r3, r3, #2
3401cb74:	697a      	ldr	r2, [r7, #20]
3401cb76:	4413      	add	r3, r2
3401cb78:	edd7 7a0a 	vldr	s15, [r7, #40]	@ 0x28
3401cb7c:	ee67 7a27 	vmul.f32	s15, s14, s15
3401cb80:	edc3 7a00 	vstr	s15, [r3]
                    pOutbuff[count + AI_YOLOV2_PP_HEIGHTREL] = (pInput_static_param->pAnchors[2 * anch + 1] * expf(pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL])) * grid_height_inv;
3401cb84:	683b      	ldr	r3, [r7, #0]
3401cb86:	6a1a      	ldr	r2, [r3, #32]
3401cb88:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401cb8a:	00db      	lsls	r3, r3, #3
3401cb8c:	3304      	adds	r3, #4
3401cb8e:	4413      	add	r3, r2
3401cb90:	ed93 8a00 	vldr	s16, [r3]
3401cb94:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401cb96:	3303      	adds	r3, #3
3401cb98:	009b      	lsls	r3, r3, #2
3401cb9a:	69ba      	ldr	r2, [r7, #24]
3401cb9c:	4413      	add	r3, r2
3401cb9e:	edd3 7a00 	vldr	s15, [r3]
3401cba2:	eeb0 0a67 	vmov.f32	s0, s15
3401cba6:	f006 fd0f 	bl	340235c8 <expf>
3401cbaa:	eef0 7a40 	vmov.f32	s15, s0
3401cbae:	ee28 7a27 	vmul.f32	s14, s16, s15
3401cbb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401cbb4:	3303      	adds	r3, #3
3401cbb6:	009b      	lsls	r3, r3, #2
3401cbb8:	697a      	ldr	r2, [r7, #20]
3401cbba:	4413      	add	r3, r2
3401cbbc:	edd7 7a09 	vldr	s15, [r7, #36]	@ 0x24
3401cbc0:	ee67 7a27 	vmul.f32	s15, s14, s15
3401cbc4:	edc3 7a00 	vstr	s15, [r3]

                    count += anch_stride;
3401cbc8:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3401cbca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3401cbcc:	4413      	add	r3, r2
3401cbce:	657b      	str	r3, [r7, #84]	@ 0x54
                    count_detect++;
3401cbd0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3401cbd2:	3301      	adds	r3, #1
3401cbd4:	653b      	str	r3, [r7, #80]	@ 0x50
                }

                el_offset += anch_stride;
3401cbd6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3401cbd8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3401cbda:	4413      	add	r3, r2
3401cbdc:	64fb      	str	r3, [r7, #76]	@ 0x4c
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
3401cbde:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401cbe0:	3301      	adds	r3, #1
3401cbe2:	643b      	str	r3, [r7, #64]	@ 0x40
3401cbe4:	683b      	ldr	r3, [r7, #0]
3401cbe6:	685b      	ldr	r3, [r3, #4]
3401cbe8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3401cbea:	429a      	cmp	r2, r3
3401cbec:	f6ff aee4 	blt.w	3401c9b8 <yolov2_pp_getNNBoxes_centroid+0xb2>
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
3401cbf0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401cbf2:	3301      	adds	r3, #1
3401cbf4:	647b      	str	r3, [r7, #68]	@ 0x44
3401cbf6:	683b      	ldr	r3, [r7, #0]
3401cbf8:	68db      	ldr	r3, [r3, #12]
3401cbfa:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401cbfc:	429a      	cmp	r2, r3
3401cbfe:	f6ff aed8 	blt.w	3401c9b2 <yolov2_pp_getNNBoxes_centroid+0xac>
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
3401cc02:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3401cc04:	3301      	adds	r3, #1
3401cc06:	64bb      	str	r3, [r7, #72]	@ 0x48
3401cc08:	683b      	ldr	r3, [r7, #0]
3401cc0a:	689b      	ldr	r3, [r3, #8]
3401cc0c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3401cc0e:	429a      	cmp	r2, r3
3401cc10:	f6ff aecc 	blt.w	3401c9ac <yolov2_pp_getNNBoxes_centroid+0xa6>
            }
        }
    }

    pInput_static_param->nb_detect = count_detect;
3401cc14:	683b      	ldr	r3, [r7, #0]
3401cc16:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3401cc18:	625a      	str	r2, [r3, #36]	@ 0x24
    return (error);
3401cc1a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3401cc1c:	46ad      	mov	sp, r5
}
3401cc1e:	4618      	mov	r0, r3
3401cc20:	3758      	adds	r7, #88	@ 0x58
3401cc22:	46bd      	mov	sp, r7
3401cc24:	ecbd 8b02 	vpop	{d8}
3401cc28:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

3401cc2c <od_yolov2_pp_reset>:


/* ----------------------       Exported routines      ---------------------- */

int32_t od_yolov2_pp_reset(yolov2_pp_static_param_t *pInput_static_param)
{
3401cc2c:	b480      	push	{r7}
3401cc2e:	b083      	sub	sp, #12
3401cc30:	af00      	add	r7, sp, #0
3401cc32:	6078      	str	r0, [r7, #4]
    /* Initializations */
    pInput_static_param->nb_detect = 0;
3401cc34:	687b      	ldr	r3, [r7, #4]
3401cc36:	2200      	movs	r2, #0
3401cc38:	625a      	str	r2, [r3, #36]	@ 0x24

	return (AI_OD_POSTPROCESS_ERROR_NO);
3401cc3a:	2300      	movs	r3, #0
}
3401cc3c:	4618      	mov	r0, r3
3401cc3e:	370c      	adds	r7, #12
3401cc40:	46bd      	mov	sp, r7
3401cc42:	f85d 7b04 	ldr.w	r7, [sp], #4
3401cc46:	4770      	bx	lr

3401cc48 <od_yolov2_pp_process>:


int32_t od_yolov2_pp_process(yolov2_pp_in_t *pInput,
                                    od_pp_out_t *pOutput,
                                    yolov2_pp_static_param_t *pInput_static_param)
{
3401cc48:	b580      	push	{r7, lr}
3401cc4a:	b086      	sub	sp, #24
3401cc4c:	af00      	add	r7, sp, #0
3401cc4e:	60f8      	str	r0, [r7, #12]
3401cc50:	60b9      	str	r1, [r7, #8]
3401cc52:	607a      	str	r2, [r7, #4]
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;
3401cc54:	2300      	movs	r3, #0
3401cc56:	617b      	str	r3, [r7, #20]

    /* Call Get NN boxes first */
    error = yolov2_pp_getNNBoxes_centroid(pInput,
3401cc58:	6879      	ldr	r1, [r7, #4]
3401cc5a:	68f8      	ldr	r0, [r7, #12]
3401cc5c:	f7ff fe53 	bl	3401c906 <yolov2_pp_getNNBoxes_centroid>
3401cc60:	6178      	str	r0, [r7, #20]
                                          pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
3401cc62:	697b      	ldr	r3, [r7, #20]
3401cc64:	2b00      	cmp	r3, #0
3401cc66:	d001      	beq.n	3401cc6c <od_yolov2_pp_process+0x24>
3401cc68:	697b      	ldr	r3, [r7, #20]
3401cc6a:	e010      	b.n	3401cc8e <od_yolov2_pp_process+0x46>

    /* Then NMS */
    error = yolov2_pp_nmsFiltering_centroid(pInput,
3401cc6c:	6879      	ldr	r1, [r7, #4]
3401cc6e:	68f8      	ldr	r0, [r7, #12]
3401cc70:	f7ff fcfe 	bl	3401c670 <yolov2_pp_nmsFiltering_centroid>
3401cc74:	6178      	str	r0, [r7, #20]
                                            pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
3401cc76:	697b      	ldr	r3, [r7, #20]
3401cc78:	2b00      	cmp	r3, #0
3401cc7a:	d001      	beq.n	3401cc80 <od_yolov2_pp_process+0x38>
3401cc7c:	697b      	ldr	r3, [r7, #20]
3401cc7e:	e006      	b.n	3401cc8e <od_yolov2_pp_process+0x46>

    /* And score re-filtering */
    error = yolov2_pp_scoreFiltering_centroid(pInput,
3401cc80:	687a      	ldr	r2, [r7, #4]
3401cc82:	68b9      	ldr	r1, [r7, #8]
3401cc84:	68f8      	ldr	r0, [r7, #12]
3401cc86:	f7ff fda5 	bl	3401c7d4 <yolov2_pp_scoreFiltering_centroid>
3401cc8a:	6178      	str	r0, [r7, #20]
                                              pOutput,
                                              pInput_static_param);

    return (error);
3401cc8c:	697b      	ldr	r3, [r7, #20]
}
3401cc8e:	4618      	mov	r0, r3
3401cc90:	3718      	adds	r7, #24
3401cc92:	46bd      	mov	sp, r7
3401cc94:	bd80      	pop	{r7, pc}

3401cc96 <vision_models_maxi_if32ou32>:
#include "stdio.h"

/* return max value and it's index from an array */
#if defined(AI_OD_YOLOV5_PP_MVEF_OPTIM) || defined(AI_SPE_MOVENET_PP_MVEF_OPTIM)
void vision_models_maxi_if32ou32(float32_t *arr, uint32_t len_arr, float32_t *maxim, uint32_t *index)
{
3401cc96:	b490      	push	{r4, r7}
3401cc98:	b0dc      	sub	sp, #368	@ 0x170
3401cc9a:	af00      	add	r7, sp, #0
3401cc9c:	f507 74b8 	add.w	r4, r7, #368	@ 0x170
3401cca0:	f5a4 74b2 	sub.w	r4, r4, #356	@ 0x164
3401cca4:	6020      	str	r0, [r4, #0]
3401cca6:	f507 70b8 	add.w	r0, r7, #368	@ 0x170
3401ccaa:	f5a0 70b4 	sub.w	r0, r0, #360	@ 0x168
3401ccae:	6001      	str	r1, [r0, #0]
3401ccb0:	f507 71b8 	add.w	r1, r7, #368	@ 0x170
3401ccb4:	f5a1 71b6 	sub.w	r1, r1, #364	@ 0x16c
3401ccb8:	600a      	str	r2, [r1, #0]
3401ccba:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401ccbe:	f5a2 72b8 	sub.w	r2, r2, #368	@ 0x170
3401ccc2:	6013      	str	r3, [r2, #0]
3401ccc4:	f46f 0300 	mvn.w	r3, #8388608	@ 0x800000
3401ccc8:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_f32 (float32_t __a)
{
  return __builtin_mve_vdupq_n_fv4sf (__a);
3401cccc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
3401ccd0:	eea6 3b10 	vdup.32	q3, r3

  float32x4_t    f32x4_max_val = vdupq_n_f32(F32_MIN);
3401ccd4:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ccd8:	3b10      	subs	r3, #16
3401ccda:	ed83 7f00 	stc	15, cr7, [r3]
3401ccde:	2300      	movs	r3, #0
3401cce0:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
  return __builtin_mve_vdupq_n_uv4si (__a);
3401cce4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
3401cce8:	eea6 3b10 	vdup.32	q3, r3
  uint32x4_t     u32x4_max_idx = vdupq_n_u32(0);
3401ccec:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ccf0:	3b20      	subs	r3, #32
3401ccf2:	ed83 7f00 	stc	15, cr7, [r3]
3401ccf6:	2300      	movs	r3, #0
3401ccf8:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
  return __builtin_mve_vidupq_n_uv4si (__a, __imm);
3401ccfc:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
3401cd00:	461a      	mov	r2, r3
3401cd02:	ee23 6f6e 	cdp	15, 2, cr6, cr3, cr14, {3}


  uint32x4_t u32x4_idx = vidupq_n_u32(0,1);
3401cd06:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cd0a:	3b30      	subs	r3, #48	@ 0x30
3401cd0c:	ed83 7f00 	stc	15, cr7, [r3]
  float32_t *pSrc = arr;
3401cd10:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cd14:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
3401cd18:	681b      	ldr	r3, [r3, #0]
3401cd1a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
  int32_t iter = len_arr;
3401cd1e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cd22:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
3401cd26:	681b      	ldr	r3, [r3, #0]
3401cd28:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
  while(iter > 0)
3401cd2c:	e0c2      	b.n	3401ceb4 <vision_models_maxi_if32ou32+0x21e>
  {
    mve_pred16_t p = vctp32q(iter);
3401cd2e:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
3401cd32:	67bb      	str	r3, [r7, #120]	@ 0x78
  return __builtin_mve_vctp32qv4bi (__a);
3401cd34:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3401cd36:	f023 e801 	bfcsel	0, 3401bd3c <HAL_XSPI_MemoryMapped+0x38>, 4, hi
3401cd3a:	eefd 3a10 	vmrs	r3, <impl def 0xd>
3401cd3e:	b29b      	uxth	r3, r3
3401cd40:	f8a7 311e 	strh.w	r3, [r7, #286]	@ 0x11e
3401cd44:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
3401cd48:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
3401cd4c:	f8b7 311e 	ldrh.w	r3, [r7, #286]	@ 0x11e
3401cd50:	f8a7 307e 	strh.w	r3, [r7, #126]	@ 0x7e

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vldrwq_z_f32 (float32_t const * __base, mve_pred16_t __p)
{
  return __builtin_mve_vldrwq_z_fv4sf((__builtin_neon_si *) __base, __p);
3401cd54:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3401cd58:	f8b7 207e 	ldrh.w	r2, [r7, #126]	@ 0x7e
3401cd5c:	eeed 2a10 	vmsr	<impl def 0xd>, r2
3401cd60:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401cd64:	ed93 7f00 	ldc	15, cr7, [r3]
    // load up to 4 float32_t
    float32x4_t f32x4_val = vldrwq_z_f32(pSrc, p);
3401cd68:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cd6c:	3b68      	subs	r3, #104	@ 0x68
3401cd6e:	ed83 7f00 	stc	15, cr7, [r3]
    pSrc+=4;
3401cd72:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
3401cd76:	3310      	adds	r3, #16
3401cd78:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
3401cd7c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cd80:	3bd8      	subs	r3, #216	@ 0xd8
3401cd82:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cd86:	3a68      	subs	r2, #104	@ 0x68
3401cd88:	ed92 7f00 	ldc	15, cr7, [r2]
3401cd8c:	ed83 7f00 	stc	15, cr7, [r3]
3401cd90:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cd94:	3be8      	subs	r3, #232	@ 0xe8
3401cd96:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cd9a:	3a10      	subs	r2, #16
3401cd9c:	ed92 7f00 	ldc	15, cr7, [r2]
3401cda0:	ed83 7f00 	stc	15, cr7, [r3]
3401cda4:	f8b7 311e 	ldrh.w	r3, [r7, #286]	@ 0x11e
3401cda8:	f8a7 3086 	strh.w	r3, [r7, #134]	@ 0x86
  return __builtin_mve_vcmpgtq_m_fv4sf (__a, __b, __p);
3401cdac:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cdb0:	3bd8      	subs	r3, #216	@ 0xd8
3401cdb2:	ed93 7f00 	ldc	15, cr7, [r3]
3401cdb6:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cdba:	3be8      	subs	r3, #232	@ 0xe8
3401cdbc:	ed93 5f00 	ldc	15, cr5, [r3]
3401cdc0:	f8b7 3086 	ldrh.w	r3, [r7, #134]	@ 0x86
3401cdc4:	eeed 3a10 	vmsr	<impl def 0xd>, r3
3401cdc8:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401cdcc:	ee37 1f05 	cdp	15, 3, cr1, cr7, cr5, {0}
3401cdd0:	eefd 3a10 	vmrs	r3, <impl def 0xd>
3401cdd4:	b29b      	uxth	r3, r3
    // Compare according to p to create p0
    mve_pred16_t p0 = vcmpgtq_m_f32(f32x4_val, f32x4_max_val, p);
3401cdd6:	f8a7 3106 	strh.w	r3, [r7, #262]	@ 0x106
3401cdda:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cdde:	3bb0      	subs	r3, #176	@ 0xb0
3401cde0:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cde4:	3a68      	subs	r2, #104	@ 0x68
3401cde6:	ed92 7f00 	ldc	15, cr7, [r2]
3401cdea:	ed83 7f00 	stc	15, cr7, [r3]
3401cdee:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cdf2:	3bc0      	subs	r3, #192	@ 0xc0
3401cdf4:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cdf8:	3a10      	subs	r2, #16
3401cdfa:	ed92 7f00 	ldc	15, cr7, [r2]
3401cdfe:	ed83 7f00 	stc	15, cr7, [r3]
3401ce02:	f8b7 3106 	ldrh.w	r3, [r7, #262]	@ 0x106
3401ce06:	f8a7 30ae 	strh.w	r3, [r7, #174]	@ 0xae
  return __builtin_mve_vpselq_fv4sf (__a, __b, __p);
3401ce0a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce0e:	3bb0      	subs	r3, #176	@ 0xb0
3401ce10:	ed93 7f00 	ldc	15, cr7, [r3]
3401ce14:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce18:	3bc0      	subs	r3, #192	@ 0xc0
3401ce1a:	ed93 5f00 	ldc	15, cr5, [r3]
3401ce1e:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	@ 0xae
3401ce22:	eeed 3a10 	vmsr	<impl def 0xd>, r3
3401ce26:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}

    // according to p0: update with s8x16_val or keep s8x16_blk_minmax_val
    f32x4_max_val = vpselq_f32(f32x4_val, f32x4_max_val, p0);
3401ce2a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce2e:	3b10      	subs	r3, #16
3401ce30:	ed83 7f00 	stc	15, cr7, [r3]
3401ce34:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce38:	3b88      	subs	r3, #136	@ 0x88
3401ce3a:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401ce3e:	3a30      	subs	r2, #48	@ 0x30
3401ce40:	ed92 7f00 	ldc	15, cr7, [r2]
3401ce44:	ed83 7f00 	stc	15, cr7, [r3]
3401ce48:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce4c:	3b98      	subs	r3, #152	@ 0x98
3401ce4e:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401ce52:	3a20      	subs	r2, #32
3401ce54:	ed92 7f00 	ldc	15, cr7, [r2]
3401ce58:	ed83 7f00 	stc	15, cr7, [r3]
3401ce5c:	f8b7 3106 	ldrh.w	r3, [r7, #262]	@ 0x106
3401ce60:	f8a7 30d6 	strh.w	r3, [r7, #214]	@ 0xd6
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
3401ce64:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce68:	3b88      	subs	r3, #136	@ 0x88
3401ce6a:	ed93 7f00 	ldc	15, cr7, [r3]
3401ce6e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce72:	3b98      	subs	r3, #152	@ 0x98
3401ce74:	ed93 5f00 	ldc	15, cr5, [r3]
3401ce78:	f8b7 30d6 	ldrh.w	r3, [r7, #214]	@ 0xd6
3401ce7c:	eeed 3a10 	vmsr	<impl def 0xd>, r3
3401ce80:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}
    /* according to p0: store per-lane extrema indexes*/
    u32x4_max_idx = vpselq_u32(u32x4_idx, u32x4_max_idx, p0);
3401ce84:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce88:	3b20      	subs	r3, #32
3401ce8a:	ed83 7f00 	stc	15, cr7, [r3]
    u32x4_idx+=4;
3401ce8e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ce92:	3b30      	subs	r3, #48	@ 0x30
3401ce94:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401ce98:	3a30      	subs	r2, #48	@ 0x30
3401ce9a:	ed92 5f00 	ldc	15, cr5, [r2]
3401ce9e:	ef80 6054 	vmov.i32	q3, #4	@ 0x00000004
3401cea2:	ef24 6846 	vadd.i32	q3, q2, q3
3401cea6:	ed83 7f00 	stc	15, cr7, [r3]
    iter-=4;
3401ceaa:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
3401ceae:	3b04      	subs	r3, #4
3401ceb0:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
  while(iter > 0)
3401ceb4:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
3401ceb8:	2b00      	cmp	r3, #0
3401ceba:	f73f af38 	bgt.w	3401cd2e <vision_models_maxi_if32ou32+0x98>
3401cebe:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cec2:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
3401cec6:	f46f 0200 	mvn.w	r2, #8388608	@ 0x800000
3401ceca:	601a      	str	r2, [r3, #0]
3401cecc:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401ced0:	f5a3 73b0 	sub.w	r3, r3, #352	@ 0x160
3401ced4:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401ced8:	3a10      	subs	r2, #16
3401ceda:	ed92 7f00 	ldc	15, cr7, [r2]
3401cede:	ed83 7f00 	stc	15, cr7, [r3]
  return __builtin_mve_vmaxnmvq_fv4sf (__a, __b);
3401cee2:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cee6:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
3401ceea:	681b      	ldr	r3, [r3, #0]
3401ceec:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cef0:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
3401cef4:	ed92 7f00 	ldc	15, cr7, [r2]
3401cef8:	eeee 3f06 	cdp	15, 14, cr3, cr14, cr6, {0}
3401cefc:	461a      	mov	r2, r3

  }
  /*
   * Get max value across the vector
   */
  *maxim = vmaxnmvq_f32(F32_MIN, f32x4_max_val);
3401cefe:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf02:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
3401cf06:	681b      	ldr	r3, [r3, #0]
3401cf08:	601a      	str	r2, [r3, #0]
  /*
   * set index for lower values to max possible index
   */
  mve_pred16_t p0 = vcmpgeq_n_f32(f32x4_max_val, *maxim);
3401cf0a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf0e:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
3401cf12:	681b      	ldr	r3, [r3, #0]
3401cf14:	681a      	ldr	r2, [r3, #0]
3401cf16:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf1a:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
3401cf1e:	f507 71b8 	add.w	r1, r7, #368	@ 0x170
3401cf22:	3910      	subs	r1, #16
3401cf24:	ed91 7f00 	ldc	15, cr7, [r1]
3401cf28:	ed83 7f00 	stc	15, cr7, [r3]
3401cf2c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf30:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
3401cf34:	601a      	str	r2, [r3, #0]
  return __builtin_mve_vcmpgeq_n_fv4sf (__a, __b);
3401cf36:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf3a:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
3401cf3e:	ed93 7f00 	ldc	15, cr7, [r3]
3401cf42:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf46:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
3401cf4a:	681b      	ldr	r3, [r3, #0]
3401cf4c:	ee37 1f43 	cdp	15, 3, cr1, cr7, cr3, {2}
3401cf50:	eefd 3a10 	vmrs	r3, <impl def 0xd>
3401cf54:	b29b      	uxth	r3, r3
3401cf56:	f8a7 3136 	strh.w	r3, [r7, #310]	@ 0x136
3401cf5a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf5e:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
3401cf62:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cf66:	f5a2 72b4 	sub.w	r2, r2, #360	@ 0x168
3401cf6a:	6812      	ldr	r2, [r2, #0]
3401cf6c:	601a      	str	r2, [r3, #0]
  return __builtin_mve_vdupq_n_uv4si (__a);
3401cf6e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf72:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
3401cf76:	681b      	ldr	r3, [r3, #0]
3401cf78:	eea6 3b10 	vdup.32	q3, r3
3401cf7c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf80:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
3401cf84:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cf88:	3a20      	subs	r2, #32
3401cf8a:	ed92 5f00 	ldc	15, cr5, [r2]
3401cf8e:	ed83 5f00 	stc	15, cr5, [r3]
3401cf92:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cf96:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
3401cf9a:	ed83 7f00 	stc	15, cr7, [r3]
3401cf9e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cfa2:	f5a3 7399 	sub.w	r3, r3, #306	@ 0x132
3401cfa6:	f8b7 2136 	ldrh.w	r2, [r7, #310]	@ 0x136
3401cfaa:	801a      	strh	r2, [r3, #0]
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
3401cfac:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cfb0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
3401cfb4:	ed93 7f00 	ldc	15, cr7, [r3]
3401cfb8:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cfbc:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
3401cfc0:	ed93 5f00 	ldc	15, cr5, [r3]
3401cfc4:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cfc8:	f5a3 7399 	sub.w	r3, r3, #306	@ 0x132
3401cfcc:	881b      	ldrh	r3, [r3, #0]
3401cfce:	eeed 3a10 	vmsr	<impl def 0xd>, r3
3401cfd2:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}
  uint32x4_t indexVec = vpselq_u32(u32x4_max_idx, vdupq_n_u32(len_arr), p0);
3401cfd6:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cfda:	3b50      	subs	r3, #80	@ 0x50
3401cfdc:	ed83 7f00 	stc	15, cr7, [r3]
3401cfe0:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cfe4:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
3401cfe8:	681b      	ldr	r3, [r3, #0]
3401cfea:	677b      	str	r3, [r7, #116]	@ 0x74
3401cfec:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401cff0:	f5a3 7388 	sub.w	r3, r3, #272	@ 0x110
3401cff4:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401cff8:	3a50      	subs	r2, #80	@ 0x50
3401cffa:	ed92 7f00 	ldc	15, cr7, [r2]
3401cffe:	ed83 7f00 	stc	15, cr7, [r3]
  return __builtin_mve_vminvq_uv4si (__a, __b);
3401d002:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3401d004:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
3401d008:	f5a2 7288 	sub.w	r2, r2, #272	@ 0x110
3401d00c:	ed92 7f00 	ldc	15, cr7, [r2]
3401d010:	feea 3f86 	cdp2	15, 14, cr3, cr10, cr6, {4}
3401d014:	461a      	mov	r2, r3
  /*
   * Get min index which is thus for a max value
   */
  *index = (int32_t)vminvq_u32(len_arr, indexVec);
3401d016:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
3401d01a:	f5a3 73b8 	sub.w	r3, r3, #368	@ 0x170
3401d01e:	681b      	ldr	r3, [r3, #0]
3401d020:	601a      	str	r2, [r3, #0]

}
3401d022:	bf00      	nop
3401d024:	f507 77b8 	add.w	r7, r7, #368	@ 0x170
3401d028:	46bd      	mov	sp, r7
3401d02a:	bc90      	pop	{r4, r7}
3401d02c:	4770      	bx	lr

3401d02e <vision_models_sigmoid_f>:
    }
  }
}

float32_t vision_models_sigmoid_f(float32_t x)
{
3401d02e:	b580      	push	{r7, lr}
3401d030:	b082      	sub	sp, #8
3401d032:	af00      	add	r7, sp, #0
3401d034:	ed87 0a01 	vstr	s0, [r7, #4]
  return (1.0f / (1.0f + expf(-x)));
3401d038:	edd7 7a01 	vldr	s15, [r7, #4]
3401d03c:	eef1 7a67 	vneg.f32	s15, s15
3401d040:	eeb0 0a67 	vmov.f32	s0, s15
3401d044:	f006 fac0 	bl	340235c8 <expf>
3401d048:	eef0 7a40 	vmov.f32	s15, s0
3401d04c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
3401d050:	ee77 7a87 	vadd.f32	s15, s15, s14
3401d054:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
3401d058:	eec7 6a27 	vdiv.f32	s13, s14, s15
3401d05c:	eef0 7a66 	vmov.f32	s15, s13
}
3401d060:	eeb0 0a67 	vmov.f32	s0, s15
3401d064:	3708      	adds	r7, #8
3401d066:	46bd      	mov	sp, r7
3401d068:	bd80      	pop	{r7, pc}

3401d06a <vision_models_softmax_f>:


void vision_models_softmax_f(float32_t *input_x, float32_t *output_x, int32_t len_x, float32_t *tmp_x)
{
3401d06a:	b590      	push	{r4, r7, lr}
3401d06c:	b089      	sub	sp, #36	@ 0x24
3401d06e:	af00      	add	r7, sp, #0
3401d070:	60f8      	str	r0, [r7, #12]
3401d072:	60b9      	str	r1, [r7, #8]
3401d074:	607a      	str	r2, [r7, #4]
3401d076:	603b      	str	r3, [r7, #0]
  float32_t sum = 0;
3401d078:	f04f 0300 	mov.w	r3, #0
3401d07c:	61fb      	str	r3, [r7, #28]

  for (int32_t i = 0; i < len_x; ++i)
3401d07e:	2300      	movs	r3, #0
3401d080:	61bb      	str	r3, [r7, #24]
3401d082:	e020      	b.n	3401d0c6 <vision_models_softmax_f+0x5c>
  {
    tmp_x[i] = expf(input_x[i]);
3401d084:	69bb      	ldr	r3, [r7, #24]
3401d086:	009b      	lsls	r3, r3, #2
3401d088:	68fa      	ldr	r2, [r7, #12]
3401d08a:	4413      	add	r3, r2
3401d08c:	edd3 7a00 	vldr	s15, [r3]
3401d090:	69bb      	ldr	r3, [r7, #24]
3401d092:	009b      	lsls	r3, r3, #2
3401d094:	683a      	ldr	r2, [r7, #0]
3401d096:	18d4      	adds	r4, r2, r3
3401d098:	eeb0 0a67 	vmov.f32	s0, s15
3401d09c:	f006 fa94 	bl	340235c8 <expf>
3401d0a0:	eef0 7a40 	vmov.f32	s15, s0
3401d0a4:	edc4 7a00 	vstr	s15, [r4]
    sum = sum + tmp_x[i];
3401d0a8:	69bb      	ldr	r3, [r7, #24]
3401d0aa:	009b      	lsls	r3, r3, #2
3401d0ac:	683a      	ldr	r2, [r7, #0]
3401d0ae:	4413      	add	r3, r2
3401d0b0:	edd3 7a00 	vldr	s15, [r3]
3401d0b4:	ed97 7a07 	vldr	s14, [r7, #28]
3401d0b8:	ee77 7a27 	vadd.f32	s15, s14, s15
3401d0bc:	edc7 7a07 	vstr	s15, [r7, #28]
  for (int32_t i = 0; i < len_x; ++i)
3401d0c0:	69bb      	ldr	r3, [r7, #24]
3401d0c2:	3301      	adds	r3, #1
3401d0c4:	61bb      	str	r3, [r7, #24]
3401d0c6:	69ba      	ldr	r2, [r7, #24]
3401d0c8:	687b      	ldr	r3, [r7, #4]
3401d0ca:	429a      	cmp	r2, r3
3401d0cc:	dbda      	blt.n	3401d084 <vision_models_softmax_f+0x1a>
  }
  sum = 1.0f / sum;
3401d0ce:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
3401d0d2:	ed97 7a07 	vldr	s14, [r7, #28]
3401d0d6:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401d0da:	edc7 7a07 	vstr	s15, [r7, #28]
  for (int32_t i = 0; i < len_x; ++i)
3401d0de:	2300      	movs	r3, #0
3401d0e0:	617b      	str	r3, [r7, #20]
3401d0e2:	e012      	b.n	3401d10a <vision_models_softmax_f+0xa0>
  {
    tmp_x[i] *= sum;
3401d0e4:	697b      	ldr	r3, [r7, #20]
3401d0e6:	009b      	lsls	r3, r3, #2
3401d0e8:	683a      	ldr	r2, [r7, #0]
3401d0ea:	4413      	add	r3, r2
3401d0ec:	ed93 7a00 	vldr	s14, [r3]
3401d0f0:	697b      	ldr	r3, [r7, #20]
3401d0f2:	009b      	lsls	r3, r3, #2
3401d0f4:	683a      	ldr	r2, [r7, #0]
3401d0f6:	4413      	add	r3, r2
3401d0f8:	edd7 7a07 	vldr	s15, [r7, #28]
3401d0fc:	ee67 7a27 	vmul.f32	s15, s14, s15
3401d100:	edc3 7a00 	vstr	s15, [r3]
  for (int32_t i = 0; i < len_x; ++i)
3401d104:	697b      	ldr	r3, [r7, #20]
3401d106:	3301      	adds	r3, #1
3401d108:	617b      	str	r3, [r7, #20]
3401d10a:	697a      	ldr	r2, [r7, #20]
3401d10c:	687b      	ldr	r3, [r7, #4]
3401d10e:	429a      	cmp	r2, r3
3401d110:	dbe8      	blt.n	3401d0e4 <vision_models_softmax_f+0x7a>
  }
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
3401d112:	687b      	ldr	r3, [r7, #4]
3401d114:	009b      	lsls	r3, r3, #2
3401d116:	461a      	mov	r2, r3
3401d118:	6839      	ldr	r1, [r7, #0]
3401d11a:	68b8      	ldr	r0, [r7, #8]
3401d11c:	f004 fce9 	bl	34021af2 <memcpy>
}
3401d120:	bf00      	nop
3401d122:	3724      	adds	r7, #36	@ 0x24
3401d124:	46bd      	mov	sp, r7
3401d126:	bd90      	pop	{r4, r7, pc}

3401d128 <overlap>:


//***************iou ********
//inline
float32_t overlap(float32_t x1, float32_t w1, float32_t x2, float32_t w2)
{
3401d128:	b480      	push	{r7}
3401d12a:	b08b      	sub	sp, #44	@ 0x2c
3401d12c:	af00      	add	r7, sp, #0
3401d12e:	ed87 0a03 	vstr	s0, [r7, #12]
3401d132:	edc7 0a02 	vstr	s1, [r7, #8]
3401d136:	ed87 1a01 	vstr	s2, [r7, #4]
3401d13a:	edc7 1a00 	vstr	s3, [r7]
  float32_t l1 = x1 - w1 / 2;
3401d13e:	ed97 7a02 	vldr	s14, [r7, #8]
3401d142:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3401d146:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401d14a:	ed97 7a03 	vldr	s14, [r7, #12]
3401d14e:	ee77 7a67 	vsub.f32	s15, s14, s15
3401d152:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
  float32_t l2 = x2 - w2 / 2;
3401d156:	ed97 7a00 	vldr	s14, [r7]
3401d15a:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3401d15e:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401d162:	ed97 7a01 	vldr	s14, [r7, #4]
3401d166:	ee77 7a67 	vsub.f32	s15, s14, s15
3401d16a:	edc7 7a08 	vstr	s15, [r7, #32]
  float32_t left = l1 > l2 ? l1 : l2;
3401d16e:	ed97 7a09 	vldr	s14, [r7, #36]	@ 0x24
3401d172:	edd7 7a08 	vldr	s15, [r7, #32]
3401d176:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401d17a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d17e:	dd01      	ble.n	3401d184 <overlap+0x5c>
3401d180:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401d182:	e000      	b.n	3401d186 <overlap+0x5e>
3401d184:	6a3b      	ldr	r3, [r7, #32]
3401d186:	61fb      	str	r3, [r7, #28]
  float32_t r1 = x1 + w1 / 2;
3401d188:	ed97 7a02 	vldr	s14, [r7, #8]
3401d18c:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3401d190:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401d194:	ed97 7a03 	vldr	s14, [r7, #12]
3401d198:	ee77 7a27 	vadd.f32	s15, s14, s15
3401d19c:	edc7 7a06 	vstr	s15, [r7, #24]
  float32_t r2 = x2 + w2 / 2;
3401d1a0:	ed97 7a00 	vldr	s14, [r7]
3401d1a4:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3401d1a8:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401d1ac:	ed97 7a01 	vldr	s14, [r7, #4]
3401d1b0:	ee77 7a27 	vadd.f32	s15, s14, s15
3401d1b4:	edc7 7a05 	vstr	s15, [r7, #20]
  float32_t right = r1 < r2 ? r1 : r2;
3401d1b8:	ed97 7a06 	vldr	s14, [r7, #24]
3401d1bc:	edd7 7a05 	vldr	s15, [r7, #20]
3401d1c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401d1c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d1c8:	d501      	bpl.n	3401d1ce <overlap+0xa6>
3401d1ca:	69bb      	ldr	r3, [r7, #24]
3401d1cc:	e000      	b.n	3401d1d0 <overlap+0xa8>
3401d1ce:	697b      	ldr	r3, [r7, #20]
3401d1d0:	613b      	str	r3, [r7, #16]
  return (right - left);
3401d1d2:	ed97 7a04 	vldr	s14, [r7, #16]
3401d1d6:	edd7 7a07 	vldr	s15, [r7, #28]
3401d1da:	ee77 7a67 	vsub.f32	s15, s14, s15
}
3401d1de:	eeb0 0a67 	vmov.f32	s0, s15
3401d1e2:	372c      	adds	r7, #44	@ 0x2c
3401d1e4:	46bd      	mov	sp, r7
3401d1e6:	f85d 7b04 	ldr.w	r7, [sp], #4
3401d1ea:	4770      	bx	lr

3401d1ec <box_intersection>:

//inline
float32_t box_intersection(float32_t *a, float32_t *b)
{
3401d1ec:	b580      	push	{r7, lr}
3401d1ee:	b086      	sub	sp, #24
3401d1f0:	af00      	add	r7, sp, #0
3401d1f2:	6078      	str	r0, [r7, #4]
3401d1f4:	6039      	str	r1, [r7, #0]
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
3401d1f6:	687b      	ldr	r3, [r7, #4]
3401d1f8:	edd3 7a00 	vldr	s15, [r3]
3401d1fc:	687b      	ldr	r3, [r7, #4]
3401d1fe:	3308      	adds	r3, #8
3401d200:	ed93 7a00 	vldr	s14, [r3]
3401d204:	683b      	ldr	r3, [r7, #0]
3401d206:	edd3 6a00 	vldr	s13, [r3]
3401d20a:	683b      	ldr	r3, [r7, #0]
3401d20c:	3308      	adds	r3, #8
3401d20e:	ed93 6a00 	vldr	s12, [r3]
3401d212:	eef0 1a46 	vmov.f32	s3, s12
3401d216:	eeb0 1a66 	vmov.f32	s2, s13
3401d21a:	eef0 0a47 	vmov.f32	s1, s14
3401d21e:	eeb0 0a67 	vmov.f32	s0, s15
3401d222:	f7ff ff81 	bl	3401d128 <overlap>
3401d226:	ed87 0a05 	vstr	s0, [r7, #20]
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
3401d22a:	687b      	ldr	r3, [r7, #4]
3401d22c:	3304      	adds	r3, #4
3401d22e:	edd3 7a00 	vldr	s15, [r3]
3401d232:	687b      	ldr	r3, [r7, #4]
3401d234:	330c      	adds	r3, #12
3401d236:	ed93 7a00 	vldr	s14, [r3]
3401d23a:	683b      	ldr	r3, [r7, #0]
3401d23c:	3304      	adds	r3, #4
3401d23e:	edd3 6a00 	vldr	s13, [r3]
3401d242:	683b      	ldr	r3, [r7, #0]
3401d244:	330c      	adds	r3, #12
3401d246:	ed93 6a00 	vldr	s12, [r3]
3401d24a:	eef0 1a46 	vmov.f32	s3, s12
3401d24e:	eeb0 1a66 	vmov.f32	s2, s13
3401d252:	eef0 0a47 	vmov.f32	s1, s14
3401d256:	eeb0 0a67 	vmov.f32	s0, s15
3401d25a:	f7ff ff65 	bl	3401d128 <overlap>
3401d25e:	ed87 0a04 	vstr	s0, [r7, #16]
  if (w < 0 || h < 0) return 0;
3401d262:	edd7 7a05 	vldr	s15, [r7, #20]
3401d266:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401d26a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d26e:	d406      	bmi.n	3401d27e <box_intersection+0x92>
3401d270:	edd7 7a04 	vldr	s15, [r7, #16]
3401d274:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401d278:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d27c:	d502      	bpl.n	3401d284 <box_intersection+0x98>
3401d27e:	f04f 0300 	mov.w	r3, #0
3401d282:	e008      	b.n	3401d296 <box_intersection+0xaa>
  float32_t area = w * h;
3401d284:	ed97 7a05 	vldr	s14, [r7, #20]
3401d288:	edd7 7a04 	vldr	s15, [r7, #16]
3401d28c:	ee67 7a27 	vmul.f32	s15, s14, s15
3401d290:	edc7 7a03 	vstr	s15, [r7, #12]
  return (area);
3401d294:	68fb      	ldr	r3, [r7, #12]
}
3401d296:	ee07 3a90 	vmov	s15, r3
3401d29a:	eeb0 0a67 	vmov.f32	s0, s15
3401d29e:	3718      	adds	r7, #24
3401d2a0:	46bd      	mov	sp, r7
3401d2a2:	bd80      	pop	{r7, pc}

3401d2a4 <box_union>:

//inline
float32_t box_union(float32_t *a, float32_t *b)
{
3401d2a4:	b580      	push	{r7, lr}
3401d2a6:	b084      	sub	sp, #16
3401d2a8:	af00      	add	r7, sp, #0
3401d2aa:	6078      	str	r0, [r7, #4]
3401d2ac:	6039      	str	r1, [r7, #0]
  float32_t i = box_intersection(a, b);
3401d2ae:	6839      	ldr	r1, [r7, #0]
3401d2b0:	6878      	ldr	r0, [r7, #4]
3401d2b2:	f7ff ff9b 	bl	3401d1ec <box_intersection>
3401d2b6:	ed87 0a03 	vstr	s0, [r7, #12]
  float32_t u = a[2] * a[3] + b[2] * b[3] - i;
3401d2ba:	687b      	ldr	r3, [r7, #4]
3401d2bc:	3308      	adds	r3, #8
3401d2be:	ed93 7a00 	vldr	s14, [r3]
3401d2c2:	687b      	ldr	r3, [r7, #4]
3401d2c4:	330c      	adds	r3, #12
3401d2c6:	edd3 7a00 	vldr	s15, [r3]
3401d2ca:	ee27 7a27 	vmul.f32	s14, s14, s15
3401d2ce:	683b      	ldr	r3, [r7, #0]
3401d2d0:	3308      	adds	r3, #8
3401d2d2:	edd3 6a00 	vldr	s13, [r3]
3401d2d6:	683b      	ldr	r3, [r7, #0]
3401d2d8:	330c      	adds	r3, #12
3401d2da:	edd3 7a00 	vldr	s15, [r3]
3401d2de:	ee66 7aa7 	vmul.f32	s15, s13, s15
3401d2e2:	ee37 7a27 	vadd.f32	s14, s14, s15
3401d2e6:	edd7 7a03 	vldr	s15, [r7, #12]
3401d2ea:	ee77 7a67 	vsub.f32	s15, s14, s15
3401d2ee:	edc7 7a02 	vstr	s15, [r7, #8]
  return (u);
3401d2f2:	68bb      	ldr	r3, [r7, #8]
3401d2f4:	ee07 3a90 	vmov	s15, r3
}
3401d2f8:	eeb0 0a67 	vmov.f32	s0, s15
3401d2fc:	3710      	adds	r7, #16
3401d2fe:	46bd      	mov	sp, r7
3401d300:	bd80      	pop	{r7, pc}
	...

3401d304 <vision_models_box_iou>:


float32_t vision_models_box_iou(float32_t *a, float32_t *b)
{
3401d304:	b580      	push	{r7, lr}
3401d306:	b084      	sub	sp, #16
3401d308:	af00      	add	r7, sp, #0
3401d30a:	6078      	str	r0, [r7, #4]
3401d30c:	6039      	str	r1, [r7, #0]

  float32_t I = box_intersection(a, b);
3401d30e:	6839      	ldr	r1, [r7, #0]
3401d310:	6878      	ldr	r0, [r7, #4]
3401d312:	f7ff ff6b 	bl	3401d1ec <box_intersection>
3401d316:	ed87 0a03 	vstr	s0, [r7, #12]
  float32_t U = box_union(a, b);
3401d31a:	6839      	ldr	r1, [r7, #0]
3401d31c:	6878      	ldr	r0, [r7, #4]
3401d31e:	f7ff ffc1 	bl	3401d2a4 <box_union>
3401d322:	ed87 0a02 	vstr	s0, [r7, #8]
 if (I == 0 || U == 0)
3401d326:	edd7 7a03 	vldr	s15, [r7, #12]
3401d32a:	eef5 7a40 	vcmp.f32	s15, #0.0
3401d32e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d332:	d006      	beq.n	3401d342 <vision_models_box_iou+0x3e>
3401d334:	edd7 7a02 	vldr	s15, [r7, #8]
3401d338:	eef5 7a40 	vcmp.f32	s15, #0.0
3401d33c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401d340:	d102      	bne.n	3401d348 <vision_models_box_iou+0x44>
  {
    return 0;
3401d342:	eddf 6a08 	vldr	s13, [pc, #32]	@ 3401d364 <vision_models_box_iou+0x60>
3401d346:	e005      	b.n	3401d354 <vision_models_box_iou+0x50>
  }
  return (I / U);
3401d348:	ed97 7a03 	vldr	s14, [r7, #12]
3401d34c:	edd7 7a02 	vldr	s15, [r7, #8]
3401d350:	eec7 6a27 	vdiv.f32	s13, s14, s15
}
3401d354:	eef0 7a66 	vmov.f32	s15, s13
3401d358:	eeb0 0a67 	vmov.f32	s0, s15
3401d35c:	3710      	adds	r7, #16
3401d35e:	46bd      	mov	sp, r7
3401d360:	bd80      	pop	{r7, pc}
3401d362:	bf00      	nop
3401d364:	00000000 	.word	0x00000000

3401d368 <ll_aton_static_checks>:
 *  Used to exit from LL_Streng_Wait() in case epoch locks
 * @{
 */

static inline void ll_aton_static_checks(void)
{
3401d368:	b580      	push	{r7, lr}
3401d36a:	b082      	sub	sp, #8
3401d36c:	af02      	add	r7, sp, #8
  static char done = 0;

  if (done != 0)
3401d36e:	4b27      	ldr	r3, [pc, #156]	@ (3401d40c <ll_aton_static_checks+0xa4>)
3401d370:	781b      	ldrb	r3, [r3, #0]
3401d372:	2b00      	cmp	r3, #0
3401d374:	d146      	bne.n	3401d404 <ll_aton_static_checks+0x9c>
    return;
  done = 1;
3401d376:	4b25      	ldr	r3, [pc, #148]	@ (3401d40c <ll_aton_static_checks+0xa4>)
3401d378:	2201      	movs	r2, #1
3401d37a:	701a      	strb	r2, [r3, #0]
  LL_ATON_ASSERT(ATONN_CONST_SRCPORT(S, J, U, I, P) == __atonn_getSrcPortID(S, J, U, I, P))
#define ASSERT_ATONN_DSTPORT(S, J, U, I, P)                                                                            \
  LL_ATON_ASSERT(ATONN_CONST_DSTPORT(S, J, U, I, P) == __atonn_getDstPortID(S, J, U, I, P))

#if ATON_STRENG_NUM > 1
  ASSERT_ATONN_SRCPORT(STRSWITCH, 0, STRENG, 1, 0);
3401d37c:	2300      	movs	r3, #0
3401d37e:	9300      	str	r3, [sp, #0]
3401d380:	2301      	movs	r3, #1
3401d382:	2200      	movs	r2, #0
3401d384:	2100      	movs	r1, #0
3401d386:	2000      	movs	r0, #0
3401d388:	f000 fc58 	bl	3401dc3c <__atonn_getSrcPortID>
3401d38c:	4603      	mov	r3, r0
3401d38e:	2b01      	cmp	r3, #1
3401d390:	d005      	beq.n	3401d39e <ll_aton_static_checks+0x36>
3401d392:	4b1f      	ldr	r3, [pc, #124]	@ (3401d410 <ll_aton_static_checks+0xa8>)
3401d394:	4a1f      	ldr	r2, [pc, #124]	@ (3401d414 <ll_aton_static_checks+0xac>)
3401d396:	214c      	movs	r1, #76	@ 0x4c
3401d398:	481f      	ldr	r0, [pc, #124]	@ (3401d418 <ll_aton_static_checks+0xb0>)
3401d39a:	f002 ff49 	bl	34020230 <__assert_func>
  ASSERT_ATONN_DSTPORT(STRSWITCH, 0, STRENG, 1, 0);
3401d39e:	2300      	movs	r3, #0
3401d3a0:	9300      	str	r3, [sp, #0]
3401d3a2:	2301      	movs	r3, #1
3401d3a4:	2200      	movs	r2, #0
3401d3a6:	2100      	movs	r1, #0
3401d3a8:	2000      	movs	r0, #0
3401d3aa:	f000 fd37 	bl	3401de1c <__atonn_getDstPortID>
3401d3ae:	4603      	mov	r3, r0
3401d3b0:	2b0c      	cmp	r3, #12
3401d3b2:	d005      	beq.n	3401d3c0 <ll_aton_static_checks+0x58>
3401d3b4:	4b19      	ldr	r3, [pc, #100]	@ (3401d41c <ll_aton_static_checks+0xb4>)
3401d3b6:	4a17      	ldr	r2, [pc, #92]	@ (3401d414 <ll_aton_static_checks+0xac>)
3401d3b8:	214d      	movs	r1, #77	@ 0x4d
3401d3ba:	4817      	ldr	r0, [pc, #92]	@ (3401d418 <ll_aton_static_checks+0xb0>)
3401d3bc:	f002 ff38 	bl	34020230 <__assert_func>
#endif
#if ATON_STRENG_NUM > 2
  ASSERT_ATONN_SRCPORT(STRSWITCH, 0, STRENG, 2, 0);
3401d3c0:	2300      	movs	r3, #0
3401d3c2:	9300      	str	r3, [sp, #0]
3401d3c4:	2302      	movs	r3, #2
3401d3c6:	2200      	movs	r2, #0
3401d3c8:	2100      	movs	r1, #0
3401d3ca:	2000      	movs	r0, #0
3401d3cc:	f000 fc36 	bl	3401dc3c <__atonn_getSrcPortID>
3401d3d0:	4603      	mov	r3, r0
3401d3d2:	2b02      	cmp	r3, #2
3401d3d4:	d005      	beq.n	3401d3e2 <ll_aton_static_checks+0x7a>
3401d3d6:	4b12      	ldr	r3, [pc, #72]	@ (3401d420 <ll_aton_static_checks+0xb8>)
3401d3d8:	4a0e      	ldr	r2, [pc, #56]	@ (3401d414 <ll_aton_static_checks+0xac>)
3401d3da:	2150      	movs	r1, #80	@ 0x50
3401d3dc:	480e      	ldr	r0, [pc, #56]	@ (3401d418 <ll_aton_static_checks+0xb0>)
3401d3de:	f002 ff27 	bl	34020230 <__assert_func>
  ASSERT_ATONN_DSTPORT(STRSWITCH, 0, STRENG, 2, 0);
3401d3e2:	2300      	movs	r3, #0
3401d3e4:	9300      	str	r3, [sp, #0]
3401d3e6:	2302      	movs	r3, #2
3401d3e8:	2200      	movs	r2, #0
3401d3ea:	2100      	movs	r1, #0
3401d3ec:	2000      	movs	r0, #0
3401d3ee:	f000 fd15 	bl	3401de1c <__atonn_getDstPortID>
3401d3f2:	4603      	mov	r3, r0
3401d3f4:	2b10      	cmp	r3, #16
3401d3f6:	d006      	beq.n	3401d406 <ll_aton_static_checks+0x9e>
3401d3f8:	4b0a      	ldr	r3, [pc, #40]	@ (3401d424 <ll_aton_static_checks+0xbc>)
3401d3fa:	4a06      	ldr	r2, [pc, #24]	@ (3401d414 <ll_aton_static_checks+0xac>)
3401d3fc:	2151      	movs	r1, #81	@ 0x51
3401d3fe:	4806      	ldr	r0, [pc, #24]	@ (3401d418 <ll_aton_static_checks+0xb0>)
3401d400:	f002 ff16 	bl	34020230 <__assert_func>
    return;
3401d404:	bf00      	nop

#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)

#undef ASSERT_ATONN_SRCPORT
#undef ASSERT_ATONN_DSTPORT
}
3401d406:	46bd      	mov	sp, r7
3401d408:	bd80      	pop	{r7, pc}
3401d40a:	bf00      	nop
3401d40c:	34053dac 	.word	0x34053dac
3401d410:	34024610 	.word	0x34024610
3401d414:	3403304c 	.word	0x3403304c
3401d418:	3402464c 	.word	0x3402464c
3401d41c:	340246a4 	.word	0x340246a4
3401d420:	340246f0 	.word	0x340246f0
3401d424:	3402472c 	.word	0x3402472c

3401d428 <LL_ATON_Init>:
/**
 * @brief  ATON global initialization. Initializes clocks and bus interfaces. Must be called before anything else
 * @retval Always zero
 */
int LL_ATON_Init(void)
{
3401d428:	b590      	push	{r4, r7, lr}
3401d42a:	b08b      	sub	sp, #44	@ 0x2c
3401d42c:	af08      	add	r7, sp, #32
  uint32_t t;
  int i;

  ll_aton_static_checks();
3401d42e:	f7ff ff9b 	bl	3401d368 <ll_aton_static_checks>

  /* Clear pipeline */
  t = ATON_CLKCTRL_CTRL_GET(0);
3401d432:	4b97      	ldr	r3, [pc, #604]	@ (3401d690 <LL_ATON_Init+0x268>)
3401d434:	681b      	ldr	r3, [r3, #0]
3401d436:	607b      	str	r3, [r7, #4]
  t = ATON_CLKCTRL_CTRL_SET_CLR(t, 1);
3401d438:	687b      	ldr	r3, [r7, #4]
3401d43a:	f043 0302 	orr.w	r3, r3, #2
3401d43e:	607b      	str	r3, [r7, #4]
  ATON_CLKCTRL_CTRL_SET(0, t);
3401d440:	4a93      	ldr	r2, [pc, #588]	@ (3401d690 <LL_ATON_Init+0x268>)
3401d442:	687b      	ldr	r3, [r7, #4]
3401d444:	6013      	str	r3, [r2, #0]

  /* Enable all ATON clocks */
  ATON_CLKCTRL_CTRL_SET(0, 1);
3401d446:	4b92      	ldr	r3, [pc, #584]	@ (3401d690 <LL_ATON_Init+0x268>)
3401d448:	2201      	movs	r2, #1
3401d44a:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES0_SET(0, 0xffffffff);
3401d44c:	4b91      	ldr	r3, [pc, #580]	@ (3401d694 <LL_ATON_Init+0x26c>)
3401d44e:	f04f 32ff 	mov.w	r2, #4294967295
3401d452:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES1_SET(0, 0xffffffff);
3401d454:	4b90      	ldr	r3, [pc, #576]	@ (3401d698 <LL_ATON_Init+0x270>)
3401d456:	f04f 32ff 	mov.w	r2, #4294967295
3401d45a:	601a      	str	r2, [r3, #0]

#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ATON_CLKCTRL_BGATES_SET(0, (1 << ATON_EPOCHCTRL_CLKB_CLK(0)));
#else
  ATON_CLKCTRL_BGATES_SET(0, 0x0);
3401d45c:	4b8f      	ldr	r3, [pc, #572]	@ (3401d69c <LL_ATON_Init+0x274>)
3401d45e:	2200      	movs	r2, #0
3401d460:	601a      	str	r2, [r3, #0]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0xffffffff);
#endif

  /* Check that RTL and ATON.h match. Only check first unit */
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
3401d462:	4b8f      	ldr	r3, [pc, #572]	@ (3401d6a0 <LL_ATON_Init+0x278>)
3401d464:	681b      	ldr	r3, [r3, #0]
3401d466:	607b      	str	r3, [r7, #4]
3401d468:	687b      	ldr	r3, [r7, #4]
3401d46a:	2b00      	cmp	r3, #0
3401d46c:	d0f9      	beq.n	3401d462 <LL_ATON_Init+0x3a>
3401d46e:	687b      	ldr	r3, [r7, #4]
3401d470:	b2db      	uxtb	r3, r3
3401d472:	2b01      	cmp	r3, #1
3401d474:	d10a      	bne.n	3401d48c <LL_ATON_Init+0x64>
3401d476:	687b      	ldr	r3, [r7, #4]
3401d478:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d47c:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
3401d480:	d104      	bne.n	3401d48c <LL_ATON_Init+0x64>
3401d482:	687b      	ldr	r3, [r7, #4]
3401d484:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d488:	2b00      	cmp	r3, #0
3401d48a:	d02f      	beq.n	3401d4ec <LL_ATON_Init+0xc4>
3401d48c:	f004 faf6 	bl	34021a7c <__errno>
3401d490:	4603      	mov	r3, r0
3401d492:	681b      	ldr	r3, [r3, #0]
3401d494:	2b00      	cmp	r3, #0
3401d496:	d008      	beq.n	3401d4aa <LL_ATON_Init+0x82>
3401d498:	f004 faf0 	bl	34021a7c <__errno>
3401d49c:	4603      	mov	r3, r0
3401d49e:	681b      	ldr	r3, [r3, #0]
3401d4a0:	4618      	mov	r0, r3
3401d4a2:	f004 fa85 	bl	340219b0 <strerror>
3401d4a6:	4603      	mov	r3, r0
3401d4a8:	e000      	b.n	3401d4ac <LL_ATON_Init+0x84>
3401d4aa:	4b7e      	ldr	r3, [pc, #504]	@ (3401d6a4 <LL_ATON_Init+0x27c>)
3401d4ac:	687a      	ldr	r2, [r7, #4]
3401d4ae:	b2d2      	uxtb	r2, r2
3401d4b0:	6879      	ldr	r1, [r7, #4]
3401d4b2:	0b09      	lsrs	r1, r1, #12
3401d4b4:	f001 010f 	and.w	r1, r1, #15
3401d4b8:	6878      	ldr	r0, [r7, #4]
3401d4ba:	0a00      	lsrs	r0, r0, #8
3401d4bc:	f000 000f 	and.w	r0, r0, #15
3401d4c0:	2400      	movs	r4, #0
3401d4c2:	9406      	str	r4, [sp, #24]
3401d4c4:	2405      	movs	r4, #5
3401d4c6:	9405      	str	r4, [sp, #20]
3401d4c8:	2401      	movs	r4, #1
3401d4ca:	9404      	str	r4, [sp, #16]
3401d4cc:	9003      	str	r0, [sp, #12]
3401d4ce:	9102      	str	r1, [sp, #8]
3401d4d0:	9201      	str	r2, [sp, #4]
3401d4d2:	4a75      	ldr	r2, [pc, #468]	@ (3401d6a8 <LL_ATON_Init+0x280>)
3401d4d4:	9200      	str	r2, [sp, #0]
3401d4d6:	22c7      	movs	r2, #199	@ 0xc7
3401d4d8:	4974      	ldr	r1, [pc, #464]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d4da:	4875      	ldr	r0, [pc, #468]	@ (3401d6b0 <LL_ATON_Init+0x288>)
3401d4dc:	f003 fee2 	bl	340212a4 <iprintf>
3401d4e0:	4b74      	ldr	r3, [pc, #464]	@ (3401d6b4 <LL_ATON_Init+0x28c>)
3401d4e2:	4a75      	ldr	r2, [pc, #468]	@ (3401d6b8 <LL_ATON_Init+0x290>)
3401d4e4:	21c7      	movs	r1, #199	@ 0xc7
3401d4e6:	4871      	ldr	r0, [pc, #452]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d4e8:	f002 fea2 	bl	34020230 <__assert_func>

#ifdef ATON_CONVACC_NUM
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
3401d4ec:	4b73      	ldr	r3, [pc, #460]	@ (3401d6bc <LL_ATON_Init+0x294>)
3401d4ee:	681b      	ldr	r3, [r3, #0]
3401d4f0:	607b      	str	r3, [r7, #4]
3401d4f2:	687b      	ldr	r3, [r7, #4]
3401d4f4:	2b00      	cmp	r3, #0
3401d4f6:	d0f9      	beq.n	3401d4ec <LL_ATON_Init+0xc4>
3401d4f8:	687b      	ldr	r3, [r7, #4]
3401d4fa:	b2db      	uxtb	r3, r3
3401d4fc:	2b17      	cmp	r3, #23
3401d4fe:	d10b      	bne.n	3401d518 <LL_ATON_Init+0xf0>
3401d500:	687b      	ldr	r3, [r7, #4]
3401d502:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d506:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
3401d50a:	d105      	bne.n	3401d518 <LL_ATON_Init+0xf0>
3401d50c:	687b      	ldr	r3, [r7, #4]
3401d50e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d512:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401d516:	d02f      	beq.n	3401d578 <LL_ATON_Init+0x150>
3401d518:	f004 fab0 	bl	34021a7c <__errno>
3401d51c:	4603      	mov	r3, r0
3401d51e:	681b      	ldr	r3, [r3, #0]
3401d520:	2b00      	cmp	r3, #0
3401d522:	d008      	beq.n	3401d536 <LL_ATON_Init+0x10e>
3401d524:	f004 faaa 	bl	34021a7c <__errno>
3401d528:	4603      	mov	r3, r0
3401d52a:	681b      	ldr	r3, [r3, #0]
3401d52c:	4618      	mov	r0, r3
3401d52e:	f004 fa3f 	bl	340219b0 <strerror>
3401d532:	4603      	mov	r3, r0
3401d534:	e000      	b.n	3401d538 <LL_ATON_Init+0x110>
3401d536:	4b5b      	ldr	r3, [pc, #364]	@ (3401d6a4 <LL_ATON_Init+0x27c>)
3401d538:	687a      	ldr	r2, [r7, #4]
3401d53a:	b2d2      	uxtb	r2, r2
3401d53c:	6879      	ldr	r1, [r7, #4]
3401d53e:	0b09      	lsrs	r1, r1, #12
3401d540:	f001 010f 	and.w	r1, r1, #15
3401d544:	6878      	ldr	r0, [r7, #4]
3401d546:	0a00      	lsrs	r0, r0, #8
3401d548:	f000 000f 	and.w	r0, r0, #15
3401d54c:	2401      	movs	r4, #1
3401d54e:	9406      	str	r4, [sp, #24]
3401d550:	2405      	movs	r4, #5
3401d552:	9405      	str	r4, [sp, #20]
3401d554:	2417      	movs	r4, #23
3401d556:	9404      	str	r4, [sp, #16]
3401d558:	9003      	str	r0, [sp, #12]
3401d55a:	9102      	str	r1, [sp, #8]
3401d55c:	9201      	str	r2, [sp, #4]
3401d55e:	4a58      	ldr	r2, [pc, #352]	@ (3401d6c0 <LL_ATON_Init+0x298>)
3401d560:	9200      	str	r2, [sp, #0]
3401d562:	22ca      	movs	r2, #202	@ 0xca
3401d564:	4951      	ldr	r1, [pc, #324]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d566:	4852      	ldr	r0, [pc, #328]	@ (3401d6b0 <LL_ATON_Init+0x288>)
3401d568:	f003 fe9c 	bl	340212a4 <iprintf>
3401d56c:	4b51      	ldr	r3, [pc, #324]	@ (3401d6b4 <LL_ATON_Init+0x28c>)
3401d56e:	4a52      	ldr	r2, [pc, #328]	@ (3401d6b8 <LL_ATON_Init+0x290>)
3401d570:	21ca      	movs	r1, #202	@ 0xca
3401d572:	484e      	ldr	r0, [pc, #312]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d574:	f002 fe5c 	bl	34020230 <__assert_func>
#endif

#ifdef ATON_POOL_NUM
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
3401d578:	4b52      	ldr	r3, [pc, #328]	@ (3401d6c4 <LL_ATON_Init+0x29c>)
3401d57a:	681b      	ldr	r3, [r3, #0]
3401d57c:	607b      	str	r3, [r7, #4]
3401d57e:	687b      	ldr	r3, [r7, #4]
3401d580:	2b00      	cmp	r3, #0
3401d582:	d0f9      	beq.n	3401d578 <LL_ATON_Init+0x150>
3401d584:	687b      	ldr	r3, [r7, #4]
3401d586:	b2db      	uxtb	r3, r3
3401d588:	2b1c      	cmp	r3, #28
3401d58a:	d10b      	bne.n	3401d5a4 <LL_ATON_Init+0x17c>
3401d58c:	687b      	ldr	r3, [r7, #4]
3401d58e:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d592:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d596:	d105      	bne.n	3401d5a4 <LL_ATON_Init+0x17c>
3401d598:	687b      	ldr	r3, [r7, #4]
3401d59a:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d59e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401d5a2:	d02f      	beq.n	3401d604 <LL_ATON_Init+0x1dc>
3401d5a4:	f004 fa6a 	bl	34021a7c <__errno>
3401d5a8:	4603      	mov	r3, r0
3401d5aa:	681b      	ldr	r3, [r3, #0]
3401d5ac:	2b00      	cmp	r3, #0
3401d5ae:	d008      	beq.n	3401d5c2 <LL_ATON_Init+0x19a>
3401d5b0:	f004 fa64 	bl	34021a7c <__errno>
3401d5b4:	4603      	mov	r3, r0
3401d5b6:	681b      	ldr	r3, [r3, #0]
3401d5b8:	4618      	mov	r0, r3
3401d5ba:	f004 f9f9 	bl	340219b0 <strerror>
3401d5be:	4603      	mov	r3, r0
3401d5c0:	e000      	b.n	3401d5c4 <LL_ATON_Init+0x19c>
3401d5c2:	4b38      	ldr	r3, [pc, #224]	@ (3401d6a4 <LL_ATON_Init+0x27c>)
3401d5c4:	687a      	ldr	r2, [r7, #4]
3401d5c6:	b2d2      	uxtb	r2, r2
3401d5c8:	6879      	ldr	r1, [r7, #4]
3401d5ca:	0b09      	lsrs	r1, r1, #12
3401d5cc:	f001 010f 	and.w	r1, r1, #15
3401d5d0:	6878      	ldr	r0, [r7, #4]
3401d5d2:	0a00      	lsrs	r0, r0, #8
3401d5d4:	f000 000f 	and.w	r0, r0, #15
3401d5d8:	2401      	movs	r4, #1
3401d5da:	9406      	str	r4, [sp, #24]
3401d5dc:	2401      	movs	r4, #1
3401d5de:	9405      	str	r4, [sp, #20]
3401d5e0:	241c      	movs	r4, #28
3401d5e2:	9404      	str	r4, [sp, #16]
3401d5e4:	9003      	str	r0, [sp, #12]
3401d5e6:	9102      	str	r1, [sp, #8]
3401d5e8:	9201      	str	r2, [sp, #4]
3401d5ea:	4a37      	ldr	r2, [pc, #220]	@ (3401d6c8 <LL_ATON_Init+0x2a0>)
3401d5ec:	9200      	str	r2, [sp, #0]
3401d5ee:	22ce      	movs	r2, #206	@ 0xce
3401d5f0:	492e      	ldr	r1, [pc, #184]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d5f2:	482f      	ldr	r0, [pc, #188]	@ (3401d6b0 <LL_ATON_Init+0x288>)
3401d5f4:	f003 fe56 	bl	340212a4 <iprintf>
3401d5f8:	4b2e      	ldr	r3, [pc, #184]	@ (3401d6b4 <LL_ATON_Init+0x28c>)
3401d5fa:	4a2f      	ldr	r2, [pc, #188]	@ (3401d6b8 <LL_ATON_Init+0x290>)
3401d5fc:	21ce      	movs	r1, #206	@ 0xce
3401d5fe:	482b      	ldr	r0, [pc, #172]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d600:	f002 fe16 	bl	34020230 <__assert_func>
#endif

#ifdef ATON_ARITH_NUM
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
3401d604:	4b31      	ldr	r3, [pc, #196]	@ (3401d6cc <LL_ATON_Init+0x2a4>)
3401d606:	681b      	ldr	r3, [r3, #0]
3401d608:	607b      	str	r3, [r7, #4]
3401d60a:	687b      	ldr	r3, [r7, #4]
3401d60c:	2b00      	cmp	r3, #0
3401d60e:	d0f9      	beq.n	3401d604 <LL_ATON_Init+0x1dc>
3401d610:	687b      	ldr	r3, [r7, #4]
3401d612:	b2db      	uxtb	r3, r3
3401d614:	2b1a      	cmp	r3, #26
3401d616:	d10a      	bne.n	3401d62e <LL_ATON_Init+0x206>
3401d618:	687b      	ldr	r3, [r7, #4]
3401d61a:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d61e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d622:	d104      	bne.n	3401d62e <LL_ATON_Init+0x206>
3401d624:	687b      	ldr	r3, [r7, #4]
3401d626:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d62a:	2b00      	cmp	r3, #0
3401d62c:	d052      	beq.n	3401d6d4 <LL_ATON_Init+0x2ac>
3401d62e:	f004 fa25 	bl	34021a7c <__errno>
3401d632:	4603      	mov	r3, r0
3401d634:	681b      	ldr	r3, [r3, #0]
3401d636:	2b00      	cmp	r3, #0
3401d638:	d008      	beq.n	3401d64c <LL_ATON_Init+0x224>
3401d63a:	f004 fa1f 	bl	34021a7c <__errno>
3401d63e:	4603      	mov	r3, r0
3401d640:	681b      	ldr	r3, [r3, #0]
3401d642:	4618      	mov	r0, r3
3401d644:	f004 f9b4 	bl	340219b0 <strerror>
3401d648:	4603      	mov	r3, r0
3401d64a:	e000      	b.n	3401d64e <LL_ATON_Init+0x226>
3401d64c:	4b15      	ldr	r3, [pc, #84]	@ (3401d6a4 <LL_ATON_Init+0x27c>)
3401d64e:	687a      	ldr	r2, [r7, #4]
3401d650:	b2d2      	uxtb	r2, r2
3401d652:	6879      	ldr	r1, [r7, #4]
3401d654:	0b09      	lsrs	r1, r1, #12
3401d656:	f001 010f 	and.w	r1, r1, #15
3401d65a:	6878      	ldr	r0, [r7, #4]
3401d65c:	0a00      	lsrs	r0, r0, #8
3401d65e:	f000 000f 	and.w	r0, r0, #15
3401d662:	2400      	movs	r4, #0
3401d664:	9406      	str	r4, [sp, #24]
3401d666:	2401      	movs	r4, #1
3401d668:	9405      	str	r4, [sp, #20]
3401d66a:	241a      	movs	r4, #26
3401d66c:	9404      	str	r4, [sp, #16]
3401d66e:	9003      	str	r0, [sp, #12]
3401d670:	9102      	str	r1, [sp, #8]
3401d672:	9201      	str	r2, [sp, #4]
3401d674:	4a16      	ldr	r2, [pc, #88]	@ (3401d6d0 <LL_ATON_Init+0x2a8>)
3401d676:	9200      	str	r2, [sp, #0]
3401d678:	22d2      	movs	r2, #210	@ 0xd2
3401d67a:	490c      	ldr	r1, [pc, #48]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d67c:	480c      	ldr	r0, [pc, #48]	@ (3401d6b0 <LL_ATON_Init+0x288>)
3401d67e:	f003 fe11 	bl	340212a4 <iprintf>
3401d682:	4b0c      	ldr	r3, [pc, #48]	@ (3401d6b4 <LL_ATON_Init+0x28c>)
3401d684:	4a0c      	ldr	r2, [pc, #48]	@ (3401d6b8 <LL_ATON_Init+0x290>)
3401d686:	21d2      	movs	r1, #210	@ 0xd2
3401d688:	4808      	ldr	r0, [pc, #32]	@ (3401d6ac <LL_ATON_Init+0x284>)
3401d68a:	f002 fdd1 	bl	34020230 <__assert_func>
3401d68e:	bf00      	nop
3401d690:	580e0000 	.word	0x580e0000
3401d694:	580e0008 	.word	0x580e0008
3401d698:	580e000c 	.word	0x580e000c
3401d69c:	580e0010 	.word	0x580e0010
3401d6a0:	580e5004 	.word	0x580e5004
3401d6a4:	34024778 	.word	0x34024778
3401d6a8:	340247e4 	.word	0x340247e4
3401d6ac:	3402464c 	.word	0x3402464c
3401d6b0:	34024780 	.word	0x34024780
3401d6b4:	340247ec 	.word	0x340247ec
3401d6b8:	3403303c 	.word	0x3403303c
3401d6bc:	580ef004 	.word	0x580ef004
3401d6c0:	340247f0 	.word	0x340247f0
3401d6c4:	580fb004 	.word	0x580fb004
3401d6c8:	340247f8 	.word	0x340247f8
3401d6cc:	580f7004 	.word	0x580f7004
3401d6d0:	34024800 	.word	0x34024800
#endif

#ifdef ATON_ACTIV_NUM
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
3401d6d4:	4b9e      	ldr	r3, [pc, #632]	@ (3401d950 <LL_ATON_Init+0x528>)
3401d6d6:	681b      	ldr	r3, [r3, #0]
3401d6d8:	607b      	str	r3, [r7, #4]
3401d6da:	687b      	ldr	r3, [r7, #4]
3401d6dc:	2b00      	cmp	r3, #0
3401d6de:	d0f9      	beq.n	3401d6d4 <LL_ATON_Init+0x2ac>
3401d6e0:	687b      	ldr	r3, [r7, #4]
3401d6e2:	b2db      	uxtb	r3, r3
3401d6e4:	2b1b      	cmp	r3, #27
3401d6e6:	d10b      	bne.n	3401d700 <LL_ATON_Init+0x2d8>
3401d6e8:	687b      	ldr	r3, [r7, #4]
3401d6ea:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d6ee:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d6f2:	d105      	bne.n	3401d700 <LL_ATON_Init+0x2d8>
3401d6f4:	687b      	ldr	r3, [r7, #4]
3401d6f6:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d6fa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401d6fe:	d02f      	beq.n	3401d760 <LL_ATON_Init+0x338>
3401d700:	f004 f9bc 	bl	34021a7c <__errno>
3401d704:	4603      	mov	r3, r0
3401d706:	681b      	ldr	r3, [r3, #0]
3401d708:	2b00      	cmp	r3, #0
3401d70a:	d008      	beq.n	3401d71e <LL_ATON_Init+0x2f6>
3401d70c:	f004 f9b6 	bl	34021a7c <__errno>
3401d710:	4603      	mov	r3, r0
3401d712:	681b      	ldr	r3, [r3, #0]
3401d714:	4618      	mov	r0, r3
3401d716:	f004 f94b 	bl	340219b0 <strerror>
3401d71a:	4603      	mov	r3, r0
3401d71c:	e000      	b.n	3401d720 <LL_ATON_Init+0x2f8>
3401d71e:	4b8d      	ldr	r3, [pc, #564]	@ (3401d954 <LL_ATON_Init+0x52c>)
3401d720:	687a      	ldr	r2, [r7, #4]
3401d722:	b2d2      	uxtb	r2, r2
3401d724:	6879      	ldr	r1, [r7, #4]
3401d726:	0b09      	lsrs	r1, r1, #12
3401d728:	f001 010f 	and.w	r1, r1, #15
3401d72c:	6878      	ldr	r0, [r7, #4]
3401d72e:	0a00      	lsrs	r0, r0, #8
3401d730:	f000 000f 	and.w	r0, r0, #15
3401d734:	2401      	movs	r4, #1
3401d736:	9406      	str	r4, [sp, #24]
3401d738:	2401      	movs	r4, #1
3401d73a:	9405      	str	r4, [sp, #20]
3401d73c:	241b      	movs	r4, #27
3401d73e:	9404      	str	r4, [sp, #16]
3401d740:	9003      	str	r0, [sp, #12]
3401d742:	9102      	str	r1, [sp, #8]
3401d744:	9201      	str	r2, [sp, #4]
3401d746:	4a84      	ldr	r2, [pc, #528]	@ (3401d958 <LL_ATON_Init+0x530>)
3401d748:	9200      	str	r2, [sp, #0]
3401d74a:	22d6      	movs	r2, #214	@ 0xd6
3401d74c:	4983      	ldr	r1, [pc, #524]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d74e:	4884      	ldr	r0, [pc, #528]	@ (3401d960 <LL_ATON_Init+0x538>)
3401d750:	f003 fda8 	bl	340212a4 <iprintf>
3401d754:	4b83      	ldr	r3, [pc, #524]	@ (3401d964 <LL_ATON_Init+0x53c>)
3401d756:	4a84      	ldr	r2, [pc, #528]	@ (3401d968 <LL_ATON_Init+0x540>)
3401d758:	21d6      	movs	r1, #214	@ 0xd6
3401d75a:	4880      	ldr	r0, [pc, #512]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d75c:	f002 fd68 	bl	34020230 <__assert_func>
#endif

#ifdef ATON_DECUN_NUM
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
3401d760:	4b82      	ldr	r3, [pc, #520]	@ (3401d96c <LL_ATON_Init+0x544>)
3401d762:	681b      	ldr	r3, [r3, #0]
3401d764:	607b      	str	r3, [r7, #4]
3401d766:	687b      	ldr	r3, [r7, #4]
3401d768:	2b00      	cmp	r3, #0
3401d76a:	d0f9      	beq.n	3401d760 <LL_ATON_Init+0x338>
3401d76c:	687b      	ldr	r3, [r7, #4]
3401d76e:	b2db      	uxtb	r3, r3
3401d770:	2b19      	cmp	r3, #25
3401d772:	d10b      	bne.n	3401d78c <LL_ATON_Init+0x364>
3401d774:	687b      	ldr	r3, [r7, #4]
3401d776:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d77a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d77e:	d105      	bne.n	3401d78c <LL_ATON_Init+0x364>
3401d780:	687b      	ldr	r3, [r7, #4]
3401d782:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d786:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
3401d78a:	d02f      	beq.n	3401d7ec <LL_ATON_Init+0x3c4>
3401d78c:	f004 f976 	bl	34021a7c <__errno>
3401d790:	4603      	mov	r3, r0
3401d792:	681b      	ldr	r3, [r3, #0]
3401d794:	2b00      	cmp	r3, #0
3401d796:	d008      	beq.n	3401d7aa <LL_ATON_Init+0x382>
3401d798:	f004 f970 	bl	34021a7c <__errno>
3401d79c:	4603      	mov	r3, r0
3401d79e:	681b      	ldr	r3, [r3, #0]
3401d7a0:	4618      	mov	r0, r3
3401d7a2:	f004 f905 	bl	340219b0 <strerror>
3401d7a6:	4603      	mov	r3, r0
3401d7a8:	e000      	b.n	3401d7ac <LL_ATON_Init+0x384>
3401d7aa:	4b6a      	ldr	r3, [pc, #424]	@ (3401d954 <LL_ATON_Init+0x52c>)
3401d7ac:	687a      	ldr	r2, [r7, #4]
3401d7ae:	b2d2      	uxtb	r2, r2
3401d7b0:	6879      	ldr	r1, [r7, #4]
3401d7b2:	0b09      	lsrs	r1, r1, #12
3401d7b4:	f001 010f 	and.w	r1, r1, #15
3401d7b8:	6878      	ldr	r0, [r7, #4]
3401d7ba:	0a00      	lsrs	r0, r0, #8
3401d7bc:	f000 000f 	and.w	r0, r0, #15
3401d7c0:	240a      	movs	r4, #10
3401d7c2:	9406      	str	r4, [sp, #24]
3401d7c4:	2401      	movs	r4, #1
3401d7c6:	9405      	str	r4, [sp, #20]
3401d7c8:	2419      	movs	r4, #25
3401d7ca:	9404      	str	r4, [sp, #16]
3401d7cc:	9003      	str	r0, [sp, #12]
3401d7ce:	9102      	str	r1, [sp, #8]
3401d7d0:	9201      	str	r2, [sp, #4]
3401d7d2:	4a67      	ldr	r2, [pc, #412]	@ (3401d970 <LL_ATON_Init+0x548>)
3401d7d4:	9200      	str	r2, [sp, #0]
3401d7d6:	22da      	movs	r2, #218	@ 0xda
3401d7d8:	4960      	ldr	r1, [pc, #384]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d7da:	4861      	ldr	r0, [pc, #388]	@ (3401d960 <LL_ATON_Init+0x538>)
3401d7dc:	f003 fd62 	bl	340212a4 <iprintf>
3401d7e0:	4b60      	ldr	r3, [pc, #384]	@ (3401d964 <LL_ATON_Init+0x53c>)
3401d7e2:	4a61      	ldr	r2, [pc, #388]	@ (3401d968 <LL_ATON_Init+0x540>)
3401d7e4:	21da      	movs	r1, #218	@ 0xda
3401d7e6:	485d      	ldr	r0, [pc, #372]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d7e8:	f002 fd22 	bl	34020230 <__assert_func>
#endif

#ifdef ATON_EPOCHCTRL_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
3401d7ec:	4b61      	ldr	r3, [pc, #388]	@ (3401d974 <LL_ATON_Init+0x54c>)
3401d7ee:	681b      	ldr	r3, [r3, #0]
3401d7f0:	607b      	str	r3, [r7, #4]
3401d7f2:	687b      	ldr	r3, [r7, #4]
3401d7f4:	2b00      	cmp	r3, #0
3401d7f6:	d0f9      	beq.n	3401d7ec <LL_ATON_Init+0x3c4>
3401d7f8:	687b      	ldr	r3, [r7, #4]
3401d7fa:	b2db      	uxtb	r3, r3
3401d7fc:	2b21      	cmp	r3, #33	@ 0x21
3401d7fe:	d10b      	bne.n	3401d818 <LL_ATON_Init+0x3f0>
3401d800:	687b      	ldr	r3, [r7, #4]
3401d802:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d806:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d80a:	d105      	bne.n	3401d818 <LL_ATON_Init+0x3f0>
3401d80c:	687b      	ldr	r3, [r7, #4]
3401d80e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d812:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401d816:	d02f      	beq.n	3401d878 <LL_ATON_Init+0x450>
3401d818:	f004 f930 	bl	34021a7c <__errno>
3401d81c:	4603      	mov	r3, r0
3401d81e:	681b      	ldr	r3, [r3, #0]
3401d820:	2b00      	cmp	r3, #0
3401d822:	d008      	beq.n	3401d836 <LL_ATON_Init+0x40e>
3401d824:	f004 f92a 	bl	34021a7c <__errno>
3401d828:	4603      	mov	r3, r0
3401d82a:	681b      	ldr	r3, [r3, #0]
3401d82c:	4618      	mov	r0, r3
3401d82e:	f004 f8bf 	bl	340219b0 <strerror>
3401d832:	4603      	mov	r3, r0
3401d834:	e000      	b.n	3401d838 <LL_ATON_Init+0x410>
3401d836:	4b47      	ldr	r3, [pc, #284]	@ (3401d954 <LL_ATON_Init+0x52c>)
3401d838:	687a      	ldr	r2, [r7, #4]
3401d83a:	b2d2      	uxtb	r2, r2
3401d83c:	6879      	ldr	r1, [r7, #4]
3401d83e:	0b09      	lsrs	r1, r1, #12
3401d840:	f001 010f 	and.w	r1, r1, #15
3401d844:	6878      	ldr	r0, [r7, #4]
3401d846:	0a00      	lsrs	r0, r0, #8
3401d848:	f000 000f 	and.w	r0, r0, #15
3401d84c:	2401      	movs	r4, #1
3401d84e:	9406      	str	r4, [sp, #24]
3401d850:	2401      	movs	r4, #1
3401d852:	9405      	str	r4, [sp, #20]
3401d854:	2421      	movs	r4, #33	@ 0x21
3401d856:	9404      	str	r4, [sp, #16]
3401d858:	9003      	str	r0, [sp, #12]
3401d85a:	9102      	str	r1, [sp, #8]
3401d85c:	9201      	str	r2, [sp, #4]
3401d85e:	4a46      	ldr	r2, [pc, #280]	@ (3401d978 <LL_ATON_Init+0x550>)
3401d860:	9200      	str	r2, [sp, #0]
3401d862:	22de      	movs	r2, #222	@ 0xde
3401d864:	493d      	ldr	r1, [pc, #244]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d866:	483e      	ldr	r0, [pc, #248]	@ (3401d960 <LL_ATON_Init+0x538>)
3401d868:	f003 fd1c 	bl	340212a4 <iprintf>
3401d86c:	4b3d      	ldr	r3, [pc, #244]	@ (3401d964 <LL_ATON_Init+0x53c>)
3401d86e:	4a3e      	ldr	r2, [pc, #248]	@ (3401d968 <LL_ATON_Init+0x540>)
3401d870:	21de      	movs	r1, #222	@ 0xde
3401d872:	483a      	ldr	r0, [pc, #232]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d874:	f002 fcdc 	bl	34020230 <__assert_func>
#endif

#ifdef ATON_RECBUF_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
3401d878:	4b40      	ldr	r3, [pc, #256]	@ (3401d97c <LL_ATON_Init+0x554>)
3401d87a:	681b      	ldr	r3, [r3, #0]
3401d87c:	607b      	str	r3, [r7, #4]
3401d87e:	687b      	ldr	r3, [r7, #4]
3401d880:	2b00      	cmp	r3, #0
3401d882:	d0f9      	beq.n	3401d878 <LL_ATON_Init+0x450>
3401d884:	687b      	ldr	r3, [r7, #4]
3401d886:	b2db      	uxtb	r3, r3
3401d888:	2b20      	cmp	r3, #32
3401d88a:	d10b      	bne.n	3401d8a4 <LL_ATON_Init+0x47c>
3401d88c:	687b      	ldr	r3, [r7, #4]
3401d88e:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d892:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3401d896:	d105      	bne.n	3401d8a4 <LL_ATON_Init+0x47c>
3401d898:	687b      	ldr	r3, [r7, #4]
3401d89a:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d89e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401d8a2:	d02f      	beq.n	3401d904 <LL_ATON_Init+0x4dc>
3401d8a4:	f004 f8ea 	bl	34021a7c <__errno>
3401d8a8:	4603      	mov	r3, r0
3401d8aa:	681b      	ldr	r3, [r3, #0]
3401d8ac:	2b00      	cmp	r3, #0
3401d8ae:	d008      	beq.n	3401d8c2 <LL_ATON_Init+0x49a>
3401d8b0:	f004 f8e4 	bl	34021a7c <__errno>
3401d8b4:	4603      	mov	r3, r0
3401d8b6:	681b      	ldr	r3, [r3, #0]
3401d8b8:	4618      	mov	r0, r3
3401d8ba:	f004 f879 	bl	340219b0 <strerror>
3401d8be:	4603      	mov	r3, r0
3401d8c0:	e000      	b.n	3401d8c4 <LL_ATON_Init+0x49c>
3401d8c2:	4b24      	ldr	r3, [pc, #144]	@ (3401d954 <LL_ATON_Init+0x52c>)
3401d8c4:	687a      	ldr	r2, [r7, #4]
3401d8c6:	b2d2      	uxtb	r2, r2
3401d8c8:	6879      	ldr	r1, [r7, #4]
3401d8ca:	0b09      	lsrs	r1, r1, #12
3401d8cc:	f001 010f 	and.w	r1, r1, #15
3401d8d0:	6878      	ldr	r0, [r7, #4]
3401d8d2:	0a00      	lsrs	r0, r0, #8
3401d8d4:	f000 000f 	and.w	r0, r0, #15
3401d8d8:	2402      	movs	r4, #2
3401d8da:	9406      	str	r4, [sp, #24]
3401d8dc:	2403      	movs	r4, #3
3401d8de:	9405      	str	r4, [sp, #20]
3401d8e0:	2420      	movs	r4, #32
3401d8e2:	9404      	str	r4, [sp, #16]
3401d8e4:	9003      	str	r0, [sp, #12]
3401d8e6:	9102      	str	r1, [sp, #8]
3401d8e8:	9201      	str	r2, [sp, #4]
3401d8ea:	4a25      	ldr	r2, [pc, #148]	@ (3401d980 <LL_ATON_Init+0x558>)
3401d8ec:	9200      	str	r2, [sp, #0]
3401d8ee:	22e2      	movs	r2, #226	@ 0xe2
3401d8f0:	491a      	ldr	r1, [pc, #104]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d8f2:	481b      	ldr	r0, [pc, #108]	@ (3401d960 <LL_ATON_Init+0x538>)
3401d8f4:	f003 fcd6 	bl	340212a4 <iprintf>
3401d8f8:	4b1a      	ldr	r3, [pc, #104]	@ (3401d964 <LL_ATON_Init+0x53c>)
3401d8fa:	4a1b      	ldr	r2, [pc, #108]	@ (3401d968 <LL_ATON_Init+0x540>)
3401d8fc:	21e2      	movs	r1, #226	@ 0xe2
3401d8fe:	4817      	ldr	r0, [pc, #92]	@ (3401d95c <LL_ATON_Init+0x534>)
3401d900:	f002 fc96 	bl	34020230 <__assert_func>

#ifdef ATON_IMC_NUM
  ASSERT_UNITS_VERS_W_MSG(IMC, t);
#endif

  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
3401d904:	4b1f      	ldr	r3, [pc, #124]	@ (3401d984 <LL_ATON_Init+0x55c>)
3401d906:	681b      	ldr	r3, [r3, #0]
3401d908:	607b      	str	r3, [r7, #4]
3401d90a:	687b      	ldr	r3, [r7, #4]
3401d90c:	2b00      	cmp	r3, #0
3401d90e:	d0f9      	beq.n	3401d904 <LL_ATON_Init+0x4dc>
3401d910:	687b      	ldr	r3, [r7, #4]
3401d912:	b2db      	uxtb	r3, r3
3401d914:	2b1f      	cmp	r3, #31
3401d916:	d10b      	bne.n	3401d930 <LL_ATON_Init+0x508>
3401d918:	687b      	ldr	r3, [r7, #4]
3401d91a:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d91e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d922:	d105      	bne.n	3401d930 <LL_ATON_Init+0x508>
3401d924:	687b      	ldr	r3, [r7, #4]
3401d926:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d92a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401d92e:	d04c      	beq.n	3401d9ca <LL_ATON_Init+0x5a2>
3401d930:	f004 f8a4 	bl	34021a7c <__errno>
3401d934:	4603      	mov	r3, r0
3401d936:	681b      	ldr	r3, [r3, #0]
3401d938:	2b00      	cmp	r3, #0
3401d93a:	d025      	beq.n	3401d988 <LL_ATON_Init+0x560>
3401d93c:	f004 f89e 	bl	34021a7c <__errno>
3401d940:	4603      	mov	r3, r0
3401d942:	681b      	ldr	r3, [r3, #0]
3401d944:	4618      	mov	r0, r3
3401d946:	f004 f833 	bl	340219b0 <strerror>
3401d94a:	4603      	mov	r3, r0
3401d94c:	e01d      	b.n	3401d98a <LL_ATON_Init+0x562>
3401d94e:	bf00      	nop
3401d950:	580f5004 	.word	0x580f5004
3401d954:	34024778 	.word	0x34024778
3401d958:	34024808 	.word	0x34024808
3401d95c:	3402464c 	.word	0x3402464c
3401d960:	34024780 	.word	0x34024780
3401d964:	340247ec 	.word	0x340247ec
3401d968:	3403303c 	.word	0x3403303c
3401d96c:	580f3004 	.word	0x580f3004
3401d970:	34024810 	.word	0x34024810
3401d974:	580fe004 	.word	0x580fe004
3401d978:	34024818 	.word	0x34024818
3401d97c:	580fd004 	.word	0x580fd004
3401d980:	34024824 	.word	0x34024824
3401d984:	580e0004 	.word	0x580e0004
3401d988:	4b85      	ldr	r3, [pc, #532]	@ (3401dba0 <LL_ATON_Init+0x778>)
3401d98a:	687a      	ldr	r2, [r7, #4]
3401d98c:	b2d2      	uxtb	r2, r2
3401d98e:	6879      	ldr	r1, [r7, #4]
3401d990:	0b09      	lsrs	r1, r1, #12
3401d992:	f001 010f 	and.w	r1, r1, #15
3401d996:	6878      	ldr	r0, [r7, #4]
3401d998:	0a00      	lsrs	r0, r0, #8
3401d99a:	f000 000f 	and.w	r0, r0, #15
3401d99e:	2402      	movs	r4, #2
3401d9a0:	9406      	str	r4, [sp, #24]
3401d9a2:	2401      	movs	r4, #1
3401d9a4:	9405      	str	r4, [sp, #20]
3401d9a6:	241f      	movs	r4, #31
3401d9a8:	9404      	str	r4, [sp, #16]
3401d9aa:	9003      	str	r0, [sp, #12]
3401d9ac:	9102      	str	r1, [sp, #8]
3401d9ae:	9201      	str	r2, [sp, #4]
3401d9b0:	4a7c      	ldr	r2, [pc, #496]	@ (3401dba4 <LL_ATON_Init+0x77c>)
3401d9b2:	9200      	str	r2, [sp, #0]
3401d9b4:	22f5      	movs	r2, #245	@ 0xf5
3401d9b6:	497c      	ldr	r1, [pc, #496]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401d9b8:	487c      	ldr	r0, [pc, #496]	@ (3401dbac <LL_ATON_Init+0x784>)
3401d9ba:	f003 fc73 	bl	340212a4 <iprintf>
3401d9be:	4b7c      	ldr	r3, [pc, #496]	@ (3401dbb0 <LL_ATON_Init+0x788>)
3401d9c0:	4a7c      	ldr	r2, [pc, #496]	@ (3401dbb4 <LL_ATON_Init+0x78c>)
3401d9c2:	21f5      	movs	r1, #245	@ 0xf5
3401d9c4:	4878      	ldr	r0, [pc, #480]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401d9c6:	f002 fc33 	bl	34020230 <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
3401d9ca:	4b7b      	ldr	r3, [pc, #492]	@ (3401dbb8 <LL_ATON_Init+0x790>)
3401d9cc:	681b      	ldr	r3, [r3, #0]
3401d9ce:	607b      	str	r3, [r7, #4]
3401d9d0:	687b      	ldr	r3, [r7, #4]
3401d9d2:	2b00      	cmp	r3, #0
3401d9d4:	d0f9      	beq.n	3401d9ca <LL_ATON_Init+0x5a2>
3401d9d6:	687b      	ldr	r3, [r7, #4]
3401d9d8:	b2db      	uxtb	r3, r3
3401d9da:	2b1e      	cmp	r3, #30
3401d9dc:	d10b      	bne.n	3401d9f6 <LL_ATON_Init+0x5ce>
3401d9de:	687b      	ldr	r3, [r7, #4]
3401d9e0:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401d9e4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401d9e8:	d105      	bne.n	3401d9f6 <LL_ATON_Init+0x5ce>
3401d9ea:	687b      	ldr	r3, [r7, #4]
3401d9ec:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401d9f0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401d9f4:	d02f      	beq.n	3401da56 <LL_ATON_Init+0x62e>
3401d9f6:	f004 f841 	bl	34021a7c <__errno>
3401d9fa:	4603      	mov	r3, r0
3401d9fc:	681b      	ldr	r3, [r3, #0]
3401d9fe:	2b00      	cmp	r3, #0
3401da00:	d008      	beq.n	3401da14 <LL_ATON_Init+0x5ec>
3401da02:	f004 f83b 	bl	34021a7c <__errno>
3401da06:	4603      	mov	r3, r0
3401da08:	681b      	ldr	r3, [r3, #0]
3401da0a:	4618      	mov	r0, r3
3401da0c:	f003 ffd0 	bl	340219b0 <strerror>
3401da10:	4603      	mov	r3, r0
3401da12:	e000      	b.n	3401da16 <LL_ATON_Init+0x5ee>
3401da14:	4b62      	ldr	r3, [pc, #392]	@ (3401dba0 <LL_ATON_Init+0x778>)
3401da16:	687a      	ldr	r2, [r7, #4]
3401da18:	b2d2      	uxtb	r2, r2
3401da1a:	6879      	ldr	r1, [r7, #4]
3401da1c:	0b09      	lsrs	r1, r1, #12
3401da1e:	f001 010f 	and.w	r1, r1, #15
3401da22:	6878      	ldr	r0, [r7, #4]
3401da24:	0a00      	lsrs	r0, r0, #8
3401da26:	f000 000f 	and.w	r0, r0, #15
3401da2a:	2401      	movs	r4, #1
3401da2c:	9406      	str	r4, [sp, #24]
3401da2e:	2401      	movs	r4, #1
3401da30:	9405      	str	r4, [sp, #20]
3401da32:	241e      	movs	r4, #30
3401da34:	9404      	str	r4, [sp, #16]
3401da36:	9003      	str	r0, [sp, #12]
3401da38:	9102      	str	r1, [sp, #8]
3401da3a:	9201      	str	r2, [sp, #4]
3401da3c:	4a5f      	ldr	r2, [pc, #380]	@ (3401dbbc <LL_ATON_Init+0x794>)
3401da3e:	9200      	str	r2, [sp, #0]
3401da40:	22f7      	movs	r2, #247	@ 0xf7
3401da42:	4959      	ldr	r1, [pc, #356]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401da44:	4859      	ldr	r0, [pc, #356]	@ (3401dbac <LL_ATON_Init+0x784>)
3401da46:	f003 fc2d 	bl	340212a4 <iprintf>
3401da4a:	4b59      	ldr	r3, [pc, #356]	@ (3401dbb0 <LL_ATON_Init+0x788>)
3401da4c:	4a59      	ldr	r2, [pc, #356]	@ (3401dbb4 <LL_ATON_Init+0x78c>)
3401da4e:	21f7      	movs	r1, #247	@ 0xf7
3401da50:	4855      	ldr	r0, [pc, #340]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401da52:	f002 fbed 	bl	34020230 <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
3401da56:	4b5a      	ldr	r3, [pc, #360]	@ (3401dbc0 <LL_ATON_Init+0x798>)
3401da58:	681b      	ldr	r3, [r3, #0]
3401da5a:	607b      	str	r3, [r7, #4]
3401da5c:	687b      	ldr	r3, [r7, #4]
3401da5e:	2b00      	cmp	r3, #0
3401da60:	d0f9      	beq.n	3401da56 <LL_ATON_Init+0x62e>
3401da62:	687b      	ldr	r3, [r7, #4]
3401da64:	b2db      	uxtb	r3, r3
3401da66:	2b00      	cmp	r3, #0
3401da68:	d10b      	bne.n	3401da82 <LL_ATON_Init+0x65a>
3401da6a:	687b      	ldr	r3, [r7, #4]
3401da6c:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401da70:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401da74:	d105      	bne.n	3401da82 <LL_ATON_Init+0x65a>
3401da76:	687b      	ldr	r3, [r7, #4]
3401da78:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401da7c:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3401da80:	d02f      	beq.n	3401dae2 <LL_ATON_Init+0x6ba>
3401da82:	f003 fffb 	bl	34021a7c <__errno>
3401da86:	4603      	mov	r3, r0
3401da88:	681b      	ldr	r3, [r3, #0]
3401da8a:	2b00      	cmp	r3, #0
3401da8c:	d008      	beq.n	3401daa0 <LL_ATON_Init+0x678>
3401da8e:	f003 fff5 	bl	34021a7c <__errno>
3401da92:	4603      	mov	r3, r0
3401da94:	681b      	ldr	r3, [r3, #0]
3401da96:	4618      	mov	r0, r3
3401da98:	f003 ff8a 	bl	340219b0 <strerror>
3401da9c:	4603      	mov	r3, r0
3401da9e:	e000      	b.n	3401daa2 <LL_ATON_Init+0x67a>
3401daa0:	4b3f      	ldr	r3, [pc, #252]	@ (3401dba0 <LL_ATON_Init+0x778>)
3401daa2:	687a      	ldr	r2, [r7, #4]
3401daa4:	b2d2      	uxtb	r2, r2
3401daa6:	6879      	ldr	r1, [r7, #4]
3401daa8:	0b09      	lsrs	r1, r1, #12
3401daaa:	f001 010f 	and.w	r1, r1, #15
3401daae:	6878      	ldr	r0, [r7, #4]
3401dab0:	0a00      	lsrs	r0, r0, #8
3401dab2:	f000 000f 	and.w	r0, r0, #15
3401dab6:	2406      	movs	r4, #6
3401dab8:	9406      	str	r4, [sp, #24]
3401daba:	2401      	movs	r4, #1
3401dabc:	9405      	str	r4, [sp, #20]
3401dabe:	2400      	movs	r4, #0
3401dac0:	9404      	str	r4, [sp, #16]
3401dac2:	9003      	str	r0, [sp, #12]
3401dac4:	9102      	str	r1, [sp, #8]
3401dac6:	9201      	str	r2, [sp, #4]
3401dac8:	4a3e      	ldr	r2, [pc, #248]	@ (3401dbc4 <LL_ATON_Init+0x79c>)
3401daca:	9200      	str	r2, [sp, #0]
3401dacc:	22f9      	movs	r2, #249	@ 0xf9
3401dace:	4936      	ldr	r1, [pc, #216]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401dad0:	4836      	ldr	r0, [pc, #216]	@ (3401dbac <LL_ATON_Init+0x784>)
3401dad2:	f003 fbe7 	bl	340212a4 <iprintf>
3401dad6:	4b36      	ldr	r3, [pc, #216]	@ (3401dbb0 <LL_ATON_Init+0x788>)
3401dad8:	4a36      	ldr	r2, [pc, #216]	@ (3401dbb4 <LL_ATON_Init+0x78c>)
3401dada:	21f9      	movs	r1, #249	@ 0xf9
3401dadc:	4832      	ldr	r0, [pc, #200]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401dade:	f002 fba7 	bl	34020230 <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
3401dae2:	4b39      	ldr	r3, [pc, #228]	@ (3401dbc8 <LL_ATON_Init+0x7a0>)
3401dae4:	681b      	ldr	r3, [r3, #0]
3401dae6:	607b      	str	r3, [r7, #4]
3401dae8:	687b      	ldr	r3, [r7, #4]
3401daea:	2b00      	cmp	r3, #0
3401daec:	d0f9      	beq.n	3401dae2 <LL_ATON_Init+0x6ba>
3401daee:	687b      	ldr	r3, [r7, #4]
3401daf0:	b2db      	uxtb	r3, r3
3401daf2:	2b1d      	cmp	r3, #29
3401daf4:	d10a      	bne.n	3401db0c <LL_ATON_Init+0x6e4>
3401daf6:	687b      	ldr	r3, [r7, #4]
3401daf8:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401dafc:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
3401db00:	d104      	bne.n	3401db0c <LL_ATON_Init+0x6e4>
3401db02:	687b      	ldr	r3, [r7, #4]
3401db04:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401db08:	2b00      	cmp	r3, #0
3401db0a:	d02f      	beq.n	3401db6c <LL_ATON_Init+0x744>
3401db0c:	f003 ffb6 	bl	34021a7c <__errno>
3401db10:	4603      	mov	r3, r0
3401db12:	681b      	ldr	r3, [r3, #0]
3401db14:	2b00      	cmp	r3, #0
3401db16:	d008      	beq.n	3401db2a <LL_ATON_Init+0x702>
3401db18:	f003 ffb0 	bl	34021a7c <__errno>
3401db1c:	4603      	mov	r3, r0
3401db1e:	681b      	ldr	r3, [r3, #0]
3401db20:	4618      	mov	r0, r3
3401db22:	f003 ff45 	bl	340219b0 <strerror>
3401db26:	4603      	mov	r3, r0
3401db28:	e000      	b.n	3401db2c <LL_ATON_Init+0x704>
3401db2a:	4b1d      	ldr	r3, [pc, #116]	@ (3401dba0 <LL_ATON_Init+0x778>)
3401db2c:	687a      	ldr	r2, [r7, #4]
3401db2e:	b2d2      	uxtb	r2, r2
3401db30:	6879      	ldr	r1, [r7, #4]
3401db32:	0b09      	lsrs	r1, r1, #12
3401db34:	f001 010f 	and.w	r1, r1, #15
3401db38:	6878      	ldr	r0, [r7, #4]
3401db3a:	0a00      	lsrs	r0, r0, #8
3401db3c:	f000 000f 	and.w	r0, r0, #15
3401db40:	2400      	movs	r4, #0
3401db42:	9406      	str	r4, [sp, #24]
3401db44:	2405      	movs	r4, #5
3401db46:	9405      	str	r4, [sp, #20]
3401db48:	241d      	movs	r4, #29
3401db4a:	9404      	str	r4, [sp, #16]
3401db4c:	9003      	str	r0, [sp, #12]
3401db4e:	9102      	str	r1, [sp, #8]
3401db50:	9201      	str	r2, [sp, #4]
3401db52:	4a1e      	ldr	r2, [pc, #120]	@ (3401dbcc <LL_ATON_Init+0x7a4>)
3401db54:	9200      	str	r2, [sp, #0]
3401db56:	22fb      	movs	r2, #251	@ 0xfb
3401db58:	4913      	ldr	r1, [pc, #76]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401db5a:	4814      	ldr	r0, [pc, #80]	@ (3401dbac <LL_ATON_Init+0x784>)
3401db5c:	f003 fba2 	bl	340212a4 <iprintf>
3401db60:	4b13      	ldr	r3, [pc, #76]	@ (3401dbb0 <LL_ATON_Init+0x788>)
3401db62:	4a14      	ldr	r2, [pc, #80]	@ (3401dbb4 <LL_ATON_Init+0x78c>)
3401db64:	21fb      	movs	r1, #251	@ 0xfb
3401db66:	4810      	ldr	r0, [pc, #64]	@ (3401dba8 <LL_ATON_Init+0x780>)
3401db68:	f002 fb62 	bl	34020230 <__assert_func>

  /* Enable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
3401db6c:	2300      	movs	r3, #0
3401db6e:	603b      	str	r3, [r7, #0]
3401db70:	e00a      	b.n	3401db88 <LL_ATON_Init+0x760>
  {
    ATON_BUSIF_CTRL_SET(i, 1);
3401db72:	683b      	ldr	r3, [r7, #0]
3401db74:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
3401db78:	33e2      	adds	r3, #226	@ 0xe2
3401db7a:	031b      	lsls	r3, r3, #12
3401db7c:	461a      	mov	r2, r3
3401db7e:	2301      	movs	r3, #1
3401db80:	6013      	str	r3, [r2, #0]
  for (i = 0; i < ATON_BUSIF_NUM; i++)
3401db82:	683b      	ldr	r3, [r7, #0]
3401db84:	3301      	adds	r3, #1
3401db86:	603b      	str	r3, [r7, #0]
3401db88:	683b      	ldr	r3, [r7, #0]
3401db8a:	2b01      	cmp	r3, #1
3401db8c:	ddf1      	ble.n	3401db72 <LL_ATON_Init+0x74a>
  }

  /* Enable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 1);
3401db8e:	4b10      	ldr	r3, [pc, #64]	@ (3401dbd0 <LL_ATON_Init+0x7a8>)
3401db90:	2201      	movs	r2, #1
3401db92:	601a      	str	r2, [r3, #0]

  return 0;
3401db94:	2300      	movs	r3, #0
}
3401db96:	4618      	mov	r0, r3
3401db98:	370c      	adds	r7, #12
3401db9a:	46bd      	mov	sp, r7
3401db9c:	bd90      	pop	{r4, r7, pc}
3401db9e:	bf00      	nop
3401dba0:	34024778 	.word	0x34024778
3401dba4:	3402482c 	.word	0x3402482c
3401dba8:	3402464c 	.word	0x3402464c
3401dbac:	34024780 	.word	0x34024780
3401dbb0:	340247ec 	.word	0x340247ec
3401dbb4:	3403303c 	.word	0x3403303c
3401dbb8:	580e1004 	.word	0x580e1004
3401dbbc:	34024834 	.word	0x34024834
3401dbc0:	580e4004 	.word	0x580e4004
3401dbc4:	3402483c 	.word	0x3402483c
3401dbc8:	580e2004 	.word	0x580e2004
3401dbcc:	34024848 	.word	0x34024848
3401dbd0:	580e1000 	.word	0x580e1000

3401dbd4 <LL_ATON_DeInit>:
/**
 * @brief  ATON global de-initialization. Must be called at the very end
 * @retval Always zero
 */
int LL_ATON_DeInit(void)
{
3401dbd4:	b480      	push	{r7}
3401dbd6:	b083      	sub	sp, #12
3401dbd8:	af00      	add	r7, sp, #0
  int i;

  /* Disable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 0);
3401dbda:	4b13      	ldr	r3, [pc, #76]	@ (3401dc28 <LL_ATON_DeInit+0x54>)
3401dbdc:	2200      	movs	r2, #0
3401dbde:	601a      	str	r2, [r3, #0]

  /* Disable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
3401dbe0:	2300      	movs	r3, #0
3401dbe2:	607b      	str	r3, [r7, #4]
3401dbe4:	e00a      	b.n	3401dbfc <LL_ATON_DeInit+0x28>
  {
    ATON_BUSIF_CTRL_SET(i, 0);
3401dbe6:	687b      	ldr	r3, [r7, #4]
3401dbe8:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
3401dbec:	33e2      	adds	r3, #226	@ 0xe2
3401dbee:	031b      	lsls	r3, r3, #12
3401dbf0:	461a      	mov	r2, r3
3401dbf2:	2300      	movs	r3, #0
3401dbf4:	6013      	str	r3, [r2, #0]
  for (i = 0; i < ATON_BUSIF_NUM; i++)
3401dbf6:	687b      	ldr	r3, [r7, #4]
3401dbf8:	3301      	adds	r3, #1
3401dbfa:	607b      	str	r3, [r7, #4]
3401dbfc:	687b      	ldr	r3, [r7, #4]
3401dbfe:	2b01      	cmp	r3, #1
3401dc00:	ddf1      	ble.n	3401dbe6 <LL_ATON_DeInit+0x12>
  }

  /* Disable all ATON clocks */
  ATON_CLKCTRL_AGATES0_SET(0, 0);
3401dc02:	4b0a      	ldr	r3, [pc, #40]	@ (3401dc2c <LL_ATON_DeInit+0x58>)
3401dc04:	2200      	movs	r2, #0
3401dc06:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES1_SET(0, 0);
3401dc08:	4b09      	ldr	r3, [pc, #36]	@ (3401dc30 <LL_ATON_DeInit+0x5c>)
3401dc0a:	2200      	movs	r2, #0
3401dc0c:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_BGATES_SET(0, 0);
3401dc0e:	4b09      	ldr	r3, [pc, #36]	@ (3401dc34 <LL_ATON_DeInit+0x60>)
3401dc10:	2200      	movs	r2, #0
3401dc12:	601a      	str	r2, [r3, #0]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0);
#endif
  ATON_CLKCTRL_CTRL_SET(0, 0);
3401dc14:	4b08      	ldr	r3, [pc, #32]	@ (3401dc38 <LL_ATON_DeInit+0x64>)
3401dc16:	2200      	movs	r2, #0
3401dc18:	601a      	str	r2, [r3, #0]

  return 0;
3401dc1a:	2300      	movs	r3, #0
}
3401dc1c:	4618      	mov	r0, r3
3401dc1e:	370c      	adds	r7, #12
3401dc20:	46bd      	mov	sp, r7
3401dc22:	f85d 7b04 	ldr.w	r7, [sp], #4
3401dc26:	4770      	bx	lr
3401dc28:	580e1000 	.word	0x580e1000
3401dc2c:	580e0008 	.word	0x580e0008
3401dc30:	580e000c 	.word	0x580e000c
3401dc34:	580e0010 	.word	0x580e0010
3401dc38:	580e0000 	.word	0x580e0000

3401dc3c <__atonn_getSrcPortID>:
}
#endif

unsigned __atonn_getSrcPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
3401dc3c:	b590      	push	{r4, r7, lr}
3401dc3e:	b083      	sub	sp, #12
3401dc40:	af00      	add	r7, sp, #0
3401dc42:	4604      	mov	r4, r0
3401dc44:	4608      	mov	r0, r1
3401dc46:	4611      	mov	r1, r2
3401dc48:	461a      	mov	r2, r3
3401dc4a:	4623      	mov	r3, r4
3401dc4c:	71fb      	strb	r3, [r7, #7]
3401dc4e:	4603      	mov	r3, r0
3401dc50:	71bb      	strb	r3, [r7, #6]
3401dc52:	460b      	mov	r3, r1
3401dc54:	717b      	strb	r3, [r7, #5]
3401dc56:	4613      	mov	r3, r2
3401dc58:	713b      	strb	r3, [r7, #4]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
3401dc5a:	79bb      	ldrb	r3, [r7, #6]
3401dc5c:	2b00      	cmp	r3, #0
3401dc5e:	d006      	beq.n	3401dc6e <__atonn_getSrcPortID+0x32>
3401dc60:	4b66      	ldr	r3, [pc, #408]	@ (3401ddfc <__atonn_getSrcPortID+0x1c0>)
3401dc62:	4a67      	ldr	r2, [pc, #412]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dc64:	f240 313e 	movw	r1, #830	@ 0x33e
3401dc68:	4866      	ldr	r0, [pc, #408]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dc6a:	f002 fae1 	bl	34020230 <__assert_func>
  switch (sut)
3401dc6e:	79fb      	ldrb	r3, [r7, #7]
3401dc70:	2b02      	cmp	r3, #2
3401dc72:	f000 80b6 	beq.w	3401dde2 <__atonn_getSrcPortID+0x1a6>
3401dc76:	2b02      	cmp	r3, #2
3401dc78:	f300 80ba 	bgt.w	3401ddf0 <__atonn_getSrcPortID+0x1b4>
3401dc7c:	2b00      	cmp	r3, #0
3401dc7e:	d003      	beq.n	3401dc88 <__atonn_getSrcPortID+0x4c>
3401dc80:	2b01      	cmp	r3, #1
3401dc82:	f000 80a7 	beq.w	3401ddd4 <__atonn_getSrcPortID+0x198>
3401dc86:	e0b3      	b.n	3401ddf0 <__atonn_getSrcPortID+0x1b4>
  {
  case STRSWITCH:
    switch (aut)
3401dc88:	797b      	ldrb	r3, [r7, #5]
3401dc8a:	2b06      	cmp	r3, #6
3401dc8c:	f200 809b 	bhi.w	3401ddc6 <__atonn_getSrcPortID+0x18a>
3401dc90:	a201      	add	r2, pc, #4	@ (adr r2, 3401dc98 <__atonn_getSrcPortID+0x5c>)
3401dc92:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401dc96:	bf00      	nop
3401dc98:	3401dcb5 	.word	0x3401dcb5
3401dc9c:	3401ddc7 	.word	0x3401ddc7
3401dca0:	3401dce1 	.word	0x3401dce1
3401dca4:	3401dd0f 	.word	0x3401dd0f
3401dca8:	3401dd3d 	.word	0x3401dd3d
3401dcac:	3401dd6b 	.word	0x3401dd6b
3401dcb0:	3401dd99 	.word	0x3401dd99
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
3401dcb4:	7e3b      	ldrb	r3, [r7, #24]
3401dcb6:	2b00      	cmp	r3, #0
3401dcb8:	d006      	beq.n	3401dcc8 <__atonn_getSrcPortID+0x8c>
3401dcba:	4b53      	ldr	r3, [pc, #332]	@ (3401de08 <__atonn_getSrcPortID+0x1cc>)
3401dcbc:	4a50      	ldr	r2, [pc, #320]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dcbe:	f240 3146 	movw	r1, #838	@ 0x346
3401dcc2:	4850      	ldr	r0, [pc, #320]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dcc4:	f002 fab4 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
3401dcc8:	793b      	ldrb	r3, [r7, #4]
3401dcca:	2b09      	cmp	r3, #9
3401dccc:	d906      	bls.n	3401dcdc <__atonn_getSrcPortID+0xa0>
3401dcce:	4b4f      	ldr	r3, [pc, #316]	@ (3401de0c <__atonn_getSrcPortID+0x1d0>)
3401dcd0:	4a4b      	ldr	r2, [pc, #300]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dcd2:	f240 3147 	movw	r1, #839	@ 0x347
3401dcd6:	484b      	ldr	r0, [pc, #300]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dcd8:	f002 faaa 	bl	34020230 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, STRENG, 0, 0) + au_num;
3401dcdc:	793b      	ldrb	r3, [r7, #4]
3401dcde:	e088      	b.n	3401ddf2 <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_CONVACC_NUM)
    case CONVACC:
      LL_ATON_ASSERT(port == 0);
3401dce0:	7e3b      	ldrb	r3, [r7, #24]
3401dce2:	2b00      	cmp	r3, #0
3401dce4:	d006      	beq.n	3401dcf4 <__atonn_getSrcPortID+0xb8>
3401dce6:	4b48      	ldr	r3, [pc, #288]	@ (3401de08 <__atonn_getSrcPortID+0x1cc>)
3401dce8:	4a45      	ldr	r2, [pc, #276]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dcea:	f240 314d 	movw	r1, #845	@ 0x34d
3401dcee:	4845      	ldr	r0, [pc, #276]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dcf0:	f002 fa9e 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
3401dcf4:	793b      	ldrb	r3, [r7, #4]
3401dcf6:	2b03      	cmp	r3, #3
3401dcf8:	d906      	bls.n	3401dd08 <__atonn_getSrcPortID+0xcc>
3401dcfa:	4b45      	ldr	r3, [pc, #276]	@ (3401de10 <__atonn_getSrcPortID+0x1d4>)
3401dcfc:	4a40      	ldr	r2, [pc, #256]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dcfe:	f240 314e 	movw	r1, #846	@ 0x34e
3401dd02:	4840      	ldr	r0, [pc, #256]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd04:	f002 fa94 	bl	34020230 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, CONVACC, 0, 0) + au_num;
3401dd08:	793b      	ldrb	r3, [r7, #4]
3401dd0a:	330a      	adds	r3, #10
3401dd0c:	e071      	b.n	3401ddf2 <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_DECUN_NUM)
    case DECUN:
      LL_ATON_ASSERT(port == 0);
3401dd0e:	7e3b      	ldrb	r3, [r7, #24]
3401dd10:	2b00      	cmp	r3, #0
3401dd12:	d006      	beq.n	3401dd22 <__atonn_getSrcPortID+0xe6>
3401dd14:	4b3c      	ldr	r3, [pc, #240]	@ (3401de08 <__atonn_getSrcPortID+0x1cc>)
3401dd16:	4a3a      	ldr	r2, [pc, #232]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dd18:	f44f 7155 	mov.w	r1, #852	@ 0x354
3401dd1c:	4839      	ldr	r0, [pc, #228]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd1e:	f002 fa87 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
3401dd22:	793b      	ldrb	r3, [r7, #4]
3401dd24:	2b01      	cmp	r3, #1
3401dd26:	d906      	bls.n	3401dd36 <__atonn_getSrcPortID+0xfa>
3401dd28:	4b3a      	ldr	r3, [pc, #232]	@ (3401de14 <__atonn_getSrcPortID+0x1d8>)
3401dd2a:	4a35      	ldr	r2, [pc, #212]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dd2c:	f240 3155 	movw	r1, #853	@ 0x355
3401dd30:	4834      	ldr	r0, [pc, #208]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd32:	f002 fa7d 	bl	34020230 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, DECUN, 0, 0) + au_num;
3401dd36:	793b      	ldrb	r3, [r7, #4]
3401dd38:	330e      	adds	r3, #14
3401dd3a:	e05a      	b.n	3401ddf2 <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_ACTIV_NUM)
    case ACTIV:
      LL_ATON_ASSERT(port == 0);
3401dd3c:	7e3b      	ldrb	r3, [r7, #24]
3401dd3e:	2b00      	cmp	r3, #0
3401dd40:	d006      	beq.n	3401dd50 <__atonn_getSrcPortID+0x114>
3401dd42:	4b31      	ldr	r3, [pc, #196]	@ (3401de08 <__atonn_getSrcPortID+0x1cc>)
3401dd44:	4a2e      	ldr	r2, [pc, #184]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dd46:	f240 315b 	movw	r1, #859	@ 0x35b
3401dd4a:	482e      	ldr	r0, [pc, #184]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd4c:	f002 fa70 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
3401dd50:	793b      	ldrb	r3, [r7, #4]
3401dd52:	2b01      	cmp	r3, #1
3401dd54:	d906      	bls.n	3401dd64 <__atonn_getSrcPortID+0x128>
3401dd56:	4b2f      	ldr	r3, [pc, #188]	@ (3401de14 <__atonn_getSrcPortID+0x1d8>)
3401dd58:	4a29      	ldr	r2, [pc, #164]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dd5a:	f44f 7157 	mov.w	r1, #860	@ 0x35c
3401dd5e:	4829      	ldr	r0, [pc, #164]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd60:	f002 fa66 	bl	34020230 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ACTIV, 0, 0) + au_num;
3401dd64:	793b      	ldrb	r3, [r7, #4]
3401dd66:	3310      	adds	r3, #16
3401dd68:	e043      	b.n	3401ddf2 <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_ARITH_NUM)
    case ARITH:
      LL_ATON_ASSERT(port == 0);
3401dd6a:	7e3b      	ldrb	r3, [r7, #24]
3401dd6c:	2b00      	cmp	r3, #0
3401dd6e:	d006      	beq.n	3401dd7e <__atonn_getSrcPortID+0x142>
3401dd70:	4b25      	ldr	r3, [pc, #148]	@ (3401de08 <__atonn_getSrcPortID+0x1cc>)
3401dd72:	4a23      	ldr	r2, [pc, #140]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dd74:	f240 3162 	movw	r1, #866	@ 0x362
3401dd78:	4822      	ldr	r0, [pc, #136]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd7a:	f002 fa59 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
3401dd7e:	793b      	ldrb	r3, [r7, #4]
3401dd80:	2b03      	cmp	r3, #3
3401dd82:	d906      	bls.n	3401dd92 <__atonn_getSrcPortID+0x156>
3401dd84:	4b22      	ldr	r3, [pc, #136]	@ (3401de10 <__atonn_getSrcPortID+0x1d4>)
3401dd86:	4a1e      	ldr	r2, [pc, #120]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dd88:	f240 3163 	movw	r1, #867	@ 0x363
3401dd8c:	481d      	ldr	r0, [pc, #116]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dd8e:	f002 fa4f 	bl	34020230 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ARITH, 0, 0) + au_num;
3401dd92:	793b      	ldrb	r3, [r7, #4]
3401dd94:	3312      	adds	r3, #18
3401dd96:	e02c      	b.n	3401ddf2 <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_POOL_NUM)
    case POOL:
      LL_ATON_ASSERT(port == 0);
3401dd98:	7e3b      	ldrb	r3, [r7, #24]
3401dd9a:	2b00      	cmp	r3, #0
3401dd9c:	d006      	beq.n	3401ddac <__atonn_getSrcPortID+0x170>
3401dd9e:	4b1a      	ldr	r3, [pc, #104]	@ (3401de08 <__atonn_getSrcPortID+0x1cc>)
3401dda0:	4a17      	ldr	r2, [pc, #92]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dda2:	f240 3169 	movw	r1, #873	@ 0x369
3401dda6:	4817      	ldr	r0, [pc, #92]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401dda8:	f002 fa42 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
3401ddac:	793b      	ldrb	r3, [r7, #4]
3401ddae:	2b01      	cmp	r3, #1
3401ddb0:	d906      	bls.n	3401ddc0 <__atonn_getSrcPortID+0x184>
3401ddb2:	4b18      	ldr	r3, [pc, #96]	@ (3401de14 <__atonn_getSrcPortID+0x1d8>)
3401ddb4:	4a12      	ldr	r2, [pc, #72]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401ddb6:	f240 316a 	movw	r1, #874	@ 0x36a
3401ddba:	4812      	ldr	r0, [pc, #72]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401ddbc:	f002 fa38 	bl	34020230 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, POOL, 0, 0) + au_num;
3401ddc0:	793b      	ldrb	r3, [r7, #4]
3401ddc2:	3316      	adds	r3, #22
3401ddc4:	e015      	b.n	3401ddf2 <__atonn_getSrcPortID+0x1b6>
      break;
#endif
    default:
      LL_ATON_ASSERT(0);
3401ddc6:	4b14      	ldr	r3, [pc, #80]	@ (3401de18 <__atonn_getSrcPortID+0x1dc>)
3401ddc8:	4a0d      	ldr	r2, [pc, #52]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401ddca:	f240 316f 	movw	r1, #879	@ 0x36f
3401ddce:	480d      	ldr	r0, [pc, #52]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401ddd0:	f002 fa2e 	bl	34020230 <__assert_func>
      break;
    }
    break;
  case STRSWITCH64:
    // TODO
    LL_ATON_ASSERT(0);
3401ddd4:	4b10      	ldr	r3, [pc, #64]	@ (3401de18 <__atonn_getSrcPortID+0x1dc>)
3401ddd6:	4a0a      	ldr	r2, [pc, #40]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401ddd8:	f240 3175 	movw	r1, #885	@ 0x375
3401dddc:	4809      	ldr	r0, [pc, #36]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401ddde:	f002 fa27 	bl	34020230 <__assert_func>
    break;
  case STRSWITCH_VC:
    // TODO
    LL_ATON_ASSERT(0);
3401dde2:	4b0d      	ldr	r3, [pc, #52]	@ (3401de18 <__atonn_getSrcPortID+0x1dc>)
3401dde4:	4a06      	ldr	r2, [pc, #24]	@ (3401de00 <__atonn_getSrcPortID+0x1c4>)
3401dde6:	f240 3179 	movw	r1, #889	@ 0x379
3401ddea:	4806      	ldr	r0, [pc, #24]	@ (3401de04 <__atonn_getSrcPortID+0x1c8>)
3401ddec:	f002 fa20 	bl	34020230 <__assert_func>
    break;
  }
  return 0;
3401ddf0:	2300      	movs	r3, #0
}
3401ddf2:	4618      	mov	r0, r3
3401ddf4:	370c      	adds	r7, #12
3401ddf6:	46bd      	mov	sp, r7
3401ddf8:	bd90      	pop	{r4, r7, pc}
3401ddfa:	bf00      	nop
3401ddfc:	34024868 	.word	0x34024868
3401de00:	34033064 	.word	0x34033064
3401de04:	3402464c 	.word	0x3402464c
3401de08:	34024874 	.word	0x34024874
3401de0c:	34024880 	.word	0x34024880
3401de10:	3402488c 	.word	0x3402488c
3401de14:	34024898 	.word	0x34024898
3401de18:	340247ec 	.word	0x340247ec

3401de1c <__atonn_getDstPortID>:

unsigned __atonn_getDstPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
3401de1c:	b590      	push	{r4, r7, lr}
3401de1e:	b083      	sub	sp, #12
3401de20:	af00      	add	r7, sp, #0
3401de22:	4604      	mov	r4, r0
3401de24:	4608      	mov	r0, r1
3401de26:	4611      	mov	r1, r2
3401de28:	461a      	mov	r2, r3
3401de2a:	4623      	mov	r3, r4
3401de2c:	71fb      	strb	r3, [r7, #7]
3401de2e:	4603      	mov	r3, r0
3401de30:	71bb      	strb	r3, [r7, #6]
3401de32:	460b      	mov	r3, r1
3401de34:	717b      	strb	r3, [r7, #5]
3401de36:	4613      	mov	r3, r2
3401de38:	713b      	strb	r3, [r7, #4]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
3401de3a:	79bb      	ldrb	r3, [r7, #6]
3401de3c:	2b00      	cmp	r3, #0
3401de3e:	d006      	beq.n	3401de4e <__atonn_getDstPortID+0x32>
3401de40:	4b6f      	ldr	r3, [pc, #444]	@ (3401e000 <__atonn_getDstPortID+0x1e4>)
3401de42:	4a70      	ldr	r2, [pc, #448]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401de44:	f240 3183 	movw	r1, #899	@ 0x383
3401de48:	486f      	ldr	r0, [pc, #444]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401de4a:	f002 f9f1 	bl	34020230 <__assert_func>
  switch (sut)
3401de4e:	79fb      	ldrb	r3, [r7, #7]
3401de50:	2b02      	cmp	r3, #2
3401de52:	f000 80c8 	beq.w	3401dfe6 <__atonn_getDstPortID+0x1ca>
3401de56:	2b02      	cmp	r3, #2
3401de58:	f300 80cc 	bgt.w	3401dff4 <__atonn_getDstPortID+0x1d8>
3401de5c:	2b00      	cmp	r3, #0
3401de5e:	d003      	beq.n	3401de68 <__atonn_getDstPortID+0x4c>
3401de60:	2b01      	cmp	r3, #1
3401de62:	f000 80b9 	beq.w	3401dfd8 <__atonn_getDstPortID+0x1bc>
3401de66:	e0c5      	b.n	3401dff4 <__atonn_getDstPortID+0x1d8>
  {
  case STRSWITCH:
    switch (aut)
3401de68:	797b      	ldrb	r3, [r7, #5]
3401de6a:	2b06      	cmp	r3, #6
3401de6c:	f200 80ad 	bhi.w	3401dfca <__atonn_getDstPortID+0x1ae>
3401de70:	a201      	add	r2, pc, #4	@ (adr r2, 3401de78 <__atonn_getDstPortID+0x5c>)
3401de72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401de76:	bf00      	nop
3401de78:	3401de95 	.word	0x3401de95
3401de7c:	3401dfcb 	.word	0x3401dfcb
3401de80:	3401dec5 	.word	0x3401dec5
3401de84:	3401deff 	.word	0x3401deff
3401de88:	3401df35 	.word	0x3401df35
3401de8c:	3401df65 	.word	0x3401df65
3401de90:	3401df9b 	.word	0x3401df9b
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
3401de94:	7e3b      	ldrb	r3, [r7, #24]
3401de96:	2b00      	cmp	r3, #0
3401de98:	d006      	beq.n	3401dea8 <__atonn_getDstPortID+0x8c>
3401de9a:	4b5c      	ldr	r3, [pc, #368]	@ (3401e00c <__atonn_getDstPortID+0x1f0>)
3401de9c:	4a59      	ldr	r2, [pc, #356]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401de9e:	f240 318b 	movw	r1, #907	@ 0x38b
3401dea2:	4859      	ldr	r0, [pc, #356]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dea4:	f002 f9c4 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
3401dea8:	793b      	ldrb	r3, [r7, #4]
3401deaa:	2b09      	cmp	r3, #9
3401deac:	d906      	bls.n	3401debc <__atonn_getDstPortID+0xa0>
3401deae:	4b58      	ldr	r3, [pc, #352]	@ (3401e010 <__atonn_getDstPortID+0x1f4>)
3401deb0:	4a54      	ldr	r2, [pc, #336]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401deb2:	f44f 7163 	mov.w	r1, #908	@ 0x38c
3401deb6:	4854      	ldr	r0, [pc, #336]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401deb8:	f002 f9ba 	bl	34020230 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, STRENG, 0, 0) + (0x4 * au_num);
3401debc:	793b      	ldrb	r3, [r7, #4]
3401debe:	009b      	lsls	r3, r3, #2
3401dec0:	3308      	adds	r3, #8
3401dec2:	e098      	b.n	3401dff6 <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_CONVACC_NUM)
    case CONVACC:
      LL_ATON_ASSERT(port < 3);
3401dec4:	7e3b      	ldrb	r3, [r7, #24]
3401dec6:	2b02      	cmp	r3, #2
3401dec8:	d906      	bls.n	3401ded8 <__atonn_getDstPortID+0xbc>
3401deca:	4b52      	ldr	r3, [pc, #328]	@ (3401e014 <__atonn_getDstPortID+0x1f8>)
3401decc:	4a4d      	ldr	r2, [pc, #308]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dece:	f240 3192 	movw	r1, #914	@ 0x392
3401ded2:	484d      	ldr	r0, [pc, #308]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401ded4:	f002 f9ac 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
3401ded8:	793b      	ldrb	r3, [r7, #4]
3401deda:	2b03      	cmp	r3, #3
3401dedc:	d906      	bls.n	3401deec <__atonn_getDstPortID+0xd0>
3401dede:	4b4e      	ldr	r3, [pc, #312]	@ (3401e018 <__atonn_getDstPortID+0x1fc>)
3401dee0:	4a48      	ldr	r2, [pc, #288]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dee2:	f240 3193 	movw	r1, #915	@ 0x393
3401dee6:	4848      	ldr	r0, [pc, #288]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dee8:	f002 f9a2 	bl	34020230 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, CONVACC, 0, 0) + (0x4 * (3 * au_num + port));
3401deec:	793a      	ldrb	r2, [r7, #4]
3401deee:	4613      	mov	r3, r2
3401def0:	005b      	lsls	r3, r3, #1
3401def2:	441a      	add	r2, r3
3401def4:	7e3b      	ldrb	r3, [r7, #24]
3401def6:	4413      	add	r3, r2
3401def8:	009b      	lsls	r3, r3, #2
3401defa:	3330      	adds	r3, #48	@ 0x30
3401defc:	e07b      	b.n	3401dff6 <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_DECUN_NUM)
    case DECUN:
      LL_ATON_ASSERT(port < 2);
3401defe:	7e3b      	ldrb	r3, [r7, #24]
3401df00:	2b01      	cmp	r3, #1
3401df02:	d906      	bls.n	3401df12 <__atonn_getDstPortID+0xf6>
3401df04:	4b45      	ldr	r3, [pc, #276]	@ (3401e01c <__atonn_getDstPortID+0x200>)
3401df06:	4a3f      	ldr	r2, [pc, #252]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401df08:	f240 3199 	movw	r1, #921	@ 0x399
3401df0c:	483e      	ldr	r0, [pc, #248]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401df0e:	f002 f98f 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
3401df12:	793b      	ldrb	r3, [r7, #4]
3401df14:	2b01      	cmp	r3, #1
3401df16:	d906      	bls.n	3401df26 <__atonn_getDstPortID+0x10a>
3401df18:	4b41      	ldr	r3, [pc, #260]	@ (3401e020 <__atonn_getDstPortID+0x204>)
3401df1a:	4a3a      	ldr	r2, [pc, #232]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401df1c:	f240 319a 	movw	r1, #922	@ 0x39a
3401df20:	4839      	ldr	r0, [pc, #228]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401df22:	f002 f985 	bl	34020230 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, DECUN, 0, 0) + (0x4 * (2 * au_num + port));
3401df26:	793b      	ldrb	r3, [r7, #4]
3401df28:	005a      	lsls	r2, r3, #1
3401df2a:	7e3b      	ldrb	r3, [r7, #24]
3401df2c:	4413      	add	r3, r2
3401df2e:	009b      	lsls	r3, r3, #2
3401df30:	3360      	adds	r3, #96	@ 0x60
3401df32:	e060      	b.n	3401dff6 <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_ACTIV_NUM)
    case ACTIV:
      LL_ATON_ASSERT(port == 0);
3401df34:	7e3b      	ldrb	r3, [r7, #24]
3401df36:	2b00      	cmp	r3, #0
3401df38:	d006      	beq.n	3401df48 <__atonn_getDstPortID+0x12c>
3401df3a:	4b34      	ldr	r3, [pc, #208]	@ (3401e00c <__atonn_getDstPortID+0x1f0>)
3401df3c:	4a31      	ldr	r2, [pc, #196]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401df3e:	f44f 7168 	mov.w	r1, #928	@ 0x3a0
3401df42:	4831      	ldr	r0, [pc, #196]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401df44:	f002 f974 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
3401df48:	793b      	ldrb	r3, [r7, #4]
3401df4a:	2b01      	cmp	r3, #1
3401df4c:	d906      	bls.n	3401df5c <__atonn_getDstPortID+0x140>
3401df4e:	4b34      	ldr	r3, [pc, #208]	@ (3401e020 <__atonn_getDstPortID+0x204>)
3401df50:	4a2c      	ldr	r2, [pc, #176]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401df52:	f240 31a1 	movw	r1, #929	@ 0x3a1
3401df56:	482c      	ldr	r0, [pc, #176]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401df58:	f002 f96a 	bl	34020230 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ACTIV, 0, 0) + (0x4 * au_num);
3401df5c:	793b      	ldrb	r3, [r7, #4]
3401df5e:	009b      	lsls	r3, r3, #2
3401df60:	3370      	adds	r3, #112	@ 0x70
3401df62:	e048      	b.n	3401dff6 <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_ARITH_NUM)
    case ARITH:
      LL_ATON_ASSERT(port < 2);
3401df64:	7e3b      	ldrb	r3, [r7, #24]
3401df66:	2b01      	cmp	r3, #1
3401df68:	d906      	bls.n	3401df78 <__atonn_getDstPortID+0x15c>
3401df6a:	4b2c      	ldr	r3, [pc, #176]	@ (3401e01c <__atonn_getDstPortID+0x200>)
3401df6c:	4a25      	ldr	r2, [pc, #148]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401df6e:	f240 31a7 	movw	r1, #935	@ 0x3a7
3401df72:	4825      	ldr	r0, [pc, #148]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401df74:	f002 f95c 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
3401df78:	793b      	ldrb	r3, [r7, #4]
3401df7a:	2b03      	cmp	r3, #3
3401df7c:	d906      	bls.n	3401df8c <__atonn_getDstPortID+0x170>
3401df7e:	4b26      	ldr	r3, [pc, #152]	@ (3401e018 <__atonn_getDstPortID+0x1fc>)
3401df80:	4a20      	ldr	r2, [pc, #128]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401df82:	f44f 716a 	mov.w	r1, #936	@ 0x3a8
3401df86:	4820      	ldr	r0, [pc, #128]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401df88:	f002 f952 	bl	34020230 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ARITH, 0, 0) + (0x4 * (2 * au_num + port));
3401df8c:	793b      	ldrb	r3, [r7, #4]
3401df8e:	005a      	lsls	r2, r3, #1
3401df90:	7e3b      	ldrb	r3, [r7, #24]
3401df92:	4413      	add	r3, r2
3401df94:	009b      	lsls	r3, r3, #2
3401df96:	3378      	adds	r3, #120	@ 0x78
3401df98:	e02d      	b.n	3401dff6 <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_POOL_NUM)
    case POOL:
      LL_ATON_ASSERT(port == 0);
3401df9a:	7e3b      	ldrb	r3, [r7, #24]
3401df9c:	2b00      	cmp	r3, #0
3401df9e:	d006      	beq.n	3401dfae <__atonn_getDstPortID+0x192>
3401dfa0:	4b1a      	ldr	r3, [pc, #104]	@ (3401e00c <__atonn_getDstPortID+0x1f0>)
3401dfa2:	4a18      	ldr	r2, [pc, #96]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dfa4:	f240 31ae 	movw	r1, #942	@ 0x3ae
3401dfa8:	4817      	ldr	r0, [pc, #92]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dfaa:	f002 f941 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
3401dfae:	793b      	ldrb	r3, [r7, #4]
3401dfb0:	2b01      	cmp	r3, #1
3401dfb2:	d906      	bls.n	3401dfc2 <__atonn_getDstPortID+0x1a6>
3401dfb4:	4b1a      	ldr	r3, [pc, #104]	@ (3401e020 <__atonn_getDstPortID+0x204>)
3401dfb6:	4a13      	ldr	r2, [pc, #76]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dfb8:	f240 31af 	movw	r1, #943	@ 0x3af
3401dfbc:	4812      	ldr	r0, [pc, #72]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dfbe:	f002 f937 	bl	34020230 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, POOL, 0, 0) + (0x4 * au_num);
3401dfc2:	793b      	ldrb	r3, [r7, #4]
3401dfc4:	009b      	lsls	r3, r3, #2
3401dfc6:	3398      	adds	r3, #152	@ 0x98
3401dfc8:	e015      	b.n	3401dff6 <__atonn_getDstPortID+0x1da>
      break;
#endif
    default:
      LL_ATON_ASSERT(0);
3401dfca:	4b16      	ldr	r3, [pc, #88]	@ (3401e024 <__atonn_getDstPortID+0x208>)
3401dfcc:	4a0d      	ldr	r2, [pc, #52]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dfce:	f44f 716d 	mov.w	r1, #948	@ 0x3b4
3401dfd2:	480d      	ldr	r0, [pc, #52]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dfd4:	f002 f92c 	bl	34020230 <__assert_func>
      break;
    }
    break;
  case STRSWITCH64:
    // TODO
    LL_ATON_ASSERT(0);
3401dfd8:	4b12      	ldr	r3, [pc, #72]	@ (3401e024 <__atonn_getDstPortID+0x208>)
3401dfda:	4a0a      	ldr	r2, [pc, #40]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dfdc:	f240 31ba 	movw	r1, #954	@ 0x3ba
3401dfe0:	4809      	ldr	r0, [pc, #36]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dfe2:	f002 f925 	bl	34020230 <__assert_func>
    break;
  case STRSWITCH_VC:
    // TODO
    LL_ATON_ASSERT(0);
3401dfe6:	4b0f      	ldr	r3, [pc, #60]	@ (3401e024 <__atonn_getDstPortID+0x208>)
3401dfe8:	4a06      	ldr	r2, [pc, #24]	@ (3401e004 <__atonn_getDstPortID+0x1e8>)
3401dfea:	f240 31be 	movw	r1, #958	@ 0x3be
3401dfee:	4806      	ldr	r0, [pc, #24]	@ (3401e008 <__atonn_getDstPortID+0x1ec>)
3401dff0:	f002 f91e 	bl	34020230 <__assert_func>
    break;
  }
  return 0;
3401dff4:	2300      	movs	r3, #0
}
3401dff6:	4618      	mov	r0, r3
3401dff8:	370c      	adds	r7, #12
3401dffa:	46bd      	mov	sp, r7
3401dffc:	bd90      	pop	{r4, r7, pc}
3401dffe:	bf00      	nop
3401e000:	34024868 	.word	0x34024868
3401e004:	3403307c 	.word	0x3403307c
3401e008:	3402464c 	.word	0x3402464c
3401e00c:	34024874 	.word	0x34024874
3401e010:	34024880 	.word	0x34024880
3401e014:	340248a4 	.word	0x340248a4
3401e018:	3402488c 	.word	0x3402488c
3401e01c:	340248b0 	.word	0x340248b0
3401e020:	34024898 	.word	0x34024898
3401e024:	340247ec 	.word	0x340247ec

3401e028 <LL_EpochCtrl_Init>:
 * @param  id Epoch Controller identifier [0..ATON_EPOCHCTRL_NUM-1]
 * @param  conf Structure describing Epoch Controller initialization parameters
 * @retval Error code
 */
int LL_EpochCtrl_Init(int id, const LL_EpochCtrl_InitTypeDef *conf)
{
3401e028:	b580      	push	{r7, lr}
3401e02a:	b084      	sub	sp, #16
3401e02c:	af00      	add	r7, sp, #0
3401e02e:	6078      	str	r0, [r7, #4]
3401e030:	6039      	str	r1, [r7, #0]
  uint32_t t;

  if (id >= ATON_EPOCHCTRL_NUM)
3401e032:	687b      	ldr	r3, [r7, #4]
3401e034:	2b00      	cmp	r3, #0
3401e036:	dd02      	ble.n	3401e03e <LL_EpochCtrl_Init+0x16>
    return LL_ATON_INVALID_ID;
3401e038:	f04f 33ff 	mov.w	r3, #4294967295
3401e03c:	e024      	b.n	3401e088 <LL_EpochCtrl_Init+0x60>

  LL_ATON_EnableClock(ATON_EPOCHCTRL_CLKB_CLK(id));
3401e03e:	687b      	ldr	r3, [r7, #4]
3401e040:	3319      	adds	r3, #25
3401e042:	4618      	mov	r0, r3
3401e044:	f000 f828 	bl	3401e098 <LL_ATON_EnableClock>

  /* Configure CTRL register */
  t = ATON_EPOCHCTRL_CTRL_DT;
3401e048:	2300      	movs	r3, #0
3401e04a:	60fb      	str	r3, [r7, #12]
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
3401e04c:	68fb      	ldr	r3, [r7, #12]
3401e04e:	f023 0208 	bic.w	r2, r3, #8
3401e052:	683b      	ldr	r3, [r7, #0]
3401e054:	791b      	ldrb	r3, [r3, #4]
3401e056:	f3c3 0300 	ubfx	r3, r3, #0, #1
3401e05a:	b2db      	uxtb	r3, r3
3401e05c:	00db      	lsls	r3, r3, #3
3401e05e:	f003 0308 	and.w	r3, r3, #8
3401e062:	4313      	orrs	r3, r2
3401e064:	60fb      	str	r3, [r7, #12]
  ATON_EPOCHCTRL_CTRL_SET(id, t);
3401e066:	4a0a      	ldr	r2, [pc, #40]	@ (3401e090 <LL_EpochCtrl_Init+0x68>)
3401e068:	68fb      	ldr	r3, [r7, #12]
3401e06a:	6013      	str	r3, [r2, #0]

  /* Check address is 8 byte aligned */
  if (conf->blobaddr & 0x7)
3401e06c:	683b      	ldr	r3, [r7, #0]
3401e06e:	681b      	ldr	r3, [r3, #0]
3401e070:	f003 0307 	and.w	r3, r3, #7
3401e074:	2b00      	cmp	r3, #0
3401e076:	d002      	beq.n	3401e07e <LL_EpochCtrl_Init+0x56>
    return LL_ATON_INVALID_PARAM;
3401e078:	f06f 0301 	mvn.w	r3, #1
3401e07c:	e004      	b.n	3401e088 <LL_EpochCtrl_Init+0x60>

  ATON_EPOCHCTRL_ADDR_SET(id, conf->blobaddr);
3401e07e:	4a05      	ldr	r2, [pc, #20]	@ (3401e094 <LL_EpochCtrl_Init+0x6c>)
3401e080:	683b      	ldr	r3, [r7, #0]
3401e082:	681b      	ldr	r3, [r3, #0]
3401e084:	6013      	str	r3, [r2, #0]

  return LL_ATON_OK;
3401e086:	2300      	movs	r3, #0
}
3401e088:	4618      	mov	r0, r3
3401e08a:	3710      	adds	r7, #16
3401e08c:	46bd      	mov	sp, r7
3401e08e:	bd80      	pop	{r7, pc}
3401e090:	580fe000 	.word	0x580fe000
3401e094:	580fe008 	.word	0x580fe008

3401e098 <LL_ATON_EnableClock>:
  return bloblines * 4;
}
#endif // ATON_EPOCHCTRL_NUM

void LL_ATON_EnableClock(unsigned int clock)
{
3401e098:	b490      	push	{r4, r7}
3401e09a:	b084      	sub	sp, #16
3401e09c:	af00      	add	r7, sp, #0
3401e09e:	6078      	str	r0, [r7, #4]
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 1);
3401e0a0:	4b13      	ldr	r3, [pc, #76]	@ (3401e0f0 <LL_ATON_EnableClock+0x58>)
3401e0a2:	681b      	ldr	r3, [r3, #0]
3401e0a4:	60fb      	str	r3, [r7, #12]
3401e0a6:	f04f 0201 	mov.w	r2, #1
3401e0aa:	f04f 0300 	mov.w	r3, #0
3401e0ae:	6879      	ldr	r1, [r7, #4]
3401e0b0:	ea52 130d 	orrs.w	r3, r2, sp, lsl #4
3401e0b4:	4613      	mov	r3, r2
3401e0b6:	43da      	mvns	r2, r3
3401e0b8:	68fb      	ldr	r3, [r7, #12]
3401e0ba:	ea02 0103 	and.w	r1, r2, r3
3401e0be:	2201      	movs	r2, #1
3401e0c0:	687b      	ldr	r3, [r7, #4]
3401e0c2:	fa02 f303 	lsl.w	r3, r2, r3
3401e0c6:	461c      	mov	r4, r3
3401e0c8:	f04f 0201 	mov.w	r2, #1
3401e0cc:	f04f 0300 	mov.w	r3, #0
3401e0d0:	6878      	ldr	r0, [r7, #4]
3401e0d2:	ea52 030d 	orrs.w	r3, r2, sp
3401e0d6:	4613      	mov	r3, r2
3401e0d8:	4023      	ands	r3, r4
3401e0da:	430b      	orrs	r3, r1
3401e0dc:	60fb      	str	r3, [r7, #12]
3401e0de:	4a04      	ldr	r2, [pc, #16]	@ (3401e0f0 <LL_ATON_EnableClock+0x58>)
3401e0e0:	68fb      	ldr	r3, [r7, #12]
3401e0e2:	6013      	str	r3, [r2, #0]
#endif
}
3401e0e4:	bf00      	nop
3401e0e6:	3710      	adds	r7, #16
3401e0e8:	46bd      	mov	sp, r7
3401e0ea:	bc90      	pop	{r4, r7}
3401e0ec:	4770      	bx	lr
3401e0ee:	bf00      	nop
3401e0f0:	580e0010 	.word	0x580e0010

3401e0f4 <LL_ATON_DisableClock>:

void LL_ATON_DisableClock(unsigned int clock)
{
3401e0f4:	b480      	push	{r7}
3401e0f6:	b085      	sub	sp, #20
3401e0f8:	af00      	add	r7, sp, #0
3401e0fa:	6078      	str	r0, [r7, #4]
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 0);
3401e0fc:	4b0b      	ldr	r3, [pc, #44]	@ (3401e12c <LL_ATON_DisableClock+0x38>)
3401e0fe:	681b      	ldr	r3, [r3, #0]
3401e100:	60fb      	str	r3, [r7, #12]
3401e102:	f04f 0201 	mov.w	r2, #1
3401e106:	f04f 0300 	mov.w	r3, #0
3401e10a:	6879      	ldr	r1, [r7, #4]
3401e10c:	ea52 130d 	orrs.w	r3, r2, sp, lsl #4
3401e110:	4613      	mov	r3, r2
3401e112:	43db      	mvns	r3, r3
3401e114:	68fa      	ldr	r2, [r7, #12]
3401e116:	4013      	ands	r3, r2
3401e118:	60fb      	str	r3, [r7, #12]
3401e11a:	4a04      	ldr	r2, [pc, #16]	@ (3401e12c <LL_ATON_DisableClock+0x38>)
3401e11c:	68fb      	ldr	r3, [r7, #12]
3401e11e:	6013      	str	r3, [r2, #0]
#endif
}
3401e120:	bf00      	nop
3401e122:	3714      	adds	r7, #20
3401e124:	46bd      	mov	sp, r7
3401e126:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e12a:	4770      	bx	lr
3401e12c:	580e0010 	.word	0x580e0010

3401e130 <LL_ATON_RT_Main>:
 *                         and the network interface, or macros
 *                         `LL_ATON_DECLARE_NAMED_NN_INTERFACE()` & `LL_ATON_DECLARE_NAMED_NN_INSTANCE()` to
 *                         create/instantiate the objects separately.
 */
void LL_ATON_RT_Main(NN_Instance_TypeDef *network_instance)
{
3401e130:	b580      	push	{r7, lr}
3401e132:	b084      	sub	sp, #16
3401e134:	af00      	add	r7, sp, #0
3401e136:	6078      	str	r0, [r7, #4]

  /*** Start of user initialization code ***/

  /*** End of user initialization code ***/

  LL_ATON_ASSERT(network_instance != NULL);
3401e138:	687b      	ldr	r3, [r7, #4]
3401e13a:	2b00      	cmp	r3, #0
3401e13c:	d105      	bne.n	3401e14a <LL_ATON_RT_Main+0x1a>
3401e13e:	4b15      	ldr	r3, [pc, #84]	@ (3401e194 <LL_ATON_RT_Main+0x64>)
3401e140:	4a15      	ldr	r2, [pc, #84]	@ (3401e198 <LL_ATON_RT_Main+0x68>)
3401e142:	212f      	movs	r1, #47	@ 0x2f
3401e144:	4815      	ldr	r0, [pc, #84]	@ (3401e19c <LL_ATON_RT_Main+0x6c>)
3401e146:	f002 f873 	bl	34020230 <__assert_func>
  LL_ATON_ASSERT(network_instance->network != NULL);
3401e14a:	687b      	ldr	r3, [r7, #4]
3401e14c:	681b      	ldr	r3, [r3, #0]
3401e14e:	2b00      	cmp	r3, #0
3401e150:	d105      	bne.n	3401e15e <LL_ATON_RT_Main+0x2e>
3401e152:	4b13      	ldr	r3, [pc, #76]	@ (3401e1a0 <LL_ATON_RT_Main+0x70>)
3401e154:	4a10      	ldr	r2, [pc, #64]	@ (3401e198 <LL_ATON_RT_Main+0x68>)
3401e156:	2130      	movs	r1, #48	@ 0x30
3401e158:	4810      	ldr	r0, [pc, #64]	@ (3401e19c <LL_ATON_RT_Main+0x6c>)
3401e15a:	f002 f869 	bl	34020230 <__assert_func>
  LL_ATON_RT_RuntimeInit();                  // Initialize runtime
3401e15e:	f000 fd11 	bl	3401eb84 <LL_ATON_RT_RuntimeInit>
  LL_ATON_RT_Init_Network(network_instance); // Initialize passed network instance object
3401e162:	6878      	ldr	r0, [r7, #4]
3401e164:	f000 fc96 	bl	3401ea94 <LL_ATON_RT_Init_Network>

  do
  {
    /* Execute first/next step of Cube.AI/ATON runtime */
    ll_aton_rt_ret = LL_ATON_RT_RunEpochBlock(network_instance);
3401e168:	6878      	ldr	r0, [r7, #4]
3401e16a:	f000 fd83 	bl	3401ec74 <LL_ATON_RT_RunEpochBlock>
3401e16e:	4603      	mov	r3, r0
3401e170:	73fb      	strb	r3, [r7, #15]
    /*** Start of user event handling code ***/

    /*** End of user event handling code ***/

    /* Wait for next event */
    if (ll_aton_rt_ret == LL_ATON_RT_WFE)
3401e172:	7bfb      	ldrb	r3, [r7, #15]
3401e174:	2b01      	cmp	r3, #1
3401e176:	d100      	bne.n	3401e17a <LL_ATON_RT_Main+0x4a>
    { /*** subject to change to fit also user code requirements ***/
      LL_ATON_OSAL_WFE();
3401e178:	bf20      	wfe
    }
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE); /*** subject to change to fit also user code requirements ***/
3401e17a:	7bfb      	ldrb	r3, [r7, #15]
3401e17c:	2b02      	cmp	r3, #2
3401e17e:	d1f3      	bne.n	3401e168 <LL_ATON_RT_Main+0x38>

  LL_ATON_RT_DeInit_Network(network_instance); // De-initialize the network instance object
3401e180:	6878      	ldr	r0, [r7, #4]
3401e182:	f000 fcc1 	bl	3401eb08 <LL_ATON_RT_DeInit_Network>
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime
3401e186:	f000 fd59 	bl	3401ec3c <LL_ATON_RT_RuntimeDeInit>

  /*** Start of user de-initialization code ***/

  /*** End of user de-initialization code ***/
}
3401e18a:	bf00      	nop
3401e18c:	3710      	adds	r7, #16
3401e18e:	46bd      	mov	sp, r7
3401e190:	bd80      	pop	{r7, pc}
3401e192:	bf00      	nop
3401e194:	3402490c 	.word	0x3402490c
3401e198:	34033094 	.word	0x34033094
3401e19c:	3402492c 	.word	0x3402492c
3401e1a0:	3402498c 	.word	0x3402498c

3401e1a4 <__NVIC_EnableIRQ>:
{
3401e1a4:	b480      	push	{r7}
3401e1a6:	b083      	sub	sp, #12
3401e1a8:	af00      	add	r7, sp, #0
3401e1aa:	4603      	mov	r3, r0
3401e1ac:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3401e1ae:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401e1b2:	2b00      	cmp	r3, #0
3401e1b4:	db0b      	blt.n	3401e1ce <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401e1b6:	88fb      	ldrh	r3, [r7, #6]
3401e1b8:	f003 021f 	and.w	r2, r3, #31
3401e1bc:	4907      	ldr	r1, [pc, #28]	@ (3401e1dc <__NVIC_EnableIRQ+0x38>)
3401e1be:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401e1c2:	095b      	lsrs	r3, r3, #5
3401e1c4:	2001      	movs	r0, #1
3401e1c6:	fa00 f202 	lsl.w	r2, r0, r2
3401e1ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3401e1ce:	bf00      	nop
3401e1d0:	370c      	adds	r7, #12
3401e1d2:	46bd      	mov	sp, r7
3401e1d4:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e1d8:	4770      	bx	lr
3401e1da:	bf00      	nop
3401e1dc:	e000e100 	.word	0xe000e100

3401e1e0 <__NVIC_DisableIRQ>:
{
3401e1e0:	b480      	push	{r7}
3401e1e2:	b083      	sub	sp, #12
3401e1e4:	af00      	add	r7, sp, #0
3401e1e6:	4603      	mov	r3, r0
3401e1e8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3401e1ea:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401e1ee:	2b00      	cmp	r3, #0
3401e1f0:	db12      	blt.n	3401e218 <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401e1f2:	88fb      	ldrh	r3, [r7, #6]
3401e1f4:	f003 021f 	and.w	r2, r3, #31
3401e1f8:	490a      	ldr	r1, [pc, #40]	@ (3401e224 <__NVIC_DisableIRQ+0x44>)
3401e1fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401e1fe:	095b      	lsrs	r3, r3, #5
3401e200:	2001      	movs	r0, #1
3401e202:	fa00 f202 	lsl.w	r2, r0, r2
3401e206:	3320      	adds	r3, #32
3401e208:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
3401e20c:	f3bf 8f4f 	dsb	sy
}
3401e210:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3401e212:	f3bf 8f6f 	isb	sy
}
3401e216:	bf00      	nop
}
3401e218:	bf00      	nop
3401e21a:	370c      	adds	r7, #12
3401e21c:	46bd      	mov	sp, r7
3401e21e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e222:	4770      	bx	lr
3401e224:	e000e100 	.word	0xe000e100

3401e228 <EpochBlock_IsLastEpochBlock>:
  /**
   * @}
   */

  static inline bool EpochBlock_IsLastEpochBlock(const EpochBlock_ItemTypeDef *eb)
  {
3401e228:	b480      	push	{r7}
3401e22a:	b083      	sub	sp, #12
3401e22c:	af00      	add	r7, sp, #0
3401e22e:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_last_eb) != 0);
3401e230:	687b      	ldr	r3, [r7, #4]
3401e232:	8a1b      	ldrh	r3, [r3, #16]
3401e234:	f003 0308 	and.w	r3, r3, #8
3401e238:	2b00      	cmp	r3, #0
3401e23a:	bf14      	ite	ne
3401e23c:	2301      	movne	r3, #1
3401e23e:	2300      	moveq	r3, #0
3401e240:	b2db      	uxtb	r3, r3
  }
3401e242:	4618      	mov	r0, r3
3401e244:	370c      	adds	r7, #12
3401e246:	46bd      	mov	sp, r7
3401e248:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e24c:	4770      	bx	lr

3401e24e <EpochBlock_IsEpochStart>:

  static inline bool EpochBlock_IsEpochStart(const EpochBlock_ItemTypeDef *eb)
  {
3401e24e:	b480      	push	{r7}
3401e250:	b083      	sub	sp, #12
3401e252:	af00      	add	r7, sp, #0
3401e254:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
3401e256:	687b      	ldr	r3, [r7, #4]
3401e258:	8a1b      	ldrh	r3, [r3, #16]
3401e25a:	f003 0301 	and.w	r3, r3, #1
3401e25e:	2b00      	cmp	r3, #0
3401e260:	bf14      	ite	ne
3401e262:	2301      	movne	r3, #1
3401e264:	2300      	moveq	r3, #0
3401e266:	b2db      	uxtb	r3, r3
  }
3401e268:	4618      	mov	r0, r3
3401e26a:	370c      	adds	r7, #12
3401e26c:	46bd      	mov	sp, r7
3401e26e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e272:	4770      	bx	lr

3401e274 <EpochBlock_IsEpochBlob>:
  {
    return ((eb->flags & EpochBlock_Flags_epoch_end) != 0);
  }

  static inline bool EpochBlock_IsEpochBlob(const EpochBlock_ItemTypeDef *eb)
  {
3401e274:	b480      	push	{r7}
3401e276:	b083      	sub	sp, #12
3401e278:	af00      	add	r7, sp, #0
3401e27a:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_blob) != 0);
3401e27c:	687b      	ldr	r3, [r7, #4]
3401e27e:	8a1b      	ldrh	r3, [r3, #16]
3401e280:	f003 0304 	and.w	r3, r3, #4
3401e284:	2b00      	cmp	r3, #0
3401e286:	bf14      	ite	ne
3401e288:	2301      	movne	r3, #1
3401e28a:	2300      	moveq	r3, #0
3401e28c:	b2db      	uxtb	r3, r3
  }
3401e28e:	4618      	mov	r0, r3
3401e290:	370c      	adds	r7, #12
3401e292:	46bd      	mov	sp, r7
3401e294:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e298:	4770      	bx	lr

3401e29a <EpochBlock_IsEpochPureHW>:
  {
    return ((eb->flags & EpochBlock_Flags_pure_sw) != 0);
  }

  static inline bool EpochBlock_IsEpochPureHW(const EpochBlock_ItemTypeDef *eb)
  {
3401e29a:	b480      	push	{r7}
3401e29c:	b083      	sub	sp, #12
3401e29e:	af00      	add	r7, sp, #0
3401e2a0:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
3401e2a2:	687b      	ldr	r3, [r7, #4]
3401e2a4:	8a1b      	ldrh	r3, [r3, #16]
3401e2a6:	f003 0310 	and.w	r3, r3, #16
3401e2aa:	2b00      	cmp	r3, #0
3401e2ac:	bf14      	ite	ne
3401e2ae:	2301      	movne	r3, #1
3401e2b0:	2300      	moveq	r3, #0
3401e2b2:	b2db      	uxtb	r3, r3
  }
3401e2b4:	4618      	mov	r0, r3
3401e2b6:	370c      	adds	r7, #12
3401e2b8:	46bd      	mov	sp, r7
3401e2ba:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e2be:	4770      	bx	lr

3401e2c0 <EpochBlock_IsEpochHybrid>:

  static inline bool EpochBlock_IsEpochHybrid(const EpochBlock_ItemTypeDef *eb)
  {
3401e2c0:	b480      	push	{r7}
3401e2c2:	b083      	sub	sp, #12
3401e2c4:	af00      	add	r7, sp, #0
3401e2c6:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_hybrid) != 0);
3401e2c8:	687b      	ldr	r3, [r7, #4]
3401e2ca:	8a1b      	ldrh	r3, [r3, #16]
3401e2cc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401e2d0:	2b00      	cmp	r3, #0
3401e2d2:	bf14      	ite	ne
3401e2d4:	2301      	movne	r3, #1
3401e2d6:	2300      	moveq	r3, #0
3401e2d8:	b2db      	uxtb	r3, r3
  }
3401e2da:	4618      	mov	r0, r3
3401e2dc:	370c      	adds	r7, #12
3401e2de:	46bd      	mov	sp, r7
3401e2e0:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e2e4:	4770      	bx	lr

3401e2e6 <EpochBlock_IsEpochInternal>:

  static inline bool EpochBlock_IsEpochInternal(const EpochBlock_ItemTypeDef *eb)
  {
3401e2e6:	b480      	push	{r7}
3401e2e8:	b083      	sub	sp, #12
3401e2ea:	af00      	add	r7, sp, #0
3401e2ec:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_internal) != 0);
3401e2ee:	687b      	ldr	r3, [r7, #4]
3401e2f0:	8a1b      	ldrh	r3, [r3, #16]
3401e2f2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3401e2f6:	2b00      	cmp	r3, #0
3401e2f8:	bf14      	ite	ne
3401e2fa:	2301      	movne	r3, #1
3401e2fc:	2300      	moveq	r3, #0
3401e2fe:	b2db      	uxtb	r3, r3
  }
3401e300:	4618      	mov	r0, r3
3401e302:	370c      	adds	r7, #12
3401e304:	46bd      	mov	sp, r7
3401e306:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e30a:	4770      	bx	lr

3401e30c <EpochBlock_EpochControllerUnit>:

  static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
  {
3401e30c:	b580      	push	{r7, lr}
3401e30e:	b082      	sub	sp, #8
3401e310:	af00      	add	r7, sp, #0
3401e312:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401e314:	6878      	ldr	r0, [r7, #4]
3401e316:	f7ff ffad 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401e31a:	4603      	mov	r3, r0
3401e31c:	2b00      	cmp	r3, #0
3401e31e:	d106      	bne.n	3401e32e <EpochBlock_EpochControllerUnit+0x22>
3401e320:	4b06      	ldr	r3, [pc, #24]	@ (3401e33c <EpochBlock_EpochControllerUnit+0x30>)
3401e322:	4a07      	ldr	r2, [pc, #28]	@ (3401e340 <EpochBlock_EpochControllerUnit+0x34>)
3401e324:	f240 212f 	movw	r1, #559	@ 0x22f
3401e328:	4806      	ldr	r0, [pc, #24]	@ (3401e344 <EpochBlock_EpochControllerUnit+0x38>)
3401e32a:	f001 ff81 	bl	34020230 <__assert_func>
    return eb->wait_mask;
3401e32e:	687b      	ldr	r3, [r7, #4]
3401e330:	68db      	ldr	r3, [r3, #12]
  }
3401e332:	4618      	mov	r0, r3
3401e334:	3708      	adds	r7, #8
3401e336:	46bd      	mov	sp, r7
3401e338:	bd80      	pop	{r7, pc}
3401e33a:	bf00      	nop
3401e33c:	340249b8 	.word	0x340249b8
3401e340:	340331b4 	.word	0x340331b4
3401e344:	340249d4 	.word	0x340249d4

3401e348 <EpochBlock_EpochBlobAddr>:

  static inline uintptr_t EpochBlock_EpochBlobAddr(const EpochBlock_ItemTypeDef *eb)
  {
3401e348:	b580      	push	{r7, lr}
3401e34a:	b082      	sub	sp, #8
3401e34c:	af00      	add	r7, sp, #0
3401e34e:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401e350:	6878      	ldr	r0, [r7, #4]
3401e352:	f7ff ff8f 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401e356:	4603      	mov	r3, r0
3401e358:	2b00      	cmp	r3, #0
3401e35a:	d106      	bne.n	3401e36a <EpochBlock_EpochBlobAddr+0x22>
3401e35c:	4b06      	ldr	r3, [pc, #24]	@ (3401e378 <EpochBlock_EpochBlobAddr+0x30>)
3401e35e:	4a07      	ldr	r2, [pc, #28]	@ (3401e37c <EpochBlock_EpochBlobAddr+0x34>)
3401e360:	f240 2135 	movw	r1, #565	@ 0x235
3401e364:	4806      	ldr	r0, [pc, #24]	@ (3401e380 <EpochBlock_EpochBlobAddr+0x38>)
3401e366:	f001 ff63 	bl	34020230 <__assert_func>
    return eb->blob_address;
3401e36a:	687b      	ldr	r3, [r7, #4]
3401e36c:	689b      	ldr	r3, [r3, #8]
  }
3401e36e:	4618      	mov	r0, r3
3401e370:	3708      	adds	r7, #8
3401e372:	46bd      	mov	sp, r7
3401e374:	bd80      	pop	{r7, pc}
3401e376:	bf00      	nop
3401e378:	340249b8 	.word	0x340249b8
3401e37c:	340331d4 	.word	0x340331d4
3401e380:	340249d4 	.word	0x340249d4

3401e384 <__ll_set_aton_owner>:
  typedef EpochBlock_ItemTypeDef LL_ATON_RT_EpochBlockItem_t;

  /*** Helper Functions ***/

  static inline void __ll_set_aton_owner(NN_Instance_TypeDef *new_owner)
  {
3401e384:	b580      	push	{r7, lr}
3401e386:	b082      	sub	sp, #8
3401e388:	af00      	add	r7, sp, #0
3401e38a:	6078      	str	r0, [r7, #4]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(new_owner != __ll_current_aton_ip_owner);
3401e38c:	4b12      	ldr	r3, [pc, #72]	@ (3401e3d8 <__ll_set_aton_owner+0x54>)
3401e38e:	681b      	ldr	r3, [r3, #0]
3401e390:	687a      	ldr	r2, [r7, #4]
3401e392:	429a      	cmp	r2, r3
3401e394:	d105      	bne.n	3401e3a2 <__ll_set_aton_owner+0x1e>
3401e396:	4b11      	ldr	r3, [pc, #68]	@ (3401e3dc <__ll_set_aton_owner+0x58>)
3401e398:	4a11      	ldr	r2, [pc, #68]	@ (3401e3e0 <__ll_set_aton_owner+0x5c>)
3401e39a:	2131      	movs	r1, #49	@ 0x31
3401e39c:	4811      	ldr	r0, [pc, #68]	@ (3401e3e4 <__ll_set_aton_owner+0x60>)
3401e39e:	f001 ff47 	bl	34020230 <__assert_func>

    LL_ATON_OSAL_LOCK_ATON();

    LL_ATON_ASSERT(__ll_current_aton_ip_owner == NULL);
3401e3a2:	4b0d      	ldr	r3, [pc, #52]	@ (3401e3d8 <__ll_set_aton_owner+0x54>)
3401e3a4:	681b      	ldr	r3, [r3, #0]
3401e3a6:	2b00      	cmp	r3, #0
3401e3a8:	d005      	beq.n	3401e3b6 <__ll_set_aton_owner+0x32>
3401e3aa:	4b0f      	ldr	r3, [pc, #60]	@ (3401e3e8 <__ll_set_aton_owner+0x64>)
3401e3ac:	4a0c      	ldr	r2, [pc, #48]	@ (3401e3e0 <__ll_set_aton_owner+0x5c>)
3401e3ae:	2135      	movs	r1, #53	@ 0x35
3401e3b0:	480c      	ldr	r0, [pc, #48]	@ (3401e3e4 <__ll_set_aton_owner+0x60>)
3401e3b2:	f001 ff3d 	bl	34020230 <__assert_func>

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401e3b6:	4b0d      	ldr	r3, [pc, #52]	@ (3401e3ec <__ll_set_aton_owner+0x68>)
3401e3b8:	681b      	ldr	r3, [r3, #0]
3401e3ba:	2b00      	cmp	r3, #0
3401e3bc:	d005      	beq.n	3401e3ca <__ll_set_aton_owner+0x46>
3401e3be:	4b0c      	ldr	r3, [pc, #48]	@ (3401e3f0 <__ll_set_aton_owner+0x6c>)
3401e3c0:	4a07      	ldr	r2, [pc, #28]	@ (3401e3e0 <__ll_set_aton_owner+0x5c>)
3401e3c2:	2139      	movs	r1, #57	@ 0x39
3401e3c4:	4807      	ldr	r0, [pc, #28]	@ (3401e3e4 <__ll_set_aton_owner+0x60>)
3401e3c6:	f001 ff33 	bl	34020230 <__assert_func>
#endif // NDEBUG

    __ll_current_aton_ip_owner = new_owner;
3401e3ca:	4a03      	ldr	r2, [pc, #12]	@ (3401e3d8 <__ll_set_aton_owner+0x54>)
3401e3cc:	687b      	ldr	r3, [r7, #4]
3401e3ce:	6013      	str	r3, [r2, #0]
  }
3401e3d0:	bf00      	nop
3401e3d2:	3708      	adds	r7, #8
3401e3d4:	46bd      	mov	sp, r7
3401e3d6:	bd80      	pop	{r7, pc}
3401e3d8:	34053db0 	.word	0x34053db0
3401e3dc:	34024a38 	.word	0x34024a38
3401e3e0:	34033184 	.word	0x34033184
3401e3e4:	34024a60 	.word	0x34024a60
3401e3e8:	34024ac0 	.word	0x34024ac0
3401e3ec:	34053db4 	.word	0x34053db4
3401e3f0:	34024aec 	.word	0x34024aec

3401e3f4 <__ll_clear_aton_owner>:

  static inline void __ll_clear_aton_owner(NN_Instance_TypeDef *current_owner)
  {
3401e3f4:	b580      	push	{r7, lr}
3401e3f6:	b082      	sub	sp, #8
3401e3f8:	af00      	add	r7, sp, #0
3401e3fa:	6078      	str	r0, [r7, #4]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(current_owner == __ll_current_aton_ip_owner);
3401e3fc:	4b0d      	ldr	r3, [pc, #52]	@ (3401e434 <__ll_clear_aton_owner+0x40>)
3401e3fe:	681b      	ldr	r3, [r3, #0]
3401e400:	687a      	ldr	r2, [r7, #4]
3401e402:	429a      	cmp	r2, r3
3401e404:	d005      	beq.n	3401e412 <__ll_clear_aton_owner+0x1e>
3401e406:	4b0c      	ldr	r3, [pc, #48]	@ (3401e438 <__ll_clear_aton_owner+0x44>)
3401e408:	4a0c      	ldr	r2, [pc, #48]	@ (3401e43c <__ll_clear_aton_owner+0x48>)
3401e40a:	2142      	movs	r1, #66	@ 0x42
3401e40c:	480c      	ldr	r0, [pc, #48]	@ (3401e440 <__ll_clear_aton_owner+0x4c>)
3401e40e:	f001 ff0f 	bl	34020230 <__assert_func>

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401e412:	4b0c      	ldr	r3, [pc, #48]	@ (3401e444 <__ll_clear_aton_owner+0x50>)
3401e414:	681b      	ldr	r3, [r3, #0]
3401e416:	2b00      	cmp	r3, #0
3401e418:	d005      	beq.n	3401e426 <__ll_clear_aton_owner+0x32>
3401e41a:	4b0b      	ldr	r3, [pc, #44]	@ (3401e448 <__ll_clear_aton_owner+0x54>)
3401e41c:	4a07      	ldr	r2, [pc, #28]	@ (3401e43c <__ll_clear_aton_owner+0x48>)
3401e41e:	2146      	movs	r1, #70	@ 0x46
3401e420:	4807      	ldr	r0, [pc, #28]	@ (3401e440 <__ll_clear_aton_owner+0x4c>)
3401e422:	f001 ff05 	bl	34020230 <__assert_func>
#endif // NDEBUG

    __ll_current_aton_ip_owner = NULL;
3401e426:	4b03      	ldr	r3, [pc, #12]	@ (3401e434 <__ll_clear_aton_owner+0x40>)
3401e428:	2200      	movs	r2, #0
3401e42a:	601a      	str	r2, [r3, #0]
    LL_ATON_OSAL_UNLOCK_ATON();
  }
3401e42c:	bf00      	nop
3401e42e:	3708      	adds	r7, #8
3401e430:	46bd      	mov	sp, r7
3401e432:	bd80      	pop	{r7, pc}
3401e434:	34053db0 	.word	0x34053db0
3401e438:	34024b08 	.word	0x34024b08
3401e43c:	340330e4 	.word	0x340330e4
3401e440:	34024a60 	.word	0x34024a60
3401e444:	34053db4 	.word	0x34053db4
3401e448:	34024aec 	.word	0x34024aec

3401e44c <__LL_ATON_RT_Start_AtoNN_Epoch>:
   *  Note: the following function may only be called at the beginning of
   *       `LL_ATON_Start_EpochBlock<n>()` functions, assuming also that at that point
   *       no streaming engine interrupts might trigger (anymore)!
   **/
  static inline void __LL_ATON_RT_Start_AtoNN_Epoch(NN_Instance_TypeDef *nn_instance)
  {
3401e44c:	b580      	push	{r7, lr}
3401e44e:	b082      	sub	sp, #8
3401e450:	af00      	add	r7, sp, #0
3401e452:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(nn_instance != NULL);
3401e454:	687b      	ldr	r3, [r7, #4]
3401e456:	2b00      	cmp	r3, #0
3401e458:	d105      	bne.n	3401e466 <__LL_ATON_RT_Start_AtoNN_Epoch+0x1a>
3401e45a:	4b0a      	ldr	r3, [pc, #40]	@ (3401e484 <__LL_ATON_RT_Start_AtoNN_Epoch+0x38>)
3401e45c:	4a0a      	ldr	r2, [pc, #40]	@ (3401e488 <__LL_ATON_RT_Start_AtoNN_Epoch+0x3c>)
3401e45e:	2154      	movs	r1, #84	@ 0x54
3401e460:	480a      	ldr	r0, [pc, #40]	@ (3401e48c <__LL_ATON_RT_Start_AtoNN_Epoch+0x40>)
3401e462:	f001 fee5 	bl	34020230 <__assert_func>
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401e466:	687b      	ldr	r3, [r7, #4]
3401e468:	69db      	ldr	r3, [r3, #28]
3401e46a:	2b00      	cmp	r3, #0
3401e46c:	d005      	beq.n	3401e47a <__LL_ATON_RT_Start_AtoNN_Epoch+0x2e>
3401e46e:	4b08      	ldr	r3, [pc, #32]	@ (3401e490 <__LL_ATON_RT_Start_AtoNN_Epoch+0x44>)
3401e470:	4a05      	ldr	r2, [pc, #20]	@ (3401e488 <__LL_ATON_RT_Start_AtoNN_Epoch+0x3c>)
3401e472:	2156      	movs	r1, #86	@ 0x56
3401e474:	4805      	ldr	r0, [pc, #20]	@ (3401e48c <__LL_ATON_RT_Start_AtoNN_Epoch+0x40>)
3401e476:	f001 fedb 	bl	34020230 <__assert_func>
                   0x0); // with the removal of parallel SW/HW epochs execution all triggered events must have been
                         // cleared at this point in time!
#endif
  }
3401e47a:	bf00      	nop
3401e47c:	3708      	adds	r7, #8
3401e47e:	46bd      	mov	sp, r7
3401e480:	bd80      	pop	{r7, pc}
3401e482:	bf00      	nop
3401e484:	34024b34 	.word	0x34024b34
3401e488:	34033164 	.word	0x34033164
3401e48c:	34024a60 	.word	0x34024a60
3401e490:	34024b50 	.word	0x34024b50

3401e494 <__LL_ATON_RT_SetWaitMask>:
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
  }

  /* set wait mask(s) in interrupt controller */
  static inline void __LL_ATON_RT_SetWaitMask(uint32_t wait_mask)
  {
3401e494:	b580      	push	{r7, lr}
3401e496:	b082      	sub	sp, #8
3401e498:	af00      	add	r7, sp, #0
3401e49a:	6078      	str	r0, [r7, #4]
#ifndef NDEBUG
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401e49c:	4b0a      	ldr	r3, [pc, #40]	@ (3401e4c8 <__LL_ATON_RT_SetWaitMask+0x34>)
3401e49e:	681b      	ldr	r3, [r3, #0]
3401e4a0:	2b00      	cmp	r3, #0
3401e4a2:	d105      	bne.n	3401e4b0 <__LL_ATON_RT_SetWaitMask+0x1c>
3401e4a4:	4b09      	ldr	r3, [pc, #36]	@ (3401e4cc <__LL_ATON_RT_SetWaitMask+0x38>)
3401e4a6:	4a0a      	ldr	r2, [pc, #40]	@ (3401e4d0 <__LL_ATON_RT_SetWaitMask+0x3c>)
3401e4a8:	2175      	movs	r1, #117	@ 0x75
3401e4aa:	480a      	ldr	r0, [pc, #40]	@ (3401e4d4 <__LL_ATON_RT_SetWaitMask+0x40>)
3401e4ac:	f001 fec0 	bl	34020230 <__assert_func>

    extern uint32_t volatile __ll_current_wait_mask;
    __ll_current_wait_mask = wait_mask;
3401e4b0:	4a09      	ldr	r2, [pc, #36]	@ (3401e4d8 <__LL_ATON_RT_SetWaitMask+0x44>)
3401e4b2:	687b      	ldr	r3, [r7, #4]
3401e4b4:	6013      	str	r3, [r2, #0]

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    wait_mask <<= ATON_STRENG_INT(0);
#ifndef LL_ATON_RT_USE_IRQ_OR_MASK
    /* configure interrupt controller AND mask for epoch block */
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
3401e4b6:	4a09      	ldr	r2, [pc, #36]	@ (3401e4dc <__LL_ATON_RT_SetWaitMask+0x48>)
3401e4b8:	687b      	ldr	r3, [r7, #4]
3401e4ba:	43db      	mvns	r3, r3
3401e4bc:	6013      	str	r3, [r2, #0]
                                                                // (all other events & errors are enabled)
    val &= ~wait_mask;
    ATON_INTCTRL_STD_INTORMSK_SET(val);
#endif // LL_ATON_RT_USE_IRQ_OR_MASK
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  }
3401e4be:	bf00      	nop
3401e4c0:	3708      	adds	r7, #8
3401e4c2:	46bd      	mov	sp, r7
3401e4c4:	bd80      	pop	{r7, pc}
3401e4c6:	bf00      	nop
3401e4c8:	34053db0 	.word	0x34053db0
3401e4cc:	34024b80 	.word	0x34024b80
3401e4d0:	34033198 	.word	0x34033198
3401e4d4:	34024a60 	.word	0x34024a60
3401e4d8:	34053db4 	.word	0x34053db4
3401e4dc:	580e1024 	.word	0x580e1024

3401e4e0 <__LL_ATON_RT_RetFromLibEpochBlockArray>:

  /* return from inserted epoch block */
  static inline void __LL_ATON_RT_RetFromLibEpochBlockArray(bool unlock, NN_Instance_TypeDef *nn_instance)
  {
3401e4e0:	b580      	push	{r7, lr}
3401e4e2:	b082      	sub	sp, #8
3401e4e4:	af00      	add	r7, sp, #0
3401e4e6:	4603      	mov	r3, r0
3401e4e8:	6039      	str	r1, [r7, #0]
3401e4ea:	71fb      	strb	r3, [r7, #7]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;

    if (!unlock)
3401e4ec:	79fb      	ldrb	r3, [r7, #7]
3401e4ee:	f083 0301 	eor.w	r3, r3, #1
3401e4f2:	b2db      	uxtb	r3, r3
3401e4f4:	2b00      	cmp	r3, #0
3401e4f6:	d015      	beq.n	3401e524 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x44>
    {
      LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401e4f8:	4b38      	ldr	r3, [pc, #224]	@ (3401e5dc <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401e4fa:	681b      	ldr	r3, [r3, #0]
3401e4fc:	2b00      	cmp	r3, #0
3401e4fe:	d105      	bne.n	3401e50c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x2c>
3401e500:	4b37      	ldr	r3, [pc, #220]	@ (3401e5e0 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x100>)
3401e502:	4a38      	ldr	r2, [pc, #224]	@ (3401e5e4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401e504:	2191      	movs	r1, #145	@ 0x91
3401e506:	4838      	ldr	r0, [pc, #224]	@ (3401e5e8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401e508:	f001 fe92 	bl	34020230 <__assert_func>
      LL_ATON_ASSERT(nn_instance == NULL);
3401e50c:	683b      	ldr	r3, [r7, #0]
3401e50e:	2b00      	cmp	r3, #0
3401e510:	d005      	beq.n	3401e51e <__LL_ATON_RT_RetFromLibEpochBlockArray+0x3e>
3401e512:	4b36      	ldr	r3, [pc, #216]	@ (3401e5ec <__LL_ATON_RT_RetFromLibEpochBlockArray+0x10c>)
3401e514:	4a33      	ldr	r2, [pc, #204]	@ (3401e5e4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401e516:	2192      	movs	r1, #146	@ 0x92
3401e518:	4833      	ldr	r0, [pc, #204]	@ (3401e5e8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401e51a:	f001 fe89 	bl	34020230 <__assert_func>

      nn_instance = __ll_current_aton_ip_owner;
3401e51e:	4b2f      	ldr	r3, [pc, #188]	@ (3401e5dc <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401e520:	681b      	ldr	r3, [r3, #0]
3401e522:	603b      	str	r3, [r7, #0]
    }

    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401e524:	4b2d      	ldr	r3, [pc, #180]	@ (3401e5dc <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401e526:	681b      	ldr	r3, [r3, #0]
3401e528:	2b00      	cmp	r3, #0
3401e52a:	d105      	bne.n	3401e538 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x58>
3401e52c:	4b2c      	ldr	r3, [pc, #176]	@ (3401e5e0 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x100>)
3401e52e:	4a2d      	ldr	r2, [pc, #180]	@ (3401e5e4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401e530:	2197      	movs	r1, #151	@ 0x97
3401e532:	482d      	ldr	r0, [pc, #180]	@ (3401e5e8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401e534:	f001 fe7c 	bl	34020230 <__assert_func>
    LL_ATON_ASSERT(unlock ? EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block)
3401e538:	79fb      	ldrb	r3, [r7, #7]
3401e53a:	2b00      	cmp	r3, #0
3401e53c:	d006      	beq.n	3401e54c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x6c>
3401e53e:	683b      	ldr	r3, [r7, #0]
3401e540:	685b      	ldr	r3, [r3, #4]
3401e542:	4618      	mov	r0, r3
3401e544:	f7ff fe70 	bl	3401e228 <EpochBlock_IsLastEpochBlock>
3401e548:	4603      	mov	r3, r0
3401e54a:	e005      	b.n	3401e558 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x78>
3401e54c:	683b      	ldr	r3, [r7, #0]
3401e54e:	685b      	ldr	r3, [r3, #4]
3401e550:	4618      	mov	r0, r3
3401e552:	f7ff fec8 	bl	3401e2e6 <EpochBlock_IsEpochInternal>
3401e556:	4603      	mov	r3, r0
3401e558:	2b00      	cmp	r3, #0
3401e55a:	d105      	bne.n	3401e568 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x88>
3401e55c:	4b24      	ldr	r3, [pc, #144]	@ (3401e5f0 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x110>)
3401e55e:	4a21      	ldr	r2, [pc, #132]	@ (3401e5e4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401e560:	2198      	movs	r1, #152	@ 0x98
3401e562:	4821      	ldr	r0, [pc, #132]	@ (3401e5e8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401e564:	f001 fe64 	bl	34020230 <__assert_func>
                          : EpochBlock_IsEpochInternal(nn_instance->exec_state.current_epoch_block));
    LL_ATON_ASSERT(EpochBlock_IsEpochHybrid(nn_instance->exec_state.saved_current_epoch_block));
3401e568:	683b      	ldr	r3, [r7, #0]
3401e56a:	691b      	ldr	r3, [r3, #16]
3401e56c:	4618      	mov	r0, r3
3401e56e:	f7ff fea7 	bl	3401e2c0 <EpochBlock_IsEpochHybrid>
3401e572:	4603      	mov	r3, r0
3401e574:	2b00      	cmp	r3, #0
3401e576:	d105      	bne.n	3401e584 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xa4>
3401e578:	4b1e      	ldr	r3, [pc, #120]	@ (3401e5f4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x114>)
3401e57a:	4a1a      	ldr	r2, [pc, #104]	@ (3401e5e4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401e57c:	219a      	movs	r1, #154	@ 0x9a
3401e57e:	481a      	ldr	r0, [pc, #104]	@ (3401e5e8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401e580:	f001 fe56 	bl	34020230 <__assert_func>

    /* Clear owner */
    if (unlock)
3401e584:	79fb      	ldrb	r3, [r7, #7]
3401e586:	2b00      	cmp	r3, #0
3401e588:	d004      	beq.n	3401e594 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xb4>
    {
      __ll_clear_aton_owner(__ll_current_aton_ip_owner);
3401e58a:	4b14      	ldr	r3, [pc, #80]	@ (3401e5dc <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401e58c:	681b      	ldr	r3, [r3, #0]
3401e58e:	4618      	mov	r0, r3
3401e590:	f7ff ff30 	bl	3401e3f4 <__ll_clear_aton_owner>
    }

    /* set old context */
    LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401e594:	683b      	ldr	r3, [r7, #0]
3401e596:	68db      	ldr	r3, [r3, #12]
3401e598:	2b00      	cmp	r3, #0
3401e59a:	d005      	beq.n	3401e5a8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xc8>
3401e59c:	4b16      	ldr	r3, [pc, #88]	@ (3401e5f8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x118>)
3401e59e:	4a11      	ldr	r2, [pc, #68]	@ (3401e5e4 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401e5a0:	21a3      	movs	r1, #163	@ 0xa3
3401e5a2:	4811      	ldr	r0, [pc, #68]	@ (3401e5e8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401e5a4:	f001 fe44 	bl	34020230 <__assert_func>
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.saved_current_epoch_block;
3401e5a8:	683b      	ldr	r3, [r7, #0]
3401e5aa:	691a      	ldr	r2, [r3, #16]
3401e5ac:	683b      	ldr	r3, [r7, #0]
3401e5ae:	605a      	str	r2, [r3, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.saved_first_epoch_block;
3401e5b0:	683b      	ldr	r3, [r7, #0]
3401e5b2:	695a      	ldr	r2, [r3, #20]
3401e5b4:	683b      	ldr	r3, [r7, #0]
3401e5b6:	609a      	str	r2, [r3, #8]

#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = nn_instance->exec_state.saved_nr_of_epoch_blocks;
3401e5b8:	683b      	ldr	r3, [r7, #0]
3401e5ba:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3401e5bc:	683b      	ldr	r3, [r7, #0]
3401e5be:	625a      	str	r2, [r3, #36]	@ 0x24
#endif

    /* reset saved context */
    nn_instance->exec_state.saved_current_epoch_block = NULL;
3401e5c0:	683b      	ldr	r3, [r7, #0]
3401e5c2:	2200      	movs	r2, #0
3401e5c4:	611a      	str	r2, [r3, #16]
    nn_instance->exec_state.saved_first_epoch_block = NULL;
3401e5c6:	683b      	ldr	r3, [r7, #0]
3401e5c8:	2200      	movs	r2, #0
3401e5ca:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401e5cc:	683b      	ldr	r3, [r7, #0]
3401e5ce:	2200      	movs	r2, #0
3401e5d0:	629a      	str	r2, [r3, #40]	@ 0x28
#endif
  }
3401e5d2:	bf00      	nop
3401e5d4:	3708      	adds	r7, #8
3401e5d6:	46bd      	mov	sp, r7
3401e5d8:	bd80      	pop	{r7, pc}
3401e5da:	bf00      	nop
3401e5dc:	34053db0 	.word	0x34053db0
3401e5e0:	34024b80 	.word	0x34024b80
3401e5e4:	34033118 	.word	0x34033118
3401e5e8:	34024a60 	.word	0x34024a60
3401e5ec:	34024bac 	.word	0x34024bac
3401e5f0:	34024bc8 	.word	0x34024bc8
3401e5f4:	34024c64 	.word	0x34024c64
3401e5f8:	34024cb0 	.word	0x34024cb0

3401e5fc <dump_dma_state>:
#error current ATON runtime supports only up to 32 epoch controllers!
#endif // (ATON_EPOCHCTRL_NUM > 32)

#endif // `ATON_INT_NR` and `ATON_STRENG_NUM` are defined

LL_ATON_WEAK void dump_dma_state(void){};
3401e5fc:	b480      	push	{r7}
3401e5fe:	af00      	add	r7, sp, #0
3401e600:	bf00      	nop
3401e602:	46bd      	mov	sp, r7
3401e604:	f85d 7b04 	ldr.w	r7, [sp], #4
3401e608:	4770      	bx	lr

3401e60a <__LL_ATON_RT_CntEpochBlocks>:

/*** Helper Functions ***/

#ifndef NDEBUG
static uint32_t __LL_ATON_RT_CntEpochBlocks(const LL_ATON_RT_EpochBlockItem_t *list)
{
3401e60a:	b580      	push	{r7, lr}
3401e60c:	b084      	sub	sp, #16
3401e60e:	af00      	add	r7, sp, #0
3401e610:	6078      	str	r0, [r7, #4]
  int i = 0;
3401e612:	2300      	movs	r3, #0
3401e614:	60fb      	str	r3, [r7, #12]

  if (list != NULL)
3401e616:	687b      	ldr	r3, [r7, #4]
3401e618:	2b00      	cmp	r3, #0
3401e61a:	d011      	beq.n	3401e640 <__LL_ATON_RT_CntEpochBlocks+0x36>
  {
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401e61c:	2301      	movs	r3, #1
3401e61e:	60fb      	str	r3, [r7, #12]
3401e620:	e005      	b.n	3401e62e <__LL_ATON_RT_CntEpochBlocks+0x24>
    { // Note: also terminating empty epoch block is counted
      list++;
3401e622:	687b      	ldr	r3, [r7, #4]
3401e624:	3314      	adds	r3, #20
3401e626:	607b      	str	r3, [r7, #4]
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401e628:	68fb      	ldr	r3, [r7, #12]
3401e62a:	3301      	adds	r3, #1
3401e62c:	60fb      	str	r3, [r7, #12]
3401e62e:	6878      	ldr	r0, [r7, #4]
3401e630:	f7ff fdfa 	bl	3401e228 <EpochBlock_IsLastEpochBlock>
3401e634:	4603      	mov	r3, r0
3401e636:	f083 0301 	eor.w	r3, r3, #1
3401e63a:	b2db      	uxtb	r3, r3
3401e63c:	2b00      	cmp	r3, #0
3401e63e:	d1f0      	bne.n	3401e622 <__LL_ATON_RT_CntEpochBlocks+0x18>
    }
  }

  return i;
3401e640:	68fb      	ldr	r3, [r7, #12]
}
3401e642:	4618      	mov	r0, r3
3401e644:	3710      	adds	r7, #16
3401e646:	46bd      	mov	sp, r7
3401e648:	bd80      	pop	{r7, pc}
	...

3401e64c <__LL_ATON_RT_ExecStartEpochBlock>:
#endif

static inline void __LL_ATON_RT_ExecStartEpochBlock(const LL_ATON_RT_EpochBlockItem_t *eb,
                                                    NN_Instance_TypeDef *nn_instance)
{
3401e64c:	b580      	push	{r7, lr}
3401e64e:	b086      	sub	sp, #24
3401e650:	af00      	add	r7, sp, #0
3401e652:	6078      	str	r0, [r7, #4]
3401e654:	6039      	str	r1, [r7, #0]
  LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401e656:	683b      	ldr	r3, [r7, #0]
3401e658:	68db      	ldr	r3, [r3, #12]
3401e65a:	2b00      	cmp	r3, #0
3401e65c:	d005      	beq.n	3401e66a <__LL_ATON_RT_ExecStartEpochBlock+0x1e>
3401e65e:	4b4a      	ldr	r3, [pc, #296]	@ (3401e788 <__LL_ATON_RT_ExecStartEpochBlock+0x13c>)
3401e660:	4a4a      	ldr	r2, [pc, #296]	@ (3401e78c <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401e662:	2161      	movs	r1, #97	@ 0x61
3401e664:	484a      	ldr	r0, [pc, #296]	@ (3401e790 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401e666:	f001 fde3 	bl	34020230 <__assert_func>

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401e66a:	683b      	ldr	r3, [r7, #0]
3401e66c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e66e:	2b00      	cmp	r3, #0
3401e670:	d005      	beq.n	3401e67e <__LL_ATON_RT_ExecStartEpochBlock+0x32>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_START, nn_instance, eb);
3401e672:	683b      	ldr	r3, [r7, #0]
3401e674:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e676:	687a      	ldr	r2, [r7, #4]
3401e678:	6839      	ldr	r1, [r7, #0]
3401e67a:	2000      	movs	r0, #0
3401e67c:	4798      	blx	r3

  /* Is it the first epoch block in an AtoNN epoch? */
  if (EpochBlock_IsEpochStart(eb))
3401e67e:	6878      	ldr	r0, [r7, #4]
3401e680:	f7ff fde5 	bl	3401e24e <EpochBlock_IsEpochStart>
3401e684:	4603      	mov	r3, r0
3401e686:	2b00      	cmp	r3, #0
3401e688:	d002      	beq.n	3401e690 <__LL_ATON_RT_ExecStartEpochBlock+0x44>
  {
    __LL_ATON_RT_Start_AtoNN_Epoch(nn_instance);
3401e68a:	6838      	ldr	r0, [r7, #0]
3401e68c:	f7ff fede 	bl	3401e44c <__LL_ATON_RT_Start_AtoNN_Epoch>
  }

  /* Grab ATON IP lock in case not a pure SW or internal epoch */
  if (EpochBlock_IsEpochPureHW(eb) ||
3401e690:	6878      	ldr	r0, [r7, #4]
3401e692:	f7ff fe02 	bl	3401e29a <EpochBlock_IsEpochPureHW>
3401e696:	4603      	mov	r3, r0
3401e698:	2b00      	cmp	r3, #0
3401e69a:	d105      	bne.n	3401e6a8 <__LL_ATON_RT_ExecStartEpochBlock+0x5c>
      EpochBlock_IsEpochHybrid(eb)) // epoch blobs are flagged as pure HW, so checking for epoch blob is not necessary
3401e69c:	6878      	ldr	r0, [r7, #4]
3401e69e:	f7ff fe0f 	bl	3401e2c0 <EpochBlock_IsEpochHybrid>
3401e6a2:	4603      	mov	r3, r0
  if (EpochBlock_IsEpochPureHW(eb) ||
3401e6a4:	2b00      	cmp	r3, #0
3401e6a6:	d002      	beq.n	3401e6ae <__LL_ATON_RT_ExecStartEpochBlock+0x62>
  {
    __ll_set_aton_owner(nn_instance);
3401e6a8:	6838      	ldr	r0, [r7, #0]
3401e6aa:	f7ff fe6b 	bl	3401e384 <__ll_set_aton_owner>
  }

  if (!EpochBlock_IsEpochBlob(eb))
3401e6ae:	6878      	ldr	r0, [r7, #4]
3401e6b0:	f7ff fde0 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401e6b4:	4603      	mov	r3, r0
3401e6b6:	f083 0301 	eor.w	r3, r3, #1
3401e6ba:	b2db      	uxtb	r3, r3
3401e6bc:	2b00      	cmp	r3, #0
3401e6be:	d01c      	beq.n	3401e6fa <__LL_ATON_RT_ExecStartEpochBlock+0xae>
  { // standard epoch block handling based on streaming engines
    /* set wait mask(s) in interrupt controller */
    if (EpochBlock_IsEpochPureHW(eb) || EpochBlock_IsEpochInternal(eb))
3401e6c0:	6878      	ldr	r0, [r7, #4]
3401e6c2:	f7ff fdea 	bl	3401e29a <EpochBlock_IsEpochPureHW>
3401e6c6:	4603      	mov	r3, r0
3401e6c8:	2b00      	cmp	r3, #0
3401e6ca:	d105      	bne.n	3401e6d8 <__LL_ATON_RT_ExecStartEpochBlock+0x8c>
3401e6cc:	6878      	ldr	r0, [r7, #4]
3401e6ce:	f7ff fe0a 	bl	3401e2e6 <EpochBlock_IsEpochInternal>
3401e6d2:	4603      	mov	r3, r0
3401e6d4:	2b00      	cmp	r3, #0
3401e6d6:	d014      	beq.n	3401e702 <__LL_ATON_RT_ExecStartEpochBlock+0xb6>
    {
      LL_ATON_ASSERT(__ll_current_aton_ip_owner == nn_instance);
3401e6d8:	4b2e      	ldr	r3, [pc, #184]	@ (3401e794 <__LL_ATON_RT_ExecStartEpochBlock+0x148>)
3401e6da:	681b      	ldr	r3, [r3, #0]
3401e6dc:	683a      	ldr	r2, [r7, #0]
3401e6de:	429a      	cmp	r2, r3
3401e6e0:	d005      	beq.n	3401e6ee <__LL_ATON_RT_ExecStartEpochBlock+0xa2>
3401e6e2:	4b2d      	ldr	r3, [pc, #180]	@ (3401e798 <__LL_ATON_RT_ExecStartEpochBlock+0x14c>)
3401e6e4:	4a29      	ldr	r2, [pc, #164]	@ (3401e78c <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401e6e6:	2178      	movs	r1, #120	@ 0x78
3401e6e8:	4829      	ldr	r0, [pc, #164]	@ (3401e790 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401e6ea:	f001 fda1 	bl	34020230 <__assert_func>
      __LL_ATON_RT_SetWaitMask(eb->wait_mask);
3401e6ee:	687b      	ldr	r3, [r7, #4]
3401e6f0:	68db      	ldr	r3, [r3, #12]
3401e6f2:	4618      	mov	r0, r3
3401e6f4:	f7ff fece 	bl	3401e494 <__LL_ATON_RT_SetWaitMask>
3401e6f8:	e003      	b.n	3401e702 <__LL_ATON_RT_ExecStartEpochBlock+0xb6>
  else
  { // epoch blob handling based on epoch controller
#if defined(ATON_EPOCHCTRL_NUM) &&                                                                                     \
    (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC) // Polling mode is not allowed/supported when using the epoch controller
    /* reset wait mask(s) in interrupt controller, but ignore stream engine completion event interrupts */
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
3401e6fa:	f240 30ff 	movw	r0, #1023	@ 0x3ff
3401e6fe:	f7ff fec9 	bl	3401e494 <__LL_ATON_RT_SetWaitMask>
#endif // ATON_PLAT_HAS_FFLUSH
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM || LL_ATON_RT_POLLING
  }

  if (eb->start_epoch_block != NULL)
3401e702:	687b      	ldr	r3, [r7, #4]
3401e704:	681b      	ldr	r3, [r3, #0]
3401e706:	2b00      	cmp	r3, #0
3401e708:	d003      	beq.n	3401e712 <__LL_ATON_RT_ExecStartEpochBlock+0xc6>
    else
    {
      eb->start_epoch_block((const void *)eb);
    }
#else
    eb->start_epoch_block((const void *)eb);
3401e70a:	687b      	ldr	r3, [r7, #4]
3401e70c:	681b      	ldr	r3, [r3, #0]
3401e70e:	6878      	ldr	r0, [r7, #4]
3401e710:	4798      	blx	r3
#endif
  }

  if (EpochBlock_IsEpochBlob(eb))
3401e712:	6878      	ldr	r0, [r7, #4]
3401e714:	f7ff fdae 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401e718:	4603      	mov	r3, r0
3401e71a:	2b00      	cmp	r3, #0
3401e71c:	d026      	beq.n	3401e76c <__LL_ATON_RT_ExecStartEpochBlock+0x120>
  {
#if defined(ATON_EPOCHCTRL_NUM)
    /* configure epoch controller */
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
3401e71e:	6878      	ldr	r0, [r7, #4]
3401e720:	f7ff fdf4 	bl	3401e30c <EpochBlock_EpochControllerUnit>
3401e724:	6178      	str	r0, [r7, #20]
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401e726:	697b      	ldr	r3, [r7, #20]
3401e728:	2b00      	cmp	r3, #0
3401e72a:	d005      	beq.n	3401e738 <__LL_ATON_RT_ExecStartEpochBlock+0xec>
3401e72c:	4b1b      	ldr	r3, [pc, #108]	@ (3401e79c <__LL_ATON_RT_ExecStartEpochBlock+0x150>)
3401e72e:	4a17      	ldr	r2, [pc, #92]	@ (3401e78c <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401e730:	21a4      	movs	r1, #164	@ 0xa4
3401e732:	4817      	ldr	r0, [pc, #92]	@ (3401e790 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401e734:	f001 fd7c 	bl	34020230 <__assert_func>

    LL_EpochCtrl_InitTypeDef conf;
    conf.stepmode = 0;
3401e738:	7b3b      	ldrb	r3, [r7, #12]
3401e73a:	f023 0301 	bic.w	r3, r3, #1
3401e73e:	733b      	strb	r3, [r7, #12]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
3401e740:	6878      	ldr	r0, [r7, #4]
3401e742:	f7ff fe01 	bl	3401e348 <EpochBlock_EpochBlobAddr>
3401e746:	4603      	mov	r3, r0
3401e748:	60bb      	str	r3, [r7, #8]

    LL_EpochCtrl_Init(ecId, &conf);
3401e74a:	697b      	ldr	r3, [r7, #20]
3401e74c:	f107 0208 	add.w	r2, r7, #8
3401e750:	4611      	mov	r1, r2
3401e752:	4618      	mov	r0, r3
3401e754:	f7ff fc68 	bl	3401e028 <LL_EpochCtrl_Init>

    /* start/enable epoch controller */
    ATON_ENABLE(EPOCHCTRL, ecId);
3401e758:	4b11      	ldr	r3, [pc, #68]	@ (3401e7a0 <__LL_ATON_RT_ExecStartEpochBlock+0x154>)
3401e75a:	681b      	ldr	r3, [r3, #0]
3401e75c:	613b      	str	r3, [r7, #16]
3401e75e:	693b      	ldr	r3, [r7, #16]
3401e760:	f043 0301 	orr.w	r3, r3, #1
3401e764:	613b      	str	r3, [r7, #16]
3401e766:	4a0e      	ldr	r2, [pc, #56]	@ (3401e7a0 <__LL_ATON_RT_ExecStartEpochBlock+0x154>)
3401e768:	693b      	ldr	r3, [r7, #16]
3401e76a:	6013      	str	r3, [r2, #0]
#else  // !ATON_EPOCHCTRL_NUM
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM
  }

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401e76c:	683b      	ldr	r3, [r7, #0]
3401e76e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e770:	2b00      	cmp	r3, #0
3401e772:	d005      	beq.n	3401e780 <__LL_ATON_RT_ExecStartEpochBlock+0x134>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_START, nn_instance, eb);
3401e774:	683b      	ldr	r3, [r7, #0]
3401e776:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e778:	687a      	ldr	r2, [r7, #4]
3401e77a:	6839      	ldr	r1, [r7, #0]
3401e77c:	2001      	movs	r0, #1
3401e77e:	4798      	blx	r3
}
3401e780:	bf00      	nop
3401e782:	3718      	adds	r7, #24
3401e784:	46bd      	mov	sp, r7
3401e786:	bd80      	pop	{r7, pc}
3401e788:	34024cb0 	.word	0x34024cb0
3401e78c:	34033140 	.word	0x34033140
3401e790:	34024ce8 	.word	0x34024ce8
3401e794:	34053db0 	.word	0x34053db0
3401e798:	34024d48 	.word	0x34024d48
3401e79c:	34024d74 	.word	0x34024d74
3401e7a0:	580fe000 	.word	0x580fe000

3401e7a4 <__LL_ATON_RT_ExecEndEpochBlock>:

static inline void __LL_ATON_RT_ExecEndEpochBlock(const LL_ATON_RT_EpochBlockItem_t *eb,
                                                  NN_Instance_TypeDef *nn_instance)
{
3401e7a4:	b580      	push	{r7, lr}
3401e7a6:	b084      	sub	sp, #16
3401e7a8:	af00      	add	r7, sp, #0
3401e7aa:	6078      	str	r0, [r7, #4]
3401e7ac:	6039      	str	r1, [r7, #0]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401e7ae:	683b      	ldr	r3, [r7, #0]
3401e7b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e7b2:	2b00      	cmp	r3, #0
3401e7b4:	d005      	beq.n	3401e7c2 <__LL_ATON_RT_ExecEndEpochBlock+0x1e>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_END, nn_instance, eb);
3401e7b6:	683b      	ldr	r3, [r7, #0]
3401e7b8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e7ba:	687a      	ldr	r2, [r7, #4]
3401e7bc:	6839      	ldr	r1, [r7, #0]
3401e7be:	2002      	movs	r0, #2
3401e7c0:	4798      	blx	r3

  if (EpochBlock_IsEpochBlob(eb))
3401e7c2:	6878      	ldr	r0, [r7, #4]
3401e7c4:	f7ff fd56 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401e7c8:	4603      	mov	r3, r0
3401e7ca:	2b00      	cmp	r3, #0
3401e7cc:	d033      	beq.n	3401e836 <__LL_ATON_RT_ExecEndEpochBlock+0x92>
  {
#if defined(ATON_EPOCHCTRL_NUM)
    /* stop/disable epoch controller */
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
3401e7ce:	6878      	ldr	r0, [r7, #4]
3401e7d0:	f7ff fd9c 	bl	3401e30c <EpochBlock_EpochControllerUnit>
3401e7d4:	60f8      	str	r0, [r7, #12]
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401e7d6:	68fb      	ldr	r3, [r7, #12]
3401e7d8:	2b00      	cmp	r3, #0
3401e7da:	d005      	beq.n	3401e7e8 <__LL_ATON_RT_ExecEndEpochBlock+0x44>
3401e7dc:	4b48      	ldr	r3, [pc, #288]	@ (3401e900 <__LL_ATON_RT_ExecEndEpochBlock+0x15c>)
3401e7de:	4a49      	ldr	r2, [pc, #292]	@ (3401e904 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401e7e0:	21c2      	movs	r1, #194	@ 0xc2
3401e7e2:	4849      	ldr	r0, [pc, #292]	@ (3401e908 <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401e7e4:	f001 fd24 	bl	34020230 <__assert_func>
    uint32_t t;
    ATON_DISABLE_CLR_CONFCLR(EPOCHCTRL, ecId);
3401e7e8:	2300      	movs	r3, #0
3401e7ea:	60bb      	str	r3, [r7, #8]
3401e7ec:	68bb      	ldr	r3, [r7, #8]
3401e7ee:	f023 0301 	bic.w	r3, r3, #1
3401e7f2:	60bb      	str	r3, [r7, #8]
3401e7f4:	68bb      	ldr	r3, [r7, #8]
3401e7f6:	f043 0302 	orr.w	r3, r3, #2
3401e7fa:	60bb      	str	r3, [r7, #8]
3401e7fc:	4a43      	ldr	r2, [pc, #268]	@ (3401e90c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401e7fe:	68bb      	ldr	r3, [r7, #8]
3401e800:	6013      	str	r3, [r2, #0]
3401e802:	4b42      	ldr	r3, [pc, #264]	@ (3401e90c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401e804:	681b      	ldr	r3, [r3, #0]
3401e806:	f003 0302 	and.w	r3, r3, #2
3401e80a:	2b00      	cmp	r3, #0
3401e80c:	d1f9      	bne.n	3401e802 <__LL_ATON_RT_ExecEndEpochBlock+0x5e>
3401e80e:	2300      	movs	r3, #0
3401e810:	60bb      	str	r3, [r7, #8]
3401e812:	68bb      	ldr	r3, [r7, #8]
3401e814:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3401e818:	60bb      	str	r3, [r7, #8]
3401e81a:	4a3c      	ldr	r2, [pc, #240]	@ (3401e90c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401e81c:	68bb      	ldr	r3, [r7, #8]
3401e81e:	6013      	str	r3, [r2, #0]
3401e820:	4b3a      	ldr	r3, [pc, #232]	@ (3401e90c <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401e822:	681b      	ldr	r3, [r3, #0]
3401e824:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401e828:	2b00      	cmp	r3, #0
3401e82a:	d1f9      	bne.n	3401e820 <__LL_ATON_RT_ExecEndEpochBlock+0x7c>

    /* disable epoch controller clock */
    LL_ATON_DisableClock(ATON_EPOCHCTRL_CLKB_CLK(ecId));
3401e82c:	68fb      	ldr	r3, [r7, #12]
3401e82e:	3319      	adds	r3, #25
3401e830:	4618      	mov	r0, r3
3401e832:	f7ff fc5f 	bl	3401e0f4 <LL_ATON_DisableClock>
#else  // !ATON_EPOCHCTRL_NUM
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM
  }

  if (eb->end_epoch_block != NULL)
3401e836:	687b      	ldr	r3, [r7, #4]
3401e838:	685b      	ldr	r3, [r3, #4]
3401e83a:	2b00      	cmp	r3, #0
3401e83c:	d003      	beq.n	3401e846 <__LL_ATON_RT_ExecEndEpochBlock+0xa2>
    else
    {
      eb->end_epoch_block((const void *)eb);
    }
#else
    eb->end_epoch_block((const void *)eb);
3401e83e:	687b      	ldr	r3, [r7, #4]
3401e840:	685b      	ldr	r3, [r3, #4]
3401e842:	6878      	ldr	r0, [r7, #4]
3401e844:	4798      	blx	r3
#endif
  }

  /* Reset wait mask */
  if (EpochBlock_IsEpochPureHW(eb) ||
3401e846:	6878      	ldr	r0, [r7, #4]
3401e848:	f7ff fd27 	bl	3401e29a <EpochBlock_IsEpochPureHW>
3401e84c:	4603      	mov	r3, r0
3401e84e:	2b00      	cmp	r3, #0
3401e850:	d105      	bne.n	3401e85e <__LL_ATON_RT_ExecEndEpochBlock+0xba>
      EpochBlock_IsEpochInternal(eb)) // epoch blobs are flagged as pure HW, so checking for epoch blob is not necessary
3401e852:	6878      	ldr	r0, [r7, #4]
3401e854:	f7ff fd47 	bl	3401e2e6 <EpochBlock_IsEpochInternal>
3401e858:	4603      	mov	r3, r0
  if (EpochBlock_IsEpochPureHW(eb) ||
3401e85a:	2b00      	cmp	r3, #0
3401e85c:	d00d      	beq.n	3401e87a <__LL_ATON_RT_ExecEndEpochBlock+0xd6>
  {
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
3401e85e:	4b2c      	ldr	r3, [pc, #176]	@ (3401e910 <__LL_ATON_RT_ExecEndEpochBlock+0x16c>)
3401e860:	681b      	ldr	r3, [r3, #0]
3401e862:	683a      	ldr	r2, [r7, #0]
3401e864:	429a      	cmp	r2, r3
3401e866:	d005      	beq.n	3401e874 <__LL_ATON_RT_ExecEndEpochBlock+0xd0>
3401e868:	4b2a      	ldr	r3, [pc, #168]	@ (3401e914 <__LL_ATON_RT_ExecEndEpochBlock+0x170>)
3401e86a:	4a26      	ldr	r2, [pc, #152]	@ (3401e904 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401e86c:	21e1      	movs	r1, #225	@ 0xe1
3401e86e:	4826      	ldr	r0, [pc, #152]	@ (3401e908 <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401e870:	f001 fcde 	bl	34020230 <__assert_func>
    __LL_ATON_RT_SetWaitMask(0);
3401e874:	2000      	movs	r0, #0
3401e876:	f7ff fe0d 	bl	3401e494 <__LL_ATON_RT_SetWaitMask>
  }

  /* Release ATON IP unlock in case it's a pure HW epoch */
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401e87a:	6878      	ldr	r0, [r7, #4]
3401e87c:	f7ff fd0d 	bl	3401e29a <EpochBlock_IsEpochPureHW>
3401e880:	4603      	mov	r3, r0
3401e882:	2b00      	cmp	r3, #0
3401e884:	d113      	bne.n	3401e8ae <__LL_ATON_RT_ExecEndEpochBlock+0x10a>
3401e886:	6878      	ldr	r0, [r7, #4]
3401e888:	f7ff fd1a 	bl	3401e2c0 <EpochBlock_IsEpochHybrid>
3401e88c:	4603      	mov	r3, r0
3401e88e:	2b00      	cmp	r3, #0
3401e890:	d105      	bne.n	3401e89e <__LL_ATON_RT_ExecEndEpochBlock+0xfa>
3401e892:	6878      	ldr	r0, [r7, #4]
3401e894:	f7ff fd27 	bl	3401e2e6 <EpochBlock_IsEpochInternal>
3401e898:	4603      	mov	r3, r0
3401e89a:	2b00      	cmp	r3, #0
3401e89c:	d00a      	beq.n	3401e8b4 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401e89e:	683b      	ldr	r3, [r7, #0]
3401e8a0:	691b      	ldr	r3, [r3, #16]
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401e8a2:	2b00      	cmp	r3, #0
3401e8a4:	d106      	bne.n	3401e8b4 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                       (nn_instance->exec_state.next_epoch_block ==
3401e8a6:	683b      	ldr	r3, [r7, #0]
3401e8a8:	68db      	ldr	r3, [r3, #12]
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401e8aa:	2b00      	cmp	r3, #0
3401e8ac:	d102      	bne.n	3401e8b4 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                        NULL))) /* hybrid has finished after that last part has been executed in SW */
  {
    __ll_clear_aton_owner(nn_instance);
3401e8ae:	6838      	ldr	r0, [r7, #0]
3401e8b0:	f7ff fda0 	bl	3401e3f4 <__ll_clear_aton_owner>
  }
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
3401e8b4:	6878      	ldr	r0, [r7, #4]
3401e8b6:	f7ff fd16 	bl	3401e2e6 <EpochBlock_IsEpochInternal>
3401e8ba:	4603      	mov	r3, r0
3401e8bc:	2b00      	cmp	r3, #0
3401e8be:	d110      	bne.n	3401e8e2 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401e8c0:	6878      	ldr	r0, [r7, #4]
3401e8c2:	f7ff fcfd 	bl	3401e2c0 <EpochBlock_IsEpochHybrid>
3401e8c6:	4603      	mov	r3, r0
3401e8c8:	2b00      	cmp	r3, #0
3401e8ca:	d10a      	bne.n	3401e8e2 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401e8cc:	4b10      	ldr	r3, [pc, #64]	@ (3401e910 <__LL_ATON_RT_ExecEndEpochBlock+0x16c>)
3401e8ce:	681b      	ldr	r3, [r3, #0]
3401e8d0:	683a      	ldr	r2, [r7, #0]
3401e8d2:	429a      	cmp	r2, r3
3401e8d4:	d105      	bne.n	3401e8e2 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401e8d6:	4b10      	ldr	r3, [pc, #64]	@ (3401e918 <__LL_ATON_RT_ExecEndEpochBlock+0x174>)
3401e8d8:	4a0a      	ldr	r2, [pc, #40]	@ (3401e904 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401e8da:	21ed      	movs	r1, #237	@ 0xed
3401e8dc:	480a      	ldr	r0, [pc, #40]	@ (3401e908 <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401e8de:	f001 fca7 	bl	34020230 <__assert_func>
                 (__ll_current_aton_ip_owner != nn_instance));

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401e8e2:	683b      	ldr	r3, [r7, #0]
3401e8e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e8e6:	2b00      	cmp	r3, #0
3401e8e8:	d005      	beq.n	3401e8f6 <__LL_ATON_RT_ExecEndEpochBlock+0x152>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
3401e8ea:	683b      	ldr	r3, [r7, #0]
3401e8ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e8ee:	687a      	ldr	r2, [r7, #4]
3401e8f0:	6839      	ldr	r1, [r7, #0]
3401e8f2:	2003      	movs	r0, #3
3401e8f4:	4798      	blx	r3
  }
}
3401e8f6:	bf00      	nop
3401e8f8:	3710      	adds	r7, #16
3401e8fa:	46bd      	mov	sp, r7
3401e8fc:	bd80      	pop	{r7, pc}
3401e8fe:	bf00      	nop
3401e900:	34024d74 	.word	0x34024d74
3401e904:	340331f0 	.word	0x340331f0
3401e908:	34024ce8 	.word	0x34024ce8
3401e90c:	580fe000 	.word	0x580fe000
3401e910:	34053db0 	.word	0x34053db0
3401e914:	34024d80 	.word	0x34024d80
3401e918:	34024dac 	.word	0x34024dac

3401e91c <__LL_ATON_RT_DetermineNextEpochBlock>:

static void __LL_ATON_RT_DetermineNextEpochBlock(NN_Instance_TypeDef *nn_instance)
{
3401e91c:	b580      	push	{r7, lr}
3401e91e:	b082      	sub	sp, #8
3401e920:	af00      	add	r7, sp, #0
3401e922:	6078      	str	r0, [r7, #4]
  LL_ATON_ASSERT(nn_instance != NULL);
3401e924:	687b      	ldr	r3, [r7, #4]
3401e926:	2b00      	cmp	r3, #0
3401e928:	d105      	bne.n	3401e936 <__LL_ATON_RT_DetermineNextEpochBlock+0x1a>
3401e92a:	4b26      	ldr	r3, [pc, #152]	@ (3401e9c4 <__LL_ATON_RT_DetermineNextEpochBlock+0xa8>)
3401e92c:	4a26      	ldr	r2, [pc, #152]	@ (3401e9c8 <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401e92e:	21f8      	movs	r1, #248	@ 0xf8
3401e930:	4826      	ldr	r0, [pc, #152]	@ (3401e9cc <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401e932:	f001 fc7d 	bl	34020230 <__assert_func>
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401e936:	687b      	ldr	r3, [r7, #4]
3401e938:	69db      	ldr	r3, [r3, #28]
3401e93a:	2b00      	cmp	r3, #0
3401e93c:	d005      	beq.n	3401e94a <__LL_ATON_RT_DetermineNextEpochBlock+0x2e>
3401e93e:	4b24      	ldr	r3, [pc, #144]	@ (3401e9d0 <__LL_ATON_RT_DetermineNextEpochBlock+0xb4>)
3401e940:	4a21      	ldr	r2, [pc, #132]	@ (3401e9c8 <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401e942:	21fa      	movs	r1, #250	@ 0xfa
3401e944:	4821      	ldr	r0, [pc, #132]	@ (3401e9cc <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401e946:	f001 fc73 	bl	34020230 <__assert_func>
                 0x0); // with the removal of parallel SW/HW epochs execution all triggered events must have been
                       // cleared at this point in time!
#endif                 // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /* Determine if there is a new inserted epoch block array */
  if ((nn_instance->exec_state.next_epoch_block != NULL))
3401e94a:	687b      	ldr	r3, [r7, #4]
3401e94c:	68db      	ldr	r3, [r3, #12]
3401e94e:	2b00      	cmp	r3, #0
3401e950:	d02a      	beq.n	3401e9a8 <__LL_ATON_RT_DetermineNextEpochBlock+0x8c>
  {
    LL_ATON_ASSERT(nn_instance->exec_state.saved_current_epoch_block == NULL);
3401e952:	687b      	ldr	r3, [r7, #4]
3401e954:	691b      	ldr	r3, [r3, #16]
3401e956:	2b00      	cmp	r3, #0
3401e958:	d006      	beq.n	3401e968 <__LL_ATON_RT_DetermineNextEpochBlock+0x4c>
3401e95a:	4b1e      	ldr	r3, [pc, #120]	@ (3401e9d4 <__LL_ATON_RT_DetermineNextEpochBlock+0xb8>)
3401e95c:	4a1a      	ldr	r2, [pc, #104]	@ (3401e9c8 <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401e95e:	f44f 7181 	mov.w	r1, #258	@ 0x102
3401e962:	481a      	ldr	r0, [pc, #104]	@ (3401e9cc <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401e964:	f001 fc64 	bl	34020230 <__assert_func>

    /* save current context */
    nn_instance->exec_state.saved_current_epoch_block = nn_instance->exec_state.current_epoch_block;
3401e968:	687b      	ldr	r3, [r7, #4]
3401e96a:	685a      	ldr	r2, [r3, #4]
3401e96c:	687b      	ldr	r3, [r7, #4]
3401e96e:	611a      	str	r2, [r3, #16]
    nn_instance->exec_state.saved_first_epoch_block = nn_instance->exec_state.first_epoch_block;
3401e970:	687b      	ldr	r3, [r7, #4]
3401e972:	689a      	ldr	r2, [r3, #8]
3401e974:	687b      	ldr	r3, [r7, #4]
3401e976:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = nn_instance->exec_state.nr_of_epoch_blocks;
3401e978:	687b      	ldr	r3, [r7, #4]
3401e97a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401e97c:	687b      	ldr	r3, [r7, #4]
3401e97e:	629a      	str	r2, [r3, #40]	@ 0x28
#endif

    /* set new context */
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.next_epoch_block;
3401e980:	687b      	ldr	r3, [r7, #4]
3401e982:	68da      	ldr	r2, [r3, #12]
3401e984:	687b      	ldr	r3, [r7, #4]
3401e986:	605a      	str	r2, [r3, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.next_epoch_block;
3401e988:	687b      	ldr	r3, [r7, #4]
3401e98a:	68da      	ldr	r2, [r3, #12]
3401e98c:	687b      	ldr	r3, [r7, #4]
3401e98e:	609a      	str	r2, [r3, #8]
#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
3401e990:	687b      	ldr	r3, [r7, #4]
3401e992:	689b      	ldr	r3, [r3, #8]
3401e994:	4618      	mov	r0, r3
3401e996:	f7ff fe38 	bl	3401e60a <__LL_ATON_RT_CntEpochBlocks>
3401e99a:	4602      	mov	r2, r0
3401e99c:	687b      	ldr	r3, [r7, #4]
3401e99e:	625a      	str	r2, [r3, #36]	@ 0x24
#endif

    /* reset next epoch block */
    nn_instance->exec_state.next_epoch_block = NULL;
3401e9a0:	687b      	ldr	r3, [r7, #4]
3401e9a2:	2200      	movs	r2, #0
3401e9a4:	60da      	str	r2, [r3, #12]
3401e9a6:	e005      	b.n	3401e9b4 <__LL_ATON_RT_DetermineNextEpochBlock+0x98>
  }
  else
  {
    nn_instance->exec_state.current_epoch_block++;
3401e9a8:	687b      	ldr	r3, [r7, #4]
3401e9aa:	685b      	ldr	r3, [r3, #4]
3401e9ac:	f103 0214 	add.w	r2, r3, #20
3401e9b0:	687b      	ldr	r3, [r7, #4]
3401e9b2:	605a      	str	r2, [r3, #4]
  }

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.current_epoch_block_started = false;
3401e9b4:	687b      	ldr	r3, [r7, #4]
3401e9b6:	2200      	movs	r2, #0
3401e9b8:	f883 2020 	strb.w	r2, [r3, #32]
#endif
}
3401e9bc:	bf00      	nop
3401e9be:	3708      	adds	r7, #8
3401e9c0:	46bd      	mov	sp, r7
3401e9c2:	bd80      	pop	{r7, pc}
3401e9c4:	34024b34 	.word	0x34024b34
3401e9c8:	340330a4 	.word	0x340330a4
3401e9cc:	34024ce8 	.word	0x34024ce8
3401e9d0:	34024b50 	.word	0x34024b50
3401e9d4:	34024e1c 	.word	0x34024e1c

3401e9d8 <__LL_ATON_RT_GetWaitMask>:

static inline uint32_t __LL_ATON_RT_GetWaitMask(const LL_ATON_RT_EpochBlockItem_t *eb)
{
3401e9d8:	b580      	push	{r7, lr}
3401e9da:	b082      	sub	sp, #8
3401e9dc:	af00      	add	r7, sp, #0
3401e9de:	6078      	str	r0, [r7, #4]
  if (EpochBlock_IsEpochBlob(eb))
3401e9e0:	6878      	ldr	r0, [r7, #4]
3401e9e2:	f7ff fc47 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401e9e6:	4603      	mov	r3, r0
3401e9e8:	2b00      	cmp	r3, #0
3401e9ea:	d007      	beq.n	3401e9fc <__LL_ATON_RT_GetWaitMask+0x24>
  {
    // in case of epoch blob `wait_mask` contains unit number of epoch controller to use
    return (1 << EpochBlock_EpochControllerUnit(eb));
3401e9ec:	6878      	ldr	r0, [r7, #4]
3401e9ee:	f7ff fc8d 	bl	3401e30c <EpochBlock_EpochControllerUnit>
3401e9f2:	4603      	mov	r3, r0
3401e9f4:	2201      	movs	r2, #1
3401e9f6:	fa02 f303 	lsl.w	r3, r2, r3
3401e9fa:	e001      	b.n	3401ea00 <__LL_ATON_RT_GetWaitMask+0x28>
  }
  else
  {
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
3401e9fc:	687b      	ldr	r3, [r7, #4]
3401e9fe:	68db      	ldr	r3, [r3, #12]
                          // wait for
  }
}
3401ea00:	4618      	mov	r0, r3
3401ea02:	3708      	adds	r7, #8
3401ea04:	46bd      	mov	sp, r7
3401ea06:	bd80      	pop	{r7, pc}

3401ea08 <__LL_ATON_RT_Init_Network>:

static inline void __LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
3401ea08:	b580      	push	{r7, lr}
3401ea0a:	b084      	sub	sp, #16
3401ea0c:	af00      	add	r7, sp, #0
3401ea0e:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401ea10:	687b      	ldr	r3, [r7, #4]
3401ea12:	2b00      	cmp	r3, #0
3401ea14:	d037      	beq.n	3401ea86 <__LL_ATON_RT_Init_Network+0x7e>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
3401ea16:	687b      	ldr	r3, [r7, #4]
3401ea18:	681b      	ldr	r3, [r3, #0]
3401ea1a:	2b00      	cmp	r3, #0
3401ea1c:	d035      	beq.n	3401ea8a <__LL_ATON_RT_Init_Network+0x82>
  else
  {
    eb_list = nn_instance->network->epoch_block_items();
  }
#else
  const LL_ATON_RT_EpochBlockItem_t *eb_list = nn_instance->network->epoch_block_items();
3401ea1e:	687b      	ldr	r3, [r7, #4]
3401ea20:	681b      	ldr	r3, [r3, #0]
3401ea22:	69db      	ldr	r3, [r3, #28]
3401ea24:	4798      	blx	r3
3401ea26:	60f8      	str	r0, [r7, #12]
#endif
  nn_instance->exec_state.current_epoch_block = eb_list;
3401ea28:	687b      	ldr	r3, [r7, #4]
3401ea2a:	68fa      	ldr	r2, [r7, #12]
3401ea2c:	605a      	str	r2, [r3, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401ea2e:	687b      	ldr	r3, [r7, #4]
3401ea30:	68fa      	ldr	r2, [r7, #12]
3401ea32:	609a      	str	r2, [r3, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401ea34:	687b      	ldr	r3, [r7, #4]
3401ea36:	2200      	movs	r2, #0
3401ea38:	60da      	str	r2, [r3, #12]

  /* set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
3401ea3a:	687b      	ldr	r3, [r7, #4]
3401ea3c:	2200      	movs	r2, #0
3401ea3e:	611a      	str	r2, [r3, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
3401ea40:	687b      	ldr	r3, [r7, #4]
3401ea42:	2200      	movs	r2, #0
3401ea44:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
3401ea46:	687b      	ldr	r3, [r7, #4]
3401ea48:	685b      	ldr	r3, [r3, #4]
3401ea4a:	4618      	mov	r0, r3
3401ea4c:	f7ff fddd 	bl	3401e60a <__LL_ATON_RT_CntEpochBlocks>
3401ea50:	4602      	mov	r2, r0
3401ea52:	687b      	ldr	r3, [r7, #4]
3401ea54:	625a      	str	r2, [r3, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401ea56:	687b      	ldr	r3, [r7, #4]
3401ea58:	2200      	movs	r2, #0
3401ea5a:	629a      	str	r2, [r3, #40]	@ 0x28
#endif

  /* set information about running inference */
  nn_instance->exec_state.inference_started = false;
3401ea5c:	687b      	ldr	r3, [r7, #4]
3401ea5e:	2200      	movs	r2, #0
3401ea60:	761a      	strb	r2, [r3, #24]

  /* set asynchronous status variables */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.triggered_events = 0x0;
3401ea62:	687b      	ldr	r3, [r7, #4]
3401ea64:	2200      	movs	r2, #0
3401ea66:	61da      	str	r2, [r3, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401ea68:	687b      	ldr	r3, [r7, #4]
3401ea6a:	2200      	movs	r2, #0
3401ea6c:	f883 2020 	strb.w	r2, [r3, #32]
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_Init` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401ea70:	687b      	ldr	r3, [r7, #4]
3401ea72:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ea74:	2b00      	cmp	r3, #0
3401ea76:	d009      	beq.n	3401ea8c <__LL_ATON_RT_Init_Network+0x84>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
3401ea78:	687b      	ldr	r3, [r7, #4]
3401ea7a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ea7c:	2200      	movs	r2, #0
3401ea7e:	6879      	ldr	r1, [r7, #4]
3401ea80:	2004      	movs	r0, #4
3401ea82:	4798      	blx	r3
3401ea84:	e002      	b.n	3401ea8c <__LL_ATON_RT_Init_Network+0x84>
    return;
3401ea86:	bf00      	nop
3401ea88:	e000      	b.n	3401ea8c <__LL_ATON_RT_Init_Network+0x84>
    return;
3401ea8a:	bf00      	nop
  }
}
3401ea8c:	3710      	adds	r7, #16
3401ea8e:	46bd      	mov	sp, r7
3401ea90:	bd80      	pop	{r7, pc}
	...

3401ea94 <LL_ATON_RT_Init_Network>:
/**
 * @brief Initialize a network instance
 * @param nn_instance Pointer to network instance to initialize
 */
void LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
3401ea94:	b580      	push	{r7, lr}
3401ea96:	b084      	sub	sp, #16
3401ea98:	af00      	add	r7, sp, #0
3401ea9a:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401ea9c:	687b      	ldr	r3, [r7, #4]
3401ea9e:	2b00      	cmp	r3, #0
3401eaa0:	d023      	beq.n	3401eaea <LL_ATON_RT_Init_Network+0x56>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
3401eaa2:	687b      	ldr	r3, [r7, #4]
3401eaa4:	681b      	ldr	r3, [r3, #0]
3401eaa6:	2b00      	cmp	r3, #0
3401eaa8:	d021      	beq.n	3401eaee <LL_ATON_RT_Init_Network+0x5a>
  {
    LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
    ret = nn_instance->network->ec_network_init();
  }
#else
  LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
3401eaaa:	687b      	ldr	r3, [r7, #4]
3401eaac:	681b      	ldr	r3, [r3, #0]
3401eaae:	685b      	ldr	r3, [r3, #4]
3401eab0:	2b00      	cmp	r3, #0
3401eab2:	d106      	bne.n	3401eac2 <LL_ATON_RT_Init_Network+0x2e>
3401eab4:	4b10      	ldr	r3, [pc, #64]	@ (3401eaf8 <LL_ATON_RT_Init_Network+0x64>)
3401eab6:	4a11      	ldr	r2, [pc, #68]	@ (3401eafc <LL_ATON_RT_Init_Network+0x68>)
3401eab8:	f44f 71d3 	mov.w	r1, #422	@ 0x1a6
3401eabc:	4810      	ldr	r0, [pc, #64]	@ (3401eb00 <LL_ATON_RT_Init_Network+0x6c>)
3401eabe:	f001 fbb7 	bl	34020230 <__assert_func>
  bool ret = nn_instance->network->ec_network_init();
3401eac2:	687b      	ldr	r3, [r7, #4]
3401eac4:	681b      	ldr	r3, [r3, #0]
3401eac6:	685b      	ldr	r3, [r3, #4]
3401eac8:	4798      	blx	r3
3401eaca:	4603      	mov	r3, r0
3401eacc:	73fb      	strb	r3, [r7, #15]
#endif
  LL_ATON_ASSERT(ret == true);
3401eace:	7bfb      	ldrb	r3, [r7, #15]
3401ead0:	2b01      	cmp	r3, #1
3401ead2:	d006      	beq.n	3401eae2 <LL_ATON_RT_Init_Network+0x4e>
3401ead4:	4b0b      	ldr	r3, [pc, #44]	@ (3401eb04 <LL_ATON_RT_Init_Network+0x70>)
3401ead6:	4a09      	ldr	r2, [pc, #36]	@ (3401eafc <LL_ATON_RT_Init_Network+0x68>)
3401ead8:	f240 11a9 	movw	r1, #425	@ 0x1a9
3401eadc:	4808      	ldr	r0, [pc, #32]	@ (3401eb00 <LL_ATON_RT_Init_Network+0x6c>)
3401eade:	f001 fba7 	bl	34020230 <__assert_func>
  LL_ATON_LIB_UNUSED(ret);

  /* Call actual network instance initialization */
  __LL_ATON_RT_Init_Network(nn_instance);
3401eae2:	6878      	ldr	r0, [r7, #4]
3401eae4:	f7ff ff90 	bl	3401ea08 <__LL_ATON_RT_Init_Network>
3401eae8:	e002      	b.n	3401eaf0 <LL_ATON_RT_Init_Network+0x5c>
    return;
3401eaea:	bf00      	nop
3401eaec:	e000      	b.n	3401eaf0 <LL_ATON_RT_Init_Network+0x5c>
    return;
3401eaee:	bf00      	nop
}
3401eaf0:	3710      	adds	r7, #16
3401eaf2:	46bd      	mov	sp, r7
3401eaf4:	bd80      	pop	{r7, pc}
3401eaf6:	bf00      	nop
3401eaf8:	34024e60 	.word	0x34024e60
3401eafc:	340330cc 	.word	0x340330cc
3401eb00:	34024ce8 	.word	0x34024ce8
3401eb04:	34024e98 	.word	0x34024e98

3401eb08 <LL_ATON_RT_DeInit_Network>:
/**
 * @brief De-initialize a network instance
 * @param nn_instance Pointer to network instance to de-initialize
 */
void LL_ATON_RT_DeInit_Network(NN_Instance_TypeDef *nn_instance)
{
3401eb08:	b580      	push	{r7, lr}
3401eb0a:	b084      	sub	sp, #16
3401eb0c:	af00      	add	r7, sp, #0
3401eb0e:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401eb10:	687b      	ldr	r3, [r7, #4]
3401eb12:	2b00      	cmp	r3, #0
3401eb14:	d030      	beq.n	3401eb78 <LL_ATON_RT_DeInit_Network+0x70>
  {
    return;
  }

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_DeInit` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401eb16:	687b      	ldr	r3, [r7, #4]
3401eb18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401eb1a:	2b00      	cmp	r3, #0
3401eb1c:	d005      	beq.n	3401eb2a <LL_ATON_RT_DeInit_Network+0x22>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_DeInit, nn_instance, NULL);
3401eb1e:	687b      	ldr	r3, [r7, #4]
3401eb20:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401eb22:	2200      	movs	r2, #0
3401eb24:	6879      	ldr	r1, [r7, #4]
3401eb26:	2005      	movs	r0, #5
3401eb28:	4798      	blx	r3
  }

  /** Re-set ATON IP owner */
  if (nn_instance == __ll_current_aton_ip_owner)
3401eb2a:	4b15      	ldr	r3, [pc, #84]	@ (3401eb80 <LL_ATON_RT_DeInit_Network+0x78>)
3401eb2c:	681b      	ldr	r3, [r3, #0]
3401eb2e:	687a      	ldr	r2, [r7, #4]
3401eb30:	429a      	cmp	r2, r3
3401eb32:	d102      	bne.n	3401eb3a <LL_ATON_RT_DeInit_Network+0x32>
  { // In case this function gets called while an ATON lib internal EpochBlock (used to implement hybrid epochs) is
    // under execution we might still be owner of the ATON IP
    __ll_clear_aton_owner(nn_instance);
3401eb34:	6878      	ldr	r0, [r7, #4]
3401eb36:	f7ff fc5d 	bl	3401e3f4 <__ll_clear_aton_owner>
  }

  /** De-initialize static variables **/
  /* re-set context */
  const LL_ATON_RT_EpochBlockItem_t *eb_list = NULL;
3401eb3a:	2300      	movs	r3, #0
3401eb3c:	60fb      	str	r3, [r7, #12]
  nn_instance->exec_state.current_epoch_block = eb_list;
3401eb3e:	687b      	ldr	r3, [r7, #4]
3401eb40:	68fa      	ldr	r2, [r7, #12]
3401eb42:	605a      	str	r2, [r3, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401eb44:	687b      	ldr	r3, [r7, #4]
3401eb46:	68fa      	ldr	r2, [r7, #12]
3401eb48:	609a      	str	r2, [r3, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401eb4a:	687b      	ldr	r3, [r7, #4]
3401eb4c:	2200      	movs	r2, #0
3401eb4e:	60da      	str	r2, [r3, #12]

  /* re-set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
3401eb50:	687b      	ldr	r3, [r7, #4]
3401eb52:	2200      	movs	r2, #0
3401eb54:	611a      	str	r2, [r3, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
3401eb56:	687b      	ldr	r3, [r7, #4]
3401eb58:	2200      	movs	r2, #0
3401eb5a:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = 0;
3401eb5c:	687b      	ldr	r3, [r7, #4]
3401eb5e:	2200      	movs	r2, #0
3401eb60:	625a      	str	r2, [r3, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401eb62:	687b      	ldr	r3, [r7, #4]
3401eb64:	2200      	movs	r2, #0
3401eb66:	629a      	str	r2, [r3, #40]	@ 0x28

  /* intentional do not re-set information about running inference `nn_instance->exec_state.inference_started` */

  /* re-set asynchronous status variables */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.triggered_events = 0x0;
3401eb68:	687b      	ldr	r3, [r7, #4]
3401eb6a:	2200      	movs	r2, #0
3401eb6c:	61da      	str	r2, [r3, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401eb6e:	687b      	ldr	r3, [r7, #4]
3401eb70:	2200      	movs	r2, #0
3401eb72:	f883 2020 	strb.w	r2, [r3, #32]
3401eb76:	e000      	b.n	3401eb7a <LL_ATON_RT_DeInit_Network+0x72>
    return;
3401eb78:	bf00      	nop
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
}
3401eb7a:	3710      	adds	r7, #16
3401eb7c:	46bd      	mov	sp, r7
3401eb7e:	bd80      	pop	{r7, pc}
3401eb80:	34053db0 	.word	0x34053db0

3401eb84 <LL_ATON_RT_RuntimeInit>:

/**
 * @brief Initialize the ATON runtime
 */
void LL_ATON_RT_RuntimeInit(void)
{
3401eb84:	b580      	push	{r7, lr}
3401eb86:	b082      	sub	sp, #8
3401eb88:	af00      	add	r7, sp, #0
  /** Initialize ATON IPs **/
  LL_ATON_Init();
3401eb8a:	f7fe fc4d 	bl	3401d428 <LL_ATON_Init>
  /** Initialize IRQ Context **/
  {
    uint32_t t;

    /* Disable & Clear interrupt controller */
    ATON_DISABLE_CLR_CONFCLR(INTCTRL, 0);
3401eb8e:	2300      	movs	r3, #0
3401eb90:	607b      	str	r3, [r7, #4]
3401eb92:	687b      	ldr	r3, [r7, #4]
3401eb94:	f023 0301 	bic.w	r3, r3, #1
3401eb98:	607b      	str	r3, [r7, #4]
3401eb9a:	687b      	ldr	r3, [r7, #4]
3401eb9c:	f043 0302 	orr.w	r3, r3, #2
3401eba0:	607b      	str	r3, [r7, #4]
3401eba2:	4a22      	ldr	r2, [pc, #136]	@ (3401ec2c <LL_ATON_RT_RuntimeInit+0xa8>)
3401eba4:	687b      	ldr	r3, [r7, #4]
3401eba6:	6013      	str	r3, [r2, #0]
3401eba8:	4b20      	ldr	r3, [pc, #128]	@ (3401ec2c <LL_ATON_RT_RuntimeInit+0xa8>)
3401ebaa:	681b      	ldr	r3, [r3, #0]
3401ebac:	f003 0302 	and.w	r3, r3, #2
3401ebb0:	2b00      	cmp	r3, #0
3401ebb2:	d1f9      	bne.n	3401eba8 <LL_ATON_RT_RuntimeInit+0x24>
3401ebb4:	2300      	movs	r3, #0
3401ebb6:	607b      	str	r3, [r7, #4]
3401ebb8:	687b      	ldr	r3, [r7, #4]
3401ebba:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3401ebbe:	607b      	str	r3, [r7, #4]
3401ebc0:	4a1a      	ldr	r2, [pc, #104]	@ (3401ec2c <LL_ATON_RT_RuntimeInit+0xa8>)
3401ebc2:	687b      	ldr	r3, [r7, #4]
3401ebc4:	6013      	str	r3, [r2, #0]
3401ebc6:	4b19      	ldr	r3, [pc, #100]	@ (3401ec2c <LL_ATON_RT_RuntimeInit+0xa8>)
3401ebc8:	681b      	ldr	r3, [r3, #0]
3401ebca:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401ebce:	2b00      	cmp	r3, #0
3401ebd0:	d1f9      	bne.n	3401ebc6 <LL_ATON_RT_RuntimeInit+0x42>

    /* Preset Interrupt Controller masks */
    ATON_INTCTRL_STD_INTORMSK_SET(ATON_STRENG_INT_MASK(
3401ebd2:	4b17      	ldr	r3, [pc, #92]	@ (3401ec30 <LL_ATON_RT_RuntimeInit+0xac>)
3401ebd4:	f240 32ff 	movw	r2, #1023	@ 0x3ff
3401ebd8:	601a      	str	r2, [r3, #0]
        ATON_STRENG_NUM, 0, 0)); // OR-mask: disable all streaming engine events and enable all other events & errors
    ATON_INTCTRL_STD_INTANDMSK_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
3401ebda:	4b16      	ldr	r3, [pc, #88]	@ (3401ec34 <LL_ATON_RT_RuntimeInit+0xb0>)
3401ebdc:	f04f 32ff 	mov.w	r2, #4294967295
3401ebe0:	601a      	str	r2, [r3, #0]
    ATON_INTCTRL_STD_INTORMSK_H_SET(0);           // OR-mask: enable all events & errors
    ATON_INTCTRL_STD_INTANDMSK_H_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
#endif

    /* Enable Interrupt Controller (again) */
    ATON_ENABLE(INTCTRL, 0);
3401ebe2:	4b12      	ldr	r3, [pc, #72]	@ (3401ec2c <LL_ATON_RT_RuntimeInit+0xa8>)
3401ebe4:	681b      	ldr	r3, [r3, #0]
3401ebe6:	603b      	str	r3, [r7, #0]
3401ebe8:	683b      	ldr	r3, [r7, #0]
3401ebea:	f043 0301 	orr.w	r3, r3, #1
3401ebee:	603b      	str	r3, [r7, #0]
3401ebf0:	4a0e      	ldr	r2, [pc, #56]	@ (3401ec2c <LL_ATON_RT_RuntimeInit+0xa8>)
3401ebf2:	683b      	ldr	r3, [r7, #0]
3401ebf4:	6013      	str	r3, [r2, #0]

  /** Initialize OSAL layer **/
  LL_ATON_OSAL_INIT();

  /** Disable all four ATON interrupts **/
  LL_ATON_DISABLE_ALL_IRQs();
3401ebf6:	2035      	movs	r0, #53	@ 0x35
3401ebf8:	f7ff faf2 	bl	3401e1e0 <__NVIC_DisableIRQ>
3401ebfc:	2036      	movs	r0, #54	@ 0x36
3401ebfe:	f7ff faef 	bl	3401e1e0 <__NVIC_DisableIRQ>
3401ec02:	2037      	movs	r0, #55	@ 0x37
3401ec04:	f7ff faec 	bl	3401e1e0 <__NVIC_DisableIRQ>
3401ec08:	2038      	movs	r0, #56	@ 0x38
3401ec0a:	f7ff fae9 	bl	3401e1e0 <__NVIC_DisableIRQ>

  /** Install IRQ handler **/
  LL_ATON_OSAL_INSTALL_IRQ(ATON_STD_IRQ_LINE, ATON_STD_IRQHandler);

  /** Enable ATON `ATON_STD_IRQ_LINE` interrupt **/
  LL_ATON_OSAL_ENABLE_IRQ(ATON_STD_IRQ_LINE);
3401ec0e:	2035      	movs	r0, #53	@ 0x35
3401ec10:	f7ff fac8 	bl	3401e1a4 <__NVIC_EnableIRQ>

  /** After having initialized ATON call callback (which among others might initialize further subsystems) */
  if (ll_aton_init_deinit_trace)
3401ec14:	4b08      	ldr	r3, [pc, #32]	@ (3401ec38 <LL_ATON_RT_RuntimeInit+0xb4>)
3401ec16:	681b      	ldr	r3, [r3, #0]
3401ec18:	2b00      	cmp	r3, #0
3401ec1a:	d003      	beq.n	3401ec24 <LL_ATON_RT_RuntimeInit+0xa0>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Init);
3401ec1c:	4b06      	ldr	r3, [pc, #24]	@ (3401ec38 <LL_ATON_RT_RuntimeInit+0xb4>)
3401ec1e:	681b      	ldr	r3, [r3, #0]
3401ec20:	2006      	movs	r0, #6
3401ec22:	4798      	blx	r3
}
3401ec24:	bf00      	nop
3401ec26:	3708      	adds	r7, #8
3401ec28:	46bd      	mov	sp, r7
3401ec2a:	bd80      	pop	{r7, pc}
3401ec2c:	580e1000 	.word	0x580e1000
3401ec30:	580e1014 	.word	0x580e1014
3401ec34:	580e1024 	.word	0x580e1024
3401ec38:	34053db8 	.word	0x34053db8

3401ec3c <LL_ATON_RT_RuntimeDeInit>:
 * @brief De-initialize the ATON runtime
 * @param nn_instance Pointer to network instance to de-initialize (optional - i.e. may be `NULL`, see
 * `LL_ATON_RT_DeInit_Network()`)
 */
void LL_ATON_RT_RuntimeDeInit(void)
{
3401ec3c:	b580      	push	{r7, lr}
3401ec3e:	af00      	add	r7, sp, #0
  /* Call runtime de-init callback */
  if (ll_aton_init_deinit_trace)
3401ec40:	4b0b      	ldr	r3, [pc, #44]	@ (3401ec70 <LL_ATON_RT_RuntimeDeInit+0x34>)
3401ec42:	681b      	ldr	r3, [r3, #0]
3401ec44:	2b00      	cmp	r3, #0
3401ec46:	d003      	beq.n	3401ec50 <LL_ATON_RT_RuntimeDeInit+0x14>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Deinit);
3401ec48:	4b09      	ldr	r3, [pc, #36]	@ (3401ec70 <LL_ATON_RT_RuntimeDeInit+0x34>)
3401ec4a:	681b      	ldr	r3, [r3, #0]
3401ec4c:	2007      	movs	r0, #7
3401ec4e:	4798      	blx	r3

  /* Disable all four ATON interrupts */
  LL_ATON_DISABLE_ALL_IRQs();
3401ec50:	2035      	movs	r0, #53	@ 0x35
3401ec52:	f7ff fac5 	bl	3401e1e0 <__NVIC_DisableIRQ>
3401ec56:	2036      	movs	r0, #54	@ 0x36
3401ec58:	f7ff fac2 	bl	3401e1e0 <__NVIC_DisableIRQ>
3401ec5c:	2037      	movs	r0, #55	@ 0x37
3401ec5e:	f7ff fabf 	bl	3401e1e0 <__NVIC_DisableIRQ>
3401ec62:	2038      	movs	r0, #56	@ 0x38
3401ec64:	f7ff fabc 	bl	3401e1e0 <__NVIC_DisableIRQ>

  /* De-initialize OSAL layer */
  LL_ATON_OSAL_DEINIT();

  /* De-initialize ATON IPs */
  LL_ATON_DeInit();
3401ec68:	f7fe ffb4 	bl	3401dbd4 <LL_ATON_DeInit>
}
3401ec6c:	bf00      	nop
3401ec6e:	bd80      	pop	{r7, pc}
3401ec70:	34053db8 	.word	0x34053db8

3401ec74 <LL_ATON_RT_RunEpochBlock>:
 *                            same thread!
 *                            It is entirely the user's responsibility to comply with this restriction!
 * @retval LL_ATON_RT_DONE    NN execution finished
 */
LL_ATON_RT_RetValues_t LL_ATON_RT_RunEpochBlock(NN_Instance_TypeDef *nn_instance)
{
3401ec74:	b580      	push	{r7, lr}
3401ec76:	b084      	sub	sp, #16
3401ec78:	af00      	add	r7, sp, #0
3401ec7a:	6078      	str	r0, [r7, #4]
  LL_ATON_ASSERT(nn_instance != NULL);
3401ec7c:	687b      	ldr	r3, [r7, #4]
3401ec7e:	2b00      	cmp	r3, #0
3401ec80:	d106      	bne.n	3401ec90 <LL_ATON_RT_RunEpochBlock+0x1c>
3401ec82:	4b63      	ldr	r3, [pc, #396]	@ (3401ee10 <LL_ATON_RT_RunEpochBlock+0x19c>)
3401ec84:	4a63      	ldr	r2, [pc, #396]	@ (3401ee14 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401ec86:	f44f 7110 	mov.w	r1, #576	@ 0x240
3401ec8a:	4863      	ldr	r0, [pc, #396]	@ (3401ee18 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401ec8c:	f001 fad0 	bl	34020230 <__assert_func>

  /* Test for wrong/missing initialization */
  LL_ATON_ASSERT(nn_instance->exec_state.current_epoch_block != NULL); // should never happen
3401ec90:	687b      	ldr	r3, [r7, #4]
3401ec92:	685b      	ldr	r3, [r3, #4]
3401ec94:	2b00      	cmp	r3, #0
3401ec96:	d106      	bne.n	3401eca6 <LL_ATON_RT_RunEpochBlock+0x32>
3401ec98:	4b60      	ldr	r3, [pc, #384]	@ (3401ee1c <LL_ATON_RT_RunEpochBlock+0x1a8>)
3401ec9a:	4a5e      	ldr	r2, [pc, #376]	@ (3401ee14 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401ec9c:	f240 2143 	movw	r1, #579	@ 0x243
3401eca0:	485d      	ldr	r0, [pc, #372]	@ (3401ee18 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401eca2:	f001 fac5 	bl	34020230 <__assert_func>

  /* Check if network is starting a new inference */
  if (nn_instance->exec_state.inference_started == false)
3401eca6:	687b      	ldr	r3, [r7, #4]
3401eca8:	7e1b      	ldrb	r3, [r3, #24]
3401ecaa:	f083 0301 	eor.w	r3, r3, #1
3401ecae:	b2db      	uxtb	r3, r3
3401ecb0:	2b00      	cmp	r3, #0
3401ecb2:	d022      	beq.n	3401ecfa <LL_ATON_RT_RunEpochBlock+0x86>
    {
      LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
      ret = nn_instance->network->ec_inference_init();
    }
#else
    LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
3401ecb4:	687b      	ldr	r3, [r7, #4]
3401ecb6:	681b      	ldr	r3, [r3, #0]
3401ecb8:	2b00      	cmp	r3, #0
3401ecba:	d004      	beq.n	3401ecc6 <LL_ATON_RT_RunEpochBlock+0x52>
3401ecbc:	687b      	ldr	r3, [r7, #4]
3401ecbe:	681b      	ldr	r3, [r3, #0]
3401ecc0:	689b      	ldr	r3, [r3, #8]
3401ecc2:	2b00      	cmp	r3, #0
3401ecc4:	d106      	bne.n	3401ecd4 <LL_ATON_RT_RunEpochBlock+0x60>
3401ecc6:	4b56      	ldr	r3, [pc, #344]	@ (3401ee20 <LL_ATON_RT_RunEpochBlock+0x1ac>)
3401ecc8:	4a52      	ldr	r2, [pc, #328]	@ (3401ee14 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401ecca:	f240 2155 	movw	r1, #597	@ 0x255
3401ecce:	4852      	ldr	r0, [pc, #328]	@ (3401ee18 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401ecd0:	f001 faae 	bl	34020230 <__assert_func>
    bool ret = nn_instance->network->ec_inference_init();
3401ecd4:	687b      	ldr	r3, [r7, #4]
3401ecd6:	681b      	ldr	r3, [r3, #0]
3401ecd8:	689b      	ldr	r3, [r3, #8]
3401ecda:	4798      	blx	r3
3401ecdc:	4603      	mov	r3, r0
3401ecde:	73bb      	strb	r3, [r7, #14]
#endif

    LL_ATON_ASSERT(ret == true);
3401ece0:	7bbb      	ldrb	r3, [r7, #14]
3401ece2:	2b01      	cmp	r3, #1
3401ece4:	d006      	beq.n	3401ecf4 <LL_ATON_RT_RunEpochBlock+0x80>
3401ece6:	4b4f      	ldr	r3, [pc, #316]	@ (3401ee24 <LL_ATON_RT_RunEpochBlock+0x1b0>)
3401ece8:	4a4a      	ldr	r2, [pc, #296]	@ (3401ee14 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401ecea:	f240 2159 	movw	r1, #601	@ 0x259
3401ecee:	484a      	ldr	r0, [pc, #296]	@ (3401ee18 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401ecf0:	f001 fa9e 	bl	34020230 <__assert_func>
    LL_ATON_LIB_UNUSED(ret);

    /* Set inference started flag to `true` */
    nn_instance->exec_state.inference_started = true;
3401ecf4:	687b      	ldr	r3, [r7, #4]
3401ecf6:	2201      	movs	r2, #1
3401ecf8:	761a      	strb	r2, [r3, #24]
    /* Placeholder for things which need to be done before starting an inference */
    /* ==> here <== */
  }

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  bool this_run_executed_end_epoch = false;
3401ecfa:	2300      	movs	r3, #0
3401ecfc:	73fb      	strb	r3, [r7, #15]

  while (true)
  {
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    /* wait for current epoch block to finish */
    uint32_t _wait_mask = __LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block);
3401ecfe:	687b      	ldr	r3, [r7, #4]
3401ed00:	685b      	ldr	r3, [r3, #4]
3401ed02:	4618      	mov	r0, r3
3401ed04:	f7ff fe68 	bl	3401e9d8 <__LL_ATON_RT_GetWaitMask>
3401ed08:	60b8      	str	r0, [r7, #8]
    if (nn_instance->exec_state.current_epoch_block_started && (_wait_mask != 0))
3401ed0a:	687b      	ldr	r3, [r7, #4]
3401ed0c:	f893 3020 	ldrb.w	r3, [r3, #32]
3401ed10:	b2db      	uxtb	r3, r3
3401ed12:	2b00      	cmp	r3, #0
3401ed14:	d030      	beq.n	3401ed78 <LL_ATON_RT_RunEpochBlock+0x104>
3401ed16:	68bb      	ldr	r3, [r7, #8]
3401ed18:	2b00      	cmp	r3, #0
3401ed1a:	d02d      	beq.n	3401ed78 <LL_ATON_RT_RunEpochBlock+0x104>
    {
      if ((nn_instance->exec_state.triggered_events & _wait_mask) == _wait_mask)
3401ed1c:	687b      	ldr	r3, [r7, #4]
3401ed1e:	69da      	ldr	r2, [r3, #28]
3401ed20:	68bb      	ldr	r3, [r7, #8]
3401ed22:	4013      	ands	r3, r2
3401ed24:	68ba      	ldr	r2, [r7, #8]
3401ed26:	429a      	cmp	r2, r3
3401ed28:	d124      	bne.n	3401ed74 <LL_ATON_RT_RunEpochBlock+0x100>
      {
        /* Enter critical section */
        LL_ATON_ASSERT(__ll_current_aton_ip_owner ==
3401ed2a:	4b3f      	ldr	r3, [pc, #252]	@ (3401ee28 <LL_ATON_RT_RunEpochBlock+0x1b4>)
3401ed2c:	681b      	ldr	r3, [r3, #0]
3401ed2e:	687a      	ldr	r2, [r7, #4]
3401ed30:	429a      	cmp	r2, r3
3401ed32:	d006      	beq.n	3401ed42 <LL_ATON_RT_RunEpochBlock+0xce>
3401ed34:	4b3d      	ldr	r3, [pc, #244]	@ (3401ee2c <LL_ATON_RT_RunEpochBlock+0x1b8>)
3401ed36:	4a37      	ldr	r2, [pc, #220]	@ (3401ee14 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401ed38:	f240 2171 	movw	r1, #625	@ 0x271
3401ed3c:	4836      	ldr	r0, [pc, #216]	@ (3401ee18 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401ed3e:	f001 fa77 	bl	34020230 <__assert_func>
                       nn_instance); // when entering a critical section we MUST hold the ATON IP lock
        LL_ATON_OSAL_ENTER_CS();
3401ed42:	2035      	movs	r0, #53	@ 0x35
3401ed44:	f7ff fa4c 	bl	3401e1e0 <__NVIC_DisableIRQ>

        /* reset triggered events */
        nn_instance->exec_state.triggered_events &= ~_wait_mask;
3401ed48:	687b      	ldr	r3, [r7, #4]
3401ed4a:	69da      	ldr	r2, [r3, #28]
3401ed4c:	68bb      	ldr	r3, [r7, #8]
3401ed4e:	43db      	mvns	r3, r3
3401ed50:	401a      	ands	r2, r3
3401ed52:	687b      	ldr	r3, [r7, #4]
3401ed54:	61da      	str	r2, [r3, #28]

        /* Exit critical section */
        LL_ATON_OSAL_EXIT_CS();
3401ed56:	2035      	movs	r0, #53	@ 0x35
3401ed58:	f7ff fa24 	bl	3401e1a4 <__NVIC_EnableIRQ>

        /* end/clean-up epoch block */
        __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401ed5c:	687b      	ldr	r3, [r7, #4]
3401ed5e:	685b      	ldr	r3, [r3, #4]
3401ed60:	6879      	ldr	r1, [r7, #4]
3401ed62:	4618      	mov	r0, r3
3401ed64:	f7ff fd1e 	bl	3401e7a4 <__LL_ATON_RT_ExecEndEpochBlock>
        this_run_executed_end_epoch = true;
3401ed68:	2301      	movs	r3, #1
3401ed6a:	73fb      	strb	r3, [r7, #15]

        /* advance epoch block */
        __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401ed6c:	6878      	ldr	r0, [r7, #4]
3401ed6e:	f7ff fdd5 	bl	3401e91c <__LL_ATON_RT_DetermineNextEpochBlock>
3401ed72:	e001      	b.n	3401ed78 <LL_ATON_RT_RunEpochBlock+0x104>
      }
      else
      {
        /* Return to main loop */
        return LL_ATON_RT_WFE;
3401ed74:	2301      	movs	r3, #1
3401ed76:	e047      	b.n	3401ee08 <LL_ATON_RT_RunEpochBlock+0x194>
      }
    }
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

    /* test for last epoch block */
    if (EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block))
3401ed78:	687b      	ldr	r3, [r7, #4]
3401ed7a:	685b      	ldr	r3, [r3, #4]
3401ed7c:	4618      	mov	r0, r3
3401ed7e:	f7ff fa53 	bl	3401e228 <EpochBlock_IsLastEpochBlock>
3401ed82:	4603      	mov	r3, r0
3401ed84:	2b00      	cmp	r3, #0
3401ed86:	d011      	beq.n	3401edac <LL_ATON_RT_RunEpochBlock+0x138>
    {
      if (nn_instance->exec_state.saved_current_epoch_block != NULL)
3401ed88:	687b      	ldr	r3, [r7, #4]
3401ed8a:	691b      	ldr	r3, [r3, #16]
3401ed8c:	2b00      	cmp	r3, #0
3401ed8e:	d00b      	beq.n	3401eda8 <LL_ATON_RT_RunEpochBlock+0x134>
      {
        /* return from inserted epoch block */
        __LL_ATON_RT_RetFromLibEpochBlockArray(true, nn_instance);
3401ed90:	6879      	ldr	r1, [r7, #4]
3401ed92:	2001      	movs	r0, #1
3401ed94:	f7ff fba4 	bl	3401e4e0 <__LL_ATON_RT_RetFromLibEpochBlockArray>

        /* advance epoch block */
        nn_instance->exec_state.current_epoch_block++;
3401ed98:	687b      	ldr	r3, [r7, #4]
3401ed9a:	685b      	ldr	r3, [r3, #4]
3401ed9c:	f103 0214 	add.w	r2, r3, #20
3401eda0:	687b      	ldr	r3, [r7, #4]
3401eda2:	605a      	str	r2, [r3, #4]

        /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
        return LL_ATON_RT_NO_WFE;
3401eda4:	2300      	movs	r3, #0
3401eda6:	e02f      	b.n	3401ee08 <LL_ATON_RT_RunEpochBlock+0x194>
      }
      else
      {
        /* Reached end of execution */
        return LL_ATON_RT_DONE;
3401eda8:	2302      	movs	r3, #2
3401edaa:	e02d      	b.n	3401ee08 <LL_ATON_RT_RunEpochBlock+0x194>
      }
    }

    /* run/start current epoch block */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    if (this_run_executed_end_epoch)
3401edac:	7bfb      	ldrb	r3, [r7, #15]
3401edae:	2b00      	cmp	r3, #0
3401edb0:	d001      	beq.n	3401edb6 <LL_ATON_RT_RunEpochBlock+0x142>
    { // alow reset of network (see function `LL_ATON_RT_Reset_Network()`)
      /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
      return LL_ATON_RT_NO_WFE;
3401edb2:	2300      	movs	r3, #0
3401edb4:	e028      	b.n	3401ee08 <LL_ATON_RT_RunEpochBlock+0x194>
    }

    if (!nn_instance->exec_state.current_epoch_block_started)
3401edb6:	687b      	ldr	r3, [r7, #4]
3401edb8:	f893 3020 	ldrb.w	r3, [r3, #32]
3401edbc:	b2db      	uxtb	r3, r3
3401edbe:	f083 0301 	eor.w	r3, r3, #1
3401edc2:	b2db      	uxtb	r3, r3
3401edc4:	2b00      	cmp	r3, #0
3401edc6:	d009      	beq.n	3401eddc <LL_ATON_RT_RunEpochBlock+0x168>
    {
      nn_instance->exec_state.current_epoch_block_started = true;
3401edc8:	687b      	ldr	r3, [r7, #4]
3401edca:	2201      	movs	r2, #1
3401edcc:	f883 2020 	strb.w	r2, [r3, #32]

      __LL_ATON_RT_ExecStartEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401edd0:	687b      	ldr	r3, [r7, #4]
3401edd2:	685b      	ldr	r3, [r3, #4]
3401edd4:	6879      	ldr	r1, [r7, #4]
3401edd6:	4618      	mov	r0, r3
3401edd8:	f7ff fc38 	bl	3401e64c <__LL_ATON_RT_ExecStartEpochBlock>
    }

    /* End epoch block and advance to next one */
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
3401eddc:	687b      	ldr	r3, [r7, #4]
3401edde:	685b      	ldr	r3, [r3, #4]
3401ede0:	4618      	mov	r0, r3
3401ede2:	f7ff fdf9 	bl	3401e9d8 <__LL_ATON_RT_GetWaitMask>
3401ede6:	4603      	mov	r3, r0
3401ede8:	2b00      	cmp	r3, #0
3401edea:	d10c      	bne.n	3401ee06 <LL_ATON_RT_RunEpochBlock+0x192>
    {
      /* end/clean-up epoch block */
      __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401edec:	687b      	ldr	r3, [r7, #4]
3401edee:	685b      	ldr	r3, [r3, #4]
3401edf0:	6879      	ldr	r1, [r7, #4]
3401edf2:	4618      	mov	r0, r3
3401edf4:	f7ff fcd6 	bl	3401e7a4 <__LL_ATON_RT_ExecEndEpochBlock>
      this_run_executed_end_epoch = true; // has no effect (just for cosmetics)
3401edf8:	2301      	movs	r3, #1
3401edfa:	73fb      	strb	r3, [r7, #15]

      /* advance epoch block */
      __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401edfc:	6878      	ldr	r0, [r7, #4]
3401edfe:	f7ff fd8d 	bl	3401e91c <__LL_ATON_RT_DetermineNextEpochBlock>

      /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
      return LL_ATON_RT_NO_WFE;
3401ee02:	2300      	movs	r3, #0
3401ee04:	e000      	b.n	3401ee08 <LL_ATON_RT_RunEpochBlock+0x194>
    }
    else
    {
      /* Return to main loop */
      return LL_ATON_RT_WFE;
3401ee06:	2301      	movs	r3, #1
    /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
    return LL_ATON_RT_NO_WFE;

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  }
}
3401ee08:	4618      	mov	r0, r3
3401ee0a:	3710      	adds	r7, #16
3401ee0c:	46bd      	mov	sp, r7
3401ee0e:	bd80      	pop	{r7, pc}
3401ee10:	34024b34 	.word	0x34024b34
3401ee14:	340330fc 	.word	0x340330fc
3401ee18:	34024ce8 	.word	0x34024ce8
3401ee1c:	34024ea4 	.word	0x34024ea4
3401ee20:	34024ee0 	.word	0x34024ee0
3401ee24:	34024e98 	.word	0x34024e98
3401ee28:	34053db0 	.word	0x34053db0
3401ee2c:	34024d48 	.word	0x34024d48

3401ee30 <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401ee30:	b5b0      	push	{r4, r5, r7, lr}
3401ee32:	b086      	sub	sp, #24
3401ee34:	af00      	add	r7, sp, #0
3401ee36:	6078      	str	r0, [r7, #4]
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
3401ee38:	687b      	ldr	r3, [r7, #4]
3401ee3a:	2b00      	cmp	r3, #0
3401ee3c:	f000 808f 	beq.w	3401ef5e <__LL_ATON_RT_IrqErr+0x12e>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
3401ee40:	687a      	ldr	r2, [r7, #4]
3401ee42:	4b49      	ldr	r3, [pc, #292]	@ (3401ef68 <__LL_ATON_RT_IrqErr+0x138>)
3401ee44:	4013      	ands	r3, r2
3401ee46:	2b00      	cmp	r3, #0
3401ee48:	d013      	beq.n	3401ee72 <__LL_ATON_RT_IrqErr+0x42>
    int64_t masked_irqs; // must be signed for two's compliment `(-masked_irqs)`
#else                    //(ATON_INT_NR <= 32)
    int32_t masked_irqs; // must be signed for two's compliment `(-masked_irqs)`
#endif                   //(ATON_INT_NR <= 32)

    masked_irqs = (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM));
3401ee4a:	687a      	ldr	r2, [r7, #4]
3401ee4c:	4b46      	ldr	r3, [pc, #280]	@ (3401ef68 <__LL_ATON_RT_IrqErr+0x138>)
3401ee4e:	4013      	ands	r3, r2
3401ee50:	613b      	str	r3, [r7, #16]

    // assumes that stream engine interrupts are assigned in the order of their engine number and to consecutive bits
    // within the `INTREG` register
    uint32_t streaming_engine_nr = (uint32_t)(masked_irqs & (-masked_irqs));
3401ee52:	693b      	ldr	r3, [r7, #16]
3401ee54:	425a      	negs	r2, r3
3401ee56:	693b      	ldr	r3, [r7, #16]
3401ee58:	4013      	ands	r3, r2
3401ee5a:	60fb      	str	r3, [r7, #12]
    streaming_engine_nr -= ATON_STRENG_INT(0);

#ifndef NDEBUG
    uint32_t streng_err = ATON_STRENG_IRQ_GET(streaming_engine_nr);
3401ee5c:	68fb      	ldr	r3, [r7, #12]
3401ee5e:	031a      	lsls	r2, r3, #12
3401ee60:	4b42      	ldr	r3, [pc, #264]	@ (3401ef6c <__LL_ATON_RT_IrqErr+0x13c>)
3401ee62:	4413      	add	r3, r2
3401ee64:	681b      	ldr	r3, [r3, #0]
3401ee66:	60bb      	str	r3, [r7, #8]
    LL_ATON_PRINTF("Streaming engine #%u error interrupt: 0x%" PRIx32 "\n", streaming_engine_nr, streng_err);
3401ee68:	68ba      	ldr	r2, [r7, #8]
3401ee6a:	68f9      	ldr	r1, [r7, #12]
3401ee6c:	4840      	ldr	r0, [pc, #256]	@ (3401ef70 <__LL_ATON_RT_IrqErr+0x140>)
3401ee6e:	f002 fa19 	bl	340212a4 <iprintf>
#endif // NDEBUG
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
3401ee72:	687b      	ldr	r3, [r7, #4]
3401ee74:	f3c3 0309 	ubfx	r3, r3, #0, #10
3401ee78:	2b00      	cmp	r3, #0
3401ee7a:	d002      	beq.n	3401ee82 <__LL_ATON_RT_IrqErr+0x52>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
3401ee7c:	483d      	ldr	r0, [pc, #244]	@ (3401ef74 <__LL_ATON_RT_IrqErr+0x144>)
3401ee7e:	f002 fa79 	bl	34021374 <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
3401ee82:	687b      	ldr	r3, [r7, #4]
3401ee84:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
3401ee88:	2b00      	cmp	r3, #0
3401ee8a:	d002      	beq.n	3401ee92 <__LL_ATON_RT_IrqErr+0x62>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
3401ee8c:	483a      	ldr	r0, [pc, #232]	@ (3401ef78 <__LL_ATON_RT_IrqErr+0x148>)
3401ee8e:	f002 fa71 	bl	34021374 <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
3401ee92:	687b      	ldr	r3, [r7, #4]
3401ee94:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3401ee98:	2b00      	cmp	r3, #0
3401ee9a:	d002      	beq.n	3401eea2 <__LL_ATON_RT_IrqErr+0x72>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
3401ee9c:	4837      	ldr	r0, [pc, #220]	@ (3401ef7c <__LL_ATON_RT_IrqErr+0x14c>)
3401ee9e:	f002 fa69 	bl	34021374 <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
3401eea2:	687b      	ldr	r3, [r7, #4]
3401eea4:	f003 63c0 	and.w	r3, r3, #100663296	@ 0x6000000
3401eea8:	2b00      	cmp	r3, #0
3401eeaa:	d015      	beq.n	3401eed8 <__LL_ATON_RT_IrqErr+0xa8>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
3401eeac:	4834      	ldr	r0, [pc, #208]	@ (3401ef80 <__LL_ATON_RT_IrqErr+0x150>)
3401eeae:	f002 fa61 	bl	34021374 <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
3401eeb2:	2300      	movs	r3, #0
3401eeb4:	617b      	str	r3, [r7, #20]
3401eeb6:	e00c      	b.n	3401eed2 <__LL_ATON_RT_IrqErr+0xa2>
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
3401eeb8:	697b      	ldr	r3, [r7, #20]
3401eeba:	031a      	lsls	r2, r3, #12
3401eebc:	4b31      	ldr	r3, [pc, #196]	@ (3401ef84 <__LL_ATON_RT_IrqErr+0x154>)
3401eebe:	4413      	add	r3, r2
3401eec0:	681b      	ldr	r3, [r3, #0]
3401eec2:	461a      	mov	r2, r3
3401eec4:	6979      	ldr	r1, [r7, #20]
3401eec6:	4830      	ldr	r0, [pc, #192]	@ (3401ef88 <__LL_ATON_RT_IrqErr+0x158>)
3401eec8:	f002 f9ec 	bl	340212a4 <iprintf>
    for (i = 0; i < ATON_BUSIF_NUM; i++)
3401eecc:	697b      	ldr	r3, [r7, #20]
3401eece:	3301      	adds	r3, #1
3401eed0:	617b      	str	r3, [r7, #20]
3401eed2:	697b      	ldr	r3, [r7, #20]
3401eed4:	2b01      	cmp	r3, #1
3401eed6:	ddef      	ble.n	3401eeb8 <__LL_ATON_RT_IrqErr+0x88>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
3401eed8:	687b      	ldr	r3, [r7, #4]
3401eeda:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3401eede:	2b00      	cmp	r3, #0
3401eee0:	d002      	beq.n	3401eee8 <__LL_ATON_RT_IrqErr+0xb8>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
3401eee2:	482a      	ldr	r0, [pc, #168]	@ (3401ef8c <__LL_ATON_RT_IrqErr+0x15c>)
3401eee4:	f002 fa46 	bl	34021374 <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
3401eee8:	687b      	ldr	r3, [r7, #4]
3401eeea:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401eeee:	2b00      	cmp	r3, #0
3401eef0:	d011      	beq.n	3401ef16 <__LL_ATON_RT_IrqErr+0xe6>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
3401eef2:	4b27      	ldr	r3, [pc, #156]	@ (3401ef90 <__LL_ATON_RT_IrqErr+0x160>)
3401eef4:	681b      	ldr	r3, [r3, #0]
3401eef6:	4619      	mov	r1, r3
3401eef8:	4826      	ldr	r0, [pc, #152]	@ (3401ef94 <__LL_ATON_RT_IrqErr+0x164>)
3401eefa:	f002 f9d3 	bl	340212a4 <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
3401eefe:	4b26      	ldr	r3, [pc, #152]	@ (3401ef98 <__LL_ATON_RT_IrqErr+0x168>)
3401ef00:	681b      	ldr	r3, [r3, #0]
3401ef02:	4619      	mov	r1, r3
3401ef04:	4825      	ldr	r0, [pc, #148]	@ (3401ef9c <__LL_ATON_RT_IrqErr+0x16c>)
3401ef06:	f002 f9cd 	bl	340212a4 <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
3401ef0a:	4b25      	ldr	r3, [pc, #148]	@ (3401efa0 <__LL_ATON_RT_IrqErr+0x170>)
3401ef0c:	681b      	ldr	r3, [r3, #0]
3401ef0e:	4619      	mov	r1, r3
3401ef10:	4824      	ldr	r0, [pc, #144]	@ (3401efa4 <__LL_ATON_RT_IrqErr+0x174>)
3401ef12:	f002 f9c7 	bl	340212a4 <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
3401ef16:	687b      	ldr	r3, [r7, #4]
3401ef18:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
3401ef1c:	2b00      	cmp	r3, #0
3401ef1e:	d002      	beq.n	3401ef26 <__LL_ATON_RT_IrqErr+0xf6>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
3401ef20:	4821      	ldr	r0, [pc, #132]	@ (3401efa8 <__LL_ATON_RT_IrqErr+0x178>)
3401ef22:	f002 fa27 	bl	34021374 <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
3401ef26:	687b      	ldr	r3, [r7, #4]
3401ef28:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3401ef2c:	2b00      	cmp	r3, #0
3401ef2e:	d002      	beq.n	3401ef36 <__LL_ATON_RT_IrqErr+0x106>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
3401ef30:	481e      	ldr	r0, [pc, #120]	@ (3401efac <__LL_ATON_RT_IrqErr+0x17c>)
3401ef32:	f002 fa1f 	bl	34021374 <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
3401ef36:	f7ff fb61 	bl	3401e5fc <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
3401ef3a:	687b      	ldr	r3, [r7, #4]
3401ef3c:	2200      	movs	r2, #0
3401ef3e:	461c      	mov	r4, r3
3401ef40:	4615      	mov	r5, r2
3401ef42:	4622      	mov	r2, r4
3401ef44:	462b      	mov	r3, r5
3401ef46:	f240 314a 	movw	r1, #842	@ 0x34a
3401ef4a:	4819      	ldr	r0, [pc, #100]	@ (3401efb0 <__LL_ATON_RT_IrqErr+0x180>)
3401ef4c:	f002 f9aa 	bl	340212a4 <iprintf>
#if (ATON_PLAT_HAS_FFLUSH)
  LL_ATON_FFLUSH(stdout);
#endif
  LL_ATON_ASSERT(false); // may never happen
3401ef50:	4b18      	ldr	r3, [pc, #96]	@ (3401efb4 <__LL_ATON_RT_IrqErr+0x184>)
3401ef52:	4a19      	ldr	r2, [pc, #100]	@ (3401efb8 <__LL_ATON_RT_IrqErr+0x188>)
3401ef54:	f240 314e 	movw	r1, #846	@ 0x34e
3401ef58:	4818      	ldr	r0, [pc, #96]	@ (3401efbc <__LL_ATON_RT_IrqErr+0x18c>)
3401ef5a:	f001 f969 	bl	34020230 <__assert_func>
    return;
3401ef5e:	bf00      	nop
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
3401ef60:	3718      	adds	r7, #24
3401ef62:	46bd      	mov	sp, r7
3401ef64:	bdb0      	pop	{r4, r5, r7, pc}
3401ef66:	bf00      	nop
3401ef68:	000ffc00 	.word	0x000ffc00
3401ef6c:	580e503c 	.word	0x580e503c
3401ef70:	34024f44 	.word	0x34024f44
3401ef74:	34024f74 	.word	0x34024f74
3401ef78:	34024f9c 	.word	0x34024f9c
3401ef7c:	34024fc0 	.word	0x34024fc0
3401ef80:	34024fe0 	.word	0x34024fe0
3401ef84:	580e2010 	.word	0x580e2010
3401ef88:	34024ff8 	.word	0x34024ff8
3401ef8c:	34025010 	.word	0x34025010
3401ef90:	580fe00c 	.word	0x580fe00c
3401ef94:	34025028 	.word	0x34025028
3401ef98:	580fe020 	.word	0x580fe020
3401ef9c:	3402505c 	.word	0x3402505c
3401efa0:	580fe01c 	.word	0x580fe01c
3401efa4:	34025088 	.word	0x34025088
3401efa8:	340250ac 	.word	0x340250ac
3401efac:	340250d0 	.word	0x340250d0
3401efb0:	340250ec 	.word	0x340250ec
3401efb4:	34025114 	.word	0x34025114
3401efb8:	34033210 	.word	0x34033210
3401efbc:	34024ce8 	.word	0x34024ce8

3401efc0 <__LL_ATON_RT_IrqEpochBlock>:
#if (ATON_INT_NR > 32)
static inline void __LL_ATON_RT_IrqEpochBlock(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static inline void __LL_ATON_RT_IrqEpochBlock(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401efc0:	b480      	push	{r7}
3401efc2:	b087      	sub	sp, #28
3401efc4:	af00      	add	r7, sp, #0
3401efc6:	6078      	str	r0, [r7, #4]
   * consecutive bits within the `INTREG` register (and within all other interrupt controller registers, like e.g.
   * status/mask/clear)! */
  irqs >>= ATON_STRENG_INT(0);
  wait_irqs =
      irqs &
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
3401efc8:	4b1e      	ldr	r3, [pc, #120]	@ (3401f044 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401efca:	681b      	ldr	r3, [r3, #0]
3401efcc:	685b      	ldr	r3, [r3, #4]
          ->wait_mask; /* treat only IRQs we are currently waiting for
3401efce:	68db      	ldr	r3, [r3, #12]
  wait_irqs =
3401efd0:	687a      	ldr	r2, [r7, #4]
3401efd2:	4013      	ands	r3, r2
3401efd4:	60fb      	str	r3, [r7, #12]
                          (Note: we might be running in a hybrid function which uses DMAs in parallel with a "normal"
                          ATON execution and we must not clear the IRQs of this "normal" ATON execution here) */
  if (wait_irqs)
3401efd6:	68fb      	ldr	r3, [r7, #12]
3401efd8:	2b00      	cmp	r3, #0
3401efda:	d02d      	beq.n	3401f038 <__LL_ATON_RT_IrqEpochBlock+0x78>
  {
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401efdc:	4b19      	ldr	r3, [pc, #100]	@ (3401f044 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401efde:	681b      	ldr	r3, [r3, #0]
3401efe0:	69db      	ldr	r3, [r3, #28]
3401efe2:	613b      	str	r3, [r7, #16]
    for (i = 0; i < ATON_STRENG_NUM; i++)
3401efe4:	2300      	movs	r3, #0
3401efe6:	617b      	str	r3, [r7, #20]
3401efe8:	e01f      	b.n	3401f02a <__LL_ATON_RT_IrqEpochBlock+0x6a>
    {
      /* Handle event interrupts */
      if ((wait_irqs >> i) & 1)
3401efea:	68fa      	ldr	r2, [r7, #12]
3401efec:	697b      	ldr	r3, [r7, #20]
3401efee:	fa22 f303 	lsr.w	r3, r2, r3
3401eff2:	f003 0301 	and.w	r3, r3, #1
3401eff6:	2b00      	cmp	r3, #0
3401eff8:	d014      	beq.n	3401f024 <__LL_ATON_RT_IrqEpochBlock+0x64>
      { /* more future-proofed but less efficient alternative:
           `if (wait_irqs & ATON_STRENG_INT_MASK(i, 0, 0))`
         */
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
3401effa:	697b      	ldr	r3, [r7, #20]
3401effc:	031a      	lsls	r2, r3, #12
3401effe:	4b12      	ldr	r3, [pc, #72]	@ (3401f048 <__LL_ATON_RT_IrqEpochBlock+0x88>)
3401f000:	4413      	add	r3, r2
3401f002:	681b      	ldr	r3, [r3, #0]
3401f004:	60bb      	str	r3, [r7, #8]
        ATON_STRENG_IRQ_SET(
3401f006:	697b      	ldr	r3, [r7, #20]
3401f008:	031a      	lsls	r2, r3, #12
3401f00a:	4b0f      	ldr	r3, [pc, #60]	@ (3401f048 <__LL_ATON_RT_IrqEpochBlock+0x88>)
3401f00c:	4413      	add	r3, r2
3401f00e:	461a      	mov	r2, r3
3401f010:	68bb      	ldr	r3, [r7, #8]
3401f012:	6013      	str	r3, [r2, #0]
            i, strengIrqs); /* Acknowledge ATON interrupt source (i.e. stream engine #i) - could be more fine grain */

        /* Handle RT integration */
        _tmp_triggered_events |= (1 << i);
3401f014:	2201      	movs	r2, #1
3401f016:	697b      	ldr	r3, [r7, #20]
3401f018:	fa02 f303 	lsl.w	r3, r2, r3
3401f01c:	461a      	mov	r2, r3
3401f01e:	693b      	ldr	r3, [r7, #16]
3401f020:	4313      	orrs	r3, r2
3401f022:	613b      	str	r3, [r7, #16]
    for (i = 0; i < ATON_STRENG_NUM; i++)
3401f024:	697b      	ldr	r3, [r7, #20]
3401f026:	3301      	adds	r3, #1
3401f028:	617b      	str	r3, [r7, #20]
3401f02a:	697b      	ldr	r3, [r7, #20]
3401f02c:	2b09      	cmp	r3, #9
3401f02e:	dddc      	ble.n	3401efea <__LL_ATON_RT_IrqEpochBlock+0x2a>
      }
    }
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401f030:	4b04      	ldr	r3, [pc, #16]	@ (3401f044 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401f032:	681b      	ldr	r3, [r3, #0]
3401f034:	693a      	ldr	r2, [r7, #16]
3401f036:	61da      	str	r2, [r3, #28]
  }
}
3401f038:	bf00      	nop
3401f03a:	371c      	adds	r7, #28
3401f03c:	46bd      	mov	sp, r7
3401f03e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401f042:	4770      	bx	lr
3401f044:	34053db0 	.word	0x34053db0
3401f048:	580e503c 	.word	0x580e503c

3401f04c <__LL_ATON_RT_IrqEpochBlob>:
#if (ATON_INT_NR > 32)
static inline void __LL_ATON_RT_IrqEpochBlob(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static inline void __LL_ATON_RT_IrqEpochBlob(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401f04c:	b580      	push	{r7, lr}
3401f04e:	b086      	sub	sp, #24
3401f050:	af00      	add	r7, sp, #0
3401f052:	6078      	str	r0, [r7, #4]
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3401f054:	4b1d      	ldr	r3, [pc, #116]	@ (3401f0cc <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401f056:	681b      	ldr	r3, [r3, #0]
3401f058:	685b      	ldr	r3, [r3, #4]
3401f05a:	4618      	mov	r0, r3
3401f05c:	f7ff f956 	bl	3401e30c <EpochBlock_EpochControllerUnit>
3401f060:	6178      	str	r0, [r7, #20]
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401f062:	697b      	ldr	r3, [r7, #20]
3401f064:	2b00      	cmp	r3, #0
3401f066:	d006      	beq.n	3401f076 <__LL_ATON_RT_IrqEpochBlob+0x2a>
3401f068:	4b19      	ldr	r3, [pc, #100]	@ (3401f0d0 <__LL_ATON_RT_IrqEpochBlob+0x84>)
3401f06a:	4a1a      	ldr	r2, [pc, #104]	@ (3401f0d4 <__LL_ATON_RT_IrqEpochBlob+0x88>)
3401f06c:	f240 3191 	movw	r1, #913	@ 0x391
3401f070:	4819      	ldr	r0, [pc, #100]	@ (3401f0d8 <__LL_ATON_RT_IrqEpochBlob+0x8c>)
3401f072:	f001 f8dd 	bl	34020230 <__assert_func>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
3401f076:	697b      	ldr	r3, [r7, #20]
3401f078:	2b00      	cmp	r3, #0
3401f07a:	d007      	beq.n	3401f08c <__LL_ATON_RT_IrqEpochBlob+0x40>
3401f07c:	697b      	ldr	r3, [r7, #20]
3401f07e:	2b01      	cmp	r3, #1
3401f080:	d102      	bne.n	3401f088 <__LL_ATON_RT_IrqEpochBlob+0x3c>
3401f082:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3401f086:	e003      	b.n	3401f090 <__LL_ATON_RT_IrqEpochBlob+0x44>
3401f088:	2300      	movs	r3, #0
3401f08a:	e001      	b.n	3401f090 <__LL_ATON_RT_IrqEpochBlob+0x44>
3401f08c:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3401f090:	687a      	ldr	r2, [r7, #4]
3401f092:	4013      	ands	r3, r2
3401f094:	2b00      	cmp	r3, #0
3401f096:	d015      	beq.n	3401f0c4 <__LL_ATON_RT_IrqEpochBlob+0x78>
  {
    /* Acknowledge interrupts in active epoch controller unit - could be more fine grain */
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
3401f098:	4b10      	ldr	r3, [pc, #64]	@ (3401f0dc <__LL_ATON_RT_IrqEpochBlob+0x90>)
3401f09a:	681b      	ldr	r3, [r3, #0]
3401f09c:	613b      	str	r3, [r7, #16]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
3401f09e:	4a0f      	ldr	r2, [pc, #60]	@ (3401f0dc <__LL_ATON_RT_IrqEpochBlob+0x90>)
3401f0a0:	693b      	ldr	r3, [r7, #16]
3401f0a2:	6013      	str	r3, [r2, #0]

    /* Handle RT integration */
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401f0a4:	4b09      	ldr	r3, [pc, #36]	@ (3401f0cc <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401f0a6:	681b      	ldr	r3, [r3, #0]
3401f0a8:	69db      	ldr	r3, [r3, #28]
3401f0aa:	60fb      	str	r3, [r7, #12]
    _tmp_triggered_events |= (1 << ecId);
3401f0ac:	2201      	movs	r2, #1
3401f0ae:	697b      	ldr	r3, [r7, #20]
3401f0b0:	fa02 f303 	lsl.w	r3, r2, r3
3401f0b4:	461a      	mov	r2, r3
3401f0b6:	68fb      	ldr	r3, [r7, #12]
3401f0b8:	4313      	orrs	r3, r2
3401f0ba:	60fb      	str	r3, [r7, #12]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401f0bc:	4b03      	ldr	r3, [pc, #12]	@ (3401f0cc <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401f0be:	681b      	ldr	r3, [r3, #0]
3401f0c0:	68fa      	ldr	r2, [r7, #12]
3401f0c2:	61da      	str	r2, [r3, #28]
  }
}
3401f0c4:	bf00      	nop
3401f0c6:	3718      	adds	r7, #24
3401f0c8:	46bd      	mov	sp, r7
3401f0ca:	bd80      	pop	{r7, pc}
3401f0cc:	34053db0 	.word	0x34053db0
3401f0d0:	34024d74 	.word	0x34024d74
3401f0d4:	34033234 	.word	0x34033234
3401f0d8:	34024ce8 	.word	0x34024ce8
3401f0dc:	580fe00c 	.word	0x580fe00c

3401f0e0 <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
3401f0e0:	b580      	push	{r7, lr}
3401f0e2:	b082      	sub	sp, #8
3401f0e4:	af00      	add	r7, sp, #0
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
3401f0e6:	4b3d      	ldr	r3, [pc, #244]	@ (3401f1dc <NPU0_IRQHandler+0xfc>)
3401f0e8:	681b      	ldr	r3, [r3, #0]
3401f0ea:	607b      	str	r3, [r7, #4]
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
3401f0ec:	4b3c      	ldr	r3, [pc, #240]	@ (3401f1e0 <NPU0_IRQHandler+0x100>)
3401f0ee:	681b      	ldr	r3, [r3, #0]
3401f0f0:	2b00      	cmp	r3, #0
3401f0f2:	d045      	beq.n	3401f180 <NPU0_IRQHandler+0xa0>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
3401f0f4:	4b3a      	ldr	r3, [pc, #232]	@ (3401f1e0 <NPU0_IRQHandler+0x100>)
3401f0f6:	681b      	ldr	r3, [r3, #0]
3401f0f8:	685b      	ldr	r3, [r3, #4]
3401f0fa:	2b00      	cmp	r3, #0
3401f0fc:	d106      	bne.n	3401f10c <NPU0_IRQHandler+0x2c>
3401f0fe:	4b39      	ldr	r3, [pc, #228]	@ (3401f1e4 <NPU0_IRQHandler+0x104>)
3401f100:	4a39      	ldr	r2, [pc, #228]	@ (3401f1e8 <NPU0_IRQHandler+0x108>)
3401f102:	f240 31b1 	movw	r1, #945	@ 0x3b1
3401f106:	4839      	ldr	r0, [pc, #228]	@ (3401f1ec <NPU0_IRQHandler+0x10c>)
3401f108:	f001 f892 	bl	34020230 <__assert_func>

    /** OR-mask interrupts MUST be handled first **/
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3401f10c:	4b34      	ldr	r3, [pc, #208]	@ (3401f1e0 <NPU0_IRQHandler+0x100>)
3401f10e:	681b      	ldr	r3, [r3, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
3401f110:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3401f112:	4618      	mov	r0, r3
3401f114:	f7ff f8ae 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401f118:	4603      	mov	r3, r0
3401f11a:	f083 0301 	eor.w	r3, r3, #1
3401f11e:	b2db      	uxtb	r3, r3
3401f120:	2b00      	cmp	r3, #0
3401f122:	d008      	beq.n	3401f136 <NPU0_IRQHandler+0x56>
    {
      __LL_ATON_RT_IrqErr(
3401f124:	687b      	ldr	r3, [r7, #4]
3401f126:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
3401f12a:	f023 0303 	bic.w	r3, r3, #3
3401f12e:	4618      	mov	r0, r3
3401f130:	f7ff fe7e 	bl	3401ee30 <__LL_ATON_RT_IrqErr>
3401f134:	e027      	b.n	3401f186 <NPU0_IRQHandler+0xa6>
          irqs & ~ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0)); /* exclude all streaming engine completion interrupts */
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3401f136:	4b2a      	ldr	r3, [pc, #168]	@ (3401f1e0 <NPU0_IRQHandler+0x100>)
3401f138:	681b      	ldr	r3, [r3, #0]
3401f13a:	685b      	ldr	r3, [r3, #4]
3401f13c:	4618      	mov	r0, r3
3401f13e:	f7ff f8e5 	bl	3401e30c <EpochBlock_EpochControllerUnit>
3401f142:	6038      	str	r0, [r7, #0]
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401f144:	683b      	ldr	r3, [r7, #0]
3401f146:	2b00      	cmp	r3, #0
3401f148:	d006      	beq.n	3401f158 <NPU0_IRQHandler+0x78>
3401f14a:	4b29      	ldr	r3, [pc, #164]	@ (3401f1f0 <NPU0_IRQHandler+0x110>)
3401f14c:	4a26      	ldr	r2, [pc, #152]	@ (3401f1e8 <NPU0_IRQHandler+0x108>)
3401f14e:	f240 31be 	movw	r1, #958	@ 0x3be
3401f152:	4826      	ldr	r0, [pc, #152]	@ (3401f1ec <NPU0_IRQHandler+0x10c>)
3401f154:	f001 f86c 	bl	34020230 <__assert_func>

      // epoch blob handling based on epoch controller interrupt
      __LL_ATON_RT_IrqErr(
          irqs & ~ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK,
3401f158:	683b      	ldr	r3, [r7, #0]
3401f15a:	2b00      	cmp	r3, #0
3401f15c:	d008      	beq.n	3401f170 <NPU0_IRQHandler+0x90>
3401f15e:	683b      	ldr	r3, [r7, #0]
3401f160:	2b01      	cmp	r3, #1
3401f162:	d102      	bne.n	3401f16a <NPU0_IRQHandler+0x8a>
3401f164:	f06f 5380 	mvn.w	r3, #268435456	@ 0x10000000
3401f168:	e004      	b.n	3401f174 <NPU0_IRQHandler+0x94>
3401f16a:	f04f 33ff 	mov.w	r3, #4294967295
3401f16e:	e001      	b.n	3401f174 <NPU0_IRQHandler+0x94>
3401f170:	f06f 5380 	mvn.w	r3, #268435456	@ 0x10000000
      __LL_ATON_RT_IrqErr(
3401f174:	687a      	ldr	r2, [r7, #4]
3401f176:	4013      	ands	r3, r2
3401f178:	4618      	mov	r0, r3
3401f17a:	f7ff fe59 	bl	3401ee30 <__LL_ATON_RT_IrqErr>
3401f17e:	e002      	b.n	3401f186 <NPU0_IRQHandler+0xa6>
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
3401f180:	6878      	ldr	r0, [r7, #4]
3401f182:	f7ff fe55 	bl	3401ee30 <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401f186:	4b16      	ldr	r3, [pc, #88]	@ (3401f1e0 <NPU0_IRQHandler+0x100>)
3401f188:	681b      	ldr	r3, [r3, #0]
3401f18a:	2b00      	cmp	r3, #0
3401f18c:	d106      	bne.n	3401f19c <NPU0_IRQHandler+0xbc>
3401f18e:	4b19      	ldr	r3, [pc, #100]	@ (3401f1f4 <NPU0_IRQHandler+0x114>)
3401f190:	4a15      	ldr	r2, [pc, #84]	@ (3401f1e8 <NPU0_IRQHandler+0x108>)
3401f192:	f240 31d2 	movw	r1, #978	@ 0x3d2
3401f196:	4815      	ldr	r0, [pc, #84]	@ (3401f1ec <NPU0_IRQHandler+0x10c>)
3401f198:	f001 f84a 	bl	34020230 <__assert_func>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
3401f19c:	4b10      	ldr	r3, [pc, #64]	@ (3401f1e0 <NPU0_IRQHandler+0x100>)
3401f19e:	681b      	ldr	r3, [r3, #0]
3401f1a0:	685b      	ldr	r3, [r3, #4]
3401f1a2:	4618      	mov	r0, r3
3401f1a4:	f7ff f866 	bl	3401e274 <EpochBlock_IsEpochBlob>
3401f1a8:	4603      	mov	r3, r0
3401f1aa:	f083 0301 	eor.w	r3, r3, #1
3401f1ae:	b2db      	uxtb	r3, r3
3401f1b0:	2b00      	cmp	r3, #0
3401f1b2:	d003      	beq.n	3401f1bc <NPU0_IRQHandler+0xdc>
  { // standard epoch block handling based on streaming engines
    __LL_ATON_RT_IrqEpochBlock(irqs);
3401f1b4:	6878      	ldr	r0, [r7, #4]
3401f1b6:	f7ff ff03 	bl	3401efc0 <__LL_ATON_RT_IrqEpochBlock>
3401f1ba:	e002      	b.n	3401f1c2 <NPU0_IRQHandler+0xe2>
  }
  else
  { // epoch blob handling based on epoch controller
#if defined(ATON_EPOCHCTRL_NUM)
    __LL_ATON_RT_IrqEpochBlob(irqs);
3401f1bc:	6878      	ldr	r0, [r7, #4]
3401f1be:	f7ff ff45 	bl	3401f04c <__LL_ATON_RT_IrqEpochBlob>
  __ASM volatile ("dsb 0xF":::"memory");
3401f1c2:	f3bf 8f4f 	dsb	sy
}
3401f1c6:	bf00      	nop
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
3401f1c8:	4a0b      	ldr	r2, [pc, #44]	@ (3401f1f8 <NPU0_IRQHandler+0x118>)
3401f1ca:	687b      	ldr	r3, [r7, #4]
3401f1cc:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
3401f1ce:	f3bf 8f4f 	dsb	sy
}
3401f1d2:	bf00      	nop
  /* Signal event */
  LL_ATON_OSAL_SIGNAL_EVENT();

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
3401f1d4:	bf00      	nop
}
3401f1d6:	3708      	adds	r7, #8
3401f1d8:	46bd      	mov	sp, r7
3401f1da:	bd80      	pop	{r7, pc}
3401f1dc:	580e1008 	.word	0x580e1008
3401f1e0:	34053db0 	.word	0x34053db0
3401f1e4:	34025118 	.word	0x34025118
3401f1e8:	34033224 	.word	0x34033224
3401f1ec:	34024ce8 	.word	0x34024ce8
3401f1f0:	34024d74 	.word	0x34024d74
3401f1f4:	34024b80 	.word	0x34024b80
3401f1f8:	580e1010 	.word	0x580e1010

3401f1fc <ll_sw_forward_dequantizelinear>:
}

//##########################################################################################
/** Dequantizelinear forward function */
void ll_sw_forward_dequantizelinear(/* int processor, */ void *sw_info_struct)
{
3401f1fc:	b580      	push	{r7, lr}
3401f1fe:	b0ca      	sub	sp, #296	@ 0x128
3401f200:	af00      	add	r7, sp, #0
3401f202:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f206:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
3401f20a:	6018      	str	r0, [r3, #0]
  Dequantizelinear_sw_info *sw_info = (Dequantizelinear_sw_info *)sw_info_struct;
3401f20c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f210:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
3401f214:	681b      	ldr	r3, [r3, #0]
3401f216:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124

  // array init
  int32_t format = sw_info->general.input.format.is_signed ? (AI_ARRAY_FORMAT_S8 | AI_FMT_FLAG_IS_IO)
3401f21a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f21e:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
                                                           : (AI_ARRAY_FORMAT_U8 | AI_FMT_FLAG_IS_IO);
3401f222:	2b00      	cmp	r3, #0
3401f224:	d001      	beq.n	3401f22a <ll_sw_forward_dequantizelinear+0x2e>
3401f226:	4bb4      	ldr	r3, [pc, #720]	@ (3401f4f8 <ll_sw_forward_dequantizelinear+0x2fc>)
3401f228:	e000      	b.n	3401f22c <ll_sw_forward_dequantizelinear+0x30>
3401f22a:	4bb4      	ldr	r3, [pc, #720]	@ (3401f4fc <ll_sw_forward_dequantizelinear+0x300>)
  int32_t format = sw_info->general.input.format.is_signed ? (AI_ARRAY_FORMAT_S8 | AI_FMT_FLAG_IS_IO)
3401f22c:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
  AI_ARRAY_OBJ_DECLARE(input_output_array, format, sw_info->general.input.mem.start_offset,
3401f230:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
3401f234:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
3401f238:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f23c:	695b      	ldr	r3, [r3, #20]
3401f23e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
3401f242:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f246:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401f248:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
3401f24c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f250:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401f252:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
                       sw_info->general.input.mem.start_offset, sw_info->general.input.dim.num_elem, )
  AI_ARRAY_OBJ_DECLARE(dequantize_output_array, FORMAT, sw_info->general.output.mem.start_offset,
3401f256:	4baa      	ldr	r3, [pc, #680]	@ (3401f500 <ll_sw_forward_dequantizelinear+0x304>)
3401f258:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
3401f25c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f260:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401f262:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
3401f266:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f26a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401f26c:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3401f270:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f274:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401f276:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
                       sw_info->general.output.mem.start_offset, sw_info->general.output.dim.num_elem, )

  uint16_t offset_format =
      sw_info->is.format.is_signed ? (AI_BUFFER_META_FLAG_ZEROPOINT_S8) : (AI_BUFFER_META_FLAG_ZEROPOINT_U8);
3401f27a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f27e:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
  uint16_t offset_format =
3401f282:	2b00      	cmp	r3, #0
3401f284:	d001      	beq.n	3401f28a <ll_sw_forward_dequantizelinear+0x8e>
3401f286:	2304      	movs	r3, #4
3401f288:	e000      	b.n	3401f28c <ll_sw_forward_dequantizelinear+0x90>
3401f28a:	2302      	movs	r3, #2
3401f28c:	f8a7 311e 	strh.w	r3, [r7, #286]	@ 0x11e
  uint16_t scale_format = AI_BUFFER_META_FLAG_SCALE_FLOAT;
3401f290:	2301      	movs	r3, #1
3401f292:	f8a7 311c 	strh.w	r3, [r7, #284]	@ 0x11c
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
3401f296:	f8b7 211e 	ldrh.w	r2, [r7, #286]	@ 0x11e
3401f29a:	f8b7 311c 	ldrh.w	r3, [r7, #284]	@ 0x11c
3401f29e:	4313      	orrs	r3, r2
3401f2a0:	b29b      	uxth	r3, r3
3401f2a2:	f8a7 30f4 	strh.w	r3, [r7, #244]	@ 0xf4
                                  .size = sw_info->is.dim.num_elem,
3401f2a6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f2aa:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
3401f2ac:	b29b      	uxth	r3, r3
3401f2ae:	f8a7 30f6 	strh.w	r3, [r7, #246]	@ 0xf6
                                  .info = (const ai_intq_info[1]){{
                                      .scale = ((float *)sw_info->is.mem.start_offset),
3401f2b2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f2b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
                                  .info = (const ai_intq_info[1]){{
3401f2ba:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
                                      .zeropoint = ((void *)sw_info->izp.mem.start_offset),
3401f2be:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f2c2:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
                                  .info = (const ai_intq_info[1]){{
3401f2c6:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
3401f2ca:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
3401f2ce:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
                                  }}};

  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
3401f2d2:	f107 03f4 	add.w	r3, r7, #244	@ 0xf4
3401f2d6:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
3401f2da:	2300      	movs	r3, #0
3401f2dc:	f8a7 30d4 	strh.w	r3, [r7, #212]	@ 0xd4
3401f2e0:	2304      	movs	r3, #4
3401f2e2:	f887 30d6 	strb.w	r3, [r7, #214]	@ 0xd6
3401f2e6:	2301      	movs	r3, #1
3401f2e8:	f887 30d7 	strb.w	r3, [r7, #215]	@ 0xd7
3401f2ec:	2301      	movs	r3, #1
3401f2ee:	f887 30d8 	strb.w	r3, [r7, #216]	@ 0xd8
3401f2f2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
3401f2f6:	2204      	movs	r2, #4
3401f2f8:	f362 231f 	bfi	r3, r2, #8, #24
3401f2fc:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
3401f300:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f304:	691b      	ldr	r3, [r3, #16]
3401f306:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3401f30a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f30e:	68db      	ldr	r3, [r3, #12]
3401f310:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3401f314:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f318:	689b      	ldr	r3, [r3, #8]
3401f31a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
3401f31e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f322:	685b      	ldr	r3, [r3, #4]
3401f324:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
3401f328:	f107 03c0 	add.w	r3, r7, #192	@ 0xc0
3401f32c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3401f330:	2302      	movs	r3, #2
3401f332:	f887 30e0 	strb.w	r3, [r7, #224]	@ 0xe0
3401f336:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
3401f33a:	2204      	movs	r2, #4
3401f33c:	f362 231f 	bfi	r3, r2, #8, #24
3401f340:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
3401f344:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f348:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401f34a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
3401f34e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f352:	6a1b      	ldr	r3, [r3, #32]
3401f354:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3401f358:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f35c:	69db      	ldr	r3, [r3, #28]
3401f35e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3401f362:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f366:	699b      	ldr	r3, [r3, #24]
3401f368:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3401f36c:	f107 03b0 	add.w	r3, r7, #176	@ 0xb0
3401f370:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
3401f374:	f507 7386 	add.w	r3, r7, #268	@ 0x10c
3401f378:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
                                   sw_info->general.input.dim.tensor_c, sw_info->general.input.dim.tensor_b),
                        STRIDE_INIT(sw_info->general.input.stride.h, sw_info->general.input.stride.w,
                                    sw_info->general.input.stride.c, sw_info->general.input.stride.b),
                        1, &input_output_array, &input_intq);

  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
3401f37c:	2300      	movs	r3, #0
3401f37e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
3401f382:	2300      	movs	r3, #0
3401f384:	f8a7 3098 	strh.w	r3, [r7, #152]	@ 0x98
3401f388:	2304      	movs	r3, #4
3401f38a:	f887 309a 	strb.w	r3, [r7, #154]	@ 0x9a
3401f38e:	2301      	movs	r3, #1
3401f390:	f887 309b 	strb.w	r3, [r7, #155]	@ 0x9b
3401f394:	2301      	movs	r3, #1
3401f396:	f887 309c 	strb.w	r3, [r7, #156]	@ 0x9c
3401f39a:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
3401f39e:	2204      	movs	r2, #4
3401f3a0:	f362 231f 	bfi	r3, r2, #8, #24
3401f3a4:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
3401f3a8:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f3ac:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401f3ae:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
3401f3b2:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f3b6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401f3b8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
3401f3bc:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f3c0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401f3c2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
3401f3c6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f3ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401f3cc:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
3401f3d0:	f107 0384 	add.w	r3, r7, #132	@ 0x84
3401f3d4:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
3401f3d8:	2302      	movs	r3, #2
3401f3da:	f887 30a4 	strb.w	r3, [r7, #164]	@ 0xa4
3401f3de:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
3401f3e2:	2204      	movs	r2, #4
3401f3e4:	f362 231f 	bfi	r3, r2, #8, #24
3401f3e8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
3401f3ec:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f3f0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3401f3f2:	677b      	str	r3, [r7, #116]	@ 0x74
3401f3f4:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f3f8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401f3fa:	67bb      	str	r3, [r7, #120]	@ 0x78
3401f3fc:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f400:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401f402:	67fb      	str	r3, [r7, #124]	@ 0x7c
3401f404:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401f408:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401f40a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
3401f40e:	f107 0374 	add.w	r3, r7, #116	@ 0x74
3401f412:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
3401f416:	f107 03fc 	add.w	r3, r7, #252	@ 0xfc
3401f41a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
                        STRIDE_INIT(sw_info->general.output.stride.h, sw_info->general.output.stride.w,
                                    sw_info->general.output.stride.c, sw_info->general.output.stride.b),
                        1, &dequantize_output_array, NULL);

  // tensor chain initialization
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
3401f41e:	2304      	movs	r3, #4
3401f420:	f8a7 306c 	strh.w	r3, [r7, #108]	@ 0x6c
3401f424:	2300      	movs	r3, #0
3401f426:	f8a7 306e 	strh.w	r3, [r7, #110]	@ 0x6e
3401f42a:	2301      	movs	r3, #1
3401f42c:	85bb      	strh	r3, [r7, #44]	@ 0x2c
3401f42e:	2300      	movs	r3, #0
3401f430:	85fb      	strh	r3, [r7, #46]	@ 0x2e
3401f432:	f107 03d0 	add.w	r3, r7, #208	@ 0xd0
3401f436:	66bb      	str	r3, [r7, #104]	@ 0x68
3401f438:	f107 0368 	add.w	r3, r7, #104	@ 0x68
3401f43c:	633b      	str	r3, [r7, #48]	@ 0x30
3401f43e:	2300      	movs	r3, #0
3401f440:	637b      	str	r3, [r7, #52]	@ 0x34
3401f442:	2301      	movs	r3, #1
3401f444:	873b      	strh	r3, [r7, #56]	@ 0x38
3401f446:	2300      	movs	r3, #0
3401f448:	877b      	strh	r3, [r7, #58]	@ 0x3a
3401f44a:	f107 0394 	add.w	r3, r7, #148	@ 0x94
3401f44e:	667b      	str	r3, [r7, #100]	@ 0x64
3401f450:	f107 0364 	add.w	r3, r7, #100	@ 0x64
3401f454:	63fb      	str	r3, [r7, #60]	@ 0x3c
3401f456:	2300      	movs	r3, #0
3401f458:	643b      	str	r3, [r7, #64]	@ 0x40
3401f45a:	2300      	movs	r3, #0
3401f45c:	f8a7 3044 	strh.w	r3, [r7, #68]	@ 0x44
3401f460:	2300      	movs	r3, #0
3401f462:	f8a7 3046 	strh.w	r3, [r7, #70]	@ 0x46
3401f466:	2300      	movs	r3, #0
3401f468:	663b      	str	r3, [r7, #96]	@ 0x60
3401f46a:	f107 0360 	add.w	r3, r7, #96	@ 0x60
3401f46e:	64bb      	str	r3, [r7, #72]	@ 0x48
3401f470:	2300      	movs	r3, #0
3401f472:	64fb      	str	r3, [r7, #76]	@ 0x4c
3401f474:	2300      	movs	r3, #0
3401f476:	f8a7 3050 	strh.w	r3, [r7, #80]	@ 0x50
3401f47a:	2300      	movs	r3, #0
3401f47c:	f8a7 3052 	strh.w	r3, [r7, #82]	@ 0x52
3401f480:	2300      	movs	r3, #0
3401f482:	65fb      	str	r3, [r7, #92]	@ 0x5c
3401f484:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
3401f488:	657b      	str	r3, [r7, #84]	@ 0x54
3401f48a:	2300      	movs	r3, #0
3401f48c:	65bb      	str	r3, [r7, #88]	@ 0x58
3401f48e:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
3401f492:	673b      	str	r3, [r7, #112]	@ 0x70
                              AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&dequantize_output)),
                              AI_TENSOR_LIST_OBJ_EMPTY, AI_TENSOR_LIST_OBJ_EMPTY)

  // layer initialization
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
3401f494:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f498:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401f49c:	4618      	mov	r0, r3
3401f49e:	2320      	movs	r3, #32
3401f4a0:	461a      	mov	r2, r3
3401f4a2:	2100      	movs	r1, #0
3401f4a4:	f002 f896 	bl	340215d4 <memset>
3401f4a8:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f4ac:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401f4b0:	f240 1207 	movw	r2, #263	@ 0x107
3401f4b4:	801a      	strh	r2, [r3, #0]
3401f4b6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f4ba:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401f4be:	2201      	movs	r2, #1
3401f4c0:	805a      	strh	r2, [r3, #2]
3401f4c2:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f4c6:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401f4ca:	4a0e      	ldr	r2, [pc, #56]	@ (3401f504 <ll_sw_forward_dequantizelinear+0x308>)
3401f4cc:	615a      	str	r2, [r3, #20]
3401f4ce:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f4d2:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401f4d6:	f107 026c 	add.w	r2, r7, #108	@ 0x6c
3401f4da:	619a      	str	r2, [r3, #24]
                       NULL, )
  dequantize_layer.forward(AI_LAYER_OBJ(&dequantize_layer));
3401f4dc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401f4e0:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401f4e4:	695b      	ldr	r3, [r3, #20]
3401f4e6:	f107 020c 	add.w	r2, r7, #12
3401f4ea:	4610      	mov	r0, r2
3401f4ec:	4798      	blx	r3
}
3401f4ee:	bf00      	nop
3401f4f0:	f507 7794 	add.w	r7, r7, #296	@ 0x128
3401f4f4:	46bd      	mov	sp, r7
3401f4f6:	bd80      	pop	{r7, pc}
3401f4f8:	08840440 	.word	0x08840440
3401f4fc:	08040440 	.word	0x08040440
3401f500:	00821040 	.word	0x00821040
3401f504:	3401f569 	.word	0x3401f569

3401f508 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
3401f508:	480f      	ldr	r0, [pc, #60]	@ (3401f548 <LoopForever+0x4>)
  msr   MSPLIM, r0
3401f50a:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
3401f50e:	480f      	ldr	r0, [pc, #60]	@ (3401f54c <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
3401f510:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
3401f512:	f7e7 fd5b 	bl	34006fcc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
3401f516:	480e      	ldr	r0, [pc, #56]	@ (3401f550 <LoopForever+0xc>)
  ldr r1, =_edata
3401f518:	490e      	ldr	r1, [pc, #56]	@ (3401f554 <LoopForever+0x10>)
  ldr r2, =_sidata
3401f51a:	4a0f      	ldr	r2, [pc, #60]	@ (3401f558 <LoopForever+0x14>)
  movs r3, #0
3401f51c:	2300      	movs	r3, #0
  b LoopCopyDataInit
3401f51e:	e002      	b.n	3401f526 <LoopCopyDataInit>

3401f520 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
3401f520:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
3401f522:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
3401f524:	3304      	adds	r3, #4

3401f526 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
3401f526:	18c4      	adds	r4, r0, r3
  cmp r4, r1
3401f528:	428c      	cmp	r4, r1
  bcc CopyDataInit
3401f52a:	d3f9      	bcc.n	3401f520 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
3401f52c:	4a0b      	ldr	r2, [pc, #44]	@ (3401f55c <LoopForever+0x18>)
  ldr r4, =_ebss
3401f52e:	4c0c      	ldr	r4, [pc, #48]	@ (3401f560 <LoopForever+0x1c>)
  movs r3, #0
3401f530:	2300      	movs	r3, #0
  b LoopFillZerobss
3401f532:	e001      	b.n	3401f538 <LoopFillZerobss>

3401f534 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
3401f534:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
3401f536:	3204      	adds	r2, #4

3401f538 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
3401f538:	42a2      	cmp	r2, r4
  bcc FillZerobss
3401f53a:	d3fb      	bcc.n	3401f534 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
3401f53c:	f002 faa4 	bl	34021a88 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
3401f540:	f7e1 fcbc 	bl	34000ebc <main>

3401f544 <LoopForever>:

LoopForever:
  b LoopForever
3401f544:	e7fe      	b.n	3401f544 <LoopForever>
3401f546:	0000      	.short	0x0000
  ldr   r0, =_sstack
3401f548:	340fc000 	.word	0x340fc000
  ldr   r0, =_estack
3401f54c:	34100000 	.word	0x34100000
  ldr r0, =_sdata
3401f550:	34033ee0 	.word	0x34033ee0
  ldr r1, =_edata
3401f554:	34034124 	.word	0x34034124
  ldr r2, =_sidata
3401f558:	34033ee0 	.word	0x34033ee0
  ldr r2, =_sbss
3401f55c:	34034124 	.word	0x34034124
  ldr r4, =_ebss
3401f560:	34053f0c 	.word	0x34053f0c

3401f564 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
3401f564:	e7fe      	b.n	3401f564 <ADC1_2_IRQHandler>
	...

3401f568 <node_convert>:
3401f568:	6982      	ldr	r2, [r0, #24]
3401f56a:	8813      	ldrh	r3, [r2, #0]
3401f56c:	2b00      	cmp	r3, #0
3401f56e:	d048      	beq.n	3401f602 <node_convert+0x9a>
3401f570:	6852      	ldr	r2, [r2, #4]
3401f572:	6851      	ldr	r1, [r2, #4]
3401f574:	b101      	cbz	r1, 3401f578 <node_convert+0x10>
3401f576:	6809      	ldr	r1, [r1, #0]
3401f578:	2b01      	cmp	r3, #1
3401f57a:	f000 8147 	beq.w	3401f80c <node_convert+0x2a4>
3401f57e:	b5f0      	push	{r4, r5, r6, r7, lr}
3401f580:	6910      	ldr	r0, [r2, #16]
3401f582:	b083      	sub	sp, #12
3401f584:	b100      	cbz	r0, 3401f588 <node_convert+0x20>
3401f586:	6800      	ldr	r0, [r0, #0]
3401f588:	688b      	ldr	r3, [r1, #8]
3401f58a:	2401      	movs	r4, #1
3401f58c:	0a1a      	lsrs	r2, r3, #8
3401f58e:	d011      	beq.n	3401f5b4 <node_convert+0x4c>
3401f590:	ea4f 0e82 	mov.w	lr, r2, lsl #2
3401f594:	f1ae 0e04 	sub.w	lr, lr, #4
3401f598:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
3401f59c:	44a6      	add	lr, r4
3401f59e:	f04e e001 	dls	lr, lr
3401f5a2:	68cb      	ldr	r3, [r1, #12]
3401f5a4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
3401f5a8:	f853 2d04 	ldr.w	r2, [r3, #-4]!
3401f5ac:	fb02 f404 	mul.w	r4, r2, r4
3401f5b0:	f00f c007 	le	lr, 3401f5a8 <node_convert+0x40>
3401f5b4:	698a      	ldr	r2, [r1, #24]
3401f5b6:	6985      	ldr	r5, [r0, #24]
3401f5b8:	6813      	ldr	r3, [r2, #0]
3401f5ba:	f3c3 4c43 	ubfx	ip, r3, #17, #4
3401f5be:	f1bc 0f01 	cmp.w	ip, #1
3401f5c2:	d020      	beq.n	3401f606 <node_convert+0x9e>
3401f5c4:	680e      	ldr	r6, [r1, #0]
3401f5c6:	68ad      	ldr	r5, [r5, #8]
3401f5c8:	2e00      	cmp	r6, #0
3401f5ca:	d03a      	beq.n	3401f642 <node_convert+0xda>
3401f5cc:	6871      	ldr	r1, [r6, #4]
3401f5ce:	6890      	ldr	r0, [r2, #8]
3401f5d0:	f3c3 52c0 	ubfx	r2, r3, #23, #1
3401f5d4:	2900      	cmp	r1, #0
3401f5d6:	f000 8099 	beq.w	3401f70c <node_convert+0x1a4>
3401f5da:	8873      	ldrh	r3, [r6, #2]
3401f5dc:	2b00      	cmp	r3, #0
3401f5de:	f000 8082 	beq.w	3401f6e6 <node_convert+0x17e>
3401f5e2:	680b      	ldr	r3, [r1, #0]
3401f5e4:	ed93 0a00 	vldr	s0, [r3]
3401f5e8:	684b      	ldr	r3, [r1, #4]
3401f5ea:	2a00      	cmp	r2, #0
3401f5ec:	f000 809a 	beq.w	3401f724 <node_convert+0x1bc>
3401f5f0:	f993 3000 	ldrsb.w	r3, [r3]
3401f5f4:	4622      	mov	r2, r4
3401f5f6:	4629      	mov	r1, r5
3401f5f8:	b003      	add	sp, #12
3401f5fa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f5fe:	f000 b909 	b.w	3401f814 <forward_lite_node_convert_integer_is8of32>
3401f602:	685b      	ldr	r3, [r3, #4]
3401f604:	deff      	udf	#255	@ 0xff
3401f606:	6806      	ldr	r6, [r0, #0]
3401f608:	6890      	ldr	r0, [r2, #8]
3401f60a:	2e00      	cmp	r6, #0
3401f60c:	f000 8092 	beq.w	3401f734 <node_convert+0x1cc>
3401f610:	682b      	ldr	r3, [r5, #0]
3401f612:	6872      	ldr	r2, [r6, #4]
3401f614:	68a9      	ldr	r1, [r5, #8]
3401f616:	f3c3 53c0 	ubfx	r3, r3, #23, #1
3401f61a:	2a00      	cmp	r2, #0
3401f61c:	d067      	beq.n	3401f6ee <node_convert+0x186>
3401f61e:	8875      	ldrh	r5, [r6, #2]
3401f620:	2d00      	cmp	r5, #0
3401f622:	d069      	beq.n	3401f6f8 <node_convert+0x190>
3401f624:	6815      	ldr	r5, [r2, #0]
3401f626:	ed95 0a00 	vldr	s0, [r5]
3401f62a:	2b00      	cmp	r3, #0
3401f62c:	f000 80e3 	beq.w	3401f7f6 <node_convert+0x28e>
3401f630:	6853      	ldr	r3, [r2, #4]
3401f632:	f993 3000 	ldrsb.w	r3, [r3]
3401f636:	4622      	mov	r2, r4
3401f638:	b003      	add	sp, #12
3401f63a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f63e:	f000 b8ed 	b.w	3401f81c <forward_lite_node_convert_integer_if32os8>
3401f642:	f3c3 11c6 	ubfx	r1, r3, #7, #7
3401f646:	f003 067f 	and.w	r6, r3, #127	@ 0x7f
3401f64a:	1b8e      	subs	r6, r1, r6
3401f64c:	3640      	adds	r6, #64	@ 0x40
3401f64e:	f3c3 53c0 	ubfx	r3, r3, #23, #1
3401f652:	2908      	cmp	r1, #8
3401f654:	6890      	ldr	r0, [r2, #8]
3401f656:	4629      	mov	r1, r5
3401f658:	4622      	mov	r2, r4
3401f65a:	eba6 0603 	sub.w	r6, r6, r3
3401f65e:	f000 80bc 	beq.w	3401f7da <node_convert+0x272>
3401f662:	f000 fd57 	bl	34020114 <st_int16_to_f32>
3401f666:	b3e6      	cbz	r6, 3401f6e2 <node_convert+0x17a>
3401f668:	ee07 6a90 	vmov	s15, r6
3401f66c:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
3401f670:	eef8 0ae7 	vcvt.f32.s32	s1, s15
3401f674:	f004 f834 	bl	340236e0 <powf>
3401f678:	b39c      	cbz	r4, 3401f6e2 <node_convert+0x17a>
3401f67a:	1e63      	subs	r3, r4, #1
3401f67c:	2b02      	cmp	r3, #2
3401f67e:	f240 80c1 	bls.w	3401f804 <node_convert+0x29c>
3401f682:	ee10 3a10 	vmov	r3, s0
3401f686:	08a2      	lsrs	r2, r4, #2
3401f688:	eea4 3b10 	vdup.32	q2, r3
3401f68c:	f042 e001 	dls	lr, r2
3401f690:	462b      	mov	r3, r5
3401f692:	ed93 7f00 	ldc	15, cr7, [r3]
3401f696:	461a      	mov	r2, r3
3401f698:	ff06 6d54 	vmul.f32	q3, q3, q2
3401f69c:	3310      	adds	r3, #16
3401f69e:	ed82 7f00 	stc	15, cr7, [r2]
3401f6a2:	f00f c00b 	le	lr, 3401f692 <node_convert+0x12a>
3401f6a6:	f024 0303 	bic.w	r3, r4, #3
3401f6aa:	429c      	cmp	r4, r3
3401f6ac:	eb05 0583 	add.w	r5, r5, r3, lsl #2
3401f6b0:	d017      	beq.n	3401f6e2 <node_convert+0x17a>
3401f6b2:	edd5 7a00 	vldr	s15, [r5]
3401f6b6:	ee67 7a80 	vmul.f32	s15, s15, s0
3401f6ba:	1c5a      	adds	r2, r3, #1
3401f6bc:	4294      	cmp	r4, r2
3401f6be:	edc5 7a00 	vstr	s15, [r5]
3401f6c2:	d90e      	bls.n	3401f6e2 <node_convert+0x17a>
3401f6c4:	edd5 7a01 	vldr	s15, [r5, #4]
3401f6c8:	ee67 7a80 	vmul.f32	s15, s15, s0
3401f6cc:	3302      	adds	r3, #2
3401f6ce:	429c      	cmp	r4, r3
3401f6d0:	edc5 7a01 	vstr	s15, [r5, #4]
3401f6d4:	d905      	bls.n	3401f6e2 <node_convert+0x17a>
3401f6d6:	edd5 7a02 	vldr	s15, [r5, #8]
3401f6da:	ee67 7a80 	vmul.f32	s15, s15, s0
3401f6de:	edc5 7a02 	vstr	s15, [r5, #8]
3401f6e2:	b003      	add	sp, #12
3401f6e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401f6e6:	b19a      	cbz	r2, 3401f710 <node_convert+0x1a8>
3401f6e8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401f6ec:	e782      	b.n	3401f5f4 <node_convert+0x8c>
3401f6ee:	b12b      	cbz	r3, 3401f6fc <node_convert+0x194>
3401f6f0:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401f6f4:	4613      	mov	r3, r2
3401f6f6:	e79e      	b.n	3401f636 <node_convert+0xce>
3401f6f8:	2b00      	cmp	r3, #0
3401f6fa:	d17f      	bne.n	3401f7fc <node_convert+0x294>
3401f6fc:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401f700:	4622      	mov	r2, r4
3401f702:	b003      	add	sp, #12
3401f704:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f708:	f000 b88a 	b.w	3401f820 <forward_lite_node_convert_integer_if32ou8>
3401f70c:	2a00      	cmp	r2, #0
3401f70e:	d167      	bne.n	3401f7e0 <node_convert+0x278>
3401f710:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401f714:	2300      	movs	r3, #0
3401f716:	4622      	mov	r2, r4
3401f718:	4629      	mov	r1, r5
3401f71a:	b003      	add	sp, #12
3401f71c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f720:	f000 b87a 	b.w	3401f818 <forward_lite_node_convert_integer_iu8of32>
3401f724:	4622      	mov	r2, r4
3401f726:	4629      	mov	r1, r5
3401f728:	781b      	ldrb	r3, [r3, #0]
3401f72a:	b003      	add	sp, #12
3401f72c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f730:	f000 b872 	b.w	3401f818 <forward_lite_node_convert_integer_iu8of32>
3401f734:	682a      	ldr	r2, [r5, #0]
3401f736:	f3c2 17c6 	ubfx	r7, r2, #7, #7
3401f73a:	f002 037f 	and.w	r3, r2, #127	@ 0x7f
3401f73e:	1afb      	subs	r3, r7, r3
3401f740:	3340      	adds	r3, #64	@ 0x40
3401f742:	f3c2 52c0 	ubfx	r2, r2, #23, #1
3401f746:	1a9b      	subs	r3, r3, r2
3401f748:	d03e      	beq.n	3401f7c8 <node_convert+0x260>
3401f74a:	425b      	negs	r3, r3
3401f74c:	ee00 3a90 	vmov	s1, r3
3401f750:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
3401f754:	eef8 0ae0 	vcvt.f32.s32	s1, s1
3401f758:	9001      	str	r0, [sp, #4]
3401f75a:	f003 ffc1 	bl	340236e0 <powf>
3401f75e:	9801      	ldr	r0, [sp, #4]
3401f760:	b394      	cbz	r4, 3401f7c8 <node_convert+0x260>
3401f762:	1e63      	subs	r3, r4, #1
3401f764:	2b02      	cmp	r3, #2
3401f766:	d94f      	bls.n	3401f808 <node_convert+0x2a0>
3401f768:	ee10 2a10 	vmov	r2, s0
3401f76c:	08a3      	lsrs	r3, r4, #2
3401f76e:	f043 e001 	dls	lr, r3
3401f772:	eea4 2b10 	vdup.32	q2, r2
3401f776:	4603      	mov	r3, r0
3401f778:	ed93 7f00 	ldc	15, cr7, [r3]
3401f77c:	461a      	mov	r2, r3
3401f77e:	ff06 6d54 	vmul.f32	q3, q3, q2
3401f782:	3310      	adds	r3, #16
3401f784:	ed82 7f00 	stc	15, cr7, [r2]
3401f788:	f00f c00b 	le	lr, 3401f778 <node_convert+0x210>
3401f78c:	f024 0603 	bic.w	r6, r4, #3
3401f790:	42a6      	cmp	r6, r4
3401f792:	eb00 0386 	add.w	r3, r0, r6, lsl #2
3401f796:	d017      	beq.n	3401f7c8 <node_convert+0x260>
3401f798:	edd3 7a00 	vldr	s15, [r3]
3401f79c:	ee67 7a80 	vmul.f32	s15, s15, s0
3401f7a0:	1c72      	adds	r2, r6, #1
3401f7a2:	42a2      	cmp	r2, r4
3401f7a4:	edc3 7a00 	vstr	s15, [r3]
3401f7a8:	d20e      	bcs.n	3401f7c8 <node_convert+0x260>
3401f7aa:	edd3 7a01 	vldr	s15, [r3, #4]
3401f7ae:	ee67 7a80 	vmul.f32	s15, s15, s0
3401f7b2:	3602      	adds	r6, #2
3401f7b4:	42b4      	cmp	r4, r6
3401f7b6:	edc3 7a01 	vstr	s15, [r3, #4]
3401f7ba:	d905      	bls.n	3401f7c8 <node_convert+0x260>
3401f7bc:	edd3 7a02 	vldr	s15, [r3, #8]
3401f7c0:	ee67 7a80 	vmul.f32	s15, s15, s0
3401f7c4:	edc3 7a02 	vstr	s15, [r3, #8]
3401f7c8:	2f08      	cmp	r7, #8
3401f7ca:	d00d      	beq.n	3401f7e8 <node_convert+0x280>
3401f7cc:	4622      	mov	r2, r4
3401f7ce:	68a9      	ldr	r1, [r5, #8]
3401f7d0:	b003      	add	sp, #12
3401f7d2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f7d6:	f000 ba07 	b.w	3401fbe8 <st_f32_to_int16>
3401f7da:	f000 fcdd 	bl	34020198 <st_int8_to_f32>
3401f7de:	e742      	b.n	3401f666 <node_convert+0xfe>
3401f7e0:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401f7e4:	460b      	mov	r3, r1
3401f7e6:	e705      	b.n	3401f5f4 <node_convert+0x8c>
3401f7e8:	4622      	mov	r2, r4
3401f7ea:	68a9      	ldr	r1, [r5, #8]
3401f7ec:	b003      	add	sp, #12
3401f7ee:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3401f7f2:	f000 bacd 	b.w	3401fd90 <st_f32_to_int8>
3401f7f6:	6853      	ldr	r3, [r2, #4]
3401f7f8:	781b      	ldrb	r3, [r3, #0]
3401f7fa:	e781      	b.n	3401f700 <node_convert+0x198>
3401f7fc:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401f800:	462b      	mov	r3, r5
3401f802:	e718      	b.n	3401f636 <node_convert+0xce>
3401f804:	2300      	movs	r3, #0
3401f806:	e754      	b.n	3401f6b2 <node_convert+0x14a>
3401f808:	4603      	mov	r3, r0
3401f80a:	e7c5      	b.n	3401f798 <node_convert+0x230>
3401f80c:	2300      	movs	r3, #0
3401f80e:	685b      	ldr	r3, [r3, #4]
3401f810:	deff      	udf	#255	@ 0xff
3401f812:	bf00      	nop

3401f814 <forward_lite_node_convert_integer_is8of32>:
3401f814:	f000 b806 	b.w	3401f824 <lite_convert_is8of32>

3401f818 <forward_lite_node_convert_integer_iu8of32>:
3401f818:	f000 b83a 	b.w	3401f890 <lite_convert_iu8of32>

3401f81c <forward_lite_node_convert_integer_if32os8>:
3401f81c:	f000 b860 	b.w	3401f8e0 <lite_convert_if32os8>

3401f820 <forward_lite_node_convert_integer_if32ou8>:
3401f820:	f000 b956 	b.w	3401fad0 <lite_convert_if32ou8>

3401f824 <lite_convert_is8of32>:
3401f824:	2a00      	cmp	r2, #0
3401f826:	dd31      	ble.n	3401f88c <lite_convert_is8of32+0x68>
3401f828:	b570      	push	{r4, r5, r6, lr}
3401f82a:	1885      	adds	r5, r0, r2
3401f82c:	1e50      	subs	r0, r2, #1
3401f82e:	f020 0003 	bic.w	r0, r0, #3
3401f832:	1f16      	subs	r6, r2, #4
3401f834:	ea4f 0c92 	mov.w	ip, r2, lsr #2
3401f838:	ee10 4a10 	vmov	r4, s0
3401f83c:	1a36      	subs	r6, r6, r0
3401f83e:	f10c 0c01 	add.w	ip, ip, #1
3401f842:	e008      	b.n	3401f856 <lite_convert_is8of32+0x32>
3401f844:	4608      	mov	r0, r1
3401f846:	4296      	cmp	r6, r2
3401f848:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401f84c:	ed80 7f00 	stc	15, cr7, [r0]
3401f850:	f101 0110 	add.w	r1, r1, #16
3401f854:	d019      	beq.n	3401f88a <lite_convert_is8of32+0x66>
3401f856:	f022 e801 	bfcsel	0, 3401f85c <lite_convert_is8of32+0x38>, 4, hi
3401f85a:	1aa8      	subs	r0, r5, r2
3401f85c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401f860:	ed90 6f00 	ldc	15, cr6, [r0]
3401f864:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
3401f868:	ffbb 6646 	vcvt.f32.s32	q3, q3
3401f86c:	f1bc 0c01 	subs.w	ip, ip, #1
3401f870:	eefd ea10 	vmrs	lr, <impl def 0xd>
3401f874:	ee37 6e64 	cdp	14, 3, cr6, cr7, cr4, {3}
3401f878:	f1a2 0204 	sub.w	r2, r2, #4
3401f87c:	d1e2      	bne.n	3401f844 <lite_convert_is8of32+0x20>
3401f87e:	eeed ea10 	vmsr	<impl def 0xd>, lr
3401f882:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401f886:	ed81 7f00 	stc	15, cr7, [r1]
3401f88a:	bd70      	pop	{r4, r5, r6, pc}
3401f88c:	4770      	bx	lr
3401f88e:	bf00      	nop

3401f890 <lite_convert_iu8of32>:
3401f890:	2a00      	cmp	r2, #0
3401f892:	dd22      	ble.n	3401f8da <lite_convert_iu8of32+0x4a>
3401f894:	b530      	push	{r4, r5, lr}
3401f896:	f102 3eff 	add.w	lr, r2, #4294967295
3401f89a:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
3401f89e:	f10e 0e01 	add.w	lr, lr, #1
3401f8a2:	ee10 5a10 	vmov	r5, s0
3401f8a6:	f04e e001 	dls	lr, lr
3401f8aa:	1884      	adds	r4, r0, r2
3401f8ac:	f022 e801 	bfcsel	0, 3401f8b2 <lite_convert_iu8of32+0x22>, 4, hi
3401f8b0:	1aa0      	subs	r0, r4, r2
3401f8b2:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401f8b6:	fd90 6f00 	ldc2	15, cr6, [r0]
3401f8ba:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
3401f8be:	ffbb 6646 	vcvt.f32.s32	q3, q3
3401f8c2:	4608      	mov	r0, r1
3401f8c4:	ee37 6e65 	cdp	14, 3, cr6, cr7, cr5, {3}
3401f8c8:	3a04      	subs	r2, #4
3401f8ca:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401f8ce:	ed80 7f00 	stc	15, cr7, [r0]
3401f8d2:	3110      	adds	r1, #16
3401f8d4:	f00f c017 	le	lr, 3401f8ac <lite_convert_iu8of32+0x1c>
3401f8d8:	bd30      	pop	{r4, r5, pc}
3401f8da:	4770      	bx	lr
3401f8dc:	0000      	movs	r0, r0
	...

3401f8e0 <lite_convert_if32os8>:
3401f8e0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401f8e4:	ee07 3a10 	vmov	s14, r3
3401f8e8:	eec7 7a80 	vdiv.f32	s15, s15, s0
3401f8ec:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
3401f8f0:	ee17 ca90 	vmov	ip, s15
3401f8f4:	b500      	push	{lr}
3401f8f6:	ed2d 8b10 	vpush	{d8-d15}
3401f8fa:	ee17 3a10 	vmov	r3, s14
3401f8fe:	eea8 cb10 	vdup.32	q4, ip
3401f902:	b09d      	sub	sp, #116	@ 0x74
3401f904:	eea0 3b10 	vdup.32	q0, r3
3401f908:	2a00      	cmp	r2, #0
3401f90a:	ab10      	add	r3, sp, #64	@ 0x40
3401f90c:	ed83 9f00 	stc	15, cr9, [r3]
3401f910:	dd6a      	ble.n	3401f9e8 <lite_convert_if32os8+0x108>
3401f912:	2a0f      	cmp	r2, #15
3401f914:	dd6d      	ble.n	3401f9f2 <lite_convert_if32os8+0x112>
3401f916:	f1a2 0c10 	sub.w	ip, r2, #16
3401f91a:	ea4f 131c 	mov.w	r3, ip, lsr #4
3401f91e:	3301      	adds	r3, #1
3401f920:	f1bc 0f00 	cmp.w	ip, #0
3401f924:	f04f 0e01 	mov.w	lr, #1
3401f928:	ed9f 2b61 	vldr	d2, [pc, #388]	@ 3401fab0 <lite_convert_if32os8+0x1d0>
3401f92c:	ed9f 3b62 	vldr	d3, [pc, #392]	@ 3401fab8 <lite_convert_if32os8+0x1d8>
3401f930:	bfa8      	it	ge
3401f932:	469e      	movge	lr, r3
3401f934:	ab14      	add	r3, sp, #80	@ 0x50
3401f936:	ed9f 4b62 	vldr	d4, [pc, #392]	@ 3401fac0 <lite_convert_if32os8+0x1e0>
3401f93a:	ed9f 5b63 	vldr	d5, [pc, #396]	@ 3401fac8 <lite_convert_if32os8+0x1e8>
3401f93e:	f04e e001 	dls	lr, lr
3401f942:	ef22 6152 	vorr	q3, q1, q1
3401f946:	ed83 9f00 	stc	15, cr9, [r3]
3401f94a:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
3401f94e:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
3401f952:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
3401f956:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
3401f95a:	466b      	mov	r3, sp
3401f95c:	ec8d 8b10 	vstmia	sp, {d8-d15}
3401f960:	ed93 df00 	ldc	15, cr13, [r3]
3401f964:	ab14      	add	r3, sp, #80	@ 0x50
3401f966:	ed93 ff00 	ldc	15, cr15, [r3]
3401f96a:	ef20 a150 	vorr	q5, q0, q0
3401f96e:	ef0c ac5e 	vfma.f32	q5, q6, q7
3401f972:	ffbb a04a 	vcvta.s32.f32	q5, q5
3401f976:	ab04      	add	r3, sp, #16
3401f978:	ed93 df00 	ldc	15, cr13, [r3]
3401f97c:	ee37 6e0b 	cdp	14, 3, cr6, cr7, cr11, {0}
3401f980:	ef20 a150 	vorr	q5, q0, q0
3401f984:	ef0c ac5e 	vfma.f32	q5, q6, q7
3401f988:	ffbb a04a 	vcvta.s32.f32	q5, q5
3401f98c:	ab08      	add	r3, sp, #32
3401f98e:	ee37 2e0b 	cdp	14, 3, cr2, cr7, cr11, {0}
3401f992:	ef20 c150 	vorr	q6, q0, q0
3401f996:	ed93 bf00 	ldc	15, cr11, [r3]
3401f99a:	ab0c      	add	r3, sp, #48	@ 0x30
3401f99c:	ef0a cc5e 	vfma.f32	q6, q5, q7
3401f9a0:	ed93 9f00 	ldc	15, cr9, [r3]
3401f9a4:	ef20 a150 	vorr	q5, q0, q0
3401f9a8:	ffbb c04c 	vcvta.s32.f32	q6, q6
3401f9ac:	ef08 ac5e 	vfma.f32	q5, q4, q7
3401f9b0:	ee37 7e0d 	cdp	14, 3, cr7, cr7, cr13, {0}
3401f9b4:	ffbb a04a 	vcvta.s32.f32	q5, q5
3401f9b8:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
3401f9bc:	ee37 3e0b 	cdp	14, 3, cr3, cr7, cr11, {0}
3401f9c0:	f002 e801 	bfcsel	0, 3401f9c6 <lite_convert_if32os8+0xe6>, 4, eq
3401f9c4:	468c      	mov	ip, r1
3401f9c6:	ee33 5e03 	cdp	14, 3, cr5, cr3, cr3, {0}
3401f9ca:	3110      	adds	r1, #16
3401f9cc:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401f9d0:	ed8c 5e00 	stc	14, cr5, [ip]
3401f9d4:	3a10      	subs	r2, #16
3401f9d6:	f00f c049 	le	lr, 3401f94a <lite_convert_if32os8+0x6a>
3401f9da:	ab14      	add	r3, sp, #80	@ 0x50
3401f9dc:	ed83 5e00 	stc	14, cr5, [r3]
3401f9e0:	ab18      	add	r3, sp, #96	@ 0x60
3401f9e2:	ed83 3e80 	stc	14, cr3, [r3, #512]	@ 0x200
3401f9e6:	b9a2      	cbnz	r2, 3401fa12 <lite_convert_if32os8+0x132>
3401f9e8:	b01d      	add	sp, #116	@ 0x74
3401f9ea:	ecbd 8b10 	vpop	{d8-d15}
3401f9ee:	f85d fb04 	ldr.w	pc, [sp], #4
3401f9f2:	ed9f 4b2f 	vldr	d4, [pc, #188]	@ 3401fab0 <lite_convert_if32os8+0x1d0>
3401f9f6:	ed9f 5b30 	vldr	d5, [pc, #192]	@ 3401fab8 <lite_convert_if32os8+0x1d8>
3401f9fa:	ed9f 6b31 	vldr	d6, [pc, #196]	@ 3401fac0 <lite_convert_if32os8+0x1e0>
3401f9fe:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 3401fac8 <lite_convert_if32os8+0x1e8>
3401fa02:	ab18      	add	r3, sp, #96	@ 0x60
3401fa04:	ed83 5e80 	stc	14, cr5, [r3, #512]	@ 0x200
3401fa08:	ab14      	add	r3, sp, #80	@ 0x50
3401fa0a:	ed83 7e00 	stc	14, cr7, [r3]
3401fa0e:	ef24 6154 	vorr	q3, q2, q2
3401fa12:	f002 e801 	bfcsel	0, 3401fa18 <lite_convert_if32os8+0x138>, 4, eq
3401fa16:	aa10      	add	r2, sp, #64	@ 0x40
3401fa18:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
3401fa1c:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
3401fa20:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
3401fa24:	fc90 9f61 	ldc2	15, cr9, [r0], {97}	@ 0x61
3401fa28:	ed92 5f00 	ldc	15, cr5, [r2]
3401fa2c:	ef20 2150 	vorr	q1, q0, q0
3401fa30:	ef08 2c54 	vfma.f32	q1, q4, q2
3401fa34:	ffbb 4042 	vcvta.s32.f32	q2, q1
3401fa38:	466a      	mov	r2, sp
3401fa3a:	ee37 6e05 	cdp	14, 3, cr6, cr7, cr5, {0}
3401fa3e:	ed82 7e80 	stc	14, cr7, [r2, #512]	@ 0x200
3401fa42:	aa10      	add	r2, sp, #64	@ 0x40
3401fa44:	ed92 5f00 	ldc	15, cr5, [r2]
3401fa48:	ef20 2150 	vorr	q1, q0, q0
3401fa4c:	ef0a 2c54 	vfma.f32	q1, q5, q2
3401fa50:	aa18      	add	r2, sp, #96	@ 0x60
3401fa52:	ffbb 6042 	vcvta.s32.f32	q3, q1
3401fa56:	ed92 3e80 	ldc	14, cr3, [r2, #512]	@ 0x200
3401fa5a:	ee37 2e07 	cdp	14, 3, cr2, cr7, cr7, {0}
3401fa5e:	aa10      	add	r2, sp, #64	@ 0x40
3401fa60:	ef22 4152 	vorr	q2, q1, q1
3401fa64:	ed92 3f00 	ldc	15, cr3, [r2]
3401fa68:	ef20 6150 	vorr	q3, q0, q0
3401fa6c:	ef0e 0c52 	vfma.f32	q0, q7, q1
3401fa70:	ef0c 6c52 	vfma.f32	q3, q6, q1
3401fa74:	466a      	mov	r2, sp
3401fa76:	ef20 2150 	vorr	q1, q0, q0
3401fa7a:	ffbb 0046 	vcvta.s32.f32	q0, q3
3401fa7e:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401fa82:	ed92 7e80 	ldc	14, cr7, [r2, #512]	@ 0x200
3401fa86:	aa14      	add	r2, sp, #80	@ 0x50
3401fa88:	ee37 5e03 	cdp	14, 3, cr5, cr7, cr3, {0}
3401fa8c:	ee37 7e01 	cdp	14, 3, cr7, cr7, cr1, {0}
3401fa90:	ed92 3e00 	ldc	14, cr3, [r2]
3401fa94:	ee33 2e07 	cdp	14, 3, cr2, cr3, cr7, {0}
3401fa98:	ee33 3e05 	cdp	14, 3, cr3, cr3, cr5, {0}
3401fa9c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401faa0:	ed81 3e00 	stc	14, cr3, [r1]
3401faa4:	b01d      	add	sp, #116	@ 0x74
3401faa6:	ecbd 8b10 	vpop	{d8-d15}
3401faaa:	f85d fb04 	ldr.w	pc, [sp], #4
3401faae:	bf00      	nop
	...

3401fad0 <lite_convert_if32ou8>:
3401fad0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401fad4:	2a00      	cmp	r2, #0
3401fad6:	eec7 7a80 	vdiv.f32	s15, s15, s0
3401fada:	dd72      	ble.n	3401fbc2 <lite_convert_if32ou8+0xf2>
3401fadc:	ee07 3a10 	vmov	s14, r3
3401fae0:	eeb8 7a47 	vcvt.f32.u32	s14, s14
3401fae4:	ee17 ca90 	vmov	ip, s15
3401fae8:	b500      	push	{lr}
3401faea:	ed2d 8b10 	vpush	{d8-d15}
3401faee:	ee17 3a10 	vmov	r3, s14
3401faf2:	eea8 cb10 	vdup.32	q4, ip
3401faf6:	ed9f 6b34 	vldr	d6, [pc, #208]	@ 3401fbc8 <lite_convert_if32ou8+0xf8>
3401fafa:	ed9f 7b35 	vldr	d7, [pc, #212]	@ 3401fbd0 <lite_convert_if32ou8+0x100>
3401fafe:	f102 3eff 	add.w	lr, r2, #4294967295
3401fb02:	b095      	sub	sp, #84	@ 0x54
3401fb04:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
3401fb08:	eea0 3b10 	vdup.32	q0, r3
3401fb0c:	f10e 0e01 	add.w	lr, lr, #1
3401fb10:	ab10      	add	r3, sp, #64	@ 0x40
3401fb12:	ed9f 2b31 	vldr	d2, [pc, #196]	@ 3401fbd8 <lite_convert_if32ou8+0x108>
3401fb16:	ed9f 3b32 	vldr	d3, [pc, #200]	@ 3401fbe0 <lite_convert_if32ou8+0x110>
3401fb1a:	f04e e001 	dls	lr, lr
3401fb1e:	ef26 4156 	vorr	q2, q3, q3
3401fb22:	ed83 9f00 	stc	15, cr9, [r3]
3401fb26:	4411      	add	r1, r2
3401fb28:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
3401fb2c:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
3401fb30:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
3401fb34:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
3401fb38:	466b      	mov	r3, sp
3401fb3a:	ec8d 8b10 	vstmia	sp, {d8-d15}
3401fb3e:	ed93 df00 	ldc	15, cr13, [r3]
3401fb42:	ab10      	add	r3, sp, #64	@ 0x40
3401fb44:	ed93 ff00 	ldc	15, cr15, [r3]
3401fb48:	ef20 a150 	vorr	q5, q0, q0
3401fb4c:	ef0c ac5e 	vfma.f32	q5, q6, q7
3401fb50:	ffbb a0ca 	vcvta.u32.f32	q5, q5
3401fb54:	ab04      	add	r3, sp, #16
3401fb56:	ed93 df00 	ldc	15, cr13, [r3]
3401fb5a:	fe37 4e0b 	cdp2	14, 3, cr4, cr7, cr11, {0}
3401fb5e:	ef20 a150 	vorr	q5, q0, q0
3401fb62:	ef0c ac5e 	vfma.f32	q5, q6, q7
3401fb66:	ffbb a0ca 	vcvta.u32.f32	q5, q5
3401fb6a:	ab08      	add	r3, sp, #32
3401fb6c:	fe37 6e0b 	cdp2	14, 3, cr6, cr7, cr11, {0}
3401fb70:	ef20 c150 	vorr	q6, q0, q0
3401fb74:	ed93 bf00 	ldc	15, cr11, [r3]
3401fb78:	ab0c      	add	r3, sp, #48	@ 0x30
3401fb7a:	ef0a cc5e 	vfma.f32	q6, q5, q7
3401fb7e:	ed93 9f00 	ldc	15, cr9, [r3]
3401fb82:	ef20 a150 	vorr	q5, q0, q0
3401fb86:	ffbb c0cc 	vcvta.u32.f32	q6, q6
3401fb8a:	ef08 ac5e 	vfma.f32	q5, q4, q7
3401fb8e:	fe37 5e0d 	cdp2	14, 3, cr5, cr7, cr13, {0}
3401fb92:	ffbb a0ca 	vcvta.u32.f32	q5, q5
3401fb96:	fe33 2e05 	cdp2	14, 3, cr2, cr3, cr5, {0}
3401fb9a:	fe37 7e0b 	cdp2	14, 3, cr7, cr7, cr11, {0}
3401fb9e:	f022 e801 	bfcsel	0, 3401fba4 <lite_convert_if32ou8+0xd4>, 4, hi
3401fba2:	fe33 3e07 	cdp2	14, 3, cr3, cr3, cr7, {0}
3401fba6:	eba1 0c02 	sub.w	ip, r1, r2
3401fbaa:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401fbae:	ed8c 3e00 	stc	14, cr3, [ip]
3401fbb2:	3a10      	subs	r2, #16
3401fbb4:	f00f c049 	le	lr, 3401fb28 <lite_convert_if32ou8+0x58>
3401fbb8:	b015      	add	sp, #84	@ 0x54
3401fbba:	ecbd 8b10 	vpop	{d8-d15}
3401fbbe:	f85d fb04 	ldr.w	pc, [sp], #4
3401fbc2:	4770      	bx	lr
3401fbc4:	f3af 8000 	nop.w
	...

3401fbe8 <st_f32_to_int16>:
3401fbe8:	b570      	push	{r4, r5, r6, lr}
3401fbea:	08d5      	lsrs	r5, r2, #3
3401fbec:	ed2d 8b08 	vpush	{d8-d11}
3401fbf0:	d022      	beq.n	3401fc38 <st_f32_to_int16+0x50>
3401fbf2:	460c      	mov	r4, r1
3401fbf4:	ed9f 6b60 	vldr	d6, [pc, #384]	@ 3401fd78 <st_f32_to_int16+0x190>
3401fbf8:	ed9f 7b61 	vldr	d7, [pc, #388]	@ 3401fd80 <st_f32_to_int16+0x198>
3401fbfc:	4684      	mov	ip, r0
3401fbfe:	f045 e001 	dls	lr, r5
3401fc02:	4b61      	ldr	r3, [pc, #388]	@ (3401fd88 <st_f32_to_int16+0x1a0>)
3401fc04:	fc9c 9f00 	ldc2	15, cr9, [ip], {0}
3401fc08:	fcbc 9f20 	ldc2	15, cr9, [ip], #128	@ 0x80
3401fc0c:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
3401fc10:	ee3b 4e63 	cdp	14, 3, cr4, cr11, cr3, {3}
3401fc14:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401fc18:	ffbb 4044 	vcvta.s32.f32	q2, q2
3401fc1c:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
3401fc20:	4626      	mov	r6, r4
3401fc22:	ee37 7e05 	cdp	14, 3, cr7, cr7, cr5, {0}
3401fc26:	3410      	adds	r4, #16
3401fc28:	ed86 7e80 	stc	14, cr7, [r6, #512]	@ 0x200
3401fc2c:	f00f c017 	le	lr, 3401fc04 <st_f32_to_int16+0x1c>
3401fc30:	eb00 1045 	add.w	r0, r0, r5, lsl #5
3401fc34:	eb01 1105 	add.w	r1, r1, r5, lsl #4
3401fc38:	f012 0207 	ands.w	r2, r2, #7
3401fc3c:	f000 8097 	beq.w	3401fd6e <st_f32_to_int16+0x186>
3401fc40:	edd0 5a00 	vldr	s11, [r0]
3401fc44:	ed9f 6a51 	vldr	s12, [pc, #324]	@ 3401fd8c <st_f32_to_int16+0x1a4>
3401fc48:	ee65 5a86 	vmul.f32	s11, s11, s12
3401fc4c:	eef5 5ac0 	vcmpe.f32	s11, #0.0
3401fc50:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
3401fc54:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
3401fc58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fc5c:	fe77 7a26 	vselgt.f32	s15, s14, s13
3401fc60:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fc64:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fc68:	ee17 3a90 	vmov	r3, s15
3401fc6c:	f303 030f 	ssat	r3, #16, r3
3401fc70:	2a01      	cmp	r2, #1
3401fc72:	800b      	strh	r3, [r1, #0]
3401fc74:	d07b      	beq.n	3401fd6e <st_f32_to_int16+0x186>
3401fc76:	edd0 7a01 	vldr	s15, [r0, #4]
3401fc7a:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fc7e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fc82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fc86:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fc8a:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fc8e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fc92:	ee17 3a90 	vmov	r3, s15
3401fc96:	f303 030f 	ssat	r3, #16, r3
3401fc9a:	2a02      	cmp	r2, #2
3401fc9c:	804b      	strh	r3, [r1, #2]
3401fc9e:	d066      	beq.n	3401fd6e <st_f32_to_int16+0x186>
3401fca0:	edd0 7a02 	vldr	s15, [r0, #8]
3401fca4:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fca8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fcac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fcb0:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fcb4:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fcb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fcbc:	ee17 3a90 	vmov	r3, s15
3401fcc0:	f303 030f 	ssat	r3, #16, r3
3401fcc4:	2a03      	cmp	r2, #3
3401fcc6:	808b      	strh	r3, [r1, #4]
3401fcc8:	d051      	beq.n	3401fd6e <st_f32_to_int16+0x186>
3401fcca:	edd0 7a03 	vldr	s15, [r0, #12]
3401fcce:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fcd2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fcd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fcda:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fcde:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fce2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fce6:	ee17 3a90 	vmov	r3, s15
3401fcea:	f303 030f 	ssat	r3, #16, r3
3401fcee:	2a04      	cmp	r2, #4
3401fcf0:	80cb      	strh	r3, [r1, #6]
3401fcf2:	d03c      	beq.n	3401fd6e <st_f32_to_int16+0x186>
3401fcf4:	edd0 7a04 	vldr	s15, [r0, #16]
3401fcf8:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fcfc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fd00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fd04:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fd08:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fd0c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fd10:	ee17 3a90 	vmov	r3, s15
3401fd14:	f303 030f 	ssat	r3, #16, r3
3401fd18:	3a05      	subs	r2, #5
3401fd1a:	810b      	strh	r3, [r1, #8]
3401fd1c:	d027      	beq.n	3401fd6e <st_f32_to_int16+0x186>
3401fd1e:	edd0 7a05 	vldr	s15, [r0, #20]
3401fd22:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fd26:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fd2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fd2e:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fd32:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fd36:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fd3a:	ee17 3a90 	vmov	r3, s15
3401fd3e:	f303 030f 	ssat	r3, #16, r3
3401fd42:	2a01      	cmp	r2, #1
3401fd44:	814b      	strh	r3, [r1, #10]
3401fd46:	d012      	beq.n	3401fd6e <st_f32_to_int16+0x186>
3401fd48:	edd0 7a06 	vldr	s15, [r0, #24]
3401fd4c:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fd50:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fd54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fd58:	fe37 7a26 	vselgt.f32	s14, s14, s13
3401fd5c:	ee37 7a27 	vadd.f32	s14, s14, s15
3401fd60:	eebd 7ac7 	vcvt.s32.f32	s14, s14
3401fd64:	ee17 3a10 	vmov	r3, s14
3401fd68:	f303 030f 	ssat	r3, #16, r3
3401fd6c:	818b      	strh	r3, [r1, #12]
3401fd6e:	ecbd 8b08 	vpop	{d8-d11}
3401fd72:	bd70      	pop	{r4, r5, r6, pc}
3401fd74:	f3af 8000 	nop.w
	...
3401fd88:	46fffe00 	.word	0x46fffe00
3401fd8c:	47000000 	.word	0x47000000

3401fd90 <st_f32_to_int8>:
3401fd90:	b570      	push	{r4, r5, r6, lr}
3401fd92:	0915      	lsrs	r5, r2, #4
3401fd94:	ed2d 8b10 	vpush	{d8-d15}
3401fd98:	f000 81a5 	beq.w	340200e6 <st_f32_to_int8+0x356>
3401fd9c:	ed9f 0bd4 	vldr	d0, [pc, #848]	@ 340200f0 <st_f32_to_int8+0x360>
3401fda0:	ed9f 1bd5 	vldr	d1, [pc, #852]	@ 340200f8 <st_f32_to_int8+0x368>
3401fda4:	ea4f 1e05 	mov.w	lr, r5, lsl #4
3401fda8:	f1ae 0e10 	sub.w	lr, lr, #16
3401fdac:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
3401fdb0:	f10e 0e01 	add.w	lr, lr, #1
3401fdb4:	ed9f 4bd2 	vldr	d4, [pc, #840]	@ 34020100 <st_f32_to_int8+0x370>
3401fdb8:	ed9f 5bd3 	vldr	d5, [pc, #844]	@ 34020108 <st_f32_to_int8+0x378>
3401fdbc:	f04f 4386 	mov.w	r3, #1124073472	@ 0x43000000
3401fdc0:	f04e e001 	dls	lr, lr
3401fdc4:	4684      	mov	ip, r0
3401fdc6:	ef20 6150 	vorr	q3, q0, q0
3401fdca:	eb01 1405 	add.w	r4, r1, r5, lsl #4
3401fdce:	fc9c 9f01 	ldc2	15, cr9, [ip], {1}
3401fdd2:	fc9c 9f21 	ldc2	15, cr9, [ip], {33}	@ 0x21
3401fdd6:	fc9c 9f41 	ldc2	15, cr9, [ip], {65}	@ 0x41
3401fdda:	fcbc 9f61 	ldc2	15, cr9, [ip], #388	@ 0x184
3401fdde:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
3401fde2:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401fde6:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
3401fdea:	ee3b 2e63 	cdp	14, 3, cr2, cr11, cr3, {3}
3401fdee:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401fdf2:	ee37 0e03 	cdp	14, 3, cr0, cr7, cr3, {0}
3401fdf6:	ee3d 2e63 	cdp	14, 3, cr2, cr13, cr3, {3}
3401fdfa:	ee3f 8e63 	cdp	14, 3, cr8, cr15, cr3, {3}
3401fdfe:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401fe02:	ffbb 8048 	vcvta.s32.f32	q4, q4
3401fe06:	ee37 7e03 	cdp	14, 3, cr7, cr7, cr3, {0}
3401fe0a:	ee37 1e09 	cdp	14, 3, cr1, cr7, cr9, {0}
3401fe0e:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
3401fe12:	460e      	mov	r6, r1
3401fe14:	ee33 5e01 	cdp	14, 3, cr5, cr3, cr1, {0}
3401fe18:	3110      	adds	r1, #16
3401fe1a:	ed86 5e00 	stc	14, cr5, [r6]
3401fe1e:	f00f c02b 	le	lr, 3401fdce <st_f32_to_int8+0x3e>
3401fe22:	eb00 1085 	add.w	r0, r0, r5, lsl #6
3401fe26:	f012 030f 	ands.w	r3, r2, #15
3401fe2a:	f000 8159 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401fe2e:	edd0 5a00 	vldr	s11, [r0]
3401fe32:	ed9f 6ab7 	vldr	s12, [pc, #732]	@ 34020110 <st_f32_to_int8+0x380>
3401fe36:	ee65 5a86 	vmul.f32	s11, s11, s12
3401fe3a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
3401fe3e:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
3401fe42:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
3401fe46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fe4a:	fe77 7a26 	vselgt.f32	s15, s14, s13
3401fe4e:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fe52:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fe56:	ee17 2a90 	vmov	r2, s15
3401fe5a:	b212      	sxth	r2, r2
3401fe5c:	f302 0207 	ssat	r2, #8, r2
3401fe60:	2b01      	cmp	r3, #1
3401fe62:	7022      	strb	r2, [r4, #0]
3401fe64:	f000 813c 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401fe68:	edd0 7a01 	vldr	s15, [r0, #4]
3401fe6c:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fe70:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fe74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fe78:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fe7c:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fe80:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fe84:	ee17 2a90 	vmov	r2, s15
3401fe88:	b212      	sxth	r2, r2
3401fe8a:	f302 0207 	ssat	r2, #8, r2
3401fe8e:	2b02      	cmp	r3, #2
3401fe90:	7062      	strb	r2, [r4, #1]
3401fe92:	f000 8125 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401fe96:	edd0 7a02 	vldr	s15, [r0, #8]
3401fe9a:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fe9e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fea2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fea6:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401feaa:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401feae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401feb2:	ee17 2a90 	vmov	r2, s15
3401feb6:	b212      	sxth	r2, r2
3401feb8:	f302 0207 	ssat	r2, #8, r2
3401febc:	2b03      	cmp	r3, #3
3401febe:	70a2      	strb	r2, [r4, #2]
3401fec0:	f000 810e 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401fec4:	edd0 7a03 	vldr	s15, [r0, #12]
3401fec8:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fecc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fed0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401fed4:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fed8:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fedc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fee0:	ee17 2a90 	vmov	r2, s15
3401fee4:	b212      	sxth	r2, r2
3401fee6:	f302 0207 	ssat	r2, #8, r2
3401feea:	2b04      	cmp	r3, #4
3401feec:	70e2      	strb	r2, [r4, #3]
3401feee:	f000 80f7 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401fef2:	edd0 7a04 	vldr	s15, [r0, #16]
3401fef6:	ee67 7a86 	vmul.f32	s15, s15, s12
3401fefa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401fefe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ff02:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401ff06:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401ff0a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401ff0e:	ee17 2a90 	vmov	r2, s15
3401ff12:	b212      	sxth	r2, r2
3401ff14:	f302 0207 	ssat	r2, #8, r2
3401ff18:	2b05      	cmp	r3, #5
3401ff1a:	7122      	strb	r2, [r4, #4]
3401ff1c:	f000 80e0 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401ff20:	edd0 7a05 	vldr	s15, [r0, #20]
3401ff24:	ee67 7a86 	vmul.f32	s15, s15, s12
3401ff28:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401ff2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ff30:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401ff34:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401ff38:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401ff3c:	ee17 2a90 	vmov	r2, s15
3401ff40:	b212      	sxth	r2, r2
3401ff42:	f302 0207 	ssat	r2, #8, r2
3401ff46:	2b06      	cmp	r3, #6
3401ff48:	7162      	strb	r2, [r4, #5]
3401ff4a:	f000 80c9 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401ff4e:	edd0 7a06 	vldr	s15, [r0, #24]
3401ff52:	ee67 7a86 	vmul.f32	s15, s15, s12
3401ff56:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401ff5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ff5e:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401ff62:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401ff66:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401ff6a:	ee17 2a90 	vmov	r2, s15
3401ff6e:	b212      	sxth	r2, r2
3401ff70:	f302 0207 	ssat	r2, #8, r2
3401ff74:	2b07      	cmp	r3, #7
3401ff76:	71a2      	strb	r2, [r4, #6]
3401ff78:	f000 80b2 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401ff7c:	edd0 7a07 	vldr	s15, [r0, #28]
3401ff80:	ee67 7a86 	vmul.f32	s15, s15, s12
3401ff84:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401ff88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ff8c:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401ff90:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401ff94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401ff98:	ee17 2a90 	vmov	r2, s15
3401ff9c:	b212      	sxth	r2, r2
3401ff9e:	f302 0207 	ssat	r2, #8, r2
3401ffa2:	2b08      	cmp	r3, #8
3401ffa4:	71e2      	strb	r2, [r4, #7]
3401ffa6:	f000 809b 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401ffaa:	edd0 7a08 	vldr	s15, [r0, #32]
3401ffae:	ee67 7a86 	vmul.f32	s15, s15, s12
3401ffb2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401ffb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ffba:	fe37 7a26 	vselgt.f32	s14, s14, s13
3401ffbe:	ee77 7a87 	vadd.f32	s15, s15, s14
3401ffc2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401ffc6:	ee17 2a90 	vmov	r2, s15
3401ffca:	b212      	sxth	r2, r2
3401ffcc:	f302 0207 	ssat	r2, #8, r2
3401ffd0:	2b09      	cmp	r3, #9
3401ffd2:	7222      	strb	r2, [r4, #8]
3401ffd4:	f000 8084 	beq.w	340200e0 <st_f32_to_int8+0x350>
3401ffd8:	edd0 7a09 	vldr	s15, [r0, #36]	@ 0x24
3401ffdc:	ee67 7a86 	vmul.f32	s15, s15, s12
3401ffe0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401ffe4:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
3401ffe8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ffec:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401fff0:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401fff4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401fff8:	ee17 2a90 	vmov	r2, s15
3401fffc:	b212      	sxth	r2, r2
3401fffe:	f302 0207 	ssat	r2, #8, r2
34020002:	2b0a      	cmp	r3, #10
34020004:	7262      	strb	r2, [r4, #9]
34020006:	d06b      	beq.n	340200e0 <st_f32_to_int8+0x350>
34020008:	edd0 7a0a 	vldr	s15, [r0, #40]	@ 0x28
3402000c:	ee67 7a86 	vmul.f32	s15, s15, s12
34020010:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34020014:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020018:	fe77 5a26 	vselgt.f32	s11, s14, s13
3402001c:	ee77 7aa5 	vadd.f32	s15, s15, s11
34020020:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34020024:	ee17 2a90 	vmov	r2, s15
34020028:	b212      	sxth	r2, r2
3402002a:	f302 0207 	ssat	r2, #8, r2
3402002e:	2b0b      	cmp	r3, #11
34020030:	72a2      	strb	r2, [r4, #10]
34020032:	d055      	beq.n	340200e0 <st_f32_to_int8+0x350>
34020034:	edd0 7a0b 	vldr	s15, [r0, #44]	@ 0x2c
34020038:	ee67 7a86 	vmul.f32	s15, s15, s12
3402003c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34020040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020044:	fe77 5a26 	vselgt.f32	s11, s14, s13
34020048:	ee77 7aa5 	vadd.f32	s15, s15, s11
3402004c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34020050:	ee17 2a90 	vmov	r2, s15
34020054:	b212      	sxth	r2, r2
34020056:	f302 0207 	ssat	r2, #8, r2
3402005a:	2b0c      	cmp	r3, #12
3402005c:	72e2      	strb	r2, [r4, #11]
3402005e:	d03f      	beq.n	340200e0 <st_f32_to_int8+0x350>
34020060:	edd0 7a0c 	vldr	s15, [r0, #48]	@ 0x30
34020064:	ee67 7a86 	vmul.f32	s15, s15, s12
34020068:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3402006c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020070:	fe77 5a26 	vselgt.f32	s11, s14, s13
34020074:	ee77 7aa5 	vadd.f32	s15, s15, s11
34020078:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3402007c:	ee17 2a90 	vmov	r2, s15
34020080:	b212      	sxth	r2, r2
34020082:	f302 0207 	ssat	r2, #8, r2
34020086:	3b0d      	subs	r3, #13
34020088:	7322      	strb	r2, [r4, #12]
3402008a:	d029      	beq.n	340200e0 <st_f32_to_int8+0x350>
3402008c:	edd0 7a0d 	vldr	s15, [r0, #52]	@ 0x34
34020090:	ee67 7a86 	vmul.f32	s15, s15, s12
34020094:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34020098:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402009c:	fe77 5a26 	vselgt.f32	s11, s14, s13
340200a0:	ee77 7aa5 	vadd.f32	s15, s15, s11
340200a4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340200a8:	ee17 2a90 	vmov	r2, s15
340200ac:	b212      	sxth	r2, r2
340200ae:	f302 0207 	ssat	r2, #8, r2
340200b2:	2b01      	cmp	r3, #1
340200b4:	7362      	strb	r2, [r4, #13]
340200b6:	d013      	beq.n	340200e0 <st_f32_to_int8+0x350>
340200b8:	edd0 7a0e 	vldr	s15, [r0, #56]	@ 0x38
340200bc:	ee27 6a86 	vmul.f32	s12, s15, s12
340200c0:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
340200c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340200c8:	fe77 7a26 	vselgt.f32	s15, s14, s13
340200cc:	ee77 7a86 	vadd.f32	s15, s15, s12
340200d0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340200d4:	ee17 3a90 	vmov	r3, s15
340200d8:	b21b      	sxth	r3, r3
340200da:	f303 0307 	ssat	r3, #8, r3
340200de:	73a3      	strb	r3, [r4, #14]
340200e0:	ecbd 8b10 	vpop	{d8-d15}
340200e4:	bd70      	pop	{r4, r5, r6, pc}
340200e6:	460c      	mov	r4, r1
340200e8:	e69d      	b.n	3401fe26 <st_f32_to_int8+0x96>
340200ea:	bf00      	nop
340200ec:	f3af 8000 	nop.w
	...
34020110:	43000000 	.word	0x43000000

34020114 <st_int16_to_f32>:
34020114:	ea5f 0c92 	movs.w	ip, r2, lsr #2
34020118:	b530      	push	{r4, r5, lr}
3402011a:	d013      	beq.n	34020144 <st_int16_to_f32+0x30>
3402011c:	4604      	mov	r4, r0
3402011e:	460b      	mov	r3, r1
34020120:	f04c e001 	dls	lr, ip
34020124:	4625      	mov	r5, r4
34020126:	ed9d 6f00 	ldc	15, cr6, [sp]
3402012a:	461d      	mov	r5, r3
3402012c:	efb1 6e56 	vcvt.f32.s32	q3, q3, #15
34020130:	3408      	adds	r4, #8
34020132:	ed85 7f00 	stc	15, cr7, [r5]
34020136:	3310      	adds	r3, #16
34020138:	f00f c00d 	le	lr, 34020124 <st_int16_to_f32+0x10>
3402013c:	eb01 110c 	add.w	r1, r1, ip, lsl #4
34020140:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
34020144:	f012 0203 	ands.w	r2, r2, #3
34020148:	d023      	beq.n	34020192 <st_int16_to_f32+0x7e>
3402014a:	f9b0 3000 	ldrsh.w	r3, [r0]
3402014e:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 34020194 <st_int16_to_f32+0x80>
34020152:	ee07 3a90 	vmov	s15, r3
34020156:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3402015a:	ee67 7a87 	vmul.f32	s15, s15, s14
3402015e:	3a01      	subs	r2, #1
34020160:	edc1 7a00 	vstr	s15, [r1]
34020164:	d015      	beq.n	34020192 <st_int16_to_f32+0x7e>
34020166:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
3402016a:	2a01      	cmp	r2, #1
3402016c:	ee07 3a90 	vmov	s15, r3
34020170:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34020174:	ee67 7a87 	vmul.f32	s15, s15, s14
34020178:	edc1 7a01 	vstr	s15, [r1, #4]
3402017c:	d009      	beq.n	34020192 <st_int16_to_f32+0x7e>
3402017e:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
34020182:	ee07 3a90 	vmov	s15, r3
34020186:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3402018a:	ee67 7a87 	vmul.f32	s15, s15, s14
3402018e:	edc1 7a02 	vstr	s15, [r1, #8]
34020192:	bd30      	pop	{r4, r5, pc}
34020194:	38000000 	.word	0x38000000

34020198 <st_int8_to_f32>:
34020198:	ea5f 0c92 	movs.w	ip, r2, lsr #2
3402019c:	b530      	push	{r4, r5, lr}
3402019e:	d042      	beq.n	34020226 <st_int8_to_f32+0x8e>
340201a0:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
340201a4:	f1ae 0e04 	sub.w	lr, lr, #4
340201a8:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
340201ac:	f10e 0e01 	add.w	lr, lr, #1
340201b0:	f04e e001 	dls	lr, lr
340201b4:	460b      	mov	r3, r1
340201b6:	eb00 048c 	add.w	r4, r0, ip, lsl #2
340201ba:	4605      	mov	r5, r0
340201bc:	ed95 6f00 	ldc	15, cr6, [r5]
340201c0:	461d      	mov	r5, r3
340201c2:	efb9 6e56 	vcvt.f32.s32	q3, q3, #7
340201c6:	3004      	adds	r0, #4
340201c8:	ed85 7f00 	stc	15, cr7, [r5]
340201cc:	3310      	adds	r3, #16
340201ce:	f00f c00d 	le	lr, 340201ba <st_int8_to_f32+0x22>
340201d2:	eb01 110c 	add.w	r1, r1, ip, lsl #4
340201d6:	f012 0203 	ands.w	r2, r2, #3
340201da:	d023      	beq.n	34020224 <st_int8_to_f32+0x8c>
340201dc:	f994 3000 	ldrsb.w	r3, [r4]
340201e0:	ed9f 7a12 	vldr	s14, [pc, #72]	@ 3402022c <st_int8_to_f32+0x94>
340201e4:	ee07 3a90 	vmov	s15, r3
340201e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340201ec:	ee67 7a87 	vmul.f32	s15, s15, s14
340201f0:	3a01      	subs	r2, #1
340201f2:	edc1 7a00 	vstr	s15, [r1]
340201f6:	d015      	beq.n	34020224 <st_int8_to_f32+0x8c>
340201f8:	f994 3001 	ldrsb.w	r3, [r4, #1]
340201fc:	2a01      	cmp	r2, #1
340201fe:	ee07 3a90 	vmov	s15, r3
34020202:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34020206:	ee67 7a87 	vmul.f32	s15, s15, s14
3402020a:	edc1 7a01 	vstr	s15, [r1, #4]
3402020e:	d009      	beq.n	34020224 <st_int8_to_f32+0x8c>
34020210:	f994 3002 	ldrsb.w	r3, [r4, #2]
34020214:	ee07 3a90 	vmov	s15, r3
34020218:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3402021c:	ee67 7a87 	vmul.f32	s15, s15, s14
34020220:	edc1 7a02 	vstr	s15, [r1, #8]
34020224:	bd30      	pop	{r4, r5, pc}
34020226:	4604      	mov	r4, r0
34020228:	e7d5      	b.n	340201d6 <st_int8_to_f32+0x3e>
3402022a:	bf00      	nop
3402022c:	3c000000 	.word	0x3c000000

34020230 <__assert_func>:
34020230:	b51f      	push	{r0, r1, r2, r3, r4, lr}
34020232:	4614      	mov	r4, r2
34020234:	461a      	mov	r2, r3
34020236:	4b09      	ldr	r3, [pc, #36]	@ (3402025c <__assert_func+0x2c>)
34020238:	4605      	mov	r5, r0
3402023a:	681b      	ldr	r3, [r3, #0]
3402023c:	68d8      	ldr	r0, [r3, #12]
3402023e:	b14c      	cbz	r4, 34020254 <__assert_func+0x24>
34020240:	4b07      	ldr	r3, [pc, #28]	@ (34020260 <__assert_func+0x30>)
34020242:	9100      	str	r1, [sp, #0]
34020244:	4907      	ldr	r1, [pc, #28]	@ (34020264 <__assert_func+0x34>)
34020246:	e9cd 3401 	strd	r3, r4, [sp, #4]
3402024a:	462b      	mov	r3, r5
3402024c:	f000 fffa 	bl	34021244 <fiprintf>
34020250:	f001 fc5c 	bl	34021b0c <abort>
34020254:	4b04      	ldr	r3, [pc, #16]	@ (34020268 <__assert_func+0x38>)
34020256:	461c      	mov	r4, r3
34020258:	e7f3      	b.n	34020242 <__assert_func+0x12>
3402025a:	bf00      	nop
3402025c:	34033f68 	.word	0x34033f68
34020260:	3403324e 	.word	0x3403324e
34020264:	3403325b 	.word	0x3403325b
34020268:	34033289 	.word	0x34033289

3402026c <malloc>:
3402026c:	4b02      	ldr	r3, [pc, #8]	@ (34020278 <malloc+0xc>)
3402026e:	4601      	mov	r1, r0
34020270:	6818      	ldr	r0, [r3, #0]
34020272:	f000 b825 	b.w	340202c0 <_malloc_r>
34020276:	bf00      	nop
34020278:	34033f68 	.word	0x34033f68

3402027c <sbrk_aligned>:
3402027c:	b570      	push	{r4, r5, r6, lr}
3402027e:	4e0f      	ldr	r6, [pc, #60]	@ (340202bc <sbrk_aligned+0x40>)
34020280:	460c      	mov	r4, r1
34020282:	4605      	mov	r5, r0
34020284:	6831      	ldr	r1, [r6, #0]
34020286:	b911      	cbnz	r1, 3402028e <sbrk_aligned+0x12>
34020288:	f001 fbd6 	bl	34021a38 <_sbrk_r>
3402028c:	6030      	str	r0, [r6, #0]
3402028e:	4621      	mov	r1, r4
34020290:	4628      	mov	r0, r5
34020292:	f001 fbd1 	bl	34021a38 <_sbrk_r>
34020296:	1c43      	adds	r3, r0, #1
34020298:	d103      	bne.n	340202a2 <sbrk_aligned+0x26>
3402029a:	f04f 34ff 	mov.w	r4, #4294967295
3402029e:	4620      	mov	r0, r4
340202a0:	bd70      	pop	{r4, r5, r6, pc}
340202a2:	1cc4      	adds	r4, r0, #3
340202a4:	f024 0403 	bic.w	r4, r4, #3
340202a8:	42a0      	cmp	r0, r4
340202aa:	d0f8      	beq.n	3402029e <sbrk_aligned+0x22>
340202ac:	1a21      	subs	r1, r4, r0
340202ae:	4628      	mov	r0, r5
340202b0:	f001 fbc2 	bl	34021a38 <_sbrk_r>
340202b4:	3001      	adds	r0, #1
340202b6:	d1f2      	bne.n	3402029e <sbrk_aligned+0x22>
340202b8:	e7ef      	b.n	3402029a <sbrk_aligned+0x1e>
340202ba:	bf00      	nop
340202bc:	34053dbc 	.word	0x34053dbc

340202c0 <_malloc_r>:
340202c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
340202c4:	1ccd      	adds	r5, r1, #3
340202c6:	4606      	mov	r6, r0
340202c8:	f025 0503 	bic.w	r5, r5, #3
340202cc:	3508      	adds	r5, #8
340202ce:	2d0c      	cmp	r5, #12
340202d0:	bf38      	it	cc
340202d2:	250c      	movcc	r5, #12
340202d4:	2d00      	cmp	r5, #0
340202d6:	db01      	blt.n	340202dc <_malloc_r+0x1c>
340202d8:	42a9      	cmp	r1, r5
340202da:	d904      	bls.n	340202e6 <_malloc_r+0x26>
340202dc:	230c      	movs	r3, #12
340202de:	6033      	str	r3, [r6, #0]
340202e0:	2000      	movs	r0, #0
340202e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
340202e6:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 340203bc <_malloc_r+0xfc>
340202ea:	f000 f869 	bl	340203c0 <__malloc_lock>
340202ee:	f8d8 3000 	ldr.w	r3, [r8]
340202f2:	461c      	mov	r4, r3
340202f4:	bb44      	cbnz	r4, 34020348 <_malloc_r+0x88>
340202f6:	4629      	mov	r1, r5
340202f8:	4630      	mov	r0, r6
340202fa:	f7ff ffbf 	bl	3402027c <sbrk_aligned>
340202fe:	1c43      	adds	r3, r0, #1
34020300:	4604      	mov	r4, r0
34020302:	d158      	bne.n	340203b6 <_malloc_r+0xf6>
34020304:	f8d8 4000 	ldr.w	r4, [r8]
34020308:	4627      	mov	r7, r4
3402030a:	2f00      	cmp	r7, #0
3402030c:	d143      	bne.n	34020396 <_malloc_r+0xd6>
3402030e:	2c00      	cmp	r4, #0
34020310:	d04b      	beq.n	340203aa <_malloc_r+0xea>
34020312:	6823      	ldr	r3, [r4, #0]
34020314:	4639      	mov	r1, r7
34020316:	4630      	mov	r0, r6
34020318:	eb04 0903 	add.w	r9, r4, r3
3402031c:	f001 fb8c 	bl	34021a38 <_sbrk_r>
34020320:	4581      	cmp	r9, r0
34020322:	d142      	bne.n	340203aa <_malloc_r+0xea>
34020324:	6821      	ldr	r1, [r4, #0]
34020326:	4630      	mov	r0, r6
34020328:	1a6d      	subs	r5, r5, r1
3402032a:	4629      	mov	r1, r5
3402032c:	f7ff ffa6 	bl	3402027c <sbrk_aligned>
34020330:	3001      	adds	r0, #1
34020332:	d03a      	beq.n	340203aa <_malloc_r+0xea>
34020334:	6823      	ldr	r3, [r4, #0]
34020336:	442b      	add	r3, r5
34020338:	6023      	str	r3, [r4, #0]
3402033a:	f8d8 3000 	ldr.w	r3, [r8]
3402033e:	685a      	ldr	r2, [r3, #4]
34020340:	bb62      	cbnz	r2, 3402039c <_malloc_r+0xdc>
34020342:	f8c8 7000 	str.w	r7, [r8]
34020346:	e00f      	b.n	34020368 <_malloc_r+0xa8>
34020348:	6822      	ldr	r2, [r4, #0]
3402034a:	1b52      	subs	r2, r2, r5
3402034c:	d420      	bmi.n	34020390 <_malloc_r+0xd0>
3402034e:	2a0b      	cmp	r2, #11
34020350:	d917      	bls.n	34020382 <_malloc_r+0xc2>
34020352:	1961      	adds	r1, r4, r5
34020354:	42a3      	cmp	r3, r4
34020356:	6025      	str	r5, [r4, #0]
34020358:	bf18      	it	ne
3402035a:	6059      	strne	r1, [r3, #4]
3402035c:	6863      	ldr	r3, [r4, #4]
3402035e:	bf08      	it	eq
34020360:	f8c8 1000 	streq.w	r1, [r8]
34020364:	5162      	str	r2, [r4, r5]
34020366:	604b      	str	r3, [r1, #4]
34020368:	4630      	mov	r0, r6
3402036a:	f000 f82f 	bl	340203cc <__malloc_unlock>
3402036e:	f104 000b 	add.w	r0, r4, #11
34020372:	1d23      	adds	r3, r4, #4
34020374:	f020 0007 	bic.w	r0, r0, #7
34020378:	1ac2      	subs	r2, r0, r3
3402037a:	bf1c      	itt	ne
3402037c:	1a1b      	subne	r3, r3, r0
3402037e:	50a3      	strne	r3, [r4, r2]
34020380:	e7af      	b.n	340202e2 <_malloc_r+0x22>
34020382:	6862      	ldr	r2, [r4, #4]
34020384:	42a3      	cmp	r3, r4
34020386:	bf0c      	ite	eq
34020388:	f8c8 2000 	streq.w	r2, [r8]
3402038c:	605a      	strne	r2, [r3, #4]
3402038e:	e7eb      	b.n	34020368 <_malloc_r+0xa8>
34020390:	4623      	mov	r3, r4
34020392:	6864      	ldr	r4, [r4, #4]
34020394:	e7ae      	b.n	340202f4 <_malloc_r+0x34>
34020396:	463c      	mov	r4, r7
34020398:	687f      	ldr	r7, [r7, #4]
3402039a:	e7b6      	b.n	3402030a <_malloc_r+0x4a>
3402039c:	461a      	mov	r2, r3
3402039e:	685b      	ldr	r3, [r3, #4]
340203a0:	42a3      	cmp	r3, r4
340203a2:	d1fb      	bne.n	3402039c <_malloc_r+0xdc>
340203a4:	2300      	movs	r3, #0
340203a6:	6053      	str	r3, [r2, #4]
340203a8:	e7de      	b.n	34020368 <_malloc_r+0xa8>
340203aa:	230c      	movs	r3, #12
340203ac:	4630      	mov	r0, r6
340203ae:	6033      	str	r3, [r6, #0]
340203b0:	f000 f80c 	bl	340203cc <__malloc_unlock>
340203b4:	e794      	b.n	340202e0 <_malloc_r+0x20>
340203b6:	6005      	str	r5, [r0, #0]
340203b8:	e7d6      	b.n	34020368 <_malloc_r+0xa8>
340203ba:	bf00      	nop
340203bc:	34053dc0 	.word	0x34053dc0

340203c0 <__malloc_lock>:
340203c0:	4801      	ldr	r0, [pc, #4]	@ (340203c8 <__malloc_lock+0x8>)
340203c2:	f001 bb86 	b.w	34021ad2 <__retarget_lock_acquire_recursive>
340203c6:	bf00      	nop
340203c8:	34053f04 	.word	0x34053f04

340203cc <__malloc_unlock>:
340203cc:	4801      	ldr	r0, [pc, #4]	@ (340203d4 <__malloc_unlock+0x8>)
340203ce:	f001 bb81 	b.w	34021ad4 <__retarget_lock_release_recursive>
340203d2:	bf00      	nop
340203d4:	34053f04 	.word	0x34053f04

340203d8 <_realloc_r>:
340203d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
340203dc:	4607      	mov	r7, r0
340203de:	4614      	mov	r4, r2
340203e0:	460d      	mov	r5, r1
340203e2:	b921      	cbnz	r1, 340203ee <_realloc_r+0x16>
340203e4:	4611      	mov	r1, r2
340203e6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
340203ea:	f7ff bf69 	b.w	340202c0 <_malloc_r>
340203ee:	b92a      	cbnz	r2, 340203fc <_realloc_r+0x24>
340203f0:	4625      	mov	r5, r4
340203f2:	f002 f97f 	bl	340226f4 <_free_r>
340203f6:	4628      	mov	r0, r5
340203f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
340203fc:	f002 fd46 	bl	34022e8c <_malloc_usable_size_r>
34020400:	4284      	cmp	r4, r0
34020402:	4606      	mov	r6, r0
34020404:	d802      	bhi.n	3402040c <_realloc_r+0x34>
34020406:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
3402040a:	d8f4      	bhi.n	340203f6 <_realloc_r+0x1e>
3402040c:	4621      	mov	r1, r4
3402040e:	4638      	mov	r0, r7
34020410:	f7ff ff56 	bl	340202c0 <_malloc_r>
34020414:	4680      	mov	r8, r0
34020416:	b908      	cbnz	r0, 3402041c <_realloc_r+0x44>
34020418:	4645      	mov	r5, r8
3402041a:	e7ec      	b.n	340203f6 <_realloc_r+0x1e>
3402041c:	42b4      	cmp	r4, r6
3402041e:	4622      	mov	r2, r4
34020420:	4629      	mov	r1, r5
34020422:	bf28      	it	cs
34020424:	4632      	movcs	r2, r6
34020426:	f001 fb64 	bl	34021af2 <memcpy>
3402042a:	4629      	mov	r1, r5
3402042c:	4638      	mov	r0, r7
3402042e:	f002 f961 	bl	340226f4 <_free_r>
34020432:	e7f1      	b.n	34020418 <_realloc_r+0x40>

34020434 <swapfunc>:
34020434:	2b02      	cmp	r3, #2
34020436:	b510      	push	{r4, lr}
34020438:	d00a      	beq.n	34020450 <swapfunc+0x1c>
3402043a:	0892      	lsrs	r2, r2, #2
3402043c:	3a01      	subs	r2, #1
3402043e:	6803      	ldr	r3, [r0, #0]
34020440:	680c      	ldr	r4, [r1, #0]
34020442:	2a00      	cmp	r2, #0
34020444:	f840 4b04 	str.w	r4, [r0], #4
34020448:	f841 3b04 	str.w	r3, [r1], #4
3402044c:	dcf6      	bgt.n	3402043c <swapfunc+0x8>
3402044e:	bd10      	pop	{r4, pc}
34020450:	4402      	add	r2, r0
34020452:	7803      	ldrb	r3, [r0, #0]
34020454:	780c      	ldrb	r4, [r1, #0]
34020456:	f800 4b01 	strb.w	r4, [r0], #1
3402045a:	f801 3b01 	strb.w	r3, [r1], #1
3402045e:	1a13      	subs	r3, r2, r0
34020460:	2b00      	cmp	r3, #0
34020462:	dcf6      	bgt.n	34020452 <swapfunc+0x1e>
34020464:	e7f3      	b.n	3402044e <swapfunc+0x1a>

34020466 <med3.constprop.0>:
34020466:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34020468:	460f      	mov	r7, r1
3402046a:	4616      	mov	r6, r2
3402046c:	4604      	mov	r4, r0
3402046e:	461d      	mov	r5, r3
34020470:	4798      	blx	r3
34020472:	2800      	cmp	r0, #0
34020474:	4631      	mov	r1, r6
34020476:	4638      	mov	r0, r7
34020478:	da0c      	bge.n	34020494 <med3.constprop.0+0x2e>
3402047a:	47a8      	blx	r5
3402047c:	2800      	cmp	r0, #0
3402047e:	da02      	bge.n	34020486 <med3.constprop.0+0x20>
34020480:	463c      	mov	r4, r7
34020482:	4620      	mov	r0, r4
34020484:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34020486:	4631      	mov	r1, r6
34020488:	4620      	mov	r0, r4
3402048a:	47a8      	blx	r5
3402048c:	2800      	cmp	r0, #0
3402048e:	daf8      	bge.n	34020482 <med3.constprop.0+0x1c>
34020490:	4634      	mov	r4, r6
34020492:	e7f6      	b.n	34020482 <med3.constprop.0+0x1c>
34020494:	47a8      	blx	r5
34020496:	2800      	cmp	r0, #0
34020498:	dcf2      	bgt.n	34020480 <med3.constprop.0+0x1a>
3402049a:	4631      	mov	r1, r6
3402049c:	4620      	mov	r0, r4
3402049e:	47a8      	blx	r5
340204a0:	2800      	cmp	r0, #0
340204a2:	daf5      	bge.n	34020490 <med3.constprop.0+0x2a>
340204a4:	e7ed      	b.n	34020482 <med3.constprop.0+0x1c>

340204a6 <qsort>:
340204a6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340204aa:	b095      	sub	sp, #84	@ 0x54
340204ac:	4607      	mov	r7, r0
340204ae:	4615      	mov	r5, r2
340204b0:	9300      	str	r3, [sp, #0]
340204b2:	ea40 0302 	orr.w	r3, r0, r2
340204b6:	079b      	lsls	r3, r3, #30
340204b8:	d119      	bne.n	340204ee <qsort+0x48>
340204ba:	f1b2 0804 	subs.w	r8, r2, #4
340204be:	bf18      	it	ne
340204c0:	f04f 0801 	movne.w	r8, #1
340204c4:	2300      	movs	r3, #0
340204c6:	9301      	str	r3, [sp, #4]
340204c8:	fb05 f401 	mul.w	r4, r5, r1
340204cc:	2906      	cmp	r1, #6
340204ce:	eb07 0b05 	add.w	fp, r7, r5
340204d2:	eb07 0304 	add.w	r3, r7, r4
340204d6:	9302      	str	r3, [sp, #8]
340204d8:	d828      	bhi.n	3402052c <qsort+0x86>
340204da:	9b02      	ldr	r3, [sp, #8]
340204dc:	459b      	cmp	fp, r3
340204de:	d310      	bcc.n	34020502 <qsort+0x5c>
340204e0:	9b01      	ldr	r3, [sp, #4]
340204e2:	2b00      	cmp	r3, #0
340204e4:	f040 8117 	bne.w	34020716 <qsort+0x270>
340204e8:	b015      	add	sp, #84	@ 0x54
340204ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340204ee:	f04f 0802 	mov.w	r8, #2
340204f2:	e7e7      	b.n	340204c4 <qsort+0x1e>
340204f4:	4643      	mov	r3, r8
340204f6:	462a      	mov	r2, r5
340204f8:	4631      	mov	r1, r6
340204fa:	4620      	mov	r0, r4
340204fc:	f7ff ff9a 	bl	34020434 <swapfunc>
34020500:	e00f      	b.n	34020522 <qsort+0x7c>
34020502:	465c      	mov	r4, fp
34020504:	e00e      	b.n	34020524 <qsort+0x7e>
34020506:	1b66      	subs	r6, r4, r5
34020508:	4621      	mov	r1, r4
3402050a:	9b00      	ldr	r3, [sp, #0]
3402050c:	4630      	mov	r0, r6
3402050e:	4798      	blx	r3
34020510:	2800      	cmp	r0, #0
34020512:	dd09      	ble.n	34020528 <qsort+0x82>
34020514:	f1b8 0f00 	cmp.w	r8, #0
34020518:	d1ec      	bne.n	340204f4 <qsort+0x4e>
3402051a:	6823      	ldr	r3, [r4, #0]
3402051c:	6832      	ldr	r2, [r6, #0]
3402051e:	6022      	str	r2, [r4, #0]
34020520:	6033      	str	r3, [r6, #0]
34020522:	4634      	mov	r4, r6
34020524:	42a7      	cmp	r7, r4
34020526:	d3ee      	bcc.n	34020506 <qsort+0x60>
34020528:	44ab      	add	fp, r5
3402052a:	e7d6      	b.n	340204da <qsort+0x34>
3402052c:	ea4f 0951 	mov.w	r9, r1, lsr #1
34020530:	1b64      	subs	r4, r4, r5
34020532:	2907      	cmp	r1, #7
34020534:	fb05 7909 	mla	r9, r5, r9, r7
34020538:	443c      	add	r4, r7
3402053a:	d021      	beq.n	34020580 <qsort+0xda>
3402053c:	2928      	cmp	r1, #40	@ 0x28
3402053e:	d944      	bls.n	340205ca <qsort+0x124>
34020540:	08ce      	lsrs	r6, r1, #3
34020542:	9b00      	ldr	r3, [sp, #0]
34020544:	4638      	mov	r0, r7
34020546:	436e      	muls	r6, r5
34020548:	eb07 0246 	add.w	r2, r7, r6, lsl #1
3402054c:	19b9      	adds	r1, r7, r6
3402054e:	f7ff ff8a 	bl	34020466 <med3.constprop.0>
34020552:	4649      	mov	r1, r9
34020554:	eb09 0206 	add.w	r2, r9, r6
34020558:	9b00      	ldr	r3, [sp, #0]
3402055a:	4682      	mov	sl, r0
3402055c:	1b88      	subs	r0, r1, r6
3402055e:	f7ff ff82 	bl	34020466 <med3.constprop.0>
34020562:	4622      	mov	r2, r4
34020564:	4681      	mov	r9, r0
34020566:	9b00      	ldr	r3, [sp, #0]
34020568:	1ba1      	subs	r1, r4, r6
3402056a:	eba4 0046 	sub.w	r0, r4, r6, lsl #1
3402056e:	f7ff ff7a 	bl	34020466 <med3.constprop.0>
34020572:	4602      	mov	r2, r0
34020574:	4649      	mov	r1, r9
34020576:	9b00      	ldr	r3, [sp, #0]
34020578:	4650      	mov	r0, sl
3402057a:	f7ff ff74 	bl	34020466 <med3.constprop.0>
3402057e:	4681      	mov	r9, r0
34020580:	f1b8 0f00 	cmp.w	r8, #0
34020584:	d124      	bne.n	340205d0 <qsort+0x12a>
34020586:	683b      	ldr	r3, [r7, #0]
34020588:	f8d9 2000 	ldr.w	r2, [r9]
3402058c:	603a      	str	r2, [r7, #0]
3402058e:	f8c9 3000 	str.w	r3, [r9]
34020592:	46d9      	mov	r9, fp
34020594:	46a2      	mov	sl, r4
34020596:	465e      	mov	r6, fp
34020598:	2300      	movs	r3, #0
3402059a:	45a1      	cmp	r9, r4
3402059c:	d836      	bhi.n	3402060c <qsort+0x166>
3402059e:	9303      	str	r3, [sp, #12]
340205a0:	4639      	mov	r1, r7
340205a2:	9b00      	ldr	r3, [sp, #0]
340205a4:	4648      	mov	r0, r9
340205a6:	4798      	blx	r3
340205a8:	2800      	cmp	r0, #0
340205aa:	9b03      	ldr	r3, [sp, #12]
340205ac:	dc2c      	bgt.n	34020608 <qsort+0x162>
340205ae:	d10a      	bne.n	340205c6 <qsort+0x120>
340205b0:	f1b8 0f00 	cmp.w	r8, #0
340205b4:	d113      	bne.n	340205de <qsort+0x138>
340205b6:	6833      	ldr	r3, [r6, #0]
340205b8:	f8d9 2000 	ldr.w	r2, [r9]
340205bc:	6032      	str	r2, [r6, #0]
340205be:	f8c9 3000 	str.w	r3, [r9]
340205c2:	442e      	add	r6, r5
340205c4:	2301      	movs	r3, #1
340205c6:	44a9      	add	r9, r5
340205c8:	e7e7      	b.n	3402059a <qsort+0xf4>
340205ca:	4622      	mov	r2, r4
340205cc:	46ba      	mov	sl, r7
340205ce:	e7d1      	b.n	34020574 <qsort+0xce>
340205d0:	4643      	mov	r3, r8
340205d2:	462a      	mov	r2, r5
340205d4:	4649      	mov	r1, r9
340205d6:	4638      	mov	r0, r7
340205d8:	f7ff ff2c 	bl	34020434 <swapfunc>
340205dc:	e7d9      	b.n	34020592 <qsort+0xec>
340205de:	4643      	mov	r3, r8
340205e0:	462a      	mov	r2, r5
340205e2:	4649      	mov	r1, r9
340205e4:	4630      	mov	r0, r6
340205e6:	f7ff ff25 	bl	34020434 <swapfunc>
340205ea:	e7ea      	b.n	340205c2 <qsort+0x11c>
340205ec:	d10b      	bne.n	34020606 <qsort+0x160>
340205ee:	f1b8 0f00 	cmp.w	r8, #0
340205f2:	d113      	bne.n	3402061c <qsort+0x176>
340205f4:	6823      	ldr	r3, [r4, #0]
340205f6:	f8da 2000 	ldr.w	r2, [sl]
340205fa:	6022      	str	r2, [r4, #0]
340205fc:	f8ca 3000 	str.w	r3, [sl]
34020600:	ebaa 0a05 	sub.w	sl, sl, r5
34020604:	2301      	movs	r3, #1
34020606:	1b64      	subs	r4, r4, r5
34020608:	45a1      	cmp	r9, r4
3402060a:	d90e      	bls.n	3402062a <qsort+0x184>
3402060c:	2b00      	cmp	r3, #0
3402060e:	d140      	bne.n	34020692 <qsort+0x1ec>
34020610:	9b02      	ldr	r3, [sp, #8]
34020612:	459b      	cmp	fp, r3
34020614:	f4bf af64 	bcs.w	340204e0 <qsort+0x3a>
34020618:	465c      	mov	r4, fp
3402061a:	e036      	b.n	3402068a <qsort+0x1e4>
3402061c:	4643      	mov	r3, r8
3402061e:	462a      	mov	r2, r5
34020620:	4651      	mov	r1, sl
34020622:	4620      	mov	r0, r4
34020624:	f7ff ff06 	bl	34020434 <swapfunc>
34020628:	e7ea      	b.n	34020600 <qsort+0x15a>
3402062a:	9303      	str	r3, [sp, #12]
3402062c:	4639      	mov	r1, r7
3402062e:	9b00      	ldr	r3, [sp, #0]
34020630:	4620      	mov	r0, r4
34020632:	4798      	blx	r3
34020634:	2800      	cmp	r0, #0
34020636:	9b03      	ldr	r3, [sp, #12]
34020638:	dad8      	bge.n	340205ec <qsort+0x146>
3402063a:	f1b8 0f00 	cmp.w	r8, #0
3402063e:	d107      	bne.n	34020650 <qsort+0x1aa>
34020640:	f8d9 3000 	ldr.w	r3, [r9]
34020644:	6822      	ldr	r2, [r4, #0]
34020646:	f8c9 2000 	str.w	r2, [r9]
3402064a:	6023      	str	r3, [r4, #0]
3402064c:	1b64      	subs	r4, r4, r5
3402064e:	e7b9      	b.n	340205c4 <qsort+0x11e>
34020650:	4643      	mov	r3, r8
34020652:	462a      	mov	r2, r5
34020654:	4621      	mov	r1, r4
34020656:	4648      	mov	r0, r9
34020658:	f7ff feec 	bl	34020434 <swapfunc>
3402065c:	e7f6      	b.n	3402064c <qsort+0x1a6>
3402065e:	4643      	mov	r3, r8
34020660:	462a      	mov	r2, r5
34020662:	4631      	mov	r1, r6
34020664:	4620      	mov	r0, r4
34020666:	f7ff fee5 	bl	34020434 <swapfunc>
3402066a:	e00d      	b.n	34020688 <qsort+0x1e2>
3402066c:	1b66      	subs	r6, r4, r5
3402066e:	4621      	mov	r1, r4
34020670:	9b00      	ldr	r3, [sp, #0]
34020672:	4630      	mov	r0, r6
34020674:	4798      	blx	r3
34020676:	2800      	cmp	r0, #0
34020678:	dd09      	ble.n	3402068e <qsort+0x1e8>
3402067a:	f1b8 0f00 	cmp.w	r8, #0
3402067e:	d1ee      	bne.n	3402065e <qsort+0x1b8>
34020680:	6823      	ldr	r3, [r4, #0]
34020682:	6832      	ldr	r2, [r6, #0]
34020684:	6022      	str	r2, [r4, #0]
34020686:	6033      	str	r3, [r6, #0]
34020688:	4634      	mov	r4, r6
3402068a:	42a7      	cmp	r7, r4
3402068c:	d3ee      	bcc.n	3402066c <qsort+0x1c6>
3402068e:	44ab      	add	fp, r5
34020690:	e7be      	b.n	34020610 <qsort+0x16a>
34020692:	eba9 0b06 	sub.w	fp, r9, r6
34020696:	1bf2      	subs	r2, r6, r7
34020698:	455a      	cmp	r2, fp
3402069a:	bfa8      	it	ge
3402069c:	465a      	movge	r2, fp
3402069e:	b12a      	cbz	r2, 340206ac <qsort+0x206>
340206a0:	4643      	mov	r3, r8
340206a2:	eba9 0102 	sub.w	r1, r9, r2
340206a6:	4638      	mov	r0, r7
340206a8:	f7ff fec4 	bl	34020434 <swapfunc>
340206ac:	9b02      	ldr	r3, [sp, #8]
340206ae:	ebaa 0404 	sub.w	r4, sl, r4
340206b2:	eba3 020a 	sub.w	r2, r3, sl
340206b6:	1b52      	subs	r2, r2, r5
340206b8:	42a2      	cmp	r2, r4
340206ba:	bf28      	it	cs
340206bc:	4622      	movcs	r2, r4
340206be:	b12a      	cbz	r2, 340206cc <qsort+0x226>
340206c0:	9902      	ldr	r1, [sp, #8]
340206c2:	4643      	mov	r3, r8
340206c4:	4648      	mov	r0, r9
340206c6:	1a89      	subs	r1, r1, r2
340206c8:	f7ff feb4 	bl	34020434 <swapfunc>
340206cc:	9b02      	ldr	r3, [sp, #8]
340206ce:	455c      	cmp	r4, fp
340206d0:	eba3 0604 	sub.w	r6, r3, r4
340206d4:	d805      	bhi.n	340206e2 <qsort+0x23c>
340206d6:	4623      	mov	r3, r4
340206d8:	465c      	mov	r4, fp
340206da:	469b      	mov	fp, r3
340206dc:	4633      	mov	r3, r6
340206de:	463e      	mov	r6, r7
340206e0:	461f      	mov	r7, r3
340206e2:	45ab      	cmp	fp, r5
340206e4:	d920      	bls.n	34020728 <qsort+0x282>
340206e6:	9b01      	ldr	r3, [sp, #4]
340206e8:	2b07      	cmp	r3, #7
340206ea:	fbbb f1f5 	udiv	r1, fp, r5
340206ee:	d80b      	bhi.n	34020708 <qsort+0x262>
340206f0:	aa14      	add	r2, sp, #80	@ 0x50
340206f2:	fbb4 f4f5 	udiv	r4, r4, r5
340206f6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
340206fa:	f843 6c40 	str.w	r6, [r3, #-64]
340206fe:	f843 4c3c 	str.w	r4, [r3, #-60]
34020702:	9b01      	ldr	r3, [sp, #4]
34020704:	3301      	adds	r3, #1
34020706:	e6de      	b.n	340204c6 <qsort+0x20>
34020708:	9b00      	ldr	r3, [sp, #0]
3402070a:	462a      	mov	r2, r5
3402070c:	4638      	mov	r0, r7
3402070e:	f7ff feca 	bl	340204a6 <qsort>
34020712:	42ac      	cmp	r4, r5
34020714:	d80b      	bhi.n	3402072e <qsort+0x288>
34020716:	9b01      	ldr	r3, [sp, #4]
34020718:	aa14      	add	r2, sp, #80	@ 0x50
3402071a:	3b01      	subs	r3, #1
3402071c:	9301      	str	r3, [sp, #4]
3402071e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34020722:	e953 7110 	ldrd	r7, r1, [r3, #-64]	@ 0x40
34020726:	e6cf      	b.n	340204c8 <qsort+0x22>
34020728:	42ac      	cmp	r4, r5
3402072a:	f67f aed9 	bls.w	340204e0 <qsort+0x3a>
3402072e:	4637      	mov	r7, r6
34020730:	fbb4 f1f5 	udiv	r1, r4, r5
34020734:	e6c8      	b.n	340204c8 <qsort+0x22>

34020736 <__cvt>:
34020736:	b5f0      	push	{r4, r5, r6, r7, lr}
34020738:	ed2d 8b02 	vpush	{d8}
3402073c:	eeb0 8b40 	vmov.f64	d8, d0
34020740:	b085      	sub	sp, #20
34020742:	4617      	mov	r7, r2
34020744:	460c      	mov	r4, r1
34020746:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
34020748:	ee18 2a90 	vmov	r2, s17
3402074c:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
3402074e:	f025 0520 	bic.w	r5, r5, #32
34020752:	2a00      	cmp	r2, #0
34020754:	bfb6      	itet	lt
34020756:	222d      	movlt	r2, #45	@ 0x2d
34020758:	2200      	movge	r2, #0
3402075a:	eeb1 8b40 	vneglt.f64	d8, d0
3402075e:	2d46      	cmp	r5, #70	@ 0x46
34020760:	701a      	strb	r2, [r3, #0]
34020762:	d004      	beq.n	3402076e <__cvt+0x38>
34020764:	2d45      	cmp	r5, #69	@ 0x45
34020766:	d100      	bne.n	3402076a <__cvt+0x34>
34020768:	3401      	adds	r4, #1
3402076a:	2102      	movs	r1, #2
3402076c:	e000      	b.n	34020770 <__cvt+0x3a>
3402076e:	2103      	movs	r1, #3
34020770:	ab03      	add	r3, sp, #12
34020772:	eeb0 0b48 	vmov.f64	d0, d8
34020776:	4622      	mov	r2, r4
34020778:	9301      	str	r3, [sp, #4]
3402077a:	ab02      	add	r3, sp, #8
3402077c:	9300      	str	r3, [sp, #0]
3402077e:	4633      	mov	r3, r6
34020780:	f001 fa5a 	bl	34021c38 <_dtoa_r>
34020784:	2d47      	cmp	r5, #71	@ 0x47
34020786:	d114      	bne.n	340207b2 <__cvt+0x7c>
34020788:	07fb      	lsls	r3, r7, #31
3402078a:	d50a      	bpl.n	340207a2 <__cvt+0x6c>
3402078c:	1902      	adds	r2, r0, r4
3402078e:	eeb5 8b40 	vcmp.f64	d8, #0.0
34020792:	2130      	movs	r1, #48	@ 0x30
34020794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020798:	bf08      	it	eq
3402079a:	9203      	streq	r2, [sp, #12]
3402079c:	9b03      	ldr	r3, [sp, #12]
3402079e:	4293      	cmp	r3, r2
340207a0:	d319      	bcc.n	340207d6 <__cvt+0xa0>
340207a2:	9b03      	ldr	r3, [sp, #12]
340207a4:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340207a6:	1a1b      	subs	r3, r3, r0
340207a8:	6013      	str	r3, [r2, #0]
340207aa:	b005      	add	sp, #20
340207ac:	ecbd 8b02 	vpop	{d8}
340207b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
340207b2:	2d46      	cmp	r5, #70	@ 0x46
340207b4:	eb00 0204 	add.w	r2, r0, r4
340207b8:	d1e9      	bne.n	3402078e <__cvt+0x58>
340207ba:	7803      	ldrb	r3, [r0, #0]
340207bc:	2b30      	cmp	r3, #48	@ 0x30
340207be:	d107      	bne.n	340207d0 <__cvt+0x9a>
340207c0:	eeb5 8b40 	vcmp.f64	d8, #0.0
340207c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340207c8:	bf1c      	itt	ne
340207ca:	f1c4 0401 	rsbne	r4, r4, #1
340207ce:	6034      	strne	r4, [r6, #0]
340207d0:	6833      	ldr	r3, [r6, #0]
340207d2:	441a      	add	r2, r3
340207d4:	e7db      	b.n	3402078e <__cvt+0x58>
340207d6:	1c5c      	adds	r4, r3, #1
340207d8:	9403      	str	r4, [sp, #12]
340207da:	7019      	strb	r1, [r3, #0]
340207dc:	e7de      	b.n	3402079c <__cvt+0x66>

340207de <__exponent>:
340207de:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
340207e0:	2900      	cmp	r1, #0
340207e2:	7002      	strb	r2, [r0, #0]
340207e4:	bfba      	itte	lt
340207e6:	4249      	neglt	r1, r1
340207e8:	232d      	movlt	r3, #45	@ 0x2d
340207ea:	232b      	movge	r3, #43	@ 0x2b
340207ec:	2909      	cmp	r1, #9
340207ee:	7043      	strb	r3, [r0, #1]
340207f0:	dd28      	ble.n	34020844 <__exponent+0x66>
340207f2:	f10d 0307 	add.w	r3, sp, #7
340207f6:	270a      	movs	r7, #10
340207f8:	461d      	mov	r5, r3
340207fa:	461a      	mov	r2, r3
340207fc:	3b01      	subs	r3, #1
340207fe:	fbb1 f6f7 	udiv	r6, r1, r7
34020802:	fb07 1416 	mls	r4, r7, r6, r1
34020806:	3430      	adds	r4, #48	@ 0x30
34020808:	f802 4c01 	strb.w	r4, [r2, #-1]
3402080c:	460c      	mov	r4, r1
3402080e:	4631      	mov	r1, r6
34020810:	2c63      	cmp	r4, #99	@ 0x63
34020812:	dcf2      	bgt.n	340207fa <__exponent+0x1c>
34020814:	3130      	adds	r1, #48	@ 0x30
34020816:	1e94      	subs	r4, r2, #2
34020818:	f803 1c01 	strb.w	r1, [r3, #-1]
3402081c:	1c41      	adds	r1, r0, #1
3402081e:	4623      	mov	r3, r4
34020820:	42ab      	cmp	r3, r5
34020822:	d30a      	bcc.n	3402083a <__exponent+0x5c>
34020824:	f10d 0309 	add.w	r3, sp, #9
34020828:	1a9b      	subs	r3, r3, r2
3402082a:	42ac      	cmp	r4, r5
3402082c:	bf88      	it	hi
3402082e:	2300      	movhi	r3, #0
34020830:	3302      	adds	r3, #2
34020832:	4403      	add	r3, r0
34020834:	1a18      	subs	r0, r3, r0
34020836:	b003      	add	sp, #12
34020838:	bdf0      	pop	{r4, r5, r6, r7, pc}
3402083a:	f813 6b01 	ldrb.w	r6, [r3], #1
3402083e:	f801 6f01 	strb.w	r6, [r1, #1]!
34020842:	e7ed      	b.n	34020820 <__exponent+0x42>
34020844:	2330      	movs	r3, #48	@ 0x30
34020846:	3130      	adds	r1, #48	@ 0x30
34020848:	7083      	strb	r3, [r0, #2]
3402084a:	1d03      	adds	r3, r0, #4
3402084c:	70c1      	strb	r1, [r0, #3]
3402084e:	e7f1      	b.n	34020834 <__exponent+0x56>

34020850 <_printf_float>:
34020850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34020854:	b08d      	sub	sp, #52	@ 0x34
34020856:	460c      	mov	r4, r1
34020858:	4616      	mov	r6, r2
3402085a:	461f      	mov	r7, r3
3402085c:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
34020860:	4605      	mov	r5, r0
34020862:	f001 f8b1 	bl	340219c8 <_localeconv_r>
34020866:	f8d0 b000 	ldr.w	fp, [r0]
3402086a:	4658      	mov	r0, fp
3402086c:	f7df ff90 	bl	34000790 <strlen>
34020870:	2300      	movs	r3, #0
34020872:	f894 9018 	ldrb.w	r9, [r4, #24]
34020876:	930a      	str	r3, [sp, #40]	@ 0x28
34020878:	f8d8 3000 	ldr.w	r3, [r8]
3402087c:	6822      	ldr	r2, [r4, #0]
3402087e:	3307      	adds	r3, #7
34020880:	9005      	str	r0, [sp, #20]
34020882:	f023 0307 	bic.w	r3, r3, #7
34020886:	f103 0108 	add.w	r1, r3, #8
3402088a:	f8c8 1000 	str.w	r1, [r8]
3402088e:	ed93 0b00 	vldr	d0, [r3]
34020892:	ed9f 6b97 	vldr	d6, [pc, #604]	@ 34020af0 <_printf_float+0x2a0>
34020896:	eeb0 7bc0 	vabs.f64	d7, d0
3402089a:	ed84 0b12 	vstr	d0, [r4, #72]	@ 0x48
3402089e:	eeb4 7b46 	vcmp.f64	d7, d6
340208a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340208a6:	dd24      	ble.n	340208f2 <_printf_float+0xa2>
340208a8:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
340208ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340208b0:	d502      	bpl.n	340208b8 <_printf_float+0x68>
340208b2:	232d      	movs	r3, #45	@ 0x2d
340208b4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340208b8:	498f      	ldr	r1, [pc, #572]	@ (34020af8 <_printf_float+0x2a8>)
340208ba:	4b90      	ldr	r3, [pc, #576]	@ (34020afc <_printf_float+0x2ac>)
340208bc:	f1b9 0f47 	cmp.w	r9, #71	@ 0x47
340208c0:	bf8c      	ite	hi
340208c2:	4688      	movhi	r8, r1
340208c4:	4698      	movls	r8, r3
340208c6:	f022 0204 	bic.w	r2, r2, #4
340208ca:	2303      	movs	r3, #3
340208cc:	f04f 0a00 	mov.w	sl, #0
340208d0:	6022      	str	r2, [r4, #0]
340208d2:	6123      	str	r3, [r4, #16]
340208d4:	4633      	mov	r3, r6
340208d6:	aa0b      	add	r2, sp, #44	@ 0x2c
340208d8:	4621      	mov	r1, r4
340208da:	4628      	mov	r0, r5
340208dc:	9700      	str	r7, [sp, #0]
340208de:	f000 f9d1 	bl	34020c84 <_printf_common>
340208e2:	3001      	adds	r0, #1
340208e4:	f040 8089 	bne.w	340209fa <_printf_float+0x1aa>
340208e8:	f04f 30ff 	mov.w	r0, #4294967295
340208ec:	b00d      	add	sp, #52	@ 0x34
340208ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340208f2:	eeb4 0b40 	vcmp.f64	d0, d0
340208f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340208fa:	d709      	bvc.n	34020910 <_printf_float+0xc0>
340208fc:	ee10 3a90 	vmov	r3, s1
34020900:	497f      	ldr	r1, [pc, #508]	@ (34020b00 <_printf_float+0x2b0>)
34020902:	2b00      	cmp	r3, #0
34020904:	bfbc      	itt	lt
34020906:	232d      	movlt	r3, #45	@ 0x2d
34020908:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
3402090c:	4b7d      	ldr	r3, [pc, #500]	@ (34020b04 <_printf_float+0x2b4>)
3402090e:	e7d5      	b.n	340208bc <_printf_float+0x6c>
34020910:	6863      	ldr	r3, [r4, #4]
34020912:	f009 0adf 	and.w	sl, r9, #223	@ 0xdf
34020916:	1c59      	adds	r1, r3, #1
34020918:	d139      	bne.n	3402098e <_printf_float+0x13e>
3402091a:	2306      	movs	r3, #6
3402091c:	6063      	str	r3, [r4, #4]
3402091e:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
34020922:	2300      	movs	r3, #0
34020924:	4628      	mov	r0, r5
34020926:	6022      	str	r2, [r4, #0]
34020928:	9303      	str	r3, [sp, #12]
3402092a:	ab0a      	add	r3, sp, #40	@ 0x28
3402092c:	e9cd 9301 	strd	r9, r3, [sp, #4]
34020930:	ab09      	add	r3, sp, #36	@ 0x24
34020932:	9300      	str	r3, [sp, #0]
34020934:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
34020938:	6861      	ldr	r1, [r4, #4]
3402093a:	f7ff fefc 	bl	34020736 <__cvt>
3402093e:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
34020942:	4680      	mov	r8, r0
34020944:	9909      	ldr	r1, [sp, #36]	@ 0x24
34020946:	d129      	bne.n	3402099c <_printf_float+0x14c>
34020948:	1cc8      	adds	r0, r1, #3
3402094a:	db02      	blt.n	34020952 <_printf_float+0x102>
3402094c:	6863      	ldr	r3, [r4, #4]
3402094e:	4299      	cmp	r1, r3
34020950:	dd41      	ble.n	340209d6 <_printf_float+0x186>
34020952:	f1a9 0902 	sub.w	r9, r9, #2
34020956:	fa5f f989 	uxtb.w	r9, r9
3402095a:	3901      	subs	r1, #1
3402095c:	464a      	mov	r2, r9
3402095e:	f104 0050 	add.w	r0, r4, #80	@ 0x50
34020962:	9109      	str	r1, [sp, #36]	@ 0x24
34020964:	f7ff ff3b 	bl	340207de <__exponent>
34020968:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
3402096a:	4682      	mov	sl, r0
3402096c:	1813      	adds	r3, r2, r0
3402096e:	2a01      	cmp	r2, #1
34020970:	6123      	str	r3, [r4, #16]
34020972:	dc02      	bgt.n	3402097a <_printf_float+0x12a>
34020974:	6822      	ldr	r2, [r4, #0]
34020976:	07d2      	lsls	r2, r2, #31
34020978:	d501      	bpl.n	3402097e <_printf_float+0x12e>
3402097a:	3301      	adds	r3, #1
3402097c:	6123      	str	r3, [r4, #16]
3402097e:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
34020982:	2b00      	cmp	r3, #0
34020984:	d0a6      	beq.n	340208d4 <_printf_float+0x84>
34020986:	232d      	movs	r3, #45	@ 0x2d
34020988:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
3402098c:	e7a2      	b.n	340208d4 <_printf_float+0x84>
3402098e:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
34020992:	d1c4      	bne.n	3402091e <_printf_float+0xce>
34020994:	2b00      	cmp	r3, #0
34020996:	d1c2      	bne.n	3402091e <_printf_float+0xce>
34020998:	2301      	movs	r3, #1
3402099a:	e7bf      	b.n	3402091c <_printf_float+0xcc>
3402099c:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
340209a0:	d9db      	bls.n	3402095a <_printf_float+0x10a>
340209a2:	f1b9 0f66 	cmp.w	r9, #102	@ 0x66
340209a6:	d118      	bne.n	340209da <_printf_float+0x18a>
340209a8:	2900      	cmp	r1, #0
340209aa:	6863      	ldr	r3, [r4, #4]
340209ac:	dd0b      	ble.n	340209c6 <_printf_float+0x176>
340209ae:	6121      	str	r1, [r4, #16]
340209b0:	b913      	cbnz	r3, 340209b8 <_printf_float+0x168>
340209b2:	6822      	ldr	r2, [r4, #0]
340209b4:	07d0      	lsls	r0, r2, #31
340209b6:	d502      	bpl.n	340209be <_printf_float+0x16e>
340209b8:	3301      	adds	r3, #1
340209ba:	440b      	add	r3, r1
340209bc:	6123      	str	r3, [r4, #16]
340209be:	f04f 0a00 	mov.w	sl, #0
340209c2:	65a1      	str	r1, [r4, #88]	@ 0x58
340209c4:	e7db      	b.n	3402097e <_printf_float+0x12e>
340209c6:	b913      	cbnz	r3, 340209ce <_printf_float+0x17e>
340209c8:	6822      	ldr	r2, [r4, #0]
340209ca:	07d2      	lsls	r2, r2, #31
340209cc:	d501      	bpl.n	340209d2 <_printf_float+0x182>
340209ce:	3302      	adds	r3, #2
340209d0:	e7f4      	b.n	340209bc <_printf_float+0x16c>
340209d2:	2301      	movs	r3, #1
340209d4:	e7f2      	b.n	340209bc <_printf_float+0x16c>
340209d6:	f04f 0967 	mov.w	r9, #103	@ 0x67
340209da:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340209dc:	4299      	cmp	r1, r3
340209de:	db05      	blt.n	340209ec <_printf_float+0x19c>
340209e0:	6823      	ldr	r3, [r4, #0]
340209e2:	6121      	str	r1, [r4, #16]
340209e4:	07d8      	lsls	r0, r3, #31
340209e6:	d5ea      	bpl.n	340209be <_printf_float+0x16e>
340209e8:	1c4b      	adds	r3, r1, #1
340209ea:	e7e7      	b.n	340209bc <_printf_float+0x16c>
340209ec:	2900      	cmp	r1, #0
340209ee:	bfd4      	ite	le
340209f0:	f1c1 0202 	rsble	r2, r1, #2
340209f4:	2201      	movgt	r2, #1
340209f6:	4413      	add	r3, r2
340209f8:	e7e0      	b.n	340209bc <_printf_float+0x16c>
340209fa:	6823      	ldr	r3, [r4, #0]
340209fc:	055a      	lsls	r2, r3, #21
340209fe:	d407      	bmi.n	34020a10 <_printf_float+0x1c0>
34020a00:	6923      	ldr	r3, [r4, #16]
34020a02:	4642      	mov	r2, r8
34020a04:	4631      	mov	r1, r6
34020a06:	4628      	mov	r0, r5
34020a08:	47b8      	blx	r7
34020a0a:	3001      	adds	r0, #1
34020a0c:	d12a      	bne.n	34020a64 <_printf_float+0x214>
34020a0e:	e76b      	b.n	340208e8 <_printf_float+0x98>
34020a10:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
34020a14:	f240 80e0 	bls.w	34020bd8 <_printf_float+0x388>
34020a18:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
34020a1c:	eeb5 7b40 	vcmp.f64	d7, #0.0
34020a20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020a24:	d133      	bne.n	34020a8e <_printf_float+0x23e>
34020a26:	2301      	movs	r3, #1
34020a28:	4a37      	ldr	r2, [pc, #220]	@ (34020b08 <_printf_float+0x2b8>)
34020a2a:	4631      	mov	r1, r6
34020a2c:	4628      	mov	r0, r5
34020a2e:	47b8      	blx	r7
34020a30:	3001      	adds	r0, #1
34020a32:	f43f af59 	beq.w	340208e8 <_printf_float+0x98>
34020a36:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
34020a3a:	4543      	cmp	r3, r8
34020a3c:	db02      	blt.n	34020a44 <_printf_float+0x1f4>
34020a3e:	6823      	ldr	r3, [r4, #0]
34020a40:	07d8      	lsls	r0, r3, #31
34020a42:	d50f      	bpl.n	34020a64 <_printf_float+0x214>
34020a44:	9b05      	ldr	r3, [sp, #20]
34020a46:	465a      	mov	r2, fp
34020a48:	4631      	mov	r1, r6
34020a4a:	4628      	mov	r0, r5
34020a4c:	47b8      	blx	r7
34020a4e:	3001      	adds	r0, #1
34020a50:	f43f af4a 	beq.w	340208e8 <_printf_float+0x98>
34020a54:	f04f 0900 	mov.w	r9, #0
34020a58:	f108 38ff 	add.w	r8, r8, #4294967295
34020a5c:	f104 0a1a 	add.w	sl, r4, #26
34020a60:	45c8      	cmp	r8, r9
34020a62:	dc09      	bgt.n	34020a78 <_printf_float+0x228>
34020a64:	6823      	ldr	r3, [r4, #0]
34020a66:	079b      	lsls	r3, r3, #30
34020a68:	f100 8107 	bmi.w	34020c7a <_printf_float+0x42a>
34020a6c:	68e0      	ldr	r0, [r4, #12]
34020a6e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34020a70:	4298      	cmp	r0, r3
34020a72:	bfb8      	it	lt
34020a74:	4618      	movlt	r0, r3
34020a76:	e739      	b.n	340208ec <_printf_float+0x9c>
34020a78:	2301      	movs	r3, #1
34020a7a:	4652      	mov	r2, sl
34020a7c:	4631      	mov	r1, r6
34020a7e:	4628      	mov	r0, r5
34020a80:	47b8      	blx	r7
34020a82:	3001      	adds	r0, #1
34020a84:	f43f af30 	beq.w	340208e8 <_printf_float+0x98>
34020a88:	f109 0901 	add.w	r9, r9, #1
34020a8c:	e7e8      	b.n	34020a60 <_printf_float+0x210>
34020a8e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34020a90:	2b00      	cmp	r3, #0
34020a92:	dc3b      	bgt.n	34020b0c <_printf_float+0x2bc>
34020a94:	2301      	movs	r3, #1
34020a96:	4a1c      	ldr	r2, [pc, #112]	@ (34020b08 <_printf_float+0x2b8>)
34020a98:	4631      	mov	r1, r6
34020a9a:	4628      	mov	r0, r5
34020a9c:	47b8      	blx	r7
34020a9e:	3001      	adds	r0, #1
34020aa0:	f43f af22 	beq.w	340208e8 <_printf_float+0x98>
34020aa4:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
34020aa8:	ea59 0303 	orrs.w	r3, r9, r3
34020aac:	d102      	bne.n	34020ab4 <_printf_float+0x264>
34020aae:	6823      	ldr	r3, [r4, #0]
34020ab0:	07d9      	lsls	r1, r3, #31
34020ab2:	d5d7      	bpl.n	34020a64 <_printf_float+0x214>
34020ab4:	9b05      	ldr	r3, [sp, #20]
34020ab6:	465a      	mov	r2, fp
34020ab8:	4631      	mov	r1, r6
34020aba:	4628      	mov	r0, r5
34020abc:	47b8      	blx	r7
34020abe:	3001      	adds	r0, #1
34020ac0:	f43f af12 	beq.w	340208e8 <_printf_float+0x98>
34020ac4:	f04f 0a00 	mov.w	sl, #0
34020ac8:	f104 0b1a 	add.w	fp, r4, #26
34020acc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34020ace:	425b      	negs	r3, r3
34020ad0:	4553      	cmp	r3, sl
34020ad2:	dc01      	bgt.n	34020ad8 <_printf_float+0x288>
34020ad4:	464b      	mov	r3, r9
34020ad6:	e794      	b.n	34020a02 <_printf_float+0x1b2>
34020ad8:	2301      	movs	r3, #1
34020ada:	465a      	mov	r2, fp
34020adc:	4631      	mov	r1, r6
34020ade:	4628      	mov	r0, r5
34020ae0:	47b8      	blx	r7
34020ae2:	3001      	adds	r0, #1
34020ae4:	f43f af00 	beq.w	340208e8 <_printf_float+0x98>
34020ae8:	f10a 0a01 	add.w	sl, sl, #1
34020aec:	e7ee      	b.n	34020acc <_printf_float+0x27c>
34020aee:	bf00      	nop
34020af0:	ffffffff 	.word	0xffffffff
34020af4:	7fefffff 	.word	0x7fefffff
34020af8:	3403328e 	.word	0x3403328e
34020afc:	3403328a 	.word	0x3403328a
34020b00:	34033296 	.word	0x34033296
34020b04:	34033292 	.word	0x34033292
34020b08:	3403329a 	.word	0x3403329a
34020b0c:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34020b0e:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
34020b12:	4553      	cmp	r3, sl
34020b14:	bfa8      	it	ge
34020b16:	4653      	movge	r3, sl
34020b18:	2b00      	cmp	r3, #0
34020b1a:	4699      	mov	r9, r3
34020b1c:	dc37      	bgt.n	34020b8e <_printf_float+0x33e>
34020b1e:	2300      	movs	r3, #0
34020b20:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
34020b24:	f104 021a 	add.w	r2, r4, #26
34020b28:	9307      	str	r3, [sp, #28]
34020b2a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34020b2c:	9907      	ldr	r1, [sp, #28]
34020b2e:	9306      	str	r3, [sp, #24]
34020b30:	eba3 0309 	sub.w	r3, r3, r9
34020b34:	428b      	cmp	r3, r1
34020b36:	dc31      	bgt.n	34020b9c <_printf_float+0x34c>
34020b38:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34020b3a:	459a      	cmp	sl, r3
34020b3c:	dc3b      	bgt.n	34020bb6 <_printf_float+0x366>
34020b3e:	6823      	ldr	r3, [r4, #0]
34020b40:	07da      	lsls	r2, r3, #31
34020b42:	d438      	bmi.n	34020bb6 <_printf_float+0x366>
34020b44:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34020b46:	ebaa 0903 	sub.w	r9, sl, r3
34020b4a:	9b06      	ldr	r3, [sp, #24]
34020b4c:	ebaa 0303 	sub.w	r3, sl, r3
34020b50:	4599      	cmp	r9, r3
34020b52:	bfa8      	it	ge
34020b54:	4699      	movge	r9, r3
34020b56:	f1b9 0f00 	cmp.w	r9, #0
34020b5a:	dc34      	bgt.n	34020bc6 <_printf_float+0x376>
34020b5c:	f04f 0800 	mov.w	r8, #0
34020b60:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
34020b64:	f104 0b1a 	add.w	fp, r4, #26
34020b68:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34020b6a:	ebaa 0303 	sub.w	r3, sl, r3
34020b6e:	eba3 0309 	sub.w	r3, r3, r9
34020b72:	4543      	cmp	r3, r8
34020b74:	f77f af76 	ble.w	34020a64 <_printf_float+0x214>
34020b78:	2301      	movs	r3, #1
34020b7a:	465a      	mov	r2, fp
34020b7c:	4631      	mov	r1, r6
34020b7e:	4628      	mov	r0, r5
34020b80:	47b8      	blx	r7
34020b82:	3001      	adds	r0, #1
34020b84:	f43f aeb0 	beq.w	340208e8 <_printf_float+0x98>
34020b88:	f108 0801 	add.w	r8, r8, #1
34020b8c:	e7ec      	b.n	34020b68 <_printf_float+0x318>
34020b8e:	4642      	mov	r2, r8
34020b90:	4631      	mov	r1, r6
34020b92:	4628      	mov	r0, r5
34020b94:	47b8      	blx	r7
34020b96:	3001      	adds	r0, #1
34020b98:	d1c1      	bne.n	34020b1e <_printf_float+0x2ce>
34020b9a:	e6a5      	b.n	340208e8 <_printf_float+0x98>
34020b9c:	2301      	movs	r3, #1
34020b9e:	4631      	mov	r1, r6
34020ba0:	4628      	mov	r0, r5
34020ba2:	9206      	str	r2, [sp, #24]
34020ba4:	47b8      	blx	r7
34020ba6:	3001      	adds	r0, #1
34020ba8:	f43f ae9e 	beq.w	340208e8 <_printf_float+0x98>
34020bac:	9b07      	ldr	r3, [sp, #28]
34020bae:	9a06      	ldr	r2, [sp, #24]
34020bb0:	3301      	adds	r3, #1
34020bb2:	9307      	str	r3, [sp, #28]
34020bb4:	e7b9      	b.n	34020b2a <_printf_float+0x2da>
34020bb6:	9b05      	ldr	r3, [sp, #20]
34020bb8:	465a      	mov	r2, fp
34020bba:	4631      	mov	r1, r6
34020bbc:	4628      	mov	r0, r5
34020bbe:	47b8      	blx	r7
34020bc0:	3001      	adds	r0, #1
34020bc2:	d1bf      	bne.n	34020b44 <_printf_float+0x2f4>
34020bc4:	e690      	b.n	340208e8 <_printf_float+0x98>
34020bc6:	9a06      	ldr	r2, [sp, #24]
34020bc8:	464b      	mov	r3, r9
34020bca:	4631      	mov	r1, r6
34020bcc:	4628      	mov	r0, r5
34020bce:	4442      	add	r2, r8
34020bd0:	47b8      	blx	r7
34020bd2:	3001      	adds	r0, #1
34020bd4:	d1c2      	bne.n	34020b5c <_printf_float+0x30c>
34020bd6:	e687      	b.n	340208e8 <_printf_float+0x98>
34020bd8:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
34020bdc:	f1b9 0f01 	cmp.w	r9, #1
34020be0:	dc01      	bgt.n	34020be6 <_printf_float+0x396>
34020be2:	07db      	lsls	r3, r3, #31
34020be4:	d536      	bpl.n	34020c54 <_printf_float+0x404>
34020be6:	2301      	movs	r3, #1
34020be8:	4642      	mov	r2, r8
34020bea:	4631      	mov	r1, r6
34020bec:	4628      	mov	r0, r5
34020bee:	47b8      	blx	r7
34020bf0:	3001      	adds	r0, #1
34020bf2:	f43f ae79 	beq.w	340208e8 <_printf_float+0x98>
34020bf6:	9b05      	ldr	r3, [sp, #20]
34020bf8:	465a      	mov	r2, fp
34020bfa:	4631      	mov	r1, r6
34020bfc:	4628      	mov	r0, r5
34020bfe:	47b8      	blx	r7
34020c00:	3001      	adds	r0, #1
34020c02:	f43f ae71 	beq.w	340208e8 <_printf_float+0x98>
34020c06:	f109 39ff 	add.w	r9, r9, #4294967295
34020c0a:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
34020c0e:	eeb5 7b40 	vcmp.f64	d7, #0.0
34020c12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020c16:	d018      	beq.n	34020c4a <_printf_float+0x3fa>
34020c18:	464b      	mov	r3, r9
34020c1a:	f108 0201 	add.w	r2, r8, #1
34020c1e:	4631      	mov	r1, r6
34020c20:	4628      	mov	r0, r5
34020c22:	47b8      	blx	r7
34020c24:	3001      	adds	r0, #1
34020c26:	d10c      	bne.n	34020c42 <_printf_float+0x3f2>
34020c28:	e65e      	b.n	340208e8 <_printf_float+0x98>
34020c2a:	2301      	movs	r3, #1
34020c2c:	465a      	mov	r2, fp
34020c2e:	4631      	mov	r1, r6
34020c30:	4628      	mov	r0, r5
34020c32:	47b8      	blx	r7
34020c34:	3001      	adds	r0, #1
34020c36:	f43f ae57 	beq.w	340208e8 <_printf_float+0x98>
34020c3a:	f108 0801 	add.w	r8, r8, #1
34020c3e:	45c8      	cmp	r8, r9
34020c40:	dbf3      	blt.n	34020c2a <_printf_float+0x3da>
34020c42:	4653      	mov	r3, sl
34020c44:	f104 0250 	add.w	r2, r4, #80	@ 0x50
34020c48:	e6dc      	b.n	34020a04 <_printf_float+0x1b4>
34020c4a:	f04f 0800 	mov.w	r8, #0
34020c4e:	f104 0b1a 	add.w	fp, r4, #26
34020c52:	e7f4      	b.n	34020c3e <_printf_float+0x3ee>
34020c54:	2301      	movs	r3, #1
34020c56:	4642      	mov	r2, r8
34020c58:	e7e1      	b.n	34020c1e <_printf_float+0x3ce>
34020c5a:	2301      	movs	r3, #1
34020c5c:	464a      	mov	r2, r9
34020c5e:	4631      	mov	r1, r6
34020c60:	4628      	mov	r0, r5
34020c62:	47b8      	blx	r7
34020c64:	3001      	adds	r0, #1
34020c66:	f43f ae3f 	beq.w	340208e8 <_printf_float+0x98>
34020c6a:	f108 0801 	add.w	r8, r8, #1
34020c6e:	68e3      	ldr	r3, [r4, #12]
34020c70:	990b      	ldr	r1, [sp, #44]	@ 0x2c
34020c72:	1a5b      	subs	r3, r3, r1
34020c74:	4543      	cmp	r3, r8
34020c76:	dcf0      	bgt.n	34020c5a <_printf_float+0x40a>
34020c78:	e6f8      	b.n	34020a6c <_printf_float+0x21c>
34020c7a:	f04f 0800 	mov.w	r8, #0
34020c7e:	f104 0919 	add.w	r9, r4, #25
34020c82:	e7f4      	b.n	34020c6e <_printf_float+0x41e>

34020c84 <_printf_common>:
34020c84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34020c88:	4616      	mov	r6, r2
34020c8a:	4698      	mov	r8, r3
34020c8c:	688a      	ldr	r2, [r1, #8]
34020c8e:	4607      	mov	r7, r0
34020c90:	690b      	ldr	r3, [r1, #16]
34020c92:	460c      	mov	r4, r1
34020c94:	f8dd 9020 	ldr.w	r9, [sp, #32]
34020c98:	4293      	cmp	r3, r2
34020c9a:	bfb8      	it	lt
34020c9c:	4613      	movlt	r3, r2
34020c9e:	6033      	str	r3, [r6, #0]
34020ca0:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
34020ca4:	b10a      	cbz	r2, 34020caa <_printf_common+0x26>
34020ca6:	3301      	adds	r3, #1
34020ca8:	6033      	str	r3, [r6, #0]
34020caa:	6823      	ldr	r3, [r4, #0]
34020cac:	0699      	lsls	r1, r3, #26
34020cae:	bf42      	ittt	mi
34020cb0:	6833      	ldrmi	r3, [r6, #0]
34020cb2:	3302      	addmi	r3, #2
34020cb4:	6033      	strmi	r3, [r6, #0]
34020cb6:	6825      	ldr	r5, [r4, #0]
34020cb8:	f015 0506 	ands.w	r5, r5, #6
34020cbc:	d106      	bne.n	34020ccc <_printf_common+0x48>
34020cbe:	f104 0a19 	add.w	sl, r4, #25
34020cc2:	68e3      	ldr	r3, [r4, #12]
34020cc4:	6832      	ldr	r2, [r6, #0]
34020cc6:	1a9b      	subs	r3, r3, r2
34020cc8:	42ab      	cmp	r3, r5
34020cca:	dc2b      	bgt.n	34020d24 <_printf_common+0xa0>
34020ccc:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
34020cd0:	6822      	ldr	r2, [r4, #0]
34020cd2:	3b00      	subs	r3, #0
34020cd4:	bf18      	it	ne
34020cd6:	2301      	movne	r3, #1
34020cd8:	0692      	lsls	r2, r2, #26
34020cda:	d430      	bmi.n	34020d3e <_printf_common+0xba>
34020cdc:	f104 0243 	add.w	r2, r4, #67	@ 0x43
34020ce0:	4641      	mov	r1, r8
34020ce2:	4638      	mov	r0, r7
34020ce4:	47c8      	blx	r9
34020ce6:	3001      	adds	r0, #1
34020ce8:	d023      	beq.n	34020d32 <_printf_common+0xae>
34020cea:	6823      	ldr	r3, [r4, #0]
34020cec:	341a      	adds	r4, #26
34020cee:	f854 2c0a 	ldr.w	r2, [r4, #-10]
34020cf2:	f003 0306 	and.w	r3, r3, #6
34020cf6:	2b04      	cmp	r3, #4
34020cf8:	bf0a      	itet	eq
34020cfa:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
34020cfe:	2500      	movne	r5, #0
34020d00:	6833      	ldreq	r3, [r6, #0]
34020d02:	f04f 0600 	mov.w	r6, #0
34020d06:	bf08      	it	eq
34020d08:	1aed      	subeq	r5, r5, r3
34020d0a:	f854 3c12 	ldr.w	r3, [r4, #-18]
34020d0e:	bf08      	it	eq
34020d10:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
34020d14:	4293      	cmp	r3, r2
34020d16:	bfc4      	itt	gt
34020d18:	1a9b      	subgt	r3, r3, r2
34020d1a:	18ed      	addgt	r5, r5, r3
34020d1c:	42b5      	cmp	r5, r6
34020d1e:	d11a      	bne.n	34020d56 <_printf_common+0xd2>
34020d20:	2000      	movs	r0, #0
34020d22:	e008      	b.n	34020d36 <_printf_common+0xb2>
34020d24:	2301      	movs	r3, #1
34020d26:	4652      	mov	r2, sl
34020d28:	4641      	mov	r1, r8
34020d2a:	4638      	mov	r0, r7
34020d2c:	47c8      	blx	r9
34020d2e:	3001      	adds	r0, #1
34020d30:	d103      	bne.n	34020d3a <_printf_common+0xb6>
34020d32:	f04f 30ff 	mov.w	r0, #4294967295
34020d36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34020d3a:	3501      	adds	r5, #1
34020d3c:	e7c1      	b.n	34020cc2 <_printf_common+0x3e>
34020d3e:	18e1      	adds	r1, r4, r3
34020d40:	1c5a      	adds	r2, r3, #1
34020d42:	2030      	movs	r0, #48	@ 0x30
34020d44:	3302      	adds	r3, #2
34020d46:	4422      	add	r2, r4
34020d48:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
34020d4c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
34020d50:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
34020d54:	e7c2      	b.n	34020cdc <_printf_common+0x58>
34020d56:	2301      	movs	r3, #1
34020d58:	4622      	mov	r2, r4
34020d5a:	4641      	mov	r1, r8
34020d5c:	4638      	mov	r0, r7
34020d5e:	47c8      	blx	r9
34020d60:	3001      	adds	r0, #1
34020d62:	d0e6      	beq.n	34020d32 <_printf_common+0xae>
34020d64:	3601      	adds	r6, #1
34020d66:	e7d9      	b.n	34020d1c <_printf_common+0x98>

34020d68 <_printf_i>:
34020d68:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
34020d6c:	7e0f      	ldrb	r7, [r1, #24]
34020d6e:	4691      	mov	r9, r2
34020d70:	4680      	mov	r8, r0
34020d72:	460c      	mov	r4, r1
34020d74:	2f78      	cmp	r7, #120	@ 0x78
34020d76:	469a      	mov	sl, r3
34020d78:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
34020d7a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
34020d7e:	d807      	bhi.n	34020d90 <_printf_i+0x28>
34020d80:	2f62      	cmp	r7, #98	@ 0x62
34020d82:	d80a      	bhi.n	34020d9a <_printf_i+0x32>
34020d84:	2f00      	cmp	r7, #0
34020d86:	f000 80d1 	beq.w	34020f2c <_printf_i+0x1c4>
34020d8a:	2f58      	cmp	r7, #88	@ 0x58
34020d8c:	f000 80b8 	beq.w	34020f00 <_printf_i+0x198>
34020d90:	f104 0642 	add.w	r6, r4, #66	@ 0x42
34020d94:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
34020d98:	e03a      	b.n	34020e10 <_printf_i+0xa8>
34020d9a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
34020d9e:	2b15      	cmp	r3, #21
34020da0:	d8f6      	bhi.n	34020d90 <_printf_i+0x28>
34020da2:	a101      	add	r1, pc, #4	@ (adr r1, 34020da8 <_printf_i+0x40>)
34020da4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
34020da8:	34020e01 	.word	0x34020e01
34020dac:	34020e15 	.word	0x34020e15
34020db0:	34020d91 	.word	0x34020d91
34020db4:	34020d91 	.word	0x34020d91
34020db8:	34020d91 	.word	0x34020d91
34020dbc:	34020d91 	.word	0x34020d91
34020dc0:	34020e15 	.word	0x34020e15
34020dc4:	34020d91 	.word	0x34020d91
34020dc8:	34020d91 	.word	0x34020d91
34020dcc:	34020d91 	.word	0x34020d91
34020dd0:	34020d91 	.word	0x34020d91
34020dd4:	34020f13 	.word	0x34020f13
34020dd8:	34020e3f 	.word	0x34020e3f
34020ddc:	34020ecd 	.word	0x34020ecd
34020de0:	34020d91 	.word	0x34020d91
34020de4:	34020d91 	.word	0x34020d91
34020de8:	34020f35 	.word	0x34020f35
34020dec:	34020d91 	.word	0x34020d91
34020df0:	34020e3f 	.word	0x34020e3f
34020df4:	34020d91 	.word	0x34020d91
34020df8:	34020d91 	.word	0x34020d91
34020dfc:	34020ed5 	.word	0x34020ed5
34020e00:	6833      	ldr	r3, [r6, #0]
34020e02:	1d1a      	adds	r2, r3, #4
34020e04:	681b      	ldr	r3, [r3, #0]
34020e06:	6032      	str	r2, [r6, #0]
34020e08:	f104 0642 	add.w	r6, r4, #66	@ 0x42
34020e0c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
34020e10:	2301      	movs	r3, #1
34020e12:	e09c      	b.n	34020f4e <_printf_i+0x1e6>
34020e14:	6833      	ldr	r3, [r6, #0]
34020e16:	6820      	ldr	r0, [r4, #0]
34020e18:	1d19      	adds	r1, r3, #4
34020e1a:	6031      	str	r1, [r6, #0]
34020e1c:	0606      	lsls	r6, r0, #24
34020e1e:	d501      	bpl.n	34020e24 <_printf_i+0xbc>
34020e20:	681d      	ldr	r5, [r3, #0]
34020e22:	e003      	b.n	34020e2c <_printf_i+0xc4>
34020e24:	0645      	lsls	r5, r0, #25
34020e26:	d5fb      	bpl.n	34020e20 <_printf_i+0xb8>
34020e28:	f9b3 5000 	ldrsh.w	r5, [r3]
34020e2c:	2d00      	cmp	r5, #0
34020e2e:	da03      	bge.n	34020e38 <_printf_i+0xd0>
34020e30:	232d      	movs	r3, #45	@ 0x2d
34020e32:	426d      	negs	r5, r5
34020e34:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34020e38:	4858      	ldr	r0, [pc, #352]	@ (34020f9c <_printf_i+0x234>)
34020e3a:	230a      	movs	r3, #10
34020e3c:	e011      	b.n	34020e62 <_printf_i+0xfa>
34020e3e:	6821      	ldr	r1, [r4, #0]
34020e40:	6833      	ldr	r3, [r6, #0]
34020e42:	0608      	lsls	r0, r1, #24
34020e44:	f853 5b04 	ldr.w	r5, [r3], #4
34020e48:	d402      	bmi.n	34020e50 <_printf_i+0xe8>
34020e4a:	0649      	lsls	r1, r1, #25
34020e4c:	bf48      	it	mi
34020e4e:	b2ad      	uxthmi	r5, r5
34020e50:	2f6f      	cmp	r7, #111	@ 0x6f
34020e52:	6033      	str	r3, [r6, #0]
34020e54:	4851      	ldr	r0, [pc, #324]	@ (34020f9c <_printf_i+0x234>)
34020e56:	bf14      	ite	ne
34020e58:	230a      	movne	r3, #10
34020e5a:	2308      	moveq	r3, #8
34020e5c:	2100      	movs	r1, #0
34020e5e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
34020e62:	6866      	ldr	r6, [r4, #4]
34020e64:	2e00      	cmp	r6, #0
34020e66:	60a6      	str	r6, [r4, #8]
34020e68:	db05      	blt.n	34020e76 <_printf_i+0x10e>
34020e6a:	6821      	ldr	r1, [r4, #0]
34020e6c:	432e      	orrs	r6, r5
34020e6e:	f021 0104 	bic.w	r1, r1, #4
34020e72:	6021      	str	r1, [r4, #0]
34020e74:	d04b      	beq.n	34020f0e <_printf_i+0x1a6>
34020e76:	4616      	mov	r6, r2
34020e78:	fbb5 f1f3 	udiv	r1, r5, r3
34020e7c:	fb03 5711 	mls	r7, r3, r1, r5
34020e80:	5dc7      	ldrb	r7, [r0, r7]
34020e82:	f806 7d01 	strb.w	r7, [r6, #-1]!
34020e86:	462f      	mov	r7, r5
34020e88:	460d      	mov	r5, r1
34020e8a:	42bb      	cmp	r3, r7
34020e8c:	d9f4      	bls.n	34020e78 <_printf_i+0x110>
34020e8e:	2b08      	cmp	r3, #8
34020e90:	d10b      	bne.n	34020eaa <_printf_i+0x142>
34020e92:	6823      	ldr	r3, [r4, #0]
34020e94:	07df      	lsls	r7, r3, #31
34020e96:	d508      	bpl.n	34020eaa <_printf_i+0x142>
34020e98:	6923      	ldr	r3, [r4, #16]
34020e9a:	6861      	ldr	r1, [r4, #4]
34020e9c:	4299      	cmp	r1, r3
34020e9e:	bfde      	ittt	le
34020ea0:	2330      	movle	r3, #48	@ 0x30
34020ea2:	f806 3c01 	strble.w	r3, [r6, #-1]
34020ea6:	f106 36ff 	addle.w	r6, r6, #4294967295
34020eaa:	1b92      	subs	r2, r2, r6
34020eac:	6122      	str	r2, [r4, #16]
34020eae:	464b      	mov	r3, r9
34020eb0:	aa03      	add	r2, sp, #12
34020eb2:	4621      	mov	r1, r4
34020eb4:	4640      	mov	r0, r8
34020eb6:	f8cd a000 	str.w	sl, [sp]
34020eba:	f7ff fee3 	bl	34020c84 <_printf_common>
34020ebe:	3001      	adds	r0, #1
34020ec0:	d14a      	bne.n	34020f58 <_printf_i+0x1f0>
34020ec2:	f04f 30ff 	mov.w	r0, #4294967295
34020ec6:	b004      	add	sp, #16
34020ec8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34020ecc:	6823      	ldr	r3, [r4, #0]
34020ece:	f043 0320 	orr.w	r3, r3, #32
34020ed2:	6023      	str	r3, [r4, #0]
34020ed4:	2778      	movs	r7, #120	@ 0x78
34020ed6:	4832      	ldr	r0, [pc, #200]	@ (34020fa0 <_printf_i+0x238>)
34020ed8:	6823      	ldr	r3, [r4, #0]
34020eda:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
34020ede:	061f      	lsls	r7, r3, #24
34020ee0:	6831      	ldr	r1, [r6, #0]
34020ee2:	f851 5b04 	ldr.w	r5, [r1], #4
34020ee6:	d402      	bmi.n	34020eee <_printf_i+0x186>
34020ee8:	065f      	lsls	r7, r3, #25
34020eea:	bf48      	it	mi
34020eec:	b2ad      	uxthmi	r5, r5
34020eee:	6031      	str	r1, [r6, #0]
34020ef0:	07d9      	lsls	r1, r3, #31
34020ef2:	bf44      	itt	mi
34020ef4:	f043 0320 	orrmi.w	r3, r3, #32
34020ef8:	6023      	strmi	r3, [r4, #0]
34020efa:	b11d      	cbz	r5, 34020f04 <_printf_i+0x19c>
34020efc:	2310      	movs	r3, #16
34020efe:	e7ad      	b.n	34020e5c <_printf_i+0xf4>
34020f00:	4826      	ldr	r0, [pc, #152]	@ (34020f9c <_printf_i+0x234>)
34020f02:	e7e9      	b.n	34020ed8 <_printf_i+0x170>
34020f04:	6823      	ldr	r3, [r4, #0]
34020f06:	f023 0320 	bic.w	r3, r3, #32
34020f0a:	6023      	str	r3, [r4, #0]
34020f0c:	e7f6      	b.n	34020efc <_printf_i+0x194>
34020f0e:	4616      	mov	r6, r2
34020f10:	e7bd      	b.n	34020e8e <_printf_i+0x126>
34020f12:	6833      	ldr	r3, [r6, #0]
34020f14:	6825      	ldr	r5, [r4, #0]
34020f16:	1d18      	adds	r0, r3, #4
34020f18:	6961      	ldr	r1, [r4, #20]
34020f1a:	6030      	str	r0, [r6, #0]
34020f1c:	062e      	lsls	r6, r5, #24
34020f1e:	681b      	ldr	r3, [r3, #0]
34020f20:	d501      	bpl.n	34020f26 <_printf_i+0x1be>
34020f22:	6019      	str	r1, [r3, #0]
34020f24:	e002      	b.n	34020f2c <_printf_i+0x1c4>
34020f26:	0668      	lsls	r0, r5, #25
34020f28:	d5fb      	bpl.n	34020f22 <_printf_i+0x1ba>
34020f2a:	8019      	strh	r1, [r3, #0]
34020f2c:	2300      	movs	r3, #0
34020f2e:	4616      	mov	r6, r2
34020f30:	6123      	str	r3, [r4, #16]
34020f32:	e7bc      	b.n	34020eae <_printf_i+0x146>
34020f34:	6833      	ldr	r3, [r6, #0]
34020f36:	2100      	movs	r1, #0
34020f38:	1d1a      	adds	r2, r3, #4
34020f3a:	6032      	str	r2, [r6, #0]
34020f3c:	681e      	ldr	r6, [r3, #0]
34020f3e:	6862      	ldr	r2, [r4, #4]
34020f40:	4630      	mov	r0, r6
34020f42:	f000 fdc8 	bl	34021ad6 <memchr>
34020f46:	b108      	cbz	r0, 34020f4c <_printf_i+0x1e4>
34020f48:	1b80      	subs	r0, r0, r6
34020f4a:	6060      	str	r0, [r4, #4]
34020f4c:	6863      	ldr	r3, [r4, #4]
34020f4e:	6123      	str	r3, [r4, #16]
34020f50:	2300      	movs	r3, #0
34020f52:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34020f56:	e7aa      	b.n	34020eae <_printf_i+0x146>
34020f58:	6923      	ldr	r3, [r4, #16]
34020f5a:	4632      	mov	r2, r6
34020f5c:	4649      	mov	r1, r9
34020f5e:	4640      	mov	r0, r8
34020f60:	47d0      	blx	sl
34020f62:	3001      	adds	r0, #1
34020f64:	d0ad      	beq.n	34020ec2 <_printf_i+0x15a>
34020f66:	6823      	ldr	r3, [r4, #0]
34020f68:	079b      	lsls	r3, r3, #30
34020f6a:	d413      	bmi.n	34020f94 <_printf_i+0x22c>
34020f6c:	68e0      	ldr	r0, [r4, #12]
34020f6e:	9b03      	ldr	r3, [sp, #12]
34020f70:	4298      	cmp	r0, r3
34020f72:	bfb8      	it	lt
34020f74:	4618      	movlt	r0, r3
34020f76:	e7a6      	b.n	34020ec6 <_printf_i+0x15e>
34020f78:	2301      	movs	r3, #1
34020f7a:	4632      	mov	r2, r6
34020f7c:	4649      	mov	r1, r9
34020f7e:	4640      	mov	r0, r8
34020f80:	47d0      	blx	sl
34020f82:	3001      	adds	r0, #1
34020f84:	d09d      	beq.n	34020ec2 <_printf_i+0x15a>
34020f86:	3501      	adds	r5, #1
34020f88:	68e3      	ldr	r3, [r4, #12]
34020f8a:	9903      	ldr	r1, [sp, #12]
34020f8c:	1a5b      	subs	r3, r3, r1
34020f8e:	42ab      	cmp	r3, r5
34020f90:	dcf2      	bgt.n	34020f78 <_printf_i+0x210>
34020f92:	e7eb      	b.n	34020f6c <_printf_i+0x204>
34020f94:	2500      	movs	r5, #0
34020f96:	f104 0619 	add.w	r6, r4, #25
34020f9a:	e7f5      	b.n	34020f88 <_printf_i+0x220>
34020f9c:	3403329c 	.word	0x3403329c
34020fa0:	340332ad 	.word	0x340332ad

34020fa4 <__sflush_r>:
34020fa4:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
34020fa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34020fac:	0716      	lsls	r6, r2, #28
34020fae:	4605      	mov	r5, r0
34020fb0:	460c      	mov	r4, r1
34020fb2:	d454      	bmi.n	3402105e <__sflush_r+0xba>
34020fb4:	684b      	ldr	r3, [r1, #4]
34020fb6:	2b00      	cmp	r3, #0
34020fb8:	dc02      	bgt.n	34020fc0 <__sflush_r+0x1c>
34020fba:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
34020fbc:	2b00      	cmp	r3, #0
34020fbe:	dd48      	ble.n	34021052 <__sflush_r+0xae>
34020fc0:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
34020fc2:	2e00      	cmp	r6, #0
34020fc4:	d045      	beq.n	34021052 <__sflush_r+0xae>
34020fc6:	2300      	movs	r3, #0
34020fc8:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
34020fcc:	682f      	ldr	r7, [r5, #0]
34020fce:	6a21      	ldr	r1, [r4, #32]
34020fd0:	602b      	str	r3, [r5, #0]
34020fd2:	d030      	beq.n	34021036 <__sflush_r+0x92>
34020fd4:	6d62      	ldr	r2, [r4, #84]	@ 0x54
34020fd6:	89a3      	ldrh	r3, [r4, #12]
34020fd8:	0759      	lsls	r1, r3, #29
34020fda:	d505      	bpl.n	34020fe8 <__sflush_r+0x44>
34020fdc:	6863      	ldr	r3, [r4, #4]
34020fde:	1ad2      	subs	r2, r2, r3
34020fe0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
34020fe2:	b10b      	cbz	r3, 34020fe8 <__sflush_r+0x44>
34020fe4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34020fe6:	1ad2      	subs	r2, r2, r3
34020fe8:	2300      	movs	r3, #0
34020fea:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
34020fec:	6a21      	ldr	r1, [r4, #32]
34020fee:	4628      	mov	r0, r5
34020ff0:	47b0      	blx	r6
34020ff2:	1c43      	adds	r3, r0, #1
34020ff4:	89a3      	ldrh	r3, [r4, #12]
34020ff6:	d106      	bne.n	34021006 <__sflush_r+0x62>
34020ff8:	6829      	ldr	r1, [r5, #0]
34020ffa:	291d      	cmp	r1, #29
34020ffc:	d82b      	bhi.n	34021056 <__sflush_r+0xb2>
34020ffe:	4a2a      	ldr	r2, [pc, #168]	@ (340210a8 <__sflush_r+0x104>)
34021000:	40ca      	lsrs	r2, r1
34021002:	07d6      	lsls	r6, r2, #31
34021004:	d527      	bpl.n	34021056 <__sflush_r+0xb2>
34021006:	2200      	movs	r2, #0
34021008:	04d9      	lsls	r1, r3, #19
3402100a:	6062      	str	r2, [r4, #4]
3402100c:	6922      	ldr	r2, [r4, #16]
3402100e:	6022      	str	r2, [r4, #0]
34021010:	d504      	bpl.n	3402101c <__sflush_r+0x78>
34021012:	1c42      	adds	r2, r0, #1
34021014:	d101      	bne.n	3402101a <__sflush_r+0x76>
34021016:	682b      	ldr	r3, [r5, #0]
34021018:	b903      	cbnz	r3, 3402101c <__sflush_r+0x78>
3402101a:	6560      	str	r0, [r4, #84]	@ 0x54
3402101c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3402101e:	602f      	str	r7, [r5, #0]
34021020:	b1b9      	cbz	r1, 34021052 <__sflush_r+0xae>
34021022:	f104 0344 	add.w	r3, r4, #68	@ 0x44
34021026:	4299      	cmp	r1, r3
34021028:	d002      	beq.n	34021030 <__sflush_r+0x8c>
3402102a:	4628      	mov	r0, r5
3402102c:	f001 fb62 	bl	340226f4 <_free_r>
34021030:	2300      	movs	r3, #0
34021032:	6363      	str	r3, [r4, #52]	@ 0x34
34021034:	e00d      	b.n	34021052 <__sflush_r+0xae>
34021036:	2301      	movs	r3, #1
34021038:	4628      	mov	r0, r5
3402103a:	47b0      	blx	r6
3402103c:	4602      	mov	r2, r0
3402103e:	1c50      	adds	r0, r2, #1
34021040:	d1c9      	bne.n	34020fd6 <__sflush_r+0x32>
34021042:	682b      	ldr	r3, [r5, #0]
34021044:	2b00      	cmp	r3, #0
34021046:	d0c6      	beq.n	34020fd6 <__sflush_r+0x32>
34021048:	2b1d      	cmp	r3, #29
3402104a:	d001      	beq.n	34021050 <__sflush_r+0xac>
3402104c:	2b16      	cmp	r3, #22
3402104e:	d11d      	bne.n	3402108c <__sflush_r+0xe8>
34021050:	602f      	str	r7, [r5, #0]
34021052:	2000      	movs	r0, #0
34021054:	e021      	b.n	3402109a <__sflush_r+0xf6>
34021056:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3402105a:	b21b      	sxth	r3, r3
3402105c:	e01a      	b.n	34021094 <__sflush_r+0xf0>
3402105e:	690f      	ldr	r7, [r1, #16]
34021060:	2f00      	cmp	r7, #0
34021062:	d0f6      	beq.n	34021052 <__sflush_r+0xae>
34021064:	0793      	lsls	r3, r2, #30
34021066:	680e      	ldr	r6, [r1, #0]
34021068:	600f      	str	r7, [r1, #0]
3402106a:	bf0c      	ite	eq
3402106c:	694b      	ldreq	r3, [r1, #20]
3402106e:	2300      	movne	r3, #0
34021070:	eba6 0807 	sub.w	r8, r6, r7
34021074:	608b      	str	r3, [r1, #8]
34021076:	f1b8 0f00 	cmp.w	r8, #0
3402107a:	ddea      	ble.n	34021052 <__sflush_r+0xae>
3402107c:	4643      	mov	r3, r8
3402107e:	463a      	mov	r2, r7
34021080:	6a21      	ldr	r1, [r4, #32]
34021082:	4628      	mov	r0, r5
34021084:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
34021086:	47b0      	blx	r6
34021088:	2800      	cmp	r0, #0
3402108a:	dc08      	bgt.n	3402109e <__sflush_r+0xfa>
3402108c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34021090:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34021094:	f04f 30ff 	mov.w	r0, #4294967295
34021098:	81a3      	strh	r3, [r4, #12]
3402109a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3402109e:	4407      	add	r7, r0
340210a0:	eba8 0800 	sub.w	r8, r8, r0
340210a4:	e7e7      	b.n	34021076 <__sflush_r+0xd2>
340210a6:	bf00      	nop
340210a8:	20400001 	.word	0x20400001

340210ac <_fflush_r>:
340210ac:	b538      	push	{r3, r4, r5, lr}
340210ae:	690b      	ldr	r3, [r1, #16]
340210b0:	4605      	mov	r5, r0
340210b2:	460c      	mov	r4, r1
340210b4:	b913      	cbnz	r3, 340210bc <_fflush_r+0x10>
340210b6:	2500      	movs	r5, #0
340210b8:	4628      	mov	r0, r5
340210ba:	bd38      	pop	{r3, r4, r5, pc}
340210bc:	b118      	cbz	r0, 340210c6 <_fflush_r+0x1a>
340210be:	6a03      	ldr	r3, [r0, #32]
340210c0:	b90b      	cbnz	r3, 340210c6 <_fflush_r+0x1a>
340210c2:	f000 f8a7 	bl	34021214 <__sinit>
340210c6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
340210ca:	2b00      	cmp	r3, #0
340210cc:	d0f3      	beq.n	340210b6 <_fflush_r+0xa>
340210ce:	6e62      	ldr	r2, [r4, #100]	@ 0x64
340210d0:	07d0      	lsls	r0, r2, #31
340210d2:	d404      	bmi.n	340210de <_fflush_r+0x32>
340210d4:	0599      	lsls	r1, r3, #22
340210d6:	d402      	bmi.n	340210de <_fflush_r+0x32>
340210d8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340210da:	f000 fcfa 	bl	34021ad2 <__retarget_lock_acquire_recursive>
340210de:	4628      	mov	r0, r5
340210e0:	4621      	mov	r1, r4
340210e2:	f7ff ff5f 	bl	34020fa4 <__sflush_r>
340210e6:	6e63      	ldr	r3, [r4, #100]	@ 0x64
340210e8:	4605      	mov	r5, r0
340210ea:	07da      	lsls	r2, r3, #31
340210ec:	d4e4      	bmi.n	340210b8 <_fflush_r+0xc>
340210ee:	89a3      	ldrh	r3, [r4, #12]
340210f0:	059b      	lsls	r3, r3, #22
340210f2:	d4e1      	bmi.n	340210b8 <_fflush_r+0xc>
340210f4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340210f6:	f000 fced 	bl	34021ad4 <__retarget_lock_release_recursive>
340210fa:	e7dd      	b.n	340210b8 <_fflush_r+0xc>

340210fc <std>:
340210fc:	2300      	movs	r3, #0
340210fe:	b510      	push	{r4, lr}
34021100:	4604      	mov	r4, r0
34021102:	6083      	str	r3, [r0, #8]
34021104:	8181      	strh	r1, [r0, #12]
34021106:	4619      	mov	r1, r3
34021108:	6643      	str	r3, [r0, #100]	@ 0x64
3402110a:	81c2      	strh	r2, [r0, #14]
3402110c:	2208      	movs	r2, #8
3402110e:	6183      	str	r3, [r0, #24]
34021110:	e9c0 3300 	strd	r3, r3, [r0]
34021114:	e9c0 3304 	strd	r3, r3, [r0, #16]
34021118:	305c      	adds	r0, #92	@ 0x5c
3402111a:	f000 fa5b 	bl	340215d4 <memset>
3402111e:	4b0d      	ldr	r3, [pc, #52]	@ (34021154 <std+0x58>)
34021120:	6224      	str	r4, [r4, #32]
34021122:	6263      	str	r3, [r4, #36]	@ 0x24
34021124:	4b0c      	ldr	r3, [pc, #48]	@ (34021158 <std+0x5c>)
34021126:	62a3      	str	r3, [r4, #40]	@ 0x28
34021128:	4b0c      	ldr	r3, [pc, #48]	@ (3402115c <std+0x60>)
3402112a:	62e3      	str	r3, [r4, #44]	@ 0x2c
3402112c:	4b0c      	ldr	r3, [pc, #48]	@ (34021160 <std+0x64>)
3402112e:	6323      	str	r3, [r4, #48]	@ 0x30
34021130:	4b0c      	ldr	r3, [pc, #48]	@ (34021164 <std+0x68>)
34021132:	429c      	cmp	r4, r3
34021134:	d006      	beq.n	34021144 <std+0x48>
34021136:	f103 0268 	add.w	r2, r3, #104	@ 0x68
3402113a:	4294      	cmp	r4, r2
3402113c:	d002      	beq.n	34021144 <std+0x48>
3402113e:	33d0      	adds	r3, #208	@ 0xd0
34021140:	429c      	cmp	r4, r3
34021142:	d105      	bne.n	34021150 <std+0x54>
34021144:	f104 0058 	add.w	r0, r4, #88	@ 0x58
34021148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3402114c:	f000 bcc0 	b.w	34021ad0 <__retarget_lock_init_recursive>
34021150:	bd10      	pop	{r4, pc}
34021152:	bf00      	nop
34021154:	340213f1 	.word	0x340213f1
34021158:	34021413 	.word	0x34021413
3402115c:	3402144b 	.word	0x3402144b
34021160:	3402146f 	.word	0x3402146f
34021164:	34053dc4 	.word	0x34053dc4

34021168 <stdio_exit_handler>:
34021168:	4a02      	ldr	r2, [pc, #8]	@ (34021174 <stdio_exit_handler+0xc>)
3402116a:	4903      	ldr	r1, [pc, #12]	@ (34021178 <stdio_exit_handler+0x10>)
3402116c:	4803      	ldr	r0, [pc, #12]	@ (3402117c <stdio_exit_handler+0x14>)
3402116e:	f000 b87b 	b.w	34021268 <_fwalk_sglue>
34021172:	bf00      	nop
34021174:	34033f5c 	.word	0x34033f5c
34021178:	340210ad 	.word	0x340210ad
3402117c:	34033f6c 	.word	0x34033f6c

34021180 <cleanup_stdio>:
34021180:	6841      	ldr	r1, [r0, #4]
34021182:	4b0c      	ldr	r3, [pc, #48]	@ (340211b4 <cleanup_stdio+0x34>)
34021184:	4299      	cmp	r1, r3
34021186:	b510      	push	{r4, lr}
34021188:	4604      	mov	r4, r0
3402118a:	d001      	beq.n	34021190 <cleanup_stdio+0x10>
3402118c:	f7ff ff8e 	bl	340210ac <_fflush_r>
34021190:	68a1      	ldr	r1, [r4, #8]
34021192:	4b09      	ldr	r3, [pc, #36]	@ (340211b8 <cleanup_stdio+0x38>)
34021194:	4299      	cmp	r1, r3
34021196:	d002      	beq.n	3402119e <cleanup_stdio+0x1e>
34021198:	4620      	mov	r0, r4
3402119a:	f7ff ff87 	bl	340210ac <_fflush_r>
3402119e:	68e1      	ldr	r1, [r4, #12]
340211a0:	4b06      	ldr	r3, [pc, #24]	@ (340211bc <cleanup_stdio+0x3c>)
340211a2:	4299      	cmp	r1, r3
340211a4:	d004      	beq.n	340211b0 <cleanup_stdio+0x30>
340211a6:	4620      	mov	r0, r4
340211a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
340211ac:	f7ff bf7e 	b.w	340210ac <_fflush_r>
340211b0:	bd10      	pop	{r4, pc}
340211b2:	bf00      	nop
340211b4:	34053dc4 	.word	0x34053dc4
340211b8:	34053e2c 	.word	0x34053e2c
340211bc:	34053e94 	.word	0x34053e94

340211c0 <global_stdio_init.part.0>:
340211c0:	b510      	push	{r4, lr}
340211c2:	4b0b      	ldr	r3, [pc, #44]	@ (340211f0 <global_stdio_init.part.0+0x30>)
340211c4:	2104      	movs	r1, #4
340211c6:	4c0b      	ldr	r4, [pc, #44]	@ (340211f4 <global_stdio_init.part.0+0x34>)
340211c8:	4a0b      	ldr	r2, [pc, #44]	@ (340211f8 <global_stdio_init.part.0+0x38>)
340211ca:	4620      	mov	r0, r4
340211cc:	601a      	str	r2, [r3, #0]
340211ce:	2200      	movs	r2, #0
340211d0:	f7ff ff94 	bl	340210fc <std>
340211d4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
340211d8:	2201      	movs	r2, #1
340211da:	2109      	movs	r1, #9
340211dc:	f7ff ff8e 	bl	340210fc <std>
340211e0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
340211e4:	2202      	movs	r2, #2
340211e6:	2112      	movs	r1, #18
340211e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
340211ec:	f7ff bf86 	b.w	340210fc <std>
340211f0:	34053efc 	.word	0x34053efc
340211f4:	34053dc4 	.word	0x34053dc4
340211f8:	34021169 	.word	0x34021169

340211fc <__sfp_lock_acquire>:
340211fc:	4801      	ldr	r0, [pc, #4]	@ (34021204 <__sfp_lock_acquire+0x8>)
340211fe:	f000 bc68 	b.w	34021ad2 <__retarget_lock_acquire_recursive>
34021202:	bf00      	nop
34021204:	34053f05 	.word	0x34053f05

34021208 <__sfp_lock_release>:
34021208:	4801      	ldr	r0, [pc, #4]	@ (34021210 <__sfp_lock_release+0x8>)
3402120a:	f000 bc63 	b.w	34021ad4 <__retarget_lock_release_recursive>
3402120e:	bf00      	nop
34021210:	34053f05 	.word	0x34053f05

34021214 <__sinit>:
34021214:	b510      	push	{r4, lr}
34021216:	4604      	mov	r4, r0
34021218:	f7ff fff0 	bl	340211fc <__sfp_lock_acquire>
3402121c:	6a23      	ldr	r3, [r4, #32]
3402121e:	b11b      	cbz	r3, 34021228 <__sinit+0x14>
34021220:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34021224:	f7ff bff0 	b.w	34021208 <__sfp_lock_release>
34021228:	4b04      	ldr	r3, [pc, #16]	@ (3402123c <__sinit+0x28>)
3402122a:	6223      	str	r3, [r4, #32]
3402122c:	4b04      	ldr	r3, [pc, #16]	@ (34021240 <__sinit+0x2c>)
3402122e:	681b      	ldr	r3, [r3, #0]
34021230:	2b00      	cmp	r3, #0
34021232:	d1f5      	bne.n	34021220 <__sinit+0xc>
34021234:	f7ff ffc4 	bl	340211c0 <global_stdio_init.part.0>
34021238:	e7f2      	b.n	34021220 <__sinit+0xc>
3402123a:	bf00      	nop
3402123c:	34021181 	.word	0x34021181
34021240:	34053efc 	.word	0x34053efc

34021244 <fiprintf>:
34021244:	b40e      	push	{r1, r2, r3}
34021246:	b503      	push	{r0, r1, lr}
34021248:	ab03      	add	r3, sp, #12
3402124a:	4601      	mov	r1, r0
3402124c:	4805      	ldr	r0, [pc, #20]	@ (34021264 <fiprintf+0x20>)
3402124e:	f853 2b04 	ldr.w	r2, [r3], #4
34021252:	6800      	ldr	r0, [r0, #0]
34021254:	9301      	str	r3, [sp, #4]
34021256:	f001 ffa3 	bl	340231a0 <_vfiprintf_r>
3402125a:	b002      	add	sp, #8
3402125c:	f85d eb04 	ldr.w	lr, [sp], #4
34021260:	b003      	add	sp, #12
34021262:	4770      	bx	lr
34021264:	34033f68 	.word	0x34033f68

34021268 <_fwalk_sglue>:
34021268:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3402126c:	4607      	mov	r7, r0
3402126e:	4688      	mov	r8, r1
34021270:	4614      	mov	r4, r2
34021272:	2600      	movs	r6, #0
34021274:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
34021278:	f1b9 0901 	subs.w	r9, r9, #1
3402127c:	d505      	bpl.n	3402128a <_fwalk_sglue+0x22>
3402127e:	6824      	ldr	r4, [r4, #0]
34021280:	2c00      	cmp	r4, #0
34021282:	d1f7      	bne.n	34021274 <_fwalk_sglue+0xc>
34021284:	4630      	mov	r0, r6
34021286:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3402128a:	89ab      	ldrh	r3, [r5, #12]
3402128c:	2b01      	cmp	r3, #1
3402128e:	d907      	bls.n	340212a0 <_fwalk_sglue+0x38>
34021290:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
34021294:	3301      	adds	r3, #1
34021296:	d003      	beq.n	340212a0 <_fwalk_sglue+0x38>
34021298:	4629      	mov	r1, r5
3402129a:	4638      	mov	r0, r7
3402129c:	47c0      	blx	r8
3402129e:	4306      	orrs	r6, r0
340212a0:	3568      	adds	r5, #104	@ 0x68
340212a2:	e7e9      	b.n	34021278 <_fwalk_sglue+0x10>

340212a4 <iprintf>:
340212a4:	b40f      	push	{r0, r1, r2, r3}
340212a6:	b507      	push	{r0, r1, r2, lr}
340212a8:	4906      	ldr	r1, [pc, #24]	@ (340212c4 <iprintf+0x20>)
340212aa:	ab04      	add	r3, sp, #16
340212ac:	6808      	ldr	r0, [r1, #0]
340212ae:	f853 2b04 	ldr.w	r2, [r3], #4
340212b2:	6881      	ldr	r1, [r0, #8]
340212b4:	9301      	str	r3, [sp, #4]
340212b6:	f001 ff73 	bl	340231a0 <_vfiprintf_r>
340212ba:	b003      	add	sp, #12
340212bc:	f85d eb04 	ldr.w	lr, [sp], #4
340212c0:	b004      	add	sp, #16
340212c2:	4770      	bx	lr
340212c4:	34033f68 	.word	0x34033f68

340212c8 <_puts_r>:
340212c8:	6a03      	ldr	r3, [r0, #32]
340212ca:	b570      	push	{r4, r5, r6, lr}
340212cc:	4605      	mov	r5, r0
340212ce:	460e      	mov	r6, r1
340212d0:	6884      	ldr	r4, [r0, #8]
340212d2:	b90b      	cbnz	r3, 340212d8 <_puts_r+0x10>
340212d4:	f7ff ff9e 	bl	34021214 <__sinit>
340212d8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
340212da:	07db      	lsls	r3, r3, #31
340212dc:	d405      	bmi.n	340212ea <_puts_r+0x22>
340212de:	89a3      	ldrh	r3, [r4, #12]
340212e0:	0598      	lsls	r0, r3, #22
340212e2:	d402      	bmi.n	340212ea <_puts_r+0x22>
340212e4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340212e6:	f000 fbf4 	bl	34021ad2 <__retarget_lock_acquire_recursive>
340212ea:	89a3      	ldrh	r3, [r4, #12]
340212ec:	0719      	lsls	r1, r3, #28
340212ee:	d502      	bpl.n	340212f6 <_puts_r+0x2e>
340212f0:	6923      	ldr	r3, [r4, #16]
340212f2:	2b00      	cmp	r3, #0
340212f4:	d135      	bne.n	34021362 <_puts_r+0x9a>
340212f6:	4621      	mov	r1, r4
340212f8:	4628      	mov	r0, r5
340212fa:	f000 f8fb 	bl	340214f4 <__swsetup_r>
340212fe:	b380      	cbz	r0, 34021362 <_puts_r+0x9a>
34021300:	f04f 35ff 	mov.w	r5, #4294967295
34021304:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34021306:	07da      	lsls	r2, r3, #31
34021308:	d405      	bmi.n	34021316 <_puts_r+0x4e>
3402130a:	89a3      	ldrh	r3, [r4, #12]
3402130c:	059b      	lsls	r3, r3, #22
3402130e:	d402      	bmi.n	34021316 <_puts_r+0x4e>
34021310:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34021312:	f000 fbdf 	bl	34021ad4 <__retarget_lock_release_recursive>
34021316:	4628      	mov	r0, r5
34021318:	bd70      	pop	{r4, r5, r6, pc}
3402131a:	2b00      	cmp	r3, #0
3402131c:	da04      	bge.n	34021328 <_puts_r+0x60>
3402131e:	69a2      	ldr	r2, [r4, #24]
34021320:	429a      	cmp	r2, r3
34021322:	dc17      	bgt.n	34021354 <_puts_r+0x8c>
34021324:	290a      	cmp	r1, #10
34021326:	d015      	beq.n	34021354 <_puts_r+0x8c>
34021328:	6823      	ldr	r3, [r4, #0]
3402132a:	1c5a      	adds	r2, r3, #1
3402132c:	6022      	str	r2, [r4, #0]
3402132e:	7019      	strb	r1, [r3, #0]
34021330:	68a3      	ldr	r3, [r4, #8]
34021332:	f816 1f01 	ldrb.w	r1, [r6, #1]!
34021336:	3b01      	subs	r3, #1
34021338:	60a3      	str	r3, [r4, #8]
3402133a:	2900      	cmp	r1, #0
3402133c:	d1ed      	bne.n	3402131a <_puts_r+0x52>
3402133e:	2b00      	cmp	r3, #0
34021340:	da11      	bge.n	34021366 <_puts_r+0x9e>
34021342:	4622      	mov	r2, r4
34021344:	210a      	movs	r1, #10
34021346:	4628      	mov	r0, r5
34021348:	f000 f895 	bl	34021476 <__swbuf_r>
3402134c:	3001      	adds	r0, #1
3402134e:	d0d7      	beq.n	34021300 <_puts_r+0x38>
34021350:	250a      	movs	r5, #10
34021352:	e7d7      	b.n	34021304 <_puts_r+0x3c>
34021354:	4622      	mov	r2, r4
34021356:	4628      	mov	r0, r5
34021358:	f000 f88d 	bl	34021476 <__swbuf_r>
3402135c:	3001      	adds	r0, #1
3402135e:	d1e7      	bne.n	34021330 <_puts_r+0x68>
34021360:	e7ce      	b.n	34021300 <_puts_r+0x38>
34021362:	3e01      	subs	r6, #1
34021364:	e7e4      	b.n	34021330 <_puts_r+0x68>
34021366:	6823      	ldr	r3, [r4, #0]
34021368:	1c5a      	adds	r2, r3, #1
3402136a:	6022      	str	r2, [r4, #0]
3402136c:	220a      	movs	r2, #10
3402136e:	701a      	strb	r2, [r3, #0]
34021370:	e7ee      	b.n	34021350 <_puts_r+0x88>
	...

34021374 <puts>:
34021374:	4b02      	ldr	r3, [pc, #8]	@ (34021380 <puts+0xc>)
34021376:	4601      	mov	r1, r0
34021378:	6818      	ldr	r0, [r3, #0]
3402137a:	f7ff bfa5 	b.w	340212c8 <_puts_r>
3402137e:	bf00      	nop
34021380:	34033f68 	.word	0x34033f68

34021384 <sniprintf>:
34021384:	b40c      	push	{r2, r3}
34021386:	4b19      	ldr	r3, [pc, #100]	@ (340213ec <sniprintf+0x68>)
34021388:	b530      	push	{r4, r5, lr}
3402138a:	1e0c      	subs	r4, r1, #0
3402138c:	b09d      	sub	sp, #116	@ 0x74
3402138e:	681d      	ldr	r5, [r3, #0]
34021390:	da08      	bge.n	340213a4 <sniprintf+0x20>
34021392:	238b      	movs	r3, #139	@ 0x8b
34021394:	f04f 30ff 	mov.w	r0, #4294967295
34021398:	602b      	str	r3, [r5, #0]
3402139a:	b01d      	add	sp, #116	@ 0x74
3402139c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
340213a0:	b002      	add	sp, #8
340213a2:	4770      	bx	lr
340213a4:	f44f 7302 	mov.w	r3, #520	@ 0x208
340213a8:	9002      	str	r0, [sp, #8]
340213aa:	9006      	str	r0, [sp, #24]
340213ac:	a902      	add	r1, sp, #8
340213ae:	f8ad 3014 	strh.w	r3, [sp, #20]
340213b2:	f04f 0300 	mov.w	r3, #0
340213b6:	9a20      	ldr	r2, [sp, #128]	@ 0x80
340213b8:	4628      	mov	r0, r5
340213ba:	931b      	str	r3, [sp, #108]	@ 0x6c
340213bc:	bf14      	ite	ne
340213be:	f104 33ff 	addne.w	r3, r4, #4294967295
340213c2:	4623      	moveq	r3, r4
340213c4:	9304      	str	r3, [sp, #16]
340213c6:	9307      	str	r3, [sp, #28]
340213c8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
340213cc:	f8ad 3016 	strh.w	r3, [sp, #22]
340213d0:	ab21      	add	r3, sp, #132	@ 0x84
340213d2:	9301      	str	r3, [sp, #4]
340213d4:	f001 fdbe 	bl	34022f54 <_svfiprintf_r>
340213d8:	1c43      	adds	r3, r0, #1
340213da:	bfbc      	itt	lt
340213dc:	238b      	movlt	r3, #139	@ 0x8b
340213de:	602b      	strlt	r3, [r5, #0]
340213e0:	2c00      	cmp	r4, #0
340213e2:	d0da      	beq.n	3402139a <sniprintf+0x16>
340213e4:	9b02      	ldr	r3, [sp, #8]
340213e6:	2200      	movs	r2, #0
340213e8:	701a      	strb	r2, [r3, #0]
340213ea:	e7d6      	b.n	3402139a <sniprintf+0x16>
340213ec:	34033f68 	.word	0x34033f68

340213f0 <__sread>:
340213f0:	b510      	push	{r4, lr}
340213f2:	460c      	mov	r4, r1
340213f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
340213f8:	f000 fb0c 	bl	34021a14 <_read_r>
340213fc:	2800      	cmp	r0, #0
340213fe:	bfab      	itete	ge
34021400:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
34021402:	89a3      	ldrhlt	r3, [r4, #12]
34021404:	181b      	addge	r3, r3, r0
34021406:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
3402140a:	bfac      	ite	ge
3402140c:	6563      	strge	r3, [r4, #84]	@ 0x54
3402140e:	81a3      	strhlt	r3, [r4, #12]
34021410:	bd10      	pop	{r4, pc}

34021412 <__swrite>:
34021412:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34021416:	461f      	mov	r7, r3
34021418:	898b      	ldrh	r3, [r1, #12]
3402141a:	4605      	mov	r5, r0
3402141c:	460c      	mov	r4, r1
3402141e:	05db      	lsls	r3, r3, #23
34021420:	4616      	mov	r6, r2
34021422:	d505      	bpl.n	34021430 <__swrite+0x1e>
34021424:	2302      	movs	r3, #2
34021426:	2200      	movs	r2, #0
34021428:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3402142c:	f000 fae0 	bl	340219f0 <_lseek_r>
34021430:	89a3      	ldrh	r3, [r4, #12]
34021432:	4632      	mov	r2, r6
34021434:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
34021438:	4628      	mov	r0, r5
3402143a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
3402143e:	81a3      	strh	r3, [r4, #12]
34021440:	463b      	mov	r3, r7
34021442:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34021446:	f000 bb07 	b.w	34021a58 <_write_r>

3402144a <__sseek>:
3402144a:	b510      	push	{r4, lr}
3402144c:	460c      	mov	r4, r1
3402144e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34021452:	f000 facd 	bl	340219f0 <_lseek_r>
34021456:	1c43      	adds	r3, r0, #1
34021458:	89a3      	ldrh	r3, [r4, #12]
3402145a:	bf15      	itete	ne
3402145c:	6560      	strne	r0, [r4, #84]	@ 0x54
3402145e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
34021462:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
34021466:	81a3      	strheq	r3, [r4, #12]
34021468:	bf18      	it	ne
3402146a:	81a3      	strhne	r3, [r4, #12]
3402146c:	bd10      	pop	{r4, pc}

3402146e <__sclose>:
3402146e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34021472:	f000 baad 	b.w	340219d0 <_close_r>

34021476 <__swbuf_r>:
34021476:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34021478:	460e      	mov	r6, r1
3402147a:	4614      	mov	r4, r2
3402147c:	4605      	mov	r5, r0
3402147e:	b118      	cbz	r0, 34021488 <__swbuf_r+0x12>
34021480:	6a03      	ldr	r3, [r0, #32]
34021482:	b90b      	cbnz	r3, 34021488 <__swbuf_r+0x12>
34021484:	f7ff fec6 	bl	34021214 <__sinit>
34021488:	69a3      	ldr	r3, [r4, #24]
3402148a:	60a3      	str	r3, [r4, #8]
3402148c:	89a3      	ldrh	r3, [r4, #12]
3402148e:	071a      	lsls	r2, r3, #28
34021490:	d501      	bpl.n	34021496 <__swbuf_r+0x20>
34021492:	6923      	ldr	r3, [r4, #16]
34021494:	b943      	cbnz	r3, 340214a8 <__swbuf_r+0x32>
34021496:	4621      	mov	r1, r4
34021498:	4628      	mov	r0, r5
3402149a:	f000 f82b 	bl	340214f4 <__swsetup_r>
3402149e:	b118      	cbz	r0, 340214a8 <__swbuf_r+0x32>
340214a0:	f04f 37ff 	mov.w	r7, #4294967295
340214a4:	4638      	mov	r0, r7
340214a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
340214a8:	6823      	ldr	r3, [r4, #0]
340214aa:	b2f6      	uxtb	r6, r6
340214ac:	6922      	ldr	r2, [r4, #16]
340214ae:	4637      	mov	r7, r6
340214b0:	1a98      	subs	r0, r3, r2
340214b2:	6963      	ldr	r3, [r4, #20]
340214b4:	4283      	cmp	r3, r0
340214b6:	dc05      	bgt.n	340214c4 <__swbuf_r+0x4e>
340214b8:	4621      	mov	r1, r4
340214ba:	4628      	mov	r0, r5
340214bc:	f7ff fdf6 	bl	340210ac <_fflush_r>
340214c0:	2800      	cmp	r0, #0
340214c2:	d1ed      	bne.n	340214a0 <__swbuf_r+0x2a>
340214c4:	68a3      	ldr	r3, [r4, #8]
340214c6:	3b01      	subs	r3, #1
340214c8:	60a3      	str	r3, [r4, #8]
340214ca:	6823      	ldr	r3, [r4, #0]
340214cc:	1c5a      	adds	r2, r3, #1
340214ce:	6022      	str	r2, [r4, #0]
340214d0:	701e      	strb	r6, [r3, #0]
340214d2:	1c43      	adds	r3, r0, #1
340214d4:	6962      	ldr	r2, [r4, #20]
340214d6:	429a      	cmp	r2, r3
340214d8:	d004      	beq.n	340214e4 <__swbuf_r+0x6e>
340214da:	89a3      	ldrh	r3, [r4, #12]
340214dc:	07db      	lsls	r3, r3, #31
340214de:	d5e1      	bpl.n	340214a4 <__swbuf_r+0x2e>
340214e0:	2e0a      	cmp	r6, #10
340214e2:	d1df      	bne.n	340214a4 <__swbuf_r+0x2e>
340214e4:	4621      	mov	r1, r4
340214e6:	4628      	mov	r0, r5
340214e8:	f7ff fde0 	bl	340210ac <_fflush_r>
340214ec:	2800      	cmp	r0, #0
340214ee:	d0d9      	beq.n	340214a4 <__swbuf_r+0x2e>
340214f0:	e7d6      	b.n	340214a0 <__swbuf_r+0x2a>
	...

340214f4 <__swsetup_r>:
340214f4:	b538      	push	{r3, r4, r5, lr}
340214f6:	4b29      	ldr	r3, [pc, #164]	@ (3402159c <__swsetup_r+0xa8>)
340214f8:	4605      	mov	r5, r0
340214fa:	460c      	mov	r4, r1
340214fc:	6818      	ldr	r0, [r3, #0]
340214fe:	b118      	cbz	r0, 34021508 <__swsetup_r+0x14>
34021500:	6a03      	ldr	r3, [r0, #32]
34021502:	b90b      	cbnz	r3, 34021508 <__swsetup_r+0x14>
34021504:	f7ff fe86 	bl	34021214 <__sinit>
34021508:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3402150c:	0719      	lsls	r1, r3, #28
3402150e:	d422      	bmi.n	34021556 <__swsetup_r+0x62>
34021510:	06da      	lsls	r2, r3, #27
34021512:	d407      	bmi.n	34021524 <__swsetup_r+0x30>
34021514:	2209      	movs	r2, #9
34021516:	602a      	str	r2, [r5, #0]
34021518:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3402151c:	f04f 30ff 	mov.w	r0, #4294967295
34021520:	81a3      	strh	r3, [r4, #12]
34021522:	e033      	b.n	3402158c <__swsetup_r+0x98>
34021524:	0758      	lsls	r0, r3, #29
34021526:	d512      	bpl.n	3402154e <__swsetup_r+0x5a>
34021528:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3402152a:	b141      	cbz	r1, 3402153e <__swsetup_r+0x4a>
3402152c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
34021530:	4299      	cmp	r1, r3
34021532:	d002      	beq.n	3402153a <__swsetup_r+0x46>
34021534:	4628      	mov	r0, r5
34021536:	f001 f8dd 	bl	340226f4 <_free_r>
3402153a:	2300      	movs	r3, #0
3402153c:	6363      	str	r3, [r4, #52]	@ 0x34
3402153e:	89a3      	ldrh	r3, [r4, #12]
34021540:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
34021544:	81a3      	strh	r3, [r4, #12]
34021546:	2300      	movs	r3, #0
34021548:	6063      	str	r3, [r4, #4]
3402154a:	6923      	ldr	r3, [r4, #16]
3402154c:	6023      	str	r3, [r4, #0]
3402154e:	89a3      	ldrh	r3, [r4, #12]
34021550:	f043 0308 	orr.w	r3, r3, #8
34021554:	81a3      	strh	r3, [r4, #12]
34021556:	6923      	ldr	r3, [r4, #16]
34021558:	b94b      	cbnz	r3, 3402156e <__swsetup_r+0x7a>
3402155a:	89a3      	ldrh	r3, [r4, #12]
3402155c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
34021560:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34021564:	d003      	beq.n	3402156e <__swsetup_r+0x7a>
34021566:	4621      	mov	r1, r4
34021568:	4628      	mov	r0, r5
3402156a:	f001 ff56 	bl	3402341a <__smakebuf_r>
3402156e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34021572:	f013 0201 	ands.w	r2, r3, #1
34021576:	d00a      	beq.n	3402158e <__swsetup_r+0x9a>
34021578:	2200      	movs	r2, #0
3402157a:	60a2      	str	r2, [r4, #8]
3402157c:	6962      	ldr	r2, [r4, #20]
3402157e:	4252      	negs	r2, r2
34021580:	61a2      	str	r2, [r4, #24]
34021582:	6922      	ldr	r2, [r4, #16]
34021584:	b942      	cbnz	r2, 34021598 <__swsetup_r+0xa4>
34021586:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
3402158a:	d1c5      	bne.n	34021518 <__swsetup_r+0x24>
3402158c:	bd38      	pop	{r3, r4, r5, pc}
3402158e:	0799      	lsls	r1, r3, #30
34021590:	bf58      	it	pl
34021592:	6962      	ldrpl	r2, [r4, #20]
34021594:	60a2      	str	r2, [r4, #8]
34021596:	e7f4      	b.n	34021582 <__swsetup_r+0x8e>
34021598:	2000      	movs	r0, #0
3402159a:	e7f7      	b.n	3402158c <__swsetup_r+0x98>
3402159c:	34033f68 	.word	0x34033f68

340215a0 <memmove>:
340215a0:	4288      	cmp	r0, r1
340215a2:	b510      	push	{r4, lr}
340215a4:	eb01 0402 	add.w	r4, r1, r2
340215a8:	d902      	bls.n	340215b0 <memmove+0x10>
340215aa:	4284      	cmp	r4, r0
340215ac:	4623      	mov	r3, r4
340215ae:	d807      	bhi.n	340215c0 <memmove+0x20>
340215b0:	1e43      	subs	r3, r0, #1
340215b2:	42a1      	cmp	r1, r4
340215b4:	d008      	beq.n	340215c8 <memmove+0x28>
340215b6:	f811 2b01 	ldrb.w	r2, [r1], #1
340215ba:	f803 2f01 	strb.w	r2, [r3, #1]!
340215be:	e7f8      	b.n	340215b2 <memmove+0x12>
340215c0:	4402      	add	r2, r0
340215c2:	4601      	mov	r1, r0
340215c4:	428a      	cmp	r2, r1
340215c6:	d100      	bne.n	340215ca <memmove+0x2a>
340215c8:	bd10      	pop	{r4, pc}
340215ca:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
340215ce:	f802 4d01 	strb.w	r4, [r2, #-1]!
340215d2:	e7f7      	b.n	340215c4 <memmove+0x24>

340215d4 <memset>:
340215d4:	4402      	add	r2, r0
340215d6:	4603      	mov	r3, r0
340215d8:	4293      	cmp	r3, r2
340215da:	d100      	bne.n	340215de <memset+0xa>
340215dc:	4770      	bx	lr
340215de:	f803 1b01 	strb.w	r1, [r3], #1
340215e2:	e7f9      	b.n	340215d8 <memset+0x4>

340215e4 <_strerror_r>:
340215e4:	b510      	push	{r4, lr}
340215e6:	4604      	mov	r4, r0
340215e8:	4608      	mov	r0, r1
340215ea:	4611      	mov	r1, r2
340215ec:	461a      	mov	r2, r3
340215ee:	288e      	cmp	r0, #142	@ 0x8e
340215f0:	f200 8130 	bhi.w	34021854 <_strerror_r+0x270>
340215f4:	e8df f010 	tbh	[pc, r0, lsl #1]
340215f8:	0138008f 	.word	0x0138008f
340215fc:	00940092 	.word	0x00940092
34021600:	00980096 	.word	0x00980096
34021604:	009c009a 	.word	0x009c009a
34021608:	00a2009e 	.word	0x00a2009e
3402160c:	00a800a4 	.word	0x00a800a4
34021610:	00ac00aa 	.word	0x00ac00aa
34021614:	012e00ae 	.word	0x012e00ae
34021618:	00b200b0 	.word	0x00b200b0
3402161c:	00b600b4 	.word	0x00b600b4
34021620:	00be00b8 	.word	0x00be00b8
34021624:	00c600c0 	.word	0x00c600c0
34021628:	00ca00c8 	.word	0x00ca00c8
3402162c:	00ce00cc 	.word	0x00ce00cc
34021630:	00d600d2 	.word	0x00d600d2
34021634:	00da00d8 	.word	0x00da00d8
34021638:	00de00dc 	.word	0x00de00dc
3402163c:	00e200e0 	.word	0x00e200e0
34021640:	012e00e4 	.word	0x012e00e4
34021644:	012e012e 	.word	0x012e012e
34021648:	012e012e 	.word	0x012e012e
3402164c:	012e012e 	.word	0x012e012e
34021650:	00e8012e 	.word	0x00e8012e
34021654:	012e00ec 	.word	0x012e00ec
34021658:	012e012e 	.word	0x012e012e
3402165c:	012e012e 	.word	0x012e012e
34021660:	012e012e 	.word	0x012e012e
34021664:	012e012e 	.word	0x012e012e
34021668:	012e012e 	.word	0x012e012e
3402166c:	012e012e 	.word	0x012e012e
34021670:	010800ee 	.word	0x010800ee
34021674:	00f200f0 	.word	0x00f200f0
34021678:	012e012e 	.word	0x012e012e
3402167c:	00f4012e 	.word	0x00f4012e
34021680:	012e012e 	.word	0x012e012e
34021684:	00f6012e 	.word	0x00f6012e
34021688:	012e012e 	.word	0x012e012e
3402168c:	012e00fa 	.word	0x012e00fa
34021690:	00fc012e 	.word	0x00fc012e
34021694:	012e012e 	.word	0x012e012e
34021698:	012e012e 	.word	0x012e012e
3402169c:	012e012e 	.word	0x012e012e
340216a0:	012e012e 	.word	0x012e012e
340216a4:	012e012e 	.word	0x012e012e
340216a8:	012e00fe 	.word	0x012e00fe
340216ac:	01020100 	.word	0x01020100
340216b0:	012e0104 	.word	0x012e0104
340216b4:	0126012e 	.word	0x0126012e
340216b8:	012e012e 	.word	0x012e012e
340216bc:	012e012e 	.word	0x012e012e
340216c0:	012e012e 	.word	0x012e012e
340216c4:	012e012e 	.word	0x012e012e
340216c8:	01060114 	.word	0x01060114
340216cc:	010c010a 	.word	0x010c010a
340216d0:	0110010e 	.word	0x0110010e
340216d4:	0112012e 	.word	0x0112012e
340216d8:	011a0116 	.word	0x011a0116
340216dc:	00c200ea 	.word	0x00c200ea
340216e0:	00ba012c 	.word	0x00ba012c
340216e4:	00bc00d0 	.word	0x00bc00d0
340216e8:	00a600a0 	.word	0x00a600a0
340216ec:	00f8012a 	.word	0x00f8012a
340216f0:	0118012e 	.word	0x0118012e
340216f4:	011e00c4 	.word	0x011e00c4
340216f8:	012e011c 	.word	0x012e011c
340216fc:	012e012e 	.word	0x012e012e
34021700:	012e012e 	.word	0x012e012e
34021704:	012e00d4 	.word	0x012e00d4
34021708:	012e012e 	.word	0x012e012e
3402170c:	012800e6 	.word	0x012800e6
34021710:	01220120 	.word	0x01220120
34021714:	0124      	.short	0x0124
34021716:	4b55      	ldr	r3, [pc, #340]	@ (3402186c <_strerror_r+0x288>)
34021718:	4618      	mov	r0, r3
3402171a:	bd10      	pop	{r4, pc}
3402171c:	4b54      	ldr	r3, [pc, #336]	@ (34021870 <_strerror_r+0x28c>)
3402171e:	e7fb      	b.n	34021718 <_strerror_r+0x134>
34021720:	4b54      	ldr	r3, [pc, #336]	@ (34021874 <_strerror_r+0x290>)
34021722:	e7f9      	b.n	34021718 <_strerror_r+0x134>
34021724:	4b54      	ldr	r3, [pc, #336]	@ (34021878 <_strerror_r+0x294>)
34021726:	e7f7      	b.n	34021718 <_strerror_r+0x134>
34021728:	4b54      	ldr	r3, [pc, #336]	@ (3402187c <_strerror_r+0x298>)
3402172a:	e7f5      	b.n	34021718 <_strerror_r+0x134>
3402172c:	4b54      	ldr	r3, [pc, #336]	@ (34021880 <_strerror_r+0x29c>)
3402172e:	e7f3      	b.n	34021718 <_strerror_r+0x134>
34021730:	4b54      	ldr	r3, [pc, #336]	@ (34021884 <_strerror_r+0x2a0>)
34021732:	e7f1      	b.n	34021718 <_strerror_r+0x134>
34021734:	4b54      	ldr	r3, [pc, #336]	@ (34021888 <_strerror_r+0x2a4>)
34021736:	e7ef      	b.n	34021718 <_strerror_r+0x134>
34021738:	4b54      	ldr	r3, [pc, #336]	@ (3402188c <_strerror_r+0x2a8>)
3402173a:	e7ed      	b.n	34021718 <_strerror_r+0x134>
3402173c:	4b54      	ldr	r3, [pc, #336]	@ (34021890 <_strerror_r+0x2ac>)
3402173e:	e7eb      	b.n	34021718 <_strerror_r+0x134>
34021740:	4b54      	ldr	r3, [pc, #336]	@ (34021894 <_strerror_r+0x2b0>)
34021742:	e7e9      	b.n	34021718 <_strerror_r+0x134>
34021744:	4b54      	ldr	r3, [pc, #336]	@ (34021898 <_strerror_r+0x2b4>)
34021746:	e7e7      	b.n	34021718 <_strerror_r+0x134>
34021748:	4b54      	ldr	r3, [pc, #336]	@ (3402189c <_strerror_r+0x2b8>)
3402174a:	e7e5      	b.n	34021718 <_strerror_r+0x134>
3402174c:	4b54      	ldr	r3, [pc, #336]	@ (340218a0 <_strerror_r+0x2bc>)
3402174e:	e7e3      	b.n	34021718 <_strerror_r+0x134>
34021750:	4b54      	ldr	r3, [pc, #336]	@ (340218a4 <_strerror_r+0x2c0>)
34021752:	e7e1      	b.n	34021718 <_strerror_r+0x134>
34021754:	4b54      	ldr	r3, [pc, #336]	@ (340218a8 <_strerror_r+0x2c4>)
34021756:	e7df      	b.n	34021718 <_strerror_r+0x134>
34021758:	4b54      	ldr	r3, [pc, #336]	@ (340218ac <_strerror_r+0x2c8>)
3402175a:	e7dd      	b.n	34021718 <_strerror_r+0x134>
3402175c:	4b54      	ldr	r3, [pc, #336]	@ (340218b0 <_strerror_r+0x2cc>)
3402175e:	e7db      	b.n	34021718 <_strerror_r+0x134>
34021760:	4b54      	ldr	r3, [pc, #336]	@ (340218b4 <_strerror_r+0x2d0>)
34021762:	e7d9      	b.n	34021718 <_strerror_r+0x134>
34021764:	4b54      	ldr	r3, [pc, #336]	@ (340218b8 <_strerror_r+0x2d4>)
34021766:	e7d7      	b.n	34021718 <_strerror_r+0x134>
34021768:	4b54      	ldr	r3, [pc, #336]	@ (340218bc <_strerror_r+0x2d8>)
3402176a:	e7d5      	b.n	34021718 <_strerror_r+0x134>
3402176c:	4b54      	ldr	r3, [pc, #336]	@ (340218c0 <_strerror_r+0x2dc>)
3402176e:	e7d3      	b.n	34021718 <_strerror_r+0x134>
34021770:	4b54      	ldr	r3, [pc, #336]	@ (340218c4 <_strerror_r+0x2e0>)
34021772:	e7d1      	b.n	34021718 <_strerror_r+0x134>
34021774:	4b54      	ldr	r3, [pc, #336]	@ (340218c8 <_strerror_r+0x2e4>)
34021776:	e7cf      	b.n	34021718 <_strerror_r+0x134>
34021778:	4b54      	ldr	r3, [pc, #336]	@ (340218cc <_strerror_r+0x2e8>)
3402177a:	e7cd      	b.n	34021718 <_strerror_r+0x134>
3402177c:	4b54      	ldr	r3, [pc, #336]	@ (340218d0 <_strerror_r+0x2ec>)
3402177e:	e7cb      	b.n	34021718 <_strerror_r+0x134>
34021780:	4b54      	ldr	r3, [pc, #336]	@ (340218d4 <_strerror_r+0x2f0>)
34021782:	e7c9      	b.n	34021718 <_strerror_r+0x134>
34021784:	4b54      	ldr	r3, [pc, #336]	@ (340218d8 <_strerror_r+0x2f4>)
34021786:	e7c7      	b.n	34021718 <_strerror_r+0x134>
34021788:	4b54      	ldr	r3, [pc, #336]	@ (340218dc <_strerror_r+0x2f8>)
3402178a:	e7c5      	b.n	34021718 <_strerror_r+0x134>
3402178c:	4b54      	ldr	r3, [pc, #336]	@ (340218e0 <_strerror_r+0x2fc>)
3402178e:	e7c3      	b.n	34021718 <_strerror_r+0x134>
34021790:	4b54      	ldr	r3, [pc, #336]	@ (340218e4 <_strerror_r+0x300>)
34021792:	e7c1      	b.n	34021718 <_strerror_r+0x134>
34021794:	4b54      	ldr	r3, [pc, #336]	@ (340218e8 <_strerror_r+0x304>)
34021796:	e7bf      	b.n	34021718 <_strerror_r+0x134>
34021798:	4b54      	ldr	r3, [pc, #336]	@ (340218ec <_strerror_r+0x308>)
3402179a:	e7bd      	b.n	34021718 <_strerror_r+0x134>
3402179c:	4b54      	ldr	r3, [pc, #336]	@ (340218f0 <_strerror_r+0x30c>)
3402179e:	e7bb      	b.n	34021718 <_strerror_r+0x134>
340217a0:	4b54      	ldr	r3, [pc, #336]	@ (340218f4 <_strerror_r+0x310>)
340217a2:	e7b9      	b.n	34021718 <_strerror_r+0x134>
340217a4:	4b54      	ldr	r3, [pc, #336]	@ (340218f8 <_strerror_r+0x314>)
340217a6:	e7b7      	b.n	34021718 <_strerror_r+0x134>
340217a8:	4b54      	ldr	r3, [pc, #336]	@ (340218fc <_strerror_r+0x318>)
340217aa:	e7b5      	b.n	34021718 <_strerror_r+0x134>
340217ac:	4b54      	ldr	r3, [pc, #336]	@ (34021900 <_strerror_r+0x31c>)
340217ae:	e7b3      	b.n	34021718 <_strerror_r+0x134>
340217b0:	4b54      	ldr	r3, [pc, #336]	@ (34021904 <_strerror_r+0x320>)
340217b2:	e7b1      	b.n	34021718 <_strerror_r+0x134>
340217b4:	4b54      	ldr	r3, [pc, #336]	@ (34021908 <_strerror_r+0x324>)
340217b6:	e7af      	b.n	34021718 <_strerror_r+0x134>
340217b8:	4b54      	ldr	r3, [pc, #336]	@ (3402190c <_strerror_r+0x328>)
340217ba:	e7ad      	b.n	34021718 <_strerror_r+0x134>
340217bc:	4b54      	ldr	r3, [pc, #336]	@ (34021910 <_strerror_r+0x32c>)
340217be:	e7ab      	b.n	34021718 <_strerror_r+0x134>
340217c0:	4b54      	ldr	r3, [pc, #336]	@ (34021914 <_strerror_r+0x330>)
340217c2:	e7a9      	b.n	34021718 <_strerror_r+0x134>
340217c4:	4b54      	ldr	r3, [pc, #336]	@ (34021918 <_strerror_r+0x334>)
340217c6:	e7a7      	b.n	34021718 <_strerror_r+0x134>
340217c8:	4b54      	ldr	r3, [pc, #336]	@ (3402191c <_strerror_r+0x338>)
340217ca:	e7a5      	b.n	34021718 <_strerror_r+0x134>
340217cc:	4b54      	ldr	r3, [pc, #336]	@ (34021920 <_strerror_r+0x33c>)
340217ce:	e7a3      	b.n	34021718 <_strerror_r+0x134>
340217d0:	4b54      	ldr	r3, [pc, #336]	@ (34021924 <_strerror_r+0x340>)
340217d2:	e7a1      	b.n	34021718 <_strerror_r+0x134>
340217d4:	4b54      	ldr	r3, [pc, #336]	@ (34021928 <_strerror_r+0x344>)
340217d6:	e79f      	b.n	34021718 <_strerror_r+0x134>
340217d8:	4b54      	ldr	r3, [pc, #336]	@ (3402192c <_strerror_r+0x348>)
340217da:	e79d      	b.n	34021718 <_strerror_r+0x134>
340217dc:	4b54      	ldr	r3, [pc, #336]	@ (34021930 <_strerror_r+0x34c>)
340217de:	e79b      	b.n	34021718 <_strerror_r+0x134>
340217e0:	4b54      	ldr	r3, [pc, #336]	@ (34021934 <_strerror_r+0x350>)
340217e2:	e799      	b.n	34021718 <_strerror_r+0x134>
340217e4:	4b54      	ldr	r3, [pc, #336]	@ (34021938 <_strerror_r+0x354>)
340217e6:	e797      	b.n	34021718 <_strerror_r+0x134>
340217e8:	4b54      	ldr	r3, [pc, #336]	@ (3402193c <_strerror_r+0x358>)
340217ea:	e795      	b.n	34021718 <_strerror_r+0x134>
340217ec:	4b54      	ldr	r3, [pc, #336]	@ (34021940 <_strerror_r+0x35c>)
340217ee:	e793      	b.n	34021718 <_strerror_r+0x134>
340217f0:	4b54      	ldr	r3, [pc, #336]	@ (34021944 <_strerror_r+0x360>)
340217f2:	e791      	b.n	34021718 <_strerror_r+0x134>
340217f4:	4b54      	ldr	r3, [pc, #336]	@ (34021948 <_strerror_r+0x364>)
340217f6:	e78f      	b.n	34021718 <_strerror_r+0x134>
340217f8:	4b54      	ldr	r3, [pc, #336]	@ (3402194c <_strerror_r+0x368>)
340217fa:	e78d      	b.n	34021718 <_strerror_r+0x134>
340217fc:	4b54      	ldr	r3, [pc, #336]	@ (34021950 <_strerror_r+0x36c>)
340217fe:	e78b      	b.n	34021718 <_strerror_r+0x134>
34021800:	4b54      	ldr	r3, [pc, #336]	@ (34021954 <_strerror_r+0x370>)
34021802:	e789      	b.n	34021718 <_strerror_r+0x134>
34021804:	4b54      	ldr	r3, [pc, #336]	@ (34021958 <_strerror_r+0x374>)
34021806:	e787      	b.n	34021718 <_strerror_r+0x134>
34021808:	4b54      	ldr	r3, [pc, #336]	@ (3402195c <_strerror_r+0x378>)
3402180a:	e785      	b.n	34021718 <_strerror_r+0x134>
3402180c:	4b54      	ldr	r3, [pc, #336]	@ (34021960 <_strerror_r+0x37c>)
3402180e:	e783      	b.n	34021718 <_strerror_r+0x134>
34021810:	4b54      	ldr	r3, [pc, #336]	@ (34021964 <_strerror_r+0x380>)
34021812:	e781      	b.n	34021718 <_strerror_r+0x134>
34021814:	4b54      	ldr	r3, [pc, #336]	@ (34021968 <_strerror_r+0x384>)
34021816:	e77f      	b.n	34021718 <_strerror_r+0x134>
34021818:	4b54      	ldr	r3, [pc, #336]	@ (3402196c <_strerror_r+0x388>)
3402181a:	e77d      	b.n	34021718 <_strerror_r+0x134>
3402181c:	4b54      	ldr	r3, [pc, #336]	@ (34021970 <_strerror_r+0x38c>)
3402181e:	e77b      	b.n	34021718 <_strerror_r+0x134>
34021820:	4b54      	ldr	r3, [pc, #336]	@ (34021974 <_strerror_r+0x390>)
34021822:	e779      	b.n	34021718 <_strerror_r+0x134>
34021824:	4b54      	ldr	r3, [pc, #336]	@ (34021978 <_strerror_r+0x394>)
34021826:	e777      	b.n	34021718 <_strerror_r+0x134>
34021828:	4b54      	ldr	r3, [pc, #336]	@ (3402197c <_strerror_r+0x398>)
3402182a:	e775      	b.n	34021718 <_strerror_r+0x134>
3402182c:	4b54      	ldr	r3, [pc, #336]	@ (34021980 <_strerror_r+0x39c>)
3402182e:	e773      	b.n	34021718 <_strerror_r+0x134>
34021830:	4b54      	ldr	r3, [pc, #336]	@ (34021984 <_strerror_r+0x3a0>)
34021832:	e771      	b.n	34021718 <_strerror_r+0x134>
34021834:	4b54      	ldr	r3, [pc, #336]	@ (34021988 <_strerror_r+0x3a4>)
34021836:	e76f      	b.n	34021718 <_strerror_r+0x134>
34021838:	4b54      	ldr	r3, [pc, #336]	@ (3402198c <_strerror_r+0x3a8>)
3402183a:	e76d      	b.n	34021718 <_strerror_r+0x134>
3402183c:	4b54      	ldr	r3, [pc, #336]	@ (34021990 <_strerror_r+0x3ac>)
3402183e:	e76b      	b.n	34021718 <_strerror_r+0x134>
34021840:	4b54      	ldr	r3, [pc, #336]	@ (34021994 <_strerror_r+0x3b0>)
34021842:	e769      	b.n	34021718 <_strerror_r+0x134>
34021844:	4b54      	ldr	r3, [pc, #336]	@ (34021998 <_strerror_r+0x3b4>)
34021846:	e767      	b.n	34021718 <_strerror_r+0x134>
34021848:	4b54      	ldr	r3, [pc, #336]	@ (3402199c <_strerror_r+0x3b8>)
3402184a:	e765      	b.n	34021718 <_strerror_r+0x134>
3402184c:	4b54      	ldr	r3, [pc, #336]	@ (340219a0 <_strerror_r+0x3bc>)
3402184e:	e763      	b.n	34021718 <_strerror_r+0x134>
34021850:	4b54      	ldr	r3, [pc, #336]	@ (340219a4 <_strerror_r+0x3c0>)
34021852:	e761      	b.n	34021718 <_strerror_r+0x134>
34021854:	2a00      	cmp	r2, #0
34021856:	bf08      	it	eq
34021858:	4622      	moveq	r2, r4
3402185a:	f000 f8b3 	bl	340219c4 <_user_strerror>
3402185e:	4b52      	ldr	r3, [pc, #328]	@ (340219a8 <_strerror_r+0x3c4>)
34021860:	2800      	cmp	r0, #0
34021862:	bf18      	it	ne
34021864:	4603      	movne	r3, r0
34021866:	e757      	b.n	34021718 <_strerror_r+0x134>
34021868:	4b50      	ldr	r3, [pc, #320]	@ (340219ac <_strerror_r+0x3c8>)
3402186a:	e755      	b.n	34021718 <_strerror_r+0x134>
3402186c:	340332be 	.word	0x340332be
34021870:	340332d0 	.word	0x340332d0
34021874:	340332ea 	.word	0x340332ea
34021878:	340332fa 	.word	0x340332fa
3402187c:	34033312 	.word	0x34033312
34021880:	3403331c 	.word	0x3403331c
34021884:	34033336 	.word	0x34033336
34021888:	34033348 	.word	0x34033348
3402188c:	3403335a 	.word	0x3403335a
34021890:	34033373 	.word	0x34033373
34021894:	34033383 	.word	0x34033383
34021898:	3403338f 	.word	0x3403338f
3402189c:	340333ac 	.word	0x340333ac
340218a0:	340333be 	.word	0x340333be
340218a4:	340333cf 	.word	0x340333cf
340218a8:	340333e1 	.word	0x340333e1
340218ac:	340333ed 	.word	0x340333ed
340218b0:	34033405 	.word	0x34033405
340218b4:	34033411 	.word	0x34033411
340218b8:	34033423 	.word	0x34033423
340218bc:	34033432 	.word	0x34033432
340218c0:	34033442 	.word	0x34033442
340218c4:	3403344f 	.word	0x3403344f
340218c8:	3403346e 	.word	0x3403346e
340218cc:	3403347d 	.word	0x3403347d
340218d0:	3403348e 	.word	0x3403348e
340218d4:	340334b2 	.word	0x340334b2
340218d8:	340334d0 	.word	0x340334d0
340218dc:	340334ee 	.word	0x340334ee
340218e0:	3403350e 	.word	0x3403350e
340218e4:	34033525 	.word	0x34033525
340218e8:	34033534 	.word	0x34033534
340218ec:	34033543 	.word	0x34033543
340218f0:	34033557 	.word	0x34033557
340218f4:	3403356f 	.word	0x3403356f
340218f8:	3403357d 	.word	0x3403357d
340218fc:	3403358a 	.word	0x3403358a
34021900:	340335a0 	.word	0x340335a0
34021904:	340335af 	.word	0x340335af
34021908:	340335bb 	.word	0x340335bb
3402190c:	340335ea 	.word	0x340335ea
34021910:	340335fb 	.word	0x340335fb
34021914:	34033616 	.word	0x34033616
34021918:	34033629 	.word	0x34033629
3402191c:	3403363f 	.word	0x3403363f
34021920:	34033648 	.word	0x34033648
34021924:	3403365f 	.word	0x3403365f
34021928:	34033667 	.word	0x34033667
3402192c:	34033674 	.word	0x34033674
34021930:	34033689 	.word	0x34033689
34021934:	3403369d 	.word	0x3403369d
34021938:	340336b5 	.word	0x340336b5
3402193c:	340336c4 	.word	0x340336c4
34021940:	340336d5 	.word	0x340336d5
34021944:	340336e8 	.word	0x340336e8
34021948:	340336f4 	.word	0x340336f4
3402194c:	3403370d 	.word	0x3403370d
34021950:	34033721 	.word	0x34033721
34021954:	3403373c 	.word	0x3403373c
34021958:	34033754 	.word	0x34033754
3402195c:	3403376e 	.word	0x3403376e
34021960:	34033776 	.word	0x34033776
34021964:	340337a6 	.word	0x340337a6
34021968:	340337c5 	.word	0x340337c5
3402196c:	340337e4 	.word	0x340337e4
34021970:	340337fb 	.word	0x340337fb
34021974:	3403380e 	.word	0x3403380e
34021978:	34033827 	.word	0x34033827
3402197c:	3403383e 	.word	0x3403383e
34021980:	34033854 	.word	0x34033854
34021984:	34033875 	.word	0x34033875
34021988:	3403388d 	.word	0x3403388d
3402198c:	340338a9 	.word	0x340338a9
34021990:	340338bc 	.word	0x340338bc
34021994:	340338d2 	.word	0x340338d2
34021998:	340338e6 	.word	0x340338e6
3402199c:	34033908 	.word	0x34033908
340219a0:	3403392e 	.word	0x3403392e
340219a4:	3403393f 	.word	0x3403393f
340219a8:	34033289 	.word	0x34033289
340219ac:	340332c6 	.word	0x340332c6

340219b0 <strerror>:
340219b0:	4601      	mov	r1, r0
340219b2:	2300      	movs	r3, #0
340219b4:	4802      	ldr	r0, [pc, #8]	@ (340219c0 <strerror+0x10>)
340219b6:	461a      	mov	r2, r3
340219b8:	6800      	ldr	r0, [r0, #0]
340219ba:	f7ff be13 	b.w	340215e4 <_strerror_r>
340219be:	bf00      	nop
340219c0:	34033f68 	.word	0x34033f68

340219c4 <_user_strerror>:
340219c4:	2000      	movs	r0, #0
340219c6:	4770      	bx	lr

340219c8 <_localeconv_r>:
340219c8:	4800      	ldr	r0, [pc, #0]	@ (340219cc <_localeconv_r+0x4>)
340219ca:	4770      	bx	lr
340219cc:	340340a8 	.word	0x340340a8

340219d0 <_close_r>:
340219d0:	b538      	push	{r3, r4, r5, lr}
340219d2:	2300      	movs	r3, #0
340219d4:	4d05      	ldr	r5, [pc, #20]	@ (340219ec <_close_r+0x1c>)
340219d6:	4604      	mov	r4, r0
340219d8:	4608      	mov	r0, r1
340219da:	602b      	str	r3, [r5, #0]
340219dc:	f7e2 f85e 	bl	34003a9c <_close>
340219e0:	1c43      	adds	r3, r0, #1
340219e2:	d102      	bne.n	340219ea <_close_r+0x1a>
340219e4:	682b      	ldr	r3, [r5, #0]
340219e6:	b103      	cbz	r3, 340219ea <_close_r+0x1a>
340219e8:	6023      	str	r3, [r4, #0]
340219ea:	bd38      	pop	{r3, r4, r5, pc}
340219ec:	34053f00 	.word	0x34053f00

340219f0 <_lseek_r>:
340219f0:	b538      	push	{r3, r4, r5, lr}
340219f2:	4604      	mov	r4, r0
340219f4:	4d06      	ldr	r5, [pc, #24]	@ (34021a10 <_lseek_r+0x20>)
340219f6:	4608      	mov	r0, r1
340219f8:	4611      	mov	r1, r2
340219fa:	2200      	movs	r2, #0
340219fc:	602a      	str	r2, [r5, #0]
340219fe:	461a      	mov	r2, r3
34021a00:	f7e2 f873 	bl	34003aea <_lseek>
34021a04:	1c43      	adds	r3, r0, #1
34021a06:	d102      	bne.n	34021a0e <_lseek_r+0x1e>
34021a08:	682b      	ldr	r3, [r5, #0]
34021a0a:	b103      	cbz	r3, 34021a0e <_lseek_r+0x1e>
34021a0c:	6023      	str	r3, [r4, #0]
34021a0e:	bd38      	pop	{r3, r4, r5, pc}
34021a10:	34053f00 	.word	0x34053f00

34021a14 <_read_r>:
34021a14:	b538      	push	{r3, r4, r5, lr}
34021a16:	4604      	mov	r4, r0
34021a18:	4d06      	ldr	r5, [pc, #24]	@ (34021a34 <_read_r+0x20>)
34021a1a:	4608      	mov	r0, r1
34021a1c:	4611      	mov	r1, r2
34021a1e:	2200      	movs	r2, #0
34021a20:	602a      	str	r2, [r5, #0]
34021a22:	461a      	mov	r2, r3
34021a24:	f7e2 f801 	bl	34003a2a <_read>
34021a28:	1c43      	adds	r3, r0, #1
34021a2a:	d102      	bne.n	34021a32 <_read_r+0x1e>
34021a2c:	682b      	ldr	r3, [r5, #0]
34021a2e:	b103      	cbz	r3, 34021a32 <_read_r+0x1e>
34021a30:	6023      	str	r3, [r4, #0]
34021a32:	bd38      	pop	{r3, r4, r5, pc}
34021a34:	34053f00 	.word	0x34053f00

34021a38 <_sbrk_r>:
34021a38:	b538      	push	{r3, r4, r5, lr}
34021a3a:	2300      	movs	r3, #0
34021a3c:	4d05      	ldr	r5, [pc, #20]	@ (34021a54 <_sbrk_r+0x1c>)
34021a3e:	4604      	mov	r4, r0
34021a40:	4608      	mov	r0, r1
34021a42:	602b      	str	r3, [r5, #0]
34021a44:	f001 fffa 	bl	34023a3c <_sbrk>
34021a48:	1c43      	adds	r3, r0, #1
34021a4a:	d102      	bne.n	34021a52 <_sbrk_r+0x1a>
34021a4c:	682b      	ldr	r3, [r5, #0]
34021a4e:	b103      	cbz	r3, 34021a52 <_sbrk_r+0x1a>
34021a50:	6023      	str	r3, [r4, #0]
34021a52:	bd38      	pop	{r3, r4, r5, pc}
34021a54:	34053f00 	.word	0x34053f00

34021a58 <_write_r>:
34021a58:	b538      	push	{r3, r4, r5, lr}
34021a5a:	4604      	mov	r4, r0
34021a5c:	4d06      	ldr	r5, [pc, #24]	@ (34021a78 <_write_r+0x20>)
34021a5e:	4608      	mov	r0, r1
34021a60:	4611      	mov	r1, r2
34021a62:	2200      	movs	r2, #0
34021a64:	602a      	str	r2, [r5, #0]
34021a66:	461a      	mov	r2, r3
34021a68:	f7e1 fffc 	bl	34003a64 <_write>
34021a6c:	1c43      	adds	r3, r0, #1
34021a6e:	d102      	bne.n	34021a76 <_write_r+0x1e>
34021a70:	682b      	ldr	r3, [r5, #0]
34021a72:	b103      	cbz	r3, 34021a76 <_write_r+0x1e>
34021a74:	6023      	str	r3, [r4, #0]
34021a76:	bd38      	pop	{r3, r4, r5, pc}
34021a78:	34053f00 	.word	0x34053f00

34021a7c <__errno>:
34021a7c:	4b01      	ldr	r3, [pc, #4]	@ (34021a84 <__errno+0x8>)
34021a7e:	6818      	ldr	r0, [r3, #0]
34021a80:	4770      	bx	lr
34021a82:	bf00      	nop
34021a84:	34033f68 	.word	0x34033f68

34021a88 <__libc_init_array>:
34021a88:	b570      	push	{r4, r5, r6, lr}
34021a8a:	4d0d      	ldr	r5, [pc, #52]	@ (34021ac0 <__libc_init_array+0x38>)
34021a8c:	2600      	movs	r6, #0
34021a8e:	4c0d      	ldr	r4, [pc, #52]	@ (34021ac4 <__libc_init_array+0x3c>)
34021a90:	1b64      	subs	r4, r4, r5
34021a92:	10a4      	asrs	r4, r4, #2
34021a94:	42a6      	cmp	r6, r4
34021a96:	d109      	bne.n	34021aac <__libc_init_array+0x24>
34021a98:	4d0b      	ldr	r5, [pc, #44]	@ (34021ac8 <__libc_init_array+0x40>)
34021a9a:	2600      	movs	r6, #0
34021a9c:	4c0b      	ldr	r4, [pc, #44]	@ (34021acc <__libc_init_array+0x44>)
34021a9e:	f001 ffdb 	bl	34023a58 <_init>
34021aa2:	1b64      	subs	r4, r4, r5
34021aa4:	10a4      	asrs	r4, r4, #2
34021aa6:	42a6      	cmp	r6, r4
34021aa8:	d105      	bne.n	34021ab6 <__libc_init_array+0x2e>
34021aaa:	bd70      	pop	{r4, r5, r6, pc}
34021aac:	f855 3b04 	ldr.w	r3, [r5], #4
34021ab0:	3601      	adds	r6, #1
34021ab2:	4798      	blx	r3
34021ab4:	e7ee      	b.n	34021a94 <__libc_init_array+0xc>
34021ab6:	f855 3b04 	ldr.w	r3, [r5], #4
34021aba:	3601      	adds	r6, #1
34021abc:	4798      	blx	r3
34021abe:	e7f2      	b.n	34021aa6 <__libc_init_array+0x1e>
34021ac0:	34033ed8 	.word	0x34033ed8
34021ac4:	34033ed8 	.word	0x34033ed8
34021ac8:	34033ed8 	.word	0x34033ed8
34021acc:	34033edc 	.word	0x34033edc

34021ad0 <__retarget_lock_init_recursive>:
34021ad0:	4770      	bx	lr

34021ad2 <__retarget_lock_acquire_recursive>:
34021ad2:	4770      	bx	lr

34021ad4 <__retarget_lock_release_recursive>:
34021ad4:	4770      	bx	lr

34021ad6 <memchr>:
34021ad6:	b2c9      	uxtb	r1, r1
34021ad8:	4603      	mov	r3, r0
34021ada:	4402      	add	r2, r0
34021adc:	b510      	push	{r4, lr}
34021ade:	4293      	cmp	r3, r2
34021ae0:	4618      	mov	r0, r3
34021ae2:	d101      	bne.n	34021ae8 <memchr+0x12>
34021ae4:	2000      	movs	r0, #0
34021ae6:	e003      	b.n	34021af0 <memchr+0x1a>
34021ae8:	7804      	ldrb	r4, [r0, #0]
34021aea:	3301      	adds	r3, #1
34021aec:	428c      	cmp	r4, r1
34021aee:	d1f6      	bne.n	34021ade <memchr+0x8>
34021af0:	bd10      	pop	{r4, pc}

34021af2 <memcpy>:
34021af2:	440a      	add	r2, r1
34021af4:	1e43      	subs	r3, r0, #1
34021af6:	4291      	cmp	r1, r2
34021af8:	d100      	bne.n	34021afc <memcpy+0xa>
34021afa:	4770      	bx	lr
34021afc:	b510      	push	{r4, lr}
34021afe:	f811 4b01 	ldrb.w	r4, [r1], #1
34021b02:	4291      	cmp	r1, r2
34021b04:	f803 4f01 	strb.w	r4, [r3, #1]!
34021b08:	d1f9      	bne.n	34021afe <memcpy+0xc>
34021b0a:	bd10      	pop	{r4, pc}

34021b0c <abort>:
34021b0c:	2006      	movs	r0, #6
34021b0e:	b508      	push	{r3, lr}
34021b10:	f001 fce8 	bl	340234e4 <raise>
34021b14:	2001      	movs	r0, #1
34021b16:	f7e1 ff7d 	bl	34003a14 <_exit>

34021b1a <quorem>:
34021b1a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34021b1e:	6903      	ldr	r3, [r0, #16]
34021b20:	4607      	mov	r7, r0
34021b22:	690c      	ldr	r4, [r1, #16]
34021b24:	42a3      	cmp	r3, r4
34021b26:	f2c0 8083 	blt.w	34021c30 <quorem+0x116>
34021b2a:	3c01      	subs	r4, #1
34021b2c:	f100 0514 	add.w	r5, r0, #20
34021b30:	f101 0814 	add.w	r8, r1, #20
34021b34:	00a3      	lsls	r3, r4, #2
34021b36:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
34021b3a:	eb08 0984 	add.w	r9, r8, r4, lsl #2
34021b3e:	9300      	str	r3, [sp, #0]
34021b40:	eb05 0384 	add.w	r3, r5, r4, lsl #2
34021b44:	9301      	str	r3, [sp, #4]
34021b46:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
34021b4a:	3301      	adds	r3, #1
34021b4c:	429a      	cmp	r2, r3
34021b4e:	fbb2 f6f3 	udiv	r6, r2, r3
34021b52:	d331      	bcc.n	34021bb8 <quorem+0x9e>
34021b54:	f04f 0a00 	mov.w	sl, #0
34021b58:	46c4      	mov	ip, r8
34021b5a:	46ae      	mov	lr, r5
34021b5c:	46d3      	mov	fp, sl
34021b5e:	f85c 3b04 	ldr.w	r3, [ip], #4
34021b62:	b298      	uxth	r0, r3
34021b64:	45e1      	cmp	r9, ip
34021b66:	ea4f 4313 	mov.w	r3, r3, lsr #16
34021b6a:	fb06 a000 	mla	r0, r6, r0, sl
34021b6e:	ea4f 4210 	mov.w	r2, r0, lsr #16
34021b72:	b280      	uxth	r0, r0
34021b74:	fb06 2303 	mla	r3, r6, r3, r2
34021b78:	f8de 2000 	ldr.w	r2, [lr]
34021b7c:	b292      	uxth	r2, r2
34021b7e:	ea4f 4a13 	mov.w	sl, r3, lsr #16
34021b82:	eba2 0200 	sub.w	r2, r2, r0
34021b86:	b29b      	uxth	r3, r3
34021b88:	f8de 0000 	ldr.w	r0, [lr]
34021b8c:	445a      	add	r2, fp
34021b8e:	ebc3 4322 	rsb	r3, r3, r2, asr #16
34021b92:	b292      	uxth	r2, r2
34021b94:	eb03 4310 	add.w	r3, r3, r0, lsr #16
34021b98:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
34021b9c:	ea4f 4b23 	mov.w	fp, r3, asr #16
34021ba0:	f84e 2b04 	str.w	r2, [lr], #4
34021ba4:	d2db      	bcs.n	34021b5e <quorem+0x44>
34021ba6:	9b00      	ldr	r3, [sp, #0]
34021ba8:	58eb      	ldr	r3, [r5, r3]
34021baa:	b92b      	cbnz	r3, 34021bb8 <quorem+0x9e>
34021bac:	9b01      	ldr	r3, [sp, #4]
34021bae:	3b04      	subs	r3, #4
34021bb0:	429d      	cmp	r5, r3
34021bb2:	461a      	mov	r2, r3
34021bb4:	d330      	bcc.n	34021c18 <quorem+0xfe>
34021bb6:	613c      	str	r4, [r7, #16]
34021bb8:	4638      	mov	r0, r7
34021bba:	f001 f85b 	bl	34022c74 <__mcmp>
34021bbe:	2800      	cmp	r0, #0
34021bc0:	db26      	blt.n	34021c10 <quorem+0xf6>
34021bc2:	4629      	mov	r1, r5
34021bc4:	2000      	movs	r0, #0
34021bc6:	f858 2b04 	ldr.w	r2, [r8], #4
34021bca:	f8d1 c000 	ldr.w	ip, [r1]
34021bce:	fa1f fe82 	uxth.w	lr, r2
34021bd2:	45c1      	cmp	r9, r8
34021bd4:	fa1f f38c 	uxth.w	r3, ip
34021bd8:	ea4f 4212 	mov.w	r2, r2, lsr #16
34021bdc:	eba3 030e 	sub.w	r3, r3, lr
34021be0:	4403      	add	r3, r0
34021be2:	ebc2 4223 	rsb	r2, r2, r3, asr #16
34021be6:	b29b      	uxth	r3, r3
34021be8:	eb02 421c 	add.w	r2, r2, ip, lsr #16
34021bec:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
34021bf0:	ea4f 4022 	mov.w	r0, r2, asr #16
34021bf4:	f841 3b04 	str.w	r3, [r1], #4
34021bf8:	d2e5      	bcs.n	34021bc6 <quorem+0xac>
34021bfa:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
34021bfe:	eb05 0384 	add.w	r3, r5, r4, lsl #2
34021c02:	b922      	cbnz	r2, 34021c0e <quorem+0xf4>
34021c04:	3b04      	subs	r3, #4
34021c06:	429d      	cmp	r5, r3
34021c08:	461a      	mov	r2, r3
34021c0a:	d30b      	bcc.n	34021c24 <quorem+0x10a>
34021c0c:	613c      	str	r4, [r7, #16]
34021c0e:	3601      	adds	r6, #1
34021c10:	4630      	mov	r0, r6
34021c12:	b003      	add	sp, #12
34021c14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34021c18:	6812      	ldr	r2, [r2, #0]
34021c1a:	3b04      	subs	r3, #4
34021c1c:	2a00      	cmp	r2, #0
34021c1e:	d1ca      	bne.n	34021bb6 <quorem+0x9c>
34021c20:	3c01      	subs	r4, #1
34021c22:	e7c5      	b.n	34021bb0 <quorem+0x96>
34021c24:	6812      	ldr	r2, [r2, #0]
34021c26:	3b04      	subs	r3, #4
34021c28:	2a00      	cmp	r2, #0
34021c2a:	d1ef      	bne.n	34021c0c <quorem+0xf2>
34021c2c:	3c01      	subs	r4, #1
34021c2e:	e7ea      	b.n	34021c06 <quorem+0xec>
34021c30:	2000      	movs	r0, #0
34021c32:	e7ee      	b.n	34021c12 <quorem+0xf8>
34021c34:	0000      	movs	r0, r0
	...

34021c38 <_dtoa_r>:
34021c38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34021c3c:	69c7      	ldr	r7, [r0, #28]
34021c3e:	4681      	mov	r9, r0
34021c40:	ed2d 8b02 	vpush	{d8}
34021c44:	b091      	sub	sp, #68	@ 0x44
34021c46:	ec55 4b10 	vmov	r4, r5, d0
34021c4a:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
34021c4c:	9107      	str	r1, [sp, #28]
34021c4e:	9209      	str	r2, [sp, #36]	@ 0x24
34021c50:	930d      	str	r3, [sp, #52]	@ 0x34
34021c52:	ed8d 0b02 	vstr	d0, [sp, #8]
34021c56:	b97f      	cbnz	r7, 34021c78 <_dtoa_r+0x40>
34021c58:	2010      	movs	r0, #16
34021c5a:	f7fe fb07 	bl	3402026c <malloc>
34021c5e:	4602      	mov	r2, r0
34021c60:	f8c9 001c 	str.w	r0, [r9, #28]
34021c64:	b920      	cbnz	r0, 34021c70 <_dtoa_r+0x38>
34021c66:	4ba0      	ldr	r3, [pc, #640]	@ (34021ee8 <_dtoa_r+0x2b0>)
34021c68:	21ef      	movs	r1, #239	@ 0xef
34021c6a:	48a0      	ldr	r0, [pc, #640]	@ (34021eec <_dtoa_r+0x2b4>)
34021c6c:	f7fe fae0 	bl	34020230 <__assert_func>
34021c70:	e9c0 7701 	strd	r7, r7, [r0, #4]
34021c74:	6007      	str	r7, [r0, #0]
34021c76:	60c7      	str	r7, [r0, #12]
34021c78:	f8d9 301c 	ldr.w	r3, [r9, #28]
34021c7c:	6819      	ldr	r1, [r3, #0]
34021c7e:	b159      	cbz	r1, 34021c98 <_dtoa_r+0x60>
34021c80:	685a      	ldr	r2, [r3, #4]
34021c82:	2301      	movs	r3, #1
34021c84:	4648      	mov	r0, r9
34021c86:	4093      	lsls	r3, r2
34021c88:	604a      	str	r2, [r1, #4]
34021c8a:	608b      	str	r3, [r1, #8]
34021c8c:	f000 fdbc 	bl	34022808 <_Bfree>
34021c90:	f8d9 301c 	ldr.w	r3, [r9, #28]
34021c94:	2200      	movs	r2, #0
34021c96:	601a      	str	r2, [r3, #0]
34021c98:	1e2b      	subs	r3, r5, #0
34021c9a:	bfb7      	itett	lt
34021c9c:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
34021ca0:	2300      	movge	r3, #0
34021ca2:	2201      	movlt	r2, #1
34021ca4:	9303      	strlt	r3, [sp, #12]
34021ca6:	bfac      	ite	ge
34021ca8:	6033      	strge	r3, [r6, #0]
34021caa:	6032      	strlt	r2, [r6, #0]
34021cac:	4b90      	ldr	r3, [pc, #576]	@ (34021ef0 <_dtoa_r+0x2b8>)
34021cae:	9e03      	ldr	r6, [sp, #12]
34021cb0:	43b3      	bics	r3, r6
34021cb2:	d110      	bne.n	34021cd6 <_dtoa_r+0x9e>
34021cb4:	f242 730f 	movw	r3, #9999	@ 0x270f
34021cb8:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
34021cba:	6013      	str	r3, [r2, #0]
34021cbc:	f3c6 0313 	ubfx	r3, r6, #0, #20
34021cc0:	4323      	orrs	r3, r4
34021cc2:	f000 84e6 	beq.w	34022692 <_dtoa_r+0xa5a>
34021cc6:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34021cc8:	4f8a      	ldr	r7, [pc, #552]	@ (34021ef4 <_dtoa_r+0x2bc>)
34021cca:	2b00      	cmp	r3, #0
34021ccc:	f000 84e8 	beq.w	340226a0 <_dtoa_r+0xa68>
34021cd0:	1cfb      	adds	r3, r7, #3
34021cd2:	f000 bce3 	b.w	3402269c <_dtoa_r+0xa64>
34021cd6:	ed9d 8b02 	vldr	d8, [sp, #8]
34021cda:	eeb5 8b40 	vcmp.f64	d8, #0.0
34021cde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021ce2:	d10a      	bne.n	34021cfa <_dtoa_r+0xc2>
34021ce4:	2301      	movs	r3, #1
34021ce6:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
34021ce8:	6013      	str	r3, [r2, #0]
34021cea:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34021cec:	b113      	cbz	r3, 34021cf4 <_dtoa_r+0xbc>
34021cee:	4b82      	ldr	r3, [pc, #520]	@ (34021ef8 <_dtoa_r+0x2c0>)
34021cf0:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
34021cf2:	6013      	str	r3, [r2, #0]
34021cf4:	4f81      	ldr	r7, [pc, #516]	@ (34021efc <_dtoa_r+0x2c4>)
34021cf6:	f000 bcd3 	b.w	340226a0 <_dtoa_r+0xa68>
34021cfa:	aa0e      	add	r2, sp, #56	@ 0x38
34021cfc:	eeb0 0b48 	vmov.f64	d0, d8
34021d00:	a90f      	add	r1, sp, #60	@ 0x3c
34021d02:	4648      	mov	r0, r9
34021d04:	f001 f86a 	bl	34022ddc <__d2b>
34021d08:	f3c6 530a 	ubfx	r3, r6, #20, #11
34021d0c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
34021d0e:	9001      	str	r0, [sp, #4]
34021d10:	2b00      	cmp	r3, #0
34021d12:	d045      	beq.n	34021da0 <_dtoa_r+0x168>
34021d14:	ee18 1a90 	vmov	r1, s17
34021d18:	eeb0 7b48 	vmov.f64	d7, d8
34021d1c:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
34021d20:	2500      	movs	r5, #0
34021d22:	f3c1 0113 	ubfx	r1, r1, #0, #20
34021d26:	f041 517f 	orr.w	r1, r1, #1069547520	@ 0x3fc00000
34021d2a:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
34021d2e:	eeb7 6b08 	vmov.f64	d6, #120	@ 0x3fc00000  1.5
34021d32:	ee07 1a90 	vmov	s15, r1
34021d36:	ed9f 5b66 	vldr	d5, [pc, #408]	@ 34021ed0 <_dtoa_r+0x298>
34021d3a:	ee37 7b46 	vsub.f64	d7, d7, d6
34021d3e:	ed9f 6b66 	vldr	d6, [pc, #408]	@ 34021ed8 <_dtoa_r+0x2a0>
34021d42:	eea7 6b05 	vfma.f64	d6, d7, d5
34021d46:	ee07 3a90 	vmov	s15, r3
34021d4a:	eeb8 4be7 	vcvt.f64.s32	d4, s15
34021d4e:	ed9f 5b64 	vldr	d5, [pc, #400]	@ 34021ee0 <_dtoa_r+0x2a8>
34021d52:	eeb0 7b46 	vmov.f64	d7, d6
34021d56:	eea4 7b05 	vfma.f64	d7, d4, d5
34021d5a:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
34021d5e:	eefd 6bc7 	vcvt.s32.f64	s13, d7
34021d62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021d66:	ee16 8a90 	vmov	r8, s13
34021d6a:	d508      	bpl.n	34021d7e <_dtoa_r+0x146>
34021d6c:	eeb8 6be6 	vcvt.f64.s32	d6, s13
34021d70:	eeb4 6b47 	vcmp.f64	d6, d7
34021d74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021d78:	bf18      	it	ne
34021d7a:	f108 38ff 	addne.w	r8, r8, #4294967295
34021d7e:	f1b8 0f16 	cmp.w	r8, #22
34021d82:	d82d      	bhi.n	34021de0 <_dtoa_r+0x1a8>
34021d84:	495e      	ldr	r1, [pc, #376]	@ (34021f00 <_dtoa_r+0x2c8>)
34021d86:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
34021d8a:	ed91 7b00 	vldr	d7, [r1]
34021d8e:	eeb4 8bc7 	vcmpe.f64	d8, d7
34021d92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021d96:	d501      	bpl.n	34021d9c <_dtoa_r+0x164>
34021d98:	f108 38ff 	add.w	r8, r8, #4294967295
34021d9c:	2100      	movs	r1, #0
34021d9e:	e020      	b.n	34021de2 <_dtoa_r+0x1aa>
34021da0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
34021da2:	2501      	movs	r5, #1
34021da4:	4413      	add	r3, r2
34021da6:	f203 4132 	addw	r1, r3, #1074	@ 0x432
34021daa:	2920      	cmp	r1, #32
34021dac:	bfc9      	itett	gt
34021dae:	f1c1 0140 	rsbgt	r1, r1, #64	@ 0x40
34021db2:	f1c1 0120 	rsble	r1, r1, #32
34021db6:	408e      	lslgt	r6, r1
34021db8:	f203 4112 	addwgt	r1, r3, #1042	@ 0x412
34021dbc:	bfd8      	it	le
34021dbe:	fa04 f101 	lslle.w	r1, r4, r1
34021dc2:	f103 33ff 	add.w	r3, r3, #4294967295
34021dc6:	bfc4      	itt	gt
34021dc8:	fa24 f101 	lsrgt.w	r1, r4, r1
34021dcc:	4331      	orrgt	r1, r6
34021dce:	ee07 1a90 	vmov	s15, r1
34021dd2:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34021dd6:	ee17 1a90 	vmov	r1, s15
34021dda:	f1a1 71f8 	sub.w	r1, r1, #32505856	@ 0x1f00000
34021dde:	e7a6      	b.n	34021d2e <_dtoa_r+0xf6>
34021de0:	2101      	movs	r1, #1
34021de2:	1ad2      	subs	r2, r2, r3
34021de4:	910c      	str	r1, [sp, #48]	@ 0x30
34021de6:	1e53      	subs	r3, r2, #1
34021de8:	9306      	str	r3, [sp, #24]
34021dea:	bf49      	itett	mi
34021dec:	f1c2 0301 	rsbmi	r3, r2, #1
34021df0:	2300      	movpl	r3, #0
34021df2:	9304      	strmi	r3, [sp, #16]
34021df4:	2300      	movmi	r3, #0
34021df6:	bf54      	ite	pl
34021df8:	9304      	strpl	r3, [sp, #16]
34021dfa:	9306      	strmi	r3, [sp, #24]
34021dfc:	f1b8 0f00 	cmp.w	r8, #0
34021e00:	db16      	blt.n	34021e30 <_dtoa_r+0x1f8>
34021e02:	9b06      	ldr	r3, [sp, #24]
34021e04:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
34021e08:	4443      	add	r3, r8
34021e0a:	9306      	str	r3, [sp, #24]
34021e0c:	2300      	movs	r3, #0
34021e0e:	9a07      	ldr	r2, [sp, #28]
34021e10:	2a09      	cmp	r2, #9
34021e12:	d843      	bhi.n	34021e9c <_dtoa_r+0x264>
34021e14:	2a05      	cmp	r2, #5
34021e16:	bfc5      	ittet	gt
34021e18:	3a04      	subgt	r2, #4
34021e1a:	2400      	movgt	r4, #0
34021e1c:	2401      	movle	r4, #1
34021e1e:	9207      	strgt	r2, [sp, #28]
34021e20:	9a07      	ldr	r2, [sp, #28]
34021e22:	3a02      	subs	r2, #2
34021e24:	2a03      	cmp	r2, #3
34021e26:	d844      	bhi.n	34021eb2 <_dtoa_r+0x27a>
34021e28:	e8df f002 	tbb	[pc, r2]
34021e2c:	0b173634 	.word	0x0b173634
34021e30:	9b04      	ldr	r3, [sp, #16]
34021e32:	2200      	movs	r2, #0
34021e34:	eba3 0308 	sub.w	r3, r3, r8
34021e38:	920a      	str	r2, [sp, #40]	@ 0x28
34021e3a:	9304      	str	r3, [sp, #16]
34021e3c:	f1c8 0300 	rsb	r3, r8, #0
34021e40:	e7e5      	b.n	34021e0e <_dtoa_r+0x1d6>
34021e42:	2201      	movs	r2, #1
34021e44:	9208      	str	r2, [sp, #32]
34021e46:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34021e48:	eb08 0b02 	add.w	fp, r8, r2
34021e4c:	f10b 0a01 	add.w	sl, fp, #1
34021e50:	4652      	mov	r2, sl
34021e52:	2a01      	cmp	r2, #1
34021e54:	bfb8      	it	lt
34021e56:	2201      	movlt	r2, #1
34021e58:	e006      	b.n	34021e68 <_dtoa_r+0x230>
34021e5a:	2201      	movs	r2, #1
34021e5c:	9208      	str	r2, [sp, #32]
34021e5e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34021e60:	2a00      	cmp	r2, #0
34021e62:	dd29      	ble.n	34021eb8 <_dtoa_r+0x280>
34021e64:	4693      	mov	fp, r2
34021e66:	4692      	mov	sl, r2
34021e68:	f8d9 701c 	ldr.w	r7, [r9, #28]
34021e6c:	2100      	movs	r1, #0
34021e6e:	2004      	movs	r0, #4
34021e70:	f100 0614 	add.w	r6, r0, #20
34021e74:	4296      	cmp	r6, r2
34021e76:	d926      	bls.n	34021ec6 <_dtoa_r+0x28e>
34021e78:	6079      	str	r1, [r7, #4]
34021e7a:	4648      	mov	r0, r9
34021e7c:	9305      	str	r3, [sp, #20]
34021e7e:	f000 fc83 	bl	34022788 <_Balloc>
34021e82:	9b05      	ldr	r3, [sp, #20]
34021e84:	4607      	mov	r7, r0
34021e86:	2800      	cmp	r0, #0
34021e88:	d13e      	bne.n	34021f08 <_dtoa_r+0x2d0>
34021e8a:	4b1e      	ldr	r3, [pc, #120]	@ (34021f04 <_dtoa_r+0x2cc>)
34021e8c:	4602      	mov	r2, r0
34021e8e:	f240 11af 	movw	r1, #431	@ 0x1af
34021e92:	e6ea      	b.n	34021c6a <_dtoa_r+0x32>
34021e94:	2200      	movs	r2, #0
34021e96:	e7e1      	b.n	34021e5c <_dtoa_r+0x224>
34021e98:	2200      	movs	r2, #0
34021e9a:	e7d3      	b.n	34021e44 <_dtoa_r+0x20c>
34021e9c:	2401      	movs	r4, #1
34021e9e:	2200      	movs	r2, #0
34021ea0:	e9cd 2407 	strd	r2, r4, [sp, #28]
34021ea4:	f04f 3bff 	mov.w	fp, #4294967295
34021ea8:	2100      	movs	r1, #0
34021eaa:	2212      	movs	r2, #18
34021eac:	46da      	mov	sl, fp
34021eae:	9109      	str	r1, [sp, #36]	@ 0x24
34021eb0:	e7da      	b.n	34021e68 <_dtoa_r+0x230>
34021eb2:	2201      	movs	r2, #1
34021eb4:	9208      	str	r2, [sp, #32]
34021eb6:	e7f5      	b.n	34021ea4 <_dtoa_r+0x26c>
34021eb8:	f04f 0b01 	mov.w	fp, #1
34021ebc:	46da      	mov	sl, fp
34021ebe:	465a      	mov	r2, fp
34021ec0:	f8cd b024 	str.w	fp, [sp, #36]	@ 0x24
34021ec4:	e7d0      	b.n	34021e68 <_dtoa_r+0x230>
34021ec6:	3101      	adds	r1, #1
34021ec8:	0040      	lsls	r0, r0, #1
34021eca:	e7d1      	b.n	34021e70 <_dtoa_r+0x238>
34021ecc:	f3af 8000 	nop.w
34021ed0:	636f4361 	.word	0x636f4361
34021ed4:	3fd287a7 	.word	0x3fd287a7
34021ed8:	8b60c8b3 	.word	0x8b60c8b3
34021edc:	3fc68a28 	.word	0x3fc68a28
34021ee0:	509f79fb 	.word	0x509f79fb
34021ee4:	3fd34413 	.word	0x3fd34413
34021ee8:	34033961 	.word	0x34033961
34021eec:	34033978 	.word	0x34033978
34021ef0:	7ff00000 	.word	0x7ff00000
34021ef4:	3403395d 	.word	0x3403395d
34021ef8:	3403329b 	.word	0x3403329b
34021efc:	3403329a 	.word	0x3403329a
34021f00:	34033a90 	.word	0x34033a90
34021f04:	340339d0 	.word	0x340339d0
34021f08:	f8d9 201c 	ldr.w	r2, [r9, #28]
34021f0c:	f1ba 0f0e 	cmp.w	sl, #14
34021f10:	6010      	str	r0, [r2, #0]
34021f12:	d86e      	bhi.n	34021ff2 <_dtoa_r+0x3ba>
34021f14:	2c00      	cmp	r4, #0
34021f16:	d06c      	beq.n	34021ff2 <_dtoa_r+0x3ba>
34021f18:	f1b8 0f00 	cmp.w	r8, #0
34021f1c:	f340 80b4 	ble.w	34022088 <_dtoa_r+0x450>
34021f20:	f008 010f 	and.w	r1, r8, #15
34021f24:	4ac7      	ldr	r2, [pc, #796]	@ (34022244 <_dtoa_r+0x60c>)
34021f26:	f418 7f80 	tst.w	r8, #256	@ 0x100
34021f2a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
34021f2e:	ea4f 1128 	mov.w	r1, r8, asr #4
34021f32:	ed92 7b00 	vldr	d7, [r2]
34021f36:	f000 809b 	beq.w	34022070 <_dtoa_r+0x438>
34021f3a:	4ac3      	ldr	r2, [pc, #780]	@ (34022248 <_dtoa_r+0x610>)
34021f3c:	f001 010f 	and.w	r1, r1, #15
34021f40:	ed92 6b08 	vldr	d6, [r2, #32]
34021f44:	2203      	movs	r2, #3
34021f46:	ee88 6b06 	vdiv.f64	d6, d8, d6
34021f4a:	ed8d 6b02 	vstr	d6, [sp, #8]
34021f4e:	48be      	ldr	r0, [pc, #760]	@ (34022248 <_dtoa_r+0x610>)
34021f50:	2900      	cmp	r1, #0
34021f52:	f040 808f 	bne.w	34022074 <_dtoa_r+0x43c>
34021f56:	ed9d 6b02 	vldr	d6, [sp, #8]
34021f5a:	ee86 7b07 	vdiv.f64	d7, d6, d7
34021f5e:	ed8d 7b02 	vstr	d7, [sp, #8]
34021f62:	990c      	ldr	r1, [sp, #48]	@ 0x30
34021f64:	ed9d 7b02 	vldr	d7, [sp, #8]
34021f68:	2900      	cmp	r1, #0
34021f6a:	f000 80b3 	beq.w	340220d4 <_dtoa_r+0x49c>
34021f6e:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
34021f72:	eeb4 7bc6 	vcmpe.f64	d7, d6
34021f76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021f7a:	f140 80ab 	bpl.w	340220d4 <_dtoa_r+0x49c>
34021f7e:	f1ba 0f00 	cmp.w	sl, #0
34021f82:	f000 80a7 	beq.w	340220d4 <_dtoa_r+0x49c>
34021f86:	f1bb 0f00 	cmp.w	fp, #0
34021f8a:	dd30      	ble.n	34021fee <_dtoa_r+0x3b6>
34021f8c:	eeb2 6b04 	vmov.f64	d6, #36	@ 0x41200000  10.0
34021f90:	f108 31ff 	add.w	r1, r8, #4294967295
34021f94:	3201      	adds	r2, #1
34021f96:	465c      	mov	r4, fp
34021f98:	9105      	str	r1, [sp, #20]
34021f9a:	ee27 7b06 	vmul.f64	d7, d7, d6
34021f9e:	ed8d 7b02 	vstr	d7, [sp, #8]
34021fa2:	ee07 2a90 	vmov	s15, r2
34021fa6:	eeb1 5b0c 	vmov.f64	d5, #28	@ 0x40e00000  7.0
34021faa:	ed9d 6b02 	vldr	d6, [sp, #8]
34021fae:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34021fb2:	eea7 5b06 	vfma.f64	d5, d7, d6
34021fb6:	ee15 2a90 	vmov	r2, s11
34021fba:	ec51 0b15 	vmov	r0, r1, d5
34021fbe:	f1a2 7150 	sub.w	r1, r2, #54525952	@ 0x3400000
34021fc2:	2c00      	cmp	r4, #0
34021fc4:	f040 808a 	bne.w	340220dc <_dtoa_r+0x4a4>
34021fc8:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
34021fcc:	ee36 6b47 	vsub.f64	d6, d6, d7
34021fd0:	ec41 0b17 	vmov	d7, r0, r1
34021fd4:	eeb4 6bc7 	vcmpe.f64	d6, d7
34021fd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021fdc:	f300 826a 	bgt.w	340224b4 <_dtoa_r+0x87c>
34021fe0:	eeb1 7b47 	vneg.f64	d7, d7
34021fe4:	eeb4 6bc7 	vcmpe.f64	d6, d7
34021fe8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34021fec:	d423      	bmi.n	34022036 <_dtoa_r+0x3fe>
34021fee:	ed8d 8b02 	vstr	d8, [sp, #8]
34021ff2:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
34021ff4:	2a00      	cmp	r2, #0
34021ff6:	f2c0 8129 	blt.w	3402224c <_dtoa_r+0x614>
34021ffa:	f1b8 0f0e 	cmp.w	r8, #14
34021ffe:	f300 8125 	bgt.w	3402224c <_dtoa_r+0x614>
34022002:	4b90      	ldr	r3, [pc, #576]	@ (34022244 <_dtoa_r+0x60c>)
34022004:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
34022008:	ed93 6b00 	vldr	d6, [r3]
3402200c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3402200e:	2b00      	cmp	r3, #0
34022010:	f280 80c8 	bge.w	340221a4 <_dtoa_r+0x56c>
34022014:	f1ba 0f00 	cmp.w	sl, #0
34022018:	f300 80c4 	bgt.w	340221a4 <_dtoa_r+0x56c>
3402201c:	d10b      	bne.n	34022036 <_dtoa_r+0x3fe>
3402201e:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
34022022:	ee26 6b07 	vmul.f64	d6, d6, d7
34022026:	ed9d 7b02 	vldr	d7, [sp, #8]
3402202a:	eeb4 6bc7 	vcmpe.f64	d6, d7
3402202e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34022032:	f2c0 823c 	blt.w	340224ae <_dtoa_r+0x876>
34022036:	2400      	movs	r4, #0
34022038:	4625      	mov	r5, r4
3402203a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3402203c:	463e      	mov	r6, r7
3402203e:	43db      	mvns	r3, r3
34022040:	9305      	str	r3, [sp, #20]
34022042:	f04f 0800 	mov.w	r8, #0
34022046:	4621      	mov	r1, r4
34022048:	4648      	mov	r0, r9
3402204a:	f000 fbdd 	bl	34022808 <_Bfree>
3402204e:	2d00      	cmp	r5, #0
34022050:	f000 80a2 	beq.w	34022198 <_dtoa_r+0x560>
34022054:	f1b8 0f00 	cmp.w	r8, #0
34022058:	d005      	beq.n	34022066 <_dtoa_r+0x42e>
3402205a:	45a8      	cmp	r8, r5
3402205c:	d003      	beq.n	34022066 <_dtoa_r+0x42e>
3402205e:	4641      	mov	r1, r8
34022060:	4648      	mov	r0, r9
34022062:	f000 fbd1 	bl	34022808 <_Bfree>
34022066:	4629      	mov	r1, r5
34022068:	4648      	mov	r0, r9
3402206a:	f000 fbcd 	bl	34022808 <_Bfree>
3402206e:	e093      	b.n	34022198 <_dtoa_r+0x560>
34022070:	2202      	movs	r2, #2
34022072:	e76c      	b.n	34021f4e <_dtoa_r+0x316>
34022074:	07cc      	lsls	r4, r1, #31
34022076:	d504      	bpl.n	34022082 <_dtoa_r+0x44a>
34022078:	3201      	adds	r2, #1
3402207a:	ed90 6b00 	vldr	d6, [r0]
3402207e:	ee27 7b06 	vmul.f64	d7, d7, d6
34022082:	1049      	asrs	r1, r1, #1
34022084:	3008      	adds	r0, #8
34022086:	e763      	b.n	34021f50 <_dtoa_r+0x318>
34022088:	d022      	beq.n	340220d0 <_dtoa_r+0x498>
3402208a:	f1c8 0100 	rsb	r1, r8, #0
3402208e:	4a6d      	ldr	r2, [pc, #436]	@ (34022244 <_dtoa_r+0x60c>)
34022090:	2400      	movs	r4, #0
34022092:	f001 000f 	and.w	r0, r1, #15
34022096:	1109      	asrs	r1, r1, #4
34022098:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
3402209c:	486a      	ldr	r0, [pc, #424]	@ (34022248 <_dtoa_r+0x610>)
3402209e:	ed92 7b00 	vldr	d7, [r2]
340220a2:	2202      	movs	r2, #2
340220a4:	ee28 7b07 	vmul.f64	d7, d8, d7
340220a8:	ed8d 7b02 	vstr	d7, [sp, #8]
340220ac:	b929      	cbnz	r1, 340220ba <_dtoa_r+0x482>
340220ae:	2c00      	cmp	r4, #0
340220b0:	f43f af57 	beq.w	34021f62 <_dtoa_r+0x32a>
340220b4:	ed8d 7b02 	vstr	d7, [sp, #8]
340220b8:	e753      	b.n	34021f62 <_dtoa_r+0x32a>
340220ba:	07ce      	lsls	r6, r1, #31
340220bc:	d505      	bpl.n	340220ca <_dtoa_r+0x492>
340220be:	3201      	adds	r2, #1
340220c0:	2401      	movs	r4, #1
340220c2:	ed90 6b00 	vldr	d6, [r0]
340220c6:	ee27 7b06 	vmul.f64	d7, d7, d6
340220ca:	1049      	asrs	r1, r1, #1
340220cc:	3008      	adds	r0, #8
340220ce:	e7ed      	b.n	340220ac <_dtoa_r+0x474>
340220d0:	2202      	movs	r2, #2
340220d2:	e746      	b.n	34021f62 <_dtoa_r+0x32a>
340220d4:	4654      	mov	r4, sl
340220d6:	f8cd 8014 	str.w	r8, [sp, #20]
340220da:	e762      	b.n	34021fa2 <_dtoa_r+0x36a>
340220dc:	4a59      	ldr	r2, [pc, #356]	@ (34022244 <_dtoa_r+0x60c>)
340220de:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
340220e2:	443c      	add	r4, r7
340220e4:	ed12 4b02 	vldr	d4, [r2, #-8]
340220e8:	9a08      	ldr	r2, [sp, #32]
340220ea:	ec41 0b17 	vmov	d7, r0, r1
340220ee:	b34a      	cbz	r2, 34022144 <_dtoa_r+0x50c>
340220f0:	eeb6 3b00 	vmov.f64	d3, #96	@ 0x3f000000  0.5
340220f4:	463e      	mov	r6, r7
340220f6:	eeb7 2b00 	vmov.f64	d2, #112	@ 0x3f800000  1.0
340220fa:	ee83 5b04 	vdiv.f64	d5, d3, d4
340220fe:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
34022102:	ee35 7b47 	vsub.f64	d7, d5, d7
34022106:	eefd 4bc6 	vcvt.s32.f64	s9, d6
3402210a:	eeb8 5be4 	vcvt.f64.s32	d5, s9
3402210e:	ee14 2a90 	vmov	r2, s9
34022112:	3230      	adds	r2, #48	@ 0x30
34022114:	ee36 6b45 	vsub.f64	d6, d6, d5
34022118:	f806 2b01 	strb.w	r2, [r6], #1
3402211c:	eeb4 6bc7 	vcmpe.f64	d6, d7
34022120:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34022124:	d438      	bmi.n	34022198 <_dtoa_r+0x560>
34022126:	ee32 5b46 	vsub.f64	d5, d2, d6
3402212a:	eeb4 5bc7 	vcmpe.f64	d5, d7
3402212e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34022132:	d46e      	bmi.n	34022212 <_dtoa_r+0x5da>
34022134:	42a6      	cmp	r6, r4
34022136:	f43f af5a 	beq.w	34021fee <_dtoa_r+0x3b6>
3402213a:	ee27 7b03 	vmul.f64	d7, d7, d3
3402213e:	ee26 6b03 	vmul.f64	d6, d6, d3
34022142:	e7e0      	b.n	34022106 <_dtoa_r+0x4ce>
34022144:	ee27 7b04 	vmul.f64	d7, d7, d4
34022148:	4621      	mov	r1, r4
3402214a:	463e      	mov	r6, r7
3402214c:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
34022150:	eefd 4bc6 	vcvt.s32.f64	s9, d6
34022154:	ee14 2a90 	vmov	r2, s9
34022158:	eeb8 5be4 	vcvt.f64.s32	d5, s9
3402215c:	3230      	adds	r2, #48	@ 0x30
3402215e:	ee36 6b45 	vsub.f64	d6, d6, d5
34022162:	f806 2b01 	strb.w	r2, [r6], #1
34022166:	42a6      	cmp	r6, r4
34022168:	d119      	bne.n	3402219e <_dtoa_r+0x566>
3402216a:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
3402216e:	ee37 4b05 	vadd.f64	d4, d7, d5
34022172:	eeb4 6bc4 	vcmpe.f64	d6, d4
34022176:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402217a:	dc4a      	bgt.n	34022212 <_dtoa_r+0x5da>
3402217c:	ee35 5b47 	vsub.f64	d5, d5, d7
34022180:	eeb4 6bc5 	vcmpe.f64	d6, d5
34022184:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34022188:	f57f af31 	bpl.w	34021fee <_dtoa_r+0x3b6>
3402218c:	460e      	mov	r6, r1
3402218e:	3901      	subs	r1, #1
34022190:	f816 3c01 	ldrb.w	r3, [r6, #-1]
34022194:	2b30      	cmp	r3, #48	@ 0x30
34022196:	d0f9      	beq.n	3402218c <_dtoa_r+0x554>
34022198:	f8dd 8014 	ldr.w	r8, [sp, #20]
3402219c:	e027      	b.n	340221ee <_dtoa_r+0x5b6>
3402219e:	ee26 6b03 	vmul.f64	d6, d6, d3
340221a2:	e7d5      	b.n	34022150 <_dtoa_r+0x518>
340221a4:	ed9d 7b02 	vldr	d7, [sp, #8]
340221a8:	eeb2 4b04 	vmov.f64	d4, #36	@ 0x41200000  10.0
340221ac:	463e      	mov	r6, r7
340221ae:	ee87 5b06 	vdiv.f64	d5, d7, d6
340221b2:	eebd 5bc5 	vcvt.s32.f64	s10, d5
340221b6:	ee15 3a10 	vmov	r3, s10
340221ba:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
340221be:	3330      	adds	r3, #48	@ 0x30
340221c0:	eea3 7b46 	vfms.f64	d7, d3, d6
340221c4:	f806 3b01 	strb.w	r3, [r6], #1
340221c8:	1bf3      	subs	r3, r6, r7
340221ca:	459a      	cmp	sl, r3
340221cc:	d132      	bne.n	34022234 <_dtoa_r+0x5fc>
340221ce:	ee37 7b07 	vadd.f64	d7, d7, d7
340221d2:	eeb4 7bc6 	vcmpe.f64	d7, d6
340221d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340221da:	dc18      	bgt.n	3402220e <_dtoa_r+0x5d6>
340221dc:	eeb4 7b46 	vcmp.f64	d7, d6
340221e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340221e4:	d103      	bne.n	340221ee <_dtoa_r+0x5b6>
340221e6:	ee15 3a10 	vmov	r3, s10
340221ea:	07db      	lsls	r3, r3, #31
340221ec:	d40f      	bmi.n	3402220e <_dtoa_r+0x5d6>
340221ee:	9901      	ldr	r1, [sp, #4]
340221f0:	4648      	mov	r0, r9
340221f2:	f000 fb09 	bl	34022808 <_Bfree>
340221f6:	2300      	movs	r3, #0
340221f8:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
340221fa:	7033      	strb	r3, [r6, #0]
340221fc:	f108 0301 	add.w	r3, r8, #1
34022200:	6013      	str	r3, [r2, #0]
34022202:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34022204:	2b00      	cmp	r3, #0
34022206:	f000 824b 	beq.w	340226a0 <_dtoa_r+0xa68>
3402220a:	601e      	str	r6, [r3, #0]
3402220c:	e248      	b.n	340226a0 <_dtoa_r+0xa68>
3402220e:	f8cd 8014 	str.w	r8, [sp, #20]
34022212:	4633      	mov	r3, r6
34022214:	461e      	mov	r6, r3
34022216:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3402221a:	2a39      	cmp	r2, #57	@ 0x39
3402221c:	d106      	bne.n	3402222c <_dtoa_r+0x5f4>
3402221e:	429f      	cmp	r7, r3
34022220:	d1f8      	bne.n	34022214 <_dtoa_r+0x5dc>
34022222:	9a05      	ldr	r2, [sp, #20]
34022224:	3201      	adds	r2, #1
34022226:	9205      	str	r2, [sp, #20]
34022228:	2230      	movs	r2, #48	@ 0x30
3402222a:	703a      	strb	r2, [r7, #0]
3402222c:	781a      	ldrb	r2, [r3, #0]
3402222e:	3201      	adds	r2, #1
34022230:	701a      	strb	r2, [r3, #0]
34022232:	e7b1      	b.n	34022198 <_dtoa_r+0x560>
34022234:	ee27 7b04 	vmul.f64	d7, d7, d4
34022238:	eeb5 7b40 	vcmp.f64	d7, #0.0
3402223c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34022240:	d1b5      	bne.n	340221ae <_dtoa_r+0x576>
34022242:	e7d4      	b.n	340221ee <_dtoa_r+0x5b6>
34022244:	34033a90 	.word	0x34033a90
34022248:	34033a68 	.word	0x34033a68
3402224c:	9908      	ldr	r1, [sp, #32]
3402224e:	2900      	cmp	r1, #0
34022250:	f000 80e9 	beq.w	34022426 <_dtoa_r+0x7ee>
34022254:	9907      	ldr	r1, [sp, #28]
34022256:	2901      	cmp	r1, #1
34022258:	f300 80cb 	bgt.w	340223f2 <_dtoa_r+0x7ba>
3402225c:	2d00      	cmp	r5, #0
3402225e:	f000 80c4 	beq.w	340223ea <_dtoa_r+0x7b2>
34022262:	f202 4233 	addw	r2, r2, #1075	@ 0x433
34022266:	461c      	mov	r4, r3
34022268:	9e04      	ldr	r6, [sp, #16]
3402226a:	9305      	str	r3, [sp, #20]
3402226c:	2101      	movs	r1, #1
3402226e:	9b04      	ldr	r3, [sp, #16]
34022270:	4648      	mov	r0, r9
34022272:	4413      	add	r3, r2
34022274:	9304      	str	r3, [sp, #16]
34022276:	9b06      	ldr	r3, [sp, #24]
34022278:	4413      	add	r3, r2
3402227a:	9306      	str	r3, [sp, #24]
3402227c:	f000 fb7a 	bl	34022974 <__i2b>
34022280:	9b05      	ldr	r3, [sp, #20]
34022282:	4605      	mov	r5, r0
34022284:	b166      	cbz	r6, 340222a0 <_dtoa_r+0x668>
34022286:	9a06      	ldr	r2, [sp, #24]
34022288:	2a00      	cmp	r2, #0
3402228a:	dd09      	ble.n	340222a0 <_dtoa_r+0x668>
3402228c:	42b2      	cmp	r2, r6
3402228e:	9904      	ldr	r1, [sp, #16]
34022290:	bfa8      	it	ge
34022292:	4632      	movge	r2, r6
34022294:	1a89      	subs	r1, r1, r2
34022296:	1ab6      	subs	r6, r6, r2
34022298:	9104      	str	r1, [sp, #16]
3402229a:	9906      	ldr	r1, [sp, #24]
3402229c:	1a8a      	subs	r2, r1, r2
3402229e:	9206      	str	r2, [sp, #24]
340222a0:	b30b      	cbz	r3, 340222e6 <_dtoa_r+0x6ae>
340222a2:	9a08      	ldr	r2, [sp, #32]
340222a4:	2a00      	cmp	r2, #0
340222a6:	f000 80c5 	beq.w	34022434 <_dtoa_r+0x7fc>
340222aa:	2c00      	cmp	r4, #0
340222ac:	f000 80bf 	beq.w	3402242e <_dtoa_r+0x7f6>
340222b0:	4629      	mov	r1, r5
340222b2:	4622      	mov	r2, r4
340222b4:	4648      	mov	r0, r9
340222b6:	930b      	str	r3, [sp, #44]	@ 0x2c
340222b8:	f000 fc16 	bl	34022ae8 <__pow5mult>
340222bc:	9a01      	ldr	r2, [sp, #4]
340222be:	4601      	mov	r1, r0
340222c0:	4605      	mov	r5, r0
340222c2:	4648      	mov	r0, r9
340222c4:	f000 fb6c 	bl	340229a0 <__multiply>
340222c8:	9901      	ldr	r1, [sp, #4]
340222ca:	9005      	str	r0, [sp, #20]
340222cc:	4648      	mov	r0, r9
340222ce:	f000 fa9b 	bl	34022808 <_Bfree>
340222d2:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
340222d4:	1b1b      	subs	r3, r3, r4
340222d6:	f000 80b0 	beq.w	3402243a <_dtoa_r+0x802>
340222da:	461a      	mov	r2, r3
340222dc:	9905      	ldr	r1, [sp, #20]
340222de:	4648      	mov	r0, r9
340222e0:	f000 fc02 	bl	34022ae8 <__pow5mult>
340222e4:	9001      	str	r0, [sp, #4]
340222e6:	2101      	movs	r1, #1
340222e8:	4648      	mov	r0, r9
340222ea:	f000 fb43 	bl	34022974 <__i2b>
340222ee:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340222f0:	4604      	mov	r4, r0
340222f2:	2b00      	cmp	r3, #0
340222f4:	f000 81da 	beq.w	340226ac <_dtoa_r+0xa74>
340222f8:	461a      	mov	r2, r3
340222fa:	4601      	mov	r1, r0
340222fc:	4648      	mov	r0, r9
340222fe:	f000 fbf3 	bl	34022ae8 <__pow5mult>
34022302:	9b07      	ldr	r3, [sp, #28]
34022304:	4604      	mov	r4, r0
34022306:	2b01      	cmp	r3, #1
34022308:	f300 80a0 	bgt.w	3402244c <_dtoa_r+0x814>
3402230c:	9b02      	ldr	r3, [sp, #8]
3402230e:	2b00      	cmp	r3, #0
34022310:	f040 8096 	bne.w	34022440 <_dtoa_r+0x808>
34022314:	9b03      	ldr	r3, [sp, #12]
34022316:	f3c3 0213 	ubfx	r2, r3, #0, #20
3402231a:	2a00      	cmp	r2, #0
3402231c:	f040 8092 	bne.w	34022444 <_dtoa_r+0x80c>
34022320:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
34022324:	0d12      	lsrs	r2, r2, #20
34022326:	0512      	lsls	r2, r2, #20
34022328:	2a00      	cmp	r2, #0
3402232a:	f000 808d 	beq.w	34022448 <_dtoa_r+0x810>
3402232e:	9b04      	ldr	r3, [sp, #16]
34022330:	3301      	adds	r3, #1
34022332:	9304      	str	r3, [sp, #16]
34022334:	9b06      	ldr	r3, [sp, #24]
34022336:	3301      	adds	r3, #1
34022338:	9306      	str	r3, [sp, #24]
3402233a:	2301      	movs	r3, #1
3402233c:	930b      	str	r3, [sp, #44]	@ 0x2c
3402233e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34022340:	2b00      	cmp	r3, #0
34022342:	f000 81b9 	beq.w	340226b8 <_dtoa_r+0xa80>
34022346:	6922      	ldr	r2, [r4, #16]
34022348:	eb04 0282 	add.w	r2, r4, r2, lsl #2
3402234c:	6910      	ldr	r0, [r2, #16]
3402234e:	f000 fac5 	bl	340228dc <__hi0bits>
34022352:	f1c0 0020 	rsb	r0, r0, #32
34022356:	9b06      	ldr	r3, [sp, #24]
34022358:	4418      	add	r0, r3
3402235a:	f010 001f 	ands.w	r0, r0, #31
3402235e:	f000 8081 	beq.w	34022464 <_dtoa_r+0x82c>
34022362:	f1c0 0220 	rsb	r2, r0, #32
34022366:	2a04      	cmp	r2, #4
34022368:	dd73      	ble.n	34022452 <_dtoa_r+0x81a>
3402236a:	f1c0 001c 	rsb	r0, r0, #28
3402236e:	9b04      	ldr	r3, [sp, #16]
34022370:	4403      	add	r3, r0
34022372:	4406      	add	r6, r0
34022374:	9304      	str	r3, [sp, #16]
34022376:	9b06      	ldr	r3, [sp, #24]
34022378:	4403      	add	r3, r0
3402237a:	9306      	str	r3, [sp, #24]
3402237c:	9b04      	ldr	r3, [sp, #16]
3402237e:	2b00      	cmp	r3, #0
34022380:	dd05      	ble.n	3402238e <_dtoa_r+0x756>
34022382:	461a      	mov	r2, r3
34022384:	9901      	ldr	r1, [sp, #4]
34022386:	4648      	mov	r0, r9
34022388:	f000 fc08 	bl	34022b9c <__lshift>
3402238c:	9001      	str	r0, [sp, #4]
3402238e:	9b06      	ldr	r3, [sp, #24]
34022390:	2b00      	cmp	r3, #0
34022392:	dd05      	ble.n	340223a0 <_dtoa_r+0x768>
34022394:	4621      	mov	r1, r4
34022396:	461a      	mov	r2, r3
34022398:	4648      	mov	r0, r9
3402239a:	f000 fbff 	bl	34022b9c <__lshift>
3402239e:	4604      	mov	r4, r0
340223a0:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
340223a2:	2b00      	cmp	r3, #0
340223a4:	d060      	beq.n	34022468 <_dtoa_r+0x830>
340223a6:	4621      	mov	r1, r4
340223a8:	9801      	ldr	r0, [sp, #4]
340223aa:	f000 fc63 	bl	34022c74 <__mcmp>
340223ae:	2800      	cmp	r0, #0
340223b0:	da5a      	bge.n	34022468 <_dtoa_r+0x830>
340223b2:	f108 33ff 	add.w	r3, r8, #4294967295
340223b6:	220a      	movs	r2, #10
340223b8:	9901      	ldr	r1, [sp, #4]
340223ba:	4648      	mov	r0, r9
340223bc:	9305      	str	r3, [sp, #20]
340223be:	2300      	movs	r3, #0
340223c0:	f000 fa44 	bl	3402284c <__multadd>
340223c4:	9b08      	ldr	r3, [sp, #32]
340223c6:	9001      	str	r0, [sp, #4]
340223c8:	2b00      	cmp	r3, #0
340223ca:	f000 8177 	beq.w	340226bc <_dtoa_r+0xa84>
340223ce:	4629      	mov	r1, r5
340223d0:	2300      	movs	r3, #0
340223d2:	220a      	movs	r2, #10
340223d4:	4648      	mov	r0, r9
340223d6:	f000 fa39 	bl	3402284c <__multadd>
340223da:	f1bb 0f00 	cmp.w	fp, #0
340223de:	4605      	mov	r5, r0
340223e0:	dc6e      	bgt.n	340224c0 <_dtoa_r+0x888>
340223e2:	9b07      	ldr	r3, [sp, #28]
340223e4:	2b02      	cmp	r3, #2
340223e6:	dc48      	bgt.n	3402247a <_dtoa_r+0x842>
340223e8:	e06a      	b.n	340224c0 <_dtoa_r+0x888>
340223ea:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340223ec:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
340223f0:	e739      	b.n	34022266 <_dtoa_r+0x62e>
340223f2:	f10a 34ff 	add.w	r4, sl, #4294967295
340223f6:	42a3      	cmp	r3, r4
340223f8:	db07      	blt.n	3402240a <_dtoa_r+0x7d2>
340223fa:	f1ba 0f00 	cmp.w	sl, #0
340223fe:	eba3 0404 	sub.w	r4, r3, r4
34022402:	db0b      	blt.n	3402241c <_dtoa_r+0x7e4>
34022404:	9e04      	ldr	r6, [sp, #16]
34022406:	4652      	mov	r2, sl
34022408:	e72f      	b.n	3402226a <_dtoa_r+0x632>
3402240a:	1ae2      	subs	r2, r4, r3
3402240c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3402240e:	9e04      	ldr	r6, [sp, #16]
34022410:	4413      	add	r3, r2
34022412:	4652      	mov	r2, sl
34022414:	930a      	str	r3, [sp, #40]	@ 0x28
34022416:	4623      	mov	r3, r4
34022418:	2400      	movs	r4, #0
3402241a:	e726      	b.n	3402226a <_dtoa_r+0x632>
3402241c:	9a04      	ldr	r2, [sp, #16]
3402241e:	eba2 060a 	sub.w	r6, r2, sl
34022422:	2200      	movs	r2, #0
34022424:	e721      	b.n	3402226a <_dtoa_r+0x632>
34022426:	461c      	mov	r4, r3
34022428:	9e04      	ldr	r6, [sp, #16]
3402242a:	9d08      	ldr	r5, [sp, #32]
3402242c:	e72a      	b.n	34022284 <_dtoa_r+0x64c>
3402242e:	9a01      	ldr	r2, [sp, #4]
34022430:	9205      	str	r2, [sp, #20]
34022432:	e752      	b.n	340222da <_dtoa_r+0x6a2>
34022434:	461a      	mov	r2, r3
34022436:	9901      	ldr	r1, [sp, #4]
34022438:	e751      	b.n	340222de <_dtoa_r+0x6a6>
3402243a:	9b05      	ldr	r3, [sp, #20]
3402243c:	9301      	str	r3, [sp, #4]
3402243e:	e752      	b.n	340222e6 <_dtoa_r+0x6ae>
34022440:	2300      	movs	r3, #0
34022442:	e77b      	b.n	3402233c <_dtoa_r+0x704>
34022444:	9b02      	ldr	r3, [sp, #8]
34022446:	e779      	b.n	3402233c <_dtoa_r+0x704>
34022448:	920b      	str	r2, [sp, #44]	@ 0x2c
3402244a:	e778      	b.n	3402233e <_dtoa_r+0x706>
3402244c:	2300      	movs	r3, #0
3402244e:	930b      	str	r3, [sp, #44]	@ 0x2c
34022450:	e779      	b.n	34022346 <_dtoa_r+0x70e>
34022452:	d093      	beq.n	3402237c <_dtoa_r+0x744>
34022454:	321c      	adds	r2, #28
34022456:	9b04      	ldr	r3, [sp, #16]
34022458:	4413      	add	r3, r2
3402245a:	4416      	add	r6, r2
3402245c:	9304      	str	r3, [sp, #16]
3402245e:	9b06      	ldr	r3, [sp, #24]
34022460:	4413      	add	r3, r2
34022462:	e78a      	b.n	3402237a <_dtoa_r+0x742>
34022464:	4602      	mov	r2, r0
34022466:	e7f5      	b.n	34022454 <_dtoa_r+0x81c>
34022468:	f1ba 0f00 	cmp.w	sl, #0
3402246c:	46d3      	mov	fp, sl
3402246e:	f8cd 8014 	str.w	r8, [sp, #20]
34022472:	dc21      	bgt.n	340224b8 <_dtoa_r+0x880>
34022474:	9b07      	ldr	r3, [sp, #28]
34022476:	2b02      	cmp	r3, #2
34022478:	dd1e      	ble.n	340224b8 <_dtoa_r+0x880>
3402247a:	f1bb 0f00 	cmp.w	fp, #0
3402247e:	f47f addc 	bne.w	3402203a <_dtoa_r+0x402>
34022482:	4621      	mov	r1, r4
34022484:	465b      	mov	r3, fp
34022486:	2205      	movs	r2, #5
34022488:	4648      	mov	r0, r9
3402248a:	f000 f9df 	bl	3402284c <__multadd>
3402248e:	4601      	mov	r1, r0
34022490:	4604      	mov	r4, r0
34022492:	9801      	ldr	r0, [sp, #4]
34022494:	f000 fbee 	bl	34022c74 <__mcmp>
34022498:	2800      	cmp	r0, #0
3402249a:	f77f adce 	ble.w	3402203a <_dtoa_r+0x402>
3402249e:	2331      	movs	r3, #49	@ 0x31
340224a0:	463e      	mov	r6, r7
340224a2:	f806 3b01 	strb.w	r3, [r6], #1
340224a6:	9b05      	ldr	r3, [sp, #20]
340224a8:	3301      	adds	r3, #1
340224aa:	9305      	str	r3, [sp, #20]
340224ac:	e5c9      	b.n	34022042 <_dtoa_r+0x40a>
340224ae:	4654      	mov	r4, sl
340224b0:	f8cd 8014 	str.w	r8, [sp, #20]
340224b4:	4625      	mov	r5, r4
340224b6:	e7f2      	b.n	3402249e <_dtoa_r+0x866>
340224b8:	9b08      	ldr	r3, [sp, #32]
340224ba:	2b00      	cmp	r3, #0
340224bc:	f000 8102 	beq.w	340226c4 <_dtoa_r+0xa8c>
340224c0:	2e00      	cmp	r6, #0
340224c2:	dd05      	ble.n	340224d0 <_dtoa_r+0x898>
340224c4:	4629      	mov	r1, r5
340224c6:	4632      	mov	r2, r6
340224c8:	4648      	mov	r0, r9
340224ca:	f000 fb67 	bl	34022b9c <__lshift>
340224ce:	4605      	mov	r5, r0
340224d0:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
340224d2:	2b00      	cmp	r3, #0
340224d4:	d058      	beq.n	34022588 <_dtoa_r+0x950>
340224d6:	6869      	ldr	r1, [r5, #4]
340224d8:	4648      	mov	r0, r9
340224da:	f000 f955 	bl	34022788 <_Balloc>
340224de:	4606      	mov	r6, r0
340224e0:	b928      	cbnz	r0, 340224ee <_dtoa_r+0x8b6>
340224e2:	4b82      	ldr	r3, [pc, #520]	@ (340226ec <_dtoa_r+0xab4>)
340224e4:	4602      	mov	r2, r0
340224e6:	f240 21ef 	movw	r1, #751	@ 0x2ef
340224ea:	f7ff bbbe 	b.w	34021c6a <_dtoa_r+0x32>
340224ee:	692a      	ldr	r2, [r5, #16]
340224f0:	f105 010c 	add.w	r1, r5, #12
340224f4:	300c      	adds	r0, #12
340224f6:	3202      	adds	r2, #2
340224f8:	0092      	lsls	r2, r2, #2
340224fa:	f7ff fafa 	bl	34021af2 <memcpy>
340224fe:	2201      	movs	r2, #1
34022500:	4631      	mov	r1, r6
34022502:	4648      	mov	r0, r9
34022504:	f000 fb4a 	bl	34022b9c <__lshift>
34022508:	1c7b      	adds	r3, r7, #1
3402250a:	46a8      	mov	r8, r5
3402250c:	4605      	mov	r5, r0
3402250e:	9304      	str	r3, [sp, #16]
34022510:	eb07 030b 	add.w	r3, r7, fp
34022514:	9309      	str	r3, [sp, #36]	@ 0x24
34022516:	9b02      	ldr	r3, [sp, #8]
34022518:	f003 0301 	and.w	r3, r3, #1
3402251c:	9308      	str	r3, [sp, #32]
3402251e:	9b04      	ldr	r3, [sp, #16]
34022520:	4621      	mov	r1, r4
34022522:	9801      	ldr	r0, [sp, #4]
34022524:	f103 3bff 	add.w	fp, r3, #4294967295
34022528:	f7ff faf7 	bl	34021b1a <quorem>
3402252c:	4641      	mov	r1, r8
3402252e:	9002      	str	r0, [sp, #8]
34022530:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
34022534:	9801      	ldr	r0, [sp, #4]
34022536:	f000 fb9d 	bl	34022c74 <__mcmp>
3402253a:	462a      	mov	r2, r5
3402253c:	9006      	str	r0, [sp, #24]
3402253e:	4621      	mov	r1, r4
34022540:	4648      	mov	r0, r9
34022542:	f000 fbb3 	bl	34022cac <__mdiff>
34022546:	68c2      	ldr	r2, [r0, #12]
34022548:	4606      	mov	r6, r0
3402254a:	b9fa      	cbnz	r2, 3402258c <_dtoa_r+0x954>
3402254c:	4601      	mov	r1, r0
3402254e:	9801      	ldr	r0, [sp, #4]
34022550:	f000 fb90 	bl	34022c74 <__mcmp>
34022554:	4602      	mov	r2, r0
34022556:	4631      	mov	r1, r6
34022558:	4648      	mov	r0, r9
3402255a:	920a      	str	r2, [sp, #40]	@ 0x28
3402255c:	f000 f954 	bl	34022808 <_Bfree>
34022560:	9b07      	ldr	r3, [sp, #28]
34022562:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
34022564:	9e04      	ldr	r6, [sp, #16]
34022566:	ea42 0103 	orr.w	r1, r2, r3
3402256a:	9b08      	ldr	r3, [sp, #32]
3402256c:	4319      	orrs	r1, r3
3402256e:	d10f      	bne.n	34022590 <_dtoa_r+0x958>
34022570:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34022574:	d028      	beq.n	340225c8 <_dtoa_r+0x990>
34022576:	9b06      	ldr	r3, [sp, #24]
34022578:	2b00      	cmp	r3, #0
3402257a:	dd02      	ble.n	34022582 <_dtoa_r+0x94a>
3402257c:	9b02      	ldr	r3, [sp, #8]
3402257e:	f103 0a31 	add.w	sl, r3, #49	@ 0x31
34022582:	f88b a000 	strb.w	sl, [fp]
34022586:	e55e      	b.n	34022046 <_dtoa_r+0x40e>
34022588:	4628      	mov	r0, r5
3402258a:	e7bd      	b.n	34022508 <_dtoa_r+0x8d0>
3402258c:	2201      	movs	r2, #1
3402258e:	e7e2      	b.n	34022556 <_dtoa_r+0x91e>
34022590:	9b06      	ldr	r3, [sp, #24]
34022592:	2b00      	cmp	r3, #0
34022594:	db04      	blt.n	340225a0 <_dtoa_r+0x968>
34022596:	9907      	ldr	r1, [sp, #28]
34022598:	430b      	orrs	r3, r1
3402259a:	9908      	ldr	r1, [sp, #32]
3402259c:	430b      	orrs	r3, r1
3402259e:	d120      	bne.n	340225e2 <_dtoa_r+0x9aa>
340225a0:	2a00      	cmp	r2, #0
340225a2:	ddee      	ble.n	34022582 <_dtoa_r+0x94a>
340225a4:	2201      	movs	r2, #1
340225a6:	9901      	ldr	r1, [sp, #4]
340225a8:	4648      	mov	r0, r9
340225aa:	f000 faf7 	bl	34022b9c <__lshift>
340225ae:	4621      	mov	r1, r4
340225b0:	9001      	str	r0, [sp, #4]
340225b2:	f000 fb5f 	bl	34022c74 <__mcmp>
340225b6:	2800      	cmp	r0, #0
340225b8:	dc03      	bgt.n	340225c2 <_dtoa_r+0x98a>
340225ba:	d1e2      	bne.n	34022582 <_dtoa_r+0x94a>
340225bc:	f01a 0f01 	tst.w	sl, #1
340225c0:	d0df      	beq.n	34022582 <_dtoa_r+0x94a>
340225c2:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
340225c6:	d1d9      	bne.n	3402257c <_dtoa_r+0x944>
340225c8:	2339      	movs	r3, #57	@ 0x39
340225ca:	f88b 3000 	strb.w	r3, [fp]
340225ce:	4633      	mov	r3, r6
340225d0:	461e      	mov	r6, r3
340225d2:	3b01      	subs	r3, #1
340225d4:	f816 2c01 	ldrb.w	r2, [r6, #-1]
340225d8:	2a39      	cmp	r2, #57	@ 0x39
340225da:	d052      	beq.n	34022682 <_dtoa_r+0xa4a>
340225dc:	3201      	adds	r2, #1
340225de:	701a      	strb	r2, [r3, #0]
340225e0:	e531      	b.n	34022046 <_dtoa_r+0x40e>
340225e2:	2a00      	cmp	r2, #0
340225e4:	dd07      	ble.n	340225f6 <_dtoa_r+0x9be>
340225e6:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
340225ea:	d0ed      	beq.n	340225c8 <_dtoa_r+0x990>
340225ec:	f10a 0301 	add.w	r3, sl, #1
340225f0:	f88b 3000 	strb.w	r3, [fp]
340225f4:	e527      	b.n	34022046 <_dtoa_r+0x40e>
340225f6:	9b04      	ldr	r3, [sp, #16]
340225f8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
340225fa:	f803 ac01 	strb.w	sl, [r3, #-1]
340225fe:	4293      	cmp	r3, r2
34022600:	d029      	beq.n	34022656 <_dtoa_r+0xa1e>
34022602:	2300      	movs	r3, #0
34022604:	220a      	movs	r2, #10
34022606:	9901      	ldr	r1, [sp, #4]
34022608:	4648      	mov	r0, r9
3402260a:	f000 f91f 	bl	3402284c <__multadd>
3402260e:	45a8      	cmp	r8, r5
34022610:	9001      	str	r0, [sp, #4]
34022612:	f04f 0300 	mov.w	r3, #0
34022616:	f04f 020a 	mov.w	r2, #10
3402261a:	4641      	mov	r1, r8
3402261c:	4648      	mov	r0, r9
3402261e:	d107      	bne.n	34022630 <_dtoa_r+0x9f8>
34022620:	f000 f914 	bl	3402284c <__multadd>
34022624:	4680      	mov	r8, r0
34022626:	4605      	mov	r5, r0
34022628:	9b04      	ldr	r3, [sp, #16]
3402262a:	3301      	adds	r3, #1
3402262c:	9304      	str	r3, [sp, #16]
3402262e:	e776      	b.n	3402251e <_dtoa_r+0x8e6>
34022630:	f000 f90c 	bl	3402284c <__multadd>
34022634:	4629      	mov	r1, r5
34022636:	4680      	mov	r8, r0
34022638:	2300      	movs	r3, #0
3402263a:	220a      	movs	r2, #10
3402263c:	4648      	mov	r0, r9
3402263e:	f000 f905 	bl	3402284c <__multadd>
34022642:	4605      	mov	r5, r0
34022644:	e7f0      	b.n	34022628 <_dtoa_r+0x9f0>
34022646:	f1bb 0f00 	cmp.w	fp, #0
3402264a:	f04f 0800 	mov.w	r8, #0
3402264e:	bfcc      	ite	gt
34022650:	465e      	movgt	r6, fp
34022652:	2601      	movle	r6, #1
34022654:	443e      	add	r6, r7
34022656:	2201      	movs	r2, #1
34022658:	9901      	ldr	r1, [sp, #4]
3402265a:	4648      	mov	r0, r9
3402265c:	f000 fa9e 	bl	34022b9c <__lshift>
34022660:	4621      	mov	r1, r4
34022662:	9001      	str	r0, [sp, #4]
34022664:	f000 fb06 	bl	34022c74 <__mcmp>
34022668:	2800      	cmp	r0, #0
3402266a:	dcb0      	bgt.n	340225ce <_dtoa_r+0x996>
3402266c:	d102      	bne.n	34022674 <_dtoa_r+0xa3c>
3402266e:	f01a 0f01 	tst.w	sl, #1
34022672:	d1ac      	bne.n	340225ce <_dtoa_r+0x996>
34022674:	4633      	mov	r3, r6
34022676:	461e      	mov	r6, r3
34022678:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3402267c:	2a30      	cmp	r2, #48	@ 0x30
3402267e:	d0fa      	beq.n	34022676 <_dtoa_r+0xa3e>
34022680:	e4e1      	b.n	34022046 <_dtoa_r+0x40e>
34022682:	429f      	cmp	r7, r3
34022684:	d1a4      	bne.n	340225d0 <_dtoa_r+0x998>
34022686:	9b05      	ldr	r3, [sp, #20]
34022688:	3301      	adds	r3, #1
3402268a:	9305      	str	r3, [sp, #20]
3402268c:	2331      	movs	r3, #49	@ 0x31
3402268e:	703b      	strb	r3, [r7, #0]
34022690:	e4d9      	b.n	34022046 <_dtoa_r+0x40e>
34022692:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34022694:	4f16      	ldr	r7, [pc, #88]	@ (340226f0 <_dtoa_r+0xab8>)
34022696:	b11b      	cbz	r3, 340226a0 <_dtoa_r+0xa68>
34022698:	f107 0308 	add.w	r3, r7, #8
3402269c:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
3402269e:	6013      	str	r3, [r2, #0]
340226a0:	4638      	mov	r0, r7
340226a2:	b011      	add	sp, #68	@ 0x44
340226a4:	ecbd 8b02 	vpop	{d8}
340226a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340226ac:	9b07      	ldr	r3, [sp, #28]
340226ae:	2b01      	cmp	r3, #1
340226b0:	f77f ae2c 	ble.w	3402230c <_dtoa_r+0x6d4>
340226b4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340226b6:	930b      	str	r3, [sp, #44]	@ 0x2c
340226b8:	2001      	movs	r0, #1
340226ba:	e64c      	b.n	34022356 <_dtoa_r+0x71e>
340226bc:	f1bb 0f00 	cmp.w	fp, #0
340226c0:	f77f aed8 	ble.w	34022474 <_dtoa_r+0x83c>
340226c4:	463e      	mov	r6, r7
340226c6:	4621      	mov	r1, r4
340226c8:	9801      	ldr	r0, [sp, #4]
340226ca:	f7ff fa26 	bl	34021b1a <quorem>
340226ce:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
340226d2:	f806 ab01 	strb.w	sl, [r6], #1
340226d6:	1bf2      	subs	r2, r6, r7
340226d8:	4593      	cmp	fp, r2
340226da:	ddb4      	ble.n	34022646 <_dtoa_r+0xa0e>
340226dc:	2300      	movs	r3, #0
340226de:	220a      	movs	r2, #10
340226e0:	9901      	ldr	r1, [sp, #4]
340226e2:	4648      	mov	r0, r9
340226e4:	f000 f8b2 	bl	3402284c <__multadd>
340226e8:	9001      	str	r0, [sp, #4]
340226ea:	e7ec      	b.n	340226c6 <_dtoa_r+0xa8e>
340226ec:	340339d0 	.word	0x340339d0
340226f0:	34033954 	.word	0x34033954

340226f4 <_free_r>:
340226f4:	b538      	push	{r3, r4, r5, lr}
340226f6:	4605      	mov	r5, r0
340226f8:	2900      	cmp	r1, #0
340226fa:	d041      	beq.n	34022780 <_free_r+0x8c>
340226fc:	f851 3c04 	ldr.w	r3, [r1, #-4]
34022700:	1f0c      	subs	r4, r1, #4
34022702:	2b00      	cmp	r3, #0
34022704:	bfb8      	it	lt
34022706:	18e4      	addlt	r4, r4, r3
34022708:	f7fd fe5a 	bl	340203c0 <__malloc_lock>
3402270c:	4a1d      	ldr	r2, [pc, #116]	@ (34022784 <_free_r+0x90>)
3402270e:	6813      	ldr	r3, [r2, #0]
34022710:	b933      	cbnz	r3, 34022720 <_free_r+0x2c>
34022712:	6063      	str	r3, [r4, #4]
34022714:	6014      	str	r4, [r2, #0]
34022716:	4628      	mov	r0, r5
34022718:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3402271c:	f7fd be56 	b.w	340203cc <__malloc_unlock>
34022720:	42a3      	cmp	r3, r4
34022722:	d908      	bls.n	34022736 <_free_r+0x42>
34022724:	6820      	ldr	r0, [r4, #0]
34022726:	1821      	adds	r1, r4, r0
34022728:	428b      	cmp	r3, r1
3402272a:	bf01      	itttt	eq
3402272c:	6819      	ldreq	r1, [r3, #0]
3402272e:	685b      	ldreq	r3, [r3, #4]
34022730:	1809      	addeq	r1, r1, r0
34022732:	6021      	streq	r1, [r4, #0]
34022734:	e7ed      	b.n	34022712 <_free_r+0x1e>
34022736:	461a      	mov	r2, r3
34022738:	685b      	ldr	r3, [r3, #4]
3402273a:	b10b      	cbz	r3, 34022740 <_free_r+0x4c>
3402273c:	42a3      	cmp	r3, r4
3402273e:	d9fa      	bls.n	34022736 <_free_r+0x42>
34022740:	6811      	ldr	r1, [r2, #0]
34022742:	1850      	adds	r0, r2, r1
34022744:	42a0      	cmp	r0, r4
34022746:	d10b      	bne.n	34022760 <_free_r+0x6c>
34022748:	6820      	ldr	r0, [r4, #0]
3402274a:	4401      	add	r1, r0
3402274c:	1850      	adds	r0, r2, r1
3402274e:	6011      	str	r1, [r2, #0]
34022750:	4283      	cmp	r3, r0
34022752:	d1e0      	bne.n	34022716 <_free_r+0x22>
34022754:	6818      	ldr	r0, [r3, #0]
34022756:	685b      	ldr	r3, [r3, #4]
34022758:	4408      	add	r0, r1
3402275a:	6053      	str	r3, [r2, #4]
3402275c:	6010      	str	r0, [r2, #0]
3402275e:	e7da      	b.n	34022716 <_free_r+0x22>
34022760:	d902      	bls.n	34022768 <_free_r+0x74>
34022762:	230c      	movs	r3, #12
34022764:	602b      	str	r3, [r5, #0]
34022766:	e7d6      	b.n	34022716 <_free_r+0x22>
34022768:	6820      	ldr	r0, [r4, #0]
3402276a:	1821      	adds	r1, r4, r0
3402276c:	428b      	cmp	r3, r1
3402276e:	bf02      	ittt	eq
34022770:	6819      	ldreq	r1, [r3, #0]
34022772:	685b      	ldreq	r3, [r3, #4]
34022774:	1809      	addeq	r1, r1, r0
34022776:	6063      	str	r3, [r4, #4]
34022778:	bf08      	it	eq
3402277a:	6021      	streq	r1, [r4, #0]
3402277c:	6054      	str	r4, [r2, #4]
3402277e:	e7ca      	b.n	34022716 <_free_r+0x22>
34022780:	bd38      	pop	{r3, r4, r5, pc}
34022782:	bf00      	nop
34022784:	34053dc0 	.word	0x34053dc0

34022788 <_Balloc>:
34022788:	b570      	push	{r4, r5, r6, lr}
3402278a:	69c6      	ldr	r6, [r0, #28]
3402278c:	4604      	mov	r4, r0
3402278e:	460d      	mov	r5, r1
34022790:	b976      	cbnz	r6, 340227b0 <_Balloc+0x28>
34022792:	2010      	movs	r0, #16
34022794:	f7fd fd6a 	bl	3402026c <malloc>
34022798:	4602      	mov	r2, r0
3402279a:	61e0      	str	r0, [r4, #28]
3402279c:	b920      	cbnz	r0, 340227a8 <_Balloc+0x20>
3402279e:	4b18      	ldr	r3, [pc, #96]	@ (34022800 <_Balloc+0x78>)
340227a0:	216b      	movs	r1, #107	@ 0x6b
340227a2:	4818      	ldr	r0, [pc, #96]	@ (34022804 <_Balloc+0x7c>)
340227a4:	f7fd fd44 	bl	34020230 <__assert_func>
340227a8:	e9c0 6601 	strd	r6, r6, [r0, #4]
340227ac:	6006      	str	r6, [r0, #0]
340227ae:	60c6      	str	r6, [r0, #12]
340227b0:	69e6      	ldr	r6, [r4, #28]
340227b2:	68f3      	ldr	r3, [r6, #12]
340227b4:	b183      	cbz	r3, 340227d8 <_Balloc+0x50>
340227b6:	69e3      	ldr	r3, [r4, #28]
340227b8:	68db      	ldr	r3, [r3, #12]
340227ba:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
340227be:	b9b8      	cbnz	r0, 340227f0 <_Balloc+0x68>
340227c0:	2101      	movs	r1, #1
340227c2:	4620      	mov	r0, r4
340227c4:	fa01 f605 	lsl.w	r6, r1, r5
340227c8:	1d72      	adds	r2, r6, #5
340227ca:	0092      	lsls	r2, r2, #2
340227cc:	f000 fec8 	bl	34023560 <_calloc_r>
340227d0:	b160      	cbz	r0, 340227ec <_Balloc+0x64>
340227d2:	e9c0 5601 	strd	r5, r6, [r0, #4]
340227d6:	e00e      	b.n	340227f6 <_Balloc+0x6e>
340227d8:	2221      	movs	r2, #33	@ 0x21
340227da:	2104      	movs	r1, #4
340227dc:	4620      	mov	r0, r4
340227de:	f000 febf 	bl	34023560 <_calloc_r>
340227e2:	69e3      	ldr	r3, [r4, #28]
340227e4:	60f0      	str	r0, [r6, #12]
340227e6:	68db      	ldr	r3, [r3, #12]
340227e8:	2b00      	cmp	r3, #0
340227ea:	d1e4      	bne.n	340227b6 <_Balloc+0x2e>
340227ec:	2000      	movs	r0, #0
340227ee:	bd70      	pop	{r4, r5, r6, pc}
340227f0:	6802      	ldr	r2, [r0, #0]
340227f2:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
340227f6:	2300      	movs	r3, #0
340227f8:	e9c0 3303 	strd	r3, r3, [r0, #12]
340227fc:	e7f7      	b.n	340227ee <_Balloc+0x66>
340227fe:	bf00      	nop
34022800:	34033961 	.word	0x34033961
34022804:	340339e1 	.word	0x340339e1

34022808 <_Bfree>:
34022808:	b570      	push	{r4, r5, r6, lr}
3402280a:	69c6      	ldr	r6, [r0, #28]
3402280c:	4605      	mov	r5, r0
3402280e:	460c      	mov	r4, r1
34022810:	b976      	cbnz	r6, 34022830 <_Bfree+0x28>
34022812:	2010      	movs	r0, #16
34022814:	f7fd fd2a 	bl	3402026c <malloc>
34022818:	4602      	mov	r2, r0
3402281a:	61e8      	str	r0, [r5, #28]
3402281c:	b920      	cbnz	r0, 34022828 <_Bfree+0x20>
3402281e:	4b09      	ldr	r3, [pc, #36]	@ (34022844 <_Bfree+0x3c>)
34022820:	218f      	movs	r1, #143	@ 0x8f
34022822:	4809      	ldr	r0, [pc, #36]	@ (34022848 <_Bfree+0x40>)
34022824:	f7fd fd04 	bl	34020230 <__assert_func>
34022828:	e9c0 6601 	strd	r6, r6, [r0, #4]
3402282c:	6006      	str	r6, [r0, #0]
3402282e:	60c6      	str	r6, [r0, #12]
34022830:	b13c      	cbz	r4, 34022842 <_Bfree+0x3a>
34022832:	69eb      	ldr	r3, [r5, #28]
34022834:	6862      	ldr	r2, [r4, #4]
34022836:	68db      	ldr	r3, [r3, #12]
34022838:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3402283c:	6021      	str	r1, [r4, #0]
3402283e:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
34022842:	bd70      	pop	{r4, r5, r6, pc}
34022844:	34033961 	.word	0x34033961
34022848:	340339e1 	.word	0x340339e1

3402284c <__multadd>:
3402284c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34022850:	f101 0c14 	add.w	ip, r1, #20
34022854:	4607      	mov	r7, r0
34022856:	460c      	mov	r4, r1
34022858:	461e      	mov	r6, r3
3402285a:	690d      	ldr	r5, [r1, #16]
3402285c:	2000      	movs	r0, #0
3402285e:	f8dc 3000 	ldr.w	r3, [ip]
34022862:	3001      	adds	r0, #1
34022864:	b299      	uxth	r1, r3
34022866:	4285      	cmp	r5, r0
34022868:	fb02 6101 	mla	r1, r2, r1, r6
3402286c:	ea4f 4613 	mov.w	r6, r3, lsr #16
34022870:	ea4f 4311 	mov.w	r3, r1, lsr #16
34022874:	b289      	uxth	r1, r1
34022876:	fb02 3306 	mla	r3, r2, r6, r3
3402287a:	eb01 4103 	add.w	r1, r1, r3, lsl #16
3402287e:	ea4f 4613 	mov.w	r6, r3, lsr #16
34022882:	f84c 1b04 	str.w	r1, [ip], #4
34022886:	dcea      	bgt.n	3402285e <__multadd+0x12>
34022888:	b30e      	cbz	r6, 340228ce <__multadd+0x82>
3402288a:	68a3      	ldr	r3, [r4, #8]
3402288c:	42ab      	cmp	r3, r5
3402288e:	dc19      	bgt.n	340228c4 <__multadd+0x78>
34022890:	6861      	ldr	r1, [r4, #4]
34022892:	4638      	mov	r0, r7
34022894:	3101      	adds	r1, #1
34022896:	f7ff ff77 	bl	34022788 <_Balloc>
3402289a:	4680      	mov	r8, r0
3402289c:	b928      	cbnz	r0, 340228aa <__multadd+0x5e>
3402289e:	4602      	mov	r2, r0
340228a0:	4b0c      	ldr	r3, [pc, #48]	@ (340228d4 <__multadd+0x88>)
340228a2:	21ba      	movs	r1, #186	@ 0xba
340228a4:	480c      	ldr	r0, [pc, #48]	@ (340228d8 <__multadd+0x8c>)
340228a6:	f7fd fcc3 	bl	34020230 <__assert_func>
340228aa:	6922      	ldr	r2, [r4, #16]
340228ac:	f104 010c 	add.w	r1, r4, #12
340228b0:	300c      	adds	r0, #12
340228b2:	3202      	adds	r2, #2
340228b4:	0092      	lsls	r2, r2, #2
340228b6:	f7ff f91c 	bl	34021af2 <memcpy>
340228ba:	4621      	mov	r1, r4
340228bc:	4644      	mov	r4, r8
340228be:	4638      	mov	r0, r7
340228c0:	f7ff ffa2 	bl	34022808 <_Bfree>
340228c4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
340228c8:	3501      	adds	r5, #1
340228ca:	615e      	str	r6, [r3, #20]
340228cc:	6125      	str	r5, [r4, #16]
340228ce:	4620      	mov	r0, r4
340228d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
340228d4:	340339d0 	.word	0x340339d0
340228d8:	340339e1 	.word	0x340339e1

340228dc <__hi0bits>:
340228dc:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
340228e0:	4603      	mov	r3, r0
340228e2:	bf36      	itet	cc
340228e4:	0403      	lslcc	r3, r0, #16
340228e6:	2000      	movcs	r0, #0
340228e8:	2010      	movcc	r0, #16
340228ea:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340228ee:	bf3c      	itt	cc
340228f0:	021b      	lslcc	r3, r3, #8
340228f2:	3008      	addcc	r0, #8
340228f4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340228f8:	bf3c      	itt	cc
340228fa:	011b      	lslcc	r3, r3, #4
340228fc:	3004      	addcc	r0, #4
340228fe:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34022902:	bf3c      	itt	cc
34022904:	009b      	lslcc	r3, r3, #2
34022906:	3002      	addcc	r0, #2
34022908:	2b00      	cmp	r3, #0
3402290a:	db05      	blt.n	34022918 <__hi0bits+0x3c>
3402290c:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
34022910:	f100 0001 	add.w	r0, r0, #1
34022914:	bf08      	it	eq
34022916:	2020      	moveq	r0, #32
34022918:	4770      	bx	lr

3402291a <__lo0bits>:
3402291a:	6803      	ldr	r3, [r0, #0]
3402291c:	4602      	mov	r2, r0
3402291e:	f013 0007 	ands.w	r0, r3, #7
34022922:	d00b      	beq.n	3402293c <__lo0bits+0x22>
34022924:	07d9      	lsls	r1, r3, #31
34022926:	d421      	bmi.n	3402296c <__lo0bits+0x52>
34022928:	0798      	lsls	r0, r3, #30
3402292a:	bf47      	ittee	mi
3402292c:	085b      	lsrmi	r3, r3, #1
3402292e:	2001      	movmi	r0, #1
34022930:	089b      	lsrpl	r3, r3, #2
34022932:	2002      	movpl	r0, #2
34022934:	bf4c      	ite	mi
34022936:	6013      	strmi	r3, [r2, #0]
34022938:	6013      	strpl	r3, [r2, #0]
3402293a:	4770      	bx	lr
3402293c:	b299      	uxth	r1, r3
3402293e:	b909      	cbnz	r1, 34022944 <__lo0bits+0x2a>
34022940:	0c1b      	lsrs	r3, r3, #16
34022942:	2010      	movs	r0, #16
34022944:	b2d9      	uxtb	r1, r3
34022946:	b909      	cbnz	r1, 3402294c <__lo0bits+0x32>
34022948:	3008      	adds	r0, #8
3402294a:	0a1b      	lsrs	r3, r3, #8
3402294c:	0719      	lsls	r1, r3, #28
3402294e:	bf04      	itt	eq
34022950:	091b      	lsreq	r3, r3, #4
34022952:	3004      	addeq	r0, #4
34022954:	0799      	lsls	r1, r3, #30
34022956:	bf04      	itt	eq
34022958:	089b      	lsreq	r3, r3, #2
3402295a:	3002      	addeq	r0, #2
3402295c:	07d9      	lsls	r1, r3, #31
3402295e:	d403      	bmi.n	34022968 <__lo0bits+0x4e>
34022960:	085b      	lsrs	r3, r3, #1
34022962:	f100 0001 	add.w	r0, r0, #1
34022966:	d003      	beq.n	34022970 <__lo0bits+0x56>
34022968:	6013      	str	r3, [r2, #0]
3402296a:	4770      	bx	lr
3402296c:	2000      	movs	r0, #0
3402296e:	4770      	bx	lr
34022970:	2020      	movs	r0, #32
34022972:	4770      	bx	lr

34022974 <__i2b>:
34022974:	b510      	push	{r4, lr}
34022976:	460c      	mov	r4, r1
34022978:	2101      	movs	r1, #1
3402297a:	f7ff ff05 	bl	34022788 <_Balloc>
3402297e:	4602      	mov	r2, r0
34022980:	b928      	cbnz	r0, 3402298e <__i2b+0x1a>
34022982:	4b05      	ldr	r3, [pc, #20]	@ (34022998 <__i2b+0x24>)
34022984:	f240 1145 	movw	r1, #325	@ 0x145
34022988:	4804      	ldr	r0, [pc, #16]	@ (3402299c <__i2b+0x28>)
3402298a:	f7fd fc51 	bl	34020230 <__assert_func>
3402298e:	2301      	movs	r3, #1
34022990:	6144      	str	r4, [r0, #20]
34022992:	6103      	str	r3, [r0, #16]
34022994:	bd10      	pop	{r4, pc}
34022996:	bf00      	nop
34022998:	340339d0 	.word	0x340339d0
3402299c:	340339e1 	.word	0x340339e1

340229a0 <__multiply>:
340229a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340229a4:	4617      	mov	r7, r2
340229a6:	690a      	ldr	r2, [r1, #16]
340229a8:	4689      	mov	r9, r1
340229aa:	b085      	sub	sp, #20
340229ac:	693b      	ldr	r3, [r7, #16]
340229ae:	429a      	cmp	r2, r3
340229b0:	bfa2      	ittt	ge
340229b2:	463b      	movge	r3, r7
340229b4:	460f      	movge	r7, r1
340229b6:	4699      	movge	r9, r3
340229b8:	693d      	ldr	r5, [r7, #16]
340229ba:	68bb      	ldr	r3, [r7, #8]
340229bc:	f8d9 a010 	ldr.w	sl, [r9, #16]
340229c0:	6879      	ldr	r1, [r7, #4]
340229c2:	eb05 060a 	add.w	r6, r5, sl
340229c6:	42b3      	cmp	r3, r6
340229c8:	bfb8      	it	lt
340229ca:	3101      	addlt	r1, #1
340229cc:	f7ff fedc 	bl	34022788 <_Balloc>
340229d0:	b930      	cbnz	r0, 340229e0 <__multiply+0x40>
340229d2:	4602      	mov	r2, r0
340229d4:	4b42      	ldr	r3, [pc, #264]	@ (34022ae0 <__multiply+0x140>)
340229d6:	f44f 71b1 	mov.w	r1, #354	@ 0x162
340229da:	4842      	ldr	r0, [pc, #264]	@ (34022ae4 <__multiply+0x144>)
340229dc:	f7fd fc28 	bl	34020230 <__assert_func>
340229e0:	f100 0414 	add.w	r4, r0, #20
340229e4:	2200      	movs	r2, #0
340229e6:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
340229ea:	4623      	mov	r3, r4
340229ec:	4573      	cmp	r3, lr
340229ee:	d320      	bcc.n	34022a32 <__multiply+0x92>
340229f0:	f107 0814 	add.w	r8, r7, #20
340229f4:	f109 0114 	add.w	r1, r9, #20
340229f8:	eb08 0585 	add.w	r5, r8, r5, lsl #2
340229fc:	eb01 038a 	add.w	r3, r1, sl, lsl #2
34022a00:	9302      	str	r3, [sp, #8]
34022a02:	1beb      	subs	r3, r5, r7
34022a04:	3715      	adds	r7, #21
34022a06:	3b15      	subs	r3, #21
34022a08:	f023 0303 	bic.w	r3, r3, #3
34022a0c:	3304      	adds	r3, #4
34022a0e:	42bd      	cmp	r5, r7
34022a10:	bf38      	it	cc
34022a12:	2304      	movcc	r3, #4
34022a14:	9301      	str	r3, [sp, #4]
34022a16:	9b02      	ldr	r3, [sp, #8]
34022a18:	9103      	str	r1, [sp, #12]
34022a1a:	428b      	cmp	r3, r1
34022a1c:	d80c      	bhi.n	34022a38 <__multiply+0x98>
34022a1e:	2e00      	cmp	r6, #0
34022a20:	dd03      	ble.n	34022a2a <__multiply+0x8a>
34022a22:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
34022a26:	2b00      	cmp	r3, #0
34022a28:	d057      	beq.n	34022ada <__multiply+0x13a>
34022a2a:	6106      	str	r6, [r0, #16]
34022a2c:	b005      	add	sp, #20
34022a2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34022a32:	f843 2b04 	str.w	r2, [r3], #4
34022a36:	e7d9      	b.n	340229ec <__multiply+0x4c>
34022a38:	f8b1 a000 	ldrh.w	sl, [r1]
34022a3c:	f1ba 0f00 	cmp.w	sl, #0
34022a40:	d021      	beq.n	34022a86 <__multiply+0xe6>
34022a42:	46c4      	mov	ip, r8
34022a44:	46a1      	mov	r9, r4
34022a46:	2700      	movs	r7, #0
34022a48:	f85c 2b04 	ldr.w	r2, [ip], #4
34022a4c:	f8d9 3000 	ldr.w	r3, [r9]
34022a50:	fa1f fb82 	uxth.w	fp, r2
34022a54:	4565      	cmp	r5, ip
34022a56:	b29b      	uxth	r3, r3
34022a58:	ea4f 4212 	mov.w	r2, r2, lsr #16
34022a5c:	fb0a 330b 	mla	r3, sl, fp, r3
34022a60:	443b      	add	r3, r7
34022a62:	f8d9 7000 	ldr.w	r7, [r9]
34022a66:	ea4f 4717 	mov.w	r7, r7, lsr #16
34022a6a:	fb0a 7202 	mla	r2, sl, r2, r7
34022a6e:	eb02 4213 	add.w	r2, r2, r3, lsr #16
34022a72:	b29b      	uxth	r3, r3
34022a74:	ea4f 4712 	mov.w	r7, r2, lsr #16
34022a78:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
34022a7c:	f849 3b04 	str.w	r3, [r9], #4
34022a80:	d8e2      	bhi.n	34022a48 <__multiply+0xa8>
34022a82:	9b01      	ldr	r3, [sp, #4]
34022a84:	50e7      	str	r7, [r4, r3]
34022a86:	9b03      	ldr	r3, [sp, #12]
34022a88:	3104      	adds	r1, #4
34022a8a:	f8b3 9002 	ldrh.w	r9, [r3, #2]
34022a8e:	f1b9 0f00 	cmp.w	r9, #0
34022a92:	d020      	beq.n	34022ad6 <__multiply+0x136>
34022a94:	6823      	ldr	r3, [r4, #0]
34022a96:	4647      	mov	r7, r8
34022a98:	46a4      	mov	ip, r4
34022a9a:	f04f 0a00 	mov.w	sl, #0
34022a9e:	f8b7 b000 	ldrh.w	fp, [r7]
34022aa2:	b29b      	uxth	r3, r3
34022aa4:	f8bc 2002 	ldrh.w	r2, [ip, #2]
34022aa8:	fb09 220b 	mla	r2, r9, fp, r2
34022aac:	4452      	add	r2, sl
34022aae:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
34022ab2:	f84c 3b04 	str.w	r3, [ip], #4
34022ab6:	f857 3b04 	ldr.w	r3, [r7], #4
34022aba:	ea4f 4a13 	mov.w	sl, r3, lsr #16
34022abe:	f8bc 3000 	ldrh.w	r3, [ip]
34022ac2:	42bd      	cmp	r5, r7
34022ac4:	fb09 330a 	mla	r3, r9, sl, r3
34022ac8:	eb03 4312 	add.w	r3, r3, r2, lsr #16
34022acc:	ea4f 4a13 	mov.w	sl, r3, lsr #16
34022ad0:	d8e5      	bhi.n	34022a9e <__multiply+0xfe>
34022ad2:	9a01      	ldr	r2, [sp, #4]
34022ad4:	50a3      	str	r3, [r4, r2]
34022ad6:	3404      	adds	r4, #4
34022ad8:	e79d      	b.n	34022a16 <__multiply+0x76>
34022ada:	3e01      	subs	r6, #1
34022adc:	e79f      	b.n	34022a1e <__multiply+0x7e>
34022ade:	bf00      	nop
34022ae0:	340339d0 	.word	0x340339d0
34022ae4:	340339e1 	.word	0x340339e1

34022ae8 <__pow5mult>:
34022ae8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34022aec:	4615      	mov	r5, r2
34022aee:	f012 0203 	ands.w	r2, r2, #3
34022af2:	4607      	mov	r7, r0
34022af4:	460e      	mov	r6, r1
34022af6:	d007      	beq.n	34022b08 <__pow5mult+0x20>
34022af8:	3a01      	subs	r2, #1
34022afa:	4c25      	ldr	r4, [pc, #148]	@ (34022b90 <__pow5mult+0xa8>)
34022afc:	2300      	movs	r3, #0
34022afe:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
34022b02:	f7ff fea3 	bl	3402284c <__multadd>
34022b06:	4606      	mov	r6, r0
34022b08:	10ad      	asrs	r5, r5, #2
34022b0a:	d03d      	beq.n	34022b88 <__pow5mult+0xa0>
34022b0c:	69fc      	ldr	r4, [r7, #28]
34022b0e:	b97c      	cbnz	r4, 34022b30 <__pow5mult+0x48>
34022b10:	2010      	movs	r0, #16
34022b12:	f7fd fbab 	bl	3402026c <malloc>
34022b16:	4602      	mov	r2, r0
34022b18:	61f8      	str	r0, [r7, #28]
34022b1a:	b928      	cbnz	r0, 34022b28 <__pow5mult+0x40>
34022b1c:	4b1d      	ldr	r3, [pc, #116]	@ (34022b94 <__pow5mult+0xac>)
34022b1e:	f240 11b3 	movw	r1, #435	@ 0x1b3
34022b22:	481d      	ldr	r0, [pc, #116]	@ (34022b98 <__pow5mult+0xb0>)
34022b24:	f7fd fb84 	bl	34020230 <__assert_func>
34022b28:	e9c0 4401 	strd	r4, r4, [r0, #4]
34022b2c:	6004      	str	r4, [r0, #0]
34022b2e:	60c4      	str	r4, [r0, #12]
34022b30:	f8d7 801c 	ldr.w	r8, [r7, #28]
34022b34:	f8d8 4008 	ldr.w	r4, [r8, #8]
34022b38:	b94c      	cbnz	r4, 34022b4e <__pow5mult+0x66>
34022b3a:	f240 2171 	movw	r1, #625	@ 0x271
34022b3e:	4638      	mov	r0, r7
34022b40:	f7ff ff18 	bl	34022974 <__i2b>
34022b44:	2300      	movs	r3, #0
34022b46:	4604      	mov	r4, r0
34022b48:	f8c8 0008 	str.w	r0, [r8, #8]
34022b4c:	6003      	str	r3, [r0, #0]
34022b4e:	f04f 0900 	mov.w	r9, #0
34022b52:	07eb      	lsls	r3, r5, #31
34022b54:	d50a      	bpl.n	34022b6c <__pow5mult+0x84>
34022b56:	4631      	mov	r1, r6
34022b58:	4622      	mov	r2, r4
34022b5a:	4638      	mov	r0, r7
34022b5c:	f7ff ff20 	bl	340229a0 <__multiply>
34022b60:	4680      	mov	r8, r0
34022b62:	4631      	mov	r1, r6
34022b64:	4638      	mov	r0, r7
34022b66:	4646      	mov	r6, r8
34022b68:	f7ff fe4e 	bl	34022808 <_Bfree>
34022b6c:	106d      	asrs	r5, r5, #1
34022b6e:	d00b      	beq.n	34022b88 <__pow5mult+0xa0>
34022b70:	6820      	ldr	r0, [r4, #0]
34022b72:	b938      	cbnz	r0, 34022b84 <__pow5mult+0x9c>
34022b74:	4622      	mov	r2, r4
34022b76:	4621      	mov	r1, r4
34022b78:	4638      	mov	r0, r7
34022b7a:	f7ff ff11 	bl	340229a0 <__multiply>
34022b7e:	6020      	str	r0, [r4, #0]
34022b80:	f8c0 9000 	str.w	r9, [r0]
34022b84:	4604      	mov	r4, r0
34022b86:	e7e4      	b.n	34022b52 <__pow5mult+0x6a>
34022b88:	4630      	mov	r0, r6
34022b8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
34022b8e:	bf00      	nop
34022b90:	34033a58 	.word	0x34033a58
34022b94:	34033961 	.word	0x34033961
34022b98:	340339e1 	.word	0x340339e1

34022b9c <__lshift>:
34022b9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34022ba0:	460c      	mov	r4, r1
34022ba2:	4607      	mov	r7, r0
34022ba4:	4691      	mov	r9, r2
34022ba6:	ea4f 1a62 	mov.w	sl, r2, asr #5
34022baa:	6923      	ldr	r3, [r4, #16]
34022bac:	6849      	ldr	r1, [r1, #4]
34022bae:	eb03 1862 	add.w	r8, r3, r2, asr #5
34022bb2:	68a3      	ldr	r3, [r4, #8]
34022bb4:	f108 0601 	add.w	r6, r8, #1
34022bb8:	42b3      	cmp	r3, r6
34022bba:	db0b      	blt.n	34022bd4 <__lshift+0x38>
34022bbc:	4638      	mov	r0, r7
34022bbe:	f7ff fde3 	bl	34022788 <_Balloc>
34022bc2:	4605      	mov	r5, r0
34022bc4:	b948      	cbnz	r0, 34022bda <__lshift+0x3e>
34022bc6:	4602      	mov	r2, r0
34022bc8:	4b28      	ldr	r3, [pc, #160]	@ (34022c6c <__lshift+0xd0>)
34022bca:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
34022bce:	4828      	ldr	r0, [pc, #160]	@ (34022c70 <__lshift+0xd4>)
34022bd0:	f7fd fb2e 	bl	34020230 <__assert_func>
34022bd4:	3101      	adds	r1, #1
34022bd6:	005b      	lsls	r3, r3, #1
34022bd8:	e7ee      	b.n	34022bb8 <__lshift+0x1c>
34022bda:	2300      	movs	r3, #0
34022bdc:	f100 0114 	add.w	r1, r0, #20
34022be0:	f100 0210 	add.w	r2, r0, #16
34022be4:	4618      	mov	r0, r3
34022be6:	4553      	cmp	r3, sl
34022be8:	db33      	blt.n	34022c52 <__lshift+0xb6>
34022bea:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
34022bee:	f104 0314 	add.w	r3, r4, #20
34022bf2:	6920      	ldr	r0, [r4, #16]
34022bf4:	f019 091f 	ands.w	r9, r9, #31
34022bf8:	eb01 018a 	add.w	r1, r1, sl, lsl #2
34022bfc:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
34022c00:	d02b      	beq.n	34022c5a <__lshift+0xbe>
34022c02:	f1c9 0e20 	rsb	lr, r9, #32
34022c06:	468a      	mov	sl, r1
34022c08:	2200      	movs	r2, #0
34022c0a:	6818      	ldr	r0, [r3, #0]
34022c0c:	fa00 f009 	lsl.w	r0, r0, r9
34022c10:	4310      	orrs	r0, r2
34022c12:	f84a 0b04 	str.w	r0, [sl], #4
34022c16:	f853 2b04 	ldr.w	r2, [r3], #4
34022c1a:	459c      	cmp	ip, r3
34022c1c:	fa22 f20e 	lsr.w	r2, r2, lr
34022c20:	d8f3      	bhi.n	34022c0a <__lshift+0x6e>
34022c22:	ebac 0304 	sub.w	r3, ip, r4
34022c26:	f104 0015 	add.w	r0, r4, #21
34022c2a:	3b15      	subs	r3, #21
34022c2c:	f023 0303 	bic.w	r3, r3, #3
34022c30:	3304      	adds	r3, #4
34022c32:	4560      	cmp	r0, ip
34022c34:	bf88      	it	hi
34022c36:	2304      	movhi	r3, #4
34022c38:	50ca      	str	r2, [r1, r3]
34022c3a:	b10a      	cbz	r2, 34022c40 <__lshift+0xa4>
34022c3c:	f108 0602 	add.w	r6, r8, #2
34022c40:	3e01      	subs	r6, #1
34022c42:	4638      	mov	r0, r7
34022c44:	4621      	mov	r1, r4
34022c46:	612e      	str	r6, [r5, #16]
34022c48:	f7ff fdde 	bl	34022808 <_Bfree>
34022c4c:	4628      	mov	r0, r5
34022c4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34022c52:	3301      	adds	r3, #1
34022c54:	f842 0f04 	str.w	r0, [r2, #4]!
34022c58:	e7c5      	b.n	34022be6 <__lshift+0x4a>
34022c5a:	3904      	subs	r1, #4
34022c5c:	f853 2b04 	ldr.w	r2, [r3], #4
34022c60:	459c      	cmp	ip, r3
34022c62:	f841 2f04 	str.w	r2, [r1, #4]!
34022c66:	d8f9      	bhi.n	34022c5c <__lshift+0xc0>
34022c68:	e7ea      	b.n	34022c40 <__lshift+0xa4>
34022c6a:	bf00      	nop
34022c6c:	340339d0 	.word	0x340339d0
34022c70:	340339e1 	.word	0x340339e1

34022c74 <__mcmp>:
34022c74:	4603      	mov	r3, r0
34022c76:	690a      	ldr	r2, [r1, #16]
34022c78:	6900      	ldr	r0, [r0, #16]
34022c7a:	1a80      	subs	r0, r0, r2
34022c7c:	b530      	push	{r4, r5, lr}
34022c7e:	d10e      	bne.n	34022c9e <__mcmp+0x2a>
34022c80:	3314      	adds	r3, #20
34022c82:	3114      	adds	r1, #20
34022c84:	eb03 0482 	add.w	r4, r3, r2, lsl #2
34022c88:	eb01 0182 	add.w	r1, r1, r2, lsl #2
34022c8c:	f854 5d04 	ldr.w	r5, [r4, #-4]!
34022c90:	f851 2d04 	ldr.w	r2, [r1, #-4]!
34022c94:	4295      	cmp	r5, r2
34022c96:	d003      	beq.n	34022ca0 <__mcmp+0x2c>
34022c98:	d205      	bcs.n	34022ca6 <__mcmp+0x32>
34022c9a:	f04f 30ff 	mov.w	r0, #4294967295
34022c9e:	bd30      	pop	{r4, r5, pc}
34022ca0:	42a3      	cmp	r3, r4
34022ca2:	d3f3      	bcc.n	34022c8c <__mcmp+0x18>
34022ca4:	e7fb      	b.n	34022c9e <__mcmp+0x2a>
34022ca6:	2001      	movs	r0, #1
34022ca8:	e7f9      	b.n	34022c9e <__mcmp+0x2a>
	...

34022cac <__mdiff>:
34022cac:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34022cb0:	4689      	mov	r9, r1
34022cb2:	4606      	mov	r6, r0
34022cb4:	4611      	mov	r1, r2
34022cb6:	4614      	mov	r4, r2
34022cb8:	4648      	mov	r0, r9
34022cba:	f7ff ffdb 	bl	34022c74 <__mcmp>
34022cbe:	1e05      	subs	r5, r0, #0
34022cc0:	d112      	bne.n	34022ce8 <__mdiff+0x3c>
34022cc2:	4629      	mov	r1, r5
34022cc4:	4630      	mov	r0, r6
34022cc6:	f7ff fd5f 	bl	34022788 <_Balloc>
34022cca:	4602      	mov	r2, r0
34022ccc:	b928      	cbnz	r0, 34022cda <__mdiff+0x2e>
34022cce:	4b41      	ldr	r3, [pc, #260]	@ (34022dd4 <__mdiff+0x128>)
34022cd0:	f240 2137 	movw	r1, #567	@ 0x237
34022cd4:	4840      	ldr	r0, [pc, #256]	@ (34022dd8 <__mdiff+0x12c>)
34022cd6:	f7fd faab 	bl	34020230 <__assert_func>
34022cda:	2301      	movs	r3, #1
34022cdc:	e9c0 3504 	strd	r3, r5, [r0, #16]
34022ce0:	4610      	mov	r0, r2
34022ce2:	b003      	add	sp, #12
34022ce4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34022ce8:	bfbc      	itt	lt
34022cea:	464b      	movlt	r3, r9
34022cec:	46a1      	movlt	r9, r4
34022cee:	4630      	mov	r0, r6
34022cf0:	bfb8      	it	lt
34022cf2:	2501      	movlt	r5, #1
34022cf4:	f8d9 1004 	ldr.w	r1, [r9, #4]
34022cf8:	bfb4      	ite	lt
34022cfa:	461c      	movlt	r4, r3
34022cfc:	2500      	movge	r5, #0
34022cfe:	f7ff fd43 	bl	34022788 <_Balloc>
34022d02:	4602      	mov	r2, r0
34022d04:	b918      	cbnz	r0, 34022d0e <__mdiff+0x62>
34022d06:	4b33      	ldr	r3, [pc, #204]	@ (34022dd4 <__mdiff+0x128>)
34022d08:	f240 2145 	movw	r1, #581	@ 0x245
34022d0c:	e7e2      	b.n	34022cd4 <__mdiff+0x28>
34022d0e:	f8d9 7010 	ldr.w	r7, [r9, #16]
34022d12:	f104 0e14 	add.w	lr, r4, #20
34022d16:	6926      	ldr	r6, [r4, #16]
34022d18:	f100 0b14 	add.w	fp, r0, #20
34022d1c:	60c5      	str	r5, [r0, #12]
34022d1e:	f109 0514 	add.w	r5, r9, #20
34022d22:	f109 0310 	add.w	r3, r9, #16
34022d26:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
34022d2a:	eb05 0887 	add.w	r8, r5, r7, lsl #2
34022d2e:	46d9      	mov	r9, fp
34022d30:	f04f 0c00 	mov.w	ip, #0
34022d34:	9301      	str	r3, [sp, #4]
34022d36:	9b01      	ldr	r3, [sp, #4]
34022d38:	f85e 0b04 	ldr.w	r0, [lr], #4
34022d3c:	f853 af04 	ldr.w	sl, [r3, #4]!
34022d40:	4576      	cmp	r6, lr
34022d42:	9301      	str	r3, [sp, #4]
34022d44:	fa1f f38a 	uxth.w	r3, sl
34022d48:	4619      	mov	r1, r3
34022d4a:	b283      	uxth	r3, r0
34022d4c:	ea4f 4010 	mov.w	r0, r0, lsr #16
34022d50:	eba1 0303 	sub.w	r3, r1, r3
34022d54:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
34022d58:	4463      	add	r3, ip
34022d5a:	eb00 4023 	add.w	r0, r0, r3, asr #16
34022d5e:	b29b      	uxth	r3, r3
34022d60:	ea4f 4c20 	mov.w	ip, r0, asr #16
34022d64:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34022d68:	f849 3b04 	str.w	r3, [r9], #4
34022d6c:	d8e3      	bhi.n	34022d36 <__mdiff+0x8a>
34022d6e:	1b33      	subs	r3, r6, r4
34022d70:	3415      	adds	r4, #21
34022d72:	3b15      	subs	r3, #21
34022d74:	f023 0303 	bic.w	r3, r3, #3
34022d78:	3304      	adds	r3, #4
34022d7a:	42a6      	cmp	r6, r4
34022d7c:	bf38      	it	cc
34022d7e:	2304      	movcc	r3, #4
34022d80:	441d      	add	r5, r3
34022d82:	445b      	add	r3, fp
34022d84:	462c      	mov	r4, r5
34022d86:	461e      	mov	r6, r3
34022d88:	4544      	cmp	r4, r8
34022d8a:	d30e      	bcc.n	34022daa <__mdiff+0xfe>
34022d8c:	f108 0103 	add.w	r1, r8, #3
34022d90:	1b49      	subs	r1, r1, r5
34022d92:	3d03      	subs	r5, #3
34022d94:	f021 0103 	bic.w	r1, r1, #3
34022d98:	45a8      	cmp	r8, r5
34022d9a:	bf38      	it	cc
34022d9c:	2100      	movcc	r1, #0
34022d9e:	440b      	add	r3, r1
34022da0:	f853 1d04 	ldr.w	r1, [r3, #-4]!
34022da4:	b199      	cbz	r1, 34022dce <__mdiff+0x122>
34022da6:	6117      	str	r7, [r2, #16]
34022da8:	e79a      	b.n	34022ce0 <__mdiff+0x34>
34022daa:	f854 1b04 	ldr.w	r1, [r4], #4
34022dae:	46e6      	mov	lr, ip
34022db0:	fa1f fc81 	uxth.w	ip, r1
34022db4:	0c08      	lsrs	r0, r1, #16
34022db6:	4471      	add	r1, lr
34022db8:	44f4      	add	ip, lr
34022dba:	b289      	uxth	r1, r1
34022dbc:	eb00 402c 	add.w	r0, r0, ip, asr #16
34022dc0:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
34022dc4:	ea4f 4c20 	mov.w	ip, r0, asr #16
34022dc8:	f846 1b04 	str.w	r1, [r6], #4
34022dcc:	e7dc      	b.n	34022d88 <__mdiff+0xdc>
34022dce:	3f01      	subs	r7, #1
34022dd0:	e7e6      	b.n	34022da0 <__mdiff+0xf4>
34022dd2:	bf00      	nop
34022dd4:	340339d0 	.word	0x340339d0
34022dd8:	340339e1 	.word	0x340339e1

34022ddc <__d2b>:
34022ddc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
34022de0:	460f      	mov	r7, r1
34022de2:	2101      	movs	r1, #1
34022de4:	4616      	mov	r6, r2
34022de6:	ec59 8b10 	vmov	r8, r9, d0
34022dea:	f7ff fccd 	bl	34022788 <_Balloc>
34022dee:	4604      	mov	r4, r0
34022df0:	b930      	cbnz	r0, 34022e00 <__d2b+0x24>
34022df2:	4602      	mov	r2, r0
34022df4:	4b23      	ldr	r3, [pc, #140]	@ (34022e84 <__d2b+0xa8>)
34022df6:	f240 310f 	movw	r1, #783	@ 0x30f
34022dfa:	4823      	ldr	r0, [pc, #140]	@ (34022e88 <__d2b+0xac>)
34022dfc:	f7fd fa18 	bl	34020230 <__assert_func>
34022e00:	f3c9 550a 	ubfx	r5, r9, #20, #11
34022e04:	f3c9 0313 	ubfx	r3, r9, #0, #20
34022e08:	b10d      	cbz	r5, 34022e0e <__d2b+0x32>
34022e0a:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
34022e0e:	9301      	str	r3, [sp, #4]
34022e10:	f1b8 0300 	subs.w	r3, r8, #0
34022e14:	d023      	beq.n	34022e5e <__d2b+0x82>
34022e16:	4668      	mov	r0, sp
34022e18:	9300      	str	r3, [sp, #0]
34022e1a:	f7ff fd7e 	bl	3402291a <__lo0bits>
34022e1e:	e9dd 1200 	ldrd	r1, r2, [sp]
34022e22:	b1d0      	cbz	r0, 34022e5a <__d2b+0x7e>
34022e24:	f1c0 0320 	rsb	r3, r0, #32
34022e28:	fa02 f303 	lsl.w	r3, r2, r3
34022e2c:	40c2      	lsrs	r2, r0
34022e2e:	430b      	orrs	r3, r1
34022e30:	9201      	str	r2, [sp, #4]
34022e32:	6163      	str	r3, [r4, #20]
34022e34:	9b01      	ldr	r3, [sp, #4]
34022e36:	2b00      	cmp	r3, #0
34022e38:	61a3      	str	r3, [r4, #24]
34022e3a:	bf0c      	ite	eq
34022e3c:	2201      	moveq	r2, #1
34022e3e:	2202      	movne	r2, #2
34022e40:	6122      	str	r2, [r4, #16]
34022e42:	b1a5      	cbz	r5, 34022e6e <__d2b+0x92>
34022e44:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
34022e48:	4405      	add	r5, r0
34022e4a:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
34022e4e:	603d      	str	r5, [r7, #0]
34022e50:	6030      	str	r0, [r6, #0]
34022e52:	4620      	mov	r0, r4
34022e54:	b003      	add	sp, #12
34022e56:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
34022e5a:	6161      	str	r1, [r4, #20]
34022e5c:	e7ea      	b.n	34022e34 <__d2b+0x58>
34022e5e:	a801      	add	r0, sp, #4
34022e60:	f7ff fd5b 	bl	3402291a <__lo0bits>
34022e64:	9b01      	ldr	r3, [sp, #4]
34022e66:	3020      	adds	r0, #32
34022e68:	2201      	movs	r2, #1
34022e6a:	6163      	str	r3, [r4, #20]
34022e6c:	e7e8      	b.n	34022e40 <__d2b+0x64>
34022e6e:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
34022e72:	eb04 0382 	add.w	r3, r4, r2, lsl #2
34022e76:	6038      	str	r0, [r7, #0]
34022e78:	6918      	ldr	r0, [r3, #16]
34022e7a:	f7ff fd2f 	bl	340228dc <__hi0bits>
34022e7e:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
34022e82:	e7e5      	b.n	34022e50 <__d2b+0x74>
34022e84:	340339d0 	.word	0x340339d0
34022e88:	340339e1 	.word	0x340339e1

34022e8c <_malloc_usable_size_r>:
34022e8c:	f851 3c04 	ldr.w	r3, [r1, #-4]
34022e90:	1f18      	subs	r0, r3, #4
34022e92:	2b00      	cmp	r3, #0
34022e94:	bfbc      	itt	lt
34022e96:	580b      	ldrlt	r3, [r1, r0]
34022e98:	18c0      	addlt	r0, r0, r3
34022e9a:	4770      	bx	lr

34022e9c <__ssputs_r>:
34022e9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34022ea0:	461f      	mov	r7, r3
34022ea2:	688e      	ldr	r6, [r1, #8]
34022ea4:	4682      	mov	sl, r0
34022ea6:	460c      	mov	r4, r1
34022ea8:	42be      	cmp	r6, r7
34022eaa:	4690      	mov	r8, r2
34022eac:	680b      	ldr	r3, [r1, #0]
34022eae:	d82d      	bhi.n	34022f0c <__ssputs_r+0x70>
34022eb0:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
34022eb4:	f412 6f90 	tst.w	r2, #1152	@ 0x480
34022eb8:	d026      	beq.n	34022f08 <__ssputs_r+0x6c>
34022eba:	6965      	ldr	r5, [r4, #20]
34022ebc:	6909      	ldr	r1, [r1, #16]
34022ebe:	eb05 0545 	add.w	r5, r5, r5, lsl #1
34022ec2:	eba3 0901 	sub.w	r9, r3, r1
34022ec6:	1c7b      	adds	r3, r7, #1
34022ec8:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
34022ecc:	444b      	add	r3, r9
34022ece:	106d      	asrs	r5, r5, #1
34022ed0:	429d      	cmp	r5, r3
34022ed2:	bf38      	it	cc
34022ed4:	461d      	movcc	r5, r3
34022ed6:	0553      	lsls	r3, r2, #21
34022ed8:	d527      	bpl.n	34022f2a <__ssputs_r+0x8e>
34022eda:	4629      	mov	r1, r5
34022edc:	f7fd f9f0 	bl	340202c0 <_malloc_r>
34022ee0:	4606      	mov	r6, r0
34022ee2:	b360      	cbz	r0, 34022f3e <__ssputs_r+0xa2>
34022ee4:	464a      	mov	r2, r9
34022ee6:	6921      	ldr	r1, [r4, #16]
34022ee8:	f7fe fe03 	bl	34021af2 <memcpy>
34022eec:	89a3      	ldrh	r3, [r4, #12]
34022eee:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
34022ef2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
34022ef6:	81a3      	strh	r3, [r4, #12]
34022ef8:	6126      	str	r6, [r4, #16]
34022efa:	444e      	add	r6, r9
34022efc:	6165      	str	r5, [r4, #20]
34022efe:	eba5 0509 	sub.w	r5, r5, r9
34022f02:	6026      	str	r6, [r4, #0]
34022f04:	463e      	mov	r6, r7
34022f06:	60a5      	str	r5, [r4, #8]
34022f08:	42be      	cmp	r6, r7
34022f0a:	d900      	bls.n	34022f0e <__ssputs_r+0x72>
34022f0c:	463e      	mov	r6, r7
34022f0e:	4632      	mov	r2, r6
34022f10:	4641      	mov	r1, r8
34022f12:	6820      	ldr	r0, [r4, #0]
34022f14:	f7fe fb44 	bl	340215a0 <memmove>
34022f18:	68a3      	ldr	r3, [r4, #8]
34022f1a:	2000      	movs	r0, #0
34022f1c:	1b9b      	subs	r3, r3, r6
34022f1e:	60a3      	str	r3, [r4, #8]
34022f20:	6823      	ldr	r3, [r4, #0]
34022f22:	4433      	add	r3, r6
34022f24:	6023      	str	r3, [r4, #0]
34022f26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34022f2a:	462a      	mov	r2, r5
34022f2c:	f7fd fa54 	bl	340203d8 <_realloc_r>
34022f30:	4606      	mov	r6, r0
34022f32:	2800      	cmp	r0, #0
34022f34:	d1e0      	bne.n	34022ef8 <__ssputs_r+0x5c>
34022f36:	6921      	ldr	r1, [r4, #16]
34022f38:	4650      	mov	r0, sl
34022f3a:	f7ff fbdb 	bl	340226f4 <_free_r>
34022f3e:	230c      	movs	r3, #12
34022f40:	f04f 30ff 	mov.w	r0, #4294967295
34022f44:	f8ca 3000 	str.w	r3, [sl]
34022f48:	89a3      	ldrh	r3, [r4, #12]
34022f4a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34022f4e:	81a3      	strh	r3, [r4, #12]
34022f50:	e7e9      	b.n	34022f26 <__ssputs_r+0x8a>
	...

34022f54 <_svfiprintf_r>:
34022f54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34022f58:	4698      	mov	r8, r3
34022f5a:	898b      	ldrh	r3, [r1, #12]
34022f5c:	b09d      	sub	sp, #116	@ 0x74
34022f5e:	4607      	mov	r7, r0
34022f60:	061b      	lsls	r3, r3, #24
34022f62:	460d      	mov	r5, r1
34022f64:	4614      	mov	r4, r2
34022f66:	d510      	bpl.n	34022f8a <_svfiprintf_r+0x36>
34022f68:	690b      	ldr	r3, [r1, #16]
34022f6a:	b973      	cbnz	r3, 34022f8a <_svfiprintf_r+0x36>
34022f6c:	2140      	movs	r1, #64	@ 0x40
34022f6e:	f7fd f9a7 	bl	340202c0 <_malloc_r>
34022f72:	6028      	str	r0, [r5, #0]
34022f74:	6128      	str	r0, [r5, #16]
34022f76:	b930      	cbnz	r0, 34022f86 <_svfiprintf_r+0x32>
34022f78:	230c      	movs	r3, #12
34022f7a:	603b      	str	r3, [r7, #0]
34022f7c:	f04f 30ff 	mov.w	r0, #4294967295
34022f80:	b01d      	add	sp, #116	@ 0x74
34022f82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34022f86:	2340      	movs	r3, #64	@ 0x40
34022f88:	616b      	str	r3, [r5, #20]
34022f8a:	2300      	movs	r3, #0
34022f8c:	f8cd 800c 	str.w	r8, [sp, #12]
34022f90:	f04f 0901 	mov.w	r9, #1
34022f94:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 34023138 <_svfiprintf_r+0x1e4>
34022f98:	9309      	str	r3, [sp, #36]	@ 0x24
34022f9a:	2320      	movs	r3, #32
34022f9c:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
34022fa0:	2330      	movs	r3, #48	@ 0x30
34022fa2:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
34022fa6:	4623      	mov	r3, r4
34022fa8:	469a      	mov	sl, r3
34022faa:	f813 2b01 	ldrb.w	r2, [r3], #1
34022fae:	b10a      	cbz	r2, 34022fb4 <_svfiprintf_r+0x60>
34022fb0:	2a25      	cmp	r2, #37	@ 0x25
34022fb2:	d1f9      	bne.n	34022fa8 <_svfiprintf_r+0x54>
34022fb4:	ebba 0b04 	subs.w	fp, sl, r4
34022fb8:	d00b      	beq.n	34022fd2 <_svfiprintf_r+0x7e>
34022fba:	465b      	mov	r3, fp
34022fbc:	4622      	mov	r2, r4
34022fbe:	4629      	mov	r1, r5
34022fc0:	4638      	mov	r0, r7
34022fc2:	f7ff ff6b 	bl	34022e9c <__ssputs_r>
34022fc6:	3001      	adds	r0, #1
34022fc8:	f000 80a7 	beq.w	3402311a <_svfiprintf_r+0x1c6>
34022fcc:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34022fce:	445a      	add	r2, fp
34022fd0:	9209      	str	r2, [sp, #36]	@ 0x24
34022fd2:	f89a 3000 	ldrb.w	r3, [sl]
34022fd6:	2b00      	cmp	r3, #0
34022fd8:	f000 809f 	beq.w	3402311a <_svfiprintf_r+0x1c6>
34022fdc:	2300      	movs	r3, #0
34022fde:	f04f 32ff 	mov.w	r2, #4294967295
34022fe2:	f10a 0a01 	add.w	sl, sl, #1
34022fe6:	9304      	str	r3, [sp, #16]
34022fe8:	9307      	str	r3, [sp, #28]
34022fea:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
34022fee:	931a      	str	r3, [sp, #104]	@ 0x68
34022ff0:	e9cd 2305 	strd	r2, r3, [sp, #20]
34022ff4:	4654      	mov	r4, sl
34022ff6:	2205      	movs	r2, #5
34022ff8:	484f      	ldr	r0, [pc, #316]	@ (34023138 <_svfiprintf_r+0x1e4>)
34022ffa:	f814 1b01 	ldrb.w	r1, [r4], #1
34022ffe:	f7fe fd6a 	bl	34021ad6 <memchr>
34023002:	9a04      	ldr	r2, [sp, #16]
34023004:	b9d8      	cbnz	r0, 3402303e <_svfiprintf_r+0xea>
34023006:	06d0      	lsls	r0, r2, #27
34023008:	bf44      	itt	mi
3402300a:	2320      	movmi	r3, #32
3402300c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
34023010:	0711      	lsls	r1, r2, #28
34023012:	bf44      	itt	mi
34023014:	232b      	movmi	r3, #43	@ 0x2b
34023016:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3402301a:	f89a 3000 	ldrb.w	r3, [sl]
3402301e:	2b2a      	cmp	r3, #42	@ 0x2a
34023020:	d015      	beq.n	3402304e <_svfiprintf_r+0xfa>
34023022:	9a07      	ldr	r2, [sp, #28]
34023024:	4654      	mov	r4, sl
34023026:	2000      	movs	r0, #0
34023028:	f04f 0c0a 	mov.w	ip, #10
3402302c:	4621      	mov	r1, r4
3402302e:	f811 3b01 	ldrb.w	r3, [r1], #1
34023032:	3b30      	subs	r3, #48	@ 0x30
34023034:	2b09      	cmp	r3, #9
34023036:	d94b      	bls.n	340230d0 <_svfiprintf_r+0x17c>
34023038:	b1b0      	cbz	r0, 34023068 <_svfiprintf_r+0x114>
3402303a:	9207      	str	r2, [sp, #28]
3402303c:	e014      	b.n	34023068 <_svfiprintf_r+0x114>
3402303e:	eba0 0308 	sub.w	r3, r0, r8
34023042:	46a2      	mov	sl, r4
34023044:	fa09 f303 	lsl.w	r3, r9, r3
34023048:	4313      	orrs	r3, r2
3402304a:	9304      	str	r3, [sp, #16]
3402304c:	e7d2      	b.n	34022ff4 <_svfiprintf_r+0xa0>
3402304e:	9b03      	ldr	r3, [sp, #12]
34023050:	1d19      	adds	r1, r3, #4
34023052:	681b      	ldr	r3, [r3, #0]
34023054:	2b00      	cmp	r3, #0
34023056:	9103      	str	r1, [sp, #12]
34023058:	bfbb      	ittet	lt
3402305a:	425b      	neglt	r3, r3
3402305c:	f042 0202 	orrlt.w	r2, r2, #2
34023060:	9307      	strge	r3, [sp, #28]
34023062:	9307      	strlt	r3, [sp, #28]
34023064:	bfb8      	it	lt
34023066:	9204      	strlt	r2, [sp, #16]
34023068:	7823      	ldrb	r3, [r4, #0]
3402306a:	2b2e      	cmp	r3, #46	@ 0x2e
3402306c:	d10a      	bne.n	34023084 <_svfiprintf_r+0x130>
3402306e:	7863      	ldrb	r3, [r4, #1]
34023070:	2b2a      	cmp	r3, #42	@ 0x2a
34023072:	d132      	bne.n	340230da <_svfiprintf_r+0x186>
34023074:	9b03      	ldr	r3, [sp, #12]
34023076:	3402      	adds	r4, #2
34023078:	1d1a      	adds	r2, r3, #4
3402307a:	681b      	ldr	r3, [r3, #0]
3402307c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
34023080:	9203      	str	r2, [sp, #12]
34023082:	9305      	str	r3, [sp, #20]
34023084:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 34023148 <_svfiprintf_r+0x1f4>
34023088:	2203      	movs	r2, #3
3402308a:	7821      	ldrb	r1, [r4, #0]
3402308c:	4650      	mov	r0, sl
3402308e:	f7fe fd22 	bl	34021ad6 <memchr>
34023092:	b138      	cbz	r0, 340230a4 <_svfiprintf_r+0x150>
34023094:	eba0 000a 	sub.w	r0, r0, sl
34023098:	2240      	movs	r2, #64	@ 0x40
3402309a:	9b04      	ldr	r3, [sp, #16]
3402309c:	3401      	adds	r4, #1
3402309e:	4082      	lsls	r2, r0
340230a0:	4313      	orrs	r3, r2
340230a2:	9304      	str	r3, [sp, #16]
340230a4:	f814 1b01 	ldrb.w	r1, [r4], #1
340230a8:	2206      	movs	r2, #6
340230aa:	4824      	ldr	r0, [pc, #144]	@ (3402313c <_svfiprintf_r+0x1e8>)
340230ac:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
340230b0:	f7fe fd11 	bl	34021ad6 <memchr>
340230b4:	2800      	cmp	r0, #0
340230b6:	d036      	beq.n	34023126 <_svfiprintf_r+0x1d2>
340230b8:	4b21      	ldr	r3, [pc, #132]	@ (34023140 <_svfiprintf_r+0x1ec>)
340230ba:	bb1b      	cbnz	r3, 34023104 <_svfiprintf_r+0x1b0>
340230bc:	9b03      	ldr	r3, [sp, #12]
340230be:	3307      	adds	r3, #7
340230c0:	f023 0307 	bic.w	r3, r3, #7
340230c4:	3308      	adds	r3, #8
340230c6:	9303      	str	r3, [sp, #12]
340230c8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340230ca:	4433      	add	r3, r6
340230cc:	9309      	str	r3, [sp, #36]	@ 0x24
340230ce:	e76a      	b.n	34022fa6 <_svfiprintf_r+0x52>
340230d0:	fb0c 3202 	mla	r2, ip, r2, r3
340230d4:	460c      	mov	r4, r1
340230d6:	2001      	movs	r0, #1
340230d8:	e7a8      	b.n	3402302c <_svfiprintf_r+0xd8>
340230da:	2300      	movs	r3, #0
340230dc:	3401      	adds	r4, #1
340230de:	f04f 0c0a 	mov.w	ip, #10
340230e2:	4619      	mov	r1, r3
340230e4:	9305      	str	r3, [sp, #20]
340230e6:	4620      	mov	r0, r4
340230e8:	f810 2b01 	ldrb.w	r2, [r0], #1
340230ec:	3a30      	subs	r2, #48	@ 0x30
340230ee:	2a09      	cmp	r2, #9
340230f0:	d903      	bls.n	340230fa <_svfiprintf_r+0x1a6>
340230f2:	2b00      	cmp	r3, #0
340230f4:	d0c6      	beq.n	34023084 <_svfiprintf_r+0x130>
340230f6:	9105      	str	r1, [sp, #20]
340230f8:	e7c4      	b.n	34023084 <_svfiprintf_r+0x130>
340230fa:	fb0c 2101 	mla	r1, ip, r1, r2
340230fe:	4604      	mov	r4, r0
34023100:	2301      	movs	r3, #1
34023102:	e7f0      	b.n	340230e6 <_svfiprintf_r+0x192>
34023104:	ab03      	add	r3, sp, #12
34023106:	462a      	mov	r2, r5
34023108:	a904      	add	r1, sp, #16
3402310a:	4638      	mov	r0, r7
3402310c:	9300      	str	r3, [sp, #0]
3402310e:	4b0d      	ldr	r3, [pc, #52]	@ (34023144 <_svfiprintf_r+0x1f0>)
34023110:	f7fd fb9e 	bl	34020850 <_printf_float>
34023114:	1c42      	adds	r2, r0, #1
34023116:	4606      	mov	r6, r0
34023118:	d1d6      	bne.n	340230c8 <_svfiprintf_r+0x174>
3402311a:	89ab      	ldrh	r3, [r5, #12]
3402311c:	065b      	lsls	r3, r3, #25
3402311e:	f53f af2d 	bmi.w	34022f7c <_svfiprintf_r+0x28>
34023122:	9809      	ldr	r0, [sp, #36]	@ 0x24
34023124:	e72c      	b.n	34022f80 <_svfiprintf_r+0x2c>
34023126:	ab03      	add	r3, sp, #12
34023128:	462a      	mov	r2, r5
3402312a:	a904      	add	r1, sp, #16
3402312c:	4638      	mov	r0, r7
3402312e:	9300      	str	r3, [sp, #0]
34023130:	4b04      	ldr	r3, [pc, #16]	@ (34023144 <_svfiprintf_r+0x1f0>)
34023132:	f7fd fe19 	bl	34020d68 <_printf_i>
34023136:	e7ed      	b.n	34023114 <_svfiprintf_r+0x1c0>
34023138:	34033a3a 	.word	0x34033a3a
3402313c:	34033a44 	.word	0x34033a44
34023140:	34020851 	.word	0x34020851
34023144:	34022e9d 	.word	0x34022e9d
34023148:	34033a40 	.word	0x34033a40

3402314c <__sfputc_r>:
3402314c:	6893      	ldr	r3, [r2, #8]
3402314e:	3b01      	subs	r3, #1
34023150:	2b00      	cmp	r3, #0
34023152:	b410      	push	{r4}
34023154:	6093      	str	r3, [r2, #8]
34023156:	da08      	bge.n	3402316a <__sfputc_r+0x1e>
34023158:	6994      	ldr	r4, [r2, #24]
3402315a:	42a3      	cmp	r3, r4
3402315c:	db01      	blt.n	34023162 <__sfputc_r+0x16>
3402315e:	290a      	cmp	r1, #10
34023160:	d103      	bne.n	3402316a <__sfputc_r+0x1e>
34023162:	f85d 4b04 	ldr.w	r4, [sp], #4
34023166:	f7fe b986 	b.w	34021476 <__swbuf_r>
3402316a:	6813      	ldr	r3, [r2, #0]
3402316c:	1c58      	adds	r0, r3, #1
3402316e:	6010      	str	r0, [r2, #0]
34023170:	4608      	mov	r0, r1
34023172:	7019      	strb	r1, [r3, #0]
34023174:	f85d 4b04 	ldr.w	r4, [sp], #4
34023178:	4770      	bx	lr

3402317a <__sfputs_r>:
3402317a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3402317c:	4606      	mov	r6, r0
3402317e:	460f      	mov	r7, r1
34023180:	4614      	mov	r4, r2
34023182:	18d5      	adds	r5, r2, r3
34023184:	42ac      	cmp	r4, r5
34023186:	d101      	bne.n	3402318c <__sfputs_r+0x12>
34023188:	2000      	movs	r0, #0
3402318a:	e007      	b.n	3402319c <__sfputs_r+0x22>
3402318c:	463a      	mov	r2, r7
3402318e:	f814 1b01 	ldrb.w	r1, [r4], #1
34023192:	4630      	mov	r0, r6
34023194:	f7ff ffda 	bl	3402314c <__sfputc_r>
34023198:	1c43      	adds	r3, r0, #1
3402319a:	d1f3      	bne.n	34023184 <__sfputs_r+0xa>
3402319c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

340231a0 <_vfiprintf_r>:
340231a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340231a4:	460d      	mov	r5, r1
340231a6:	b09d      	sub	sp, #116	@ 0x74
340231a8:	4614      	mov	r4, r2
340231aa:	4698      	mov	r8, r3
340231ac:	4606      	mov	r6, r0
340231ae:	b118      	cbz	r0, 340231b8 <_vfiprintf_r+0x18>
340231b0:	6a03      	ldr	r3, [r0, #32]
340231b2:	b90b      	cbnz	r3, 340231b8 <_vfiprintf_r+0x18>
340231b4:	f7fe f82e 	bl	34021214 <__sinit>
340231b8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
340231ba:	07d9      	lsls	r1, r3, #31
340231bc:	d405      	bmi.n	340231ca <_vfiprintf_r+0x2a>
340231be:	89ab      	ldrh	r3, [r5, #12]
340231c0:	059a      	lsls	r2, r3, #22
340231c2:	d402      	bmi.n	340231ca <_vfiprintf_r+0x2a>
340231c4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
340231c6:	f7fe fc84 	bl	34021ad2 <__retarget_lock_acquire_recursive>
340231ca:	89ab      	ldrh	r3, [r5, #12]
340231cc:	071b      	lsls	r3, r3, #28
340231ce:	d501      	bpl.n	340231d4 <_vfiprintf_r+0x34>
340231d0:	692b      	ldr	r3, [r5, #16]
340231d2:	b99b      	cbnz	r3, 340231fc <_vfiprintf_r+0x5c>
340231d4:	4629      	mov	r1, r5
340231d6:	4630      	mov	r0, r6
340231d8:	f7fe f98c 	bl	340214f4 <__swsetup_r>
340231dc:	b170      	cbz	r0, 340231fc <_vfiprintf_r+0x5c>
340231de:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
340231e0:	07dc      	lsls	r4, r3, #31
340231e2:	d504      	bpl.n	340231ee <_vfiprintf_r+0x4e>
340231e4:	f04f 30ff 	mov.w	r0, #4294967295
340231e8:	b01d      	add	sp, #116	@ 0x74
340231ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340231ee:	89ab      	ldrh	r3, [r5, #12]
340231f0:	0598      	lsls	r0, r3, #22
340231f2:	d4f7      	bmi.n	340231e4 <_vfiprintf_r+0x44>
340231f4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
340231f6:	f7fe fc6d 	bl	34021ad4 <__retarget_lock_release_recursive>
340231fa:	e7f3      	b.n	340231e4 <_vfiprintf_r+0x44>
340231fc:	2300      	movs	r3, #0
340231fe:	f8cd 800c 	str.w	r8, [sp, #12]
34023202:	f04f 0901 	mov.w	r9, #1
34023206:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 340233bc <_vfiprintf_r+0x21c>
3402320a:	9309      	str	r3, [sp, #36]	@ 0x24
3402320c:	2320      	movs	r3, #32
3402320e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
34023212:	2330      	movs	r3, #48	@ 0x30
34023214:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
34023218:	4623      	mov	r3, r4
3402321a:	469a      	mov	sl, r3
3402321c:	f813 2b01 	ldrb.w	r2, [r3], #1
34023220:	b10a      	cbz	r2, 34023226 <_vfiprintf_r+0x86>
34023222:	2a25      	cmp	r2, #37	@ 0x25
34023224:	d1f9      	bne.n	3402321a <_vfiprintf_r+0x7a>
34023226:	ebba 0b04 	subs.w	fp, sl, r4
3402322a:	d00b      	beq.n	34023244 <_vfiprintf_r+0xa4>
3402322c:	465b      	mov	r3, fp
3402322e:	4622      	mov	r2, r4
34023230:	4629      	mov	r1, r5
34023232:	4630      	mov	r0, r6
34023234:	f7ff ffa1 	bl	3402317a <__sfputs_r>
34023238:	3001      	adds	r0, #1
3402323a:	f000 80a7 	beq.w	3402338c <_vfiprintf_r+0x1ec>
3402323e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34023240:	445a      	add	r2, fp
34023242:	9209      	str	r2, [sp, #36]	@ 0x24
34023244:	f89a 3000 	ldrb.w	r3, [sl]
34023248:	2b00      	cmp	r3, #0
3402324a:	f000 809f 	beq.w	3402338c <_vfiprintf_r+0x1ec>
3402324e:	2300      	movs	r3, #0
34023250:	f04f 32ff 	mov.w	r2, #4294967295
34023254:	f10a 0a01 	add.w	sl, sl, #1
34023258:	9304      	str	r3, [sp, #16]
3402325a:	9307      	str	r3, [sp, #28]
3402325c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
34023260:	931a      	str	r3, [sp, #104]	@ 0x68
34023262:	e9cd 2305 	strd	r2, r3, [sp, #20]
34023266:	4654      	mov	r4, sl
34023268:	2205      	movs	r2, #5
3402326a:	4854      	ldr	r0, [pc, #336]	@ (340233bc <_vfiprintf_r+0x21c>)
3402326c:	f814 1b01 	ldrb.w	r1, [r4], #1
34023270:	f7fe fc31 	bl	34021ad6 <memchr>
34023274:	9a04      	ldr	r2, [sp, #16]
34023276:	b9d8      	cbnz	r0, 340232b0 <_vfiprintf_r+0x110>
34023278:	06d1      	lsls	r1, r2, #27
3402327a:	bf44      	itt	mi
3402327c:	2320      	movmi	r3, #32
3402327e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
34023282:	0713      	lsls	r3, r2, #28
34023284:	bf44      	itt	mi
34023286:	232b      	movmi	r3, #43	@ 0x2b
34023288:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3402328c:	f89a 3000 	ldrb.w	r3, [sl]
34023290:	2b2a      	cmp	r3, #42	@ 0x2a
34023292:	d015      	beq.n	340232c0 <_vfiprintf_r+0x120>
34023294:	9a07      	ldr	r2, [sp, #28]
34023296:	4654      	mov	r4, sl
34023298:	2000      	movs	r0, #0
3402329a:	f04f 0c0a 	mov.w	ip, #10
3402329e:	4621      	mov	r1, r4
340232a0:	f811 3b01 	ldrb.w	r3, [r1], #1
340232a4:	3b30      	subs	r3, #48	@ 0x30
340232a6:	2b09      	cmp	r3, #9
340232a8:	d94b      	bls.n	34023342 <_vfiprintf_r+0x1a2>
340232aa:	b1b0      	cbz	r0, 340232da <_vfiprintf_r+0x13a>
340232ac:	9207      	str	r2, [sp, #28]
340232ae:	e014      	b.n	340232da <_vfiprintf_r+0x13a>
340232b0:	eba0 0308 	sub.w	r3, r0, r8
340232b4:	46a2      	mov	sl, r4
340232b6:	fa09 f303 	lsl.w	r3, r9, r3
340232ba:	4313      	orrs	r3, r2
340232bc:	9304      	str	r3, [sp, #16]
340232be:	e7d2      	b.n	34023266 <_vfiprintf_r+0xc6>
340232c0:	9b03      	ldr	r3, [sp, #12]
340232c2:	1d19      	adds	r1, r3, #4
340232c4:	681b      	ldr	r3, [r3, #0]
340232c6:	2b00      	cmp	r3, #0
340232c8:	9103      	str	r1, [sp, #12]
340232ca:	bfbb      	ittet	lt
340232cc:	425b      	neglt	r3, r3
340232ce:	f042 0202 	orrlt.w	r2, r2, #2
340232d2:	9307      	strge	r3, [sp, #28]
340232d4:	9307      	strlt	r3, [sp, #28]
340232d6:	bfb8      	it	lt
340232d8:	9204      	strlt	r2, [sp, #16]
340232da:	7823      	ldrb	r3, [r4, #0]
340232dc:	2b2e      	cmp	r3, #46	@ 0x2e
340232de:	d10a      	bne.n	340232f6 <_vfiprintf_r+0x156>
340232e0:	7863      	ldrb	r3, [r4, #1]
340232e2:	2b2a      	cmp	r3, #42	@ 0x2a
340232e4:	d132      	bne.n	3402334c <_vfiprintf_r+0x1ac>
340232e6:	9b03      	ldr	r3, [sp, #12]
340232e8:	3402      	adds	r4, #2
340232ea:	1d1a      	adds	r2, r3, #4
340232ec:	681b      	ldr	r3, [r3, #0]
340232ee:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
340232f2:	9203      	str	r2, [sp, #12]
340232f4:	9305      	str	r3, [sp, #20]
340232f6:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 340233cc <_vfiprintf_r+0x22c>
340232fa:	2203      	movs	r2, #3
340232fc:	7821      	ldrb	r1, [r4, #0]
340232fe:	4650      	mov	r0, sl
34023300:	f7fe fbe9 	bl	34021ad6 <memchr>
34023304:	b138      	cbz	r0, 34023316 <_vfiprintf_r+0x176>
34023306:	eba0 000a 	sub.w	r0, r0, sl
3402330a:	2240      	movs	r2, #64	@ 0x40
3402330c:	9b04      	ldr	r3, [sp, #16]
3402330e:	3401      	adds	r4, #1
34023310:	4082      	lsls	r2, r0
34023312:	4313      	orrs	r3, r2
34023314:	9304      	str	r3, [sp, #16]
34023316:	f814 1b01 	ldrb.w	r1, [r4], #1
3402331a:	2206      	movs	r2, #6
3402331c:	4828      	ldr	r0, [pc, #160]	@ (340233c0 <_vfiprintf_r+0x220>)
3402331e:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
34023322:	f7fe fbd8 	bl	34021ad6 <memchr>
34023326:	2800      	cmp	r0, #0
34023328:	d03f      	beq.n	340233aa <_vfiprintf_r+0x20a>
3402332a:	4b26      	ldr	r3, [pc, #152]	@ (340233c4 <_vfiprintf_r+0x224>)
3402332c:	bb1b      	cbnz	r3, 34023376 <_vfiprintf_r+0x1d6>
3402332e:	9b03      	ldr	r3, [sp, #12]
34023330:	3307      	adds	r3, #7
34023332:	f023 0307 	bic.w	r3, r3, #7
34023336:	3308      	adds	r3, #8
34023338:	9303      	str	r3, [sp, #12]
3402333a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3402333c:	443b      	add	r3, r7
3402333e:	9309      	str	r3, [sp, #36]	@ 0x24
34023340:	e76a      	b.n	34023218 <_vfiprintf_r+0x78>
34023342:	fb0c 3202 	mla	r2, ip, r2, r3
34023346:	460c      	mov	r4, r1
34023348:	2001      	movs	r0, #1
3402334a:	e7a8      	b.n	3402329e <_vfiprintf_r+0xfe>
3402334c:	2300      	movs	r3, #0
3402334e:	3401      	adds	r4, #1
34023350:	f04f 0c0a 	mov.w	ip, #10
34023354:	4619      	mov	r1, r3
34023356:	9305      	str	r3, [sp, #20]
34023358:	4620      	mov	r0, r4
3402335a:	f810 2b01 	ldrb.w	r2, [r0], #1
3402335e:	3a30      	subs	r2, #48	@ 0x30
34023360:	2a09      	cmp	r2, #9
34023362:	d903      	bls.n	3402336c <_vfiprintf_r+0x1cc>
34023364:	2b00      	cmp	r3, #0
34023366:	d0c6      	beq.n	340232f6 <_vfiprintf_r+0x156>
34023368:	9105      	str	r1, [sp, #20]
3402336a:	e7c4      	b.n	340232f6 <_vfiprintf_r+0x156>
3402336c:	fb0c 2101 	mla	r1, ip, r1, r2
34023370:	4604      	mov	r4, r0
34023372:	2301      	movs	r3, #1
34023374:	e7f0      	b.n	34023358 <_vfiprintf_r+0x1b8>
34023376:	ab03      	add	r3, sp, #12
34023378:	462a      	mov	r2, r5
3402337a:	a904      	add	r1, sp, #16
3402337c:	4630      	mov	r0, r6
3402337e:	9300      	str	r3, [sp, #0]
34023380:	4b11      	ldr	r3, [pc, #68]	@ (340233c8 <_vfiprintf_r+0x228>)
34023382:	f7fd fa65 	bl	34020850 <_printf_float>
34023386:	4607      	mov	r7, r0
34023388:	1c78      	adds	r0, r7, #1
3402338a:	d1d6      	bne.n	3402333a <_vfiprintf_r+0x19a>
3402338c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3402338e:	07d9      	lsls	r1, r3, #31
34023390:	d405      	bmi.n	3402339e <_vfiprintf_r+0x1fe>
34023392:	89ab      	ldrh	r3, [r5, #12]
34023394:	059a      	lsls	r2, r3, #22
34023396:	d402      	bmi.n	3402339e <_vfiprintf_r+0x1fe>
34023398:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3402339a:	f7fe fb9b 	bl	34021ad4 <__retarget_lock_release_recursive>
3402339e:	89ab      	ldrh	r3, [r5, #12]
340233a0:	065b      	lsls	r3, r3, #25
340233a2:	f53f af1f 	bmi.w	340231e4 <_vfiprintf_r+0x44>
340233a6:	9809      	ldr	r0, [sp, #36]	@ 0x24
340233a8:	e71e      	b.n	340231e8 <_vfiprintf_r+0x48>
340233aa:	ab03      	add	r3, sp, #12
340233ac:	462a      	mov	r2, r5
340233ae:	a904      	add	r1, sp, #16
340233b0:	4630      	mov	r0, r6
340233b2:	9300      	str	r3, [sp, #0]
340233b4:	4b04      	ldr	r3, [pc, #16]	@ (340233c8 <_vfiprintf_r+0x228>)
340233b6:	f7fd fcd7 	bl	34020d68 <_printf_i>
340233ba:	e7e4      	b.n	34023386 <_vfiprintf_r+0x1e6>
340233bc:	34033a3a 	.word	0x34033a3a
340233c0:	34033a44 	.word	0x34033a44
340233c4:	34020851 	.word	0x34020851
340233c8:	3402317b 	.word	0x3402317b
340233cc:	34033a40 	.word	0x34033a40

340233d0 <__swhatbuf_r>:
340233d0:	b570      	push	{r4, r5, r6, lr}
340233d2:	460c      	mov	r4, r1
340233d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
340233d8:	b096      	sub	sp, #88	@ 0x58
340233da:	4615      	mov	r5, r2
340233dc:	2900      	cmp	r1, #0
340233de:	461e      	mov	r6, r3
340233e0:	da0c      	bge.n	340233fc <__swhatbuf_r+0x2c>
340233e2:	89a3      	ldrh	r3, [r4, #12]
340233e4:	2100      	movs	r1, #0
340233e6:	f013 0f80 	tst.w	r3, #128	@ 0x80
340233ea:	bf14      	ite	ne
340233ec:	2340      	movne	r3, #64	@ 0x40
340233ee:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
340233f2:	2000      	movs	r0, #0
340233f4:	6031      	str	r1, [r6, #0]
340233f6:	602b      	str	r3, [r5, #0]
340233f8:	b016      	add	sp, #88	@ 0x58
340233fa:	bd70      	pop	{r4, r5, r6, pc}
340233fc:	466a      	mov	r2, sp
340233fe:	f000 f879 	bl	340234f4 <_fstat_r>
34023402:	2800      	cmp	r0, #0
34023404:	dbed      	blt.n	340233e2 <__swhatbuf_r+0x12>
34023406:	9901      	ldr	r1, [sp, #4]
34023408:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
3402340c:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
34023410:	4259      	negs	r1, r3
34023412:	4159      	adcs	r1, r3
34023414:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34023418:	e7eb      	b.n	340233f2 <__swhatbuf_r+0x22>

3402341a <__smakebuf_r>:
3402341a:	898b      	ldrh	r3, [r1, #12]
3402341c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3402341e:	079d      	lsls	r5, r3, #30
34023420:	4606      	mov	r6, r0
34023422:	460c      	mov	r4, r1
34023424:	d507      	bpl.n	34023436 <__smakebuf_r+0x1c>
34023426:	f104 0347 	add.w	r3, r4, #71	@ 0x47
3402342a:	6023      	str	r3, [r4, #0]
3402342c:	6123      	str	r3, [r4, #16]
3402342e:	2301      	movs	r3, #1
34023430:	6163      	str	r3, [r4, #20]
34023432:	b003      	add	sp, #12
34023434:	bdf0      	pop	{r4, r5, r6, r7, pc}
34023436:	ab01      	add	r3, sp, #4
34023438:	466a      	mov	r2, sp
3402343a:	f7ff ffc9 	bl	340233d0 <__swhatbuf_r>
3402343e:	9f00      	ldr	r7, [sp, #0]
34023440:	4605      	mov	r5, r0
34023442:	4630      	mov	r0, r6
34023444:	4639      	mov	r1, r7
34023446:	f7fc ff3b 	bl	340202c0 <_malloc_r>
3402344a:	b948      	cbnz	r0, 34023460 <__smakebuf_r+0x46>
3402344c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34023450:	059a      	lsls	r2, r3, #22
34023452:	d4ee      	bmi.n	34023432 <__smakebuf_r+0x18>
34023454:	f023 0303 	bic.w	r3, r3, #3
34023458:	f043 0302 	orr.w	r3, r3, #2
3402345c:	81a3      	strh	r3, [r4, #12]
3402345e:	e7e2      	b.n	34023426 <__smakebuf_r+0xc>
34023460:	89a3      	ldrh	r3, [r4, #12]
34023462:	6020      	str	r0, [r4, #0]
34023464:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
34023468:	81a3      	strh	r3, [r4, #12]
3402346a:	9b01      	ldr	r3, [sp, #4]
3402346c:	e9c4 0704 	strd	r0, r7, [r4, #16]
34023470:	b15b      	cbz	r3, 3402348a <__smakebuf_r+0x70>
34023472:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
34023476:	4630      	mov	r0, r6
34023478:	f000 f84e 	bl	34023518 <_isatty_r>
3402347c:	b128      	cbz	r0, 3402348a <__smakebuf_r+0x70>
3402347e:	89a3      	ldrh	r3, [r4, #12]
34023480:	f023 0303 	bic.w	r3, r3, #3
34023484:	f043 0301 	orr.w	r3, r3, #1
34023488:	81a3      	strh	r3, [r4, #12]
3402348a:	89a3      	ldrh	r3, [r4, #12]
3402348c:	431d      	orrs	r5, r3
3402348e:	81a5      	strh	r5, [r4, #12]
34023490:	e7cf      	b.n	34023432 <__smakebuf_r+0x18>

34023492 <_raise_r>:
34023492:	291f      	cmp	r1, #31
34023494:	b538      	push	{r3, r4, r5, lr}
34023496:	4605      	mov	r5, r0
34023498:	460c      	mov	r4, r1
3402349a:	d904      	bls.n	340234a6 <_raise_r+0x14>
3402349c:	2316      	movs	r3, #22
3402349e:	6003      	str	r3, [r0, #0]
340234a0:	f04f 30ff 	mov.w	r0, #4294967295
340234a4:	bd38      	pop	{r3, r4, r5, pc}
340234a6:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
340234a8:	b112      	cbz	r2, 340234b0 <_raise_r+0x1e>
340234aa:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
340234ae:	b94b      	cbnz	r3, 340234c4 <_raise_r+0x32>
340234b0:	4628      	mov	r0, r5
340234b2:	f000 f853 	bl	3402355c <_getpid_r>
340234b6:	4622      	mov	r2, r4
340234b8:	4601      	mov	r1, r0
340234ba:	4628      	mov	r0, r5
340234bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
340234c0:	f000 b83a 	b.w	34023538 <_kill_r>
340234c4:	2b01      	cmp	r3, #1
340234c6:	d00a      	beq.n	340234de <_raise_r+0x4c>
340234c8:	1c59      	adds	r1, r3, #1
340234ca:	d103      	bne.n	340234d4 <_raise_r+0x42>
340234cc:	2316      	movs	r3, #22
340234ce:	6003      	str	r3, [r0, #0]
340234d0:	2001      	movs	r0, #1
340234d2:	e7e7      	b.n	340234a4 <_raise_r+0x12>
340234d4:	2100      	movs	r1, #0
340234d6:	4620      	mov	r0, r4
340234d8:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
340234dc:	4798      	blx	r3
340234de:	2000      	movs	r0, #0
340234e0:	e7e0      	b.n	340234a4 <_raise_r+0x12>
	...

340234e4 <raise>:
340234e4:	4b02      	ldr	r3, [pc, #8]	@ (340234f0 <raise+0xc>)
340234e6:	4601      	mov	r1, r0
340234e8:	6818      	ldr	r0, [r3, #0]
340234ea:	f7ff bfd2 	b.w	34023492 <_raise_r>
340234ee:	bf00      	nop
340234f0:	34033f68 	.word	0x34033f68

340234f4 <_fstat_r>:
340234f4:	b538      	push	{r3, r4, r5, lr}
340234f6:	2300      	movs	r3, #0
340234f8:	4d06      	ldr	r5, [pc, #24]	@ (34023514 <_fstat_r+0x20>)
340234fa:	4604      	mov	r4, r0
340234fc:	4608      	mov	r0, r1
340234fe:	4611      	mov	r1, r2
34023500:	602b      	str	r3, [r5, #0]
34023502:	f7e0 fad7 	bl	34003ab4 <_fstat>
34023506:	1c43      	adds	r3, r0, #1
34023508:	d102      	bne.n	34023510 <_fstat_r+0x1c>
3402350a:	682b      	ldr	r3, [r5, #0]
3402350c:	b103      	cbz	r3, 34023510 <_fstat_r+0x1c>
3402350e:	6023      	str	r3, [r4, #0]
34023510:	bd38      	pop	{r3, r4, r5, pc}
34023512:	bf00      	nop
34023514:	34053f00 	.word	0x34053f00

34023518 <_isatty_r>:
34023518:	b538      	push	{r3, r4, r5, lr}
3402351a:	2300      	movs	r3, #0
3402351c:	4d05      	ldr	r5, [pc, #20]	@ (34023534 <_isatty_r+0x1c>)
3402351e:	4604      	mov	r4, r0
34023520:	4608      	mov	r0, r1
34023522:	602b      	str	r3, [r5, #0]
34023524:	f7e0 fad6 	bl	34003ad4 <_isatty>
34023528:	1c43      	adds	r3, r0, #1
3402352a:	d102      	bne.n	34023532 <_isatty_r+0x1a>
3402352c:	682b      	ldr	r3, [r5, #0]
3402352e:	b103      	cbz	r3, 34023532 <_isatty_r+0x1a>
34023530:	6023      	str	r3, [r4, #0]
34023532:	bd38      	pop	{r3, r4, r5, pc}
34023534:	34053f00 	.word	0x34053f00

34023538 <_kill_r>:
34023538:	b538      	push	{r3, r4, r5, lr}
3402353a:	2300      	movs	r3, #0
3402353c:	4d06      	ldr	r5, [pc, #24]	@ (34023558 <_kill_r+0x20>)
3402353e:	4604      	mov	r4, r0
34023540:	4608      	mov	r0, r1
34023542:	4611      	mov	r1, r2
34023544:	602b      	str	r3, [r5, #0]
34023546:	f7e0 fa55 	bl	340039f4 <_kill>
3402354a:	1c43      	adds	r3, r0, #1
3402354c:	d102      	bne.n	34023554 <_kill_r+0x1c>
3402354e:	682b      	ldr	r3, [r5, #0]
34023550:	b103      	cbz	r3, 34023554 <_kill_r+0x1c>
34023552:	6023      	str	r3, [r4, #0]
34023554:	bd38      	pop	{r3, r4, r5, pc}
34023556:	bf00      	nop
34023558:	34053f00 	.word	0x34053f00

3402355c <_getpid_r>:
3402355c:	f7e0 ba42 	b.w	340039e4 <_getpid>

34023560 <_calloc_r>:
34023560:	b570      	push	{r4, r5, r6, lr}
34023562:	fba1 5402 	umull	r5, r4, r1, r2
34023566:	b934      	cbnz	r4, 34023576 <_calloc_r+0x16>
34023568:	4629      	mov	r1, r5
3402356a:	f7fc fea9 	bl	340202c0 <_malloc_r>
3402356e:	4606      	mov	r6, r0
34023570:	b928      	cbnz	r0, 3402357e <_calloc_r+0x1e>
34023572:	4630      	mov	r0, r6
34023574:	bd70      	pop	{r4, r5, r6, pc}
34023576:	220c      	movs	r2, #12
34023578:	2600      	movs	r6, #0
3402357a:	6002      	str	r2, [r0, #0]
3402357c:	e7f9      	b.n	34023572 <_calloc_r+0x12>
3402357e:	462a      	mov	r2, r5
34023580:	4621      	mov	r1, r4
34023582:	f7fe f827 	bl	340215d4 <memset>
34023586:	e7f4      	b.n	34023572 <_calloc_r+0x12>

34023588 <__ascii_mbtowc>:
34023588:	b082      	sub	sp, #8
3402358a:	b901      	cbnz	r1, 3402358e <__ascii_mbtowc+0x6>
3402358c:	a901      	add	r1, sp, #4
3402358e:	b142      	cbz	r2, 340235a2 <__ascii_mbtowc+0x1a>
34023590:	b14b      	cbz	r3, 340235a6 <__ascii_mbtowc+0x1e>
34023592:	7813      	ldrb	r3, [r2, #0]
34023594:	600b      	str	r3, [r1, #0]
34023596:	7812      	ldrb	r2, [r2, #0]
34023598:	1e10      	subs	r0, r2, #0
3402359a:	bf18      	it	ne
3402359c:	2001      	movne	r0, #1
3402359e:	b002      	add	sp, #8
340235a0:	4770      	bx	lr
340235a2:	4610      	mov	r0, r2
340235a4:	e7fb      	b.n	3402359e <__ascii_mbtowc+0x16>
340235a6:	f06f 0001 	mvn.w	r0, #1
340235aa:	e7f8      	b.n	3402359e <__ascii_mbtowc+0x16>

340235ac <__ascii_wctomb>:
340235ac:	4603      	mov	r3, r0
340235ae:	4608      	mov	r0, r1
340235b0:	b141      	cbz	r1, 340235c4 <__ascii_wctomb+0x18>
340235b2:	2aff      	cmp	r2, #255	@ 0xff
340235b4:	d904      	bls.n	340235c0 <__ascii_wctomb+0x14>
340235b6:	228a      	movs	r2, #138	@ 0x8a
340235b8:	f04f 30ff 	mov.w	r0, #4294967295
340235bc:	601a      	str	r2, [r3, #0]
340235be:	4770      	bx	lr
340235c0:	2001      	movs	r0, #1
340235c2:	700a      	strb	r2, [r1, #0]
340235c4:	4770      	bx	lr
	...

340235c8 <expf>:
340235c8:	ee10 2a10 	vmov	r2, s0
340235cc:	f240 412a 	movw	r1, #1066	@ 0x42a
340235d0:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
340235d4:	f3c2 530a 	ubfx	r3, r2, #20, #11
340235d8:	428b      	cmp	r3, r1
340235da:	b430      	push	{r4, r5}
340235dc:	d92a      	bls.n	34023634 <expf+0x6c>
340235de:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
340235e2:	d058      	beq.n	34023696 <expf+0xce>
340235e4:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
340235e8:	d303      	bcc.n	340235f2 <expf+0x2a>
340235ea:	ee30 0a00 	vadd.f32	s0, s0, s0
340235ee:	bc30      	pop	{r4, r5}
340235f0:	4770      	bx	lr
340235f2:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 3402369c <expf+0xd4>
340235f6:	eeb4 0ae7 	vcmpe.f32	s0, s15
340235fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340235fe:	dd03      	ble.n	34023608 <expf+0x40>
34023600:	2000      	movs	r0, #0
34023602:	bc30      	pop	{r4, r5}
34023604:	f000 b9f2 	b.w	340239ec <__math_oflowf>
34023608:	eddf 7a25 	vldr	s15, [pc, #148]	@ 340236a0 <expf+0xd8>
3402360c:	eeb4 0ae7 	vcmpe.f32	s0, s15
34023610:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34023614:	d503      	bpl.n	3402361e <expf+0x56>
34023616:	2000      	movs	r0, #0
34023618:	bc30      	pop	{r4, r5}
3402361a:	f000 b9db 	b.w	340239d4 <__math_uflowf>
3402361e:	eddf 7a21 	vldr	s15, [pc, #132]	@ 340236a4 <expf+0xdc>
34023622:	eeb4 0ae7 	vcmpe.f32	s0, s15
34023626:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402362a:	d503      	bpl.n	34023634 <expf+0x6c>
3402362c:	2000      	movs	r0, #0
3402362e:	bc30      	pop	{r4, r5}
34023630:	f000 b9d6 	b.w	340239e0 <__math_may_uflowf>
34023634:	4b1c      	ldr	r3, [pc, #112]	@ (340236a8 <expf+0xe0>)
34023636:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3402363a:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
3402363e:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
34023642:	eeb0 7b44 	vmov.f64	d7, d4
34023646:	eea5 7b06 	vfma.f64	d7, d5, d6
3402364a:	ee17 0a10 	vmov	r0, s14
3402364e:	ee37 7b44 	vsub.f64	d7, d7, d4
34023652:	f000 021f 	and.w	r2, r0, #31
34023656:	ee95 7b06 	vfnms.f64	d7, d5, d6
3402365a:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
3402365e:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
34023662:	684d      	ldr	r5, [r1, #4]
34023664:	2100      	movs	r1, #0
34023666:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
3402366a:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
3402366e:	190a      	adds	r2, r1, r4
34023670:	eea5 6b07 	vfma.f64	d6, d5, d7
34023674:	ee27 4b07 	vmul.f64	d4, d7, d7
34023678:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
3402367c:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
34023680:	eea5 0b07 	vfma.f64	d0, d5, d7
34023684:	ec43 2b17 	vmov	d7, r2, r3
34023688:	eea6 0b04 	vfma.f64	d0, d6, d4
3402368c:	ee20 0b07 	vmul.f64	d0, d0, d7
34023690:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34023694:	e7ab      	b.n	340235ee <expf+0x26>
34023696:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 340236ac <expf+0xe4>
3402369a:	e7a8      	b.n	340235ee <expf+0x26>
3402369c:	42b17217 	.word	0x42b17217
340236a0:	c2cff1b4 	.word	0xc2cff1b4
340236a4:	c2ce8ecf 	.word	0xc2ce8ecf
340236a8:	34033c60 	.word	0x34033c60
340236ac:	00000000 	.word	0x00000000

340236b0 <checkint>:
340236b0:	f3c0 53c7 	ubfx	r3, r0, #23, #8
340236b4:	2b7e      	cmp	r3, #126	@ 0x7e
340236b6:	d910      	bls.n	340236da <checkint+0x2a>
340236b8:	2b96      	cmp	r3, #150	@ 0x96
340236ba:	d80c      	bhi.n	340236d6 <checkint+0x26>
340236bc:	2201      	movs	r2, #1
340236be:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
340236c2:	fa02 f303 	lsl.w	r3, r2, r3
340236c6:	1e5a      	subs	r2, r3, #1
340236c8:	4202      	tst	r2, r0
340236ca:	d106      	bne.n	340236da <checkint+0x2a>
340236cc:	4203      	tst	r3, r0
340236ce:	bf14      	ite	ne
340236d0:	2001      	movne	r0, #1
340236d2:	2002      	moveq	r0, #2
340236d4:	4770      	bx	lr
340236d6:	2002      	movs	r0, #2
340236d8:	4770      	bx	lr
340236da:	2000      	movs	r0, #0
340236dc:	4770      	bx	lr
	...

340236e0 <powf>:
340236e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
340236e2:	ee10 1a10 	vmov	r1, s0
340236e6:	ee10 4a90 	vmov	r4, s1
340236ea:	eef0 7a40 	vmov.f32	s15, s0
340236ee:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
340236f2:	0063      	lsls	r3, r4, #1
340236f4:	eeb0 7a60 	vmov.f32	s14, s1
340236f8:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
340236fc:	f103 30ff 	add.w	r0, r3, #4294967295
34023700:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
34023704:	d252      	bcs.n	340237ac <powf+0xcc>
34023706:	4290      	cmp	r0, r2
34023708:	d258      	bcs.n	340237bc <powf+0xdc>
3402370a:	2000      	movs	r0, #0
3402370c:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
34023710:	4a9f      	ldr	r2, [pc, #636]	@ (34023990 <powf+0x2b0>)
34023712:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
34023716:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
3402371a:	f3c3 44c3 	ubfx	r4, r3, #19, #4
3402371e:	f36f 0316 	bfc	r3, #0, #23
34023722:	1ac9      	subs	r1, r1, r3
34023724:	eb02 1404 	add.w	r4, r2, r4, lsl #4
34023728:	15db      	asrs	r3, r3, #23
3402372a:	ee07 1a90 	vmov	s15, r1
3402372e:	ed94 4b00 	vldr	d4, [r4]
34023732:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
34023736:	ee07 3a90 	vmov	s15, r3
3402373a:	ed94 5b02 	vldr	d5, [r4, #8]
3402373e:	eea4 2b06 	vfma.f64	d2, d4, d6
34023742:	eeb8 6be7 	vcvt.f64.s32	d6, s15
34023746:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3402374a:	ee36 6b05 	vadd.f64	d6, d6, d5
3402374e:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
34023752:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
34023756:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
3402375a:	ee22 4b02 	vmul.f64	d4, d2, d2
3402375e:	eea2 1b05 	vfma.f64	d1, d2, d5
34023762:	ee24 0b04 	vmul.f64	d0, d4, d4
34023766:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
3402376a:	eea2 5b03 	vfma.f64	d5, d2, d3
3402376e:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
34023772:	eea2 6b03 	vfma.f64	d6, d2, d3
34023776:	eea4 6b05 	vfma.f64	d6, d4, d5
3402377a:	eea1 6b00 	vfma.f64	d6, d1, d0
3402377e:	ee27 7b06 	vmul.f64	d7, d7, d6
34023782:	ee17 3a90 	vmov	r3, s15
34023786:	f3c3 32cf 	ubfx	r2, r3, #15, #16
3402378a:	f248 03bf 	movw	r3, #32959	@ 0x80bf
3402378e:	429a      	cmp	r2, r3
34023790:	f0c0 8098 	bcc.w	340238c4 <powf+0x1e4>
34023794:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 34023970 <powf+0x290>
34023798:	eeb4 7bc6 	vcmpe.f64	d7, d6
3402379c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340237a0:	dd79      	ble.n	34023896 <powf+0x1b6>
340237a2:	b003      	add	sp, #12
340237a4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
340237a8:	f000 b920 	b.w	340239ec <__math_oflowf>
340237ac:	4290      	cmp	r0, r2
340237ae:	d330      	bcc.n	34023812 <powf+0x132>
340237b0:	b12b      	cbz	r3, 340237be <powf+0xde>
340237b2:	0049      	lsls	r1, r1, #1
340237b4:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
340237b8:	d808      	bhi.n	340237cc <powf+0xec>
340237ba:	e015      	b.n	340237e8 <powf+0x108>
340237bc:	b953      	cbnz	r3, 340237d4 <powf+0xf4>
340237be:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
340237c2:	0049      	lsls	r1, r1, #1
340237c4:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
340237c8:	f240 80ca 	bls.w	34023960 <powf+0x280>
340237cc:	ee37 0a87 	vadd.f32	s0, s15, s14
340237d0:	b003      	add	sp, #12
340237d2:	bd30      	pop	{r4, r5, pc}
340237d4:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
340237d8:	d105      	bne.n	340237e6 <powf+0x106>
340237da:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
340237de:	0064      	lsls	r4, r4, #1
340237e0:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
340237e4:	e7f0      	b.n	340237c8 <powf+0xe8>
340237e6:	0049      	lsls	r1, r1, #1
340237e8:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
340237ec:	d1ee      	bne.n	340237cc <powf+0xec>
340237ee:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
340237f2:	f000 80b5 	beq.w	34023960 <powf+0x280>
340237f6:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
340237fa:	ea6f 0404 	mvn.w	r4, r4
340237fe:	bf34      	ite	cc
34023800:	2100      	movcc	r1, #0
34023802:	2101      	movcs	r1, #1
34023804:	0fe4      	lsrs	r4, r4, #31
34023806:	42a1      	cmp	r1, r4
34023808:	f040 80ad 	bne.w	34023966 <powf+0x286>
3402380c:	ee27 0a07 	vmul.f32	s0, s14, s14
34023810:	e7de      	b.n	340237d0 <powf+0xf0>
34023812:	004d      	lsls	r5, r1, #1
34023814:	1e6b      	subs	r3, r5, #1
34023816:	4293      	cmp	r3, r2
34023818:	d31b      	bcc.n	34023852 <powf+0x172>
3402381a:	2900      	cmp	r1, #0
3402381c:	ee20 0a00 	vmul.f32	s0, s0, s0
34023820:	da0e      	bge.n	34023840 <powf+0x160>
34023822:	4620      	mov	r0, r4
34023824:	f7ff ff44 	bl	340236b0 <checkint>
34023828:	2801      	cmp	r0, #1
3402382a:	d109      	bne.n	34023840 <powf+0x160>
3402382c:	eeb1 0a40 	vneg.f32	s0, s0
34023830:	b945      	cbnz	r5, 34023844 <powf+0x164>
34023832:	2c00      	cmp	r4, #0
34023834:	dacc      	bge.n	340237d0 <powf+0xf0>
34023836:	b003      	add	sp, #12
34023838:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3402383c:	f000 b8dc 	b.w	340239f8 <__math_divzerof>
34023840:	2000      	movs	r0, #0
34023842:	e7f5      	b.n	34023830 <powf+0x150>
34023844:	2c00      	cmp	r4, #0
34023846:	dac3      	bge.n	340237d0 <powf+0xf0>
34023848:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3402384c:	ee87 0a80 	vdiv.f32	s0, s15, s0
34023850:	e7be      	b.n	340237d0 <powf+0xf0>
34023852:	2900      	cmp	r1, #0
34023854:	da1d      	bge.n	34023892 <powf+0x1b2>
34023856:	4620      	mov	r0, r4
34023858:	f7ff ff2a 	bl	340236b0 <checkint>
3402385c:	b920      	cbnz	r0, 34023868 <powf+0x188>
3402385e:	b003      	add	sp, #12
34023860:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34023864:	f000 b8da 	b.w	34023a1c <__math_invalidf>
34023868:	1e43      	subs	r3, r0, #1
3402386a:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
3402386e:	4258      	negs	r0, r3
34023870:	4158      	adcs	r0, r3
34023872:	0400      	lsls	r0, r0, #16
34023874:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
34023878:	f4bf af48 	bcs.w	3402370c <powf+0x2c>
3402387c:	eddf 6a45 	vldr	s13, [pc, #276]	@ 34023994 <powf+0x2b4>
34023880:	ee27 0aa6 	vmul.f32	s0, s15, s13
34023884:	ee10 3a10 	vmov	r3, s0
34023888:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3402388c:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
34023890:	e73c      	b.n	3402370c <powf+0x2c>
34023892:	2000      	movs	r0, #0
34023894:	e7ee      	b.n	34023874 <powf+0x194>
34023896:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 34023978 <powf+0x298>
3402389a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3402389e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340238a2:	dd45      	ble.n	34023930 <powf+0x250>
340238a4:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
340238a8:	b3d0      	cbz	r0, 34023920 <powf+0x240>
340238aa:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
340238ae:	9301      	str	r3, [sp, #4]
340238b0:	eddd 6a01 	vldr	s13, [sp, #4]
340238b4:	ee76 6a66 	vsub.f32	s13, s12, s13
340238b8:	eef4 6a46 	vcmp.f32	s13, s12
340238bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340238c0:	f47f af6f 	bne.w	340237a2 <powf+0xc2>
340238c4:	4b34      	ldr	r3, [pc, #208]	@ (34023998 <powf+0x2b8>)
340238c6:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
340238ca:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
340238ce:	ee37 6b05 	vadd.f64	d6, d7, d5
340238d2:	ee16 2a10 	vmov	r2, s12
340238d6:	ee36 6b45 	vsub.f64	d6, d6, d5
340238da:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
340238de:	ee37 7b46 	vsub.f64	d7, d7, d6
340238e2:	f002 011f 	and.w	r1, r2, #31
340238e6:	1880      	adds	r0, r0, r2
340238e8:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
340238ec:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
340238f0:	ee27 4b07 	vmul.f64	d4, d7, d7
340238f4:	2100      	movs	r1, #0
340238f6:	686d      	ldr	r5, [r5, #4]
340238f8:	190a      	adds	r2, r1, r4
340238fa:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
340238fe:	eea7 6b05 	vfma.f64	d6, d7, d5
34023902:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
34023906:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3402390a:	eea7 0b05 	vfma.f64	d0, d7, d5
3402390e:	ec43 2b17 	vmov	d7, r2, r3
34023912:	eea6 0b04 	vfma.f64	d0, d6, d4
34023916:	ee20 0b07 	vmul.f64	d0, d0, d7
3402391a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3402391e:	e757      	b.n	340237d0 <powf+0xf0>
34023920:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
34023924:	9300      	str	r3, [sp, #0]
34023926:	eddd 6a00 	vldr	s13, [sp]
3402392a:	ee76 6a86 	vadd.f32	s13, s13, s12
3402392e:	e7c3      	b.n	340238b8 <powf+0x1d8>
34023930:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 34023980 <powf+0x2a0>
34023934:	eeb4 7bc6 	vcmpe.f64	d7, d6
34023938:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402393c:	d804      	bhi.n	34023948 <powf+0x268>
3402393e:	b003      	add	sp, #12
34023940:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34023944:	f000 b846 	b.w	340239d4 <__math_uflowf>
34023948:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 34023988 <powf+0x2a8>
3402394c:	eeb4 7bc6 	vcmpe.f64	d7, d6
34023950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34023954:	d5b6      	bpl.n	340238c4 <powf+0x1e4>
34023956:	b003      	add	sp, #12
34023958:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3402395c:	f000 b840 	b.w	340239e0 <__math_may_uflowf>
34023960:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34023964:	e734      	b.n	340237d0 <powf+0xf0>
34023966:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 3402399c <powf+0x2bc>
3402396a:	e731      	b.n	340237d0 <powf+0xf0>
3402396c:	f3af 8000 	nop.w
34023970:	ffd1d571 	.word	0xffd1d571
34023974:	405fffff 	.word	0x405fffff
34023978:	ffa3aae2 	.word	0xffa3aae2
3402397c:	405fffff 	.word	0x405fffff
34023980:	00000000 	.word	0x00000000
34023984:	c062c000 	.word	0xc062c000
34023988:	00000000 	.word	0x00000000
3402398c:	c062a000 	.word	0xc062a000
34023990:	34033da8 	.word	0x34033da8
34023994:	4b000000 	.word	0x4b000000
34023998:	34033c60 	.word	0x34033c60
3402399c:	00000000 	.word	0x00000000

340239a0 <with_errnof>:
340239a0:	b510      	push	{r4, lr}
340239a2:	ed2d 8b02 	vpush	{d8}
340239a6:	eeb0 8a40 	vmov.f32	s16, s0
340239aa:	4604      	mov	r4, r0
340239ac:	f7fe f866 	bl	34021a7c <__errno>
340239b0:	6004      	str	r4, [r0, #0]
340239b2:	eeb0 0a48 	vmov.f32	s0, s16
340239b6:	ecbd 8b02 	vpop	{d8}
340239ba:	bd10      	pop	{r4, pc}

340239bc <xflowf>:
340239bc:	b130      	cbz	r0, 340239cc <xflowf+0x10>
340239be:	eef1 7a40 	vneg.f32	s15, s0
340239c2:	ee27 0a80 	vmul.f32	s0, s15, s0
340239c6:	2022      	movs	r0, #34	@ 0x22
340239c8:	f7ff bfea 	b.w	340239a0 <with_errnof>
340239cc:	eef0 7a40 	vmov.f32	s15, s0
340239d0:	e7f7      	b.n	340239c2 <xflowf+0x6>
	...

340239d4 <__math_uflowf>:
340239d4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 340239dc <__math_uflowf+0x8>
340239d8:	f7ff bff0 	b.w	340239bc <xflowf>
340239dc:	10000000 	.word	0x10000000

340239e0 <__math_may_uflowf>:
340239e0:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 340239e8 <__math_may_uflowf+0x8>
340239e4:	f7ff bfea 	b.w	340239bc <xflowf>
340239e8:	1a200000 	.word	0x1a200000

340239ec <__math_oflowf>:
340239ec:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 340239f4 <__math_oflowf+0x8>
340239f0:	f7ff bfe4 	b.w	340239bc <xflowf>
340239f4:	70000000 	.word	0x70000000

340239f8 <__math_divzerof>:
340239f8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
340239fc:	2800      	cmp	r0, #0
340239fe:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
34023a02:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 34023a18 <__math_divzerof+0x20>
34023a06:	f04f 0022 	mov.w	r0, #34	@ 0x22
34023a0a:	fe47 7a87 	vseleq.f32	s15, s15, s14
34023a0e:	ee87 0a80 	vdiv.f32	s0, s15, s0
34023a12:	f7ff bfc5 	b.w	340239a0 <with_errnof>
34023a16:	bf00      	nop
34023a18:	00000000 	.word	0x00000000

34023a1c <__math_invalidf>:
34023a1c:	eef0 7a40 	vmov.f32	s15, s0
34023a20:	ee30 7a40 	vsub.f32	s14, s0, s0
34023a24:	eef4 7a67 	vcmp.f32	s15, s15
34023a28:	ee87 0a07 	vdiv.f32	s0, s14, s14
34023a2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34023a30:	d602      	bvs.n	34023a38 <__math_invalidf+0x1c>
34023a32:	2021      	movs	r0, #33	@ 0x21
34023a34:	f7ff bfb4 	b.w	340239a0 <with_errnof>
34023a38:	4770      	bx	lr
	...

34023a3c <_sbrk>:
34023a3c:	4a04      	ldr	r2, [pc, #16]	@ (34023a50 <_sbrk+0x14>)
34023a3e:	4603      	mov	r3, r0
34023a40:	6811      	ldr	r1, [r2, #0]
34023a42:	b909      	cbnz	r1, 34023a48 <_sbrk+0xc>
34023a44:	4903      	ldr	r1, [pc, #12]	@ (34023a54 <_sbrk+0x18>)
34023a46:	6011      	str	r1, [r2, #0]
34023a48:	6810      	ldr	r0, [r2, #0]
34023a4a:	4403      	add	r3, r0
34023a4c:	6013      	str	r3, [r2, #0]
34023a4e:	4770      	bx	lr
34023a50:	34053f08 	.word	0x34053f08
34023a54:	34053f10 	.word	0x34053f10

34023a58 <_init>:
34023a58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34023a5a:	bf00      	nop
34023a5c:	bcf8      	pop	{r3, r4, r5, r6, r7}
34023a5e:	bc08      	pop	{r3}
34023a60:	469e      	mov	lr, r3
34023a62:	4770      	bx	lr

34023a64 <_fini>:
34023a64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34023a66:	bf00      	nop
34023a68:	bcf8      	pop	{r3, r4, r5, r6, r7}
34023a6a:	bc08      	pop	{r3}
34023a6c:	469e      	mov	lr, r3
34023a6e:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34023a80 <SECURE_SystemCoreClockUpdate>:
34023a80:	e97f e97f 	sg
34023a84:	f7e3 bd30 	b.w	340074e8 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
