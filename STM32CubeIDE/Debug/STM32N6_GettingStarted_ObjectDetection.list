
STM32N6_GettingStarted_ObjectDetection.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001b3b4  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .gnu.sgstubs  00000020  3401bb20  3401bb20  0001bb20  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000230f0  3401bb40  3401bb40  0001bb40  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .version      0000000c  3403ec30  3403ec30  0003ec30  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.extab    00000000  3403ec3c  3403ec3c  0003ef98  2**0
                  CONTENTS
  6 .ARM          00000008  3403ec3c  3403ec3c  0003ec3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .preinit_array 00000000  3403ec44  3403ef98  0003ef98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .init_array   00000004  3403ec44  3403ec44  0003ec44  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fini_array   00000004  3403ec48  3403ec48  0003ec48  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .data         0000034c  3403ec4c  3403ec4c  0003ec4c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          00005780  3403ef98  3403ef98  0003ef98  2**3
                  ALLOC
 12 ._user_heap_stack 00004200  34044718  34044718  0003ef98  2**0
                  ALLOC
 13 .psram_section 00232800  91000000  91000000  0003f000  2**5
                  ALLOC
 14 .ARM.attributes 0000003a  00000000  00000000  0003ef98  2**0
                  CONTENTS, READONLY
 15 .debug_info   000830a7  00000000  00000000  0003efd2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000b7f3  00000000  00000000  000c2079  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 0002ff3b  00000000  00000000  000cd86c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000033d8  00000000  00000000  000fd7a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00004840  00000000  00000000  00100b80  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00095543  00000000  00000000  001053c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0005fac1  00000000  00000000  0019a903  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    003b657a  00000000  00000000  001fa3c4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000086  00000000  00000000  005b093e  2**0
                  CONTENTS, READONLY
 24 .debug_frame  0000b5d0  00000000  00000000  005b09c4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 000000c7  00000000  00000000  005bbf94  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	3403ef98 	.word	0x3403ef98
3400076c:	00000000 	.word	0x00000000
34000770:	3401baec 	.word	0x3401baec

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	3403ef9c 	.word	0x3403ef9c
3400078c:	3401baec 	.word	0x3401baec

34000790 <vsvAKZpqpB>:
34000790:	ed90 6aad 	vldr	s12, [r0, #692]	@ 0x2b4
34000794:	b530      	push	{r4, r5, lr}
34000796:	ed2d 8b10 	vpush	{d8-d15}
3400079a:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
3400079e:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
340007a2:	b087      	sub	sp, #28
340007a4:	ed8d 7b02 	vstr	d7, [sp, #8]
340007a8:	2300      	movs	r3, #0
340007aa:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
340007ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340007b2:	ed91 5a01 	vldr	s10, [r1, #4]
340007b6:	ed91 4a00 	vldr	s8, [r1]
340007ba:	ed91 fb02 	vldr	d15, [r1, #8]
340007be:	ed91 eb04 	vldr	d14, [r1, #16]
340007c2:	4604      	mov	r4, r0
340007c4:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
340007c8:	ed90 cbaa 	vldr	d12, [r0, #680]	@ 0x2a8
340007cc:	ed90 ab16 	vldr	d10, [r0, #88]	@ 0x58
340007d0:	ed8d 7b04 	vstr	d7, [sp, #16]
340007d4:	ed90 bba6 	vldr	d11, [r0, #664]	@ 0x298
340007d8:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
340007dc:	dc09      	bgt.n	340007f2 <vsvAKZpqpB+0x62>
340007de:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
340007e2:	48d1      	ldr	r0, [pc, #836]	@ (34000b28 <vsvAKZpqpB+0x398>)
340007e4:	4798      	blx	r3
340007e6:	f04f 30ff 	mov.w	r0, #4294967295
340007ea:	b007      	add	sp, #28
340007ec:	ecbd 8b10 	vpop	{d8-d15}
340007f0:	bd30      	pop	{r4, r5, pc}
340007f2:	eeb8 5b45 	vcvt.f64.u32	d5, s10
340007f6:	ed9f 7bbe 	vldr	d7, [pc, #760]	@ 34000af0 <vsvAKZpqpB+0x360>
340007fa:	eeb8 4b44 	vcvt.f64.u32	d4, s8
340007fe:	ee25 7b07 	vmul.f64	d7, d5, d7
34000802:	eeb4 7bc4 	vcmpe.f64	d7, d4
34000806:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400080a:	dd0f      	ble.n	3400082c <vsvAKZpqpB+0x9c>
3400080c:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
34000810:	ed9f 2bb9 	vldr	d2, [pc, #740]	@ 34000af8 <vsvAKZpqpB+0x368>
34000814:	ee37 2b02 	vadd.f64	d2, d7, d2
34000818:	ed9f 7bb9 	vldr	d7, [pc, #740]	@ 34000b00 <vsvAKZpqpB+0x370>
3400081c:	eeb4 2bc7 	vcmpe.f64	d2, d7
34000820:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000824:	fe37 7b02 	vselgt.f64	d7, d7, d2
34000828:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
3400082c:	ed9f 7bb6 	vldr	d7, [pc, #728]	@ 34000b08 <vsvAKZpqpB+0x378>
34000830:	ee25 5b07 	vmul.f64	d5, d5, d7
34000834:	eeb4 5bc4 	vcmpe.f64	d5, d4
34000838:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400083c:	d510      	bpl.n	34000860 <vsvAKZpqpB+0xd0>
3400083e:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
34000842:	ed9f 5bad 	vldr	d5, [pc, #692]	@ 34000af8 <vsvAKZpqpB+0x368>
34000846:	ee37 7b45 	vsub.f64	d7, d7, d5
3400084a:	ed9f 5bb1 	vldr	d5, [pc, #708]	@ 34000b10 <vsvAKZpqpB+0x380>
3400084e:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000852:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000856:	bf58      	it	pl
34000858:	eeb0 5b47 	vmovpl.f64	d5, d7
3400085c:	ed84 5b1c 	vstr	d5, [r4, #112]	@ 0x70
34000860:	ee83 8b0c 	vdiv.f64	d8, d3, d12
34000864:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34000868:	eeb8 8b48 	vcvt.f64.u32	d8, s16
3400086c:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34000870:	ee28 8b0c 	vmul.f64	d8, d8, d12
34000874:	2d01      	cmp	r5, #1
34000876:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3400087a:	f040 80ac 	bne.w	340009d6 <vsvAKZpqpB+0x246>
3400087e:	ed9f 7ba6 	vldr	d7, [pc, #664]	@ 34000b18 <vsvAKZpqpB+0x388>
34000882:	ee3f 5b4e 	vsub.f64	d5, d15, d14
34000886:	ee85 db07 	vdiv.f64	d13, d5, d7
3400088a:	ee3f 5b0e 	vadd.f64	d5, d15, d14
3400088e:	ee85 9b07 	vdiv.f64	d9, d5, d7
34000892:	eeb0 7bcd 	vabs.f64	d7, d13
34000896:	eeb4 6bc7 	vcmpe.f64	d6, d7
3400089a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400089e:	eeb0 5bc9 	vabs.f64	d5, d9
340008a2:	db1f      	blt.n	340008e4 <vsvAKZpqpB+0x154>
340008a4:	eeb4 6bc5 	vcmpe.f64	d6, d5
340008a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008ac:	db1a      	blt.n	340008e4 <vsvAKZpqpB+0x154>
340008ae:	2300      	movs	r3, #0
340008b0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
340008b4:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
340008b8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
340008bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008c0:	f340 8134 	ble.w	34000b2c <vsvAKZpqpB+0x39c>
340008c4:	2301      	movs	r3, #1
340008c6:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340008ca:	ed9d 7b02 	vldr	d7, [sp, #8]
340008ce:	eeb4 abc7 	vcmpe.f64	d10, d7
340008d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008d6:	f140 813c 	bpl.w	34000b52 <vsvAKZpqpB+0x3c2>
340008da:	ed9d 7b04 	vldr	d7, [sp, #16]
340008de:	ee3a bb07 	vadd.f64	d11, d10, d7
340008e2:	e128      	b.n	34000b36 <vsvAKZpqpB+0x3a6>
340008e4:	eeb4 6bc5 	vcmpe.f64	d6, d5
340008e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008ec:	d50c      	bpl.n	34000908 <vsvAKZpqpB+0x178>
340008ee:	ee89 5b0d 	vdiv.f64	d5, d9, d13
340008f2:	ed94 6aae 	vldr	s12, [r4, #696]	@ 0x2b8
340008f6:	eeb0 5bc5 	vabs.f64	d5, d5
340008fa:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
340008fe:	eeb4 5bc6 	vcmpe.f64	d5, d6
34000902:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000906:	dad5      	bge.n	340008b4 <vsvAKZpqpB+0x124>
34000908:	eef7 0bca 	vcvt.f32.f64	s1, d10
3400090c:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
34000910:	f01a fdc6 	bl	3401b4a0 <powf>
34000914:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34000918:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
3400091c:	ee20 0b07 	vmul.f64	d0, d0, d7
34000920:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34000924:	eeb0 6bce 	vabs.f64	d6, d14
34000928:	edcd 7a01 	vstr	s15, [sp, #4]
3400092c:	eeb0 7bcf 	vabs.f64	d7, d15
34000930:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000938:	dc62      	bgt.n	34000a00 <vsvAKZpqpB+0x270>
3400093a:	eeb5 ebc0 	vcmpe.f64	d14, #0.0
3400093e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000942:	d562      	bpl.n	34000a0a <vsvAKZpqpB+0x27a>
34000944:	ee38 0b00 	vadd.f64	d0, d8, d0
34000948:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
3400094c:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000954:	d503      	bpl.n	3400095e <vsvAKZpqpB+0x1ce>
34000956:	eeb0 ab4b 	vmov.f64	d10, d11
3400095a:	eeb0 0b47 	vmov.f64	d0, d7
3400095e:	ed94 7b3a 	vldr	d7, [r4, #232]	@ 0xe8
34000962:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000966:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400096a:	dd03      	ble.n	34000974 <vsvAKZpqpB+0x1e4>
3400096c:	eeb0 ab4b 	vmov.f64	d10, d11
34000970:	eeb0 0b47 	vmov.f64	d0, d7
34000974:	ee80 8b0c 	vdiv.f64	d8, d0, d12
34000978:	eebc 8bc8 	vcvt.u32.f64	s16, d8
3400097c:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34000980:	2d01      	cmp	r5, #1
34000982:	ee2c 8b08 	vmul.f64	d8, d12, d8
34000986:	d116      	bne.n	340009b6 <vsvAKZpqpB+0x226>
34000988:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
3400098c:	2b02      	cmp	r3, #2
3400098e:	d83f      	bhi.n	34000a10 <vsvAKZpqpB+0x280>
34000990:	eddd 7a01 	vldr	s15, [sp, #4]
34000994:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000998:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
3400099c:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
340009a0:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
340009a4:	eb04 1203 	add.w	r2, r4, r3, lsl #4
340009a8:	3301      	adds	r3, #1
340009aa:	ed82 db2c 	vstr	d13, [r2, #176]	@ 0xb0
340009ae:	ed82 9b2e 	vstr	d9, [r2, #184]	@ 0xb8
340009b2:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
340009b6:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
340009ba:	2b01      	cmp	r3, #1
340009bc:	d007      	beq.n	340009ce <vsvAKZpqpB+0x23e>
340009be:	eefc 7bc8 	vcvt.u32.f64	s15, d8
340009c2:	ee17 3a90 	vmov	r3, s15
340009c6:	9a01      	ldr	r2, [sp, #4]
340009c8:	4293      	cmp	r3, r2
340009ca:	f43f af73 	beq.w	340008b4 <vsvAKZpqpB+0x124>
340009ce:	2301      	movs	r3, #1
340009d0:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340009d4:	e76e      	b.n	340008b4 <vsvAKZpqpB+0x124>
340009d6:	eeb0 7bcf 	vabs.f64	d7, d15
340009da:	eeb0 5bce 	vabs.f64	d5, d14
340009de:	eeb4 5b47 	vcmp.f64	d5, d7
340009e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009e6:	fe35 7b07 	vselgt.f64	d7, d5, d7
340009ea:	eeb4 7bc6 	vcmpe.f64	d7, d6
340009ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009f2:	f67f af5f 	bls.w	340008b4 <vsvAKZpqpB+0x124>
340009f6:	ed9f 9b4a 	vldr	d9, [pc, #296]	@ 34000b20 <vsvAKZpqpB+0x390>
340009fa:	eeb0 db49 	vmov.f64	d13, d9
340009fe:	e783      	b.n	34000908 <vsvAKZpqpB+0x178>
34000a00:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34000a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a08:	d59c      	bpl.n	34000944 <vsvAKZpqpB+0x1b4>
34000a0a:	ee38 0b40 	vsub.f64	d0, d8, d0
34000a0e:	e79b      	b.n	34000948 <vsvAKZpqpB+0x1b8>
34000a10:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34000a14:	ed94 6aaf 	vldr	s12, [r4, #700]	@ 0x2bc
34000a18:	ee38 7b47 	vsub.f64	d7, d8, d7
34000a1c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34000a20:	eeb0 7bc7 	vabs.f64	d7, d7
34000a24:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000a28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a2c:	db56      	blt.n	34000adc <vsvAKZpqpB+0x34c>
34000a2e:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34000a32:	ee38 7b47 	vsub.f64	d7, d8, d7
34000a36:	eeb0 7bc7 	vabs.f64	d7, d7
34000a3a:	eeb4 6bc7 	vcmpe.f64	d6, d7
34000a3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a42:	dd4b      	ble.n	34000adc <vsvAKZpqpB+0x34c>
34000a44:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34000a48:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34000a4c:	ee39 0b40 	vsub.f64	d0, d9, d0
34000a50:	ee3d 7b47 	vsub.f64	d7, d13, d7
34000a54:	ee20 0b00 	vmul.f64	d0, d0, d0
34000a58:	eea7 0b07 	vfma.f64	d0, d7, d7
34000a5c:	f01a f970 	bl	3401ad40 <sqrt>
34000a60:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34000a64:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000a68:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000a6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a70:	d534      	bpl.n	34000adc <vsvAKZpqpB+0x34c>
34000a72:	eddd 7a01 	vldr	s15, [sp, #4]
34000a76:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34000a7a:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34000a7e:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000a82:	2b00      	cmp	r3, #0
34000a84:	d197      	bne.n	340009b6 <vsvAKZpqpB+0x226>
34000a86:	2210      	movs	r2, #16
34000a88:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34000a8c:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34000a90:	f018 f85a 	bl	34018b48 <memmove>
34000a94:	2210      	movs	r2, #16
34000a96:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
34000a9a:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34000a9e:	f018 f853 	bl	34018b48 <memmove>
34000aa2:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
34000aa6:	eddd 7a01 	vldr	s15, [sp, #4]
34000aaa:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000aae:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34000ab2:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34000ab6:	ed84 7b24 	vstr	d7, [r4, #144]	@ 0x90
34000aba:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
34000abe:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34000ac2:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
34000ac6:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
34000aca:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
34000ace:	ed84 db34 	vstr	d13, [r4, #208]	@ 0xd0
34000ad2:	ed84 9b36 	vstr	d9, [r4, #216]	@ 0xd8
34000ad6:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
34000ada:	e76c      	b.n	340009b6 <vsvAKZpqpB+0x226>
34000adc:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000ae0:	2b01      	cmp	r3, #1
34000ae2:	bf04      	itt	eq
34000ae4:	2300      	moveq	r3, #0
34000ae6:	f884 3078 	strbeq.w	r3, [r4, #120]	@ 0x78
34000aea:	e7c8      	b.n	34000a7e <vsvAKZpqpB+0x2ee>
34000aec:	f3af 8000 	nop.w
34000af0:	9999999a 	.word	0x9999999a
34000af4:	3fa99999 	.word	0x3fa99999
34000af8:	47ae147b 	.word	0x47ae147b
34000afc:	3f847ae1 	.word	0x3f847ae1
34000b00:	33333334 	.word	0x33333334
34000b04:	3fc33333 	.word	0x3fc33333
34000b08:	33333333 	.word	0x33333333
34000b0c:	3fc33333 	.word	0x3fc33333
34000b10:	11111111 	.word	0x11111111
34000b14:	3fb11111 	.word	0x3fb11111
34000b18:	667f3bcd 	.word	0x667f3bcd
34000b1c:	3ff6a09e 	.word	0x3ff6a09e
	...
34000b28:	3401d8a4 	.word	0x3401d8a4
34000b2c:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34000b30:	2b00      	cmp	r3, #0
34000b32:	f47f aeca 	bne.w	340008ca <vsvAKZpqpB+0x13a>
34000b36:	ee88 7b0c 	vdiv.f64	d7, d8, d12
34000b3a:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34000b3e:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34000b42:	ee27 7b0c 	vmul.f64	d7, d7, d12
34000b46:	ed84 bb16 	vstr	d11, [r4, #88]	@ 0x58
34000b4a:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34000b4e:	2001      	movs	r0, #1
34000b50:	e64b      	b.n	340007ea <vsvAKZpqpB+0x5a>
34000b52:	ed9d bb02 	vldr	d11, [sp, #8]
34000b56:	e7ee      	b.n	34000b36 <vsvAKZpqpB+0x3a6>

34000b58 <JxZhqVLLqu>:
34000b58:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34000b5c:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000b60:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34000b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b68:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34000b6c:	eeb0 7b46 	vmov.f64	d7, d6
34000b70:	bfdf      	itttt	le
34000b72:	ee84 7b05 	vdivle.f64	d7, d4, d5
34000b76:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34000b7a:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34000b7e:	ee27 7b05 	vmulle.f64	d7, d7, d5
34000b82:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34000b86:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34000b8a:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000b8e:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b96:	bfc8      	it	gt
34000b98:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34000b9c:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34000ba0:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000ba4:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000ba8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bac:	bf48      	it	mi
34000bae:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34000bb2:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34000bb6:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34000bba:	b530      	push	{r4, r5, lr}
34000bbc:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34000bc0:	ed93 5a00 	vldr	s10, [r3]
34000bc4:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34000bc8:	eeb4 5ac7 	vcmpe.f32	s10, s14
34000bcc:	eef1 5a67 	vneg.f32	s11, s15
34000bd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bd4:	f04f 0100 	mov.w	r1, #0
34000bd8:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34000bdc:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34000be0:	3b01      	subs	r3, #1
34000be2:	b28a      	uxth	r2, r1
34000be4:	4293      	cmp	r3, r2
34000be6:	d805      	bhi.n	34000bf4 <JxZhqVLLqu+0x9c>
34000be8:	2244      	movs	r2, #68	@ 0x44
34000bea:	fb02 0303 	mla	r3, r2, r3, r0
34000bee:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34000bf2:	e011      	b.n	34000c18 <JxZhqVLLqu+0xc0>
34000bf4:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34000bf8:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34000bfc:	ee77 5aa5 	vadd.f32	s11, s15, s11
34000c00:	eef4 5ac7 	vcmpe.f32	s11, s14
34000c04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c08:	f101 0101 	add.w	r1, r1, #1
34000c0c:	dbe9      	blt.n	34000be2 <JxZhqVLLqu+0x8a>
34000c0e:	2344      	movs	r3, #68	@ 0x44
34000c10:	fb03 0202 	mla	r2, r3, r2, r0
34000c14:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34000c18:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000c1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c20:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34000c24:	dc05      	bgt.n	34000c32 <JxZhqVLLqu+0xda>
34000c26:	ed93 7a00 	vldr	s14, [r3]
34000c2a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000c2e:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34000c32:	685a      	ldr	r2, [r3, #4]
34000c34:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34000c38:	6042      	str	r2, [r0, #4]
34000c3a:	689a      	ldr	r2, [r3, #8]
34000c3c:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34000c40:	6082      	str	r2, [r0, #8]
34000c42:	68da      	ldr	r2, [r3, #12]
34000c44:	60c2      	str	r2, [r0, #12]
34000c46:	691a      	ldr	r2, [r3, #16]
34000c48:	6102      	str	r2, [r0, #16]
34000c4a:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34000c4e:	695d      	ldr	r5, [r3, #20]
34000c50:	330c      	adds	r3, #12
34000c52:	6145      	str	r5, [r0, #20]
34000c54:	68dd      	ldr	r5, [r3, #12]
34000c56:	300c      	adds	r0, #12
34000c58:	60c5      	str	r5, [r0, #12]
34000c5a:	691d      	ldr	r5, [r3, #16]
34000c5c:	42a3      	cmp	r3, r4
34000c5e:	6105      	str	r5, [r0, #16]
34000c60:	f851 5b04 	ldr.w	r5, [r1], #4
34000c64:	f842 5b04 	str.w	r5, [r2], #4
34000c68:	d1f1      	bne.n	34000c4e <JxZhqVLLqu+0xf6>
34000c6a:	2001      	movs	r0, #1
34000c6c:	bd30      	pop	{r4, r5, pc}

34000c6e <evision_api_awb_new>:
34000c6e:	b510      	push	{r4, lr}
34000c70:	4604      	mov	r4, r0
34000c72:	b090      	sub	sp, #64	@ 0x40
34000c74:	b170      	cbz	r0, 34000c94 <evision_api_awb_new+0x26>
34000c76:	2300      	movs	r3, #0
34000c78:	4c08      	ldr	r4, [pc, #32]	@ (34000c9c <evision_api_awb_new+0x2e>)
34000c7a:	2140      	movs	r1, #64	@ 0x40
34000c7c:	7023      	strb	r3, [r4, #0]
34000c7e:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34000c82:	4b07      	ldr	r3, [pc, #28]	@ (34000ca0 <evision_api_awb_new+0x32>)
34000c84:	4668      	mov	r0, sp
34000c86:	4a07      	ldr	r2, [pc, #28]	@ (34000ca4 <evision_api_awb_new+0x36>)
34000c88:	f017 fe14 	bl	340188b4 <sniprintf>
34000c8c:	4668      	mov	r0, sp
34000c8e:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000c92:	4798      	blx	r3
34000c94:	4620      	mov	r0, r4
34000c96:	b010      	add	sp, #64	@ 0x40
34000c98:	bd10      	pop	{r4, pc}
34000c9a:	bf00      	nop
34000c9c:	3403efb8 	.word	0x3403efb8
34000ca0:	3403ec30 	.word	0x3403ec30
34000ca4:	3401d8e4 	.word	0x3401d8e4

34000ca8 <evision_api_awb_delete>:
34000ca8:	2800      	cmp	r0, #0
34000caa:	bf14      	ite	ne
34000cac:	2001      	movne	r0, #1
34000cae:	f04f 30ff 	moveq.w	r0, #4294967295
34000cb2:	4770      	bx	lr

34000cb4 <evision_api_awb_set_profile>:
34000cb4:	ed80 0a00 	vstr	s0, [r0]
34000cb8:	b530      	push	{r4, r5, lr}
34000cba:	680c      	ldr	r4, [r1, #0]
34000cbc:	6044      	str	r4, [r0, #4]
34000cbe:	684c      	ldr	r4, [r1, #4]
34000cc0:	6084      	str	r4, [r0, #8]
34000cc2:	688c      	ldr	r4, [r1, #8]
34000cc4:	60c4      	str	r4, [r0, #12]
34000cc6:	68c9      	ldr	r1, [r1, #12]
34000cc8:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34000ccc:	6101      	str	r1, [r0, #16]
34000cce:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34000cd2:	6815      	ldr	r5, [r2, #0]
34000cd4:	320c      	adds	r2, #12
34000cd6:	6145      	str	r5, [r0, #20]
34000cd8:	f852 5c08 	ldr.w	r5, [r2, #-8]
34000cdc:	300c      	adds	r0, #12
34000cde:	60c5      	str	r5, [r0, #12]
34000ce0:	f852 5c04 	ldr.w	r5, [r2, #-4]
34000ce4:	42a2      	cmp	r2, r4
34000ce6:	6105      	str	r5, [r0, #16]
34000ce8:	f853 5b04 	ldr.w	r5, [r3], #4
34000cec:	f841 5b04 	str.w	r5, [r1], #4
34000cf0:	d1ef      	bne.n	34000cd2 <evision_api_awb_set_profile+0x1e>
34000cf2:	bd30      	pop	{r4, r5, pc}

34000cf4 <evision_api_awb_init_profiles>:
34000cf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000cf8:	ed2d 8b06 	vpush	{d8-d10}
34000cfc:	460e      	mov	r6, r1
34000cfe:	eeb0 9b40 	vmov.f64	d9, d0
34000d02:	eeb0 8b41 	vmov.f64	d8, d1
34000d06:	461d      	mov	r5, r3
34000d08:	4604      	mov	r4, r0
34000d0a:	b0c7      	sub	sp, #284	@ 0x11c
34000d0c:	2800      	cmp	r0, #0
34000d0e:	f000 818f 	beq.w	34001030 <evision_api_awb_init_profiles+0x33c>
34000d12:	ed9f abcb 	vldr	d10, [pc, #812]	@ 34001040 <evision_api_awb_init_profiles+0x34c>
34000d16:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34000d1a:	2000      	movs	r0, #0
34000d1c:	49ce      	ldr	r1, [pc, #824]	@ (34001058 <evision_api_awb_init_profiles+0x364>)
34000d1e:	f04f 0800 	mov.w	r8, #0
34000d22:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34000d26:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34000d2a:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34000d2e:	49cb      	ldr	r1, [pc, #812]	@ (3400105c <evision_api_awb_init_profiles+0x368>)
34000d30:	f8df 935c 	ldr.w	r9, [pc, #860]	@ 34001090 <evision_api_awb_init_profiles+0x39c>
34000d34:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34000d38:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34000d3c:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34000d40:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34000d44:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34000d48:	f20f 29fc 	addw	r9, pc, #764	@ 0x2fc
34000d4c:	e9d9 8900 	ldrd	r8, r9, [r9]
34000d50:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34000d54:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
34000d58:	f04f 0800 	mov.w	r8, #0
34000d5c:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34000d60:	49bf      	ldr	r1, [pc, #764]	@ (34001060 <evision_api_awb_init_profiles+0x36c>)
34000d62:	f8df 9330 	ldr.w	r9, [pc, #816]	@ 34001094 <evision_api_awb_init_profiles+0x3a0>
34000d66:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
34000d6a:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34000d6e:	2300      	movs	r3, #0
34000d70:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34000d74:	2701      	movs	r7, #1
34000d76:	f04f 0800 	mov.w	r8, #0
34000d7a:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34000d7e:	1e71      	subs	r1, r6, #1
34000d80:	f8df 9314 	ldr.w	r9, [pc, #788]	@ 34001098 <evision_api_awb_init_profiles+0x3a4>
34000d84:	b288      	uxth	r0, r1
34000d86:	2804      	cmp	r0, #4
34000d88:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34000d8c:	f20f 29c0 	addw	r9, pc, #704	@ 0x2c0
34000d90:	e9d9 8900 	ldrd	r8, r9, [r9]
34000d94:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000d98:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34000d9c:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34000da0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34000da4:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
34000da8:	d914      	bls.n	34000dd4 <evision_api_awb_init_profiles+0xe0>
34000daa:	2305      	movs	r3, #5
34000dac:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000db0:	4aac      	ldr	r2, [pc, #688]	@ (34001064 <evision_api_awb_init_profiles+0x370>)
34000db2:	a806      	add	r0, sp, #24
34000db4:	f017 fd7e 	bl	340188b4 <sniprintf>
34000db8:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000dbc:	a806      	add	r0, sp, #24
34000dbe:	4798      	blx	r3
34000dc0:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34000dc4:	4620      	mov	r0, r4
34000dc6:	b047      	add	sp, #284	@ 0x11c
34000dc8:	ecbd 8b06 	vpop	{d8-d10}
34000dcc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000dd0:	f7ff bec2 	b.w	34000b58 <JxZhqVLLqu>
34000dd4:	ed95 7a00 	vldr	s14, [r5]
34000dd8:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000ddc:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000de0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000de4:	dd12      	ble.n	34000e0c <evision_api_awb_init_profiles+0x118>
34000de6:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000dea:	489f      	ldr	r0, [pc, #636]	@ (34001068 <evision_api_awb_init_profiles+0x374>)
34000dec:	4798      	blx	r3
34000dee:	ed95 7a00 	vldr	s14, [r5]
34000df2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000df6:	ed8d 9b00 	vstr	d9, [sp]
34000dfa:	ed8d 7b02 	vstr	d7, [sp, #8]
34000dfe:	4a9b      	ldr	r2, [pc, #620]	@ (3400106c <evision_api_awb_init_profiles+0x378>)
34000e00:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000e04:	a806      	add	r0, sp, #24
34000e06:	f017 fd55 	bl	340188b4 <sniprintf>
34000e0a:	e7d5      	b.n	34000db8 <evision_api_awb_init_profiles+0xc4>
34000e0c:	f04f 0c44 	mov.w	ip, #68	@ 0x44
34000e10:	fb0c 5806 	mla	r8, ip, r6, r5
34000e14:	ed18 7a11 	vldr	s14, [r8, #-68]	@ 0xffffffbc
34000e18:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e1c:	eeb4 1bc7 	vcmpe.f64	d1, d7
34000e20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e24:	d541      	bpl.n	34000eaa <evision_api_awb_init_profiles+0x1b6>
34000e26:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000e2a:	4891      	ldr	r0, [pc, #580]	@ (34001070 <evision_api_awb_init_profiles+0x37c>)
34000e2c:	4798      	blx	r3
34000e2e:	ed98 7a00 	vldr	s14, [r8]
34000e32:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e36:	ed8d 8b00 	vstr	d8, [sp]
34000e3a:	ed8d 7b02 	vstr	d7, [sp, #8]
34000e3e:	4a8d      	ldr	r2, [pc, #564]	@ (34001074 <evision_api_awb_init_profiles+0x380>)
34000e40:	e7de      	b.n	34000e00 <evision_api_awb_init_profiles+0x10c>
34000e42:	fb0c f708 	mul.w	r7, ip, r8
34000e46:	eb05 0907 	add.w	r9, r5, r7
34000e4a:	3744      	adds	r7, #68	@ 0x44
34000e4c:	442f      	add	r7, r5
34000e4e:	ed99 7a00 	vldr	s14, [r9]
34000e52:	edd7 7a00 	vldr	s15, [r7]
34000e56:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000e5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e5e:	f108 0a01 	add.w	sl, r8, #1
34000e62:	f100 0001 	add.w	r0, r0, #1
34000e66:	db21      	blt.n	34000eac <evision_api_awb_init_profiles+0x1b8>
34000e68:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000e6c:	4882      	ldr	r0, [pc, #520]	@ (34001078 <evision_api_awb_init_profiles+0x384>)
34000e6e:	4798      	blx	r3
34000e70:	ed97 7a00 	vldr	s14, [r7]
34000e74:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e78:	ed8d 7b04 	vstr	d7, [sp, #16]
34000e7c:	f8cd a008 	str.w	sl, [sp, #8]
34000e80:	ed99 7a00 	vldr	s14, [r9]
34000e84:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e88:	4643      	mov	r3, r8
34000e8a:	ed8d 7b00 	vstr	d7, [sp]
34000e8e:	4a7b      	ldr	r2, [pc, #492]	@ (3400107c <evision_api_awb_init_profiles+0x388>)
34000e90:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000e94:	a806      	add	r0, sp, #24
34000e96:	f017 fd0d 	bl	340188b4 <sniprintf>
34000e9a:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000e9e:	a806      	add	r0, sp, #24
34000ea0:	4798      	blx	r3
34000ea2:	2301      	movs	r3, #1
34000ea4:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34000ea8:	e78c      	b.n	34000dc4 <evision_api_awb_init_profiles+0xd0>
34000eaa:	4618      	mov	r0, r3
34000eac:	fa1f f880 	uxth.w	r8, r0
34000eb0:	4541      	cmp	r1, r8
34000eb2:	d8c6      	bhi.n	34000e42 <evision_api_awb_init_profiles+0x14e>
34000eb4:	2300      	movs	r3, #0
34000eb6:	f04f 0c44 	mov.w	ip, #68	@ 0x44
34000eba:	1eb0      	subs	r0, r6, #2
34000ebc:	b29f      	uxth	r7, r3
34000ebe:	42b9      	cmp	r1, r7
34000ec0:	d839      	bhi.n	34000f36 <evision_api_awb_init_profiles+0x242>
34000ec2:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
34000ec6:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
34000eca:	2000      	movs	r0, #0
34000ecc:	f8a4 60f8 	strh.w	r6, [r4, #248]	@ 0xf8
34000ed0:	b283      	uxth	r3, r0
34000ed2:	4299      	cmp	r1, r3
34000ed4:	f100 0001 	add.w	r0, r0, #1
34000ed8:	f200 808b 	bhi.w	34000ff2 <evision_api_awb_init_profiles+0x2fe>
34000edc:	2700      	movs	r7, #0
34000ede:	46b8      	mov	r8, r7
34000ee0:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34000ee4:	f504 7990 	add.w	r9, r4, #288	@ 0x120
34000ee8:	eb05 0b07 	add.w	fp, r5, r7
34000eec:	eb09 0007 	add.w	r0, r9, r7
34000ef0:	2244      	movs	r2, #68	@ 0x44
34000ef2:	4659      	mov	r1, fp
34000ef4:	f018 f8d9 	bl	340190aa <memcpy>
34000ef8:	f8db 3000 	ldr.w	r3, [fp]
34000efc:	f108 0801 	add.w	r8, r8, #1
34000f00:	f84a 3b04 	str.w	r3, [sl], #4
34000f04:	fa1f f388 	uxth.w	r3, r8
34000f08:	429e      	cmp	r6, r3
34000f0a:	f107 0744 	add.w	r7, r7, #68	@ 0x44
34000f0e:	d8eb      	bhi.n	34000ee8 <evision_api_awb_init_profiles+0x1f4>
34000f10:	1e73      	subs	r3, r6, #1
34000f12:	b29b      	uxth	r3, r3
34000f14:	2e00      	cmp	r6, #0
34000f16:	f103 0301 	add.w	r3, r3, #1
34000f1a:	bf14      	ite	ne
34000f1c:	461a      	movne	r2, r3
34000f1e:	2201      	moveq	r2, #1
34000f20:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
34000f24:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
34000f28:	3a01      	subs	r2, #1
34000f2a:	d16a      	bne.n	34001002 <evision_api_awb_init_profiles+0x30e>
34000f2c:	2301      	movs	r3, #1
34000f2e:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34000f32:	7023      	strb	r3, [r4, #0]
34000f34:	e746      	b.n	34000dc4 <evision_api_awb_init_profiles+0xd0>
34000f36:	eb02 0987 	add.w	r9, r2, r7, lsl #2
34000f3a:	42b8      	cmp	r0, r7
34000f3c:	edd9 7a00 	vldr	s15, [r9]
34000f40:	ea4f 0887 	mov.w	r8, r7, lsl #2
34000f44:	f107 0a01 	add.w	sl, r7, #1
34000f48:	d91e      	bls.n	34000f88 <evision_api_awb_init_profiles+0x294>
34000f4a:	f108 0804 	add.w	r8, r8, #4
34000f4e:	4490      	add	r8, r2
34000f50:	ed98 7a00 	vldr	s14, [r8]
34000f54:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000f5c:	d814      	bhi.n	34000f88 <evision_api_awb_init_profiles+0x294>
34000f5e:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000f62:	4847      	ldr	r0, [pc, #284]	@ (34001080 <evision_api_awb_init_profiles+0x38c>)
34000f64:	4798      	blx	r3
34000f66:	ed98 7a00 	vldr	s14, [r8]
34000f6a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f6e:	ed8d 7b04 	vstr	d7, [sp, #16]
34000f72:	f8cd a008 	str.w	sl, [sp, #8]
34000f76:	ed99 7a00 	vldr	s14, [r9]
34000f7a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f7e:	463b      	mov	r3, r7
34000f80:	ed8d 7b00 	vstr	d7, [sp]
34000f84:	4a3f      	ldr	r2, [pc, #252]	@ (34001084 <evision_api_awb_init_profiles+0x390>)
34000f86:	e783      	b.n	34000e90 <evision_api_awb_init_profiles+0x19c>
34000f88:	fb0c f807 	mul.w	r8, ip, r7
34000f8c:	eb05 0a08 	add.w	sl, r5, r8
34000f90:	ed9a 7a00 	vldr	s14, [sl]
34000f94:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000f9c:	f108 0844 	add.w	r8, r8, #68	@ 0x44
34000fa0:	44a8      	add	r8, r5
34000fa2:	da08      	bge.n	34000fb6 <evision_api_awb_init_profiles+0x2c2>
34000fa4:	ed98 7a00 	vldr	s14, [r8]
34000fa8:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000fac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000fb0:	f103 0301 	add.w	r3, r3, #1
34000fb4:	d882      	bhi.n	34000ebc <evision_api_awb_init_profiles+0x1c8>
34000fb6:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000fba:	4833      	ldr	r0, [pc, #204]	@ (34001088 <evision_api_awb_init_profiles+0x394>)
34000fbc:	4798      	blx	r3
34000fbe:	ed98 7a00 	vldr	s14, [r8]
34000fc2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fc6:	ed8d 7b04 	vstr	d7, [sp, #16]
34000fca:	ed9a 7a00 	vldr	s14, [sl]
34000fce:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fd2:	ed8d 7b02 	vstr	d7, [sp, #8]
34000fd6:	ed99 7a00 	vldr	s14, [r9]
34000fda:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fde:	463b      	mov	r3, r7
34000fe0:	ed8d 7b00 	vstr	d7, [sp]
34000fe4:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000fe8:	4a28      	ldr	r2, [pc, #160]	@ (3400108c <evision_api_awb_init_profiles+0x398>)
34000fea:	a806      	add	r0, sp, #24
34000fec:	f017 fc62 	bl	340188b4 <sniprintf>
34000ff0:	e753      	b.n	34000e9a <evision_api_awb_init_profiles+0x1a6>
34000ff2:	eb02 0783 	add.w	r7, r2, r3, lsl #2
34000ff6:	683f      	ldr	r7, [r7, #0]
34000ff8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
34000ffc:	f8c3 7110 	str.w	r7, [r3, #272]	@ 0x110
34001000:	e766      	b.n	34000ed0 <evision_api_awb_init_profiles+0x1dc>
34001002:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
34001006:	ed91 6a00 	vldr	s12, [r1]
3400100a:	ed93 7a00 	vldr	s14, [r3]
3400100e:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34001012:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001016:	ee36 6b4a 	vsub.f64	d6, d6, d10
3400101a:	ee37 7b4a 	vsub.f64	d7, d7, d10
3400101e:	eeb4 6bc7 	vcmpe.f64	d6, d7
34001022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001026:	bf48      	it	mi
34001028:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
3400102c:	3144      	adds	r1, #68	@ 0x44
3400102e:	e77b      	b.n	34000f28 <evision_api_awb_init_profiles+0x234>
34001030:	f04f 30ff 	mov.w	r0, #4294967295
34001034:	b047      	add	sp, #284	@ 0x11c
34001036:	ecbd 8b06 	vpop	{d8-d10}
3400103a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400103e:	bf00      	nop
34001040:	00000000 	.word	0x00000000
34001044:	40b38800 	.word	0x40b38800
34001048:	9999999a 	.word	0x9999999a
3400104c:	3fb99999 	.word	0x3fb99999
34001050:	00000000 	.word	0x00000000
34001054:	406ea000 	.word	0x406ea000
34001058:	3ff00000 	.word	0x3ff00000
3400105c:	42480000 	.word	0x42480000
34001060:	432f0000 	.word	0x432f0000
34001064:	3401d8f4 	.word	0x3401d8f4
34001068:	3401d938 	.word	0x3401d938
3400106c:	3401d9bf 	.word	0x3401d9bf
34001070:	3401da1d 	.word	0x3401da1d
34001074:	3401daa5 	.word	0x3401daa5
34001078:	3401db02 	.word	0x3401db02
3400107c:	3401db66 	.word	0x3401db66
34001080:	3401dbbe 	.word	0x3401dbbe
34001084:	3401dc2d 	.word	0x3401dc2d
34001088:	3401dc97 	.word	0x3401dc97
3400108c:	3401dcee 	.word	0x3401dcee
34001090:	bff00000 	.word	0xbff00000
34001094:	40080000 	.word	0x40080000
34001098:	40240000 	.word	0x40240000

3400109c <evision_api_awb_run_average>:
3400109c:	b530      	push	{r4, r5, lr}
3400109e:	4605      	mov	r5, r0
340010a0:	4614      	mov	r4, r2
340010a2:	b08d      	sub	sp, #52	@ 0x34
340010a4:	b952      	cbnz	r2, 340010bc <evision_api_awb_run_average+0x20>
340010a6:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
340010aa:	481d      	ldr	r0, [pc, #116]	@ (34001120 <evision_api_awb_run_average+0x84>)
340010ac:	4798      	blx	r3
340010ae:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
340010b2:	481c      	ldr	r0, [pc, #112]	@ (34001124 <evision_api_awb_run_average+0x88>)
340010b4:	4798      	blx	r3
340010b6:	4620      	mov	r0, r4
340010b8:	b00d      	add	sp, #52	@ 0x34
340010ba:	bd30      	pop	{r4, r5, pc}
340010bc:	ed93 2b04 	vldr	d2, [r3, #16]
340010c0:	ed93 1b02 	vldr	d1, [r3, #8]
340010c4:	ed93 0b00 	vldr	d0, [r3]
340010c8:	aa0a      	add	r2, sp, #40	@ 0x28
340010ca:	a908      	add	r1, sp, #32
340010cc:	a806      	add	r0, sp, #24
340010ce:	f000 f82f 	bl	34001130 <LOXtOTiCQC>
340010d2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
340010d6:	e9cd 2302 	strd	r2, r3, [sp, #8]
340010da:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
340010de:	e9cd 2304 	strd	r2, r3, [sp, #16]
340010e2:	2301      	movs	r3, #1
340010e4:	4298      	cmp	r0, r3
340010e6:	4604      	mov	r4, r0
340010e8:	e9cd 3300 	strd	r3, r3, [sp]
340010ec:	d1df      	bne.n	340010ae <evision_api_awb_run_average+0x12>
340010ee:	4669      	mov	r1, sp
340010f0:	4628      	mov	r0, r5
340010f2:	f7ff fb4d 	bl	34000790 <vsvAKZpqpB>
340010f6:	2801      	cmp	r0, #1
340010f8:	4604      	mov	r4, r0
340010fa:	d003      	beq.n	34001104 <evision_api_awb_run_average+0x68>
340010fc:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
34001100:	4809      	ldr	r0, [pc, #36]	@ (34001128 <evision_api_awb_run_average+0x8c>)
34001102:	e7d7      	b.n	340010b4 <evision_api_awb_run_average+0x18>
34001104:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
34001108:	2b01      	cmp	r3, #1
3400110a:	d1d4      	bne.n	340010b6 <evision_api_awb_run_average+0x1a>
3400110c:	4628      	mov	r0, r5
3400110e:	f7ff fd23 	bl	34000b58 <JxZhqVLLqu>
34001112:	2801      	cmp	r0, #1
34001114:	4604      	mov	r4, r0
34001116:	d0ce      	beq.n	340010b6 <evision_api_awb_run_average+0x1a>
34001118:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3400111c:	4803      	ldr	r0, [pc, #12]	@ (3400112c <evision_api_awb_run_average+0x90>)
3400111e:	e7c9      	b.n	340010b4 <evision_api_awb_run_average+0x18>
34001120:	3401dd74 	.word	0x3401dd74
34001124:	3401ddd5 	.word	0x3401ddd5
34001128:	3401ddfe 	.word	0x3401ddfe
3400112c:	3401de32 	.word	0x3401de32

34001130 <LOXtOTiCQC>:
34001130:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34001134:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001138:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3400113a:	d409      	bmi.n	34001150 <LOXtOTiCQC+0x20>
3400113c:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
34001140:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001144:	d404      	bmi.n	34001150 <LOXtOTiCQC+0x20>
34001146:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
3400114a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400114e:	d50d      	bpl.n	3400116c <LOXtOTiCQC+0x3c>
34001150:	ed8d 2b02 	vstr	d2, [sp, #8]
34001154:	ed8d 1b00 	vstr	d1, [sp]
34001158:	ec53 2b10 	vmov	r2, r3, d0
3400115c:	4844      	ldr	r0, [pc, #272]	@ (34001270 <LOXtOTiCQC+0x140>)
3400115e:	f017 fb39 	bl	340187d4 <iprintf>
34001162:	f04f 30ff 	mov.w	r0, #4294967295
34001166:	b005      	add	sp, #20
34001168:	f85d fb04 	ldr.w	pc, [sp], #4
3400116c:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 34001238 <LOXtOTiCQC+0x108>
34001170:	eeb4 0bc7 	vcmpe.f64	d0, d7
34001174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001178:	dc09      	bgt.n	3400118e <LOXtOTiCQC+0x5e>
3400117a:	eeb4 1bc7 	vcmpe.f64	d1, d7
3400117e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001182:	dc04      	bgt.n	3400118e <LOXtOTiCQC+0x5e>
34001184:	eeb4 2bc7 	vcmpe.f64	d2, d7
34001188:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400118c:	dd07      	ble.n	3400119e <LOXtOTiCQC+0x6e>
3400118e:	ed8d 2b02 	vstr	d2, [sp, #8]
34001192:	ed8d 1b00 	vstr	d1, [sp]
34001196:	ec53 2b10 	vmov	r2, r3, d0
3400119a:	4836      	ldr	r0, [pc, #216]	@ (34001274 <LOXtOTiCQC+0x144>)
3400119c:	e7df      	b.n	3400115e <LOXtOTiCQC+0x2e>
3400119e:	b128      	cbz	r0, 340011ac <LOXtOTiCQC+0x7c>
340011a0:	b189      	cbz	r1, 340011c6 <LOXtOTiCQC+0x96>
340011a2:	b9b2      	cbnz	r2, 340011d2 <LOXtOTiCQC+0xa2>
340011a4:	4934      	ldr	r1, [pc, #208]	@ (34001278 <LOXtOTiCQC+0x148>)
340011a6:	4b35      	ldr	r3, [pc, #212]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011a8:	4608      	mov	r0, r1
340011aa:	e007      	b.n	340011bc <LOXtOTiCQC+0x8c>
340011ac:	b171      	cbz	r1, 340011cc <LOXtOTiCQC+0x9c>
340011ae:	4933      	ldr	r1, [pc, #204]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011b0:	4831      	ldr	r0, [pc, #196]	@ (34001278 <LOXtOTiCQC+0x148>)
340011b2:	2a00      	cmp	r2, #0
340011b4:	4a30      	ldr	r2, [pc, #192]	@ (34001278 <LOXtOTiCQC+0x148>)
340011b6:	4b31      	ldr	r3, [pc, #196]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011b8:	bf18      	it	ne
340011ba:	4613      	movne	r3, r2
340011bc:	4602      	mov	r2, r0
340011be:	4830      	ldr	r0, [pc, #192]	@ (34001280 <LOXtOTiCQC+0x150>)
340011c0:	f017 fb08 	bl	340187d4 <iprintf>
340011c4:	e7cd      	b.n	34001162 <LOXtOTiCQC+0x32>
340011c6:	492c      	ldr	r1, [pc, #176]	@ (34001278 <LOXtOTiCQC+0x148>)
340011c8:	482c      	ldr	r0, [pc, #176]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011ca:	e7f2      	b.n	340011b2 <LOXtOTiCQC+0x82>
340011cc:	492b      	ldr	r1, [pc, #172]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011ce:	4608      	mov	r0, r1
340011d0:	e7ef      	b.n	340011b2 <LOXtOTiCQC+0x82>
340011d2:	ed9f 7b1b 	vldr	d7, [pc, #108]	@ 34001240 <LOXtOTiCQC+0x110>
340011d6:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 34001248 <LOXtOTiCQC+0x118>
340011da:	ee21 7b07 	vmul.f64	d7, d1, d7
340011de:	eeb3 5b00 	vmov.f64	d5, #48	@ 0x41800000  16.0
340011e2:	eea0 7b06 	vfma.f64	d7, d0, d6
340011e6:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 34001250 <LOXtOTiCQC+0x120>
340011ea:	eea2 7b05 	vfma.f64	d7, d2, d5
340011ee:	eea7 5b06 	vfma.f64	d5, d7, d6
340011f2:	ed9f 7b19 	vldr	d7, [pc, #100]	@ 34001258 <LOXtOTiCQC+0x128>
340011f6:	ed80 5b00 	vstr	d5, [r0]
340011fa:	ee27 7b41 	vnmul.f64	d7, d7, d1
340011fe:	eebb 5b0a 	vmov.f64	d5, #186	@ 0xc1d00000 -26.0
34001202:	eea0 7b05 	vfma.f64	d7, d0, d5
34001206:	ed9f 5b16 	vldr	d5, [pc, #88]	@ 34001260 <LOXtOTiCQC+0x130>
3400120a:	eea2 7b05 	vfma.f64	d7, d2, d5
3400120e:	ee27 7b06 	vmul.f64	d7, d7, d6
34001212:	ed81 7b00 	vstr	d7, [r1]
34001216:	ed9f 7b14 	vldr	d7, [pc, #80]	@ 34001268 <LOXtOTiCQC+0x138>
3400121a:	ee27 1b41 	vnmul.f64	d1, d7, d1
3400121e:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34001222:	eea0 1b05 	vfma.f64	d1, d0, d5
34001226:	eea2 1b47 	vfms.f64	d1, d2, d7
3400122a:	ee21 1b06 	vmul.f64	d1, d1, d6
3400122e:	2001      	movs	r0, #1
34001230:	ed82 1b00 	vstr	d1, [r2]
34001234:	e797      	b.n	34001166 <LOXtOTiCQC+0x36>
34001236:	bf00      	nop
34001238:	00000000 	.word	0x00000000
3400123c:	406fe000 	.word	0x406fe000
34001240:	00000000 	.word	0x00000000
34001244:	4063a000 	.word	0x4063a000
34001248:	00000000 	.word	0x00000000
3400124c:	40478000 	.word	0x40478000
34001250:	00000000 	.word	0x00000000
34001254:	3f700000 	.word	0x3f700000
34001258:	00000000 	.word	0x00000000
3400125c:	40558000 	.word	0x40558000
34001260:	00000000 	.word	0x00000000
34001264:	405c0000 	.word	0x405c0000
34001268:	00000000 	.word	0x00000000
3400126c:	40598000 	.word	0x40598000
34001270:	3401de6f 	.word	0x3401de6f
34001274:	3401dead 	.word	0x3401dead
34001278:	3401de69 	.word	0x3401de69
3400127c:	3401de67 	.word	0x3401de67
34001280:	3401deed 	.word	0x3401deed
34001284:	00000000 	.word	0x00000000

34001288 <evision_api_st_ae_new>:
34001288:	b510      	push	{r4, lr}
3400128a:	4604      	mov	r4, r0
3400128c:	b090      	sub	sp, #64	@ 0x40
3400128e:	b160      	cbz	r0, 340012aa <evision_api_st_ae_new+0x22>
34001290:	2300      	movs	r3, #0
34001292:	4c07      	ldr	r4, [pc, #28]	@ (340012b0 <evision_api_st_ae_new+0x28>)
34001294:	2140      	movs	r1, #64	@ 0x40
34001296:	7023      	strb	r3, [r4, #0]
34001298:	65a0      	str	r0, [r4, #88]	@ 0x58
3400129a:	4b06      	ldr	r3, [pc, #24]	@ (340012b4 <evision_api_st_ae_new+0x2c>)
3400129c:	4668      	mov	r0, sp
3400129e:	4a06      	ldr	r2, [pc, #24]	@ (340012b8 <evision_api_st_ae_new+0x30>)
340012a0:	f017 fb08 	bl	340188b4 <sniprintf>
340012a4:	4668      	mov	r0, sp
340012a6:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340012a8:	4798      	blx	r3
340012aa:	4620      	mov	r0, r4
340012ac:	b010      	add	sp, #64	@ 0x40
340012ae:	bd10      	pop	{r4, pc}
340012b0:	3403f288 	.word	0x3403f288
340012b4:	3403ec36 	.word	0x3403ec36
340012b8:	3401df37 	.word	0x3401df37

340012bc <evision_api_st_ae_delete>:
340012bc:	2800      	cmp	r0, #0
340012be:	bf14      	ite	ne
340012c0:	2001      	movne	r0, #1
340012c2:	f04f 30ff 	moveq.w	r0, #4294967295
340012c6:	4770      	bx	lr

340012c8 <AagifFaCgc>:
340012c8:	2238      	movs	r2, #56	@ 0x38
340012ca:	230a      	movs	r3, #10
340012cc:	e9c0 2304 	strd	r2, r3, [r0, #16]
340012d0:	2364      	movs	r3, #100	@ 0x64
340012d2:	222d      	movs	r2, #45	@ 0x2d
340012d4:	2178      	movs	r1, #120	@ 0x78
340012d6:	e9c0 3206 	strd	r3, r2, [r0, #24]
340012da:	f240 52dc 	movw	r2, #1500	@ 0x5dc
340012de:	b530      	push	{r4, r5, lr}
340012e0:	e9c0 1208 	strd	r1, r2, [r0, #32]
340012e4:	f241 7470 	movw	r4, #6000	@ 0x1770
340012e8:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
340012ec:	e9c0 420a 	strd	r4, r2, [r0, #40]	@ 0x28
340012f0:	a50b      	add	r5, pc, #44	@ (adr r5, 34001320 <AagifFaCgc+0x58>)
340012f2:	e9d5 4500 	ldrd	r4, r5, [r5]
340012f6:	2205      	movs	r2, #5
340012f8:	f04f 0c00 	mov.w	ip, #0
340012fc:	6502      	str	r2, [r0, #80]	@ 0x50
340012fe:	f248 02e8 	movw	r2, #33000	@ 0x80e8
34001302:	e9c0 c210 	strd	ip, r2, [r0, #64]	@ 0x40
34001306:	2201      	movs	r2, #1
34001308:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
3400130c:	a506      	add	r5, pc, #24	@ (adr r5, 34001328 <AagifFaCgc+0x60>)
3400130e:	e9d5 4500 	ldrd	r4, r5, [r5]
34001312:	e9c0 2312 	strd	r2, r3, [r0, #72]	@ 0x48
34001316:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
3400131a:	bd30      	pop	{r4, r5, pc}
3400131c:	f3af 8000 	nop.w
34001320:	40000000 	.word	0x40000000
34001324:	3f947ae1 	.word	0x3f947ae1
34001328:	e0000000 	.word	0xe0000000
3400132c:	3f70624d 	.word	0x3f70624d

34001330 <evision_api_st_ae_init>:
34001330:	b510      	push	{r4, lr}
34001332:	4604      	mov	r4, r0
34001334:	b120      	cbz	r0, 34001340 <evision_api_st_ae_init+0x10>
34001336:	f7ff ffc7 	bl	340012c8 <AagifFaCgc>
3400133a:	2001      	movs	r0, #1
3400133c:	7020      	strb	r0, [r4, #0]
3400133e:	bd10      	pop	{r4, pc}
34001340:	f04f 30ff 	mov.w	r0, #4294967295
34001344:	e7fb      	b.n	3400133e <evision_api_st_ae_init+0xe>

34001346 <evision_api_st_ae_process>:
34001346:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400134a:	460e      	mov	r6, r1
3400134c:	4604      	mov	r4, r0
3400134e:	2800      	cmp	r0, #0
34001350:	f000 80e1 	beq.w	34001516 <evision_api_st_ae_process+0x1d0>
34001354:	7801      	ldrb	r1, [r0, #0]
34001356:	2901      	cmp	r1, #1
34001358:	d10b      	bne.n	34001372 <evision_api_st_ae_process+0x2c>
3400135a:	2102      	movs	r1, #2
3400135c:	7001      	strb	r1, [r0, #0]
3400135e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34001360:	e9c4 2601 	strd	r2, r6, [r4, #4]
34001364:	42b5      	cmp	r5, r6
34001366:	d208      	bcs.n	3400137a <evision_api_st_ae_process+0x34>
34001368:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400136a:	4291      	cmp	r1, r2
3400136c:	d905      	bls.n	3400137a <evision_api_st_ae_process+0x34>
3400136e:	60a5      	str	r5, [r4, #8]
34001370:	e04c      	b.n	3400140c <evision_api_st_ae_process+0xc6>
34001372:	2902      	cmp	r1, #2
34001374:	d0f3      	beq.n	3400135e <evision_api_st_ae_process+0x18>
34001376:	2000      	movs	r0, #0
34001378:	e049      	b.n	3400140e <evision_api_st_ae_process+0xc8>
3400137a:	f8d4 c010 	ldr.w	ip, [r4, #16]
3400137e:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34001382:	ee07 ca90 	vmov	s15, ip
34001386:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3400138a:	ee07 3a90 	vmov	s15, r3
3400138e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34001392:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34001396:	ee37 7b05 	vadd.f64	d7, d7, d5
3400139a:	ee86 0b07 	vdiv.f64	d0, d6, d7
3400139e:	6d21      	ldr	r1, [r4, #80]	@ 0x50
340013a0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
340013a4:	428b      	cmp	r3, r1
340013a6:	d24b      	bcs.n	34001440 <evision_api_st_ae_process+0xfa>
340013a8:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
340013ac:	eeb4 0ae7 	vcmpe.f32	s0, s15
340013b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013b4:	d444      	bmi.n	34001440 <evision_api_st_ae_process+0xfa>
340013b6:	6c61      	ldr	r1, [r4, #68]	@ 0x44
340013b8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
340013bc:	428a      	cmp	r2, r1
340013be:	d220      	bcs.n	34001402 <evision_api_st_ae_process+0xbc>
340013c0:	2a01      	cmp	r2, #1
340013c2:	4613      	mov	r3, r2
340013c4:	bf38      	it	cc
340013c6:	2301      	movcc	r3, #1
340013c8:	ee07 3a90 	vmov	s15, r3
340013cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340013d0:	ee67 7a80 	vmul.f32	s15, s15, s0
340013d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340013d8:	ee17 3a90 	vmov	r3, s15
340013dc:	428b      	cmp	r3, r1
340013de:	bfc1      	itttt	gt
340013e0:	ee07 1a90 	vmovgt	s15, r1
340013e4:	eeb8 6ae7 	vcvtgt.f32.s32	s12, s15
340013e8:	ee07 2a90 	vmovgt	s15, r2
340013ec:	eef8 6a67 	vcvtgt.f32.u32	s13, s15
340013f0:	bfc3      	ittte	gt
340013f2:	eec6 7a26 	vdivgt.f32	s15, s12, s13
340013f6:	460b      	movgt	r3, r1
340013f8:	ee80 0a27 	vdivgt.f32	s0, s0, s15
340013fc:	eeb0 0a47 	vmovle.f32	s0, s14
34001400:	6063      	str	r3, [r4, #4]
34001402:	eeb4 0ac7 	vcmpe.f32	s0, s14
34001406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400140a:	dc02      	bgt.n	34001412 <evision_api_st_ae_process+0xcc>
3400140c:	2001      	movs	r0, #1
3400140e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34001412:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34001416:	f019 fc5f 	bl	3401acd8 <log10>
3400141a:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
3400141e:	ee20 0b07 	vmul.f64	d0, d0, d7
34001422:	ed9f 7b3f 	vldr	d7, [pc, #252]	@ 34001520 <evision_api_st_ae_process+0x1da>
34001426:	ee20 0b07 	vmul.f64	d0, d0, d7
3400142a:	eebd 0bc0 	vcvt.s32.f64	s0, d0
3400142e:	ee10 3a10 	vmov	r3, s0
34001432:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
34001434:	4433      	add	r3, r6
34001436:	4293      	cmp	r3, r2
34001438:	bfd4      	ite	le
3400143a:	60a3      	strle	r3, [r4, #8]
3400143c:	60a2      	strgt	r2, [r4, #8]
3400143e:	e7e5      	b.n	3400140c <evision_api_st_ae_process+0xc6>
34001440:	ebac 0703 	sub.w	r7, ip, r3
34001444:	69e1      	ldr	r1, [r4, #28]
34001446:	ea87 70e7 	eor.w	r0, r7, r7, asr #31
3400144a:	eba0 70e7 	sub.w	r0, r0, r7, asr #31
3400144e:	4288      	cmp	r0, r1
34001450:	d847      	bhi.n	340014e2 <evision_api_st_ae_process+0x19c>
34001452:	6a60      	ldr	r0, [r4, #36]	@ 0x24
34001454:	f8d4 e014 	ldr.w	lr, [r4, #20]
34001458:	69a1      	ldr	r1, [r4, #24]
3400145a:	eb0e 080c 	add.w	r8, lr, ip
3400145e:	4598      	cmp	r8, r3
34001460:	fb07 f101 	mul.w	r1, r7, r1
34001464:	d243      	bcs.n	340014ee <evision_api_st_ae_process+0x1a8>
34001466:	ee07 0a90 	vmov	s15, r0
3400146a:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 34001528 <evision_api_st_ae_process+0x1e2>
3400146e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34001472:	ee67 7a87 	vmul.f32	s15, s15, s14
34001476:	ee07 1a10 	vmov	s14, r1
3400147a:	eef1 6a67 	vneg.f32	s13, s15
3400147e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34001482:	eeb4 7ae6 	vcmpe.f32	s14, s13
34001486:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400148a:	d504      	bpl.n	34001496 <evision_api_st_ae_process+0x150>
3400148c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001490:	ee17 3a90 	vmov	r3, s15
34001494:	4259      	negs	r1, r3
34001496:	2900      	cmp	r1, #0
34001498:	d0b8      	beq.n	3400140c <evision_api_st_ae_process+0xc6>
3400149a:	42b5      	cmp	r5, r6
3400149c:	d132      	bne.n	34001504 <evision_api_st_ae_process+0x1be>
3400149e:	6c60      	ldr	r0, [r4, #68]	@ 0x44
340014a0:	4290      	cmp	r0, r2
340014a2:	d801      	bhi.n	340014a8 <evision_api_st_ae_process+0x162>
340014a4:	2900      	cmp	r1, #0
340014a6:	da2d      	bge.n	34001504 <evision_api_st_ae_process+0x1be>
340014a8:	fb02 7707 	mla	r7, r2, r7, r7
340014ac:	ee07 2a90 	vmov	s15, r2
340014b0:	ee06 7a90 	vmov	s13, r7
340014b4:	2900      	cmp	r1, #0
340014b6:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340014ba:	eeb8 6be6 	vcvt.f64.s32	d6, s13
340014be:	da1e      	bge.n	340014fe <evision_api_st_ae_process+0x1b8>
340014c0:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
340014c4:	eea5 7b06 	vfma.f64	d7, d5, d6
340014c8:	eebd 7bc7 	vcvt.s32.f64	s14, d7
340014cc:	ee17 2a10 	vmov	r2, s14
340014d0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
340014d2:	429a      	cmp	r2, r3
340014d4:	bfb8      	it	lt
340014d6:	461a      	movlt	r2, r3
340014d8:	4282      	cmp	r2, r0
340014da:	bfd4      	ite	le
340014dc:	6062      	strle	r2, [r4, #4]
340014de:	6060      	strgt	r0, [r4, #4]
340014e0:	e794      	b.n	3400140c <evision_api_st_ae_process+0xc6>
340014e2:	6a21      	ldr	r1, [r4, #32]
340014e4:	4288      	cmp	r0, r1
340014e6:	bf2c      	ite	cs
340014e8:	6ae0      	ldrcs	r0, [r4, #44]	@ 0x2c
340014ea:	6aa0      	ldrcc	r0, [r4, #40]	@ 0x28
340014ec:	e7b2      	b.n	34001454 <evision_api_st_ae_process+0x10e>
340014ee:	ebac 0c0e 	sub.w	ip, ip, lr
340014f2:	459c      	cmp	ip, r3
340014f4:	dd8a      	ble.n	3400140c <evision_api_st_ae_process+0xc6>
340014f6:	4281      	cmp	r1, r0
340014f8:	bfa8      	it	ge
340014fa:	4601      	movge	r1, r0
340014fc:	e7cb      	b.n	34001496 <evision_api_st_ae_process+0x150>
340014fe:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
34001502:	e7df      	b.n	340014c4 <evision_api_st_ae_process+0x17e>
34001504:	440e      	add	r6, r1
34001506:	42b5      	cmp	r5, r6
34001508:	f73f af31 	bgt.w	3400136e <evision_api_st_ae_process+0x28>
3400150c:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
3400150e:	42b5      	cmp	r5, r6
34001510:	bfa8      	it	ge
34001512:	4635      	movge	r5, r6
34001514:	e72b      	b.n	3400136e <evision_api_st_ae_process+0x28>
34001516:	f04f 30ff 	mov.w	r0, #4294967295
3400151a:	e778      	b.n	3400140e <evision_api_st_ae_process+0xc8>
3400151c:	f3af 8000 	nop.w
34001520:	00000000 	.word	0x00000000
34001524:	408f4000 	.word	0x408f4000
34001528:	3f59999a 	.word	0x3f59999a

3400152c <strlen>:
3400152c:	4603      	mov	r3, r0
3400152e:	f813 2b01 	ldrb.w	r2, [r3], #1
34001532:	2a00      	cmp	r2, #0
34001534:	d1fb      	bne.n	3400152e <strlen+0x2>
34001536:	1a18      	subs	r0, r3, r0
34001538:	3801      	subs	r0, #1
3400153a:	4770      	bx	lr

3400153c <__aeabi_ldivmod>:
3400153c:	b97b      	cbnz	r3, 3400155e <__aeabi_ldivmod+0x22>
3400153e:	b972      	cbnz	r2, 3400155e <__aeabi_ldivmod+0x22>
34001540:	2900      	cmp	r1, #0
34001542:	bfbe      	ittt	lt
34001544:	2000      	movlt	r0, #0
34001546:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
3400154a:	e006      	blt.n	3400155a <__aeabi_ldivmod+0x1e>
3400154c:	bf08      	it	eq
3400154e:	2800      	cmpeq	r0, #0
34001550:	bf1c      	itt	ne
34001552:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34001556:	f04f 30ff 	movne.w	r0, #4294967295
3400155a:	f000 b9fb 	b.w	34001954 <__aeabi_idiv0>
3400155e:	f1ad 0c08 	sub.w	ip, sp, #8
34001562:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34001566:	2900      	cmp	r1, #0
34001568:	db09      	blt.n	3400157e <__aeabi_ldivmod+0x42>
3400156a:	2b00      	cmp	r3, #0
3400156c:	db1a      	blt.n	340015a4 <__aeabi_ldivmod+0x68>
3400156e:	f000 f84d 	bl	3400160c <__udivmoddi4>
34001572:	f8dd e004 	ldr.w	lr, [sp, #4]
34001576:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
3400157a:	b004      	add	sp, #16
3400157c:	4770      	bx	lr
3400157e:	4240      	negs	r0, r0
34001580:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001584:	2b00      	cmp	r3, #0
34001586:	db1b      	blt.n	340015c0 <__aeabi_ldivmod+0x84>
34001588:	f000 f840 	bl	3400160c <__udivmoddi4>
3400158c:	f8dd e004 	ldr.w	lr, [sp, #4]
34001590:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001594:	b004      	add	sp, #16
34001596:	4240      	negs	r0, r0
34001598:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
3400159c:	4252      	negs	r2, r2
3400159e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015a2:	4770      	bx	lr
340015a4:	4252      	negs	r2, r2
340015a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015aa:	f000 f82f 	bl	3400160c <__udivmoddi4>
340015ae:	f8dd e004 	ldr.w	lr, [sp, #4]
340015b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340015b6:	b004      	add	sp, #16
340015b8:	4240      	negs	r0, r0
340015ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
340015be:	4770      	bx	lr
340015c0:	4252      	negs	r2, r2
340015c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015c6:	f000 f821 	bl	3400160c <__udivmoddi4>
340015ca:	f8dd e004 	ldr.w	lr, [sp, #4]
340015ce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340015d2:	b004      	add	sp, #16
340015d4:	4252      	negs	r2, r2
340015d6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015da:	4770      	bx	lr

340015dc <__aeabi_uldivmod>:
340015dc:	b953      	cbnz	r3, 340015f4 <__aeabi_uldivmod+0x18>
340015de:	b94a      	cbnz	r2, 340015f4 <__aeabi_uldivmod+0x18>
340015e0:	2900      	cmp	r1, #0
340015e2:	bf08      	it	eq
340015e4:	2800      	cmpeq	r0, #0
340015e6:	bf1c      	itt	ne
340015e8:	f04f 31ff 	movne.w	r1, #4294967295
340015ec:	f04f 30ff 	movne.w	r0, #4294967295
340015f0:	f000 b9b0 	b.w	34001954 <__aeabi_idiv0>
340015f4:	f1ad 0c08 	sub.w	ip, sp, #8
340015f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
340015fc:	f000 f806 	bl	3400160c <__udivmoddi4>
34001600:	f8dd e004 	ldr.w	lr, [sp, #4]
34001604:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001608:	b004      	add	sp, #16
3400160a:	4770      	bx	lr

3400160c <__udivmoddi4>:
3400160c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001610:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34001612:	4688      	mov	r8, r1
34001614:	4604      	mov	r4, r0
34001616:	468e      	mov	lr, r1
34001618:	2b00      	cmp	r3, #0
3400161a:	d14a      	bne.n	340016b2 <__udivmoddi4+0xa6>
3400161c:	428a      	cmp	r2, r1
3400161e:	4617      	mov	r7, r2
34001620:	d95f      	bls.n	340016e2 <__udivmoddi4+0xd6>
34001622:	fab2 f682 	clz	r6, r2
34001626:	b14e      	cbz	r6, 3400163c <__udivmoddi4+0x30>
34001628:	f1c6 0320 	rsb	r3, r6, #32
3400162c:	fa01 fe06 	lsl.w	lr, r1, r6
34001630:	40b7      	lsls	r7, r6
34001632:	40b4      	lsls	r4, r6
34001634:	fa20 f303 	lsr.w	r3, r0, r3
34001638:	ea43 0e0e 	orr.w	lr, r3, lr
3400163c:	ea4f 4817 	mov.w	r8, r7, lsr #16
34001640:	fa1f fc87 	uxth.w	ip, r7
34001644:	0c23      	lsrs	r3, r4, #16
34001646:	fbbe f1f8 	udiv	r1, lr, r8
3400164a:	fb08 ee11 	mls	lr, r8, r1, lr
3400164e:	fb01 f20c 	mul.w	r2, r1, ip
34001652:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34001656:	429a      	cmp	r2, r3
34001658:	d907      	bls.n	3400166a <__udivmoddi4+0x5e>
3400165a:	18fb      	adds	r3, r7, r3
3400165c:	f101 30ff 	add.w	r0, r1, #4294967295
34001660:	d202      	bcs.n	34001668 <__udivmoddi4+0x5c>
34001662:	429a      	cmp	r2, r3
34001664:	f200 8154 	bhi.w	34001910 <__udivmoddi4+0x304>
34001668:	4601      	mov	r1, r0
3400166a:	1a9b      	subs	r3, r3, r2
3400166c:	b2a2      	uxth	r2, r4
3400166e:	fbb3 f0f8 	udiv	r0, r3, r8
34001672:	fb08 3310 	mls	r3, r8, r0, r3
34001676:	fb00 fc0c 	mul.w	ip, r0, ip
3400167a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3400167e:	4594      	cmp	ip, r2
34001680:	d90b      	bls.n	3400169a <__udivmoddi4+0x8e>
34001682:	18ba      	adds	r2, r7, r2
34001684:	f100 33ff 	add.w	r3, r0, #4294967295
34001688:	bf2c      	ite	cs
3400168a:	2401      	movcs	r4, #1
3400168c:	2400      	movcc	r4, #0
3400168e:	4594      	cmp	ip, r2
34001690:	d902      	bls.n	34001698 <__udivmoddi4+0x8c>
34001692:	2c00      	cmp	r4, #0
34001694:	f000 813f 	beq.w	34001916 <__udivmoddi4+0x30a>
34001698:	4618      	mov	r0, r3
3400169a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
3400169e:	eba2 020c 	sub.w	r2, r2, ip
340016a2:	2100      	movs	r1, #0
340016a4:	b11d      	cbz	r5, 340016ae <__udivmoddi4+0xa2>
340016a6:	40f2      	lsrs	r2, r6
340016a8:	2300      	movs	r3, #0
340016aa:	e9c5 2300 	strd	r2, r3, [r5]
340016ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340016b2:	428b      	cmp	r3, r1
340016b4:	d905      	bls.n	340016c2 <__udivmoddi4+0xb6>
340016b6:	b10d      	cbz	r5, 340016bc <__udivmoddi4+0xb0>
340016b8:	e9c5 0100 	strd	r0, r1, [r5]
340016bc:	2100      	movs	r1, #0
340016be:	4608      	mov	r0, r1
340016c0:	e7f5      	b.n	340016ae <__udivmoddi4+0xa2>
340016c2:	fab3 f183 	clz	r1, r3
340016c6:	2900      	cmp	r1, #0
340016c8:	d14e      	bne.n	34001768 <__udivmoddi4+0x15c>
340016ca:	4543      	cmp	r3, r8
340016cc:	f0c0 8112 	bcc.w	340018f4 <__udivmoddi4+0x2e8>
340016d0:	4282      	cmp	r2, r0
340016d2:	f240 810f 	bls.w	340018f4 <__udivmoddi4+0x2e8>
340016d6:	4608      	mov	r0, r1
340016d8:	2d00      	cmp	r5, #0
340016da:	d0e8      	beq.n	340016ae <__udivmoddi4+0xa2>
340016dc:	e9c5 4e00 	strd	r4, lr, [r5]
340016e0:	e7e5      	b.n	340016ae <__udivmoddi4+0xa2>
340016e2:	2a00      	cmp	r2, #0
340016e4:	f000 80ac 	beq.w	34001840 <__udivmoddi4+0x234>
340016e8:	fab2 f682 	clz	r6, r2
340016ec:	2e00      	cmp	r6, #0
340016ee:	f040 80bb 	bne.w	34001868 <__udivmoddi4+0x25c>
340016f2:	1a8b      	subs	r3, r1, r2
340016f4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
340016f8:	b2bc      	uxth	r4, r7
340016fa:	2101      	movs	r1, #1
340016fc:	0c02      	lsrs	r2, r0, #16
340016fe:	b280      	uxth	r0, r0
34001700:	fbb3 fcfe 	udiv	ip, r3, lr
34001704:	fb0e 331c 	mls	r3, lr, ip, r3
34001708:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
3400170c:	fb04 f20c 	mul.w	r2, r4, ip
34001710:	429a      	cmp	r2, r3
34001712:	d90e      	bls.n	34001732 <__udivmoddi4+0x126>
34001714:	18fb      	adds	r3, r7, r3
34001716:	f10c 38ff 	add.w	r8, ip, #4294967295
3400171a:	bf2c      	ite	cs
3400171c:	f04f 0901 	movcs.w	r9, #1
34001720:	f04f 0900 	movcc.w	r9, #0
34001724:	429a      	cmp	r2, r3
34001726:	d903      	bls.n	34001730 <__udivmoddi4+0x124>
34001728:	f1b9 0f00 	cmp.w	r9, #0
3400172c:	f000 80ec 	beq.w	34001908 <__udivmoddi4+0x2fc>
34001730:	46c4      	mov	ip, r8
34001732:	1a9b      	subs	r3, r3, r2
34001734:	fbb3 f8fe 	udiv	r8, r3, lr
34001738:	fb0e 3318 	mls	r3, lr, r8, r3
3400173c:	fb04 f408 	mul.w	r4, r4, r8
34001740:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34001744:	4294      	cmp	r4, r2
34001746:	d90b      	bls.n	34001760 <__udivmoddi4+0x154>
34001748:	18ba      	adds	r2, r7, r2
3400174a:	f108 33ff 	add.w	r3, r8, #4294967295
3400174e:	bf2c      	ite	cs
34001750:	2001      	movcs	r0, #1
34001752:	2000      	movcc	r0, #0
34001754:	4294      	cmp	r4, r2
34001756:	d902      	bls.n	3400175e <__udivmoddi4+0x152>
34001758:	2800      	cmp	r0, #0
3400175a:	f000 80d1 	beq.w	34001900 <__udivmoddi4+0x2f4>
3400175e:	4698      	mov	r8, r3
34001760:	1b12      	subs	r2, r2, r4
34001762:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34001766:	e79d      	b.n	340016a4 <__udivmoddi4+0x98>
34001768:	f1c1 0620 	rsb	r6, r1, #32
3400176c:	408b      	lsls	r3, r1
3400176e:	fa08 f401 	lsl.w	r4, r8, r1
34001772:	fa00 f901 	lsl.w	r9, r0, r1
34001776:	fa22 f706 	lsr.w	r7, r2, r6
3400177a:	fa28 f806 	lsr.w	r8, r8, r6
3400177e:	408a      	lsls	r2, r1
34001780:	431f      	orrs	r7, r3
34001782:	fa20 f306 	lsr.w	r3, r0, r6
34001786:	0c38      	lsrs	r0, r7, #16
34001788:	4323      	orrs	r3, r4
3400178a:	fa1f fc87 	uxth.w	ip, r7
3400178e:	0c1c      	lsrs	r4, r3, #16
34001790:	fbb8 fef0 	udiv	lr, r8, r0
34001794:	fb00 881e 	mls	r8, r0, lr, r8
34001798:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
3400179c:	fb0e f80c 	mul.w	r8, lr, ip
340017a0:	45a0      	cmp	r8, r4
340017a2:	d90e      	bls.n	340017c2 <__udivmoddi4+0x1b6>
340017a4:	193c      	adds	r4, r7, r4
340017a6:	f10e 3aff 	add.w	sl, lr, #4294967295
340017aa:	bf2c      	ite	cs
340017ac:	f04f 0b01 	movcs.w	fp, #1
340017b0:	f04f 0b00 	movcc.w	fp, #0
340017b4:	45a0      	cmp	r8, r4
340017b6:	d903      	bls.n	340017c0 <__udivmoddi4+0x1b4>
340017b8:	f1bb 0f00 	cmp.w	fp, #0
340017bc:	f000 80b8 	beq.w	34001930 <__udivmoddi4+0x324>
340017c0:	46d6      	mov	lr, sl
340017c2:	eba4 0408 	sub.w	r4, r4, r8
340017c6:	fa1f f883 	uxth.w	r8, r3
340017ca:	fbb4 f3f0 	udiv	r3, r4, r0
340017ce:	fb00 4413 	mls	r4, r0, r3, r4
340017d2:	fb03 fc0c 	mul.w	ip, r3, ip
340017d6:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
340017da:	45a4      	cmp	ip, r4
340017dc:	d90e      	bls.n	340017fc <__udivmoddi4+0x1f0>
340017de:	193c      	adds	r4, r7, r4
340017e0:	f103 30ff 	add.w	r0, r3, #4294967295
340017e4:	bf2c      	ite	cs
340017e6:	f04f 0801 	movcs.w	r8, #1
340017ea:	f04f 0800 	movcc.w	r8, #0
340017ee:	45a4      	cmp	ip, r4
340017f0:	d903      	bls.n	340017fa <__udivmoddi4+0x1ee>
340017f2:	f1b8 0f00 	cmp.w	r8, #0
340017f6:	f000 809f 	beq.w	34001938 <__udivmoddi4+0x32c>
340017fa:	4603      	mov	r3, r0
340017fc:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34001800:	eba4 040c 	sub.w	r4, r4, ip
34001804:	fba0 ec02 	umull	lr, ip, r0, r2
34001808:	4564      	cmp	r4, ip
3400180a:	4673      	mov	r3, lr
3400180c:	46e0      	mov	r8, ip
3400180e:	d302      	bcc.n	34001816 <__udivmoddi4+0x20a>
34001810:	d107      	bne.n	34001822 <__udivmoddi4+0x216>
34001812:	45f1      	cmp	r9, lr
34001814:	d205      	bcs.n	34001822 <__udivmoddi4+0x216>
34001816:	ebbe 0302 	subs.w	r3, lr, r2
3400181a:	eb6c 0c07 	sbc.w	ip, ip, r7
3400181e:	3801      	subs	r0, #1
34001820:	46e0      	mov	r8, ip
34001822:	b15d      	cbz	r5, 3400183c <__udivmoddi4+0x230>
34001824:	ebb9 0203 	subs.w	r2, r9, r3
34001828:	eb64 0408 	sbc.w	r4, r4, r8
3400182c:	fa04 f606 	lsl.w	r6, r4, r6
34001830:	fa22 f301 	lsr.w	r3, r2, r1
34001834:	40cc      	lsrs	r4, r1
34001836:	431e      	orrs	r6, r3
34001838:	e9c5 6400 	strd	r6, r4, [r5]
3400183c:	2100      	movs	r1, #0
3400183e:	e736      	b.n	340016ae <__udivmoddi4+0xa2>
34001840:	fbb1 fcf2 	udiv	ip, r1, r2
34001844:	0c01      	lsrs	r1, r0, #16
34001846:	4614      	mov	r4, r2
34001848:	b280      	uxth	r0, r0
3400184a:	4696      	mov	lr, r2
3400184c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001850:	2620      	movs	r6, #32
34001852:	4690      	mov	r8, r2
34001854:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34001858:	4610      	mov	r0, r2
3400185a:	fbb1 f1f2 	udiv	r1, r1, r2
3400185e:	eba3 0308 	sub.w	r3, r3, r8
34001862:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34001866:	e74b      	b.n	34001700 <__udivmoddi4+0xf4>
34001868:	40b7      	lsls	r7, r6
3400186a:	f1c6 0320 	rsb	r3, r6, #32
3400186e:	fa01 f206 	lsl.w	r2, r1, r6
34001872:	fa21 f803 	lsr.w	r8, r1, r3
34001876:	ea4f 4e17 	mov.w	lr, r7, lsr #16
3400187a:	fa20 f303 	lsr.w	r3, r0, r3
3400187e:	b2bc      	uxth	r4, r7
34001880:	40b0      	lsls	r0, r6
34001882:	4313      	orrs	r3, r2
34001884:	0c02      	lsrs	r2, r0, #16
34001886:	0c19      	lsrs	r1, r3, #16
34001888:	b280      	uxth	r0, r0
3400188a:	fbb8 f9fe 	udiv	r9, r8, lr
3400188e:	fb0e 8819 	mls	r8, lr, r9, r8
34001892:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001896:	fb09 f804 	mul.w	r8, r9, r4
3400189a:	4588      	cmp	r8, r1
3400189c:	d951      	bls.n	34001942 <__udivmoddi4+0x336>
3400189e:	1879      	adds	r1, r7, r1
340018a0:	f109 3cff 	add.w	ip, r9, #4294967295
340018a4:	bf2c      	ite	cs
340018a6:	f04f 0a01 	movcs.w	sl, #1
340018aa:	f04f 0a00 	movcc.w	sl, #0
340018ae:	4588      	cmp	r8, r1
340018b0:	d902      	bls.n	340018b8 <__udivmoddi4+0x2ac>
340018b2:	f1ba 0f00 	cmp.w	sl, #0
340018b6:	d031      	beq.n	3400191c <__udivmoddi4+0x310>
340018b8:	eba1 0108 	sub.w	r1, r1, r8
340018bc:	fbb1 f9fe 	udiv	r9, r1, lr
340018c0:	fb09 f804 	mul.w	r8, r9, r4
340018c4:	fb0e 1119 	mls	r1, lr, r9, r1
340018c8:	b29b      	uxth	r3, r3
340018ca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340018ce:	4543      	cmp	r3, r8
340018d0:	d235      	bcs.n	3400193e <__udivmoddi4+0x332>
340018d2:	18fb      	adds	r3, r7, r3
340018d4:	f109 31ff 	add.w	r1, r9, #4294967295
340018d8:	bf2c      	ite	cs
340018da:	f04f 0a01 	movcs.w	sl, #1
340018de:	f04f 0a00 	movcc.w	sl, #0
340018e2:	4543      	cmp	r3, r8
340018e4:	d2bb      	bcs.n	3400185e <__udivmoddi4+0x252>
340018e6:	f1ba 0f00 	cmp.w	sl, #0
340018ea:	d1b8      	bne.n	3400185e <__udivmoddi4+0x252>
340018ec:	f1a9 0102 	sub.w	r1, r9, #2
340018f0:	443b      	add	r3, r7
340018f2:	e7b4      	b.n	3400185e <__udivmoddi4+0x252>
340018f4:	1a84      	subs	r4, r0, r2
340018f6:	eb68 0203 	sbc.w	r2, r8, r3
340018fa:	2001      	movs	r0, #1
340018fc:	4696      	mov	lr, r2
340018fe:	e6eb      	b.n	340016d8 <__udivmoddi4+0xcc>
34001900:	443a      	add	r2, r7
34001902:	f1a8 0802 	sub.w	r8, r8, #2
34001906:	e72b      	b.n	34001760 <__udivmoddi4+0x154>
34001908:	f1ac 0c02 	sub.w	ip, ip, #2
3400190c:	443b      	add	r3, r7
3400190e:	e710      	b.n	34001732 <__udivmoddi4+0x126>
34001910:	3902      	subs	r1, #2
34001912:	443b      	add	r3, r7
34001914:	e6a9      	b.n	3400166a <__udivmoddi4+0x5e>
34001916:	443a      	add	r2, r7
34001918:	3802      	subs	r0, #2
3400191a:	e6be      	b.n	3400169a <__udivmoddi4+0x8e>
3400191c:	eba7 0808 	sub.w	r8, r7, r8
34001920:	f1a9 0c02 	sub.w	ip, r9, #2
34001924:	4441      	add	r1, r8
34001926:	fbb1 f9fe 	udiv	r9, r1, lr
3400192a:	fb09 f804 	mul.w	r8, r9, r4
3400192e:	e7c9      	b.n	340018c4 <__udivmoddi4+0x2b8>
34001930:	f1ae 0e02 	sub.w	lr, lr, #2
34001934:	443c      	add	r4, r7
34001936:	e744      	b.n	340017c2 <__udivmoddi4+0x1b6>
34001938:	3b02      	subs	r3, #2
3400193a:	443c      	add	r4, r7
3400193c:	e75e      	b.n	340017fc <__udivmoddi4+0x1f0>
3400193e:	4649      	mov	r1, r9
34001940:	e78d      	b.n	3400185e <__udivmoddi4+0x252>
34001942:	eba1 0108 	sub.w	r1, r1, r8
34001946:	46cc      	mov	ip, r9
34001948:	fbb1 f9fe 	udiv	r9, r1, lr
3400194c:	fb09 f804 	mul.w	r8, r9, r4
34001950:	e7b8      	b.n	340018c4 <__udivmoddi4+0x2b8>
34001952:	bf00      	nop

34001954 <__aeabi_idiv0>:
34001954:	4770      	bx	lr
34001956:	bf00      	nop

34001958 <CAM_Init>:
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
  assert(ret == HAL_OK);
}

void CAM_Init(uint32_t *lcd_bg_width, uint32_t *lcd_bg_height, uint32_t *pitch_nn)
{
34001958:	b570      	push	{r4, r5, r6, lr}
  int ret;
  CMW_CameraInit_t cam_conf;

  cam_conf.width = CAMERA_WIDTH;
3400195a:	2300      	movs	r3, #0
{
3400195c:	4614      	mov	r4, r2
  cam_conf.height = CAMERA_HEIGHT;
  cam_conf.fps = CAMERA_FPS;
3400195e:	221e      	movs	r2, #30
{
34001960:	b092      	sub	sp, #72	@ 0x48
34001962:	4606      	mov	r6, r0
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
  cam_conf.anti_flicker = 0;
  cam_conf.mirror_flip = CAMERA_FLIP;

  ret = CMW_CAMERA_Init(&cam_conf);
34001964:	a801      	add	r0, sp, #4
{
34001966:	460d      	mov	r5, r1
  cam_conf.height = CAMERA_HEIGHT;
34001968:	e9cd 3301 	strd	r3, r3, [sp, #4]
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
3400196c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  cam_conf.mirror_flip = CAMERA_FLIP;
34001970:	e9cd 3305 	strd	r3, r3, [sp, #20]
  ret = CMW_CAMERA_Init(&cam_conf);
34001974:	f00f f8c0 	bl	34010af8 <CMW_CAMERA_Init>
  assert(ret == CMW_ERROR_NONE);
34001978:	b128      	cbz	r0, 34001986 <CAM_Init+0x2e>
3400197a:	218c      	movs	r1, #140	@ 0x8c
3400197c:	4b1a      	ldr	r3, [pc, #104]	@ (340019e8 <CAM_Init+0x90>)
3400197e:	4a1b      	ldr	r2, [pc, #108]	@ (340019ec <CAM_Init+0x94>)
  assert(ret == HAL_OK);
34001980:	481b      	ldr	r0, [pc, #108]	@ (340019f0 <CAM_Init+0x98>)
34001982:	f015 ff99 	bl	340178b8 <__assert_func>
  if (camConf->height <= 480)
34001986:	9b02      	ldr	r3, [sp, #8]
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
34001988:	e9cd 000b 	strd	r0, r0, [sp, #44]	@ 0x2c
  if (camConf->height <= 480)
3400198c:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34001990:	bf28      	it	cs
34001992:	f44f 73f0 	movcs.w	r3, #480	@ 0x1e0
  *bg_width = lcd_bg_width;
34001996:	6033      	str	r3, [r6, #0]
  *bg_height = lcd_bg_height;
34001998:	602b      	str	r3, [r5, #0]
  dcmipp_conf.output_bpp = CAPTURE_BPP;
3400199a:	2501      	movs	r5, #1
3400199c:	2602      	movs	r6, #2
  dcmipp_conf.mode = aspect_ratio;
3400199e:	900d      	str	r0, [sp, #52]	@ 0x34
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
340019a0:	466a      	mov	r2, sp
340019a2:	4628      	mov	r0, r5
340019a4:	a907      	add	r1, sp, #28
  dcmipp_conf.output_height = lcd_bg_height;
340019a6:	e9cd 3307 	strd	r3, r3, [sp, #28]
  dcmipp_conf.output_bpp = CAPTURE_BPP;
340019aa:	e9cd 5609 	strd	r5, r6, [sp, #36]	@ 0x24
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
340019ae:	f00e ff5d 	bl	3401086c <CMW_CAMERA_SetPipeConfig>
  assert(ret == HAL_OK);
340019b2:	b118      	cbz	r0, 340019bc <CAM_Init+0x64>
340019b4:	215a      	movs	r1, #90	@ 0x5a
340019b6:	4b0f      	ldr	r3, [pc, #60]	@ (340019f4 <CAM_Init+0x9c>)
340019b8:	4a0f      	ldr	r2, [pc, #60]	@ (340019f8 <CAM_Init+0xa0>)
340019ba:	e7e1      	b.n	34001980 <CAM_Init+0x28>
  dcmipp_conf.output_width = NN_WIDTH;
340019bc:	23e0      	movs	r3, #224	@ 0xe0
  dcmipp_conf.output_height = NN_HEIGHT;
340019be:	e9cd 3307 	strd	r3, r3, [sp, #28]
  dcmipp_conf.output_bpp = NN_BPP;
340019c2:	2303      	movs	r3, #3
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
340019c4:	e9cd 500b 	strd	r5, r0, [sp, #44]	@ 0x2c
  dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
340019c8:	9009      	str	r0, [sp, #36]	@ 0x24
  dcmipp_conf.mode = aspect_ratio;
340019ca:	900d      	str	r0, [sp, #52]	@ 0x34
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
340019cc:	4622      	mov	r2, r4
340019ce:	4630      	mov	r0, r6
340019d0:	a907      	add	r1, sp, #28
  dcmipp_conf.output_bpp = NN_BPP;
340019d2:	930a      	str	r3, [sp, #40]	@ 0x28
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
340019d4:	f00e ff4a 	bl	3401086c <CMW_CAMERA_SetPipeConfig>
  assert(ret == HAL_OK);
340019d8:	b118      	cbz	r0, 340019e2 <CAM_Init+0x8a>
340019da:	217c      	movs	r1, #124	@ 0x7c
340019dc:	4b05      	ldr	r3, [pc, #20]	@ (340019f4 <CAM_Init+0x9c>)
340019de:	4a07      	ldr	r2, [pc, #28]	@ (340019fc <CAM_Init+0xa4>)
340019e0:	e7ce      	b.n	34001980 <CAM_Init+0x28>
  DCMIPP_PipeInitDisplay(&cam_conf, lcd_bg_width, lcd_bg_height);
  DCMIPP_PipeInitNn(pitch_nn);
}
340019e2:	b012      	add	sp, #72	@ 0x48
340019e4:	bd70      	pop	{r4, r5, r6, pc}
340019e6:	bf00      	nop
340019e8:	3401bd44 	.word	0x3401bd44
340019ec:	3401e7aa 	.word	0x3401e7aa
340019f0:	3401bd5a 	.word	0x3401bd5a
340019f4:	3401bd91 	.word	0x3401bd91
340019f8:	3401e793 	.word	0x3401e793
340019fc:	3401e781 	.word	0x3401e781

34001a00 <CAM_DisplayPipe_Start>:
  ret = CMW_CAMERA_DeInit();
  assert(ret == CMW_ERROR_NONE);
}

void CAM_DisplayPipe_Start(uint8_t *display_pipe_dst, uint32_t cam_mode)
{
34001a00:	460a      	mov	r2, r1
34001a02:	b508      	push	{r3, lr}
  int ret;
  ret = CMW_CAMERA_Start(DCMIPP_PIPE1, display_pipe_dst, cam_mode);
34001a04:	4601      	mov	r1, r0
34001a06:	2001      	movs	r0, #1
34001a08:	f00e fff2 	bl	340109f0 <CMW_CAMERA_Start>
  assert(ret == CMW_ERROR_NONE);
34001a0c:	b128      	cbz	r0, 34001a1a <CAM_DisplayPipe_Start+0x1a>
34001a0e:	219c      	movs	r1, #156	@ 0x9c
34001a10:	4b02      	ldr	r3, [pc, #8]	@ (34001a1c <CAM_DisplayPipe_Start+0x1c>)
34001a12:	4a03      	ldr	r2, [pc, #12]	@ (34001a20 <CAM_DisplayPipe_Start+0x20>)
34001a14:	4803      	ldr	r0, [pc, #12]	@ (34001a24 <CAM_DisplayPipe_Start+0x24>)
34001a16:	f015 ff4f 	bl	340178b8 <__assert_func>
}
34001a1a:	bd08      	pop	{r3, pc}
34001a1c:	3401bd44 	.word	0x3401bd44
34001a20:	3401e76b 	.word	0x3401e76b
34001a24:	3401bd5a 	.word	0x3401bd5a

34001a28 <CAM_NNPipe_Start>:

void CAM_NNPipe_Start(uint8_t *nn_pipe_dst, uint32_t cam_mode)
{
34001a28:	460a      	mov	r2, r1
34001a2a:	b508      	push	{r3, lr}
  int ret;

  ret = CMW_CAMERA_Start(DCMIPP_PIPE2, nn_pipe_dst, cam_mode);
34001a2c:	4601      	mov	r1, r0
34001a2e:	2002      	movs	r0, #2
34001a30:	f00e ffde 	bl	340109f0 <CMW_CAMERA_Start>
  assert(ret == CMW_ERROR_NONE);
34001a34:	b128      	cbz	r0, 34001a42 <CAM_NNPipe_Start+0x1a>
34001a36:	21a4      	movs	r1, #164	@ 0xa4
34001a38:	4b02      	ldr	r3, [pc, #8]	@ (34001a44 <CAM_NNPipe_Start+0x1c>)
34001a3a:	4a03      	ldr	r2, [pc, #12]	@ (34001a48 <CAM_NNPipe_Start+0x20>)
34001a3c:	4803      	ldr	r0, [pc, #12]	@ (34001a4c <CAM_NNPipe_Start+0x24>)
34001a3e:	f015 ff3b 	bl	340178b8 <__assert_func>
}
34001a42:	bd08      	pop	{r3, pc}
34001a44:	3401bd44 	.word	0x3401bd44
34001a48:	3401e75a 	.word	0x3401e75a
34001a4c:	3401bd5a 	.word	0x3401bd5a

34001a50 <CAM_IspUpdate>:
  ret = CMW_CAMERA_Suspend(DCMIPP_PIPE1);
  assert(ret == CMW_ERROR_NONE);
}

void CAM_IspUpdate(void)
{
34001a50:	b508      	push	{r3, lr}
  int ret = CMW_ERROR_NONE;
  ret = CMW_CAMERA_Run();
34001a52:	f00f f8a7 	bl	34010ba4 <CMW_CAMERA_Run>
  assert(ret == CMW_ERROR_NONE);
34001a56:	b128      	cbz	r0, 34001a64 <CAM_IspUpdate+0x14>
34001a58:	21b2      	movs	r1, #178	@ 0xb2
34001a5a:	4b03      	ldr	r3, [pc, #12]	@ (34001a68 <CAM_IspUpdate+0x18>)
34001a5c:	4a03      	ldr	r2, [pc, #12]	@ (34001a6c <CAM_IspUpdate+0x1c>)
34001a5e:	4804      	ldr	r0, [pc, #16]	@ (34001a70 <CAM_IspUpdate+0x20>)
34001a60:	f015 ff2a 	bl	340178b8 <__assert_func>
}
34001a64:	bd08      	pop	{r3, pc}
34001a66:	bf00      	nop
34001a68:	3401bd44 	.word	0x3401bd44
34001a6c:	3401e74c 	.word	0x3401e74c
34001a70:	3401bd5a 	.word	0x3401bd5a

34001a74 <CMW_CAMERA_PIPE_FrameEventCallback>:
  * @param  hdcmipp pointer to the DCMIPP handle
  * @retval None
  */
int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
{
  switch (pipe)
34001a74:	2802      	cmp	r0, #2
  {
    case DCMIPP_PIPE2 :
      cameraFrameReceived++;
34001a76:	bf08      	it	eq
34001a78:	4a03      	ldreq	r2, [pc, #12]	@ (34001a88 <CMW_CAMERA_PIPE_FrameEventCallback+0x14>)
      break;
  }
  return 0;
}
34001a7a:	f04f 0000 	mov.w	r0, #0
      cameraFrameReceived++;
34001a7e:	bf02      	ittt	eq
34001a80:	6813      	ldreq	r3, [r2, #0]
34001a82:	3301      	addeq	r3, #1
34001a84:	6013      	streq	r3, [r2, #0]
}
34001a86:	4770      	bx	lr
34001a88:	3403f318 	.word	0x3403f318

34001a8c <Fuse_Programming>:
/**
  * @brief  Check specific fuse configuration and update it if needed.
  * @retval None
  */
void Fuse_Programming(void)
{
34001a8c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t fuse_id, bit_mask, data;

  BSEC_HandleTypeDef sBsecHandler;

  sBsecHandler.Instance = BSEC;
34001a8e:	4b15      	ldr	r3, [pc, #84]	@ (34001ae4 <Fuse_Programming+0x58>)

  /* Read current value of fuse */
  fuse_id = BSEC_FUSE_ADDRESS;
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001a90:	217c      	movs	r1, #124	@ 0x7c
34001a92:	aa01      	add	r2, sp, #4
34001a94:	a802      	add	r0, sp, #8
  sBsecHandler.Instance = BSEC;
34001a96:	9302      	str	r3, [sp, #8]
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001a98:	f002 ff12 	bl	340048c0 <HAL_BSEC_OTP_Read>
34001a9c:	4603      	mov	r3, r0
34001a9e:	b9e0      	cbnz	r0, 34001ada <Fuse_Programming+0x4e>
  {
    /* Check if bit has already been set */
    bit_mask = BSEC_FUSE_MASK;
    if ((data & bit_mask) != bit_mask)
34001aa0:	9a01      	ldr	r2, [sp, #4]
34001aa2:	f402 31c0 	and.w	r1, r2, #98304	@ 0x18000
34001aa6:	f5b1 3fc0 	cmp.w	r1, #98304	@ 0x18000
34001aaa:	d017      	beq.n	34001adc <Fuse_Programming+0x50>
    {
      data |= bit_mask;
34001aac:	f442 32c0 	orr.w	r2, r2, #98304	@ 0x18000
      /* Bitwise programming of lower bits */
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34001ab0:	217c      	movs	r1, #124	@ 0x7c
34001ab2:	a802      	add	r0, sp, #8
      data |= bit_mask;
34001ab4:	9201      	str	r2, [sp, #4]
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34001ab6:	f002 ff1f 	bl	340048f8 <HAL_BSEC_OTP_Program>
34001aba:	b968      	cbnz	r0, 34001ad8 <Fuse_Programming+0x4c>
      {
        /* Read lower bits to verify the correct programming */
        if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001abc:	217c      	movs	r1, #124	@ 0x7c
34001abe:	aa01      	add	r2, sp, #4
34001ac0:	a802      	add	r0, sp, #8
34001ac2:	f002 fefd 	bl	340048c0 <HAL_BSEC_OTP_Read>
34001ac6:	b930      	cbnz	r0, 34001ad6 <Fuse_Programming+0x4a>
        {
          if ((data & bit_mask) != bit_mask)
34001ac8:	9b01      	ldr	r3, [sp, #4]
34001aca:	f403 33c0 	and.w	r3, r3, #98304	@ 0x18000
34001ace:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
34001ad2:	d003      	beq.n	34001adc <Fuse_Programming+0x50>
34001ad4:	e7fe      	b.n	34001ad4 <Fuse_Programming+0x48>
34001ad6:	e7fe      	b.n	34001ad6 <Fuse_Programming+0x4a>
34001ad8:	e7fe      	b.n	34001ad8 <Fuse_Programming+0x4c>
34001ada:	e7fe      	b.n	34001ada <Fuse_Programming+0x4e>
  else
  {
    /* Error  : Fuse read unsuccessful */
    ErrorHandler();
  }
}
34001adc:	b005      	add	sp, #20
34001ade:	f85d fb04 	ldr.w	pc, [sp], #4
34001ae2:	bf00      	nop
34001ae4:	56009000 	.word	0x56009000

34001ae8 <app_postprocess_init>:
int32_t app_postprocess_init(void *params_postprocess)
{
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
  yolov2_pp_static_param_t *params = (yolov2_pp_static_param_t *) params_postprocess;
  params->conf_threshold = AI_OBJDETECT_YOLOV2_PP_CONF_THRESHOLD;
34001ae8:	4a09      	ldr	r2, [pc, #36]	@ (34001b10 <app_postprocess_init+0x28>)
  params->iou_threshold = AI_OBJDETECT_YOLOV2_PP_IOU_THRESHOLD;
  params->nb_anchors = AI_OBJDETECT_YOLOV2_PP_NB_ANCHORS;
  params->nb_classes = AI_OBJDETECT_YOLOV2_PP_NB_CLASSES;
34001aea:	2105      	movs	r1, #5
  params->conf_threshold = AI_OBJDETECT_YOLOV2_PP_CONF_THRESHOLD;
34001aec:	6182      	str	r2, [r0, #24]
  params->iou_threshold = AI_OBJDETECT_YOLOV2_PP_IOU_THRESHOLD;
34001aee:	4a09      	ldr	r2, [pc, #36]	@ (34001b14 <app_postprocess_init+0x2c>)
34001af0:	61c2      	str	r2, [r0, #28]
  params->nb_classes = AI_OBJDETECT_YOLOV2_PP_NB_CLASSES;
34001af2:	2201      	movs	r2, #1
34001af4:	e9c0 2100 	strd	r2, r1, [r0]
  params->grid_height = AI_OBJDETECT_YOLOV2_PP_GRID_HEIGHT;
34001af8:	2207      	movs	r2, #7
  params->grid_width = AI_OBJDETECT_YOLOV2_PP_GRID_WIDTH;
34001afa:	e9c0 2202 	strd	r2, r2, [r0, #8]
  params->nb_input_boxes = AI_OBJDETECT_YOLOV2_PP_NB_INPUT_BOXES;
34001afe:	2231      	movs	r2, #49	@ 0x31
34001b00:	6102      	str	r2, [r0, #16]
  params->pAnchors = AI_OBJDETECT_YOLOV2_PP_ANCHORS;
34001b02:	4a05      	ldr	r2, [pc, #20]	@ (34001b18 <app_postprocess_init+0x30>)
34001b04:	6202      	str	r2, [r0, #32]
  params->max_boxes_limit = AI_OBJDETECT_YOLOV2_PP_MAX_BOXES_LIMIT;
34001b06:	220a      	movs	r2, #10
34001b08:	6142      	str	r2, [r0, #20]
  error = od_yolov2_pp_reset(params);
34001b0a:	f013 bf4b 	b.w	340159a4 <od_yolov2_pp_reset>
34001b0e:	bf00      	nop
34001b10:	3f19999a 	.word	0x3f19999a
34001b14:	3e99999a 	.word	0x3e99999a
34001b18:	3401e7c8 	.word	0x3401e7c8

34001b1c <app_postprocess_run>:

  return error;
}

int32_t app_postprocess_run(void *pInput[], int nb_input, void *pOutput, void *pInput_param)
{
34001b1c:	b513      	push	{r0, r1, r4, lr}
34001b1e:	460c      	mov	r4, r1
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  assert(nb_input == 1);
34001b20:	2c01      	cmp	r4, #1
{
34001b22:	4611      	mov	r1, r2
34001b24:	461a      	mov	r2, r3
  assert(nb_input == 1);
34001b26:	d005      	beq.n	34001b34 <app_postprocess_run+0x18>
34001b28:	21c4      	movs	r1, #196	@ 0xc4
34001b2a:	4b06      	ldr	r3, [pc, #24]	@ (34001b44 <app_postprocess_run+0x28>)
34001b2c:	4a06      	ldr	r2, [pc, #24]	@ (34001b48 <app_postprocess_run+0x2c>)
34001b2e:	4807      	ldr	r0, [pc, #28]	@ (34001b4c <app_postprocess_run+0x30>)
34001b30:	f015 fec2 	bl	340178b8 <__assert_func>
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
  yolov2_pp_in_t pp_input = {
34001b34:	6803      	ldr	r3, [r0, #0]
    .pRaw_detections = (float32_t *) pInput[0]
  };
  error = od_yolov2_pp_process(&pp_input, (od_pp_out_t *) pOutput,
34001b36:	a801      	add	r0, sp, #4
  yolov2_pp_in_t pp_input = {
34001b38:	9301      	str	r3, [sp, #4]
  error = od_yolov2_pp_process(&pp_input, (od_pp_out_t *) pOutput,
34001b3a:	f013 ff37 	bl	340159ac <od_yolov2_pp_process>
#else
  #error "PostProcessing type not supported"
#endif

  return error;
}
34001b3e:	b002      	add	sp, #8
34001b40:	bd10      	pop	{r4, pc}
34001b42:	bf00      	nop
34001b44:	3401bd9f 	.word	0x3401bd9f
34001b48:	3401e7b3 	.word	0x3401e7b3
34001b4c:	3401bdad 	.word	0x3401bdad

34001b50 <img_crop>:
#include <assert.h>

void img_crop(uint8_t *src_image, uint8_t *dst_img, const uint32_t src_stride,
              const uint16_t dst_width, const uint16_t height,
              const uint16_t dst_bpp)
{
34001b50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34001b54:	460d      	mov	r5, r1
  const uint8_t *pIn = src_image;
  uint8_t *pOut = dst_img;
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34001b56:	4604      	mov	r4, r0

  /* Copy line per line */
  for (uint32_t i = 0; i < height; i++)
34001b58:	2700      	movs	r7, #0
{
34001b5a:	4690      	mov	r8, r2
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34001b5c:	f8bd 2024 	ldrh.w	r2, [sp, #36]	@ 0x24
{
34001b60:	f8bd 9020 	ldrh.w	r9, [sp, #32]
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34001b64:	fb02 f603 	mul.w	r6, r2, r3
  for (uint32_t i = 0; i < height; i++)
34001b68:	45b9      	cmp	r9, r7
34001b6a:	d801      	bhi.n	34001b70 <img_crop+0x20>
  {
    memcpy(pOut, pIn + (i * src_stride), dst_line_size);
    pOut += dst_line_size;
  }
34001b6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    memcpy(pOut, pIn + (i * src_stride), dst_line_size);
34001b70:	4621      	mov	r1, r4
34001b72:	4628      	mov	r0, r5
34001b74:	4632      	mov	r2, r6
34001b76:	f017 fa98 	bl	340190aa <memcpy>
    pOut += dst_line_size;
34001b7a:	4435      	add	r5, r6
  for (uint32_t i = 0; i < height; i++)
34001b7c:	3701      	adds	r7, #1
34001b7e:	4444      	add	r4, r8
34001b80:	e7f2      	b.n	34001b68 <img_crop+0x18>
	...

34001b84 <LL_MEM_EnableClock>:
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClock(uint32_t Memories)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMENSR, Memories);
34001b84:	4b04      	ldr	r3, [pc, #16]	@ (34001b98 <LL_MEM_EnableClock+0x14>)
{
34001b86:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMENSR, Memories);
34001b88:	f8c3 0a4c 	str.w	r0, [r3, #2636]	@ 0xa4c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMENR);
34001b8c:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
34001b90:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001b92:	9b01      	ldr	r3, [sp, #4]
}
34001b94:	b002      	add	sp, #8
34001b96:	4770      	bx	lr
34001b98:	56028000 	.word	0x56028000

34001b9c <LL_MEM_EnableClockLowPower>:
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClockLowPower(uint32_t Memories)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMLPENSR, Memories);
34001b9c:	4b04      	ldr	r3, [pc, #16]	@ (34001bb0 <LL_MEM_EnableClockLowPower+0x14>)
{
34001b9e:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMLPENSR, Memories);
34001ba0:	f8c3 0a8c 	str.w	r0, [r3, #2700]	@ 0xa8c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMLPENR);
34001ba4:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
34001ba8:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001baa:	9b01      	ldr	r3, [sp, #4]
}
34001bac:	b002      	add	sp, #8
34001bae:	4770      	bx	lr
34001bb0:	56028000 	.word	0x56028000

34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>:
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
34001bb4:	4b04      	ldr	r3, [pc, #16]	@ (34001bc8 <LL_AHB5_GRP1_EnableClockLowPower+0x14>)
{
34001bb6:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
34001bb8:	f8c3 0aa0 	str.w	r0, [r3, #2720]	@ 0xaa0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5LPENR);
34001bbc:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
34001bc0:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001bc2:	9b01      	ldr	r3, [sp, #4]
}
34001bc4:	b002      	add	sp, #8
34001bc6:	4770      	bx	lr
34001bc8:	56028000 	.word	0x56028000

34001bcc <SystemClock_Config>:

  return ret;
}

static void SystemClock_Config(void)
{
34001bcc:	b530      	push	{r4, r5, lr}
34001bce:	f5ad 7d1b 	sub.w	sp, sp, #620	@ 0x26c
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34001bd2:	2240      	movs	r2, #64	@ 0x40
34001bd4:	2100      	movs	r1, #0
34001bd6:	4668      	mov	r0, sp
34001bd8:	f016 ffd0 	bl	34018b7c <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34001bdc:	2298      	movs	r2, #152	@ 0x98
34001bde:	2100      	movs	r1, #0
34001be0:	a810      	add	r0, sp, #64	@ 0x40
34001be2:	f016 ffcb 	bl	34018b7c <memset>
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34001be6:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34001bea:	2100      	movs	r1, #0
34001bec:	a836      	add	r0, sp, #216	@ 0xd8
34001bee:	f016 ffc5 	bl	34018b7c <memset>

  /* Ensure VDDCORE=0.9V before increasing the system frequency */
  BSP_SMPS_Init(SMPS_VOLTAGE_OVERDRIVE);
34001bf2:	2001      	movs	r0, #1
34001bf4:	f001 f9c0 	bl	34002f78 <BSP_SMPS_Init>
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL1.PLLM = 2;
  RCC_OscInitStruct.PLL1.PLLN = 25;
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34001bf8:	2401      	movs	r4, #1
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34001bfa:	2300      	movs	r3, #0
  RCC_OscInitStruct.PLL1.PLLN = 25;
34001bfc:	2219      	movs	r2, #25
  /* PLL2 = 64 x 125 / 8 = 1000MHz */
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL2.PLLM = 8;
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
  RCC_OscInitStruct.PLL2.PLLN = 125;
34001bfe:	217d      	movs	r1, #125	@ 0x7d
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34001c00:	2502      	movs	r5, #2
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34001c02:	e9cd 321d 	strd	r3, r2, [sp, #116]	@ 0x74
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
34001c06:	e9cd 1425 	strd	r1, r4, [sp, #148]	@ 0x94
  RCC_OscInitStruct.PLL2.PLLM = 8;
34001c0a:	2208      	movs	r2, #8

  /* PLL3 = (64 x 225 / 8) / (1 * 2) = 900MHz */
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL3.PLLM = 8;
  RCC_OscInitStruct.PLL3.PLLN = 225;
34001c0c:	21e1      	movs	r1, #225	@ 0xe1
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34001c0e:	e9cd 531a 	strd	r5, r3, [sp, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34001c12:	e9cd 5321 	strd	r5, r3, [sp, #132]	@ 0x84
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
34001c16:	e9cd 2323 	strd	r2, r3, [sp, #140]	@ 0x8c
  RCC_OscInitStruct.PLL3.PLLM = 8;
34001c1a:	e9cd 3229 	strd	r3, r2, [sp, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34001c1e:	e9cd 312b 	strd	r3, r1, [sp, #172]	@ 0xac
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
  RCC_OscInitStruct.PLL3.PLLP2 = 2;

  /* PLL4 = (64 x 225 / 8) / (6 * 6) = 50 MHz */
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34001c22:	e9cd 532f 	strd	r5, r3, [sp, #188]	@ 0xbc
  RCC_OscInitStruct.PLL4.PLLM = 8;
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34001c26:	e9cd 2331 	strd	r2, r3, [sp, #196]	@ 0xc4
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34001c2a:	9310      	str	r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL4.PLLN = 225;
  RCC_OscInitStruct.PLL4.PLLP1 = 6;
34001c2c:	2306      	movs	r3, #6
  RCC_OscInitStruct.PLL4.PLLP2 = 6;

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34001c2e:	a810      	add	r0, sp, #64	@ 0x40
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34001c30:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
34001c34:	e9cd 4527 	strd	r4, r5, [sp, #156]	@ 0x9c
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34001c38:	e9cd 452d 	strd	r4, r5, [sp, #180]	@ 0xb4
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
34001c3c:	e9cd 3334 	strd	r3, r3, [sp, #208]	@ 0xd0
  RCC_OscInitStruct.PLL1.PLLM = 2;
34001c40:	951c      	str	r5, [sp, #112]	@ 0x70
  RCC_OscInitStruct.PLL4.PLLN = 225;
34001c42:	9133      	str	r1, [sp, #204]	@ 0xcc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34001c44:	f007 fbb8 	bl	340093b8 <HAL_RCC_OscConfig>
34001c48:	b100      	cbz	r0, 34001c4c <SystemClock_Config+0x80>
  {
    while(1);
34001c4a:	e7fe      	b.n	34001c4a <SystemClock_Config+0x7e>
                                 RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
                                 RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK4 |
                                 RCC_CLOCKTYPE_PCLK5);

  /* CPU CLock (sysa_ck) = ic1_ck = PLL1 output/ic1_divider = 800 MHz */
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34001c4c:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34001c50:	227f      	movs	r2, #127	@ 0x7f
34001c52:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34001c56:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34001c5a:	9302      	str	r3, [sp, #8]
  /* AXI Clock (sysb_ck) = ic2_ck = PLL1 output/ic2_divider = 400 MHz */
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;

  /* NPU Clock (sysc_ck) = ic6_ck = PLL2 output/ic6_divider = 1000 MHz */
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34001c5c:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34001c60:	e9cd 340c 	strd	r3, r4, [sp, #48]	@ 0x30

  /* AXISRAM3/4/5/6 Clock (sysd_ck) = ic11_ck = PLL3 output/ic11_divider = 900 MHz */
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34001c64:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
34001c68:	e9cd 340e 	strd	r3, r4, [sp, #56]	@ 0x38

  /* HCLK = sysb_ck / HCLK divider = 200 MHz */
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34001c6c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34001c70:	e9cd 0408 	strd	r0, r4, [sp, #32]
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34001c74:	e9cd 050a 	strd	r0, r5, [sp, #40]	@ 0x28

  /* PCLKx = HCLK / PCLKx divider = 200 MHz */
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34001c78:	e9cd 3003 	strd	r3, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34001c7c:	e9cd 0005 	strd	r0, r0, [sp, #20]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34001c80:	9007      	str	r0, [sp, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34001c82:	4668      	mov	r0, sp
34001c84:	f007 ff94 	bl	34009bb0 <HAL_RCC_ClockConfig>
34001c88:	b100      	cbz	r0, 34001c8c <SystemClock_Config+0xc0>
  {
    while(1);
34001c8a:	e7fe      	b.n	34001c8a <SystemClock_Config+0xbe>

  RCC_PeriphCLKInitStruct.PeriphClockSelection = 0;

  /* XSPI1 kernel clock (ck_ker_xspi1) = HCLK = 200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI1;
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34001c8c:	4b08      	ldr	r3, [pc, #32]	@ (34001cb0 <SystemClock_Config+0xe4>)

  /* XSPI2 kernel clock (ck_ker_xspi1) = HCLK =  200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34001c8e:	2200      	movs	r2, #0
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34001c90:	9361      	str	r3, [sp, #388]	@ 0x184
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34001c92:	f44f 0340 	mov.w	r3, #12582912	@ 0xc00000
34001c96:	e9cd 2336 	strd	r2, r3, [sp, #216]	@ 0xd8
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34001c9a:	4b06      	ldr	r3, [pc, #24]	@ (34001cb4 <SystemClock_Config+0xe8>)

  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34001c9c:	a836      	add	r0, sp, #216	@ 0xd8
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34001c9e:	9362      	str	r3, [sp, #392]	@ 0x188
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34001ca0:	f008 fb3c 	bl	3400a31c <HAL_RCCEx_PeriphCLKConfig>
34001ca4:	b100      	cbz	r0, 34001ca8 <SystemClock_Config+0xdc>
  {
    while (1);
34001ca6:	e7fe      	b.n	34001ca6 <SystemClock_Config+0xda>
  }
}
34001ca8:	f50d 7d1b 	add.w	sp, sp, #620	@ 0x26c
34001cac:	bd30      	pop	{r4, r5, pc}
34001cae:	bf00      	nop
34001cb0:	03000014 	.word	0x03000014
34001cb4:	03000414 	.word	0x03000414

34001cb8 <main>:
{
34001cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34001cbc:	4ac9      	ldr	r2, [pc, #804]	@ (34001fe4 <main+0x32c>)
{
34001cbe:	b09b      	sub	sp, #108	@ 0x6c
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34001cc0:	6813      	ldr	r3, [r2, #0]
34001cc2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34001cc6:	6013      	str	r3, [r2, #0]
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_IC1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCpuClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, Source);
34001cc8:	4bc7      	ldr	r3, [pc, #796]	@ (34001fe8 <main+0x330>)
34001cca:	6a1a      	ldr	r2, [r3, #32]
34001ccc:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
34001cd0:	621a      	str	r2, [r3, #32]
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_IC2_IC6_IC11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, Source);
34001cd2:	6a1a      	ldr	r2, [r3, #32]
34001cd4:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
34001cd8:	621a      	str	r2, [r3, #32]
  HAL_Init();
34001cda:	f002 fd79 	bl	340047d0 <HAL_Init>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34001cde:	4bc3      	ldr	r3, [pc, #780]	@ (34001fec <main+0x334>)
34001ce0:	695a      	ldr	r2, [r3, #20]
34001ce2:	f412 3200 	ands.w	r2, r2, #131072	@ 0x20000
34001ce6:	d111      	bne.n	34001d0c <main+0x54>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34001ce8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001cec:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34001cf0:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34001cf4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001cf8:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
34001cfc:	695a      	ldr	r2, [r3, #20]
34001cfe:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
34001d02:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34001d04:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001d08:	f3bf 8f6f 	isb	sy
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
34001d0c:	4ab5      	ldr	r2, [pc, #724]	@ (34001fe4 <main+0x32c>)
34001d0e:	6813      	ldr	r3, [r2, #0]
34001d10:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34001d14:	6013      	str	r3, [r2, #0]
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34001d16:	f5a2 4273 	sub.w	r2, r2, #62208	@ 0xf300
34001d1a:	6953      	ldr	r3, [r2, #20]
34001d1c:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
34001d20:	d128      	bne.n	34001d74 <main+0xbc>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
34001d22:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34001d26:	f3bf 8f4f 	dsb	sy
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34001d2a:	f643 74e0 	movw	r4, #16352	@ 0x3fe0
    ccsidr = SCB->CCSIDR;
34001d2e:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34001d32:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
34001d36:	f3c3 334e 	ubfx	r3, r3, #13, #15
34001d3a:	015b      	lsls	r3, r3, #5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34001d3c:	f100 0e01 	add.w	lr, r0, #1
34001d40:	4601      	mov	r1, r0
34001d42:	f04e e001 	dls	lr, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34001d46:	ea03 0604 	and.w	r6, r3, r4
34001d4a:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
34001d4e:	f8c2 5260 	str.w	r5, [r2, #608]	@ 0x260
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34001d52:	3901      	subs	r1, #1
34001d54:	f00f c807 	le	lr, 34001d4a <main+0x92>
    } while(sets-- != 0U);
34001d58:	3b20      	subs	r3, #32
34001d5a:	f113 0f20 	cmn.w	r3, #32
34001d5e:	d1ed      	bne.n	34001d3c <main+0x84>
34001d60:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
34001d64:	6953      	ldr	r3, [r2, #20]
34001d66:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34001d6a:	6153      	str	r3, [r2, #20]
34001d6c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001d70:	f3bf 8f6f 	isb	sy
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001d74:	f04f 4700 	mov.w	r7, #2147483648	@ 0x80000000
  WRITE_REG(RCC->AHB2ENSR, Periphs);
34001d78:	f44f 5980 	mov.w	r9, #4096	@ 0x1000
  RAMCFG_HandleTypeDef hramcfg = {0};
34001d7c:	2500      	movs	r5, #0
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001d7e:	4c9a      	ldr	r4, [pc, #616]	@ (34001fe8 <main+0x330>)
  SystemClock_Config();
34001d80:	f7ff ff24 	bl	34001bcc <SystemClock_Config>
34001d84:	f8c4 7a60 	str.w	r7, [r4, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34001d88:	f8d4 3260 	ldr.w	r3, [r4, #608]	@ 0x260
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34001d8c:	f8df a2ac 	ldr.w	sl, [pc, #684]	@ 3400203c <main+0x384>
  tmpreg = READ_REG(RCC->AHB5ENR);
34001d90:	930a      	str	r3, [sp, #40]	@ 0x28
  (void)tmpreg;
34001d92:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
34001d94:	2001      	movs	r0, #1
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34001d96:	f8c4 7a20 	str.w	r7, [r4, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34001d9a:	f8ca 7220 	str.w	r7, [sl, #544]	@ 0x220
34001d9e:	f7ff fef1 	bl	34001b84 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
34001da2:	2002      	movs	r0, #2
34001da4:	f7ff feee 	bl	34001b84 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
34001da8:	2004      	movs	r0, #4
34001daa:	f7ff feeb 	bl	34001b84 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
34001dae:	2008      	movs	r0, #8
34001db0:	f7ff fee8 	bl	34001b84 <LL_MEM_EnableClock>
  WRITE_REG(RCC->AHB2ENSR, Periphs);
34001db4:	f8c4 9a54 	str.w	r9, [r4, #2644]	@ 0xa54
  tmpreg = READ_REG(RCC->AHB2ENR);
34001db8:	f8d4 3254 	ldr.w	r3, [r4, #596]	@ 0x254
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dbc:	a815      	add	r0, sp, #84	@ 0x54
34001dbe:	9309      	str	r3, [sp, #36]	@ 0x24
  (void)tmpreg;
34001dc0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
34001dc2:	4b8b      	ldr	r3, [pc, #556]	@ (34001ff0 <main+0x338>)
  RAMCFG_HandleTypeDef hramcfg = {0};
34001dc4:	e9cd 5516 	strd	r5, r5, [sp, #88]	@ 0x58
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
34001dc8:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dca:	f007 f8d1 	bl	34008f70 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
34001dce:	4b89      	ldr	r3, [pc, #548]	@ (34001ff4 <main+0x33c>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dd0:	a815      	add	r0, sp, #84	@ 0x54
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
34001dd2:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dd4:	f007 f8cc 	bl	34008f70 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
34001dd8:	4b87      	ldr	r3, [pc, #540]	@ (34001ff8 <main+0x340>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dda:	a815      	add	r0, sp, #84	@ 0x54
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
34001ddc:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dde:	f007 f8c7 	bl	34008f70 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
34001de2:	4b86      	ldr	r3, [pc, #536]	@ (34001ffc <main+0x344>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001de4:	a815      	add	r0, sp, #84	@ 0x54
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
34001de6:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001de8:	f007 f8c2 	bl	34008f70 <HAL_RAMCFG_EnableAXISRAM>
  Fuse_Programming();
34001dec:	f7ff fe4e 	bl	34001a8c <Fuse_Programming>
  npu_cache_init();
34001df0:	f000 fc6c 	bl	340026cc <npu_cache_init>
  npu_cache_enable();
34001df4:	f000 fc74 	bl	340026e0 <npu_cache_enable>
  PC_STREAM_Init();
34001df8:	f000 fc7c 	bl	340026f4 <PC_STREAM_Init>
  BSP_XSPI_RAM_Init(0);
34001dfc:	4628      	mov	r0, r5
34001dfe:	f002 f9ef 	bl	340041e0 <BSP_XSPI_RAM_Init>
  BSP_XSPI_RAM_EnableMemoryMappedMode(0);
34001e02:	4628      	mov	r0, r5
34001e04:	f002 fb10 	bl	34004428 <BSP_XSPI_RAM_EnableMemoryMappedMode>
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34001e08:	f240 1301 	movw	r3, #257	@ 0x101
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34001e0c:	f44f 7800 	mov.w	r8, #512	@ 0x200
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34001e10:	a907      	add	r1, sp, #28
34001e12:	4628      	mov	r0, r5
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001e14:	2602      	movs	r6, #2
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34001e16:	f8ad 301c 	strh.w	r3, [sp, #28]
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34001e1a:	f002 f89d 	bl	34003f58 <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34001e1e:	4628      	mov	r0, r5
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001e20:	2503      	movs	r5, #3
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34001e22:	f002 f807 	bl	34003e34 <BSP_XSPI_NOR_EnableMemoryMappedMode>
34001e26:	f8c4 8a58 	str.w	r8, [r4, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34001e2a:	f8d4 3258 	ldr.w	r3, [r4, #600]	@ 0x258
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34001e2e:	2001      	movs	r0, #1
34001e30:	930b      	str	r3, [sp, #44]	@ 0x2c
34001e32:	a915      	add	r1, sp, #84	@ 0x54
  (void)tmpreg;
34001e34:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001e36:	e9cd 6515 	strd	r6, r5, [sp, #84]	@ 0x54
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34001e3a:	f00d f89d 	bl	3400ef78 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34001e3e:	2008      	movs	r0, #8
34001e40:	a915      	add	r1, sp, #84	@ 0x54
34001e42:	f00d f899 	bl	3400ef78 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34001e46:	2009      	movs	r0, #9
34001e48:	a915      	add	r1, sp, #84	@ 0x54
34001e4a:	f00d f895 	bl	3400ef78 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34001e4e:	200a      	movs	r0, #10
34001e50:	a915      	add	r1, sp, #84	@ 0x54
34001e52:	f00d f891 	bl	3400ef78 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34001e56:	200b      	movs	r0, #11
34001e58:	a915      	add	r1, sp, #84	@ 0x54
34001e5a:	f00d f88d 	bl	3400ef78 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e5e:	4629      	mov	r1, r5
34001e60:	4867      	ldr	r0, [pc, #412]	@ (34002000 <main+0x348>)
34001e62:	f00d f8df 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e66:	4629      	mov	r1, r5
34001e68:	4866      	ldr	r0, [pc, #408]	@ (34002004 <main+0x34c>)
34001e6a:	f00d f8db 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI    , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e6e:	4629      	mov	r1, r5
34001e70:	4865      	ldr	r0, [pc, #404]	@ (34002008 <main+0x350>)
34001e72:	f00d f8d7 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e76:	4629      	mov	r1, r5
34001e78:	4864      	ldr	r0, [pc, #400]	@ (3400200c <main+0x354>)
34001e7a:	f00d f8d3 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e7e:	4629      	mov	r1, r5
34001e80:	4863      	ldr	r0, [pc, #396]	@ (34002010 <main+0x358>)
34001e82:	f00d f8cf 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e86:	4629      	mov	r1, r5
34001e88:	4862      	ldr	r0, [pc, #392]	@ (34002014 <main+0x35c>)
34001e8a:	f00d f8cb 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e8e:	4629      	mov	r1, r5
34001e90:	4861      	ldr	r0, [pc, #388]	@ (34002018 <main+0x360>)
34001e92:	f00d f8c7 	bl	3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34001e96:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34001e9a:	f8c4 3a58 	str.w	r3, [r4, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34001e9e:	f8d4 2258 	ldr.w	r2, [r4, #600]	@ 0x258
  __HAL_RCC_XSPI1_CLK_SLEEP_ENABLE();    /* For display frame buffer */
34001ea2:	2020      	movs	r0, #32
34001ea4:	920c      	str	r2, [sp, #48]	@ 0x30
  (void)tmpreg;
34001ea6:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001ea8:	2204      	movs	r2, #4
  WRITE_REG(RCC->AHB3RSTSR, Periphs);
34001eaa:	f8c4 3a18 	str.w	r3, [r4, #2584]	@ 0xa18
  WRITE_REG(RCC->AHB3RSTCR, Periphs);
34001eae:	f8ca 3218 	str.w	r3, [sl, #536]	@ 0x218
34001eb2:	f7ff fe7f 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_XSPI2_CLK_SLEEP_ENABLE();    /* For NN weights */
34001eb6:	4648      	mov	r0, r9
34001eb8:	f7ff fe7c 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_NPU_CLK_SLEEP_ENABLE();      /* For NN inference */
34001ebc:	4638      	mov	r0, r7
34001ebe:	f7ff fe79 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CACHEAXI_CLK_SLEEP_ENABLE(); /* For NN inference */
34001ec2:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34001ec6:	f7ff fe75 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001eca:	f8c4 6abc 	str.w	r6, [r4, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
34001ece:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE();    /* For display */
34001ed2:	4630      	mov	r0, r6
34001ed4:	930f      	str	r3, [sp, #60]	@ 0x3c
  (void)tmpreg;
34001ed6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
34001ed8:	f7ff fe6c 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001edc:	f8c4 2abc 	str.w	r2, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34001ee0:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  __HAL_RCC_FLEXRAM_MEM_CLK_SLEEP_ENABLE();
34001ee4:	4640      	mov	r0, r8
34001ee6:	930e      	str	r3, [sp, #56]	@ 0x38
  (void)tmpreg;
34001ee8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001eea:	2340      	movs	r3, #64	@ 0x40
34001eec:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34001ef0:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
34001ef4:	930d      	str	r3, [sp, #52]	@ 0x34
  (void)tmpreg;
34001ef6:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
34001ef8:	f7ff fe50 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM1_MEM_CLK_SLEEP_ENABLE();
34001efc:	2080      	movs	r0, #128	@ 0x80
34001efe:	f7ff fe4d 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM2_MEM_CLK_SLEEP_ENABLE();
34001f02:	f44f 7080 	mov.w	r0, #256	@ 0x100
34001f06:	f7ff fe49 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM3_MEM_CLK_SLEEP_ENABLE();
34001f0a:	2001      	movs	r0, #1
34001f0c:	f7ff fe46 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM4_MEM_CLK_SLEEP_ENABLE();
34001f10:	4630      	mov	r0, r6
34001f12:	f7ff fe43 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM5_MEM_CLK_SLEEP_ENABLE();
34001f16:	4610      	mov	r0, r2
34001f18:	f7ff fe40 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM6_MEM_CLK_SLEEP_ENABLE(); 
34001f1c:	2008      	movs	r0, #8
34001f1e:	f7ff fe3d 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_Default();
34001f22:	f000 fbc7 	bl	340026b4 <LL_ATON_Input_Buffers_Info_Default>
34001f26:	4604      	mov	r4, r0
  const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_Default();
34001f28:	f000 fbc8 	bl	340026bc <LL_ATON_Output_Buffers_Info_Default>
34001f2c:	6861      	ldr	r1, [r4, #4]
34001f2e:	4602      	mov	r2, r0
    return eb->blob_address;
  }

  static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
  {
    if (buf->is_user_allocated)
34001f30:	7d20      	ldrb	r0, [r4, #20]
    {
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
      return *tmp;
    }
    return buf->addr_base.p;
34001f32:	460b      	mov	r3, r1
    if (buf->is_user_allocated)
34001f34:	b100      	cbz	r0, 34001f38 <main+0x280>
      return *tmp;
34001f36:	680b      	ldr	r3, [r1, #0]
  int number_output = 0;
34001f38:	f04f 0900 	mov.w	r9, #0
34001f3c:	2538      	movs	r5, #56	@ 0x38
  }

  static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
  {
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34001f3e:	68a0      	ldr	r0, [r4, #8]
  nn_in = (uint8_t *) LL_Buffer_addr_start(&nn_in_info[0]);
34001f40:	4936      	ldr	r1, [pc, #216]	@ (3400201c <main+0x364>)
34001f42:	4403      	add	r3, r0
34001f44:	600b      	str	r3, [r1, #0]
  while (nn_out_info[number_output].name != NULL)
34001f46:	fb05 f309 	mul.w	r3, r5, r9
34001f4a:	58d1      	ldr	r1, [r2, r3]
34001f4c:	2900      	cmp	r1, #0
34001f4e:	f040 8105 	bne.w	3400215c <main+0x4a4>
  assert(number_output <= MAX_NUMBER_OUTPUT);
34001f52:	f1b9 0f05 	cmp.w	r9, #5
34001f56:	f300 8104 	bgt.w	34002162 <main+0x4aa>
34001f5a:	4931      	ldr	r1, [pc, #196]	@ (34002020 <main+0x368>)
34001f5c:	08db      	lsrs	r3, r3, #3
34001f5e:	434b      	muls	r3, r1
34001f60:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
34001f64:	ad10      	add	r5, sp, #64	@ 0x40
34001f66:	ae15      	add	r6, sp, #84	@ 0x54
34001f68:	3301      	adds	r3, #1
  for (int i = 0; i < number_output; i++)
34001f6a:	3b01      	subs	r3, #1
34001f6c:	f040 80ff 	bne.w	3400216e <main+0x4b6>
  uint32_t pitch_nn = 0;
34001f70:	2500      	movs	r5, #0
    return LL_Buffer_addr_base(buf) + buf->offset_limit;
  }

  static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
  {
    return buf->offset_end - buf->offset_start;
34001f72:	68e3      	ldr	r3, [r4, #12]
  CAM_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
34001f74:	4c2b      	ldr	r4, [pc, #172]	@ (34002024 <main+0x36c>)
34001f76:	1a1b      	subs	r3, r3, r0
  app_postprocess_init(&pp_params);
34001f78:	482b      	ldr	r0, [pc, #172]	@ (34002028 <main+0x370>)
34001f7a:	9303      	str	r3, [sp, #12]
  uint32_t pitch_nn = 0;
34001f7c:	9508      	str	r5, [sp, #32]
  app_postprocess_init(&pp_params);
34001f7e:	f7ff fdb3 	bl	34001ae8 <app_postprocess_init>
  CAM_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
34001f82:	4621      	mov	r1, r4
34001f84:	aa08      	add	r2, sp, #32
34001f86:	1f20      	subs	r0, r4, #4
34001f88:	f7ff fce6 	bl	34001958 <CAM_Init>
  LayerConfig.X0          = lcd_bg_area.X0;
34001f8c:	f1a4 080c 	sub.w	r8, r4, #12
  BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
34001f90:	2101      	movs	r1, #1
34001f92:	4628      	mov	r0, r5
34001f94:	f001 fe5c 	bl	34003c50 <BSP_LCD_Init>
  LayerConfig.X0          = lcd_bg_area.X0;
34001f98:	f854 1c0c 	ldr.w	r1, [r4, #-12]
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34001f9c:	f8d8 3008 	ldr.w	r3, [r8, #8]
  LayerConfig.X0          = lcd_bg_area.X0;
34001fa0:	4c22      	ldr	r4, [pc, #136]	@ (3400202c <main+0x374>)
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34001fa2:	440b      	add	r3, r1
  LayerConfig.Y0          = lcd_bg_area.Y0;
34001fa4:	f8d8 2004 	ldr.w	r2, [r8, #4]
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34001fa8:	6063      	str	r3, [r4, #4]
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34001faa:	f8d8 300c 	ldr.w	r3, [r8, #12]
  LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34001fae:	4e20      	ldr	r6, [pc, #128]	@ (34002030 <main+0x378>)
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34001fb0:	4413      	add	r3, r2
34001fb2:	60e3      	str	r3, [r4, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34001fb4:	2302      	movs	r3, #2
  LayerConfig.X0          = lcd_bg_area.X0;
34001fb6:	6021      	str	r1, [r4, #0]
  LayerConfig.Y0          = lcd_bg_area.Y0;
34001fb8:	60a2      	str	r2, [r4, #8]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34001fba:	4629      	mov	r1, r5
34001fbc:	4622      	mov	r2, r4
34001fbe:	4628      	mov	r0, r5
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34001fc0:	6123      	str	r3, [r4, #16]
  LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34001fc2:	6166      	str	r6, [r4, #20]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34001fc4:	f001 fe50 	bl	34003c68 <BSP_LCD_ConfigLayer>
  LayerConfig.X0 = lcd_fg_area.X0;
34001fc8:	4b1a      	ldr	r3, [pc, #104]	@ (34002034 <main+0x37c>)
34001fca:	6818      	ldr	r0, [r3, #0]
  LayerConfig.Y0 = lcd_fg_area.Y0;
34001fcc:	6859      	ldr	r1, [r3, #4]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34001fce:	689a      	ldr	r2, [r3, #8]
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34001fd0:	68db      	ldr	r3, [r3, #12]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34001fd2:	4402      	add	r2, r0
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34001fd4:	440b      	add	r3, r1
34001fd6:	60e3      	str	r3, [r4, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34001fd8:	2304      	movs	r3, #4
34001fda:	6123      	str	r3, [r4, #16]
  LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
34001fdc:	4b16      	ldr	r3, [pc, #88]	@ (34002038 <main+0x380>)
  LayerConfig.X0 = lcd_fg_area.X0;
34001fde:	6020      	str	r0, [r4, #0]
34001fe0:	e02e      	b.n	34002040 <main+0x388>
34001fe2:	bf00      	nop
34001fe4:	e001e000 	.word	0xe001e000
34001fe8:	56028000 	.word	0x56028000
34001fec:	e000ed00 	.word	0xe000ed00
34001ff0:	52023100 	.word	0x52023100
34001ff4:	52023180 	.word	0x52023180
34001ff8:	52023200 	.word	0x52023200
34001ffc:	52023280 	.word	0x52023280
34002000:	3000000a 	.word	0x3000000a
34002004:	30000005 	.word	0x30000005
34002008:	2000001c 	.word	0x2000001c
3400200c:	2000001d 	.word	0x2000001d
34002010:	30000006 	.word	0x30000006
34002014:	30000007 	.word	0x30000007
34002018:	30000008 	.word	0x30000008
3400201c:	3403f314 	.word	0x3403f314
34002020:	16db6db7 	.word	0x16db6db7
34002024:	3403ec98 	.word	0x3403ec98
34002028:	3403f31c 	.word	0x3403f31c
3400202c:	3403f2fc 	.word	0x3403f2fc
34002030:	91177000 	.word	0x91177000
34002034:	3403ec7c 	.word	0x3403ec7c
34002038:	91000000 	.word	0x91000000
3400203c:	56029000 	.word	0x56029000
  LayerConfig.Y0 = lcd_fg_area.Y0;
34002040:	60a1      	str	r1, [r4, #8]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34002042:	6062      	str	r2, [r4, #4]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
34002044:	2101      	movs	r1, #1
34002046:	4622      	mov	r2, r4
34002048:	4628      	mov	r0, r5
  LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
3400204a:	6163      	str	r3, [r4, #20]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
3400204c:	f001 fe0c 	bl	34003c68 <BSP_LCD_ConfigLayer>
  UTIL_LCD_SetFuncDriver(&LCD_Driver);
34002050:	48a2      	ldr	r0, [pc, #648]	@ (340022dc <main+0x624>)
34002052:	f013 f853 	bl	340150fc <UTIL_LCD_SetFuncDriver>
  UTIL_LCD_SetLayer(LTDC_LAYER_2);
34002056:	2001      	movs	r0, #1
34002058:	f013 f880 	bl	3401515c <UTIL_LCD_SetLayer>
  UTIL_LCD_Clear(0x00000000);
3400205c:	4628      	mov	r0, r5
3400205e:	f013 fae7 	bl	34015630 <UTIL_LCD_Clear>
  UTIL_LCD_SetFont(&Font20);
34002062:	489f      	ldr	r0, [pc, #636]	@ (340022e0 <main+0x628>)
34002064:	f013 f8b0 	bl	340151c8 <UTIL_LCD_SetFont>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
34002068:	f04f 30ff 	mov.w	r0, #4294967295
3400206c:	f013 f89c 	bl	340151a8 <UTIL_LCD_SetTextColor>
  CAM_DisplayPipe_Start(lcd_bg_buffer, CMW_MODE_CONTINUOUS);
34002070:	4629      	mov	r1, r5
34002072:	4630      	mov	r0, r6
34002074:	f7ff fcc4 	bl	34001a00 <CAM_DisplayPipe_Start>
    CAM_IspUpdate();
34002078:	f7ff fcea 	bl	34001a50 <CAM_IspUpdate>
    if (pitch_nn != (NN_WIDTH * NN_BPP))
3400207c:	9b08      	ldr	r3, [sp, #32]
      CAM_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
3400207e:	2104      	movs	r1, #4
    if (pitch_nn != (NN_WIDTH * NN_BPP))
34002080:	f5b3 7f28 	cmp.w	r3, #672	@ 0x2a0
      CAM_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
34002084:	bf14      	ite	ne
34002086:	4b97      	ldrne	r3, [pc, #604]	@ (340022e4 <main+0x62c>)
      CAM_NNPipe_Start(nn_in, CMW_MODE_SNAPSHOT);
34002088:	4b97      	ldreq	r3, [pc, #604]	@ (340022e8 <main+0x630>)
3400208a:	6818      	ldr	r0, [r3, #0]
3400208c:	f7ff fccc 	bl	34001a28 <CAM_NNPipe_Start>
    while (cameraFrameReceived == 0) {};
34002090:	4b96      	ldr	r3, [pc, #600]	@ (340022ec <main+0x634>)
34002092:	681a      	ldr	r2, [r3, #0]
34002094:	2a00      	cmp	r2, #0
34002096:	d0fc      	beq.n	34002092 <main+0x3da>
    cameraFrameReceived = 0;
34002098:	2200      	movs	r2, #0
3400209a:	601a      	str	r2, [r3, #0]
    if (pitch_nn != (NN_WIDTH * NN_BPP))
3400209c:	9b08      	ldr	r3, [sp, #32]
3400209e:	f5b3 7f28 	cmp.w	r3, #672	@ 0x2a0
340020a2:	d044      	beq.n	3400212e <main+0x476>
      SCB_InvalidateDCache_by_Addr(dcmipp_out_nn, sizeof(dcmipp_out_nn));
340020a4:	488f      	ldr	r0, [pc, #572]	@ (340022e4 <main+0x62c>)
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340020a6:	6801      	ldr	r1, [r0, #0]
340020a8:	f001 021f 	and.w	r2, r1, #31
  __ASM volatile ("dsb 0xF":::"memory");
340020ac:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;

      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340020b0:	1cd3      	adds	r3, r2, #3
340020b2:	3a1c      	subs	r2, #28
340020b4:	095b      	lsrs	r3, r3, #5
340020b6:	3220      	adds	r2, #32
340020b8:	f103 0e01 	add.w	lr, r3, #1
340020bc:	bfd8      	it	le
340020be:	f04f 0e01 	movle.w	lr, #1
340020c2:	f04e e001 	dls	lr, lr
340020c6:	4c8a      	ldr	r4, [pc, #552]	@ (340022f0 <main+0x638>)
340020c8:	f8c4 125c 	str.w	r1, [r4, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
340020cc:	3120      	adds	r1, #32
        op_size -= __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
340020ce:	f00f c805 	le	lr, 340020c8 <main+0x410>
340020d2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340020d6:	f3bf 8f6f 	isb	sy
      img_crop(dcmipp_out_nn, nn_in, pitch_nn, NN_WIDTH, NN_HEIGHT, NN_BPP);
340020da:	23e0      	movs	r3, #224	@ 0xe0
340020dc:	2203      	movs	r2, #3
340020de:	e9cd 3200 	strd	r3, r2, [sp]
340020e2:	4c81      	ldr	r4, [pc, #516]	@ (340022e8 <main+0x630>)
340020e4:	9a08      	ldr	r2, [sp, #32]
340020e6:	6821      	ldr	r1, [r4, #0]
340020e8:	6800      	ldr	r0, [r0, #0]
340020ea:	f7ff fd31 	bl	34001b50 <img_crop>
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
340020ee:	9a03      	ldr	r2, [sp, #12]
      SCB_CleanInvalidateDCache_by_Addr(nn_in, nn_in_len);
340020f0:	6823      	ldr	r3, [r4, #0]
340020f2:	2a00      	cmp	r2, #0
340020f4:	dd1b      	ble.n	3400212e <main+0x476>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340020f6:	f003 011f 	and.w	r1, r3, #31
340020fa:	4411      	add	r1, r2
  __ASM volatile ("dsb 0xF":::"memory");
340020fc:	f3bf 8f4f 	dsb	sy

      do {
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
        op_size -=          __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
34002100:	43da      	mvns	r2, r3
34002102:	185c      	adds	r4, r3, r1
34002104:	4422      	add	r2, r4
34002106:	3920      	subs	r1, #32
34002108:	0952      	lsrs	r2, r2, #5
3400210a:	3120      	adds	r1, #32
3400210c:	f102 0e01 	add.w	lr, r2, #1
34002110:	bfd8      	it	le
34002112:	f04f 0e01 	movle.w	lr, #1
34002116:	f04e e001 	dls	lr, lr
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400211a:	4875      	ldr	r0, [pc, #468]	@ (340022f0 <main+0x638>)
3400211c:	f8c0 3270 	str.w	r3, [r0, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
34002120:	3320      	adds	r3, #32
      } while ( op_size > 0 );
34002122:	f00f c805 	le	lr, 3400211c <main+0x464>
34002126:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400212a:	f3bf 8f6f 	isb	sy
    ts[0] = HAL_GetTick();
3400212e:	f002 fb6d 	bl	3400480c <HAL_GetTick>
34002132:	4605      	mov	r5, r0
    LL_ATON_RT_Main(&NN_Instance_Default);
34002134:	486f      	ldr	r0, [pc, #444]	@ (340022f4 <main+0x63c>)
34002136:	f014 f82b 	bl	34016190 <LL_ATON_RT_Main>
    ts[1] = HAL_GetTick();
3400213a:	f002 fb67 	bl	3400480c <HAL_GetTick>
    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
3400213e:	4c6e      	ldr	r4, [pc, #440]	@ (340022f8 <main+0x640>)
    ts[1] = HAL_GetTick();
34002140:	4606      	mov	r6, r0
    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
34002142:	4622      	mov	r2, r4
34002144:	4649      	mov	r1, r9
34002146:	4b6d      	ldr	r3, [pc, #436]	@ (340022fc <main+0x644>)
34002148:	a810      	add	r0, sp, #64	@ 0x40
3400214a:	f7ff fce7 	bl	34001b1c <app_postprocess_run>
    assert(ret == 0);
3400214e:	4607      	mov	r7, r0
34002150:	b1e0      	cbz	r0, 3400218c <main+0x4d4>
34002152:	f240 1107 	movw	r1, #263	@ 0x107
34002156:	4b6a      	ldr	r3, [pc, #424]	@ (34002300 <main+0x648>)
34002158:	4a6a      	ldr	r2, [pc, #424]	@ (34002304 <main+0x64c>)
3400215a:	e005      	b.n	34002168 <main+0x4b0>
    number_output++;
3400215c:	f109 0901 	add.w	r9, r9, #1
34002160:	e6f1      	b.n	34001f46 <main+0x28e>
  assert(number_output <= MAX_NUMBER_OUTPUT);
34002162:	21cc      	movs	r1, #204	@ 0xcc
34002164:	4b68      	ldr	r3, [pc, #416]	@ (34002308 <main+0x650>)
34002166:	4a67      	ldr	r2, [pc, #412]	@ (34002304 <main+0x64c>)
    assert(ret == 0);
34002168:	4868      	ldr	r0, [pc, #416]	@ (3400230c <main+0x654>)
3400216a:	f015 fba5 	bl	340178b8 <__assert_func>
    if (buf->is_user_allocated)
3400216e:	7d17      	ldrb	r7, [r2, #20]
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
34002170:	6851      	ldr	r1, [r2, #4]
    if (buf->is_user_allocated)
34002172:	b107      	cbz	r7, 34002176 <main+0x4be>
      return *tmp;
34002174:	6809      	ldr	r1, [r1, #0]
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34002176:	6897      	ldr	r7, [r2, #8]
34002178:	3238      	adds	r2, #56	@ 0x38
3400217a:	4439      	add	r1, r7
    nn_out[i] = (float32_t *) LL_Buffer_addr_start(&nn_out_info[i]);
3400217c:	f845 1b04 	str.w	r1, [r5], #4
    return buf->offset_end - buf->offset_start;
34002180:	f852 1c2c 	ldr.w	r1, [r2, #-44]
34002184:	1bc9      	subs	r1, r1, r7
    nn_out_len[i] = LL_Buffer_len(&nn_out_info[i]);
34002186:	f846 1b04 	str.w	r1, [r6], #4
  for (int i = 0; i < number_output; i++)
3400218a:	e6ee      	b.n	34001f6a <main+0x2b2>
    Display_NetworkOutput(&pp_output, ts[1] - ts[0]);
3400218c:	1b73      	subs	r3, r6, r5
3400218e:	9305      	str	r3, [sp, #20]
  uint32_t nb_rois = p_postprocess->nb_detect;
34002190:	e9d4 5300 	ldrd	r5, r3, [r4]
34002194:	9304      	str	r3, [sp, #16]
  ret = HAL_LTDC_SetAddress_NoReload(&hlcd_ltdc, (uint32_t) lcd_fg_buffer[lcd_fg_buffer_rd_idx], LTDC_LAYER_2);
34002196:	4b5e      	ldr	r3, [pc, #376]	@ (34002310 <main+0x658>)
34002198:	485e      	ldr	r0, [pc, #376]	@ (34002314 <main+0x65c>)
3400219a:	6819      	ldr	r1, [r3, #0]
3400219c:	4b5e      	ldr	r3, [pc, #376]	@ (34002318 <main+0x660>)
3400219e:	2201      	movs	r2, #1
340021a0:	fb00 3101 	mla	r1, r0, r1, r3
340021a4:	485d      	ldr	r0, [pc, #372]	@ (3400231c <main+0x664>)
340021a6:	f006 fe51 	bl	34008e4c <HAL_LTDC_SetAddress_NoReload>
  assert(ret == HAL_OK);
340021aa:	b120      	cbz	r0, 340021b6 <main+0x4fe>
340021ac:	f240 117d 	movw	r1, #381	@ 0x17d
340021b0:	4b5b      	ldr	r3, [pc, #364]	@ (34002320 <main+0x668>)
340021b2:	4a5c      	ldr	r2, [pc, #368]	@ (34002324 <main+0x66c>)
340021b4:	e7d8      	b.n	34002168 <main+0x4b0>
  UTIL_LCD_FillRect(lcd_fg_area.X0, lcd_fg_area.Y0, lcd_fg_area.XSize, lcd_fg_area.YSize, 0x00000000); /* Clear previous boxes */
340021b6:	485c      	ldr	r0, [pc, #368]	@ (34002328 <main+0x670>)
340021b8:	9700      	str	r7, [sp, #0]
340021ba:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
340021be:	e9d0 0100 	ldrd	r0, r1, [r0]
340021c2:	f013 f9f5 	bl	340155b0 <UTIL_LCD_FillRect>
  for (int32_t i = 0; i < nb_rois; i++)
340021c6:	46ba      	mov	sl, r7
340021c8:	9b04      	ldr	r3, [sp, #16]
340021ca:	4553      	cmp	r3, sl
340021cc:	f040 80bc 	bne.w	34002348 <main+0x690>
  UTIL_LCD_SetBackColor(0x40000000);
340021d0:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
340021d4:	f012 fff0 	bl	340151b8 <UTIL_LCD_SetBackColor>
  UTIL_LCDEx_PrintfAt(0, LINE(2), CENTER_MODE, "Objects %u", nb_rois);
340021d8:	f012 fffe 	bl	340151d8 <UTIL_LCD_GetFont>
340021dc:	2201      	movs	r2, #1
340021de:	88c1      	ldrh	r1, [r0, #6]
340021e0:	9b04      	ldr	r3, [sp, #16]
340021e2:	4091      	lsls	r1, r2
340021e4:	2000      	movs	r0, #0
340021e6:	9300      	str	r3, [sp, #0]
340021e8:	4b50      	ldr	r3, [pc, #320]	@ (3400232c <main+0x674>)
340021ea:	f000 fadf 	bl	340027ac <UTIL_LCDEx_PrintfAt>
  UTIL_LCDEx_PrintfAt(0, LINE(20), CENTER_MODE, "Inference: %ums", inference_ms);
340021ee:	f012 fff3 	bl	340151d8 <UTIL_LCD_GetFont>
340021f2:	88c1      	ldrh	r1, [r0, #6]
340021f4:	2014      	movs	r0, #20
340021f6:	9b05      	ldr	r3, [sp, #20]
340021f8:	4341      	muls	r1, r0
340021fa:	2201      	movs	r2, #1
340021fc:	2000      	movs	r0, #0
340021fe:	9300      	str	r3, [sp, #0]
  if (t0 == 0)
34002200:	4c4b      	ldr	r4, [pc, #300]	@ (34002330 <main+0x678>)
  UTIL_LCDEx_PrintfAt(0, LINE(20), CENTER_MODE, "Inference: %ums", inference_ms);
34002202:	4b4c      	ldr	r3, [pc, #304]	@ (34002334 <main+0x67c>)
34002204:	f000 fad2 	bl	340027ac <UTIL_LCDEx_PrintfAt>
  UTIL_LCD_SetBackColor(0);
34002208:	2000      	movs	r0, #0
3400220a:	f012 ffd5 	bl	340151b8 <UTIL_LCD_SetBackColor>
  if (t0 == 0)
3400220e:	6823      	ldr	r3, [r4, #0]
34002210:	b913      	cbnz	r3, 34002218 <main+0x560>
    t0 = HAL_GetTick();
34002212:	f002 fafb 	bl	3400480c <HAL_GetTick>
34002216:	6020      	str	r0, [r4, #0]
  if (HAL_GetTick() - t0 < 4000)
34002218:	f002 faf8 	bl	3400480c <HAL_GetTick>
3400221c:	6823      	ldr	r3, [r4, #0]
3400221e:	1ac0      	subs	r0, r0, r3
34002220:	f5b0 6f7a 	cmp.w	r0, #4000	@ 0xfa0
34002224:	d22c      	bcs.n	34002280 <main+0x5c8>
    UTIL_LCD_FillRGBRect(300, 100, (uint8_t *) stlogo, 200, 107);
34002226:	236b      	movs	r3, #107	@ 0x6b
34002228:	2164      	movs	r1, #100	@ 0x64
3400222a:	4a43      	ldr	r2, [pc, #268]	@ (34002338 <main+0x680>)
3400222c:	f44f 7096 	mov.w	r0, #300	@ 0x12c
34002230:	9300      	str	r3, [sp, #0]
34002232:	23c8      	movs	r3, #200	@ 0xc8
34002234:	f012 ffd8 	bl	340151e8 <UTIL_LCD_FillRGBRect>
    UTIL_LCD_SetBackColor(0x40000000);
34002238:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3400223c:	f012 ffbc 	bl	340151b8 <UTIL_LCD_SetBackColor>
    UTIL_LCDEx_PrintfAt(0, LINE(16), CENTER_MODE, "Object detection");
34002240:	f012 ffca 	bl	340151d8 <UTIL_LCD_GetFont>
34002244:	88c1      	ldrh	r1, [r0, #6]
34002246:	2201      	movs	r2, #1
34002248:	4b3c      	ldr	r3, [pc, #240]	@ (3400233c <main+0x684>)
3400224a:	0109      	lsls	r1, r1, #4
3400224c:	2000      	movs	r0, #0
3400224e:	f000 faad 	bl	340027ac <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, LINE(17), CENTER_MODE, WELCOME_MSG_1);
34002252:	f012 ffc1 	bl	340151d8 <UTIL_LCD_GetFont>
34002256:	88c1      	ldrh	r1, [r0, #6]
34002258:	2201      	movs	r2, #1
3400225a:	4b39      	ldr	r3, [pc, #228]	@ (34002340 <main+0x688>)
3400225c:	eb01 1101 	add.w	r1, r1, r1, lsl #4
34002260:	2000      	movs	r0, #0
34002262:	f000 faa3 	bl	340027ac <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, LINE(18), CENTER_MODE, WELCOME_MSG_2);
34002266:	f012 ffb7 	bl	340151d8 <UTIL_LCD_GetFont>
3400226a:	88c1      	ldrh	r1, [r0, #6]
3400226c:	2012      	movs	r0, #18
3400226e:	2201      	movs	r2, #1
34002270:	4341      	muls	r1, r0
34002272:	4b34      	ldr	r3, [pc, #208]	@ (34002344 <main+0x68c>)
34002274:	2000      	movs	r0, #0
34002276:	f000 fa99 	bl	340027ac <UTIL_LCDEx_PrintfAt>
    UTIL_LCD_SetBackColor(0);
3400227a:	2000      	movs	r0, #0
3400227c:	f012 ff9c 	bl	340151b8 <UTIL_LCD_SetBackColor>
  PC_STREAM_SendFrame(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_WIDTH, LCD_FG_HEIGHT, 2);
34002280:	4d23      	ldr	r5, [pc, #140]	@ (34002310 <main+0x658>)
34002282:	4e24      	ldr	r6, [pc, #144]	@ (34002314 <main+0x65c>)
34002284:	6828      	ldr	r0, [r5, #0]
34002286:	4c24      	ldr	r4, [pc, #144]	@ (34002318 <main+0x660>)
34002288:	2302      	movs	r3, #2
3400228a:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
3400228e:	f44f 7148 	mov.w	r1, #800	@ 0x320
34002292:	fb06 4000 	mla	r0, r6, r0, r4
34002296:	f000 fa33 	bl	34002700 <PC_STREAM_SendFrame>
  SCB_CleanDCache_by_Addr(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_FRAMEBUFFER_SIZE);
3400229a:	682b      	ldr	r3, [r5, #0]
3400229c:	fb06 4303 	mla	r3, r6, r3, r4
  __ASM volatile ("dsb 0xF":::"memory");
340022a0:	f3bf 8f4f 	dsb	sy
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340022a4:	f645 5ec0 	movw	lr, #24000	@ 0x5dc0
340022a8:	f04e e001 	dls	lr, lr
340022ac:	4a10      	ldr	r2, [pc, #64]	@ (340022f0 <main+0x638>)
340022ae:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340022b2:	3320      	adds	r3, #32
      } while ( op_size > 0 );
340022b4:	f00f c805 	le	lr, 340022ae <main+0x5f6>
340022b8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340022bc:	f3bf 8f6f 	isb	sy
  ret = HAL_LTDC_ReloadLayer(&hlcd_ltdc, LTDC_RELOAD_VERTICAL_BLANKING, LTDC_LAYER_2);
340022c0:	2201      	movs	r2, #1
340022c2:	2102      	movs	r1, #2
340022c4:	4815      	ldr	r0, [pc, #84]	@ (3400231c <main+0x664>)
340022c6:	f006 fd99 	bl	34008dfc <HAL_LTDC_ReloadLayer>
  assert(ret == HAL_OK);
340022ca:	2800      	cmp	r0, #0
340022cc:	f000 80bb 	beq.w	34002446 <main+0x78e>
340022d0:	f240 119f 	movw	r1, #415	@ 0x19f
340022d4:	4b12      	ldr	r3, [pc, #72]	@ (34002320 <main+0x668>)
340022d6:	4a13      	ldr	r2, [pc, #76]	@ (34002324 <main+0x66c>)
340022d8:	e746      	b.n	34002168 <main+0x4b0>
340022da:	bf00      	nop
340022dc:	34034eac 	.word	0x34034eac
340022e0:	3403edc8 	.word	0x3403edc8
340022e4:	3403f2f0 	.word	0x3403f2f0
340022e8:	3403f314 	.word	0x3403f314
340022ec:	3403f318 	.word	0x3403f318
340022f0:	e000ed00 	.word	0xe000ed00
340022f4:	3403ec4c 	.word	0x3403ec4c
340022f8:	3403f2f4 	.word	0x3403f2f4
340022fc:	3403f31c 	.word	0x3403f31c
34002300:	3401be43 	.word	0x3401be43
34002304:	3401e834 	.word	0x3401e834
34002308:	3401bdec 	.word	0x3401bdec
3400230c:	3401be0f 	.word	0x3401be0f
34002310:	3403f2ec 	.word	0x3403f2ec
34002314:	000bb800 	.word	0x000bb800
34002318:	91000000 	.word	0x91000000
3400231c:	34043b24 	.word	0x34043b24
34002320:	3401bd91 	.word	0x3401bd91
34002324:	3401e7f0 	.word	0x3401e7f0
34002328:	3403ec7c 	.word	0x3403ec7c
3400232c:	3401be53 	.word	0x3401be53
34002330:	3403f2e8 	.word	0x3403f2e8
34002334:	3401be5e 	.word	0x3401be5e
34002338:	3401e864 	.word	0x3401e864
3400233c:	3401be6e 	.word	0x3401be6e
34002340:	3401be7f 	.word	0x3401be7f
34002344:	3401bea2 	.word	0x3401bea2
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
34002348:	edd5 6a02 	vldr	s13, [r5, #8]
3400234c:	edd5 7a00 	vldr	s15, [r5]
34002350:	ed98 7a02 	vldr	s14, [r8, #8]
34002354:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
34002358:	eef8 5a47 	vcvt.f32.u32	s11, s14
3400235c:	eee6 7ac6 	vfms.f32	s15, s13, s12
34002360:	ee67 7aa5 	vmul.f32	s15, s15, s11
34002364:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002368:	ed95 7a01 	vldr	s14, [r5, #4]
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
3400236c:	ee17 4a90 	vmov	r4, s15
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002370:	edd5 7a03 	vldr	s15, [r5, #12]
34002374:	eea7 7ac6 	vfms.f32	s14, s15, s12
34002378:	ed98 6a03 	vldr	s12, [r8, #12]
3400237c:	eeb8 6a46 	vcvt.f32.u32	s12, s12
34002380:	ee27 7a06 	vmul.f32	s14, s14, s12
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002384:	ee66 6aa5 	vmul.f32	s13, s13, s11
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002388:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
3400238c:	ee67 7a86 	vmul.f32	s15, s15, s12
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002390:	ee17 ba10 	vmov	fp, s14
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002394:	eebc 7ae6 	vcvt.u32.f32	s14, s13
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
34002398:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
3400239c:	f8d8 0000 	ldr.w	r0, [r8]
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023a0:	f8d8 3008 	ldr.w	r3, [r8, #8]
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
340023a4:	4404      	add	r4, r0
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023a6:	f8d8 2004 	ldr.w	r2, [r8, #4]
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023aa:	4418      	add	r0, r3
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023ac:	f8d8 300c 	ldr.w	r3, [r8, #12]
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023b0:	f100 3eff 	add.w	lr, r0, #4294967295
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023b4:	441a      	add	r2, r3
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023b6:	4284      	cmp	r4, r0
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
340023b8:	ee17 6a10 	vmov	r6, s14
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023bc:	bf28      	it	cs
340023be:	4674      	movcs	r4, lr
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023c0:	f102 3cff 	add.w	ip, r2, #4294967295
340023c4:	4593      	cmp	fp, r2
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
340023c6:	ee17 1a90 	vmov	r1, s15
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023ca:	bf28      	it	cs
340023cc:	46e3      	movcs	fp, ip
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
340023ce:	1933      	adds	r3, r6, r4
340023d0:	4298      	cmp	r0, r3
340023d2:	ebae 0e04 	sub.w	lr, lr, r4
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
340023d6:	eb01 000b 	add.w	r0, r1, fp
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
340023da:	bf98      	it	ls
340023dc:	4676      	movls	r6, lr
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
340023de:	4282      	cmp	r2, r0
    UTIL_LCD_DrawRect(x0, y0, width, height, colors[rois[i].class_index % NUMBER_COLORS]);
340023e0:	f04f 000a 	mov.w	r0, #10
340023e4:	696a      	ldr	r2, [r5, #20]
340023e6:	4b2e      	ldr	r3, [pc, #184]	@ (340024a0 <main+0x7e8>)
340023e8:	fb92 fef0 	sdiv	lr, r2, r0
340023ec:	fb00 221e 	mls	r2, r0, lr, r2
340023f0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
340023f4:	ebac 0c0b 	sub.w	ip, ip, fp
    UTIL_LCD_DrawRect(x0, y0, width, height, colors[rois[i].class_index % NUMBER_COLORS]);
340023f8:	bf8c      	ite	hi
340023fa:	460b      	movhi	r3, r1
340023fc:	4663      	movls	r3, ip
340023fe:	4659      	mov	r1, fp
34002400:	4620      	mov	r0, r4
34002402:	9200      	str	r2, [sp, #0]
34002404:	4632      	mov	r2, r6
34002406:	f013 f8b1 	bl	3401556c <UTIL_LCD_DrawRect>
    UTIL_LCDEx_PrintfAt(x0, y0, LEFT_MODE, classes_table[rois[i].class_index]);
3400240a:	696a      	ldr	r2, [r5, #20]
3400240c:	4b25      	ldr	r3, [pc, #148]	@ (340024a4 <main+0x7ec>)
3400240e:	4659      	mov	r1, fp
34002410:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34002414:	4620      	mov	r0, r4
34002416:	2203      	movs	r2, #3
34002418:	f000 f9c8 	bl	340027ac <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(-x0-width, y0, RIGHT_MODE, "%.0f%%", rois[i].conf*100.0f);
3400241c:	ed95 7a04 	vldr	s14, [r5, #16]
34002420:	eddf 7a21 	vldr	s15, [pc, #132]	@ 340024a8 <main+0x7f0>
34002424:	ee27 7a27 	vmul.f32	s14, s14, s15
34002428:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400242c:	19a0      	adds	r0, r4, r6
3400242e:	ed8d 7b00 	vstr	d7, [sp]
34002432:	2202      	movs	r2, #2
34002434:	4659      	mov	r1, fp
34002436:	4b1d      	ldr	r3, [pc, #116]	@ (340024ac <main+0x7f4>)
34002438:	4240      	negs	r0, r0
3400243a:	f000 f9b7 	bl	340027ac <UTIL_LCDEx_PrintfAt>
  for (int32_t i = 0; i < nb_rois; i++)
3400243e:	f10a 0a01 	add.w	sl, sl, #1
34002442:	3518      	adds	r5, #24
34002444:	e6c0      	b.n	340021c8 <main+0x510>
  lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
34002446:	682b      	ldr	r3, [r5, #0]
}
34002448:	a815      	add	r0, sp, #84	@ 0x54
  lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
3400244a:	f1c3 0301 	rsb	r3, r3, #1
3400244e:	602b      	str	r3, [r5, #0]
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002450:	4d17      	ldr	r5, [pc, #92]	@ (340024b0 <main+0x7f8>)
      float32_t *tmp = nn_out[i];
34002452:	ac10      	add	r4, sp, #64	@ 0x40
    for (int i = 0; i < number_output; i++)
34002454:	45b9      	cmp	r9, r7
34002456:	f43f ae0f 	beq.w	34002078 <main+0x3c0>
      SCB_InvalidateDCache_by_Addr(tmp, nn_out_len[i]);
3400245a:	f850 2b04 	ldr.w	r2, [r0], #4
    if ( dsize > 0 ) {
3400245e:	2a00      	cmp	r2, #0
34002460:	dd1c      	ble.n	3400249c <main+0x7e4>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002462:	f854 3027 	ldr.w	r3, [r4, r7, lsl #2]
34002466:	f003 011f 	and.w	r1, r3, #31
3400246a:	4411      	add	r1, r2
  __ASM volatile ("dsb 0xF":::"memory");
3400246c:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002470:	43da      	mvns	r2, r3
34002472:	185e      	adds	r6, r3, r1
34002474:	4432      	add	r2, r6
34002476:	3920      	subs	r1, #32
34002478:	0952      	lsrs	r2, r2, #5
3400247a:	3120      	adds	r1, #32
3400247c:	f102 0e01 	add.w	lr, r2, #1
34002480:	bfd8      	it	le
34002482:	f04f 0e01 	movle.w	lr, #1
34002486:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400248a:	f8c5 325c 	str.w	r3, [r5, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
3400248e:	3320      	adds	r3, #32
      } while ( op_size > 0 );
34002490:	f00f c805 	le	lr, 3400248a <main+0x7d2>
34002494:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002498:	f3bf 8f6f 	isb	sy
    for (int i = 0; i < number_output; i++)
3400249c:	3701      	adds	r7, #1
3400249e:	e7d9      	b.n	34002454 <main+0x79c>
340024a0:	3401e83c 	.word	0x3401e83c
340024a4:	3403ec9c 	.word	0x3403ec9c
340024a8:	42c80000 	.word	0x42c80000
340024ac:	3401be4c 	.word	0x3401be4c
340024b0:	e000ed00 	.word	0xe000ed00

340024b4 <IAC_IRQHandler>:
  while (1)
340024b4:	e7fe      	b.n	340024b4 <IAC_IRQHandler>

340024b6 <MX_DCMIPP_ClockConfig>:
{
340024b6:	b500      	push	{lr}
340024b8:	b0e5      	sub	sp, #404	@ 0x194
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
340024ba:	f44f 72c8 	mov.w	r2, #400	@ 0x190
340024be:	2100      	movs	r1, #0
340024c0:	4668      	mov	r0, sp
340024c2:	f016 fb5b 	bl	34018b7c <memset>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP;
340024c6:	2300      	movs	r3, #0
340024c8:	2210      	movs	r2, #16
340024ca:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
340024ce:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
340024d2:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
  RCC_PeriphCLKInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
340024d6:	9332      	str	r3, [sp, #200]	@ 0xc8
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
340024d8:	2303      	movs	r3, #3
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024da:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
340024dc:	e9cd 1322 	strd	r1, r3, [sp, #136]	@ 0x88
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024e0:	f007 ff1c 	bl	3400a31c <HAL_RCCEx_PeriphCLKConfig>
  if (ret)
340024e4:	b948      	cbnz	r0, 340024fa <MX_DCMIPP_ClockConfig+0x44>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CSI;
340024e6:	2300      	movs	r3, #0
340024e8:	2208      	movs	r2, #8
340024ea:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockDivider = 40;
340024ee:	2328      	movs	r3, #40	@ 0x28
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL1;
340024f0:	9024      	str	r0, [sp, #144]	@ 0x90
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024f2:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockDivider = 40;
340024f4:	9325      	str	r3, [sp, #148]	@ 0x94
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024f6:	f007 ff11 	bl	3400a31c <HAL_RCCEx_PeriphCLKConfig>
}
340024fa:	b065      	add	sp, #404	@ 0x194
340024fc:	f85d fb04 	ldr.w	pc, [sp], #4

34002500 <HAL_CACHEAXI_MspInit>:

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34002500:	b507      	push	{r0, r1, r2, lr}
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34002502:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
  __HAL_RCC_CACHEAXIRAM_MEM_CLK_ENABLE();
34002506:	f44f 6080 	mov.w	r0, #1024	@ 0x400
3400250a:	f7ff fb3b 	bl	34001b84 <LL_MEM_EnableClock>
3400250e:	4b08      	ldr	r3, [pc, #32]	@ (34002530 <HAL_CACHEAXI_MspInit+0x30>)
34002510:	f8c3 2a60 	str.w	r2, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34002514:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
34002518:	9101      	str	r1, [sp, #4]
  (void)tmpreg;
3400251a:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
3400251c:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34002520:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34002524:	f8c3 2220 	str.w	r2, [r3, #544]	@ 0x220
  __HAL_RCC_CACHEAXI_CLK_ENABLE();
  __HAL_RCC_CACHEAXI_FORCE_RESET();
  __HAL_RCC_CACHEAXI_RELEASE_RESET();
}
34002528:	b003      	add	sp, #12
3400252a:	f85d fb04 	ldr.w	pc, [sp], #4
3400252e:	bf00      	nop
34002530:	56028000 	.word	0x56028000

34002534 <assert_failed>:
  */
void assert_failed(uint8_t* file, uint32_t line)
{
  UNUSED(file);
  UNUSED(line);
  __BKPT(0);
34002534:	be00      	bkpt	0x0000
  while (1)
34002536:	e7fe      	b.n	34002536 <assert_failed+0x2>

34002538 <mcu_cache_invalidate_range>:
  }  
  return 0;
}

int mcu_cache_invalidate_range(uint32_t start_addr, uint32_t end_addr) 
{
34002538:	b530      	push	{r4, r5, lr}

#include "stm32n6xx_hal.h"

__STATIC_FORCEINLINE int mcu_cache_enabled(void) {
#if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
3400253a:	4d13      	ldr	r5, [pc, #76]	@ (34002588 <mcu_cache_invalidate_range+0x50>)
3400253c:	696b      	ldr	r3, [r5, #20]
3400253e:	03db      	lsls	r3, r3, #15
34002540:	d51f      	bpl.n	34002582 <mcu_cache_invalidate_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_InvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34002542:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
34002544:	2a00      	cmp	r2, #0
34002546:	dd1c      	ble.n	34002582 <mcu_cache_invalidate_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002548:	f000 031f 	and.w	r3, r0, #31
3400254c:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
3400254e:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002552:	1884      	adds	r4, r0, r2
34002554:	43c2      	mvns	r2, r0
34002556:	1a1b      	subs	r3, r3, r0
34002558:	440b      	add	r3, r1
3400255a:	4422      	add	r2, r4
3400255c:	3b20      	subs	r3, #32
3400255e:	0952      	lsrs	r2, r2, #5
34002560:	3320      	adds	r3, #32
34002562:	f102 0e01 	add.w	lr, r2, #1
34002566:	bfd8      	it	le
34002568:	f04f 0e01 	movle.w	lr, #1
3400256c:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002570:	f8c5 025c 	str.w	r0, [r5, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34002574:	3020      	adds	r0, #32
      } while ( op_size > 0 );
34002576:	f00f c805 	le	lr, 34002570 <mcu_cache_invalidate_range+0x38>
3400257a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400257e:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
34002582:	2000      	movs	r0, #0
34002584:	bd30      	pop	{r4, r5, pc}
34002586:	bf00      	nop
34002588:	e000ed00 	.word	0xe000ed00

3400258c <mcu_cache_clean_range>:

int mcu_cache_clean_range(uint32_t start_addr, uint32_t end_addr) {
3400258c:	b530      	push	{r4, r5, lr}
3400258e:	4d13      	ldr	r5, [pc, #76]	@ (340025dc <mcu_cache_clean_range+0x50>)
34002590:	696b      	ldr	r3, [r5, #20]
34002592:	03db      	lsls	r3, r3, #15
34002594:	d51f      	bpl.n	340025d6 <mcu_cache_clean_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_CleanDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34002596:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
34002598:	2a00      	cmp	r2, #0
3400259a:	dd1c      	ble.n	340025d6 <mcu_cache_clean_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
3400259c:	f000 031f 	and.w	r3, r0, #31
340025a0:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
340025a2:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
340025a6:	1884      	adds	r4, r0, r2
340025a8:	43c2      	mvns	r2, r0
340025aa:	1a1b      	subs	r3, r3, r0
340025ac:	440b      	add	r3, r1
340025ae:	4422      	add	r2, r4
340025b0:	3b20      	subs	r3, #32
340025b2:	0952      	lsrs	r2, r2, #5
340025b4:	3320      	adds	r3, #32
340025b6:	f102 0e01 	add.w	lr, r2, #1
340025ba:	bfd8      	it	le
340025bc:	f04f 0e01 	movle.w	lr, #1
340025c0:	f04e e001 	dls	lr, lr
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340025c4:	f8c5 0268 	str.w	r0, [r5, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340025c8:	3020      	adds	r0, #32
      } while ( op_size > 0 );
340025ca:	f00f c805 	le	lr, 340025c4 <mcu_cache_clean_range+0x38>
340025ce:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340025d2:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
340025d6:	2000      	movs	r0, #0
340025d8:	bd30      	pop	{r4, r5, pc}
340025da:	bf00      	nop
340025dc:	e000ed00 	.word	0xe000ed00

340025e0 <_ec_blob_cache_start_func_1>:
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26560) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 28032) */
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26560) /* Equivalent hex address = 0x342e67c0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 28032) /* Equivalent hex address = 0x342e6d80UL */);
340025e0:	4901      	ldr	r1, [pc, #4]	@ (340025e8 <_ec_blob_cache_start_func_1+0x8>)
340025e2:	4802      	ldr	r0, [pc, #8]	@ (340025ec <_ec_blob_cache_start_func_1+0xc>)
340025e4:	f7ff bfa8 	b.w	34002538 <mcu_cache_invalidate_range>
340025e8:	342e6d80 	.word	0x342e6d80
340025ec:	342e67c0 	.word	0x342e67c0

340025f0 <LL_ATON_End_EpochBlock_20>:


/* scheduling epoch=20   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_20(const void *epoch_block)
{
340025f0:	b530      	push	{r4, r5, lr}
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) */
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856) /* Equivalent hex address = 0x342e16e0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) /* Equivalent hex address = 0x342e1700UL */);
340025f2:	4d23      	ldr	r5, [pc, #140]	@ (34002680 <LL_ATON_End_EpochBlock_20+0x90>)
{
340025f4:	b0af      	sub	sp, #188	@ 0xbc
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856) /* Equivalent hex address = 0x342e16e0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) /* Equivalent hex address = 0x342e1700UL */);
340025f6:	4629      	mov	r1, r5
340025f8:	4822      	ldr	r0, [pc, #136]	@ (34002684 <LL_ATON_End_EpochBlock_20+0x94>)
340025fa:	f7ff ff9d 	bl	34002538 <mcu_cache_invalidate_range>
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=Dequantize_54 */
  Dequantizelinear_sw_info dequantizelinear1_sw_info = {
340025fe:	22b4      	movs	r2, #180	@ 0xb4
34002600:	2100      	movs	r1, #0
34002602:	a801      	add	r0, sp, #4
34002604:	f016 faba 	bl	34018b7c <memset>
34002608:	24d2      	movs	r4, #210	@ 0xd2
3400260a:	f240 51be 	movw	r1, #1470	@ 0x5be
3400260e:	2207      	movs	r2, #7
34002610:	232a      	movs	r3, #42	@ 0x2a
34002612:	201e      	movs	r0, #30
34002614:	e9cd 1406 	strd	r1, r4, [sp, #24]
34002618:	e9cd 2202 	strd	r2, r2, [sp, #8]
3400261c:	e9cd 220d 	strd	r2, r2, [sp, #52]	@ 0x34
34002620:	f88d 3004 	strb.w	r3, [sp, #4]
34002624:	910a      	str	r1, [sp, #40]	@ 0x28
34002626:	2301      	movs	r3, #1
34002628:	9111      	str	r1, [sp, #68]	@ 0x44
3400262a:	2278      	movs	r2, #120	@ 0x78
3400262c:	f44f 7152 	mov.w	r1, #840	@ 0x348
34002630:	e9cd 0304 	strd	r0, r3, [sp, #16]
34002634:	e9cd 0308 	strd	r0, r3, [sp, #32]
34002638:	e9cd 030f 	strd	r0, r3, [sp, #60]	@ 0x3c
3400263c:	e9cd 1212 	strd	r1, r2, [sp, #72]	@ 0x48
34002640:	2004      	movs	r0, #4
34002642:	f241 62f8 	movw	r2, #5880	@ 0x16f8
34002646:	4c10      	ldr	r4, [pc, #64]	@ (34002688 <LL_ATON_End_EpochBlock_20+0x98>)
34002648:	e9cd 0214 	strd	r0, r2, [sp, #80]	@ 0x50
3400264c:	4a0f      	ldr	r2, [pc, #60]	@ (3400268c <LL_ATON_End_EpochBlock_20+0x9c>)
3400264e:	940b      	str	r4, [sp, #44]	@ 0x2c
34002650:	4c0f      	ldr	r4, [pc, #60]	@ (34002690 <LL_ATON_End_EpochBlock_20+0xa0>)
34002652:	9221      	str	r2, [sp, #132]	@ 0x84
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Dequantize_54 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear1_sw_info);
34002654:	a801      	add	r0, sp, #4
  Dequantizelinear_sw_info dequantizelinear1_sw_info = {
34002656:	3230      	adds	r2, #48	@ 0x30
34002658:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
3400265c:	f88d 305c 	strb.w	r3, [sp, #92]	@ 0x5c
34002660:	931c      	str	r3, [sp, #112]	@ 0x70
34002662:	f88d 3088 	strb.w	r3, [sp, #136]	@ 0x88
34002666:	9327      	str	r3, [sp, #156]	@ 0x9c
34002668:	922c      	str	r2, [sp, #176]	@ 0xb0
3400266a:	f88d 30b4 	strb.w	r3, [sp, #180]	@ 0xb4
3400266e:	9416      	str	r4, [sp, #88]	@ 0x58
  ll_sw_forward_dequantizelinear(&dequantizelinear1_sw_info);
34002670:	f014 f9f4 	bl	34016a5c <ll_sw_forward_dequantizelinear>
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) */
  mcu_cache_clean_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0) /* Equivalent hex address = 0x342e0000UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) /* Equivalent hex address = 0x342e1700UL */);
34002674:	4629      	mov	r1, r5
34002676:	4620      	mov	r0, r4
34002678:	f7ff ff88 	bl	3400258c <mcu_cache_clean_range>
#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)

  // Un-lock MCU cache
  LL_ATON_UNLOCK_MCU_CACHE();

}
3400267c:	b02f      	add	sp, #188	@ 0xbc
3400267e:	bd30      	pop	{r4, r5, pc}
34002680:	342e1700 	.word	0x342e1700
34002684:	342e16e0 	.word	0x342e16e0
34002688:	342e67c0 	.word	0x342e67c0
3400268c:	70e0d3e0 	.word	0x70e0d3e0
34002690:	342e0000 	.word	0x342e0000

34002694 <LL_ATON_Set_User_Input_Buffer_Default>:
}
34002694:	2003      	movs	r0, #3
34002696:	4770      	bx	lr

34002698 <LL_ATON_Get_User_Input_Buffer_Default>:
}
34002698:	2000      	movs	r0, #0
3400269a:	4770      	bx	lr

3400269c <LL_ATON_Set_User_Output_Buffer_Default>:
LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
3400269c:	2003      	movs	r0, #3
3400269e:	4770      	bx	lr

340026a0 <LL_ATON_Get_User_Output_Buffer_Default>:
void *LL_ATON_Get_User_Output_Buffer_Default(uint32_t num)
340026a0:	2000      	movs	r0, #0
340026a2:	4770      	bx	lr

340026a4 <LL_ATON_EC_Network_Init_Default>:
bool LL_ATON_EC_Network_Init_Default(void)
{


  return true;
}
340026a4:	2001      	movs	r0, #1
340026a6:	4770      	bx	lr

340026a8 <LL_ATON_EC_Inference_Init_Default>:

// this function should be called before each inference
bool LL_ATON_EC_Inference_Init_Default(void)
340026a8:	2001      	movs	r0, #1
340026aa:	4770      	bx	lr

340026ac <LL_ATON_EpochBlockItems_Default>:
    },
  };


  return ll_atonn_rt_epoch_block_array;
}
340026ac:	4800      	ldr	r0, [pc, #0]	@ (340026b0 <LL_ATON_EpochBlockItems_Default+0x4>)
340026ae:	4770      	bx	lr
340026b0:	34029944 	.word	0x34029944

340026b4 <LL_ATON_Input_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
340026b4:	4800      	ldr	r0, [pc, #0]	@ (340026b8 <LL_ATON_Input_Buffers_Info_Default+0x4>)
340026b6:	4770      	bx	lr
340026b8:	340298d4 	.word	0x340298d4

340026bc <LL_ATON_Output_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
340026bc:	4800      	ldr	r0, [pc, #0]	@ (340026c0 <LL_ATON_Output_Buffers_Info_Default+0x4>)
340026be:	4770      	bx	lr
340026c0:	3402983c 	.word	0x3402983c

340026c4 <LL_ATON_Internal_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
340026c4:	4800      	ldr	r0, [pc, #0]	@ (340026c8 <LL_ATON_Internal_Buffers_Info_Default+0x4>)
340026c6:	4770      	bx	lr
340026c8:	34029234 	.word	0x34029234

340026cc <npu_cache_init>:

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
  hcacheaxi_s.Instance = CACHEAXI;
340026cc:	4802      	ldr	r0, [pc, #8]	@ (340026d8 <npu_cache_init+0xc>)
340026ce:	4b03      	ldr	r3, [pc, #12]	@ (340026dc <npu_cache_init+0x10>)
340026d0:	6003      	str	r3, [r0, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
340026d2:	f002 b9a5 	b.w	34004a20 <HAL_CACHEAXI_Init>
340026d6:	bf00      	nop
340026d8:	3403f344 	.word	0x3403f344
340026dc:	580dfc00 	.word	0x580dfc00

340026e0 <npu_cache_enable>:
}

void npu_cache_enable(void)
{
340026e0:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status;
  // Enable is wrapped in a loop because most of times, the first call returns
  //    HAL_BUSY, resulting in a cache not enabled.
  do
  {
    status = HAL_CACHEAXI_Enable(&hcacheaxi_s);
340026e2:	4c03      	ldr	r4, [pc, #12]	@ (340026f0 <npu_cache_enable+0x10>)
340026e4:	4620      	mov	r0, r4
340026e6:	f002 f967 	bl	340049b8 <HAL_CACHEAXI_Enable>
  } while (status == HAL_BUSY);
340026ea:	2802      	cmp	r0, #2
340026ec:	d0fa      	beq.n	340026e4 <npu_cache_enable+0x4>
}
340026ee:	bd10      	pop	{r4, pc}
340026f0:	3403f344 	.word	0x3403f344

340026f4 <PC_STREAM_Init>:
    .HwFlowCtl = UART_HWCONTROL_NONE
};

void PC_STREAM_Init(void)
{
    BSP_COM_Init(COM1, &PcUartInit);
340026f4:	2000      	movs	r0, #0
340026f6:	4901      	ldr	r1, [pc, #4]	@ (340026fc <PC_STREAM_Init+0x8>)
340026f8:	f000 bc88 	b.w	3400300c <BSP_COM_Init>
340026fc:	3403eca4 	.word	0x3403eca4

34002700 <PC_STREAM_SendFrame>:
    uint8_t b8 = (pixel & 0x1F) << 3;
    return (uint8_t)((r8 * 30 + g8 * 59 + b8 * 11) / 100);
}

void PC_STREAM_SendFrame(const uint8_t *frame, uint32_t width, uint32_t height, uint32_t bpp)
{
34002700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34002704:	2400      	movs	r4, #0
34002706:	b08d      	sub	sp, #52	@ 0x34
34002708:	e9cd 0102 	strd	r0, r1, [sp, #8]
3400270c:	270a      	movs	r7, #10
3400270e:	4620      	mov	r0, r4
    return (uint8_t)((r8 * 30 + g8 * 59 + b8 * 11) / 100);
34002710:	f04f 0c1e 	mov.w	ip, #30
34002714:	f04f 080b 	mov.w	r8, #11
34002718:	f04f 0964 	mov.w	r9, #100	@ 0x64
{
3400271c:	f04f 0ea0 	mov.w	lr, #160	@ 0xa0
34002720:	2500      	movs	r5, #0
34002722:	f04e e001 	dls	lr, lr
34002726:	4b1e      	ldr	r3, [pc, #120]	@ (340027a0 <PC_STREAM_SendFrame+0xa0>)
34002728:	18e6      	adds	r6, r4, r3
3400272a:	9b02      	ldr	r3, [sp, #8]
3400272c:	fb07 3b00 	mla	fp, r7, r0, r3
    for (uint32_t y = 0; y < STREAM_HEIGHT; y++)
    {
        const uint16_t *line = src + (y * STREAM_SCALE) * width;
        for (uint32_t x = 0; x < STREAM_WIDTH; x++)
        {
            uint16_t px = line[x * STREAM_SCALE];
34002730:	f83b 3015 	ldrh.w	r3, [fp, r5, lsl #1]
        for (uint32_t x = 0; x < STREAM_WIDTH; x++)
34002734:	3505      	adds	r5, #5
    uint8_t b8 = (pixel & 0x1F) << 3;
34002736:	00da      	lsls	r2, r3, #3
    uint8_t r8 = ((pixel >> 11) & 0x1F) << 3;
34002738:	0ad9      	lsrs	r1, r3, #11
    uint8_t g8 = ((pixel >> 5) & 0x3F) << 2;
3400273a:	08db      	lsrs	r3, r3, #3
    return (uint8_t)((r8 * 30 + g8 * 59 + b8 * 11) / 100);
3400273c:	f003 03fc 	and.w	r3, r3, #252	@ 0xfc
34002740:	ebc3 1a03 	rsb	sl, r3, r3, lsl #4
34002744:	00c9      	lsls	r1, r1, #3
34002746:	ebc3 038a 	rsb	r3, r3, sl, lsl #2
3400274a:	fb1c 3101 	smlabb	r1, ip, r1, r3
3400274e:	b2d2      	uxtb	r2, r2
34002750:	fb18 1202 	smlabb	r2, r8, r2, r1
34002754:	fbb2 f2f9 	udiv	r2, r2, r9
34002758:	f806 2b01 	strb.w	r2, [r6], #1
        for (uint32_t x = 0; x < STREAM_WIDTH; x++)
3400275c:	f00f c019 	le	lr, 34002730 <PC_STREAM_SendFrame+0x30>
    for (uint32_t y = 0; y < STREAM_HEIGHT; y++)
34002760:	9b03      	ldr	r3, [sp, #12]
34002762:	34a0      	adds	r4, #160	@ 0xa0
34002764:	f5b4 5f70 	cmp.w	r4, #15360	@ 0x3c00
34002768:	4418      	add	r0, r3
3400276a:	d1d7      	bne.n	3400271c <PC_STREAM_SendFrame+0x1c>
            stream_buffer[y * STREAM_WIDTH + x] = rgb565_to_gray(px);
        }
    }

    char header[32];
    int hl = snprintf(header, sizeof(header), "FRAME %u %u 1\n", (unsigned)STREAM_WIDTH, (unsigned)STREAM_HEIGHT);
3400276c:	2360      	movs	r3, #96	@ 0x60
3400276e:	2120      	movs	r1, #32
34002770:	9300      	str	r3, [sp, #0]
34002772:	4a0c      	ldr	r2, [pc, #48]	@ (340027a4 <PC_STREAM_SendFrame+0xa4>)
34002774:	23a0      	movs	r3, #160	@ 0xa0
34002776:	a804      	add	r0, sp, #16
34002778:	f016 f89c 	bl	340188b4 <sniprintf>
    if (hl > 0)
    {
        HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)header, (uint16_t)hl, HAL_MAX_DELAY);
3400277c:	a904      	add	r1, sp, #16
3400277e:	f04f 33ff 	mov.w	r3, #4294967295
34002782:	220f      	movs	r2, #15
34002784:	4808      	ldr	r0, [pc, #32]	@ (340027a8 <PC_STREAM_SendFrame+0xa8>)
34002786:	f00c ffd9 	bl	3400f73c <HAL_UART_Transmit>
    }
    HAL_UART_Transmit(&hcom_uart[COM1], stream_buffer, sizeof(stream_buffer), HAL_MAX_DELAY);
3400278a:	f04f 33ff 	mov.w	r3, #4294967295
3400278e:	4622      	mov	r2, r4
34002790:	4903      	ldr	r1, [pc, #12]	@ (340027a0 <PC_STREAM_SendFrame+0xa0>)
34002792:	4805      	ldr	r0, [pc, #20]	@ (340027a8 <PC_STREAM_SendFrame+0xa8>)
34002794:	f00c ffd2 	bl	3400f73c <HAL_UART_Transmit>
}
34002798:	b00d      	add	sp, #52	@ 0x34
3400279a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400279e:	bf00      	nop
340027a0:	3403f350 	.word	0x3403f350
340027a4:	3401c17a 	.word	0x3401c17a
340027a8:	34042f80 	.word	0x34042f80

340027ac <UTIL_LCDEx_PrintfAt>:
  UTIL_LCD_DisplayStringAtLine(line, (uint8_t *) buffer);
  va_end(args);
}

void UTIL_LCDEx_PrintfAt(uint32_t x_pos, uint32_t y_pos, Text_AlignModeTypdef mode, const char * format, ...)
{
340027ac:	b408      	push	{r3}
340027ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
340027b0:	4604      	mov	r4, r0
340027b2:	460d      	mov	r5, r1
340027b4:	4616      	mov	r6, r2
340027b6:	ab07      	add	r3, sp, #28
  static char buffer[N_PRINTABLE_CHARS + 1];
  va_list args;
  va_start(args, format);
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
340027b8:	4f09      	ldr	r7, [pc, #36]	@ (340027e0 <UTIL_LCDEx_PrintfAt+0x34>)
{
340027ba:	f853 2b04 	ldr.w	r2, [r3], #4
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
340027be:	2130      	movs	r1, #48	@ 0x30
340027c0:	4638      	mov	r0, r7
  va_start(args, format);
340027c2:	9301      	str	r3, [sp, #4]
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
340027c4:	f016 f91e 	bl	34018a04 <vsniprintf>
  UTIL_LCD_DisplayStringAt(x_pos, y_pos, (uint8_t *) buffer, mode);
340027c8:	4633      	mov	r3, r6
340027ca:	463a      	mov	r2, r7
340027cc:	4629      	mov	r1, r5
340027ce:	4620      	mov	r0, r4
340027d0:	f012 fe82 	bl	340154d8 <UTIL_LCD_DisplayStringAt>
  va_end(args);
}
340027d4:	b002      	add	sp, #8
340027d6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
340027da:	b001      	add	sp, #4
340027dc:	4770      	bx	lr
340027de:	bf00      	nop
340027e0:	34042f50 	.word	0x34042f50

340027e4 <NMI_Handler>:
/**
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
340027e4:	4770      	bx	lr

340027e6 <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
340027e6:	e7fe      	b.n	340027e6 <HardFault_Handler>

340027e8 <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
340027e8:	e7fe      	b.n	340027e8 <MemManage_Handler>

340027ea <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
340027ea:	e7fe      	b.n	340027ea <BusFault_Handler>

340027ec <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
340027ec:	e7fe      	b.n	340027ec <UsageFault_Handler>

340027ee <SecureFault_Handler>:
  * @retval None
  */
void SecureFault_Handler(void)
{
  /* Go to infinite loop when Secure Fault exception occurs */
  while (1)
340027ee:	e7fe      	b.n	340027ee <SecureFault_Handler>

340027f0 <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
340027f0:	4770      	bx	lr

340027f2 <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
  while (1)
340027f2:	e7fe      	b.n	340027f2 <DebugMon_Handler>

340027f4 <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
  while (1)
340027f4:	e7fe      	b.n	340027f4 <PendSV_Handler>

340027f6 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
340027f6:	f001 bffd 	b.w	340047f4 <HAL_IncTick>

340027fa <CSI_IRQHandler>:
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32n6xx.s).                                               */
/******************************************************************************/
void CSI_IRQHandler(void)
{
340027fa:	b508      	push	{r3, lr}
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
340027fc:	f00e f832 	bl	34010864 <CMW_CAMERA_GetDCMIPPHandle>
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
}
34002800:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
34002804:	f002 beba 	b.w	3400557c <HAL_DCMIPP_CSI_IRQHandler>

34002808 <DCMIPP_IRQHandler>:

void DCMIPP_IRQHandler(void)
{
34002808:	b508      	push	{r3, lr}
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
3400280a:	f00e f82b 	bl	34010864 <CMW_CAMERA_GetDCMIPPHandle>
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
3400280e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
34002812:	f002 bd7d 	b.w	34005310 <HAL_DCMIPP_IRQHandler>

34002816 <_getpid>:
}

int _getpid(void)
{
  return 1;
}
34002816:	2001      	movs	r0, #1
34002818:	4770      	bx	lr

3400281a <_kill>:

int _kill(int pid, int sig)
{
3400281a:	b508      	push	{r3, lr}
  (void)pid;
  (void)sig;
  errno = EINVAL;
3400281c:	f016 fc02 	bl	34019024 <__errno>
34002820:	2316      	movs	r3, #22
34002822:	6003      	str	r3, [r0, #0]
  return -1;
}
34002824:	f04f 30ff 	mov.w	r0, #4294967295
34002828:	bd08      	pop	{r3, pc}

3400282a <_exit>:

void _exit (int status)
{
3400282a:	b508      	push	{r3, lr}
  errno = EINVAL;
3400282c:	f016 fbfa 	bl	34019024 <__errno>
34002830:	2316      	movs	r3, #22
34002832:	6003      	str	r3, [r0, #0]
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
34002834:	e7fe      	b.n	34002834 <_exit+0xa>

34002836 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
34002836:	b570      	push	{r4, r5, r6, lr}
34002838:	460d      	mov	r5, r1
3400283a:	4614      	mov	r4, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
3400283c:	460e      	mov	r6, r1
3400283e:	1b73      	subs	r3, r6, r5
34002840:	429c      	cmp	r4, r3
34002842:	dc01      	bgt.n	34002848 <_read+0x12>
  {
    *ptr++ = __io_getchar();
  }

  return len;
}
34002844:	4620      	mov	r0, r4
34002846:	bd70      	pop	{r4, r5, r6, pc}
    *ptr++ = __io_getchar();
34002848:	f3af 8000 	nop.w
3400284c:	f806 0b01 	strb.w	r0, [r6], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002850:	e7f5      	b.n	3400283e <_read+0x8>

34002852 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
34002852:	b570      	push	{r4, r5, r6, lr}
34002854:	460d      	mov	r5, r1
34002856:	4614      	mov	r4, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002858:	460e      	mov	r6, r1
3400285a:	1b73      	subs	r3, r6, r5
3400285c:	429c      	cmp	r4, r3
3400285e:	dc01      	bgt.n	34002864 <_write+0x12>
  {
    __io_putchar(*ptr++);
  }
  return len;
}
34002860:	4620      	mov	r0, r4
34002862:	bd70      	pop	{r4, r5, r6, pc}
    __io_putchar(*ptr++);
34002864:	f816 0b01 	ldrb.w	r0, [r6], #1
34002868:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
3400286c:	e7f5      	b.n	3400285a <_write+0x8>

3400286e <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
3400286e:	f04f 30ff 	mov.w	r0, #4294967295
34002872:	4770      	bx	lr

34002874 <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
34002874:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  return 0;
}
34002878:	2000      	movs	r0, #0
  st->st_mode = S_IFCHR;
3400287a:	604b      	str	r3, [r1, #4]
}
3400287c:	4770      	bx	lr

3400287e <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
3400287e:	2001      	movs	r0, #1
34002880:	4770      	bx	lr

34002882 <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
34002882:	2000      	movs	r0, #0
34002884:	4770      	bx	lr

34002886 <APS256XX_EnableMemoryMappedMode>:
  * @param  BurstType Type of burst used for the access
  * @retval Memory status
  */
int32_t APS256XX_EnableMemoryMappedMode(XSPI_HandleTypeDef *Ctx, uint32_t ReadLatencyCode, uint32_t WriteLatencyCode,
                                        uint32_t IOMode, uint32_t BurstType)
{
34002886:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400288a:	b098      	sub	sp, #96	@ 0x60
3400288c:	4605      	mov	r5, r0
3400288e:	4617      	mov	r7, r2
34002890:	460e      	mov	r6, r1
  XSPI_RegularCmdTypeDef   sCommand = {0};
34002892:	223c      	movs	r2, #60	@ 0x3c
34002894:	2100      	movs	r1, #0
34002896:	a806      	add	r0, sp, #24
{
34002898:	4698      	mov	r8, r3
3400289a:	9c1e      	ldr	r4, [sp, #120]	@ 0x78
  XSPI_RegularCmdTypeDef   sCommand = {0};
3400289c:	f016 f96e 	bl	34018b7c <memset>
  XSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
340028a0:	2210      	movs	r2, #16
340028a2:	2100      	movs	r1, #0
340028a4:	a801      	add	r0, sp, #4
340028a6:	f016 f969 	bl	34018b7c <memset>

  /* Initialize the write command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_WRITE_CFG;
340028aa:	2302      	movs	r3, #2
340028ac:	9305      	str	r3, [sp, #20]
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
340028ae:	2304      	movs	r3, #4
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
340028b0:	2c00      	cmp	r4, #0
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
340028b2:	9308      	str	r3, [sp, #32]
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
340028b4:	bf14      	ite	ne
340028b6:	2380      	movne	r3, #128	@ 0x80
340028b8:	23a0      	moveq	r3, #160	@ 0xa0
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
340028ba:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
340028be:	9307      	str	r3, [sp, #28]
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
340028c0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340028c4:	e9cd 130c 	strd	r1, r3, [sp, #48]	@ 0x30
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
340028c8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
340028cc:	f1b8 0f00 	cmp.w	r8, #0
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
340028d0:	930e      	str	r3, [sp, #56]	@ 0x38
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
340028d2:	bf14      	ite	ne
340028d4:	f04f 63a0 	movne.w	r3, #83886080	@ 0x5000000
340028d8:	f04f 6380 	moveq.w	r3, #67108864	@ 0x4000000
340028dc:	9313      	str	r3, [sp, #76]	@ 0x4c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
340028de:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340028e2:	9315      	str	r3, [sp, #84]	@ 0x54
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
340028e4:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
340028e8:	3f01      	subs	r7, #1
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340028ea:	f241 3288 	movw	r2, #5000	@ 0x1388
340028ee:	4628      	mov	r0, r5
340028f0:	a905      	add	r1, sp, #20
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
340028f2:	9716      	str	r7, [sp, #88]	@ 0x58
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
340028f4:	9317      	str	r3, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340028f6:	f00d fb2b 	bl	3400ff50 <HAL_XSPI_Command>
340028fa:	b120      	cbz	r0, 34002906 <APS256XX_EnableMemoryMappedMode+0x80>
  {
    return APS256XX_ERROR;
340028fc:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return APS256XX_ERROR;
  }

  return APS256XX_OK;
}
34002900:	b018      	add	sp, #96	@ 0x60
34002902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  sCommand.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002906:	2301      	movs	r3, #1
34002908:	9305      	str	r3, [sp, #20]
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
3400290a:	fab4 f384 	clz	r3, r4
3400290e:	095b      	lsrs	r3, r3, #5
34002910:	015b      	lsls	r3, r3, #5
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
34002912:	3e01      	subs	r6, #1
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002914:	f241 3288 	movw	r2, #5000	@ 0x1388
34002918:	4628      	mov	r0, r5
3400291a:	a905      	add	r1, sp, #20
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
3400291c:	9307      	str	r3, [sp, #28]
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
3400291e:	9616      	str	r6, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002920:	f00d fb16 	bl	3400ff50 <HAL_XSPI_Command>
34002924:	2800      	cmp	r0, #0
34002926:	d1e9      	bne.n	340028fc <APS256XX_EnableMemoryMappedMode+0x76>
  sMemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34002928:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &sMemMappedCfg) != HAL_OK)
3400292a:	a901      	add	r1, sp, #4
3400292c:	4628      	mov	r0, r5
3400292e:	f00d fd3d 	bl	340103ac <HAL_XSPI_MemoryMapped>
34002932:	3800      	subs	r0, #0
34002934:	bf18      	it	ne
34002936:	2001      	movne	r0, #1
34002938:	4240      	negs	r0, r0
3400293a:	e7e1      	b.n	34002900 <APS256XX_EnableMemoryMappedMode+0x7a>

3400293c <APS256XX_WriteReg>:
  * @param  Address Register address
  * @param  Value Value to write to register
  * @retval error status
  */
int32_t APS256XX_WriteReg(XSPI_HandleTypeDef *Ctx, uint32_t Address, uint8_t Value)
{
3400293c:	b530      	push	{r4, r5, lr}
3400293e:	b097      	sub	sp, #92	@ 0x5c
34002940:	460d      	mov	r5, r1
34002942:	4604      	mov	r4, r0
  XSPI_RegularCmdTypeDef sCommand = {0};
34002944:	2100      	movs	r1, #0
{
34002946:	f88d 2007 	strb.w	r2, [sp, #7]
  XSPI_RegularCmdTypeDef sCommand = {0};
3400294a:	a803      	add	r0, sp, #12
3400294c:	224c      	movs	r2, #76	@ 0x4c
3400294e:	f016 f915 	bl	34018b7c <memset>
  /* Initialize the write register command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_COMMON_CFG;
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
34002952:	23c0      	movs	r3, #192	@ 0xc0
34002954:	2204      	movs	r2, #4
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
34002956:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
3400295a:	e9cd 3205 	strd	r3, r2, [sp, #20]
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3400295e:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002962:	e9cd 130a 	strd	r1, r3, [sp, #40]	@ 0x28
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34002966:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400296a:	930c      	str	r3, [sp, #48]	@ 0x30
  sCommand.Address             = Address;
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
3400296c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  sCommand.Address             = Address;
34002970:	9509      	str	r5, [sp, #36]	@ 0x24
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
34002972:	9311      	str	r3, [sp, #68]	@ 0x44
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
  sCommand.DataLength          = 2;
34002974:	f04f 6500 	mov.w	r5, #134217728	@ 0x8000000
34002978:	2302      	movs	r3, #2
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Configure the command */
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400297a:	f241 3288 	movw	r2, #5000	@ 0x1388
3400297e:	4620      	mov	r0, r4
34002980:	a903      	add	r1, sp, #12
  sCommand.DataLength          = 2;
34002982:	e9cd 3512 	strd	r3, r5, [sp, #72]	@ 0x48
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002986:	f00d fae3 	bl	3400ff50 <HAL_XSPI_Command>
3400298a:	b960      	cbnz	r0, 340029a6 <APS256XX_WriteReg+0x6a>
  {
    return APS256XX_ERROR;
  }

  /* Transmission of the data */
  if (HAL_XSPI_Transmit(Ctx, (uint8_t *)(&Value), HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400298c:	f241 3288 	movw	r2, #5000	@ 0x1388
34002990:	4620      	mov	r0, r4
34002992:	f10d 0107 	add.w	r1, sp, #7
34002996:	f00d fbf3 	bl	34010180 <HAL_XSPI_Transmit>
3400299a:	3800      	subs	r0, #0
3400299c:	bf18      	it	ne
3400299e:	2001      	movne	r0, #1
340029a0:	4240      	negs	r0, r0
  {
    return APS256XX_ERROR;
  }

  return APS256XX_OK;
}
340029a2:	b017      	add	sp, #92	@ 0x5c
340029a4:	bd30      	pop	{r4, r5, pc}
    return APS256XX_ERROR;
340029a6:	f04f 30ff 	mov.w	r0, #4294967295
340029aa:	e7fa      	b.n	340029a2 <APS256XX_WriteReg+0x66>

340029ac <MX66UW1G45G_GetFlashInfo>:
  */
int32_t MX66UW1G45G_GetFlashInfo(MX66UW1G45G_Info_t *pInfo)
{
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize = MX66UW1G45G_FLASH_SIZE;
  pInfo->EraseSectorSize = MX66UW1G45G_BLOCK_64K;
340029ac:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
340029b0:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
340029b4:	e9c0 2300 	strd	r2, r3, [r0]
  pInfo->EraseSectorsNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_64K);
  pInfo->EraseSubSectorSize = MX66UW1G45G_BLOCK_4K;
340029b8:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
340029bc:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340029c0:	e9c0 3202 	strd	r3, r2, [r0, #8]
  pInfo->EraseSubSectorNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
340029c4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
  pInfo->ProgPageSize = MX66UW1G45G_PAGE_SIZE;
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
340029c8:	f44f 7180 	mov.w	r1, #256	@ 0x100
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
340029cc:	e9c0 3204 	strd	r3, r2, [r0, #16]
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
340029d0:	6183      	str	r3, [r0, #24]
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
340029d2:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
340029d6:	e9c0 1307 	strd	r1, r3, [r0, #28]

  return MX66UW1G45G_OK;
};
340029da:	2000      	movs	r0, #0
340029dc:	4770      	bx	lr

340029de <MX66UW1G45G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX66UW1G45G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                        MX66UW1G45G_Transfer_t Rate)
{
340029de:	b570      	push	{r4, r5, r6, lr}
340029e0:	460d      	mov	r5, r1
340029e2:	b098      	sub	sp, #96	@ 0x60
  XSPI_RegularCmdTypeDef s_command = {0};
340029e4:	2100      	movs	r1, #0
{
340029e6:	4606      	mov	r6, r0
340029e8:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
340029ea:	a805      	add	r0, sp, #20
340029ec:	224c      	movs	r2, #76	@ 0x4c
340029ee:	f016 f8c5 	bl	34018b7c <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
340029f2:	2214      	movs	r2, #20
340029f4:	2100      	movs	r1, #0
340029f6:	4668      	mov	r0, sp
340029f8:	f016 f8c0 	bl	34018b7c <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
340029fc:	b92d      	cbnz	r5, 34002a0a <MX66UW1G45G_AutoPollingMemReady+0x2c>
340029fe:	2c01      	cmp	r4, #1
34002a00:	d14d      	bne.n	34002a9e <MX66UW1G45G_AutoPollingMemReady+0xc0>
  {
    return MX66UW1G45G_ERROR;
34002a02:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002a06:	b018      	add	sp, #96	@ 0x60
34002a08:	bd70      	pop	{r4, r5, r6, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002a0a:	2204      	movs	r2, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002a0c:	f104 3cff 	add.w	ip, r4, #4294967295
34002a10:	f1dc 0300 	rsbs	r3, ip, #0
34002a14:	eb43 030c 	adc.w	r3, r3, ip
34002a18:	00db      	lsls	r3, r3, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002a1a:	9208      	str	r2, [sp, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002a1c:	930a      	str	r3, [sp, #40]	@ 0x28
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002a1e:	2d00      	cmp	r5, #0
34002a20:	d040      	beq.n	34002aa4 <MX66UW1G45G_AutoPollingMemReady+0xc6>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002a22:	2310      	movs	r3, #16
34002a24:	f240 52fa 	movw	r2, #1530	@ 0x5fa
34002a28:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002a2a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002a2e:	1e60      	subs	r0, r4, #1
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002a30:	930c      	str	r3, [sp, #48]	@ 0x30
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002a32:	4243      	negs	r3, r0
34002a34:	4143      	adcs	r3, r0
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002a36:	9207      	str	r2, [sp, #28]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002a38:	02da      	lsls	r2, r3, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002a3a:	920e      	str	r2, [sp, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002a3c:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002a40:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002a42:	920d      	str	r2, [sp, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002a44:	bf14      	ite	ne
34002a46:	f04f 6280 	movne.w	r2, #67108864	@ 0x4000000
34002a4a:	f04f 7280 	moveq.w	r2, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34002a4e:	ea4f 63c3 	mov.w	r3, r3, lsl #27
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002a52:	9213      	str	r2, [sp, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002a54:	9315      	str	r3, [sp, #84]	@ 0x54
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002a56:	d02d      	beq.n	34002ab4 <MX66UW1G45G_AutoPollingMemReady+0xd6>
34002a58:	2c01      	cmp	r4, #1
34002a5a:	d126      	bne.n	34002aaa <MX66UW1G45G_AutoPollingMemReady+0xcc>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002a5c:	2305      	movs	r3, #5
34002a5e:	9316      	str	r3, [sp, #88]	@ 0x58
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002a60:	2202      	movs	r2, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002a62:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34002a66:	9317      	str	r3, [sp, #92]	@ 0x5c
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34002a68:	2301      	movs	r3, #1
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002a6a:	2110      	movs	r1, #16
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34002a6c:	9301      	str	r3, [sp, #4]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002a6e:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34002a72:	9214      	str	r2, [sp, #80]	@ 0x50
34002a74:	e9cd 3103 	strd	r3, r1, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a78:	f241 3288 	movw	r2, #5000	@ 0x1388
34002a7c:	4630      	mov	r0, r6
34002a7e:	a905      	add	r1, sp, #20
34002a80:	f00d fa66 	bl	3400ff50 <HAL_XSPI_Command>
34002a84:	2800      	cmp	r0, #0
34002a86:	d1bc      	bne.n	34002a02 <MX66UW1G45G_AutoPollingMemReady+0x24>
  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a88:	f241 3288 	movw	r2, #5000	@ 0x1388
34002a8c:	4669      	mov	r1, sp
34002a8e:	4630      	mov	r0, r6
34002a90:	f00d fc10 	bl	340102b4 <HAL_XSPI_AutoPolling>
34002a94:	3800      	subs	r0, #0
34002a96:	bf18      	it	ne
34002a98:	2001      	movne	r0, #1
34002a9a:	4240      	negs	r0, r0
34002a9c:	e7b3      	b.n	34002a06 <MX66UW1G45G_AutoPollingMemReady+0x28>
34002a9e:	2201      	movs	r2, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002aa0:	462b      	mov	r3, r5
34002aa2:	e7ba      	b.n	34002a1a <MX66UW1G45G_AutoPollingMemReady+0x3c>
34002aa4:	2205      	movs	r2, #5
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002aa6:	462b      	mov	r3, r5
34002aa8:	e7c1      	b.n	34002a2e <MX66UW1G45G_AutoPollingMemReady+0x50>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002aaa:	2304      	movs	r3, #4
34002aac:	9316      	str	r3, [sp, #88]	@ 0x58
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002aae:	2201      	movs	r2, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002ab0:	2300      	movs	r3, #0
34002ab2:	e7d8      	b.n	34002a66 <MX66UW1G45G_AutoPollingMemReady+0x88>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002ab4:	2c01      	cmp	r4, #1
34002ab6:	d1fa      	bne.n	34002aae <MX66UW1G45G_AutoPollingMemReady+0xd0>
34002ab8:	e7d2      	b.n	34002a60 <MX66UW1G45G_AutoPollingMemReady+0x82>

34002aba <MX66UW1G45G_EnableSTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                              MX66UW1G45G_AddressWidth_t AddressWidth)
{
34002aba:	b570      	push	{r4, r5, r6, lr}
34002abc:	460c      	mov	r4, r1
34002abe:	b098      	sub	sp, #96	@ 0x60
  XSPI_RegularCmdTypeDef s_command = {0};
34002ac0:	2100      	movs	r1, #0
{
34002ac2:	4606      	mov	r6, r0
34002ac4:	4615      	mov	r5, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002ac6:	a805      	add	r0, sp, #20
34002ac8:	224c      	movs	r2, #76	@ 0x4c
34002aca:	f016 f857 	bl	34018b7c <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34002ace:	2210      	movs	r2, #16
34002ad0:	2100      	movs	r1, #0
34002ad2:	a801      	add	r0, sp, #4
34002ad4:	f016 f852 	bl	34018b7c <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX66UW1G45G_OPI_MODE) && (AddressWidth == MX66UW1G45G_3BYTES_SIZE))
34002ad8:	2c01      	cmp	r4, #1
34002ada:	d144      	bne.n	34002b66 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xac>
34002adc:	b91d      	cbnz	r5, 34002ae6 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x2c>
  {
    return MX66UW1G45G_ERROR;
34002ade:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002ae2:	b018      	add	sp, #96	@ 0x60
34002ae4:	bd70      	pop	{r4, r5, r6, pc}
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002ae6:	9405      	str	r4, [sp, #20]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002ae8:	2204      	movs	r2, #4
34002aea:	2310      	movs	r3, #16
34002aec:	e9cd 2308 	strd	r2, r3, [sp, #32]
34002af0:	f64e 4213 	movw	r2, #60435	@ 0xec13
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002af4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
                               : HAL_XSPI_ADDRESS_32_BITS;
34002af8:	2d00      	cmp	r5, #0
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002afa:	930c      	str	r3, [sp, #48]	@ 0x30
                               : HAL_XSPI_ADDRESS_32_BITS;
34002afc:	bf14      	ite	ne
34002afe:	f44f 5340 	movne.w	r3, #12288	@ 0x3000
34002b02:	f44f 5300 	moveq.w	r3, #8192	@ 0x2000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002b06:	2c00      	cmp	r4, #0
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002b08:	9207      	str	r2, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002b0a:	bf0c      	ite	eq
34002b0c:	f04f 7280 	moveq.w	r2, #16777216	@ 0x1000000
34002b10:	f04f 6280 	movne.w	r2, #67108864	@ 0x4000000
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
34002b14:	930d      	str	r3, [sp, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002b16:	bf0c      	ite	eq
34002b18:	2308      	moveq	r3, #8
34002b1a:	230a      	movne	r3, #10
34002b1c:	9213      	str	r2, [sp, #76]	@ 0x4c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b1e:	4630      	mov	r0, r6
34002b20:	f241 3288 	movw	r2, #5000	@ 0x1388
34002b24:	a905      	add	r1, sp, #20
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
34002b26:	9316      	str	r3, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b28:	f00d fa12 	bl	3400ff50 <HAL_XSPI_Command>
34002b2c:	2800      	cmp	r0, #0
34002b2e:	d1d6      	bne.n	34002ade <MX66UW1G45G_EnableSTRMemoryMappedMode+0x24>
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
34002b30:	2302      	movs	r3, #2
34002b32:	9305      	str	r3, [sp, #20]
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002b34:	bb1c      	cbnz	r4, 34002b7e <MX66UW1G45G_EnableSTRMemoryMappedMode+0xc4>
34002b36:	2d00      	cmp	r5, #0
34002b38:	bf18      	it	ne
34002b3a:	2312      	movne	r3, #18
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002b3c:	9307      	str	r3, [sp, #28]
  s_command.DummyCycles = 0U;
34002b3e:	2300      	movs	r3, #0
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b40:	f241 3288 	movw	r2, #5000	@ 0x1388
34002b44:	4630      	mov	r0, r6
34002b46:	a905      	add	r1, sp, #20
  s_command.DummyCycles = 0U;
34002b48:	9316      	str	r3, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b4a:	f00d fa01 	bl	3400ff50 <HAL_XSPI_Command>
34002b4e:	2800      	cmp	r0, #0
34002b50:	d1c5      	bne.n	34002ade <MX66UW1G45G_EnableSTRMemoryMappedMode+0x24>
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34002b52:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34002b54:	a901      	add	r1, sp, #4
34002b56:	4630      	mov	r0, r6
34002b58:	f00d fc28 	bl	340103ac <HAL_XSPI_MemoryMapped>
34002b5c:	3800      	subs	r0, #0
34002b5e:	bf18      	it	ne
34002b60:	2001      	movne	r0, #1
34002b62:	4240      	negs	r0, r0
34002b64:	e7bd      	b.n	34002ae2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x28>
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002b66:	2301      	movs	r3, #1
34002b68:	9305      	str	r3, [sp, #20]
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34002b6a:	2c00      	cmp	r4, #0
34002b6c:	d1bc      	bne.n	34002ae8 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x2e>
                              : MX66UW1G45G_OCTA_READ_CMD;
34002b6e:	2d00      	cmp	r5, #0
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002b70:	9308      	str	r3, [sp, #32]
                              : MX66UW1G45G_OCTA_READ_CMD;
34002b72:	bf14      	ite	ne
34002b74:	220c      	movne	r2, #12
34002b76:	220b      	moveq	r2, #11
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002b78:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002b7c:	e7bc      	b.n	34002af8 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002b7e:	f241 23ed 	movw	r3, #4845	@ 0x12ed
34002b82:	e7db      	b.n	34002b3c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x82>

34002b84 <MX66UW1G45G_EnableDTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode)
{
34002b84:	b530      	push	{r4, r5, lr}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef s_command = {0};
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34002b86:	2510      	movs	r5, #16
{
34002b88:	b099      	sub	sp, #100	@ 0x64
34002b8a:	4604      	mov	r4, r0
  XSPI_RegularCmdTypeDef s_command = {0};
34002b8c:	223c      	movs	r2, #60	@ 0x3c
34002b8e:	2100      	movs	r1, #0
34002b90:	a806      	add	r0, sp, #24
34002b92:	f015 fff3 	bl	34018b7c <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34002b96:	462a      	mov	r2, r5
34002b98:	2100      	movs	r1, #0
34002b9a:	a801      	add	r0, sp, #4
34002b9c:	f015 ffee 	bl	34018b7c <memset>

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002ba0:	2301      	movs	r3, #1
34002ba2:	9305      	str	r3, [sp, #20]
  s_command.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
34002ba4:	2304      	movs	r3, #4
34002ba6:	9308      	str	r3, [sp, #32]
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
34002ba8:	2308      	movs	r3, #8
  s_command.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
34002baa:	e9cd 5309 	strd	r5, r3, [sp, #36]	@ 0x24
  s_command.Instruction = MX66UW1G45G_OCTA_READ_DTR_CMD;
34002bae:	f64e 6311 	movw	r3, #60945	@ 0xee11
34002bb2:	9307      	str	r3, [sp, #28]
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34002bb4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002bb8:	f44f 6e00 	mov.w	lr, #2048	@ 0x800
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34002bbc:	930c      	str	r3, [sp, #48]	@ 0x30
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002bbe:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002bc2:	e9cd 3e0d 	strd	r3, lr, [sp, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
34002bc6:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
34002bca:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
34002bce:	9313      	str	r3, [sp, #76]	@ 0x4c
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
34002bd0:	230a      	movs	r3, #10
34002bd2:	e9cd 1315 	strd	r1, r3, [sp, #84]	@ 0x54
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
34002bd6:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002bda:	f241 3288 	movw	r2, #5000	@ 0x1388
34002bde:	4620      	mov	r0, r4
34002be0:	a905      	add	r1, sp, #20
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
34002be2:	9317      	str	r3, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002be4:	f00d f9b4 	bl	3400ff50 <HAL_XSPI_Command>
34002be8:	b118      	cbz	r0, 34002bf2 <MX66UW1G45G_EnableDTRMemoryMappedMode+0x6e>
  {
    return MX66UW1G45G_ERROR;
34002bea:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002bee:	b019      	add	sp, #100	@ 0x64
34002bf0:	bd30      	pop	{r4, r5, pc}
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
34002bf2:	2302      	movs	r3, #2
34002bf4:	9305      	str	r3, [sp, #20]
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002bf6:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34002bfa:	e9cd 0016 	strd	r0, r0, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002bfe:	f241 3288 	movw	r2, #5000	@ 0x1388
34002c02:	4620      	mov	r0, r4
34002c04:	a905      	add	r1, sp, #20
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002c06:	9307      	str	r3, [sp, #28]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c08:	f00d f9a2 	bl	3400ff50 <HAL_XSPI_Command>
34002c0c:	2800      	cmp	r0, #0
34002c0e:	d1ec      	bne.n	34002bea <MX66UW1G45G_EnableDTRMemoryMappedMode+0x66>
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34002c10:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34002c12:	a901      	add	r1, sp, #4
34002c14:	4620      	mov	r0, r4
34002c16:	f00d fbc9 	bl	340103ac <HAL_XSPI_MemoryMapped>
34002c1a:	3800      	subs	r0, #0
34002c1c:	bf18      	it	ne
34002c1e:	2001      	movne	r0, #1
34002c20:	4240      	negs	r0, r0
34002c22:	e7e4      	b.n	34002bee <MX66UW1G45G_EnableDTRMemoryMappedMode+0x6a>

34002c24 <MX66UW1G45G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34002c24:	b5f0      	push	{r4, r5, r6, r7, lr}
34002c26:	460c      	mov	r4, r1
34002c28:	b099      	sub	sp, #100	@ 0x64
  XSPI_RegularCmdTypeDef s_command = {0};
34002c2a:	2100      	movs	r1, #0
{
34002c2c:	4606      	mov	r6, r0
34002c2e:	4615      	mov	r5, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002c30:	a805      	add	r0, sp, #20
34002c32:	224c      	movs	r2, #76	@ 0x4c
34002c34:	f015 ffa2 	bl	34018b7c <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
34002c38:	2214      	movs	r2, #20
34002c3a:	2100      	movs	r1, #0
34002c3c:	4668      	mov	r0, sp
34002c3e:	f015 ff9d 	bl	34018b7c <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002c42:	b92c      	cbnz	r4, 34002c50 <MX66UW1G45G_WriteEnable+0x2c>
34002c44:	2d01      	cmp	r5, #1
34002c46:	d15d      	bne.n	34002d04 <MX66UW1G45G_WriteEnable+0xe0>
  {
    return MX66UW1G45G_ERROR;
34002c48:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002c4c:	b019      	add	sp, #100	@ 0x64
34002c4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002c50:	2204      	movs	r2, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002c52:	1e69      	subs	r1, r5, #1
34002c54:	424b      	negs	r3, r1
34002c56:	414b      	adcs	r3, r1
34002c58:	00db      	lsls	r3, r3, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002c5a:	9208      	str	r2, [sp, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002c5c:	930a      	str	r3, [sp, #40]	@ 0x28
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002c5e:	2c00      	cmp	r4, #0
34002c60:	d053      	beq.n	34002d0a <MX66UW1G45G_WriteEnable+0xe6>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002c62:	2310      	movs	r3, #16
34002c64:	9309      	str	r3, [sp, #36]	@ 0x24
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
34002c66:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c6a:	f241 3288 	movw	r2, #5000	@ 0x1388
34002c6e:	4630      	mov	r0, r6
34002c70:	a905      	add	r1, sp, #20
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002c72:	9307      	str	r3, [sp, #28]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c74:	f00d f96c 	bl	3400ff50 <HAL_XSPI_Command>
34002c78:	4603      	mov	r3, r0
34002c7a:	2800      	cmp	r0, #0
34002c7c:	d1e4      	bne.n	34002c48 <MX66UW1G45G_WriteEnable+0x24>
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002c7e:	2c00      	cmp	r4, #0
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002c80:	f105 32ff 	add.w	r2, r5, #4294967295
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002c84:	f240 5cfa 	movw	ip, #1530	@ 0x5fa
34002c88:	bf12      	itee	ne
34002c8a:	f44f 6e80 	movne.w	lr, #1024	@ 0x400
34002c8e:	f04f 0c05 	moveq.w	ip, #5
34002c92:	f04f 0e00 	moveq.w	lr, #0
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002c96:	4257      	negs	r7, r2
34002c98:	4157      	adcs	r7, r2
34002c9a:	02ff      	lsls	r7, r7, #11
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002c9c:	2c00      	cmp	r4, #0
34002c9e:	d036      	beq.n	34002d0e <MX66UW1G45G_WriteEnable+0xea>
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002ca0:	2d01      	cmp	r5, #1
34002ca2:	d03a      	beq.n	34002d1a <MX66UW1G45G_WriteEnable+0xf6>
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002ca4:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002ca8:	2404      	movs	r4, #4
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002caa:	2101      	movs	r1, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002cac:	461a      	mov	r2, r3
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002cae:	f44f 5540 	mov.w	r5, #12288	@ 0x3000
34002cb2:	950d      	str	r5, [sp, #52]	@ 0x34
  s_command.Address = 0U;
34002cb4:	2500      	movs	r5, #0
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002cb6:	9013      	str	r0, [sp, #76]	@ 0x4c
34002cb8:	9114      	str	r1, [sp, #80]	@ 0x50
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002cba:	9217      	str	r2, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002cbc:	4630      	mov	r0, r6
34002cbe:	f241 3288 	movw	r2, #5000	@ 0x1388
34002cc2:	a905      	add	r1, sp, #20
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002cc4:	e9cd 3415 	strd	r3, r4, [sp, #84]	@ 0x54
34002cc8:	f8cd c01c 	str.w	ip, [sp, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002ccc:	f8cd e030 	str.w	lr, [sp, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002cd0:	970e      	str	r7, [sp, #56]	@ 0x38
  s_command.Address = 0U;
34002cd2:	950b      	str	r5, [sp, #44]	@ 0x2c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002cd4:	f00d f93c 	bl	3400ff50 <HAL_XSPI_Command>
34002cd8:	2800      	cmp	r0, #0
34002cda:	d1b5      	bne.n	34002c48 <MX66UW1G45G_WriteEnable+0x24>
  s_config.MatchValue = 2U;
34002cdc:	2302      	movs	r3, #2
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002cde:	2210      	movs	r2, #16
  s_config.MatchMask = 2U;
34002ce0:	e9cd 3300 	strd	r3, r3, [sp]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002ce4:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
34002ce8:	9002      	str	r0, [sp, #8]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002cea:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002cee:	4669      	mov	r1, sp
34002cf0:	f241 3288 	movw	r2, #5000	@ 0x1388
34002cf4:	4630      	mov	r0, r6
34002cf6:	f00d fadd 	bl	340102b4 <HAL_XSPI_AutoPolling>
34002cfa:	1b40      	subs	r0, r0, r5
34002cfc:	bf18      	it	ne
34002cfe:	2001      	movne	r0, #1
34002d00:	4240      	negs	r0, r0
34002d02:	e7a3      	b.n	34002c4c <MX66UW1G45G_WriteEnable+0x28>
34002d04:	2201      	movs	r2, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002d06:	4623      	mov	r3, r4
34002d08:	e7a7      	b.n	34002c5a <MX66UW1G45G_WriteEnable+0x36>
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
34002d0a:	2306      	movs	r3, #6
34002d0c:	e7ad      	b.n	34002c6a <MX66UW1G45G_WriteEnable+0x46>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002d0e:	2d01      	cmp	r5, #1
34002d10:	d00c      	beq.n	34002d2c <MX66UW1G45G_WriteEnable+0x108>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34002d12:	4623      	mov	r3, r4
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d14:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
34002d18:	e7c7      	b.n	34002caa <MX66UW1G45G_WriteEnable+0x86>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34002d1a:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d1e:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
34002d22:	2405      	movs	r4, #5
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002d24:	2102      	movs	r1, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002d26:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34002d2a:	e7c0      	b.n	34002cae <MX66UW1G45G_WriteEnable+0x8a>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34002d2c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d30:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
34002d34:	e7f6      	b.n	34002d24 <MX66UW1G45G_WriteEnable+0x100>

34002d36 <MX66UW1G45G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX66UW1G45G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                      MX66UW1G45G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
34002d36:	b5f0      	push	{r4, r5, r6, r7, lr}
34002d38:	460d      	mov	r5, r1
34002d3a:	b095      	sub	sp, #84	@ 0x54
34002d3c:	4606      	mov	r6, r0
34002d3e:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002d40:	2100      	movs	r1, #0
34002d42:	224c      	movs	r2, #76	@ 0x4c
34002d44:	a801      	add	r0, sp, #4
{
34002d46:	461f      	mov	r7, r3
  XSPI_RegularCmdTypeDef s_command = {0};
34002d48:	f015 ff18 	bl	34018b7c <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002d4c:	b92d      	cbnz	r5, 34002d5a <MX66UW1G45G_WriteCfg2Register+0x24>
34002d4e:	2c01      	cmp	r4, #1
34002d50:	d140      	bne.n	34002dd4 <MX66UW1G45G_WriteCfg2Register+0x9e>
  {
    return MX66UW1G45G_ERROR;
34002d52:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002d56:	b015      	add	sp, #84	@ 0x54
34002d58:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002d5a:	2304      	movs	r3, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002d5c:	1e61      	subs	r1, r4, #1
34002d5e:	424a      	negs	r2, r1
34002d60:	414a      	adcs	r2, r1
34002d62:	00d2      	lsls	r2, r2, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002d64:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002d66:	9206      	str	r2, [sp, #24]
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002d68:	2d00      	cmp	r5, #0
34002d6a:	d036      	beq.n	34002dda <MX66UW1G45G_WriteCfg2Register+0xa4>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002d6c:	2310      	movs	r3, #16
34002d6e:	f247 228d 	movw	r2, #29325	@ 0x728d
34002d72:	9305      	str	r3, [sp, #20]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002d74:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002d78:	9308      	str	r3, [sp, #32]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002d7a:	1e63      	subs	r3, r4, #1
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002d7c:	9203      	str	r2, [sp, #12]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002d7e:	425a      	negs	r2, r3
34002d80:	415a      	adcs	r2, r3
34002d82:	02d3      	lsls	r3, r2, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002d84:	930a      	str	r3, [sp, #40]	@ 0x28
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002d86:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d8a:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002d8c:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d8e:	bf14      	ite	ne
34002d90:	f04f 6380 	movne.w	r3, #67108864	@ 0x4000000
34002d94:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34002d98:	ea4f 62c2 	mov.w	r2, r2, lsl #27
  s_command.Address = WriteAddr;
34002d9c:	9707      	str	r7, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d9e:	930f      	str	r3, [sp, #60]	@ 0x3c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002da0:	9211      	str	r2, [sp, #68]	@ 0x44
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34002da2:	d01e      	beq.n	34002de2 <MX66UW1G45G_WriteCfg2Register+0xac>
34002da4:	2c01      	cmp	r4, #1
34002da6:	bf0c      	ite	eq
34002da8:	2302      	moveq	r3, #2
34002daa:	2301      	movne	r3, #1
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002dac:	f241 3288 	movw	r2, #5000	@ 0x1388
34002db0:	4630      	mov	r0, r6
34002db2:	a901      	add	r1, sp, #4
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34002db4:	9310      	str	r3, [sp, #64]	@ 0x40
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002db6:	f00d f8cb 	bl	3400ff50 <HAL_XSPI_Command>
34002dba:	2800      	cmp	r0, #0
34002dbc:	d1c9      	bne.n	34002d52 <MX66UW1G45G_WriteCfg2Register+0x1c>
  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002dbe:	f241 3288 	movw	r2, #5000	@ 0x1388
34002dc2:	4630      	mov	r0, r6
34002dc4:	a91a      	add	r1, sp, #104	@ 0x68
34002dc6:	f00d f9db 	bl	34010180 <HAL_XSPI_Transmit>
34002dca:	3800      	subs	r0, #0
34002dcc:	bf18      	it	ne
34002dce:	2001      	movne	r0, #1
34002dd0:	4240      	negs	r0, r0
34002dd2:	e7c0      	b.n	34002d56 <MX66UW1G45G_WriteCfg2Register+0x20>
34002dd4:	2301      	movs	r3, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002dd6:	462a      	mov	r2, r5
34002dd8:	e7c4      	b.n	34002d64 <MX66UW1G45G_WriteCfg2Register+0x2e>
34002dda:	2272      	movs	r2, #114	@ 0x72
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002ddc:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002de0:	e7ca      	b.n	34002d78 <MX66UW1G45G_WriteCfg2Register+0x42>
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34002de2:	2301      	movs	r3, #1
34002de4:	e7e2      	b.n	34002dac <MX66UW1G45G_WriteCfg2Register+0x76>

34002de6 <MX66UW1G45G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX66UW1G45G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                     MX66UW1G45G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
34002de6:	b5f0      	push	{r4, r5, r6, r7, lr}
34002de8:	460d      	mov	r5, r1
34002dea:	b095      	sub	sp, #84	@ 0x54
34002dec:	4606      	mov	r6, r0
34002dee:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002df0:	2100      	movs	r1, #0
34002df2:	224c      	movs	r2, #76	@ 0x4c
34002df4:	a801      	add	r0, sp, #4
{
34002df6:	461f      	mov	r7, r3
  XSPI_RegularCmdTypeDef s_command = {0};
34002df8:	f015 fec0 	bl	34018b7c <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002dfc:	b92d      	cbnz	r5, 34002e0a <MX66UW1G45G_ReadCfg2Register+0x24>
34002dfe:	2c01      	cmp	r4, #1
34002e00:	d144      	bne.n	34002e8c <MX66UW1G45G_ReadCfg2Register+0xa6>
  {
    return MX66UW1G45G_ERROR;
34002e02:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002e06:	b015      	add	sp, #84	@ 0x54
34002e08:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e0a:	2304      	movs	r3, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002e0c:	1e61      	subs	r1, r4, #1
34002e0e:	424a      	negs	r2, r1
34002e10:	414a      	adcs	r2, r1
34002e12:	00d2      	lsls	r2, r2, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002e14:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e16:	9206      	str	r2, [sp, #24]
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002e18:	2d00      	cmp	r5, #0
34002e1a:	d03a      	beq.n	34002e92 <MX66UW1G45G_ReadCfg2Register+0xac>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002e1c:	2310      	movs	r3, #16
34002e1e:	f247 128e 	movw	r2, #29070	@ 0x718e
34002e22:	9305      	str	r3, [sp, #20]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002e24:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002e28:	9308      	str	r3, [sp, #32]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002e2a:	1e63      	subs	r3, r4, #1
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002e2c:	9203      	str	r2, [sp, #12]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002e2e:	425a      	negs	r2, r3
34002e30:	415a      	adcs	r2, r3
34002e32:	02d3      	lsls	r3, r2, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e34:	930a      	str	r3, [sp, #40]	@ 0x28
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002e36:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e3a:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002e3c:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e3e:	bf14      	ite	ne
34002e40:	f04f 6380 	movne.w	r3, #67108864	@ 0x4000000
34002e44:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34002e48:	ea4f 62c2 	mov.w	r2, r2, lsl #27
  s_command.Address = ReadAddr;
34002e4c:	9707      	str	r7, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e4e:	930f      	str	r3, [sp, #60]	@ 0x3c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e50:	9211      	str	r2, [sp, #68]	@ 0x44
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002e52:	d027      	beq.n	34002ea4 <MX66UW1G45G_ReadCfg2Register+0xbe>
34002e54:	2c01      	cmp	r4, #1
34002e56:	d120      	bne.n	34002e9a <MX66UW1G45G_ReadCfg2Register+0xb4>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002e58:	2305      	movs	r3, #5
34002e5a:	9312      	str	r3, [sp, #72]	@ 0x48
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002e5c:	2202      	movs	r2, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002e5e:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34002e62:	9210      	str	r2, [sp, #64]	@ 0x40
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e64:	4630      	mov	r0, r6
34002e66:	f241 3288 	movw	r2, #5000	@ 0x1388
34002e6a:	a901      	add	r1, sp, #4
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002e6c:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e6e:	f00d f86f 	bl	3400ff50 <HAL_XSPI_Command>
34002e72:	2800      	cmp	r0, #0
34002e74:	d1c5      	bne.n	34002e02 <MX66UW1G45G_ReadCfg2Register+0x1c>
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e76:	f241 3288 	movw	r2, #5000	@ 0x1388
34002e7a:	4630      	mov	r0, r6
34002e7c:	991a      	ldr	r1, [sp, #104]	@ 0x68
34002e7e:	f00d f9c3 	bl	34010208 <HAL_XSPI_Receive>
34002e82:	3800      	subs	r0, #0
34002e84:	bf18      	it	ne
34002e86:	2001      	movne	r0, #1
34002e88:	4240      	negs	r0, r0
34002e8a:	e7bc      	b.n	34002e06 <MX66UW1G45G_ReadCfg2Register+0x20>
34002e8c:	2301      	movs	r3, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002e8e:	462a      	mov	r2, r5
34002e90:	e7c0      	b.n	34002e14 <MX66UW1G45G_ReadCfg2Register+0x2e>
34002e92:	2271      	movs	r2, #113	@ 0x71
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002e94:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002e98:	e7c6      	b.n	34002e28 <MX66UW1G45G_ReadCfg2Register+0x42>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002e9a:	2304      	movs	r3, #4
34002e9c:	9312      	str	r3, [sp, #72]	@ 0x48
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002e9e:	2201      	movs	r2, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002ea0:	2300      	movs	r3, #0
34002ea2:	e7de      	b.n	34002e62 <MX66UW1G45G_ReadCfg2Register+0x7c>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002ea4:	2c01      	cmp	r4, #1
34002ea6:	d1fa      	bne.n	34002e9e <MX66UW1G45G_ReadCfg2Register+0xb8>
34002ea8:	e7d8      	b.n	34002e5c <MX66UW1G45G_ReadCfg2Register+0x76>

34002eaa <MX66UW1G45G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34002eaa:	b570      	push	{r4, r5, r6, lr}
34002eac:	460d      	mov	r5, r1
34002eae:	b094      	sub	sp, #80	@ 0x50
34002eb0:	4606      	mov	r6, r0
34002eb2:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002eb4:	2100      	movs	r1, #0
34002eb6:	224c      	movs	r2, #76	@ 0x4c
34002eb8:	a801      	add	r0, sp, #4
34002eba:	f015 fe5f 	bl	34018b7c <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002ebe:	b9d5      	cbnz	r5, 34002ef6 <MX66UW1G45G_ResetEnable+0x4c>
34002ec0:	2c01      	cmp	r4, #1
34002ec2:	d01c      	beq.n	34002efe <MX66UW1G45G_ResetEnable+0x54>
  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
  s_command.IOSelect =  HAL_XSPI_SELECT_IO_3_0;
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34002ec4:	2301      	movs	r3, #1
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002ec6:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002ec8:	1e63      	subs	r3, r4, #1
34002eca:	425c      	negs	r4, r3
34002ecc:	415c      	adcs	r4, r3
34002ece:	00e4      	lsls	r4, r4, #3
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002ed0:	9406      	str	r4, [sp, #24]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002ed2:	b195      	cbz	r5, 34002efa <MX66UW1G45G_ResetEnable+0x50>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002ed4:	2310      	movs	r3, #16
34002ed6:	9305      	str	r3, [sp, #20]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_ENABLE_CMD
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34002ed8:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.DummyCycles = 0U;
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;


  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002edc:	f241 3288 	movw	r2, #5000	@ 0x1388
34002ee0:	4630      	mov	r0, r6
34002ee2:	a901      	add	r1, sp, #4
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002ee4:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002ee6:	f00d f833 	bl	3400ff50 <HAL_XSPI_Command>
34002eea:	3800      	subs	r0, #0
34002eec:	bf18      	it	ne
34002eee:	2001      	movne	r0, #1
34002ef0:	4240      	negs	r0, r0
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002ef2:	b014      	add	sp, #80	@ 0x50
34002ef4:	bd70      	pop	{r4, r5, r6, pc}
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34002ef6:	2304      	movs	r3, #4
34002ef8:	e7e5      	b.n	34002ec6 <MX66UW1G45G_ResetEnable+0x1c>
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34002efa:	2366      	movs	r3, #102	@ 0x66
34002efc:	e7ee      	b.n	34002edc <MX66UW1G45G_ResetEnable+0x32>
    return MX66UW1G45G_ERROR;
34002efe:	f04f 30ff 	mov.w	r0, #4294967295
34002f02:	e7f6      	b.n	34002ef2 <MX66UW1G45G_ResetEnable+0x48>

34002f04 <MX66UW1G45G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34002f04:	b570      	push	{r4, r5, r6, lr}
34002f06:	460d      	mov	r5, r1
34002f08:	b094      	sub	sp, #80	@ 0x50
34002f0a:	4606      	mov	r6, r0
34002f0c:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002f0e:	2100      	movs	r1, #0
34002f10:	224c      	movs	r2, #76	@ 0x4c
34002f12:	a801      	add	r0, sp, #4
34002f14:	f015 fe32 	bl	34018b7c <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002f18:	b9bd      	cbnz	r5, 34002f4a <MX66UW1G45G_ResetMemory+0x46>
34002f1a:	2c01      	cmp	r4, #1
34002f1c:	d01d      	beq.n	34002f5a <MX66UW1G45G_ResetMemory+0x56>
34002f1e:	2301      	movs	r3, #1
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002f20:	462c      	mov	r4, r5
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002f22:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002f24:	9406      	str	r4, [sp, #24]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002f26:	b1b5      	cbz	r5, 34002f56 <MX66UW1G45G_ResetMemory+0x52>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002f28:	2310      	movs	r3, #16
34002f2a:	9305      	str	r3, [sp, #20]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_MEMORY_CMD
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34002f2c:	f649 1366 	movw	r3, #39270	@ 0x9966
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002f30:	f241 3288 	movw	r2, #5000	@ 0x1388
34002f34:	4630      	mov	r0, r6
34002f36:	a901      	add	r1, sp, #4
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002f38:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002f3a:	f00d f809 	bl	3400ff50 <HAL_XSPI_Command>
34002f3e:	3800      	subs	r0, #0
34002f40:	bf18      	it	ne
34002f42:	2001      	movne	r0, #1
34002f44:	4240      	negs	r0, r0
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002f46:	b014      	add	sp, #80	@ 0x50
34002f48:	bd70      	pop	{r4, r5, r6, pc}
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002f4a:	1e63      	subs	r3, r4, #1
34002f4c:	425c      	negs	r4, r3
34002f4e:	415c      	adcs	r4, r3
34002f50:	00e4      	lsls	r4, r4, #3
34002f52:	2304      	movs	r3, #4
34002f54:	e7e5      	b.n	34002f22 <MX66UW1G45G_ResetMemory+0x1e>
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34002f56:	2399      	movs	r3, #153	@ 0x99
34002f58:	e7ea      	b.n	34002f30 <MX66UW1G45G_ResetMemory+0x2c>
    return MX66UW1G45G_ERROR;
34002f5a:	f04f 30ff 	mov.w	r0, #4294967295
34002f5e:	e7f2      	b.n	34002f46 <MX66UW1G45G_ResetMemory+0x42>

34002f60 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002f60:	4b04      	ldr	r3, [pc, #16]	@ (34002f74 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34002f62:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34002f64:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34002f68:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34002f6c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34002f6e:	9b01      	ldr	r3, [sp, #4]
}
34002f70:	b002      	add	sp, #8
34002f72:	4770      	bx	lr
34002f74:	56028000 	.word	0x56028000

34002f78 <BSP_SMPS_Init>:
  * @param Voltage configuration
  *          This parameter can be one of the following values:
  *            @arg  SMPS_VOLTAGE_NOMINAL
  *            @arg  SMPS_VOLTAGE_OVERDRIVE
  */
void BSP_SMPS_Init(SMPSVoltage_TypeDef Voltage){
34002f78:	b570      	push	{r4, r5, r6, lr}
34002f7a:	4604      	mov	r4, r0
34002f7c:	b086      	sub	sp, #24
  SMPS_GPIO_CLK_ENABLE();
34002f7e:	2020      	movs	r0, #32
34002f80:	f7ff ffee 	bl	34002f60 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitTypeDef  gpio_init_structure = {0};
34002f84:	2300      	movs	r3, #0
  /* configure the external SMPS control pin */
  gpio_init_structure.Pin = SMPS_GPIO_PIN;
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34002f86:	2610      	movs	r6, #16
  GPIO_InitTypeDef  gpio_init_structure = {0};
34002f88:	9303      	str	r3, [sp, #12]
34002f8a:	9305      	str	r3, [sp, #20]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34002f8c:	2301      	movs	r3, #1
34002f8e:	e9cd 6301 	strd	r6, r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002f92:	2303      	movs	r3, #3
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34002f94:	4d06      	ldr	r5, [pc, #24]	@ (34002fb0 <BSP_SMPS_Init+0x38>)
34002f96:	a901      	add	r1, sp, #4
34002f98:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34002f9a:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34002f9c:	f004 fac6 	bl	3400752c <HAL_GPIO_Init>

  HAL_GPIO_WritePin(SMPS_GPIO_PORT, SMPS_GPIO_PIN, (GPIO_PinState) Voltage);
34002fa0:	4622      	mov	r2, r4
34002fa2:	4631      	mov	r1, r6
34002fa4:	4628      	mov	r0, r5
34002fa6:	f004 fe07 	bl	34007bb8 <HAL_GPIO_WritePin>
}
34002faa:	b006      	add	sp, #24
34002fac:	bd70      	pop	{r4, r5, r6, pc}
34002fae:	bf00      	nop
34002fb0:	56021400 	.word	0x56021400

34002fb4 <MX_USART1_Init>:
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
  /* USART configuration */
  huart->Instance          = COM_UART[COM1];
34002fb4:	4a09      	ldr	r2, [pc, #36]	@ (34002fdc <MX_USART1_Init+0x28>)
34002fb6:	6812      	ldr	r2, [r2, #0]
34002fb8:	6002      	str	r2, [r0, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
34002fba:	680a      	ldr	r2, [r1, #0]
34002fbc:	6042      	str	r2, [r0, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
34002fbe:	220c      	movs	r2, #12
34002fc0:	6142      	str	r2, [r0, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
34002fc2:	894a      	ldrh	r2, [r1, #10]
34002fc4:	6102      	str	r2, [r0, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
34002fc6:	684a      	ldr	r2, [r1, #4]
34002fc8:	6082      	str	r2, [r0, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
34002fca:	890a      	ldrh	r2, [r1, #8]
34002fcc:	60c2      	str	r2, [r0, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
34002fce:	898a      	ldrh	r2, [r1, #12]
34002fd0:	6182      	str	r2, [r0, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
34002fd2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34002fd6:	61c2      	str	r2, [r0, #28]

  return HAL_UART_Init(huart);
34002fd8:	f00c bc62 	b.w	3400f8a0 <HAL_UART_Init>
34002fdc:	3403ecb4 	.word	0x3403ecb4

34002fe0 <MX_USART2_Init>:
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART2_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
  /* USART configuration */
  huart->Instance          = COM_UART[COM2];
34002fe0:	4a09      	ldr	r2, [pc, #36]	@ (34003008 <MX_USART2_Init+0x28>)
34002fe2:	6852      	ldr	r2, [r2, #4]
34002fe4:	6002      	str	r2, [r0, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
34002fe6:	680a      	ldr	r2, [r1, #0]
34002fe8:	6042      	str	r2, [r0, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
34002fea:	220c      	movs	r2, #12
34002fec:	6142      	str	r2, [r0, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
34002fee:	894a      	ldrh	r2, [r1, #10]
34002ff0:	6102      	str	r2, [r0, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
34002ff2:	684a      	ldr	r2, [r1, #4]
34002ff4:	6082      	str	r2, [r0, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
34002ff6:	890a      	ldrh	r2, [r1, #8]
34002ff8:	60c2      	str	r2, [r0, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
34002ffa:	898a      	ldrh	r2, [r1, #12]
34002ffc:	6182      	str	r2, [r0, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
34002ffe:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34003002:	61c2      	str	r2, [r0, #28]

  return HAL_UART_Init(huart);
34003004:	f00c bc4c 	b.w	3400f8a0 <HAL_UART_Init>
34003008:	3403ecb4 	.word	0x3403ecb4

3400300c <BSP_COM_Init>:
{
3400300c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(COM >= COMn)
34003010:	2801      	cmp	r0, #1
{
34003012:	4604      	mov	r4, r0
34003014:	460f      	mov	r7, r1
34003016:	b08e      	sub	sp, #56	@ 0x38
  if(COM >= COMn)
34003018:	d870      	bhi.n	340030fc <BSP_COM_Init+0xf0>
    hcom_uart[COM].Instance = COM_UART[COM];
3400301a:	2294      	movs	r2, #148	@ 0x94
3400301c:	4b39      	ldr	r3, [pc, #228]	@ (34003104 <BSP_COM_Init+0xf8>)
3400301e:	4342      	muls	r2, r0
34003020:	4939      	ldr	r1, [pc, #228]	@ (34003108 <BSP_COM_Init+0xfc>)
34003022:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    UART_MspInit(&hcom_uart[COM]);
34003026:	4245      	negs	r5, r0
34003028:	f005 0594 	and.w	r5, r5, #148	@ 0x94
    hcom_uart[COM].Instance = COM_UART[COM];
3400302c:	508b      	str	r3, [r1, r2]
    UART_MspInit(&hcom_uart[COM]);
3400302e:	440d      	add	r5, r1
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
  GPIO_InitTypeDef GPIO_Init;
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
34003030:	4a36      	ldr	r2, [pc, #216]	@ (3400310c <BSP_COM_Init+0x100>)
34003032:	4937      	ldr	r1, [pc, #220]	@ (34003110 <BSP_COM_Init+0x104>)
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
34003034:	9207      	str	r2, [sp, #28]
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
34003036:	e9cd 2105 	strd	r2, r1, [sp, #20]
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
3400303a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400303e:	9208      	str	r2, [sp, #32]
  uint16_t         COM_TX_PIN[COMn]  = {COM1_TX_PIN, COM2_TX_PIN};
  uint16_t         COM_RX_PIN[COMn]  = {COM1_RX_PIN, COM2_RX_PIN};
34003040:	f04f 1240 	mov.w	r2, #4194368	@ 0x400040
34003044:	9202      	str	r2, [sp, #8]
  uint8_t          COM_TX_AF[COMn]   = {COM1_TX_AF, COM2_TX_AF};
  uint8_t          COM_RX_AF[COMn]   = {COM1_RX_AF, COM2_RX_AF};
34003046:	f240 7207 	movw	r2, #1799	@ 0x707
3400304a:	f8ad 2004 	strh.w	r2, [sp, #4]
  COM_TypeDef      COM;

  /* Get COM according instance */
  if (huart->Instance == COM1_UART)
3400304e:	4a31      	ldr	r2, [pc, #196]	@ (34003114 <BSP_COM_Init+0x108>)
34003050:	4293      	cmp	r3, r2
34003052:	d13a      	bne.n	340030ca <BSP_COM_Init+0xbe>
  {
    COM = COM1;
    /* Enable COM and GPIO clocks */
    COM1_TX_GPIO_CLK_ENABLE();
34003054:	2010      	movs	r0, #16
    COM = COM1;
34003056:	2600      	movs	r6, #0
    COM1_TX_GPIO_CLK_ENABLE();
34003058:	f7ff ff82 	bl	34002f60 <LL_AHB4_GRP1_EnableClock>
    COM1_RX_GPIO_CLK_ENABLE();
3400305c:	f7ff ff80 	bl	34002f60 <LL_AHB4_GRP1_EnableClock>
  WRITE_REG(RCC->APB2ENSR, Periphs);
34003060:	4b2d      	ldr	r3, [pc, #180]	@ (34003118 <BSP_COM_Init+0x10c>)
34003062:	f8c3 0a6c 	str.w	r0, [r3, #2668]	@ 0xa6c
  tmpreg = READ_REG(RCC->APB2ENR);
34003066:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
3400306a:	9303      	str	r3, [sp, #12]
  (void)tmpreg;
3400306c:	9b03      	ldr	r3, [sp, #12]
      return;
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
3400306e:	2302      	movs	r3, #2
34003070:	2220      	movs	r2, #32
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
34003072:	930c      	str	r3, [sp, #48]	@ 0x30
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
34003074:	e9cd 2309 	strd	r2, r3, [sp, #36]	@ 0x24
  GPIO_Init.Pull      = GPIO_PULLUP;
34003078:	2301      	movs	r3, #1
3400307a:	930b      	str	r3, [sp, #44]	@ 0x2c
  GPIO_Init.Alternate = COM_TX_AF[COM];
3400307c:	2307      	movs	r3, #7
3400307e:	930d      	str	r3, [sp, #52]	@ 0x34
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
34003080:	ab0e      	add	r3, sp, #56	@ 0x38
34003082:	eb03 0886 	add.w	r8, r3, r6, lsl #2
34003086:	f858 0c24 	ldr.w	r0, [r8, #-36]
3400308a:	a909      	add	r1, sp, #36	@ 0x24
3400308c:	f004 fa4e 	bl	3400752c <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
34003090:	ab0e      	add	r3, sp, #56	@ 0x38
34003092:	eb03 0346 	add.w	r3, r3, r6, lsl #1
34003096:	f833 3c30 	ldrh.w	r3, [r3, #-48]
  GPIO_Init.Alternate = COM_RX_AF[COM];
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
3400309a:	f858 0c1c 	ldr.w	r0, [r8, #-28]
  GPIO_Init.Pin       = COM_RX_PIN[COM];
3400309e:	9309      	str	r3, [sp, #36]	@ 0x24
  GPIO_Init.Alternate = COM_RX_AF[COM];
340030a0:	f106 0338 	add.w	r3, r6, #56	@ 0x38
340030a4:	eb0d 0603 	add.w	r6, sp, r3
340030a8:	f816 3c34 	ldrb.w	r3, [r6, #-52]
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
340030ac:	a909      	add	r1, sp, #36	@ 0x24
  GPIO_Init.Alternate = COM_RX_AF[COM];
340030ae:	930d      	str	r3, [sp, #52]	@ 0x34
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
340030b0:	f004 fa3c 	bl	3400752c <HAL_GPIO_Init>
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
340030b4:	4639      	mov	r1, r7
340030b6:	4628      	mov	r0, r5
      if (COM == COM1)
340030b8:	b9ec      	cbnz	r4, 340030f6 <BSP_COM_Init+0xea>
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
340030ba:	f7ff ff7b 	bl	34002fb4 <MX_USART1_Init>
340030be:	b1c0      	cbz	r0, 340030f2 <BSP_COM_Init+0xe6>
          ret = BSP_ERROR_PERIPH_FAILURE;
340030c0:	f06f 0003 	mvn.w	r0, #3
}
340030c4:	b00e      	add	sp, #56	@ 0x38
340030c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (huart->Instance == COM2_UART)
340030ca:	4a14      	ldr	r2, [pc, #80]	@ (3400311c <BSP_COM_Init+0x110>)
340030cc:	4293      	cmp	r3, r2
340030ce:	d1f1      	bne.n	340030b4 <BSP_COM_Init+0xa8>
  WRITE_REG(RCC->APB1ENSR1, Periphs);
340030d0:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
    COM2_TX_GPIO_CLK_ENABLE();
340030d4:	2008      	movs	r0, #8
340030d6:	f7ff ff43 	bl	34002f60 <LL_AHB4_GRP1_EnableClock>
    COM2_RX_GPIO_CLK_ENABLE();
340030da:	2020      	movs	r0, #32
340030dc:	f7ff ff40 	bl	34002f60 <LL_AHB4_GRP1_EnableClock>
340030e0:	4b0d      	ldr	r3, [pc, #52]	@ (34003118 <BSP_COM_Init+0x10c>)
    COM = COM2;
340030e2:	2601      	movs	r6, #1
340030e4:	f8c3 2a64 	str.w	r2, [r3, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
340030e8:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
340030ec:	9304      	str	r3, [sp, #16]
  (void)tmpreg;
340030ee:	9b04      	ldr	r3, [sp, #16]
}
340030f0:	e7bd      	b.n	3400306e <BSP_COM_Init+0x62>
  int32_t ret = BSP_ERROR_NONE;
340030f2:	2000      	movs	r0, #0
340030f4:	e7e6      	b.n	340030c4 <BSP_COM_Init+0xb8>
        if (MX_USART2_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
340030f6:	f7ff ff73 	bl	34002fe0 <MX_USART2_Init>
340030fa:	e7e0      	b.n	340030be <BSP_COM_Init+0xb2>
    ret = BSP_ERROR_WRONG_PARAM;
340030fc:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003100:	e7e0      	b.n	340030c4 <BSP_COM_Init+0xb8>
34003102:	bf00      	nop
34003104:	3403ecb4 	.word	0x3403ecb4
34003108:	34042f80 	.word	0x34042f80
3400310c:	56021000 	.word	0x56021000
34003110:	56020c00 	.word	0x56020c00
34003114:	52001000 	.word	0x52001000
34003118:	56028000 	.word	0x56028000
3400311c:	50004400 	.word	0x50004400

34003120 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003120:	4b04      	ldr	r3, [pc, #16]	@ (34003134 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34003122:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003124:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34003128:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3400312c:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
3400312e:	9b01      	ldr	r3, [sp, #4]
}
34003130:	b002      	add	sp, #8
34003132:	4770      	bx	lr
34003134:	56028000 	.word	0x56028000

34003138 <I2C_GetTiming.constprop.0>:
  * @brief  Compute I2C timing according current I2C clock source and required I2C clock.
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
34003138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400313c:	b08b      	sub	sp, #44	@ 0x2c
{
  uint32_t ret = 0;
  uint32_t speed;
  uint32_t idx;

  if ((clock_src_freq != 0U) && (i2c_freq != 0U))
3400313e:	b918      	cbnz	r0, 34003148 <I2C_GetTiming.constprop.0+0x10>
  uint32_t ret = 0;
34003140:	2000      	movs	r0, #0
      }
    }
  }

  return ret;
}
34003142:	b00b      	add	sp, #44	@ 0x2c
34003144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint32_t scldel;
  uint32_t sdadel;
  uint32_t tafdel_min;
  uint32_t tafdel_max;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34003148:	4b6f      	ldr	r3, [pc, #444]	@ (34003308 <I2C_GetTiming.constprop.0+0x1d0>)
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / tPRESC */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
3400314a:	f640 15f6 	movw	r5, #2550	@ 0x9f6
  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
3400314e:	eb03 0350 	add.w	r3, r3, r0, lsr #1
34003152:	fbb3 f3f0 	udiv	r3, r3, r0
34003156:	9300      	str	r3, [sp, #0]
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34003158:	005b      	lsls	r3, r3, #1
3400315a:	9301      	str	r3, [sp, #4]
3400315c:	9b00      	ldr	r3, [sp, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
3400315e:	f04f 0b10 	mov.w	fp, #16
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34003162:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34003166:	eba5 0583 	sub.w	r5, r5, r3, lsl #2
  if (tsdadel_min <= 0)
  {
    tsdadel_min = 0;
  }

  if (tsdadel_max <= 0)
3400316a:	4619      	mov	r1, r3
3400316c:	2300      	movs	r3, #0
3400316e:	469a      	mov	sl, r3
34003170:	f8df c19c 	ldr.w	ip, [pc, #412]	@ 34003310 <I2C_GetTiming.constprop.0+0x1d8>
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34003174:	f1c4 24ff 	rsb	r4, r4, #4278255360	@ 0xff00ff00
34003178:	f504 047f 	add.w	r4, r4, #16711680	@ 0xff0000
3400317c:	34e2      	adds	r4, #226	@ 0xe2
3400317e:	f8dc 2000 	ldr.w	r2, [ip]
  if (tsdadel_min <= 0)
34003182:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
  if (tsdadel_max <= 0)
34003186:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
3400318a:	468e      	mov	lr, r1
    tsdadel_max = 0;
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
3400318c:	2700      	movs	r7, #0
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;

      if (tscldel >= (uint32_t)tscldel_min)
3400318e:	f240 3079 	movw	r0, #889	@ 0x379
34003192:	4586      	cmp	lr, r0
34003194:	9702      	str	r7, [sp, #8]
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
34003196:	f107 0701 	add.w	r7, r7, #1
      if (tscldel >= (uint32_t)tscldel_min)
3400319a:	d950      	bls.n	3400323e <I2C_GetTiming.constprop.0+0x106>
3400319c:	2600      	movs	r6, #0
3400319e:	f04f 0810 	mov.w	r8, #16
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
340031a2:	46b1      	mov	r9, r6
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
340031a4:	42b4      	cmp	r4, r6
340031a6:	d844      	bhi.n	34003232 <I2C_GetTiming.constprop.0+0xfa>
340031a8:	42b5      	cmp	r5, r6
340031aa:	d342      	bcc.n	34003232 <I2C_GetTiming.constprop.0+0xfa>
          {
            if (presc != prev_presc)
340031ac:	459b      	cmp	fp, r3
340031ae:	d040      	beq.n	34003232 <I2C_GetTiming.constprop.0+0xfa>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
340031b0:	2014      	movs	r0, #20
340031b2:	fb00 fb02 	mul.w	fp, r0, r2
340031b6:	4855      	ldr	r0, [pc, #340]	@ (3400330c <I2C_GetTiming.constprop.0+0x1d4>)
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
              prev_presc = presc;
              I2c_valid_timing_nbr ++;
340031b8:	3201      	adds	r2, #1
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
340031ba:	eb00 0a0b 	add.w	sl, r0, fp
340031be:	f840 300b 	str.w	r3, [r0, fp]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
340031c2:	9802      	ldr	r0, [sp, #8]

              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
340031c4:	2a7f      	cmp	r2, #127	@ 0x7f
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
340031c6:	e9ca 0901 	strd	r0, r9, [sl, #4]
              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
340031ca:	d92f      	bls.n	3400322c <I2C_GetTiming.constprop.0+0xf4>
340031cc:	f8cc 2000 	str.w	r2, [ip]
  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;

  prev_error = ti2cspeed;

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340031d0:	f8dc 3000 	ldr.w	r3, [ip]
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
340031d4:	2600      	movs	r6, #0
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340031d6:	9306      	str	r3, [sp, #24]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
340031d8:	f242 7310 	movw	r3, #10000	@ 0x2710
340031dc:	f04f 32ff 	mov.w	r2, #4294967295
340031e0:	9304      	str	r3, [sp, #16]
340031e2:	9b01      	ldr	r3, [sp, #4]
340031e4:	4949      	ldr	r1, [pc, #292]	@ (3400330c <I2C_GetTiming.constprop.0+0x1d4>)
340031e6:	3332      	adds	r3, #50	@ 0x32
340031e8:	9309      	str	r3, [sp, #36]	@ 0x24
340031ea:	9b01      	ldr	r3, [sp, #4]
340031ec:	f5c3 5e90 	rsb	lr, r3, #4608	@ 0x1200
340031f0:	f10e 0e0c 	add.w	lr, lr, #12
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340031f4:	9b06      	ldr	r3, [sp, #24]
340031f6:	429e      	cmp	r6, r3
340031f8:	d12d      	bne.n	34003256 <I2C_GetTiming.constprop.0+0x11e>
        if (idx < I2C_VALID_TIMING_NBR)
340031fa:	2a7f      	cmp	r2, #127	@ 0x7f
340031fc:	d8a0      	bhi.n	34003140 <I2C_GetTiming.constprop.0+0x8>
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
340031fe:	2114      	movs	r1, #20
34003200:	434a      	muls	r2, r1
34003202:	4b42      	ldr	r3, [pc, #264]	@ (3400330c <I2C_GetTiming.constprop.0+0x1d4>)
34003204:	1899      	adds	r1, r3, r2
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
34003206:	7c08      	ldrb	r0, [r1, #16]
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003208:	589b      	ldr	r3, [r3, r2]
3400320a:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
3400320e:	684b      	ldr	r3, [r1, #4]
34003210:	051b      	lsls	r3, r3, #20
34003212:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003216:	4318      	orrs	r0, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34003218:	688b      	ldr	r3, [r1, #8]
3400321a:	041b      	lsls	r3, r3, #16
3400321c:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003220:	4318      	orrs	r0, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
34003222:	68cb      	ldr	r3, [r1, #12]
34003224:	021b      	lsls	r3, r3, #8
34003226:	b29b      	uxth	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003228:	4318      	orrs	r0, r3
  return ret;
3400322a:	e78a      	b.n	34003142 <I2C_GetTiming.constprop.0+0xa>
              prev_presc = presc;
3400322c:	469b      	mov	fp, r3
3400322e:	f04f 0a01 	mov.w	sl, #1
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34003232:	f1b8 0801 	subs.w	r8, r8, #1
34003236:	f109 0901 	add.w	r9, r9, #1
3400323a:	440e      	add	r6, r1
3400323c:	d1b2      	bne.n	340031a4 <I2C_GetTiming.constprop.0+0x6c>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
3400323e:	2f10      	cmp	r7, #16
34003240:	448e      	add	lr, r1
34003242:	d1a4      	bne.n	3400318e <I2C_GetTiming.constprop.0+0x56>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34003244:	9800      	ldr	r0, [sp, #0]
34003246:	3301      	adds	r3, #1
34003248:	2b10      	cmp	r3, #16
3400324a:	4401      	add	r1, r0
3400324c:	d19d      	bne.n	3400318a <I2C_GetTiming.constprop.0+0x52>
3400324e:	f1ba 0f00 	cmp.w	sl, #0
34003252:	d1bb      	bne.n	340031cc <I2C_GetTiming.constprop.0+0x94>
34003254:	e7bc      	b.n	340031d0 <I2C_GetTiming.constprop.0+0x98>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34003256:	2700      	movs	r7, #0
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
34003258:	9800      	ldr	r0, [sp, #0]
3400325a:	680b      	ldr	r3, [r1, #0]
3400325c:	fb03 0300 	mla	r3, r3, r0, r0
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34003260:	9809      	ldr	r0, [sp, #36]	@ 0x24
34003262:	ebae 0403 	sub.w	r4, lr, r3
34003266:	4418      	add	r0, r3
34003268:	9003      	str	r0, [sp, #12]
3400326a:	9801      	ldr	r0, [sp, #4]
3400326c:	ea4f 0b44 	mov.w	fp, r4, lsl #1
34003270:	181d      	adds	r5, r3, r0
34003272:	f5a5 5011 	sub.w	r0, r5, #9280	@ 0x2440
34003276:	380a      	subs	r0, #10
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
34003278:	9c03      	ldr	r4, [sp, #12]
3400327a:	9002      	str	r0, [sp, #8]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
3400327c:	f241 205c 	movw	r0, #4700	@ 0x125c
34003280:	4284      	cmp	r4, r0
34003282:	9708      	str	r7, [sp, #32]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34003284:	f107 0701 	add.w	r7, r7, #1
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34003288:	d935      	bls.n	340032f6 <I2C_GetTiming.constprop.0+0x1be>
3400328a:	9800      	ldr	r0, [sp, #0]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
3400328c:	f1a4 0532 	sub.w	r5, r4, #50	@ 0x32
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34003290:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
34003294:	d22f      	bcs.n	340032f6 <I2C_GetTiming.constprop.0+0x1be>
34003296:	9802      	ldr	r0, [sp, #8]
34003298:	46d8      	mov	r8, fp
3400329a:	1905      	adds	r5, r0, r4
            if ((uint32_t)error < prev_error)
            {
              prev_error = (uint32_t)error;
              I2c_valid_timing[count].scll = scll;
              I2c_valid_timing[count].sclh = sclh;
              ret = count;
3400329c:	f44f 7080 	mov.w	r0, #256	@ 0x100
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
340032a0:	f04f 0900 	mov.w	r9, #0
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
340032a4:	f8dd c00c 	ldr.w	ip, [sp, #12]
              ret = count;
340032a8:	9005      	str	r0, [sp, #20]
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
340032aa:	f241 0047 	movw	r0, #4167	@ 0x1047
340032ae:	f205 6a83 	addw	sl, r5, #1667	@ 0x683
340032b2:	4582      	cmp	sl, r0
340032b4:	f8cd 901c 	str.w	r9, [sp, #28]
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
340032b8:	f109 0901 	add.w	r9, r9, #1
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
340032bc:	d813      	bhi.n	340032e6 <I2C_GetTiming.constprop.0+0x1ae>
340032be:	f5bc 6f7a 	cmp.w	ip, #4000	@ 0xfa0
340032c2:	d310      	bcc.n	340032e6 <I2C_GetTiming.constprop.0+0x1ae>
340032c4:	9800      	ldr	r0, [sp, #0]
340032c6:	4560      	cmp	r0, ip
340032c8:	d20d      	bcs.n	340032e6 <I2C_GetTiming.constprop.0+0x1ae>
              error = -error;
340032ca:	2d00      	cmp	r5, #0
340032cc:	bfac      	ite	ge
340032ce:	46aa      	movge	sl, r5
340032d0:	46c2      	movlt	sl, r8
            if ((uint32_t)error < prev_error)
340032d2:	9804      	ldr	r0, [sp, #16]
340032d4:	4582      	cmp	sl, r0
340032d6:	d206      	bcs.n	340032e6 <I2C_GetTiming.constprop.0+0x1ae>
              I2c_valid_timing[count].scll = scll;
340032d8:	9a08      	ldr	r2, [sp, #32]
              prev_error = (uint32_t)error;
340032da:	f8cd a010 	str.w	sl, [sp, #16]
              I2c_valid_timing[count].scll = scll;
340032de:	610a      	str	r2, [r1, #16]
              I2c_valid_timing[count].sclh = sclh;
340032e0:	9a07      	ldr	r2, [sp, #28]
340032e2:	60ca      	str	r2, [r1, #12]
              ret = count;
340032e4:	4632      	mov	r2, r6
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
340032e6:	9805      	ldr	r0, [sp, #20]
340032e8:	449c      	add	ip, r3
340032ea:	3801      	subs	r0, #1
340032ec:	441d      	add	r5, r3
340032ee:	eba8 0803 	sub.w	r8, r8, r3
340032f2:	9005      	str	r0, [sp, #20]
340032f4:	d1d9      	bne.n	340032aa <I2C_GetTiming.constprop.0+0x172>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
340032f6:	f5b7 7f80 	cmp.w	r7, #256	@ 0x100
340032fa:	441c      	add	r4, r3
340032fc:	ebab 0b03 	sub.w	fp, fp, r3
34003300:	d1bc      	bne.n	3400327c <I2C_GetTiming.constprop.0+0x144>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
34003302:	3601      	adds	r6, #1
34003304:	3114      	adds	r1, #20
34003306:	e775      	b.n	340031f4 <I2C_GetTiming.constprop.0+0xbc>
34003308:	3b9aca00 	.word	0x3b9aca00
3400330c:	34043100 	.word	0x34043100
34003310:	340430fc 	.word	0x340430fc

34003314 <BSP_I2C1_DeInit>:
  I2c1InitCounter--;
34003314:	4a0e      	ldr	r2, [pc, #56]	@ (34003350 <BSP_I2C1_DeInit+0x3c>)
{
34003316:	b508      	push	{r3, lr}
  I2c1InitCounter--;
34003318:	6813      	ldr	r3, [r2, #0]
3400331a:	3b01      	subs	r3, #1
3400331c:	6013      	str	r3, [r2, #0]
  if (I2c1InitCounter == 0U)
3400331e:	b10b      	cbz	r3, 34003324 <BSP_I2C1_DeInit+0x10>
  int32_t ret = BSP_ERROR_NONE;
34003320:	2000      	movs	r0, #0
}
34003322:	bd08      	pop	{r3, pc}
  HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, gpio_init_structure.Pin );
34003324:	f44f 7100 	mov.w	r1, #512	@ 0x200
34003328:	480a      	ldr	r0, [pc, #40]	@ (34003354 <BSP_I2C1_DeInit+0x40>)
3400332a:	f004 fb17 	bl	3400795c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, gpio_init_structure.Pin);
3400332e:	480a      	ldr	r0, [pc, #40]	@ (34003358 <BSP_I2C1_DeInit+0x44>)
34003330:	2102      	movs	r1, #2
34003332:	f004 fb13 	bl	3400795c <HAL_GPIO_DeInit>
  WRITE_REG(RCC->APB1ENCR1, Periphs);
34003336:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
3400333a:	4b08      	ldr	r3, [pc, #32]	@ (3400335c <BSP_I2C1_DeInit+0x48>)
    if (HAL_I2C_DeInit(&hbus_i2c1) != HAL_OK)
3400333c:	4808      	ldr	r0, [pc, #32]	@ (34003360 <BSP_I2C1_DeInit+0x4c>)
3400333e:	f8c3 2264 	str.w	r2, [r3, #612]	@ 0x264
34003342:	f004 fe99 	bl	34008078 <HAL_I2C_DeInit>
34003346:	2800      	cmp	r0, #0
34003348:	d0ea      	beq.n	34003320 <BSP_I2C1_DeInit+0xc>
      ret = BSP_ERROR_BUS_FAILURE;
3400334a:	f06f 0007 	mvn.w	r0, #7
  return ret;
3400334e:	e7e8      	b.n	34003322 <BSP_I2C1_DeInit+0xe>
34003350:	34043b00 	.word	0x34043b00
34003354:	56021c00 	.word	0x56021c00
34003358:	56020800 	.word	0x56020800
3400335c:	56029000 	.word	0x56029000
34003360:	340430a8 	.word	0x340430a8

34003364 <MX_I2C1_Init>:
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
34003364:	2300      	movs	r3, #0
34003366:	2201      	movs	r2, #1
{
34003368:	b510      	push	{r4, lr}
  hI2c->Init.Timing           = timing;
3400336a:	6041      	str	r1, [r0, #4]
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
3400336c:	e9c0 3202 	strd	r3, r2, [r0, #8]
  hI2c->Init.OwnAddress2      = 0;
34003370:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
34003374:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
34003378:	6203      	str	r3, [r0, #32]
{
3400337a:	4604      	mov	r4, r0
  if (HAL_I2C_Init(hI2c) != HAL_OK)
3400337c:	f004 fdba 	bl	34007ef4 <HAL_I2C_Init>
34003380:	4601      	mov	r1, r0
34003382:	b108      	cbz	r0, 34003388 <MX_I2C1_Init+0x24>
    status = HAL_ERROR;
34003384:	2001      	movs	r0, #1
}
34003386:	bd10      	pop	{r4, pc}
    if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
34003388:	4620      	mov	r0, r4
3400338a:	f005 f88f 	bl	340084ac <HAL_I2CEx_ConfigAnalogFilter>
3400338e:	4601      	mov	r1, r0
34003390:	2800      	cmp	r0, #0
34003392:	d1f7      	bne.n	34003384 <MX_I2C1_Init+0x20>
      if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
34003394:	4620      	mov	r0, r4
34003396:	f005 f8e3 	bl	34008560 <HAL_I2CEx_ConfigDigitalFilter>
3400339a:	3800      	subs	r0, #0
3400339c:	bf18      	it	ne
3400339e:	2001      	movne	r0, #1
340033a0:	e7f1      	b.n	34003386 <MX_I2C1_Init+0x22>
	...

340033a4 <BSP_I2C1_Init>:
{
340033a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hbus_i2c1.Instance = BUS_I2C1;
340033a8:	4b28      	ldr	r3, [pc, #160]	@ (3400344c <BSP_I2C1_Init+0xa8>)
340033aa:	4e29      	ldr	r6, [pc, #164]	@ (34003450 <BSP_I2C1_Init+0xac>)
{
340033ac:	b086      	sub	sp, #24
  hbus_i2c1.Instance = BUS_I2C1;
340033ae:	6033      	str	r3, [r6, #0]
  if (I2c1InitCounter == 0U)
340033b0:	4b28      	ldr	r3, [pc, #160]	@ (34003454 <BSP_I2C1_Init+0xb0>)
340033b2:	681a      	ldr	r2, [r3, #0]
340033b4:	b11a      	cbz	r2, 340033be <BSP_I2C1_Init+0x1a>
  int32_t ret = BSP_ERROR_NONE;
340033b6:	2000      	movs	r0, #0
}
340033b8:	b006      	add	sp, #24
340033ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    I2c1InitCounter++;
340033be:	2201      	movs	r2, #1
    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
340033c0:	4630      	mov	r0, r6
    I2c1InitCounter++;
340033c2:	601a      	str	r2, [r3, #0]
    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
340033c4:	f005 f86c 	bl	340084a0 <HAL_I2C_GetState>
340033c8:	4604      	mov	r4, r0
340033ca:	2800      	cmp	r0, #0
340033cc:	d1f3      	bne.n	340033b6 <BSP_I2C1_Init+0x12>
  HAL_PWREx_EnableVddIO4();
340033ce:	f005 fdc7 	bl	34008f60 <HAL_PWREx_EnableVddIO4>
  BUS_I2C1_SCL_GPIO_CLK_ENABLE();
340033d2:	2080      	movs	r0, #128	@ 0x80
340033d4:	f7ff fea4 	bl	34003120 <LL_AHB4_GRP1_EnableClock>
  BUS_I2C1_SDA_GPIO_CLK_ENABLE();
340033d8:	2004      	movs	r0, #4
340033da:	f7ff fea1 	bl	34003120 <LL_AHB4_GRP1_EnableClock>
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
340033de:	2702      	movs	r7, #2
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340033e0:	f44f 7300 	mov.w	r3, #512	@ 0x200
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
340033e4:	4605      	mov	r5, r0
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340033e6:	f04f 0812 	mov.w	r8, #18
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
340033ea:	eb0d 0100 	add.w	r1, sp, r0
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
340033ee:	9005      	str	r0, [sp, #20]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
340033f0:	4819      	ldr	r0, [pc, #100]	@ (34003458 <BSP_I2C1_Init+0xb4>)
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340033f2:	e9cd 3801 	strd	r3, r8, [sp, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
340033f6:	9403      	str	r4, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
340033f8:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
340033fa:	f004 f897 	bl	3400752c <HAL_GPIO_Init>
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
340033fe:	4817      	ldr	r0, [pc, #92]	@ (3400345c <BSP_I2C1_Init+0xb8>)
34003400:	eb0d 0105 	add.w	r1, sp, r5
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34003404:	e9cd 7801 	strd	r7, r8, [sp, #4]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34003408:	e9cd 4703 	strd	r4, r7, [sp, #12]
  gpio_init_structure.Alternate = BUS_I2C1_SDA_AF;
3400340c:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
3400340e:	f004 f88d 	bl	3400752c <HAL_GPIO_Init>
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34003412:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
34003416:	4a12      	ldr	r2, [pc, #72]	@ (34003460 <BSP_I2C1_Init+0xbc>)
34003418:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
3400341c:	f8d2 1264 	ldr.w	r1, [r2, #612]	@ 0x264
34003420:	9100      	str	r1, [sp, #0]
  (void)tmpreg;
34003422:	9900      	ldr	r1, [sp, #0]
  WRITE_REG(RCC->APB1RSTSR1, Periphs);
34003424:	f8c2 3a24 	str.w	r3, [r2, #2596]	@ 0xa24
  WRITE_REG(RCC->APB1RSTCR1, Periphs);
34003428:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400342c:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
        if (MX_I2C1_Init(&hbus_i2c1, I2C_GetTiming(HAL_RCC_GetPCLK1Freq(), BUS_I2C1_FREQUENCY)) != HAL_OK)
34003430:	f006 fe48 	bl	3400a0c4 <HAL_RCC_GetPCLK1Freq>
34003434:	f7ff fe80 	bl	34003138 <I2C_GetTiming.constprop.0>
34003438:	4601      	mov	r1, r0
3400343a:	4630      	mov	r0, r6
3400343c:	f7ff ff92 	bl	34003364 <MX_I2C1_Init>
34003440:	2800      	cmp	r0, #0
34003442:	d0b8      	beq.n	340033b6 <BSP_I2C1_Init+0x12>
          ret = BSP_ERROR_BUS_FAILURE;
34003444:	f06f 0007 	mvn.w	r0, #7
  return ret;
34003448:	e7b6      	b.n	340033b8 <BSP_I2C1_Init+0x14>
3400344a:	bf00      	nop
3400344c:	50005400 	.word	0x50005400
34003450:	340430a8 	.word	0x340430a8
34003454:	34043b00 	.word	0x34043b00
34003458:	56021c00 	.word	0x56021c00
3400345c:	56020800 	.word	0x56020800
34003460:	56028000 	.word	0x56028000

34003464 <BSP_I2C1_WriteReg16>:
{
34003464:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003466:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
3400346a:	9200      	str	r2, [sp, #0]
3400346c:	e9cd 3401 	strd	r3, r4, [sp, #4]
34003470:	460a      	mov	r2, r1
34003472:	2302      	movs	r3, #2
34003474:	4601      	mov	r1, r0
34003476:	4808      	ldr	r0, [pc, #32]	@ (34003498 <BSP_I2C1_WriteReg16+0x34>)
34003478:	f004 fe46 	bl	34008108 <HAL_I2C_Mem_Write>
    ret = BSP_ERROR_NONE;
3400347c:	2300      	movs	r3, #0
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
3400347e:	b140      	cbz	r0, 34003492 <BSP_I2C1_WriteReg16+0x2e>
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34003480:	4805      	ldr	r0, [pc, #20]	@ (34003498 <BSP_I2C1_WriteReg16+0x34>)
34003482:	f005 f810 	bl	340084a6 <HAL_I2C_GetError>
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34003486:	2804      	cmp	r0, #4
34003488:	bf14      	ite	ne
3400348a:	f06f 0303 	mvnne.w	r3, #3
3400348e:	f06f 0365 	mvneq.w	r3, #101	@ 0x65
}
34003492:	4618      	mov	r0, r3
34003494:	b004      	add	sp, #16
34003496:	bd10      	pop	{r4, pc}
34003498:	340430a8 	.word	0x340430a8

3400349c <BSP_I2C1_ReadReg16>:
{
3400349c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
3400349e:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
340034a2:	9200      	str	r2, [sp, #0]
340034a4:	e9cd 3401 	strd	r3, r4, [sp, #4]
340034a8:	460a      	mov	r2, r1
340034aa:	2302      	movs	r3, #2
340034ac:	4601      	mov	r1, r0
340034ae:	4808      	ldr	r0, [pc, #32]	@ (340034d0 <BSP_I2C1_ReadReg16+0x34>)
340034b0:	f004 ff0e 	bl	340082d0 <HAL_I2C_Mem_Read>
    ret = BSP_ERROR_NONE;
340034b4:	2300      	movs	r3, #0
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
340034b6:	b140      	cbz	r0, 340034ca <BSP_I2C1_ReadReg16+0x2e>
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
340034b8:	4805      	ldr	r0, [pc, #20]	@ (340034d0 <BSP_I2C1_ReadReg16+0x34>)
340034ba:	f004 fff4 	bl	340084a6 <HAL_I2C_GetError>
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
340034be:	2804      	cmp	r0, #4
340034c0:	bf14      	ite	ne
340034c2:	f06f 0303 	mvnne.w	r3, #3
340034c6:	f06f 0365 	mvneq.w	r3, #101	@ 0x65
}
340034ca:	4618      	mov	r0, r3
340034cc:	b004      	add	sp, #16
340034ce:	bd10      	pop	{r4, pc}
340034d0:	340430a8 	.word	0x340430a8

340034d4 <BSP_GetTick>:
  return (int32_t)HAL_GetTick();
340034d4:	f001 b99a 	b.w	3400480c <HAL_GetTick>

340034d8 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340034d8:	4b04      	ldr	r3, [pc, #16]	@ (340034ec <LL_AHB4_GRP1_EnableClock+0x14>)
{
340034da:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340034dc:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
340034e0:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
340034e4:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
340034e6:	9b01      	ldr	r3, [sp, #4]
}
340034e8:	b002      	add	sp, #8
340034ea:	4770      	bx	lr
340034ec:	56028000 	.word	0x56028000

340034f0 <BSP_LCD_GetPixelFormat>:
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
340034f0:	b918      	cbnz	r0, 340034fa <BSP_LCD_GetPixelFormat+0xa>
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat =  Lcd_Ctx[Instance].PixelFormat;
340034f2:	4b03      	ldr	r3, [pc, #12]	@ (34003500 <BSP_LCD_GetPixelFormat+0x10>)
340034f4:	68db      	ldr	r3, [r3, #12]
340034f6:	600b      	str	r3, [r1, #0]
340034f8:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
340034fa:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
340034fe:	4770      	bx	lr
34003500:	34043b04 	.word	0x34043b04

34003504 <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
34003504:	b510      	push	{r4, lr}
  int32_t ret = BSP_ERROR_NONE;
  LTDC_LayerCfgTypeDef *pLayerCfg;

  if(Instance >= LCD_INSTANCES_NBR)
34003506:	bb08      	cbnz	r0, 3400354c <BSP_LCD_SetActiveLayer+0x48>
  else
  {
    pLayerCfg = &hlcd_ltdc.LayerCfg[LayerIndex];

    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34003508:	2434      	movs	r4, #52	@ 0x34
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
3400350a:	4b12      	ldr	r3, [pc, #72]	@ (34003554 <BSP_LCD_SetActiveLayer+0x50>)
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
3400350c:	4a12      	ldr	r2, [pc, #72]	@ (34003558 <BSP_LCD_SetActiveLayer+0x54>)
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
3400350e:	6099      	str	r1, [r3, #8]
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
34003510:	fb04 2101 	mla	r1, r4, r1, r2
34003514:	6e0a      	ldr	r2, [r1, #96]	@ 0x60
34003516:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize = pLayerCfg->ImageHeight;
34003518:	6e4a      	ldr	r2, [r1, #100]	@ 0x64
3400351a:	605a      	str	r2, [r3, #4]

    if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB565)
3400351c:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
3400351e:	2a04      	cmp	r2, #4
34003520:	d104      	bne.n	3400352c <BSP_LCD_SetActiveLayer+0x28>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
34003522:	2202      	movs	r2, #2
34003524:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB565;
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
    {
      Lcd_Ctx[Instance].BppFactor = 2;
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34003526:	60da      	str	r2, [r3, #12]
  int32_t ret = BSP_ERROR_NONE;
34003528:	2000      	movs	r0, #0
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
    }
  }

  return ret;
}
3400352a:	bd10      	pop	{r4, pc}
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
3400352c:	2a08      	cmp	r2, #8
3400352e:	d103      	bne.n	34003538 <BSP_LCD_SetActiveLayer+0x34>
      Lcd_Ctx[Instance].BppFactor = 2;
34003530:	2202      	movs	r2, #2
34003532:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34003534:	2204      	movs	r2, #4
34003536:	e7f6      	b.n	34003526 <BSP_LCD_SetActiveLayer+0x22>
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB888)
34003538:	2a06      	cmp	r2, #6
3400353a:	d103      	bne.n	34003544 <BSP_LCD_SetActiveLayer+0x40>
      Lcd_Ctx[Instance].BppFactor = 3;
3400353c:	2203      	movs	r2, #3
3400353e:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB888;
34003540:	2201      	movs	r2, #1
34003542:	e7f0      	b.n	34003526 <BSP_LCD_SetActiveLayer+0x22>
      Lcd_Ctx[Instance].BppFactor = 4;
34003544:	2204      	movs	r2, #4
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
34003546:	e9c3 0203 	strd	r0, r2, [r3, #12]
3400354a:	e7ed      	b.n	34003528 <BSP_LCD_SetActiveLayer+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
3400354c:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003550:	e7eb      	b.n	3400352a <BSP_LCD_SetActiveLayer+0x26>
34003552:	bf00      	nop
34003554:	34043b04 	.word	0x34043b04
34003558:	34043b24 	.word	0x34043b24

3400355c <BSP_LCD_GetXSize>:
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
3400355c:	b918      	cbnz	r0, 34003566 <BSP_LCD_GetXSize+0xa>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
3400355e:	4b03      	ldr	r3, [pc, #12]	@ (3400356c <BSP_LCD_GetXSize+0x10>)
34003560:	681b      	ldr	r3, [r3, #0]
34003562:	600b      	str	r3, [r1, #0]
34003564:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
34003566:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
3400356a:	4770      	bx	lr
3400356c:	34043b04 	.word	0x34043b04

34003570 <BSP_LCD_GetYSize>:
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
34003570:	b918      	cbnz	r0, 3400357a <BSP_LCD_GetYSize+0xa>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34003572:	4b03      	ldr	r3, [pc, #12]	@ (34003580 <BSP_LCD_GetYSize+0x10>)
34003574:	685b      	ldr	r3, [r3, #4]
34003576:	600b      	str	r3, [r1, #0]
34003578:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
3400357a:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
3400357e:	4770      	bx	lr
34003580:	34043b04 	.word	0x34043b04

34003584 <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
34003584:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003586:	2734      	movs	r7, #52	@ 0x34
34003588:	4d0f      	ldr	r5, [pc, #60]	@ (340035c8 <BSP_LCD_ReadPixel+0x44>)
3400358a:	0146      	lsls	r6, r0, #5
3400358c:	eb05 1040 	add.w	r0, r5, r0, lsl #5
34003590:	6884      	ldr	r4, [r0, #8]
34003592:	480e      	ldr	r0, [pc, #56]	@ (340035cc <BSP_LCD_ReadPixel+0x48>)
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003594:	59ad      	ldr	r5, [r5, r6]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003596:	fb07 0004 	mla	r0, r7, r4, r0
3400359a:	6c84      	ldr	r4, [r0, #72]	@ 0x48
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
3400359c:	fb05 1202 	mla	r2, r5, r2, r1
340035a0:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340035a2:	b924      	cbnz	r4, 340035ae <BSP_LCD_ReadPixel+0x2a>
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340035a4:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
    /* Read data value from RAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
  }

  return BSP_ERROR_NONE;
}
340035a8:	2000      	movs	r0, #0
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340035aa:	601a      	str	r2, [r3, #0]
}
340035ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
340035ae:	2c06      	cmp	r4, #6
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340035b0:	bf05      	ittet	eq
340035b2:	eb02 0242 	addeq.w	r2, r2, r2, lsl #1
340035b6:	5812      	ldreq	r2, [r2, r0]
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340035b8:	f830 2012 	ldrhne.w	r2, [r0, r2, lsl #1]
    *Color = CONVERTARGB88882RGB888(*Color);
340035bc:	f022 427f 	biceq.w	r2, r2, #4278190080	@ 0xff000000
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340035c0:	bf18      	it	ne
340035c2:	b292      	uxthne	r2, r2
340035c4:	e7f0      	b.n	340035a8 <BSP_LCD_ReadPixel+0x24>
340035c6:	bf00      	nop
340035c8:	34043b04 	.word	0x34043b04
340035cc:	34043b24 	.word	0x34043b24

340035d0 <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
340035d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340035d4:	2734      	movs	r7, #52	@ 0x34
340035d6:	4e24      	ldr	r6, [pc, #144]	@ (34003668 <BSP_LCD_WritePixel+0x98>)
340035d8:	ea4f 1c40 	mov.w	ip, r0, lsl #5
340035dc:	eb06 1040 	add.w	r0, r6, r0, lsl #5
340035e0:	6884      	ldr	r4, [r0, #8]
340035e2:	4d22      	ldr	r5, [pc, #136]	@ (3400366c <BSP_LCD_WritePixel+0x9c>)
340035e4:	fb07 5404 	mla	r4, r7, r4, r5
340035e8:	f8d4 8048 	ldr.w	r8, [r4, #72]	@ 0x48
  {
    /* Write data value to RAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
340035ec:	f8d4 e05c 	ldr.w	lr, [r4, #92]	@ 0x5c
340035f0:	f856 400c 	ldr.w	r4, [r6, ip]
340035f4:	fb04 1402 	mla	r4, r4, r2, r1
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340035f8:	f1b8 0f00 	cmp.w	r8, #0
340035fc:	d104      	bne.n	34003608 <BSP_LCD_WritePixel+0x38>
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
340035fe:	f84e 3024 	str.w	r3, [lr, r4, lsl #2]
    /* Write data value to RAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
  }

  return BSP_ERROR_NONE;
}
34003602:	2000      	movs	r0, #0
34003604:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34003608:	f1b8 0f06 	cmp.w	r8, #6
3400360c:	d127      	bne.n	3400365e <BSP_LCD_WritePixel+0x8e>
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-3U)) = (uint8_t) (Color);
3400360e:	fa5f f883 	uxtb.w	r8, r3
34003612:	eb04 0444 	add.w	r4, r4, r4, lsl #1
34003616:	f1ae 0e03 	sub.w	lr, lr, #3
3400361a:	f804 800e 	strb.w	r8, [r4, lr]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
3400361e:	f856 400c 	ldr.w	r4, [r6, ip]
34003622:	f3c3 2807 	ubfx	r8, r3, #8, #8
34003626:	fb04 1402 	mla	r4, r4, r2, r1
3400362a:	eb04 0944 	add.w	r9, r4, r4, lsl #1
3400362e:	6884      	ldr	r4, [r0, #8]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34003630:	f3c3 4307 	ubfx	r3, r3, #16, #8
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34003634:	fb07 5e04 	mla	lr, r7, r4, r5
34003638:	f8de e05c 	ldr.w	lr, [lr, #92]	@ 0x5c
3400363c:	f1ae 0e02 	sub.w	lr, lr, #2
34003640:	f809 800e 	strb.w	r8, [r9, lr]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34003644:	f856 400c 	ldr.w	r4, [r6, ip]
34003648:	fb04 1202 	mla	r2, r4, r2, r1
3400364c:	6881      	ldr	r1, [r0, #8]
3400364e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
34003652:	fb07 5501 	mla	r5, r7, r1, r5
34003656:	6de9      	ldr	r1, [r5, #92]	@ 0x5c
34003658:	3901      	subs	r1, #1
3400365a:	5453      	strb	r3, [r2, r1]
3400365c:	e7d1      	b.n	34003602 <BSP_LCD_WritePixel+0x32>
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
3400365e:	b29b      	uxth	r3, r3
34003660:	f82e 3014 	strh.w	r3, [lr, r4, lsl #1]
34003664:	e7cd      	b.n	34003602 <BSP_LCD_WritePixel+0x32>
34003666:	bf00      	nop
34003668:	34043b04 	.word	0x34043b04
3400366c:	34043b24 	.word	0x34043b24

34003670 <BSP_LCD_FillRGBRect>:
{
34003670:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34003674:	4680      	mov	r8, r0
34003676:	460e      	mov	r6, r1
34003678:	4614      	mov	r4, r2
3400367a:	461d      	mov	r5, r3
  for(i = 0; i < Height; i++)
3400367c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3400367e:	eb03 0902 	add.w	r9, r3, r2
      pdata += Lcd_Ctx[Instance].BppFactor;
34003682:	4b0d      	ldr	r3, [pc, #52]	@ (340036b8 <BSP_LCD_FillRGBRect+0x48>)
34003684:	eb03 1a40 	add.w	sl, r3, r0, lsl #5
  for(i = 0; i < Height; i++)
34003688:	454c      	cmp	r4, r9
3400368a:	d012      	beq.n	340036b2 <BSP_LCD_FillRGBRect+0x42>
3400368c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3400368e:	4637      	mov	r7, r6
34003690:	eb03 0b06 	add.w	fp, r3, r6
34003694:	e009      	b.n	340036aa <BSP_LCD_FillRGBRect+0x3a>
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
34003696:	682b      	ldr	r3, [r5, #0]
34003698:	4639      	mov	r1, r7
3400369a:	4622      	mov	r2, r4
3400369c:	4640      	mov	r0, r8
3400369e:	f7ff ff97 	bl	340035d0 <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
340036a2:	f8da 3010 	ldr.w	r3, [sl, #16]
340036a6:	3701      	adds	r7, #1
340036a8:	441d      	add	r5, r3
    for(j = 0; j < Width; j++)
340036aa:	455f      	cmp	r7, fp
340036ac:	d1f3      	bne.n	34003696 <BSP_LCD_FillRGBRect+0x26>
  for(i = 0; i < Height; i++)
340036ae:	3401      	adds	r4, #1
340036b0:	e7ea      	b.n	34003688 <BSP_LCD_FillRGBRect+0x18>
}
340036b2:	2000      	movs	r0, #0
340036b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
340036b8:	34043b04 	.word	0x34043b04

340036bc <BSP_LCD_DrawBitmap>:
{
340036bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340036c0:	2634      	movs	r6, #52	@ 0x34
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
340036c2:	f8d3 4012 	ldr.w	r4, [r3, #18]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340036c6:	4f39      	ldr	r7, [pc, #228]	@ (340037ac <BSP_LCD_DrawBitmap+0xf0>)
340036c8:	ea4f 1840 	mov.w	r8, r0, lsl #5
{
340036cc:	b085      	sub	sp, #20
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
340036ce:	9402      	str	r4, [sp, #8]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340036d0:	f857 4008 	ldr.w	r4, [r7, r8]
340036d4:	eb07 1040 	add.w	r0, r7, r0, lsl #5
340036d8:	fb04 1202 	mla	r2, r4, r2, r1
340036dc:	6904      	ldr	r4, [r0, #16]
340036de:	4934      	ldr	r1, [pc, #208]	@ (340037b0 <BSP_LCD_DrawBitmap+0xf4>)
340036e0:	6880      	ldr	r0, [r0, #8]
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
340036e2:	8b9d      	ldrh	r5, [r3, #28]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340036e4:	fb06 1100 	mla	r1, r6, r0, r1
340036e8:	6dce      	ldr	r6, [r1, #92]	@ 0x5c
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
340036ea:	f8d3 c00a 	ldr.w	ip, [r3, #10]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340036ee:	fb04 6602 	mla	r6, r4, r2, r6
  if ((bit_pixel/8U) == 4U)
340036f2:	f1a5 0220 	sub.w	r2, r5, #32
340036f6:	2a07      	cmp	r2, #7
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
340036f8:	f8d3 a016 	ldr.w	sl, [r3, #22]
  if ((bit_pixel/8U) == 4U)
340036fc:	d91b      	bls.n	34003736 <BSP_LCD_DrawBitmap+0x7a>
  else if ((bit_pixel/8U) == 2U)
340036fe:	f1a5 0210 	sub.w	r2, r5, #16
    input_color_mode = DMA2D_INPUT_RGB565;
34003702:	2a07      	cmp	r2, #7
34003704:	bf8c      	ite	hi
34003706:	f04f 0b01 	movhi.w	fp, #1
3400370a:	f04f 0b02 	movls.w	fp, #2
  for(index=0; index < height; index++)
3400370e:	f04f 0900 	mov.w	r9, #0
34003712:	9a02      	ldr	r2, [sp, #8]
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
34003714:	08ed      	lsrs	r5, r5, #3
34003716:	4355      	muls	r5, r2
34003718:	f10a 32ff 	add.w	r2, sl, #4294967295
3400371c:	fb05 cc02 	mla	ip, r5, r2, ip
34003720:	eb03 040c 	add.w	r4, r3, ip
    pbmp -= width*(bit_pixel/8U);
34003724:	426b      	negs	r3, r5
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
    break;
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
34003726:	4d23      	ldr	r5, [pc, #140]	@ (340037b4 <BSP_LCD_DrawBitmap+0xf8>)
    pbmp -= width*(bit_pixel/8U);
34003728:	9303      	str	r3, [sp, #12]
  for(index=0; index < height; index++)
3400372a:	45d1      	cmp	r9, sl
3400372c:	d106      	bne.n	3400373c <BSP_LCD_DrawBitmap+0x80>
}
3400372e:	2000      	movs	r0, #0
34003730:	b005      	add	sp, #20
34003732:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    input_color_mode = DMA2D_INPUT_ARGB8888;
34003736:	f04f 0b00 	mov.w	fp, #0
3400373a:	e7e8      	b.n	3400370e <BSP_LCD_DrawBitmap+0x52>
  switch(Lcd_Ctx[Instance].PixelFormat)
3400373c:	eb07 0308 	add.w	r3, r7, r8
34003740:	68db      	ldr	r3, [r3, #12]
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;

  hlcd_dma2d.Instance = DMA2D;

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34003742:	481c      	ldr	r0, [pc, #112]	@ (340037b4 <BSP_LCD_DrawBitmap+0xf8>)
34003744:	3b01      	subs	r3, #1
34003746:	2b03      	cmp	r3, #3
34003748:	bf96      	itet	ls
3400374a:	4a1b      	ldrls	r2, [pc, #108]	@ (340037b8 <BSP_LCD_DrawBitmap+0xfc>)
  switch(Lcd_Ctx[Instance].PixelFormat)
3400374c:	2300      	movhi	r3, #0
3400374e:	5cd3      	ldrbls	r3, [r2, r3]
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
34003750:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34003754:	e9c5 2301 	strd	r2, r3, [r5, #4]
  hlcd_dma2d.Init.OutputOffset = 0;
34003758:	2300      	movs	r3, #0
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
3400375a:	22ff      	movs	r2, #255	@ 0xff
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
3400375c:	e9c5 3b11 	strd	r3, fp, [r5, #68]	@ 0x44
  hlcd_dma2d.Init.OutputOffset = 0;
34003760:	60eb      	str	r3, [r5, #12]
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34003762:	64eb      	str	r3, [r5, #76]	@ 0x4c
  hlcd_dma2d.Instance = DMA2D;
34003764:	4b15      	ldr	r3, [pc, #84]	@ (340037bc <BSP_LCD_DrawBitmap+0x100>)
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
34003766:	652a      	str	r2, [r5, #80]	@ 0x50
  hlcd_dma2d.Instance = DMA2D;
34003768:	602b      	str	r3, [r5, #0]
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
3400376a:	f003 fcf3 	bl	34007154 <HAL_DMA2D_Init>
3400376e:	b988      	cbnz	r0, 34003794 <BSP_LCD_DrawBitmap+0xd8>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
34003770:	2101      	movs	r1, #1
34003772:	4628      	mov	r0, r5
34003774:	f003 fe2a 	bl	340073cc <HAL_DMA2D_ConfigLayer>
34003778:	b960      	cbnz	r0, 34003794 <BSP_LCD_DrawBitmap+0xd8>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
3400377a:	2301      	movs	r3, #1
3400377c:	4632      	mov	r2, r6
3400377e:	9300      	str	r3, [sp, #0]
34003780:	4621      	mov	r1, r4
34003782:	9b02      	ldr	r3, [sp, #8]
34003784:	480b      	ldr	r0, [pc, #44]	@ (340037b4 <BSP_LCD_DrawBitmap+0xf8>)
34003786:	f003 fd6d 	bl	34007264 <HAL_DMA2D_Start>
3400378a:	b918      	cbnz	r0, 34003794 <BSP_LCD_DrawBitmap+0xd8>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
3400378c:	2132      	movs	r1, #50	@ 0x32
3400378e:	4809      	ldr	r0, [pc, #36]	@ (340037b4 <BSP_LCD_DrawBitmap+0xf8>)
34003790:	f003 fd9e 	bl	340072d0 <HAL_DMA2D_PollForTransfer>
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
34003794:	eb07 0308 	add.w	r3, r7, r8
34003798:	691b      	ldr	r3, [r3, #16]
3400379a:	f857 2008 	ldr.w	r2, [r7, r8]
  for(index=0; index < height; index++)
3400379e:	f109 0901 	add.w	r9, r9, #1
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
340037a2:	fb03 6602 	mla	r6, r3, r2, r6
    pbmp -= width*(bit_pixel/8U);
340037a6:	9b03      	ldr	r3, [sp, #12]
340037a8:	441c      	add	r4, r3
  for(index=0; index < height; index++)
340037aa:	e7be      	b.n	3400372a <BSP_LCD_DrawBitmap+0x6e>
340037ac:	34043b04 	.word	0x34043b04
340037b0:	34043b24 	.word	0x34043b24
340037b4:	34043bcc 	.word	0x34043bcc
340037b8:	34034ea8 	.word	0x34034ea8
340037bc:	58021000 	.word	0x58021000

340037c0 <LL_FillBuffer>:
{
340037c0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
340037c4:	461f      	mov	r7, r3
  switch(Lcd_Ctx[Instance].PixelFormat)
340037c6:	4b34      	ldr	r3, [pc, #208]	@ (34003898 <LL_FillBuffer+0xd8>)
{
340037c8:	4616      	mov	r6, r2
  switch(Lcd_Ctx[Instance].PixelFormat)
340037ca:	eb03 1340 	add.w	r3, r3, r0, lsl #5
340037ce:	68da      	ldr	r2, [r3, #12]
{
340037d0:	460d      	mov	r5, r1
340037d2:	e9dd 1408 	ldrd	r1, r4, [sp, #32]
  switch(Lcd_Ctx[Instance].PixelFormat)
340037d6:	2a02      	cmp	r2, #2
340037d8:	d023      	beq.n	34003822 <LL_FillBuffer+0x62>
340037da:	2a04      	cmp	r2, #4
340037dc:	d03e      	beq.n	3400385c <LL_FillBuffer+0x9c>
340037de:	2a01      	cmp	r2, #1
340037e0:	d054      	beq.n	3400388c <LL_FillBuffer+0xcc>
340037e2:	2200      	movs	r2, #0
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
340037e4:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
340037e8:	f8df 80b4 	ldr.w	r8, [pc, #180]	@ 340038a0 <LL_FillBuffer+0xe0>
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
340037ec:	e9c8 3201 	strd	r3, r2, [r8, #4]
  hlcd_dma2d.Instance = DMA2D;
340037f0:	4b2a      	ldr	r3, [pc, #168]	@ (3400389c <LL_FillBuffer+0xdc>)
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
340037f2:	4640      	mov	r0, r8
  hlcd_dma2d.Init.OutputOffset = OffLine;
340037f4:	f8c8 100c 	str.w	r1, [r8, #12]
  hlcd_dma2d.Instance = DMA2D;
340037f8:	f8c8 3000 	str.w	r3, [r8]
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
340037fc:	f003 fcaa 	bl	34007154 <HAL_DMA2D_Init>
34003800:	2800      	cmp	r0, #0
34003802:	d146      	bne.n	34003892 <LL_FillBuffer+0xd2>
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
34003804:	4633      	mov	r3, r6
34003806:	462a      	mov	r2, r5
34003808:	4621      	mov	r1, r4
3400380a:	4640      	mov	r0, r8
3400380c:	9700      	str	r7, [sp, #0]
3400380e:	f003 fd29 	bl	34007264 <HAL_DMA2D_Start>
34003812:	bbf0      	cbnz	r0, 34003892 <LL_FillBuffer+0xd2>
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34003814:	2132      	movs	r1, #50	@ 0x32
34003816:	4640      	mov	r0, r8
}
34003818:	b002      	add	sp, #8
3400381a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
3400381e:	f003 bd57 	b.w	340072d0 <HAL_DMA2D_PollForTransfer>
    input_color = CONVERTRGB5652ARGB8888(Color);
34003822:	f240 1e03 	movw	lr, #259	@ 0x103
34003826:	f240 2c0f 	movw	ip, #527	@ 0x20f
3400382a:	f3c4 1045 	ubfx	r0, r4, #5, #6
3400382e:	f3c4 23c4 	ubfx	r3, r4, #11, #5
34003832:	fb0e f000 	mul.w	r0, lr, r0
34003836:	fb0c f303 	mul.w	r3, ip, r3
3400383a:	f004 041f 	and.w	r4, r4, #31
3400383e:	fb0c f404 	mul.w	r4, ip, r4
34003842:	3021      	adds	r0, #33	@ 0x21
34003844:	3317      	adds	r3, #23
34003846:	0980      	lsrs	r0, r0, #6
34003848:	099b      	lsrs	r3, r3, #6
3400384a:	0200      	lsls	r0, r0, #8
3400384c:	3417      	adds	r4, #23
3400384e:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
34003852:	ea40 1094 	orr.w	r0, r0, r4, lsr #6
34003856:	f040 447f 	orr.w	r4, r0, #4278190080	@ 0xff000000
    break;
3400385a:	e7c3      	b.n	340037e4 <LL_FillBuffer+0x24>
    input_color = CONVERTARGB44442ARGB8888(Color);
3400385c:	f3c4 3303 	ubfx	r3, r4, #12, #4
34003860:	eb03 1003 	add.w	r0, r3, r3, lsl #4
34003864:	f3c4 2303 	ubfx	r3, r4, #8, #4
34003868:	eb03 1303 	add.w	r3, r3, r3, lsl #4
3400386c:	041b      	lsls	r3, r3, #16
3400386e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
34003872:	f004 000f 	and.w	r0, r4, #15
34003876:	eb00 1000 	add.w	r0, r0, r0, lsl #4
3400387a:	4303      	orrs	r3, r0
3400387c:	f3c4 1003 	ubfx	r0, r4, #4, #4
34003880:	f004 04f0 	and.w	r4, r4, #240	@ 0xf0
34003884:	4404      	add	r4, r0
34003886:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
    break;
3400388a:	e7ab      	b.n	340037e4 <LL_FillBuffer+0x24>
    input_color = CONVERTRGB8882ARGB8888(Color);
3400388c:	f044 447f 	orr.w	r4, r4, #4278190080	@ 0xff000000
    break;
34003890:	e7a8      	b.n	340037e4 <LL_FillBuffer+0x24>
}
34003892:	b002      	add	sp, #8
34003894:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34003898:	34043b04 	.word	0x34043b04
3400389c:	58021000 	.word	0x58021000
340038a0:	34043bcc 	.word	0x34043bcc

340038a4 <BSP_LCD_DrawHLine>:
{
340038a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
340038a6:	4615      	mov	r5, r2
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340038a8:	4c0d      	ldr	r4, [pc, #52]	@ (340038e0 <BSP_LCD_DrawHLine+0x3c>)
340038aa:	0146      	lsls	r6, r0, #5
{
340038ac:	461a      	mov	r2, r3
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340038ae:	eb04 1340 	add.w	r3, r4, r0, lsl #5
340038b2:	59a4      	ldr	r4, [r4, r6]
340038b4:	691e      	ldr	r6, [r3, #16]
340038b6:	fb04 1105 	mla	r1, r4, r5, r1
340038ba:	2534      	movs	r5, #52	@ 0x34
340038bc:	689c      	ldr	r4, [r3, #8]
340038be:	4b09      	ldr	r3, [pc, #36]	@ (340038e4 <BSP_LCD_DrawHLine+0x40>)
340038c0:	fb05 3304 	mla	r3, r5, r4, r3
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
340038c4:	2400      	movs	r4, #0
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340038c6:	6ddd      	ldr	r5, [r3, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
340038c8:	9b06      	ldr	r3, [sp, #24]
340038ca:	fb06 5101 	mla	r1, r6, r1, r5
340038ce:	9301      	str	r3, [sp, #4]
340038d0:	9400      	str	r4, [sp, #0]
340038d2:	2301      	movs	r3, #1
340038d4:	f7ff ff74 	bl	340037c0 <LL_FillBuffer>
}
340038d8:	4620      	mov	r0, r4
340038da:	b002      	add	sp, #8
340038dc:	bd70      	pop	{r4, r5, r6, pc}
340038de:	bf00      	nop
340038e0:	34043b04 	.word	0x34043b04
340038e4:	34043b24 	.word	0x34043b24

340038e8 <BSP_LCD_DrawVLine>:
{
340038e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340038ea:	2734      	movs	r7, #52	@ 0x34
340038ec:	4d0c      	ldr	r5, [pc, #48]	@ (34003920 <BSP_LCD_DrawVLine+0x38>)
340038ee:	0146      	lsls	r6, r0, #5
340038f0:	eb05 1440 	add.w	r4, r5, r0, lsl #5
340038f4:	59ad      	ldr	r5, [r5, r6]
340038f6:	6926      	ldr	r6, [r4, #16]
340038f8:	fb02 1105 	mla	r1, r2, r5, r1
340038fc:	68a4      	ldr	r4, [r4, #8]
340038fe:	4a09      	ldr	r2, [pc, #36]	@ (34003924 <BSP_LCD_DrawVLine+0x3c>)
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34003900:	3d01      	subs	r5, #1
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003902:	fb07 2204 	mla	r2, r7, r4, r2
34003906:	6dd4      	ldr	r4, [r2, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34003908:	9a08      	ldr	r2, [sp, #32]
3400390a:	fb06 4101 	mla	r1, r6, r1, r4
3400390e:	9201      	str	r2, [sp, #4]
34003910:	9500      	str	r5, [sp, #0]
34003912:	2201      	movs	r2, #1
34003914:	f7ff ff54 	bl	340037c0 <LL_FillBuffer>
}
34003918:	2000      	movs	r0, #0
3400391a:	b003      	add	sp, #12
3400391c:	bdf0      	pop	{r4, r5, r6, r7, pc}
3400391e:	bf00      	nop
34003920:	34043b04 	.word	0x34043b04
34003924:	34043b24 	.word	0x34043b24

34003928 <BSP_LCD_FillRect>:
{
34003928:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400392a:	4615      	mov	r5, r2
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
3400392c:	2734      	movs	r7, #52	@ 0x34
{
3400392e:	461a      	mov	r2, r3
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003930:	4b0c      	ldr	r3, [pc, #48]	@ (34003964 <BSP_LCD_FillRect+0x3c>)
34003932:	0146      	lsls	r6, r0, #5
34003934:	eb03 1440 	add.w	r4, r3, r0, lsl #5
34003938:	599b      	ldr	r3, [r3, r6]
3400393a:	6926      	ldr	r6, [r4, #16]
3400393c:	fb05 1503 	mla	r5, r5, r3, r1
34003940:	68a1      	ldr	r1, [r4, #8]
34003942:	4c09      	ldr	r4, [pc, #36]	@ (34003968 <BSP_LCD_FillRect+0x40>)
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34003944:	1a9b      	subs	r3, r3, r2
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003946:	fb07 4401 	mla	r4, r7, r1, r4
3400394a:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
3400394c:	9c09      	ldr	r4, [sp, #36]	@ 0x24
3400394e:	9300      	str	r3, [sp, #0]
34003950:	fb06 1105 	mla	r1, r6, r5, r1
34003954:	9b08      	ldr	r3, [sp, #32]
34003956:	9401      	str	r4, [sp, #4]
34003958:	f7ff ff32 	bl	340037c0 <LL_FillBuffer>
}
3400395c:	2000      	movs	r0, #0
3400395e:	b003      	add	sp, #12
34003960:	bdf0      	pop	{r4, r5, r6, r7, pc}
34003962:	bf00      	nop
34003964:	34043b04 	.word	0x34043b04
34003968:	34043b24 	.word	0x34043b24

3400396c <MX_LTDC_Init>:
{
3400396c:	b4f0      	push	{r4, r5, r6, r7}
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
3400396e:	2400      	movs	r4, #0
34003970:	4d0c      	ldr	r5, [pc, #48]	@ (340039a4 <MX_LTDC_Init+0x38>)
  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34003972:	2603      	movs	r6, #3
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34003974:	e9c0 5400 	strd	r5, r4, [r0]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34003978:	250b      	movs	r5, #11
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
3400397a:	194f      	adds	r7, r1, r5
  hltdc->Init.TotalWidth         = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP + RK050HR18_HFP - 1U;
3400397c:	3113      	adds	r1, #19
3400397e:	62c1      	str	r1, [r0, #44]	@ 0x2c
  hltdc->Init.Backcolor.Blue  = 0x0;
34003980:	8684      	strh	r4, [r0, #52]	@ 0x34
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34003982:	1951      	adds	r1, r2, r5
  hltdc->Init.Backcolor.Red   = 0x0;
34003984:	f880 4036 	strb.w	r4, [r0, #54]	@ 0x36
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34003988:	3213      	adds	r2, #19
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
3400398a:	e9c0 4402 	strd	r4, r4, [r0, #8]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
3400398e:	6104      	str	r4, [r0, #16]
  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34003990:	6146      	str	r6, [r0, #20]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34003992:	61c5      	str	r5, [r0, #28]
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34003994:	6247      	str	r7, [r0, #36]	@ 0x24
  hltdc->Init.VerticalSync       = (uint32_t)RK050HR18_VSYNC - 1U;
34003996:	6186      	str	r6, [r0, #24]
  hltdc->Init.AccumulatedVBP     = (uint32_t)RK050HR18_VSYNC + (uint32_t)RK050HR18_VBP - 1U;
34003998:	6205      	str	r5, [r0, #32]
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
3400399a:	6281      	str	r1, [r0, #40]	@ 0x28
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
3400399c:	6302      	str	r2, [r0, #48]	@ 0x30
}
3400399e:	bcf0      	pop	{r4, r5, r6, r7}
  return HAL_LTDC_Init(hltdc);
340039a0:	f005 b8b4 	b.w	34008b0c <HAL_LTDC_Init>
340039a4:	58001000 	.word	0x58001000

340039a8 <MX_LTDC_ConfigLayer>:
{
340039a8:	b5f0      	push	{r4, r5, r6, r7, lr}
340039aa:	4614      	mov	r4, r2
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
340039ac:	221c      	movs	r2, #28
{
340039ae:	b08f      	sub	sp, #60	@ 0x3c
340039b0:	4606      	mov	r6, r0
340039b2:	460f      	mov	r7, r1
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
340039b4:	eb0d 0002 	add.w	r0, sp, r2
340039b8:	2100      	movs	r1, #0
340039ba:	f015 f8df 	bl	34018b7c <memset>
  pLayerCfg.PixelFormat = Config->PixelFormat;
340039be:	6920      	ldr	r0, [r4, #16]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340039c0:	f44f 6ec0 	mov.w	lr, #1536	@ 0x600
  pLayerCfg.PixelFormat = Config->PixelFormat;
340039c4:	9005      	str	r0, [sp, #20]
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
340039c6:	20ff      	movs	r0, #255	@ 0xff
340039c8:	9006      	str	r0, [sp, #24]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340039ca:	2007      	movs	r0, #7
  pLayerCfg.WindowX0 = Config->X0;
340039cc:	6821      	ldr	r1, [r4, #0]
  pLayerCfg.WindowY0 = Config->Y0;
340039ce:	68a2      	ldr	r2, [r4, #8]
  pLayerCfg.WindowX1 = Config->X1;
340039d0:	6865      	ldr	r5, [r4, #4]
  pLayerCfg.WindowY1 = Config->Y1;
340039d2:	68e3      	ldr	r3, [r4, #12]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340039d4:	e9cd e008 	strd	lr, r0, [sp, #32]
  pLayerCfg.FBStartAdress = Config->Address;
340039d8:	6960      	ldr	r0, [r4, #20]
  pLayerCfg.WindowX0 = Config->X0;
340039da:	9101      	str	r1, [sp, #4]
  pLayerCfg.WindowX1 = Config->X1;
340039dc:	9502      	str	r5, [sp, #8]
  pLayerCfg.WindowY0 = Config->Y0;
340039de:	9203      	str	r2, [sp, #12]
  pLayerCfg.WindowY1 = Config->Y1;
340039e0:	9304      	str	r3, [sp, #16]
  pLayerCfg.FBStartAdress = Config->Address;
340039e2:	900a      	str	r0, [sp, #40]	@ 0x28
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
340039e4:	1a9b      	subs	r3, r3, r2
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
340039e6:	1a6d      	subs	r5, r5, r1
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
340039e8:	463a      	mov	r2, r7
340039ea:	4630      	mov	r0, r6
340039ec:	a901      	add	r1, sp, #4
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
340039ee:	950b      	str	r5, [sp, #44]	@ 0x2c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
340039f0:	930c      	str	r3, [sp, #48]	@ 0x30
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
340039f2:	f005 f95d 	bl	34008cb0 <HAL_LTDC_ConfigLayer>
}
340039f6:	b00f      	add	sp, #60	@ 0x3c
340039f8:	bdf0      	pop	{r4, r5, r6, r7, pc}

340039fa <MX_LTDC_ClockConfig>:
{
340039fa:	b500      	push	{lr}
340039fc:	b0e5      	sub	sp, #404	@ 0x194
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
340039fe:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34003a02:	2100      	movs	r1, #0
34003a04:	4668      	mov	r0, sp
34003a06:	f015 f8b9 	bl	34018b7c <memset>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34003a0a:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34003a0e:	2300      	movs	r3, #0
34003a10:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34003a14:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34003a18:	f04f 5140 	mov.w	r1, #805306368	@ 0x30000000
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34003a1c:	9346      	str	r3, [sp, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34003a1e:	2302      	movs	r3, #2
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34003a20:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34003a22:	e9cd 1320 	strd	r1, r3, [sp, #128]	@ 0x80
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34003a26:	f006 fc79 	bl	3400a31c <HAL_RCCEx_PeriphCLKConfig>
}
34003a2a:	3800      	subs	r0, #0
34003a2c:	bf18      	it	ne
34003a2e:	2001      	movne	r0, #1
34003a30:	b065      	add	sp, #404	@ 0x194
34003a32:	f85d fb04 	ldr.w	pc, [sp], #4
	...

34003a38 <BSP_LCD_InitEx>:
{
34003a38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34003a3c:	4614      	mov	r4, r2
  MX_LTDC_LayerConfig_t config = {0};
34003a3e:	2218      	movs	r2, #24
{
34003a40:	460e      	mov	r6, r1
34003a42:	b08d      	sub	sp, #52	@ 0x34
34003a44:	4605      	mov	r5, r0
  MX_LTDC_LayerConfig_t config = {0};
34003a46:	2100      	movs	r1, #0
34003a48:	eb0d 0002 	add.w	r0, sp, r2
{
34003a4c:	4699      	mov	r9, r3
  MX_LTDC_LayerConfig_t config = {0};
34003a4e:	f015 f895 	bl	34018b7c <memset>
  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
34003a52:	2e01      	cmp	r6, #1
34003a54:	f200 80da 	bhi.w	34003c0c <BSP_LCD_InitEx+0x1d4>
34003a58:	2d00      	cmp	r5, #0
34003a5a:	f040 80d7 	bne.w	34003c0c <BSP_LCD_InitEx+0x1d4>
34003a5e:	2c02      	cmp	r4, #2
34003a60:	f240 80ad 	bls.w	34003bbe <BSP_LCD_InitEx+0x186>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
34003a64:	2c04      	cmp	r4, #4
34003a66:	f040 80d1 	bne.w	34003c0c <BSP_LCD_InitEx+0x1d4>
34003a6a:	2302      	movs	r3, #2
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
34003a6c:	2508      	movs	r5, #8
      Lcd_Ctx[Instance].BppFactor = 2U;
34003a6e:	f8df 81d4 	ldr.w	r8, [pc, #468]	@ 34003c44 <BSP_LCD_InitEx+0x20c>
    hlcd_ltdc.Instance = LTDC;
34003a72:	4a68      	ldr	r2, [pc, #416]	@ (34003c14 <BSP_LCD_InitEx+0x1dc>)
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
34003a74:	e9c8 4303 	strd	r4, r3, [r8, #12]
  WRITE_REG(RCC->APB5ENSR, Periphs);
34003a78:	2402      	movs	r4, #2
    Lcd_Ctx[Instance].YSize  = Height;
34003a7a:	9b16      	ldr	r3, [sp, #88]	@ 0x58
34003a7c:	4e66      	ldr	r6, [pc, #408]	@ (34003c18 <BSP_LCD_InitEx+0x1e0>)
34003a7e:	f8c8 3004 	str.w	r3, [r8, #4]
    hlcd_ltdc.Instance = LTDC;
34003a82:	4b66      	ldr	r3, [pc, #408]	@ (34003c1c <BSP_LCD_InitEx+0x1e4>)
    hlcd_dma2d.Instance = DMA2D;
34003a84:	f8df b1c0 	ldr.w	fp, [pc, #448]	@ 34003c48 <BSP_LCD_InitEx+0x210>
    hlcd_ltdc.Instance = LTDC;
34003a88:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
34003a8a:	4b65      	ldr	r3, [pc, #404]	@ (34003c20 <BSP_LCD_InitEx+0x1e8>)
    Lcd_Ctx[Instance].XSize  = Width;
34003a8c:	f8c8 9000 	str.w	r9, [r8]
    hlcd_dma2d.Instance = DMA2D;
34003a90:	f8cb 3000 	str.w	r3, [fp]
34003a94:	f8c6 4a7c 	str.w	r4, [r6, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34003a98:	f8d6 327c 	ldr.w	r3, [r6, #636]	@ 0x27c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34003a9c:	f8df a1ac 	ldr.w	sl, [pc, #428]	@ 34003c4c <BSP_LCD_InitEx+0x214>
  tmpreg = READ_REG(RCC->APB5ENR);
34003aa0:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
34003aa2:	9b00      	ldr	r3, [sp, #0]
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
34003aa4:	2001      	movs	r0, #1
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34003aa6:	f8c6 4a3c 	str.w	r4, [r6, #2620]	@ 0xa3c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34003aaa:	f8ca 423c 	str.w	r4, [sl, #572]	@ 0x23c
34003aae:	f7ff fd13 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
34003ab2:	4620      	mov	r0, r4
34003ab4:	f7ff fd10 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
34003ab8:	2008      	movs	r0, #8
34003aba:	f7ff fd0d 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
34003abe:	2010      	movs	r0, #16
34003ac0:	f7ff fd0a 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
34003ac4:	2040      	movs	r0, #64	@ 0x40
34003ac6:	f7ff fd07 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34003aca:	2080      	movs	r0, #128	@ 0x80
34003acc:	f7ff fd04 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
34003ad0:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34003ad4:	f7ff fd00 	bl	340034d8 <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
    gpio_init_structure.Pull      = GPIO_NOPULL;
34003ad8:	2300      	movs	r3, #0
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003ada:	270e      	movs	r7, #14
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34003adc:	e9cd 3403 	strd	r3, r4, [sp, #12]
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34003ae0:	f248 1387 	movw	r3, #33159	@ 0x8187
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
34003ae4:	484f      	ldr	r0, [pc, #316]	@ (34003c24 <BSP_LCD_InitEx+0x1ec>)
34003ae6:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34003ae8:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003aea:	9705      	str	r7, [sp, #20]
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
34003aec:	9402      	str	r4, [sp, #8]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
34003aee:	f003 fd1d 	bl	3400752c <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34003af2:	f64f 0314 	movw	r3, #63508	@ 0xf814
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34003af6:	484c      	ldr	r0, [pc, #304]	@ (34003c28 <BSP_LCD_InitEx+0x1f0>)
34003af8:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34003afa:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003afc:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34003afe:	f003 fd15 	bl	3400752c <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34003b02:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34003b06:	4849      	ldr	r0, [pc, #292]	@ (34003c2c <BSP_LCD_InitEx+0x1f4>)
34003b08:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34003b0a:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003b0c:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34003b0e:	f003 fd0d 	bl	3400752c <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
34003b12:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003b16:	4846      	ldr	r0, [pc, #280]	@ (34003c30 <BSP_LCD_InitEx+0x1f8>)
34003b18:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_11;
34003b1a:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003b1c:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003b1e:	f003 fd05 	bl	3400752c <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34003b22:	f641 1343 	movw	r3, #6467	@ 0x1943
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003b26:	4843      	ldr	r0, [pc, #268]	@ (34003c34 <BSP_LCD_InitEx+0x1fc>)
34003b28:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34003b2a:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003b2c:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003b2e:	f003 fcfd 	bl	3400752c <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34003b32:	2358      	movs	r3, #88	@ 0x58
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003b34:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003b36:	2701      	movs	r7, #1
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34003b38:	483f      	ldr	r0, [pc, #252]	@ (34003c38 <BSP_LCD_InitEx+0x200>)
34003b3a:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34003b3c:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34003b3e:	f003 fcf5 	bl	3400752c <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003b42:	483b      	ldr	r0, [pc, #236]	@ (34003c30 <BSP_LCD_InitEx+0x1f8>)
34003b44:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_1;
34003b46:	9401      	str	r4, [sp, #4]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003b48:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003b4a:	f003 fcef 	bl	3400752c <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
34003b4e:	2348      	movs	r3, #72	@ 0x48
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34003b50:	483a      	ldr	r0, [pc, #232]	@ (34003c3c <BSP_LCD_InitEx+0x204>)
34003b52:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003b54:	e9cd 3701 	strd	r3, r7, [sp, #4]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34003b58:	f003 fce8 	bl	3400752c <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
34003b5c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003b60:	4834      	ldr	r0, [pc, #208]	@ (34003c34 <BSP_LCD_InitEx+0x1fc>)
34003b62:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003b64:	e9cd 3701 	strd	r3, r7, [sp, #4]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003b68:	f003 fce0 	bl	3400752c <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
34003b6c:	463a      	mov	r2, r7
34003b6e:	2108      	movs	r1, #8
34003b70:	4832      	ldr	r0, [pc, #200]	@ (34003c3c <BSP_LCD_InitEx+0x204>)
34003b72:	f004 f821 	bl	34007bb8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
34003b76:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34003b7a:	463a      	mov	r2, r7
34003b7c:	4619      	mov	r1, r3
34003b7e:	482d      	ldr	r0, [pc, #180]	@ (34003c34 <BSP_LCD_InitEx+0x1fc>)
34003b80:	f004 f81a 	bl	34007bb8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
34003b84:	463a      	mov	r2, r7
34003b86:	2140      	movs	r1, #64	@ 0x40
34003b88:	482c      	ldr	r0, [pc, #176]	@ (34003c3c <BSP_LCD_InitEx+0x204>)
34003b8a:	f004 f815 	bl	34007bb8 <HAL_GPIO_WritePin>
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
  if(hdma2d->Instance == DMA2D)
34003b8e:	f8db 3000 	ldr.w	r3, [fp]
34003b92:	4a23      	ldr	r2, [pc, #140]	@ (34003c20 <BSP_LCD_InitEx+0x1e8>)
34003b94:	4293      	cmp	r3, r2
34003b96:	d109      	bne.n	34003bac <BSP_LCD_InitEx+0x174>
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34003b98:	f8c6 4a60 	str.w	r4, [r6, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34003b9c:	f8d6 3260 	ldr.w	r3, [r6, #608]	@ 0x260
34003ba0:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003ba2:	9b01      	ldr	r3, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34003ba4:	f8c6 4a20 	str.w	r4, [r6, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34003ba8:	f8ca 4220 	str.w	r4, [sl, #544]	@ 0x220
    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34003bac:	481b      	ldr	r0, [pc, #108]	@ (34003c1c <BSP_LCD_InitEx+0x1e4>)
34003bae:	f7ff ff24 	bl	340039fa <MX_LTDC_ClockConfig>
34003bb2:	b170      	cbz	r0, 34003bd2 <BSP_LCD_InitEx+0x19a>
      ret = BSP_ERROR_PERIPH_FAILURE;
34003bb4:	f06f 0003 	mvn.w	r0, #3
}
34003bb8:	b00d      	add	sp, #52	@ 0x34
34003bba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
34003bbe:	d005      	beq.n	34003bcc <BSP_LCD_InitEx+0x194>
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
34003bc0:	2c01      	cmp	r4, #1
34003bc2:	bf0a      	itet	eq
34003bc4:	2303      	moveq	r3, #3
34003bc6:	2304      	movne	r3, #4
34003bc8:	2506      	moveq	r5, #6
34003bca:	e750      	b.n	34003a6e <BSP_LCD_InitEx+0x36>
34003bcc:	4623      	mov	r3, r4
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
34003bce:	2504      	movs	r5, #4
34003bd0:	e74d      	b.n	34003a6e <BSP_LCD_InitEx+0x36>
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
34003bd2:	4649      	mov	r1, r9
34003bd4:	9a16      	ldr	r2, [sp, #88]	@ 0x58
34003bd6:	4811      	ldr	r0, [pc, #68]	@ (34003c1c <BSP_LCD_InitEx+0x1e4>)
34003bd8:	f7ff fec8 	bl	3400396c <MX_LTDC_Init>
34003bdc:	4601      	mov	r1, r0
34003bde:	2800      	cmp	r0, #0
34003be0:	d1e8      	bne.n	34003bb4 <BSP_LCD_InitEx+0x17c>
        config.Y1          = Height;
34003be2:	9b16      	ldr	r3, [sp, #88]	@ 0x58
        config.X1          = Width;
34003be4:	e9cd 0906 	strd	r0, r9, [sp, #24]
        config.PixelFormat = ltdc_pixel_format;
34003be8:	e9cd 3509 	strd	r3, r5, [sp, #36]	@ 0x24
        config.Address     = LCD_LAYER_0_ADDRESS;
34003bec:	4b14      	ldr	r3, [pc, #80]	@ (34003c40 <BSP_LCD_InitEx+0x208>)
        config.Y0          = 0;
34003bee:	9008      	str	r0, [sp, #32]
        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34003bf0:	aa06      	add	r2, sp, #24
34003bf2:	480a      	ldr	r0, [pc, #40]	@ (34003c1c <BSP_LCD_InitEx+0x1e4>)
        config.Address     = LCD_LAYER_0_ADDRESS;
34003bf4:	930b      	str	r3, [sp, #44]	@ 0x2c
        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34003bf6:	f7ff fed7 	bl	340039a8 <MX_LTDC_ConfigLayer>
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34003bfa:	2301      	movs	r3, #1
  int32_t ret = BSP_ERROR_NONE;
34003bfc:	2800      	cmp	r0, #0
34003bfe:	bf14      	ite	ne
34003c00:	f06f 0003 	mvnne.w	r0, #3
34003c04:	2000      	moveq	r0, #0
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34003c06:	f8c8 3018 	str.w	r3, [r8, #24]
34003c0a:	e7d5      	b.n	34003bb8 <BSP_LCD_InitEx+0x180>
    ret = BSP_ERROR_WRONG_PARAM;
34003c0c:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003c10:	e7d2      	b.n	34003bb8 <BSP_LCD_InitEx+0x180>
34003c12:	bf00      	nop
34003c14:	58001000 	.word	0x58001000
34003c18:	56028000 	.word	0x56028000
34003c1c:	34043b24 	.word	0x34043b24
34003c20:	58021000 	.word	0x58021000
34003c24:	56020000 	.word	0x56020000
34003c28:	56020400 	.word	0x56020400
34003c2c:	56020c00 	.word	0x56020c00
34003c30:	56021000 	.word	0x56021000
34003c34:	56021800 	.word	0x56021800
34003c38:	56021c00 	.word	0x56021c00
34003c3c:	56024000 	.word	0x56024000
34003c40:	34200000 	.word	0x34200000
34003c44:	34043b04 	.word	0x34043b04
34003c48:	34043bcc 	.word	0x34043bcc
34003c4c:	56029000 	.word	0x56029000

34003c50 <BSP_LCD_Init>:
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34003c50:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
{
34003c54:	b507      	push	{r0, r1, r2, lr}
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34003c56:	2202      	movs	r2, #2
34003c58:	9300      	str	r3, [sp, #0]
34003c5a:	f44f 7348 	mov.w	r3, #800	@ 0x320
34003c5e:	f7ff feeb 	bl	34003a38 <BSP_LCD_InitEx>
}
34003c62:	b003      	add	sp, #12
34003c64:	f85d fb04 	ldr.w	pc, [sp], #4

34003c68 <BSP_LCD_ConfigLayer>:
{
34003c68:	b508      	push	{r3, lr}
  if(Instance >= LCD_INSTANCES_NBR)
34003c6a:	b9a8      	cbnz	r0, 34003c98 <BSP_LCD_ConfigLayer+0x30>
    if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_RGB565)
34003c6c:	6913      	ldr	r3, [r2, #16]
34003c6e:	2b02      	cmp	r3, #2
34003c70:	d10a      	bne.n	34003c88 <BSP_LCD_ConfigLayer+0x20>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
34003c72:	2304      	movs	r3, #4
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
34003c74:	6113      	str	r3, [r2, #16]
    if (MX_LTDC_ConfigLayer(&hlcd_ltdc, LayerIndex, Config) != HAL_OK)
34003c76:	480a      	ldr	r0, [pc, #40]	@ (34003ca0 <BSP_LCD_ConfigLayer+0x38>)
34003c78:	f7ff fe96 	bl	340039a8 <MX_LTDC_ConfigLayer>
  int32_t ret = BSP_ERROR_NONE;
34003c7c:	2800      	cmp	r0, #0
34003c7e:	bf14      	ite	ne
34003c80:	f06f 0003 	mvnne.w	r0, #3
34003c84:	2000      	moveq	r0, #0
}
34003c86:	bd08      	pop	{r3, pc}
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB4444)
34003c88:	2b04      	cmp	r3, #4
34003c8a:	d101      	bne.n	34003c90 <BSP_LCD_ConfigLayer+0x28>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34003c8c:	2308      	movs	r3, #8
34003c8e:	e7f1      	b.n	34003c74 <BSP_LCD_ConfigLayer+0xc>
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB8888)
34003c90:	2b00      	cmp	r3, #0
34003c92:	d0f0      	beq.n	34003c76 <BSP_LCD_ConfigLayer+0xe>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
34003c94:	2306      	movs	r3, #6
34003c96:	e7ed      	b.n	34003c74 <BSP_LCD_ConfigLayer+0xc>
    ret = BSP_ERROR_WRONG_PARAM;
34003c98:	f06f 0001 	mvn.w	r0, #1
34003c9c:	e7f3      	b.n	34003c86 <BSP_LCD_ConfigLayer+0x1e>
34003c9e:	bf00      	nop
34003ca0:	34043b24 	.word	0x34043b24

34003ca4 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003ca4:	4b04      	ldr	r3, [pc, #16]	@ (34003cb8 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34003ca6:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003ca8:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34003cac:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003cb0:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003cb2:	9b01      	ldr	r3, [sp, #4]
}
34003cb4:	b002      	add	sp, #8
34003cb6:	4770      	bx	lr
34003cb8:	56028000 	.word	0x56028000

34003cbc <XSPI_NOR_EnterSOPIMode.constprop.0>:
/**
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
34003cbc:	b530      	push	{r4, r5, lr}
{
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003cbe:	4c20      	ldr	r4, [pc, #128]	@ (34003d40 <XSPI_NOR_EnterSOPIMode.constprop.0+0x84>)
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
34003cc0:	b085      	sub	sp, #20
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003cc2:	78a2      	ldrb	r2, [r4, #2]
34003cc4:	7861      	ldrb	r1, [r4, #1]
34003cc6:	481f      	ldr	r0, [pc, #124]	@ (34003d44 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003cc8:	f7fe ffac 	bl	34002c24 <MX66UW1G45G_WriteEnable>
34003ccc:	b118      	cbz	r0, 34003cd6 <XSPI_NOR_EnterSOPIMode.constprop.0+0x1a>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003cce:	f06f 0004 	mvn.w	r0, #4
    }
  }

  /* Return BSP status */
  return ret;
}
34003cd2:	b005      	add	sp, #20
34003cd4:	bd30      	pop	{r4, r5, pc}
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003cd6:	9000      	str	r0, [sp, #0]
34003cd8:	f44f 7340 	mov.w	r3, #768	@ 0x300
34003cdc:	78a2      	ldrb	r2, [r4, #2]
34003cde:	7861      	ldrb	r1, [r4, #1]
34003ce0:	4818      	ldr	r0, [pc, #96]	@ (34003d44 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003ce2:	f7ff f828 	bl	34002d36 <MX66UW1G45G_WriteCfg2Register>
34003ce6:	2800      	cmp	r0, #0
34003ce8:	d1f1      	bne.n	34003cce <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003cea:	78a2      	ldrb	r2, [r4, #2]
34003cec:	7861      	ldrb	r1, [r4, #1]
34003cee:	4815      	ldr	r0, [pc, #84]	@ (34003d44 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003cf0:	f7fe ff98 	bl	34002c24 <MX66UW1G45G_WriteEnable>
34003cf4:	4603      	mov	r3, r0
34003cf6:	2800      	cmp	r0, #0
34003cf8:	d1e9      	bne.n	34003cce <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003cfa:	2501      	movs	r5, #1
34003cfc:	9500      	str	r5, [sp, #0]
34003cfe:	78a2      	ldrb	r2, [r4, #2]
34003d00:	7861      	ldrb	r1, [r4, #1]
34003d02:	4810      	ldr	r0, [pc, #64]	@ (34003d44 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003d04:	f7ff f817 	bl	34002d36 <MX66UW1G45G_WriteCfg2Register>
34003d08:	4604      	mov	r4, r0
34003d0a:	2800      	cmp	r0, #0
34003d0c:	d1df      	bne.n	34003cce <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34003d0e:	2028      	movs	r0, #40	@ 0x28
34003d10:	f000 fd82 	bl	34004818 <HAL_Delay>
    if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34003d14:	4622      	mov	r2, r4
34003d16:	4629      	mov	r1, r5
34003d18:	480a      	ldr	r0, [pc, #40]	@ (34003d44 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003d1a:	f7fe fe60 	bl	340029de <MX66UW1G45G_AutoPollingMemReady>
34003d1e:	4603      	mov	r3, r0
34003d20:	2800      	cmp	r0, #0
34003d22:	d1d4      	bne.n	34003cce <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34003d24:	aa03      	add	r2, sp, #12
34003d26:	9200      	str	r2, [sp, #0]
34003d28:	4629      	mov	r1, r5
34003d2a:	4602      	mov	r2, r0
34003d2c:	4805      	ldr	r0, [pc, #20]	@ (34003d44 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003d2e:	f7ff f85a 	bl	34002de6 <MX66UW1G45G_ReadCfg2Register>
34003d32:	2800      	cmp	r0, #0
34003d34:	d1cb      	bne.n	34003cce <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    else if (reg[0] != MX66UW1G45G_CR2_SOPI)
34003d36:	f89d 300c 	ldrb.w	r3, [sp, #12]
34003d3a:	42ab      	cmp	r3, r5
34003d3c:	d0c9      	beq.n	34003cd2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x16>
34003d3e:	e7c6      	b.n	34003cce <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
34003d40:	34043c9c 	.word	0x34043c9c
34003d44:	34043ca0 	.word	0x34043ca0

34003d48 <XSPI_NOR_EnterDOPIMode.constprop.0>:
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
34003d48:	b530      	push	{r4, r5, lr}
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003d4a:	4d27      	ldr	r5, [pc, #156]	@ (34003de8 <XSPI_NOR_EnterDOPIMode.constprop.0+0xa0>)
34003d4c:	4c27      	ldr	r4, [pc, #156]	@ (34003dec <XSPI_NOR_EnterDOPIMode.constprop.0+0xa4>)
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
34003d4e:	b085      	sub	sp, #20
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003d50:	4620      	mov	r0, r4
34003d52:	78aa      	ldrb	r2, [r5, #2]
34003d54:	7869      	ldrb	r1, [r5, #1]
34003d56:	f7fe ff65 	bl	34002c24 <MX66UW1G45G_WriteEnable>
34003d5a:	b118      	cbz	r0, 34003d64 <XSPI_NOR_EnterDOPIMode.constprop.0+0x1c>
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003d5c:	f06f 0004 	mvn.w	r0, #4
}
34003d60:	b005      	add	sp, #20
34003d62:	bd30      	pop	{r4, r5, pc}
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003d64:	9000      	str	r0, [sp, #0]
34003d66:	f44f 7340 	mov.w	r3, #768	@ 0x300
34003d6a:	4620      	mov	r0, r4
34003d6c:	78aa      	ldrb	r2, [r5, #2]
34003d6e:	7869      	ldrb	r1, [r5, #1]
34003d70:	f7fe ffe1 	bl	34002d36 <MX66UW1G45G_WriteCfg2Register>
34003d74:	2800      	cmp	r0, #0
34003d76:	d1f1      	bne.n	34003d5c <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003d78:	4620      	mov	r0, r4
34003d7a:	78aa      	ldrb	r2, [r5, #2]
34003d7c:	7869      	ldrb	r1, [r5, #1]
34003d7e:	f7fe ff51 	bl	34002c24 <MX66UW1G45G_WriteEnable>
34003d82:	4603      	mov	r3, r0
34003d84:	2800      	cmp	r0, #0
34003d86:	d1e9      	bne.n	34003d5c <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003d88:	2202      	movs	r2, #2
34003d8a:	9200      	str	r2, [sp, #0]
34003d8c:	4620      	mov	r0, r4
34003d8e:	78aa      	ldrb	r2, [r5, #2]
34003d90:	7869      	ldrb	r1, [r5, #1]
34003d92:	f7fe ffd0 	bl	34002d36 <MX66UW1G45G_WriteCfg2Register>
34003d96:	2800      	cmp	r0, #0
34003d98:	d1e0      	bne.n	34003d5c <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34003d9a:	2028      	movs	r0, #40	@ 0x28
34003d9c:	f000 fd3c 	bl	34004818 <HAL_Delay>
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34003da0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34003da4:	60e3      	str	r3, [r4, #12]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003da6:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003daa:	4620      	mov	r0, r4
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003dac:	62e3      	str	r3, [r4, #44]	@ 0x2c
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003dae:	f00b ff91 	bl	3400fcd4 <HAL_XSPI_Init>
34003db2:	b9a8      	cbnz	r0, 34003de0 <XSPI_NOR_EnterDOPIMode.constprop.0+0x98>
    else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34003db4:	2201      	movs	r2, #1
34003db6:	4620      	mov	r0, r4
34003db8:	4611      	mov	r1, r2
34003dba:	f7fe fe10 	bl	340029de <MX66UW1G45G_AutoPollingMemReady>
34003dbe:	4603      	mov	r3, r0
34003dc0:	2800      	cmp	r0, #0
34003dc2:	d1cb      	bne.n	34003d5c <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
34003dc4:	aa03      	add	r2, sp, #12
34003dc6:	9200      	str	r2, [sp, #0]
34003dc8:	2201      	movs	r2, #1
34003dca:	4620      	mov	r0, r4
34003dcc:	4611      	mov	r1, r2
34003dce:	f7ff f80a 	bl	34002de6 <MX66UW1G45G_ReadCfg2Register>
34003dd2:	2800      	cmp	r0, #0
34003dd4:	d1c2      	bne.n	34003d5c <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    else if (reg[0] != MX66UW1G45G_CR2_DOPI)
34003dd6:	f89d 300c 	ldrb.w	r3, [sp, #12]
34003dda:	2b02      	cmp	r3, #2
34003ddc:	d0c0      	beq.n	34003d60 <XSPI_NOR_EnterDOPIMode.constprop.0+0x18>
34003dde:	e7bd      	b.n	34003d5c <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
      ret = BSP_ERROR_PERIPH_FAILURE;
34003de0:	f06f 0003 	mvn.w	r0, #3
  return ret;
34003de4:	e7bc      	b.n	34003d60 <XSPI_NOR_EnterDOPIMode.constprop.0+0x18>
34003de6:	bf00      	nop
34003de8:	34043c9c 	.word	0x34043c9c
34003dec:	34043ca0 	.word	0x34043ca0

34003df0 <MX_XSPI_NOR_Init>:
  hxspi->Init.FifoThresholdByte       = 1;
34003df0:	2301      	movs	r3, #1
34003df2:	4a0f      	ldr	r2, [pc, #60]	@ (34003e30 <MX_XSPI_NOR_Init+0x40>)
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34003df4:	f04f 0c02 	mov.w	ip, #2
  hxspi->Init.FifoThresholdByte       = 1;
34003df8:	e9c0 2300 	strd	r2, r3, [r0]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
34003dfc:	680b      	ldr	r3, [r1, #0]
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
34003dfe:	684a      	ldr	r2, [r1, #4]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
34003e00:	6103      	str	r3, [r0, #16]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34003e02:	2300      	movs	r3, #0
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
34003e04:	6242      	str	r2, [r0, #36]	@ 0x24
  hxspi->Init.DelayHoldQuarterCycle   = HAL_XSPI_DHQC_DISABLE;
34003e06:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34003e08:	688a      	ldr	r2, [r1, #8]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34003e0a:	e9c0 c305 	strd	ip, r3, [r0, #20]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
34003e0e:	61c3      	str	r3, [r0, #28]
  hxspi->Init.ChipSelectBoundary      = HAL_XSPI_BONDARYOF_NONE;
34003e10:	6303      	str	r3, [r0, #48]	@ 0x30
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
34003e12:	6083      	str	r3, [r0, #8]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
34003e14:	6203      	str	r3, [r0, #32]
  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34003e16:	68cb      	ldr	r3, [r1, #12]
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34003e18:	6282      	str	r2, [r0, #40]	@ 0x28
  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34003e1a:	2b01      	cmp	r3, #1
34003e1c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34003e20:	60c3      	str	r3, [r0, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003e22:	bf04      	itt	eq
34003e24:	f04f 5380 	moveq.w	r3, #268435456	@ 0x10000000
34003e28:	62c3      	streq	r3, [r0, #44]	@ 0x2c
  return HAL_XSPI_Init(hxspi);
34003e2a:	f00b bf53 	b.w	3400fcd4 <HAL_XSPI_Init>
34003e2e:	bf00      	nop
34003e30:	5802a000 	.word	0x5802a000

34003e34 <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003e34:	4601      	mov	r1, r0
{
34003e36:	b510      	push	{r4, lr}
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003e38:	b9b0      	cbnz	r0, 34003e68 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x34>
    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34003e3a:	4c0d      	ldr	r4, [pc, #52]	@ (34003e70 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x3c>)
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
34003e3c:	480d      	ldr	r0, [pc, #52]	@ (34003e74 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
34003e3e:	f00c fb23 	bl	34010488 <HAL_XSPI_SetClockPrescaler>
    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34003e42:	78a3      	ldrb	r3, [r4, #2]
34003e44:	7861      	ldrb	r1, [r4, #1]
34003e46:	b95b      	cbnz	r3, 34003e60 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x2c>
      if (MX66UW1G45G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003e48:	2201      	movs	r2, #1
34003e4a:	480a      	ldr	r0, [pc, #40]	@ (34003e74 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
34003e4c:	f7fe fe35 	bl	34002aba <MX66UW1G45G_EnableSTRMemoryMappedMode>
34003e50:	b110      	cbz	r0, 34003e58 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x24>
        ret = BSP_ERROR_COMPONENT_FAILURE;
34003e52:	f06f 0004 	mvn.w	r0, #4
}
34003e56:	bd10      	pop	{r4, pc}
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
34003e58:	2302      	movs	r3, #2
  int32_t ret = BSP_ERROR_NONE;
34003e5a:	2000      	movs	r0, #0
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
34003e5c:	7023      	strb	r3, [r4, #0]
34003e5e:	e7fa      	b.n	34003e56 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x22>
      if (MX66UW1G45G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
34003e60:	4804      	ldr	r0, [pc, #16]	@ (34003e74 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
34003e62:	f7fe fe8f 	bl	34002b84 <MX66UW1G45G_EnableDTRMemoryMappedMode>
34003e66:	e7f3      	b.n	34003e50 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1c>
    ret = BSP_ERROR_WRONG_PARAM;
34003e68:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003e6c:	e7f3      	b.n	34003e56 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x22>
34003e6e:	bf00      	nop
34003e70:	34043c9c 	.word	0x34043c9c
34003e74:	34043ca0 	.word	0x34043ca0

34003e78 <BSP_XSPI_NOR_ConfigFlash>:
{
34003e78:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
34003e7c:	460d      	mov	r5, r1
34003e7e:	4616      	mov	r6, r2
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003e80:	2800      	cmp	r0, #0
34003e82:	d15f      	bne.n	34003f44 <BSP_XSPI_NOR_ConfigFlash+0xcc>
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
34003e84:	4c32      	ldr	r4, [pc, #200]	@ (34003f50 <BSP_XSPI_NOR_ConfigFlash+0xd8>)
34003e86:	7823      	ldrb	r3, [r4, #0]
34003e88:	2b02      	cmp	r3, #2
34003e8a:	d05e      	beq.n	34003f4a <BSP_XSPI_NOR_ConfigFlash+0xd2>
      switch (XSPI_Nor_Ctx[Instance].InterfaceMode)
34003e8c:	7863      	ldrb	r3, [r4, #1]
34003e8e:	2b01      	cmp	r3, #1
34003e90:	d14f      	bne.n	34003f32 <BSP_XSPI_NOR_ConfigFlash+0xba>
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != XSPI_Nor_Ctx[Instance].TransferRate))
34003e92:	2901      	cmp	r1, #1
34003e94:	78a2      	ldrb	r2, [r4, #2]
34003e96:	d109      	bne.n	34003eac <BSP_XSPI_NOR_ConfigFlash+0x34>
34003e98:	4296      	cmp	r6, r2
34003e9a:	d107      	bne.n	34003eac <BSP_XSPI_NOR_ConfigFlash+0x34>
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34003e9c:	2301      	movs	r3, #1
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34003e9e:	2000      	movs	r0, #0
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34003ea0:	7023      	strb	r3, [r4, #0]
        XSPI_Nor_Ctx[Instance].InterfaceMode = Mode;
34003ea2:	7065      	strb	r5, [r4, #1]
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34003ea4:	70a6      	strb	r6, [r4, #2]
}
34003ea6:	b004      	add	sp, #16
34003ea8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
  int32_t ret = BSP_ERROR_NONE;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003eac:	4f29      	ldr	r7, [pc, #164]	@ (34003f54 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34003eae:	2101      	movs	r1, #1
34003eb0:	4638      	mov	r0, r7
34003eb2:	f7fe feb7 	bl	34002c24 <MX66UW1G45G_WriteEnable>
34003eb6:	4603      	mov	r3, r0
34003eb8:	b110      	cbz	r0, 34003ec0 <BSP_XSPI_NOR_ConfigFlash+0x48>
            ret = XSPI_NOR_ExitOPIMode(Instance);
34003eba:	f06f 0004 	mvn.w	r0, #4
34003ebe:	e7f2      	b.n	34003ea6 <BSP_XSPI_NOR_ConfigFlash+0x2e>
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
    reg[1] = 0;
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003ec0:	9000      	str	r0, [sp, #0]
    reg[0] = 0;
34003ec2:	f8ad 000c 	strh.w	r0, [sp, #12]
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003ec6:	78a2      	ldrb	r2, [r4, #2]
34003ec8:	4638      	mov	r0, r7
34003eca:	7861      	ldrb	r1, [r4, #1]
34003ecc:	f7fe ff33 	bl	34002d36 <MX66UW1G45G_WriteCfg2Register>
34003ed0:	4680      	mov	r8, r0
34003ed2:	2800      	cmp	r0, #0
34003ed4:	d1f1      	bne.n	34003eba <BSP_XSPI_NOR_ConfigFlash+0x42>
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34003ed6:	2028      	movs	r0, #40	@ 0x28
34003ed8:	f000 fc9e 	bl	34004818 <HAL_Delay>

      if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
34003edc:	78a3      	ldrb	r3, [r4, #2]
34003ede:	2b01      	cmp	r3, #1
34003ee0:	d01b      	beq.n	34003f1a <BSP_XSPI_NOR_ConfigFlash+0xa2>
      }

      if (ret == BSP_ERROR_NONE)
      {
        /* Check Flash busy ? */
        if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34003ee2:	2200      	movs	r2, #0
34003ee4:	481b      	ldr	r0, [pc, #108]	@ (34003f54 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34003ee6:	4611      	mov	r1, r2
34003ee8:	f7fe fd79 	bl	340029de <MX66UW1G45G_AutoPollingMemReady>
34003eec:	4603      	mov	r3, r0
34003eee:	2800      	cmp	r0, #0
34003ef0:	d1e3      	bne.n	34003eba <BSP_XSPI_NOR_ConfigFlash+0x42>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        /* Check the configuration has been correctly done */
        else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34003ef2:	aa03      	add	r2, sp, #12
34003ef4:	4601      	mov	r1, r0
34003ef6:	9200      	str	r2, [sp, #0]
34003ef8:	4602      	mov	r2, r0
34003efa:	4816      	ldr	r0, [pc, #88]	@ (34003f54 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34003efc:	f7fe ff73 	bl	34002de6 <MX66UW1G45G_ReadCfg2Register>
34003f00:	2800      	cmp	r0, #0
34003f02:	d1da      	bne.n	34003eba <BSP_XSPI_NOR_ConfigFlash+0x42>
                                               MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        else if (reg[0] != 0U)
34003f04:	f89d 300c 	ldrb.w	r3, [sp, #12]
34003f08:	2b00      	cmp	r3, #0
34003f0a:	d1d6      	bne.n	34003eba <BSP_XSPI_NOR_ConfigFlash+0x42>
            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
34003f0c:	2d01      	cmp	r5, #1
34003f0e:	d1c5      	bne.n	34003e9c <BSP_XSPI_NOR_ConfigFlash+0x24>
              if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34003f10:	78a3      	ldrb	r3, [r4, #2]
34003f12:	b993      	cbnz	r3, 34003f3a <BSP_XSPI_NOR_ConfigFlash+0xc2>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
34003f14:	f7ff ff18 	bl	34003d48 <XSPI_NOR_EnterDOPIMode.constprop.0>
34003f18:	e011      	b.n	34003f3e <BSP_XSPI_NOR_ConfigFlash+0xc6>
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003f1a:	4638      	mov	r0, r7
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
34003f1c:	f8c7 800c 	str.w	r8, [r7, #12]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34003f20:	f8c7 802c 	str.w	r8, [r7, #44]	@ 0x2c
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003f24:	f00b fed6 	bl	3400fcd4 <HAL_XSPI_Init>
34003f28:	2800      	cmp	r0, #0
34003f2a:	d0da      	beq.n	34003ee2 <BSP_XSPI_NOR_ConfigFlash+0x6a>
            ret = XSPI_NOR_ExitOPIMode(Instance);
34003f2c:	f06f 0003 	mvn.w	r0, #3
34003f30:	e7b9      	b.n	34003ea6 <BSP_XSPI_NOR_ConfigFlash+0x2e>
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
34003f32:	2901      	cmp	r1, #1
34003f34:	d1b2      	bne.n	34003e9c <BSP_XSPI_NOR_ConfigFlash+0x24>
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
34003f36:	2a00      	cmp	r2, #0
34003f38:	d1ec      	bne.n	34003f14 <BSP_XSPI_NOR_ConfigFlash+0x9c>
              ret = XSPI_NOR_EnterSOPIMode(Instance);
34003f3a:	f7ff febf 	bl	34003cbc <XSPI_NOR_EnterSOPIMode.constprop.0>
      if (ret == BSP_ERROR_NONE)
34003f3e:	2800      	cmp	r0, #0
34003f40:	d1b1      	bne.n	34003ea6 <BSP_XSPI_NOR_ConfigFlash+0x2e>
34003f42:	e7ab      	b.n	34003e9c <BSP_XSPI_NOR_ConfigFlash+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
34003f44:	f06f 0001 	mvn.w	r0, #1
34003f48:	e7ad      	b.n	34003ea6 <BSP_XSPI_NOR_ConfigFlash+0x2e>
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
34003f4a:	f06f 0019 	mvn.w	r0, #25
  return ret;
34003f4e:	e7aa      	b.n	34003ea6 <BSP_XSPI_NOR_ConfigFlash+0x2e>
34003f50:	34043c9c 	.word	0x34043c9c
34003f54:	34043ca0 	.word	0x34043ca0

34003f58 <BSP_XSPI_NOR_Init>:
{
34003f58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34003f5c:	4689      	mov	r9, r1
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003f5e:	4604      	mov	r4, r0
34003f60:	4e81      	ldr	r6, [pc, #516]	@ (34004168 <BSP_XSPI_NOR_Init+0x210>)
{
34003f62:	b08e      	sub	sp, #56	@ 0x38
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003f64:	2800      	cmp	r0, #0
34003f66:	f040 80f8 	bne.w	3400415a <BSP_XSPI_NOR_Init+0x202>
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
34003f6a:	f8df 8208 	ldr.w	r8, [pc, #520]	@ 34004174 <BSP_XSPI_NOR_Init+0x21c>
34003f6e:	f898 3000 	ldrb.w	r3, [r8]
34003f72:	b153      	cbz	r3, 34003f8a <BSP_XSPI_NOR_Init+0x32>
      ret = BSP_ERROR_NONE;
34003f74:	2500      	movs	r5, #0
 (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
34003f76:	2064      	movs	r0, #100	@ 0x64
34003f78:	2100      	movs	r1, #0
34003f7a:	fb00 6004 	mla	r0, r0, r4, r6
34003f7e:	f00c fa83 	bl	34010488 <HAL_XSPI_SetClockPrescaler>
}
34003f82:	4628      	mov	r0, r5
34003f84:	b00e      	add	sp, #56	@ 0x38
34003f86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34003f8a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34003f8e:	4a77      	ldr	r2, [pc, #476]	@ (3400416c <BSP_XSPI_NOR_Init+0x214>)
  __HAL_RCC_PWR_CLK_ENABLE();
34003f90:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34003f94:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34003f98:	f8d2 1260 	ldr.w	r1, [r2, #608]	@ 0x260
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34003f9c:	2509      	movs	r5, #9
34003f9e:	9100      	str	r1, [sp, #0]
  (void)tmpreg;
34003fa0:	9900      	ldr	r1, [sp, #0]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34003fa2:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34003fa6:	441a      	add	r2, r3
34003fa8:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
  __HAL_RCC_PWR_CLK_ENABLE();
34003fac:	f7ff fe7a 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
34003fb0:	f004 ffce 	bl	34008f50 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
34003fb4:	2101      	movs	r1, #1
34003fb6:	2002      	movs	r0, #2
34003fb8:	f004 ff7c 	bl	34008eb4 <HAL_PWREx_ConfigVddIORange>
  XSPI_NOR_CLK_GPIO_CLK_ENABLE();
34003fbc:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34003fc0:	f7ff fe70 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34003fc4:	2701      	movs	r7, #1
  XSPI_NOR_DQS_GPIO_CLK_ENABLE();
34003fc6:	f7ff fe6d 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_CS_GPIO_CLK_ENABLE();
34003fca:	f7ff fe6b 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D0_GPIO_CLK_ENABLE();
34003fce:	f7ff fe69 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D1_GPIO_CLK_ENABLE();
34003fd2:	f7ff fe67 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D2_GPIO_CLK_ENABLE();
34003fd6:	f7ff fe65 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D3_GPIO_CLK_ENABLE();
34003fda:	f7ff fe63 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D4_GPIO_CLK_ENABLE();
34003fde:	f7ff fe61 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D5_GPIO_CLK_ENABLE();
34003fe2:	f7ff fe5f 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D6_GPIO_CLK_ENABLE();
34003fe6:	f7ff fe5d 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D7_GPIO_CLK_ENABLE();
34003fea:	f7ff fe5b 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Pin       = XSPI_NOR_CS_PIN;
34003fee:	2302      	movs	r3, #2
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
34003ff0:	485f      	ldr	r0, [pc, #380]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34003ff2:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34003ff4:	e9cd 3305 	strd	r3, r3, [sp, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
34003ff8:	e9cd 7307 	strd	r7, r3, [sp, #28]
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34003ffc:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
34003ffe:	f003 fa95 	bl	3400752c <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
34004002:	485b      	ldr	r0, [pc, #364]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004004:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_DQS_PIN;
34004006:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_DQS_PIN_AF;
34004008:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
3400400a:	f003 fa8f 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
3400400e:	2340      	movs	r3, #64	@ 0x40
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
34004010:	4857      	ldr	r0, [pc, #348]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004012:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
34004014:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
34004016:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Alternate = XSPI_NOR_CLK_PIN_AF;
34004018:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
3400401a:	f003 fa87 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
3400401e:	2304      	movs	r3, #4
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34004020:	4853      	ldr	r0, [pc, #332]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004022:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
34004024:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D0_PIN_AF;
34004026:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34004028:	f003 fa80 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
3400402c:	2308      	movs	r3, #8
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
3400402e:	4850      	ldr	r0, [pc, #320]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004030:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
34004032:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D1_PIN_AF;
34004034:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
34004036:	f003 fa79 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
3400403a:	2310      	movs	r3, #16
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
3400403c:	f04f 0a20 	mov.w	sl, #32
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
34004040:	484b      	ldr	r0, [pc, #300]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004042:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
34004044:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D2_PIN_AF;
34004046:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
34004048:	f003 fa70 	bl	3400752c <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
3400404c:	4848      	ldr	r0, [pc, #288]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
3400404e:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
34004050:	f8cd a014 	str.w	sl, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D3_PIN_AF;
34004054:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
34004056:	f003 fa69 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
3400405a:	f44f 7380 	mov.w	r3, #256	@ 0x100
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
3400405e:	4844      	ldr	r0, [pc, #272]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004060:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
34004062:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D4_PIN_AF;
34004064:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
34004066:	f003 fa61 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
3400406a:	f44f 7300 	mov.w	r3, #512	@ 0x200
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
3400406e:	4840      	ldr	r0, [pc, #256]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004070:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
34004072:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D5_PIN_AF;
34004074:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
34004076:	f003 fa59 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
3400407a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
3400407e:	483c      	ldr	r0, [pc, #240]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
34004080:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
34004082:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D6_PIN_AF;
34004084:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
34004086:	f003 fa51 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
3400408a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
3400408e:	a905      	add	r1, sp, #20
34004090:	4837      	ldr	r0, [pc, #220]	@ (34004170 <BSP_XSPI_NOR_Init+0x218>)
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
34004092:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D7_PIN_AF;
34004094:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
34004096:	f003 fa49 	bl	3400752c <HAL_GPIO_Init>
      (void)MX66UW1G45G_GetFlashInfo(&pInfo);
3400409a:	a805      	add	r0, sp, #20
3400409c:	f7fe fc86 	bl	340029ac <MX66UW1G45G_GetFlashInfo>
      xspi_init.ClockPrescaler = 0x03; /* XSPI clock = 200MHz / ClockPrescaler = 50MHz, then switch to 200MHz*/
340040a0:	2303      	movs	r3, #3
340040a2:	9302      	str	r3, [sp, #8]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
340040a4:	9b05      	ldr	r3, [sp, #20]
340040a6:	fa93 f3a3 	rbit	r3, r3
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
340040aa:	2b00      	cmp	r3, #0
340040ac:	fab3 f283 	clz	r2, r3
340040b0:	bf08      	it	eq
340040b2:	4652      	moveq	r2, sl
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
340040b4:	f899 3001 	ldrb.w	r3, [r9, #1]
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
340040b8:	4630      	mov	r0, r6
340040ba:	a901      	add	r1, sp, #4
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
340040bc:	9201      	str	r2, [sp, #4]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
340040be:	9403      	str	r4, [sp, #12]
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
340040c0:	9304      	str	r3, [sp, #16]
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
340040c2:	f7ff fe95 	bl	34003df0 <MX_XSPI_NOR_Init>
340040c6:	2800      	cmp	r0, #0
340040c8:	d14a      	bne.n	34004160 <BSP_XSPI_NOR_Init+0x208>
  if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
340040ca:	4622      	mov	r2, r4
340040cc:	4621      	mov	r1, r4
340040ce:	4630      	mov	r0, r6
340040d0:	f7fe feeb 	bl	34002eaa <MX66UW1G45G_ResetEnable>
340040d4:	b110      	cbz	r0, 340040dc <BSP_XSPI_NOR_Init+0x184>
        ret = BSP_ERROR_COMPONENT_FAILURE;
340040d6:	f06f 0504 	mvn.w	r5, #4
340040da:	e74c      	b.n	34003f76 <BSP_XSPI_NOR_Init+0x1e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
340040dc:	4622      	mov	r2, r4
340040de:	4621      	mov	r1, r4
340040e0:	4630      	mov	r0, r6
340040e2:	f7fe ff0f 	bl	34002f04 <MX66UW1G45G_ResetMemory>
340040e6:	2800      	cmp	r0, #0
340040e8:	d1f5      	bne.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340040ea:	4622      	mov	r2, r4
340040ec:	4639      	mov	r1, r7
340040ee:	4630      	mov	r0, r6
340040f0:	f7fe fedb 	bl	34002eaa <MX66UW1G45G_ResetEnable>
340040f4:	2800      	cmp	r0, #0
340040f6:	d1ee      	bne.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340040f8:	4622      	mov	r2, r4
340040fa:	4639      	mov	r1, r7
340040fc:	4630      	mov	r0, r6
340040fe:	f7fe ff01 	bl	34002f04 <MX66UW1G45G_ResetMemory>
34004102:	2800      	cmp	r0, #0
34004104:	d1e7      	bne.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004106:	463a      	mov	r2, r7
34004108:	4639      	mov	r1, r7
3400410a:	4630      	mov	r0, r6
3400410c:	f7fe fecd 	bl	34002eaa <MX66UW1G45G_ResetEnable>
34004110:	2800      	cmp	r0, #0
34004112:	d1e0      	bne.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34004114:	463a      	mov	r2, r7
34004116:	4639      	mov	r1, r7
34004118:	4630      	mov	r0, r6
3400411a:	f7fe fef3 	bl	34002f04 <MX66UW1G45G_ResetMemory>
3400411e:	2800      	cmp	r0, #0
34004120:	d1d9      	bne.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34004122:	2064      	movs	r0, #100	@ 0x64
    XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;     /* After reset S/W setting to indirect access  */
34004124:	f888 7000 	strb.w	r7, [r8]
    XSPI_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;    /* After reset H/W back to SPI mode by default */
34004128:	f888 4001 	strb.w	r4, [r8, #1]
    XSPI_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode        */
3400412c:	f888 4002 	strb.w	r4, [r8, #2]
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34004130:	f000 fb72 	bl	34004818 <HAL_Delay>
      else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004134:	4630      	mov	r0, r6
34004136:	f898 2002 	ldrb.w	r2, [r8, #2]
3400413a:	f898 1001 	ldrb.w	r1, [r8, #1]
3400413e:	f7fe fc4e 	bl	340029de <MX66UW1G45G_AutoPollingMemReady>
34004142:	2800      	cmp	r0, #0
34004144:	d1c7      	bne.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
34004146:	f899 2001 	ldrb.w	r2, [r9, #1]
3400414a:	f899 1000 	ldrb.w	r1, [r9]
3400414e:	f7ff fe93 	bl	34003e78 <BSP_XSPI_NOR_ConfigFlash>
34004152:	2800      	cmp	r0, #0
34004154:	f43f af0e 	beq.w	34003f74 <BSP_XSPI_NOR_Init+0x1c>
34004158:	e7bd      	b.n	340040d6 <BSP_XSPI_NOR_Init+0x17e>
    ret = BSP_ERROR_WRONG_PARAM;
3400415a:	f06f 0501 	mvn.w	r5, #1
3400415e:	e70a      	b.n	34003f76 <BSP_XSPI_NOR_Init+0x1e>
        ret = BSP_ERROR_PERIPH_FAILURE;
34004160:	f06f 0503 	mvn.w	r5, #3
34004164:	e707      	b.n	34003f76 <BSP_XSPI_NOR_Init+0x1e>
34004166:	bf00      	nop
34004168:	34043ca0 	.word	0x34043ca0
3400416c:	56028000 	.word	0x56028000
34004170:	56023400 	.word	0x56023400
34004174:	34043c9c 	.word	0x34043c9c

34004178 <MX_XSPI_RAM_Init>:
{
34004178:	b538      	push	{r3, r4, r5, lr}
3400417a:	4604      	mov	r4, r0
3400417c:	460d      	mov	r5, r1
  uint32_t hspi_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1);
3400417e:	2000      	movs	r0, #0
34004180:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
34004184:	f00a fa38 	bl	3400e5f8 <HAL_RCCEx_GetPeriphCLKFreq>
  hxspi->Init.FifoThresholdByte          = 8;
34004188:	2308      	movs	r3, #8
3400418a:	4a13      	ldr	r2, [pc, #76]	@ (340041d8 <MX_XSPI_RAM_Init+0x60>)
  hxspi->Init.SampleShifting             = Init->SampleShifting;
3400418c:	68a9      	ldr	r1, [r5, #8]
  hxspi->Init.FifoThresholdByte          = 8;
3400418e:	e9c4 2300 	strd	r2, r3, [r4]
  hxspi->Init.MemoryMode                 = HAL_XSPI_SINGLE_MEM;
34004192:	2200      	movs	r2, #0
34004194:	f04f 63c0 	mov.w	r3, #100663296	@ 0x6000000
34004198:	e9c4 2302 	strd	r2, r3, [r4, #8]
  hxspi->Init.MemorySize                 = Init->MemorySize;
3400419c:	682b      	ldr	r3, [r5, #0]
  hxspi->Init.MemorySelect               = HAL_XSPI_CSSEL_NCS1;
3400419e:	63e2      	str	r2, [r4, #60]	@ 0x3c
  hxspi->Init.MemorySize                 = Init->MemorySize;
340041a0:	6123      	str	r3, [r4, #16]
  hxspi->Init.ChipSelectHighTimeCycle    = 1;
340041a2:	2301      	movs	r3, #1
340041a4:	6163      	str	r3, [r4, #20]
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
340041a6:	686b      	ldr	r3, [r5, #4]
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
340041a8:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
  hxspi->Init.SampleShifting             = Init->SampleShifting;
340041ac:	62a1      	str	r1, [r4, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
340041ae:	210b      	movs	r1, #11
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
340041b0:	6263      	str	r3, [r4, #36]	@ 0x24
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
340041b2:	fbb0 f3f3 	udiv	r3, r0, r3
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
340041b6:	e9c4 510b 	strd	r5, r1, [r4, #44]	@ 0x2c
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
340041ba:	4908      	ldr	r1, [pc, #32]	@ (340041dc <MX_XSPI_RAM_Init+0x64>)
340041bc:	005b      	lsls	r3, r3, #1
340041be:	fbb3 f3f1 	udiv	r3, r3, r1
340041c2:	3b04      	subs	r3, #4
  return HAL_XSPI_Init(hxspi);
340041c4:	4620      	mov	r0, r4
  hxspi->Init.ClockMode                  = HAL_XSPI_CLOCK_MODE_0;
340041c6:	61e2      	str	r2, [r4, #28]
  hxspi->Init.FreeRunningClock           = HAL_XSPI_FREERUNCLK_DISABLE;
340041c8:	61a2      	str	r2, [r4, #24]
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
340041ca:	63a3      	str	r3, [r4, #56]	@ 0x38
  hxspi->Init.WrapSize                   = HAL_XSPI_WRAP_NOT_SUPPORTED;
340041cc:	6222      	str	r2, [r4, #32]
}
340041ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return HAL_XSPI_Init(hxspi);
340041d2:	f00b bd7f 	b.w	3400fcd4 <HAL_XSPI_Init>
340041d6:	bf00      	nop
340041d8:	58025000 	.word	0x58025000
340041dc:	000f4240 	.word	0x000f4240

340041e0 <BSP_XSPI_RAM_Init>:
{
340041e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
340041e4:	4604      	mov	r4, r0
{
340041e6:	b08b      	sub	sp, #44	@ 0x2c
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
340041e8:	2800      	cmp	r0, #0
340041ea:	f040 810d 	bne.w	34004408 <BSP_XSPI_RAM_Init+0x228>
    if (XSPI_Ram_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
340041ee:	4e88      	ldr	r6, [pc, #544]	@ (34004410 <BSP_XSPI_RAM_Init+0x230>)
340041f0:	7833      	ldrb	r3, [r6, #0]
340041f2:	9301      	str	r3, [sp, #4]
340041f4:	2b00      	cmp	r3, #0
340041f6:	f040 80f0 	bne.w	340043da <BSP_XSPI_RAM_Init+0x1fa>

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

 /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
340041fa:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
340041fe:	f7ff fd51 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO2();
34004202:	f004 fe9d 	bl	34008f40 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2, PWR_VDDIO_RANGE_1V8);
34004206:	2101      	movs	r1, #1
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34004208:	f04f 0820 	mov.w	r8, #32
3400420c:	f44f 5700 	mov.w	r7, #8192	@ 0x2000
34004210:	4608      	mov	r0, r1
34004212:	f004 fe4f 	bl	34008eb4 <HAL_PWREx_ConfigVddIORange>
34004216:	4b7f      	ldr	r3, [pc, #508]	@ (34004414 <BSP_XSPI_RAM_Init+0x234>)
  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CS_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
34004218:	2409      	movs	r4, #9
3400421a:	f8c3 8a60 	str.w	r8, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
3400421e:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34004222:	2501      	movs	r5, #1
34004224:	9204      	str	r2, [sp, #16]
  (void)tmpreg;
34004226:	9a04      	ldr	r2, [sp, #16]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004228:	4a7b      	ldr	r2, [pc, #492]	@ (34004418 <BSP_XSPI_RAM_Init+0x238>)
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
3400422a:	f8c3 8a20 	str.w	r8, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400422e:	f8c2 8220 	str.w	r8, [r2, #544]	@ 0x220
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34004232:	f8c3 7a60 	str.w	r7, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34004236:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
3400423a:	f04f 0903 	mov.w	r9, #3
3400423e:	9103      	str	r1, [sp, #12]
  (void)tmpreg;
34004240:	9903      	ldr	r1, [sp, #12]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34004242:	f8c3 7a20 	str.w	r7, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004246:	f8c2 7220 	str.w	r7, [r2, #544]	@ 0x220
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
3400424a:	2202      	movs	r2, #2
  XSPI_RAM_CLK_GPIO_CLK_ENABLE();
3400424c:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34004250:	f7ff fd28 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_DQS_GPIO_CLK_ENABLE();
34004254:	f7ff fd26 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_CS_GPIO_CLK_ENABLE();
34004258:	f7ff fd24 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D0_GPIO_CLK_ENABLE();
3400425c:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34004260:	f7ff fd20 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
34004264:	a905      	add	r1, sp, #20
  XSPI_RAM_D1_GPIO_CLK_ENABLE();
34004266:	f7ff fd1d 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D2_GPIO_CLK_ENABLE();
3400426a:	f7ff fd1b 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D3_GPIO_CLK_ENABLE();
3400426e:	f7ff fd19 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D4_GPIO_CLK_ENABLE();
34004272:	f7ff fd17 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D5_GPIO_CLK_ENABLE();
34004276:	f7ff fd15 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D6_GPIO_CLK_ENABLE();
3400427a:	f7ff fd13 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D7_GPIO_CLK_ENABLE();
3400427e:	f7ff fd11 	bl	34003ca4 <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
34004282:	4866      	ldr	r0, [pc, #408]	@ (3400441c <BSP_XSPI_RAM_Init+0x23c>)
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34004284:	e9cd 5205 	strd	r5, r2, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
34004288:	e9cd 9408 	strd	r9, r4, [sp, #32]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
3400428c:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
3400428e:	f003 f94d 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI DQS0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
34004292:	2304      	movs	r3, #4
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);

  /* XSPI DQS1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
34004294:	f04f 0b08 	mov.w	fp, #8
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
34004298:	f04f 0a10 	mov.w	sl, #16
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
3400429c:	485f      	ldr	r0, [pc, #380]	@ (3400441c <BSP_XSPI_RAM_Init+0x23c>)
3400429e:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
340042a0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
340042a2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340042a4:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
340042a6:	f003 f941 	bl	3400752c <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
340042aa:	485c      	ldr	r0, [pc, #368]	@ (3400441c <BSP_XSPI_RAM_Init+0x23c>)
340042ac:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
340042ae:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
340042b0:	f8cd b014 	str.w	fp, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340042b4:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
340042b6:	f003 f939 	bl	3400752c <HAL_GPIO_Init>
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
340042ba:	4858      	ldr	r0, [pc, #352]	@ (3400441c <BSP_XSPI_RAM_Init+0x23c>)
340042bc:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
340042be:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
340042c0:	f8cd a014 	str.w	sl, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340042c4:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
340042c6:	f003 f931 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
340042ca:	4855      	ldr	r0, [pc, #340]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
340042cc:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
340042ce:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
340042d0:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340042d2:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
340042d4:	f003 f92a 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
340042d8:	2202      	movs	r2, #2
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
340042da:	4851      	ldr	r0, [pc, #324]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
340042dc:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
340042de:	9205      	str	r2, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
340042e0:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
340042e2:	f003 f923 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
340042e6:	2304      	movs	r3, #4
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
340042e8:	484d      	ldr	r0, [pc, #308]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
340042ea:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
340042ec:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
340042ee:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
340042f0:	f003 f91c 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
340042f4:	484a      	ldr	r0, [pc, #296]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
340042f6:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
340042f8:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
340042fa:	f8cd b014 	str.w	fp, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
340042fe:	f003 f915 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
34004302:	4847      	ldr	r0, [pc, #284]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004304:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
34004306:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
34004308:	f8cd a014 	str.w	sl, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
3400430c:	f003 f90e 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
34004310:	4843      	ldr	r0, [pc, #268]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004312:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
34004314:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
34004316:	f8cd 8014 	str.w	r8, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
3400431a:	f003 f907 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
3400431e:	2340      	movs	r3, #64	@ 0x40
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34004320:	483f      	ldr	r0, [pc, #252]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004322:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
34004324:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
34004326:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34004328:	f003 f900 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
3400432c:	2380      	movs	r3, #128	@ 0x80
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
3400432e:	483c      	ldr	r0, [pc, #240]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004330:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
34004332:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
34004334:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
34004336:	f003 f8f9 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D8 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
3400433a:	f44f 7380 	mov.w	r3, #256	@ 0x100
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
3400433e:	4838      	ldr	r0, [pc, #224]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004340:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
34004342:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
34004344:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
34004346:	f003 f8f1 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D9 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
3400434a:	f44f 7300 	mov.w	r3, #512	@ 0x200
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
3400434e:	4834      	ldr	r0, [pc, #208]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004350:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
34004352:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
34004354:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
34004356:	f003 f8e9 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D10 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
3400435a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
3400435e:	4830      	ldr	r0, [pc, #192]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004360:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
34004362:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
34004364:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
34004366:	f003 f8e1 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D11 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
3400436a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
3400436e:	482c      	ldr	r0, [pc, #176]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004370:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
34004372:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
34004374:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
34004376:	f003 f8d9 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D12 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
3400437a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
3400437e:	4828      	ldr	r0, [pc, #160]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
34004380:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
34004382:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
34004384:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
34004386:	f003 f8d1 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D13 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
3400438a:	4825      	ldr	r0, [pc, #148]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
3400438c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
3400438e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
34004390:	9705      	str	r7, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
34004392:	f003 f8cb 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D14 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34004396:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
3400439a:	4821      	ldr	r0, [pc, #132]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
3400439c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
3400439e:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
340043a0:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
340043a2:	f003 f8c3 	bl	3400752c <HAL_GPIO_Init>

  /* XSPI D15 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
340043a6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
340043aa:	481d      	ldr	r0, [pc, #116]	@ (34004420 <BSP_XSPI_RAM_Init+0x240>)
340043ac:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
340043ae:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
340043b0:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
340043b2:	f003 f8bb 	bl	3400752c <HAL_GPIO_Init>
      xspi_init.MemorySize     = HAL_XSPI_SIZE_256MB;
340043b6:	2318      	movs	r3, #24
340043b8:	9305      	str	r3, [sp, #20]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
340043ba:	9b01      	ldr	r3, [sp, #4]
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
340043bc:	4819      	ldr	r0, [pc, #100]	@ (34004424 <BSP_XSPI_RAM_Init+0x244>)
340043be:	a905      	add	r1, sp, #20
      xspi_init.ClockPrescaler = 3;
340043c0:	f8cd 9018 	str.w	r9, [sp, #24]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
340043c4:	9307      	str	r3, [sp, #28]
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
340043c6:	f7ff fed7 	bl	34004178 <MX_XSPI_RAM_Init>
  int32_t ret = BSP_ERROR_NONE;
340043ca:	2800      	cmp	r0, #0
340043cc:	bf14      	ite	ne
340043ce:	f06f 0403 	mvnne.w	r4, #3
340043d2:	2400      	moveq	r4, #0
      XSPI_Ram_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
340043d4:	7035      	strb	r5, [r6, #0]
      XSPI_Ram_Ctx[Instance].LatencyType   = BSP_XSPI_RAM_FIXED_LATENCY;
340043d6:	7075      	strb	r5, [r6, #1]
      XSPI_Ram_Ctx[Instance].BurstType     = BSP_XSPI_RAM_LINEAR_BURST;
340043d8:	70b5      	strb	r5, [r6, #2]
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 0, 0x30));
340043da:	2230      	movs	r2, #48	@ 0x30
340043dc:	2100      	movs	r1, #0
340043de:	4811      	ldr	r0, [pc, #68]	@ (34004424 <BSP_XSPI_RAM_Init+0x244>)
340043e0:	f7fe faac 	bl	3400293c <APS256XX_WriteReg>
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 4, 0x20));
340043e4:	2220      	movs	r2, #32
340043e6:	2104      	movs	r1, #4
340043e8:	480e      	ldr	r0, [pc, #56]	@ (34004424 <BSP_XSPI_RAM_Init+0x244>)
340043ea:	f7fe faa7 	bl	3400293c <APS256XX_WriteReg>
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 8, 0x40));
340043ee:	2108      	movs	r1, #8
340043f0:	2240      	movs	r2, #64	@ 0x40
340043f2:	480c      	ldr	r0, [pc, #48]	@ (34004424 <BSP_XSPI_RAM_Init+0x244>)
340043f4:	f7fe faa2 	bl	3400293c <APS256XX_WriteReg>
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_ram[Instance], 0));
340043f8:	2100      	movs	r1, #0
340043fa:	480a      	ldr	r0, [pc, #40]	@ (34004424 <BSP_XSPI_RAM_Init+0x244>)
340043fc:	f00c f844 	bl	34010488 <HAL_XSPI_SetClockPrescaler>
}
34004400:	4620      	mov	r0, r4
34004402:	b00b      	add	sp, #44	@ 0x2c
34004404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = BSP_ERROR_WRONG_PARAM;
34004408:	f06f 0401 	mvn.w	r4, #1
  return ret;
3400440c:	e7f8      	b.n	34004400 <BSP_XSPI_RAM_Init+0x220>
3400440e:	bf00      	nop
34004410:	34043c34 	.word	0x34043c34
34004414:	56028000 	.word	0x56028000
34004418:	56029000 	.word	0x56029000
3400441c:	56023800 	.word	0x56023800
34004420:	56023c00 	.word	0x56023c00
34004424:	34043c38 	.word	0x34043c38

34004428 <BSP_XSPI_RAM_EnableMemoryMappedMode>:
{
34004428:	b507      	push	{r0, r1, r2, lr}
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
3400442a:	b968      	cbnz	r0, 34004448 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x20>
    if (APS256XX_EnableMemoryMappedMode(&hxspi_ram[Instance], 7, 7, 1, 0) != APS256XX_OK)
3400442c:	2207      	movs	r2, #7
3400442e:	9000      	str	r0, [sp, #0]
34004430:	2301      	movs	r3, #1
34004432:	4611      	mov	r1, r2
34004434:	4806      	ldr	r0, [pc, #24]	@ (34004450 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x28>)
34004436:	f7fe fa26 	bl	34002886 <APS256XX_EnableMemoryMappedMode>
      ret = BSP_ERROR_PERIPH_FAILURE;
3400443a:	2800      	cmp	r0, #0
3400443c:	bf18      	it	ne
3400443e:	f06f 0003 	mvnne.w	r0, #3
}
34004442:	b003      	add	sp, #12
34004444:	f85d fb04 	ldr.w	pc, [sp], #4
    ret = BSP_ERROR_WRONG_PARAM;
34004448:	f06f 0001 	mvn.w	r0, #1
3400444c:	e7f9      	b.n	34004442 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x1a>
3400444e:	bf00      	nop
34004450:	34043c38 	.word	0x34043c38

34004454 <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34004454:	4b44      	ldr	r3, [pc, #272]	@ (34004568 <SystemInit+0x114>)
34004456:	4a45      	ldr	r2, [pc, #276]	@ (3400456c <SystemInit+0x118>)
{
34004458:	b570      	push	{r4, r5, r6, lr}
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
3400445a:	2001      	movs	r0, #1
  SCB->VTOR = INTVECT_START;
3400445c:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
  SAU->RLAR = 0;
  SAU->RNR = 1;
  SAU->RBAR = 0;
  SAU->RLAR = 0;
  SAU->RNR = 2;
3400445e:	2502      	movs	r5, #2
  SAU->RNR = 0;
34004460:	2200      	movs	r2, #0
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34004462:	4943      	ldr	r1, [pc, #268]	@ (34004570 <SystemInit+0x11c>)
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34004464:	4e43      	ldr	r6, [pc, #268]	@ (34004574 <SystemInit+0x120>)
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34004466:	f501 5480 	add.w	r4, r1, #4096	@ 0x1000
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
3400446a:	f8c1 0a18 	str.w	r0, [r1, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
3400446e:	f8c4 0218 	str.w	r0, [r4, #536]	@ 0x218
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34004472:	f8c4 0258 	str.w	r0, [r4, #600]	@ 0x258
  SAU->RNR = 0;
34004476:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
3400447a:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
3400447e:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 1;
34004482:	f8c3 00d8 	str.w	r0, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
34004486:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
3400448a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 2;
3400448e:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 3;
34004492:	2503      	movs	r5, #3
  SAU->RBAR = 0;
34004494:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004498:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 3;
3400449c:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 4;
340044a0:	2504      	movs	r5, #4
  SAU->RBAR = 0;
340044a2:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340044a6:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 4;
340044aa:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 5;
340044ae:	2505      	movs	r5, #5
  SAU->RBAR = 0;
340044b0:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340044b4:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 5;
340044b8:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 6;
340044bc:	2506      	movs	r5, #6
  SAU->RBAR = 0;
340044be:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340044c2:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 6;
340044c6:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 7;
340044ca:	2507      	movs	r5, #7
  SAU->RBAR = 0;
340044cc:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340044d0:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 7;
340044d4:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
340044d8:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340044dc:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
340044e0:	f8c1 0a78 	str.w	r0, [r1, #2680]	@ 0xa78
  (void)RCC->APB4ENR2;
340044e4:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
  SYSCFG->INITSVTORCR = SCB->VTOR;
340044e8:	689a      	ldr	r2, [r3, #8]
340044ea:	6132      	str	r2, [r6, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
340044ec:	4a22      	ldr	r2, [pc, #136]	@ (34004578 <SystemInit+0x124>)
340044ee:	6bd5      	ldr	r5, [r2, #60]	@ 0x3c
340044f0:	f445 5580 	orr.w	r5, r5, #4096	@ 0x1000
340044f4:	63d5      	str	r5, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
340044f6:	6bd5      	ldr	r5, [r2, #60]	@ 0x3c
340044f8:	f045 0510 	orr.w	r5, r5, #16
340044fc:	63d5      	str	r5, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
340044fe:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34004500:	f8d1 2274 	ldr.w	r2, [r1, #628]	@ 0x274
34004504:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34004508:	f8c1 2274 	str.w	r2, [r1, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
3400450c:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
34004510:	f042 0210 	orr.w	r2, r2, #16
34004514:	f8c1 2278 	str.w	r2, [r1, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34004518:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
3400451c:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
34004520:	f022 0210 	bic.w	r2, r2, #16
34004524:	f8c1 2278 	str.w	r2, [r1, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34004528:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
3400452c:	f8c1 2a20 	str.w	r2, [r1, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34004530:	f8c4 2220 	str.w	r2, [r4, #544]	@ 0x220
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34004534:	2240      	movs	r2, #64	@ 0x40
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34004536:	f8c1 0a24 	str.w	r0, [r1, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
3400453a:	f8c4 0224 	str.w	r0, [r4, #548]	@ 0x224
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
3400453e:	f8c4 0264 	str.w	r0, [r4, #612]	@ 0x264
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34004542:	f8c4 225c 	str.w	r2, [r4, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34004546:	6932      	ldr	r2, [r6, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34004548:	f8c4 0278 	str.w	r0, [r4, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
3400454c:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34004550:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
34004554:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34004558:	4a08      	ldr	r2, [pc, #32]	@ (3400457c <SystemInit+0x128>)
3400455a:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
3400455e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34004562:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34004566:	bd70      	pop	{r4, r5, r6, pc}
34004568:	e000ed00 	.word	0xe000ed00
3400456c:	34000400 	.word	0x34000400
34004570:	56028000 	.word	0x56028000
34004574:	56008000 	.word	0x56008000
34004578:	56024800 	.word	0x56024800
3400457c:	e002ed00 	.word	0xe002ed00

34004580 <SystemCoreClockUpdate>:
  uint32_t pllp2 = 0;
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004580:	4b6e      	ldr	r3, [pc, #440]	@ (3400473c <SystemCoreClockUpdate+0x1bc>)
{
34004582:	b5f0      	push	{r4, r5, r6, r7, lr}
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004584:	6a1a      	ldr	r2, [r3, #32]
34004586:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
3400458a:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
3400458e:	f000 80b8 	beq.w	34004702 <SystemCoreClockUpdate+0x182>
34004592:	d806      	bhi.n	340045a2 <SystemCoreClockUpdate+0x22>
34004594:	b962      	cbnz	r2, 340045b0 <SystemCoreClockUpdate+0x30>
  {
  case 0:  /* HSI used as system clock source (default after reset) */
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34004596:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34004598:	4b69      	ldr	r3, [pc, #420]	@ (34004740 <SystemCoreClockUpdate+0x1c0>)
3400459a:	f3c2 12c1 	ubfx	r2, r2, #7, #2
3400459e:	40d3      	lsrs	r3, r2
    break;
340045a0:	e003      	b.n	340045aa <SystemCoreClockUpdate+0x2a>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
340045a2:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
340045a6:	d00b      	beq.n	340045c0 <SystemCoreClockUpdate+0x40>
  uint32_t sysclk = 0;
340045a8:	2300      	movs	r3, #0
    /* Nothing to do, should not occur */
    break;
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
340045aa:	4a66      	ldr	r2, [pc, #408]	@ (34004744 <SystemCoreClockUpdate+0x1c4>)
340045ac:	6013      	str	r3, [r2, #0]
}
340045ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
340045b0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
      sysclk = MSI_VALUE;
340045b2:	4a65      	ldr	r2, [pc, #404]	@ (34004748 <SystemCoreClockUpdate+0x1c8>)
340045b4:	f413 7f00 	tst.w	r3, #512	@ 0x200
340045b8:	4b64      	ldr	r3, [pc, #400]	@ (3400474c <SystemCoreClockUpdate+0x1cc>)
340045ba:	bf08      	it	eq
340045bc:	4613      	moveq	r3, r2
340045be:	e7f4      	b.n	340045aa <SystemCoreClockUpdate+0x2a>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
340045c0:	f8d3 20c4 	ldr.w	r2, [r3, #196]	@ 0xc4
340045c4:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
340045c8:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
340045cc:	d02a      	beq.n	34004624 <SystemCoreClockUpdate+0xa4>
340045ce:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
340045d2:	d036      	beq.n	34004642 <SystemCoreClockUpdate+0xc2>
340045d4:	2a00      	cmp	r2, #0
340045d6:	d143      	bne.n	34004660 <SystemCoreClockUpdate+0xe0>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
340045d8:	f8d3 7080 	ldr.w	r7, [r3, #128]	@ 0x80
      if (pllbypass == 0U)
340045dc:	013d      	lsls	r5, r7, #4
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
340045de:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
340045e2:	f100 8096 	bmi.w	34004712 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
340045e6:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
340045ea:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
340045ee:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
340045f2:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
340045f6:	460e      	mov	r6, r1
    switch (pllsource)
340045f8:	f1b6 5f00 	cmp.w	r6, #536870912	@ 0x20000000
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
340045fc:	f3c2 65c2 	ubfx	r5, r2, #27, #3
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34004600:	f3c7 5105 	ubfx	r1, r7, #20, #6
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34004604:	f3c2 6202 	ubfx	r2, r2, #24, #3
    switch (pllsource)
34004608:	d04f      	beq.n	340046aa <SystemCoreClockUpdate+0x12a>
3400460a:	d87c      	bhi.n	34004706 <SystemCoreClockUpdate+0x186>
3400460c:	2e00      	cmp	r6, #0
3400460e:	d03c      	beq.n	3400468a <SystemCoreClockUpdate+0x10a>
34004610:	2600      	movs	r6, #0
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34004612:	4b4a      	ldr	r3, [pc, #296]	@ (3400473c <SystemCoreClockUpdate+0x1bc>)
        sysclk = MSI_VALUE;
34004614:	4f4c      	ldr	r7, [pc, #304]	@ (34004748 <SystemCoreClockUpdate+0x1c8>)
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34004616:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        sysclk = MSI_VALUE;
34004618:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400461c:	4b4b      	ldr	r3, [pc, #300]	@ (3400474c <SystemCoreClockUpdate+0x1cc>)
3400461e:	bf08      	it	eq
34004620:	463b      	moveq	r3, r7
34004622:	e038      	b.n	34004696 <SystemCoreClockUpdate+0x116>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34004624:	f8d3 7090 	ldr.w	r7, [r3, #144]	@ 0x90
      if (pllbypass == 0U)
34004628:	013c      	lsls	r4, r7, #4
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
3400462a:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
3400462e:	d470      	bmi.n	34004712 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34004630:	f8d3 0094 	ldr.w	r0, [r3, #148]	@ 0x94
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34004634:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34004638:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
3400463c:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34004640:	e7d9      	b.n	340045f6 <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34004642:	f8d3 70a0 	ldr.w	r7, [r3, #160]	@ 0xa0
      if (pllbypass == 0U)
34004646:	0138      	lsls	r0, r7, #4
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34004648:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
3400464c:	d461      	bmi.n	34004712 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
3400464e:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34004652:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34004656:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
3400465a:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
3400465e:	e7ca      	b.n	340045f6 <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34004660:	f8d3 70b0 	ldr.w	r7, [r3, #176]	@ 0xb0
      if (pllbypass == 0U)
34004664:	013a      	lsls	r2, r7, #4
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34004666:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
3400466a:	d452      	bmi.n	34004712 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
3400466c:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34004670:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34004674:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34004678:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
3400467c:	e7bb      	b.n	340045f6 <SystemCoreClockUpdate+0x76>
    switch (pllsource)
3400467e:	460a      	mov	r2, r1
34004680:	460d      	mov	r5, r1
34004682:	4608      	mov	r0, r1
34004684:	460c      	mov	r4, r1
34004686:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3400468a:	4b2c      	ldr	r3, [pc, #176]	@ (3400473c <SystemCoreClockUpdate+0x1bc>)
3400468c:	6c9f      	ldr	r7, [r3, #72]	@ 0x48
3400468e:	4b2c      	ldr	r3, [pc, #176]	@ (34004740 <SystemCoreClockUpdate+0x1c0>)
34004690:	f3c7 17c1 	ubfx	r7, r7, #7, #2
34004694:	40fb      	lsrs	r3, r7
    if (pllbypass == 0U)
34004696:	b14e      	cbz	r6, 340046ac <SystemCoreClockUpdate+0x12c>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34004698:	4a28      	ldr	r2, [pc, #160]	@ (3400473c <SystemCoreClockUpdate+0x1bc>)
3400469a:	f8d2 20c4 	ldr.w	r2, [r2, #196]	@ 0xc4
3400469e:	f3c2 4207 	ubfx	r2, r2, #16, #8
340046a2:	3201      	adds	r2, #1
    sysclk = sysclk / ic_divider;
340046a4:	fbb3 f3f2 	udiv	r3, r3, r2
    break;
340046a8:	e77f      	b.n	340045aa <SystemCoreClockUpdate+0x2a>
      sysclk = HSE_VALUE;
340046aa:	4b29      	ldr	r3, [pc, #164]	@ (34004750 <SystemCoreClockUpdate+0x1d0>)
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
340046ac:	ee07 0a10 	vmov	s14, r0
340046b0:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
340046b4:	ee07 4a10 	vmov	s14, r4
340046b8:	ee07 3a90 	vmov	s15, r3
340046bc:	eddf 6a25 	vldr	s13, [pc, #148]	@ 34004754 <SystemCoreClockUpdate+0x1d4>
340046c0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
340046c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340046c8:	eea6 7a26 	vfma.f32	s14, s12, s13
340046cc:	ee67 7a87 	vmul.f32	s15, s15, s14
340046d0:	ee07 1a10 	vmov	s14, r1
340046d4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
340046d8:	eec7 6a87 	vdiv.f32	s13, s15, s14
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
340046dc:	ee07 5a90 	vmov	s15, r5
340046e0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
340046e4:	ee07 2a90 	vmov	s15, r2
340046e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340046ec:	ee27 7a27 	vmul.f32	s14, s14, s15
340046f0:	eec6 7a87 	vdiv.f32	s15, s13, s14
340046f4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
340046f8:	ee17 3a90 	vmov	r3, s15
340046fc:	e7cc      	b.n	34004698 <SystemCoreClockUpdate+0x118>
      sysclk = HSE_VALUE;
340046fe:	4b14      	ldr	r3, [pc, #80]	@ (34004750 <SystemCoreClockUpdate+0x1d0>)
34004700:	e7ca      	b.n	34004698 <SystemCoreClockUpdate+0x118>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004702:	4b13      	ldr	r3, [pc, #76]	@ (34004750 <SystemCoreClockUpdate+0x1d0>)
34004704:	e751      	b.n	340045aa <SystemCoreClockUpdate+0x2a>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34004706:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
3400470a:	4b13      	ldr	r3, [pc, #76]	@ (34004758 <SystemCoreClockUpdate+0x1d8>)
3400470c:	bf18      	it	ne
3400470e:	2300      	movne	r3, #0
34004710:	e7cc      	b.n	340046ac <SystemCoreClockUpdate+0x12c>
    switch (pllsource)
34004712:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
34004716:	d0f2      	beq.n	340046fe <SystemCoreClockUpdate+0x17e>
34004718:	d809      	bhi.n	3400472e <SystemCoreClockUpdate+0x1ae>
3400471a:	2900      	cmp	r1, #0
3400471c:	d0af      	beq.n	3400467e <SystemCoreClockUpdate+0xfe>
3400471e:	2200      	movs	r2, #0
34004720:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
34004724:	4615      	mov	r5, r2
34004726:	4610      	mov	r0, r2
34004728:	4614      	mov	r4, r2
3400472a:	4611      	mov	r1, r2
3400472c:	e771      	b.n	34004612 <SystemCoreClockUpdate+0x92>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
3400472e:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34004732:	4b09      	ldr	r3, [pc, #36]	@ (34004758 <SystemCoreClockUpdate+0x1d8>)
34004734:	bf18      	it	ne
34004736:	2300      	movne	r3, #0
34004738:	e7ae      	b.n	34004698 <SystemCoreClockUpdate+0x118>
3400473a:	bf00      	nop
3400473c:	56028000 	.word	0x56028000
34004740:	03d09000 	.word	0x03d09000
34004744:	3403ecbc 	.word	0x3403ecbc
34004748:	003d0900 	.word	0x003d0900
3400474c:	00f42400 	.word	0x00f42400
34004750:	02dc6c00 	.word	0x02dc6c00
34004754:	33800000 	.word	0x33800000
34004758:	00bb8000 	.word	0x00bb8000

3400475c <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
3400475c:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34004760:	b500      	push	{lr}
  SystemCoreClockUpdate();
34004762:	f7ff ff0d 	bl	34004580 <SystemCoreClockUpdate>

  return SystemCoreClock;
}
34004766:	4b05      	ldr	r3, [pc, #20]	@ (3400477c <__acle_se_SECURE_SystemCoreClockUpdate+0x20>)
34004768:	f85d eb04 	ldr.w	lr, [sp], #4
3400476c:	6818      	ldr	r0, [r3, #0]
3400476e:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34004772:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34004776:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
3400477a:	4774      	bxns	lr
3400477c:	3403ecbc 	.word	0x3403ecbc

34004780 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
34004780:	4770      	bx	lr
	...

34004784 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34004784:	b538      	push	{r3, r4, r5, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34004786:	4b0f      	ldr	r3, [pc, #60]	@ (340047c4 <HAL_InitTick+0x40>)
{
34004788:	4605      	mov	r5, r0
  if ((uint32_t)uwTickFreq == 0UL)
3400478a:	781a      	ldrb	r2, [r3, #0]
3400478c:	b90a      	cbnz	r2, 34004792 <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
3400478e:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
34004790:	bd38      	pop	{r3, r4, r5, pc}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34004792:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34004796:	fbb3 f3f2 	udiv	r3, r3, r2
3400479a:	4a0b      	ldr	r2, [pc, #44]	@ (340047c8 <HAL_InitTick+0x44>)
3400479c:	6810      	ldr	r0, [r2, #0]
3400479e:	fbb0 f0f3 	udiv	r0, r0, r3
340047a2:	f000 f9f1 	bl	34004b88 <HAL_SYSTICK_Config>
340047a6:	4604      	mov	r4, r0
340047a8:	2800      	cmp	r0, #0
340047aa:	d1f0      	bne.n	3400478e <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
340047ac:	2d0f      	cmp	r5, #15
340047ae:	d8ee      	bhi.n	3400478e <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
340047b0:	4602      	mov	r2, r0
340047b2:	4629      	mov	r1, r5
340047b4:	f04f 30ff 	mov.w	r0, #4294967295
340047b8:	f000 f974 	bl	34004aa4 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
340047bc:	4b03      	ldr	r3, [pc, #12]	@ (340047cc <HAL_InitTick+0x48>)
340047be:	4620      	mov	r0, r4
340047c0:	601d      	str	r5, [r3, #0]
  return HAL_OK;
340047c2:	e7e5      	b.n	34004790 <HAL_InitTick+0xc>
340047c4:	3403ecc0 	.word	0x3403ecc0
340047c8:	3403ecbc 	.word	0x3403ecbc
340047cc:	3403ecc4 	.word	0x3403ecc4

340047d0 <HAL_Init>:
{
340047d0:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
340047d2:	2003      	movs	r0, #3
340047d4:	f000 f948 	bl	34004a68 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
340047d8:	f7ff fed2 	bl	34004580 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
340047dc:	200f      	movs	r0, #15
340047de:	f7ff ffd1 	bl	34004784 <HAL_InitTick>
340047e2:	4604      	mov	r4, r0
340047e4:	b918      	cbnz	r0, 340047ee <HAL_Init+0x1e>
  HAL_MspInit();
340047e6:	f7ff ffcb 	bl	34004780 <HAL_MspInit>
}
340047ea:	4620      	mov	r0, r4
340047ec:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340047ee:	2401      	movs	r4, #1
340047f0:	e7fb      	b.n	340047ea <HAL_Init+0x1a>
	...

340047f4 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
340047f4:	4a03      	ldr	r2, [pc, #12]	@ (34004804 <HAL_IncTick+0x10>)
340047f6:	4b04      	ldr	r3, [pc, #16]	@ (34004808 <HAL_IncTick+0x14>)
340047f8:	6811      	ldr	r1, [r2, #0]
340047fa:	781b      	ldrb	r3, [r3, #0]
340047fc:	440b      	add	r3, r1
340047fe:	6013      	str	r3, [r2, #0]
}
34004800:	4770      	bx	lr
34004802:	bf00      	nop
34004804:	34043d04 	.word	0x34043d04
34004808:	3403ecc0 	.word	0x3403ecc0

3400480c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
3400480c:	4b01      	ldr	r3, [pc, #4]	@ (34004814 <HAL_GetTick+0x8>)
3400480e:	6818      	ldr	r0, [r3, #0]
}
34004810:	4770      	bx	lr
34004812:	bf00      	nop
34004814:	34043d04 	.word	0x34043d04

34004818 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
34004818:	b538      	push	{r3, r4, r5, lr}
3400481a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
3400481c:	f7ff fff6 	bl	3400480c <HAL_GetTick>
34004820:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
34004822:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
34004824:	bf1e      	ittt	ne
34004826:	4b04      	ldrne	r3, [pc, #16]	@ (34004838 <HAL_Delay+0x20>)
34004828:	781b      	ldrbne	r3, [r3, #0]
3400482a:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
3400482c:	f7ff ffee 	bl	3400480c <HAL_GetTick>
34004830:	1b43      	subs	r3, r0, r5
34004832:	42a3      	cmp	r3, r4
34004834:	d3fa      	bcc.n	3400482c <HAL_Delay+0x14>
  {
  }
}
34004836:	bd38      	pop	{r3, r4, r5, pc}
34004838:	3403ecc0 	.word	0x3403ecc0

3400483c <HAL_BSEC_OTP_Reload>:
  * @param  FuseId  Fuse to be reload, this parameter value is between 0 and BSEC_NB_FUSES-1
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Reload(BSEC_HandleTypeDef *hbsec, uint32_t FuseId)
{
3400483c:	b570      	push	{r4, r5, r6, lr}
3400483e:	4604      	mov	r4, r0
34004840:	460d      	mov	r5, r1
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t tick_start = HAL_GetTick();
34004842:	f7ff ffe3 	bl	3400480c <HAL_GetTick>
34004846:	4606      	mov	r6, r0

  /* Check the handle pointer */
  if (hbsec == NULL)
34004848:	b12c      	cbz	r4, 34004856 <HAL_BSEC_OTP_Reload+0x1a>
  {
    return HAL_ERROR;
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
3400484a:	6822      	ldr	r2, [r4, #0]
3400484c:	4b1b      	ldr	r3, [pc, #108]	@ (340048bc <HAL_BSEC_OTP_Reload+0x80>)
3400484e:	429a      	cmp	r2, r3
34004850:	d003      	beq.n	3400485a <HAL_BSEC_OTP_Reload+0x1e>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004852:	2301      	movs	r3, #1
34004854:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
34004856:	2001      	movs	r0, #1
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
    return HAL_ERROR;
  }

  return HAL_OK;
}
34004858:	bd70      	pop	{r4, r5, r6, pc}
  if (FuseId < BSEC_NB_FUSES)
3400485a:	f5b5 7fbc 	cmp.w	r5, #376	@ 0x178
3400485e:	d2f8      	bcs.n	34004852 <HAL_BSEC_OTP_Reload+0x16>
    status_reg = FuseId / 32U;
34004860:	096b      	lsrs	r3, r5, #5
    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
34004862:	f503 7308 	add.w	r3, r3, #544	@ 0x220
34004866:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
3400486a:	2301      	movs	r3, #1
3400486c:	f005 001f 	and.w	r0, r5, #31
34004870:	4083      	lsls	r3, r0
    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
34004872:	420b      	tst	r3, r1
34004874:	d11f      	bne.n	340048b6 <HAL_BSEC_OTP_Reload+0x7a>
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR), FuseId);
34004876:	f8d2 3c04 	ldr.w	r3, [r2, #3076]	@ 0xc04
3400487a:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
3400487e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34004882:	432b      	orrs	r3, r5
34004884:	f8c2 3c04 	str.w	r3, [r2, #3076]	@ 0xc04
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34004888:	6823      	ldr	r3, [r4, #0]
3400488a:	f8d3 2e44 	ldr.w	r2, [r3, #3652]	@ 0xe44
3400488e:	07d2      	lsls	r2, r2, #31
34004890:	d409      	bmi.n	340048a6 <HAL_BSEC_OTP_Reload+0x6a>
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS) != 0U)
34004892:	f8d3 0e44 	ldr.w	r0, [r3, #3652]	@ 0xe44
34004896:	f410 008c 	ands.w	r0, r0, #4587520	@ 0x460000
3400489a:	d0dd      	beq.n	34004858 <HAL_BSEC_OTP_Reload+0x1c>
        hbsec->ErrorCode = (hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS);
3400489c:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
340048a0:	f403 038c 	and.w	r3, r3, #4587520	@ 0x460000
340048a4:	e7d6      	b.n	34004854 <HAL_BSEC_OTP_Reload+0x18>
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
340048a6:	f7ff ffb1 	bl	3400480c <HAL_GetTick>
340048aa:	1b80      	subs	r0, r0, r6
340048ac:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
340048b0:	d9ea      	bls.n	34004888 <HAL_BSEC_OTP_Reload+0x4c>
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
340048b2:	230a      	movs	r3, #10
340048b4:	e7ce      	b.n	34004854 <HAL_BSEC_OTP_Reload+0x18>
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
340048b6:	2304      	movs	r3, #4
340048b8:	e7cc      	b.n	34004854 <HAL_BSEC_OTP_Reload+0x18>
340048ba:	bf00      	nop
340048bc:	56009000 	.word	0x56009000

340048c0 <HAL_BSEC_OTP_Read>:
{
340048c0:	b570      	push	{r4, r5, r6, lr}
340048c2:	460e      	mov	r6, r1
340048c4:	4615      	mov	r5, r2
  if (hbsec == NULL)
340048c6:	4604      	mov	r4, r0
340048c8:	b130      	cbz	r0, 340048d8 <HAL_BSEC_OTP_Read+0x18>
 if ((pFuseData == NULL) || (hbsec->Instance != BSEC))
340048ca:	b11a      	cbz	r2, 340048d4 <HAL_BSEC_OTP_Read+0x14>
340048cc:	6802      	ldr	r2, [r0, #0]
340048ce:	4b09      	ldr	r3, [pc, #36]	@ (340048f4 <HAL_BSEC_OTP_Read+0x34>)
340048d0:	429a      	cmp	r2, r3
340048d2:	d003      	beq.n	340048dc <HAL_BSEC_OTP_Read+0x1c>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340048d4:	2301      	movs	r3, #1
340048d6:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
340048d8:	2001      	movs	r0, #1
}
340048da:	bd70      	pop	{r4, r5, r6, pc}
  if (FuseId < BSEC_NB_FUSES)
340048dc:	f5b1 7fbc 	cmp.w	r1, #376	@ 0x178
340048e0:	d2f8      	bcs.n	340048d4 <HAL_BSEC_OTP_Read+0x14>
    if (HAL_BSEC_OTP_Reload(hbsec, FuseId) == HAL_OK)
340048e2:	f7ff ffab 	bl	3400483c <HAL_BSEC_OTP_Reload>
340048e6:	2800      	cmp	r0, #0
340048e8:	d1f6      	bne.n	340048d8 <HAL_BSEC_OTP_Read+0x18>
      *pFuseData = hbsec->Instance->FVRw[FuseId];
340048ea:	6823      	ldr	r3, [r4, #0]
340048ec:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
340048f0:	602b      	str	r3, [r5, #0]
  return HAL_OK;
340048f2:	e7f2      	b.n	340048da <HAL_BSEC_OTP_Read+0x1a>
340048f4:	56009000 	.word	0x56009000

340048f8 <HAL_BSEC_OTP_Program>:
{
340048f8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
340048fc:	4604      	mov	r4, r0
340048fe:	460e      	mov	r6, r1
34004900:	4617      	mov	r7, r2
34004902:	4699      	mov	r9, r3
  uint32_t tick_start = HAL_GetTick();
34004904:	f7ff ff82 	bl	3400480c <HAL_GetTick>
34004908:	4680      	mov	r8, r0
  if (hbsec == NULL)
3400490a:	b12c      	cbz	r4, 34004918 <HAL_BSEC_OTP_Program+0x20>
 if (hbsec->Instance != BSEC)
3400490c:	6822      	ldr	r2, [r4, #0]
3400490e:	4b28      	ldr	r3, [pc, #160]	@ (340049b0 <HAL_BSEC_OTP_Program+0xb8>)
34004910:	429a      	cmp	r2, r3
34004912:	d005      	beq.n	34004920 <HAL_BSEC_OTP_Program+0x28>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004914:	2301      	movs	r3, #1
34004916:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
34004918:	2001      	movs	r0, #1
}
3400491a:	b003      	add	sp, #12
3400491c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_BSEC_PERMANENT_LOCK(Lock));
34004920:	f439 4380 	bics.w	r3, r9, #16384	@ 0x4000
34004924:	d004      	beq.n	34004930 <HAL_BSEC_OTP_Program+0x38>
34004926:	f44f 71dd 	mov.w	r1, #442	@ 0x1ba
3400492a:	4822      	ldr	r0, [pc, #136]	@ (340049b4 <HAL_BSEC_OTP_Program+0xbc>)
3400492c:	f7fd fe02 	bl	34002534 <assert_failed>
  if (FuseId < BSEC_NB_FUSES)
34004930:	f5b6 7fbc 	cmp.w	r6, #376	@ 0x178
34004934:	d2ee      	bcs.n	34004914 <HAL_BSEC_OTP_Program+0x1c>
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004936:	6822      	ldr	r2, [r4, #0]
    status_reg = FuseId / 32U;
34004938:	0973      	lsrs	r3, r6, #5
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
3400493a:	f503 7300 	add.w	r3, r3, #512	@ 0x200
3400493e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
34004942:	2301      	movs	r3, #1
34004944:	f006 001f 	and.w	r0, r6, #31
34004948:	4083      	lsls	r3, r0
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
3400494a:	420b      	tst	r3, r1
3400494c:	d12e      	bne.n	340049ac <HAL_BSEC_OTP_Program+0xb4>
      hbsec->Instance->WDR = FuseData;
3400494e:	f8c2 7c08 	str.w	r7, [r2, #3080]	@ 0xc08
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR),
34004952:	f8d2 5c04 	ldr.w	r5, [r2, #3076]	@ 0xc04
34004956:	f425 45c3 	bic.w	r5, r5, #24960	@ 0x6180
3400495a:	f025 057f 	bic.w	r5, r5, #127	@ 0x7f
3400495e:	4335      	orrs	r5, r6
34004960:	ea45 0509 	orr.w	r5, r5, r9
34004964:	f445 5500 	orr.w	r5, r5, #8192	@ 0x2000
34004968:	f8c2 5c04 	str.w	r5, [r2, #3076]	@ 0xc04
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
3400496c:	6823      	ldr	r3, [r4, #0]
3400496e:	f8d3 2e44 	ldr.w	r2, [r3, #3652]	@ 0xe44
34004972:	07d2      	lsls	r2, r2, #31
34004974:	d406      	bmi.n	34004984 <HAL_BSEC_OTP_Program+0x8c>
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_PROGFAIL) != 0U)
34004976:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
3400497a:	03db      	lsls	r3, r3, #15
3400497c:	d50b      	bpl.n	34004996 <HAL_BSEC_OTP_Program+0x9e>
        hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
3400497e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
34004982:	e7c8      	b.n	34004916 <HAL_BSEC_OTP_Program+0x1e>
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
34004984:	f7ff ff42 	bl	3400480c <HAL_GetTick>
34004988:	eba0 0008 	sub.w	r0, r0, r8
3400498c:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34004990:	d9ec      	bls.n	3400496c <HAL_BSEC_OTP_Program+0x74>
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
34004992:	230a      	movs	r3, #10
34004994:	e7bf      	b.n	34004916 <HAL_BSEC_OTP_Program+0x1e>
      if (HAL_BSEC_OTP_Read(hbsec, FuseId, &read_data) == HAL_OK)
34004996:	4631      	mov	r1, r6
34004998:	4620      	mov	r0, r4
3400499a:	aa01      	add	r2, sp, #4
3400499c:	f7ff ff90 	bl	340048c0 <HAL_BSEC_OTP_Read>
340049a0:	2800      	cmp	r0, #0
340049a2:	d1b9      	bne.n	34004918 <HAL_BSEC_OTP_Program+0x20>
        if (read_data != FuseData)
340049a4:	9b01      	ldr	r3, [sp, #4]
340049a6:	42bb      	cmp	r3, r7
340049a8:	d1e9      	bne.n	3400497e <HAL_BSEC_OTP_Program+0x86>
340049aa:	e7b6      	b.n	3400491a <HAL_BSEC_OTP_Program+0x22>
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
340049ac:	2304      	movs	r3, #4
340049ae:	e7b2      	b.n	34004916 <HAL_BSEC_OTP_Program+0x1e>
340049b0:	56009000 	.word	0x56009000
340049b4:	3401c189 	.word	0x3401c189

340049b8 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
340049b8:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
340049ba:	4604      	mov	r4, r0
340049bc:	b350      	cbz	r0, 34004a14 <HAL_CACHEAXI_Enable+0x5c>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
340049be:	6803      	ldr	r3, [r0, #0]
340049c0:	4a15      	ldr	r2, [pc, #84]	@ (34004a18 <HAL_CACHEAXI_Enable+0x60>)
340049c2:	4293      	cmp	r3, r2
340049c4:	d008      	beq.n	340049d8 <HAL_CACHEAXI_Enable+0x20>
340049c6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340049ca:	4293      	cmp	r3, r2
340049cc:	d004      	beq.n	340049d8 <HAL_CACHEAXI_Enable+0x20>
340049ce:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
340049d2:	4812      	ldr	r0, [pc, #72]	@ (34004a1c <HAL_CACHEAXI_Enable+0x64>)
340049d4:	f7fd fdae 	bl	34002534 <assert_failed>

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
340049d8:	6823      	ldr	r3, [r4, #0]
340049da:	685b      	ldr	r3, [r3, #4]
340049dc:	07d9      	lsls	r1, r3, #31
340049de:	d407      	bmi.n	340049f0 <HAL_CACHEAXI_Enable+0x38>
  }

  if (status == HAL_OK)
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
340049e0:	2000      	movs	r0, #0
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
340049e2:	6822      	ldr	r2, [r4, #0]
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
340049e4:	60a0      	str	r0, [r4, #8]
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
340049e6:	6813      	ldr	r3, [r2, #0]
340049e8:	f043 0301 	orr.w	r3, r3, #1
340049ec:	6013      	str	r3, [r2, #0]
  }

  return status;
}
340049ee:	bd38      	pop	{r3, r4, r5, pc}
    tickstart = HAL_GetTick();
340049f0:	f7ff ff0c 	bl	3400480c <HAL_GetTick>
340049f4:	4605      	mov	r5, r0
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
340049f6:	6823      	ldr	r3, [r4, #0]
340049f8:	685b      	ldr	r3, [r3, #4]
340049fa:	07db      	lsls	r3, r3, #31
340049fc:	d5f0      	bpl.n	340049e0 <HAL_CACHEAXI_Enable+0x28>
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
340049fe:	f7ff ff05 	bl	3400480c <HAL_GetTick>
34004a02:	1b40      	subs	r0, r0, r5
34004a04:	2801      	cmp	r0, #1
34004a06:	d9f6      	bls.n	340049f6 <HAL_CACHEAXI_Enable+0x3e>
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
34004a08:	6823      	ldr	r3, [r4, #0]
34004a0a:	685b      	ldr	r3, [r3, #4]
34004a0c:	07da      	lsls	r2, r3, #31
34004a0e:	d4f2      	bmi.n	340049f6 <HAL_CACHEAXI_Enable+0x3e>
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
34004a10:	2310      	movs	r3, #16
34004a12:	60a3      	str	r3, [r4, #8]
    return HAL_ERROR;
34004a14:	2001      	movs	r0, #1
34004a16:	e7ea      	b.n	340049ee <HAL_CACHEAXI_Enable+0x36>
34004a18:	580dfc00 	.word	0x580dfc00
34004a1c:	3401c1f8 	.word	0x3401c1f8

34004a20 <HAL_CACHEAXI_Init>:
{
34004a20:	b510      	push	{r4, lr}
  if (hcacheaxi == NULL)
34004a22:	4604      	mov	r4, r0
34004a24:	b1c8      	cbz	r0, 34004a5a <HAL_CACHEAXI_Init+0x3a>
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
34004a26:	6803      	ldr	r3, [r0, #0]
34004a28:	4a0d      	ldr	r2, [pc, #52]	@ (34004a60 <HAL_CACHEAXI_Init+0x40>)
34004a2a:	4293      	cmp	r3, r2
34004a2c:	d007      	beq.n	34004a3e <HAL_CACHEAXI_Init+0x1e>
34004a2e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004a32:	4293      	cmp	r3, r2
34004a34:	d003      	beq.n	34004a3e <HAL_CACHEAXI_Init+0x1e>
34004a36:	21bc      	movs	r1, #188	@ 0xbc
34004a38:	480a      	ldr	r0, [pc, #40]	@ (34004a64 <HAL_CACHEAXI_Init+0x44>)
34004a3a:	f7fd fd7b 	bl	34002534 <assert_failed>
  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34004a3e:	7923      	ldrb	r3, [r4, #4]
34004a40:	b913      	cbnz	r3, 34004a48 <HAL_CACHEAXI_Init+0x28>
    HAL_CACHEAXI_MspInit(hcacheaxi);
34004a42:	4620      	mov	r0, r4
34004a44:	f7fd fd5c 	bl	34002500 <HAL_CACHEAXI_MspInit>
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34004a48:	2300      	movs	r3, #0
34004a4a:	60a3      	str	r3, [r4, #8]
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34004a4c:	2301      	movs	r3, #1
34004a4e:	7123      	strb	r3, [r4, #4]
  status = HAL_CACHEAXI_Enable(hcacheaxi);
34004a50:	4620      	mov	r0, r4
}
34004a52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  status = HAL_CACHEAXI_Enable(hcacheaxi);
34004a56:	f7ff bfaf 	b.w	340049b8 <HAL_CACHEAXI_Enable>
}
34004a5a:	2001      	movs	r0, #1
34004a5c:	bd10      	pop	{r4, pc}
34004a5e:	bf00      	nop
34004a60:	580dfc00 	.word	0x580dfc00
34004a64:	3401c1f8 	.word	0x3401c1f8

34004a68 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
34004a68:	1ec3      	subs	r3, r0, #3
34004a6a:	2b04      	cmp	r3, #4
{
34004a6c:	b510      	push	{r4, lr}
34004a6e:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
34004a70:	d903      	bls.n	34004a7a <HAL_NVIC_SetPriorityGrouping+0x12>
34004a72:	21e6      	movs	r1, #230	@ 0xe6
34004a74:	4809      	ldr	r0, [pc, #36]	@ (34004a9c <HAL_NVIC_SetPriorityGrouping+0x34>)
34004a76:	f7fd fd5d 	bl	34002534 <assert_failed>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34004a7a:	4909      	ldr	r1, [pc, #36]	@ (34004aa0 <HAL_NVIC_SetPriorityGrouping+0x38>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34004a7c:	0223      	lsls	r3, r4, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34004a7e:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34004a80:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34004a84:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
34004a88:	0412      	lsls	r2, r2, #16
34004a8a:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34004a8c:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34004a8e:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34004a92:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
34004a96:	60cb      	str	r3, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
34004a98:	bd10      	pop	{r4, pc}
34004a9a:	bf00      	nop
34004a9c:	3401c26b 	.word	0x3401c26b
34004aa0:	e000ed00 	.word	0xe000ed00

34004aa4 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34004aa4:	f110 0f0c 	cmn.w	r0, #12
{
34004aa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34004aac:	4605      	mov	r5, r0
34004aae:	460c      	mov	r4, r1
34004ab0:	4617      	mov	r7, r2
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34004ab2:	db01      	blt.n	34004ab8 <HAL_NVIC_SetPriority+0x14>
34004ab4:	1d03      	adds	r3, r0, #4
34004ab6:	d103      	bne.n	34004ac0 <HAL_NVIC_SetPriority+0x1c>
34004ab8:	21ff      	movs	r1, #255	@ 0xff
34004aba:	4826      	ldr	r0, [pc, #152]	@ (34004b54 <HAL_NVIC_SetPriority+0xb0>)
34004abc:	f7fd fd3a 	bl	34002534 <assert_failed>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34004ac0:	4b25      	ldr	r3, [pc, #148]	@ (34004b58 <HAL_NVIC_SetPriority+0xb4>)
34004ac2:	68de      	ldr	r6, [r3, #12]
34004ac4:	f3c6 2602 	ubfx	r6, r6, #8, #3

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
34004ac8:	2e02      	cmp	r6, #2
34004aca:	d806      	bhi.n	34004ada <HAL_NVIC_SetPriority+0x36>
34004acc:	b157      	cbz	r7, 34004ae4 <HAL_NVIC_SetPriority+0x40>
34004ace:	f44f 7181 	mov.w	r1, #258	@ 0x102
34004ad2:	4820      	ldr	r0, [pc, #128]	@ (34004b54 <HAL_NVIC_SetPriority+0xb0>)
34004ad4:	f7fd fd2e 	bl	34002534 <assert_failed>
34004ad8:	e004      	b.n	34004ae4 <HAL_NVIC_SetPriority+0x40>
34004ada:	2301      	movs	r3, #1
34004adc:	1ef2      	subs	r2, r6, #3
34004ade:	4093      	lsls	r3, r2
34004ae0:	42bb      	cmp	r3, r7
34004ae2:	d9f4      	bls.n	34004ace <HAL_NVIC_SetPriority+0x2a>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));
34004ae4:	2c0f      	cmp	r4, #15
34004ae6:	f1c6 0807 	rsb	r8, r6, #7
34004aea:	d804      	bhi.n	34004af6 <HAL_NVIC_SetPriority+0x52>
34004aec:	2301      	movs	r3, #1
34004aee:	fa03 f308 	lsl.w	r3, r3, r8
34004af2:	42a3      	cmp	r3, r4
34004af4:	d804      	bhi.n	34004b00 <HAL_NVIC_SetPriority+0x5c>
34004af6:	f240 1103 	movw	r1, #259	@ 0x103
34004afa:	4816      	ldr	r0, [pc, #88]	@ (34004b54 <HAL_NVIC_SetPriority+0xb0>)
34004afc:	f7fd fd1a 	bl	34002534 <assert_failed>
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34004b00:	f1b8 0f04 	cmp.w	r8, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34004b04:	f106 0304 	add.w	r3, r6, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34004b08:	bf28      	it	cs
34004b0a:	f04f 0804 	movcs.w	r8, #4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004b0e:	f04f 32ff 	mov.w	r2, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34004b12:	2b06      	cmp	r3, #6
34004b14:	f1a6 0603 	sub.w	r6, r6, #3
34004b18:	bf98      	it	ls
34004b1a:	2600      	movls	r6, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004b1c:	fa02 f808 	lsl.w	r8, r2, r8
34004b20:	ea24 0308 	bic.w	r3, r4, r8
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34004b24:	40b2      	lsls	r2, r6
34004b26:	ea27 0702 	bic.w	r7, r7, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004b2a:	40b3      	lsls	r3, r6
  if ((int32_t)(IRQn) >= 0)
34004b2c:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004b2e:	ea43 0307 	orr.w	r3, r3, r7
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b32:	bfac      	ite	ge
34004b34:	f105 4560 	addge.w	r5, r5, #3758096384	@ 0xe0000000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b38:	4a08      	ldrlt	r2, [pc, #32]	@ (34004b5c <HAL_NVIC_SetPriority+0xb8>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b3a:	ea4f 1303 	mov.w	r3, r3, lsl #4
34004b3e:	b2db      	uxtb	r3, r3
34004b40:	bfab      	itete	ge
34004b42:	f505 4561 	addge.w	r5, r5, #57600	@ 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b46:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b4a:	f885 3300 	strbge.w	r3, [r5, #768]	@ 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b4e:	5553      	strblt	r3, [r2, r5]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
34004b50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34004b54:	3401c26b 	.word	0x3401c26b
34004b58:	e000ed00 	.word	0xe000ed00
34004b5c:	e000ed14 	.word	0xe000ed14

34004b60 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
34004b60:	2800      	cmp	r0, #0
34004b62:	db08      	blt.n	34004b76 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34004b64:	2301      	movs	r3, #1
34004b66:	0941      	lsrs	r1, r0, #5
34004b68:	4a05      	ldr	r2, [pc, #20]	@ (34004b80 <HAL_NVIC_EnableIRQ+0x20>)
34004b6a:	f000 001f 	and.w	r0, r0, #31
34004b6e:	4083      	lsls	r3, r0
34004b70:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
34004b74:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
34004b76:	f240 1115 	movw	r1, #277	@ 0x115
34004b7a:	4802      	ldr	r0, [pc, #8]	@ (34004b84 <HAL_NVIC_EnableIRQ+0x24>)
34004b7c:	f7fd bcda 	b.w	34002534 <assert_failed>
34004b80:	e000e100 	.word	0xe000e100
34004b84:	3401c26b 	.word	0x3401c26b

34004b88 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34004b88:	3801      	subs	r0, #1
34004b8a:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
34004b8e:	d20b      	bcs.n	34004ba8 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34004b90:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b94:	21f0      	movs	r1, #240	@ 0xf0
34004b96:	4a05      	ldr	r2, [pc, #20]	@ (34004bac <HAL_SYSTICK_Config+0x24>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34004b98:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004b9a:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34004b9e:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34004ba0:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34004ba2:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34004ba4:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34004ba6:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
34004ba8:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
34004baa:	4770      	bx	lr
34004bac:	e000ed00 	.word	0xe000ed00

34004bb0 <DCMIPP_CSI_SetVCConfig>:
  * @param  hdcmipp         Pointer to DCMIPP handle
  * @param  Pipe            Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  VirtualChannel  Specifies the virtual channel, can be a value from @ref DCMIPP_Virtual_Channel
  */
static HAL_StatusTypeDef DCMIPP_CSI_SetVCConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel)
{
34004bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34004bb2:	4614      	mov	r4, r2
  uint32_t tickstart;

  /* Set Virtual Channel ID for the selected Pipe */
  if (Pipe == DCMIPP_PIPE0)
  {
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34004bb4:	6803      	ldr	r3, [r0, #0]
  if (Pipe == DCMIPP_PIPE0)
34004bb6:	bb71      	cbnz	r1, 34004c16 <DCMIPP_CSI_SetVCConfig+0x66>
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34004bb8:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34004bbc:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34004bc0:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34004bc4:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
    }
  }

  /* Enable the selected virtual channel */
  switch (VirtualChannel)
34004bc8:	4b23      	ldr	r3, [pc, #140]	@ (34004c58 <DCMIPP_CSI_SetVCConfig+0xa8>)
34004bca:	2c02      	cmp	r4, #2
    case DCMIPP_VIRTUAL_CHANNEL3:
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
      break;
    default:
      /* DCMIPP_VIRTUAL_CHANNEL0: */
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34004bcc:	681a      	ldr	r2, [r3, #0]
  switch (VirtualChannel)
34004bce:	d038      	beq.n	34004c42 <DCMIPP_CSI_SetVCConfig+0x92>
34004bd0:	2c03      	cmp	r4, #3
34004bd2:	d039      	beq.n	34004c48 <DCMIPP_CSI_SetVCConfig+0x98>
34004bd4:	2c01      	cmp	r4, #1
34004bd6:	d13a      	bne.n	34004c4e <DCMIPP_CSI_SetVCConfig+0x9e>
      SET_BIT(csi_instance->CR, CSI_CR_VC1START);
34004bd8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34004bdc:	601a      	str	r2, [r3, #0]
      break;
  }

  /* wait for the selected virtual channel active state */
  tickstart = HAL_GetTick();
34004bde:	f7ff fe15 	bl	3400480c <HAL_GetTick>
  {
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
    {
      return HAL_ERROR;
    }
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34004be2:	f44f 3600 	mov.w	r6, #131072	@ 0x20000
  tickstart = HAL_GetTick();
34004be6:	4607      	mov	r7, r0
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34004be8:	4d1b      	ldr	r5, [pc, #108]	@ (34004c58 <DCMIPP_CSI_SetVCConfig+0xa8>)
34004bea:	40a6      	lsls	r6, r4
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
34004bec:	f7ff fe0e 	bl	3400480c <HAL_GetTick>
34004bf0:	1bc0      	subs	r0, r0, r7
34004bf2:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34004bf6:	d82d      	bhi.n	34004c54 <DCMIPP_CSI_SetVCConfig+0xa4>
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34004bf8:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
34004bfc:	ea36 0303 	bics.w	r3, r6, r3
34004c00:	d1f4      	bne.n	34004bec <DCMIPP_CSI_SetVCConfig+0x3c>

  /* Enable the SOF and EOF interrupts for the selected virtual channel */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34004c02:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
                             (DCMIPP_CSI_IT_SOF0 << VirtualChannel));
  return HAL_OK;
34004c06:	2000      	movs	r0, #0
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34004c08:	f8d5 2080 	ldr.w	r2, [r5, #128]	@ 0x80
34004c0c:	40a3      	lsls	r3, r4
34004c0e:	4313      	orrs	r3, r2
34004c10:	f8c5 3080 	str.w	r3, [r5, #128]	@ 0x80
}
34004c14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Pipe == DCMIPP_PIPE1)
34004c16:	2901      	cmp	r1, #1
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
34004c18:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  else if (Pipe == DCMIPP_PIPE1)
34004c1c:	d106      	bne.n	34004c2c <DCMIPP_CSI_SetVCConfig+0x7c>
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
34004c1e:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34004c22:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34004c26:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
34004c2a:	e7cd      	b.n	34004bc8 <DCMIPP_CSI_SetVCConfig+0x18>
    if ((hdcmipp->Instance->P1FSCR & DCMIPP_P1FSCR_PIPEDIFF) == DCMIPP_P1FSCR_PIPEDIFF)
34004c2c:	0352      	lsls	r2, r2, #13
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
34004c2e:	bf41      	itttt	mi
34004c30:	f8d3 2c04 	ldrmi.w	r2, [r3, #3076]	@ 0xc04
34004c34:	f422 12c0 	bicmi.w	r2, r2, #1572864	@ 0x180000
34004c38:	ea42 42c4 	orrmi.w	r2, r2, r4, lsl #19
34004c3c:	f8c3 2c04 	strmi.w	r2, [r3, #3076]	@ 0xc04
34004c40:	e7c2      	b.n	34004bc8 <DCMIPP_CSI_SetVCConfig+0x18>
      SET_BIT(csi_instance->CR, CSI_CR_VC2START);
34004c42:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
34004c46:	e7c9      	b.n	34004bdc <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
34004c48:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004c4c:	e7c6      	b.n	34004bdc <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34004c4e:	f042 0204 	orr.w	r2, r2, #4
34004c52:	e7c3      	b.n	34004bdc <DCMIPP_CSI_SetVCConfig+0x2c>
      return HAL_ERROR;
34004c54:	2001      	movs	r0, #1
34004c56:	e7dd      	b.n	34004c14 <DCMIPP_CSI_SetVCConfig+0x64>
34004c58:	58006000 	.word	0x58006000

34004c5c <DCMIPP_SetConfig.part.0>:
  else if (Pipe == DCMIPP_PIPE1)
34004c5c:	2901      	cmp	r1, #1
static void DCMIPP_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t DstAddress, uint32_t CaptureMode)
34004c5e:	b530      	push	{r4, r5, lr}
34004c60:	f04f 0502 	mov.w	r5, #2
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
34004c64:	6804      	ldr	r4, [r0, #0]
  else if (Pipe == DCMIPP_PIPE1)
34004c66:	d110      	bne.n	34004c8a <DCMIPP_SetConfig.part.0+0x2e>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004c68:	7185      	strb	r5, [r0, #6]
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
34004c6a:	f8d4 1900 	ldr.w	r1, [r4, #2304]	@ 0x900
34004c6e:	430b      	orrs	r3, r1
34004c70:	f8c4 3900 	str.w	r3, [r4, #2304]	@ 0x900
    WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
34004c74:	f8c4 29c4 	str.w	r2, [r4, #2500]	@ 0x9c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME  | DCMIPP_IT_PIPE1_OVR | DCMIPP_IT_PIPE1_VSYNC |
34004c78:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
34004c7c:	f443 0306 	orr.w	r3, r3, #8781824	@ 0x860000
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
34004c80:	f043 0320 	orr.w	r3, r3, #32
34004c84:	f8c4 33f0 	str.w	r3, [r4, #1008]	@ 0x3f0
}
34004c88:	bd30      	pop	{r4, r5, pc}
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004c8a:	4408      	add	r0, r1
34004c8c:	7145      	strb	r5, [r0, #5]
    hdcmipp->Instance->P2FCTCR |= CaptureMode;
34004c8e:	f8d4 1d00 	ldr.w	r1, [r4, #3328]	@ 0xd00
34004c92:	430b      	orrs	r3, r1
34004c94:	f8c4 3d00 	str.w	r3, [r4, #3328]	@ 0xd00
    WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
34004c98:	f8c4 2dc4 	str.w	r2, [r4, #3524]	@ 0xdc4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
34004c9c:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
34004ca0:	f043 4306 	orr.w	r3, r3, #2248146944	@ 0x86000000
34004ca4:	e7ec      	b.n	34004c80 <DCMIPP_SetConfig.part.0+0x24>

34004ca6 <DCMIPP_SetConfig>:
{
34004ca6:	b470      	push	{r4, r5, r6}
34004ca8:	4615      	mov	r5, r2
34004caa:	461e      	mov	r6, r3
  if (Pipe == DCMIPP_PIPE0)
34004cac:	b999      	cbnz	r1, 34004cd6 <DCMIPP_SetConfig+0x30>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004cae:	2302      	movs	r3, #2
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34004cb0:	6801      	ldr	r1, [r0, #0]
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004cb2:	7143      	strb	r3, [r0, #5]
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34004cb4:	f8d1 2500 	ldr.w	r2, [r1, #1280]	@ 0x500
34004cb8:	4332      	orrs	r2, r6
34004cba:	f8c1 2500 	str.w	r2, [r1, #1280]	@ 0x500
    WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
34004cbe:	f8c1 55c4 	str.w	r5, [r1, #1476]	@ 0x5c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34004cc2:	f8d1 33f0 	ldr.w	r3, [r1, #1008]	@ 0x3f0
}
34004cc6:	bc70      	pop	{r4, r5, r6}
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34004cc8:	f443 4306 	orr.w	r3, r3, #34304	@ 0x8600
34004ccc:	f043 0320 	orr.w	r3, r3, #32
34004cd0:	f8c1 33f0 	str.w	r3, [r1, #1008]	@ 0x3f0
}
34004cd4:	4770      	bx	lr
34004cd6:	bc70      	pop	{r4, r5, r6}
34004cd8:	f7ff bfc0 	b.w	34004c5c <DCMIPP_SetConfig.part.0>

34004cdc <DCMIPP_EnableCapture.part.0>:
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004cdc:	2302      	movs	r3, #2
34004cde:	7183      	strb	r3, [r0, #6]
    SET_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEN);
34004ce0:	6803      	ldr	r3, [r0, #0]
34004ce2:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34004ce6:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34004cea:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
    SET_BIT(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_CPTREQ);
34004cee:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34004cf2:	f042 0208 	orr.w	r2, r2, #8
34004cf6:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
34004cfa:	4770      	bx	lr

34004cfc <DCMIPP_EnableCapture>:
  if (Pipe == DCMIPP_PIPE0)
34004cfc:	b969      	cbnz	r1, 34004d1a <DCMIPP_EnableCapture+0x1e>
    SET_BIT(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_PIPEN);
34004cfe:	6803      	ldr	r3, [r0, #0]
34004d00:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34004d04:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34004d08:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
    SET_BIT(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
34004d0c:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34004d10:	f042 0208 	orr.w	r2, r2, #8
34004d14:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
34004d18:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE1)
34004d1a:	2901      	cmp	r1, #1
34004d1c:	d101      	bne.n	34004d22 <DCMIPP_EnableCapture+0x26>
34004d1e:	f7ff bfdd 	b.w	34004cdc <DCMIPP_EnableCapture.part.0>
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);
34004d22:	6803      	ldr	r3, [r0, #0]
34004d24:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
34004d28:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34004d2c:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
34004d30:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34004d34:	f042 0208 	orr.w	r2, r2, #8
34004d38:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
}
34004d3c:	4770      	bx	lr
	...

34004d40 <DCMIPP_CSI_WritePHYReg.constprop.0>:
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004d40:	4b18      	ldr	r3, [pc, #96]	@ (34004da4 <DCMIPP_CSI_WritePHYReg.constprop.0+0x64>)
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
34004d42:	b510      	push	{r4, lr}
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004d44:	695a      	ldr	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
34004d46:	b2c9      	uxtb	r1, r1
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004d48:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
34004d4c:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004d4e:	691a      	ldr	r2, [r3, #16]
34004d50:	f042 0201 	orr.w	r2, r2, #1
34004d54:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004d56:	695a      	ldr	r2, [r3, #20]
34004d58:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
34004d5c:	615a      	str	r2, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
34004d5e:	2200      	movs	r2, #0
34004d60:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
34004d62:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
34004d64:	695c      	ldr	r4, [r3, #20]
34004d66:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004d68:	691c      	ldr	r4, [r3, #16]
34004d6a:	f044 0401 	orr.w	r4, r4, #1
34004d6e:	611c      	str	r4, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
34004d70:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004d72:	695c      	ldr	r4, [r3, #20]
34004d74:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
34004d78:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004d7a:	691c      	ldr	r4, [r3, #16]
34004d7c:	f044 0401 	orr.w	r4, r4, #1
34004d80:	611c      	str	r4, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
34004d82:	695c      	ldr	r4, [r3, #20]
34004d84:	4304      	orrs	r4, r0
34004d86:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
34004d8a:	615c      	str	r4, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
34004d8c:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
34004d8e:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
34004d90:	6958      	ldr	r0, [r3, #20]
34004d92:	4301      	orrs	r1, r0
34004d94:	6159      	str	r1, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004d96:	6919      	ldr	r1, [r3, #16]
34004d98:	f041 0101 	orr.w	r1, r1, #1
34004d9c:	6119      	str	r1, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
34004d9e:	611a      	str	r2, [r3, #16]
}
34004da0:	bd10      	pop	{r4, pc}
34004da2:	bf00      	nop
34004da4:	58007000 	.word	0x58007000

34004da8 <HAL_DCMIPP_Init>:
{
34004da8:	b510      	push	{r4, lr}
  if (hdcmipp == NULL)
34004daa:	4604      	mov	r4, r0
34004dac:	b1d8      	cbz	r0, 34004de6 <HAL_DCMIPP_Init+0x3e>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34004dae:	6803      	ldr	r3, [r0, #0]
34004db0:	4a0e      	ldr	r2, [pc, #56]	@ (34004dec <HAL_DCMIPP_Init+0x44>)
34004db2:	4293      	cmp	r3, r2
34004db4:	d008      	beq.n	34004dc8 <HAL_DCMIPP_Init+0x20>
34004db6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004dba:	4293      	cmp	r3, r2
34004dbc:	d004      	beq.n	34004dc8 <HAL_DCMIPP_Init+0x20>
34004dbe:	f44f 71a7 	mov.w	r1, #334	@ 0x14e
34004dc2:	480b      	ldr	r0, [pc, #44]	@ (34004df0 <HAL_DCMIPP_Init+0x48>)
34004dc4:	f7fd fbb6 	bl	34002534 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
34004dc8:	7923      	ldrb	r3, [r4, #4]
34004dca:	b913      	cbnz	r3, 34004dd2 <HAL_DCMIPP_Init+0x2a>
    HAL_DCMIPP_MspInit(hdcmipp);
34004dcc:	4620      	mov	r0, r4
34004dce:	f00b ff17 	bl	34010c00 <HAL_DCMIPP_MspInit>
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34004dd2:	2303      	movs	r3, #3
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34004dd4:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34004dd6:	7123      	strb	r3, [r4, #4]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34004dd8:	2301      	movs	r3, #1
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34004dda:	7160      	strb	r0, [r4, #5]
34004ddc:	71a0      	strb	r0, [r4, #6]
34004dde:	71e0      	strb	r0, [r4, #7]
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
34004de0:	60a0      	str	r0, [r4, #8]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34004de2:	7123      	strb	r3, [r4, #4]
}
34004de4:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34004de6:	2001      	movs	r0, #1
34004de8:	e7fc      	b.n	34004de4 <HAL_DCMIPP_Init+0x3c>
34004dea:	bf00      	nop
34004dec:	58002000 	.word	0x58002000
34004df0:	3401c2dc 	.word	0x3401c2dc

34004df4 <HAL_DCMIPP_CSI_SetConfig>:
{
34004df4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34004df8:	4605      	mov	r5, r0
34004dfa:	b0fe      	sub	sp, #504	@ 0x1f8
34004dfc:	460c      	mov	r4, r1
  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
34004dfe:	f44f 72fc 	mov.w	r2, #504	@ 0x1f8
34004e02:	4668      	mov	r0, sp
34004e04:	4954      	ldr	r1, [pc, #336]	@ (34004f58 <HAL_DCMIPP_CSI_SetConfig+0x164>)
34004e06:	f014 f950 	bl	340190aa <memcpy>
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34004e0a:	b91d      	cbnz	r5, 34004e14 <HAL_DCMIPP_CSI_SetConfig+0x20>
    return HAL_ERROR;
34004e0c:	2001      	movs	r0, #1
}
34004e0e:	b07e      	add	sp, #504	@ 0x1f8
34004e10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34004e14:	2c00      	cmp	r4, #0
34004e16:	d0f9      	beq.n	34004e0c <HAL_DCMIPP_CSI_SetConfig+0x18>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34004e18:	682b      	ldr	r3, [r5, #0]
34004e1a:	4a50      	ldr	r2, [pc, #320]	@ (34004f5c <HAL_DCMIPP_CSI_SetConfig+0x168>)
34004e1c:	4293      	cmp	r3, r2
34004e1e:	d008      	beq.n	34004e32 <HAL_DCMIPP_CSI_SetConfig+0x3e>
34004e20:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004e24:	4293      	cmp	r3, r2
34004e26:	d004      	beq.n	34004e32 <HAL_DCMIPP_CSI_SetConfig+0x3e>
34004e28:	f240 218b 	movw	r1, #651	@ 0x28b
34004e2c:	484c      	ldr	r0, [pc, #304]	@ (34004f60 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004e2e:	f7fd fb81 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
34004e32:	6823      	ldr	r3, [r4, #0]
34004e34:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34004e38:	d007      	beq.n	34004e4a <HAL_DCMIPP_CSI_SetConfig+0x56>
34004e3a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34004e3e:	d004      	beq.n	34004e4a <HAL_DCMIPP_CSI_SetConfig+0x56>
34004e40:	f44f 7123 	mov.w	r1, #652	@ 0x28c
34004e44:	4846      	ldr	r0, [pc, #280]	@ (34004f60 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004e46:	f7fd fb75 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
34004e4a:	6863      	ldr	r3, [r4, #4]
34004e4c:	3b01      	subs	r3, #1
34004e4e:	2b01      	cmp	r3, #1
34004e50:	d904      	bls.n	34004e5c <HAL_DCMIPP_CSI_SetConfig+0x68>
34004e52:	f240 218d 	movw	r1, #653	@ 0x28d
34004e56:	4842      	ldr	r0, [pc, #264]	@ (34004f60 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004e58:	f7fd fb6c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));
34004e5c:	68a3      	ldr	r3, [r4, #8]
34004e5e:	2b3e      	cmp	r3, #62	@ 0x3e
34004e60:	d904      	bls.n	34004e6c <HAL_DCMIPP_CSI_SetConfig+0x78>
34004e62:	f240 218e 	movw	r1, #654	@ 0x28e
34004e66:	483e      	ldr	r0, [pc, #248]	@ (34004f60 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004e68:	f7fd fb64 	bl	34002534 <assert_failed>
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
34004e6c:	4b3d      	ldr	r3, [pc, #244]	@ (34004f64 <HAL_DCMIPP_CSI_SetConfig+0x170>)
34004e6e:	681a      	ldr	r2, [r3, #0]
34004e70:	f022 0201 	bic.w	r2, r2, #1
34004e74:	601a      	str	r2, [r3, #0]
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34004e76:	6861      	ldr	r1, [r4, #4]
34004e78:	2901      	cmp	r1, #1
34004e7a:	d11a      	bne.n	34004eb2 <HAL_DCMIPP_CSI_SetConfig+0xbe>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
34004e7c:	6822      	ldr	r2, [r4, #0]
34004e7e:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34004e82:	671a      	str	r2, [r3, #112]	@ 0x70
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
34004e84:	681a      	ldr	r2, [r3, #0]
34004e86:	f042 0201 	orr.w	r2, r2, #1
34004e8a:	601a      	str	r2, [r3, #0]
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
34004e8c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34004e90:	f042 42b0 	orr.w	r2, r2, #1476395008	@ 0x58000000
34004e94:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
34004e98:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34004e9c:	6822      	ldr	r2, [r4, #0]
34004e9e:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34004ea2:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34004ea6:	d154      	bne.n	34004f52 <HAL_DCMIPP_CSI_SetConfig+0x15e>
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34004ea8:	2901      	cmp	r1, #1
34004eaa:	d108      	bne.n	34004ebe <HAL_DCMIPP_CSI_SetConfig+0xca>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004eac:	f042 021f 	orr.w	r2, r2, #31
34004eb0:	e007      	b.n	34004ec2 <HAL_DCMIPP_CSI_SetConfig+0xce>
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
34004eb2:	2902      	cmp	r1, #2
34004eb4:	d1aa      	bne.n	34004e0c <HAL_DCMIPP_CSI_SetConfig+0x18>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34004eb6:	6822      	ldr	r2, [r4, #0]
34004eb8:	f442 1290 	orr.w	r2, r2, #1179648	@ 0x120000
34004ebc:	e7e1      	b.n	34004e82 <HAL_DCMIPP_CSI_SetConfig+0x8e>
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004ebe:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
  CLEAR_REG(csi_instance-> PCR);
34004ec2:	2600      	movs	r6, #0
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34004ec4:	4d28      	ldr	r5, [pc, #160]	@ (34004f68 <HAL_DCMIPP_CSI_SetConfig+0x174>)
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004ec6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34004eca:	682b      	ldr	r3, [r5, #0]
34004ecc:	4f25      	ldr	r7, [pc, #148]	@ (34004f64 <HAL_DCMIPP_CSI_SetConfig+0x170>)
34004ece:	f023 0302 	bic.w	r3, r3, #2
34004ed2:	602b      	str	r3, [r5, #0]
  CLEAR_REG(csi_instance-> PCR);
34004ed4:	607e      	str	r6, [r7, #4]
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34004ed6:	692b      	ldr	r3, [r5, #16]
  HAL_Delay(1);
34004ed8:	2001      	movs	r0, #1
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34004eda:	f043 0301 	orr.w	r3, r3, #1
34004ede:	612b      	str	r3, [r5, #16]
  HAL_Delay(1);
34004ee0:	f7ff fc9a 	bl	34004818 <HAL_Delay>
  CLEAR_REG(csi_instance->PTCR0);
34004ee4:	612e      	str	r6, [r5, #16]
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004ee6:	f8d4 8008 	ldr.w	r8, [r4, #8]
34004eea:	68ab      	ldr	r3, [r5, #8]
34004eec:	f85d 2038 	ldr.w	r2, [sp, r8, lsl #3]
34004ef0:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
34004ef4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34004ef8:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34004efc:	60ab      	str	r3, [r5, #8]
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34004efe:	2138      	movs	r1, #56	@ 0x38
34004f00:	2008      	movs	r0, #8
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004f02:	0216      	lsls	r6, r2, #8
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34004f04:	f7ff ff1c 	bl	34004d40 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
34004f08:	2111      	movs	r1, #17
34004f0a:	20e4      	movs	r0, #228	@ 0xe4
34004f0c:	f7ff ff18 	bl	34004d40 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34004f10:	eb0d 03c8 	add.w	r3, sp, r8, lsl #3
34004f14:	f8d3 8004 	ldr.w	r8, [r3, #4]
34004f18:	20e3      	movs	r0, #227	@ 0xe3
34004f1a:	ea4f 2118 	mov.w	r1, r8, lsr #8
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004f1e:	f446 3680 	orr.w	r6, r6, #65536	@ 0x10000
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34004f22:	f7ff ff0d 	bl	34004d40 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004f26:	f046 0628 	orr.w	r6, r6, #40	@ 0x28
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
34004f2a:	20e3      	movs	r0, #227	@ 0xe3
34004f2c:	fa5f f188 	uxtb.w	r1, r8
34004f30:	f7ff ff06 	bl	34004d40 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004f34:	60ae      	str	r6, [r5, #8]
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34004f36:	6823      	ldr	r3, [r4, #0]
  CLEAR_REG(csi_instance->PMCR);
34004f38:	2000      	movs	r0, #0
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34004f3a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34004f3e:	bf0c      	ite	eq
34004f40:	2307      	moveq	r3, #7
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34004f42:	230f      	movne	r3, #15
34004f44:	607b      	str	r3, [r7, #4]
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34004f46:	682b      	ldr	r3, [r5, #0]
34004f48:	f043 0302 	orr.w	r3, r3, #2
34004f4c:	602b      	str	r3, [r5, #0]
  CLEAR_REG(csi_instance->PMCR);
34004f4e:	6068      	str	r0, [r5, #4]
  return HAL_OK;
34004f50:	e75d      	b.n	34004e0e <HAL_DCMIPP_CSI_SetConfig+0x1a>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004f52:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
34004f56:	e7a9      	b.n	34004eac <HAL_DCMIPP_CSI_SetConfig+0xb8>
34004f58:	3401bb40 	.word	0x3401bb40
34004f5c:	58002000 	.word	0x58002000
34004f60:	3401c2dc 	.word	0x3401c2dc
34004f64:	58006000 	.word	0x58006000
34004f68:	58007000 	.word	0x58007000

34004f6c <HAL_DCMIPP_CSI_PIPE_SetConfig>:
{
34004f6c:	b570      	push	{r4, r5, r6, lr}
34004f6e:	460d      	mov	r5, r1
34004f70:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34004f72:	4606      	mov	r6, r0
34004f74:	b908      	cbnz	r0, 34004f7a <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe>
    return HAL_ERROR;
34004f76:	2001      	movs	r0, #1
}
34004f78:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34004f7a:	2a00      	cmp	r2, #0
34004f7c:	d0fb      	beq.n	34004f76 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34004f7e:	6803      	ldr	r3, [r0, #0]
34004f80:	4a50      	ldr	r2, [pc, #320]	@ (340050c4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x158>)
34004f82:	4293      	cmp	r3, r2
34004f84:	d008      	beq.n	34004f98 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2c>
34004f86:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004f8a:	4293      	cmp	r3, r2
34004f8c:	d004      	beq.n	34004f98 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2c>
34004f8e:	f44f 7144 	mov.w	r1, #784	@ 0x310
34004f92:	484d      	ldr	r0, [pc, #308]	@ (340050c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34004f94:	f7fd face 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34004f98:	2d02      	cmp	r5, #2
34004f9a:	d904      	bls.n	34004fa6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x3a>
34004f9c:	f240 3111 	movw	r1, #785	@ 0x311
34004fa0:	4849      	ldr	r0, [pc, #292]	@ (340050c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34004fa2:	f7fd fac7 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
34004fa6:	6823      	ldr	r3, [r4, #0]
34004fa8:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34004fac:	d004      	beq.n	34004fb8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x4c>
34004fae:	f240 3112 	movw	r1, #786	@ 0x312
34004fb2:	4845      	ldr	r0, [pc, #276]	@ (340050c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34004fb4:	f7fd fabe 	bl	34002534 <assert_failed>
  if (Pipe != DCMIPP_PIPE2)
34004fb8:	2d02      	cmp	r5, #2
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
34004fba:	6823      	ldr	r3, [r4, #0]
  if (Pipe != DCMIPP_PIPE2)
34004fbc:	d01c      	beq.n	34004ff8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
34004fbe:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34004fc2:	d004      	beq.n	34004fce <HAL_DCMIPP_CSI_PIPE_SetConfig+0x62>
34004fc4:	f240 3116 	movw	r1, #790	@ 0x316
34004fc8:	483f      	ldr	r0, [pc, #252]	@ (340050c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34004fca:	f7fd fab3 	bl	34002534 <assert_failed>
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34004fce:	6823      	ldr	r3, [r4, #0]
34004fd0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34004fd4:	d002      	beq.n	34004fdc <HAL_DCMIPP_CSI_PIPE_SetConfig+0x70>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34004fd6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34004fda:	d10d      	bne.n	34004ff8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
      assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDB));
34004fdc:	68a3      	ldr	r3, [r4, #8]
34004fde:	3b18      	subs	r3, #24
34004fe0:	2b15      	cmp	r3, #21
34004fe2:	d804      	bhi.n	34004fee <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
34004fe4:	4a39      	ldr	r2, [pc, #228]	@ (340050cc <HAL_DCMIPP_CSI_PIPE_SetConfig+0x160>)
34004fe6:	fa22 f303 	lsr.w	r3, r2, r3
34004fea:	07da      	lsls	r2, r3, #31
34004fec:	d404      	bmi.n	34004ff8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
34004fee:	f240 311b 	movw	r1, #795	@ 0x31b
34004ff2:	4835      	ldr	r0, [pc, #212]	@ (340050c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34004ff4:	f7fd fa9e 	bl	34002534 <assert_failed>
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34004ff8:	6823      	ldr	r3, [r4, #0]
34004ffa:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34004ffe:	d00d      	beq.n	3400501c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xb0>
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
34005000:	6863      	ldr	r3, [r4, #4]
34005002:	3b18      	subs	r3, #24
34005004:	2b15      	cmp	r3, #21
34005006:	d804      	bhi.n	34005012 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa6>
34005008:	4a30      	ldr	r2, [pc, #192]	@ (340050cc <HAL_DCMIPP_CSI_PIPE_SetConfig+0x160>)
3400500a:	fa22 f303 	lsr.w	r3, r2, r3
3400500e:	07db      	lsls	r3, r3, #31
34005010:	d404      	bmi.n	3400501c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xb0>
34005012:	f240 3121 	movw	r1, #801	@ 0x321
34005016:	482c      	ldr	r0, [pc, #176]	@ (340050c8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005018:	f7fd fa8c 	bl	34002534 <assert_failed>
  state = hdcmipp->State;
3400501c:	7933      	ldrb	r3, [r6, #4]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
3400501e:	3b01      	subs	r3, #1
34005020:	2b01      	cmp	r3, #1
34005022:	d82e      	bhi.n	34005082 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x116>
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34005024:	6822      	ldr	r2, [r4, #0]
34005026:	f5b2 3f40 	cmp.w	r2, #196608	@ 0x30000
3400502a:	d045      	beq.n	340050b8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x14c>
3400502c:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
34005030:	d12b      	bne.n	3400508a <HAL_DCMIPP_CSI_PIPE_SetConfig+0x11e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34005032:	2d00      	cmp	r5, #0
34005034:	d19f      	bne.n	34004f76 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
34005036:	4613      	mov	r3, r2
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34005038:	6861      	ldr	r1, [r4, #4]
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
3400503a:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
3400503e:	ea43 0301 	orr.w	r3, r3, r1
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34005042:	6831      	ldr	r1, [r6, #0]
34005044:	d002      	beq.n	3400504c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe0>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34005046:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
3400504a:	d104      	bne.n	34005056 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xea>
      if (Pipe != DCMIPP_PIPE2)
3400504c:	2d02      	cmp	r5, #2
3400504e:	d02b      	beq.n	340050a8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
34005050:	68a2      	ldr	r2, [r4, #8]
34005052:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    if (Pipe == DCMIPP_PIPE0)
34005056:	b9ed      	cbnz	r5, 34005094 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
34005058:	6831      	ldr	r1, [r6, #0]
3400505a:	4a1d      	ldr	r2, [pc, #116]	@ (340050d0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x164>)
3400505c:	f8d1 0404 	ldr.w	r0, [r1, #1028]	@ 0x404
34005060:	4002      	ands	r2, r0
34005062:	431a      	orrs	r2, r3
34005064:	f8c1 2404 	str.w	r2, [r1, #1028]	@ 0x404
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
34005068:	6833      	ldr	r3, [r6, #0]
3400506a:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400506e:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34005072:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34005076:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
3400507a:	f042 0201 	orr.w	r2, r2, #1
3400507e:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34005082:	2302      	movs	r3, #2
  return HAL_OK;
34005084:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34005086:	7133      	strb	r3, [r6, #4]
  return HAL_OK;
34005088:	e776      	b.n	34004f78 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc>
  uint32_t pxfscr_reg = 0;
3400508a:	2d02      	cmp	r5, #2
3400508c:	bf14      	ite	ne
3400508e:	4613      	movne	r3, r2
34005090:	2300      	moveq	r3, #0
34005092:	e7d1      	b.n	34005038 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xcc>
    else if (Pipe == DCMIPP_PIPE1)
34005094:	2d01      	cmp	r5, #1
34005096:	d107      	bne.n	340050a8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
34005098:	f8d1 0804 	ldr.w	r0, [r1, #2052]	@ 0x804
3400509c:	4a0c      	ldr	r2, [pc, #48]	@ (340050d0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x164>)
3400509e:	4002      	ands	r2, r0
340050a0:	431a      	orrs	r2, r3
340050a2:	f8c1 2804 	str.w	r2, [r1, #2052]	@ 0x804
340050a6:	e7df      	b.n	34005068 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xfc>
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
340050a8:	f8d1 2c04 	ldr.w	r2, [r1, #3076]	@ 0xc04
340050ac:	f022 023f 	bic.w	r2, r2, #63	@ 0x3f
340050b0:	4313      	orrs	r3, r2
340050b2:	f8c1 3c04 	str.w	r3, [r1, #3076]	@ 0xc04
340050b6:	e7d7      	b.n	34005068 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xfc>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
340050b8:	2d00      	cmp	r5, #0
340050ba:	f47f af5c 	bne.w	34004f76 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
340050be:	4613      	mov	r3, r2
340050c0:	e7ca      	b.n	34005058 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xec>
340050c2:	bf00      	nop
340050c4:	58002000 	.word	0x58002000
340050c8:	3401c2dc 	.word	0x3401c2dc
340050cc:	003c1fc3 	.word	0x003c1fc3
340050d0:	fffcc0c0 	.word	0xfffcc0c0

340050d4 <HAL_DCMIPP_CSI_SetVCConfig>:
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
340050d4:	2903      	cmp	r1, #3
{
340050d6:	b570      	push	{r4, r5, r6, lr}
340050d8:	4606      	mov	r6, r0
340050da:	460d      	mov	r5, r1
340050dc:	4614      	mov	r4, r2
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
340050de:	d904      	bls.n	340050ea <HAL_DCMIPP_CSI_SetVCConfig+0x16>
340050e0:	f44f 7172 	mov.w	r1, #968	@ 0x3c8
340050e4:	4815      	ldr	r0, [pc, #84]	@ (3400513c <HAL_DCMIPP_CSI_SetVCConfig+0x68>)
340050e6:	f7fd fa25 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));
340050ea:	2c06      	cmp	r4, #6
340050ec:	d904      	bls.n	340050f8 <HAL_DCMIPP_CSI_SetVCConfig+0x24>
340050ee:	f240 31c9 	movw	r1, #969	@ 0x3c9
340050f2:	4812      	ldr	r0, [pc, #72]	@ (3400513c <HAL_DCMIPP_CSI_SetVCConfig+0x68>)
340050f4:	f7fd fa1e 	bl	34002534 <assert_failed>
  if (hdcmipp == NULL)
340050f8:	b1f6      	cbz	r6, 34005138 <HAL_DCMIPP_CSI_SetVCConfig+0x64>
  switch (VirtualChannel)
340050fa:	2d03      	cmp	r5, #3
340050fc:	d808      	bhi.n	34005110 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
340050fe:	e8df f005 	tbb	[pc, r5]
34005102:	0902      	.short	0x0902
34005104:	150f      	.short	0x150f
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34005106:	4b0e      	ldr	r3, [pc, #56]	@ (34005140 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005108:	0224      	lsls	r4, r4, #8
3400510a:	f044 0401 	orr.w	r4, r4, #1
3400510e:	611c      	str	r4, [r3, #16]
  return HAL_OK;
34005110:	2000      	movs	r0, #0
}
34005112:	bd70      	pop	{r4, r5, r6, pc}
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
34005114:	4b0a      	ldr	r3, [pc, #40]	@ (34005140 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005116:	0224      	lsls	r4, r4, #8
34005118:	f044 0401 	orr.w	r4, r4, #1
3400511c:	621c      	str	r4, [r3, #32]
      break;
3400511e:	e7f7      	b.n	34005110 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
34005120:	4b07      	ldr	r3, [pc, #28]	@ (34005140 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005122:	0224      	lsls	r4, r4, #8
34005124:	f044 0401 	orr.w	r4, r4, #1
34005128:	631c      	str	r4, [r3, #48]	@ 0x30
      break;
3400512a:	e7f1      	b.n	34005110 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
3400512c:	4b04      	ldr	r3, [pc, #16]	@ (34005140 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
3400512e:	0224      	lsls	r4, r4, #8
34005130:	f044 0401 	orr.w	r4, r4, #1
34005134:	641c      	str	r4, [r3, #64]	@ 0x40
      break;
34005136:	e7eb      	b.n	34005110 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
    return HAL_ERROR;
34005138:	2001      	movs	r0, #1
3400513a:	e7ea      	b.n	34005112 <HAL_DCMIPP_CSI_SetVCConfig+0x3e>
3400513c:	3401c2dc 	.word	0x3401c2dc
34005140:	58006000 	.word	0x58006000

34005144 <HAL_DCMIPP_PIPE_SetConfig>:
{
34005144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34005146:	460d      	mov	r5, r1
34005148:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
3400514a:	4606      	mov	r6, r0
3400514c:	b908      	cbnz	r0, 34005152 <HAL_DCMIPP_PIPE_SetConfig+0xe>
    return HAL_ERROR;
3400514e:	2001      	movs	r0, #1
}
34005150:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
34005152:	2a00      	cmp	r2, #0
34005154:	d0fb      	beq.n	3400514e <HAL_DCMIPP_PIPE_SetConfig+0xa>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34005156:	6803      	ldr	r3, [r0, #0]
34005158:	4a46      	ldr	r2, [pc, #280]	@ (34005274 <HAL_DCMIPP_PIPE_SetConfig+0x130>)
3400515a:	4293      	cmp	r3, r2
3400515c:	d008      	beq.n	34005170 <HAL_DCMIPP_PIPE_SetConfig+0x2c>
3400515e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34005162:	4293      	cmp	r3, r2
34005164:	d004      	beq.n	34005170 <HAL_DCMIPP_PIPE_SetConfig+0x2c>
34005166:	f240 4102 	movw	r1, #1026	@ 0x402
3400516a:	4843      	ldr	r0, [pc, #268]	@ (34005278 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
3400516c:	f7fd f9e2 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005170:	2d02      	cmp	r5, #2
34005172:	d904      	bls.n	3400517e <HAL_DCMIPP_PIPE_SetConfig+0x3a>
34005174:	f240 4103 	movw	r1, #1027	@ 0x403
34005178:	483f      	ldr	r0, [pc, #252]	@ (34005278 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
3400517a:	f7fd f9db 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_FRAME_RATE(pPipeConfig->FrameRate));
3400517e:	6823      	ldr	r3, [r4, #0]
34005180:	2b03      	cmp	r3, #3
34005182:	d904      	bls.n	3400518e <HAL_DCMIPP_PIPE_SetConfig+0x4a>
34005184:	f240 4104 	movw	r1, #1028	@ 0x404
34005188:	483b      	ldr	r0, [pc, #236]	@ (34005278 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
3400518a:	f7fd f9d3 	bl	34002534 <assert_failed>
  if (Pipe != DCMIPP_PIPE0)
3400518e:	b9bd      	cbnz	r5, 340051c0 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  pipe_state = hdcmipp->PipeState[Pipe];
34005190:	1971      	adds	r1, r6, r5
34005192:	7948      	ldrb	r0, [r1, #5]
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005194:	7933      	ldrb	r3, [r6, #4]
  pipe_state = hdcmipp->PipeState[Pipe];
34005196:	b2c0      	uxtb	r0, r0
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005198:	2b02      	cmp	r3, #2
3400519a:	b2da      	uxtb	r2, r3
3400519c:	d1d7      	bne.n	3400514e <HAL_DCMIPP_PIPE_SetConfig+0xa>
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
3400519e:	f010 00fb 	ands.w	r0, r0, #251	@ 0xfb
340051a2:	d1d4      	bne.n	3400514e <HAL_DCMIPP_PIPE_SetConfig+0xa>
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
340051a4:	714a      	strb	r2, [r1, #5]
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
340051a6:	6833      	ldr	r3, [r6, #0]
340051a8:	6827      	ldr	r7, [r4, #0]
  if (Pipe == DCMIPP_PIPE0)
340051aa:	bb15      	cbnz	r5, 340051f2 <HAL_DCMIPP_PIPE_SetConfig+0xae>
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
340051ac:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
340051b0:	f022 0203 	bic.w	r2, r2, #3
340051b4:	433a      	orrs	r2, r7
340051b6:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
340051ba:	2301      	movs	r3, #1
340051bc:	714b      	strb	r3, [r1, #5]
  return HAL_OK;
340051be:	e7c7      	b.n	34005150 <HAL_DCMIPP_PIPE_SetConfig+0xc>
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
340051c0:	68a3      	ldr	r3, [r4, #8]
340051c2:	2b09      	cmp	r3, #9
340051c4:	d904      	bls.n	340051d0 <HAL_DCMIPP_PIPE_SetConfig+0x8c>
340051c6:	f240 4107 	movw	r1, #1031	@ 0x407
340051ca:	482b      	ldr	r0, [pc, #172]	@ (34005278 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340051cc:	f7fd f9b2 	bl	34002534 <assert_failed>
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
340051d0:	6863      	ldr	r3, [r4, #4]
340051d2:	071a      	lsls	r2, r3, #28
340051d4:	d102      	bne.n	340051dc <HAL_DCMIPP_PIPE_SetConfig+0x98>
340051d6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
340051da:	d304      	bcc.n	340051e6 <HAL_DCMIPP_PIPE_SetConfig+0xa2>
340051dc:	f44f 6181 	mov.w	r1, #1032	@ 0x408
340051e0:	4825      	ldr	r0, [pc, #148]	@ (34005278 <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340051e2:	f7fd f9a7 	bl	34002534 <assert_failed>
  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
340051e6:	2d02      	cmp	r5, #2
340051e8:	d1d2      	bne.n	34005190 <HAL_DCMIPP_PIPE_SetConfig+0x4c>
340051ea:	68a3      	ldr	r3, [r4, #8]
340051ec:	2b06      	cmp	r3, #6
340051ee:	d9cf      	bls.n	34005190 <HAL_DCMIPP_PIPE_SetConfig+0x4c>
340051f0:	e7ad      	b.n	3400514e <HAL_DCMIPP_PIPE_SetConfig+0xa>
  else if (Pipe == DCMIPP_PIPE1)
340051f2:	2d01      	cmp	r5, #1
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
340051f4:	e9d4 4601 	ldrd	r4, r6, [r4, #4]
  else if (Pipe == DCMIPP_PIPE1)
340051f8:	d126      	bne.n	34005248 <HAL_DCMIPP_PIPE_SetConfig+0x104>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
340051fa:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
340051fe:	4d1f      	ldr	r5, [pc, #124]	@ (3400527c <HAL_DCMIPP_PIPE_SetConfig+0x138>)
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34005200:	f022 0203 	bic.w	r2, r2, #3
34005204:	433a      	orrs	r2, r7
34005206:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
3400520a:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
3400520e:	f022 020f 	bic.w	r2, r2, #15
34005212:	4332      	orrs	r2, r6
34005214:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34005218:	f8d3 29cc 	ldr.w	r2, [r3, #2508]	@ 0x9cc
3400521c:	402a      	ands	r2, r5
3400521e:	4322      	orrs	r2, r4
34005220:	f8c3 29cc 	str.w	r2, [r3, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34005224:	1ff2      	subs	r2, r6, #7
34005226:	2a01      	cmp	r2, #1
34005228:	d806      	bhi.n	34005238 <HAL_DCMIPP_PIPE_SetConfig+0xf4>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
3400522a:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
3400522e:	402a      	ands	r2, r5
34005230:	4322      	orrs	r2, r4
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34005232:	f8c3 29dc 	str.w	r2, [r3, #2524]	@ 0x9dc
34005236:	e7c0      	b.n	340051ba <HAL_DCMIPP_PIPE_SetConfig+0x76>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
34005238:	2e09      	cmp	r6, #9
3400523a:	d1be      	bne.n	340051ba <HAL_DCMIPP_PIPE_SetConfig+0x76>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
3400523c:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
34005240:	402a      	ands	r2, r5
34005242:	ea42 0254 	orr.w	r2, r2, r4, lsr #1
34005246:	e7f4      	b.n	34005232 <HAL_DCMIPP_PIPE_SetConfig+0xee>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
34005248:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
3400524c:	f022 0203 	bic.w	r2, r2, #3
34005250:	433a      	orrs	r2, r7
34005252:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34005256:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
3400525a:	f022 020f 	bic.w	r2, r2, #15
3400525e:	4332      	orrs	r2, r6
34005260:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
34005264:	f8d3 2dcc 	ldr.w	r2, [r3, #3532]	@ 0xdcc
34005268:	f36f 020e 	bfc	r2, #0, #15
3400526c:	4322      	orrs	r2, r4
3400526e:	f8c3 2dcc 	str.w	r2, [r3, #3532]	@ 0xdcc
34005272:	e7a2      	b.n	340051ba <HAL_DCMIPP_PIPE_SetConfig+0x76>
34005274:	58002000 	.word	0x58002000
34005278:	3401c2dc 	.word	0x3401c2dc
3400527c:	ffff8000 	.word	0xffff8000

34005280 <HAL_DCMIPP_CSI_PIPE_Start>:
{
34005280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005284:	2902      	cmp	r1, #2
{
34005286:	4604      	mov	r4, r0
34005288:	460d      	mov	r5, r1
3400528a:	4616      	mov	r6, r2
3400528c:	461f      	mov	r7, r3
3400528e:	f8dd 8018 	ldr.w	r8, [sp, #24]
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005292:	d904      	bls.n	3400529e <HAL_DCMIPP_CSI_PIPE_Start+0x1e>
34005294:	f44f 61c2 	mov.w	r1, #1552	@ 0x610
34005298:	481a      	ldr	r0, [pc, #104]	@ (34005304 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
3400529a:	f7fd f94b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
3400529e:	2e03      	cmp	r6, #3
340052a0:	d904      	bls.n	340052ac <HAL_DCMIPP_CSI_PIPE_Start+0x2c>
340052a2:	f240 6111 	movw	r1, #1553	@ 0x611
340052a6:	4817      	ldr	r0, [pc, #92]	@ (34005304 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
340052a8:	f7fd f944 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_CAPTURE_MODE(CaptureMode));
340052ac:	f038 0304 	bics.w	r3, r8, #4
340052b0:	d004      	beq.n	340052bc <HAL_DCMIPP_CSI_PIPE_Start+0x3c>
340052b2:	f240 6112 	movw	r1, #1554	@ 0x612
340052b6:	4813      	ldr	r0, [pc, #76]	@ (34005304 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
340052b8:	f7fd f93c 	bl	34002534 <assert_failed>
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
340052bc:	b91c      	cbnz	r4, 340052c6 <HAL_DCMIPP_CSI_PIPE_Start+0x46>
    return HAL_ERROR;
340052be:	2601      	movs	r6, #1
}
340052c0:	4630      	mov	r0, r6
340052c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
340052c6:	073a      	lsls	r2, r7, #28
340052c8:	d1f9      	bne.n	340052be <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
340052ca:	6823      	ldr	r3, [r4, #0]
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
340052cc:	1962      	adds	r2, r4, r5
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
340052ce:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
340052d2:	7952      	ldrb	r2, [r2, #5]
340052d4:	2a01      	cmp	r2, #1
340052d6:	d1f2      	bne.n	340052be <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
340052d8:	07db      	lsls	r3, r3, #31
340052da:	d5f0      	bpl.n	340052be <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  if (DCMIPP_CSI_SetVCConfig(hdcmipp, Pipe, VirtualChannel) != HAL_OK)
340052dc:	4632      	mov	r2, r6
340052de:	4629      	mov	r1, r5
340052e0:	4620      	mov	r0, r4
340052e2:	f7ff fc65 	bl	34004bb0 <DCMIPP_CSI_SetVCConfig>
340052e6:	4606      	mov	r6, r0
340052e8:	2800      	cmp	r0, #0
340052ea:	d1e8      	bne.n	340052be <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  DCMIPP_SetConfig(hdcmipp, Pipe, DstAddress, CaptureMode);
340052ec:	4629      	mov	r1, r5
340052ee:	4620      	mov	r0, r4
340052f0:	4643      	mov	r3, r8
340052f2:	463a      	mov	r2, r7
340052f4:	f7ff fcd7 	bl	34004ca6 <DCMIPP_SetConfig>
  DCMIPP_EnableCapture(hdcmipp, Pipe);
340052f8:	4629      	mov	r1, r5
340052fa:	4620      	mov	r0, r4
340052fc:	f7ff fcfe 	bl	34004cfc <DCMIPP_EnableCapture>
  return HAL_OK;
34005300:	e7de      	b.n	340052c0 <HAL_DCMIPP_CSI_PIPE_Start+0x40>
34005302:	bf00      	nop
34005304:	3401c2dc 	.word	0x3401c2dc

34005308 <HAL_DCMIPP_PIPE_LineEventCallback>:
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
34005308:	4770      	bx	lr

3400530a <HAL_DCMIPP_PIPE_LimitEventCallback>:
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
3400530a:	4770      	bx	lr

3400530c <HAL_DCMIPP_PIPE_ErrorCallback>:
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
3400530c:	4770      	bx	lr

3400530e <HAL_DCMIPP_ErrorCallback>:
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
3400530e:	4770      	bx	lr

34005310 <HAL_DCMIPP_IRQHandler>:
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34005310:	6803      	ldr	r3, [r0, #0]
{
34005312:	b570      	push	{r4, r5, r6, lr}
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34005314:	f8d3 63f8 	ldr.w	r6, [r3, #1016]	@ 0x3f8
{
34005318:	4604      	mov	r4, r0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
3400531a:	0472      	lsls	r2, r6, #17
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
3400531c:	f8d3 53f0 	ldr.w	r5, [r3, #1008]	@ 0x3f0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34005320:	d512      	bpl.n	34005348 <HAL_DCMIPP_IRQHandler+0x38>
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34005322:	0469      	lsls	r1, r5, #17
34005324:	d510      	bpl.n	34005348 <HAL_DCMIPP_IRQHandler+0x38>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34005326:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
3400532a:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
3400532c:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34005330:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34005334:	6882      	ldr	r2, [r0, #8]
34005336:	f042 0204 	orr.w	r2, r2, #4
3400533a:	6082      	str	r2, [r0, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
3400533c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34005340:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34005344:	f7ff ffe1 	bl	3400530a <HAL_DCMIPP_PIPE_LimitEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
34005348:	0572      	lsls	r2, r6, #21
3400534a:	d50a      	bpl.n	34005362 <HAL_DCMIPP_IRQHandler+0x52>
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
3400534c:	056b      	lsls	r3, r5, #21
3400534e:	d508      	bpl.n	34005362 <HAL_DCMIPP_IRQHandler+0x52>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34005350:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005354:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34005356:	2100      	movs	r1, #0
34005358:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
3400535a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
3400535e:	f00b fc2f 	bl	34010bc0 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34005362:	05b0      	lsls	r0, r6, #22
34005364:	d516      	bpl.n	34005394 <HAL_DCMIPP_IRQHandler+0x84>
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
34005366:	05a9      	lsls	r1, r5, #22
34005368:	d514      	bpl.n	34005394 <HAL_DCMIPP_IRQHandler+0x84>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400536a:	6823      	ldr	r3, [r4, #0]
3400536c:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34005370:	0752      	lsls	r2, r2, #29
34005372:	d507      	bpl.n	34005384 <HAL_DCMIPP_IRQHandler+0x74>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34005374:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005378:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
3400537c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34005380:	2201      	movs	r2, #1
34005382:	7162      	strb	r2, [r4, #5]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34005384:	f44f 7200 	mov.w	r2, #512	@ 0x200
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34005388:	2100      	movs	r1, #0
3400538a:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
3400538c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34005390:	f00b fc26 	bl	34010be0 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34005394:	05f3      	lsls	r3, r6, #23
34005396:	d50a      	bpl.n	340053ae <HAL_DCMIPP_IRQHandler+0x9e>
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34005398:	05e8      	lsls	r0, r5, #23
3400539a:	d508      	bpl.n	340053ae <HAL_DCMIPP_IRQHandler+0x9e>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
3400539c:	f44f 7280 	mov.w	r2, #256	@ 0x100
340053a0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
340053a2:	2100      	movs	r1, #0
340053a4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
340053a6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
340053aa:	f7ff ffad 	bl	34005308 <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
340053ae:	0431      	lsls	r1, r6, #16
340053b0:	d516      	bpl.n	340053e0 <HAL_DCMIPP_IRQHandler+0xd0>
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
340053b2:	042a      	lsls	r2, r5, #16
340053b4:	d514      	bpl.n	340053e0 <HAL_DCMIPP_IRQHandler+0xd0>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
340053b6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340053b8:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
340053ba:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340053be:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
340053c0:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340053c4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
340053c8:	68a2      	ldr	r2, [r4, #8]
340053ca:	f042 0208 	orr.w	r2, r2, #8
340053ce:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
340053d0:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340053d4:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
340053d8:	2304      	movs	r3, #4
340053da:	7163      	strb	r3, [r4, #5]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340053dc:	f7ff ff96 	bl	3400530c <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340053e0:	03f3      	lsls	r3, r6, #15
340053e2:	d50a      	bpl.n	340053fa <HAL_DCMIPP_IRQHandler+0xea>
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340053e4:	03e8      	lsls	r0, r5, #15
340053e6:	d508      	bpl.n	340053fa <HAL_DCMIPP_IRQHandler+0xea>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
340053e8:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
340053ec:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
340053ee:	2101      	movs	r1, #1
340053f0:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
340053f2:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
340053f6:	f7ff ff87 	bl	34005308 <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
340053fa:	0371      	lsls	r1, r6, #13
340053fc:	d50a      	bpl.n	34005414 <HAL_DCMIPP_IRQHandler+0x104>
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
340053fe:	036a      	lsls	r2, r5, #13
34005400:	d508      	bpl.n	34005414 <HAL_DCMIPP_IRQHandler+0x104>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34005402:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34005406:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34005408:	2101      	movs	r1, #1
3400540a:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
3400540c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34005410:	f00b fbd6 	bl	34010bc0 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34005414:	03b3      	lsls	r3, r6, #14
34005416:	d516      	bpl.n	34005446 <HAL_DCMIPP_IRQHandler+0x136>
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34005418:	03a8      	lsls	r0, r5, #14
3400541a:	d514      	bpl.n	34005446 <HAL_DCMIPP_IRQHandler+0x136>
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400541c:	6823      	ldr	r3, [r4, #0]
3400541e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34005422:	0751      	lsls	r1, r2, #29
34005424:	d507      	bpl.n	34005436 <HAL_DCMIPP_IRQHandler+0x126>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34005426:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400542a:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
3400542e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34005432:	2201      	movs	r2, #1
34005434:	71a2      	strb	r2, [r4, #6]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34005436:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
3400543a:	2101      	movs	r1, #1
3400543c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
3400543e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34005442:	f00b fbcd 	bl	34010be0 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
34005446:	0232      	lsls	r2, r6, #8
34005448:	d516      	bpl.n	34005478 <HAL_DCMIPP_IRQHandler+0x168>
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
3400544a:	022b      	lsls	r3, r5, #8
3400544c:	d514      	bpl.n	34005478 <HAL_DCMIPP_IRQHandler+0x168>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
3400544e:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005450:	2101      	movs	r1, #1
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005452:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005456:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005458:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
3400545c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34005460:	68a2      	ldr	r2, [r4, #8]
34005462:	f042 0210 	orr.w	r2, r2, #16
34005466:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34005468:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3400546c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34005470:	2304      	movs	r3, #4
34005472:	71a3      	strb	r3, [r4, #6]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005474:	f7ff ff4a 	bl	3400530c <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
34005478:	01f0      	lsls	r0, r6, #7
3400547a:	d50a      	bpl.n	34005492 <HAL_DCMIPP_IRQHandler+0x182>
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
3400547c:	01e9      	lsls	r1, r5, #7
3400547e:	d508      	bpl.n	34005492 <HAL_DCMIPP_IRQHandler+0x182>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34005480:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34005484:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34005486:	2102      	movs	r1, #2
34005488:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
3400548a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
3400548e:	f7ff ff3b 	bl	34005308 <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34005492:	0172      	lsls	r2, r6, #5
34005494:	d50a      	bpl.n	340054ac <HAL_DCMIPP_IRQHandler+0x19c>
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
34005496:	016b      	lsls	r3, r5, #5
34005498:	d508      	bpl.n	340054ac <HAL_DCMIPP_IRQHandler+0x19c>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
3400549a:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
3400549e:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
340054a0:	2102      	movs	r1, #2
340054a2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
340054a4:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
340054a8:	f00b fb8a 	bl	34010bc0 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
340054ac:	01b0      	lsls	r0, r6, #6
340054ae:	d516      	bpl.n	340054de <HAL_DCMIPP_IRQHandler+0x1ce>
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
340054b0:	01a9      	lsls	r1, r5, #6
340054b2:	d514      	bpl.n	340054de <HAL_DCMIPP_IRQHandler+0x1ce>
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340054b4:	6823      	ldr	r3, [r4, #0]
340054b6:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
340054ba:	0752      	lsls	r2, r2, #29
340054bc:	d507      	bpl.n	340054ce <HAL_DCMIPP_IRQHandler+0x1be>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
340054be:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340054c2:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
340054c6:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
340054ca:	2201      	movs	r2, #1
340054cc:	71e2      	strb	r2, [r4, #7]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
340054ce:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
340054d2:	2102      	movs	r1, #2
340054d4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
340054d6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
340054da:	f00b fb81 	bl	34010be0 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
340054de:	2e00      	cmp	r6, #0
340054e0:	da16      	bge.n	34005510 <HAL_DCMIPP_IRQHandler+0x200>
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
340054e2:	2d00      	cmp	r5, #0
340054e4:	da14      	bge.n	34005510 <HAL_DCMIPP_IRQHandler+0x200>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
340054e6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
340054e8:	2102      	movs	r1, #2
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
340054ea:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
340054ee:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
340054f0:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
340054f4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
340054f8:	68a2      	ldr	r2, [r4, #8]
340054fa:	f042 0220 	orr.w	r2, r2, #32
340054fe:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34005500:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34005504:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34005508:	2304      	movs	r3, #4
3400550a:	71e3      	strb	r3, [r4, #7]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
3400550c:	f7ff fefe 	bl	3400530c <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34005510:	0670      	lsls	r0, r6, #25
34005512:	d514      	bpl.n	3400553e <HAL_DCMIPP_IRQHandler+0x22e>
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34005514:	0669      	lsls	r1, r5, #25
34005516:	d512      	bpl.n	3400553e <HAL_DCMIPP_IRQHandler+0x22e>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34005518:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400551a:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
3400551c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005520:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34005524:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34005528:	68a2      	ldr	r2, [r4, #8]
3400552a:	f042 0202 	orr.w	r2, r2, #2
3400552e:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34005530:	2240      	movs	r2, #64	@ 0x40
34005532:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005536:	2304      	movs	r3, #4
34005538:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400553a:	f7ff fee8 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
3400553e:	06b2      	lsls	r2, r6, #26
34005540:	d514      	bpl.n	3400556c <HAL_DCMIPP_IRQHandler+0x25c>
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34005542:	06ab      	lsls	r3, r5, #26
34005544:	d512      	bpl.n	3400556c <HAL_DCMIPP_IRQHandler+0x25c>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34005546:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005548:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
3400554a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400554e:	f022 0220 	bic.w	r2, r2, #32
34005552:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34005556:	68a2      	ldr	r2, [r4, #8]
34005558:	f042 0201 	orr.w	r2, r2, #1
3400555c:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
3400555e:	2220      	movs	r2, #32
34005560:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005564:	2304      	movs	r3, #4
34005566:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005568:	f7ff fed1 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
}
3400556c:	bd70      	pop	{r4, r5, r6, pc}

3400556e <HAL_DCMIPP_CSI_LineErrorCallback>:
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
3400556e:	4770      	bx	lr

34005570 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
34005570:	4770      	bx	lr

34005572 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
34005572:	4770      	bx	lr

34005574 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
34005574:	4770      	bx	lr

34005576 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
34005576:	4770      	bx	lr

34005578 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
34005578:	4770      	bx	lr

3400557a <HAL_DCMIPP_CSI_LineByteEventCallback>:
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
3400557a:	4770      	bx	lr

3400557c <HAL_DCMIPP_CSI_IRQHandler>:
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
3400557c:	4bb5      	ldr	r3, [pc, #724]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
{
3400557e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34005582:	f8d3 6090 	ldr.w	r6, [r3, #144]	@ 0x90
{
34005586:	4604      	mov	r4, r0
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34005588:	02b2      	lsls	r2, r6, #10
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
3400558a:	f8d3 8094 	ldr.w	r8, [r3, #148]	@ 0x94
  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
3400558e:	f8d3 5080 	ldr.w	r5, [r3, #128]	@ 0x80
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34005592:	f8d3 7084 	ldr.w	r7, [r3, #132]	@ 0x84
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34005596:	d50d      	bpl.n	340055b4 <HAL_DCMIPP_CSI_IRQHandler+0x38>
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34005598:	02a9      	lsls	r1, r5, #10
3400559a:	d50b      	bpl.n	340055b4 <HAL_DCMIPP_CSI_IRQHandler+0x38>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
3400559c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340055a0:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
340055a4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
340055a8:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
340055ac:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
340055b0:	f7ff ffde 	bl	34005570 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
340055b4:	0732      	lsls	r2, r6, #28
340055b6:	d515      	bpl.n	340055e4 <HAL_DCMIPP_CSI_IRQHandler+0x68>
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
340055b8:	072b      	lsls	r3, r5, #28
340055ba:	d513      	bpl.n	340055e4 <HAL_DCMIPP_CSI_IRQHandler+0x68>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340055bc:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340055be:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340055c0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340055c4:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340055c6:	f013 0f04 	tst.w	r3, #4
340055ca:	4ba2      	ldr	r3, [pc, #648]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
340055cc:	bf1e      	ittt	ne
340055ce:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340055d2:	f022 0208 	bicne.w	r2, r2, #8
340055d6:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
340055da:	2208      	movs	r2, #8
340055dc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340055e0:	f7ff ffcb 	bl	3400557a <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
340055e4:	0770      	lsls	r0, r6, #29
340055e6:	d515      	bpl.n	34005614 <HAL_DCMIPP_CSI_IRQHandler+0x98>
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
340055e8:	0769      	lsls	r1, r5, #29
340055ea:	d513      	bpl.n	34005614 <HAL_DCMIPP_CSI_IRQHandler+0x98>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340055ec:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
340055ee:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340055f0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
340055f4:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340055f6:	f013 0f04 	tst.w	r3, #4
340055fa:	4b96      	ldr	r3, [pc, #600]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
340055fc:	bf1e      	ittt	ne
340055fe:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005602:	f022 0204 	bicne.w	r2, r2, #4
34005606:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
3400560a:	2204      	movs	r2, #4
3400560c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34005610:	f7ff ffb3 	bl	3400557a <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
34005614:	07b2      	lsls	r2, r6, #30
34005616:	d515      	bpl.n	34005644 <HAL_DCMIPP_CSI_IRQHandler+0xc8>
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
34005618:	07ab      	lsls	r3, r5, #30
3400561a:	d513      	bpl.n	34005644 <HAL_DCMIPP_CSI_IRQHandler+0xc8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400561c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
3400561e:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005620:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005624:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005626:	f013 0f04 	tst.w	r3, #4
3400562a:	4b8a      	ldr	r3, [pc, #552]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
3400562c:	bf1e      	ittt	ne
3400562e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005632:	f022 0202 	bicne.w	r2, r2, #2
34005636:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
3400563a:	2202      	movs	r2, #2
3400563c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005640:	f7ff ff9b 	bl	3400557a <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34005644:	07f0      	lsls	r0, r6, #31
34005646:	d515      	bpl.n	34005674 <HAL_DCMIPP_CSI_IRQHandler+0xf8>
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34005648:	07e9      	lsls	r1, r5, #31
3400564a:	d513      	bpl.n	34005674 <HAL_DCMIPP_CSI_IRQHandler+0xf8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400564c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
3400564e:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005650:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005654:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005656:	f013 0f04 	tst.w	r3, #4
3400565a:	4b7e      	ldr	r3, [pc, #504]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
3400565c:	bf1e      	ittt	ne
3400565e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005662:	f022 0201 	bicne.w	r2, r2, #1
34005666:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
3400566a:	2201      	movs	r2, #1
3400566c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005670:	f7ff ff83 	bl	3400557a <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34005674:	0432      	lsls	r2, r6, #16
34005676:	d516      	bpl.n	340056a6 <HAL_DCMIPP_CSI_IRQHandler+0x12a>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
34005678:	042b      	lsls	r3, r5, #16
3400567a:	d514      	bpl.n	340056a6 <HAL_DCMIPP_CSI_IRQHandler+0x12a>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400567c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
3400567e:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005680:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005684:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005686:	f013 0f04 	tst.w	r3, #4
3400568a:	4b72      	ldr	r3, [pc, #456]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
3400568c:	bf1e      	ittt	ne
3400568e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005692:	f422 4200 	bicne.w	r2, r2, #32768	@ 0x8000
34005696:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
3400569a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3400569e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
340056a2:	f7ff ff67 	bl	34005574 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
340056a6:	0470      	lsls	r0, r6, #17
340056a8:	d516      	bpl.n	340056d8 <HAL_DCMIPP_CSI_IRQHandler+0x15c>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
340056aa:	0469      	lsls	r1, r5, #17
340056ac:	d514      	bpl.n	340056d8 <HAL_DCMIPP_CSI_IRQHandler+0x15c>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056ae:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
340056b0:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056b2:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
340056b6:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056b8:	f013 0f04 	tst.w	r3, #4
340056bc:	4b65      	ldr	r3, [pc, #404]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
340056be:	bf1e      	ittt	ne
340056c0:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340056c4:	f422 4280 	bicne.w	r2, r2, #16384	@ 0x4000
340056c8:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
340056cc:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
340056d0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
340056d4:	f7ff ff4e 	bl	34005574 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
340056d8:	04b2      	lsls	r2, r6, #18
340056da:	d516      	bpl.n	3400570a <HAL_DCMIPP_CSI_IRQHandler+0x18e>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
340056dc:	04ab      	lsls	r3, r5, #18
340056de:	d514      	bpl.n	3400570a <HAL_DCMIPP_CSI_IRQHandler+0x18e>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056e0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340056e2:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056e4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340056e8:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056ea:	f013 0f04 	tst.w	r3, #4
340056ee:	4b59      	ldr	r3, [pc, #356]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
340056f0:	bf1e      	ittt	ne
340056f2:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340056f6:	f422 5200 	bicne.w	r2, r2, #8192	@ 0x2000
340056fa:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
340056fe:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34005702:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005706:	f7ff ff35 	bl	34005574 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
3400570a:	04f0      	lsls	r0, r6, #19
3400570c:	d516      	bpl.n	3400573c <HAL_DCMIPP_CSI_IRQHandler+0x1c0>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
3400570e:	04e9      	lsls	r1, r5, #19
34005710:	d514      	bpl.n	3400573c <HAL_DCMIPP_CSI_IRQHandler+0x1c0>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005712:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005714:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005716:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
3400571a:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400571c:	f013 0f04 	tst.w	r3, #4
34005720:	4b4c      	ldr	r3, [pc, #304]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34005722:	bf1e      	ittt	ne
34005724:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005728:	f422 5280 	bicne.w	r2, r2, #4096	@ 0x1000
3400572c:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
34005730:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005734:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005738:	f7ff ff1c 	bl	34005574 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
3400573c:	0532      	lsls	r2, r6, #20
3400573e:	d516      	bpl.n	3400576e <HAL_DCMIPP_CSI_IRQHandler+0x1f2>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
34005740:	052b      	lsls	r3, r5, #20
34005742:	d514      	bpl.n	3400576e <HAL_DCMIPP_CSI_IRQHandler+0x1f2>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005744:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005746:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005748:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
3400574c:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400574e:	f013 0f04 	tst.w	r3, #4
34005752:	4b40      	ldr	r3, [pc, #256]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
34005754:	bf1e      	ittt	ne
34005756:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400575a:	f422 6200 	bicne.w	r2, r2, #2048	@ 0x800
3400575e:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
34005762:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34005766:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
3400576a:	f7ff ff04 	bl	34005576 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
3400576e:	0570      	lsls	r0, r6, #21
34005770:	d516      	bpl.n	340057a0 <HAL_DCMIPP_CSI_IRQHandler+0x224>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
34005772:	0569      	lsls	r1, r5, #21
34005774:	d514      	bpl.n	340057a0 <HAL_DCMIPP_CSI_IRQHandler+0x224>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005776:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005778:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400577a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
3400577e:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005780:	f013 0f04 	tst.w	r3, #4
34005784:	4b33      	ldr	r3, [pc, #204]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34005786:	bf1e      	ittt	ne
34005788:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400578c:	f422 6280 	bicne.w	r2, r2, #1024	@ 0x400
34005790:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34005794:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005798:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
3400579c:	f7ff feeb 	bl	34005576 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
340057a0:	05b2      	lsls	r2, r6, #22
340057a2:	d516      	bpl.n	340057d2 <HAL_DCMIPP_CSI_IRQHandler+0x256>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
340057a4:	05ab      	lsls	r3, r5, #22
340057a6:	d514      	bpl.n	340057d2 <HAL_DCMIPP_CSI_IRQHandler+0x256>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057a8:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340057aa:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057ac:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340057b0:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057b2:	f013 0f04 	tst.w	r3, #4
340057b6:	4b27      	ldr	r3, [pc, #156]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
340057b8:	bf1e      	ittt	ne
340057ba:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340057be:	f422 7200 	bicne.w	r2, r2, #512	@ 0x200
340057c2:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
340057c6:	f44f 7200 	mov.w	r2, #512	@ 0x200
340057ca:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340057ce:	f7ff fed2 	bl	34005576 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
340057d2:	05f0      	lsls	r0, r6, #23
340057d4:	d516      	bpl.n	34005804 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
340057d6:	05e9      	lsls	r1, r5, #23
340057d8:	d514      	bpl.n	34005804 <HAL_DCMIPP_CSI_IRQHandler+0x288>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057da:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340057dc:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057de:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340057e2:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057e4:	f013 0f04 	tst.w	r3, #4
340057e8:	4b1a      	ldr	r3, [pc, #104]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
340057ea:	bf1e      	ittt	ne
340057ec:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340057f0:	f422 7280 	bicne.w	r2, r2, #256	@ 0x100
340057f4:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
340057f8:	f44f 7280 	mov.w	r2, #256	@ 0x100
340057fc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34005800:	f7ff feb9 	bl	34005576 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
34005804:	0632      	lsls	r2, r6, #24
34005806:	d515      	bpl.n	34005834 <HAL_DCMIPP_CSI_IRQHandler+0x2b8>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
34005808:	062b      	lsls	r3, r5, #24
3400580a:	d513      	bpl.n	34005834 <HAL_DCMIPP_CSI_IRQHandler+0x2b8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400580c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
3400580e:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005810:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34005814:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005816:	f013 0f04 	tst.w	r3, #4
3400581a:	4b0e      	ldr	r3, [pc, #56]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
3400581c:	bf1e      	ittt	ne
3400581e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005822:	f022 0280 	bicne.w	r2, r2, #128	@ 0x80
34005826:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
3400582a:	2280      	movs	r2, #128	@ 0x80
3400582c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34005830:	f7ff fea2 	bl	34005578 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
34005834:	0670      	lsls	r0, r6, #25
34005836:	d519      	bpl.n	3400586c <HAL_DCMIPP_CSI_IRQHandler+0x2f0>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34005838:	0669      	lsls	r1, r5, #25
3400583a:	d517      	bpl.n	3400586c <HAL_DCMIPP_CSI_IRQHandler+0x2f0>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400583c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
3400583e:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005840:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005844:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005846:	f013 0f04 	tst.w	r3, #4
3400584a:	4b02      	ldr	r3, [pc, #8]	@ (34005854 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
3400584c:	bf18      	it	ne
3400584e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005852:	e001      	b.n	34005858 <HAL_DCMIPP_CSI_IRQHandler+0x2dc>
34005854:	58006000 	.word	0x58006000
34005858:	bf1c      	itt	ne
3400585a:	f022 0240 	bicne.w	r2, r2, #64	@ 0x40
3400585e:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
34005862:	2240      	movs	r2, #64	@ 0x40
34005864:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005868:	f7ff fe86 	bl	34005578 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
3400586c:	06b2      	lsls	r2, r6, #26
3400586e:	d515      	bpl.n	3400589c <HAL_DCMIPP_CSI_IRQHandler+0x320>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34005870:	06ab      	lsls	r3, r5, #26
34005872:	d513      	bpl.n	3400589c <HAL_DCMIPP_CSI_IRQHandler+0x320>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005874:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34005876:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005878:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
3400587c:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400587e:	f013 0f04 	tst.w	r3, #4
34005882:	4bb9      	ldr	r3, [pc, #740]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34005884:	bf1e      	ittt	ne
34005886:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400588a:	f022 0220 	bicne.w	r2, r2, #32
3400588e:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34005892:	2220      	movs	r2, #32
34005894:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34005898:	f7ff fe6e 	bl	34005578 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
3400589c:	06f0      	lsls	r0, r6, #27
3400589e:	d515      	bpl.n	340058cc <HAL_DCMIPP_CSI_IRQHandler+0x350>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
340058a0:	06e9      	lsls	r1, r5, #27
340058a2:	d513      	bpl.n	340058cc <HAL_DCMIPP_CSI_IRQHandler+0x350>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058a4:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
340058a6:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058a8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
340058ac:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058ae:	f013 0f04 	tst.w	r3, #4
340058b2:	4bad      	ldr	r3, [pc, #692]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
340058b4:	bf1e      	ittt	ne
340058b6:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340058ba:	f022 0210 	bicne.w	r2, r2, #16
340058be:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
340058c2:	2210      	movs	r2, #16
340058c4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
340058c8:	f7ff fe56 	bl	34005578 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
340058cc:	0072      	lsls	r2, r6, #1
340058ce:	d513      	bpl.n	340058f8 <HAL_DCMIPP_CSI_IRQHandler+0x37c>
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
340058d0:	006b      	lsls	r3, r5, #1
340058d2:	d511      	bpl.n	340058f8 <HAL_DCMIPP_CSI_IRQHandler+0x37c>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
340058d4:	4ba4      	ldr	r3, [pc, #656]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340058d6:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
340058d8:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340058dc:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
340058e0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
340058e4:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
340058e8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
340058ec:	68a3      	ldr	r3, [r4, #8]
340058ee:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340058f2:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340058f4:	f7ff fd0b 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
340058f8:	00b0      	lsls	r0, r6, #2
340058fa:	d513      	bpl.n	34005924 <HAL_DCMIPP_CSI_IRQHandler+0x3a8>
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
340058fc:	00a9      	lsls	r1, r5, #2
340058fe:	d511      	bpl.n	34005924 <HAL_DCMIPP_CSI_IRQHandler+0x3a8>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
34005900:	4b99      	ldr	r3, [pc, #612]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005902:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
34005904:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005908:	f022 5200 	bic.w	r2, r2, #536870912	@ 0x20000000
3400590c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
34005910:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34005914:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
34005918:	68a3      	ldr	r3, [r4, #8]
3400591a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400591e:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005920:	f7ff fcf5 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34005924:	00f2      	lsls	r2, r6, #3
34005926:	d513      	bpl.n	34005950 <HAL_DCMIPP_CSI_IRQHandler+0x3d4>
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34005928:	00eb      	lsls	r3, r5, #3
3400592a:	d511      	bpl.n	34005950 <HAL_DCMIPP_CSI_IRQHandler+0x3d4>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
3400592c:	4b8e      	ldr	r3, [pc, #568]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400592e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34005930:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005934:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
34005938:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
3400593c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34005940:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34005944:	68a3      	ldr	r3, [r4, #8]
34005946:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
3400594a:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400594c:	f7ff fcdf 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
34005950:	0130      	lsls	r0, r6, #4
34005952:	d513      	bpl.n	3400597c <HAL_DCMIPP_CSI_IRQHandler+0x400>
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34005954:	0129      	lsls	r1, r5, #4
34005956:	d511      	bpl.n	3400597c <HAL_DCMIPP_CSI_IRQHandler+0x400>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
34005958:	4b83      	ldr	r3, [pc, #524]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400595a:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
3400595c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005960:	f022 6200 	bic.w	r2, r2, #134217728	@ 0x8000000
34005964:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
34005968:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
3400596c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
34005970:	68a3      	ldr	r3, [r4, #8]
34005972:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
34005976:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005978:	f7ff fcc9 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
3400597c:	0172      	lsls	r2, r6, #5
3400597e:	d513      	bpl.n	340059a8 <HAL_DCMIPP_CSI_IRQHandler+0x42c>
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
34005980:	016b      	lsls	r3, r5, #5
34005982:	d511      	bpl.n	340059a8 <HAL_DCMIPP_CSI_IRQHandler+0x42c>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34005984:	4b78      	ldr	r3, [pc, #480]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005986:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34005988:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400598c:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
34005990:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
34005994:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34005998:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
3400599c:	68a3      	ldr	r3, [r4, #8]
3400599e:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
340059a2:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059a4:	f7ff fcb3 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
340059a8:	01b0      	lsls	r0, r6, #6
340059aa:	d513      	bpl.n	340059d4 <HAL_DCMIPP_CSI_IRQHandler+0x458>
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
340059ac:	01a9      	lsls	r1, r5, #6
340059ae:	d511      	bpl.n	340059d4 <HAL_DCMIPP_CSI_IRQHandler+0x458>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
340059b0:	4b6d      	ldr	r3, [pc, #436]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059b2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
340059b4:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340059b8:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
340059bc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
340059c0:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
340059c4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
340059c8:	68a3      	ldr	r3, [r4, #8]
340059ca:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
340059ce:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059d0:	f7ff fc9d 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
340059d4:	01f2      	lsls	r2, r6, #7
340059d6:	d513      	bpl.n	34005a00 <HAL_DCMIPP_CSI_IRQHandler+0x484>
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
340059d8:	01eb      	lsls	r3, r5, #7
340059da:	d511      	bpl.n	34005a00 <HAL_DCMIPP_CSI_IRQHandler+0x484>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
340059dc:	4b62      	ldr	r3, [pc, #392]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059de:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
340059e0:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340059e4:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
340059e8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
340059ec:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340059f0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
340059f4:	68a3      	ldr	r3, [r4, #8]
340059f6:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
340059fa:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059fc:	f7ff fc87 	bl	3400530e <HAL_DCMIPP_ErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
34005a00:	f018 0f01 	tst.w	r8, #1
34005a04:	d014      	beq.n	34005a30 <HAL_DCMIPP_CSI_IRQHandler+0x4b4>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34005a06:	07f8      	lsls	r0, r7, #31
34005a08:	d512      	bpl.n	34005a30 <HAL_DCMIPP_CSI_IRQHandler+0x4b4>
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
34005a0a:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
34005a0c:	4b56      	ldr	r3, [pc, #344]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a0e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
34005a10:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005a14:	f022 0201 	bic.w	r2, r2, #1
34005a18:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
34005a1c:	f8c3 1104 	str.w	r1, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34005a20:	68a3      	ldr	r3, [r4, #8]
34005a22:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34005a26:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005a28:	2304      	movs	r3, #4
34005a2a:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a2c:	f7ff fd9f 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
34005a30:	f018 0f02 	tst.w	r8, #2
34005a34:	d015      	beq.n	34005a62 <HAL_DCMIPP_CSI_IRQHandler+0x4e6>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
34005a36:	07b9      	lsls	r1, r7, #30
34005a38:	d513      	bpl.n	34005a62 <HAL_DCMIPP_CSI_IRQHandler+0x4e6>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34005a3a:	4b4b      	ldr	r3, [pc, #300]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a3c:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34005a3e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a42:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34005a44:	f022 0202 	bic.w	r2, r2, #2
34005a48:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
34005a4c:	2202      	movs	r2, #2
34005a4e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34005a52:	68a3      	ldr	r3, [r4, #8]
34005a54:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
34005a58:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005a5a:	2304      	movs	r3, #4
34005a5c:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a5e:	f7ff fd86 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
34005a62:	f018 0f04 	tst.w	r8, #4
34005a66:	d013      	beq.n	34005a90 <HAL_DCMIPP_CSI_IRQHandler+0x514>
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
34005a68:	077a      	lsls	r2, r7, #29
34005a6a:	d511      	bpl.n	34005a90 <HAL_DCMIPP_CSI_IRQHandler+0x514>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005a6c:	4b3e      	ldr	r3, [pc, #248]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a6e:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005a70:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a74:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005a76:	f022 0204 	bic.w	r2, r2, #4
34005a7a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
34005a7e:	2204      	movs	r2, #4
34005a80:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34005a84:	68a3      	ldr	r3, [r4, #8]
34005a86:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34005a8a:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a8c:	f7ff fd6f 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34005a90:	f018 0f08 	tst.w	r8, #8
34005a94:	d013      	beq.n	34005abe <HAL_DCMIPP_CSI_IRQHandler+0x542>
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
34005a96:	073b      	lsls	r3, r7, #28
34005a98:	d511      	bpl.n	34005abe <HAL_DCMIPP_CSI_IRQHandler+0x542>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005a9a:	4b33      	ldr	r3, [pc, #204]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005a9c:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005a9e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005aa2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005aa4:	f022 0208 	bic.w	r2, r2, #8
34005aa8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
34005aac:	2208      	movs	r2, #8
34005aae:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34005ab2:	68a3      	ldr	r3, [r4, #8]
34005ab4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34005ab8:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005aba:	f7ff fd58 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
34005abe:	f018 0f10 	tst.w	r8, #16
34005ac2:	d013      	beq.n	34005aec <HAL_DCMIPP_CSI_IRQHandler+0x570>
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
34005ac4:	06f8      	lsls	r0, r7, #27
34005ac6:	d511      	bpl.n	34005aec <HAL_DCMIPP_CSI_IRQHandler+0x570>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34005ac8:	4b27      	ldr	r3, [pc, #156]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005aca:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34005acc:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005ad0:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34005ad2:	f022 0210 	bic.w	r2, r2, #16
34005ad6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
34005ada:	2210      	movs	r2, #16
34005adc:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34005ae0:	68a3      	ldr	r3, [r4, #8]
34005ae2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34005ae6:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005ae8:	f7ff fd41 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
34005aec:	f418 7f80 	tst.w	r8, #256	@ 0x100
34005af0:	d016      	beq.n	34005b20 <HAL_DCMIPP_CSI_IRQHandler+0x5a4>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
34005af2:	05f9      	lsls	r1, r7, #23
34005af4:	d514      	bpl.n	34005b20 <HAL_DCMIPP_CSI_IRQHandler+0x5a4>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34005af6:	4b1c      	ldr	r3, [pc, #112]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005af8:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34005afa:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005afe:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34005b00:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
34005b04:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
34005b08:	f44f 7280 	mov.w	r2, #256	@ 0x100
34005b0c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34005b10:	68a3      	ldr	r3, [r4, #8]
34005b12:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34005b16:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005b18:	2304      	movs	r3, #4
34005b1a:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b1c:	f7ff fd27 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
34005b20:	f418 7f00 	tst.w	r8, #512	@ 0x200
34005b24:	d016      	beq.n	34005b54 <HAL_DCMIPP_CSI_IRQHandler+0x5d8>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34005b26:	05ba      	lsls	r2, r7, #22
34005b28:	d514      	bpl.n	34005b54 <HAL_DCMIPP_CSI_IRQHandler+0x5d8>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34005b2a:	4b0f      	ldr	r3, [pc, #60]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b2c:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34005b2e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b32:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34005b34:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
34005b38:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
34005b3c:	f44f 7200 	mov.w	r2, #512	@ 0x200
34005b40:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34005b44:	68a3      	ldr	r3, [r4, #8]
34005b46:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
34005b4a:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005b4c:	2304      	movs	r3, #4
34005b4e:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b50:	f7ff fd0d 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
34005b54:	f418 6f80 	tst.w	r8, #1024	@ 0x400
34005b58:	d017      	beq.n	34005b8a <HAL_DCMIPP_CSI_IRQHandler+0x60e>
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
34005b5a:	057b      	lsls	r3, r7, #21
34005b5c:	d515      	bpl.n	34005b8a <HAL_DCMIPP_CSI_IRQHandler+0x60e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005b5e:	4b02      	ldr	r3, [pc, #8]	@ (34005b68 <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b60:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005b62:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005b66:	e001      	b.n	34005b6c <HAL_DCMIPP_CSI_IRQHandler+0x5f0>
34005b68:	58006000 	.word	0x58006000
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b6c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005b6e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
34005b72:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
34005b76:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005b7a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34005b7e:	68a3      	ldr	r3, [r4, #8]
34005b80:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34005b84:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b86:	f7ff fcf2 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
34005b8a:	f418 6f00 	tst.w	r8, #2048	@ 0x800
34005b8e:	d014      	beq.n	34005bba <HAL_DCMIPP_CSI_IRQHandler+0x63e>
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34005b90:	0538      	lsls	r0, r7, #20
34005b92:	d512      	bpl.n	34005bba <HAL_DCMIPP_CSI_IRQHandler+0x63e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34005b94:	4b1f      	ldr	r3, [pc, #124]	@ (34005c14 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b96:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34005b98:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005b9c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34005b9e:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34005ba2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
34005ba6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34005baa:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34005bae:	68a3      	ldr	r3, [r4, #8]
34005bb0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34005bb4:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005bb6:	f7ff fcda 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34005bba:	f418 5f80 	tst.w	r8, #4096	@ 0x1000
34005bbe:	d014      	beq.n	34005bea <HAL_DCMIPP_CSI_IRQHandler+0x66e>
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34005bc0:	04f9      	lsls	r1, r7, #19
34005bc2:	d512      	bpl.n	34005bea <HAL_DCMIPP_CSI_IRQHandler+0x66e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005bc4:	4b13      	ldr	r3, [pc, #76]	@ (34005c14 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005bc6:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005bc8:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005bcc:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005bce:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34005bd2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005bd6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005bda:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34005bde:	68a3      	ldr	r3, [r4, #8]
34005be0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34005be4:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005be6:	f7ff fcc2 	bl	3400556e <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
34005bea:	03f2      	lsls	r2, r6, #15
34005bec:	d50f      	bpl.n	34005c0e <HAL_DCMIPP_CSI_IRQHandler+0x692>
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
34005bee:	03eb      	lsls	r3, r5, #15
34005bf0:	d50d      	bpl.n	34005c0e <HAL_DCMIPP_CSI_IRQHandler+0x692>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34005bf2:	4b08      	ldr	r3, [pc, #32]	@ (34005c14 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34005bf4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34005bf6:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005bfa:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
34005bfe:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34005c02:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34005c06:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34005c0a:	f7ff fcb2 	bl	34005572 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
}
34005c0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34005c12:	bf00      	nop
34005c14:	58006000 	.word	0x58006000

34005c18 <HAL_DCMIPP_PIPE_SetCropConfig>:
{
34005c18:	b570      	push	{r4, r5, r6, lr}
34005c1a:	460e      	mov	r6, r1
34005c1c:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34005c1e:	4605      	mov	r5, r0
34005c20:	b908      	cbnz	r0, 34005c26 <HAL_DCMIPP_PIPE_SetCropConfig+0xe>
    return HAL_ERROR;
34005c22:	2001      	movs	r0, #1
}
34005c24:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34005c26:	2a00      	cmp	r2, #0
34005c28:	d0fb      	beq.n	34005c22 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005c2a:	2902      	cmp	r1, #2
34005c2c:	d904      	bls.n	34005c38 <HAL_DCMIPP_PIPE_SetCropConfig+0x20>
34005c2e:	f640 61ef 	movw	r1, #3823	@ 0xeef
34005c32:	484a      	ldr	r0, [pc, #296]	@ (34005d5c <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005c34:	f7fc fc7e 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_AREA(pCropConfig->PipeArea));
34005c38:	6923      	ldr	r3, [r4, #16]
34005c3a:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
34005c3e:	d004      	beq.n	34005c4a <HAL_DCMIPP_PIPE_SetCropConfig+0x32>
34005c40:	f44f 616f 	mov.w	r1, #3824	@ 0xef0
34005c44:	4845      	ldr	r0, [pc, #276]	@ (34005d5c <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005c46:	f7fc fc75 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_HSTART(pCropConfig->HStart));
34005c4a:	6863      	ldr	r3, [r4, #4]
34005c4c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34005c50:	d304      	bcc.n	34005c5c <HAL_DCMIPP_PIPE_SetCropConfig+0x44>
34005c52:	f640 61f1 	movw	r1, #3825	@ 0xef1
34005c56:	4841      	ldr	r0, [pc, #260]	@ (34005d5c <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005c58:	f7fc fc6c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_HSIZE(pCropConfig->HSize));
34005c5c:	f640 72fe 	movw	r2, #4094	@ 0xffe
34005c60:	68e3      	ldr	r3, [r4, #12]
34005c62:	3b01      	subs	r3, #1
34005c64:	4293      	cmp	r3, r2
34005c66:	d904      	bls.n	34005c72 <HAL_DCMIPP_PIPE_SetCropConfig+0x5a>
34005c68:	f640 61f2 	movw	r1, #3826	@ 0xef2
34005c6c:	483b      	ldr	r0, [pc, #236]	@ (34005d5c <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005c6e:	f7fc fc61 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_VSIZE(pCropConfig->VSize));
34005c72:	f640 72fe 	movw	r2, #4094	@ 0xffe
34005c76:	68a3      	ldr	r3, [r4, #8]
34005c78:	3b01      	subs	r3, #1
34005c7a:	4293      	cmp	r3, r2
34005c7c:	d904      	bls.n	34005c88 <HAL_DCMIPP_PIPE_SetCropConfig+0x70>
34005c7e:	f640 61f3 	movw	r1, #3827	@ 0xef3
34005c82:	4836      	ldr	r0, [pc, #216]	@ (34005d5c <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005c84:	f7fc fc56 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_VSTART(pCropConfig->VStart));
34005c88:	6823      	ldr	r3, [r4, #0]
34005c8a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34005c8e:	d304      	bcc.n	34005c9a <HAL_DCMIPP_PIPE_SetCropConfig+0x82>
34005c90:	f640 61f4 	movw	r1, #3828	@ 0xef4
34005c94:	4831      	ldr	r0, [pc, #196]	@ (34005d5c <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005c96:	f7fc fc4d 	bl	34002534 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005c9a:	792b      	ldrb	r3, [r5, #4]
34005c9c:	2b02      	cmp	r3, #2
34005c9e:	d1c0      	bne.n	34005c22 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
    if (Pipe == DCMIPP_PIPE0)
34005ca0:	bb3e      	cbnz	r6, 34005cf2 <HAL_DCMIPP_PIPE_SetCropConfig+0xda>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005ca2:	682a      	ldr	r2, [r5, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005ca4:	4b2e      	ldr	r3, [pc, #184]	@ (34005d60 <HAL_DCMIPP_PIPE_SetCropConfig+0x148>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005ca6:	f8d2 1104 	ldr.w	r1, [r2, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005caa:	400b      	ands	r3, r1
34005cac:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34005cb0:	d0b7      	beq.n	34005c22 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34005cb2:	e9d4 0300 	ldrd	r0, r3, [r4]
34005cb6:	f8d2 1504 	ldr.w	r1, [r2, #1284]	@ 0x504
34005cba:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005cbe:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005cc2:	430b      	orrs	r3, r1
34005cc4:	f8c2 3504 	str.w	r3, [r2, #1284]	@ 0x504
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34005cc8:	f8d2 1508 	ldr.w	r1, [r2, #1288]	@ 0x508
34005ccc:	e9d4 3003 	ldrd	r3, r0, [r4, #12]
34005cd0:	f021 419f 	bic.w	r1, r1, #1333788672	@ 0x4f800000
34005cd4:	4303      	orrs	r3, r0
34005cd6:	f421 01fe 	bic.w	r1, r1, #8323072	@ 0x7f0000
34005cda:	68a0      	ldr	r0, [r4, #8]
34005cdc:	f421 617f 	bic.w	r1, r1, #4080	@ 0xff0
34005ce0:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005ce4:	f021 010f 	bic.w	r1, r1, #15
34005ce8:	430b      	orrs	r3, r1
34005cea:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
  return HAL_OK;
34005cee:	2000      	movs	r0, #0
34005cf0:	e798      	b.n	34005c24 <HAL_DCMIPP_PIPE_SetCropConfig+0xc>
    else if (Pipe == DCMIPP_PIPE1)
34005cf2:	2e01      	cmp	r6, #1
34005cf4:	d117      	bne.n	34005d26 <HAL_DCMIPP_PIPE_SetCropConfig+0x10e>
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
34005cf6:	e9d4 0300 	ldrd	r0, r3, [r4]
34005cfa:	682a      	ldr	r2, [r5, #0]
34005cfc:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005d00:	f8d2 1904 	ldr.w	r1, [r2, #2308]	@ 0x904
34005d04:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005d08:	430b      	orrs	r3, r1
34005d0a:	f8c2 3904 	str.w	r3, [r2, #2308]	@ 0x904
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
34005d0e:	f8d2 1908 	ldr.w	r1, [r2, #2312]	@ 0x908
34005d12:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34005d16:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005d1a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005d1e:	430b      	orrs	r3, r1
34005d20:	f8c2 3908 	str.w	r3, [r2, #2312]	@ 0x908
34005d24:	e7e3      	b.n	34005cee <HAL_DCMIPP_PIPE_SetCropConfig+0xd6>
    else if (Pipe == DCMIPP_PIPE2)
34005d26:	2e02      	cmp	r6, #2
34005d28:	f47f af7b 	bne.w	34005c22 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
34005d2c:	e9d4 0300 	ldrd	r0, r3, [r4]
34005d30:	682a      	ldr	r2, [r5, #0]
34005d32:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005d36:	f8d2 1d04 	ldr.w	r1, [r2, #3332]	@ 0xd04
34005d3a:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005d3e:	430b      	orrs	r3, r1
34005d40:	f8c2 3d04 	str.w	r3, [r2, #3332]	@ 0xd04
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
34005d44:	f8d2 1d08 	ldr.w	r1, [r2, #3336]	@ 0xd08
34005d48:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34005d4c:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005d50:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005d54:	430b      	orrs	r3, r1
34005d56:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
34005d5a:	e7c8      	b.n	34005cee <HAL_DCMIPP_PIPE_SetCropConfig+0xd6>
34005d5c:	3401c2dc 	.word	0x3401c2dc
34005d60:	00ff4000 	.word	0x00ff4000

34005d64 <HAL_DCMIPP_PIPE_EnableCrop>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005d64:	2902      	cmp	r1, #2
{
34005d66:	b538      	push	{r3, r4, r5, lr}
34005d68:	4605      	mov	r5, r0
34005d6a:	460c      	mov	r4, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005d6c:	d904      	bls.n	34005d78 <HAL_DCMIPP_PIPE_EnableCrop+0x14>
34005d6e:	f640 713f 	movw	r1, #3903	@ 0xf3f
34005d72:	481a      	ldr	r0, [pc, #104]	@ (34005ddc <HAL_DCMIPP_PIPE_EnableCrop+0x78>)
34005d74:	f7fc fbde 	bl	34002534 <assert_failed>
  if (hdcmipp == NULL)
34005d78:	b36d      	cbz	r5, 34005dd6 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005d7a:	792b      	ldrb	r3, [r5, #4]
34005d7c:	2b02      	cmp	r3, #2
34005d7e:	d12a      	bne.n	34005dd6 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
    if (Pipe == DCMIPP_PIPE0)
34005d80:	b97c      	cbnz	r4, 34005da2 <HAL_DCMIPP_PIPE_EnableCrop+0x3e>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005d82:	682b      	ldr	r3, [r5, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005d84:	4a16      	ldr	r2, [pc, #88]	@ (34005de0 <HAL_DCMIPP_PIPE_EnableCrop+0x7c>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005d86:	f8d3 1104 	ldr.w	r1, [r3, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005d8a:	400a      	ands	r2, r1
34005d8c:	f5b2 4f80 	cmp.w	r2, #16384	@ 0x4000
34005d90:	d021      	beq.n	34005dd6 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34005d92:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34005d96:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34005d9a:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
34005d9e:	2000      	movs	r0, #0
}
34005da0:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE1)
34005da2:	2c01      	cmp	r4, #1
34005da4:	d10d      	bne.n	34005dc2 <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34005da6:	682b      	ldr	r3, [r5, #0]
    return HAL_ERROR;
34005da8:	4620      	mov	r0, r4
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34005daa:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
34005dae:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
34005db2:	d0f5      	beq.n	34005da0 <HAL_DCMIPP_PIPE_EnableCrop+0x3c>
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005db4:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34005db8:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34005dbc:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34005dc0:	e7ed      	b.n	34005d9e <HAL_DCMIPP_PIPE_EnableCrop+0x3a>
    else if (Pipe == DCMIPP_PIPE2)
34005dc2:	2c02      	cmp	r4, #2
34005dc4:	d107      	bne.n	34005dd6 <HAL_DCMIPP_PIPE_EnableCrop+0x72>
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005dc6:	682a      	ldr	r2, [r5, #0]
34005dc8:	f8d2 3d08 	ldr.w	r3, [r2, #3336]	@ 0xd08
34005dcc:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34005dd0:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
34005dd4:	e7e3      	b.n	34005d9e <HAL_DCMIPP_PIPE_EnableCrop+0x3a>
    return HAL_ERROR;
34005dd6:	2001      	movs	r0, #1
34005dd8:	e7e2      	b.n	34005da0 <HAL_DCMIPP_PIPE_EnableCrop+0x3c>
34005dda:	bf00      	nop
34005ddc:	3401c2dc 	.word	0x3401c2dc
34005de0:	00ff4000 	.word	0x00ff4000

34005de4 <HAL_DCMIPP_PIPE_DisableCrop>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005de4:	2902      	cmp	r1, #2
{
34005de6:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005de8:	d906      	bls.n	34005df8 <HAL_DCMIPP_PIPE_DisableCrop+0x14>
34005dea:	f640 717e 	movw	r1, #3966	@ 0xf7e
34005dee:	4810      	ldr	r0, [pc, #64]	@ (34005e30 <HAL_DCMIPP_PIPE_DisableCrop+0x4c>)
34005df0:	f7fc fba0 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34005df4:	2001      	movs	r0, #1
34005df6:	e00a      	b.n	34005e0e <HAL_DCMIPP_PIPE_DisableCrop+0x2a>
  if (hdcmipp == NULL)
34005df8:	2800      	cmp	r0, #0
34005dfa:	d0fb      	beq.n	34005df4 <HAL_DCMIPP_PIPE_DisableCrop+0x10>
  if (Pipe == DCMIPP_PIPE0)
34005dfc:	6803      	ldr	r3, [r0, #0]
34005dfe:	b939      	cbnz	r1, 34005e10 <HAL_DCMIPP_PIPE_DisableCrop+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34005e00:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34005e04:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34005e08:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
34005e0c:	2000      	movs	r0, #0
}
34005e0e:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE1)
34005e10:	2901      	cmp	r1, #1
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005e12:	bf0b      	itete	eq
34005e14:	f8d3 2908 	ldreq.w	r2, [r3, #2312]	@ 0x908
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005e18:	f8d3 2d08 	ldrne.w	r2, [r3, #3336]	@ 0xd08
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005e1c:	f022 4200 	biceq.w	r2, r2, #2147483648	@ 0x80000000
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005e20:	f022 4200 	bicne.w	r2, r2, #2147483648	@ 0x80000000
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005e24:	bf0c      	ite	eq
34005e26:	f8c3 2908 	streq.w	r2, [r3, #2312]	@ 0x908
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005e2a:	f8c3 2d08 	strne.w	r2, [r3, #3336]	@ 0xd08
34005e2e:	e7ed      	b.n	34005e0c <HAL_DCMIPP_PIPE_DisableCrop+0x28>
34005e30:	3401c2dc 	.word	0x3401c2dc

34005e34 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005e34:	2902      	cmp	r1, #2
{
34005e36:	b570      	push	{r4, r5, r6, lr}
34005e38:	4605      	mov	r5, r0
34005e3a:	460e      	mov	r6, r1
34005e3c:	4614      	mov	r4, r2
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005e3e:	d904      	bls.n	34005e4a <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x16>
34005e40:	f241 0152 	movw	r1, #4178	@ 0x1052
34005e44:	4818      	ldr	r0, [pc, #96]	@ (34005ea8 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
34005e46:	f7fc fb75 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
34005e4a:	6822      	ldr	r2, [r4, #0]
34005e4c:	b152      	cbz	r2, 34005e64 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x30>
34005e4e:	2a18      	cmp	r2, #24
34005e50:	d803      	bhi.n	34005e5a <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x26>
34005e52:	4b16      	ldr	r3, [pc, #88]	@ (34005eac <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x78>)
34005e54:	40d3      	lsrs	r3, r2
34005e56:	07da      	lsls	r2, r3, #31
34005e58:	d404      	bmi.n	34005e64 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x30>
34005e5a:	f241 0153 	movw	r1, #4179	@ 0x1053
34005e5e:	4812      	ldr	r0, [pc, #72]	@ (34005ea8 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
34005e60:	f7fc fb68 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));
34005e64:	6862      	ldr	r2, [r4, #4]
34005e66:	b152      	cbz	r2, 34005e7e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x4a>
34005e68:	2a06      	cmp	r2, #6
34005e6a:	d803      	bhi.n	34005e74 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x40>
34005e6c:	2354      	movs	r3, #84	@ 0x54
34005e6e:	40d3      	lsrs	r3, r2
34005e70:	07db      	lsls	r3, r3, #31
34005e72:	d404      	bmi.n	34005e7e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x4a>
34005e74:	f241 0154 	movw	r1, #4180	@ 0x1054
34005e78:	480b      	ldr	r0, [pc, #44]	@ (34005ea8 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
34005e7a:	f7fc fb5b 	bl	34002534 <assert_failed>
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
34005e7e:	b18d      	cbz	r5, 34005ea4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005e80:	792b      	ldrb	r3, [r5, #4]
34005e82:	2b02      	cmp	r3, #2
34005e84:	d10e      	bne.n	34005ea4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
    if (Pipe == DCMIPP_PIPE1)
34005e86:	2e01      	cmp	r6, #1
34005e88:	d10c      	bne.n	34005ea4 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34005e8a:	e9d4 3000 	ldrd	r3, r0, [r4]
34005e8e:	4303      	orrs	r3, r0
  return HAL_OK;
34005e90:	2000      	movs	r0, #0
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34005e92:	6829      	ldr	r1, [r5, #0]
34005e94:	f8d1 2830 	ldr.w	r2, [r1, #2096]	@ 0x830
34005e98:	f022 021e 	bic.w	r2, r2, #30
34005e9c:	4313      	orrs	r3, r2
34005e9e:	f8c1 3830 	str.w	r3, [r1, #2096]	@ 0x830
}
34005ea2:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
34005ea4:	2001      	movs	r0, #1
34005ea6:	e7fc      	b.n	34005ea2 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x6e>
34005ea8:	3401c2dc 	.word	0x3401c2dc
34005eac:	01010100 	.word	0x01010100

34005eb0 <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005eb0:	2902      	cmp	r1, #2
{
34005eb2:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005eb4:	d906      	bls.n	34005ec4 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x14>
34005eb6:	f241 017a 	movw	r1, #4218	@ 0x107a
34005eba:	4809      	ldr	r0, [pc, #36]	@ (34005ee0 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x30>)
34005ebc:	f7fc fb3a 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34005ec0:	2001      	movs	r0, #1
}
34005ec2:	bd08      	pop	{r3, pc}
  if (hdcmipp == NULL)
34005ec4:	2800      	cmp	r0, #0
34005ec6:	d0fb      	beq.n	34005ec0 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x10>
  if (Pipe == DCMIPP_PIPE1)
34005ec8:	2901      	cmp	r1, #1
34005eca:	d1f9      	bne.n	34005ec0 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x10>
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34005ecc:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34005ece:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34005ed0:	f8d2 3830 	ldr.w	r3, [r2, #2096]	@ 0x830
34005ed4:	f043 0301 	orr.w	r3, r3, #1
34005ed8:	f8c2 3830 	str.w	r3, [r2, #2096]	@ 0x830
  return HAL_OK;
34005edc:	e7f1      	b.n	34005ec2 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x12>
34005ede:	bf00      	nop
34005ee0:	3401c2dc 	.word	0x3401c2dc

34005ee4 <HAL_DCMIPP_PIPE_SetDecimationConfig>:
{
34005ee4:	b570      	push	{r4, r5, r6, lr}
34005ee6:	460e      	mov	r6, r1
34005ee8:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34005eea:	4605      	mov	r5, r0
34005eec:	b908      	cbnz	r0, 34005ef2 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xe>
    return HAL_ERROR;
34005eee:	2001      	movs	r0, #1
}
34005ef0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005ef2:	2902      	cmp	r1, #2
34005ef4:	d904      	bls.n	34005f00 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x1c>
34005ef6:	f241 01bc 	movw	r1, #4284	@ 0x10bc
34005efa:	481e      	ldr	r0, [pc, #120]	@ (34005f74 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34005efc:	f7fc fb1a 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
34005f00:	6822      	ldr	r2, [r4, #0]
34005f02:	b152      	cbz	r2, 34005f1a <HAL_DCMIPP_PIPE_SetDecimationConfig+0x36>
34005f04:	2a18      	cmp	r2, #24
34005f06:	d803      	bhi.n	34005f10 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x2c>
34005f08:	4b1b      	ldr	r3, [pc, #108]	@ (34005f78 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x94>)
34005f0a:	40d3      	lsrs	r3, r2
34005f0c:	07da      	lsls	r2, r3, #31
34005f0e:	d404      	bmi.n	34005f1a <HAL_DCMIPP_PIPE_SetDecimationConfig+0x36>
34005f10:	f241 01bd 	movw	r1, #4285	@ 0x10bd
34005f14:	4817      	ldr	r0, [pc, #92]	@ (34005f74 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34005f16:	f7fc fb0d 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));
34005f1a:	6862      	ldr	r2, [r4, #4]
34005f1c:	b152      	cbz	r2, 34005f34 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x50>
34005f1e:	2a06      	cmp	r2, #6
34005f20:	d803      	bhi.n	34005f2a <HAL_DCMIPP_PIPE_SetDecimationConfig+0x46>
34005f22:	2354      	movs	r3, #84	@ 0x54
34005f24:	40d3      	lsrs	r3, r2
34005f26:	07db      	lsls	r3, r3, #31
34005f28:	d404      	bmi.n	34005f34 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x50>
34005f2a:	f241 01be 	movw	r1, #4286	@ 0x10be
34005f2e:	4811      	ldr	r0, [pc, #68]	@ (34005f74 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34005f30:	f7fc fb00 	bl	34002534 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005f34:	792b      	ldrb	r3, [r5, #4]
34005f36:	2b02      	cmp	r3, #2
34005f38:	d1d9      	bne.n	34005eee <HAL_DCMIPP_PIPE_SetDecimationConfig+0xa>
    if (Pipe == DCMIPP_PIPE1)
34005f3a:	2e01      	cmp	r6, #1
34005f3c:	d10c      	bne.n	34005f58 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x74>
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
34005f3e:	e9d4 3000 	ldrd	r3, r0, [r4]
34005f42:	6829      	ldr	r1, [r5, #0]
34005f44:	4303      	orrs	r3, r0
34005f46:	f8d1 290c 	ldr.w	r2, [r1, #2316]	@ 0x90c
34005f4a:	f022 021e 	bic.w	r2, r2, #30
34005f4e:	4313      	orrs	r3, r2
34005f50:	f8c1 390c 	str.w	r3, [r1, #2316]	@ 0x90c
  return HAL_OK;
34005f54:	2000      	movs	r0, #0
34005f56:	e7cb      	b.n	34005ef0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xc>
    else if (Pipe == DCMIPP_PIPE2)
34005f58:	2e02      	cmp	r6, #2
34005f5a:	d1c8      	bne.n	34005eee <HAL_DCMIPP_PIPE_SetDecimationConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
34005f5c:	e9d4 3000 	ldrd	r3, r0, [r4]
34005f60:	6829      	ldr	r1, [r5, #0]
34005f62:	4303      	orrs	r3, r0
34005f64:	f8d1 2d0c 	ldr.w	r2, [r1, #3340]	@ 0xd0c
34005f68:	f022 021e 	bic.w	r2, r2, #30
34005f6c:	4313      	orrs	r3, r2
34005f6e:	f8c1 3d0c 	str.w	r3, [r1, #3340]	@ 0xd0c
34005f72:	e7ef      	b.n	34005f54 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x70>
34005f74:	3401c2dc 	.word	0x3401c2dc
34005f78:	01010100 	.word	0x01010100

34005f7c <HAL_DCMIPP_PIPE_EnableDecimation>:
{
34005f7c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34005f7e:	b130      	cbz	r0, 34005f8e <HAL_DCMIPP_PIPE_EnableDecimation+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005f80:	2902      	cmp	r1, #2
34005f82:	d906      	bls.n	34005f92 <HAL_DCMIPP_PIPE_EnableDecimation+0x16>
34005f84:	f241 01e9 	movw	r1, #4329	@ 0x10e9
34005f88:	480c      	ldr	r0, [pc, #48]	@ (34005fbc <HAL_DCMIPP_PIPE_EnableDecimation+0x40>)
34005f8a:	f7fc fad3 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34005f8e:	2001      	movs	r0, #1
34005f90:	e009      	b.n	34005fa6 <HAL_DCMIPP_PIPE_EnableDecimation+0x2a>
  if (Pipe == DCMIPP_PIPE1)
34005f92:	2901      	cmp	r1, #1
34005f94:	d108      	bne.n	34005fa8 <HAL_DCMIPP_PIPE_EnableDecimation+0x2c>
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
34005f96:	6802      	ldr	r2, [r0, #0]
34005f98:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
34005f9c:	f043 0301 	orr.w	r3, r3, #1
34005fa0:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
34005fa4:	2000      	movs	r0, #0
}
34005fa6:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34005fa8:	2902      	cmp	r1, #2
34005faa:	d1f0      	bne.n	34005f8e <HAL_DCMIPP_PIPE_EnableDecimation+0x12>
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34005fac:	6802      	ldr	r2, [r0, #0]
34005fae:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
34005fb2:	f043 0301 	orr.w	r3, r3, #1
34005fb6:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
34005fba:	e7f3      	b.n	34005fa4 <HAL_DCMIPP_PIPE_EnableDecimation+0x28>
34005fbc:	3401c2dc 	.word	0x3401c2dc

34005fc0 <HAL_DCMIPP_PIPE_DisableDecimation>:
{
34005fc0:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34005fc2:	b130      	cbz	r0, 34005fd2 <HAL_DCMIPP_PIPE_DisableDecimation+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005fc4:	2902      	cmp	r1, #2
34005fc6:	d906      	bls.n	34005fd6 <HAL_DCMIPP_PIPE_DisableDecimation+0x16>
34005fc8:	f241 110a 	movw	r1, #4362	@ 0x110a
34005fcc:	480c      	ldr	r0, [pc, #48]	@ (34006000 <HAL_DCMIPP_PIPE_DisableDecimation+0x40>)
34005fce:	f7fc fab1 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34005fd2:	2001      	movs	r0, #1
34005fd4:	e009      	b.n	34005fea <HAL_DCMIPP_PIPE_DisableDecimation+0x2a>
  if (Pipe == DCMIPP_PIPE1)
34005fd6:	2901      	cmp	r1, #1
34005fd8:	d108      	bne.n	34005fec <HAL_DCMIPP_PIPE_DisableDecimation+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
34005fda:	6802      	ldr	r2, [r0, #0]
34005fdc:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
34005fe0:	f023 0301 	bic.w	r3, r3, #1
34005fe4:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
34005fe8:	2000      	movs	r0, #0
}
34005fea:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34005fec:	2902      	cmp	r1, #2
34005fee:	d1f0      	bne.n	34005fd2 <HAL_DCMIPP_PIPE_DisableDecimation+0x12>
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34005ff0:	6802      	ldr	r2, [r0, #0]
34005ff2:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
34005ff6:	f023 0301 	bic.w	r3, r3, #1
34005ffa:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
34005ffe:	e7f3      	b.n	34005fe8 <HAL_DCMIPP_PIPE_DisableDecimation+0x28>
34006000:	3401c2dc 	.word	0x3401c2dc

34006004 <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
{
34006004:	b570      	push	{r4, r5, r6, lr}
34006006:	460e      	mov	r6, r1
34006008:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
3400600a:	4605      	mov	r5, r0
3400600c:	b908      	cbnz	r0, 34006012 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xe>
    return HAL_ERROR;
3400600e:	2001      	movs	r0, #1
}
34006010:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
34006012:	2a00      	cmp	r2, #0
34006014:	d0fb      	beq.n	3400600e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006016:	2902      	cmp	r1, #2
34006018:	d904      	bls.n	34006024 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x20>
3400601a:	f241 1134 	movw	r1, #4404	@ 0x1134
3400601e:	483f      	ldr	r0, [pc, #252]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006020:	f7fc fa88 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_DIV_FACTOR(pDownsizeConfig->HDivFactor));
34006024:	6963      	ldr	r3, [r4, #20]
34006026:	3b80      	subs	r3, #128	@ 0x80
34006028:	f5b3 7f60 	cmp.w	r3, #896	@ 0x380
3400602c:	d304      	bcc.n	34006038 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x34>
3400602e:	f241 1135 	movw	r1, #4405	@ 0x1135
34006032:	483a      	ldr	r0, [pc, #232]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006034:	f7fc fa7e 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_DIV_FACTOR(pDownsizeConfig->VDivFactor));
34006038:	6923      	ldr	r3, [r4, #16]
3400603a:	3b80      	subs	r3, #128	@ 0x80
3400603c:	f5b3 7f60 	cmp.w	r3, #896	@ 0x380
34006040:	d304      	bcc.n	3400604c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x48>
34006042:	f241 1136 	movw	r1, #4406	@ 0x1136
34006046:	4835      	ldr	r0, [pc, #212]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006048:	f7fc fa74 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->HRatio));
3400604c:	68e3      	ldr	r3, [r4, #12]
3400604e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34006052:	d304      	bcc.n	3400605e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x5a>
34006054:	f241 1137 	movw	r1, #4407	@ 0x1137
34006058:	4830      	ldr	r0, [pc, #192]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
3400605a:	f7fc fa6b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->VRatio));
3400605e:	68a3      	ldr	r3, [r4, #8]
34006060:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34006064:	d304      	bcc.n	34006070 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x6c>
34006066:	f241 1138 	movw	r1, #4408	@ 0x1138
3400606a:	482c      	ldr	r0, [pc, #176]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
3400606c:	f7fc fa62 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->HSize));
34006070:	6863      	ldr	r3, [r4, #4]
34006072:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006076:	d304      	bcc.n	34006082 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x7e>
34006078:	f241 1139 	movw	r1, #4409	@ 0x1139
3400607c:	4827      	ldr	r0, [pc, #156]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
3400607e:	f7fc fa59 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->VSize));
34006082:	6823      	ldr	r3, [r4, #0]
34006084:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006088:	d304      	bcc.n	34006094 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x90>
3400608a:	f241 113a 	movw	r1, #4410	@ 0x113a
3400608e:	4823      	ldr	r0, [pc, #140]	@ (3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006090:	f7fc fa50 	bl	34002534 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006094:	792b      	ldrb	r3, [r5, #4]
34006096:	2b02      	cmp	r3, #2
34006098:	d1b9      	bne.n	3400600e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
    if (Pipe == DCMIPP_PIPE1)
3400609a:	2e01      	cmp	r6, #1
3400609c:	d11e      	bne.n	340060dc <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xd8>
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
3400609e:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
340060a2:	682b      	ldr	r3, [r5, #0]
340060a4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340060a8:	f8d3 1910 	ldr.w	r1, [r3, #2320]	@ 0x910
340060ac:	f001 21fc 	and.w	r1, r1, #4227922944	@ 0xfc00fc00
340060b0:	430a      	orrs	r2, r1
340060b2:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
340060b6:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
340060ba:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340060be:	f8c3 2914 	str.w	r2, [r3, #2324]	@ 0x914
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
340060c2:	f8d3 1918 	ldr.w	r1, [r3, #2328]	@ 0x918
340060c6:	e9d4 0200 	ldrd	r0, r2, [r4]
340060ca:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340060ce:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340060d2:	430a      	orrs	r2, r1
340060d4:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
  return HAL_OK;
340060d8:	2000      	movs	r0, #0
340060da:	e799      	b.n	34006010 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xc>
    else if (Pipe == DCMIPP_PIPE2)
340060dc:	2e02      	cmp	r6, #2
340060de:	d196      	bne.n	3400600e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
340060e0:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
340060e4:	682b      	ldr	r3, [r5, #0]
340060e6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340060ea:	f8d3 1d10 	ldr.w	r1, [r3, #3344]	@ 0xd10
340060ee:	f001 21fc 	and.w	r1, r1, #4227922944	@ 0xfc00fc00
340060f2:	430a      	orrs	r2, r1
340060f4:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
340060f8:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
340060fc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34006100:	f8c3 2d14 	str.w	r2, [r3, #3348]	@ 0xd14
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
34006104:	f8d3 1d18 	ldr.w	r1, [r3, #3352]	@ 0xd18
34006108:	e9d4 0200 	ldrd	r0, r2, [r4]
3400610c:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006110:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006114:	430a      	orrs	r2, r1
34006116:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
3400611a:	e7dd      	b.n	340060d8 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xd4>
3400611c:	3401c2dc 	.word	0x3401c2dc

34006120 <HAL_DCMIPP_PIPE_EnableDownsize>:
{
34006120:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006122:	b130      	cbz	r0, 34006132 <HAL_DCMIPP_PIPE_EnableDownsize+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006124:	2902      	cmp	r1, #2
34006126:	d906      	bls.n	34006136 <HAL_DCMIPP_PIPE_EnableDownsize+0x16>
34006128:	f241 117a 	movw	r1, #4474	@ 0x117a
3400612c:	480c      	ldr	r0, [pc, #48]	@ (34006160 <HAL_DCMIPP_PIPE_EnableDownsize+0x40>)
3400612e:	f7fc fa01 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006132:	2001      	movs	r0, #1
34006134:	e009      	b.n	3400614a <HAL_DCMIPP_PIPE_EnableDownsize+0x2a>
  if (Pipe == DCMIPP_PIPE1)
34006136:	2901      	cmp	r1, #1
34006138:	d108      	bne.n	3400614c <HAL_DCMIPP_PIPE_EnableDownsize+0x2c>
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
3400613a:	6802      	ldr	r2, [r0, #0]
3400613c:	f8d2 3910 	ldr.w	r3, [r2, #2320]	@ 0x910
34006140:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34006144:	f8c2 3910 	str.w	r3, [r2, #2320]	@ 0x910
  return HAL_OK;
34006148:	2000      	movs	r0, #0
}
3400614a:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
3400614c:	2902      	cmp	r1, #2
3400614e:	d1f0      	bne.n	34006132 <HAL_DCMIPP_PIPE_EnableDownsize+0x12>
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
34006150:	6802      	ldr	r2, [r0, #0]
34006152:	f8d2 3d10 	ldr.w	r3, [r2, #3344]	@ 0xd10
34006156:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
3400615a:	f8c2 3d10 	str.w	r3, [r2, #3344]	@ 0xd10
3400615e:	e7f3      	b.n	34006148 <HAL_DCMIPP_PIPE_EnableDownsize+0x28>
34006160:	3401c2dc 	.word	0x3401c2dc

34006164 <HAL_DCMIPP_PIPE_EnableGammaConversion>:
{
34006164:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006166:	b130      	cbz	r0, 34006176 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006168:	2902      	cmp	r1, #2
3400616a:	d906      	bls.n	3400617a <HAL_DCMIPP_PIPE_EnableGammaConversion+0x16>
3400616c:	f241 11bc 	movw	r1, #4540	@ 0x11bc
34006170:	480c      	ldr	r0, [pc, #48]	@ (340061a4 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x40>)
34006172:	f7fc f9df 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006176:	2001      	movs	r0, #1
34006178:	e009      	b.n	3400618e <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2a>
  if (Pipe == DCMIPP_PIPE1)
3400617a:	2901      	cmp	r1, #1
3400617c:	d108      	bne.n	34006190 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2c>
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
3400617e:	6802      	ldr	r2, [r0, #0]
34006180:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
34006184:	f043 0301 	orr.w	r3, r3, #1
34006188:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
3400618c:	2000      	movs	r0, #0
}
3400618e:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34006190:	2902      	cmp	r1, #2
34006192:	d1f0      	bne.n	34006176 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x12>
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34006194:	6802      	ldr	r2, [r0, #0]
34006196:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
3400619a:	f043 0301 	orr.w	r3, r3, #1
3400619e:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
340061a2:	e7f3      	b.n	3400618c <HAL_DCMIPP_PIPE_EnableGammaConversion+0x28>
340061a4:	3401c2dc 	.word	0x3401c2dc

340061a8 <HAL_DCMIPP_PIPE_DisableGammaConversion>:
{
340061a8:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340061aa:	b130      	cbz	r0, 340061ba <HAL_DCMIPP_PIPE_DisableGammaConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340061ac:	2902      	cmp	r1, #2
340061ae:	d906      	bls.n	340061be <HAL_DCMIPP_PIPE_DisableGammaConversion+0x16>
340061b0:	f241 11dd 	movw	r1, #4573	@ 0x11dd
340061b4:	480c      	ldr	r0, [pc, #48]	@ (340061e8 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x40>)
340061b6:	f7fc f9bd 	bl	34002534 <assert_failed>
    return HAL_ERROR;
340061ba:	2001      	movs	r0, #1
340061bc:	e009      	b.n	340061d2 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2a>
  if (Pipe == DCMIPP_PIPE1)
340061be:	2901      	cmp	r1, #1
340061c0:	d108      	bne.n	340061d4 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
340061c2:	6802      	ldr	r2, [r0, #0]
340061c4:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
340061c8:	f023 0301 	bic.w	r3, r3, #1
340061cc:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
340061d0:	2000      	movs	r0, #0
}
340061d2:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
340061d4:	2902      	cmp	r1, #2
340061d6:	d1f0      	bne.n	340061ba <HAL_DCMIPP_PIPE_DisableGammaConversion+0x12>
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
340061d8:	6802      	ldr	r2, [r0, #0]
340061da:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
340061de:	f023 0301 	bic.w	r3, r3, #1
340061e2:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
340061e6:	e7f3      	b.n	340061d0 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x28>
340061e8:	3401c2dc 	.word	0x3401c2dc

340061ec <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
{
340061ec:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340061ee:	4a13      	ldr	r2, [pc, #76]	@ (3400623c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x50>)
340061f0:	6803      	ldr	r3, [r0, #0]
{
340061f2:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340061f4:	4293      	cmp	r3, r2
{
340061f6:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340061f8:	d008      	beq.n	3400620c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x20>
340061fa:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340061fe:	4293      	cmp	r3, r2
34006200:	d004      	beq.n	3400620c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x20>
34006202:	f241 11f8 	movw	r1, #4600	@ 0x11f8
34006206:	480e      	ldr	r0, [pc, #56]	@ (34006240 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x54>)
34006208:	f7fc f994 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400620c:	2d02      	cmp	r5, #2
3400620e:	d906      	bls.n	3400621e <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x32>
34006210:	f241 11f9 	movw	r1, #4601	@ 0x11f9
34006214:	480a      	ldr	r0, [pc, #40]	@ (34006240 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x54>)
34006216:	f7fc f98d 	bl	34002534 <assert_failed>
    return 0;
3400621a:	2000      	movs	r0, #0
}
3400621c:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
3400621e:	2d01      	cmp	r5, #1
34006220:	d105      	bne.n	3400622e <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x42>
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
34006222:	6823      	ldr	r3, [r4, #0]
34006224:	f8d3 0970 	ldr.w	r0, [r3, #2416]	@ 0x970
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
34006228:	f000 0001 	and.w	r0, r0, #1
3400622c:	e7f6      	b.n	3400621c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x30>
  else if (Pipe == DCMIPP_PIPE2)
3400622e:	2d02      	cmp	r5, #2
34006230:	d1f3      	bne.n	3400621a <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
34006232:	6823      	ldr	r3, [r4, #0]
34006234:	f8d3 0d70 	ldr.w	r0, [r3, #3440]	@ 0xd70
34006238:	e7f6      	b.n	34006228 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x3c>
3400623a:	bf00      	nop
3400623c:	58002000 	.word	0x58002000
34006240:	3401c2dc 	.word	0x3401c2dc

34006244 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
{
34006244:	b570      	push	{r4, r5, r6, lr}
34006246:	460e      	mov	r6, r1
34006248:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
3400624a:	4605      	mov	r5, r0
3400624c:	b908      	cbnz	r0, 34006252 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xe>
    return HAL_ERROR;
3400624e:	2001      	movs	r0, #1
}
34006250:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
34006252:	2a00      	cmp	r2, #0
34006254:	d0fb      	beq.n	3400624e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006256:	2902      	cmp	r1, #2
34006258:	d904      	bls.n	34006264 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x20>
3400625a:	f241 211e 	movw	r1, #4638	@ 0x121e
3400625e:	4824      	ldr	r0, [pc, #144]	@ (340062f0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
34006260:	f7fc f968 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_RAW_TYPE(pRawBayer2RGBConfig->RawBayerType));
34006264:	68a2      	ldr	r2, [r4, #8]
34006266:	b152      	cbz	r2, 3400627e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3a>
34006268:	2a06      	cmp	r2, #6
3400626a:	d803      	bhi.n	34006274 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x30>
3400626c:	2354      	movs	r3, #84	@ 0x54
3400626e:	40d3      	lsrs	r3, r2
34006270:	07db      	lsls	r3, r3, #31
34006272:	d404      	bmi.n	3400627e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3a>
34006274:	f241 211f 	movw	r1, #4639	@ 0x121f
34006278:	481d      	ldr	r0, [pc, #116]	@ (340062f0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400627a:	f7fc f95b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->PeakStrength));
3400627e:	68e3      	ldr	r3, [r4, #12]
34006280:	2b07      	cmp	r3, #7
34006282:	d904      	bls.n	3400628e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x4a>
34006284:	f44f 5191 	mov.w	r1, #4640	@ 0x1220
34006288:	4819      	ldr	r0, [pc, #100]	@ (340062f0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400628a:	f7fc f953 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->VLineStrength));
3400628e:	6823      	ldr	r3, [r4, #0]
34006290:	2b07      	cmp	r3, #7
34006292:	d904      	bls.n	3400629e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x5a>
34006294:	f241 2121 	movw	r1, #4641	@ 0x1221
34006298:	4815      	ldr	r0, [pc, #84]	@ (340062f0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400629a:	f7fc f94b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->HLineStrength));
3400629e:	6863      	ldr	r3, [r4, #4]
340062a0:	2b07      	cmp	r3, #7
340062a2:	d904      	bls.n	340062ae <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x6a>
340062a4:	f241 2122 	movw	r1, #4642	@ 0x1222
340062a8:	4811      	ldr	r0, [pc, #68]	@ (340062f0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
340062aa:	f7fc f943 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->EdgeStrength));
340062ae:	6923      	ldr	r3, [r4, #16]
340062b0:	2b07      	cmp	r3, #7
340062b2:	d904      	bls.n	340062be <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x7a>
340062b4:	f241 2123 	movw	r1, #4643	@ 0x1223
340062b8:	480d      	ldr	r0, [pc, #52]	@ (340062f0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
340062ba:	f7fc f93b 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
340062be:	2e01      	cmp	r6, #1
340062c0:	d1c5      	bne.n	3400624e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xa>
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
340062c2:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
340062c6:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
340062c8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
340062cc:	68a2      	ldr	r2, [r4, #8]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340062ce:	6829      	ldr	r1, [r5, #0]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
340062d0:	4313      	orrs	r3, r2
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
340062d2:	6822      	ldr	r2, [r4, #0]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340062d4:	f8d1 0870 	ldr.w	r0, [r1, #2160]	@ 0x870
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
340062d8:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
340062dc:	6862      	ldr	r2, [r4, #4]
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
340062de:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340062e2:	4a04      	ldr	r2, [pc, #16]	@ (340062f4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xb0>)
340062e4:	4002      	ands	r2, r0
340062e6:	4313      	orrs	r3, r2
  return HAL_OK;
340062e8:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340062ea:	f8c1 3870 	str.w	r3, [r1, #2160]	@ 0x870
  return HAL_OK;
340062ee:	e7af      	b.n	34006250 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xc>
340062f0:	3401c2dc 	.word	0x3401c2dc
340062f4:	8888fff9 	.word	0x8888fff9

340062f8 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
{
340062f8:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340062fa:	b130      	cbz	r0, 3400630a <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340062fc:	2902      	cmp	r1, #2
340062fe:	d906      	bls.n	3400630e <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x16>
34006300:	f241 214a 	movw	r1, #4682	@ 0x124a
34006304:	4807      	ldr	r0, [pc, #28]	@ (34006324 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x2c>)
34006306:	f7fc f915 	bl	34002534 <assert_failed>
    return HAL_ERROR;
3400630a:	2001      	movs	r0, #1
}
3400630c:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
3400630e:	2901      	cmp	r1, #1
34006310:	d1fb      	bne.n	3400630a <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x12>
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006312:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006314:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006316:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
3400631a:	f043 0301 	orr.w	r3, r3, #1
3400631e:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
34006322:	e7f3      	b.n	3400630c <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x14>
34006324:	3401c2dc 	.word	0x3401c2dc

34006328 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
{
34006328:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400632a:	b130      	cbz	r0, 3400633a <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400632c:	2902      	cmp	r1, #2
3400632e:	d906      	bls.n	3400633e <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x16>
34006330:	f241 2167 	movw	r1, #4711	@ 0x1267
34006334:	4807      	ldr	r0, [pc, #28]	@ (34006354 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x2c>)
34006336:	f7fc f8fd 	bl	34002534 <assert_failed>
    return HAL_ERROR;
3400633a:	2001      	movs	r0, #1
}
3400633c:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
3400633e:	2901      	cmp	r1, #1
34006340:	d1fb      	bne.n	3400633a <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006342:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006344:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006346:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
3400634a:	f023 0301 	bic.w	r3, r3, #1
3400634e:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
34006352:	e7f3      	b.n	3400633c <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x14>
34006354:	3401c2dc 	.word	0x3401c2dc

34006358 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
{
34006358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400635a:	460f      	mov	r7, r1
3400635c:	4615      	mov	r5, r2
3400635e:	461c      	mov	r4, r3
  if (hdcmipp == NULL)
34006360:	4606      	mov	r6, r0
34006362:	b908      	cbnz	r0, 34006368 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x10>
    return HAL_ERROR;
34006364:	2001      	movs	r0, #1
}
34006366:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006368:	2902      	cmp	r1, #2
3400636a:	d904      	bls.n	34006376 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x1e>
3400636c:	f241 2189 	movw	r1, #4745	@ 0x1289
34006370:	480f      	ldr	r0, [pc, #60]	@ (340063b0 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006372:	f7fc f8df 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_NB_FIRST_LINES(NbFirstLines));
34006376:	2d07      	cmp	r5, #7
34006378:	d904      	bls.n	34006384 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x2c>
3400637a:	f241 218a 	movw	r1, #4746	@ 0x128a
3400637e:	480c      	ldr	r0, [pc, #48]	@ (340063b0 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006380:	f7fc f8d8 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_NB_LAST_LINES(NbLastLines));
34006384:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
34006388:	d304      	bcc.n	34006394 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x3c>
3400638a:	f241 218b 	movw	r1, #4747	@ 0x128b
3400638e:	4808      	ldr	r0, [pc, #32]	@ (340063b0 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006390:	f7fc f8d0 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006394:	2f01      	cmp	r7, #1
34006396:	d1e5      	bne.n	34006364 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0xc>
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34006398:	6832      	ldr	r2, [r6, #0]
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
3400639a:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
3400639e:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
340063a2:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
340063a4:	f36f 030e 	bfc	r3, #0, #15
340063a8:	431c      	orrs	r4, r3
340063aa:	f8c2 4820 	str.w	r4, [r2, #2080]	@ 0x820
  return HAL_OK;
340063ae:	e7da      	b.n	34006366 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0xe>
340063b0:	3401c2dc 	.word	0x3401c2dc

340063b4 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  if (hdcmipp == NULL)
340063b4:	b150      	cbz	r0, 340063cc <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
340063b6:	2901      	cmp	r1, #1
340063b8:	d108      	bne.n	340063cc <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340063ba:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340063bc:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340063be:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
340063c2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
340063c6:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
340063ca:	4770      	bx	lr
    return HAL_ERROR;
340063cc:	2001      	movs	r0, #1
}
340063ce:	4770      	bx	lr

340063d0 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  if (hdcmipp == NULL)
340063d0:	b150      	cbz	r0, 340063e8 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
340063d2:	2901      	cmp	r1, #1
340063d4:	d108      	bne.n	340063e8 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340063d6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340063d8:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340063da:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
340063de:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
340063e2:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
340063e6:	4770      	bx	lr
    return HAL_ERROR;
340063e8:	2001      	movs	r0, #1
}
340063ea:	4770      	bx	lr

340063ec <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
{
340063ec:	b570      	push	{r4, r5, r6, lr}
340063ee:	460e      	mov	r6, r1
340063f0:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
340063f2:	4605      	mov	r5, r0
340063f4:	b908      	cbnz	r0, 340063fa <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xe>
    return HAL_ERROR;
340063f6:	2001      	movs	r0, #1
}
340063f8:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
340063fa:	2902      	cmp	r1, #2
340063fc:	d918      	bls.n	34006430 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x44>
340063fe:	f241 21ea 	movw	r1, #4842	@ 0x12ea
34006402:	480d      	ldr	r0, [pc, #52]	@ (34006438 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x4c>)
34006404:	f7fc f896 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));
34006408:	2c07      	cmp	r4, #7
3400640a:	d9f4      	bls.n	340063f6 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xa>
3400640c:	f241 21eb 	movw	r1, #4843	@ 0x12eb
34006410:	4809      	ldr	r0, [pc, #36]	@ (34006438 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x4c>)
34006412:	f7fc f88f 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006416:	2e01      	cmp	r6, #1
34006418:	d1ed      	bne.n	340063f6 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
3400641a:	6829      	ldr	r1, [r5, #0]
  return HAL_OK;
3400641c:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
3400641e:	f8d1 3824 	ldr.w	r3, [r1, #2084]	@ 0x824
34006422:	f023 030e 	bic.w	r3, r3, #14
34006426:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
3400642a:	f8c1 3824 	str.w	r3, [r1, #2084]	@ 0x824
  return HAL_OK;
3400642e:	e7e3      	b.n	340063f8 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xc>
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));
34006430:	2a07      	cmp	r2, #7
34006432:	d9f0      	bls.n	34006416 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x2a>
34006434:	e7ea      	b.n	3400640c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x20>
34006436:	bf00      	nop
34006438:	3401c2dc 	.word	0x3401c2dc

3400643c <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
{
3400643c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400643e:	b130      	cbz	r0, 3400644e <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006440:	2902      	cmp	r1, #2
34006442:	d906      	bls.n	34006452 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x16>
34006444:	f241 3108 	movw	r1, #4872	@ 0x1308
34006448:	4807      	ldr	r0, [pc, #28]	@ (34006468 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x2c>)
3400644a:	f7fc f873 	bl	34002534 <assert_failed>
    return HAL_ERROR;
3400644e:	2001      	movs	r0, #1
}
34006450:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006452:	2901      	cmp	r1, #1
34006454:	d1fb      	bne.n	3400644e <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x12>
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34006456:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006458:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400645a:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
3400645e:	f043 0301 	orr.w	r3, r3, #1
34006462:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
34006466:	e7f3      	b.n	34006450 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x14>
34006468:	3401c2dc 	.word	0x3401c2dc

3400646c <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
{
3400646c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400646e:	b130      	cbz	r0, 3400647e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006470:	2902      	cmp	r1, #2
34006472:	d906      	bls.n	34006482 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x16>
34006474:	f241 3125 	movw	r1, #4901	@ 0x1325
34006478:	4807      	ldr	r0, [pc, #28]	@ (34006498 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x2c>)
3400647a:	f7fc f85b 	bl	34002534 <assert_failed>
    return HAL_ERROR;
3400647e:	2001      	movs	r0, #1
}
34006480:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006482:	2901      	cmp	r1, #1
34006484:	d1fb      	bne.n	3400647e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34006486:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006488:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400648a:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
3400648e:	f023 0301 	bic.w	r3, r3, #1
34006492:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
34006496:	e7f3      	b.n	34006480 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x14>
34006498:	3401c2dc 	.word	0x3401c2dc

3400649c <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400649c:	2902      	cmp	r1, #2
{
3400649e:	b510      	push	{r4, lr}
340064a0:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_PIPE(Pipe));
340064a2:	d904      	bls.n	340064ae <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig+0x12>
340064a4:	f241 313b 	movw	r1, #4923	@ 0x133b
340064a8:	4804      	ldr	r0, [pc, #16]	@ (340064bc <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig+0x20>)
340064aa:	f7fc f843 	bl	34002534 <assert_failed>
  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
340064ae:	6823      	ldr	r3, [r4, #0]
340064b0:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
}
340064b4:	f3c0 0042 	ubfx	r0, r0, #1, #3
340064b8:	bd10      	pop	{r4, pc}
340064ba:	bf00      	nop
340064bc:	3401c2dc 	.word	0x3401c2dc

340064c0 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
{
340064c0:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340064c2:	4a10      	ldr	r2, [pc, #64]	@ (34006504 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x44>)
340064c4:	6803      	ldr	r3, [r0, #0]
{
340064c6:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340064c8:	4293      	cmp	r3, r2
{
340064ca:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340064cc:	d008      	beq.n	340064e0 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x20>
340064ce:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340064d2:	4293      	cmp	r3, r2
340064d4:	d004      	beq.n	340064e0 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x20>
340064d6:	f241 3148 	movw	r1, #4936	@ 0x1348
340064da:	480b      	ldr	r0, [pc, #44]	@ (34006508 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x48>)
340064dc:	f7fc f82a 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340064e0:	2d02      	cmp	r5, #2
340064e2:	d906      	bls.n	340064f2 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x32>
340064e4:	f241 3149 	movw	r1, #4937	@ 0x1349
340064e8:	4807      	ldr	r0, [pc, #28]	@ (34006508 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x48>)
340064ea:	f7fc f823 	bl	34002534 <assert_failed>
    return 0;
340064ee:	2000      	movs	r0, #0
}
340064f0:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
340064f2:	2d01      	cmp	r5, #1
340064f4:	d1fb      	bne.n	340064ee <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
340064f6:	6823      	ldr	r3, [r4, #0]
340064f8:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
340064fc:	f000 0001 	and.w	r0, r0, #1
34006500:	e7f6      	b.n	340064f0 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x30>
34006502:	bf00      	nop
34006504:	58002000 	.word	0x58002000
34006508:	3401c2dc 	.word	0x3401c2dc

3400650c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
{
3400650c:	b538      	push	{r3, r4, r5, lr}
3400650e:	4615      	mov	r5, r2
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006510:	4604      	mov	r4, r0
34006512:	b908      	cbnz	r0, 34006518 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0xc>
    return HAL_ERROR;
34006514:	2001      	movs	r0, #1
}
34006516:	bd38      	pop	{r3, r4, r5, pc}
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006518:	2a00      	cmp	r2, #0
3400651a:	d0fb      	beq.n	34006514 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x8>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400651c:	2902      	cmp	r1, #2
3400651e:	d904      	bls.n	3400652a <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1e>
34006520:	f241 3166 	movw	r1, #4966	@ 0x1366
34006524:	4806      	ldr	r0, [pc, #24]	@ (34006540 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x34>)
34006526:	f7fc f805 	bl	34002534 <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400652a:	7923      	ldrb	r3, [r4, #4]
3400652c:	2b02      	cmp	r3, #2
3400652e:	d1f1      	bne.n	34006514 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x8>
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34006530:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
34006532:	2000      	movs	r0, #0
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34006534:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
34006538:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400653c:	602b      	str	r3, [r5, #0]
  return HAL_OK;
3400653e:	e7ea      	b.n	34006516 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0xa>
34006540:	3401c2dc 	.word	0x3401c2dc

34006544 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
{
34006544:	b570      	push	{r4, r5, r6, lr}
34006546:	460e      	mov	r6, r1
34006548:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
3400654a:	4605      	mov	r5, r0
3400654c:	b908      	cbnz	r0, 34006552 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xe>
    return HAL_ERROR;
3400654e:	2001      	movs	r0, #1
}
34006550:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34006552:	2a00      	cmp	r2, #0
34006554:	d0fb      	beq.n	3400654e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006556:	2902      	cmp	r1, #2
34006558:	d904      	bls.n	34006564 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x20>
3400655a:	f241 4125 	movw	r1, #5157	@ 0x1425
3400655e:	4898      	ldr	r0, [pc, #608]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006560:	f7fb ffe8 	bl	34002534 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(pColorConversionConfig->ClampOutputSamples));
34006564:	7823      	ldrb	r3, [r4, #0]
34006566:	2b01      	cmp	r3, #1
34006568:	d904      	bls.n	34006574 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x30>
3400656a:	f241 4126 	movw	r1, #5158	@ 0x1426
3400656e:	4894      	ldr	r0, [pc, #592]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006570:	f7fb ffe0 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_OUTPUT_SAMPLES_TYPES(pColorConversionConfig->OutputSamplesType));
34006574:	7863      	ldrb	r3, [r4, #1]
34006576:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
3400657a:	d004      	beq.n	34006586 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x42>
3400657c:	f241 4127 	movw	r1, #5159	@ 0x1427
34006580:	488f      	ldr	r0, [pc, #572]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006582:	f7fb ffd7 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RR));
34006586:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
3400658a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400658e:	db04      	blt.n	3400659a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x56>
34006590:	f241 4128 	movw	r1, #5160	@ 0x1428
34006594:	488a      	ldr	r0, [pc, #552]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006596:	f7fb ffcd 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RG));
3400659a:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
3400659e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340065a2:	db04      	blt.n	340065ae <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x6a>
340065a4:	f241 4129 	movw	r1, #5161	@ 0x1429
340065a8:	4885      	ldr	r0, [pc, #532]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340065aa:	f7fb ffc3 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RB));
340065ae:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
340065b2:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340065b6:	db04      	blt.n	340065c2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x7e>
340065b8:	f241 412a 	movw	r1, #5162	@ 0x142a
340065bc:	4880      	ldr	r0, [pc, #512]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340065be:	f7fb ffb9 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RA));
340065c2:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
340065c6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340065ca:	db04      	blt.n	340065d6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x92>
340065cc:	f241 412b 	movw	r1, #5163	@ 0x142b
340065d0:	487b      	ldr	r0, [pc, #492]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340065d2:	f7fb ffaf 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GR));
340065d6:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
340065da:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340065de:	db04      	blt.n	340065ea <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa6>
340065e0:	f241 412c 	movw	r1, #5164	@ 0x142c
340065e4:	4876      	ldr	r0, [pc, #472]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340065e6:	f7fb ffa5 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GG));
340065ea:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
340065ee:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340065f2:	db04      	blt.n	340065fe <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xba>
340065f4:	f241 412d 	movw	r1, #5165	@ 0x142d
340065f8:	4871      	ldr	r0, [pc, #452]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340065fa:	f7fb ff9b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GB));
340065fe:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
34006602:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006606:	db04      	blt.n	34006612 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xce>
34006608:	f241 412e 	movw	r1, #5166	@ 0x142e
3400660c:	486c      	ldr	r0, [pc, #432]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400660e:	f7fb ff91 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GA));
34006612:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
34006616:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400661a:	db04      	blt.n	34006626 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xe2>
3400661c:	f241 412f 	movw	r1, #5167	@ 0x142f
34006620:	4867      	ldr	r0, [pc, #412]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006622:	f7fb ff87 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BR));
34006626:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
3400662a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400662e:	db04      	blt.n	3400663a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xf6>
34006630:	f241 4130 	movw	r1, #5168	@ 0x1430
34006634:	4862      	ldr	r0, [pc, #392]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006636:	f7fb ff7d 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BG));
3400663a:	f9b4 3014 	ldrsh.w	r3, [r4, #20]
3400663e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006642:	db04      	blt.n	3400664e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x10a>
34006644:	f241 4131 	movw	r1, #5169	@ 0x1431
34006648:	485d      	ldr	r0, [pc, #372]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400664a:	f7fb ff73 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BB));
3400664e:	f9b4 3016 	ldrsh.w	r3, [r4, #22]
34006652:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006656:	db04      	blt.n	34006662 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x11e>
34006658:	f241 4132 	movw	r1, #5170	@ 0x1432
3400665c:	4858      	ldr	r0, [pc, #352]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400665e:	f7fb ff69 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BA));
34006662:	f9b4 3018 	ldrsh.w	r3, [r4, #24]
34006666:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400666a:	db04      	blt.n	34006676 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x132>
3400666c:	f241 4133 	movw	r1, #5171	@ 0x1433
34006670:	4853      	ldr	r0, [pc, #332]	@ (340067c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006672:	f7fb ff5f 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006676:	2e01      	cmp	r6, #1
34006678:	f47f af69 	bne.w	3400654e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
3400667c:	682b      	ldr	r3, [r5, #0]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
3400667e:	7820      	ldrb	r0, [r4, #0]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006680:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
34006684:	7862      	ldrb	r2, [r4, #1]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006686:	f021 0106 	bic.w	r1, r1, #6
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
3400668a:	ea42 0280 	orr.w	r2, r2, r0, lsl #2
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
3400668e:	430a      	orrs	r2, r1
34006690:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34006694:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
34006698:	b290      	uxth	r0, r2
3400669a:	f3c2 010a 	ubfx	r1, r2, #0, #11
3400669e:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
340066a0:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
340066a4:	bfb8      	it	lt
340066a6:	4608      	movlt	r0, r1
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
340066a8:	f3c2 050a 	ubfx	r5, r2, #0, #11
340066ac:	2a00      	cmp	r2, #0
340066ae:	b291      	uxth	r1, r2
340066b0:	bfb8      	it	lt
340066b2:	4629      	movlt	r1, r5
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
340066b4:	f8d3 2884 	ldr.w	r2, [r3, #2180]	@ 0x884
340066b8:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
340066bc:	4302      	orrs	r2, r0
340066be:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340066c2:	f8c3 2884 	str.w	r2, [r3, #2180]	@ 0x884
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
340066c6:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
340066ca:	b295      	uxth	r5, r2
340066cc:	f3c2 010a 	ubfx	r1, r2, #0, #11
340066d0:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
340066d2:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
340066d6:	bfb8      	it	lt
340066d8:	460d      	movlt	r5, r1
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
340066da:	f3c2 0109 	ubfx	r1, r2, #0, #10
340066de:	2a00      	cmp	r2, #0
340066e0:	b290      	uxth	r0, r2
340066e2:	bfb8      	it	lt
340066e4:	4608      	movlt	r0, r1
    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
340066e6:	f8d3 2888 	ldr.w	r2, [r3, #2184]	@ 0x888
340066ea:	4936      	ldr	r1, [pc, #216]	@ (340067c4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x280>)
340066ec:	400a      	ands	r2, r1
340066ee:	432a      	orrs	r2, r5
340066f0:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340066f4:	f8c3 2888 	str.w	r2, [r3, #2184]	@ 0x888
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
340066f8:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
340066fc:	b295      	uxth	r5, r2
340066fe:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006702:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
34006704:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
34006708:	bfb8      	it	lt
3400670a:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
3400670c:	f3c2 060a 	ubfx	r6, r2, #0, #11
34006710:	2a00      	cmp	r2, #0
34006712:	b290      	uxth	r0, r2
34006714:	bfb8      	it	lt
34006716:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
34006718:	f8d3 288c 	ldr.w	r2, [r3, #2188]	@ 0x88c
3400671c:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006720:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
34006724:	4302      	orrs	r2, r0
34006726:	f8c3 288c 	str.w	r2, [r3, #2188]	@ 0x88c
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
3400672a:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
3400672e:	b295      	uxth	r5, r2
34006730:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006734:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
34006736:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
3400673a:	bfb8      	it	lt
3400673c:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
3400673e:	f3c2 0609 	ubfx	r6, r2, #0, #10
34006742:	2a00      	cmp	r2, #0
34006744:	b290      	uxth	r0, r2
34006746:	bfb8      	it	lt
34006748:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
3400674a:	f8d3 2890 	ldr.w	r2, [r3, #2192]	@ 0x890
3400674e:	400a      	ands	r2, r1
34006750:	432a      	orrs	r2, r5
34006752:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006756:	f8c3 2890 	str.w	r2, [r3, #2192]	@ 0x890
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
3400675a:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
3400675e:	b295      	uxth	r5, r2
34006760:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006764:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
34006766:	f9b4 2014 	ldrsh.w	r2, [r4, #20]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
3400676a:	bfb8      	it	lt
3400676c:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
3400676e:	f3c2 060a 	ubfx	r6, r2, #0, #11
34006772:	2a00      	cmp	r2, #0
34006774:	b290      	uxth	r0, r2
34006776:	bfb8      	it	lt
34006778:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
3400677a:	f8d3 2894 	ldr.w	r2, [r3, #2196]	@ 0x894
3400677e:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006782:	432a      	orrs	r2, r5
34006784:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
34006788:	f8c3 2894 	str.w	r2, [r3, #2196]	@ 0x894
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
3400678c:	f9b4 2016 	ldrsh.w	r2, [r4, #22]
34006790:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006794:	b295      	uxth	r5, r2
34006796:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
34006798:	f9b4 2018 	ldrsh.w	r2, [r4, #24]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
3400679c:	bfb8      	it	lt
3400679e:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
340067a0:	f3c2 0409 	ubfx	r4, r2, #0, #10
340067a4:	2a00      	cmp	r2, #0
340067a6:	b290      	uxth	r0, r2
340067a8:	bfb8      	it	lt
340067aa:	4620      	movlt	r0, r4
    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
340067ac:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
340067b0:	400a      	ands	r2, r1
340067b2:	432a      	orrs	r2, r5
340067b4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340067b8:	f8c3 2898 	str.w	r2, [r3, #2200]	@ 0x898
  return HAL_OK;
340067bc:	2000      	movs	r0, #0
340067be:	e6c7      	b.n	34006550 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xc>
340067c0:	3401c2dc 	.word	0x3401c2dc
340067c4:	fc00f800 	.word	0xfc00f800

340067c8 <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
{
340067c8:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340067ca:	b130      	cbz	r0, 340067da <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340067cc:	2902      	cmp	r1, #2
340067ce:	d906      	bls.n	340067de <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x16>
340067d0:	f241 417b 	movw	r1, #5243	@ 0x147b
340067d4:	4807      	ldr	r0, [pc, #28]	@ (340067f4 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x2c>)
340067d6:	f7fb fead 	bl	34002534 <assert_failed>
    return HAL_ERROR;
340067da:	2001      	movs	r0, #1
}
340067dc:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340067de:	2901      	cmp	r1, #1
340067e0:	d1fb      	bne.n	340067da <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x12>
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340067e2:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340067e4:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340067e6:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
340067ea:	f043 0301 	orr.w	r3, r3, #1
340067ee:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
340067f2:	e7f3      	b.n	340067dc <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x14>
340067f4:	3401c2dc 	.word	0x3401c2dc

340067f8 <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
{
340067f8:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340067fa:	b130      	cbz	r0, 3400680a <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340067fc:	2902      	cmp	r1, #2
340067fe:	d906      	bls.n	3400680e <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x16>
34006800:	f241 4197 	movw	r1, #5271	@ 0x1497
34006804:	4807      	ldr	r0, [pc, #28]	@ (34006824 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x2c>)
34006806:	f7fb fe95 	bl	34002534 <assert_failed>
    return HAL_ERROR;
3400680a:	2001      	movs	r0, #1
}
3400680c:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
3400680e:	2901      	cmp	r1, #1
34006810:	d1fb      	bne.n	3400680a <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34006812:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006814:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34006816:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
3400681a:	f023 0301 	bic.w	r3, r3, #1
3400681e:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
34006822:	e7f3      	b.n	3400680c <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x14>
34006824:	3401c2dc 	.word	0x3401c2dc

34006828 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
{
34006828:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
3400682a:	b100      	cbz	r0, 3400682e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
3400682c:	b90a      	cbnz	r2, 34006832 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0xa>
    return HAL_ERROR;
3400682e:	2001      	movs	r0, #1
}
34006830:	bd10      	pop	{r4, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006832:	2902      	cmp	r1, #2
34006834:	d905      	bls.n	34006842 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x1a>
34006836:	f241 515b 	movw	r1, #5467	@ 0x155b
3400683a:	480b      	ldr	r0, [pc, #44]	@ (34006868 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x40>)
3400683c:	f7fb fe7a 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006840:	e7f5      	b.n	3400682e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
34006842:	2901      	cmp	r1, #1
34006844:	d1f3      	bne.n	3400682e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
34006846:	6800      	ldr	r0, [r0, #0]
34006848:	7853      	ldrb	r3, [r2, #1]
3400684a:	7814      	ldrb	r4, [r2, #0]
3400684c:	f8d0 1840 	ldr.w	r1, [r0, #2112]	@ 0x840
34006850:	7892      	ldrb	r2, [r2, #2]
34006852:	041b      	lsls	r3, r3, #16
34006854:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34006858:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
3400685c:	b2ca      	uxtb	r2, r1
3400685e:	4313      	orrs	r3, r2
34006860:	f8c0 3840 	str.w	r3, [r0, #2112]	@ 0x840
  return HAL_OK;
34006864:	2000      	movs	r0, #0
34006866:	e7e3      	b.n	34006830 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x8>
34006868:	3401c2dc 	.word	0x3401c2dc

3400686c <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
{
3400686c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400686e:	b130      	cbz	r0, 3400687e <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006870:	2902      	cmp	r1, #2
34006872:	d906      	bls.n	34006882 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x16>
34006874:	f241 517a 	movw	r1, #5498	@ 0x157a
34006878:	4807      	ldr	r0, [pc, #28]	@ (34006898 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x2c>)
3400687a:	f7fb fe5b 	bl	34002534 <assert_failed>
    return HAL_ERROR;
3400687e:	2001      	movs	r0, #1
}
34006880:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006882:	2901      	cmp	r1, #1
34006884:	d1fb      	bne.n	3400687e <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x12>
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34006886:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006888:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
3400688a:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
3400688e:	f043 0301 	orr.w	r3, r3, #1
34006892:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
34006896:	e7f3      	b.n	34006880 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x14>
34006898:	3401c2dc 	.word	0x3401c2dc

3400689c <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
{
3400689c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400689e:	b130      	cbz	r0, 340068ae <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340068a0:	2902      	cmp	r1, #2
340068a2:	d906      	bls.n	340068b2 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x16>
340068a4:	f241 5196 	movw	r1, #5526	@ 0x1596
340068a8:	4807      	ldr	r0, [pc, #28]	@ (340068c8 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x2c>)
340068aa:	f7fb fe43 	bl	34002534 <assert_failed>
    return HAL_ERROR;
340068ae:	2001      	movs	r0, #1
}
340068b0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340068b2:	2901      	cmp	r1, #1
340068b4:	d1fb      	bne.n	340068ae <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340068b6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340068b8:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340068ba:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
340068be:	f023 0301 	bic.w	r3, r3, #1
340068c2:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
340068c6:	e7f3      	b.n	340068b0 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x14>
340068c8:	3401c2dc 	.word	0x3401c2dc

340068cc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
{
340068cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340068ce:	460f      	mov	r7, r1
340068d0:	4615      	mov	r5, r2
340068d2:	461c      	mov	r4, r3
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
340068d4:	4606      	mov	r6, r0
340068d6:	b908      	cbnz	r0, 340068dc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x10>
    return HAL_ERROR;
340068d8:	2001      	movs	r0, #1
}
340068da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
340068dc:	2b00      	cmp	r3, #0
340068de:	d0fb      	beq.n	340068d8 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340068e0:	2902      	cmp	r1, #2
340068e2:	d904      	bls.n	340068ee <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x22>
340068e4:	f241 51e9 	movw	r1, #5609	@ 0x15e9
340068e8:	482a      	ldr	r0, [pc, #168]	@ (34006994 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
340068ea:	f7fb fe23 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
340068ee:	1e6b      	subs	r3, r5, #1
340068f0:	2b02      	cmp	r3, #2
340068f2:	d904      	bls.n	340068fe <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x32>
340068f4:	f241 51ea 	movw	r1, #5610	@ 0x15ea
340068f8:	4826      	ldr	r0, [pc, #152]	@ (34006994 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
340068fa:	f7fb fe1b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_BINS(pStatisticExtractionConfig->Bins));
340068fe:	68a3      	ldr	r3, [r4, #8]
34006900:	b16b      	cbz	r3, 3400691e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
34006902:	3b04      	subs	r3, #4
34006904:	2b08      	cmp	r3, #8
34006906:	d805      	bhi.n	34006914 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x48>
34006908:	f240 1211 	movw	r2, #273	@ 0x111
3400690c:	fa22 f303 	lsr.w	r3, r2, r3
34006910:	07db      	lsls	r3, r3, #31
34006912:	d404      	bmi.n	3400691e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
34006914:	f241 51eb 	movw	r1, #5611	@ 0x15eb
34006918:	481e      	ldr	r0, [pc, #120]	@ (34006994 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
3400691a:	f7fb fe0b 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_SOURCE(pStatisticExtractionConfig->Source));
3400691e:	6863      	ldr	r3, [r4, #4]
34006920:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34006924:	d006      	beq.n	34006934 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x68>
34006926:	2b40      	cmp	r3, #64	@ 0x40
34006928:	d004      	beq.n	34006934 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x68>
3400692a:	f241 51ec 	movw	r1, #5612	@ 0x15ec
3400692e:	4819      	ldr	r0, [pc, #100]	@ (34006994 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34006930:	f7fb fe00 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODE(pStatisticExtractionConfig->Mode));
34006934:	6823      	ldr	r3, [r4, #0]
34006936:	f033 0380 	bics.w	r3, r3, #128	@ 0x80
3400693a:	d004      	beq.n	34006946 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x7a>
3400693c:	f241 51ed 	movw	r1, #5613	@ 0x15ed
34006940:	4814      	ldr	r0, [pc, #80]	@ (34006994 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34006942:	f7fb fdf7 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006946:	2f01      	cmp	r7, #1
34006948:	d1c6      	bne.n	340068d8 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc>
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
3400694a:	e9d4 3200 	ldrd	r3, r2, [r4]
3400694e:	4313      	orrs	r3, r2
34006950:	68a2      	ldr	r2, [r4, #8]
    switch (ModuleID)
34006952:	2d01      	cmp	r5, #1
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34006954:	6831      	ldr	r1, [r6, #0]
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34006956:	ea43 0302 	orr.w	r3, r3, r2
    switch (ModuleID)
3400695a:	d009      	beq.n	34006970 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xa4>
3400695c:	2d02      	cmp	r5, #2
3400695e:	d010      	beq.n	34006982 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb6>
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
34006960:	f8d1 2858 	ldr.w	r2, [r1, #2136]	@ 0x858
34006964:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34006968:	4313      	orrs	r3, r2
3400696a:	f8c1 3858 	str.w	r3, [r1, #2136]	@ 0x858
        break;
3400696e:	e006      	b.n	3400697e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb2>
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34006970:	f8d1 2850 	ldr.w	r2, [r1, #2128]	@ 0x850
34006974:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34006978:	4313      	orrs	r3, r2
3400697a:	f8c1 3850 	str.w	r3, [r1, #2128]	@ 0x850
  return HAL_OK;
3400697e:	2000      	movs	r0, #0
34006980:	e7ab      	b.n	340068da <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xe>
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
34006982:	f8d1 2854 	ldr.w	r2, [r1, #2132]	@ 0x854
34006986:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
3400698a:	4313      	orrs	r3, r2
3400698c:	f8c1 3854 	str.w	r3, [r1, #2132]	@ 0x854
        break;
34006990:	e7f5      	b.n	3400697e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb2>
34006992:	bf00      	nop
34006994:	3401c2dc 	.word	0x3401c2dc

34006998 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
{
34006998:	b570      	push	{r4, r5, r6, lr}
3400699a:	460e      	mov	r6, r1
3400699c:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
3400699e:	4605      	mov	r5, r0
340069a0:	b908      	cbnz	r0, 340069a6 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xe>
    return HAL_ERROR;
340069a2:	2001      	movs	r0, #1
}
340069a4:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
340069a6:	2a00      	cmp	r2, #0
340069a8:	d0fb      	beq.n	340069a2 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340069aa:	2902      	cmp	r1, #2
340069ac:	d904      	bls.n	340069b8 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x20>
340069ae:	f241 611f 	movw	r1, #5663	@ 0x161f
340069b2:	4821      	ldr	r0, [pc, #132]	@ (34006a38 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340069b4:	f7fb fdbe 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->HStart));
340069b8:	6863      	ldr	r3, [r4, #4]
340069ba:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340069be:	d304      	bcc.n	340069ca <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x32>
340069c0:	f44f 51b1 	mov.w	r1, #5664	@ 0x1620
340069c4:	481c      	ldr	r0, [pc, #112]	@ (34006a38 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340069c6:	f7fb fdb5 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->VStart));
340069ca:	6823      	ldr	r3, [r4, #0]
340069cc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340069d0:	d304      	bcc.n	340069dc <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x44>
340069d2:	f241 6121 	movw	r1, #5665	@ 0x1621
340069d6:	4818      	ldr	r0, [pc, #96]	@ (34006a38 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340069d8:	f7fb fdac 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->HSize));
340069dc:	68e3      	ldr	r3, [r4, #12]
340069de:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340069e2:	d304      	bcc.n	340069ee <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x56>
340069e4:	f241 6122 	movw	r1, #5666	@ 0x1622
340069e8:	4813      	ldr	r0, [pc, #76]	@ (34006a38 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340069ea:	f7fb fda3 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->VSize));
340069ee:	68a3      	ldr	r3, [r4, #8]
340069f0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340069f4:	d304      	bcc.n	34006a00 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x68>
340069f6:	f241 6123 	movw	r1, #5667	@ 0x1623
340069fa:	480f      	ldr	r0, [pc, #60]	@ (34006a38 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
340069fc:	f7fb fd9a 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006a00:	2e01      	cmp	r6, #1
34006a02:	d1ce      	bne.n	340069a2 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
34006a04:	e9d4 0300 	ldrd	r0, r3, [r4]
34006a08:	682a      	ldr	r2, [r5, #0]
34006a0a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006a0e:	f8d2 185c 	ldr.w	r1, [r2, #2140]	@ 0x85c
34006a12:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006a16:	430b      	orrs	r3, r1
34006a18:	f8c2 385c 	str.w	r3, [r2, #2140]	@ 0x85c
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34006a1c:	f8d2 1860 	ldr.w	r1, [r2, #2144]	@ 0x860
34006a20:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34006a24:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006a28:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006a2c:	430b      	orrs	r3, r1
  return HAL_OK;
34006a2e:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34006a30:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
34006a34:	e7b6      	b.n	340069a4 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xc>
34006a36:	bf00      	nop
34006a38:	3401c2dc 	.word	0x3401c2dc

34006a3c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
{
34006a3c:	b570      	push	{r4, r5, r6, lr}
34006a3e:	460e      	mov	r6, r1
34006a40:	4615      	mov	r5, r2
  if (hdcmipp == NULL)
34006a42:	4604      	mov	r4, r0
34006a44:	b908      	cbnz	r0, 34006a4a <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xe>
    return HAL_ERROR;
34006a46:	2001      	movs	r0, #1
}
34006a48:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006a4a:	2902      	cmp	r1, #2
34006a4c:	d904      	bls.n	34006a58 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x1c>
34006a4e:	f241 6147 	movw	r1, #5703	@ 0x1647
34006a52:	4815      	ldr	r0, [pc, #84]	@ (34006aa8 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>)
34006a54:	f7fb fd6e 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
34006a58:	1e6b      	subs	r3, r5, #1
34006a5a:	2b02      	cmp	r3, #2
34006a5c:	d90e      	bls.n	34006a7c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x40>
34006a5e:	f241 6148 	movw	r1, #5704	@ 0x1648
34006a62:	4811      	ldr	r0, [pc, #68]	@ (34006aa8 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>)
34006a64:	f7fb fd66 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006a68:	2e01      	cmp	r6, #1
34006a6a:	d1ec      	bne.n	34006a46 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xa>
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
34006a6c:	6822      	ldr	r2, [r4, #0]
34006a6e:	f8d2 3858 	ldr.w	r3, [r2, #2136]	@ 0x858
34006a72:	f043 0301 	orr.w	r3, r3, #1
34006a76:	f8c2 3858 	str.w	r3, [r2, #2136]	@ 0x858
        break;
34006a7a:	e013      	b.n	34006aa4 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x68>
  if (Pipe == DCMIPP_PIPE1)
34006a7c:	2e01      	cmp	r6, #1
34006a7e:	d1e2      	bne.n	34006a46 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xa>
    switch (ModuleID)
34006a80:	2d01      	cmp	r5, #1
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34006a82:	6823      	ldr	r3, [r4, #0]
    switch (ModuleID)
34006a84:	d008      	beq.n	34006a98 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x5c>
34006a86:	2d02      	cmp	r5, #2
34006a88:	d1f0      	bne.n	34006a6c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x30>
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
34006a8a:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
34006a8e:	f042 0201 	orr.w	r2, r2, #1
34006a92:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
34006a96:	e005      	b.n	34006aa4 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x68>
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34006a98:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
34006a9c:	f042 0201 	orr.w	r2, r2, #1
34006aa0:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
  return HAL_OK;
34006aa4:	2000      	movs	r0, #0
34006aa6:	e7cf      	b.n	34006a48 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xc>
34006aa8:	3401c2dc 	.word	0x3401c2dc

34006aac <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
{
34006aac:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006aae:	b130      	cbz	r0, 34006abe <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ab0:	2902      	cmp	r1, #2
34006ab2:	d906      	bls.n	34006ac2 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x16>
34006ab4:	f241 619f 	movw	r1, #5791	@ 0x169f
34006ab8:	4807      	ldr	r0, [pc, #28]	@ (34006ad8 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x2c>)
34006aba:	f7fb fd3b 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006abe:	2001      	movs	r0, #1
}
34006ac0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006ac2:	2901      	cmp	r1, #1
34006ac4:	d1fb      	bne.n	34006abe <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x12>
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
34006ac6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006ac8:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
34006aca:	f8d2 3860 	ldr.w	r3, [r2, #2144]	@ 0x860
34006ace:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34006ad2:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
34006ad6:	e7f3      	b.n	34006ac0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x14>
34006ad8:	3401c2dc 	.word	0x3401c2dc

34006adc <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
{
34006adc:	b570      	push	{r4, r5, r6, lr}
34006ade:	460e      	mov	r6, r1
34006ae0:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
34006ae2:	4605      	mov	r5, r0
34006ae4:	b908      	cbnz	r0, 34006aea <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xe>
    return HAL_ERROR;
34006ae6:	2001      	movs	r0, #1
}
34006ae8:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
34006aea:	2a00      	cmp	r2, #0
34006aec:	d0fb      	beq.n	34006ae6 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006aee:	2902      	cmp	r1, #2
34006af0:	d904      	bls.n	34006afc <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x20>
34006af2:	f241 61db 	movw	r1, #5851	@ 0x16db
34006af6:	481c      	ldr	r0, [pc, #112]	@ (34006b68 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006af8:	f7fb fd1c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftRed));
34006afc:	7823      	ldrb	r3, [r4, #0]
34006afe:	2b07      	cmp	r3, #7
34006b00:	d904      	bls.n	34006b0c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x30>
34006b02:	f241 61dc 	movw	r1, #5852	@ 0x16dc
34006b06:	4818      	ldr	r0, [pc, #96]	@ (34006b68 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006b08:	f7fb fd14 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftGreen));
34006b0c:	78a3      	ldrb	r3, [r4, #2]
34006b0e:	2b07      	cmp	r3, #7
34006b10:	d904      	bls.n	34006b1c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x40>
34006b12:	f241 61dd 	movw	r1, #5853	@ 0x16dd
34006b16:	4814      	ldr	r0, [pc, #80]	@ (34006b68 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006b18:	f7fb fd0c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftBlue));
34006b1c:	7923      	ldrb	r3, [r4, #4]
34006b1e:	2b07      	cmp	r3, #7
34006b20:	d904      	bls.n	34006b2c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x50>
34006b22:	f241 61de 	movw	r1, #5854	@ 0x16de
34006b26:	4810      	ldr	r0, [pc, #64]	@ (34006b68 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006b28:	f7fb fd04 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006b2c:	2e01      	cmp	r6, #1
34006b2e:	d1da      	bne.n	34006ae6 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
34006b30:	682a      	ldr	r2, [r5, #0]
34006b32:	7863      	ldrb	r3, [r4, #1]
34006b34:	7820      	ldrb	r0, [r4, #0]
34006b36:	f8d2 1844 	ldr.w	r1, [r2, #2116]	@ 0x844
34006b3a:	051b      	lsls	r3, r3, #20
34006b3c:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
34006b40:	f36f 511e 	bfc	r1, #20, #11
34006b44:	430b      	orrs	r3, r1
34006b46:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34006b4a:	78e3      	ldrb	r3, [r4, #3]
34006b4c:	78a1      	ldrb	r1, [r4, #2]
34006b4e:	051b      	lsls	r3, r3, #20
34006b50:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
34006b54:	7921      	ldrb	r1, [r4, #4]
  return HAL_OK;
34006b56:	2000      	movs	r0, #0
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34006b58:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
34006b5c:	7961      	ldrb	r1, [r4, #5]
34006b5e:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
34006b62:	f8c2 3848 	str.w	r3, [r2, #2120]	@ 0x848
  return HAL_OK;
34006b66:	e7bf      	b.n	34006ae8 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xc>
34006b68:	3401c2dc 	.word	0x3401c2dc

34006b6c <HAL_DCMIPP_PIPE_EnableISPExposure>:
{
34006b6c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006b6e:	b130      	cbz	r0, 34006b7e <HAL_DCMIPP_PIPE_EnableISPExposure+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b70:	2902      	cmp	r1, #2
34006b72:	d906      	bls.n	34006b82 <HAL_DCMIPP_PIPE_EnableISPExposure+0x16>
34006b74:	f241 7101 	movw	r1, #5889	@ 0x1701
34006b78:	4807      	ldr	r0, [pc, #28]	@ (34006b98 <HAL_DCMIPP_PIPE_EnableISPExposure+0x2c>)
34006b7a:	f7fb fcdb 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006b7e:	2001      	movs	r0, #1
}
34006b80:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006b82:	2901      	cmp	r1, #1
34006b84:	d1fb      	bne.n	34006b7e <HAL_DCMIPP_PIPE_EnableISPExposure+0x12>
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006b86:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006b88:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006b8a:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34006b8e:	f043 0301 	orr.w	r3, r3, #1
34006b92:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
34006b96:	e7f3      	b.n	34006b80 <HAL_DCMIPP_PIPE_EnableISPExposure+0x14>
34006b98:	3401c2dc 	.word	0x3401c2dc

34006b9c <HAL_DCMIPP_PIPE_DisableISPExposure>:
{
34006b9c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006b9e:	b130      	cbz	r0, 34006bae <HAL_DCMIPP_PIPE_DisableISPExposure+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ba0:	2902      	cmp	r1, #2
34006ba2:	d906      	bls.n	34006bb2 <HAL_DCMIPP_PIPE_DisableISPExposure+0x16>
34006ba4:	f241 711d 	movw	r1, #5917	@ 0x171d
34006ba8:	4807      	ldr	r0, [pc, #28]	@ (34006bc8 <HAL_DCMIPP_PIPE_DisableISPExposure+0x2c>)
34006baa:	f7fb fcc3 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006bae:	2001      	movs	r0, #1
}
34006bb0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006bb2:	2901      	cmp	r1, #1
34006bb4:	d1fb      	bne.n	34006bae <HAL_DCMIPP_PIPE_DisableISPExposure+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006bb6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006bb8:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006bba:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34006bbe:	f023 0301 	bic.w	r3, r3, #1
34006bc2:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
34006bc6:	e7f3      	b.n	34006bb0 <HAL_DCMIPP_PIPE_DisableISPExposure+0x14>
34006bc8:	3401c2dc 	.word	0x3401c2dc

34006bcc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
{
34006bcc:	b570      	push	{r4, r5, r6, lr}
34006bce:	460e      	mov	r6, r1
34006bd0:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34006bd2:	4605      	mov	r5, r0
34006bd4:	b908      	cbnz	r0, 34006bda <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xe>
    return HAL_ERROR;
34006bd6:	2001      	movs	r0, #1
}
34006bd8:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34006bda:	2a00      	cmp	r2, #0
34006bdc:	d0fb      	beq.n	34006bd6 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006bde:	2902      	cmp	r1, #2
34006be0:	d904      	bls.n	34006bec <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x20>
34006be2:	f241 713b 	movw	r1, #5947	@ 0x173b
34006be6:	4839      	ldr	r0, [pc, #228]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006be8:	f7fb fca4 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_0));
34006bec:	7823      	ldrb	r3, [r4, #0]
34006bee:	2b3f      	cmp	r3, #63	@ 0x3f
34006bf0:	d904      	bls.n	34006bfc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x30>
34006bf2:	f241 713c 	movw	r1, #5948	@ 0x173c
34006bf6:	4835      	ldr	r0, [pc, #212]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006bf8:	f7fb fc9c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_32));
34006bfc:	7863      	ldrb	r3, [r4, #1]
34006bfe:	2b3f      	cmp	r3, #63	@ 0x3f
34006c00:	d904      	bls.n	34006c0c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x40>
34006c02:	f241 713d 	movw	r1, #5949	@ 0x173d
34006c06:	4831      	ldr	r0, [pc, #196]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c08:	f7fb fc94 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_64));
34006c0c:	78a3      	ldrb	r3, [r4, #2]
34006c0e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c10:	d904      	bls.n	34006c1c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x50>
34006c12:	f241 713e 	movw	r1, #5950	@ 0x173e
34006c16:	482d      	ldr	r0, [pc, #180]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c18:	f7fb fc8c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_96));
34006c1c:	78e3      	ldrb	r3, [r4, #3]
34006c1e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c20:	d904      	bls.n	34006c2c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x60>
34006c22:	f241 713f 	movw	r1, #5951	@ 0x173f
34006c26:	4829      	ldr	r0, [pc, #164]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c28:	f7fb fc84 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_128));
34006c2c:	7923      	ldrb	r3, [r4, #4]
34006c2e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c30:	d904      	bls.n	34006c3c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x70>
34006c32:	f44f 51ba 	mov.w	r1, #5952	@ 0x1740
34006c36:	4825      	ldr	r0, [pc, #148]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c38:	f7fb fc7c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_160));
34006c3c:	7963      	ldrb	r3, [r4, #5]
34006c3e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c40:	d904      	bls.n	34006c4c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x80>
34006c42:	f241 7141 	movw	r1, #5953	@ 0x1741
34006c46:	4821      	ldr	r0, [pc, #132]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c48:	f7fb fc74 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_192));
34006c4c:	79a3      	ldrb	r3, [r4, #6]
34006c4e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c50:	d904      	bls.n	34006c5c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x90>
34006c52:	f241 7142 	movw	r1, #5954	@ 0x1742
34006c56:	481d      	ldr	r0, [pc, #116]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c58:	f7fb fc6c 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_224));
34006c5c:	79e3      	ldrb	r3, [r4, #7]
34006c5e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c60:	d904      	bls.n	34006c6c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa0>
34006c62:	f241 7143 	movw	r1, #5955	@ 0x1743
34006c66:	4819      	ldr	r0, [pc, #100]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c68:	f7fb fc64 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_256));
34006c6c:	7a23      	ldrb	r3, [r4, #8]
34006c6e:	2b3f      	cmp	r3, #63	@ 0x3f
34006c70:	d904      	bls.n	34006c7c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xb0>
34006c72:	f241 7144 	movw	r1, #5956	@ 0x1744
34006c76:	4815      	ldr	r0, [pc, #84]	@ (34006ccc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006c78:	f7fb fc5c 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006c7c:	2e01      	cmp	r6, #1
34006c7e:	d1aa      	bne.n	34006bd6 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34006c80:	682a      	ldr	r2, [r5, #0]
34006c82:	7821      	ldrb	r1, [r4, #0]
34006c84:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34006c88:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34006c8a:	f423 43fc 	bic.w	r3, r3, #32256	@ 0x7e00
34006c8e:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
34006c92:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
34006c96:	78a3      	ldrb	r3, [r4, #2]
34006c98:	7861      	ldrb	r1, [r4, #1]
34006c9a:	045b      	lsls	r3, r3, #17
34006c9c:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
34006ca0:	78e1      	ldrb	r1, [r4, #3]
34006ca2:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
34006ca6:	7921      	ldrb	r1, [r4, #4]
34006ca8:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
34006cac:	f8c2 38a4 	str.w	r3, [r2, #2212]	@ 0x8a4
    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
34006cb0:	79a3      	ldrb	r3, [r4, #6]
34006cb2:	7961      	ldrb	r1, [r4, #5]
34006cb4:	045b      	lsls	r3, r3, #17
34006cb6:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
34006cba:	79e1      	ldrb	r1, [r4, #7]
34006cbc:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
34006cc0:	7a21      	ldrb	r1, [r4, #8]
34006cc2:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
34006cc6:	f8c2 38a8 	str.w	r3, [r2, #2216]	@ 0x8a8
  return HAL_OK;
34006cca:	e785      	b.n	34006bd8 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xc>
34006ccc:	3401c2dc 	.word	0x3401c2dc

34006cd0 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
{
34006cd0:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006cd2:	b130      	cbz	r0, 34006ce2 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006cd4:	2902      	cmp	r1, #2
34006cd6:	d906      	bls.n	34006ce6 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x16>
34006cd8:	f241 716c 	movw	r1, #5996	@ 0x176c
34006cdc:	4807      	ldr	r0, [pc, #28]	@ (34006cfc <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x2c>)
34006cde:	f7fb fc29 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006ce2:	2001      	movs	r0, #1
}
34006ce4:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006ce6:	2901      	cmp	r1, #1
34006ce8:	d1fb      	bne.n	34006ce2 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x12>
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006cea:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006cec:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006cee:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
34006cf2:	f043 0301 	orr.w	r3, r3, #1
34006cf6:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34006cfa:	e7f3      	b.n	34006ce4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x14>
34006cfc:	3401c2dc 	.word	0x3401c2dc

34006d00 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
{
34006d00:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006d02:	b130      	cbz	r0, 34006d12 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006d04:	2902      	cmp	r1, #2
34006d06:	d906      	bls.n	34006d16 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x16>
34006d08:	f241 7188 	movw	r1, #6024	@ 0x1788
34006d0c:	4807      	ldr	r0, [pc, #28]	@ (34006d2c <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x2c>)
34006d0e:	f7fb fc11 	bl	34002534 <assert_failed>
    return HAL_ERROR;
34006d12:	2001      	movs	r0, #1
}
34006d14:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006d16:	2901      	cmp	r1, #1
34006d18:	d1fb      	bne.n	34006d12 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006d1a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006d1c:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006d1e:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
34006d22:	f023 0301 	bic.w	r3, r3, #1
34006d26:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34006d2a:	e7f3      	b.n	34006d14 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x14>
34006d2c:	3401c2dc 	.word	0x3401c2dc

34006d30 <HAL_DCMIPP_PIPE_SetPitch>:
{
34006d30:	b570      	push	{r4, r5, r6, lr}
34006d32:	460e      	mov	r6, r1
34006d34:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34006d36:	4605      	mov	r5, r0
34006d38:	b908      	cbnz	r0, 34006d3e <HAL_DCMIPP_PIPE_SetPitch+0xe>
    return HAL_ERROR;
34006d3a:	2001      	movs	r0, #1
}
34006d3c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006d3e:	2902      	cmp	r1, #2
34006d40:	d904      	bls.n	34006d4c <HAL_DCMIPP_PIPE_SetPitch+0x1c>
34006d42:	f241 71d2 	movw	r1, #6098	@ 0x17d2
34006d46:	4812      	ldr	r0, [pc, #72]	@ (34006d90 <HAL_DCMIPP_PIPE_SetPitch+0x60>)
34006d48:	f7fb fbf4 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(LinePitch));
34006d4c:	0723      	lsls	r3, r4, #28
34006d4e:	d102      	bne.n	34006d56 <HAL_DCMIPP_PIPE_SetPitch+0x26>
34006d50:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
34006d54:	d304      	bcc.n	34006d60 <HAL_DCMIPP_PIPE_SetPitch+0x30>
34006d56:	f241 71d3 	movw	r1, #6099	@ 0x17d3
34006d5a:	480d      	ldr	r0, [pc, #52]	@ (34006d90 <HAL_DCMIPP_PIPE_SetPitch+0x60>)
34006d5c:	f7fb fbea 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006d60:	2e01      	cmp	r6, #1
34006d62:	d109      	bne.n	34006d78 <HAL_DCMIPP_PIPE_SetPitch+0x48>
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
34006d64:	682a      	ldr	r2, [r5, #0]
34006d66:	f8d2 39cc 	ldr.w	r3, [r2, #2508]	@ 0x9cc
34006d6a:	f36f 030e 	bfc	r3, #0, #15
34006d6e:	4323      	orrs	r3, r4
34006d70:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
  return HAL_OK;
34006d74:	2000      	movs	r0, #0
34006d76:	e7e1      	b.n	34006d3c <HAL_DCMIPP_PIPE_SetPitch+0xc>
  else if (Pipe == DCMIPP_PIPE2)
34006d78:	2e02      	cmp	r6, #2
34006d7a:	d1de      	bne.n	34006d3a <HAL_DCMIPP_PIPE_SetPitch+0xa>
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34006d7c:	682a      	ldr	r2, [r5, #0]
34006d7e:	f8d2 3dcc 	ldr.w	r3, [r2, #3532]	@ 0xdcc
34006d82:	f36f 030e 	bfc	r3, #0, #15
34006d86:	4323      	orrs	r3, r4
34006d88:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
34006d8c:	e7f2      	b.n	34006d74 <HAL_DCMIPP_PIPE_SetPitch+0x44>
34006d8e:	bf00      	nop
34006d90:	3401c2dc 	.word	0x3401c2dc

34006d94 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
{
34006d94:	b570      	push	{r4, r5, r6, lr}
34006d96:	460e      	mov	r6, r1
34006d98:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34006d9a:	4605      	mov	r5, r0
34006d9c:	b908      	cbnz	r0, 34006da2 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xe>
    return HAL_ERROR;
34006d9e:	2001      	movs	r0, #1
}
34006da0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006da2:	2902      	cmp	r1, #2
34006da4:	d917      	bls.n	34006dd6 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x42>
34006da6:	f241 71f6 	movw	r1, #6134	@ 0x17f6
34006daa:	4812      	ldr	r0, [pc, #72]	@ (34006df4 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x60>)
34006dac:	f7fb fbc2 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));
34006db0:	2c09      	cmp	r4, #9
34006db2:	d9f4      	bls.n	34006d9e <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xa>
34006db4:	f241 71f7 	movw	r1, #6135	@ 0x17f7
34006db8:	480e      	ldr	r0, [pc, #56]	@ (34006df4 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x60>)
34006dba:	f7fb fbbb 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006dbe:	2e01      	cmp	r6, #1
34006dc0:	d10c      	bne.n	34006ddc <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x48>
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
34006dc2:	682a      	ldr	r2, [r5, #0]
34006dc4:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34006dc8:	f023 030f 	bic.w	r3, r3, #15
34006dcc:	4323      	orrs	r3, r4
34006dce:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34006dd2:	2000      	movs	r0, #0
34006dd4:	e7e4      	b.n	34006da0 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xc>
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));
34006dd6:	2a09      	cmp	r2, #9
34006dd8:	d9f1      	bls.n	34006dbe <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x2a>
34006dda:	e7eb      	b.n	34006db4 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x20>
  else if (Pipe == DCMIPP_PIPE2)
34006ddc:	2e02      	cmp	r6, #2
34006dde:	d1de      	bne.n	34006d9e <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xa>
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
34006de0:	682a      	ldr	r2, [r5, #0]
34006de2:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34006de6:	f023 030f 	bic.w	r3, r3, #15
34006dea:	4323      	orrs	r3, r4
34006dec:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34006df0:	e7ef      	b.n	34006dd2 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x3e>
34006df2:	bf00      	nop
34006df4:	3401c2dc 	.word	0x3401c2dc

34006df8 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006df8:	2902      	cmp	r1, #2
{
34006dfa:	b538      	push	{r3, r4, r5, lr}
34006dfc:	4604      	mov	r4, r0
34006dfe:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e00:	d904      	bls.n	34006e0c <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x14>
34006e02:	f641 1139 	movw	r1, #6457	@ 0x1939
34006e06:	480f      	ldr	r0, [pc, #60]	@ (34006e44 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x4c>)
34006e08:	f7fb fb94 	bl	34002534 <assert_failed>
  if (hdcmipp == NULL)
34006e0c:	b1bc      	cbz	r4, 34006e3e <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x46>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006e0e:	7923      	ldrb	r3, [r4, #4]
34006e10:	2b02      	cmp	r3, #2
34006e12:	d108      	bne.n	34006e26 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x2e>
    if (Pipe == DCMIPP_PIPE1)
34006e14:	2d01      	cmp	r5, #1
34006e16:	d108      	bne.n	34006e2a <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x32>
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34006e18:	6822      	ldr	r2, [r4, #0]
34006e1a:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34006e1e:	f043 0310 	orr.w	r3, r3, #16
34006e22:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34006e26:	2000      	movs	r0, #0
}
34006e28:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE2)
34006e2a:	2d02      	cmp	r5, #2
34006e2c:	d107      	bne.n	34006e3e <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x46>
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34006e2e:	6822      	ldr	r2, [r4, #0]
34006e30:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34006e34:	f043 0310 	orr.w	r3, r3, #16
34006e38:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34006e3c:	e7f3      	b.n	34006e26 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x2e>
    return HAL_ERROR;
34006e3e:	2001      	movs	r0, #1
34006e40:	e7f2      	b.n	34006e28 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x30>
34006e42:	bf00      	nop
34006e44:	3401c2dc 	.word	0x3401c2dc

34006e48 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e48:	2902      	cmp	r1, #2
{
34006e4a:	b538      	push	{r3, r4, r5, lr}
34006e4c:	4604      	mov	r4, r0
34006e4e:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e50:	d904      	bls.n	34006e5c <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x14>
34006e52:	f641 115b 	movw	r1, #6491	@ 0x195b
34006e56:	480f      	ldr	r0, [pc, #60]	@ (34006e94 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x4c>)
34006e58:	f7fb fb6c 	bl	34002534 <assert_failed>
  if (hdcmipp == NULL)
34006e5c:	b1bc      	cbz	r4, 34006e8e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x46>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006e5e:	7923      	ldrb	r3, [r4, #4]
34006e60:	2b02      	cmp	r3, #2
34006e62:	d108      	bne.n	34006e76 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x2e>
    if (Pipe == DCMIPP_PIPE1)
34006e64:	2d01      	cmp	r5, #1
34006e66:	d108      	bne.n	34006e7a <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x32>
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34006e68:	6822      	ldr	r2, [r4, #0]
34006e6a:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34006e6e:	f023 0310 	bic.w	r3, r3, #16
34006e72:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34006e76:	2000      	movs	r0, #0
}
34006e78:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE2)
34006e7a:	2d02      	cmp	r5, #2
34006e7c:	d107      	bne.n	34006e8e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x46>
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34006e7e:	6822      	ldr	r2, [r4, #0]
34006e80:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34006e84:	f023 0310 	bic.w	r3, r3, #16
34006e88:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34006e8c:	e7f3      	b.n	34006e76 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x2e>
    return HAL_ERROR;
34006e8e:	2001      	movs	r0, #1
34006e90:	e7f2      	b.n	34006e78 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x30>
34006e92:	bf00      	nop
34006e94:	3401c2dc 	.word	0x3401c2dc

34006e98 <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e98:	2902      	cmp	r1, #2
{
34006e9a:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e9c:	d906      	bls.n	34006eac <HAL_DCMIPP_PIPE_CSI_EnableShare+0x14>
34006e9e:	f641 217d 	movw	r1, #6781	@ 0x1a7d
34006ea2:	480a      	ldr	r0, [pc, #40]	@ (34006ecc <HAL_DCMIPP_PIPE_CSI_EnableShare+0x34>)
34006ea4:	f7fb fb46 	bl	34002534 <assert_failed>
      return HAL_ERROR;
34006ea8:	2001      	movs	r0, #1
}
34006eaa:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE2)
34006eac:	d1fc      	bne.n	34006ea8 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x10>
    tmp1 = hdcmipp->Instance->P2FSCR;
34006eae:	6803      	ldr	r3, [r0, #0]
34006eb0:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
    tmp2 = hdcmipp->Instance->P1FSCR;
34006eb4:	f8d3 1804 	ldr.w	r1, [r3, #2052]	@ 0x804
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
34006eb8:	430a      	orrs	r2, r1
34006eba:	d4f5      	bmi.n	34006ea8 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x10>
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34006ebc:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
34006ec0:	2000      	movs	r0, #0
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34006ec2:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34006ec6:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
34006eca:	e7ee      	b.n	34006eaa <HAL_DCMIPP_PIPE_CSI_EnableShare+0x12>
34006ecc:	3401c2dc 	.word	0x3401c2dc

34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
{
34006ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34006ed2:	460e      	mov	r6, r1
34006ed4:	4615      	mov	r5, r2
34006ed6:	461c      	mov	r4, r3
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006ed8:	4607      	mov	r7, r0
34006eda:	b908      	cbnz	r0, 34006ee0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x10>
    return HAL_ERROR;
34006edc:	2001      	movs	r0, #1
}
34006ede:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006ee0:	2b00      	cmp	r3, #0
34006ee2:	d0fb      	beq.n	34006edc <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ee4:	2902      	cmp	r1, #2
34006ee6:	d904      	bls.n	34006ef2 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x22>
34006ee8:	f44f 51e0 	mov.w	r1, #7168	@ 0x1c00
34006eec:	4810      	ldr	r0, [pc, #64]	@ (34006f30 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x60>)
34006eee:	f7fb fb21 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
34006ef2:	1e6b      	subs	r3, r5, #1
34006ef4:	2b02      	cmp	r3, #2
34006ef6:	d908      	bls.n	34006f0a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x3a>
34006ef8:	f641 4101 	movw	r1, #7169	@ 0x1c01
34006efc:	480c      	ldr	r0, [pc, #48]	@ (34006f30 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x60>)
34006efe:	f7fb fb19 	bl	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006f02:	2e01      	cmp	r6, #1
34006f04:	d1ea      	bne.n	34006edc <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
  return HAL_OK;
34006f06:	2000      	movs	r0, #0
34006f08:	e7e9      	b.n	34006ede <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xe>
  if (Pipe == DCMIPP_PIPE1)
34006f0a:	2e01      	cmp	r6, #1
34006f0c:	d1e6      	bne.n	34006edc <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
    switch (ModuleID)
34006f0e:	2d02      	cmp	r5, #2
34006f10:	683b      	ldr	r3, [r7, #0]
34006f12:	d007      	beq.n	34006f24 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x54>
34006f14:	2d03      	cmp	r5, #3
34006f16:	d008      	beq.n	34006f2a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x5a>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34006f18:	f8d3 3864 	ldr.w	r3, [r3, #2148]	@ 0x864
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34006f1c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34006f20:	6023      	str	r3, [r4, #0]
        break;
34006f22:	e7f0      	b.n	34006f06 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x36>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34006f24:	f8d3 3868 	ldr.w	r3, [r3, #2152]	@ 0x868
34006f28:	e7f8      	b.n	34006f1c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
34006f2a:	f8d3 386c 	ldr.w	r3, [r3, #2156]	@ 0x86c
34006f2e:	e7f5      	b.n	34006f1c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
34006f30:	3401c2dc 	.word	0x3401c2dc

34006f34 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f34:	2902      	cmp	r1, #2
{
34006f36:	b470      	push	{r4, r5, r6}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f38:	d905      	bls.n	34006f46 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x12>
}
34006f3a:	bc70      	pop	{r4, r5, r6}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f3c:	f641 511f 	movw	r1, #7455	@ 0x1d1f
34006f40:	484a      	ldr	r0, [pc, #296]	@ (3400706c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x138>)
34006f42:	f7fb baf7 	b.w	34002534 <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006f46:	2901      	cmp	r1, #1
34006f48:	f040 808d 	bne.w	34007066 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x132>
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
34006f4c:	6803      	ldr	r3, [r0, #0]
34006f4e:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                                                 ? ENABLE : DISABLE;
34006f52:	f3c1 0080 	ubfx	r0, r1, #2, #1
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34006f56:	f001 0102 	and.w	r1, r1, #2
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
34006f5a:	7010      	strb	r0, [r2, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34006f5c:	7051      	strb	r1, [r2, #1]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34006f5e:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34006f62:	4943      	ldr	r1, [pc, #268]	@ (34007070 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x13c>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34006f64:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34006f68:	ea40 0501 	orr.w	r5, r0, r1
34006f6c:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34006f70:	bf18      	it	ne
34006f72:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
34006f74:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34006f78:	8090      	strh	r0, [r2, #4]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
34006f7a:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34006f7e:	ea40 0501 	orr.w	r5, r0, r1
34006f82:	f414 6f80 	tst.w	r4, #1024	@ 0x400
34006f86:	bf18      	it	ne
34006f88:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34006f8a:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34006f8e:	8050      	strh	r0, [r2, #2]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34006f90:	4838      	ldr	r0, [pc, #224]	@ (34007074 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x140>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34006f92:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34006f96:	ea44 0600 	orr.w	r6, r4, r0
34006f9a:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34006f9e:	bf18      	it	ne
34006fa0:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34006fa2:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34006fa6:	8114      	strh	r4, [r2, #8]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34006fa8:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34006fac:	ea44 0601 	orr.w	r6, r4, r1
34006fb0:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34006fb4:	bf18      	it	ne
34006fb6:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
34006fb8:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34006fbc:	80d4      	strh	r4, [r2, #6]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
34006fbe:	f3c5 440a 	ubfx	r4, r5, #16, #11
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34006fc2:	ea44 0601 	orr.w	r6, r4, r1
34006fc6:	f015 6f80 	tst.w	r5, #67108864	@ 0x4000000
34006fca:	bf18      	it	ne
34006fcc:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
34006fce:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34006fd2:	8194      	strh	r4, [r2, #12]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
34006fd4:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34006fd8:	ea44 0601 	orr.w	r6, r4, r1
34006fdc:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34006fe0:	bf18      	it	ne
34006fe2:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34006fe4:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34006fe8:	8154      	strh	r4, [r2, #10]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34006fea:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34006fee:	ea44 0600 	orr.w	r6, r4, r0
34006ff2:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34006ff6:	bf18      	it	ne
34006ff8:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34006ffa:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34006ffe:	8214      	strh	r4, [r2, #16]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34007000:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007004:	ea44 0601 	orr.w	r6, r4, r1
34007008:	f415 6f80 	tst.w	r5, #1024	@ 0x400
3400700c:	bf18      	it	ne
3400700e:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
34007010:	f8d3 5898 	ldr.w	r5, [r3, #2200]	@ 0x898
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007014:	81d4      	strh	r4, [r2, #14]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
34007016:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
3400701a:	4320      	orrs	r0, r4
3400701c:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34007020:	bf18      	it	ne
34007022:	4604      	movne	r4, r0
34007024:	8314      	strh	r4, [r2, #24]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
34007026:	f8d3 4898 	ldr.w	r4, [r3, #2200]	@ 0x898
3400702a:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
3400702e:	ea40 0501 	orr.w	r5, r0, r1
34007032:	f414 6f80 	tst.w	r4, #1024	@ 0x400
34007036:	bf18      	it	ne
34007038:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
3400703a:	f8d3 4894 	ldr.w	r4, [r3, #2196]	@ 0x894
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
3400703e:	82d0      	strh	r0, [r2, #22]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34007040:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
34007044:	ea40 0501 	orr.w	r5, r0, r1
34007048:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
3400704c:	bf18      	it	ne
3400704e:	4628      	movne	r0, r5
34007050:	8290      	strh	r0, [r2, #20]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
34007052:	f8d3 0894 	ldr.w	r0, [r3, #2196]	@ 0x894
34007056:	f3c0 030a 	ubfx	r3, r0, #0, #11
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
3400705a:	4319      	orrs	r1, r3
3400705c:	f410 6f80 	tst.w	r0, #1024	@ 0x400
34007060:	bf18      	it	ne
34007062:	460b      	movne	r3, r1
34007064:	8253      	strh	r3, [r2, #18]
}
34007066:	bc70      	pop	{r4, r5, r6}
34007068:	4770      	bx	lr
3400706a:	bf00      	nop
3400706c:	3401c2dc 	.word	0x3401c2dc
34007070:	fffff800 	.word	0xfffff800
34007074:	fffffc00 	.word	0xfffffc00

34007078 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
{
34007078:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
3400707a:	4a10      	ldr	r2, [pc, #64]	@ (340070bc <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x44>)
3400707c:	6803      	ldr	r3, [r0, #0]
{
3400707e:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34007080:	4293      	cmp	r3, r2
{
34007082:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34007084:	d008      	beq.n	34007098 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x20>
34007086:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400708a:	4293      	cmp	r3, r2
3400708c:	d004      	beq.n	34007098 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x20>
3400708e:	f641 51c7 	movw	r1, #7623	@ 0x1dc7
34007092:	480b      	ldr	r0, [pc, #44]	@ (340070c0 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x48>)
34007094:	f7fb fa4e 	bl	34002534 <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007098:	2d02      	cmp	r5, #2
3400709a:	d906      	bls.n	340070aa <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x32>
3400709c:	f641 51c8 	movw	r1, #7624	@ 0x1dc8
340070a0:	4807      	ldr	r0, [pc, #28]	@ (340070c0 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x48>)
340070a2:	f7fb fa47 	bl	34002534 <assert_failed>
    return 0;
340070a6:	2000      	movs	r0, #0
}
340070a8:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
340070aa:	2d01      	cmp	r5, #1
340070ac:	d1fb      	bne.n	340070a6 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
340070ae:	6823      	ldr	r3, [r4, #0]
340070b0:	f8d3 0880 	ldr.w	r0, [r3, #2176]	@ 0x880
340070b4:	f000 0001 	and.w	r0, r0, #1
340070b8:	e7f6      	b.n	340070a8 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x30>
340070ba:	bf00      	nop
340070bc:	58002000 	.word	0x58002000
340070c0:	3401c2dc 	.word	0x3401c2dc

340070c4 <HAL_DCMIPP_GetState>:
  return hdcmipp->State;
340070c4:	7900      	ldrb	r0, [r0, #4]
}
340070c6:	4770      	bx	lr

340070c8 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
340070c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
340070ca:	6804      	ldr	r4, [r0, #0]
340070cc:	9d05      	ldr	r5, [sp, #20]
340070ce:	6c66      	ldr	r6, [r4, #68]	@ 0x44
340070d0:	ea45 4503 	orr.w	r5, r5, r3, lsl #16

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
340070d4:	6843      	ldr	r3, [r0, #4]
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
340070d6:	f006 4640 	and.w	r6, r6, #3221225472	@ 0xc0000000
340070da:	4335      	orrs	r5, r6
  if (hdma2d->Init.Mode == DMA2D_R2M)
340070dc:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
340070e0:	6465      	str	r5, [r4, #68]	@ 0x44
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
340070e2:	63e2      	str	r2, [r4, #60]	@ 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
340070e4:	d12f      	bne.n	34007146 <DMA2D_SetConfig+0x7e>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
340070e6:	6880      	ldr	r0, [r0, #8]
340070e8:	f001 467f 	and.w	r6, r1, #4278190080	@ 0xff000000
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
340070ec:	f401 037f 	and.w	r3, r1, #16711680	@ 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
340070f0:	f401 427f 	and.w	r2, r1, #65280	@ 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
340070f4:	b2cd      	uxtb	r5, r1

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
340070f6:	2803      	cmp	r0, #3
340070f8:	d81a      	bhi.n	34007130 <DMA2D_SetConfig+0x68>
340070fa:	e8df f000 	tbb	[pc, r0]
340070fe:	0204      	.short	0x0204
34007100:	0e06      	.short	0x0e06
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
    {
      tmp = (tmp3 | tmp2 | tmp4);
34007102:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
      tmp3 = (tmp3 >> 12U);
      tmp4 = (tmp4 >> 4U);
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
34007106:	63a1      	str	r1, [r4, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
34007108:	bdf0      	pop	{r4, r5, r6, r7, pc}
      tmp2 = (tmp2 >> 19U);
3400710a:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10U);
3400710c:	0a92      	lsrs	r2, r2, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
3400710e:	02c9      	lsls	r1, r1, #11
34007110:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
34007114:	ea41 01d5 	orr.w	r1, r1, r5, lsr #3
34007118:	e7f5      	b.n	34007106 <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 19U);
3400711a:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11U);
3400711c:	0ad2      	lsrs	r2, r2, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
3400711e:	029b      	lsls	r3, r3, #10
34007120:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
34007124:	ea43 03d5 	orr.w	r3, r3, r5, lsr #3
      tmp1 = (tmp1 >> 31U);
34007128:	0ff1      	lsrs	r1, r6, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
3400712a:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
3400712e:	e7ea      	b.n	34007106 <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 20U);
34007130:	0d1b      	lsrs	r3, r3, #20
      tmp3 = (tmp3 >> 12U);
34007132:	0b12      	lsrs	r2, r2, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34007134:	021b      	lsls	r3, r3, #8
34007136:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
3400713a:	ea43 1315 	orr.w	r3, r3, r5, lsr #4
      tmp1 = (tmp1 >> 28U);
3400713e:	0f36      	lsrs	r6, r6, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34007140:	ea43 3106 	orr.w	r1, r3, r6, lsl #12
34007144:	e7df      	b.n	34007106 <DMA2D_SetConfig+0x3e>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
34007146:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
3400714a:	bf0c      	ite	eq
3400714c:	6161      	streq	r1, [r4, #20]
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
3400714e:	60e1      	strne	r1, [r4, #12]
}
34007150:	e7da      	b.n	34007108 <DMA2D_SetConfig+0x40>

34007152 <HAL_DMA2D_MspInit>:
}
34007152:	4770      	bx	lr

34007154 <HAL_DMA2D_Init>:
{
34007154:	b510      	push	{r4, lr}
  if (hdma2d == NULL)
34007156:	4604      	mov	r4, r0
34007158:	2800      	cmp	r0, #0
3400715a:	d07d      	beq.n	34007258 <HAL_DMA2D_Init+0x104>
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
3400715c:	6803      	ldr	r3, [r0, #0]
3400715e:	4a3f      	ldr	r2, [pc, #252]	@ (3400725c <HAL_DMA2D_Init+0x108>)
34007160:	4293      	cmp	r3, r2
34007162:	d007      	beq.n	34007174 <HAL_DMA2D_Init+0x20>
34007164:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007168:	4293      	cmp	r3, r2
3400716a:	d003      	beq.n	34007174 <HAL_DMA2D_Init+0x20>
3400716c:	21f7      	movs	r1, #247	@ 0xf7
3400716e:	483c      	ldr	r0, [pc, #240]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
34007170:	f7fb f9e0 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
34007174:	6863      	ldr	r3, [r4, #4]
34007176:	f433 3240 	bics.w	r2, r3, #196608	@ 0x30000
3400717a:	d008      	beq.n	3400718e <HAL_DMA2D_Init+0x3a>
3400717c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34007180:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34007184:	d003      	beq.n	3400718e <HAL_DMA2D_Init+0x3a>
34007186:	21f8      	movs	r1, #248	@ 0xf8
34007188:	4835      	ldr	r0, [pc, #212]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
3400718a:	f7fb f9d3 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
3400718e:	68a3      	ldr	r3, [r4, #8]
34007190:	2b04      	cmp	r3, #4
34007192:	d903      	bls.n	3400719c <HAL_DMA2D_Init+0x48>
34007194:	21f9      	movs	r1, #249	@ 0xf9
34007196:	4832      	ldr	r0, [pc, #200]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
34007198:	f7fb f9cc 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
3400719c:	68e3      	ldr	r3, [r4, #12]
3400719e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340071a2:	d303      	bcc.n	340071ac <HAL_DMA2D_Init+0x58>
340071a4:	21fa      	movs	r1, #250	@ 0xfa
340071a6:	482e      	ldr	r0, [pc, #184]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
340071a8:	f7fb f9c4 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->Init.AlphaInverted));
340071ac:	6923      	ldr	r3, [r4, #16]
340071ae:	2b01      	cmp	r3, #1
340071b0:	d903      	bls.n	340071ba <HAL_DMA2D_Init+0x66>
340071b2:	21fb      	movs	r1, #251	@ 0xfb
340071b4:	482a      	ldr	r0, [pc, #168]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
340071b6:	f7fb f9bd 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->Init.RedBlueSwap));
340071ba:	6963      	ldr	r3, [r4, #20]
340071bc:	2b01      	cmp	r3, #1
340071be:	d903      	bls.n	340071c8 <HAL_DMA2D_Init+0x74>
340071c0:	21fc      	movs	r1, #252	@ 0xfc
340071c2:	4827      	ldr	r0, [pc, #156]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
340071c4:	f7fb f9b6 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_LOM_MODE(hdma2d->Init.LineOffsetMode));
340071c8:	69e3      	ldr	r3, [r4, #28]
340071ca:	f033 0340 	bics.w	r3, r3, #64	@ 0x40
340071ce:	d003      	beq.n	340071d8 <HAL_DMA2D_Init+0x84>
340071d0:	21fd      	movs	r1, #253	@ 0xfd
340071d2:	4823      	ldr	r0, [pc, #140]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
340071d4:	f7fb f9ae 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_BYTES_SWAP(hdma2d->Init.BytesSwap));
340071d8:	69a3      	ldr	r3, [r4, #24]
340071da:	f433 7380 	bics.w	r3, r3, #256	@ 0x100
340071de:	d003      	beq.n	340071e8 <HAL_DMA2D_Init+0x94>
340071e0:	21fe      	movs	r1, #254	@ 0xfe
340071e2:	481f      	ldr	r0, [pc, #124]	@ (34007260 <HAL_DMA2D_Init+0x10c>)
340071e4:	f7fb f9a6 	bl	34002534 <assert_failed>
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
340071e8:	f894 3061 	ldrb.w	r3, [r4, #97]	@ 0x61
340071ec:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
340071f0:	b923      	cbnz	r3, 340071fc <HAL_DMA2D_Init+0xa8>
    HAL_DMA2D_MspInit(hdma2d);
340071f2:	4620      	mov	r0, r4
    hdma2d->Lock = HAL_UNLOCKED;
340071f4:	f884 2060 	strb.w	r2, [r4, #96]	@ 0x60
    HAL_DMA2D_MspInit(hdma2d);
340071f8:	f7ff ffab 	bl	34007152 <HAL_DMA2D_MspInit>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
340071fc:	2302      	movs	r3, #2
340071fe:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34007202:	6823      	ldr	r3, [r4, #0]
34007204:	69e0      	ldr	r0, [r4, #28]
34007206:	6819      	ldr	r1, [r3, #0]
34007208:	6862      	ldr	r2, [r4, #4]
3400720a:	f421 21e0 	bic.w	r1, r1, #458752	@ 0x70000
3400720e:	4302      	orrs	r2, r0
34007210:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
34007214:	430a      	orrs	r2, r1
34007216:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
34007218:	6b59      	ldr	r1, [r3, #52]	@ 0x34
3400721a:	69a0      	ldr	r0, [r4, #24]
3400721c:	68a2      	ldr	r2, [r4, #8]
3400721e:	f421 7183 	bic.w	r1, r1, #262	@ 0x106
34007222:	4302      	orrs	r2, r0
34007224:	f021 0101 	bic.w	r1, r1, #1
34007228:	430a      	orrs	r2, r1
3400722a:	635a      	str	r2, [r3, #52]	@ 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
3400722c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400722e:	68e1      	ldr	r1, [r4, #12]
34007230:	f36f 020f 	bfc	r2, #0, #16
34007234:	430a      	orrs	r2, r1
34007236:	641a      	str	r2, [r3, #64]	@ 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
34007238:	6b59      	ldr	r1, [r3, #52]	@ 0x34
3400723a:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
3400723e:	0552      	lsls	r2, r2, #21
34007240:	ea42 5200 	orr.w	r2, r2, r0, lsl #20
34007244:	f421 1140 	bic.w	r1, r1, #3145728	@ 0x300000
34007248:	430a      	orrs	r2, r1
3400724a:	635a      	str	r2, [r3, #52]	@ 0x34
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
3400724c:	2000      	movs	r0, #0
  hdma2d->State  = HAL_DMA2D_STATE_READY;
3400724e:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34007250:	6660      	str	r0, [r4, #100]	@ 0x64
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34007252:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
}
34007256:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34007258:	2001      	movs	r0, #1
3400725a:	e7fc      	b.n	34007256 <HAL_DMA2D_Init+0x102>
3400725c:	58021000 	.word	0x58021000
34007260:	3401c34d 	.word	0x3401c34d

34007264 <HAL_DMA2D_Start>:
{
34007264:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
34007268:	f8dd 8020 	ldr.w	r8, [sp, #32]
3400726c:	4604      	mov	r4, r0
  assert_param(IS_DMA2D_LINE(Height));
3400726e:	f5b8 3f80 	cmp.w	r8, #65536	@ 0x10000
{
34007272:	460e      	mov	r6, r1
34007274:	4617      	mov	r7, r2
34007276:	461d      	mov	r5, r3
  assert_param(IS_DMA2D_LINE(Height));
34007278:	d304      	bcc.n	34007284 <HAL_DMA2D_Start+0x20>
3400727a:	f240 21a9 	movw	r1, #681	@ 0x2a9
3400727e:	4813      	ldr	r0, [pc, #76]	@ (340072cc <HAL_DMA2D_Start+0x68>)
34007280:	f7fb f958 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_PIXEL(Width));
34007284:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
34007288:	d304      	bcc.n	34007294 <HAL_DMA2D_Start+0x30>
3400728a:	f240 21aa 	movw	r1, #682	@ 0x2aa
3400728e:	480f      	ldr	r0, [pc, #60]	@ (340072cc <HAL_DMA2D_Start+0x68>)
34007290:	f7fb f950 	bl	34002534 <assert_failed>
  __HAL_LOCK(hdma2d);
34007294:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34007298:	2002      	movs	r0, #2
3400729a:	2b01      	cmp	r3, #1
3400729c:	d012      	beq.n	340072c4 <HAL_DMA2D_Start+0x60>
3400729e:	2301      	movs	r3, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
340072a0:	f884 0061 	strb.w	r0, [r4, #97]	@ 0x61
  __HAL_LOCK(hdma2d);
340072a4:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
340072a8:	463a      	mov	r2, r7
340072aa:	462b      	mov	r3, r5
340072ac:	4620      	mov	r0, r4
340072ae:	4631      	mov	r1, r6
340072b0:	f8cd 8000 	str.w	r8, [sp]
340072b4:	f7ff ff08 	bl	340070c8 <DMA2D_SetConfig>
  return HAL_OK;
340072b8:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
340072ba:	6822      	ldr	r2, [r4, #0]
340072bc:	6813      	ldr	r3, [r2, #0]
340072be:	f043 0301 	orr.w	r3, r3, #1
340072c2:	6013      	str	r3, [r2, #0]
}
340072c4:	b002      	add	sp, #8
340072c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
340072ca:	bf00      	nop
340072cc:	3401c34d 	.word	0x3401c34d

340072d0 <HAL_DMA2D_PollForTransfer>:
  __IO uint32_t isrflags = 0x0U;
340072d0:	2300      	movs	r3, #0
{
340072d2:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
340072d4:	9301      	str	r3, [sp, #4]
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
340072d6:	6803      	ldr	r3, [r0, #0]
{
340072d8:	4604      	mov	r4, r0
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
340072da:	681b      	ldr	r3, [r3, #0]
{
340072dc:	460d      	mov	r5, r1
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
340072de:	07db      	lsls	r3, r3, #31
340072e0:	d418      	bmi.n	34007314 <HAL_DMA2D_PollForTransfer+0x44>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
340072e2:	6822      	ldr	r2, [r4, #0]
340072e4:	69d3      	ldr	r3, [r2, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
340072e6:	6a52      	ldr	r2, [r2, #36]	@ 0x24
340072e8:	4313      	orrs	r3, r2
  if (layer_start != 0U)
340072ea:	069e      	lsls	r6, r3, #26
340072ec:	d506      	bpl.n	340072fc <HAL_DMA2D_PollForTransfer+0x2c>
    tickstart = HAL_GetTick();
340072ee:	f7fd fa8d 	bl	3400480c <HAL_GetTick>
340072f2:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
340072f4:	6823      	ldr	r3, [r4, #0]
340072f6:	685a      	ldr	r2, [r3, #4]
340072f8:	06d2      	lsls	r2, r2, #27
340072fa:	d53f      	bpl.n	3400737c <HAL_DMA2D_PollForTransfer+0xac>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
340072fc:	2212      	movs	r2, #18
340072fe:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
34007300:	2000      	movs	r0, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34007302:	609a      	str	r2, [r3, #8]
  hdma2d->State = HAL_DMA2D_STATE_READY;
34007304:	2301      	movs	r3, #1
34007306:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        __HAL_UNLOCK(hdma2d);
3400730a:	2300      	movs	r3, #0
3400730c:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
}
34007310:	b002      	add	sp, #8
34007312:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick();
34007314:	f7fd fa7a 	bl	3400480c <HAL_GetTick>
34007318:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
3400731a:	6823      	ldr	r3, [r4, #0]
3400731c:	685a      	ldr	r2, [r3, #4]
3400731e:	0792      	lsls	r2, r2, #30
34007320:	d4df      	bmi.n	340072e2 <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34007322:	685a      	ldr	r2, [r3, #4]
34007324:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34007326:	9a01      	ldr	r2, [sp, #4]
34007328:	f012 0f21 	tst.w	r2, #33	@ 0x21
3400732c:	d014      	beq.n	34007358 <HAL_DMA2D_PollForTransfer+0x88>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
3400732e:	9a01      	ldr	r2, [sp, #4]
34007330:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34007332:	bf42      	ittt	mi
34007334:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007336:	f042 0202 	orrmi.w	r2, r2, #2
3400733a:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
3400733c:	9a01      	ldr	r2, [sp, #4]
3400733e:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34007340:	bf42      	ittt	mi
34007342:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007344:	f042 0201 	orrmi.w	r2, r2, #1
34007348:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3400734a:	2221      	movs	r2, #33	@ 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3400734c:	609a      	str	r2, [r3, #8]
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
3400734e:	2304      	movs	r3, #4
        return HAL_ERROR;
34007350:	2001      	movs	r0, #1
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34007352:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        return HAL_ERROR;
34007356:	e7d8      	b.n	3400730a <HAL_DMA2D_PollForTransfer+0x3a>
      if (Timeout != HAL_MAX_DELAY)
34007358:	1c69      	adds	r1, r5, #1
3400735a:	d0df      	beq.n	3400731c <HAL_DMA2D_PollForTransfer+0x4c>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3400735c:	f7fd fa56 	bl	3400480c <HAL_GetTick>
34007360:	1b80      	subs	r0, r0, r6
34007362:	42a8      	cmp	r0, r5
34007364:	d801      	bhi.n	3400736a <HAL_DMA2D_PollForTransfer+0x9a>
34007366:	2d00      	cmp	r5, #0
34007368:	d1d7      	bne.n	3400731a <HAL_DMA2D_PollForTransfer+0x4a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
3400736a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
          return HAL_TIMEOUT;
3400736c:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
3400736e:	f043 0320 	orr.w	r3, r3, #32
34007372:	6663      	str	r3, [r4, #100]	@ 0x64
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34007374:	2303      	movs	r3, #3
34007376:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
          return HAL_TIMEOUT;
3400737a:	e7c6      	b.n	3400730a <HAL_DMA2D_PollForTransfer+0x3a>
      isrflags = READ_REG(hdma2d->Instance->ISR);
3400737c:	685a      	ldr	r2, [r3, #4]
3400737e:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34007380:	9a01      	ldr	r2, [sp, #4]
34007382:	f012 0f29 	tst.w	r2, #41	@ 0x29
34007386:	d016      	beq.n	340073b6 <HAL_DMA2D_PollForTransfer+0xe6>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34007388:	9a01      	ldr	r2, [sp, #4]
3400738a:	0716      	lsls	r6, r2, #28
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
3400738c:	bf42      	ittt	mi
3400738e:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007390:	f042 0204 	orrmi.w	r2, r2, #4
34007394:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34007396:	9a01      	ldr	r2, [sp, #4]
34007398:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
3400739a:	bf42      	ittt	mi
3400739c:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
3400739e:	f042 0202 	orrmi.w	r2, r2, #2
340073a2:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
340073a4:	9a01      	ldr	r2, [sp, #4]
340073a6:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
340073a8:	bf42      	ittt	mi
340073aa:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
340073ac:	f042 0201 	orrmi.w	r2, r2, #1
340073b0:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
340073b2:	2229      	movs	r2, #41	@ 0x29
340073b4:	e7ca      	b.n	3400734c <HAL_DMA2D_PollForTransfer+0x7c>
      if (Timeout != HAL_MAX_DELAY)
340073b6:	1c69      	adds	r1, r5, #1
340073b8:	d09d      	beq.n	340072f6 <HAL_DMA2D_PollForTransfer+0x26>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
340073ba:	f7fd fa27 	bl	3400480c <HAL_GetTick>
340073be:	1b80      	subs	r0, r0, r6
340073c0:	42a8      	cmp	r0, r5
340073c2:	d8d2      	bhi.n	3400736a <HAL_DMA2D_PollForTransfer+0x9a>
340073c4:	2d00      	cmp	r5, #0
340073c6:	d195      	bne.n	340072f4 <HAL_DMA2D_PollForTransfer+0x24>
340073c8:	e7cf      	b.n	3400736a <HAL_DMA2D_PollForTransfer+0x9a>
	...

340073cc <HAL_DMA2D_ConfigLayer>:
  assert_param(IS_DMA2D_LAYER(LayerIdx));
340073cc:	2901      	cmp	r1, #1
{
340073ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340073d0:	4604      	mov	r4, r0
340073d2:	460d      	mov	r5, r1
  assert_param(IS_DMA2D_LAYER(LayerIdx));
340073d4:	d904      	bls.n	340073e0 <HAL_DMA2D_ConfigLayer+0x14>
340073d6:	f240 61f3 	movw	r1, #1779	@ 0x6f3
340073da:	4850      	ldr	r0, [pc, #320]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
340073dc:	f7fb f8aa 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
340073e0:	231c      	movs	r3, #28
340073e2:	fb03 4305 	mla	r3, r3, r5, r4
340073e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340073e8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340073ec:	d304      	bcc.n	340073f8 <HAL_DMA2D_ConfigLayer+0x2c>
340073ee:	f240 61f4 	movw	r1, #1780	@ 0x6f4
340073f2:	484a      	ldr	r0, [pc, #296]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
340073f4:	f7fb f89e 	bl	34002534 <assert_failed>
  if (hdma2d->Init.Mode != DMA2D_R2M)
340073f8:	6863      	ldr	r3, [r4, #4]
340073fa:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340073fe:	d017      	beq.n	34007430 <HAL_DMA2D_ConfigLayer+0x64>
    assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
34007400:	231c      	movs	r3, #28
34007402:	fb03 4305 	mla	r3, r3, r5, r4
34007406:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34007408:	2b0b      	cmp	r3, #11
3400740a:	d904      	bls.n	34007416 <HAL_DMA2D_ConfigLayer+0x4a>
3400740c:	f240 61f7 	movw	r1, #1783	@ 0x6f7
34007410:	4842      	ldr	r0, [pc, #264]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
34007412:	f7fb f88f 	bl	34002534 <assert_failed>
    if (hdma2d->Init.Mode != DMA2D_M2M)
34007416:	6863      	ldr	r3, [r4, #4]
34007418:	b153      	cbz	r3, 34007430 <HAL_DMA2D_ConfigLayer+0x64>
      assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
3400741a:	231c      	movs	r3, #28
3400741c:	fb03 4305 	mla	r3, r3, r5, r4
34007420:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007422:	2b02      	cmp	r3, #2
34007424:	d904      	bls.n	34007430 <HAL_DMA2D_ConfigLayer+0x64>
34007426:	f240 61fa 	movw	r1, #1786	@ 0x6fa
3400742a:	483c      	ldr	r0, [pc, #240]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
3400742c:	f7fb f882 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
34007430:	261c      	movs	r6, #28
34007432:	fb06 4305 	mla	r3, r6, r5, r4
34007436:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34007438:	2b01      	cmp	r3, #1
3400743a:	d904      	bls.n	34007446 <HAL_DMA2D_ConfigLayer+0x7a>
3400743c:	f240 61fd 	movw	r1, #1789	@ 0x6fd
34007440:	4836      	ldr	r0, [pc, #216]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
34007442:	f7fb f877 	bl	34002534 <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
34007446:	fb06 4605 	mla	r6, r6, r5, r4
3400744a:	6bf3      	ldr	r3, [r6, #60]	@ 0x3c
3400744c:	2b01      	cmp	r3, #1
3400744e:	d904      	bls.n	3400745a <HAL_DMA2D_ConfigLayer+0x8e>
34007450:	f240 61fe 	movw	r1, #1790	@ 0x6fe
34007454:	4831      	ldr	r0, [pc, #196]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
34007456:	f7fb f86d 	bl	34002534 <assert_failed>
  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
3400745a:	2d01      	cmp	r5, #1
3400745c:	d10a      	bne.n	34007474 <HAL_DMA2D_ConfigLayer+0xa8>
3400745e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
34007460:	2b0b      	cmp	r3, #11
34007462:	d107      	bne.n	34007474 <HAL_DMA2D_ConfigLayer+0xa8>
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
34007464:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
34007466:	2b02      	cmp	r3, #2
34007468:	d904      	bls.n	34007474 <HAL_DMA2D_ConfigLayer+0xa8>
3400746a:	f240 7102 	movw	r1, #1794	@ 0x702
3400746e:	482b      	ldr	r0, [pc, #172]	@ (3400751c <HAL_DMA2D_ConfigLayer+0x150>)
34007470:	f7fb f860 	bl	34002534 <assert_failed>
  __HAL_LOCK(hdma2d);
34007474:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34007478:	2002      	movs	r0, #2
3400747a:	2b01      	cmp	r3, #1
3400747c:	d033      	beq.n	340074e6 <HAL_DMA2D_ConfigLayer+0x11a>
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400747e:	211c      	movs	r1, #28
  __HAL_LOCK(hdma2d);
34007480:	2301      	movs	r3, #1
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007482:	fb01 4105 	mla	r1, r1, r5, r4
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34007486:	f884 0061 	strb.w	r0, [r4, #97]	@ 0x61
  __HAL_LOCK(hdma2d);
3400748a:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
3400748e:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007490:	e9d1 620b 	ldrd	r6, r2, [r1, #44]	@ 0x2c
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007494:	051b      	lsls	r3, r3, #20
34007496:	6b4f      	ldr	r7, [r1, #52]	@ 0x34
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007498:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
3400749c:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400749e:	4333      	orrs	r3, r6
340074a0:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340074a4:	f1a6 0009 	sub.w	r0, r6, #9
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
340074a8:	f007 427f 	and.w	r2, r7, #4278190080	@ 0xff000000
340074ac:	431a      	orrs	r2, r3
340074ae:	2801      	cmp	r0, #1
340074b0:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
340074b4:	bf98      	it	ls
340074b6:	4613      	movls	r3, r2
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340074b8:	6822      	ldr	r2, [r4, #0]
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
340074ba:	b9ad      	cbnz	r5, 340074e8 <HAL_DMA2D_ConfigLayer+0x11c>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340074bc:	6a55      	ldr	r5, [r2, #36]	@ 0x24
340074be:	4918      	ldr	r1, [pc, #96]	@ (34007520 <HAL_DMA2D_ConfigLayer+0x154>)
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340074c0:	2801      	cmp	r0, #1
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340074c2:	ea01 0105 	and.w	r1, r1, r5
340074c6:	ea41 0103 	orr.w	r1, r1, r3
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
340074ca:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340074cc:	6251      	str	r1, [r2, #36]	@ 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
340074ce:	6193      	str	r3, [r2, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340074d0:	d803      	bhi.n	340074da <HAL_DMA2D_ConfigLayer+0x10e>
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
340074d2:	6b63      	ldr	r3, [r4, #52]	@ 0x34
340074d4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340074d8:	6293      	str	r3, [r2, #40]	@ 0x28
  hdma2d->State = HAL_DMA2D_STATE_READY;
340074da:	2301      	movs	r3, #1
  __HAL_UNLOCK(hdma2d);
340074dc:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
340074de:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  __HAL_UNLOCK(hdma2d);
340074e2:	f884 0060 	strb.w	r0, [r4, #96]	@ 0x60
}
340074e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
340074e8:	2e0b      	cmp	r6, #11
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
340074ea:	bf03      	ittte	eq
340074ec:	6c09      	ldreq	r1, [r1, #64]	@ 0x40
      regMask  |= DMA2D_FGPFCCR_CSS;
340074ee:	4e0d      	ldreq	r6, [pc, #52]	@ (34007524 <HAL_DMA2D_ConfigLayer+0x158>)
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
340074f0:	ea43 4381 	orreq.w	r3, r3, r1, lsl #18
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
340074f4:	4e0c      	ldrne	r6, [pc, #48]	@ (34007528 <HAL_DMA2D_ConfigLayer+0x15c>)
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
340074f6:	69d1      	ldr	r1, [r2, #28]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340074f8:	2801      	cmp	r0, #1
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
340074fa:	ea21 0106 	bic.w	r1, r1, r6
340074fe:	ea43 0301 	orr.w	r3, r3, r1
34007502:	61d3      	str	r3, [r2, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
34007504:	f04f 031c 	mov.w	r3, #28
34007508:	fb03 4505 	mla	r5, r3, r5, r4
3400750c:	6aab      	ldr	r3, [r5, #40]	@ 0x28
3400750e:	6113      	str	r3, [r2, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
34007510:	bf9e      	ittt	ls
34007512:	6b6b      	ldrls	r3, [r5, #52]	@ 0x34
34007514:	f023 437f 	bicls.w	r3, r3, #4278190080	@ 0xff000000
34007518:	6213      	strls	r3, [r2, #32]
3400751a:	e7de      	b.n	340074da <HAL_DMA2D_ConfigLayer+0x10e>
3400751c:	3401c34d 	.word	0x3401c34d
34007520:	00ccfff0 	.word	0x00ccfff0
34007524:	ff3f000f 	.word	0xff3f000f
34007528:	ff33000f 	.word	0xff33000f

3400752c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
3400752c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t temp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007530:	4b47      	ldr	r3, [pc, #284]	@ (34007650 <HAL_GPIO_Init+0x124>)
{
34007532:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007534:	4298      	cmp	r0, r3
{
34007536:	460e      	mov	r6, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007538:	d054      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
3400753a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400753e:	4298      	cmp	r0, r3
34007540:	d050      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007542:	4b44      	ldr	r3, [pc, #272]	@ (34007654 <HAL_GPIO_Init+0x128>)
34007544:	4298      	cmp	r0, r3
34007546:	d04d      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007548:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400754c:	4298      	cmp	r0, r3
3400754e:	d049      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007550:	4b41      	ldr	r3, [pc, #260]	@ (34007658 <HAL_GPIO_Init+0x12c>)
34007552:	4298      	cmp	r0, r3
34007554:	d046      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007556:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400755a:	4298      	cmp	r0, r3
3400755c:	d042      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
3400755e:	4b3f      	ldr	r3, [pc, #252]	@ (3400765c <HAL_GPIO_Init+0x130>)
34007560:	4298      	cmp	r0, r3
34007562:	d03f      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007564:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007568:	4298      	cmp	r0, r3
3400756a:	d03b      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
3400756c:	4b3c      	ldr	r3, [pc, #240]	@ (34007660 <HAL_GPIO_Init+0x134>)
3400756e:	4298      	cmp	r0, r3
34007570:	d038      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007572:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007576:	4298      	cmp	r0, r3
34007578:	d034      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
3400757a:	4b3a      	ldr	r3, [pc, #232]	@ (34007664 <HAL_GPIO_Init+0x138>)
3400757c:	4298      	cmp	r0, r3
3400757e:	d031      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007580:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007584:	4298      	cmp	r0, r3
34007586:	d02d      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007588:	4b37      	ldr	r3, [pc, #220]	@ (34007668 <HAL_GPIO_Init+0x13c>)
3400758a:	4298      	cmp	r0, r3
3400758c:	d02a      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
3400758e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007592:	4298      	cmp	r0, r3
34007594:	d026      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
34007596:	4b35      	ldr	r3, [pc, #212]	@ (3400766c <HAL_GPIO_Init+0x140>)
34007598:	4298      	cmp	r0, r3
3400759a:	d023      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
3400759c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340075a0:	4298      	cmp	r0, r3
340075a2:	d01f      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075a4:	4b32      	ldr	r3, [pc, #200]	@ (34007670 <HAL_GPIO_Init+0x144>)
340075a6:	4298      	cmp	r0, r3
340075a8:	d01c      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075aa:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340075ae:	4298      	cmp	r0, r3
340075b0:	d018      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075b2:	4b30      	ldr	r3, [pc, #192]	@ (34007674 <HAL_GPIO_Init+0x148>)
340075b4:	4298      	cmp	r0, r3
340075b6:	d015      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075b8:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340075bc:	4298      	cmp	r0, r3
340075be:	d011      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075c0:	4b2d      	ldr	r3, [pc, #180]	@ (34007678 <HAL_GPIO_Init+0x14c>)
340075c2:	4298      	cmp	r0, r3
340075c4:	d00e      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075c6:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340075ca:	4298      	cmp	r0, r3
340075cc:	d00a      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075ce:	4b2b      	ldr	r3, [pc, #172]	@ (3400767c <HAL_GPIO_Init+0x150>)
340075d0:	4298      	cmp	r0, r3
340075d2:	d007      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075d4:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340075d8:	4298      	cmp	r0, r3
340075da:	d003      	beq.n	340075e4 <HAL_GPIO_Init+0xb8>
340075dc:	21ad      	movs	r1, #173	@ 0xad
340075de:	4828      	ldr	r0, [pc, #160]	@ (34007680 <HAL_GPIO_Init+0x154>)
340075e0:	f7fa ffa8 	bl	34002534 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
340075e4:	6833      	ldr	r3, [r6, #0]
340075e6:	b29a      	uxth	r2, r3
340075e8:	b112      	cbz	r2, 340075f0 <HAL_GPIO_Init+0xc4>
340075ea:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340075ee:	d303      	bcc.n	340075f8 <HAL_GPIO_Init+0xcc>
340075f0:	21ae      	movs	r1, #174	@ 0xae
340075f2:	4823      	ldr	r0, [pc, #140]	@ (34007680 <HAL_GPIO_Init+0x154>)
340075f4:	f7fa ff9e 	bl	34002534 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
340075f8:	6873      	ldr	r3, [r6, #4]
340075fa:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
340075fe:	d011      	beq.n	34007624 <HAL_GPIO_Init+0xf8>
34007600:	d81d      	bhi.n	3400763e <HAL_GPIO_Init+0x112>
34007602:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
34007606:	d00d      	beq.n	34007624 <HAL_GPIO_Init+0xf8>
34007608:	d809      	bhi.n	3400761e <HAL_GPIO_Init+0xf2>
3400760a:	2b03      	cmp	r3, #3
3400760c:	d90a      	bls.n	34007624 <HAL_GPIO_Init+0xf8>
3400760e:	3b11      	subs	r3, #17
34007610:	2b01      	cmp	r3, #1
34007612:	d907      	bls.n	34007624 <HAL_GPIO_Init+0xf8>
34007614:	21af      	movs	r1, #175	@ 0xaf
34007616:	481a      	ldr	r0, [pc, #104]	@ (34007680 <HAL_GPIO_Init+0x154>)
34007618:	f7fa ff8c 	bl	34002534 <assert_failed>
3400761c:	e002      	b.n	34007624 <HAL_GPIO_Init+0xf8>
3400761e:	f5b3 1f90 	cmp.w	r3, #1179648	@ 0x120000
34007622:	d1f7      	bne.n	34007614 <HAL_GPIO_Init+0xe8>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = EXTI->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007624:	f04f 0900 	mov.w	r9, #0
34007628:	464f      	mov	r7, r9
3400762a:	f8df 8024 	ldr.w	r8, [pc, #36]	@ 34007650 <HAL_GPIO_Init+0x124>
        EXTI->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
3400762e:	f8df a054 	ldr.w	sl, [pc, #84]	@ 34007684 <HAL_GPIO_Init+0x158>
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34007632:	6835      	ldr	r5, [r6, #0]
34007634:	fa35 f307 	lsrs.w	r3, r5, r7
34007638:	d126      	bne.n	34007688 <HAL_GPIO_Init+0x15c>
      }
    }

    position++;
  }
}
3400763a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400763e:	f5b3 1f44 	cmp.w	r3, #3211264	@ 0x310000
34007642:	d0ef      	beq.n	34007624 <HAL_GPIO_Init+0xf8>
34007644:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
34007648:	f5b3 1f08 	cmp.w	r3, #2228224	@ 0x220000
3400764c:	e7e9      	b.n	34007622 <HAL_GPIO_Init+0xf6>
3400764e:	bf00      	nop
34007650:	56020000 	.word	0x56020000
34007654:	56020400 	.word	0x56020400
34007658:	56020800 	.word	0x56020800
3400765c:	56020c00 	.word	0x56020c00
34007660:	56021000 	.word	0x56021000
34007664:	56021400 	.word	0x56021400
34007668:	56021800 	.word	0x56021800
3400766c:	56021c00 	.word	0x56021c00
34007670:	56023400 	.word	0x56023400
34007674:	56023800 	.word	0x56023800
34007678:	56023c00 	.word	0x56023c00
3400767c:	56024000 	.word	0x56024000
34007680:	3401c3bd 	.word	0x3401c3bd
34007684:	56025000 	.word	0x56025000
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34007688:	f04f 0b01 	mov.w	fp, #1
3400768c:	fa0b fb07 	lsl.w	fp, fp, r7
    if (iocurrent != 0x00u)
34007690:	ea1b 0505 	ands.w	r5, fp, r5
34007694:	f000 8130 	beq.w	340078f8 <HAL_GPIO_Init+0x3cc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34007698:	6873      	ldr	r3, [r6, #4]
3400769a:	f003 0303 	and.w	r3, r3, #3
3400769e:	3b01      	subs	r3, #1
340076a0:	2b01      	cmp	r3, #1
340076a2:	d81a      	bhi.n	340076da <HAL_GPIO_Init+0x1ae>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
340076a4:	68f3      	ldr	r3, [r6, #12]
340076a6:	2b03      	cmp	r3, #3
340076a8:	d903      	bls.n	340076b2 <HAL_GPIO_Init+0x186>
340076aa:	21be      	movs	r1, #190	@ 0xbe
340076ac:	489e      	ldr	r0, [pc, #632]	@ (34007928 <HAL_GPIO_Init+0x3fc>)
340076ae:	f7fa ff41 	bl	34002534 <assert_failed>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
340076b2:	2303      	movs	r3, #3
        temp = GPIOx->OSPEEDR;
340076b4:	68a2      	ldr	r2, [r4, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
340076b6:	fa03 f309 	lsl.w	r3, r3, r9
340076ba:	ea22 0203 	bic.w	r2, r2, r3
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
340076be:	68f3      	ldr	r3, [r6, #12]
340076c0:	fa03 f309 	lsl.w	r3, r3, r9
340076c4:	4313      	orrs	r3, r2
        GPIOx->OSPEEDR = temp;
340076c6:	60a3      	str	r3, [r4, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
340076c8:	6873      	ldr	r3, [r6, #4]
        temp = GPIOx->OTYPER;
340076ca:	6862      	ldr	r2, [r4, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
340076cc:	f3c3 1300 	ubfx	r3, r3, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
340076d0:	ea22 020b 	bic.w	r2, r2, fp
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
340076d4:	40bb      	lsls	r3, r7
340076d6:	4313      	orrs	r3, r2
        GPIOx->OTYPER = temp;
340076d8:	6063      	str	r3, [r4, #4]
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
340076da:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
340076de:	f003 0303 	and.w	r3, r3, #3
340076e2:	2b03      	cmp	r3, #3
340076e4:	d102      	bne.n	340076ec <HAL_GPIO_Init+0x1c0>
340076e6:	2a01      	cmp	r2, #1
340076e8:	f000 8082 	beq.w	340077f0 <HAL_GPIO_Init+0x2c4>
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
340076ec:	2a02      	cmp	r2, #2
340076ee:	d903      	bls.n	340076f8 <HAL_GPIO_Init+0x1cc>
340076f0:	21d1      	movs	r1, #209	@ 0xd1
340076f2:	488d      	ldr	r0, [pc, #564]	@ (34007928 <HAL_GPIO_Init+0x3fc>)
340076f4:	f7fa ff1e 	bl	34002534 <assert_failed>
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340076f8:	2303      	movs	r3, #3
        temp = GPIOx->PUPDR;
340076fa:	68e2      	ldr	r2, [r4, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340076fc:	fa03 f309 	lsl.w	r3, r3, r9
34007700:	ea22 0203 	bic.w	r2, r2, r3
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34007704:	68b3      	ldr	r3, [r6, #8]
34007706:	fa03 f309 	lsl.w	r3, r3, r9
3400770a:	4313      	orrs	r3, r2
        GPIOx->PUPDR = temp;
3400770c:	60e3      	str	r3, [r4, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
3400770e:	6873      	ldr	r3, [r6, #4]
34007710:	f003 0303 	and.w	r3, r3, #3
34007714:	2b02      	cmp	r3, #2
34007716:	d16b      	bne.n	340077f0 <HAL_GPIO_Init+0x2c4>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
34007718:	4544      	cmp	r4, r8
3400771a:	d053      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400771c:	4b83      	ldr	r3, [pc, #524]	@ (3400792c <HAL_GPIO_Init+0x400>)
3400771e:	429c      	cmp	r4, r3
34007720:	d050      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007722:	4b83      	ldr	r3, [pc, #524]	@ (34007930 <HAL_GPIO_Init+0x404>)
34007724:	429c      	cmp	r4, r3
34007726:	d04d      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007728:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400772c:	429c      	cmp	r4, r3
3400772e:	d049      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007730:	4b80      	ldr	r3, [pc, #512]	@ (34007934 <HAL_GPIO_Init+0x408>)
34007732:	429c      	cmp	r4, r3
34007734:	d046      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007736:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400773a:	429c      	cmp	r4, r3
3400773c:	d042      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400773e:	4b7e      	ldr	r3, [pc, #504]	@ (34007938 <HAL_GPIO_Init+0x40c>)
34007740:	429c      	cmp	r4, r3
34007742:	d03f      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007744:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007748:	429c      	cmp	r4, r3
3400774a:	d03b      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400774c:	4b7b      	ldr	r3, [pc, #492]	@ (3400793c <HAL_GPIO_Init+0x410>)
3400774e:	429c      	cmp	r4, r3
34007750:	d038      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007752:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007756:	429c      	cmp	r4, r3
34007758:	d034      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400775a:	4b79      	ldr	r3, [pc, #484]	@ (34007940 <HAL_GPIO_Init+0x414>)
3400775c:	429c      	cmp	r4, r3
3400775e:	d031      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007760:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007764:	429c      	cmp	r4, r3
34007766:	d02d      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007768:	4b76      	ldr	r3, [pc, #472]	@ (34007944 <HAL_GPIO_Init+0x418>)
3400776a:	429c      	cmp	r4, r3
3400776c:	d02a      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400776e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007772:	429c      	cmp	r4, r3
34007774:	d026      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007776:	4b74      	ldr	r3, [pc, #464]	@ (34007948 <HAL_GPIO_Init+0x41c>)
34007778:	429c      	cmp	r4, r3
3400777a:	d023      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400777c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007780:	429c      	cmp	r4, r3
34007782:	d01f      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007784:	4b71      	ldr	r3, [pc, #452]	@ (3400794c <HAL_GPIO_Init+0x420>)
34007786:	429c      	cmp	r4, r3
34007788:	d01c      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
3400778a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400778e:	429c      	cmp	r4, r3
34007790:	d018      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007792:	4b6f      	ldr	r3, [pc, #444]	@ (34007950 <HAL_GPIO_Init+0x424>)
34007794:	429c      	cmp	r4, r3
34007796:	d015      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
34007798:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400779c:	429c      	cmp	r4, r3
3400779e:	d011      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
340077a0:	4b6c      	ldr	r3, [pc, #432]	@ (34007954 <HAL_GPIO_Init+0x428>)
340077a2:	429c      	cmp	r4, r3
340077a4:	d00e      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
340077a6:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340077aa:	429c      	cmp	r4, r3
340077ac:	d00a      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
340077ae:	4b6a      	ldr	r3, [pc, #424]	@ (34007958 <HAL_GPIO_Init+0x42c>)
340077b0:	429c      	cmp	r4, r3
340077b2:	d007      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
340077b4:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340077b8:	429c      	cmp	r4, r3
340077ba:	d003      	beq.n	340077c4 <HAL_GPIO_Init+0x298>
340077bc:	21de      	movs	r1, #222	@ 0xde
340077be:	485a      	ldr	r0, [pc, #360]	@ (34007928 <HAL_GPIO_Init+0x3fc>)
340077c0:	f7fa feb8 	bl	34002534 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
340077c4:	6933      	ldr	r3, [r6, #16]
340077c6:	2b0f      	cmp	r3, #15
340077c8:	d903      	bls.n	340077d2 <HAL_GPIO_Init+0x2a6>
340077ca:	21df      	movs	r1, #223	@ 0xdf
340077cc:	4856      	ldr	r0, [pc, #344]	@ (34007928 <HAL_GPIO_Init+0x3fc>)
340077ce:	f7fa feb1 	bl	34002534 <assert_failed>
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340077d2:	230f      	movs	r3, #15
        temp = GPIOx->AFR[position >> 3u];
340077d4:	08fa      	lsrs	r2, r7, #3
340077d6:	eb04 0282 	add.w	r2, r4, r2, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340077da:	f007 0107 	and.w	r1, r7, #7
        temp = GPIOx->AFR[position >> 3u];
340077de:	6a10      	ldr	r0, [r2, #32]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340077e0:	0089      	lsls	r1, r1, #2
340077e2:	408b      	lsls	r3, r1
340077e4:	ea20 0003 	bic.w	r0, r0, r3
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340077e8:	6933      	ldr	r3, [r6, #16]
340077ea:	408b      	lsls	r3, r1
340077ec:	4303      	orrs	r3, r0
        GPIOx->AFR[position >> 3u] = temp;
340077ee:	6213      	str	r3, [r2, #32]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340077f0:	2303      	movs	r3, #3
      temp = GPIOx->MODER;
340077f2:	6820      	ldr	r0, [r4, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340077f4:	fa03 f209 	lsl.w	r2, r3, r9
340077f8:	ea20 0002 	bic.w	r0, r0, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
340077fc:	6872      	ldr	r2, [r6, #4]
340077fe:	ea02 0103 	and.w	r1, r2, r3
34007802:	fa01 f109 	lsl.w	r1, r1, r9
34007806:	4301      	orrs	r1, r0
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34007808:	f412 3f40 	tst.w	r2, #196608	@ 0x30000
      GPIOx->MODER = temp;
3400780c:	6021      	str	r1, [r4, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
3400780e:	d073      	beq.n	340078f8 <HAL_GPIO_Init+0x3cc>
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007810:	f04f 0e0f 	mov.w	lr, #15
34007814:	f027 0103 	bic.w	r1, r7, #3
34007818:	f101 41ac 	add.w	r1, r1, #1442840576	@ 0x56000000
3400781c:	f501 3114 	add.w	r1, r1, #151552	@ 0x25000
34007820:	ea07 0003 	and.w	r0, r7, r3
        temp = EXTI->EXTICR[position >> 2u];
34007824:	f8d1 c060 	ldr.w	ip, [r1, #96]	@ 0x60
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007828:	4098      	lsls	r0, r3
3400782a:	fa0e fe00 	lsl.w	lr, lr, r0
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400782e:	4544      	cmp	r4, r8
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007830:	ea2c 0c0e 	bic.w	ip, ip, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007834:	d064      	beq.n	34007900 <HAL_GPIO_Init+0x3d4>
34007836:	f8df e0f8 	ldr.w	lr, [pc, #248]	@ 34007930 <HAL_GPIO_Init+0x404>
3400783a:	4574      	cmp	r4, lr
3400783c:	d062      	beq.n	34007904 <HAL_GPIO_Init+0x3d8>
3400783e:	f50e 6e80 	add.w	lr, lr, #1024	@ 0x400
34007842:	4574      	cmp	r4, lr
34007844:	d060      	beq.n	34007908 <HAL_GPIO_Init+0x3dc>
34007846:	f50e 6e80 	add.w	lr, lr, #1024	@ 0x400
3400784a:	4574      	cmp	r4, lr
3400784c:	d020      	beq.n	34007890 <HAL_GPIO_Init+0x364>
3400784e:	4b3b      	ldr	r3, [pc, #236]	@ (3400793c <HAL_GPIO_Init+0x410>)
34007850:	429c      	cmp	r4, r3
34007852:	d05b      	beq.n	3400790c <HAL_GPIO_Init+0x3e0>
34007854:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007858:	429c      	cmp	r4, r3
3400785a:	d059      	beq.n	34007910 <HAL_GPIO_Init+0x3e4>
3400785c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007860:	429c      	cmp	r4, r3
34007862:	d057      	beq.n	34007914 <HAL_GPIO_Init+0x3e8>
34007864:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007868:	429c      	cmp	r4, r3
3400786a:	d055      	beq.n	34007918 <HAL_GPIO_Init+0x3ec>
3400786c:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
34007870:	429c      	cmp	r4, r3
34007872:	d053      	beq.n	3400791c <HAL_GPIO_Init+0x3f0>
34007874:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007878:	429c      	cmp	r4, r3
3400787a:	d051      	beq.n	34007920 <HAL_GPIO_Init+0x3f4>
3400787c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007880:	429c      	cmp	r4, r3
34007882:	d04f      	beq.n	34007924 <HAL_GPIO_Init+0x3f8>
34007884:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007888:	429c      	cmp	r4, r3
3400788a:	bf14      	ite	ne
3400788c:	2310      	movne	r3, #16
3400788e:	230b      	moveq	r3, #11
34007890:	4083      	lsls	r3, r0
34007892:	ea43 030c 	orr.w	r3, r3, ip
        EXTI->EXTICR[position >> 2u] = temp;
34007896:	660b      	str	r3, [r1, #96]	@ 0x60
        temp = EXTI->IMR1;
34007898:	f8da 3080 	ldr.w	r3, [sl, #128]	@ 0x80
        temp &= ~(iocurrent);
3400789c:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
340078a0:	ea23 0105 	bic.w	r1, r3, r5
340078a4:	ea43 0305 	orr.w	r3, r3, r5
340078a8:	bf08      	it	eq
340078aa:	460b      	moveq	r3, r1
        EXTI->IMR1 = temp;
340078ac:	f8ca 3080 	str.w	r3, [sl, #128]	@ 0x80
        temp = EXTI->EMR1;
340078b0:	f8da 3084 	ldr.w	r3, [sl, #132]	@ 0x84
        temp &= ~(iocurrent);
340078b4:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
340078b8:	ea23 0105 	bic.w	r1, r3, r5
340078bc:	ea43 0305 	orr.w	r3, r3, r5
340078c0:	bf08      	it	eq
340078c2:	460b      	moveq	r3, r1
        EXTI->EMR1 = temp;
340078c4:	f8ca 3084 	str.w	r3, [sl, #132]	@ 0x84
        temp = EXTI->RTSR1;
340078c8:	f8da 3000 	ldr.w	r3, [sl]
        temp &= ~(iocurrent);
340078cc:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
340078d0:	ea23 0105 	bic.w	r1, r3, r5
340078d4:	ea43 0305 	orr.w	r3, r3, r5
340078d8:	bf08      	it	eq
340078da:	460b      	moveq	r3, r1
        EXTI->RTSR1 = temp;
340078dc:	f8ca 3000 	str.w	r3, [sl]
        temp = EXTI->FTSR1;
340078e0:	f8da 3004 	ldr.w	r3, [sl, #4]
        temp &= ~(iocurrent);
340078e4:	f412 1f00 	tst.w	r2, #2097152	@ 0x200000
340078e8:	ea23 0105 	bic.w	r1, r3, r5
340078ec:	ea45 0503 	orr.w	r5, r5, r3
340078f0:	bf08      	it	eq
340078f2:	460d      	moveq	r5, r1
        EXTI->FTSR1 = temp;
340078f4:	f8ca 5004 	str.w	r5, [sl, #4]
    position++;
340078f8:	3701      	adds	r7, #1
340078fa:	f109 0902 	add.w	r9, r9, #2
340078fe:	e698      	b.n	34007632 <HAL_GPIO_Init+0x106>
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007900:	2300      	movs	r3, #0
34007902:	e7c5      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007904:	2301      	movs	r3, #1
34007906:	e7c3      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007908:	2302      	movs	r3, #2
3400790a:	e7c1      	b.n	34007890 <HAL_GPIO_Init+0x364>
3400790c:	2304      	movs	r3, #4
3400790e:	e7bf      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007910:	2305      	movs	r3, #5
34007912:	e7bd      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007914:	2306      	movs	r3, #6
34007916:	e7bb      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007918:	2307      	movs	r3, #7
3400791a:	e7b9      	b.n	34007890 <HAL_GPIO_Init+0x364>
3400791c:	2308      	movs	r3, #8
3400791e:	e7b7      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007920:	2309      	movs	r3, #9
34007922:	e7b5      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007924:	230a      	movs	r3, #10
34007926:	e7b3      	b.n	34007890 <HAL_GPIO_Init+0x364>
34007928:	3401c3bd 	.word	0x3401c3bd
3400792c:	46020000 	.word	0x46020000
34007930:	56020400 	.word	0x56020400
34007934:	56020800 	.word	0x56020800
34007938:	56020c00 	.word	0x56020c00
3400793c:	56021000 	.word	0x56021000
34007940:	56021400 	.word	0x56021400
34007944:	56021800 	.word	0x56021800
34007948:	56021c00 	.word	0x56021c00
3400794c:	56023400 	.word	0x56023400
34007950:	56023800 	.word	0x56023800
34007954:	56023c00 	.word	0x56023c00
34007958:	56024000 	.word	0x56024000

3400795c <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
3400795c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007960:	4b87      	ldr	r3, [pc, #540]	@ (34007b80 <HAL_GPIO_DeInit+0x224>)
{
34007962:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007964:	4298      	cmp	r0, r3
{
34007966:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007968:	d055      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
3400796a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400796e:	4298      	cmp	r0, r3
34007970:	d051      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007972:	4b84      	ldr	r3, [pc, #528]	@ (34007b84 <HAL_GPIO_DeInit+0x228>)
34007974:	4298      	cmp	r0, r3
34007976:	d04e      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007978:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400797c:	4298      	cmp	r0, r3
3400797e:	d04a      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007980:	4b81      	ldr	r3, [pc, #516]	@ (34007b88 <HAL_GPIO_DeInit+0x22c>)
34007982:	4298      	cmp	r0, r3
34007984:	d047      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007986:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400798a:	4298      	cmp	r0, r3
3400798c:	d043      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
3400798e:	4b7f      	ldr	r3, [pc, #508]	@ (34007b8c <HAL_GPIO_DeInit+0x230>)
34007990:	4298      	cmp	r0, r3
34007992:	d040      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007994:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007998:	4298      	cmp	r0, r3
3400799a:	d03c      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
3400799c:	4b7c      	ldr	r3, [pc, #496]	@ (34007b90 <HAL_GPIO_DeInit+0x234>)
3400799e:	4298      	cmp	r0, r3
340079a0:	d039      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079a2:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079a6:	4298      	cmp	r0, r3
340079a8:	d035      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079aa:	4b7a      	ldr	r3, [pc, #488]	@ (34007b94 <HAL_GPIO_DeInit+0x238>)
340079ac:	4298      	cmp	r0, r3
340079ae:	d032      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079b0:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079b4:	4298      	cmp	r0, r3
340079b6:	d02e      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079b8:	4b77      	ldr	r3, [pc, #476]	@ (34007b98 <HAL_GPIO_DeInit+0x23c>)
340079ba:	4298      	cmp	r0, r3
340079bc:	d02b      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079be:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079c2:	4298      	cmp	r0, r3
340079c4:	d027      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079c6:	4b75      	ldr	r3, [pc, #468]	@ (34007b9c <HAL_GPIO_DeInit+0x240>)
340079c8:	4298      	cmp	r0, r3
340079ca:	d024      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079cc:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079d0:	4298      	cmp	r0, r3
340079d2:	d020      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079d4:	4b72      	ldr	r3, [pc, #456]	@ (34007ba0 <HAL_GPIO_DeInit+0x244>)
340079d6:	4298      	cmp	r0, r3
340079d8:	d01d      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079da:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079de:	4298      	cmp	r0, r3
340079e0:	d019      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079e2:	4b70      	ldr	r3, [pc, #448]	@ (34007ba4 <HAL_GPIO_DeInit+0x248>)
340079e4:	4298      	cmp	r0, r3
340079e6:	d016      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079e8:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079ec:	4298      	cmp	r0, r3
340079ee:	d012      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079f0:	4b6d      	ldr	r3, [pc, #436]	@ (34007ba8 <HAL_GPIO_DeInit+0x24c>)
340079f2:	4298      	cmp	r0, r3
340079f4:	d00f      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079f6:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340079fa:	4298      	cmp	r0, r3
340079fc:	d00b      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
340079fe:	4b6b      	ldr	r3, [pc, #428]	@ (34007bac <HAL_GPIO_DeInit+0x250>)
34007a00:	4298      	cmp	r0, r3
34007a02:	d008      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007a04:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a08:	4298      	cmp	r0, r3
34007a0a:	d004      	beq.n	34007a16 <HAL_GPIO_DeInit+0xba>
34007a0c:	f240 112d 	movw	r1, #301	@ 0x12d
34007a10:	4867      	ldr	r0, [pc, #412]	@ (34007bb0 <HAL_GPIO_DeInit+0x254>)
34007a12:	f7fa fd8f 	bl	34002534 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
34007a16:	b2ab      	uxth	r3, r5
34007a18:	b113      	cbz	r3, 34007a20 <HAL_GPIO_DeInit+0xc4>
34007a1a:	f5b5 3f80 	cmp.w	r5, #65536	@ 0x10000
34007a1e:	d304      	bcc.n	34007a2a <HAL_GPIO_DeInit+0xce>
34007a20:	f44f 7197 	mov.w	r1, #302	@ 0x12e
34007a24:	4862      	ldr	r0, [pc, #392]	@ (34007bb0 <HAL_GPIO_DeInit+0x254>)
34007a26:	f7fa fd85 	bl	34002534 <assert_failed>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34007a2a:	2200      	movs	r2, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
34007a2c:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007a30:	f04f 080f 	mov.w	r8, #15
        EXTI->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34007a34:	f04f 0b03 	mov.w	fp, #3
        EXTI->IMR1 &= ~(iocurrent);
34007a38:	485e      	ldr	r0, [pc, #376]	@ (34007bb4 <HAL_GPIO_DeInit+0x258>)
  while ((GPIO_Pin >> position) != 0x00u)
34007a3a:	fa35 f302 	lsrs.w	r3, r5, r2
34007a3e:	d101      	bne.n	34007a44 <HAL_GPIO_DeInit+0xe8>
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
    }

    position++;
  }
}
34007a40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
34007a44:	fa0a fc02 	lsl.w	ip, sl, r2
    if (iocurrent != 0x00u)
34007a48:	ea1c 0605 	ands.w	r6, ip, r5
34007a4c:	d07f      	beq.n	34007b4e <HAL_GPIO_DeInit+0x1f2>
      tmp = EXTI->EXTICR[position >> 2u];
34007a4e:	f022 0103 	bic.w	r1, r2, #3
34007a52:	f101 41ac 	add.w	r1, r1, #1442840576	@ 0x56000000
34007a56:	f501 3114 	add.w	r1, r1, #151552	@ 0x25000
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007a5a:	f002 0703 	and.w	r7, r2, #3
      tmp = EXTI->EXTICR[position >> 2u];
34007a5e:	6e0b      	ldr	r3, [r1, #96]	@ 0x60
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007a60:	00ff      	lsls	r7, r7, #3
34007a62:	fa08 f907 	lsl.w	r9, r8, r7
34007a66:	ea09 0e03 	and.w	lr, r9, r3
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34007a6a:	4b45      	ldr	r3, [pc, #276]	@ (34007b80 <HAL_GPIO_DeInit+0x224>)
34007a6c:	429c      	cmp	r4, r3
34007a6e:	d070      	beq.n	34007b52 <HAL_GPIO_DeInit+0x1f6>
34007a70:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007a74:	429c      	cmp	r4, r3
34007a76:	d06e      	beq.n	34007b56 <HAL_GPIO_DeInit+0x1fa>
34007a78:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007a7c:	429c      	cmp	r4, r3
34007a7e:	d06c      	beq.n	34007b5a <HAL_GPIO_DeInit+0x1fe>
34007a80:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007a84:	429c      	cmp	r4, r3
34007a86:	d06a      	beq.n	34007b5e <HAL_GPIO_DeInit+0x202>
34007a88:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007a8c:	429c      	cmp	r4, r3
34007a8e:	d068      	beq.n	34007b62 <HAL_GPIO_DeInit+0x206>
34007a90:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007a94:	429c      	cmp	r4, r3
34007a96:	d066      	beq.n	34007b66 <HAL_GPIO_DeInit+0x20a>
34007a98:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007a9c:	429c      	cmp	r4, r3
34007a9e:	d064      	beq.n	34007b6a <HAL_GPIO_DeInit+0x20e>
34007aa0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007aa4:	429c      	cmp	r4, r3
34007aa6:	d062      	beq.n	34007b6e <HAL_GPIO_DeInit+0x212>
34007aa8:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
34007aac:	429c      	cmp	r4, r3
34007aae:	d060      	beq.n	34007b72 <HAL_GPIO_DeInit+0x216>
34007ab0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007ab4:	429c      	cmp	r4, r3
34007ab6:	d05e      	beq.n	34007b76 <HAL_GPIO_DeInit+0x21a>
34007ab8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007abc:	429c      	cmp	r4, r3
34007abe:	d05c      	beq.n	34007b7a <HAL_GPIO_DeInit+0x21e>
34007ac0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007ac4:	429c      	cmp	r4, r3
34007ac6:	bf14      	ite	ne
34007ac8:	2310      	movne	r3, #16
34007aca:	230b      	moveq	r3, #11
34007acc:	40bb      	lsls	r3, r7
34007ace:	4573      	cmp	r3, lr
34007ad0:	d117      	bne.n	34007b02 <HAL_GPIO_DeInit+0x1a6>
        EXTI->IMR1 &= ~(iocurrent);
34007ad2:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
34007ad6:	ea23 0306 	bic.w	r3, r3, r6
34007ada:	f8c0 3080 	str.w	r3, [r0, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
34007ade:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
34007ae2:	ea23 0306 	bic.w	r3, r3, r6
34007ae6:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
34007aea:	6803      	ldr	r3, [r0, #0]
34007aec:	ea23 0306 	bic.w	r3, r3, r6
34007af0:	6003      	str	r3, [r0, #0]
        EXTI->FTSR1 &= ~(iocurrent);
34007af2:	6843      	ldr	r3, [r0, #4]
34007af4:	ea23 0306 	bic.w	r3, r3, r6
34007af8:	6043      	str	r3, [r0, #4]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
34007afa:	6e0b      	ldr	r3, [r1, #96]	@ 0x60
34007afc:	ea23 0309 	bic.w	r3, r3, r9
34007b00:	660b      	str	r3, [r1, #96]	@ 0x60
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34007b02:	6823      	ldr	r3, [r4, #0]
34007b04:	0056      	lsls	r6, r2, #1
34007b06:	fa0b f606 	lsl.w	r6, fp, r6
34007b0a:	4333      	orrs	r3, r6
34007b0c:	6023      	str	r3, [r4, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
34007b0e:	08d3      	lsrs	r3, r2, #3
34007b10:	eb04 0383 	add.w	r3, r4, r3, lsl #2
34007b14:	f002 0107 	and.w	r1, r2, #7
34007b18:	6a1f      	ldr	r7, [r3, #32]
34007b1a:	0089      	lsls	r1, r1, #2
34007b1c:	fa08 f101 	lsl.w	r1, r8, r1
34007b20:	ea27 0701 	bic.w	r7, r7, r1
34007b24:	621f      	str	r7, [r3, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34007b26:	68a7      	ldr	r7, [r4, #8]
34007b28:	ea27 0706 	bic.w	r7, r7, r6
34007b2c:	60a7      	str	r7, [r4, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
34007b2e:	6867      	ldr	r7, [r4, #4]
34007b30:	ea27 070c 	bic.w	r7, r7, ip
34007b34:	6067      	str	r7, [r4, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34007b36:	68e7      	ldr	r7, [r4, #12]
34007b38:	ea27 0706 	bic.w	r7, r7, r6
34007b3c:	60e7      	str	r7, [r4, #12]
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
34007b3e:	6c1e      	ldr	r6, [r3, #64]	@ 0x40
34007b40:	ea26 0601 	bic.w	r6, r6, r1
34007b44:	641e      	str	r6, [r3, #64]	@ 0x40
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
34007b46:	6c9e      	ldr	r6, [r3, #72]	@ 0x48
34007b48:	ea26 0101 	bic.w	r1, r6, r1
34007b4c:	6499      	str	r1, [r3, #72]	@ 0x48
    position++;
34007b4e:	3201      	adds	r2, #1
34007b50:	e773      	b.n	34007a3a <HAL_GPIO_DeInit+0xde>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34007b52:	2300      	movs	r3, #0
34007b54:	e7ba      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b56:	2301      	movs	r3, #1
34007b58:	e7b8      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b5a:	2302      	movs	r3, #2
34007b5c:	e7b6      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b5e:	2303      	movs	r3, #3
34007b60:	e7b4      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b62:	2304      	movs	r3, #4
34007b64:	e7b2      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b66:	2305      	movs	r3, #5
34007b68:	e7b0      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b6a:	2306      	movs	r3, #6
34007b6c:	e7ae      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b6e:	2307      	movs	r3, #7
34007b70:	e7ac      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b72:	2308      	movs	r3, #8
34007b74:	e7aa      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b76:	2309      	movs	r3, #9
34007b78:	e7a8      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b7a:	230a      	movs	r3, #10
34007b7c:	e7a6      	b.n	34007acc <HAL_GPIO_DeInit+0x170>
34007b7e:	bf00      	nop
34007b80:	56020000 	.word	0x56020000
34007b84:	56020400 	.word	0x56020400
34007b88:	56020800 	.word	0x56020800
34007b8c:	56020c00 	.word	0x56020c00
34007b90:	56021000 	.word	0x56021000
34007b94:	56021400 	.word	0x56021400
34007b98:	56021800 	.word	0x56021800
34007b9c:	56021c00 	.word	0x56021c00
34007ba0:	56023400 	.word	0x56023400
34007ba4:	56023800 	.word	0x56023800
34007ba8:	56023c00 	.word	0x56023c00
34007bac:	56024000 	.word	0x56024000
34007bb0:	3401c3bd 	.word	0x3401c3bd
34007bb4:	56025000 	.word	0x56025000

34007bb8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34007bb8:	b570      	push	{r4, r5, r6, lr}
34007bba:	4605      	mov	r5, r0
34007bbc:	4616      	mov	r6, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
34007bbe:	460c      	mov	r4, r1
34007bc0:	b921      	cbnz	r1, 34007bcc <HAL_GPIO_WritePin+0x14>
34007bc2:	f44f 71d0 	mov.w	r1, #416	@ 0x1a0
34007bc6:	4808      	ldr	r0, [pc, #32]	@ (34007be8 <HAL_GPIO_WritePin+0x30>)
34007bc8:	f7fa fcb4 	bl	34002534 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
34007bcc:	2e01      	cmp	r6, #1
34007bce:	d906      	bls.n	34007bde <HAL_GPIO_WritePin+0x26>
34007bd0:	f240 11a1 	movw	r1, #417	@ 0x1a1
34007bd4:	4804      	ldr	r0, [pc, #16]	@ (34007be8 <HAL_GPIO_WritePin+0x30>)
34007bd6:	f7fa fcad 	bl	34002534 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34007bda:	61ac      	str	r4, [r5, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34007bdc:	bd70      	pop	{r4, r5, r6, pc}
  if (PinState != GPIO_PIN_RESET)
34007bde:	2e00      	cmp	r6, #0
34007be0:	d1fb      	bne.n	34007bda <HAL_GPIO_WritePin+0x22>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34007be2:	62ac      	str	r4, [r5, #40]	@ 0x28
}
34007be4:	e7fa      	b.n	34007bdc <HAL_GPIO_WritePin+0x24>
34007be6:	bf00      	nop
34007be8:	3401c3bd 	.word	0x3401c3bd

34007bec <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
34007bec:	6803      	ldr	r3, [r0, #0]
34007bee:	699a      	ldr	r2, [r3, #24]
34007bf0:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
34007bf2:	bf44      	itt	mi
34007bf4:	2200      	movmi	r2, #0
34007bf6:	629a      	strmi	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
34007bf8:	699a      	ldr	r2, [r3, #24]
34007bfa:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
34007bfc:	bf5e      	ittt	pl
34007bfe:	699a      	ldrpl	r2, [r3, #24]
34007c00:	f042 0201 	orrpl.w	r2, r2, #1
34007c04:	619a      	strpl	r2, [r3, #24]
  }
}
34007c06:	4770      	bx	lr

34007c08 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
34007c08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34007c0c:	4614      	mov	r4, r2
34007c0e:	461f      	mov	r7, r3
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007c10:	6802      	ldr	r2, [r0, #0]
34007c12:	4b29      	ldr	r3, [pc, #164]	@ (34007cb8 <I2C_TransferConfig+0xb0>)
{
34007c14:	4680      	mov	r8, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007c16:	429a      	cmp	r2, r3
{
34007c18:	460e      	mov	r6, r1
34007c1a:	9d06      	ldr	r5, [sp, #24]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007c1c:	d01d      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c1e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007c22:	429a      	cmp	r2, r3
34007c24:	d019      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c26:	4b25      	ldr	r3, [pc, #148]	@ (34007cbc <I2C_TransferConfig+0xb4>)
34007c28:	429a      	cmp	r2, r3
34007c2a:	d016      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c2c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007c30:	429a      	cmp	r2, r3
34007c32:	d012      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c34:	4b22      	ldr	r3, [pc, #136]	@ (34007cc0 <I2C_TransferConfig+0xb8>)
34007c36:	429a      	cmp	r2, r3
34007c38:	d00f      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c3a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007c3e:	429a      	cmp	r2, r3
34007c40:	d00b      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c42:	4b20      	ldr	r3, [pc, #128]	@ (34007cc4 <I2C_TransferConfig+0xbc>)
34007c44:	429a      	cmp	r2, r3
34007c46:	d008      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c48:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007c4c:	429a      	cmp	r2, r3
34007c4e:	d004      	beq.n	34007c5a <I2C_TransferConfig+0x52>
34007c50:	f641 51c9 	movw	r1, #7625	@ 0x1dc9
34007c54:	481c      	ldr	r0, [pc, #112]	@ (34007cc8 <I2C_TransferConfig+0xc0>)
34007c56:	f7fa fc6d 	bl	34002534 <assert_failed>
  assert_param(IS_TRANSFER_MODE(Mode));
34007c5a:	f037 7380 	bics.w	r3, r7, #16777216	@ 0x1000000
34007c5e:	d007      	beq.n	34007c70 <I2C_TransferConfig+0x68>
34007c60:	f1b7 7f00 	cmp.w	r7, #33554432	@ 0x2000000
34007c64:	d004      	beq.n	34007c70 <I2C_TransferConfig+0x68>
34007c66:	f641 51ca 	movw	r1, #7626	@ 0x1dca
34007c6a:	4817      	ldr	r0, [pc, #92]	@ (34007cc8 <I2C_TransferConfig+0xc0>)
34007c6c:	f7fa fc62 	bl	34002534 <assert_failed>
  assert_param(IS_TRANSFER_REQUEST(Request));
34007c70:	4b16      	ldr	r3, [pc, #88]	@ (34007ccc <I2C_TransferConfig+0xc4>)
34007c72:	429d      	cmp	r5, r3
34007c74:	d00b      	beq.n	34007c8e <I2C_TransferConfig+0x86>
34007c76:	f425 6280 	bic.w	r2, r5, #1024	@ 0x400
34007c7a:	f5a3 5300 	sub.w	r3, r3, #8192	@ 0x2000
34007c7e:	429a      	cmp	r2, r3
34007c80:	d005      	beq.n	34007c8e <I2C_TransferConfig+0x86>
34007c82:	b125      	cbz	r5, 34007c8e <I2C_TransferConfig+0x86>
34007c84:	f641 51cb 	movw	r1, #7627	@ 0x1dcb
34007c88:	480f      	ldr	r0, [pc, #60]	@ (34007cc8 <I2C_TransferConfig+0xc0>)
34007c8a:	f7fa fc53 	bl	34002534 <assert_failed>
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
34007c8e:	f8d8 0000 	ldr.w	r0, [r8]
34007c92:	490f      	ldr	r1, [pc, #60]	@ (34007cd0 <I2C_TransferConfig+0xc8>)
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34007c94:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
34007c98:	6842      	ldr	r2, [r0, #4]
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34007c9a:	ea44 0307 	orr.w	r3, r4, r7
34007c9e:	f3c6 0609 	ubfx	r6, r6, #0, #10
34007ca2:	4333      	orrs	r3, r6
  MODIFY_REG(hi2c->Instance->CR2, \
34007ca4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34007ca8:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
  MODIFY_REG(hi2c->Instance->CR2, \
34007cac:	ea22 0201 	bic.w	r2, r2, r1
34007cb0:	4313      	orrs	r3, r2
34007cb2:	6043      	str	r3, [r0, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
34007cb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34007cb8:	50005400 	.word	0x50005400
34007cbc:	50005800 	.word	0x50005800
34007cc0:	50005c00 	.word	0x50005c00
34007cc4:	56001c00 	.word	0x56001c00
34007cc8:	3401c42c 	.word	0x3401c42c
34007ccc:	80004000 	.word	0x80004000
34007cd0:	03ff63ff 	.word	0x03ff63ff

34007cd4 <I2C_IsErrorOccurred>:
  uint32_t itflag   = hi2c->Instance->ISR;
34007cd4:	6803      	ldr	r3, [r0, #0]
{
34007cd6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t itflag   = hi2c->Instance->ISR;
34007cda:	699c      	ldr	r4, [r3, #24]
{
34007cdc:	4605      	mov	r5, r0
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
34007cde:	f014 0410 	ands.w	r4, r4, #16
{
34007ce2:	460f      	mov	r7, r1
34007ce4:	4616      	mov	r6, r2
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
34007ce6:	d06f      	beq.n	34007dc8 <I2C_IsErrorOccurred+0xf4>
  uint32_t error_code = 0;
34007ce8:	2400      	movs	r4, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34007cea:	2210      	movs	r2, #16
  HAL_StatusTypeDef status = HAL_OK;
34007cec:	46a0      	mov	r8, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34007cee:	61da      	str	r2, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
34007cf0:	682b      	ldr	r3, [r5, #0]
34007cf2:	699a      	ldr	r2, [r3, #24]
34007cf4:	0690      	lsls	r0, r2, #26
34007cf6:	d461      	bmi.n	34007dbc <I2C_IsErrorOccurred+0xe8>
34007cf8:	f1b8 0f00 	cmp.w	r8, #0
34007cfc:	d035      	beq.n	34007d6a <I2C_IsErrorOccurred+0x96>
    status = HAL_ERROR;
34007cfe:	2001      	movs	r0, #1
    error_code |= HAL_I2C_ERROR_AF;
34007d00:	f044 0404 	orr.w	r4, r4, #4
  itflag = hi2c->Instance->ISR;
34007d04:	682e      	ldr	r6, [r5, #0]
34007d06:	69b3      	ldr	r3, [r6, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
34007d08:	05d9      	lsls	r1, r3, #23
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34007d0a:	bf41      	itttt	mi
34007d0c:	f44f 7280 	movmi.w	r2, #256	@ 0x100
    status = HAL_ERROR;
34007d10:	2001      	movmi	r0, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34007d12:	61f2      	strmi	r2, [r6, #28]
    error_code |= HAL_I2C_ERROR_BERR;
34007d14:	f044 0401 	orrmi.w	r4, r4, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
34007d18:	055a      	lsls	r2, r3, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34007d1a:	bf41      	itttt	mi
34007d1c:	f44f 6280 	movmi.w	r2, #1024	@ 0x400
    status = HAL_ERROR;
34007d20:	2001      	movmi	r0, #1
    error_code |= HAL_I2C_ERROR_OVR;
34007d22:	f044 0408 	orrmi.w	r4, r4, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34007d26:	61f2      	strmi	r2, [r6, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
34007d28:	059b      	lsls	r3, r3, #22
34007d2a:	d54f      	bpl.n	34007dcc <I2C_IsErrorOccurred+0xf8>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34007d2c:	f44f 7300 	mov.w	r3, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
34007d30:	f044 0402 	orr.w	r4, r4, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34007d34:	61f3      	str	r3, [r6, #28]
    I2C_Flush_TXDR(hi2c);
34007d36:	4628      	mov	r0, r5
34007d38:	f7ff ff58 	bl	34007bec <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
34007d3c:	6873      	ldr	r3, [r6, #4]
    __HAL_UNLOCK(hi2c);
34007d3e:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
34007d40:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
34007d44:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
34007d48:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
34007d4c:	f023 0301 	bic.w	r3, r3, #1
34007d50:	6073      	str	r3, [r6, #4]
    hi2c->ErrorCode |= error_code;
34007d52:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
34007d54:	4323      	orrs	r3, r4
34007d56:	646b      	str	r3, [r5, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
34007d58:	2320      	movs	r3, #32
34007d5a:	f885 3041 	strb.w	r3, [r5, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
34007d5e:	2300      	movs	r3, #0
34007d60:	f885 3042 	strb.w	r3, [r5, #66]	@ 0x42
    __HAL_UNLOCK(hi2c);
34007d64:	f885 3040 	strb.w	r3, [r5, #64]	@ 0x40
34007d68:	e032      	b.n	34007dd0 <I2C_IsErrorOccurred+0xfc>
      if (Timeout != HAL_MAX_DELAY)
34007d6a:	1c7a      	adds	r2, r7, #1
34007d6c:	d0c1      	beq.n	34007cf2 <I2C_IsErrorOccurred+0x1e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34007d6e:	f7fc fd4d 	bl	3400480c <HAL_GetTick>
34007d72:	1b80      	subs	r0, r0, r6
34007d74:	42b8      	cmp	r0, r7
34007d76:	d801      	bhi.n	34007d7c <I2C_IsErrorOccurred+0xa8>
34007d78:	2f00      	cmp	r7, #0
34007d7a:	d1b9      	bne.n	34007cf0 <I2C_IsErrorOccurred+0x1c>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
34007d7c:	682b      	ldr	r3, [r5, #0]
34007d7e:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
34007d80:	f895 2042 	ldrb.w	r2, [r5, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34007d84:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
34007d86:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34007d88:	0400      	lsls	r0, r0, #16
34007d8a:	d50a      	bpl.n	34007da2 <I2C_IsErrorOccurred+0xce>
34007d8c:	0449      	lsls	r1, r1, #17
34007d8e:	d408      	bmi.n	34007da2 <I2C_IsErrorOccurred+0xce>
              (tmp1 != I2C_CR2_STOP) && \
34007d90:	2a20      	cmp	r2, #32
34007d92:	d006      	beq.n	34007da2 <I2C_IsErrorOccurred+0xce>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
34007d94:	685a      	ldr	r2, [r3, #4]
34007d96:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34007d9a:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
34007d9c:	f7fc fd36 	bl	3400480c <HAL_GetTick>
34007da0:	4606      	mov	r6, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34007da2:	682b      	ldr	r3, [r5, #0]
34007da4:	699b      	ldr	r3, [r3, #24]
34007da6:	069b      	lsls	r3, r3, #26
34007da8:	d4a2      	bmi.n	34007cf0 <I2C_IsErrorOccurred+0x1c>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
34007daa:	f7fc fd2f 	bl	3400480c <HAL_GetTick>
34007dae:	1b80      	subs	r0, r0, r6
34007db0:	2819      	cmp	r0, #25
34007db2:	d9f6      	bls.n	34007da2 <I2C_IsErrorOccurred+0xce>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
34007db4:	2420      	movs	r4, #32
              status = HAL_ERROR;
34007db6:	f04f 0801 	mov.w	r8, #1
34007dba:	e799      	b.n	34007cf0 <I2C_IsErrorOccurred+0x1c>
    if (status == HAL_OK)
34007dbc:	f1b8 0f00 	cmp.w	r8, #0
34007dc0:	d19d      	bne.n	34007cfe <I2C_IsErrorOccurred+0x2a>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34007dc2:	2220      	movs	r2, #32
34007dc4:	61da      	str	r2, [r3, #28]
34007dc6:	e79a      	b.n	34007cfe <I2C_IsErrorOccurred+0x2a>
  HAL_StatusTypeDef status = HAL_OK;
34007dc8:	4620      	mov	r0, r4
34007dca:	e79b      	b.n	34007d04 <I2C_IsErrorOccurred+0x30>
  if (status != HAL_OK)
34007dcc:	2800      	cmp	r0, #0
34007dce:	d1b2      	bne.n	34007d36 <I2C_IsErrorOccurred+0x62>
}
34007dd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

34007dd4 <I2C_WaitOnTXISFlagUntilTimeout>:
{
34007dd4:	b570      	push	{r4, r5, r6, lr}
34007dd6:	4604      	mov	r4, r0
34007dd8:	460d      	mov	r5, r1
34007dda:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34007ddc:	6823      	ldr	r3, [r4, #0]
34007dde:	699b      	ldr	r3, [r3, #24]
34007de0:	079b      	lsls	r3, r3, #30
34007de2:	d501      	bpl.n	34007de8 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
34007de4:	2000      	movs	r0, #0
34007de6:	e01f      	b.n	34007e28 <I2C_WaitOnTXISFlagUntilTimeout+0x54>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34007de8:	4632      	mov	r2, r6
34007dea:	4629      	mov	r1, r5
34007dec:	4620      	mov	r0, r4
34007dee:	f7ff ff71 	bl	34007cd4 <I2C_IsErrorOccurred>
34007df2:	b9c0      	cbnz	r0, 34007e26 <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
34007df4:	1c6a      	adds	r2, r5, #1
34007df6:	d0f1      	beq.n	34007ddc <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34007df8:	f7fc fd08 	bl	3400480c <HAL_GetTick>
34007dfc:	1b80      	subs	r0, r0, r6
34007dfe:	42a8      	cmp	r0, r5
34007e00:	d801      	bhi.n	34007e06 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
34007e02:	2d00      	cmp	r5, #0
34007e04:	d1ea      	bne.n	34007ddc <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34007e06:	6823      	ldr	r3, [r4, #0]
34007e08:	699b      	ldr	r3, [r3, #24]
34007e0a:	f013 0302 	ands.w	r3, r3, #2
34007e0e:	d1e5      	bne.n	34007ddc <I2C_WaitOnTXISFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007e10:	6c62      	ldr	r2, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hi2c);
34007e12:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007e16:	f042 0220 	orr.w	r2, r2, #32
34007e1a:	6462      	str	r2, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34007e1c:	2220      	movs	r2, #32
34007e1e:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34007e22:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
34007e26:	2001      	movs	r0, #1
}
34007e28:	bd70      	pop	{r4, r5, r6, pc}

34007e2a <I2C_WaitOnFlagUntilTimeout>:
{
34007e2a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34007e2e:	4604      	mov	r4, r0
34007e30:	460f      	mov	r7, r1
34007e32:	4616      	mov	r6, r2
34007e34:	461d      	mov	r5, r3
34007e36:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34007e3a:	6823      	ldr	r3, [r4, #0]
34007e3c:	699b      	ldr	r3, [r3, #24]
34007e3e:	ea37 0303 	bics.w	r3, r7, r3
34007e42:	bf0c      	ite	eq
34007e44:	2301      	moveq	r3, #1
34007e46:	2300      	movne	r3, #0
34007e48:	42b3      	cmp	r3, r6
34007e4a:	d001      	beq.n	34007e50 <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
34007e4c:	2000      	movs	r0, #0
34007e4e:	e025      	b.n	34007e9c <I2C_WaitOnFlagUntilTimeout+0x72>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34007e50:	4642      	mov	r2, r8
34007e52:	4629      	mov	r1, r5
34007e54:	4620      	mov	r0, r4
34007e56:	f7ff ff3d 	bl	34007cd4 <I2C_IsErrorOccurred>
34007e5a:	b9f0      	cbnz	r0, 34007e9a <I2C_WaitOnFlagUntilTimeout+0x70>
    if (Timeout != HAL_MAX_DELAY)
34007e5c:	1c6b      	adds	r3, r5, #1
34007e5e:	d0ec      	beq.n	34007e3a <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34007e60:	f7fc fcd4 	bl	3400480c <HAL_GetTick>
34007e64:	eba0 0008 	sub.w	r0, r0, r8
34007e68:	42a8      	cmp	r0, r5
34007e6a:	d801      	bhi.n	34007e70 <I2C_WaitOnFlagUntilTimeout+0x46>
34007e6c:	2d00      	cmp	r5, #0
34007e6e:	d1e4      	bne.n	34007e3a <I2C_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34007e70:	6823      	ldr	r3, [r4, #0]
34007e72:	699b      	ldr	r3, [r3, #24]
34007e74:	ea37 0303 	bics.w	r3, r7, r3
34007e78:	bf0c      	ite	eq
34007e7a:	2301      	moveq	r3, #1
34007e7c:	2300      	movne	r3, #0
34007e7e:	42b3      	cmp	r3, r6
34007e80:	d1db      	bne.n	34007e3a <I2C_WaitOnFlagUntilTimeout+0x10>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007e82:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34007e84:	f043 0320 	orr.w	r3, r3, #32
34007e88:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34007e8a:	2320      	movs	r3, #32
34007e8c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34007e90:	2300      	movs	r3, #0
34007e92:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
34007e96:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
34007e9a:	2001      	movs	r0, #1
}
34007e9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

34007ea0 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
34007ea0:	b570      	push	{r4, r5, r6, lr}
34007ea2:	4604      	mov	r4, r0
34007ea4:	460d      	mov	r5, r1
34007ea6:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34007ea8:	6823      	ldr	r3, [r4, #0]
34007eaa:	699b      	ldr	r3, [r3, #24]
34007eac:	069b      	lsls	r3, r3, #26
34007eae:	d501      	bpl.n	34007eb4 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
34007eb0:	2000      	movs	r0, #0
34007eb2:	e01d      	b.n	34007ef0 <I2C_WaitOnSTOPFlagUntilTimeout+0x50>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34007eb4:	4632      	mov	r2, r6
34007eb6:	4629      	mov	r1, r5
34007eb8:	4620      	mov	r0, r4
34007eba:	f7ff ff0b 	bl	34007cd4 <I2C_IsErrorOccurred>
34007ebe:	b9b0      	cbnz	r0, 34007eee <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34007ec0:	f7fc fca4 	bl	3400480c <HAL_GetTick>
34007ec4:	1b80      	subs	r0, r0, r6
34007ec6:	42a8      	cmp	r0, r5
34007ec8:	d801      	bhi.n	34007ece <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
34007eca:	2d00      	cmp	r5, #0
34007ecc:	d1ec      	bne.n	34007ea8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34007ece:	6823      	ldr	r3, [r4, #0]
34007ed0:	699b      	ldr	r3, [r3, #24]
34007ed2:	f013 0320 	ands.w	r3, r3, #32
34007ed6:	d1e7      	bne.n	34007ea8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007ed8:	6c62      	ldr	r2, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
34007eda:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007ede:	f042 0220 	orr.w	r2, r2, #32
34007ee2:	6462      	str	r2, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
34007ee4:	2220      	movs	r2, #32
34007ee6:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
34007eea:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
34007eee:	2001      	movs	r0, #1
}
34007ef0:	bd70      	pop	{r4, r5, r6, pc}

34007ef2 <HAL_I2C_MspInit>:
}
34007ef2:	4770      	bx	lr

34007ef4 <HAL_I2C_Init>:
{
34007ef4:	b510      	push	{r4, lr}
  if (hi2c == NULL)
34007ef6:	4604      	mov	r4, r0
34007ef8:	2800      	cmp	r0, #0
34007efa:	f000 80af 	beq.w	3400805c <HAL_I2C_Init+0x168>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007efe:	6803      	ldr	r3, [r0, #0]
34007f00:	4a57      	ldr	r2, [pc, #348]	@ (34008060 <HAL_I2C_Init+0x16c>)
34007f02:	4293      	cmp	r3, r2
34007f04:	d01d      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f06:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007f0a:	4293      	cmp	r3, r2
34007f0c:	d019      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f0e:	4a55      	ldr	r2, [pc, #340]	@ (34008064 <HAL_I2C_Init+0x170>)
34007f10:	4293      	cmp	r3, r2
34007f12:	d016      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f14:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007f18:	4293      	cmp	r3, r2
34007f1a:	d012      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f1c:	4a52      	ldr	r2, [pc, #328]	@ (34008068 <HAL_I2C_Init+0x174>)
34007f1e:	4293      	cmp	r3, r2
34007f20:	d00f      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f22:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007f26:	4293      	cmp	r3, r2
34007f28:	d00b      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f2a:	4a50      	ldr	r2, [pc, #320]	@ (3400806c <HAL_I2C_Init+0x178>)
34007f2c:	4293      	cmp	r3, r2
34007f2e:	d008      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f30:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007f34:	4293      	cmp	r3, r2
34007f36:	d004      	beq.n	34007f42 <HAL_I2C_Init+0x4e>
34007f38:	f240 2126 	movw	r1, #550	@ 0x226
34007f3c:	484c      	ldr	r0, [pc, #304]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007f3e:	f7fa faf9 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
34007f42:	68a3      	ldr	r3, [r4, #8]
34007f44:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34007f48:	d304      	bcc.n	34007f54 <HAL_I2C_Init+0x60>
34007f4a:	f240 2127 	movw	r1, #551	@ 0x227
34007f4e:	4848      	ldr	r0, [pc, #288]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007f50:	f7fa faf0 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
34007f54:	68e3      	ldr	r3, [r4, #12]
34007f56:	3b01      	subs	r3, #1
34007f58:	2b01      	cmp	r3, #1
34007f5a:	d904      	bls.n	34007f66 <HAL_I2C_Init+0x72>
34007f5c:	f44f 710a 	mov.w	r1, #552	@ 0x228
34007f60:	4843      	ldr	r0, [pc, #268]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007f62:	f7fa fae7 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
34007f66:	6923      	ldr	r3, [r4, #16]
34007f68:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
34007f6c:	d004      	beq.n	34007f78 <HAL_I2C_Init+0x84>
34007f6e:	f240 2129 	movw	r1, #553	@ 0x229
34007f72:	483f      	ldr	r0, [pc, #252]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007f74:	f7fa fade 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
34007f78:	6963      	ldr	r3, [r4, #20]
34007f7a:	2bff      	cmp	r3, #255	@ 0xff
34007f7c:	d904      	bls.n	34007f88 <HAL_I2C_Init+0x94>
34007f7e:	f240 212a 	movw	r1, #554	@ 0x22a
34007f82:	483b      	ldr	r0, [pc, #236]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007f84:	f7fa fad6 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
34007f88:	69a3      	ldr	r3, [r4, #24]
34007f8a:	2b07      	cmp	r3, #7
34007f8c:	d904      	bls.n	34007f98 <HAL_I2C_Init+0xa4>
34007f8e:	f240 212b 	movw	r1, #555	@ 0x22b
34007f92:	4837      	ldr	r0, [pc, #220]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007f94:	f7fa face 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
34007f98:	69e3      	ldr	r3, [r4, #28]
34007f9a:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
34007f9e:	d004      	beq.n	34007faa <HAL_I2C_Init+0xb6>
34007fa0:	f44f 710b 	mov.w	r1, #556	@ 0x22c
34007fa4:	4832      	ldr	r0, [pc, #200]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007fa6:	f7fa fac5 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
34007faa:	6a23      	ldr	r3, [r4, #32]
34007fac:	f433 3300 	bics.w	r3, r3, #131072	@ 0x20000
34007fb0:	d004      	beq.n	34007fbc <HAL_I2C_Init+0xc8>
34007fb2:	f240 212d 	movw	r1, #557	@ 0x22d
34007fb6:	482e      	ldr	r0, [pc, #184]	@ (34008070 <HAL_I2C_Init+0x17c>)
34007fb8:	f7fa fabc 	bl	34002534 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
34007fbc:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34007fc0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34007fc4:	b923      	cbnz	r3, 34007fd0 <HAL_I2C_Init+0xdc>
    HAL_I2C_MspInit(hi2c);
34007fc6:	4620      	mov	r0, r4
    hi2c->Lock = HAL_UNLOCKED;
34007fc8:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
34007fcc:	f7ff ff91 	bl	34007ef2 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
34007fd0:	2324      	movs	r3, #36	@ 0x24
34007fd2:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
34007fd6:	6823      	ldr	r3, [r4, #0]
34007fd8:	681a      	ldr	r2, [r3, #0]
34007fda:	f022 0201 	bic.w	r2, r2, #1
34007fde:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
34007fe0:	6862      	ldr	r2, [r4, #4]
34007fe2:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
34007fe6:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
34007fe8:	689a      	ldr	r2, [r3, #8]
34007fea:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34007fee:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
34007ff0:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
34007ff4:	2901      	cmp	r1, #1
34007ff6:	d106      	bne.n	34008006 <HAL_I2C_Init+0x112>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
34007ff8:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34007ffc:	609a      	str	r2, [r3, #8]
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34007ffe:	685a      	ldr	r2, [r3, #4]
34008000:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34008004:	e007      	b.n	34008016 <HAL_I2C_Init+0x122>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
34008006:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400800a:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
3400800c:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400800e:	d1f6      	bne.n	34007ffe <HAL_I2C_Init+0x10a>
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34008010:	685a      	ldr	r2, [r3, #4]
34008012:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34008016:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
34008018:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400801a:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
3400801c:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
34008020:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34008024:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
34008026:	68da      	ldr	r2, [r3, #12]
34008028:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3400802c:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3400802e:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
34008032:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
34008034:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
34008036:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
3400803a:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
3400803c:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
34008040:	430a      	orrs	r2, r1
34008042:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
34008044:	681a      	ldr	r2, [r3, #0]
34008046:	f042 0201 	orr.w	r2, r2, #1
3400804a:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
3400804c:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400804e:	6460      	str	r0, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
34008050:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34008054:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
34008056:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
3400805a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
3400805c:	2001      	movs	r0, #1
3400805e:	e7fc      	b.n	3400805a <HAL_I2C_Init+0x166>
34008060:	50005400 	.word	0x50005400
34008064:	50005800 	.word	0x50005800
34008068:	50005c00 	.word	0x50005c00
3400806c:	56001c00 	.word	0x56001c00
34008070:	3401c42c 	.word	0x3401c42c

34008074 <HAL_I2C_MspDeInit>:
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
34008074:	4770      	bx	lr
	...

34008078 <HAL_I2C_DeInit>:
{
34008078:	b510      	push	{r4, lr}
  if (hi2c == NULL)
3400807a:	4604      	mov	r4, r0
3400807c:	2800      	cmp	r0, #0
3400807e:	d036      	beq.n	340080ee <HAL_I2C_DeInit+0x76>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008080:	6803      	ldr	r3, [r0, #0]
34008082:	4a1c      	ldr	r2, [pc, #112]	@ (340080f4 <HAL_I2C_DeInit+0x7c>)
34008084:	4293      	cmp	r3, r2
34008086:	d01d      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
34008088:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400808c:	4293      	cmp	r3, r2
3400808e:	d019      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
34008090:	4a19      	ldr	r2, [pc, #100]	@ (340080f8 <HAL_I2C_DeInit+0x80>)
34008092:	4293      	cmp	r3, r2
34008094:	d016      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
34008096:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400809a:	4293      	cmp	r3, r2
3400809c:	d012      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
3400809e:	4a17      	ldr	r2, [pc, #92]	@ (340080fc <HAL_I2C_DeInit+0x84>)
340080a0:	4293      	cmp	r3, r2
340080a2:	d00f      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
340080a4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340080a8:	4293      	cmp	r3, r2
340080aa:	d00b      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
340080ac:	4a14      	ldr	r2, [pc, #80]	@ (34008100 <HAL_I2C_DeInit+0x88>)
340080ae:	4293      	cmp	r3, r2
340080b0:	d008      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
340080b2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340080b6:	4293      	cmp	r3, r2
340080b8:	d004      	beq.n	340080c4 <HAL_I2C_DeInit+0x4c>
340080ba:	f240 2199 	movw	r1, #665	@ 0x299
340080be:	4811      	ldr	r0, [pc, #68]	@ (34008104 <HAL_I2C_DeInit+0x8c>)
340080c0:	f7fa fa38 	bl	34002534 <assert_failed>
  hi2c->State = HAL_I2C_STATE_BUSY;
340080c4:	2324      	movs	r3, #36	@ 0x24
  __HAL_I2C_DISABLE(hi2c);
340080c6:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
340080c8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
340080cc:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
340080ce:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE(hi2c);
340080d0:	f023 0301 	bic.w	r3, r3, #1
340080d4:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
340080d6:	f7ff ffcd 	bl	34008074 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340080da:	2000      	movs	r0, #0
340080dc:	6460      	str	r0, [r4, #68]	@ 0x44
  __HAL_UNLOCK(hi2c);
340080de:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
340080e2:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
340080e6:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
340080e8:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
340080ec:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340080ee:	2001      	movs	r0, #1
340080f0:	e7fc      	b.n	340080ec <HAL_I2C_DeInit+0x74>
340080f2:	bf00      	nop
340080f4:	50005400 	.word	0x50005400
340080f8:	50005800 	.word	0x50005800
340080fc:	50005c00 	.word	0x50005c00
34008100:	56001c00 	.word	0x56001c00
34008104:	3401c42c 	.word	0x3401c42c

34008108 <HAL_I2C_Mem_Write>:
{
34008108:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3400810c:	4699      	mov	r9, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
3400810e:	3b01      	subs	r3, #1
34008110:	2b01      	cmp	r3, #1
{
34008112:	4604      	mov	r4, r0
34008114:	460f      	mov	r7, r1
34008116:	4616      	mov	r6, r2
34008118:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
3400811c:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
34008120:	d904      	bls.n	3400812c <HAL_I2C_Mem_Write+0x24>
34008122:	f640 2138 	movw	r1, #2616	@ 0xa38
34008126:	4868      	ldr	r0, [pc, #416]	@ (340082c8 <HAL_I2C_Mem_Write+0x1c0>)
34008128:	f7fa fa04 	bl	34002534 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
3400812c:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008130:	2b20      	cmp	r3, #32
34008132:	f040 80c6 	bne.w	340082c2 <HAL_I2C_Mem_Write+0x1ba>
    if ((pData == NULL) || (Size == 0U))
34008136:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
34008138:	b113      	cbz	r3, 34008140 <HAL_I2C_Mem_Write+0x38>
3400813a:	f1ba 0f00 	cmp.w	sl, #0
3400813e:	d106      	bne.n	3400814e <HAL_I2C_Mem_Write+0x46>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34008140:	f44f 7300 	mov.w	r3, #512	@ 0x200
34008144:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
34008146:	2001      	movs	r0, #1
}
34008148:	b003      	add	sp, #12
3400814a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
3400814e:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
34008152:	2b01      	cmp	r3, #1
34008154:	f000 80b5 	beq.w	340082c2 <HAL_I2C_Mem_Write+0x1ba>
34008158:	f04f 0b01 	mov.w	fp, #1
3400815c:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
34008160:	f7fc fb54 	bl	3400480c <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008164:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
34008166:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008168:	9000      	str	r0, [sp, #0]
3400816a:	465a      	mov	r2, fp
3400816c:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34008170:	4620      	mov	r0, r4
34008172:	f7ff fe5a 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
34008176:	2800      	cmp	r0, #0
34008178:	d1e5      	bne.n	34008146 <HAL_I2C_Mem_Write+0x3e>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
3400817a:	2321      	movs	r3, #33	@ 0x21
3400817c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
34008180:	2340      	movs	r3, #64	@ 0x40
34008182:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
34008186:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34008188:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
3400818a:	6263      	str	r3, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
3400818c:	4b4f      	ldr	r3, [pc, #316]	@ (340082cc <HAL_I2C_Mem_Write+0x1c4>)
    hi2c->XferISR   = NULL;
3400818e:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34008190:	4639      	mov	r1, r7
34008192:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
34008194:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34008198:	fa5f f289 	uxtb.w	r2, r9
3400819c:	9300      	str	r3, [sp, #0]
3400819e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340081a2:	f7ff fd31 	bl	34007c08 <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
340081a6:	462a      	mov	r2, r5
340081a8:	4641      	mov	r1, r8
340081aa:	4620      	mov	r0, r4
340081ac:	f7ff fe12 	bl	34007dd4 <I2C_WaitOnTXISFlagUntilTimeout>
340081b0:	bb18      	cbnz	r0, 340081fa <HAL_I2C_Mem_Write+0xf2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
340081b2:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340081b6:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
340081b8:	d115      	bne.n	340081e6 <HAL_I2C_Mem_Write+0xde>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340081ba:	b2f6      	uxtb	r6, r6
340081bc:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
340081be:	2200      	movs	r2, #0
340081c0:	4643      	mov	r3, r8
340081c2:	2180      	movs	r1, #128	@ 0x80
340081c4:	4620      	mov	r0, r4
340081c6:	9500      	str	r5, [sp, #0]
340081c8:	f7ff fe2f 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
340081cc:	b9a8      	cbnz	r0, 340081fa <HAL_I2C_Mem_Write+0xf2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
340081ce:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
340081d0:	b29b      	uxth	r3, r3
340081d2:	2bff      	cmp	r3, #255	@ 0xff
340081d4:	d815      	bhi.n	34008202 <HAL_I2C_Mem_Write+0xfa>
      hi2c->XferSize = hi2c->XferCount;
340081d6:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
340081d8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
340081dc:	b292      	uxth	r2, r2
340081de:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
340081e0:	9000      	str	r0, [sp, #0]
340081e2:	b2d2      	uxtb	r2, r2
340081e4:	e012      	b.n	3400820c <HAL_I2C_Mem_Write+0x104>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
340081e6:	0a32      	lsrs	r2, r6, #8
340081e8:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
340081ea:	4641      	mov	r1, r8
340081ec:	462a      	mov	r2, r5
340081ee:	4620      	mov	r0, r4
340081f0:	f7ff fdf0 	bl	34007dd4 <I2C_WaitOnTXISFlagUntilTimeout>
340081f4:	b908      	cbnz	r0, 340081fa <HAL_I2C_Mem_Write+0xf2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340081f6:	6823      	ldr	r3, [r4, #0]
340081f8:	e7df      	b.n	340081ba <HAL_I2C_Mem_Write+0xb2>
      __HAL_UNLOCK(hi2c);
340081fa:	2300      	movs	r3, #0
340081fc:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
34008200:	e7a1      	b.n	34008146 <HAL_I2C_Mem_Write+0x3e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
34008202:	22ff      	movs	r2, #255	@ 0xff
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
34008204:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
34008208:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
3400820a:	9000      	str	r0, [sp, #0]
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
3400820c:	4639      	mov	r1, r7
3400820e:	4620      	mov	r0, r4
34008210:	f7ff fcfa 	bl	34007c08 <I2C_TransferConfig>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34008214:	462a      	mov	r2, r5
34008216:	4641      	mov	r1, r8
34008218:	4620      	mov	r0, r4
3400821a:	f7ff fddb 	bl	34007dd4 <I2C_WaitOnTXISFlagUntilTimeout>
3400821e:	2800      	cmp	r0, #0
34008220:	d191      	bne.n	34008146 <HAL_I2C_Mem_Write+0x3e>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34008222:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34008224:	6822      	ldr	r2, [r4, #0]
34008226:	f813 1b01 	ldrb.w	r1, [r3], #1
3400822a:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
3400822c:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
3400822e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
34008230:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
34008232:	3b01      	subs	r3, #1
34008234:	b29b      	uxth	r3, r3
34008236:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008238:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
3400823a:	3a01      	subs	r2, #1
3400823c:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400823e:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
34008240:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008242:	b1b3      	cbz	r3, 34008272 <HAL_I2C_Mem_Write+0x16a>
34008244:	b9aa      	cbnz	r2, 34008272 <HAL_I2C_Mem_Write+0x16a>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
34008246:	4643      	mov	r3, r8
34008248:	2180      	movs	r1, #128	@ 0x80
3400824a:	4620      	mov	r0, r4
3400824c:	9500      	str	r5, [sp, #0]
3400824e:	f7ff fdec 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
34008252:	2800      	cmp	r0, #0
34008254:	f47f af77 	bne.w	34008146 <HAL_I2C_Mem_Write+0x3e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008258:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
3400825a:	b29b      	uxth	r3, r3
3400825c:	2bff      	cmp	r3, #255	@ 0xff
3400825e:	d928      	bls.n	340082b2 <HAL_I2C_Mem_Write+0x1aa>
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008260:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34008262:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008266:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34008268:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400826a:	4639      	mov	r1, r7
3400826c:	4620      	mov	r0, r4
3400826e:	f7ff fccb 	bl	34007c08 <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
34008272:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008274:	b29b      	uxth	r3, r3
34008276:	2b00      	cmp	r3, #0
34008278:	d1cc      	bne.n	34008214 <HAL_I2C_Mem_Write+0x10c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3400827a:	462a      	mov	r2, r5
3400827c:	4641      	mov	r1, r8
3400827e:	4620      	mov	r0, r4
34008280:	f7ff fe0e 	bl	34007ea0 <I2C_WaitOnSTOPFlagUntilTimeout>
34008284:	2800      	cmp	r0, #0
34008286:	f47f af5e 	bne.w	34008146 <HAL_I2C_Mem_Write+0x3e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400828a:	2120      	movs	r1, #32
3400828c:	6823      	ldr	r3, [r4, #0]
3400828e:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34008290:	685a      	ldr	r2, [r3, #4]
34008292:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
34008296:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
3400829a:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
3400829e:	f022 0201 	bic.w	r2, r2, #1
340082a2:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
340082a4:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
340082a8:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
340082ac:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
340082b0:	e74a      	b.n	34008148 <HAL_I2C_Mem_Write+0x40>
          hi2c->XferSize = hi2c->XferCount;
340082b2:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340082b4:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
340082b8:	b292      	uxth	r2, r2
340082ba:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340082bc:	9000      	str	r0, [sp, #0]
340082be:	b2d2      	uxtb	r2, r2
340082c0:	e7d3      	b.n	3400826a <HAL_I2C_Mem_Write+0x162>
    __HAL_LOCK(hi2c);
340082c2:	2002      	movs	r0, #2
340082c4:	e740      	b.n	34008148 <HAL_I2C_Mem_Write+0x40>
340082c6:	bf00      	nop
340082c8:	3401c42c 	.word	0x3401c42c
340082cc:	80002000 	.word	0x80002000

340082d0 <HAL_I2C_Mem_Read>:
{
340082d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340082d4:	4699      	mov	r9, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
340082d6:	3b01      	subs	r3, #1
340082d8:	2b01      	cmp	r3, #1
{
340082da:	4604      	mov	r4, r0
340082dc:	460f      	mov	r7, r1
340082de:	4616      	mov	r6, r2
340082e0:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
340082e4:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
340082e8:	d904      	bls.n	340082f4 <HAL_I2C_Mem_Read+0x24>
340082ea:	f640 21c1 	movw	r1, #2753	@ 0xac1
340082ee:	4869      	ldr	r0, [pc, #420]	@ (34008494 <HAL_I2C_Mem_Read+0x1c4>)
340082f0:	f7fa f920 	bl	34002534 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
340082f4:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
340082f8:	2b20      	cmp	r3, #32
340082fa:	f040 80c9 	bne.w	34008490 <HAL_I2C_Mem_Read+0x1c0>
    if ((pData == NULL) || (Size == 0U))
340082fe:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
34008300:	b113      	cbz	r3, 34008308 <HAL_I2C_Mem_Read+0x38>
34008302:	f1ba 0f00 	cmp.w	sl, #0
34008306:	d106      	bne.n	34008316 <HAL_I2C_Mem_Read+0x46>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34008308:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400830c:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
3400830e:	2001      	movs	r0, #1
}
34008310:	b003      	add	sp, #12
34008312:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
34008316:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
3400831a:	2b01      	cmp	r3, #1
3400831c:	f000 80b8 	beq.w	34008490 <HAL_I2C_Mem_Read+0x1c0>
34008320:	f04f 0b01 	mov.w	fp, #1
34008324:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
34008328:	f7fc fa70 	bl	3400480c <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3400832c:	2319      	movs	r3, #25
3400832e:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
34008330:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008332:	465a      	mov	r2, fp
34008334:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34008338:	4620      	mov	r0, r4
3400833a:	f7ff fd76 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
3400833e:	4603      	mov	r3, r0
34008340:	2800      	cmp	r0, #0
34008342:	d1e4      	bne.n	3400830e <HAL_I2C_Mem_Read+0x3e>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
34008344:	2222      	movs	r2, #34	@ 0x22
34008346:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3400834a:	2240      	movs	r2, #64	@ 0x40
3400834c:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
34008350:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34008352:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
34008354:	6262      	str	r2, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34008356:	4a50      	ldr	r2, [pc, #320]	@ (34008498 <HAL_I2C_Mem_Read+0x1c8>)
    hi2c->XferISR   = NULL;
34008358:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
3400835a:	4639      	mov	r1, r7
3400835c:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
3400835e:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34008362:	9200      	str	r2, [sp, #0]
34008364:	fa5f f289 	uxtb.w	r2, r9
34008368:	f7ff fc4e 	bl	34007c08 <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400836c:	462a      	mov	r2, r5
3400836e:	4641      	mov	r1, r8
34008370:	4620      	mov	r0, r4
34008372:	f7ff fd2f 	bl	34007dd4 <I2C_WaitOnTXISFlagUntilTimeout>
34008376:	bb20      	cbnz	r0, 340083c2 <HAL_I2C_Mem_Read+0xf2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34008378:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400837c:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400837e:	d116      	bne.n	340083ae <HAL_I2C_Mem_Read+0xde>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34008380:	b2f6      	uxtb	r6, r6
34008382:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
34008384:	2200      	movs	r2, #0
34008386:	4643      	mov	r3, r8
34008388:	2140      	movs	r1, #64	@ 0x40
3400838a:	4620      	mov	r0, r4
3400838c:	9500      	str	r5, [sp, #0]
3400838e:	f7ff fd4c 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
34008392:	b9b0      	cbnz	r0, 340083c2 <HAL_I2C_Mem_Read+0xf2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008394:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008396:	b29b      	uxth	r3, r3
34008398:	2bff      	cmp	r3, #255	@ 0xff
3400839a:	4b40      	ldr	r3, [pc, #256]	@ (3400849c <HAL_I2C_Mem_Read+0x1cc>)
3400839c:	d815      	bhi.n	340083ca <HAL_I2C_Mem_Read+0xfa>
      hi2c->XferSize = hi2c->XferCount;
3400839e:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
340083a0:	b292      	uxth	r2, r2
340083a2:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340083a4:	9300      	str	r3, [sp, #0]
340083a6:	b2d2      	uxtb	r2, r2
340083a8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
340083ac:	e012      	b.n	340083d4 <HAL_I2C_Mem_Read+0x104>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
340083ae:	0a32      	lsrs	r2, r6, #8
340083b0:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
340083b2:	4641      	mov	r1, r8
340083b4:	462a      	mov	r2, r5
340083b6:	4620      	mov	r0, r4
340083b8:	f7ff fd0c 	bl	34007dd4 <I2C_WaitOnTXISFlagUntilTimeout>
340083bc:	b908      	cbnz	r0, 340083c2 <HAL_I2C_Mem_Read+0xf2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340083be:	6823      	ldr	r3, [r4, #0]
340083c0:	e7de      	b.n	34008380 <HAL_I2C_Mem_Read+0xb0>
      __HAL_UNLOCK(hi2c);
340083c2:	2300      	movs	r3, #0
340083c4:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
340083c8:	e7a1      	b.n	3400830e <HAL_I2C_Mem_Read+0x3e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
340083ca:	22ff      	movs	r2, #255	@ 0xff
340083cc:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
340083ce:	9300      	str	r3, [sp, #0]
340083d0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340083d4:	4639      	mov	r1, r7
340083d6:	4620      	mov	r0, r4
340083d8:	f7ff fc16 	bl	34007c08 <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
340083dc:	4643      	mov	r3, r8
340083de:	2200      	movs	r2, #0
340083e0:	2104      	movs	r1, #4
340083e2:	4620      	mov	r0, r4
340083e4:	9500      	str	r5, [sp, #0]
340083e6:	f7ff fd20 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
340083ea:	2800      	cmp	r0, #0
340083ec:	d18f      	bne.n	3400830e <HAL_I2C_Mem_Read+0x3e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340083ee:	6823      	ldr	r3, [r4, #0]
340083f0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340083f2:	6a63      	ldr	r3, [r4, #36]	@ 0x24
340083f4:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
340083f6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
340083f8:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
340083fa:	3301      	adds	r3, #1
340083fc:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
340083fe:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
34008400:	3a01      	subs	r2, #1
      hi2c->XferCount--;
34008402:	3b01      	subs	r3, #1
34008404:	b29b      	uxth	r3, r3
34008406:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008408:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
3400840a:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400840c:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
3400840e:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008410:	b1b3      	cbz	r3, 34008440 <HAL_I2C_Mem_Read+0x170>
34008412:	b9aa      	cbnz	r2, 34008440 <HAL_I2C_Mem_Read+0x170>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
34008414:	4643      	mov	r3, r8
34008416:	2180      	movs	r1, #128	@ 0x80
34008418:	4620      	mov	r0, r4
3400841a:	9500      	str	r5, [sp, #0]
3400841c:	f7ff fd05 	bl	34007e2a <I2C_WaitOnFlagUntilTimeout>
34008420:	2800      	cmp	r0, #0
34008422:	f47f af74 	bne.w	3400830e <HAL_I2C_Mem_Read+0x3e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008426:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008428:	b29b      	uxth	r3, r3
3400842a:	2bff      	cmp	r3, #255	@ 0xff
3400842c:	d928      	bls.n	34008480 <HAL_I2C_Mem_Read+0x1b0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
3400842e:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34008430:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008434:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34008436:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008438:	4639      	mov	r1, r7
3400843a:	4620      	mov	r0, r4
3400843c:	f7ff fbe4 	bl	34007c08 <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
34008440:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008442:	b29b      	uxth	r3, r3
34008444:	2b00      	cmp	r3, #0
34008446:	d1c9      	bne.n	340083dc <HAL_I2C_Mem_Read+0x10c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34008448:	462a      	mov	r2, r5
3400844a:	4641      	mov	r1, r8
3400844c:	4620      	mov	r0, r4
3400844e:	f7ff fd27 	bl	34007ea0 <I2C_WaitOnSTOPFlagUntilTimeout>
34008452:	2800      	cmp	r0, #0
34008454:	f47f af5b 	bne.w	3400830e <HAL_I2C_Mem_Read+0x3e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34008458:	2120      	movs	r1, #32
3400845a:	6823      	ldr	r3, [r4, #0]
3400845c:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
3400845e:	685a      	ldr	r2, [r3, #4]
34008460:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
34008464:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
34008468:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
3400846c:	f022 0201 	bic.w	r2, r2, #1
34008470:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
34008472:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34008476:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3400847a:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
3400847e:	e747      	b.n	34008310 <HAL_I2C_Mem_Read+0x40>
          hi2c->XferSize = hi2c->XferCount;
34008480:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008482:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
34008486:	b292      	uxth	r2, r2
34008488:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400848a:	9000      	str	r0, [sp, #0]
3400848c:	b2d2      	uxtb	r2, r2
3400848e:	e7d3      	b.n	34008438 <HAL_I2C_Mem_Read+0x168>
    __HAL_LOCK(hi2c);
34008490:	2002      	movs	r0, #2
34008492:	e73d      	b.n	34008310 <HAL_I2C_Mem_Read+0x40>
34008494:	3401c42c 	.word	0x3401c42c
34008498:	80002000 	.word	0x80002000
3400849c:	80002400 	.word	0x80002400

340084a0 <HAL_I2C_GetState>:
  return hi2c->State;
340084a0:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
340084a4:	4770      	bx	lr

340084a6 <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
340084a6:	6c40      	ldr	r0, [r0, #68]	@ 0x44
}
340084a8:	4770      	bx	lr
	...

340084ac <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
340084ac:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
340084ae:	4a27      	ldr	r2, [pc, #156]	@ (3400854c <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
340084b0:	6803      	ldr	r3, [r0, #0]
{
340084b2:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
340084b4:	4293      	cmp	r3, r2
{
340084b6:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
340084b8:	d01c      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084ba:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340084be:	4293      	cmp	r3, r2
340084c0:	d018      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084c2:	4a23      	ldr	r2, [pc, #140]	@ (34008550 <HAL_I2CEx_ConfigAnalogFilter+0xa4>)
340084c4:	4293      	cmp	r3, r2
340084c6:	d015      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084c8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340084cc:	4293      	cmp	r3, r2
340084ce:	d011      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084d0:	4a20      	ldr	r2, [pc, #128]	@ (34008554 <HAL_I2CEx_ConfigAnalogFilter+0xa8>)
340084d2:	4293      	cmp	r3, r2
340084d4:	d00e      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084d6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340084da:	4293      	cmp	r3, r2
340084dc:	d00a      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084de:	4a1e      	ldr	r2, [pc, #120]	@ (34008558 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
340084e0:	4293      	cmp	r3, r2
340084e2:	d007      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084e4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340084e8:	4293      	cmp	r3, r2
340084ea:	d003      	beq.n	340084f4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340084ec:	2162      	movs	r1, #98	@ 0x62
340084ee:	481b      	ldr	r0, [pc, #108]	@ (3400855c <HAL_I2CEx_ConfigAnalogFilter+0xb0>)
340084f0:	f7fa f820 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
340084f4:	f435 5380 	bics.w	r3, r5, #4096	@ 0x1000
340084f8:	d003      	beq.n	34008502 <HAL_I2CEx_ConfigAnalogFilter+0x56>
340084fa:	2163      	movs	r1, #99	@ 0x63
340084fc:	4817      	ldr	r0, [pc, #92]	@ (3400855c <HAL_I2CEx_ConfigAnalogFilter+0xb0>)
340084fe:	f7fa f819 	bl	34002534 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
34008502:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008506:	2b20      	cmp	r3, #32
34008508:	b2d9      	uxtb	r1, r3
3400850a:	d11c      	bne.n	34008546 <HAL_I2CEx_ConfigAnalogFilter+0x9a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3400850c:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
34008510:	2b01      	cmp	r3, #1
34008512:	d018      	beq.n	34008546 <HAL_I2CEx_ConfigAnalogFilter+0x9a>

    hi2c->State = HAL_I2C_STATE_BUSY;
34008514:	2324      	movs	r3, #36	@ 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34008516:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
34008518:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    __HAL_I2C_DISABLE(hi2c);
3400851c:	6823      	ldr	r3, [r4, #0]
3400851e:	681a      	ldr	r2, [r3, #0]
34008520:	f022 0201 	bic.w	r2, r2, #1
34008524:	601a      	str	r2, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
34008526:	681a      	ldr	r2, [r3, #0]
34008528:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
3400852c:	601a      	str	r2, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
3400852e:	681a      	ldr	r2, [r3, #0]
34008530:	432a      	orrs	r2, r5
34008532:	601a      	str	r2, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
34008534:	681a      	ldr	r2, [r3, #0]
34008536:	f042 0201 	orr.w	r2, r2, #1
3400853a:	601a      	str	r2, [r3, #0]
    hi2c->State = HAL_I2C_STATE_READY;
3400853c:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34008540:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
34008544:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hi2c);
34008546:	2002      	movs	r0, #2
34008548:	e7fc      	b.n	34008544 <HAL_I2CEx_ConfigAnalogFilter+0x98>
3400854a:	bf00      	nop
3400854c:	50005400 	.word	0x50005400
34008550:	50005800 	.word	0x50005800
34008554:	50005c00 	.word	0x50005c00
34008558:	56001c00 	.word	0x56001c00
3400855c:	3401c49a 	.word	0x3401c49a

34008560 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
34008560:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008562:	4a26      	ldr	r2, [pc, #152]	@ (340085fc <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
34008564:	6803      	ldr	r3, [r0, #0]
{
34008566:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008568:	4293      	cmp	r3, r2
{
3400856a:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
3400856c:	d01c      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
3400856e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008572:	4293      	cmp	r3, r2
34008574:	d018      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008576:	4a22      	ldr	r2, [pc, #136]	@ (34008600 <HAL_I2CEx_ConfigDigitalFilter+0xa0>)
34008578:	4293      	cmp	r3, r2
3400857a:	d015      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
3400857c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008580:	4293      	cmp	r3, r2
34008582:	d011      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008584:	4a1f      	ldr	r2, [pc, #124]	@ (34008604 <HAL_I2CEx_ConfigDigitalFilter+0xa4>)
34008586:	4293      	cmp	r3, r2
34008588:	d00e      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
3400858a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400858e:	4293      	cmp	r3, r2
34008590:	d00a      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008592:	4a1d      	ldr	r2, [pc, #116]	@ (34008608 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
34008594:	4293      	cmp	r3, r2
34008596:	d007      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008598:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400859c:	4293      	cmp	r3, r2
3400859e:	d003      	beq.n	340085a8 <HAL_I2CEx_ConfigDigitalFilter+0x48>
340085a0:	2190      	movs	r1, #144	@ 0x90
340085a2:	481a      	ldr	r0, [pc, #104]	@ (3400860c <HAL_I2CEx_ConfigDigitalFilter+0xac>)
340085a4:	f7f9 ffc6 	bl	34002534 <assert_failed>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
340085a8:	2d0f      	cmp	r5, #15
340085aa:	d903      	bls.n	340085b4 <HAL_I2CEx_ConfigDigitalFilter+0x54>
340085ac:	2191      	movs	r1, #145	@ 0x91
340085ae:	4817      	ldr	r0, [pc, #92]	@ (3400860c <HAL_I2CEx_ConfigDigitalFilter+0xac>)
340085b0:	f7f9 ffc0 	bl	34002534 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
340085b4:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
340085b8:	2b20      	cmp	r3, #32
340085ba:	b2d8      	uxtb	r0, r3
340085bc:	d11b      	bne.n	340085f6 <HAL_I2CEx_ConfigDigitalFilter+0x96>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
340085be:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
340085c2:	2b01      	cmp	r3, #1
340085c4:	d017      	beq.n	340085f6 <HAL_I2CEx_ConfigDigitalFilter+0x96>

    hi2c->State = HAL_I2C_STATE_BUSY;
340085c6:	2324      	movs	r3, #36	@ 0x24
340085c8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
340085cc:	6823      	ldr	r3, [r4, #0]
340085ce:	681a      	ldr	r2, [r3, #0]
340085d0:	f022 0201 	bic.w	r2, r2, #1
340085d4:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
340085d6:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
340085d8:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
340085dc:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
340085e0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
340085e2:	681a      	ldr	r2, [r3, #0]
340085e4:	f042 0201 	orr.w	r2, r2, #1
340085e8:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
340085ea:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340085ee:	2000      	movs	r0, #0
340085f0:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
340085f4:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hi2c);
340085f6:	2002      	movs	r0, #2
340085f8:	e7fc      	b.n	340085f4 <HAL_I2CEx_ConfigDigitalFilter+0x94>
340085fa:	bf00      	nop
340085fc:	50005400 	.word	0x50005400
34008600:	50005800 	.word	0x50005800
34008604:	50005c00 	.word	0x50005c00
34008608:	56001c00 	.word	0x56001c00
3400860c:	3401c49a 	.word	0x3401c49a

34008610 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
34008610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008614:	2634      	movs	r6, #52	@ 0x34
{
34008616:	b087      	sub	sp, #28
34008618:	f8dd c040 	ldr.w	ip, [sp, #64]	@ 0x40
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3400861c:	6804      	ldr	r4, [r0, #0]
3400861e:	fb06 060c 	mla	r6, r6, ip, r0

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008622:	f8d6 e048 	ldr.w	lr, [r6, #72]	@ 0x48
{
34008626:	e9cd 2302 	strd	r2, r3, [sp, #8]
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3400862a:	6e75      	ldr	r5, [r6, #100]	@ 0x64
3400862c:	f10c 0301 	add.w	r3, ip, #1
34008630:	eb04 2303 	add.w	r3, r4, r3, lsl #8
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008634:	f1be 0f03 	cmp.w	lr, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008638:	63dd      	str	r5, [r3, #60]	@ 0x3c
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400863a:	d84c      	bhi.n	340086d6 <LTDC_SetConfig+0xc6>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
3400863c:	2604      	movs	r6, #4
      stride = 1U;
      break;
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3400863e:	2734      	movs	r7, #52	@ 0x34
34008640:	fb07 000c 	mla	r0, r7, ip, r0
34008644:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34008648:	f8d0 b038 	ldr.w	fp, [r0, #56]	@ 0x38
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400864c:	68e7      	ldr	r7, [r4, #12]
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3400864e:	f8d0 803c 	ldr.w	r8, [r0, #60]	@ 0x3c
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008652:	f10b 0901 	add.w	r9, fp, #1
34008656:	f3c7 470b 	ubfx	r7, r7, #16, #12
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3400865a:	f3cc 4c0b 	ubfx	ip, ip, #16, #12
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400865e:	444f      	add	r7, r9
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008660:	44c4      	add	ip, r8
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008662:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34008666:	611f      	str	r7, [r3, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008668:	6c47      	ldr	r7, [r0, #68]	@ 0x44
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400866a:	6c02      	ldr	r2, [r0, #64]	@ 0x40
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3400866c:	9704      	str	r7, [sp, #16]
3400866e:	68e7      	ldr	r7, [r4, #12]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008670:	68e4      	ldr	r4, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34008672:	9205      	str	r2, [sp, #20]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008674:	f3c4 0c0b 	ubfx	ip, r4, #0, #12
34008678:	1c54      	adds	r4, r2, #1
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3400867a:	9a04      	ldr	r2, [sp, #16]
3400867c:	f3c7 070b 	ubfx	r7, r7, #0, #12
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008680:	4464      	add	r4, ip
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008682:	4417      	add	r7, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008684:	ea44 4407 	orr.w	r4, r4, r7, lsl #16

  if (Mirror == LTDC_MIRROR_NONE)
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008688:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400868a:	615c      	str	r4, [r3, #20]
        /* Configure the auxiliary frame buffer address 1 */
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;

        /* Configure the buffer length */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400868c:	eba8 040b 	sub.w	r4, r8, fp
        break;
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
34008690:	fb04 f906 	mul.w	r9, r4, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008694:	9201      	str	r2, [sp, #4]
  if (Mirror == LTDC_MIRROR_NONE)
34008696:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34008698:	6e00      	ldr	r0, [r0, #96]	@ 0x60
  if (Mirror == LTDC_MIRROR_NONE)
3400869a:	2a03      	cmp	r2, #3
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400869c:	fb00 fc06 	mul.w	ip, r0, r6
                                            stride)  + 7U));
340086a0:	f109 0a07 	add.w	sl, r9, #7
  if (Mirror == LTDC_MIRROR_NONE)
340086a4:	d145      	bne.n	34008732 <LTDC_SetConfig+0x122>
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340086a6:	f240 160d 	movw	r6, #269	@ 0x10d
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
340086aa:	9a01      	ldr	r2, [sp, #4]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340086ac:	45b6      	cmp	lr, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
340086ae:	635a      	str	r2, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340086b0:	d02a      	beq.n	34008708 <LTDC_SetConfig+0xf8>
340086b2:	f240 260d 	movw	r6, #525	@ 0x20d
340086b6:	45b6      	cmp	lr, r6
340086b8:	d031      	beq.n	3400871e <LTDC_SetConfig+0x10e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
340086ba:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
340086be:	639a      	str	r2, [r3, #56]	@ 0x38
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
340086c0:	68da      	ldr	r2, [r3, #12]
340086c2:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
340086c6:	f022 0201 	bic.w	r2, r2, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
340086ca:	f042 0201 	orr.w	r2, r2, #1
340086ce:	60da      	str	r2, [r3, #12]
  }
}
340086d0:	b007      	add	sp, #28
340086d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340086d6:	f1ae 0704 	sub.w	r7, lr, #4
340086da:	2f09      	cmp	r7, #9
340086dc:	f04f 0601 	mov.w	r6, #1
340086e0:	d8ad      	bhi.n	3400863e <LTDC_SetConfig+0x2e>
340086e2:	f240 299b 	movw	r9, #667	@ 0x29b
340086e6:	fa06 f807 	lsl.w	r8, r6, r7
340086ea:	ea18 0f09 	tst.w	r8, r9
340086ee:	d107      	bne.n	34008700 <LTDC_SetConfig+0xf0>
340086f0:	2f02      	cmp	r7, #2
340086f2:	d007      	beq.n	34008704 <LTDC_SetConfig+0xf4>
340086f4:	2f08      	cmp	r7, #8
340086f6:	d1a2      	bne.n	3400863e <LTDC_SetConfig+0x2e>
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
340086f8:	6f9e      	ldr	r6, [r3, #120]	@ 0x78
340086fa:	f3c6 4682 	ubfx	r6, r6, #18, #3
      break;
340086fe:	e79e      	b.n	3400863e <LTDC_SetConfig+0x2e>
      stride = 2U;
34008700:	2602      	movs	r6, #2
34008702:	e79c      	b.n	3400863e <LTDC_SetConfig+0x2e>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008704:	2603      	movs	r6, #3
34008706:	e79a      	b.n	3400863e <LTDC_SetConfig+0x2e>
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
34008708:	f108 0207 	add.w	r2, r8, #7
3400870c:	eba2 020b 	sub.w	r2, r2, fp
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34008710:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34008714:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34008716:	649a      	str	r2, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
34008718:	086d      	lsrs	r5, r5, #1
3400871a:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
3400871c:	e7cd      	b.n	340086ba <LTDC_SetConfig+0xaa>
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400871e:	0864      	lsrs	r4, r4, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34008720:	9a02      	ldr	r2, [sp, #8]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008722:	0840      	lsrs	r0, r0, #1
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008724:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008726:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3400872a:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
3400872c:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400872e:	649c      	str	r4, [r3, #72]	@ 0x48
34008730:	e7f2      	b.n	34008718 <LTDC_SetConfig+0x108>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
34008732:	9a03      	ldr	r2, [sp, #12]
34008734:	bb3a      	cbnz	r2, 34008786 <LTDC_SetConfig+0x176>
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34008736:	9a01      	ldr	r2, [sp, #4]
34008738:	1e57      	subs	r7, r2, #1
3400873a:	444f      	add	r7, r9
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400873c:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400873e:	f240 170d 	movw	r7, #269	@ 0x10d
34008742:	45be      	cmp	lr, r7
34008744:	d00a      	beq.n	3400875c <LTDC_SetConfig+0x14c>
34008746:	f240 270d 	movw	r7, #525	@ 0x20d
3400874a:	45be      	cmp	lr, r7
3400874c:	d010      	beq.n	34008770 <LTDC_SetConfig+0x160>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400874e:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
34008752:	639a      	str	r2, [r3, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34008754:	68da      	ldr	r2, [r3, #12]
34008756:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
3400875a:	e7b6      	b.n	340086ca <LTDC_SetConfig+0xba>
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400875c:	3901      	subs	r1, #1
3400875e:	4449      	add	r1, r9
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008760:	6419      	str	r1, [r3, #64]	@ 0x40
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008762:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008764:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008768:	086d      	lsrs	r5, r5, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400876a:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400876c:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
3400876e:	e7ee      	b.n	3400874e <LTDC_SetConfig+0x13e>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008770:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008772:	4366      	muls	r6, r4
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008774:	9a02      	ldr	r2, [sp, #8]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008776:	3901      	subs	r1, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008778:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400877a:	4431      	add	r1, r6
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400877c:	4432      	add	r2, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400877e:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008780:	0840      	lsrs	r0, r0, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008782:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008784:	e7ed      	b.n	34008762 <LTDC_SetConfig+0x152>
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34008786:	e9dd 2704 	ldrd	r2, r7, [sp, #16]
3400878a:	eba2 0807 	sub.w	r8, r2, r7
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3400878e:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008790:	f5cc 4c00 	rsb	ip, ip, #32768	@ 0x8000
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34008794:	2a01      	cmp	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008796:	ea4a 4c0c 	orr.w	ip, sl, ip, lsl #16
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3400879a:	d131      	bne.n	34008800 <LTDC_SetConfig+0x1f0>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400879c:	9a01      	ldr	r2, [sp, #4]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400879e:	f108 3aff 	add.w	sl, r8, #4294967295
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
340087a2:	fb09 270a 	mla	r7, r9, sl, r2
340087a6:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340087a8:	f240 170d 	movw	r7, #269	@ 0x10d
340087ac:	45be      	cmp	lr, r7
340087ae:	d006      	beq.n	340087be <LTDC_SetConfig+0x1ae>
340087b0:	f240 270d 	movw	r7, #525	@ 0x20d
340087b4:	45be      	cmp	lr, r7
340087b6:	d00d      	beq.n	340087d4 <LTDC_SetConfig+0x1c4>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
340087b8:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
340087bc:	e780      	b.n	340086c0 <LTDC_SetConfig+0xb0>
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340087be:	ea4f 0258 	mov.w	r2, r8, lsr #1
340087c2:	3a01      	subs	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340087c4:	fb09 1202 	mla	r2, r9, r2, r1
340087c8:	641a      	str	r2, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
340087ca:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
340087ce:	086d      	lsrs	r5, r5, #1
340087d0:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
340087d2:	e7f1      	b.n	340087b8 <LTDC_SetConfig+0x1a8>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340087d4:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
340087d6:	4374      	muls	r4, r6
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340087d8:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340087dc:	0840      	lsrs	r0, r0, #1
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340087de:	f108 38ff 	add.w	r8, r8, #4294967295
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340087e2:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340087e6:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340087ea:	4370      	muls	r0, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340087ec:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
340087ee:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340087f0:	4441      	add	r1, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340087f2:	4442      	add	r2, r8
                                               stride) << 16U) |
340087f4:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340087f8:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340087fa:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340087fc:	649c      	str	r4, [r3, #72]	@ 0x48
340087fe:	e7e6      	b.n	340087ce <LTDC_SetConfig+0x1be>
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
34008800:	9a01      	ldr	r2, [sp, #4]
34008802:	1e57      	subs	r7, r2, #1
34008804:	fb09 7708 	mla	r7, r9, r8, r7
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008808:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400880a:	f240 170d 	movw	r7, #269	@ 0x10d
3400880e:	45be      	cmp	lr, r7
34008810:	d006      	beq.n	34008820 <LTDC_SetConfig+0x210>
34008812:	f240 270d 	movw	r7, #525	@ 0x20d
34008816:	45be      	cmp	lr, r7
34008818:	d00d      	beq.n	34008836 <LTDC_SetConfig+0x226>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400881a:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
3400881e:	e799      	b.n	34008754 <LTDC_SetConfig+0x144>
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008820:	ea4f 0858 	mov.w	r8, r8, lsr #1
34008824:	3901      	subs	r1, #1
34008826:	fb09 1108 	mla	r1, r9, r8, r1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400882a:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400882c:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008830:	086d      	lsrs	r5, r5, #1
34008832:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008834:	e7f1      	b.n	3400881a <LTDC_SetConfig+0x20a>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008836:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008838:	4374      	muls	r4, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400883a:	0840      	lsrs	r0, r0, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400883c:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008840:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008844:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008848:	4370      	muls	r0, r6
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400884a:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400884c:	3901      	subs	r1, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400884e:	3a01      	subs	r2, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34008850:	3407      	adds	r4, #7
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008852:	4442      	add	r2, r8
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008854:	4441      	add	r1, r8
                                              << 16U) |
34008856:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400885a:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400885c:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400885e:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
34008860:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34008862:	f36f 020f 	bfc	r2, #0, #16
34008866:	64da      	str	r2, [r3, #76]	@ 0x4c
34008868:	e7e2      	b.n	34008830 <LTDC_SetConfig+0x220>
	...

3400886c <LTDC_SetCompositionConfig>:

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3400886c:	6802      	ldr	r2, [r0, #0]
3400886e:	1c4b      	adds	r3, r1, #1
34008870:	eb02 2203 	add.w	r2, r2, r3, lsl #8
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
34008874:	2334      	movs	r3, #52	@ 0x34
34008876:	fb03 0101 	mla	r1, r3, r1, r0
3400887a:	6d08      	ldr	r0, [r1, #80]	@ 0x50
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3400887c:	f891 3068 	ldrb.w	r3, [r1, #104]	@ 0x68
34008880:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
34008884:	f891 0069 	ldrb.w	r0, [r1, #105]	@ 0x69
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008888:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
3400888c:	f891 006a 	ldrb.w	r0, [r1, #106]	@ 0x6a
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008890:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34008894:	6253      	str	r3, [r2, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
34008896:	6a13      	ldr	r3, [r2, #32]
34008898:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400889c:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
3400889e:	6ccb      	ldr	r3, [r1, #76]	@ 0x4c
340088a0:	6213      	str	r3, [r2, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
340088a2:	6a90      	ldr	r0, [r2, #40]	@ 0x28
340088a4:	4b05      	ldr	r3, [pc, #20]	@ (340088bc <LTDC_SetCompositionConfig+0x50>)
340088a6:	4003      	ands	r3, r0
340088a8:	6293      	str	r3, [r2, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
340088aa:	6a90      	ldr	r0, [r2, #40]	@ 0x28
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
340088ac:	e9d1 3115 	ldrd	r3, r1, [r1, #84]	@ 0x54
340088b0:	430b      	orrs	r3, r1
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
340088b2:	f400 3180 	and.w	r1, r0, #65536	@ 0x10000
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
340088b6:	430b      	orrs	r3, r1
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
340088b8:	6293      	str	r3, [r2, #40]	@ 0x28
}
340088ba:	4770      	bx	lr
340088bc:	fffef8f8 	.word	0xfffef8f8

340088c0 <LTDC_SetPredefFormat>:
  uint32_t BPOS = 0U;
  uint32_t GLEN = 0U;
  uint32_t GPOS = 0U;

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340088c0:	2334      	movs	r3, #52	@ 0x34
340088c2:	fb03 0301 	mla	r3, r3, r1, r0
340088c6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
{
340088c8:	b5f0      	push	{r4, r5, r6, r7, lr}
340088ca:	1fd4      	subs	r4, r2, #7
340088cc:	2c04      	cmp	r4, #4
340088ce:	d823      	bhi.n	34008918 <LTDC_SetPredefFormat+0x58>
340088d0:	4a16      	ldr	r2, [pc, #88]	@ (3400892c <LTDC_SetPredefFormat+0x6c>)
340088d2:	f8df c06c 	ldr.w	ip, [pc, #108]	@ 34008940 <LTDC_SetPredefFormat+0x80>
340088d6:	5d16      	ldrb	r6, [r2, r4]
340088d8:	4a15      	ldr	r2, [pc, #84]	@ (34008930 <LTDC_SetPredefFormat+0x70>)
340088da:	4b16      	ldr	r3, [pc, #88]	@ (34008934 <LTDC_SetPredefFormat+0x74>)
340088dc:	5d17      	ldrb	r7, [r2, r4]
340088de:	4a16      	ldr	r2, [pc, #88]	@ (34008938 <LTDC_SetPredefFormat+0x78>)
340088e0:	5d1b      	ldrb	r3, [r3, r4]
340088e2:	5d15      	ldrb	r5, [r2, r4]
340088e4:	4a15      	ldr	r2, [pc, #84]	@ (3400893c <LTDC_SetPredefFormat+0x7c>)
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
340088e6:	049b      	lsls	r3, r3, #18
340088e8:	5d12      	ldrb	r2, [r2, r4]
340088ea:	f81c 4004 	ldrb.w	r4, [ip, r4]
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
340088ee:	f101 0c01 	add.w	ip, r1, #1
340088f2:	6801      	ldr	r1, [r0, #0]
340088f4:	2007      	movs	r0, #7
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
340088f6:	0252      	lsls	r2, r2, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
340088f8:	eb02 3285 	add.w	r2, r2, r5, lsl #14
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
340088fc:	443a      	add	r2, r7
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
340088fe:	eb03 3385 	add.w	r3, r3, r5, lsl #14
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34008902:	eb01 210c 	add.w	r1, r1, ip, lsl #8
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34008906:	eb02 1246 	add.w	r2, r2, r6, lsl #5
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400890a:	4423      	add	r3, r4
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
3400890c:	61c8      	str	r0, [r1, #28]
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400890e:	eb03 1345 	add.w	r3, r3, r5, lsl #5
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34008912:	674a      	str	r2, [r1, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
34008914:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
    default:
      break;
  }
}
34008916:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008918:	2a06      	cmp	r2, #6
3400891a:	d8fc      	bhi.n	34008916 <LTDC_SetPredefFormat+0x56>
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
3400891c:	6803      	ldr	r3, [r0, #0]
3400891e:	3101      	adds	r1, #1
34008920:	eb03 2101 	add.w	r1, r3, r1, lsl #8
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34008924:	2300      	movs	r3, #0
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34008926:	61ca      	str	r2, [r1, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34008928:	674b      	str	r3, [r1, #116]	@ 0x74
3400892a:	e7f3      	b.n	34008914 <LTDC_SetPredefFormat+0x54>
3400892c:	34034eec 	.word	0x34034eec
34008930:	34034ee7 	.word	0x34034ee7
34008934:	34034ef1 	.word	0x34034ef1
34008938:	34034ee2 	.word	0x34034ee2
3400893c:	34034edd 	.word	0x34034edd
34008940:	34034ed8 	.word	0x34034ed8

34008944 <LTDC_RetrieveUserConfig.constprop.0>:
static void LTDC_RetrieveUserConfig(LTDC_HandleTypeDef *hltdc, uint32_t *Mirror, uint32_t *Aux0Addr,
34008944:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34008948:	468c      	mov	ip, r1
3400894a:	9907      	ldr	r1, [sp, #28]
  const uint32_t hmirror = ((LTDC_LAYER(hltdc, LayerIdx)->CR) & LTDC_LxCR_HMEN_Msk);
3400894c:	6805      	ldr	r5, [r0, #0]
3400894e:	1c4c      	adds	r4, r1, #1
34008950:	eb05 2504 	add.w	r5, r5, r4, lsl #8
34008954:	68ec      	ldr	r4, [r5, #12]
34008956:	f404 7e80 	and.w	lr, r4, #256	@ 0x100
  const uint32_t pitchSign = (LTDC_LAYER(hltdc, LayerIdx)->CFBLR & LTDC_LxCFBLR_CFBP) & LTDC_PITCH_SIGN_MSK;
3400895a:	6bac      	ldr	r4, [r5, #56]	@ 0x38
3400895c:	f004 4880 	and.w	r8, r4, #1073741824	@ 0x40000000
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008960:	2434      	movs	r4, #52	@ 0x34
34008962:	fb04 0401 	mla	r4, r4, r1, r0
34008966:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
34008968:	2e03      	cmp	r6, #3
3400896a:	d813      	bhi.n	34008994 <LTDC_RetrieveUserConfig.constprop.0+0x50>
      stride = 4U;
3400896c:	2404      	movs	r4, #4
  if ((pitchSign == 0U) && (hmirror == 0U))
3400896e:	f1b8 0f00 	cmp.w	r8, #0
34008972:	d153      	bne.n	34008a1c <LTDC_RetrieveUserConfig.constprop.0+0xd8>
34008974:	2734      	movs	r7, #52	@ 0x34
34008976:	f1be 0f00 	cmp.w	lr, #0
3400897a:	d123      	bne.n	340089c4 <LTDC_RetrieveUserConfig.constprop.0+0x80>
    *Mirror = LTDC_MIRROR_NONE;
3400897c:	2403      	movs	r4, #3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
3400897e:	fb07 0701 	mla	r7, r7, r1, r0
    *Mirror = LTDC_MIRROR_NONE;
34008982:	f8cc 4000 	str.w	r4, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34008986:	6b6c      	ldr	r4, [r5, #52]	@ 0x34
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34008988:	6c29      	ldr	r1, [r5, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
3400898a:	65fc      	str	r4, [r7, #92]	@ 0x5c
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
3400898c:	6011      	str	r1, [r2, #0]
    *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R;
3400898e:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008990:	601a      	str	r2, [r3, #0]
}
34008992:	e02d      	b.n	340089f0 <LTDC_RetrieveUserConfig.constprop.0+0xac>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008994:	3e04      	subs	r6, #4
34008996:	2e09      	cmp	r6, #9
34008998:	f04f 0401 	mov.w	r4, #1
3400899c:	d8e7      	bhi.n	3400896e <LTDC_RetrieveUserConfig.constprop.0+0x2a>
3400899e:	f240 299b 	movw	r9, #667	@ 0x29b
340089a2:	fa04 f706 	lsl.w	r7, r4, r6
340089a6:	ea17 0f09 	tst.w	r7, r9
340089aa:	d107      	bne.n	340089bc <LTDC_RetrieveUserConfig.constprop.0+0x78>
340089ac:	2e02      	cmp	r6, #2
340089ae:	d007      	beq.n	340089c0 <LTDC_RetrieveUserConfig.constprop.0+0x7c>
340089b0:	2e08      	cmp	r6, #8
340089b2:	d1dc      	bne.n	3400896e <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = ((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos;
340089b4:	6fac      	ldr	r4, [r5, #120]	@ 0x78
340089b6:	f3c4 4482 	ubfx	r4, r4, #18, #3
      break;
340089ba:	e7d8      	b.n	3400896e <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = 2U;
340089bc:	2402      	movs	r4, #2
340089be:	e7d6      	b.n	3400896e <LTDC_RetrieveUserConfig.constprop.0+0x2a>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340089c0:	2403      	movs	r4, #3
340089c2:	e7d4      	b.n	3400896e <LTDC_RetrieveUserConfig.constprop.0+0x2a>
    *Mirror = LTDC_MIRROR_HORIZONTAL;
340089c4:	f8cc 8000 	str.w	r8, [ip]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340089c8:	f240 1c0d 	movw	ip, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
340089cc:	fb07 0001 	mla	r0, r7, r1, r0
340089d0:	e9d0 710e 	ldrd	r7, r1, [r0, #56]	@ 0x38
340089d4:	1bc9      	subs	r1, r1, r7
340089d6:	fb04 f701 	mul.w	r7, r4, r1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
340089da:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
340089dc:	3601      	adds	r6, #1
340089de:	1bf6      	subs	r6, r6, r7
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
340089e0:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340089e2:	6c86      	ldr	r6, [r0, #72]	@ 0x48
340089e4:	4566      	cmp	r6, ip
340089e6:	d005      	beq.n	340089f4 <LTDC_RetrieveUserConfig.constprop.0+0xb0>
340089e8:	f240 270d 	movw	r7, #525	@ 0x20d
340089ec:	42be      	cmp	r6, r7
340089ee:	d006      	beq.n	340089fe <LTDC_RetrieveUserConfig.constprop.0+0xba>
}
340089f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
340089f4:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
340089f6:	3301      	adds	r3, #1
340089f8:	1bdb      	subs	r3, r3, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
340089fa:	6013      	str	r3, [r2, #0]
        break;
340089fc:	e7f8      	b.n	340089f0 <LTDC_RetrieveUserConfig.constprop.0+0xac>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
340089fe:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34008a00:	0849      	lsrs	r1, r1, #1
34008a02:	3601      	adds	r6, #1
34008a04:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34008a08:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
34008a0a:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008a0c:	e9d0 010e 	ldrd	r0, r1, [r0, #56]	@ 0x38
34008a10:	1a09      	subs	r1, r1, r0
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34008a12:	3201      	adds	r2, #1
34008a14:	0849      	lsrs	r1, r1, #1
34008a16:	fb04 2211 	mls	r2, r4, r1, r2
34008a1a:	e7b9      	b.n	34008990 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
  else if ((pitchSign != 0U) && (hmirror == 0U))
34008a1c:	2634      	movs	r6, #52	@ 0x34
34008a1e:	f1be 0f00 	cmp.w	lr, #0
34008a22:	d138      	bne.n	34008a96 <LTDC_RetrieveUserConfig.constprop.0+0x152>
    *Mirror = LTDC_MIRROR_VERTICAL;
34008a24:	2701      	movs	r7, #1
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008a26:	fb06 0601 	mla	r6, r6, r1, r0
    *Mirror = LTDC_MIRROR_VERTICAL;
34008a2a:	f8cc 7000 	str.w	r7, [ip]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008a2e:	e9d6 100e 	ldrd	r1, r0, [r6, #56]	@ 0x38
34008a32:	1a40      	subs	r0, r0, r1
34008a34:	fb00 fc04 	mul.w	ip, r0, r4
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008a38:	e9d6 1710 	ldrd	r1, r7, [r6, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008a3c:	f8d5 8034 	ldr.w	r8, [r5, #52]	@ 0x34
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008a40:	1a79      	subs	r1, r7, r1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34008a42:	f101 3eff 	add.w	lr, r1, #4294967295
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008a46:	fb0c 871e 	mls	r7, ip, lr, r8
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008a4a:	f240 1e0d 	movw	lr, #269	@ 0x10d
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008a4e:	65f7      	str	r7, [r6, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008a50:	6cb7      	ldr	r7, [r6, #72]	@ 0x48
34008a52:	4577      	cmp	r7, lr
34008a54:	d019      	beq.n	34008a8a <LTDC_RetrieveUserConfig.constprop.0+0x146>
34008a56:	f240 2c0d 	movw	ip, #525	@ 0x20d
34008a5a:	4567      	cmp	r7, ip
34008a5c:	d1c8      	bne.n	340089f0 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008a5e:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008a60:	0840      	lsrs	r0, r0, #1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008a62:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008a64:	4341      	muls	r1, r0
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008a66:	6c2f      	ldr	r7, [r5, #64]	@ 0x40
34008a68:	fb04 7111 	mls	r1, r4, r1, r7
34008a6c:	6011      	str	r1, [r2, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008a6e:	e9d6 1210 	ldrd	r1, r2, [r6, #64]	@ 0x40
34008a72:	1a52      	subs	r2, r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008a74:	6c68      	ldr	r0, [r5, #68]	@ 0x44
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008a76:	0852      	lsrs	r2, r2, #1
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008a78:	e9d6 510e 	ldrd	r5, r1, [r6, #56]	@ 0x38
34008a7c:	1b49      	subs	r1, r1, r5
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008a7e:	3a01      	subs	r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008a80:	0849      	lsrs	r1, r1, #1
34008a82:	434a      	muls	r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008a84:	fb04 0212 	mls	r2, r4, r2, r0
34008a88:	e782      	b.n	34008990 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008a8a:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008a8c:	0849      	lsrs	r1, r1, #1
34008a8e:	3901      	subs	r1, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008a90:	fb0c 3311 	mls	r3, ip, r1, r3
34008a94:	e7b1      	b.n	340089fa <LTDC_RetrieveUserConfig.constprop.0+0xb6>
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34008a96:	2702      	movs	r7, #2
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008a98:	fb06 0001 	mla	r0, r6, r1, r0
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34008a9c:	f8cc 7000 	str.w	r7, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008aa0:	f8d5 e034 	ldr.w	lr, [r5, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008aa4:	e9d0 610e 	ldrd	r6, r1, [r0, #56]	@ 0x38
34008aa8:	1b89      	subs	r1, r1, r6
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008aaa:	e9d0 7610 	ldrd	r7, r6, [r0, #64]	@ 0x40
34008aae:	1bf7      	subs	r7, r6, r7
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34008ab0:	f10e 0601 	add.w	r6, lr, #1
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008ab4:	f240 1e0d 	movw	lr, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008ab8:	fb01 fc04 	mul.w	ip, r1, r4
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34008abc:	fb07 661c 	mls	r6, r7, ip, r6
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008ac0:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008ac2:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34008ac4:	4576      	cmp	r6, lr
34008ac6:	d019      	beq.n	34008afc <LTDC_RetrieveUserConfig.constprop.0+0x1b8>
34008ac8:	f240 2c0d 	movw	ip, #525	@ 0x20d
34008acc:	4566      	cmp	r6, ip
34008ace:	d18f      	bne.n	340089f0 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008ad0:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008ad2:	087f      	lsrs	r7, r7, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008ad4:	4379      	muls	r1, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008ad6:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008ad8:	3601      	adds	r6, #1
34008ada:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008ade:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008ae0:	6c69      	ldr	r1, [r5, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008ae2:	e9d0 520e 	ldrd	r5, r2, [r0, #56]	@ 0x38
34008ae6:	1b52      	subs	r2, r2, r5
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008ae8:	e9d0 0510 	ldrd	r0, r5, [r0, #64]	@ 0x40
34008aec:	1a28      	subs	r0, r5, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008aee:	0852      	lsrs	r2, r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008af0:	0840      	lsrs	r0, r0, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008af2:	4342      	muls	r2, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008af4:	3101      	adds	r1, #1
34008af6:	fb04 1212 	mls	r2, r4, r2, r1
34008afa:	e749      	b.n	34008990 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008afc:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008afe:	087f      	lsrs	r7, r7, #1
34008b00:	3301      	adds	r3, #1
34008b02:	fb0c 3317 	mls	r3, ip, r7, r3
34008b06:	e778      	b.n	340089fa <LTDC_RetrieveUserConfig.constprop.0+0xb6>

34008b08 <HAL_LTDC_MspInit>:
}
34008b08:	4770      	bx	lr
	...

34008b0c <HAL_LTDC_Init>:
{
34008b0c:	b538      	push	{r3, r4, r5, lr}
  if (hltdc == NULL)
34008b0e:	4604      	mov	r4, r0
34008b10:	2800      	cmp	r0, #0
34008b12:	f000 80c6 	beq.w	34008ca2 <HAL_LTDC_Init+0x196>
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
34008b16:	6803      	ldr	r3, [r0, #0]
34008b18:	4a63      	ldr	r2, [pc, #396]	@ (34008ca8 <HAL_LTDC_Init+0x19c>)
34008b1a:	4293      	cmp	r3, r2
34008b1c:	d007      	beq.n	34008b2e <HAL_LTDC_Init+0x22>
34008b1e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008b22:	4293      	cmp	r3, r2
34008b24:	d003      	beq.n	34008b2e <HAL_LTDC_Init+0x22>
34008b26:	21f8      	movs	r1, #248	@ 0xf8
34008b28:	4860      	ldr	r0, [pc, #384]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b2a:	f7f9 fd03 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
34008b2e:	6963      	ldr	r3, [r4, #20]
34008b30:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b34:	d303      	bcc.n	34008b3e <HAL_LTDC_Init+0x32>
34008b36:	21f9      	movs	r1, #249	@ 0xf9
34008b38:	485c      	ldr	r0, [pc, #368]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b3a:	f7f9 fcfb 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
34008b3e:	69a3      	ldr	r3, [r4, #24]
34008b40:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b44:	d303      	bcc.n	34008b4e <HAL_LTDC_Init+0x42>
34008b46:	21fa      	movs	r1, #250	@ 0xfa
34008b48:	4858      	ldr	r0, [pc, #352]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b4a:	f7f9 fcf3 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
34008b4e:	69e3      	ldr	r3, [r4, #28]
34008b50:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b54:	d303      	bcc.n	34008b5e <HAL_LTDC_Init+0x52>
34008b56:	21fb      	movs	r1, #251	@ 0xfb
34008b58:	4854      	ldr	r0, [pc, #336]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b5a:	f7f9 fceb 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
34008b5e:	6a23      	ldr	r3, [r4, #32]
34008b60:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b64:	d303      	bcc.n	34008b6e <HAL_LTDC_Init+0x62>
34008b66:	21fc      	movs	r1, #252	@ 0xfc
34008b68:	4850      	ldr	r0, [pc, #320]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b6a:	f7f9 fce3 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
34008b6e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34008b70:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b74:	d303      	bcc.n	34008b7e <HAL_LTDC_Init+0x72>
34008b76:	21fd      	movs	r1, #253	@ 0xfd
34008b78:	484c      	ldr	r0, [pc, #304]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b7a:	f7f9 fcdb 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
34008b7e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34008b80:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b84:	d303      	bcc.n	34008b8e <HAL_LTDC_Init+0x82>
34008b86:	21fe      	movs	r1, #254	@ 0xfe
34008b88:	4848      	ldr	r0, [pc, #288]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b8a:	f7f9 fcd3 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
34008b8e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
34008b90:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008b94:	d303      	bcc.n	34008b9e <HAL_LTDC_Init+0x92>
34008b96:	21ff      	movs	r1, #255	@ 0xff
34008b98:	4844      	ldr	r0, [pc, #272]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008b9a:	f7f9 fccb 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
34008b9e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34008ba0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008ba4:	d304      	bcc.n	34008bb0 <HAL_LTDC_Init+0xa4>
34008ba6:	f44f 7180 	mov.w	r1, #256	@ 0x100
34008baa:	4840      	ldr	r0, [pc, #256]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008bac:	f7f9 fcc2 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
34008bb0:	6863      	ldr	r3, [r4, #4]
34008bb2:	f033 4300 	bics.w	r3, r3, #2147483648	@ 0x80000000
34008bb6:	d004      	beq.n	34008bc2 <HAL_LTDC_Init+0xb6>
34008bb8:	f240 1101 	movw	r1, #257	@ 0x101
34008bbc:	483b      	ldr	r0, [pc, #236]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008bbe:	f7f9 fcb9 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
34008bc2:	68a3      	ldr	r3, [r4, #8]
34008bc4:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
34008bc8:	d004      	beq.n	34008bd4 <HAL_LTDC_Init+0xc8>
34008bca:	f44f 7181 	mov.w	r1, #258	@ 0x102
34008bce:	4837      	ldr	r0, [pc, #220]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008bd0:	f7f9 fcb0 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
34008bd4:	68e3      	ldr	r3, [r4, #12]
34008bd6:	f033 5300 	bics.w	r3, r3, #536870912	@ 0x20000000
34008bda:	d004      	beq.n	34008be6 <HAL_LTDC_Init+0xda>
34008bdc:	f240 1103 	movw	r1, #259	@ 0x103
34008be0:	4832      	ldr	r0, [pc, #200]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008be2:	f7f9 fca7 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
34008be6:	6923      	ldr	r3, [r4, #16]
34008be8:	f033 5380 	bics.w	r3, r3, #268435456	@ 0x10000000
34008bec:	d004      	beq.n	34008bf8 <HAL_LTDC_Init+0xec>
34008bee:	f44f 7182 	mov.w	r1, #260	@ 0x104
34008bf2:	482e      	ldr	r0, [pc, #184]	@ (34008cac <HAL_LTDC_Init+0x1a0>)
34008bf4:	f7f9 fc9e 	bl	34002534 <assert_failed>
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34008bf8:	f894 30a1 	ldrb.w	r3, [r4, #161]	@ 0xa1
34008bfc:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34008c00:	b923      	cbnz	r3, 34008c0c <HAL_LTDC_Init+0x100>
    HAL_LTDC_MspInit(hltdc);
34008c02:	4620      	mov	r0, r4
    hltdc->Lock = HAL_UNLOCKED;
34008c04:	f884 20a0 	strb.w	r2, [r4, #160]	@ 0xa0
    HAL_LTDC_MspInit(hltdc);
34008c08:	f7ff ff7e 	bl	34008b08 <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008c0c:	2302      	movs	r3, #2
34008c0e:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34008c12:	6823      	ldr	r3, [r4, #0]
34008c14:	699a      	ldr	r2, [r3, #24]
34008c16:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34008c1a:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34008c1c:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
34008c20:	4302      	orrs	r2, r0
34008c22:	68e0      	ldr	r0, [r4, #12]
34008c24:	6999      	ldr	r1, [r3, #24]
34008c26:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34008c28:	6920      	ldr	r0, [r4, #16]
34008c2a:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34008c2c:	430a      	orrs	r2, r1
34008c2e:	619a      	str	r2, [r3, #24]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34008c30:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
34008c34:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008c38:	609a      	str	r2, [r3, #8]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34008c3a:	e9d4 1207 	ldrd	r1, r2, [r4, #28]
34008c3e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008c42:	60da      	str	r2, [r3, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34008c44:	e9d4 1209 	ldrd	r1, r2, [r4, #36]	@ 0x24
34008c48:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008c4c:	611a      	str	r2, [r3, #16]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34008c4e:	e9d4 120b 	ldrd	r1, r2, [r4, #44]	@ 0x2c
34008c52:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008c56:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34008c58:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34008c5a:	f894 0035 	ldrb.w	r0, [r4, #53]	@ 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34008c5e:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34008c62:	f894 1036 	ldrb.w	r1, [r4, #54]	@ 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34008c66:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34008c68:	6add      	ldr	r5, [r3, #44]	@ 0x2c
34008c6a:	f894 2034 	ldrb.w	r2, [r4, #52]	@ 0x34
34008c6e:	432a      	orrs	r2, r5
34008c70:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
34008c74:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008c78:	62da      	str	r2, [r3, #44]	@ 0x2c
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34008c7a:	2204      	movs	r2, #4
34008c7c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34008c80:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34008c84:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34008c86:	2000      	movs	r0, #0
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34008c88:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34008c8c:	665a      	str	r2, [r3, #100]	@ 0x64
  __HAL_LTDC_ENABLE(hltdc);
34008c8e:	699a      	ldr	r2, [r3, #24]
34008c90:	f042 0201 	orr.w	r2, r2, #1
34008c94:	619a      	str	r2, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
34008c96:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34008c98:	f8c4 00a4 	str.w	r0, [r4, #164]	@ 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
34008c9c:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
34008ca0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
34008ca2:	2001      	movs	r0, #1
34008ca4:	e7fc      	b.n	34008ca0 <HAL_LTDC_Init+0x194>
34008ca6:	bf00      	nop
34008ca8:	58001000 	.word	0x58001000
34008cac:	3401c50b 	.word	0x3401c50b

34008cb0 <HAL_LTDC_ConfigLayer>:
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008cb0:	2a01      	cmp	r2, #1
{
34008cb2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34008cb4:	4606      	mov	r6, r0
34008cb6:	460c      	mov	r4, r1
34008cb8:	4617      	mov	r7, r2
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008cba:	d904      	bls.n	34008cc6 <HAL_LTDC_ConfigLayer+0x16>
34008cbc:	f240 4104 	movw	r1, #1028	@ 0x404
34008cc0:	484d      	ldr	r0, [pc, #308]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008cc2:	f7f9 fc37 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
34008cc6:	6823      	ldr	r3, [r4, #0]
34008cc8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008ccc:	d304      	bcc.n	34008cd8 <HAL_LTDC_ConfigLayer+0x28>
34008cce:	f240 4105 	movw	r1, #1029	@ 0x405
34008cd2:	4849      	ldr	r0, [pc, #292]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008cd4:	f7f9 fc2e 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
34008cd8:	6863      	ldr	r3, [r4, #4]
34008cda:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008cde:	d304      	bcc.n	34008cea <HAL_LTDC_ConfigLayer+0x3a>
34008ce0:	f240 4106 	movw	r1, #1030	@ 0x406
34008ce4:	4844      	ldr	r0, [pc, #272]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008ce6:	f7f9 fc25 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
34008cea:	68a3      	ldr	r3, [r4, #8]
34008cec:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008cf0:	d304      	bcc.n	34008cfc <HAL_LTDC_ConfigLayer+0x4c>
34008cf2:	f240 4107 	movw	r1, #1031	@ 0x407
34008cf6:	4840      	ldr	r0, [pc, #256]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008cf8:	f7f9 fc1c 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
34008cfc:	68e3      	ldr	r3, [r4, #12]
34008cfe:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008d02:	d304      	bcc.n	34008d0e <HAL_LTDC_ConfigLayer+0x5e>
34008d04:	f44f 6181 	mov.w	r1, #1032	@ 0x408
34008d08:	483b      	ldr	r0, [pc, #236]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d0a:	f7f9 fc13 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
34008d0e:	6923      	ldr	r3, [r4, #16]
34008d10:	2b0b      	cmp	r3, #11
34008d12:	d904      	bls.n	34008d1e <HAL_LTDC_ConfigLayer+0x6e>
34008d14:	f240 4109 	movw	r1, #1033	@ 0x409
34008d18:	4837      	ldr	r0, [pc, #220]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d1a:	f7f9 fc0b 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha));
34008d1e:	6963      	ldr	r3, [r4, #20]
34008d20:	2bff      	cmp	r3, #255	@ 0xff
34008d22:	d904      	bls.n	34008d2e <HAL_LTDC_ConfigLayer+0x7e>
34008d24:	f240 410a 	movw	r1, #1034	@ 0x40a
34008d28:	4833      	ldr	r0, [pc, #204]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d2a:	f7f9 fc03 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
34008d2e:	69a3      	ldr	r3, [r4, #24]
34008d30:	2bff      	cmp	r3, #255	@ 0xff
34008d32:	d904      	bls.n	34008d3e <HAL_LTDC_ConfigLayer+0x8e>
34008d34:	f240 410b 	movw	r1, #1035	@ 0x40b
34008d38:	482f      	ldr	r0, [pc, #188]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d3a:	f7f9 fbfb 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
34008d3e:	69e3      	ldr	r3, [r4, #28]
34008d40:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
34008d44:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34008d48:	d004      	beq.n	34008d54 <HAL_LTDC_ConfigLayer+0xa4>
34008d4a:	f240 410c 	movw	r1, #1036	@ 0x40c
34008d4e:	482a      	ldr	r0, [pc, #168]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d50:	f7f9 fbf0 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
34008d54:	6a23      	ldr	r3, [r4, #32]
34008d56:	f023 0302 	bic.w	r3, r3, #2
34008d5a:	2b05      	cmp	r3, #5
34008d5c:	d004      	beq.n	34008d68 <HAL_LTDC_ConfigLayer+0xb8>
34008d5e:	f240 410d 	movw	r1, #1037	@ 0x40d
34008d62:	4825      	ldr	r0, [pc, #148]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d64:	f7f9 fbe6 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
34008d68:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34008d6a:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34008d6e:	d304      	bcc.n	34008d7a <HAL_LTDC_ConfigLayer+0xca>
34008d70:	f240 410e 	movw	r1, #1038	@ 0x40e
34008d74:	4820      	ldr	r0, [pc, #128]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d76:	f7f9 fbdd 	bl	34002534 <assert_failed>
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
34008d7a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34008d7c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008d80:	d304      	bcc.n	34008d8c <HAL_LTDC_ConfigLayer+0xdc>
34008d82:	f240 410f 	movw	r1, #1039	@ 0x40f
34008d86:	481c      	ldr	r0, [pc, #112]	@ (34008df8 <HAL_LTDC_ConfigLayer+0x148>)
34008d88:	f7f9 fbd4 	bl	34002534 <assert_failed>
  __HAL_LOCK(hltdc);
34008d8c:	f896 30a0 	ldrb.w	r3, [r6, #160]	@ 0xa0
34008d90:	2002      	movs	r0, #2
34008d92:	2b01      	cmp	r3, #1
34008d94:	d02d      	beq.n	34008df2 <HAL_LTDC_ConfigLayer+0x142>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34008d96:	2534      	movs	r5, #52	@ 0x34
34008d98:	fb05 6507 	mla	r5, r5, r7, r6
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008d9c:	f886 00a1 	strb.w	r0, [r6, #161]	@ 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34008da0:	3538      	adds	r5, #56	@ 0x38
34008da2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34008da4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34008da6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34008da8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34008daa:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34008dac:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34008dae:	6823      	ldr	r3, [r4, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34008db0:	4639      	mov	r1, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34008db2:	602b      	str	r3, [r5, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34008db4:	4630      	mov	r0, r6
34008db6:	f7ff fd83 	bl	340088c0 <LTDC_SetPredefFormat>
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34008dba:	4639      	mov	r1, r7
34008dbc:	4630      	mov	r0, r6
34008dbe:	f7ff fd55 	bl	3400886c <LTDC_SetCompositionConfig>
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008dc2:	2200      	movs	r2, #0
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34008dc4:	6834      	ldr	r4, [r6, #0]
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008dc6:	4630      	mov	r0, r6
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34008dc8:	f504 7480 	add.w	r4, r4, #256	@ 0x100
34008dcc:	eb04 2407 	add.w	r4, r4, r7, lsl #8
34008dd0:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008dd2:	4611      	mov	r1, r2
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34008dd4:	f023 0308 	bic.w	r3, r3, #8
34008dd8:	6323      	str	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008dda:	2303      	movs	r3, #3
34008ddc:	9700      	str	r7, [sp, #0]
34008dde:	f7ff fc17 	bl	34008610 <LTDC_SetConfig>
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34008de2:	2305      	movs	r3, #5
  __HAL_UNLOCK(hltdc);
34008de4:	2000      	movs	r0, #0
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34008de6:	60a3      	str	r3, [r4, #8]
  hltdc->State  = HAL_LTDC_STATE_READY;
34008de8:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34008dea:	f886 00a0 	strb.w	r0, [r6, #160]	@ 0xa0
  hltdc->State  = HAL_LTDC_STATE_READY;
34008dee:	f886 30a1 	strb.w	r3, [r6, #161]	@ 0xa1
}
34008df2:	b003      	add	sp, #12
34008df4:	bdf0      	pop	{r4, r5, r6, r7, pc}
34008df6:	bf00      	nop
34008df8:	3401c50b 	.word	0x3401c50b

34008dfc <HAL_LTDC_ReloadLayer>:
  assert_param(IS_LTDC_RELOAD(ReloadType));
34008dfc:	1e4b      	subs	r3, r1, #1
34008dfe:	2b01      	cmp	r3, #1
{
34008e00:	b570      	push	{r4, r5, r6, lr}
34008e02:	4604      	mov	r4, r0
34008e04:	460d      	mov	r5, r1
34008e06:	4616      	mov	r6, r2
  assert_param(IS_LTDC_RELOAD(ReloadType));
34008e08:	d904      	bls.n	34008e14 <HAL_LTDC_ReloadLayer+0x18>
34008e0a:	f640 0119 	movw	r1, #2073	@ 0x819
34008e0e:	480e      	ldr	r0, [pc, #56]	@ (34008e48 <HAL_LTDC_ReloadLayer+0x4c>)
34008e10:	f7f9 fb90 	bl	34002534 <assert_failed>
  __HAL_LOCK(hltdc);
34008e14:	f894 30a0 	ldrb.w	r3, [r4, #160]	@ 0xa0
34008e18:	2002      	movs	r0, #2
34008e1a:	2b01      	cmp	r3, #1
34008e1c:	d012      	beq.n	34008e44 <HAL_LTDC_ReloadLayer+0x48>
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34008e1e:	6823      	ldr	r3, [r4, #0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008e20:	f884 00a1 	strb.w	r0, [r4, #161]	@ 0xa1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34008e24:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
34008e26:	3601      	adds	r6, #1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34008e28:	f042 0208 	orr.w	r2, r2, #8
34008e2c:	665a      	str	r2, [r3, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
34008e2e:	f045 0504 	orr.w	r5, r5, #4
34008e32:	eb03 2306 	add.w	r3, r3, r6, lsl #8
34008e36:	609d      	str	r5, [r3, #8]
  __HAL_UNLOCK(hltdc);
34008e38:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
34008e3a:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34008e3c:	f884 00a0 	strb.w	r0, [r4, #160]	@ 0xa0
  hltdc->State = HAL_LTDC_STATE_READY;
34008e40:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
34008e44:	bd70      	pop	{r4, r5, r6, pc}
34008e46:	bf00      	nop
34008e48:	3401c50b 	.word	0x3401c50b

34008e4c <HAL_LTDC_SetAddress_NoReload>:
  uint32_t aux0Addr = 0U;
34008e4c:	2300      	movs	r3, #0
{
34008e4e:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008e50:	2a01      	cmp	r2, #1
{
34008e52:	b086      	sub	sp, #24
34008e54:	4604      	mov	r4, r0
34008e56:	460e      	mov	r6, r1
34008e58:	4615      	mov	r5, r2
  uint32_t aux1Addr = 0U;
34008e5a:	e9cd 3303 	strd	r3, r3, [sp, #12]
  uint32_t mirror = 0U;
34008e5e:	9305      	str	r3, [sp, #20]
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008e60:	d904      	bls.n	34008e6c <HAL_LTDC_SetAddress_NoReload+0x20>
34008e62:	f640 1165 	movw	r1, #2405	@ 0x965
34008e66:	4812      	ldr	r0, [pc, #72]	@ (34008eb0 <HAL_LTDC_SetAddress_NoReload+0x64>)
34008e68:	f7f9 fb64 	bl	34002534 <assert_failed>
  __HAL_LOCK(hltdc);
34008e6c:	f894 30a0 	ldrb.w	r3, [r4, #160]	@ 0xa0
34008e70:	2002      	movs	r0, #2
34008e72:	2b01      	cmp	r3, #1
34008e74:	d019      	beq.n	34008eaa <HAL_LTDC_SetAddress_NoReload+0x5e>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008e76:	f884 00a1 	strb.w	r0, [r4, #161]	@ 0xa1
  LTDC_RetrieveUserConfig(hltdc, &mirror, &aux0Addr, &aux1Addr, LayerIdx);
34008e7a:	ab04      	add	r3, sp, #16
34008e7c:	4620      	mov	r0, r4
34008e7e:	aa03      	add	r2, sp, #12
34008e80:	a905      	add	r1, sp, #20
34008e82:	9500      	str	r5, [sp, #0]
34008e84:	f7ff fd5e 	bl	34008944 <LTDC_RetrieveUserConfig.constprop.0>
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34008e88:	2334      	movs	r3, #52	@ 0x34
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34008e8a:	2200      	movs	r2, #0
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34008e8c:	fb03 4305 	mla	r3, r3, r5, r4
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34008e90:	4620      	mov	r0, r4
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34008e92:	65de      	str	r6, [r3, #92]	@ 0x5c
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34008e94:	4611      	mov	r1, r2
34008e96:	9b05      	ldr	r3, [sp, #20]
34008e98:	9500      	str	r5, [sp, #0]
34008e9a:	f7ff fbb9 	bl	34008610 <LTDC_SetConfig>
  hltdc->State = HAL_LTDC_STATE_READY;
34008e9e:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34008ea0:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
34008ea2:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
34008ea6:	f884 00a0 	strb.w	r0, [r4, #160]	@ 0xa0
}
34008eaa:	b006      	add	sp, #24
34008eac:	bd70      	pop	{r4, r5, r6, pc}
34008eae:	bf00      	nop
34008eb0:	3401c50b 	.word	0x3401c50b

34008eb4 <HAL_PWREx_ConfigVddIORange>:
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
34008eb4:	2804      	cmp	r0, #4
{
34008eb6:	b538      	push	{r3, r4, r5, lr}
34008eb8:	4605      	mov	r5, r0
34008eba:	460c      	mov	r4, r1
  assert_param(IS_PWR_VDDIO(VddIOPort));
34008ebc:	d912      	bls.n	34008ee4 <HAL_PWREx_ConfigVddIORange+0x30>
34008ebe:	f240 316a 	movw	r1, #874	@ 0x36a
34008ec2:	481d      	ldr	r0, [pc, #116]	@ (34008f38 <HAL_PWREx_ConfigVddIORange+0x84>)
34008ec4:	f7f9 fb36 	bl	34002534 <assert_failed>
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
34008ec8:	2c01      	cmp	r4, #1
34008eca:	d915      	bls.n	34008ef8 <HAL_PWREx_ConfigVddIORange+0x44>
34008ecc:	f240 316b 	movw	r1, #875	@ 0x36b
34008ed0:	4819      	ldr	r0, [pc, #100]	@ (34008f38 <HAL_PWREx_ConfigVddIORange+0x84>)
34008ed2:	f7f9 fb2f 	bl	34002534 <assert_failed>

  switch (VddIOPort)
34008ed6:	2d04      	cmp	r5, #4
34008ed8:	d80e      	bhi.n	34008ef8 <HAL_PWREx_ConfigVddIORange+0x44>
34008eda:	e8df f005 	tbb	[pc, r5]
34008ede:	0e06      	.short	0x0e06
34008ee0:	1c15      	.short	0x1c15
34008ee2:	24          	.byte	0x24
34008ee3:	00          	.byte	0x00
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
34008ee4:	2901      	cmp	r1, #1
34008ee6:	d9f6      	bls.n	34008ed6 <HAL_PWREx_ConfigVddIORange+0x22>
34008ee8:	e7f0      	b.n	34008ecc <HAL_PWREx_ConfigVddIORange+0x18>
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
34008eea:	4a14      	ldr	r2, [pc, #80]	@ (34008f3c <HAL_PWREx_ConfigVddIORange+0x88>)
34008eec:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008eee:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34008ef2:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
      break;

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
34008ef6:	63d3      	str	r3, [r2, #60]	@ 0x3c
      break;

    default:
      break;
  }
}
34008ef8:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
34008efa:	4a10      	ldr	r2, [pc, #64]	@ (34008f3c <HAL_PWREx_ConfigVddIORange+0x88>)
34008efc:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008efe:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
34008f02:	ea43 6344 	orr.w	r3, r3, r4, lsl #25
34008f06:	e7f6      	b.n	34008ef6 <HAL_PWREx_ConfigVddIORange+0x42>
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
34008f08:	4a0c      	ldr	r2, [pc, #48]	@ (34008f3c <HAL_PWREx_ConfigVddIORange+0x88>)
34008f0a:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008f0c:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
34008f10:	ea43 6384 	orr.w	r3, r3, r4, lsl #26
34008f14:	e7ef      	b.n	34008ef6 <HAL_PWREx_ConfigVddIORange+0x42>
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
34008f16:	4a09      	ldr	r2, [pc, #36]	@ (34008f3c <HAL_PWREx_ConfigVddIORange+0x88>)
34008f18:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34008f1a:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34008f1e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34008f22:	6353      	str	r3, [r2, #52]	@ 0x34
      break;
34008f24:	e7e8      	b.n	34008ef8 <HAL_PWREx_ConfigVddIORange+0x44>
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
34008f26:	4a05      	ldr	r2, [pc, #20]	@ (34008f3c <HAL_PWREx_ConfigVddIORange+0x88>)
34008f28:	6b93      	ldr	r3, [r2, #56]	@ 0x38
34008f2a:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34008f2e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34008f32:	6393      	str	r3, [r2, #56]	@ 0x38
}
34008f34:	e7e0      	b.n	34008ef8 <HAL_PWREx_ConfigVddIORange+0x44>
34008f36:	bf00      	nop
34008f38:	3401c57a 	.word	0x3401c57a
34008f3c:	56024800 	.word	0x56024800

34008f40 <HAL_PWREx_EnableVddIO2>:
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34008f40:	4a02      	ldr	r2, [pc, #8]	@ (34008f4c <HAL_PWREx_EnableVddIO2+0xc>)
34008f42:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008f44:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34008f48:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34008f4a:	4770      	bx	lr
34008f4c:	56024800 	.word	0x56024800

34008f50 <HAL_PWREx_EnableVddIO3>:
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34008f50:	4a02      	ldr	r2, [pc, #8]	@ (34008f5c <HAL_PWREx_EnableVddIO3+0xc>)
34008f52:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008f54:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34008f58:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34008f5a:	4770      	bx	lr
34008f5c:	56024800 	.word	0x56024800

34008f60 <HAL_PWREx_EnableVddIO4>:
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
34008f60:	4a02      	ldr	r2, [pc, #8]	@ (34008f6c <HAL_PWREx_EnableVddIO4+0xc>)
34008f62:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34008f64:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34008f68:	6353      	str	r3, [r2, #52]	@ 0x34
}
34008f6a:	4770      	bx	lr
34008f6c:	56024800 	.word	0x56024800

34008f70 <HAL_RAMCFG_EnableAXISRAM>:
  * @retval None.
  */
void HAL_RAMCFG_EnableAXISRAM(const RAMCFG_HandleTypeDef *hramcfg)
{
  /* Check the parameters */
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
34008f70:	6803      	ldr	r3, [r0, #0]
34008f72:	4a1c      	ldr	r2, [pc, #112]	@ (34008fe4 <HAL_RAMCFG_EnableAXISRAM+0x74>)
{
34008f74:	b510      	push	{r4, lr}
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
34008f76:	4293      	cmp	r3, r2
{
34008f78:	4604      	mov	r4, r0
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
34008f7a:	d02c      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008f7c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008f80:	4293      	cmp	r3, r2
34008f82:	d028      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008f84:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34008f88:	3280      	adds	r2, #128	@ 0x80
34008f8a:	4293      	cmp	r3, r2
34008f8c:	d023      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008f8e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008f92:	4293      	cmp	r3, r2
34008f94:	d01f      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008f96:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34008f9a:	3280      	adds	r2, #128	@ 0x80
34008f9c:	4293      	cmp	r3, r2
34008f9e:	d01a      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008fa0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008fa4:	4293      	cmp	r3, r2
34008fa6:	d016      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008fa8:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34008fac:	3280      	adds	r2, #128	@ 0x80
34008fae:	4293      	cmp	r3, r2
34008fb0:	d011      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008fb2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008fb6:	4293      	cmp	r3, r2
34008fb8:	d00d      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008fba:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34008fbe:	3280      	adds	r2, #128	@ 0x80
34008fc0:	4293      	cmp	r3, r2
34008fc2:	d008      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008fc4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008fc8:	4293      	cmp	r3, r2
34008fca:	d004      	beq.n	34008fd6 <HAL_RAMCFG_EnableAXISRAM+0x66>
34008fcc:	f240 4107 	movw	r1, #1031	@ 0x407
34008fd0:	4805      	ldr	r0, [pc, #20]	@ (34008fe8 <HAL_RAMCFG_EnableAXISRAM+0x78>)
34008fd2:	f7f9 faaf 	bl	34002534 <assert_failed>

  /* AXISRAMi power on */
  CLEAR_BIT(hramcfg->Instance->CR, RAMCFG_AXISRAM_POWERDOWN);
34008fd6:	6822      	ldr	r2, [r4, #0]
34008fd8:	6813      	ldr	r3, [r2, #0]
34008fda:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
34008fde:	6013      	str	r3, [r2, #0]
}
34008fe0:	bd10      	pop	{r4, pc}
34008fe2:	bf00      	nop
34008fe4:	52023080 	.word	0x52023080
34008fe8:	3401c5eb 	.word	0x3401c5eb

34008fec <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34008fec:	4b02      	ldr	r3, [pc, #8]	@ (34008ff8 <LL_RCC_HSI_IsReady+0xc>)
34008fee:	6858      	ldr	r0, [r3, #4]
}
34008ff0:	f3c0 00c0 	ubfx	r0, r0, #3, #1
34008ff4:	4770      	bx	lr
34008ff6:	bf00      	nop
34008ff8:	56028000 	.word	0x56028000

34008ffc <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34008ffc:	4b02      	ldr	r3, [pc, #8]	@ (34009008 <LL_RCC_MSI_IsReady+0xc>)
34008ffe:	6858      	ldr	r0, [r3, #4]
}
34009000:	f3c0 0080 	ubfx	r0, r0, #2, #1
34009004:	4770      	bx	lr
34009006:	bf00      	nop
34009008:	56028000 	.word	0x56028000

3400900c <LL_RCC_PLL1_IsReady>:
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400900c:	4b02      	ldr	r3, [pc, #8]	@ (34009018 <LL_RCC_PLL1_IsReady+0xc>)
3400900e:	6858      	ldr	r0, [r3, #4]
}
34009010:	f3c0 2000 	ubfx	r0, r0, #8, #1
34009014:	4770      	bx	lr
34009016:	bf00      	nop
34009018:	56028000 	.word	0x56028000

3400901c <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3400901c:	b570      	push	{r4, r5, r6, lr}
  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3400901e:	690b      	ldr	r3, [r1, #16]
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009020:	4d1b      	ldr	r5, [pc, #108]	@ (34009090 <RCC_PLL_IsNewConfig+0x74>)
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
34009022:	688e      	ldr	r6, [r1, #8]
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009024:	0104      	lsls	r4, r0, #4
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34009026:	5962      	ldr	r2, [r4, r5]
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
34009028:	021b      	lsls	r3, r3, #8
3400902a:	ea43 5306 	orr.w	r3, r3, r6, lsl #20
3400902e:	684e      	ldr	r6, [r1, #4]
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34009030:	f022 420c 	bic.w	r2, r2, #2348810240	@ 0x8c000000
34009034:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
34009038:	4333      	orrs	r3, r6
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400903a:	429a      	cmp	r2, r3
3400903c:	d126      	bne.n	3400908c <RCC_PLL_IsNewConfig+0x70>
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3400903e:	4b15      	ldr	r3, [pc, #84]	@ (34009094 <RCC_PLL_IsNewConfig+0x78>)
  {
    ret = 1U; /* New PLL configuration */
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
34009040:	68ca      	ldr	r2, [r1, #12]
34009042:	58e3      	ldr	r3, [r4, r3]
34009044:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34009048:	4293      	cmp	r3, r2
3400904a:	d11f      	bne.n	3400908c <RCC_PLL_IsNewConfig+0x70>
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3400904c:	4b12      	ldr	r3, [pc, #72]	@ (34009098 <RCC_PLL_IsNewConfig+0x7c>)
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
  {
    ret = 1U; /* New PLL configuration */
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400904e:	58e2      	ldr	r2, [r4, r3]
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
34009050:	e9d1 6305 	ldrd	r6, r3, [r1, #20]
34009054:	061b      	lsls	r3, r3, #24
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
34009056:	f002 527c 	and.w	r2, r2, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3400905a:	ea43 63c6 	orr.w	r3, r3, r6, lsl #27
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400905e:	429a      	cmp	r2, r3
34009060:	d114      	bne.n	3400908c <RCC_PLL_IsNewConfig+0x70>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009062:	4b0e      	ldr	r3, [pc, #56]	@ (3400909c <RCC_PLL_IsNewConfig+0x80>)
34009064:	685a      	ldr	r2, [r3, #4]
34009066:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400906a:	fa03 f000 	lsl.w	r0, r3, r0
3400906e:	4390      	bics	r0, r2
34009070:	d00a      	beq.n	34009088 <RCC_PLL_IsNewConfig+0x6c>
    {
      pllState = RCC_PLL_ON;
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
34009072:	5963      	ldr	r3, [r4, r5]
      {
        pllState = RCC_PLL_BYPASS;
34009074:	f013 6f00 	tst.w	r3, #134217728	@ 0x8000000
34009078:	bf0c      	ite	eq
3400907a:	2301      	moveq	r3, #1
3400907c:	2303      	movne	r3, #3
        pllState = RCC_PLL_OFF;
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
3400907e:	6808      	ldr	r0, [r1, #0]
34009080:	1ac0      	subs	r0, r0, r3
34009082:	bf18      	it	ne
34009084:	2001      	movne	r0, #1
      ret = 1U; /* New PLL configuration */
    }
  }

  return ret;
}
34009086:	bd70      	pop	{r4, r5, r6, pc}
      pllState = RCC_PLL_ON;
34009088:	2302      	movs	r3, #2
3400908a:	e7f8      	b.n	3400907e <RCC_PLL_IsNewConfig+0x62>
    ret = 1U; /* New PLL configuration */
3400908c:	2001      	movs	r0, #1
  return ret;
3400908e:	e7fa      	b.n	34009086 <RCC_PLL_IsNewConfig+0x6a>
34009090:	56028080 	.word	0x56028080
34009094:	56028084 	.word	0x56028084
34009098:	56028088 	.word	0x56028088
3400909c:	56028000 	.word	0x56028000

340090a0 <RCC_PLL_Enable>:
{
340090a0:	b570      	push	{r4, r5, r6, lr}
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
340090a2:	f44f 7480 	mov.w	r4, #256	@ 0x100
340090a6:	4e09      	ldr	r6, [pc, #36]	@ (340090cc <RCC_PLL_Enable+0x2c>)
340090a8:	4084      	lsls	r4, r0
340090aa:	f8c6 4800 	str.w	r4, [r6, #2048]	@ 0x800
  tickstart = HAL_GetTick();
340090ae:	f7fb fbad 	bl	3400480c <HAL_GetTick>
340090b2:	4605      	mov	r5, r0
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
340090b4:	6873      	ldr	r3, [r6, #4]
340090b6:	421c      	tst	r4, r3
340090b8:	d001      	beq.n	340090be <RCC_PLL_Enable+0x1e>
  return ret;
340090ba:	2000      	movs	r0, #0
}
340090bc:	bd70      	pop	{r4, r5, r6, pc}
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340090be:	f7fb fba5 	bl	3400480c <HAL_GetTick>
340090c2:	1b40      	subs	r0, r0, r5
340090c4:	2801      	cmp	r0, #1
340090c6:	d9f5      	bls.n	340090b4 <RCC_PLL_Enable+0x14>
      return HAL_TIMEOUT;
340090c8:	2003      	movs	r0, #3
340090ca:	e7f7      	b.n	340090bc <RCC_PLL_Enable+0x1c>
340090cc:	56028000 	.word	0x56028000

340090d0 <RCC_PLL_Config>:
  if (pPLLInit->PLLState == RCC_PLL_ON)
340090d0:	680b      	ldr	r3, [r1, #0]
{
340090d2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (pPLLInit->PLLState == RCC_PLL_ON)
340090d6:	2b02      	cmp	r3, #2
{
340090d8:	4681      	mov	r9, r0
340090da:	460d      	mov	r5, r1
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
340090dc:	4f83      	ldr	r7, [pc, #524]	@ (340092ec <RCC_PLL_Config+0x21c>)
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
340090de:	4e84      	ldr	r6, [pc, #528]	@ (340092f0 <RCC_PLL_Config+0x220>)
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
340090e0:	ea4f 1400 	mov.w	r4, r0, lsl #4
  if (pPLLInit->PLLState == RCC_PLL_ON)
340090e4:	f040 8099 	bne.w	3400921a <RCC_PLL_Config+0x14a>
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
340090e8:	684b      	ldr	r3, [r1, #4]
340090ea:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
340090ee:	d004      	beq.n	340090fa <RCC_PLL_Config+0x2a>
340090f0:	f44f 61ff 	mov.w	r1, #2040	@ 0x7f8
340090f4:	487f      	ldr	r0, [pc, #508]	@ (340092f4 <RCC_PLL_Config+0x224>)
340090f6:	f7f9 fa1d 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_PLLFRACN_VALUE(pPLLInit->PLLFractional));
340090fa:	68eb      	ldr	r3, [r5, #12]
340090fc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34009100:	d304      	bcc.n	3400910c <RCC_PLL_Config+0x3c>
34009102:	f240 71f9 	movw	r1, #2041	@ 0x7f9
34009106:	487b      	ldr	r0, [pc, #492]	@ (340092f4 <RCC_PLL_Config+0x224>)
34009108:	f7f9 fa14 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_PLLM_VALUE(pPLLInit->PLLM));
3400910c:	68ab      	ldr	r3, [r5, #8]
3400910e:	3b01      	subs	r3, #1
34009110:	2b3e      	cmp	r3, #62	@ 0x3e
34009112:	d904      	bls.n	3400911e <RCC_PLL_Config+0x4e>
34009114:	f240 71fa 	movw	r1, #2042	@ 0x7fa
34009118:	4876      	ldr	r0, [pc, #472]	@ (340092f4 <RCC_PLL_Config+0x224>)
3400911a:	f7f9 fa0b 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
3400911e:	f640 12ba 	movw	r2, #2490	@ 0x9ba
34009122:	692b      	ldr	r3, [r5, #16]
34009124:	3b0a      	subs	r3, #10
34009126:	4293      	cmp	r3, r2
34009128:	d904      	bls.n	34009134 <RCC_PLL_Config+0x64>
3400912a:	f240 71fb 	movw	r1, #2043	@ 0x7fb
3400912e:	4871      	ldr	r0, [pc, #452]	@ (340092f4 <RCC_PLL_Config+0x224>)
34009130:	f7f9 fa00 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
34009134:	696b      	ldr	r3, [r5, #20]
34009136:	3b01      	subs	r3, #1
34009138:	2b06      	cmp	r3, #6
3400913a:	d904      	bls.n	34009146 <RCC_PLL_Config+0x76>
3400913c:	f240 71fc 	movw	r1, #2044	@ 0x7fc
34009140:	486c      	ldr	r0, [pc, #432]	@ (340092f4 <RCC_PLL_Config+0x224>)
34009142:	f7f9 f9f7 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));
34009146:	69ab      	ldr	r3, [r5, #24]
34009148:	3b01      	subs	r3, #1
3400914a:	2b06      	cmp	r3, #6
3400914c:	d904      	bls.n	34009158 <RCC_PLL_Config+0x88>
3400914e:	f240 71fd 	movw	r1, #2045	@ 0x7fd
34009152:	4868      	ldr	r0, [pc, #416]	@ (340092f4 <RCC_PLL_Config+0x224>)
34009154:	f7f9 f9ee 	bl	34002534 <assert_failed>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009158:	f44f 7880 	mov.w	r8, #256	@ 0x100
3400915c:	4b66      	ldr	r3, [pc, #408]	@ (340092f8 <RCC_PLL_Config+0x228>)
3400915e:	fa08 f809 	lsl.w	r8, r8, r9
34009162:	f8c3 8000 	str.w	r8, [r3]
    tickstart = HAL_GetTick();
34009166:	f7fb fb51 	bl	3400480c <HAL_GetTick>
3400916a:	4681      	mov	r9, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400916c:	f8df a194 	ldr.w	sl, [pc, #404]	@ 34009304 <RCC_PLL_Config+0x234>
34009170:	f8da 3004 	ldr.w	r3, [sl, #4]
34009174:	ea38 0303 	bics.w	r3, r8, r3
34009178:	d040      	beq.n	340091fc <RCC_PLL_Config+0x12c>
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3400917a:	59a3      	ldr	r3, [r4, r6]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3400917c:	495f      	ldr	r1, [pc, #380]	@ (340092fc <RCC_PLL_Config+0x22c>)
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3400917e:	f043 0304 	orr.w	r3, r3, #4
34009182:	51a3      	str	r3, [r4, r6]
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
34009184:	59e3      	ldr	r3, [r4, r7]
34009186:	f023 6300 	bic.w	r3, r3, #134217728	@ 0x8000000
3400918a:	51e3      	str	r3, [r4, r7]
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3400918c:	692b      	ldr	r3, [r5, #16]
3400918e:	68aa      	ldr	r2, [r5, #8]
34009190:	021b      	lsls	r3, r3, #8
34009192:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
34009196:	686a      	ldr	r2, [r5, #4]
34009198:	59e0      	ldr	r0, [r4, r7]
3400919a:	4313      	orrs	r3, r2
3400919c:	4a58      	ldr	r2, [pc, #352]	@ (34009300 <RCC_PLL_Config+0x230>)
3400919e:	4002      	ands	r2, r0
340091a0:	4313      	orrs	r3, r2
340091a2:	51e3      	str	r3, [r4, r7]
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
340091a4:	59a2      	ldr	r2, [r4, r6]
340091a6:	e9d5 0305 	ldrd	r0, r3, [r5, #20]
340091aa:	061b      	lsls	r3, r3, #24
340091ac:	f022 527c 	bic.w	r2, r2, #1056964608	@ 0x3f000000
340091b0:	ea43 63c0 	orr.w	r3, r3, r0, lsl #27
340091b4:	4313      	orrs	r3, r2
340091b6:	51a3      	str	r3, [r4, r6]
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
340091b8:	5863      	ldr	r3, [r4, r1]
340091ba:	68ea      	ldr	r2, [r5, #12]
340091bc:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
340091c0:	4313      	orrs	r3, r2
340091c2:	5063      	str	r3, [r4, r1]
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
340091c4:	59a3      	ldr	r3, [r4, r6]
340091c6:	f023 0308 	bic.w	r3, r3, #8
340091ca:	51a3      	str	r3, [r4, r6]
    if (pPLLInit->PLLFractional != 0U)
340091cc:	68eb      	ldr	r3, [r5, #12]
340091ce:	b11b      	cbz	r3, 340091d8 <RCC_PLL_Config+0x108>
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
340091d0:	59a3      	ldr	r3, [r4, r6]
340091d2:	f043 030a 	orr.w	r3, r3, #10
340091d6:	51a3      	str	r3, [r4, r6]
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
340091d8:	59a3      	ldr	r3, [r4, r6]
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
340091da:	4d4a      	ldr	r5, [pc, #296]	@ (34009304 <RCC_PLL_Config+0x234>)
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
340091dc:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
340091e0:	f043 0301 	orr.w	r3, r3, #1
340091e4:	51a3      	str	r3, [r4, r6]
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
340091e6:	f8c5 8800 	str.w	r8, [r5, #2048]	@ 0x800
    tickstart = HAL_GetTick();
340091ea:	f7fb fb0f 	bl	3400480c <HAL_GetTick>
340091ee:	4604      	mov	r4, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
340091f0:	686b      	ldr	r3, [r5, #4]
340091f2:	ea18 0f03 	tst.w	r8, r3
340091f6:	d00a      	beq.n	3400920e <RCC_PLL_Config+0x13e>
  HAL_StatusTypeDef ret = HAL_OK;
340091f8:	2000      	movs	r0, #0
340091fa:	e006      	b.n	3400920a <RCC_PLL_Config+0x13a>
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340091fc:	f7fb fb06 	bl	3400480c <HAL_GetTick>
34009200:	eba0 0009 	sub.w	r0, r0, r9
34009204:	2801      	cmp	r0, #1
34009206:	d9b3      	bls.n	34009170 <RCC_PLL_Config+0xa0>
        return HAL_TIMEOUT;
34009208:	2003      	movs	r0, #3
}
3400920a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400920e:	f7fb fafd 	bl	3400480c <HAL_GetTick>
34009212:	1b00      	subs	r0, r0, r4
34009214:	2801      	cmp	r0, #1
34009216:	d9eb      	bls.n	340091f0 <RCC_PLL_Config+0x120>
34009218:	e7f6      	b.n	34009208 <RCC_PLL_Config+0x138>
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3400921a:	2b03      	cmp	r3, #3
3400921c:	d146      	bne.n	340092ac <RCC_PLL_Config+0x1dc>
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
3400921e:	684b      	ldr	r3, [r1, #4]
34009220:	b37b      	cbz	r3, 34009282 <RCC_PLL_Config+0x1b2>
34009222:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009226:	d032      	beq.n	3400928e <RCC_PLL_Config+0x1be>
34009228:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400922c:	d032      	beq.n	34009294 <RCC_PLL_Config+0x1c4>
3400922e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009232:	d00d      	beq.n	34009250 <RCC_PLL_Config+0x180>
34009234:	f640 013d 	movw	r1, #2109	@ 0x83d
34009238:	482e      	ldr	r0, [pc, #184]	@ (340092f4 <RCC_PLL_Config+0x224>)
3400923a:	f7f9 f97b 	bl	34002534 <assert_failed>
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
3400923e:	686b      	ldr	r3, [r5, #4]
{
  uint32_t ret = 1U;

  /* No assert since done in calling function */

  switch (PLLSource)
34009240:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009244:	d026      	beq.n	34009294 <RCC_PLL_Config+0x1c4>
34009246:	d803      	bhi.n	34009250 <RCC_PLL_Config+0x180>
34009248:	b1db      	cbz	r3, 34009282 <RCC_PLL_Config+0x1b2>
3400924a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400924e:	d01e      	beq.n	3400928e <RCC_PLL_Config+0x1be>
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009250:	f44f 7680 	mov.w	r6, #256	@ 0x100
34009254:	4b28      	ldr	r3, [pc, #160]	@ (340092f8 <RCC_PLL_Config+0x228>)
34009256:	fa06 f609 	lsl.w	r6, r6, r9
3400925a:	601e      	str	r6, [r3, #0]
      tickstart = HAL_GetTick();
3400925c:	f7fb fad6 	bl	3400480c <HAL_GetTick>
34009260:	4680      	mov	r8, r0
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009262:	f8df 90a0 	ldr.w	r9, [pc, #160]	@ 34009304 <RCC_PLL_Config+0x234>
34009266:	f8d9 3004 	ldr.w	r3, [r9, #4]
3400926a:	ea36 0303 	bics.w	r3, r6, r3
3400926e:	d016      	beq.n	3400929e <RCC_PLL_Config+0x1ce>
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
34009270:	59e3      	ldr	r3, [r4, r7]
34009272:	686a      	ldr	r2, [r5, #4]
34009274:	f023 43f0 	bic.w	r3, r3, #2013265920	@ 0x78000000
34009278:	4313      	orrs	r3, r2
3400927a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400927e:	51e3      	str	r3, [r4, r7]
34009280:	e7ba      	b.n	340091f8 <RCC_PLL_Config+0x128>
  {
    case RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() == 0U)
34009282:	f7ff feb3 	bl	34008fec <LL_RCC_HSI_IsReady>
34009286:	2800      	cmp	r0, #0
34009288:	d1e2      	bne.n	34009250 <RCC_PLL_Config+0x180>
      ret = HAL_ERROR;
3400928a:	2001      	movs	r0, #1
3400928c:	e7bd      	b.n	3400920a <RCC_PLL_Config+0x13a>
      {
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() == 0U)
3400928e:	f7ff feb5 	bl	34008ffc <LL_RCC_MSI_IsReady>
34009292:	e7f8      	b.n	34009286 <RCC_PLL_Config+0x1b6>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009294:	4b1b      	ldr	r3, [pc, #108]	@ (34009304 <RCC_PLL_Config+0x234>)
34009296:	685b      	ldr	r3, [r3, #4]
34009298:	06db      	lsls	r3, r3, #27
3400929a:	d5f6      	bpl.n	3400928a <RCC_PLL_Config+0x1ba>
3400929c:	e7d8      	b.n	34009250 <RCC_PLL_Config+0x180>
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400929e:	f7fb fab5 	bl	3400480c <HAL_GetTick>
340092a2:	eba0 0008 	sub.w	r0, r0, r8
340092a6:	2801      	cmp	r0, #1
340092a8:	d9dd      	bls.n	34009266 <RCC_PLL_Config+0x196>
340092aa:	e7ad      	b.n	34009208 <RCC_PLL_Config+0x138>
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
340092ac:	2b01      	cmp	r3, #1
340092ae:	d1a3      	bne.n	340091f8 <RCC_PLL_Config+0x128>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340092b0:	f44f 7580 	mov.w	r5, #256	@ 0x100
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
340092b4:	59a3      	ldr	r3, [r4, r6]
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340092b6:	4085      	lsls	r5, r0
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
340092b8:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
340092bc:	51a3      	str	r3, [r4, r6]
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340092be:	4b0e      	ldr	r3, [pc, #56]	@ (340092f8 <RCC_PLL_Config+0x228>)
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340092c0:	f8df 8040 	ldr.w	r8, [pc, #64]	@ 34009304 <RCC_PLL_Config+0x234>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340092c4:	601d      	str	r5, [r3, #0]
    tickstart = HAL_GetTick();
340092c6:	f7fb faa1 	bl	3400480c <HAL_GetTick>
340092ca:	4606      	mov	r6, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340092cc:	f8d8 3004 	ldr.w	r3, [r8, #4]
340092d0:	ea35 0303 	bics.w	r3, r5, r3
340092d4:	d003      	beq.n	340092de <RCC_PLL_Config+0x20e>
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
340092d6:	59e3      	ldr	r3, [r4, r7]
340092d8:	f023 6300 	bic.w	r3, r3, #134217728	@ 0x8000000
340092dc:	e7cf      	b.n	3400927e <RCC_PLL_Config+0x1ae>
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340092de:	f7fb fa95 	bl	3400480c <HAL_GetTick>
340092e2:	1b80      	subs	r0, r0, r6
340092e4:	2801      	cmp	r0, #1
340092e6:	d9f1      	bls.n	340092cc <RCC_PLL_Config+0x1fc>
340092e8:	e78e      	b.n	34009208 <RCC_PLL_Config+0x138>
340092ea:	bf00      	nop
340092ec:	56028080 	.word	0x56028080
340092f0:	56028088 	.word	0x56028088
340092f4:	3401c65c 	.word	0x3401c65c
340092f8:	56029000 	.word	0x56029000
340092fc:	56028084 	.word	0x56028084
34009300:	8c0000ff 	.word	0x8c0000ff
34009304:	56028000 	.word	0x56028000

34009308 <RCC_IC_CheckPLLSources>:
  uint32_t ret = 1U;

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
34009308:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
3400930c:	b508      	push	{r3, lr}
  switch (PLLSource1)
3400930e:	d021      	beq.n	34009354 <RCC_IC_CheckPLLSources+0x4c>
34009310:	d805      	bhi.n	3400931e <RCC_IC_CheckPLLSources+0x16>
34009312:	b9c0      	cbnz	r0, 34009346 <RCC_IC_CheckPLLSources+0x3e>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
34009314:	f7ff fe7a 	bl	3400900c <LL_RCC_PLL1_IsReady>
34009318:	b178      	cbz	r0, 3400933a <RCC_IC_CheckPLLSources+0x32>
  uint32_t ret = 1U;
3400931a:	2201      	movs	r2, #1
3400931c:	e003      	b.n	34009326 <RCC_IC_CheckPLLSources+0x1e>
  switch (PLLSource1)
3400931e:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
34009322:	d01e      	beq.n	34009362 <RCC_IC_CheckPLLSources+0x5a>
34009324:	2200      	movs	r2, #0
      ret = 0U;
      break;
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
34009326:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
3400932a:	d03c      	beq.n	340093a6 <RCC_IC_CheckPLLSources+0x9e>
3400932c:	d820      	bhi.n	34009370 <RCC_IC_CheckPLLSources+0x68>
3400932e:	b349      	cbz	r1, 34009384 <RCC_IC_CheckPLLSources+0x7c>
34009330:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
34009334:	d030      	beq.n	34009398 <RCC_IC_CheckPLLSources+0x90>
        }
      }
      break;
    default:
      /* Unexpected */
      ret = 0U;
34009336:	2200      	movs	r2, #0
34009338:	e02c      	b.n	34009394 <RCC_IC_CheckPLLSources+0x8c>
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400933a:	4b1e      	ldr	r3, [pc, #120]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
3400933c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009340:	f3c2 62c0 	ubfx	r2, r2, #27, #1
34009344:	e7ef      	b.n	34009326 <RCC_IC_CheckPLLSources+0x1e>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34009346:	4b1b      	ldr	r3, [pc, #108]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
34009348:	685a      	ldr	r2, [r3, #4]
3400934a:	0592      	lsls	r2, r2, #22
3400934c:	d4e5      	bmi.n	3400931a <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400934e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34009352:	e7f5      	b.n	34009340 <RCC_IC_CheckPLLSources+0x38>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34009354:	4b17      	ldr	r3, [pc, #92]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
34009356:	685a      	ldr	r2, [r3, #4]
34009358:	0550      	lsls	r0, r2, #21
3400935a:	d4de      	bmi.n	3400931a <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400935c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34009360:	e7ee      	b.n	34009340 <RCC_IC_CheckPLLSources+0x38>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009362:	4b14      	ldr	r3, [pc, #80]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
34009364:	685a      	ldr	r2, [r3, #4]
34009366:	0512      	lsls	r2, r2, #20
34009368:	d4d7      	bmi.n	3400931a <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400936a:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400936e:	e7e7      	b.n	34009340 <RCC_IC_CheckPLLSources+0x38>
  switch (PLLSource2)
34009370:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34009374:	d1df      	bne.n	34009336 <RCC_IC_CheckPLLSources+0x2e>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009376:	4b0f      	ldr	r3, [pc, #60]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
34009378:	6859      	ldr	r1, [r3, #4]
3400937a:	0509      	lsls	r1, r1, #20
3400937c:	d40a      	bmi.n	34009394 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400937e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34009382:	e005      	b.n	34009390 <RCC_IC_CheckPLLSources+0x88>
      if (LL_RCC_PLL1_IsReady() == 0U)
34009384:	f7ff fe42 	bl	3400900c <LL_RCC_PLL1_IsReady>
34009388:	b920      	cbnz	r0, 34009394 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400938a:	4b0a      	ldr	r3, [pc, #40]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
3400938c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34009390:	0118      	lsls	r0, r3, #4
34009392:	d5d0      	bpl.n	34009336 <RCC_IC_CheckPLLSources+0x2e>
      break;
  }

  return ret;
}
34009394:	4610      	mov	r0, r2
34009396:	bd08      	pop	{r3, pc}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34009398:	4b06      	ldr	r3, [pc, #24]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
3400939a:	6859      	ldr	r1, [r3, #4]
3400939c:	0589      	lsls	r1, r1, #22
3400939e:	d4f9      	bmi.n	34009394 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
340093a0:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340093a4:	e7f4      	b.n	34009390 <RCC_IC_CheckPLLSources+0x88>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
340093a6:	4b03      	ldr	r3, [pc, #12]	@ (340093b4 <RCC_IC_CheckPLLSources+0xac>)
340093a8:	6859      	ldr	r1, [r3, #4]
340093aa:	0548      	lsls	r0, r1, #21
340093ac:	d4f2      	bmi.n	34009394 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
340093ae:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340093b2:	e7ed      	b.n	34009390 <RCC_IC_CheckPLLSources+0x88>
340093b4:	56028000 	.word	0x56028000

340093b8 <HAL_RCC_OscConfig>:
{
340093b8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (pRCC_OscInitStruct == NULL)
340093bc:	4604      	mov	r4, r0
340093be:	b918      	cbnz	r0, 340093c8 <HAL_RCC_OscConfig+0x10>
    return HAL_ERROR;
340093c0:	2001      	movs	r0, #1
}
340093c2:	b003      	add	sp, #12
340093c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));
340093c8:	6803      	ldr	r3, [r0, #0]
340093ca:	b133      	cbz	r3, 340093da <HAL_RCC_OscConfig+0x22>
340093cc:	06dd      	lsls	r5, r3, #27
340093ce:	d104      	bne.n	340093da <HAL_RCC_OscConfig+0x22>
340093d0:	f44f 71b8 	mov.w	r1, #368	@ 0x170
340093d4:	4893      	ldr	r0, [pc, #588]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
340093d6:	f7f9 f8ad 	bl	34002534 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
340093da:	4b93      	ldr	r3, [pc, #588]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
340093dc:	6a1e      	ldr	r6, [r3, #32]
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
340093de:	6a1d      	ldr	r5, [r3, #32]
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
340093e0:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
340093e4:	f406 1640 	and.w	r6, r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
340093e8:	f002 4be0 	and.w	fp, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
340093ec:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
340093f0:	f005 5540 	and.w	r5, r5, #805306368	@ 0x30000000
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
340093f4:	f002 4ae0 	and.w	sl, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
340093f8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
340093fc:	f002 49e0 	and.w	r9, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34009400:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
  rccsr = RCC->SR;
34009404:	685f      	ldr	r7, [r3, #4]
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34009406:	6823      	ldr	r3, [r4, #0]
34009408:	f002 48e0 	and.w	r8, r2, #1879048192	@ 0x70000000
3400940c:	07d8      	lsls	r0, r3, #31
3400940e:	d463      	bmi.n	340094d8 <HAL_RCC_OscConfig+0x120>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
34009410:	6823      	ldr	r3, [r4, #0]
34009412:	0799      	lsls	r1, r3, #30
34009414:	f100 80d4 	bmi.w	340095c0 <HAL_RCC_OscConfig+0x208>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
34009418:	6823      	ldr	r3, [r4, #0]
3400941a:	06d8      	lsls	r0, r3, #27
3400941c:	d522      	bpl.n	34009464 <HAL_RCC_OscConfig+0xac>
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));
3400941e:	69e3      	ldr	r3, [r4, #28]
34009420:	2b00      	cmp	r3, #0
34009422:	f000 8347 	beq.w	34009ab4 <HAL_RCC_OscConfig+0x6fc>
34009426:	2b04      	cmp	r3, #4
34009428:	f000 834d 	beq.w	34009ac6 <HAL_RCC_OscConfig+0x70e>
3400942c:	f240 2103 	movw	r1, #515	@ 0x203
34009430:	487c      	ldr	r0, [pc, #496]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
34009432:	f7f9 f87f 	bl	34002534 <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
34009436:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
3400943a:	f040 8148 	bne.w	340096ce <HAL_RCC_OscConfig+0x316>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3400943e:	69e3      	ldr	r3, [r4, #28]
34009440:	2b00      	cmp	r3, #0
34009442:	d0bd      	beq.n	340093c0 <HAL_RCC_OscConfig+0x8>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34009444:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009446:	2b1f      	cmp	r3, #31
34009448:	d904      	bls.n	34009454 <HAL_RCC_OscConfig+0x9c>
3400944a:	f240 2116 	movw	r1, #534	@ 0x216
3400944e:	4875      	ldr	r0, [pc, #468]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
34009450:	f7f9 f870 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
34009454:	4a74      	ldr	r2, [pc, #464]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
34009456:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34009458:	6c53      	ldr	r3, [r2, #68]	@ 0x44
3400945a:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
3400945e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34009462:	6453      	str	r3, [r2, #68]	@ 0x44
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
34009464:	6823      	ldr	r3, [r4, #0]
34009466:	0718      	lsls	r0, r3, #28
34009468:	f100 8189 	bmi.w	3400977e <HAL_RCC_OscConfig+0x3c6>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3400946c:	6823      	ldr	r3, [r4, #0]
3400946e:	0759      	lsls	r1, r3, #29
34009470:	f100 81b4 	bmi.w	340097dc <HAL_RCC_OscConfig+0x424>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));
34009474:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34009476:	2b03      	cmp	r3, #3
34009478:	d904      	bls.n	34009484 <HAL_RCC_OscConfig+0xcc>
3400947a:	f240 21a3 	movw	r1, #675	@ 0x2a3
3400947e:	4869      	ldr	r0, [pc, #420]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
34009480:	f7f9 f858 	bl	34002534 <assert_failed>
  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
34009484:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
34009486:	2f00      	cmp	r7, #0
34009488:	f040 8210 	bne.w	340098ac <HAL_RCC_OscConfig+0x4f4>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));
3400948c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400948e:	2b03      	cmp	r3, #3
34009490:	d904      	bls.n	3400949c <HAL_RCC_OscConfig+0xe4>
34009492:	f240 21d1 	movw	r1, #721	@ 0x2d1
34009496:	4863      	ldr	r0, [pc, #396]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
34009498:	f7f9 f84c 	bl	34002534 <assert_failed>
  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3400949c:	6c67      	ldr	r7, [r4, #68]	@ 0x44
3400949e:	2f00      	cmp	r7, #0
340094a0:	f040 8246 	bne.w	34009930 <HAL_RCC_OscConfig+0x578>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));
340094a4:	6e23      	ldr	r3, [r4, #96]	@ 0x60
340094a6:	2b03      	cmp	r3, #3
340094a8:	d904      	bls.n	340094b4 <HAL_RCC_OscConfig+0xfc>
340094aa:	f240 21ff 	movw	r1, #767	@ 0x2ff
340094ae:	485d      	ldr	r0, [pc, #372]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
340094b0:	f7f9 f840 	bl	34002534 <assert_failed>
  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
340094b4:	6e27      	ldr	r7, [r4, #96]	@ 0x60
340094b6:	2f00      	cmp	r7, #0
340094b8:	f040 827a 	bne.w	340099b0 <HAL_RCC_OscConfig+0x5f8>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));
340094bc:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
340094be:	2b03      	cmp	r3, #3
340094c0:	d904      	bls.n	340094cc <HAL_RCC_OscConfig+0x114>
340094c2:	f44f 714b 	mov.w	r1, #812	@ 0x32c
340094c6:	4857      	ldr	r0, [pc, #348]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
340094c8:	f7f9 f834 	bl	34002534 <assert_failed>
  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
340094cc:	6fe7      	ldr	r7, [r4, #124]	@ 0x7c
340094ce:	2f00      	cmp	r7, #0
340094d0:	f040 82b0 	bne.w	34009a34 <HAL_RCC_OscConfig+0x67c>
  return HAL_OK;
340094d4:	2000      	movs	r0, #0
340094d6:	e774      	b.n	340093c2 <HAL_RCC_OscConfig+0xa>
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));
340094d8:	6863      	ldr	r3, [r4, #4]
340094da:	2b00      	cmp	r3, #0
340094dc:	f000 8313 	beq.w	34009b06 <HAL_RCC_OscConfig+0x74e>
340094e0:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
340094e4:	2a10      	cmp	r2, #16
340094e6:	f000 8305 	beq.w	34009af4 <HAL_RCC_OscConfig+0x73c>
340094ea:	4a50      	ldr	r2, [pc, #320]	@ (3400962c <HAL_RCC_OscConfig+0x274>)
340094ec:	4293      	cmp	r3, r2
340094ee:	f000 8301 	beq.w	34009af4 <HAL_RCC_OscConfig+0x73c>
340094f2:	f44f 71bf 	mov.w	r1, #382	@ 0x17e
340094f6:	484b      	ldr	r0, [pc, #300]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
340094f8:	f7f9 f81c 	bl	34002534 <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
340094fc:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
34009500:	d103      	bne.n	3400950a <HAL_RCC_OscConfig+0x152>
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
34009502:	6863      	ldr	r3, [r4, #4]
34009504:	2b00      	cmp	r3, #0
34009506:	d183      	bne.n	34009410 <HAL_RCC_OscConfig+0x58>
34009508:	e75a      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3400950a:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
3400950e:	d0f8      	beq.n	34009502 <HAL_RCC_OscConfig+0x14a>
34009510:	f1bb 5f00 	cmp.w	fp, #536870912	@ 0x20000000
34009514:	d101      	bne.n	3400951a <HAL_RCC_OscConfig+0x162>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34009516:	05fa      	lsls	r2, r7, #23
34009518:	d4f3      	bmi.n	34009502 <HAL_RCC_OscConfig+0x14a>
3400951a:	f1ba 5f00 	cmp.w	sl, #536870912	@ 0x20000000
3400951e:	d101      	bne.n	34009524 <HAL_RCC_OscConfig+0x16c>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34009520:	05bb      	lsls	r3, r7, #22
34009522:	d4ee      	bmi.n	34009502 <HAL_RCC_OscConfig+0x14a>
34009524:	f1b9 5f00 	cmp.w	r9, #536870912	@ 0x20000000
34009528:	d101      	bne.n	3400952e <HAL_RCC_OscConfig+0x176>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400952a:	0578      	lsls	r0, r7, #21
3400952c:	d4e9      	bmi.n	34009502 <HAL_RCC_OscConfig+0x14a>
3400952e:	f1b8 5f00 	cmp.w	r8, #536870912	@ 0x20000000
34009532:	d101      	bne.n	34009538 <HAL_RCC_OscConfig+0x180>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009534:	0539      	lsls	r1, r7, #20
34009536:	d4e4      	bmi.n	34009502 <HAL_RCC_OscConfig+0x14a>
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34009538:	6862      	ldr	r2, [r4, #4]
3400953a:	4b3b      	ldr	r3, [pc, #236]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
3400953c:	2a10      	cmp	r2, #16
3400953e:	d114      	bne.n	3400956a <HAL_RCC_OscConfig+0x1b2>
34009540:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009544:	f7fb f962 	bl	3400480c <HAL_GetTick>
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34009548:	6863      	ldr	r3, [r4, #4]
      tickstart = HAL_GetTick();
3400954a:	9001      	str	r0, [sp, #4]
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3400954c:	b35b      	cbz	r3, 340095a6 <HAL_RCC_OscConfig+0x1ee>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3400954e:	4b36      	ldr	r3, [pc, #216]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
34009550:	685a      	ldr	r2, [r3, #4]
34009552:	06d2      	lsls	r2, r2, #27
34009554:	f53f af5c 	bmi.w	34009410 <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34009558:	f7fb f958 	bl	3400480c <HAL_GetTick>
3400955c:	9b01      	ldr	r3, [sp, #4]
3400955e:	1ac0      	subs	r0, r0, r3
34009560:	2864      	cmp	r0, #100	@ 0x64
34009562:	4b31      	ldr	r3, [pc, #196]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
34009564:	d9f4      	bls.n	34009550 <HAL_RCC_OscConfig+0x198>
            return HAL_TIMEOUT;
34009566:	2003      	movs	r0, #3
34009568:	e72b      	b.n	340093c2 <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3400956a:	b93a      	cbnz	r2, 3400957c <HAL_RCC_OscConfig+0x1c4>
3400956c:	2110      	movs	r1, #16
3400956e:	4a30      	ldr	r2, [pc, #192]	@ (34009630 <HAL_RCC_OscConfig+0x278>)
34009570:	6011      	str	r1, [r2, #0]
34009572:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009574:	f422 32c0 	bic.w	r2, r2, #98304	@ 0x18000
34009578:	655a      	str	r2, [r3, #84]	@ 0x54
3400957a:	e7e3      	b.n	34009544 <HAL_RCC_OscConfig+0x18c>
3400957c:	f248 0110 	movw	r1, #32784	@ 0x8010
34009580:	428a      	cmp	r2, r1
34009582:	d109      	bne.n	34009598 <HAL_RCC_OscConfig+0x1e0>
34009584:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009586:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
3400958a:	655a      	str	r2, [r3, #84]	@ 0x54
3400958c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
3400958e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
34009592:	655a      	str	r2, [r3, #84]	@ 0x54
34009594:	2210      	movs	r2, #16
34009596:	e7d3      	b.n	34009540 <HAL_RCC_OscConfig+0x188>
34009598:	4924      	ldr	r1, [pc, #144]	@ (3400962c <HAL_RCC_OscConfig+0x274>)
3400959a:	428a      	cmp	r2, r1
3400959c:	d1e6      	bne.n	3400956c <HAL_RCC_OscConfig+0x1b4>
3400959e:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
340095a0:	f442 32c0 	orr.w	r2, r2, #98304	@ 0x18000
340095a4:	e7f5      	b.n	34009592 <HAL_RCC_OscConfig+0x1da>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
340095a6:	4b20      	ldr	r3, [pc, #128]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
340095a8:	685a      	ldr	r2, [r3, #4]
340095aa:	06d3      	lsls	r3, r2, #27
340095ac:	f57f af30 	bpl.w	34009410 <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
340095b0:	f7fb f92c 	bl	3400480c <HAL_GetTick>
340095b4:	9b01      	ldr	r3, [sp, #4]
340095b6:	1ac0      	subs	r0, r0, r3
340095b8:	2864      	cmp	r0, #100	@ 0x64
340095ba:	4b1b      	ldr	r3, [pc, #108]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
340095bc:	d9f4      	bls.n	340095a8 <HAL_RCC_OscConfig+0x1f0>
340095be:	e7d2      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
340095c0:	68e3      	ldr	r3, [r4, #12]
340095c2:	2b00      	cmp	r3, #0
340095c4:	f000 8288 	beq.w	34009ad8 <HAL_RCC_OscConfig+0x720>
340095c8:	2b08      	cmp	r3, #8
340095ca:	f000 828c 	beq.w	34009ae6 <HAL_RCC_OscConfig+0x72e>
340095ce:	f240 11b3 	movw	r1, #435	@ 0x1b3
340095d2:	4814      	ldr	r0, [pc, #80]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
340095d4:	f7f8 ffae 	bl	34002534 <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
340095d8:	bb66      	cbnz	r6, 34009634 <HAL_RCC_OscConfig+0x27c>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
340095da:	68e3      	ldr	r3, [r4, #12]
340095dc:	2b00      	cmp	r3, #0
340095de:	f43f aeef 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
340095e2:	6923      	ldr	r3, [r4, #16]
340095e4:	f433 73c0 	bics.w	r3, r3, #384	@ 0x180
340095e8:	d004      	beq.n	340095f4 <HAL_RCC_OscConfig+0x23c>
340095ea:	f240 11c5 	movw	r1, #453	@ 0x1c5
340095ee:	480d      	ldr	r0, [pc, #52]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
340095f0:	f7f8 ffa0 	bl	34002534 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
340095f4:	6963      	ldr	r3, [r4, #20]
340095f6:	2b7f      	cmp	r3, #127	@ 0x7f
340095f8:	d904      	bls.n	34009604 <HAL_RCC_OscConfig+0x24c>
340095fa:	f44f 71e3 	mov.w	r1, #454	@ 0x1c6
340095fe:	4809      	ldr	r0, [pc, #36]	@ (34009624 <HAL_RCC_OscConfig+0x26c>)
34009600:	f7f8 ff98 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
34009604:	4a08      	ldr	r2, [pc, #32]	@ (34009628 <HAL_RCC_OscConfig+0x270>)
34009606:	6921      	ldr	r1, [r4, #16]
34009608:	6c93      	ldr	r3, [r2, #72]	@ 0x48
3400960a:	f423 73c0 	bic.w	r3, r3, #384	@ 0x180
3400960e:	430b      	orrs	r3, r1
34009610:	6493      	str	r3, [r2, #72]	@ 0x48
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
34009612:	6c93      	ldr	r3, [r2, #72]	@ 0x48
34009614:	6961      	ldr	r1, [r4, #20]
34009616:	f423 03fe 	bic.w	r3, r3, #8323072	@ 0x7f0000
3400961a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400961e:	6493      	str	r3, [r2, #72]	@ 0x48
}
34009620:	e6fa      	b.n	34009418 <HAL_RCC_OscConfig+0x60>
34009622:	bf00      	nop
34009624:	3401c65c 	.word	0x3401c65c
34009628:	56028000 	.word	0x56028000
3400962c:	00018010 	.word	0x00018010
34009630:	56029000 	.word	0x56029000
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34009634:	2d00      	cmp	r5, #0
34009636:	d0d0      	beq.n	340095da <HAL_RCC_OscConfig+0x222>
34009638:	f1bb 0f00 	cmp.w	fp, #0
3400963c:	d101      	bne.n	34009642 <HAL_RCC_OscConfig+0x28a>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400963e:	05f8      	lsls	r0, r7, #23
34009640:	d4cb      	bmi.n	340095da <HAL_RCC_OscConfig+0x222>
34009642:	f1ba 0f00 	cmp.w	sl, #0
34009646:	d101      	bne.n	3400964c <HAL_RCC_OscConfig+0x294>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34009648:	05b9      	lsls	r1, r7, #22
3400964a:	d4c6      	bmi.n	340095da <HAL_RCC_OscConfig+0x222>
3400964c:	f1b9 0f00 	cmp.w	r9, #0
34009650:	d101      	bne.n	34009656 <HAL_RCC_OscConfig+0x29e>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34009652:	057a      	lsls	r2, r7, #21
34009654:	d4c1      	bmi.n	340095da <HAL_RCC_OscConfig+0x222>
34009656:	f1b8 0f00 	cmp.w	r8, #0
3400965a:	d101      	bne.n	34009660 <HAL_RCC_OscConfig+0x2a8>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400965c:	053b      	lsls	r3, r7, #20
3400965e:	d4bc      	bmi.n	340095da <HAL_RCC_OscConfig+0x222>
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
34009660:	68e3      	ldr	r3, [r4, #12]
34009662:	b313      	cbz	r3, 340096aa <HAL_RCC_OscConfig+0x2f2>
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
34009664:	6923      	ldr	r3, [r4, #16]
34009666:	f433 73c0 	bics.w	r3, r3, #384	@ 0x180
3400966a:	d004      	beq.n	34009676 <HAL_RCC_OscConfig+0x2be>
3400966c:	f44f 71ea 	mov.w	r1, #468	@ 0x1d4
34009670:	48ab      	ldr	r0, [pc, #684]	@ (34009920 <HAL_RCC_OscConfig+0x568>)
34009672:	f7f8 ff5f 	bl	34002534 <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
34009676:	6963      	ldr	r3, [r4, #20]
34009678:	2b7f      	cmp	r3, #127	@ 0x7f
3400967a:	d904      	bls.n	34009686 <HAL_RCC_OscConfig+0x2ce>
3400967c:	f240 11d5 	movw	r1, #469	@ 0x1d5
34009680:	48a7      	ldr	r0, [pc, #668]	@ (34009920 <HAL_RCC_OscConfig+0x568>)
34009682:	f7f8 ff57 	bl	34002534 <assert_failed>
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
34009686:	2208      	movs	r2, #8
34009688:	4ba6      	ldr	r3, [pc, #664]	@ (34009924 <HAL_RCC_OscConfig+0x56c>)
3400968a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
        tickstart = HAL_GetTick();
3400968e:	f7fb f8bd 	bl	3400480c <HAL_GetTick>
34009692:	9001      	str	r0, [sp, #4]
        while (LL_RCC_HSI_IsReady() == 0U)
34009694:	f7ff fcaa 	bl	34008fec <LL_RCC_HSI_IsReady>
34009698:	2800      	cmp	r0, #0
3400969a:	d1b3      	bne.n	34009604 <HAL_RCC_OscConfig+0x24c>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3400969c:	f7fb f8b6 	bl	3400480c <HAL_GetTick>
340096a0:	9b01      	ldr	r3, [sp, #4]
340096a2:	1ac0      	subs	r0, r0, r3
340096a4:	2801      	cmp	r0, #1
340096a6:	d9f5      	bls.n	34009694 <HAL_RCC_OscConfig+0x2dc>
340096a8:	e75d      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
340096aa:	2208      	movs	r2, #8
340096ac:	4b9e      	ldr	r3, [pc, #632]	@ (34009928 <HAL_RCC_OscConfig+0x570>)
340096ae:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
340096b0:	f7fb f8ac 	bl	3400480c <HAL_GetTick>
340096b4:	9001      	str	r0, [sp, #4]
        while (LL_RCC_HSI_IsReady() != 0U)
340096b6:	f7ff fc99 	bl	34008fec <LL_RCC_HSI_IsReady>
340096ba:	2800      	cmp	r0, #0
340096bc:	f43f aeac 	beq.w	34009418 <HAL_RCC_OscConfig+0x60>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
340096c0:	f7fb f8a4 	bl	3400480c <HAL_GetTick>
340096c4:	9b01      	ldr	r3, [sp, #4]
340096c6:	1ac0      	subs	r0, r0, r3
340096c8:	2801      	cmp	r0, #1
340096ca:	d9f4      	bls.n	340096b6 <HAL_RCC_OscConfig+0x2fe>
340096cc:	e74b      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
340096ce:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
340096d2:	f43f aeb4 	beq.w	3400943e <HAL_RCC_OscConfig+0x86>
340096d6:	f1bb 5f80 	cmp.w	fp, #268435456	@ 0x10000000
340096da:	d102      	bne.n	340096e2 <HAL_RCC_OscConfig+0x32a>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
340096dc:	05f9      	lsls	r1, r7, #23
340096de:	f53f aeae 	bmi.w	3400943e <HAL_RCC_OscConfig+0x86>
340096e2:	f1ba 5f80 	cmp.w	sl, #268435456	@ 0x10000000
340096e6:	d102      	bne.n	340096ee <HAL_RCC_OscConfig+0x336>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
340096e8:	05ba      	lsls	r2, r7, #22
340096ea:	f53f aea8 	bmi.w	3400943e <HAL_RCC_OscConfig+0x86>
340096ee:	f1b9 5f80 	cmp.w	r9, #268435456	@ 0x10000000
340096f2:	d102      	bne.n	340096fa <HAL_RCC_OscConfig+0x342>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
340096f4:	057b      	lsls	r3, r7, #21
340096f6:	f53f aea2 	bmi.w	3400943e <HAL_RCC_OscConfig+0x86>
340096fa:	f1b8 5f80 	cmp.w	r8, #268435456	@ 0x10000000
340096fe:	d102      	bne.n	34009706 <HAL_RCC_OscConfig+0x34e>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009700:	053f      	lsls	r7, r7, #20
34009702:	f53f ae9c 	bmi.w	3400943e <HAL_RCC_OscConfig+0x86>
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
34009706:	69e3      	ldr	r3, [r4, #28]
34009708:	b343      	cbz	r3, 3400975c <HAL_RCC_OscConfig+0x3a4>
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
3400970a:	6a23      	ldr	r3, [r4, #32]
3400970c:	f433 7300 	bics.w	r3, r3, #512	@ 0x200
34009710:	d004      	beq.n	3400971c <HAL_RCC_OscConfig+0x364>
34009712:	f240 2122 	movw	r1, #546	@ 0x222
34009716:	4882      	ldr	r0, [pc, #520]	@ (34009920 <HAL_RCC_OscConfig+0x568>)
34009718:	f7f8 ff0c 	bl	34002534 <assert_failed>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
3400971c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400971e:	2b1f      	cmp	r3, #31
34009720:	d904      	bls.n	3400972c <HAL_RCC_OscConfig+0x374>
34009722:	f240 2123 	movw	r1, #547	@ 0x223
34009726:	487e      	ldr	r0, [pc, #504]	@ (34009920 <HAL_RCC_OscConfig+0x568>)
34009728:	f7f8 ff04 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
3400972c:	4a7d      	ldr	r2, [pc, #500]	@ (34009924 <HAL_RCC_OscConfig+0x56c>)
3400972e:	6a21      	ldr	r1, [r4, #32]
34009730:	6c53      	ldr	r3, [r2, #68]	@ 0x44
34009732:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
34009736:	430b      	orrs	r3, r1
34009738:	6453      	str	r3, [r2, #68]	@ 0x44
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3400973a:	2304      	movs	r3, #4
3400973c:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800
        tickstart = HAL_GetTick();
34009740:	f7fb f864 	bl	3400480c <HAL_GetTick>
34009744:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
34009746:	f7ff fc59 	bl	34008ffc <LL_RCC_MSI_IsReady>
3400974a:	2800      	cmp	r0, #0
3400974c:	f47f ae82 	bne.w	34009454 <HAL_RCC_OscConfig+0x9c>
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34009750:	f7fb f85c 	bl	3400480c <HAL_GetTick>
34009754:	1bc0      	subs	r0, r0, r7
34009756:	2801      	cmp	r0, #1
34009758:	d9f5      	bls.n	34009746 <HAL_RCC_OscConfig+0x38e>
3400975a:	e704      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
3400975c:	2204      	movs	r2, #4
3400975e:	4b72      	ldr	r3, [pc, #456]	@ (34009928 <HAL_RCC_OscConfig+0x570>)
34009760:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
34009762:	f7fb f853 	bl	3400480c <HAL_GetTick>
34009766:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
34009768:	f7ff fc48 	bl	34008ffc <LL_RCC_MSI_IsReady>
3400976c:	2800      	cmp	r0, #0
3400976e:	f43f ae79 	beq.w	34009464 <HAL_RCC_OscConfig+0xac>
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34009772:	f7fb f84b 	bl	3400480c <HAL_GetTick>
34009776:	1bc0      	subs	r0, r0, r7
34009778:	2801      	cmp	r0, #1
3400977a:	d9f5      	bls.n	34009768 <HAL_RCC_OscConfig+0x3b0>
3400977c:	e6f3      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));
3400977e:	69a3      	ldr	r3, [r4, #24]
34009780:	2b01      	cmp	r3, #1
34009782:	d904      	bls.n	3400978e <HAL_RCC_OscConfig+0x3d6>
34009784:	f240 2153 	movw	r1, #595	@ 0x253
34009788:	4865      	ldr	r0, [pc, #404]	@ (34009920 <HAL_RCC_OscConfig+0x568>)
3400978a:	f7f8 fed3 	bl	34002534 <assert_failed>
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3400978e:	69a2      	ldr	r2, [r4, #24]
34009790:	2301      	movs	r3, #1
34009792:	b18a      	cbz	r2, 340097b8 <HAL_RCC_OscConfig+0x400>
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
34009794:	f8df 818c 	ldr.w	r8, [pc, #396]	@ 34009924 <HAL_RCC_OscConfig+0x56c>
34009798:	f8c8 3800 	str.w	r3, [r8, #2048]	@ 0x800
      tickstart = HAL_GetTick();
3400979c:	f7fb f836 	bl	3400480c <HAL_GetTick>
340097a0:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
340097a2:	f8d8 3004 	ldr.w	r3, [r8, #4]
      while (LL_RCC_LSI_IsReady() == 0U)
340097a6:	07da      	lsls	r2, r3, #31
340097a8:	f53f ae60 	bmi.w	3400946c <HAL_RCC_OscConfig+0xb4>
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
340097ac:	f7fb f82e 	bl	3400480c <HAL_GetTick>
340097b0:	1bc0      	subs	r0, r0, r7
340097b2:	2801      	cmp	r0, #1
340097b4:	d9f5      	bls.n	340097a2 <HAL_RCC_OscConfig+0x3ea>
340097b6:	e6d6      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
340097b8:	4a5b      	ldr	r2, [pc, #364]	@ (34009928 <HAL_RCC_OscConfig+0x570>)
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
340097ba:	f8df 8168 	ldr.w	r8, [pc, #360]	@ 34009924 <HAL_RCC_OscConfig+0x56c>
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
340097be:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
340097c0:	f7fb f824 	bl	3400480c <HAL_GetTick>
340097c4:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
340097c6:	f8d8 3004 	ldr.w	r3, [r8, #4]
      while (LL_RCC_LSI_IsReady() != 0U)
340097ca:	07db      	lsls	r3, r3, #31
340097cc:	f57f ae4e 	bpl.w	3400946c <HAL_RCC_OscConfig+0xb4>
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
340097d0:	f7fb f81c 	bl	3400480c <HAL_GetTick>
340097d4:	1bc0      	subs	r0, r0, r7
340097d6:	2801      	cmp	r0, #1
340097d8:	d9f5      	bls.n	340097c6 <HAL_RCC_OscConfig+0x40e>
340097da:	e6c4      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));
340097dc:	68a3      	ldr	r3, [r4, #8]
340097de:	f033 0202 	bics.w	r2, r3, #2
340097e2:	d00a      	beq.n	340097fa <HAL_RCC_OscConfig+0x442>
340097e4:	f248 0202 	movw	r2, #32770	@ 0x8002
340097e8:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
340097ec:	4293      	cmp	r3, r2
340097ee:	d004      	beq.n	340097fa <HAL_RCC_OscConfig+0x442>
340097f0:	f240 217e 	movw	r1, #638	@ 0x27e
340097f4:	484a      	ldr	r0, [pc, #296]	@ (34009920 <HAL_RCC_OscConfig+0x568>)
340097f6:	f7f8 fe9d 	bl	34002534 <assert_failed>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
340097fa:	68a3      	ldr	r3, [r4, #8]
340097fc:	4f49      	ldr	r7, [pc, #292]	@ (34009924 <HAL_RCC_OscConfig+0x56c>)
340097fe:	2b02      	cmp	r3, #2
34009800:	d113      	bne.n	3400982a <HAL_RCC_OscConfig+0x472>
34009802:	f8c7 3800 	str.w	r3, [r7, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009806:	f7fb f801 	bl	3400480c <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400980a:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
3400980e:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34009810:	f8df 9110 	ldr.w	r9, [pc, #272]	@ 34009924 <HAL_RCC_OscConfig+0x56c>
34009814:	f8d9 3004 	ldr.w	r3, [r9, #4]
34009818:	0798      	lsls	r0, r3, #30
3400981a:	f53f ae2b 	bmi.w	34009474 <HAL_RCC_OscConfig+0xbc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400981e:	f7fa fff5 	bl	3400480c <HAL_GetTick>
34009822:	1bc3      	subs	r3, r0, r7
34009824:	4543      	cmp	r3, r8
34009826:	d9f5      	bls.n	34009814 <HAL_RCC_OscConfig+0x45c>
34009828:	e69d      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400982a:	b9d3      	cbnz	r3, 34009862 <HAL_RCC_OscConfig+0x4aa>
3400982c:	2202      	movs	r2, #2
3400982e:	4b3e      	ldr	r3, [pc, #248]	@ (34009928 <HAL_RCC_OscConfig+0x570>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34009830:	f241 3988 	movw	r9, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
34009834:	601a      	str	r2, [r3, #0]
34009836:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009838:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400983c:	643b      	str	r3, [r7, #64]	@ 0x40
3400983e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009840:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34009844:	643b      	str	r3, [r7, #64]	@ 0x40
      tickstart = HAL_GetTick();
34009846:	f7fa ffe1 	bl	3400480c <HAL_GetTick>
3400984a:	4680      	mov	r8, r0
3400984c:	687b      	ldr	r3, [r7, #4]
3400984e:	0799      	lsls	r1, r3, #30
34009850:	f57f ae10 	bpl.w	34009474 <HAL_RCC_OscConfig+0xbc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34009854:	f7fa ffda 	bl	3400480c <HAL_GetTick>
34009858:	eba0 0308 	sub.w	r3, r0, r8
3400985c:	454b      	cmp	r3, r9
3400985e:	d9f5      	bls.n	3400984c <HAL_RCC_OscConfig+0x494>
34009860:	e681      	b.n	34009566 <HAL_RCC_OscConfig+0x1ae>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
34009862:	f248 0202 	movw	r2, #32770	@ 0x8002
34009866:	4293      	cmp	r3, r2
34009868:	d109      	bne.n	3400987e <HAL_RCC_OscConfig+0x4c6>
3400986a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400986c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34009870:	643b      	str	r3, [r7, #64]	@ 0x40
34009872:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009874:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34009878:	643b      	str	r3, [r7, #64]	@ 0x40
3400987a:	2302      	movs	r3, #2
3400987c:	e7c1      	b.n	34009802 <HAL_RCC_OscConfig+0x44a>
3400987e:	4a2b      	ldr	r2, [pc, #172]	@ (3400992c <HAL_RCC_OscConfig+0x574>)
34009880:	4293      	cmp	r3, r2
34009882:	d107      	bne.n	34009894 <HAL_RCC_OscConfig+0x4dc>
34009884:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009886:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400988a:	643b      	str	r3, [r7, #64]	@ 0x40
3400988c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400988e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34009892:	e7f1      	b.n	34009878 <HAL_RCC_OscConfig+0x4c0>
34009894:	2202      	movs	r2, #2
34009896:	4b24      	ldr	r3, [pc, #144]	@ (34009928 <HAL_RCC_OscConfig+0x570>)
34009898:	601a      	str	r2, [r3, #0]
3400989a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400989c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
340098a0:	643b      	str	r3, [r7, #64]	@ 0x40
340098a2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340098a4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
340098a8:	643b      	str	r3, [r7, #64]	@ 0x40
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
340098aa:	e7ac      	b.n	34009806 <HAL_RCC_OscConfig+0x44e>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
340098ac:	2000      	movs	r0, #0
340098ae:	f104 0128 	add.w	r1, r4, #40	@ 0x28
340098b2:	f7ff fbb3 	bl	3400901c <RCC_PLL_IsNewConfig>
340098b6:	4602      	mov	r2, r0
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
340098b8:	f7ff fba8 	bl	3400900c <LL_RCC_PLL1_IsReady>
    if (new_pll_config == 1U)
340098bc:	2a01      	cmp	r2, #1
340098be:	d125      	bne.n	3400990c <HAL_RCC_OscConfig+0x554>
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
340098c0:	4b18      	ldr	r3, [pc, #96]	@ (34009924 <HAL_RCC_OscConfig+0x56c>)
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
340098c2:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
340098c6:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
340098ca:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
340098ce:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
340098d2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
340098d6:	d103      	bne.n	340098e0 <HAL_RCC_OscConfig+0x528>
340098d8:	f017 5f40 	tst.w	r7, #805306368	@ 0x30000000
340098dc:	f43f ad70 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
340098e0:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
340098e4:	d10b      	bne.n	340098fe <HAL_RCC_OscConfig+0x546>
340098e6:	f010 5f40 	tst.w	r0, #805306368	@ 0x30000000
340098ea:	f43f ad69 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
340098ee:	f012 5f40 	tst.w	r2, #805306368	@ 0x30000000
340098f2:	f43f ad65 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
340098f6:	f013 5f40 	tst.w	r3, #805306368	@ 0x30000000
340098fa:	f43f ad61 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
340098fe:	2000      	movs	r0, #0
34009900:	f7ff fbe6 	bl	340090d0 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
34009904:	2800      	cmp	r0, #0
34009906:	f43f adc1 	beq.w	3400948c <HAL_RCC_OscConfig+0xd4>
3400990a:	e559      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3400990c:	2f02      	cmp	r7, #2
3400990e:	f47f adbd 	bne.w	3400948c <HAL_RCC_OscConfig+0xd4>
34009912:	2800      	cmp	r0, #0
34009914:	f47f adba 	bne.w	3400948c <HAL_RCC_OscConfig+0xd4>
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
34009918:	f7ff fbc2 	bl	340090a0 <RCC_PLL_Enable>
3400991c:	e7f2      	b.n	34009904 <HAL_RCC_OscConfig+0x54c>
3400991e:	bf00      	nop
34009920:	3401c65c 	.word	0x3401c65c
34009924:	56028000 	.word	0x56028000
34009928:	56029000 	.word	0x56029000
3400992c:	00018002 	.word	0x00018002
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
34009930:	2001      	movs	r0, #1
34009932:	f104 0144 	add.w	r1, r4, #68	@ 0x44
34009936:	f7ff fb71 	bl	3400901c <RCC_PLL_IsNewConfig>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400993a:	4b77      	ldr	r3, [pc, #476]	@ (34009b18 <HAL_RCC_OscConfig+0x760>)
    if (new_pll_config == 1U)
3400993c:	2801      	cmp	r0, #1
3400993e:	685a      	ldr	r2, [r3, #4]
34009940:	d12c      	bne.n	3400999c <HAL_RCC_OscConfig+0x5e4>
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
34009942:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009946:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400994a:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400994e:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009952:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34009956:	d105      	bne.n	34009964 <HAL_RCC_OscConfig+0x5ac>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009958:	f007 5740 	and.w	r7, r7, #805306368	@ 0x30000000
3400995c:	f1b7 5f80 	cmp.w	r7, #268435456	@ 0x10000000
34009960:	f43f ad2e 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
34009964:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
34009968:	d111      	bne.n	3400998e <HAL_RCC_OscConfig+0x5d6>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400996a:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400996e:	f1b0 5f80 	cmp.w	r0, #268435456	@ 0x10000000
34009972:	f43f ad25 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009976:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
3400997a:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
3400997e:	f43f ad1f 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009982:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
34009986:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400998a:	f43f ad19 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3400998e:	2001      	movs	r0, #1
34009990:	f7ff fb9e 	bl	340090d0 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
34009994:	2800      	cmp	r0, #0
34009996:	f43f ad85 	beq.w	340094a4 <HAL_RCC_OscConfig+0xec>
3400999a:	e511      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3400999c:	2f02      	cmp	r7, #2
3400999e:	f47f ad81 	bne.w	340094a4 <HAL_RCC_OscConfig+0xec>
340099a2:	0592      	lsls	r2, r2, #22
340099a4:	f53f ad7e 	bmi.w	340094a4 <HAL_RCC_OscConfig+0xec>
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
340099a8:	2001      	movs	r0, #1
340099aa:	f7ff fb79 	bl	340090a0 <RCC_PLL_Enable>
340099ae:	e7f1      	b.n	34009994 <HAL_RCC_OscConfig+0x5dc>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
340099b0:	2002      	movs	r0, #2
340099b2:	f104 0160 	add.w	r1, r4, #96	@ 0x60
340099b6:	f7ff fb31 	bl	3400901c <RCC_PLL_IsNewConfig>
340099ba:	4602      	mov	r2, r0
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
340099bc:	f7ff fb26 	bl	3400900c <LL_RCC_PLL1_IsReady>
    if (new_pll_config == 1U)
340099c0:	2a01      	cmp	r2, #1
340099c2:	d12d      	bne.n	34009a20 <HAL_RCC_OscConfig+0x668>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
340099c4:	4b54      	ldr	r3, [pc, #336]	@ (34009b18 <HAL_RCC_OscConfig+0x760>)
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
340099c6:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
340099ca:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
340099ce:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
340099d2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
340099d6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
340099da:	d105      	bne.n	340099e8 <HAL_RCC_OscConfig+0x630>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
340099dc:	f007 5740 	and.w	r7, r7, #805306368	@ 0x30000000
340099e0:	f1b7 5f00 	cmp.w	r7, #536870912	@ 0x20000000
340099e4:	f43f acec 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
340099e8:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
340099ec:	d111      	bne.n	34009a12 <HAL_RCC_OscConfig+0x65a>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
340099ee:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
340099f2:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
340099f6:	f43f ace3 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
340099fa:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
340099fe:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
34009a02:	f43f acdd 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009a06:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
34009a0a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009a0e:	f43f acd7 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
34009a12:	2002      	movs	r0, #2
34009a14:	f7ff fb5c 	bl	340090d0 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34009a18:	2800      	cmp	r0, #0
34009a1a:	f43f ad4f 	beq.w	340094bc <HAL_RCC_OscConfig+0x104>
34009a1e:	e4cf      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
34009a20:	2f02      	cmp	r7, #2
34009a22:	f47f ad4b 	bne.w	340094bc <HAL_RCC_OscConfig+0x104>
34009a26:	2800      	cmp	r0, #0
34009a28:	f47f ad48 	bne.w	340094bc <HAL_RCC_OscConfig+0x104>
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34009a2c:	4638      	mov	r0, r7
34009a2e:	f7ff fb37 	bl	340090a0 <RCC_PLL_Enable>
34009a32:	e7f1      	b.n	34009a18 <HAL_RCC_OscConfig+0x660>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
34009a34:	2003      	movs	r0, #3
34009a36:	f104 017c 	add.w	r1, r4, #124	@ 0x7c
34009a3a:	f7ff faef 	bl	3400901c <RCC_PLL_IsNewConfig>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009a3e:	4b36      	ldr	r3, [pc, #216]	@ (34009b18 <HAL_RCC_OscConfig+0x760>)
    if (new_pll_config == 1U)
34009a40:	2801      	cmp	r0, #1
34009a42:	685a      	ldr	r2, [r3, #4]
34009a44:	d12c      	bne.n	34009aa0 <HAL_RCC_OscConfig+0x6e8>
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
34009a46:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009a4a:	f8d3 40c4 	ldr.w	r4, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009a4e:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009a52:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009a56:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34009a5a:	d105      	bne.n	34009a68 <HAL_RCC_OscConfig+0x6b0>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009a5c:	f004 5640 	and.w	r6, r4, #805306368	@ 0x30000000
34009a60:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
34009a64:	f43f acac 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
34009a68:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
34009a6c:	d111      	bne.n	34009a92 <HAL_RCC_OscConfig+0x6da>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009a6e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009a72:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
34009a76:	f43f aca3 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009a7a:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
34009a7e:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
34009a82:	f43f ac9d 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009a86:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
34009a8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009a8e:	f43f ac97 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
34009a92:	2003      	movs	r0, #3
34009a94:	f7ff fb1c 	bl	340090d0 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34009a98:	3800      	subs	r0, #0
34009a9a:	bf18      	it	ne
34009a9c:	2001      	movne	r0, #1
34009a9e:	e490      	b.n	340093c2 <HAL_RCC_OscConfig+0xa>
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
34009aa0:	2f02      	cmp	r7, #2
34009aa2:	f47f ad17 	bne.w	340094d4 <HAL_RCC_OscConfig+0x11c>
34009aa6:	0513      	lsls	r3, r2, #20
34009aa8:	f53f ad14 	bmi.w	340094d4 <HAL_RCC_OscConfig+0x11c>
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34009aac:	2003      	movs	r0, #3
34009aae:	f7ff faf7 	bl	340090a0 <RCC_PLL_Enable>
34009ab2:	e7f1      	b.n	34009a98 <HAL_RCC_OscConfig+0x6e0>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
34009ab4:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
34009ab8:	f43f ac82 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
34009abc:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
34009ac0:	f47f ae09 	bne.w	340096d6 <HAL_RCC_OscConfig+0x31e>
34009ac4:	e47c      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
34009ac6:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
34009aca:	f43f acbb 	beq.w	34009444 <HAL_RCC_OscConfig+0x8c>
34009ace:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
34009ad2:	f47f ae00 	bne.w	340096d6 <HAL_RCC_OscConfig+0x31e>
34009ad6:	e4b5      	b.n	34009444 <HAL_RCC_OscConfig+0x8c>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34009ad8:	2e00      	cmp	r6, #0
34009ada:	f43f ac71 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
34009ade:	2d00      	cmp	r5, #0
34009ae0:	f47f adaa 	bne.w	34009638 <HAL_RCC_OscConfig+0x280>
34009ae4:	e46c      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
34009ae6:	2e00      	cmp	r6, #0
34009ae8:	f43f ad7b 	beq.w	340095e2 <HAL_RCC_OscConfig+0x22a>
34009aec:	2d00      	cmp	r5, #0
34009aee:	f43f ad78 	beq.w	340095e2 <HAL_RCC_OscConfig+0x22a>
34009af2:	e5a1      	b.n	34009638 <HAL_RCC_OscConfig+0x280>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34009af4:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
34009af8:	f43f ac8a 	beq.w	34009410 <HAL_RCC_OscConfig+0x58>
34009afc:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
34009b00:	f47f ad06 	bne.w	34009510 <HAL_RCC_OscConfig+0x158>
34009b04:	e484      	b.n	34009410 <HAL_RCC_OscConfig+0x58>
34009b06:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
34009b0a:	f43f ac59 	beq.w	340093c0 <HAL_RCC_OscConfig+0x8>
34009b0e:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
34009b12:	f47f acfd 	bne.w	34009510 <HAL_RCC_OscConfig+0x158>
34009b16:	e453      	b.n	340093c0 <HAL_RCC_OscConfig+0x8>
34009b18:	56028000 	.word	0x56028000

34009b1c <HAL_RCC_GetCpuClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34009b1c:	4b1f      	ldr	r3, [pc, #124]	@ (34009b9c <HAL_RCC_GetCpuClockFreq+0x80>)
{
34009b1e:	b510      	push	{r4, lr}
34009b20:	6a1a      	ldr	r2, [r3, #32]
34009b22:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
  switch (LL_RCC_GetCpuClkSource())
34009b26:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
34009b2a:	d034      	beq.n	34009b96 <HAL_RCC_GetCpuClockFreq+0x7a>
34009b2c:	d806      	bhi.n	34009b3c <HAL_RCC_GetCpuClockFreq+0x20>
34009b2e:	b952      	cbnz	r2, 34009b46 <HAL_RCC_GetCpuClockFreq+0x2a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34009b30:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009b32:	481b      	ldr	r0, [pc, #108]	@ (34009ba0 <HAL_RCC_GetCpuClockFreq+0x84>)
34009b34:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34009b38:	40d8      	lsrs	r0, r3
}
34009b3a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetCpuClkSource())
34009b3c:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
34009b40:	d009      	beq.n	34009b56 <HAL_RCC_GetCpuClockFreq+0x3a>
      switch (LL_RCC_IC1_GetSource())
34009b42:	2000      	movs	r0, #0
34009b44:	e7f9      	b.n	34009b3a <HAL_RCC_GetCpuClockFreq+0x1e>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
34009b46:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        frequency = MSI_VALUE;
34009b48:	4816      	ldr	r0, [pc, #88]	@ (34009ba4 <HAL_RCC_GetCpuClockFreq+0x88>)
34009b4a:	f413 7f00 	tst.w	r3, #512	@ 0x200
34009b4e:	4b16      	ldr	r3, [pc, #88]	@ (34009ba8 <HAL_RCC_GetCpuClockFreq+0x8c>)
34009b50:	bf08      	it	eq
34009b52:	4618      	moveq	r0, r3
34009b54:	e7f1      	b.n	34009b3a <HAL_RCC_GetCpuClockFreq+0x1e>
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34009b56:	f8d3 00c4 	ldr.w	r0, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009b5a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34009b5e:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009b62:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
      switch (LL_RCC_IC1_GetSource())
34009b66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34009b6a:	f100 0401 	add.w	r4, r0, #1
34009b6e:	d00f      	beq.n	34009b90 <HAL_RCC_GetCpuClockFreq+0x74>
34009b70:	d805      	bhi.n	34009b7e <HAL_RCC_GetCpuClockFreq+0x62>
34009b72:	b953      	cbnz	r3, 34009b8a <HAL_RCC_GetCpuClockFreq+0x6e>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009b74:	f003 fbba 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / ic_divider;
34009b78:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
34009b7c:	e7dd      	b.n	34009b3a <HAL_RCC_GetCpuClockFreq+0x1e>
      switch (LL_RCC_IC1_GetSource())
34009b7e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009b82:	d1de      	bne.n	34009b42 <HAL_RCC_GetCpuClockFreq+0x26>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009b84:	f003 fc72 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
34009b88:	e7f6      	b.n	34009b78 <HAL_RCC_GetCpuClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009b8a:	f003 fbef 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
34009b8e:	e7f3      	b.n	34009b78 <HAL_RCC_GetCpuClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009b90:	f003 fc2c 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
34009b94:	e7f0      	b.n	34009b78 <HAL_RCC_GetCpuClockFreq+0x5c>
  switch (LL_RCC_GetCpuClkSource())
34009b96:	4805      	ldr	r0, [pc, #20]	@ (34009bac <HAL_RCC_GetCpuClockFreq+0x90>)
34009b98:	e7cf      	b.n	34009b3a <HAL_RCC_GetCpuClockFreq+0x1e>
34009b9a:	bf00      	nop
34009b9c:	56028000 	.word	0x56028000
34009ba0:	03d09000 	.word	0x03d09000
34009ba4:	00f42400 	.word	0x00f42400
34009ba8:	003d0900 	.word	0x003d0900
34009bac:	02dc6c00 	.word	0x02dc6c00

34009bb0 <HAL_RCC_ClockConfig>:
{
34009bb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (pRCC_ClkInitStruct == NULL)
34009bb4:	4604      	mov	r4, r0
34009bb6:	b910      	cbnz	r0, 34009bbe <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
34009bb8:	2001      	movs	r0, #1
}
34009bba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));
34009bbe:	6803      	ldr	r3, [r0, #0]
34009bc0:	2b7f      	cmp	r3, #127	@ 0x7f
34009bc2:	d904      	bls.n	34009bce <HAL_RCC_ClockConfig+0x1e>
34009bc4:	f44f 715f 	mov.w	r1, #892	@ 0x37c
34009bc8:	4893      	ldr	r0, [pc, #588]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009bca:	f7f8 fcb3 	bl	34002534 <assert_failed>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34009bce:	6823      	ldr	r3, [r4, #0]
34009bd0:	071f      	lsls	r7, r3, #28
34009bd2:	d513      	bpl.n	34009bfc <HAL_RCC_ClockConfig+0x4c>
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
34009bd4:	6923      	ldr	r3, [r4, #16]
34009bd6:	2b07      	cmp	r3, #7
34009bd8:	d904      	bls.n	34009be4 <HAL_RCC_ClockConfig+0x34>
34009bda:	f240 3183 	movw	r1, #899	@ 0x383
34009bde:	488e      	ldr	r0, [pc, #568]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009be0:	f7f8 fca8 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34009be4:	4a8d      	ldr	r2, [pc, #564]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009be6:	6921      	ldr	r1, [r4, #16]
34009be8:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009bea:	f003 0307 	and.w	r3, r3, #7
34009bee:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34009bf0:	bf81      	itttt	hi
34009bf2:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009bf4:	f023 0307 	bichi.w	r3, r3, #7
34009bf8:	430b      	orrhi	r3, r1
34009bfa:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34009bfc:	6823      	ldr	r3, [r4, #0]
34009bfe:	06de      	lsls	r6, r3, #27
34009c00:	d516      	bpl.n	34009c30 <HAL_RCC_ClockConfig+0x80>
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
34009c02:	6963      	ldr	r3, [r4, #20]
34009c04:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34009c08:	d006      	beq.n	34009c18 <HAL_RCC_ClockConfig+0x68>
34009c0a:	2b40      	cmp	r3, #64	@ 0x40
34009c0c:	d004      	beq.n	34009c18 <HAL_RCC_ClockConfig+0x68>
34009c0e:	f240 318d 	movw	r1, #909	@ 0x38d
34009c12:	4881      	ldr	r0, [pc, #516]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009c14:	f7f8 fc8e 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34009c18:	4a80      	ldr	r2, [pc, #512]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009c1a:	6961      	ldr	r1, [r4, #20]
34009c1c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009c1e:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34009c22:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34009c24:	bf81      	itttt	hi
34009c26:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009c28:	f023 0370 	bichi.w	r3, r3, #112	@ 0x70
34009c2c:	430b      	orrhi	r3, r1
34009c2e:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34009c30:	6823      	ldr	r3, [r4, #0]
34009c32:	069d      	lsls	r5, r3, #26
34009c34:	d517      	bpl.n	34009c66 <HAL_RCC_ClockConfig+0xb6>
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
34009c36:	69a3      	ldr	r3, [r4, #24]
34009c38:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
34009c3c:	d007      	beq.n	34009c4e <HAL_RCC_ClockConfig+0x9e>
34009c3e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34009c42:	d004      	beq.n	34009c4e <HAL_RCC_ClockConfig+0x9e>
34009c44:	f240 3197 	movw	r1, #919	@ 0x397
34009c48:	4873      	ldr	r0, [pc, #460]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009c4a:	f7f8 fc73 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34009c4e:	4a73      	ldr	r2, [pc, #460]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009c50:	69a1      	ldr	r1, [r4, #24]
34009c52:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009c54:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34009c58:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34009c5a:	bf81      	itttt	hi
34009c5c:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009c5e:	f423 43e0 	bichi.w	r3, r3, #28672	@ 0x7000
34009c62:	430b      	orrhi	r3, r1
34009c64:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34009c66:	6823      	ldr	r3, [r4, #0]
34009c68:	0658      	lsls	r0, r3, #25
34009c6a:	d517      	bpl.n	34009c9c <HAL_RCC_ClockConfig+0xec>
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
34009c6c:	69e3      	ldr	r3, [r4, #28]
34009c6e:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34009c72:	d007      	beq.n	34009c84 <HAL_RCC_ClockConfig+0xd4>
34009c74:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009c78:	d004      	beq.n	34009c84 <HAL_RCC_ClockConfig+0xd4>
34009c7a:	f240 31a1 	movw	r1, #929	@ 0x3a1
34009c7e:	4866      	ldr	r0, [pc, #408]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009c80:	f7f8 fc58 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34009c84:	4a65      	ldr	r2, [pc, #404]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009c86:	69e1      	ldr	r1, [r4, #28]
34009c88:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009c8a:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34009c8e:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34009c90:	bf81      	itttt	hi
34009c92:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009c94:	f423 23e0 	bichi.w	r3, r3, #458752	@ 0x70000
34009c98:	430b      	orrhi	r3, r1
34009c9a:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34009c9c:	6823      	ldr	r3, [r4, #0]
34009c9e:	0759      	lsls	r1, r3, #29
34009ca0:	d517      	bpl.n	34009cd2 <HAL_RCC_ClockConfig+0x122>
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
34009ca2:	68e3      	ldr	r3, [r4, #12]
34009ca4:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
34009ca8:	d007      	beq.n	34009cba <HAL_RCC_ClockConfig+0x10a>
34009caa:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34009cae:	d004      	beq.n	34009cba <HAL_RCC_ClockConfig+0x10a>
34009cb0:	f240 31ab 	movw	r1, #939	@ 0x3ab
34009cb4:	4858      	ldr	r0, [pc, #352]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009cb6:	f7f8 fc3d 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
34009cba:	4a58      	ldr	r2, [pc, #352]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009cbc:	68e1      	ldr	r1, [r4, #12]
34009cbe:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009cc0:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34009cc4:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34009cc6:	bf81      	itttt	hi
34009cc8:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009cca:	f423 03e0 	bichi.w	r3, r3, #7340032	@ 0x700000
34009cce:	430b      	orrhi	r3, r1
34009cd0:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
34009cd2:	6823      	ldr	r3, [r4, #0]
34009cd4:	07da      	lsls	r2, r3, #31
34009cd6:	d52a      	bpl.n	34009d2e <HAL_RCC_ClockConfig+0x17e>
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));
34009cd8:	6863      	ldr	r3, [r4, #4]
34009cda:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34009cde:	d004      	beq.n	34009cea <HAL_RCC_ClockConfig+0x13a>
34009ce0:	f240 31b6 	movw	r1, #950	@ 0x3b6
34009ce4:	484c      	ldr	r0, [pc, #304]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009ce6:	f7f8 fc25 	bl	34002534 <assert_failed>
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
34009cea:	6863      	ldr	r3, [r4, #4]
34009cec:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34009cf0:	f040 809a 	bne.w	34009e28 <HAL_RCC_ClockConfig+0x278>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009cf4:	4b49      	ldr	r3, [pc, #292]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009cf6:	685b      	ldr	r3, [r3, #4]
34009cf8:	06db      	lsls	r3, r3, #27
34009cfa:	f57f af5d 	bpl.w	34009bb8 <HAL_RCC_ClockConfig+0x8>
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34009cfe:	4d47      	ldr	r5, [pc, #284]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009d00:	6862      	ldr	r2, [r4, #4]
34009d02:	6a2b      	ldr	r3, [r5, #32]
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009d04:	f241 3788 	movw	r7, #5000	@ 0x1388
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34009d08:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
34009d0c:	4313      	orrs	r3, r2
34009d0e:	622b      	str	r3, [r5, #32]
    tickstart = HAL_GetTick();
34009d10:	f7fa fd7c 	bl	3400480c <HAL_GetTick>
34009d14:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34009d16:	6a2b      	ldr	r3, [r5, #32]
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34009d18:	6862      	ldr	r2, [r4, #4]
34009d1a:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34009d1e:	ebb3 1f02 	cmp.w	r3, r2, lsl #4
34009d22:	f040 80b7 	bne.w	34009e94 <HAL_RCC_ClockConfig+0x2e4>
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
34009d26:	f7ff fef9 	bl	34009b1c <HAL_RCC_GetCpuClockFreq>
34009d2a:	4b3d      	ldr	r3, [pc, #244]	@ (34009e20 <HAL_RCC_ClockConfig+0x270>)
34009d2c:	6018      	str	r0, [r3, #0]
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
34009d2e:	6823      	ldr	r3, [r4, #0]
34009d30:	079f      	lsls	r7, r3, #30
34009d32:	f100 80b7 	bmi.w	34009ea4 <HAL_RCC_ClockConfig+0x2f4>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34009d36:	6823      	ldr	r3, [r4, #0]
34009d38:	075e      	lsls	r6, r3, #29
34009d3a:	f100 815c 	bmi.w	34009ff6 <HAL_RCC_ClockConfig+0x446>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34009d3e:	6823      	ldr	r3, [r4, #0]
34009d40:	0718      	lsls	r0, r3, #28
34009d42:	d513      	bpl.n	34009d6c <HAL_RCC_ClockConfig+0x1bc>
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
34009d44:	6923      	ldr	r3, [r4, #16]
34009d46:	2b07      	cmp	r3, #7
34009d48:	d904      	bls.n	34009d54 <HAL_RCC_ClockConfig+0x1a4>
34009d4a:	f240 4161 	movw	r1, #1121	@ 0x461
34009d4e:	4832      	ldr	r0, [pc, #200]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009d50:	f7f8 fbf0 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34009d54:	4a31      	ldr	r2, [pc, #196]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009d56:	6921      	ldr	r1, [r4, #16]
34009d58:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009d5a:	f003 0307 	and.w	r3, r3, #7
34009d5e:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34009d60:	bf3f      	itttt	cc
34009d62:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009d64:	f023 0307 	biccc.w	r3, r3, #7
34009d68:	430b      	orrcc	r3, r1
34009d6a:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34009d6c:	6823      	ldr	r3, [r4, #0]
34009d6e:	06d9      	lsls	r1, r3, #27
34009d70:	d516      	bpl.n	34009da0 <HAL_RCC_ClockConfig+0x1f0>
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
34009d72:	6963      	ldr	r3, [r4, #20]
34009d74:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34009d78:	d006      	beq.n	34009d88 <HAL_RCC_ClockConfig+0x1d8>
34009d7a:	2b40      	cmp	r3, #64	@ 0x40
34009d7c:	d004      	beq.n	34009d88 <HAL_RCC_ClockConfig+0x1d8>
34009d7e:	f240 416b 	movw	r1, #1131	@ 0x46b
34009d82:	4825      	ldr	r0, [pc, #148]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009d84:	f7f8 fbd6 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34009d88:	4a24      	ldr	r2, [pc, #144]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009d8a:	6961      	ldr	r1, [r4, #20]
34009d8c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009d8e:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34009d92:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34009d94:	bf3f      	itttt	cc
34009d96:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009d98:	f023 0370 	biccc.w	r3, r3, #112	@ 0x70
34009d9c:	430b      	orrcc	r3, r1
34009d9e:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34009da0:	6823      	ldr	r3, [r4, #0]
34009da2:	069a      	lsls	r2, r3, #26
34009da4:	d517      	bpl.n	34009dd6 <HAL_RCC_ClockConfig+0x226>
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
34009da6:	69a3      	ldr	r3, [r4, #24]
34009da8:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
34009dac:	d007      	beq.n	34009dbe <HAL_RCC_ClockConfig+0x20e>
34009dae:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34009db2:	d004      	beq.n	34009dbe <HAL_RCC_ClockConfig+0x20e>
34009db4:	f240 4175 	movw	r1, #1141	@ 0x475
34009db8:	4817      	ldr	r0, [pc, #92]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009dba:	f7f8 fbbb 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34009dbe:	4a17      	ldr	r2, [pc, #92]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009dc0:	69a1      	ldr	r1, [r4, #24]
34009dc2:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009dc4:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34009dc8:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34009dca:	bf3f      	itttt	cc
34009dcc:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009dce:	f423 43e0 	biccc.w	r3, r3, #28672	@ 0x7000
34009dd2:	430b      	orrcc	r3, r1
34009dd4:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34009dd6:	6823      	ldr	r3, [r4, #0]
34009dd8:	065b      	lsls	r3, r3, #25
34009dda:	d517      	bpl.n	34009e0c <HAL_RCC_ClockConfig+0x25c>
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
34009ddc:	69e3      	ldr	r3, [r4, #28]
34009dde:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34009de2:	d007      	beq.n	34009df4 <HAL_RCC_ClockConfig+0x244>
34009de4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009de8:	d004      	beq.n	34009df4 <HAL_RCC_ClockConfig+0x244>
34009dea:	f240 417f 	movw	r1, #1151	@ 0x47f
34009dee:	480a      	ldr	r0, [pc, #40]	@ (34009e18 <HAL_RCC_ClockConfig+0x268>)
34009df0:	f7f8 fba0 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34009df4:	4a09      	ldr	r2, [pc, #36]	@ (34009e1c <HAL_RCC_ClockConfig+0x26c>)
34009df6:	69e1      	ldr	r1, [r4, #28]
34009df8:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009dfa:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34009dfe:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34009e00:	bf3f      	itttt	cc
34009e02:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009e04:	f423 23e0 	biccc.w	r3, r3, #458752	@ 0x70000
34009e08:	430b      	orrcc	r3, r1
34009e0a:	6253      	strcc	r3, [r2, #36]	@ 0x24
  return HAL_InitTick(uwTickPrio);
34009e0c:	4b05      	ldr	r3, [pc, #20]	@ (34009e24 <HAL_RCC_ClockConfig+0x274>)
}
34009e0e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
34009e12:	6818      	ldr	r0, [r3, #0]
34009e14:	f7fa bcb6 	b.w	34004784 <HAL_InitTick>
34009e18:	3401c65c 	.word	0x3401c65c
34009e1c:	56028000 	.word	0x56028000
34009e20:	3403ecbc 	.word	0x3403ecbc
34009e24:	3403ecc4 	.word	0x3403ecc4
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
34009e28:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34009e2c:	d126      	bne.n	34009e7c <HAL_RCC_ClockConfig+0x2cc>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
34009e2e:	6a23      	ldr	r3, [r4, #32]
34009e30:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009e34:	d004      	beq.n	34009e40 <HAL_RCC_ClockConfig+0x290>
34009e36:	f240 31c5 	movw	r1, #965	@ 0x3c5
34009e3a:	487b      	ldr	r0, [pc, #492]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009e3c:	f7f8 fb7a 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));
34009e40:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009e42:	3b01      	subs	r3, #1
34009e44:	2bff      	cmp	r3, #255	@ 0xff
34009e46:	d904      	bls.n	34009e52 <HAL_RCC_ClockConfig+0x2a2>
34009e48:	f240 31c6 	movw	r1, #966	@ 0x3c6
34009e4c:	4876      	ldr	r0, [pc, #472]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009e4e:	f7f8 fb71 	bl	34002534 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009e52:	4e76      	ldr	r6, [pc, #472]	@ (3400a02c <HAL_RCC_ClockConfig+0x47c>)
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
34009e54:	6a25      	ldr	r5, [r4, #32]
34009e56:	f8d6 00c4 	ldr.w	r0, [r6, #196]	@ 0xc4
34009e5a:	4629      	mov	r1, r5
34009e5c:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009e60:	f7ff fa52 	bl	34009308 <RCC_IC_CheckPLLSources>
34009e64:	2801      	cmp	r0, #1
34009e66:	f47f aea7 	bne.w	34009bb8 <HAL_RCC_ClockConfig+0x8>
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
34009e6a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009e6c:	3b01      	subs	r3, #1
34009e6e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
34009e72:	f8c6 50c4 	str.w	r5, [r6, #196]	@ 0xc4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34009e76:	f8c6 0a40 	str.w	r0, [r6, #2624]	@ 0xa40
}
34009e7a:	e740      	b.n	34009cfe <HAL_RCC_ClockConfig+0x14e>
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
34009e7c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34009e80:	d105      	bne.n	34009e8e <HAL_RCC_ClockConfig+0x2de>
      if (LL_RCC_MSI_IsReady() == 0U)
34009e82:	f7ff f8bb 	bl	34008ffc <LL_RCC_MSI_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
34009e86:	2800      	cmp	r0, #0
34009e88:	f47f af39 	bne.w	34009cfe <HAL_RCC_ClockConfig+0x14e>
34009e8c:	e694      	b.n	34009bb8 <HAL_RCC_ClockConfig+0x8>
34009e8e:	f7ff f8ad 	bl	34008fec <LL_RCC_HSI_IsReady>
34009e92:	e7f8      	b.n	34009e86 <HAL_RCC_ClockConfig+0x2d6>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009e94:	f7fa fcba 	bl	3400480c <HAL_GetTick>
34009e98:	1b80      	subs	r0, r0, r6
34009e9a:	42b8      	cmp	r0, r7
34009e9c:	f67f af3b 	bls.w	34009d16 <HAL_RCC_ClockConfig+0x166>
        return HAL_TIMEOUT;
34009ea0:	2003      	movs	r0, #3
34009ea2:	e68a      	b.n	34009bba <HAL_RCC_ClockConfig+0xa>
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
34009ea4:	68a3      	ldr	r3, [r4, #8]
34009ea6:	f033 7340 	bics.w	r3, r3, #50331648	@ 0x3000000
34009eaa:	d004      	beq.n	34009eb6 <HAL_RCC_ClockConfig+0x306>
34009eac:	f240 31ff 	movw	r1, #1023	@ 0x3ff
34009eb0:	485d      	ldr	r0, [pc, #372]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009eb2:	f7f8 fb3f 	bl	34002534 <assert_failed>
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
34009eb6:	68a3      	ldr	r3, [r4, #8]
34009eb8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34009ebc:	d11e      	bne.n	34009efc <HAL_RCC_ClockConfig+0x34c>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009ebe:	4b5b      	ldr	r3, [pc, #364]	@ (3400a02c <HAL_RCC_ClockConfig+0x47c>)
34009ec0:	685b      	ldr	r3, [r3, #4]
34009ec2:	06dd      	lsls	r5, r3, #27
34009ec4:	f57f ae78 	bpl.w	34009bb8 <HAL_RCC_ClockConfig+0x8>
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34009ec8:	4d58      	ldr	r5, [pc, #352]	@ (3400a02c <HAL_RCC_ClockConfig+0x47c>)
34009eca:	68a2      	ldr	r2, [r4, #8]
34009ecc:	6a2b      	ldr	r3, [r5, #32]
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009ece:	f241 3788 	movw	r7, #5000	@ 0x1388
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34009ed2:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
34009ed6:	4313      	orrs	r3, r2
34009ed8:	622b      	str	r3, [r5, #32]
    tickstart = HAL_GetTick();
34009eda:	f7fa fc97 	bl	3400480c <HAL_GetTick>
34009ede:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34009ee0:	6a2b      	ldr	r3, [r5, #32]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34009ee2:	68a2      	ldr	r2, [r4, #8]
34009ee4:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34009ee8:	ebb3 1f02 	cmp.w	r3, r2, lsl #4
34009eec:	f43f af23 	beq.w	34009d36 <HAL_RCC_ClockConfig+0x186>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009ef0:	f7fa fc8c 	bl	3400480c <HAL_GetTick>
34009ef4:	1b80      	subs	r0, r0, r6
34009ef6:	42b8      	cmp	r0, r7
34009ef8:	d9f2      	bls.n	34009ee0 <HAL_RCC_ClockConfig+0x330>
34009efa:	e7d1      	b.n	34009ea0 <HAL_RCC_ClockConfig+0x2f0>
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
34009efc:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34009f00:	d16f      	bne.n	34009fe2 <HAL_RCC_ClockConfig+0x432>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC2Selection.ClockSelection));
34009f02:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34009f04:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009f08:	d004      	beq.n	34009f14 <HAL_RCC_ClockConfig+0x364>
34009f0a:	f240 410e 	movw	r1, #1038	@ 0x40e
34009f0e:	4846      	ldr	r0, [pc, #280]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009f10:	f7f8 fb10 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC2Selection.ClockDivider));
34009f14:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34009f16:	3b01      	subs	r3, #1
34009f18:	2bff      	cmp	r3, #255	@ 0xff
34009f1a:	d904      	bls.n	34009f26 <HAL_RCC_ClockConfig+0x376>
34009f1c:	f240 410f 	movw	r1, #1039	@ 0x40f
34009f20:	4841      	ldr	r0, [pc, #260]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009f22:	f7f8 fb07 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC6Selection.ClockSelection));
34009f26:	6b23      	ldr	r3, [r4, #48]	@ 0x30
34009f28:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009f2c:	d004      	beq.n	34009f38 <HAL_RCC_ClockConfig+0x388>
34009f2e:	f44f 6182 	mov.w	r1, #1040	@ 0x410
34009f32:	483d      	ldr	r0, [pc, #244]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009f34:	f7f8 fafe 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC6Selection.ClockDivider));
34009f38:	6b63      	ldr	r3, [r4, #52]	@ 0x34
34009f3a:	3b01      	subs	r3, #1
34009f3c:	2bff      	cmp	r3, #255	@ 0xff
34009f3e:	d904      	bls.n	34009f4a <HAL_RCC_ClockConfig+0x39a>
34009f40:	f240 4111 	movw	r1, #1041	@ 0x411
34009f44:	4838      	ldr	r0, [pc, #224]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009f46:	f7f8 faf5 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
34009f4a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
34009f4c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009f50:	d004      	beq.n	34009f5c <HAL_RCC_ClockConfig+0x3ac>
34009f52:	f240 4112 	movw	r1, #1042	@ 0x412
34009f56:	4834      	ldr	r0, [pc, #208]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009f58:	f7f8 faec 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));
34009f5c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
34009f5e:	3b01      	subs	r3, #1
34009f60:	2bff      	cmp	r3, #255	@ 0xff
34009f62:	d904      	bls.n	34009f6e <HAL_RCC_ClockConfig+0x3be>
34009f64:	f240 4113 	movw	r1, #1043	@ 0x413
34009f68:	482f      	ldr	r0, [pc, #188]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
34009f6a:	f7f8 fae3 	bl	34002534 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009f6e:	4d2f      	ldr	r5, [pc, #188]	@ (3400a02c <HAL_RCC_ClockConfig+0x47c>)
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
34009f70:	f8d4 8028 	ldr.w	r8, [r4, #40]	@ 0x28
34009f74:	f8d5 00c8 	ldr.w	r0, [r5, #200]	@ 0xc8
34009f78:	4641      	mov	r1, r8
34009f7a:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009f7e:	f7ff f9c3 	bl	34009308 <RCC_IC_CheckPLLSources>
34009f82:	2801      	cmp	r0, #1
34009f84:	f47f ae18 	bne.w	34009bb8 <HAL_RCC_ClockConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009f88:	f8d5 00d8 	ldr.w	r0, [r5, #216]	@ 0xd8
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
34009f8c:	6b27      	ldr	r7, [r4, #48]	@ 0x30
34009f8e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009f92:	4639      	mov	r1, r7
34009f94:	f7ff f9b8 	bl	34009308 <RCC_IC_CheckPLLSources>
34009f98:	2801      	cmp	r0, #1
34009f9a:	f47f ae0d 	bne.w	34009bb8 <HAL_RCC_ClockConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009f9e:	f8d5 00ec 	ldr.w	r0, [r5, #236]	@ 0xec
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
34009fa2:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
34009fa4:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009fa8:	4631      	mov	r1, r6
34009faa:	f7ff f9ad 	bl	34009308 <RCC_IC_CheckPLLSources>
34009fae:	2801      	cmp	r0, #1
34009fb0:	f47f ae02 	bne.w	34009bb8 <HAL_RCC_ClockConfig+0x8>
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
34009fb4:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34009fb6:	3b01      	subs	r3, #1
34009fb8:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
34009fbc:	f8c5 30c8 	str.w	r3, [r5, #200]	@ 0xc8
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
34009fc0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
34009fc2:	3b01      	subs	r3, #1
34009fc4:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
34009fc8:	f8c5 70d8 	str.w	r7, [r5, #216]	@ 0xd8
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
34009fcc:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
34009fce:	3b01      	subs	r3, #1
34009fd0:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
34009fd4:	f240 4322 	movw	r3, #1058	@ 0x422
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
34009fd8:	f8c5 60ec 	str.w	r6, [r5, #236]	@ 0xec
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
34009fdc:	f8c5 3a40 	str.w	r3, [r5, #2624]	@ 0xa40
34009fe0:	e772      	b.n	34009ec8 <HAL_RCC_ClockConfig+0x318>
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
34009fe2:	b92b      	cbnz	r3, 34009ff0 <HAL_RCC_ClockConfig+0x440>
      if (LL_RCC_HSI_IsReady() == 0U)
34009fe4:	f7ff f802 	bl	34008fec <LL_RCC_HSI_IsReady>
      if (LL_RCC_MSI_IsReady() == 0U)
34009fe8:	2800      	cmp	r0, #0
34009fea:	f47f af6d 	bne.w	34009ec8 <HAL_RCC_ClockConfig+0x318>
34009fee:	e5e3      	b.n	34009bb8 <HAL_RCC_ClockConfig+0x8>
34009ff0:	f7ff f804 	bl	34008ffc <LL_RCC_MSI_IsReady>
34009ff4:	e7f8      	b.n	34009fe8 <HAL_RCC_ClockConfig+0x438>
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
34009ff6:	68e3      	ldr	r3, [r4, #12]
34009ff8:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
34009ffc:	d007      	beq.n	3400a00e <HAL_RCC_ClockConfig+0x45e>
34009ffe:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3400a002:	d004      	beq.n	3400a00e <HAL_RCC_ClockConfig+0x45e>
3400a004:	f240 4156 	movw	r1, #1110	@ 0x456
3400a008:	4807      	ldr	r0, [pc, #28]	@ (3400a028 <HAL_RCC_ClockConfig+0x478>)
3400a00a:	f7f8 fa93 	bl	34002534 <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400a00e:	4a07      	ldr	r2, [pc, #28]	@ (3400a02c <HAL_RCC_ClockConfig+0x47c>)
3400a010:	68e1      	ldr	r1, [r4, #12]
3400a012:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a014:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400a018:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400a01a:	bf3f      	itttt	cc
3400a01c:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a01e:	f423 03e0 	biccc.w	r3, r3, #7340032	@ 0x700000
3400a022:	430b      	orrcc	r3, r1
3400a024:	6253      	strcc	r3, [r2, #36]	@ 0x24
3400a026:	e68a      	b.n	34009d3e <HAL_RCC_ClockConfig+0x18e>
3400a028:	3401c65c 	.word	0x3401c65c
3400a02c:	56028000 	.word	0x56028000

3400a030 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3400a030:	4b1f      	ldr	r3, [pc, #124]	@ (3400a0b0 <HAL_RCC_GetSysClockFreq+0x80>)
{
3400a032:	b510      	push	{r4, lr}
3400a034:	6a1a      	ldr	r2, [r3, #32]
3400a036:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
  switch (LL_RCC_GetSysClkSource())
3400a03a:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
3400a03e:	d034      	beq.n	3400a0aa <HAL_RCC_GetSysClockFreq+0x7a>
3400a040:	d806      	bhi.n	3400a050 <HAL_RCC_GetSysClockFreq+0x20>
3400a042:	b952      	cbnz	r2, 3400a05a <HAL_RCC_GetSysClockFreq+0x2a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400a044:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a046:	481b      	ldr	r0, [pc, #108]	@ (3400a0b4 <HAL_RCC_GetSysClockFreq+0x84>)
3400a048:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400a04c:	40d8      	lsrs	r0, r3
}
3400a04e:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSysClkSource())
3400a050:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
3400a054:	d009      	beq.n	3400a06a <HAL_RCC_GetSysClockFreq+0x3a>
      switch (LL_RCC_IC2_GetSource())
3400a056:	2000      	movs	r0, #0
3400a058:	e7f9      	b.n	3400a04e <HAL_RCC_GetSysClockFreq+0x1e>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400a05a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        frequency = MSI_VALUE;
3400a05c:	4816      	ldr	r0, [pc, #88]	@ (3400a0b8 <HAL_RCC_GetSysClockFreq+0x88>)
3400a05e:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400a062:	4b16      	ldr	r3, [pc, #88]	@ (3400a0bc <HAL_RCC_GetSysClockFreq+0x8c>)
3400a064:	bf08      	it	eq
3400a066:	4618      	moveq	r0, r3
3400a068:	e7f1      	b.n	3400a04e <HAL_RCC_GetSysClockFreq+0x1e>
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a06a:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a06e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a072:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a076:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
      switch (LL_RCC_IC2_GetSource())
3400a07a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a07e:	f100 0401 	add.w	r4, r0, #1
3400a082:	d00f      	beq.n	3400a0a4 <HAL_RCC_GetSysClockFreq+0x74>
3400a084:	d805      	bhi.n	3400a092 <HAL_RCC_GetSysClockFreq+0x62>
3400a086:	b953      	cbnz	r3, 3400a09e <HAL_RCC_GetSysClockFreq+0x6e>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a088:	f003 f930 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / ic_divider;
3400a08c:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
3400a090:	e7dd      	b.n	3400a04e <HAL_RCC_GetSysClockFreq+0x1e>
      switch (LL_RCC_IC2_GetSource())
3400a092:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a096:	d1de      	bne.n	3400a056 <HAL_RCC_GetSysClockFreq+0x26>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a098:	f003 f9e8 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400a09c:	e7f6      	b.n	3400a08c <HAL_RCC_GetSysClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a09e:	f003 f965 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400a0a2:	e7f3      	b.n	3400a08c <HAL_RCC_GetSysClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a0a4:	f003 f9a2 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400a0a8:	e7f0      	b.n	3400a08c <HAL_RCC_GetSysClockFreq+0x5c>
  switch (LL_RCC_GetSysClkSource())
3400a0aa:	4805      	ldr	r0, [pc, #20]	@ (3400a0c0 <HAL_RCC_GetSysClockFreq+0x90>)
3400a0ac:	e7cf      	b.n	3400a04e <HAL_RCC_GetSysClockFreq+0x1e>
3400a0ae:	bf00      	nop
3400a0b0:	56028000 	.word	0x56028000
3400a0b4:	03d09000 	.word	0x03d09000
3400a0b8:	00f42400 	.word	0x00f42400
3400a0bc:	003d0900 	.word	0x003d0900
3400a0c0:	02dc6c00 	.word	0x02dc6c00

3400a0c4 <HAL_RCC_GetPCLK1Freq>:
{
3400a0c4:	b508      	push	{r3, lr}
  return LL_RCC_CALC_PCLK1_FREQ(LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()),
3400a0c6:	f7ff ffb3 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400a0ca:	4b05      	ldr	r3, [pc, #20]	@ (3400a0e0 <HAL_RCC_GetPCLK1Freq+0x1c>)
3400a0cc:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400a0ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400a0d0:	f3c2 5202 	ubfx	r2, r2, #20, #3
3400a0d4:	40d0      	lsrs	r0, r2
3400a0d6:	f003 0307 	and.w	r3, r3, #7
}
3400a0da:	40d8      	lsrs	r0, r3
3400a0dc:	bd08      	pop	{r3, pc}
3400a0de:	bf00      	nop
3400a0e0:	56028000 	.word	0x56028000

3400a0e4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400a0e4:	4a02      	ldr	r2, [pc, #8]	@ (3400a0f0 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0xc>)
3400a0e6:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3400a0e8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400a0ec:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400a0ee:	4770      	bx	lr
3400a0f0:	56028000 	.word	0x56028000

3400a0f4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400a0f4:	4a02      	ldr	r2, [pc, #8]	@ (3400a100 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0xc>)
3400a0f6:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3400a0f8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400a0fc:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400a0fe:	4770      	bx	lr
3400a100:	56028000 	.word	0x56028000

3400a104 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400a104:	4b02      	ldr	r3, [pc, #8]	@ (3400a110 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0xc>)
3400a106:	6d58      	ldr	r0, [r3, #84]	@ 0x54
}
3400a108:	f3c0 1080 	ubfx	r0, r0, #6, #1
3400a10c:	4770      	bx	lr
3400a10e:	bf00      	nop
3400a110:	56028000 	.word	0x56028000

3400a114 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400a114:	4b02      	ldr	r3, [pc, #8]	@ (3400a120 <LL_RCC_HSE_IsReady+0xc>)
3400a116:	6858      	ldr	r0, [r3, #4]
}
3400a118:	f3c0 1000 	ubfx	r0, r0, #4, #1
3400a11c:	4770      	bx	lr
3400a11e:	bf00      	nop
3400a120:	56028000 	.word	0x56028000

3400a124 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400a124:	4b02      	ldr	r3, [pc, #8]	@ (3400a130 <LL_RCC_HSI_IsReady+0xc>)
3400a126:	6858      	ldr	r0, [r3, #4]
}
3400a128:	f3c0 00c0 	ubfx	r0, r0, #3, #1
3400a12c:	4770      	bx	lr
3400a12e:	bf00      	nop
3400a130:	56028000 	.word	0x56028000

3400a134 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400a134:	4b02      	ldr	r3, [pc, #8]	@ (3400a140 <LL_RCC_MSI_IsReady+0xc>)
3400a136:	6858      	ldr	r0, [r3, #4]
}
3400a138:	f3c0 0080 	ubfx	r0, r0, #2, #1
3400a13c:	4770      	bx	lr
3400a13e:	bf00      	nop
3400a140:	56028000 	.word	0x56028000

3400a144 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400a144:	4b02      	ldr	r3, [pc, #8]	@ (3400a150 <LL_RCC_LSE_IsReady+0xc>)
3400a146:	6858      	ldr	r0, [r3, #4]
}
3400a148:	f3c0 0040 	ubfx	r0, r0, #1, #1
3400a14c:	4770      	bx	lr
3400a14e:	bf00      	nop
3400a150:	56028000 	.word	0x56028000

3400a154 <LL_RCC_SetClockSource>:
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400a154:	4907      	ldr	r1, [pc, #28]	@ (3400a174 <LL_RCC_SetClockSource+0x20>)
{
3400a156:	b530      	push	{r4, r5, lr}
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400a158:	b2c4      	uxtb	r4, r0
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3400a15a:	f3c0 2504 	ubfx	r5, r0, #8, #5
3400a15e:	5863      	ldr	r3, [r4, r1]
3400a160:	0e02      	lsrs	r2, r0, #24
3400a162:	40aa      	lsls	r2, r5
3400a164:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400a168:	ea23 0302 	bic.w	r3, r3, r2
3400a16c:	40a8      	lsls	r0, r5
3400a16e:	4303      	orrs	r3, r0
3400a170:	5063      	str	r3, [r4, r1]
}
3400a172:	bd30      	pop	{r4, r5, pc}
3400a174:	56028144 	.word	0x56028144

3400a178 <LL_RCC_GetClockSource>:
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3400a178:	4b05      	ldr	r3, [pc, #20]	@ (3400a190 <LL_RCC_GetClockSource+0x18>)
3400a17a:	b2c2      	uxtb	r2, r0
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3400a17c:	58d1      	ldr	r1, [r2, r3]
3400a17e:	f3c0 2204 	ubfx	r2, r0, #8, #5
3400a182:	0e03      	lsrs	r3, r0, #24
3400a184:	4093      	lsls	r3, r2
3400a186:	400b      	ands	r3, r1
3400a188:	40d3      	lsrs	r3, r2
}
3400a18a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
3400a18e:	4770      	bx	lr
3400a190:	56028144 	.word	0x56028144

3400a194 <LL_RCC_IC7_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3400a194:	4b02      	ldr	r3, [pc, #8]	@ (3400a1a0 <LL_RCC_IC7_IsEnabled+0xc>)
3400a196:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a19a:	f3c0 1080 	ubfx	r0, r0, #6, #1
3400a19e:	4770      	bx	lr
3400a1a0:	56028000 	.word	0x56028000

3400a1a4 <LL_RCC_IC7_GetDivider>:
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3400a1a4:	4b03      	ldr	r3, [pc, #12]	@ (3400a1b4 <LL_RCC_IC7_GetDivider+0x10>)
3400a1a6:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3400a1aa:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a1ae:	3001      	adds	r0, #1
3400a1b0:	4770      	bx	lr
3400a1b2:	bf00      	nop
3400a1b4:	56028000 	.word	0x56028000

3400a1b8 <LL_RCC_IC8_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3400a1b8:	4b02      	ldr	r3, [pc, #8]	@ (3400a1c4 <LL_RCC_IC8_IsEnabled+0xc>)
3400a1ba:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a1be:	f3c0 10c0 	ubfx	r0, r0, #7, #1
3400a1c2:	4770      	bx	lr
3400a1c4:	56028000 	.word	0x56028000

3400a1c8 <LL_RCC_IC8_GetDivider>:
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3400a1c8:	4b03      	ldr	r3, [pc, #12]	@ (3400a1d8 <LL_RCC_IC8_GetDivider+0x10>)
3400a1ca:	f8d3 00e0 	ldr.w	r0, [r3, #224]	@ 0xe0
3400a1ce:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a1d2:	3001      	adds	r0, #1
3400a1d4:	4770      	bx	lr
3400a1d6:	bf00      	nop
3400a1d8:	56028000 	.word	0x56028000

3400a1dc <LL_RCC_IC9_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3400a1dc:	4b02      	ldr	r3, [pc, #8]	@ (3400a1e8 <LL_RCC_IC9_IsEnabled+0xc>)
3400a1de:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a1e2:	f3c0 2000 	ubfx	r0, r0, #8, #1
3400a1e6:	4770      	bx	lr
3400a1e8:	56028000 	.word	0x56028000

3400a1ec <LL_RCC_IC9_GetDivider>:
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3400a1ec:	4b03      	ldr	r3, [pc, #12]	@ (3400a1fc <LL_RCC_IC9_GetDivider+0x10>)
3400a1ee:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
3400a1f2:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a1f6:	3001      	adds	r0, #1
3400a1f8:	4770      	bx	lr
3400a1fa:	bf00      	nop
3400a1fc:	56028000 	.word	0x56028000

3400a200 <LL_RCC_IC14_IsEnabled>:
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3400a200:	4b02      	ldr	r3, [pc, #8]	@ (3400a20c <LL_RCC_IC14_IsEnabled+0xc>)
3400a202:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a206:	f3c0 3040 	ubfx	r0, r0, #13, #1
3400a20a:	4770      	bx	lr
3400a20c:	56028000 	.word	0x56028000

3400a210 <LL_RCC_IC14_GetDivider>:
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3400a210:	4b03      	ldr	r3, [pc, #12]	@ (3400a220 <LL_RCC_IC14_GetDivider+0x10>)
3400a212:	f8d3 00f8 	ldr.w	r0, [r3, #248]	@ 0xf8
3400a216:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a21a:	3001      	adds	r0, #1
3400a21c:	4770      	bx	lr
3400a21e:	bf00      	nop
3400a220:	56028000 	.word	0x56028000

3400a224 <LL_RCC_IC15_IsEnabled>:
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3400a224:	4b02      	ldr	r3, [pc, #8]	@ (3400a230 <LL_RCC_IC15_IsEnabled+0xc>)
3400a226:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a22a:	f3c0 3080 	ubfx	r0, r0, #14, #1
3400a22e:	4770      	bx	lr
3400a230:	56028000 	.word	0x56028000

3400a234 <LL_RCC_IC15_GetDivider>:
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3400a234:	4b03      	ldr	r3, [pc, #12]	@ (3400a244 <LL_RCC_IC15_GetDivider+0x10>)
3400a236:	f8d3 00fc 	ldr.w	r0, [r3, #252]	@ 0xfc
3400a23a:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a23e:	3001      	adds	r0, #1
3400a240:	4770      	bx	lr
3400a242:	bf00      	nop
3400a244:	56028000 	.word	0x56028000

3400a248 <RCCEx_GetHCLKFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400a248:	4b02      	ldr	r3, [pc, #8]	@ (3400a254 <RCCEx_GetHCLKFreq+0xc>)
3400a24a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
3400a24c:	f3c3 5302 	ubfx	r3, r3, #20, #3
}
3400a250:	40d8      	lsrs	r0, r3
3400a252:	4770      	bx	lr
3400a254:	56028000 	.word	0x56028000

3400a258 <RCCEx_GetPLLSourceFreq>:
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;

  switch (PLLsource)
3400a258:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
3400a25c:	b508      	push	{r3, lr}
  switch (PLLsource)
3400a25e:	d01d      	beq.n	3400a29c <RCCEx_GetPLLSourceFreq+0x44>
3400a260:	d80a      	bhi.n	3400a278 <RCCEx_GetPLLSourceFreq+0x20>
3400a262:	b970      	cbnz	r0, 3400a282 <RCCEx_GetPLLSourceFreq+0x2a>
  {
    case LL_RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400a264:	f7ff ff5e 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400a268:	b148      	cbz	r0, 3400a27e <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400a26a:	4b10      	ldr	r3, [pc, #64]	@ (3400a2ac <RCCEx_GetPLLSourceFreq+0x54>)
      {
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a26c:	4810      	ldr	r0, [pc, #64]	@ (3400a2b0 <RCCEx_GetPLLSourceFreq+0x58>)
3400a26e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400a270:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400a274:	40d8      	lsrs	r0, r3
3400a276:	e003      	b.n	3400a280 <RCCEx_GetPLLSourceFreq+0x28>
  switch (PLLsource)
3400a278:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400a27c:	d014      	beq.n	3400a2a8 <RCCEx_GetPLLSourceFreq+0x50>
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
3400a27e:	2000      	movs	r0, #0
      /* unexpected case */
      break;
  }

  return pllinputfreq;
}
3400a280:	bd08      	pop	{r3, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400a282:	f7ff ff57 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400a286:	2800      	cmp	r0, #0
3400a288:	d0f9      	beq.n	3400a27e <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400a28a:	4b08      	ldr	r3, [pc, #32]	@ (3400a2ac <RCCEx_GetPLLSourceFreq+0x54>)
          pllinputfreq = MSI_VALUE;
3400a28c:	4809      	ldr	r0, [pc, #36]	@ (3400a2b4 <RCCEx_GetPLLSourceFreq+0x5c>)
3400a28e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400a290:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400a294:	4b08      	ldr	r3, [pc, #32]	@ (3400a2b8 <RCCEx_GetPLLSourceFreq+0x60>)
3400a296:	bf08      	it	eq
3400a298:	4618      	moveq	r0, r3
3400a29a:	e7f1      	b.n	3400a280 <RCCEx_GetPLLSourceFreq+0x28>
      if (LL_RCC_HSE_IsReady() != 0U)
3400a29c:	f7ff ff3a 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400a2a0:	2800      	cmp	r0, #0
3400a2a2:	d0ec      	beq.n	3400a27e <RCCEx_GetPLLSourceFreq+0x26>
        pllinputfreq = HSE_VALUE;
3400a2a4:	4805      	ldr	r0, [pc, #20]	@ (3400a2bc <RCCEx_GetPLLSourceFreq+0x64>)
3400a2a6:	e7eb      	b.n	3400a280 <RCCEx_GetPLLSourceFreq+0x28>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
3400a2a8:	4805      	ldr	r0, [pc, #20]	@ (3400a2c0 <RCCEx_GetPLLSourceFreq+0x68>)
3400a2aa:	e7e9      	b.n	3400a280 <RCCEx_GetPLLSourceFreq+0x28>
3400a2ac:	56028000 	.word	0x56028000
3400a2b0:	03d09000 	.word	0x03d09000
3400a2b4:	00f42400 	.word	0x00f42400
3400a2b8:	003d0900 	.word	0x003d0900
3400a2bc:	02dc6c00 	.word	0x02dc6c00
3400a2c0:	00bb8000 	.word	0x00bb8000

3400a2c4 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
3400a2c4:	ee07 2a10 	vmov	s14, r2
3400a2c8:	ee06 3a10 	vmov	s12, r3
3400a2cc:	ee07 0a90 	vmov	s15, r0
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3400a2d0:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
3400a2d4:	eddf 5a10 	vldr	s11, [pc, #64]	@ 3400a318 <RCCEx_CalcPLLFreq+0x54>
3400a2d8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
3400a2dc:	ee06 1a90 	vmov	s13, r1
  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3400a2e0:	eea6 7a25 	vfma.f32	s14, s12, s11
3400a2e4:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400a2e8:	ee67 7a87 	vmul.f32	s15, s15, s14
3400a2ec:	eeb8 7a66 	vcvt.f32.u32	s14, s13
3400a2f0:	ee87 6a87 	vdiv.f32	s12, s15, s14

  freq = freq / (float_t)P1;
3400a2f4:	eddd 7a00 	vldr	s15, [sp]
3400a2f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400a2fc:	eec6 6a27 	vdiv.f32	s13, s12, s15
  freq = freq / (float_t)P2;
3400a300:	eddd 7a01 	vldr	s15, [sp, #4]
3400a304:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400a308:	ee86 7aa7 	vdiv.f32	s14, s13, s15

  return (uint32_t)freq;
}
3400a30c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
3400a310:	ee17 0a90 	vmov	r0, s15
3400a314:	4770      	bx	lr
3400a316:	bf00      	nop
3400a318:	33800000 	.word	0x33800000

3400a31c <HAL_RCCEx_PeriphCLKConfig>:
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400a31c:	e9d0 2300 	ldrd	r2, r3, [r0]
3400a320:	f023 437e 	bic.w	r3, r3, #4261412864	@ 0xfe000000
3400a324:	431a      	orrs	r2, r3
{
3400a326:	b570      	push	{r4, r5, r6, lr}
3400a328:	4604      	mov	r4, r0
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400a32a:	d103      	bne.n	3400a334 <HAL_RCCEx_PeriphCLKConfig+0x18>
3400a32c:	2193      	movs	r1, #147	@ 0x93
3400a32e:	4861      	ldr	r0, [pc, #388]	@ (3400a4b4 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400a330:	f7f8 f900 	bl	34002534 <assert_failed>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400a334:	6823      	ldr	r3, [r4, #0]
3400a336:	011a      	lsls	r2, r3, #4
3400a338:	f140 808e 	bpl.w	3400a458 <HAL_RCCEx_PeriphCLKConfig+0x13c>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
3400a33c:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400a340:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400a344:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3400a348:	d05a      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a34a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400a34e:	d057      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a350:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
3400a354:	f5b2 5f98 	cmp.w	r2, #4864	@ 0x1300
3400a358:	d052      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a35a:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
3400a35e:	f5b2 5f0c 	cmp.w	r2, #8960	@ 0x2300
3400a362:	d04d      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a364:	f423 4210 	bic.w	r2, r3, #36864	@ 0x9000
3400a368:	f5b2 4f86 	cmp.w	r2, #17152	@ 0x4300
3400a36c:	d048      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a36e:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
3400a372:	f5b2 4fe6 	cmp.w	r2, #29440	@ 0x7300
3400a376:	d043      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a378:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3400a37c:	f5b2 4f03 	cmp.w	r2, #33536	@ 0x8300
3400a380:	d03e      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a382:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400a386:	f5b1 4f63 	cmp.w	r1, #58112	@ 0xe300
3400a38a:	d039      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a38c:	494a      	ldr	r1, [pc, #296]	@ (3400a4b8 <HAL_RCCEx_PeriphCLKConfig+0x19c>)
3400a38e:	428a      	cmp	r2, r1
3400a390:	d036      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a392:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a396:	428a      	cmp	r2, r1
3400a398:	d032      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a39a:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a39e:	428a      	cmp	r2, r1
3400a3a0:	d02e      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3a2:	f423 3004 	bic.w	r0, r3, #135168	@ 0x21000
3400a3a6:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3aa:	4288      	cmp	r0, r1
3400a3ac:	d028      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3ae:	f423 3000 	bic.w	r0, r3, #131072	@ 0x20000
3400a3b2:	f501 5140 	add.w	r1, r1, #12288	@ 0x3000
3400a3b6:	4288      	cmp	r0, r1
3400a3b8:	d022      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3ba:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
3400a3be:	428a      	cmp	r2, r1
3400a3c0:	d01e      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3c2:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3c6:	428a      	cmp	r2, r1
3400a3c8:	d01a      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3ca:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3ce:	428a      	cmp	r2, r1
3400a3d0:	d016      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3d2:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3d6:	428a      	cmp	r2, r1
3400a3d8:	d012      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3da:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3de:	428a      	cmp	r2, r1
3400a3e0:	d00e      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3e2:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3e6:	428a      	cmp	r2, r1
3400a3e8:	d00a      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3ea:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a3ee:	428a      	cmp	r2, r1
3400a3f0:	d006      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3f2:	4a32      	ldr	r2, [pc, #200]	@ (3400a4bc <HAL_RCCEx_PeriphCLKConfig+0x1a0>)
3400a3f4:	4293      	cmp	r3, r2
3400a3f6:	d003      	beq.n	3400a400 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a3f8:	2199      	movs	r1, #153	@ 0x99
3400a3fa:	482e      	ldr	r0, [pc, #184]	@ (3400a4b4 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400a3fc:	f7f8 f89a 	bl	34002534 <assert_failed>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400a400:	4b2f      	ldr	r3, [pc, #188]	@ (3400a4c0 <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400a402:	f8d4 1188 	ldr.w	r1, [r4, #392]	@ 0x188
3400a406:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400a40a:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
3400a40e:	d13b      	bne.n	3400a488 <HAL_RCCEx_PeriphCLKConfig+0x16c>
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3400a410:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3400a414:	d108      	bne.n	3400a428 <HAL_RCCEx_PeriphCLKConfig+0x10c>
        tickstart = HAL_GetTick();
3400a416:	f7fa f9f9 	bl	3400480c <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a41a:	f241 3688 	movw	r6, #5000	@ 0x1388
        tickstart = HAL_GetTick();
3400a41e:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() == 0U)
3400a420:	f7ff fe90 	bl	3400a144 <LL_RCC_LSE_IsReady>
3400a424:	2800      	cmp	r0, #0
3400a426:	d03d      	beq.n	3400a4a4 <HAL_RCCEx_PeriphCLKConfig+0x188>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3400a428:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400a42c:	4a24      	ldr	r2, [pc, #144]	@ (3400a4c0 <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
3400a42e:	f403 7040 	and.w	r0, r3, #768	@ 0x300
3400a432:	f5b0 7f40 	cmp.w	r0, #768	@ 0x300
3400a436:	d108      	bne.n	3400a44a <HAL_RCCEx_PeriphCLKConfig+0x12e>
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3400a438:	f8d2 115c 	ldr.w	r1, [r2, #348]	@ 0x15c
3400a43c:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400a440:	f421 317c 	bic.w	r1, r1, #258048	@ 0x3f000
3400a444:	430b      	orrs	r3, r1
3400a446:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400a44a:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400a44e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400a452:	4303      	orrs	r3, r0
3400a454:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3400a458:	2500      	movs	r5, #0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3400a45a:	6823      	ldr	r3, [r4, #0]
3400a45c:	075e      	lsls	r6, r3, #29
3400a45e:	d55f      	bpl.n	3400a520 <HAL_RCCEx_PeriphCLKConfig+0x204>
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));
3400a460:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400a464:	2b07      	cmp	r3, #7
3400a466:	d903      	bls.n	3400a470 <HAL_RCCEx_PeriphCLKConfig+0x154>
3400a468:	21df      	movs	r1, #223	@ 0xdf
3400a46a:	4812      	ldr	r0, [pc, #72]	@ (3400a4b4 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400a46c:	f7f8 f862 	bl	34002534 <assert_failed>
    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3400a470:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400a474:	3b03      	subs	r3, #3
3400a476:	2b04      	cmp	r3, #4
3400a478:	d848      	bhi.n	3400a50c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
3400a47a:	e8df f013 	tbh	[pc, r3, lsl #1]
3400a47e:	0f27      	.short	0x0f27
3400a480:	0ee10025 	.word	0x0ee10025
3400a484:	0f500f04 	.word	0x0f500f04
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400a488:	f401 7240 	and.w	r2, r1, #768	@ 0x300
3400a48c:	429a      	cmp	r2, r3
3400a48e:	d0bf      	beq.n	3400a410 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3400a490:	4b0c      	ldr	r3, [pc, #48]	@ (3400a4c4 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
3400a492:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400a494:	f042 0201 	orr.w	r2, r2, #1
3400a498:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3400a49a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400a49c:	07db      	lsls	r3, r3, #31
3400a49e:	d4b7      	bmi.n	3400a410 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      status = ret;
3400a4a0:	2501      	movs	r5, #1
3400a4a2:	e7da      	b.n	3400a45a <HAL_RCCEx_PeriphCLKConfig+0x13e>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a4a4:	f7fa f9b2 	bl	3400480c <HAL_GetTick>
3400a4a8:	1b40      	subs	r0, r0, r5
3400a4aa:	42b0      	cmp	r0, r6
3400a4ac:	d9b8      	bls.n	3400a420 <HAL_RCCEx_PeriphCLKConfig+0x104>
        status = ret;
3400a4ae:	2503      	movs	r5, #3
3400a4b0:	e7d3      	b.n	3400a45a <HAL_RCCEx_PeriphCLKConfig+0x13e>
3400a4b2:	bf00      	nop
3400a4b4:	3401c6ca 	.word	0x3401c6ca
3400a4b8:	00010300 	.word	0x00010300
3400a4bc:	0003e300 	.word	0x0003e300
3400a4c0:	56028000 	.word	0x56028000
3400a4c4:	56024800 	.word	0x56024800
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400a4c8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400a4ca:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a4ce:	d003      	beq.n	3400a4d8 <HAL_RCCEx_PeriphCLKConfig+0x1bc>
3400a4d0:	21e4      	movs	r1, #228	@ 0xe4
3400a4d2:	48bd      	ldr	r0, [pc, #756]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a4d4:	f7f8 f82e 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400a4d8:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400a4da:	3b01      	subs	r3, #1
3400a4dc:	2bff      	cmp	r3, #255	@ 0xff
3400a4de:	d903      	bls.n	3400a4e8 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
3400a4e0:	21e5      	movs	r1, #229	@ 0xe5
3400a4e2:	48b9      	ldr	r0, [pc, #740]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a4e4:	f7f8 f826 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400a4e8:	4ab8      	ldr	r2, [pc, #736]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a4ea:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400a4ec:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400a4f0:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400a4f2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a4f6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a4fa:	3901      	subs	r1, #1
3400a4fc:	4303      	orrs	r3, r0
3400a4fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a502:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400a506:	2310      	movs	r3, #16
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400a508:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3400a50c:	4aaf      	ldr	r2, [pc, #700]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a50e:	f8d4 10b8 	ldr.w	r1, [r4, #184]	@ 0xb8
3400a512:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400a516:	f023 0307 	bic.w	r3, r3, #7
3400a51a:	430b      	orrs	r3, r1
3400a51c:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3400a520:	6863      	ldr	r3, [r4, #4]
3400a522:	0258      	lsls	r0, r3, #9
3400a524:	d539      	bpl.n	3400a59a <HAL_RCCEx_PeriphCLKConfig+0x27e>
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));
3400a526:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
3400a52a:	4aa9      	ldr	r2, [pc, #676]	@ (3400a7d0 <HAL_RCCEx_PeriphCLKConfig+0x4b4>)
3400a52c:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a530:	4293      	cmp	r3, r2
3400a532:	d004      	beq.n	3400a53e <HAL_RCCEx_PeriphCLKConfig+0x222>
3400a534:	f240 112f 	movw	r1, #303	@ 0x12f
3400a538:	48a3      	ldr	r0, [pc, #652]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a53a:	f7f7 fffb 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400a53e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
3400a542:	4aa4      	ldr	r2, [pc, #656]	@ (3400a7d4 <HAL_RCCEx_PeriphCLKConfig+0x4b8>)
3400a544:	4293      	cmp	r3, r2
3400a546:	f041 8713 	bne.w	3400c370 <HAL_RCCEx_PeriphCLKConfig+0x2054>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a54a:	69a3      	ldr	r3, [r4, #24]
3400a54c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a550:	d004      	beq.n	3400a55c <HAL_RCCEx_PeriphCLKConfig+0x240>
3400a552:	f44f 719a 	mov.w	r1, #308	@ 0x134
3400a556:	489c      	ldr	r0, [pc, #624]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a558:	f7f7 ffec 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a55c:	69e3      	ldr	r3, [r4, #28]
3400a55e:	3b01      	subs	r3, #1
3400a560:	2bff      	cmp	r3, #255	@ 0xff
3400a562:	d904      	bls.n	3400a56e <HAL_RCCEx_PeriphCLKConfig+0x252>
3400a564:	f240 1135 	movw	r1, #309	@ 0x135
3400a568:	4897      	ldr	r0, [pc, #604]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a56a:	f7f7 ffe3 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a56e:	4a97      	ldr	r2, [pc, #604]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a570:	69e1      	ldr	r1, [r4, #28]
3400a572:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a576:	69a0      	ldr	r0, [r4, #24]
3400a578:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a57c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a580:	3901      	subs	r1, #1
3400a582:	4303      	orrs	r3, r0
3400a584:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a588:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a58c:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a58e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a592:	f8d4 00ac 	ldr.w	r0, [r4, #172]	@ 0xac
3400a596:	f7ff fddd 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3400a59a:	6863      	ldr	r3, [r4, #4]
3400a59c:	0219      	lsls	r1, r3, #8
3400a59e:	d539      	bpl.n	3400a614 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));
3400a5a0:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400a5a4:	4a8c      	ldr	r2, [pc, #560]	@ (3400a7d8 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
3400a5a6:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a5aa:	4293      	cmp	r3, r2
3400a5ac:	d004      	beq.n	3400a5b8 <HAL_RCCEx_PeriphCLKConfig+0x29c>
3400a5ae:	f44f 71ae 	mov.w	r1, #348	@ 0x15c
3400a5b2:	4885      	ldr	r0, [pc, #532]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a5b4:	f7f7 ffbe 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3400a5b8:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400a5bc:	4a87      	ldr	r2, [pc, #540]	@ (3400a7dc <HAL_RCCEx_PeriphCLKConfig+0x4c0>)
3400a5be:	4293      	cmp	r3, r2
3400a5c0:	f041 8706 	bne.w	3400c3d0 <HAL_RCCEx_PeriphCLKConfig+0x20b4>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a5c4:	69a3      	ldr	r3, [r4, #24]
3400a5c6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a5ca:	d004      	beq.n	3400a5d6 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
3400a5cc:	f240 1161 	movw	r1, #353	@ 0x161
3400a5d0:	487d      	ldr	r0, [pc, #500]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a5d2:	f7f7 ffaf 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a5d6:	69e3      	ldr	r3, [r4, #28]
3400a5d8:	3b01      	subs	r3, #1
3400a5da:	2bff      	cmp	r3, #255	@ 0xff
3400a5dc:	d904      	bls.n	3400a5e8 <HAL_RCCEx_PeriphCLKConfig+0x2cc>
3400a5de:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3400a5e2:	4879      	ldr	r0, [pc, #484]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a5e4:	f7f7 ffa6 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a5e8:	4a78      	ldr	r2, [pc, #480]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a5ea:	69e1      	ldr	r1, [r4, #28]
3400a5ec:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a5f0:	69a0      	ldr	r0, [r4, #24]
3400a5f2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a5f6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a5fa:	3901      	subs	r1, #1
3400a5fc:	4303      	orrs	r3, r0
3400a5fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a602:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a606:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a608:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a60c:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
3400a610:	f7ff fda0 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3400a614:	6863      	ldr	r3, [r4, #4]
3400a616:	01da      	lsls	r2, r3, #7
3400a618:	d539      	bpl.n	3400a68e <HAL_RCCEx_PeriphCLKConfig+0x372>
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));
3400a61a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
3400a61e:	4a70      	ldr	r2, [pc, #448]	@ (3400a7e0 <HAL_RCCEx_PeriphCLKConfig+0x4c4>)
3400a620:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a624:	4293      	cmp	r3, r2
3400a626:	d004      	beq.n	3400a632 <HAL_RCCEx_PeriphCLKConfig+0x316>
3400a628:	f240 1189 	movw	r1, #393	@ 0x189
3400a62c:	4866      	ldr	r0, [pc, #408]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a62e:	f7f7 ff81 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3400a632:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
3400a636:	4a6b      	ldr	r2, [pc, #428]	@ (3400a7e4 <HAL_RCCEx_PeriphCLKConfig+0x4c8>)
3400a638:	4293      	cmp	r3, r2
3400a63a:	f041 86f9 	bne.w	3400c430 <HAL_RCCEx_PeriphCLKConfig+0x2114>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a63e:	69a3      	ldr	r3, [r4, #24]
3400a640:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a644:	d004      	beq.n	3400a650 <HAL_RCCEx_PeriphCLKConfig+0x334>
3400a646:	f44f 71c7 	mov.w	r1, #398	@ 0x18e
3400a64a:	485f      	ldr	r0, [pc, #380]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a64c:	f7f7 ff72 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a650:	69e3      	ldr	r3, [r4, #28]
3400a652:	3b01      	subs	r3, #1
3400a654:	2bff      	cmp	r3, #255	@ 0xff
3400a656:	d904      	bls.n	3400a662 <HAL_RCCEx_PeriphCLKConfig+0x346>
3400a658:	f240 118f 	movw	r1, #399	@ 0x18f
3400a65c:	485a      	ldr	r0, [pc, #360]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a65e:	f7f7 ff69 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a662:	4a5a      	ldr	r2, [pc, #360]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a664:	69e1      	ldr	r1, [r4, #28]
3400a666:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a66a:	69a0      	ldr	r0, [r4, #24]
3400a66c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a670:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a674:	3901      	subs	r1, #1
3400a676:	4303      	orrs	r3, r0
3400a678:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a67c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a680:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a682:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a686:	f8d4 00b4 	ldr.w	r0, [r4, #180]	@ 0xb4
3400a68a:	f7ff fd63 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3400a68e:	6823      	ldr	r3, [r4, #0]
3400a690:	051b      	lsls	r3, r3, #20
3400a692:	d53c      	bpl.n	3400a70e <HAL_RCCEx_PeriphCLKConfig+0x3f2>
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));
3400a694:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400a698:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400a69c:	d004      	beq.n	3400a6a8 <HAL_RCCEx_PeriphCLKConfig+0x38c>
3400a69e:	f44f 71db 	mov.w	r1, #438	@ 0x1b6
3400a6a2:	4849      	ldr	r0, [pc, #292]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a6a4:	f7f7 ff46 	bl	34002534 <assert_failed>
    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3400a6a8:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400a6ac:	2b20      	cmp	r3, #32
3400a6ae:	f041 86ff 	bne.w	3400c4b0 <HAL_RCCEx_PeriphCLKConfig+0x2194>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a6b2:	69a3      	ldr	r3, [r4, #24]
3400a6b4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a6b8:	d004      	beq.n	3400a6c4 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
3400a6ba:	f240 11bb 	movw	r1, #443	@ 0x1bb
3400a6be:	4842      	ldr	r0, [pc, #264]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a6c0:	f7f7 ff38 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a6c4:	69e3      	ldr	r3, [r4, #28]
3400a6c6:	3b01      	subs	r3, #1
3400a6c8:	2bff      	cmp	r3, #255	@ 0xff
3400a6ca:	d904      	bls.n	3400a6d6 <HAL_RCCEx_PeriphCLKConfig+0x3ba>
3400a6cc:	f44f 71de 	mov.w	r1, #444	@ 0x1bc
3400a6d0:	483d      	ldr	r0, [pc, #244]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a6d2:	f7f7 ff2f 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a6d6:	4a3d      	ldr	r2, [pc, #244]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a6d8:	69e1      	ldr	r1, [r4, #28]
3400a6da:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a6de:	69a0      	ldr	r0, [r4, #24]
3400a6e0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a6e4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a6e8:	3901      	subs	r1, #1
3400a6ea:	4303      	orrs	r3, r0
3400a6ec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a6f0:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a6f4:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a6f6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3400a6fa:	4a34      	ldr	r2, [pc, #208]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a6fc:	f8d4 10a8 	ldr.w	r1, [r4, #168]	@ 0xa8
3400a700:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3400a704:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400a708:	430b      	orrs	r3, r1
3400a70a:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3400a70e:	6823      	ldr	r3, [r4, #0]
3400a710:	005e      	lsls	r6, r3, #1
3400a712:	d539      	bpl.n	3400a788 <HAL_RCCEx_PeriphCLKConfig+0x46c>
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
3400a714:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
3400a718:	4a33      	ldr	r2, [pc, #204]	@ (3400a7e8 <HAL_RCCEx_PeriphCLKConfig+0x4cc>)
3400a71a:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a71e:	4293      	cmp	r3, r2
3400a720:	d004      	beq.n	3400a72c <HAL_RCCEx_PeriphCLKConfig+0x410>
3400a722:	f240 11e3 	movw	r1, #483	@ 0x1e3
3400a726:	4828      	ldr	r0, [pc, #160]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a728:	f7f7 ff04 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3400a72c:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
3400a730:	4a2e      	ldr	r2, [pc, #184]	@ (3400a7ec <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
3400a732:	4293      	cmp	r3, r2
3400a734:	f041 86ea 	bne.w	3400c50c <HAL_RCCEx_PeriphCLKConfig+0x21f0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400a738:	6a23      	ldr	r3, [r4, #32]
3400a73a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a73e:	d004      	beq.n	3400a74a <HAL_RCCEx_PeriphCLKConfig+0x42e>
3400a740:	f44f 71f4 	mov.w	r1, #488	@ 0x1e8
3400a744:	4820      	ldr	r0, [pc, #128]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a746:	f7f7 fef5 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400a74a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400a74c:	3b01      	subs	r3, #1
3400a74e:	2bff      	cmp	r3, #255	@ 0xff
3400a750:	d904      	bls.n	3400a75c <HAL_RCCEx_PeriphCLKConfig+0x440>
3400a752:	f240 11e9 	movw	r1, #489	@ 0x1e9
3400a756:	481c      	ldr	r0, [pc, #112]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a758:	f7f7 feec 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400a75c:	4a1b      	ldr	r2, [pc, #108]	@ (3400a7cc <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a75e:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400a760:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400a764:	6a20      	ldr	r0, [r4, #32]
3400a766:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a76a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a76e:	3901      	subs	r1, #1
3400a770:	4303      	orrs	r3, r0
3400a772:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a776:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a77a:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400a77c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a780:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
3400a784:	f7ff fce6 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3400a788:	6823      	ldr	r3, [r4, #0]
3400a78a:	2b00      	cmp	r3, #0
3400a78c:	da53      	bge.n	3400a836 <HAL_RCCEx_PeriphCLKConfig+0x51a>
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));
3400a78e:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
3400a792:	4a17      	ldr	r2, [pc, #92]	@ (3400a7f0 <HAL_RCCEx_PeriphCLKConfig+0x4d4>)
3400a794:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a798:	4293      	cmp	r3, r2
3400a79a:	d004      	beq.n	3400a7a6 <HAL_RCCEx_PeriphCLKConfig+0x48a>
3400a79c:	f44f 7104 	mov.w	r1, #528	@ 0x210
3400a7a0:	4809      	ldr	r0, [pc, #36]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a7a2:	f7f7 fec7 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3400a7a6:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
3400a7aa:	4a12      	ldr	r2, [pc, #72]	@ (3400a7f4 <HAL_RCCEx_PeriphCLKConfig+0x4d8>)
3400a7ac:	4293      	cmp	r3, r2
3400a7ae:	f041 86dd 	bne.w	3400c56c <HAL_RCCEx_PeriphCLKConfig+0x2250>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400a7b2:	6a23      	ldr	r3, [r4, #32]
3400a7b4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a7b8:	d01e      	beq.n	3400a7f8 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
3400a7ba:	f240 2115 	movw	r1, #533	@ 0x215
3400a7be:	4802      	ldr	r0, [pc, #8]	@ (3400a7c8 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a7c0:	f7f7 feb8 	bl	34002534 <assert_failed>
3400a7c4:	e018      	b.n	3400a7f8 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
3400a7c6:	bf00      	nop
3400a7c8:	3401c6ca 	.word	0x3401c6ca
3400a7cc:	56028000 	.word	0x56028000
3400a7d0:	03000014 	.word	0x03000014
3400a7d4:	03020014 	.word	0x03020014
3400a7d8:	03000414 	.word	0x03000414
3400a7dc:	03020414 	.word	0x03020414
3400a7e0:	03000814 	.word	0x03000814
3400a7e4:	03020814 	.word	0x03020814
3400a7e8:	0300001c 	.word	0x0300001c
3400a7ec:	0302001c 	.word	0x0302001c
3400a7f0:	0300041c 	.word	0x0300041c
3400a7f4:	0302041c 	.word	0x0302041c
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400a7f8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400a7fa:	3b01      	subs	r3, #1
3400a7fc:	2bff      	cmp	r3, #255	@ 0xff
3400a7fe:	d904      	bls.n	3400a80a <HAL_RCCEx_PeriphCLKConfig+0x4ee>
3400a800:	f240 2116 	movw	r1, #534	@ 0x216
3400a804:	48c4      	ldr	r0, [pc, #784]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a806:	f7f7 fe95 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400a80a:	4ac4      	ldr	r2, [pc, #784]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a80c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400a80e:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400a812:	6a20      	ldr	r0, [r4, #32]
3400a814:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a818:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a81c:	3901      	subs	r1, #1
3400a81e:	4303      	orrs	r3, r0
3400a820:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a824:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a828:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400a82a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a82e:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
3400a832:	f7ff fc8f 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
3400a836:	6823      	ldr	r3, [r4, #0]
3400a838:	07d8      	lsls	r0, r3, #31
3400a83a:	d54f      	bpl.n	3400a8dc <HAL_RCCEx_PeriphCLKConfig+0x5c0>
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
3400a83c:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
3400a840:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400a844:	d006      	beq.n	3400a854 <HAL_RCCEx_PeriphCLKConfig+0x538>
3400a846:	2b40      	cmp	r3, #64	@ 0x40
3400a848:	d004      	beq.n	3400a854 <HAL_RCCEx_PeriphCLKConfig+0x538>
3400a84a:	f240 213d 	movw	r1, #573	@ 0x23d
3400a84e:	48b2      	ldr	r0, [pc, #712]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a850:	f7f7 fe70 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));
3400a854:	f8d4 30c0 	ldr.w	r3, [r4, #192]	@ 0xc0
3400a858:	3b01      	subs	r3, #1
3400a85a:	2bff      	cmp	r3, #255	@ 0xff
3400a85c:	d904      	bls.n	3400a868 <HAL_RCCEx_PeriphCLKConfig+0x54c>
3400a85e:	f240 213e 	movw	r1, #574	@ 0x23e
3400a862:	48ad      	ldr	r0, [pc, #692]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a864:	f7f7 fe66 	bl	34002534 <assert_failed>
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3400a868:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
3400a86c:	2b20      	cmp	r3, #32
3400a86e:	f041 86ad 	bne.w	3400c5cc <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400a872:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400a874:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a878:	d004      	beq.n	3400a884 <HAL_RCCEx_PeriphCLKConfig+0x568>
3400a87a:	f240 2143 	movw	r1, #579	@ 0x243
3400a87e:	48a6      	ldr	r0, [pc, #664]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a880:	f7f7 fe58 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400a884:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a886:	3b01      	subs	r3, #1
3400a888:	2bff      	cmp	r3, #255	@ 0xff
3400a88a:	d904      	bls.n	3400a896 <HAL_RCCEx_PeriphCLKConfig+0x57a>
3400a88c:	f44f 7111 	mov.w	r1, #580	@ 0x244
3400a890:	48a1      	ldr	r0, [pc, #644]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a892:	f7f7 fe4f 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400a896:	4aa1      	ldr	r2, [pc, #644]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a898:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400a89a:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400a89e:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400a8a0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a8a4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a8a8:	3901      	subs	r1, #1
3400a8aa:	4303      	orrs	r3, r0
3400a8ac:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a8b0:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400a8b4:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400a8b6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3400a8ba:	4998      	ldr	r1, [pc, #608]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a8bc:	f8d4 20c0 	ldr.w	r2, [r4, #192]	@ 0xc0
3400a8c0:	f8d1 3144 	ldr.w	r3, [r1, #324]	@ 0x144
3400a8c4:	f8d4 00bc 	ldr.w	r0, [r4, #188]	@ 0xbc
3400a8c8:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
3400a8cc:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
3400a8d0:	3a01      	subs	r2, #1
3400a8d2:	4303      	orrs	r3, r0
3400a8d4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
3400a8d8:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3400a8dc:	6823      	ldr	r3, [r4, #0]
3400a8de:	0799      	lsls	r1, r3, #30
3400a8e0:	d53b      	bpl.n	3400a95a <HAL_RCCEx_PeriphCLKConfig+0x63e>
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));
3400a8e2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
3400a8e6:	2b07      	cmp	r3, #7
3400a8e8:	d904      	bls.n	3400a8f4 <HAL_RCCEx_PeriphCLKConfig+0x5d8>
3400a8ea:	f44f 711b 	mov.w	r1, #620	@ 0x26c
3400a8ee:	488a      	ldr	r0, [pc, #552]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a8f0:	f7f7 fe20 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3400a8f4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
3400a8f8:	2b02      	cmp	r3, #2
3400a8fa:	f041 8695 	bne.w	3400c628 <HAL_RCCEx_PeriphCLKConfig+0x230c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400a8fe:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400a900:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a904:	d004      	beq.n	3400a910 <HAL_RCCEx_PeriphCLKConfig+0x5f4>
3400a906:	f240 2171 	movw	r1, #625	@ 0x271
3400a90a:	4883      	ldr	r0, [pc, #524]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a90c:	f7f7 fe12 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400a910:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a912:	3b01      	subs	r3, #1
3400a914:	2bff      	cmp	r3, #255	@ 0xff
3400a916:	d904      	bls.n	3400a922 <HAL_RCCEx_PeriphCLKConfig+0x606>
3400a918:	f240 2172 	movw	r1, #626	@ 0x272
3400a91c:	487e      	ldr	r0, [pc, #504]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a91e:	f7f7 fe09 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400a922:	4a7e      	ldr	r2, [pc, #504]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a924:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400a926:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400a92a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400a92c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a930:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a934:	3901      	subs	r1, #1
3400a936:	4303      	orrs	r3, r0
3400a938:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a93c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400a940:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400a942:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3400a946:	4a75      	ldr	r2, [pc, #468]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a948:	f8d4 10c4 	ldr.w	r1, [r4, #196]	@ 0xc4
3400a94c:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3400a950:	f023 0307 	bic.w	r3, r3, #7
3400a954:	430b      	orrs	r3, r1
3400a956:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3400a95a:	6823      	ldr	r3, [r4, #0]
3400a95c:	071a      	lsls	r2, r3, #28
3400a95e:	d528      	bpl.n	3400a9b2 <HAL_RCCEx_PeriphCLKConfig+0x696>
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
3400a960:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3400a964:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a968:	d004      	beq.n	3400a974 <HAL_RCCEx_PeriphCLKConfig+0x658>
3400a96a:	f240 2199 	movw	r1, #665	@ 0x299
3400a96e:	486a      	ldr	r0, [pc, #424]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a970:	f7f7 fde0 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));
3400a974:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
3400a978:	3b01      	subs	r3, #1
3400a97a:	2bff      	cmp	r3, #255	@ 0xff
3400a97c:	d904      	bls.n	3400a988 <HAL_RCCEx_PeriphCLKConfig+0x66c>
3400a97e:	f240 219a 	movw	r1, #666	@ 0x29a
3400a982:	4865      	ldr	r0, [pc, #404]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a984:	f7f7 fdd6 	bl	34002534 <assert_failed>
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3400a988:	4a64      	ldr	r2, [pc, #400]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a98a:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
3400a98e:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
3400a992:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
3400a996:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a99a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a99e:	3901      	subs	r1, #1
3400a9a0:	4303      	orrs	r3, r0
3400a9a2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a9a6:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3400a9aa:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3400a9ae:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3400a9b2:	6823      	ldr	r3, [r4, #0]
3400a9b4:	06db      	lsls	r3, r3, #27
3400a9b6:	d542      	bpl.n	3400aa3e <HAL_RCCEx_PeriphCLKConfig+0x722>
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));
3400a9b8:	f8d4 30c8 	ldr.w	r3, [r4, #200]	@ 0xc8
3400a9bc:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400a9c0:	d004      	beq.n	3400a9cc <HAL_RCCEx_PeriphCLKConfig+0x6b0>
3400a9c2:	f44f 712a 	mov.w	r1, #680	@ 0x2a8
3400a9c6:	4854      	ldr	r0, [pc, #336]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a9c8:	f7f7 fdb4 	bl	34002534 <assert_failed>
    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3400a9cc:	f8d4 30c8 	ldr.w	r3, [r4, #200]	@ 0xc8
3400a9d0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400a9d4:	f041 8656 	bne.w	3400c684 <HAL_RCCEx_PeriphCLKConfig+0x2368>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
3400a9d8:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400a9dc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a9e0:	d004      	beq.n	3400a9ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>
3400a9e2:	f240 21ad 	movw	r1, #685	@ 0x2ad
3400a9e6:	484c      	ldr	r0, [pc, #304]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a9e8:	f7f7 fda4 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));
3400a9ec:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
3400a9f0:	3b01      	subs	r3, #1
3400a9f2:	2bff      	cmp	r3, #255	@ 0xff
3400a9f4:	d904      	bls.n	3400aa00 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
3400a9f6:	f240 21ae 	movw	r1, #686	@ 0x2ae
3400a9fa:	4847      	ldr	r0, [pc, #284]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a9fc:	f7f7 fd9a 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3400aa00:	4a46      	ldr	r2, [pc, #280]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aa02:	f8d4 108c 	ldr.w	r1, [r4, #140]	@ 0x8c
3400aa06:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
3400aa0a:	f8d4 0088 	ldr.w	r0, [r4, #136]	@ 0x88
3400aa0e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aa12:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aa16:	3901      	subs	r1, #1
3400aa18:	4303      	orrs	r3, r0
3400aa1a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aa1e:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3400aa22:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3400aa26:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3400aa2a:	4a3c      	ldr	r2, [pc, #240]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aa2c:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
3400aa30:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3400aa34:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
3400aa38:	430b      	orrs	r3, r1
3400aa3a:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3400aa3e:	6823      	ldr	r3, [r4, #0]
3400aa40:	069e      	lsls	r6, r3, #26
3400aa42:	d53e      	bpl.n	3400aac2 <HAL_RCCEx_PeriphCLKConfig+0x7a6>
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));
3400aa44:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
3400aa48:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400aa4c:	d004      	beq.n	3400aa58 <HAL_RCCEx_PeriphCLKConfig+0x73c>
3400aa4e:	f44f 7132 	mov.w	r1, #712	@ 0x2c8
3400aa52:	4831      	ldr	r0, [pc, #196]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aa54:	f7f7 fd6e 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3400aa58:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
3400aa5c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400aa60:	f041 8619 	bne.w	3400c696 <HAL_RCCEx_PeriphCLKConfig+0x237a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
3400aa64:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400aa66:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400aa6a:	d004      	beq.n	3400aa76 <HAL_RCCEx_PeriphCLKConfig+0x75a>
3400aa6c:	f240 21cd 	movw	r1, #717	@ 0x2cd
3400aa70:	4829      	ldr	r0, [pc, #164]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aa72:	f7f7 fd5f 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));
3400aa76:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3400aa78:	3b01      	subs	r3, #1
3400aa7a:	2bff      	cmp	r3, #255	@ 0xff
3400aa7c:	d904      	bls.n	3400aa88 <HAL_RCCEx_PeriphCLKConfig+0x76c>
3400aa7e:	f240 21ce 	movw	r1, #718	@ 0x2ce
3400aa82:	4825      	ldr	r0, [pc, #148]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aa84:	f7f7 fd56 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3400aa88:	4a24      	ldr	r2, [pc, #144]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aa8a:	6e61      	ldr	r1, [r4, #100]	@ 0x64
3400aa8c:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
3400aa90:	6e20      	ldr	r0, [r4, #96]	@ 0x60
3400aa92:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aa96:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aa9a:	3901      	subs	r1, #1
3400aa9c:	4303      	orrs	r3, r0
3400aa9e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aaa2:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3400aaa6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400aaaa:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3400aaae:	4a1b      	ldr	r2, [pc, #108]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aab0:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
3400aab4:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400aab8:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3400aabc:	430b      	orrs	r3, r1
3400aabe:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
3400aac2:	6823      	ldr	r3, [r4, #0]
3400aac4:	0658      	lsls	r0, r3, #25
3400aac6:	d516      	bpl.n	3400aaf6 <HAL_RCCEx_PeriphCLKConfig+0x7da>
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));
3400aac8:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
3400aacc:	f433 3280 	bics.w	r2, r3, #65536	@ 0x10000
3400aad0:	d007      	beq.n	3400aae2 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
3400aad2:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400aad6:	d004      	beq.n	3400aae2 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
3400aad8:	f44f 713a 	mov.w	r1, #744	@ 0x2e8
3400aadc:	480e      	ldr	r0, [pc, #56]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aade:	f7f7 fd29 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3400aae2:	4a0e      	ldr	r2, [pc, #56]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aae4:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
3400aae8:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400aaec:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400aaf0:	430b      	orrs	r3, r1
3400aaf2:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
3400aaf6:	6823      	ldr	r3, [r4, #0]
3400aaf8:	0619      	lsls	r1, r3, #24
3400aafa:	d518      	bpl.n	3400ab2e <HAL_RCCEx_PeriphCLKConfig+0x812>
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));
3400aafc:	f8d4 30d4 	ldr.w	r3, [r4, #212]	@ 0xd4
3400ab00:	f433 1380 	bics.w	r3, r3, #1048576	@ 0x100000
3400ab04:	d004      	beq.n	3400ab10 <HAL_RCCEx_PeriphCLKConfig+0x7f4>
3400ab06:	f240 21f2 	movw	r1, #754	@ 0x2f2
3400ab0a:	4803      	ldr	r0, [pc, #12]	@ (3400ab18 <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400ab0c:	f7f7 fd12 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400ab10:	4a02      	ldr	r2, [pc, #8]	@ (3400ab1c <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400ab12:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
3400ab16:	e003      	b.n	3400ab20 <HAL_RCCEx_PeriphCLKConfig+0x804>
3400ab18:	3401c6ca 	.word	0x3401c6ca
3400ab1c:	56028000 	.word	0x56028000
3400ab20:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ab24:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400ab28:	430b      	orrs	r3, r1
3400ab2a:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
3400ab2e:	6823      	ldr	r3, [r4, #0]
3400ab30:	05da      	lsls	r2, r3, #23
3400ab32:	d513      	bpl.n	3400ab5c <HAL_RCCEx_PeriphCLKConfig+0x840>
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));
3400ab34:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
3400ab38:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
3400ab3c:	d004      	beq.n	3400ab48 <HAL_RCCEx_PeriphCLKConfig+0x82c>
3400ab3e:	f44f 713f 	mov.w	r1, #764	@ 0x2fc
3400ab42:	48c1      	ldr	r0, [pc, #772]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ab44:	f7f7 fcf6 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3400ab48:	4ac0      	ldr	r2, [pc, #768]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ab4a:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
3400ab4e:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ab52:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3400ab56:	430b      	orrs	r3, r1
3400ab58:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
3400ab5c:	6823      	ldr	r3, [r4, #0]
3400ab5e:	059b      	lsls	r3, r3, #22
3400ab60:	d54b      	bpl.n	3400abfa <HAL_RCCEx_PeriphCLKConfig+0x8de>
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
3400ab62:	f8d4 30dc 	ldr.w	r3, [r4, #220]	@ 0xdc
3400ab66:	2b03      	cmp	r3, #3
3400ab68:	d904      	bls.n	3400ab74 <HAL_RCCEx_PeriphCLKConfig+0x858>
3400ab6a:	f240 3106 	movw	r1, #774	@ 0x306
3400ab6e:	48b6      	ldr	r0, [pc, #728]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ab70:	f7f7 fce0 	bl	34002534 <assert_failed>
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));
3400ab74:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
3400ab78:	3b01      	subs	r3, #1
3400ab7a:	2b0f      	cmp	r3, #15
3400ab7c:	d904      	bls.n	3400ab88 <HAL_RCCEx_PeriphCLKConfig+0x86c>
3400ab7e:	f240 3107 	movw	r1, #775	@ 0x307
3400ab82:	48b1      	ldr	r0, [pc, #708]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ab84:	f7f7 fcd6 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3400ab88:	f8d4 30dc 	ldr.w	r3, [r4, #220]	@ 0xdc
3400ab8c:	2b02      	cmp	r3, #2
3400ab8e:	f041 858b 	bne.w	3400c6a8 <HAL_RCCEx_PeriphCLKConfig+0x238c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
3400ab92:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
3400ab94:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ab98:	d004      	beq.n	3400aba4 <HAL_RCCEx_PeriphCLKConfig+0x888>
3400ab9a:	f44f 7143 	mov.w	r1, #780	@ 0x30c
3400ab9e:	48aa      	ldr	r0, [pc, #680]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400aba0:	f7f7 fcc8 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));
3400aba4:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
3400aba6:	3b01      	subs	r3, #1
3400aba8:	2bff      	cmp	r3, #255	@ 0xff
3400abaa:	d904      	bls.n	3400abb6 <HAL_RCCEx_PeriphCLKConfig+0x89a>
3400abac:	f240 310d 	movw	r1, #781	@ 0x30d
3400abb0:	48a5      	ldr	r0, [pc, #660]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400abb2:	f7f7 fcbf 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3400abb6:	4aa5      	ldr	r2, [pc, #660]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400abb8:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
3400abba:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
3400abbe:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
3400abc0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400abc4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400abc8:	3901      	subs	r1, #1
3400abca:	4303      	orrs	r3, r0
3400abcc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400abd0:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3400abd4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3400abd8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
3400abdc:	499b      	ldr	r1, [pc, #620]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400abde:	f8d4 20e0 	ldr.w	r2, [r4, #224]	@ 0xe0
3400abe2:	f8d1 3148 	ldr.w	r3, [r1, #328]	@ 0x148
3400abe6:	f8d4 00dc 	ldr.w	r0, [r4, #220]	@ 0xdc
3400abea:	f023 03f3 	bic.w	r3, r3, #243	@ 0xf3
3400abee:	3a01      	subs	r2, #1
3400abf0:	4303      	orrs	r3, r0
3400abf2:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
3400abf6:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
3400abfa:	6823      	ldr	r3, [r4, #0]
3400abfc:	055e      	lsls	r6, r3, #21
3400abfe:	d540      	bpl.n	3400ac82 <HAL_RCCEx_PeriphCLKConfig+0x966>
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));
3400ac00:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
3400ac04:	2b03      	cmp	r3, #3
3400ac06:	d904      	bls.n	3400ac12 <HAL_RCCEx_PeriphCLKConfig+0x8f6>
3400ac08:	f44f 714a 	mov.w	r1, #808	@ 0x328
3400ac0c:	488e      	ldr	r0, [pc, #568]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac0e:	f7f7 fc91 	bl	34002534 <assert_failed>
    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3400ac12:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
3400ac16:	2b02      	cmp	r3, #2
3400ac18:	f041 854e 	bne.w	3400c6b8 <HAL_RCCEx_PeriphCLKConfig+0x239c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400ac1c:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400ac20:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ac24:	d004      	beq.n	3400ac30 <HAL_RCCEx_PeriphCLKConfig+0x914>
3400ac26:	f240 312d 	movw	r1, #813	@ 0x32d
3400ac2a:	4887      	ldr	r0, [pc, #540]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac2c:	f7f7 fc82 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400ac30:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
3400ac34:	3b01      	subs	r3, #1
3400ac36:	2bff      	cmp	r3, #255	@ 0xff
3400ac38:	d904      	bls.n	3400ac44 <HAL_RCCEx_PeriphCLKConfig+0x928>
3400ac3a:	f240 312e 	movw	r1, #814	@ 0x32e
3400ac3e:	4882      	ldr	r0, [pc, #520]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac40:	f7f7 fc78 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400ac44:	4a81      	ldr	r2, [pc, #516]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ac46:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
3400ac4a:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3400ac4e:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
3400ac52:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ac56:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ac5a:	3901      	subs	r1, #1
3400ac5c:	4303      	orrs	r3, r0
3400ac5e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ac62:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400ac66:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3400ac6a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3400ac6e:	4a77      	ldr	r2, [pc, #476]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ac70:	f8d4 10e4 	ldr.w	r1, [r4, #228]	@ 0xe4
3400ac74:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3400ac78:	f023 0303 	bic.w	r3, r3, #3
3400ac7c:	430b      	orrs	r3, r1
3400ac7e:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3400ac82:	6823      	ldr	r3, [r4, #0]
3400ac84:	04d8      	lsls	r0, r3, #19
3400ac86:	d540      	bpl.n	3400ad0a <HAL_RCCEx_PeriphCLKConfig+0x9ee>
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
3400ac88:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
3400ac8c:	4a70      	ldr	r2, [pc, #448]	@ (3400ae50 <HAL_RCCEx_PeriphCLKConfig+0xb34>)
3400ac8e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ac92:	4291      	cmp	r1, r2
3400ac94:	d00a      	beq.n	3400acac <HAL_RCCEx_PeriphCLKConfig+0x990>
3400ac96:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400ac9a:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ac9e:	4293      	cmp	r3, r2
3400aca0:	d004      	beq.n	3400acac <HAL_RCCEx_PeriphCLKConfig+0x990>
3400aca2:	f44f 7152 	mov.w	r1, #840	@ 0x348
3400aca6:	4868      	ldr	r0, [pc, #416]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400aca8:	f7f7 fc44 	bl	34002534 <assert_failed>
    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3400acac:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
3400acb0:	4a68      	ldr	r2, [pc, #416]	@ (3400ae54 <HAL_RCCEx_PeriphCLKConfig+0xb38>)
3400acb2:	4293      	cmp	r3, r2
3400acb4:	f041 8508 	bne.w	3400c6c8 <HAL_RCCEx_PeriphCLKConfig+0x23ac>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400acb8:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400acba:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400acbe:	d004      	beq.n	3400acca <HAL_RCCEx_PeriphCLKConfig+0x9ae>
3400acc0:	f240 314d 	movw	r1, #845	@ 0x34d
3400acc4:	4860      	ldr	r0, [pc, #384]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400acc6:	f7f7 fc35 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400acca:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400accc:	3b01      	subs	r3, #1
3400acce:	2bff      	cmp	r3, #255	@ 0xff
3400acd0:	d904      	bls.n	3400acdc <HAL_RCCEx_PeriphCLKConfig+0x9c0>
3400acd2:	f240 314e 	movw	r1, #846	@ 0x34e
3400acd6:	485c      	ldr	r0, [pc, #368]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400acd8:	f7f7 fc2c 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400acdc:	4a5b      	ldr	r2, [pc, #364]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400acde:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400ace0:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400ace4:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400ace6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400acea:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400acee:	3901      	subs	r1, #1
3400acf0:	4303      	orrs	r3, r0
3400acf2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400acf6:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400acfa:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400acfe:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ad02:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
3400ad06:	f7ff fa25 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3400ad0a:	6823      	ldr	r3, [r4, #0]
3400ad0c:	0499      	lsls	r1, r3, #18
3400ad0e:	d540      	bpl.n	3400ad92 <HAL_RCCEx_PeriphCLKConfig+0xa76>
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
3400ad10:	f8d4 30ec 	ldr.w	r3, [r4, #236]	@ 0xec
3400ad14:	4a50      	ldr	r2, [pc, #320]	@ (3400ae58 <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
3400ad16:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ad1a:	4291      	cmp	r1, r2
3400ad1c:	d00a      	beq.n	3400ad34 <HAL_RCCEx_PeriphCLKConfig+0xa18>
3400ad1e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400ad22:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ad26:	4293      	cmp	r3, r2
3400ad28:	d004      	beq.n	3400ad34 <HAL_RCCEx_PeriphCLKConfig+0xa18>
3400ad2a:	f240 3175 	movw	r1, #885	@ 0x375
3400ad2e:	4846      	ldr	r0, [pc, #280]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ad30:	f7f7 fc00 	bl	34002534 <assert_failed>
    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3400ad34:	f8d4 30ec 	ldr.w	r3, [r4, #236]	@ 0xec
3400ad38:	4a48      	ldr	r2, [pc, #288]	@ (3400ae5c <HAL_RCCEx_PeriphCLKConfig+0xb40>)
3400ad3a:	4293      	cmp	r3, r2
3400ad3c:	f041 84f5 	bne.w	3400c72a <HAL_RCCEx_PeriphCLKConfig+0x240e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400ad40:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400ad42:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ad46:	d004      	beq.n	3400ad52 <HAL_RCCEx_PeriphCLKConfig+0xa36>
3400ad48:	f240 317a 	movw	r1, #890	@ 0x37a
3400ad4c:	483e      	ldr	r0, [pc, #248]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ad4e:	f7f7 fbf1 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400ad52:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400ad54:	3b01      	subs	r3, #1
3400ad56:	2bff      	cmp	r3, #255	@ 0xff
3400ad58:	d904      	bls.n	3400ad64 <HAL_RCCEx_PeriphCLKConfig+0xa48>
3400ad5a:	f240 317b 	movw	r1, #891	@ 0x37b
3400ad5e:	483a      	ldr	r0, [pc, #232]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ad60:	f7f7 fbe8 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400ad64:	4a39      	ldr	r2, [pc, #228]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ad66:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400ad68:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400ad6c:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400ad6e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ad72:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ad76:	3901      	subs	r1, #1
3400ad78:	4303      	orrs	r3, r0
3400ad7a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ad7e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400ad82:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ad86:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ad8a:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
3400ad8e:	f7ff f9e1 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3400ad92:	6823      	ldr	r3, [r4, #0]
3400ad94:	045a      	lsls	r2, r3, #17
3400ad96:	d540      	bpl.n	3400ae1a <HAL_RCCEx_PeriphCLKConfig+0xafe>
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
3400ad98:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400ad9c:	4a30      	ldr	r2, [pc, #192]	@ (3400ae60 <HAL_RCCEx_PeriphCLKConfig+0xb44>)
3400ad9e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ada2:	4291      	cmp	r1, r2
3400ada4:	d00a      	beq.n	3400adbc <HAL_RCCEx_PeriphCLKConfig+0xaa0>
3400ada6:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400adaa:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400adae:	4293      	cmp	r3, r2
3400adb0:	d004      	beq.n	3400adbc <HAL_RCCEx_PeriphCLKConfig+0xaa0>
3400adb2:	f240 31a2 	movw	r1, #930	@ 0x3a2
3400adb6:	4824      	ldr	r0, [pc, #144]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400adb8:	f7f7 fbbc 	bl	34002534 <assert_failed>
    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3400adbc:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400adc0:	4a28      	ldr	r2, [pc, #160]	@ (3400ae64 <HAL_RCCEx_PeriphCLKConfig+0xb48>)
3400adc2:	4293      	cmp	r3, r2
3400adc4:	f041 84f6 	bne.w	3400c7b4 <HAL_RCCEx_PeriphCLKConfig+0x2498>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400adc8:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400adca:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400adce:	d004      	beq.n	3400adda <HAL_RCCEx_PeriphCLKConfig+0xabe>
3400add0:	f240 31a7 	movw	r1, #935	@ 0x3a7
3400add4:	481c      	ldr	r0, [pc, #112]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400add6:	f7f7 fbad 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400adda:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400addc:	3b01      	subs	r3, #1
3400adde:	2bff      	cmp	r3, #255	@ 0xff
3400ade0:	d904      	bls.n	3400adec <HAL_RCCEx_PeriphCLKConfig+0xad0>
3400ade2:	f44f 716a 	mov.w	r1, #936	@ 0x3a8
3400ade6:	4818      	ldr	r0, [pc, #96]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ade8:	f7f7 fba4 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400adec:	4a17      	ldr	r2, [pc, #92]	@ (3400ae4c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400adee:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400adf0:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400adf4:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400adf6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400adfa:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400adfe:	3901      	subs	r1, #1
3400ae00:	4303      	orrs	r3, r0
3400ae02:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ae06:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400ae0a:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ae0e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ae12:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
3400ae16:	f7ff f99d 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
3400ae1a:	6823      	ldr	r3, [r4, #0]
3400ae1c:	041b      	lsls	r3, r3, #16
3400ae1e:	d554      	bpl.n	3400aeca <HAL_RCCEx_PeriphCLKConfig+0xbae>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
3400ae20:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400ae24:	4a10      	ldr	r2, [pc, #64]	@ (3400ae68 <HAL_RCCEx_PeriphCLKConfig+0xb4c>)
3400ae26:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ae2a:	4291      	cmp	r1, r2
3400ae2c:	d01e      	beq.n	3400ae6c <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400ae2e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400ae32:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ae36:	4293      	cmp	r3, r2
3400ae38:	d018      	beq.n	3400ae6c <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400ae3a:	f240 31cf 	movw	r1, #975	@ 0x3cf
3400ae3e:	4802      	ldr	r0, [pc, #8]	@ (3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ae40:	f7f7 fb78 	bl	34002534 <assert_failed>
3400ae44:	e012      	b.n	3400ae6c <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400ae46:	bf00      	nop
3400ae48:	3401c6ca 	.word	0x3401c6ca
3400ae4c:	56028000 	.word	0x56028000
3400ae50:	0700000c 	.word	0x0700000c
3400ae54:	0702000c 	.word	0x0702000c
3400ae58:	0700040c 	.word	0x0700040c
3400ae5c:	0702040c 	.word	0x0702040c
3400ae60:	0700080c 	.word	0x0700080c
3400ae64:	0702080c 	.word	0x0702080c
3400ae68:	07000c0c 	.word	0x07000c0c
    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3400ae6c:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400ae70:	4abd      	ldr	r2, [pc, #756]	@ (3400b168 <HAL_RCCEx_PeriphCLKConfig+0xe4c>)
3400ae72:	4293      	cmp	r3, r2
3400ae74:	f041 84cf 	bne.w	3400c816 <HAL_RCCEx_PeriphCLKConfig+0x24fa>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400ae78:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400ae7a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ae7e:	d004      	beq.n	3400ae8a <HAL_RCCEx_PeriphCLKConfig+0xb6e>
3400ae80:	f44f 7175 	mov.w	r1, #980	@ 0x3d4
3400ae84:	48b9      	ldr	r0, [pc, #740]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400ae86:	f7f7 fb55 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400ae8a:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400ae8c:	3b01      	subs	r3, #1
3400ae8e:	2bff      	cmp	r3, #255	@ 0xff
3400ae90:	d904      	bls.n	3400ae9c <HAL_RCCEx_PeriphCLKConfig+0xb80>
3400ae92:	f240 31d5 	movw	r1, #981	@ 0x3d5
3400ae96:	48b5      	ldr	r0, [pc, #724]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400ae98:	f7f7 fb4c 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400ae9c:	4ab4      	ldr	r2, [pc, #720]	@ (3400b170 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400ae9e:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400aea0:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400aea4:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400aea6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aeaa:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aeae:	3901      	subs	r1, #1
3400aeb0:	4303      	orrs	r3, r0
3400aeb2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aeb6:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400aeba:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400aebe:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400aec2:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
3400aec6:	f7ff f945 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3400aeca:	6823      	ldr	r3, [r4, #0]
3400aecc:	03de      	lsls	r6, r3, #15
3400aece:	d540      	bpl.n	3400af52 <HAL_RCCEx_PeriphCLKConfig+0xc36>
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));
3400aed0:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400aed4:	4aa7      	ldr	r2, [pc, #668]	@ (3400b174 <HAL_RCCEx_PeriphCLKConfig+0xe58>)
3400aed6:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400aeda:	4291      	cmp	r1, r2
3400aedc:	d00a      	beq.n	3400aef4 <HAL_RCCEx_PeriphCLKConfig+0xbd8>
3400aede:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400aee2:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400aee6:	4293      	cmp	r3, r2
3400aee8:	d004      	beq.n	3400aef4 <HAL_RCCEx_PeriphCLKConfig+0xbd8>
3400aeea:	f44f 717f 	mov.w	r1, #1020	@ 0x3fc
3400aeee:	489f      	ldr	r0, [pc, #636]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400aef0:	f7f7 fb20 	bl	34002534 <assert_failed>
    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
3400aef4:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400aef8:	4a9f      	ldr	r2, [pc, #636]	@ (3400b178 <HAL_RCCEx_PeriphCLKConfig+0xe5c>)
3400aefa:	4293      	cmp	r3, r2
3400aefc:	f041 84bc 	bne.w	3400c878 <HAL_RCCEx_PeriphCLKConfig+0x255c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400af00:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400af02:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400af06:	d004      	beq.n	3400af12 <HAL_RCCEx_PeriphCLKConfig+0xbf6>
3400af08:	f240 4101 	movw	r1, #1025	@ 0x401
3400af0c:	4897      	ldr	r0, [pc, #604]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400af0e:	f7f7 fb11 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400af12:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400af14:	3b01      	subs	r3, #1
3400af16:	2bff      	cmp	r3, #255	@ 0xff
3400af18:	d904      	bls.n	3400af24 <HAL_RCCEx_PeriphCLKConfig+0xc08>
3400af1a:	f240 4102 	movw	r1, #1026	@ 0x402
3400af1e:	4893      	ldr	r0, [pc, #588]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400af20:	f7f7 fb08 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400af24:	4a92      	ldr	r2, [pc, #584]	@ (3400b170 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400af26:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400af28:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400af2c:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400af2e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400af32:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400af36:	3901      	subs	r1, #1
3400af38:	4303      	orrs	r3, r0
3400af3a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400af3e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400af42:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400af46:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400af4a:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
3400af4e:	f7ff f901 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3400af52:	6823      	ldr	r3, [r4, #0]
3400af54:	0398      	lsls	r0, r3, #14
3400af56:	d540      	bpl.n	3400afda <HAL_RCCEx_PeriphCLKConfig+0xcbe>
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));
3400af58:	f8d4 30fc 	ldr.w	r3, [r4, #252]	@ 0xfc
3400af5c:	4a87      	ldr	r2, [pc, #540]	@ (3400b17c <HAL_RCCEx_PeriphCLKConfig+0xe60>)
3400af5e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400af62:	4291      	cmp	r1, r2
3400af64:	d00a      	beq.n	3400af7c <HAL_RCCEx_PeriphCLKConfig+0xc60>
3400af66:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400af6a:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400af6e:	4293      	cmp	r3, r2
3400af70:	d004      	beq.n	3400af7c <HAL_RCCEx_PeriphCLKConfig+0xc60>
3400af72:	f240 4129 	movw	r1, #1065	@ 0x429
3400af76:	487d      	ldr	r0, [pc, #500]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400af78:	f7f7 fadc 	bl	34002534 <assert_failed>
    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3400af7c:	f8d4 30fc 	ldr.w	r3, [r4, #252]	@ 0xfc
3400af80:	4a7f      	ldr	r2, [pc, #508]	@ (3400b180 <HAL_RCCEx_PeriphCLKConfig+0xe64>)
3400af82:	4293      	cmp	r3, r2
3400af84:	f041 84a9 	bne.w	3400c8da <HAL_RCCEx_PeriphCLKConfig+0x25be>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400af88:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400af8a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400af8e:	d004      	beq.n	3400af9a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
3400af90:	f240 412e 	movw	r1, #1070	@ 0x42e
3400af94:	4875      	ldr	r0, [pc, #468]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400af96:	f7f7 facd 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400af9a:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400af9c:	3b01      	subs	r3, #1
3400af9e:	2bff      	cmp	r3, #255	@ 0xff
3400afa0:	d904      	bls.n	3400afac <HAL_RCCEx_PeriphCLKConfig+0xc90>
3400afa2:	f240 412f 	movw	r1, #1071	@ 0x42f
3400afa6:	4871      	ldr	r0, [pc, #452]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400afa8:	f7f7 fac4 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400afac:	4a70      	ldr	r2, [pc, #448]	@ (3400b170 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400afae:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400afb0:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400afb4:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400afb6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400afba:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400afbe:	3901      	subs	r1, #1
3400afc0:	4303      	orrs	r3, r0
3400afc2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400afc6:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400afca:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400afce:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400afd2:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3400afd6:	f7ff f8bd 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3400afda:	6823      	ldr	r3, [r4, #0]
3400afdc:	0359      	lsls	r1, r3, #13
3400afde:	d540      	bpl.n	3400b062 <HAL_RCCEx_PeriphCLKConfig+0xd46>
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));
3400afe0:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400afe4:	4a67      	ldr	r2, [pc, #412]	@ (3400b184 <HAL_RCCEx_PeriphCLKConfig+0xe68>)
3400afe6:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400afea:	4291      	cmp	r1, r2
3400afec:	d00a      	beq.n	3400b004 <HAL_RCCEx_PeriphCLKConfig+0xce8>
3400afee:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400aff2:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400aff6:	4293      	cmp	r3, r2
3400aff8:	d004      	beq.n	3400b004 <HAL_RCCEx_PeriphCLKConfig+0xce8>
3400affa:	f240 4156 	movw	r1, #1110	@ 0x456
3400affe:	485b      	ldr	r0, [pc, #364]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b000:	f7f7 fa98 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3400b004:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400b008:	4a5f      	ldr	r2, [pc, #380]	@ (3400b188 <HAL_RCCEx_PeriphCLKConfig+0xe6c>)
3400b00a:	4293      	cmp	r3, r2
3400b00c:	f041 8496 	bne.w	3400c93c <HAL_RCCEx_PeriphCLKConfig+0x2620>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b010:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b012:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b016:	d004      	beq.n	3400b022 <HAL_RCCEx_PeriphCLKConfig+0xd06>
3400b018:	f240 415b 	movw	r1, #1115	@ 0x45b
3400b01c:	4853      	ldr	r0, [pc, #332]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b01e:	f7f7 fa89 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b022:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b024:	3b01      	subs	r3, #1
3400b026:	2bff      	cmp	r3, #255	@ 0xff
3400b028:	d904      	bls.n	3400b034 <HAL_RCCEx_PeriphCLKConfig+0xd18>
3400b02a:	f240 415c 	movw	r1, #1116	@ 0x45c
3400b02e:	484f      	ldr	r0, [pc, #316]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b030:	f7f7 fa80 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b034:	4a4e      	ldr	r2, [pc, #312]	@ (3400b170 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b036:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b038:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b03c:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b03e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b042:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b046:	3901      	subs	r1, #1
3400b048:	4303      	orrs	r3, r0
3400b04a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b04e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b052:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b056:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b05a:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
3400b05e:	f7ff f879 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
3400b062:	6823      	ldr	r3, [r4, #0]
3400b064:	031a      	lsls	r2, r3, #12
3400b066:	d540      	bpl.n	3400b0ea <HAL_RCCEx_PeriphCLKConfig+0xdce>
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));
3400b068:	f8d4 3104 	ldr.w	r3, [r4, #260]	@ 0x104
3400b06c:	4a47      	ldr	r2, [pc, #284]	@ (3400b18c <HAL_RCCEx_PeriphCLKConfig+0xe70>)
3400b06e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b072:	4291      	cmp	r1, r2
3400b074:	d00a      	beq.n	3400b08c <HAL_RCCEx_PeriphCLKConfig+0xd70>
3400b076:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b07a:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b07e:	4293      	cmp	r3, r2
3400b080:	d004      	beq.n	3400b08c <HAL_RCCEx_PeriphCLKConfig+0xd70>
3400b082:	f240 4176 	movw	r1, #1142	@ 0x476
3400b086:	4839      	ldr	r0, [pc, #228]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b088:	f7f7 fa54 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3400b08c:	f8d4 3104 	ldr.w	r3, [r4, #260]	@ 0x104
3400b090:	4a3f      	ldr	r2, [pc, #252]	@ (3400b190 <HAL_RCCEx_PeriphCLKConfig+0xe74>)
3400b092:	4293      	cmp	r3, r2
3400b094:	f041 845b 	bne.w	3400c94e <HAL_RCCEx_PeriphCLKConfig+0x2632>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b098:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b09a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b09e:	d004      	beq.n	3400b0aa <HAL_RCCEx_PeriphCLKConfig+0xd8e>
3400b0a0:	f240 417b 	movw	r1, #1147	@ 0x47b
3400b0a4:	4831      	ldr	r0, [pc, #196]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b0a6:	f7f7 fa45 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b0aa:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b0ac:	3b01      	subs	r3, #1
3400b0ae:	2bff      	cmp	r3, #255	@ 0xff
3400b0b0:	d904      	bls.n	3400b0bc <HAL_RCCEx_PeriphCLKConfig+0xda0>
3400b0b2:	f240 417c 	movw	r1, #1148	@ 0x47c
3400b0b6:	482d      	ldr	r0, [pc, #180]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b0b8:	f7f7 fa3c 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b0bc:	4a2c      	ldr	r2, [pc, #176]	@ (3400b170 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b0be:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b0c0:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b0c4:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b0c6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b0ca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b0ce:	3901      	subs	r1, #1
3400b0d0:	4303      	orrs	r3, r0
3400b0d2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b0d6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b0da:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b0de:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b0e2:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
3400b0e6:	f7ff f835 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
3400b0ea:	6823      	ldr	r3, [r4, #0]
3400b0ec:	02db      	lsls	r3, r3, #11
3400b0ee:	d55b      	bpl.n	3400b1a8 <HAL_RCCEx_PeriphCLKConfig+0xe8c>
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));
3400b0f0:	f8d4 3108 	ldr.w	r3, [r4, #264]	@ 0x108
3400b0f4:	4a27      	ldr	r2, [pc, #156]	@ (3400b194 <HAL_RCCEx_PeriphCLKConfig+0xe78>)
3400b0f6:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b0fa:	4291      	cmp	r1, r2
3400b0fc:	d00a      	beq.n	3400b114 <HAL_RCCEx_PeriphCLKConfig+0xdf8>
3400b0fe:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b102:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b106:	4293      	cmp	r3, r2
3400b108:	d004      	beq.n	3400b114 <HAL_RCCEx_PeriphCLKConfig+0xdf8>
3400b10a:	f240 4196 	movw	r1, #1174	@ 0x496
3400b10e:	4817      	ldr	r0, [pc, #92]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b110:	f7f7 fa10 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3400b114:	f8d4 3108 	ldr.w	r3, [r4, #264]	@ 0x108
3400b118:	4a1f      	ldr	r2, [pc, #124]	@ (3400b198 <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
3400b11a:	4293      	cmp	r3, r2
3400b11c:	f041 8420 	bne.w	3400c960 <HAL_RCCEx_PeriphCLKConfig+0x2644>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b120:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b122:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b126:	d004      	beq.n	3400b132 <HAL_RCCEx_PeriphCLKConfig+0xe16>
3400b128:	f240 419b 	movw	r1, #1179	@ 0x49b
3400b12c:	480f      	ldr	r0, [pc, #60]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b12e:	f7f7 fa01 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b132:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b134:	3b01      	subs	r3, #1
3400b136:	2bff      	cmp	r3, #255	@ 0xff
3400b138:	d904      	bls.n	3400b144 <HAL_RCCEx_PeriphCLKConfig+0xe28>
3400b13a:	f240 419c 	movw	r1, #1180	@ 0x49c
3400b13e:	480b      	ldr	r0, [pc, #44]	@ (3400b16c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b140:	f7f7 f9f8 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b144:	4a0a      	ldr	r2, [pc, #40]	@ (3400b170 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b146:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b148:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b14c:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b14e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b152:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b156:	3901      	subs	r1, #1
3400b158:	4303      	orrs	r3, r0
3400b15a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b15e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b162:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b166:	e019      	b.n	3400b19c <HAL_RCCEx_PeriphCLKConfig+0xe80>
3400b168:	07020c0c 	.word	0x07020c0c
3400b16c:	3401c6ca 	.word	0x3401c6ca
3400b170:	56028000 	.word	0x56028000
3400b174:	0700100c 	.word	0x0700100c
3400b178:	0702100c 	.word	0x0702100c
3400b17c:	0700140c 	.word	0x0700140c
3400b180:	0702140c 	.word	0x0702140c
3400b184:	0700082c 	.word	0x0700082c
3400b188:	0702082c 	.word	0x0702082c
3400b18c:	07000c2c 	.word	0x07000c2c
3400b190:	07020c2c 	.word	0x07020c2c
3400b194:	0700102c 	.word	0x0700102c
3400b198:	0702102c 	.word	0x0702102c
3400b19c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b1a0:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
3400b1a4:	f7fe ffd6 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3400b1a8:	6823      	ldr	r3, [r4, #0]
3400b1aa:	029e      	lsls	r6, r3, #10
3400b1ac:	d540      	bpl.n	3400b230 <HAL_RCCEx_PeriphCLKConfig+0xf14>
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));
3400b1ae:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
3400b1b2:	4ac2      	ldr	r2, [pc, #776]	@ (3400b4bc <HAL_RCCEx_PeriphCLKConfig+0x11a0>)
3400b1b4:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b1b8:	4291      	cmp	r1, r2
3400b1ba:	d00a      	beq.n	3400b1d2 <HAL_RCCEx_PeriphCLKConfig+0xeb6>
3400b1bc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b1c0:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b1c4:	4293      	cmp	r3, r2
3400b1c6:	d004      	beq.n	3400b1d2 <HAL_RCCEx_PeriphCLKConfig+0xeb6>
3400b1c8:	f240 41b6 	movw	r1, #1206	@ 0x4b6
3400b1cc:	48bc      	ldr	r0, [pc, #752]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b1ce:	f7f7 f9b1 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3400b1d2:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
3400b1d6:	4abb      	ldr	r2, [pc, #748]	@ (3400b4c4 <HAL_RCCEx_PeriphCLKConfig+0x11a8>)
3400b1d8:	4293      	cmp	r3, r2
3400b1da:	f041 83ca 	bne.w	3400c972 <HAL_RCCEx_PeriphCLKConfig+0x2656>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b1de:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b1e0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b1e4:	d004      	beq.n	3400b1f0 <HAL_RCCEx_PeriphCLKConfig+0xed4>
3400b1e6:	f240 41bb 	movw	r1, #1211	@ 0x4bb
3400b1ea:	48b5      	ldr	r0, [pc, #724]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b1ec:	f7f7 f9a2 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b1f0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b1f2:	3b01      	subs	r3, #1
3400b1f4:	2bff      	cmp	r3, #255	@ 0xff
3400b1f6:	d904      	bls.n	3400b202 <HAL_RCCEx_PeriphCLKConfig+0xee6>
3400b1f8:	f240 41bc 	movw	r1, #1212	@ 0x4bc
3400b1fc:	48b0      	ldr	r0, [pc, #704]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b1fe:	f7f7 f999 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b202:	4ab1      	ldr	r2, [pc, #708]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b204:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b206:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b20a:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b20c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b210:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b214:	3901      	subs	r1, #1
3400b216:	4303      	orrs	r3, r0
3400b218:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b21c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b220:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b224:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b228:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
3400b22c:	f7fe ff92 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3400b230:	6823      	ldr	r3, [r4, #0]
3400b232:	0258      	lsls	r0, r3, #9
3400b234:	d540      	bpl.n	3400b2b8 <HAL_RCCEx_PeriphCLKConfig+0xf9c>
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));
3400b236:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
3400b23a:	4aa4      	ldr	r2, [pc, #656]	@ (3400b4cc <HAL_RCCEx_PeriphCLKConfig+0x11b0>)
3400b23c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b240:	4291      	cmp	r1, r2
3400b242:	d00a      	beq.n	3400b25a <HAL_RCCEx_PeriphCLKConfig+0xf3e>
3400b244:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b248:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b24c:	4293      	cmp	r3, r2
3400b24e:	d004      	beq.n	3400b25a <HAL_RCCEx_PeriphCLKConfig+0xf3e>
3400b250:	f240 41d6 	movw	r1, #1238	@ 0x4d6
3400b254:	489a      	ldr	r0, [pc, #616]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b256:	f7f7 f96d 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3400b25a:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
3400b25e:	4a9c      	ldr	r2, [pc, #624]	@ (3400b4d0 <HAL_RCCEx_PeriphCLKConfig+0x11b4>)
3400b260:	4293      	cmp	r3, r2
3400b262:	f041 838f 	bne.w	3400c984 <HAL_RCCEx_PeriphCLKConfig+0x2668>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b266:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b268:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b26c:	d004      	beq.n	3400b278 <HAL_RCCEx_PeriphCLKConfig+0xf5c>
3400b26e:	f240 41db 	movw	r1, #1243	@ 0x4db
3400b272:	4893      	ldr	r0, [pc, #588]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b274:	f7f7 f95e 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b278:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b27a:	3b01      	subs	r3, #1
3400b27c:	2bff      	cmp	r3, #255	@ 0xff
3400b27e:	d904      	bls.n	3400b28a <HAL_RCCEx_PeriphCLKConfig+0xf6e>
3400b280:	f240 41dc 	movw	r1, #1244	@ 0x4dc
3400b284:	488e      	ldr	r0, [pc, #568]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b286:	f7f7 f955 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b28a:	4a8f      	ldr	r2, [pc, #572]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b28c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b28e:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b292:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b294:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b298:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b29c:	3901      	subs	r1, #1
3400b29e:	4303      	orrs	r3, r0
3400b2a0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b2a4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b2a8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b2ac:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b2b0:	f8d4 0110 	ldr.w	r0, [r4, #272]	@ 0x110
3400b2b4:	f7fe ff4e 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3400b2b8:	6823      	ldr	r3, [r4, #0]
3400b2ba:	0219      	lsls	r1, r3, #8
3400b2bc:	d546      	bpl.n	3400b34c <HAL_RCCEx_PeriphCLKConfig+0x1030>
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
3400b2be:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
3400b2c2:	f433 7240 	bics.w	r2, r3, #768	@ 0x300
3400b2c6:	d00c      	beq.n	3400b2e2 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400b2c8:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
3400b2cc:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
3400b2d0:	d007      	beq.n	3400b2e2 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400b2d2:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400b2d6:	d004      	beq.n	3400b2e2 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400b2d8:	f240 41f6 	movw	r1, #1270	@ 0x4f6
3400b2dc:	4878      	ldr	r0, [pc, #480]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b2de:	f7f7 f929 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
3400b2e2:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
3400b2e6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400b2ea:	f041 8354 	bne.w	3400c996 <HAL_RCCEx_PeriphCLKConfig+0x267a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400b2ee:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400b2f0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b2f4:	d004      	beq.n	3400b300 <HAL_RCCEx_PeriphCLKConfig+0xfe4>
3400b2f6:	f240 41fb 	movw	r1, #1275	@ 0x4fb
3400b2fa:	4871      	ldr	r0, [pc, #452]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b2fc:	f7f7 f91a 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400b300:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400b302:	3b01      	subs	r3, #1
3400b304:	2bff      	cmp	r3, #255	@ 0xff
3400b306:	d904      	bls.n	3400b312 <HAL_RCCEx_PeriphCLKConfig+0xff6>
3400b308:	f240 41fc 	movw	r1, #1276	@ 0x4fc
3400b30c:	486c      	ldr	r0, [pc, #432]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b30e:	f7f7 f911 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400b312:	4a6d      	ldr	r2, [pc, #436]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b314:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400b316:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400b31a:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400b31c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b320:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b324:	3901      	subs	r1, #1
3400b326:	4303      	orrs	r3, r0
3400b328:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b32c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b330:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400b334:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3400b338:	4a63      	ldr	r2, [pc, #396]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b33a:	f8d4 1114 	ldr.w	r1, [r4, #276]	@ 0x114
3400b33e:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400b342:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
3400b346:	430b      	orrs	r3, r1
3400b348:	f8c2 3178 	str.w	r3, [r2, #376]	@ 0x178
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
3400b34c:	6823      	ldr	r3, [r4, #0]
3400b34e:	01da      	lsls	r2, r3, #7
3400b350:	d542      	bpl.n	3400b3d8 <HAL_RCCEx_PeriphCLKConfig+0x10bc>
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
3400b352:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
3400b356:	f033 7340 	bics.w	r3, r3, #50331648	@ 0x3000000
3400b35a:	d004      	beq.n	3400b366 <HAL_RCCEx_PeriphCLKConfig+0x104a>
3400b35c:	f240 5123 	movw	r1, #1315	@ 0x523
3400b360:	4857      	ldr	r0, [pc, #348]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b362:	f7f7 f8e7 	bl	34002534 <assert_failed>
    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
3400b366:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
3400b36a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400b36e:	f041 8343 	bne.w	3400c9f8 <HAL_RCCEx_PeriphCLKConfig+0x26dc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
3400b372:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3400b376:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b37a:	d004      	beq.n	3400b386 <HAL_RCCEx_PeriphCLKConfig+0x106a>
3400b37c:	f44f 61a5 	mov.w	r1, #1320	@ 0x528
3400b380:	484f      	ldr	r0, [pc, #316]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b382:	f7f7 f8d7 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));
3400b386:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
3400b38a:	3b01      	subs	r3, #1
3400b38c:	2bff      	cmp	r3, #255	@ 0xff
3400b38e:	d904      	bls.n	3400b39a <HAL_RCCEx_PeriphCLKConfig+0x107e>
3400b390:	f240 5129 	movw	r1, #1321	@ 0x529
3400b394:	484a      	ldr	r0, [pc, #296]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b396:	f7f7 f8cd 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
3400b39a:	4a4b      	ldr	r2, [pc, #300]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b39c:	f8d4 1084 	ldr.w	r1, [r4, #132]	@ 0x84
3400b3a0:	f8d2 3100 	ldr.w	r3, [r2, #256]	@ 0x100
3400b3a4:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
3400b3a8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b3ac:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b3b0:	3901      	subs	r1, #1
3400b3b2:	4303      	orrs	r3, r0
3400b3b4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b3b8:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3400b3bc:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400b3c0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3400b3c4:	4a40      	ldr	r2, [pc, #256]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b3c6:	f8d4 1118 	ldr.w	r1, [r4, #280]	@ 0x118
3400b3ca:	f8d2 3150 	ldr.w	r3, [r2, #336]	@ 0x150
3400b3ce:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400b3d2:	430b      	orrs	r3, r1
3400b3d4:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3400b3d8:	6823      	ldr	r3, [r4, #0]
3400b3da:	019b      	lsls	r3, r3, #6
3400b3dc:	d540      	bpl.n	3400b460 <HAL_RCCEx_PeriphCLKConfig+0x1144>
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));
3400b3de:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
3400b3e2:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400b3e6:	d007      	beq.n	3400b3f8 <HAL_RCCEx_PeriphCLKConfig+0x10dc>
3400b3e8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400b3ec:	d004      	beq.n	3400b3f8 <HAL_RCCEx_PeriphCLKConfig+0x10dc>
3400b3ee:	f240 5143 	movw	r1, #1347	@ 0x543
3400b3f2:	4833      	ldr	r0, [pc, #204]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b3f4:	f7f7 f89e 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3400b3f8:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
3400b3fc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400b400:	f041 8303 	bne.w	3400ca0a <HAL_RCCEx_PeriphCLKConfig+0x26ee>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b404:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b406:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b40a:	d004      	beq.n	3400b416 <HAL_RCCEx_PeriphCLKConfig+0x10fa>
3400b40c:	f44f 61a9 	mov.w	r1, #1352	@ 0x548
3400b410:	482b      	ldr	r0, [pc, #172]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b412:	f7f7 f88f 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b416:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b418:	3b01      	subs	r3, #1
3400b41a:	2bff      	cmp	r3, #255	@ 0xff
3400b41c:	d904      	bls.n	3400b428 <HAL_RCCEx_PeriphCLKConfig+0x110c>
3400b41e:	f240 5149 	movw	r1, #1353	@ 0x549
3400b422:	4827      	ldr	r0, [pc, #156]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b424:	f7f7 f886 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b428:	4a27      	ldr	r2, [pc, #156]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b42a:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b42c:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b430:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b432:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b436:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b43a:	3901      	subs	r1, #1
3400b43c:	4303      	orrs	r3, r0
3400b43e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b442:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b446:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b448:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3400b44c:	4a1e      	ldr	r2, [pc, #120]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b44e:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
3400b452:	f8d2 3154 	ldr.w	r3, [r2, #340]	@ 0x154
3400b456:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400b45a:	430b      	orrs	r3, r1
3400b45c:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3400b460:	6823      	ldr	r3, [r4, #0]
3400b462:	015e      	lsls	r6, r3, #5
3400b464:	d54e      	bpl.n	3400b504 <HAL_RCCEx_PeriphCLKConfig+0x11e8>
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));
3400b466:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
3400b46a:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400b46e:	d004      	beq.n	3400b47a <HAL_RCCEx_PeriphCLKConfig+0x115e>
3400b470:	f44f 61ae 	mov.w	r1, #1392	@ 0x570
3400b474:	4812      	ldr	r0, [pc, #72]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b476:	f7f7 f85d 	bl	34002534 <assert_failed>
    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3400b47a:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
3400b47e:	2b20      	cmp	r3, #32
3400b480:	f041 82f3 	bne.w	3400ca6a <HAL_RCCEx_PeriphCLKConfig+0x274e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400b484:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400b488:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b48c:	d004      	beq.n	3400b498 <HAL_RCCEx_PeriphCLKConfig+0x117c>
3400b48e:	f240 5175 	movw	r1, #1397	@ 0x575
3400b492:	480b      	ldr	r0, [pc, #44]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b494:	f7f7 f84e 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400b498:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
3400b49c:	3b01      	subs	r3, #1
3400b49e:	2bff      	cmp	r3, #255	@ 0xff
3400b4a0:	d904      	bls.n	3400b4ac <HAL_RCCEx_PeriphCLKConfig+0x1190>
3400b4a2:	f240 5176 	movw	r1, #1398	@ 0x576
3400b4a6:	4806      	ldr	r0, [pc, #24]	@ (3400b4c0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b4a8:	f7f7 f844 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400b4ac:	4a06      	ldr	r2, [pc, #24]	@ (3400b4c8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b4ae:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
3400b4b2:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3400b4b6:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
3400b4ba:	e00b      	b.n	3400b4d4 <HAL_RCCEx_PeriphCLKConfig+0x11b8>
3400b4bc:	0700142c 	.word	0x0700142c
3400b4c0:	3401c6ca 	.word	0x3401c6ca
3400b4c4:	0702142c 	.word	0x0702142c
3400b4c8:	56028000 	.word	0x56028000
3400b4cc:	0700182c 	.word	0x0700182c
3400b4d0:	0702182c 	.word	0x0702182c
3400b4d4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b4d8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b4dc:	3901      	subs	r1, #1
3400b4de:	4303      	orrs	r3, r0
3400b4e0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b4e4:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400b4e8:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3400b4ec:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3400b4f0:	4abc      	ldr	r2, [pc, #752]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b4f2:	f8d4 1120 	ldr.w	r1, [r4, #288]	@ 0x120
3400b4f6:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400b4fa:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400b4fe:	430b      	orrs	r3, r1
3400b500:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3400b504:	6823      	ldr	r3, [r4, #0]
3400b506:	00d8      	lsls	r0, r3, #3
3400b508:	d53d      	bpl.n	3400b586 <HAL_RCCEx_PeriphCLKConfig+0x126a>
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
3400b50a:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
3400b50e:	4ab6      	ldr	r2, [pc, #728]	@ (3400b7e8 <HAL_RCCEx_PeriphCLKConfig+0x14cc>)
3400b510:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400b514:	4293      	cmp	r3, r2
3400b516:	d008      	beq.n	3400b52a <HAL_RCCEx_PeriphCLKConfig+0x120e>
3400b518:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b51c:	4293      	cmp	r3, r2
3400b51e:	d004      	beq.n	3400b52a <HAL_RCCEx_PeriphCLKConfig+0x120e>
3400b520:	f44f 61b2 	mov.w	r1, #1424	@ 0x590
3400b524:	48b1      	ldr	r0, [pc, #708]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b526:	f7f7 f805 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3400b52a:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
3400b52e:	4ab0      	ldr	r2, [pc, #704]	@ (3400b7f0 <HAL_RCCEx_PeriphCLKConfig+0x14d4>)
3400b530:	4293      	cmp	r3, r2
3400b532:	f041 82c1 	bne.w	3400cab8 <HAL_RCCEx_PeriphCLKConfig+0x279c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b536:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b538:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b53c:	d004      	beq.n	3400b548 <HAL_RCCEx_PeriphCLKConfig+0x122c>
3400b53e:	f240 5195 	movw	r1, #1429	@ 0x595
3400b542:	48aa      	ldr	r0, [pc, #680]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b544:	f7f6 fff6 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b548:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b54a:	3b01      	subs	r3, #1
3400b54c:	2bff      	cmp	r3, #255	@ 0xff
3400b54e:	d904      	bls.n	3400b55a <HAL_RCCEx_PeriphCLKConfig+0x123e>
3400b550:	f240 5196 	movw	r1, #1430	@ 0x596
3400b554:	48a5      	ldr	r0, [pc, #660]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b556:	f7f6 ffed 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b55a:	4aa2      	ldr	r2, [pc, #648]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b55c:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b55e:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b562:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b564:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b568:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b56c:	3901      	subs	r1, #1
3400b56e:	4303      	orrs	r3, r0
3400b570:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b574:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b578:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b57a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b57e:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
3400b582:	f7fe fde7 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
3400b586:	6823      	ldr	r3, [r4, #0]
3400b588:	0099      	lsls	r1, r3, #2
3400b58a:	d53d      	bpl.n	3400b608 <HAL_RCCEx_PeriphCLKConfig+0x12ec>
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
3400b58c:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
3400b590:	4a98      	ldr	r2, [pc, #608]	@ (3400b7f4 <HAL_RCCEx_PeriphCLKConfig+0x14d8>)
3400b592:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400b596:	4293      	cmp	r3, r2
3400b598:	d008      	beq.n	3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x1290>
3400b59a:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b59e:	4293      	cmp	r3, r2
3400b5a0:	d004      	beq.n	3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x1290>
3400b5a2:	f240 51bd 	movw	r1, #1469	@ 0x5bd
3400b5a6:	4891      	ldr	r0, [pc, #580]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b5a8:	f7f6 ffc4 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3400b5ac:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
3400b5b0:	4a91      	ldr	r2, [pc, #580]	@ (3400b7f8 <HAL_RCCEx_PeriphCLKConfig+0x14dc>)
3400b5b2:	4293      	cmp	r3, r2
3400b5b4:	f041 82b0 	bne.w	3400cb18 <HAL_RCCEx_PeriphCLKConfig+0x27fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b5b8:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b5ba:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b5be:	d004      	beq.n	3400b5ca <HAL_RCCEx_PeriphCLKConfig+0x12ae>
3400b5c0:	f240 51c2 	movw	r1, #1474	@ 0x5c2
3400b5c4:	4889      	ldr	r0, [pc, #548]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b5c6:	f7f6 ffb5 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b5ca:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b5cc:	3b01      	subs	r3, #1
3400b5ce:	2bff      	cmp	r3, #255	@ 0xff
3400b5d0:	d904      	bls.n	3400b5dc <HAL_RCCEx_PeriphCLKConfig+0x12c0>
3400b5d2:	f240 51c3 	movw	r1, #1475	@ 0x5c3
3400b5d6:	4885      	ldr	r0, [pc, #532]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b5d8:	f7f6 ffac 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b5dc:	4a81      	ldr	r2, [pc, #516]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b5de:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b5e0:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b5e4:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b5e6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b5ea:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b5ee:	3901      	subs	r1, #1
3400b5f0:	4303      	orrs	r3, r0
3400b5f2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b5f6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b5fa:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b5fc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b600:	f8d4 0128 	ldr.w	r0, [r4, #296]	@ 0x128
3400b604:	f7fe fda6 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3400b608:	6863      	ldr	r3, [r4, #4]
3400b60a:	07da      	lsls	r2, r3, #31
3400b60c:	d53b      	bpl.n	3400b686 <HAL_RCCEx_PeriphCLKConfig+0x136a>
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));
3400b60e:	f8d4 314c 	ldr.w	r3, [r4, #332]	@ 0x14c
3400b612:	2b06      	cmp	r3, #6
3400b614:	d904      	bls.n	3400b620 <HAL_RCCEx_PeriphCLKConfig+0x1304>
3400b616:	f240 51ea 	movw	r1, #1514	@ 0x5ea
3400b61a:	4874      	ldr	r0, [pc, #464]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b61c:	f7f6 ff8a 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
3400b620:	f8d4 314c 	ldr.w	r3, [r4, #332]	@ 0x14c
3400b624:	2b02      	cmp	r3, #2
3400b626:	f041 82a7 	bne.w	3400cb78 <HAL_RCCEx_PeriphCLKConfig+0x285c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b62a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b62c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b630:	d004      	beq.n	3400b63c <HAL_RCCEx_PeriphCLKConfig+0x1320>
3400b632:	f240 51ef 	movw	r1, #1519	@ 0x5ef
3400b636:	486d      	ldr	r0, [pc, #436]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b638:	f7f6 ff7c 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b63c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b63e:	3b01      	subs	r3, #1
3400b640:	2bff      	cmp	r3, #255	@ 0xff
3400b642:	d904      	bls.n	3400b64e <HAL_RCCEx_PeriphCLKConfig+0x1332>
3400b644:	f44f 61be 	mov.w	r1, #1520	@ 0x5f0
3400b648:	4868      	ldr	r0, [pc, #416]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b64a:	f7f6 ff73 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b64e:	4a65      	ldr	r2, [pc, #404]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b650:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b652:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b656:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b658:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b65c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b660:	3901      	subs	r1, #1
3400b662:	4303      	orrs	r3, r0
3400b664:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b668:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b66c:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b66e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3400b672:	4a5c      	ldr	r2, [pc, #368]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b674:	f8d4 114c 	ldr.w	r1, [r4, #332]	@ 0x14c
3400b678:	f8d2 3164 	ldr.w	r3, [r2, #356]	@ 0x164
3400b67c:	f023 0307 	bic.w	r3, r3, #7
3400b680:	430b      	orrs	r3, r1
3400b682:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
3400b686:	6863      	ldr	r3, [r4, #4]
3400b688:	079b      	lsls	r3, r3, #30
3400b68a:	d543      	bpl.n	3400b714 <HAL_RCCEx_PeriphCLKConfig+0x13f8>
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));
3400b68c:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
3400b690:	4a5a      	ldr	r2, [pc, #360]	@ (3400b7fc <HAL_RCCEx_PeriphCLKConfig+0x14e0>)
3400b692:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b696:	4291      	cmp	r1, r2
3400b698:	d00e      	beq.n	3400b6b8 <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400b69a:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b69e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b6a2:	4291      	cmp	r1, r2
3400b6a4:	d008      	beq.n	3400b6b8 <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400b6a6:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b6aa:	4293      	cmp	r3, r2
3400b6ac:	d004      	beq.n	3400b6b8 <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400b6ae:	f240 6117 	movw	r1, #1559	@ 0x617
3400b6b2:	484e      	ldr	r0, [pc, #312]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b6b4:	f7f6 ff3e 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
3400b6b8:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
3400b6bc:	4a50      	ldr	r2, [pc, #320]	@ (3400b800 <HAL_RCCEx_PeriphCLKConfig+0x14e4>)
3400b6be:	4293      	cmp	r3, r2
3400b6c0:	f041 8288 	bne.w	3400cbd4 <HAL_RCCEx_PeriphCLKConfig+0x28b8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b6c4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b6c6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b6ca:	d004      	beq.n	3400b6d6 <HAL_RCCEx_PeriphCLKConfig+0x13ba>
3400b6cc:	f240 611c 	movw	r1, #1564	@ 0x61c
3400b6d0:	4846      	ldr	r0, [pc, #280]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b6d2:	f7f6 ff2f 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b6d6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b6d8:	3b01      	subs	r3, #1
3400b6da:	2bff      	cmp	r3, #255	@ 0xff
3400b6dc:	d904      	bls.n	3400b6e8 <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400b6de:	f240 611d 	movw	r1, #1565	@ 0x61d
3400b6e2:	4842      	ldr	r0, [pc, #264]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b6e4:	f7f6 ff26 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b6e8:	4a3e      	ldr	r2, [pc, #248]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b6ea:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b6ec:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b6f0:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b6f2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b6f6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b6fa:	3901      	subs	r1, #1
3400b6fc:	4303      	orrs	r3, r0
3400b6fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b702:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b706:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b708:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b70c:	f8d4 0134 	ldr.w	r0, [r4, #308]	@ 0x134
3400b710:	f7fe fd20 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3400b714:	6863      	ldr	r3, [r4, #4]
3400b716:	075e      	lsls	r6, r3, #29
3400b718:	d543      	bpl.n	3400b7a2 <HAL_RCCEx_PeriphCLKConfig+0x1486>
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));
3400b71a:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
3400b71e:	4a39      	ldr	r2, [pc, #228]	@ (3400b804 <HAL_RCCEx_PeriphCLKConfig+0x14e8>)
3400b720:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b724:	4291      	cmp	r1, r2
3400b726:	d00e      	beq.n	3400b746 <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400b728:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b72c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b730:	4291      	cmp	r1, r2
3400b732:	d008      	beq.n	3400b746 <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400b734:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b738:	4293      	cmp	r3, r2
3400b73a:	d004      	beq.n	3400b746 <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400b73c:	f240 6144 	movw	r1, #1604	@ 0x644
3400b740:	482a      	ldr	r0, [pc, #168]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b742:	f7f6 fef7 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3400b746:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
3400b74a:	4a2f      	ldr	r2, [pc, #188]	@ (3400b808 <HAL_RCCEx_PeriphCLKConfig+0x14ec>)
3400b74c:	4293      	cmp	r3, r2
3400b74e:	f041 8272 	bne.w	3400cc36 <HAL_RCCEx_PeriphCLKConfig+0x291a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b752:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b754:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b758:	d004      	beq.n	3400b764 <HAL_RCCEx_PeriphCLKConfig+0x1448>
3400b75a:	f240 6149 	movw	r1, #1609	@ 0x649
3400b75e:	4823      	ldr	r0, [pc, #140]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b760:	f7f6 fee8 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b764:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b766:	3b01      	subs	r3, #1
3400b768:	2bff      	cmp	r3, #255	@ 0xff
3400b76a:	d904      	bls.n	3400b776 <HAL_RCCEx_PeriphCLKConfig+0x145a>
3400b76c:	f240 614a 	movw	r1, #1610	@ 0x64a
3400b770:	481e      	ldr	r0, [pc, #120]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b772:	f7f6 fedf 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b776:	4a1b      	ldr	r2, [pc, #108]	@ (3400b7e4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b778:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b77a:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b77e:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b780:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b784:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b788:	3901      	subs	r1, #1
3400b78a:	4303      	orrs	r3, r0
3400b78c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b790:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b794:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b796:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b79a:	f8d4 0138 	ldr.w	r0, [r4, #312]	@ 0x138
3400b79e:	f7fe fcd9 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3400b7a2:	6863      	ldr	r3, [r4, #4]
3400b7a4:	0718      	lsls	r0, r3, #28
3400b7a6:	d55d      	bpl.n	3400b864 <HAL_RCCEx_PeriphCLKConfig+0x1548>
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));
3400b7a8:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
3400b7ac:	4a17      	ldr	r2, [pc, #92]	@ (3400b80c <HAL_RCCEx_PeriphCLKConfig+0x14f0>)
3400b7ae:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b7b2:	4291      	cmp	r1, r2
3400b7b4:	d00e      	beq.n	3400b7d4 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400b7b6:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b7ba:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b7be:	4291      	cmp	r1, r2
3400b7c0:	d008      	beq.n	3400b7d4 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400b7c2:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b7c6:	4293      	cmp	r3, r2
3400b7c8:	d004      	beq.n	3400b7d4 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400b7ca:	f240 6171 	movw	r1, #1649	@ 0x671
3400b7ce:	4807      	ldr	r0, [pc, #28]	@ (3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b7d0:	f7f6 feb0 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3400b7d4:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
3400b7d8:	4a0d      	ldr	r2, [pc, #52]	@ (3400b810 <HAL_RCCEx_PeriphCLKConfig+0x14f4>)
3400b7da:	4293      	cmp	r3, r2
3400b7dc:	f041 825c 	bne.w	3400cc98 <HAL_RCCEx_PeriphCLKConfig+0x297c>
3400b7e0:	e018      	b.n	3400b814 <HAL_RCCEx_PeriphCLKConfig+0x14f8>
3400b7e2:	bf00      	nop
3400b7e4:	56028000 	.word	0x56028000
3400b7e8:	07001418 	.word	0x07001418
3400b7ec:	3401c6ca 	.word	0x3401c6ca
3400b7f0:	07021418 	.word	0x07021418
3400b7f4:	07001818 	.word	0x07001818
3400b7f8:	07021818 	.word	0x07021818
3400b7fc:	07000420 	.word	0x07000420
3400b800:	07020420 	.word	0x07020420
3400b804:	07000820 	.word	0x07000820
3400b808:	07020820 	.word	0x07020820
3400b80c:	07000c20 	.word	0x07000c20
3400b810:	07020c20 	.word	0x07020c20
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b814:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b816:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b81a:	d004      	beq.n	3400b826 <HAL_RCCEx_PeriphCLKConfig+0x150a>
3400b81c:	f240 6176 	movw	r1, #1654	@ 0x676
3400b820:	48bb      	ldr	r0, [pc, #748]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b822:	f7f6 fe87 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b826:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b828:	3b01      	subs	r3, #1
3400b82a:	2bff      	cmp	r3, #255	@ 0xff
3400b82c:	d904      	bls.n	3400b838 <HAL_RCCEx_PeriphCLKConfig+0x151c>
3400b82e:	f240 6177 	movw	r1, #1655	@ 0x677
3400b832:	48b7      	ldr	r0, [pc, #732]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b834:	f7f6 fe7e 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b838:	4ab6      	ldr	r2, [pc, #728]	@ (3400bb14 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400b83a:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b83c:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b840:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b842:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b846:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b84a:	3901      	subs	r1, #1
3400b84c:	4303      	orrs	r3, r0
3400b84e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b852:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b856:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b858:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b85c:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
3400b860:	f7fe fc78 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3400b864:	6863      	ldr	r3, [r4, #4]
3400b866:	06d9      	lsls	r1, r3, #27
3400b868:	d544      	bpl.n	3400b8f4 <HAL_RCCEx_PeriphCLKConfig+0x15d8>
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));
3400b86a:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
3400b86e:	4aaa      	ldr	r2, [pc, #680]	@ (3400bb18 <HAL_RCCEx_PeriphCLKConfig+0x17fc>)
3400b870:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b874:	4291      	cmp	r1, r2
3400b876:	d00e      	beq.n	3400b896 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b878:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b87c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b880:	4291      	cmp	r1, r2
3400b882:	d008      	beq.n	3400b896 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b884:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b888:	4293      	cmp	r3, r2
3400b88a:	d004      	beq.n	3400b896 <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b88c:	f240 619e 	movw	r1, #1694	@ 0x69e
3400b890:	489f      	ldr	r0, [pc, #636]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b892:	f7f6 fe4f 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3400b896:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
3400b89a:	4aa0      	ldr	r2, [pc, #640]	@ (3400bb1c <HAL_RCCEx_PeriphCLKConfig+0x1800>)
3400b89c:	4293      	cmp	r3, r2
3400b89e:	f041 822c 	bne.w	3400ccfa <HAL_RCCEx_PeriphCLKConfig+0x29de>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400b8a2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400b8a4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b8a8:	d004      	beq.n	3400b8b4 <HAL_RCCEx_PeriphCLKConfig+0x1598>
3400b8aa:	f240 61a3 	movw	r1, #1699	@ 0x6a3
3400b8ae:	4898      	ldr	r0, [pc, #608]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b8b0:	f7f6 fe40 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400b8b4:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400b8b6:	3b01      	subs	r3, #1
3400b8b8:	2bff      	cmp	r3, #255	@ 0xff
3400b8ba:	d904      	bls.n	3400b8c6 <HAL_RCCEx_PeriphCLKConfig+0x15aa>
3400b8bc:	f240 61a4 	movw	r1, #1700	@ 0x6a4
3400b8c0:	4893      	ldr	r0, [pc, #588]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b8c2:	f7f6 fe37 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400b8c6:	4a93      	ldr	r2, [pc, #588]	@ (3400bb14 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400b8c8:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400b8ca:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400b8ce:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400b8d0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b8d4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b8d8:	3901      	subs	r1, #1
3400b8da:	4303      	orrs	r3, r0
3400b8dc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b8e0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b8e4:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400b8e8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b8ec:	f8d4 0140 	ldr.w	r0, [r4, #320]	@ 0x140
3400b8f0:	f7fe fc30 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3400b8f4:	6863      	ldr	r3, [r4, #4]
3400b8f6:	069a      	lsls	r2, r3, #26
3400b8f8:	d544      	bpl.n	3400b984 <HAL_RCCEx_PeriphCLKConfig+0x1668>
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));
3400b8fa:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
3400b8fe:	4a88      	ldr	r2, [pc, #544]	@ (3400bb20 <HAL_RCCEx_PeriphCLKConfig+0x1804>)
3400b900:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b904:	4291      	cmp	r1, r2
3400b906:	d00e      	beq.n	3400b926 <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400b908:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b90c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b910:	4291      	cmp	r1, r2
3400b912:	d008      	beq.n	3400b926 <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400b914:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b918:	4293      	cmp	r3, r2
3400b91a:	d004      	beq.n	3400b926 <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400b91c:	f240 61cb 	movw	r1, #1739	@ 0x6cb
3400b920:	487b      	ldr	r0, [pc, #492]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b922:	f7f6 fe07 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3400b926:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
3400b92a:	4a7e      	ldr	r2, [pc, #504]	@ (3400bb24 <HAL_RCCEx_PeriphCLKConfig+0x1808>)
3400b92c:	4293      	cmp	r3, r2
3400b92e:	f041 8231 	bne.w	3400cd94 <HAL_RCCEx_PeriphCLKConfig+0x2a78>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400b932:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400b934:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b938:	d004      	beq.n	3400b944 <HAL_RCCEx_PeriphCLKConfig+0x1628>
3400b93a:	f44f 61da 	mov.w	r1, #1744	@ 0x6d0
3400b93e:	4874      	ldr	r0, [pc, #464]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b940:	f7f6 fdf8 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400b944:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400b946:	3b01      	subs	r3, #1
3400b948:	2bff      	cmp	r3, #255	@ 0xff
3400b94a:	d904      	bls.n	3400b956 <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400b94c:	f240 61d1 	movw	r1, #1745	@ 0x6d1
3400b950:	486f      	ldr	r0, [pc, #444]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b952:	f7f6 fdef 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400b956:	4a6f      	ldr	r2, [pc, #444]	@ (3400bb14 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400b958:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400b95a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400b95e:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400b960:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b964:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b968:	3901      	subs	r1, #1
3400b96a:	4303      	orrs	r3, r0
3400b96c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b970:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b974:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400b978:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b97c:	f8d4 0144 	ldr.w	r0, [r4, #324]	@ 0x144
3400b980:	f7fe fbe8 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3400b984:	6863      	ldr	r3, [r4, #4]
3400b986:	065b      	lsls	r3, r3, #25
3400b988:	d543      	bpl.n	3400ba12 <HAL_RCCEx_PeriphCLKConfig+0x16f6>
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));
3400b98a:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
3400b98e:	4a66      	ldr	r2, [pc, #408]	@ (3400bb28 <HAL_RCCEx_PeriphCLKConfig+0x180c>)
3400b990:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b994:	4291      	cmp	r1, r2
3400b996:	d00e      	beq.n	3400b9b6 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400b998:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b99c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b9a0:	4291      	cmp	r1, r2
3400b9a2:	d008      	beq.n	3400b9b6 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400b9a4:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b9a8:	4293      	cmp	r3, r2
3400b9aa:	d004      	beq.n	3400b9b6 <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400b9ac:	f44f 61df 	mov.w	r1, #1784	@ 0x6f8
3400b9b0:	4857      	ldr	r0, [pc, #348]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b9b2:	f7f6 fdbf 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3400b9b6:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
3400b9ba:	4a5c      	ldr	r2, [pc, #368]	@ (3400bb2c <HAL_RCCEx_PeriphCLKConfig+0x1810>)
3400b9bc:	4293      	cmp	r3, r2
3400b9be:	f041 821a 	bne.w	3400cdf6 <HAL_RCCEx_PeriphCLKConfig+0x2ada>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b9c2:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b9c4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b9c8:	d004      	beq.n	3400b9d4 <HAL_RCCEx_PeriphCLKConfig+0x16b8>
3400b9ca:	f240 61fd 	movw	r1, #1789	@ 0x6fd
3400b9ce:	4850      	ldr	r0, [pc, #320]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b9d0:	f7f6 fdb0 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b9d4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b9d6:	3b01      	subs	r3, #1
3400b9d8:	2bff      	cmp	r3, #255	@ 0xff
3400b9da:	d904      	bls.n	3400b9e6 <HAL_RCCEx_PeriphCLKConfig+0x16ca>
3400b9dc:	f240 61fe 	movw	r1, #1790	@ 0x6fe
3400b9e0:	484b      	ldr	r0, [pc, #300]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b9e2:	f7f6 fda7 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b9e6:	4a4b      	ldr	r2, [pc, #300]	@ (3400bb14 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400b9e8:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b9ea:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b9ee:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b9f0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b9f4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b9f8:	3901      	subs	r1, #1
3400b9fa:	4303      	orrs	r3, r0
3400b9fc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ba00:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400ba04:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400ba06:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ba0a:	f8d4 0148 	ldr.w	r0, [r4, #328]	@ 0x148
3400ba0e:	f7fe fba1 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3400ba12:	6863      	ldr	r3, [r4, #4]
3400ba14:	05de      	lsls	r6, r3, #23
3400ba16:	d544      	bpl.n	3400baa2 <HAL_RCCEx_PeriphCLKConfig+0x1786>
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
3400ba18:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
3400ba1c:	4a44      	ldr	r2, [pc, #272]	@ (3400bb30 <HAL_RCCEx_PeriphCLKConfig+0x1814>)
3400ba1e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ba22:	4291      	cmp	r1, r2
3400ba24:	d00e      	beq.n	3400ba44 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400ba26:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400ba2a:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ba2e:	4291      	cmp	r1, r2
3400ba30:	d008      	beq.n	3400ba44 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400ba32:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400ba36:	4293      	cmp	r3, r2
3400ba38:	d004      	beq.n	3400ba44 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400ba3a:	f240 7125 	movw	r1, #1829	@ 0x725
3400ba3e:	4834      	ldr	r0, [pc, #208]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba40:	f7f6 fd78 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3400ba44:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
3400ba48:	4a3a      	ldr	r2, [pc, #232]	@ (3400bb34 <HAL_RCCEx_PeriphCLKConfig+0x1818>)
3400ba4a:	4293      	cmp	r3, r2
3400ba4c:	f041 8204 	bne.w	3400ce58 <HAL_RCCEx_PeriphCLKConfig+0x2b3c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ba50:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400ba52:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ba56:	d004      	beq.n	3400ba62 <HAL_RCCEx_PeriphCLKConfig+0x1746>
3400ba58:	f240 712a 	movw	r1, #1834	@ 0x72a
3400ba5c:	482c      	ldr	r0, [pc, #176]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba5e:	f7f6 fd69 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ba62:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400ba64:	3b01      	subs	r3, #1
3400ba66:	2bff      	cmp	r3, #255	@ 0xff
3400ba68:	d904      	bls.n	3400ba74 <HAL_RCCEx_PeriphCLKConfig+0x1758>
3400ba6a:	f240 712b 	movw	r1, #1835	@ 0x72b
3400ba6e:	4828      	ldr	r0, [pc, #160]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba70:	f7f6 fd60 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400ba74:	4a27      	ldr	r2, [pc, #156]	@ (3400bb14 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400ba76:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400ba78:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400ba7c:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400ba7e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ba82:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ba86:	3901      	subs	r1, #1
3400ba88:	4303      	orrs	r3, r0
3400ba8a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ba8e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400ba92:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400ba96:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ba9a:	f8d4 0150 	ldr.w	r0, [r4, #336]	@ 0x150
3400ba9e:	f7fe fb59 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3400baa2:	6863      	ldr	r3, [r4, #4]
3400baa4:	0598      	lsls	r0, r3, #22
3400baa6:	d55d      	bpl.n	3400bb64 <HAL_RCCEx_PeriphCLKConfig+0x1848>
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
3400baa8:	f8d4 3154 	ldr.w	r3, [r4, #340]	@ 0x154
3400baac:	4a22      	ldr	r2, [pc, #136]	@ (3400bb38 <HAL_RCCEx_PeriphCLKConfig+0x181c>)
3400baae:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bab2:	4291      	cmp	r1, r2
3400bab4:	d00e      	beq.n	3400bad4 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400bab6:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400baba:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400babe:	4291      	cmp	r1, r2
3400bac0:	d008      	beq.n	3400bad4 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400bac2:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bac6:	4293      	cmp	r3, r2
3400bac8:	d004      	beq.n	3400bad4 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400baca:	f240 7152 	movw	r1, #1874	@ 0x752
3400bace:	4810      	ldr	r0, [pc, #64]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bad0:	f7f6 fd30 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3400bad4:	f8d4 3154 	ldr.w	r3, [r4, #340]	@ 0x154
3400bad8:	4a18      	ldr	r2, [pc, #96]	@ (3400bb3c <HAL_RCCEx_PeriphCLKConfig+0x1820>)
3400bada:	4293      	cmp	r3, r2
3400badc:	f041 81ed 	bne.w	3400ceba <HAL_RCCEx_PeriphCLKConfig+0x2b9e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bae0:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bae2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bae6:	d004      	beq.n	3400baf2 <HAL_RCCEx_PeriphCLKConfig+0x17d6>
3400bae8:	f240 7157 	movw	r1, #1879	@ 0x757
3400baec:	4808      	ldr	r0, [pc, #32]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400baee:	f7f6 fd21 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400baf2:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400baf4:	3b01      	subs	r3, #1
3400baf6:	2bff      	cmp	r3, #255	@ 0xff
3400baf8:	d904      	bls.n	3400bb04 <HAL_RCCEx_PeriphCLKConfig+0x17e8>
3400bafa:	f44f 61eb 	mov.w	r1, #1880	@ 0x758
3400bafe:	4804      	ldr	r0, [pc, #16]	@ (3400bb10 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bb00:	f7f6 fd18 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bb04:	4a03      	ldr	r2, [pc, #12]	@ (3400bb14 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400bb06:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bb08:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bb0c:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bb0e:	e017      	b.n	3400bb40 <HAL_RCCEx_PeriphCLKConfig+0x1824>
3400bb10:	3401c6ca 	.word	0x3401c6ca
3400bb14:	56028000 	.word	0x56028000
3400bb18:	07001020 	.word	0x07001020
3400bb1c:	07021020 	.word	0x07021020
3400bb20:	07001420 	.word	0x07001420
3400bb24:	07021420 	.word	0x07021420
3400bb28:	07001820 	.word	0x07001820
3400bb2c:	07021820 	.word	0x07021820
3400bb30:	07000030 	.word	0x07000030
3400bb34:	07020030 	.word	0x07020030
3400bb38:	07000430 	.word	0x07000430
3400bb3c:	07020430 	.word	0x07020430
3400bb40:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bb44:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bb48:	3901      	subs	r1, #1
3400bb4a:	4303      	orrs	r3, r0
3400bb4c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bb50:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bb54:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bb58:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bb5c:	f8d4 0154 	ldr.w	r0, [r4, #340]	@ 0x154
3400bb60:	f7fe faf8 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3400bb64:	6863      	ldr	r3, [r4, #4]
3400bb66:	0559      	lsls	r1, r3, #21
3400bb68:	d544      	bpl.n	3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x18d8>
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
3400bb6a:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
3400bb6e:	4abc      	ldr	r2, [pc, #752]	@ (3400be60 <HAL_RCCEx_PeriphCLKConfig+0x1b44>)
3400bb70:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bb74:	4291      	cmp	r1, r2
3400bb76:	d00e      	beq.n	3400bb96 <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400bb78:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bb7c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bb80:	4291      	cmp	r1, r2
3400bb82:	d008      	beq.n	3400bb96 <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400bb84:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bb88:	4293      	cmp	r3, r2
3400bb8a:	d004      	beq.n	3400bb96 <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400bb8c:	f240 717f 	movw	r1, #1919	@ 0x77f
3400bb90:	48b4      	ldr	r0, [pc, #720]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bb92:	f7f6 fccf 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
3400bb96:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
3400bb9a:	4ab3      	ldr	r2, [pc, #716]	@ (3400be68 <HAL_RCCEx_PeriphCLKConfig+0x1b4c>)
3400bb9c:	4293      	cmp	r3, r2
3400bb9e:	f041 81bd 	bne.w	3400cf1c <HAL_RCCEx_PeriphCLKConfig+0x2c00>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bba2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bba4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bba8:	d004      	beq.n	3400bbb4 <HAL_RCCEx_PeriphCLKConfig+0x1898>
3400bbaa:	f240 7184 	movw	r1, #1924	@ 0x784
3400bbae:	48ad      	ldr	r0, [pc, #692]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bbb0:	f7f6 fcc0 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bbb4:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bbb6:	3b01      	subs	r3, #1
3400bbb8:	2bff      	cmp	r3, #255	@ 0xff
3400bbba:	d904      	bls.n	3400bbc6 <HAL_RCCEx_PeriphCLKConfig+0x18aa>
3400bbbc:	f240 7185 	movw	r1, #1925	@ 0x785
3400bbc0:	48a8      	ldr	r0, [pc, #672]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bbc2:	f7f6 fcb7 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bbc6:	4aa9      	ldr	r2, [pc, #676]	@ (3400be6c <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bbc8:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bbca:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bbce:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bbd0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bbd4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bbd8:	3901      	subs	r1, #1
3400bbda:	4303      	orrs	r3, r0
3400bbdc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bbe0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bbe4:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bbe8:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bbec:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
3400bbf0:	f7fe fab0 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
3400bbf4:	6863      	ldr	r3, [r4, #4]
3400bbf6:	051a      	lsls	r2, r3, #20
3400bbf8:	d544      	bpl.n	3400bc84 <HAL_RCCEx_PeriphCLKConfig+0x1968>
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
3400bbfa:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400bbfe:	4a9c      	ldr	r2, [pc, #624]	@ (3400be70 <HAL_RCCEx_PeriphCLKConfig+0x1b54>)
3400bc00:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bc04:	4291      	cmp	r1, r2
3400bc06:	d00e      	beq.n	3400bc26 <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400bc08:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bc0c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bc10:	4291      	cmp	r1, r2
3400bc12:	d008      	beq.n	3400bc26 <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400bc14:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bc18:	4293      	cmp	r3, r2
3400bc1a:	d004      	beq.n	3400bc26 <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400bc1c:	f240 71ac 	movw	r1, #1964	@ 0x7ac
3400bc20:	4890      	ldr	r0, [pc, #576]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bc22:	f7f6 fc87 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3400bc26:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400bc2a:	4a92      	ldr	r2, [pc, #584]	@ (3400be74 <HAL_RCCEx_PeriphCLKConfig+0x1b58>)
3400bc2c:	4293      	cmp	r3, r2
3400bc2e:	f041 81a6 	bne.w	3400cf7e <HAL_RCCEx_PeriphCLKConfig+0x2c62>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bc32:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bc34:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bc38:	d004      	beq.n	3400bc44 <HAL_RCCEx_PeriphCLKConfig+0x1928>
3400bc3a:	f240 71b1 	movw	r1, #1969	@ 0x7b1
3400bc3e:	4889      	ldr	r0, [pc, #548]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bc40:	f7f6 fc78 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bc44:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bc46:	3b01      	subs	r3, #1
3400bc48:	2bff      	cmp	r3, #255	@ 0xff
3400bc4a:	d904      	bls.n	3400bc56 <HAL_RCCEx_PeriphCLKConfig+0x193a>
3400bc4c:	f240 71b2 	movw	r1, #1970	@ 0x7b2
3400bc50:	4884      	ldr	r0, [pc, #528]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bc52:	f7f6 fc6f 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bc56:	4a85      	ldr	r2, [pc, #532]	@ (3400be6c <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bc58:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bc5a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bc5e:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bc60:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bc64:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bc68:	3901      	subs	r1, #1
3400bc6a:	4303      	orrs	r3, r0
3400bc6c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bc70:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bc74:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bc78:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bc7c:	f8d4 015c 	ldr.w	r0, [r4, #348]	@ 0x15c
3400bc80:	f7fe fa68 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3400bc84:	6863      	ldr	r3, [r4, #4]
3400bc86:	04db      	lsls	r3, r3, #19
3400bc88:	d544      	bpl.n	3400bd14 <HAL_RCCEx_PeriphCLKConfig+0x19f8>
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
3400bc8a:	f8d4 3160 	ldr.w	r3, [r4, #352]	@ 0x160
3400bc8e:	4a7a      	ldr	r2, [pc, #488]	@ (3400be78 <HAL_RCCEx_PeriphCLKConfig+0x1b5c>)
3400bc90:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bc94:	4291      	cmp	r1, r2
3400bc96:	d00e      	beq.n	3400bcb6 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400bc98:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bc9c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bca0:	4291      	cmp	r1, r2
3400bca2:	d008      	beq.n	3400bcb6 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400bca4:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bca8:	4293      	cmp	r3, r2
3400bcaa:	d004      	beq.n	3400bcb6 <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400bcac:	f240 71d9 	movw	r1, #2009	@ 0x7d9
3400bcb0:	486c      	ldr	r0, [pc, #432]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bcb2:	f7f6 fc3f 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3400bcb6:	f8d4 3160 	ldr.w	r3, [r4, #352]	@ 0x160
3400bcba:	4a70      	ldr	r2, [pc, #448]	@ (3400be7c <HAL_RCCEx_PeriphCLKConfig+0x1b60>)
3400bcbc:	4293      	cmp	r3, r2
3400bcbe:	f041 818f 	bne.w	3400cfe0 <HAL_RCCEx_PeriphCLKConfig+0x2cc4>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bcc2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bcc4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bcc8:	d004      	beq.n	3400bcd4 <HAL_RCCEx_PeriphCLKConfig+0x19b8>
3400bcca:	f240 71de 	movw	r1, #2014	@ 0x7de
3400bcce:	4865      	ldr	r0, [pc, #404]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bcd0:	f7f6 fc30 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bcd4:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bcd6:	3b01      	subs	r3, #1
3400bcd8:	2bff      	cmp	r3, #255	@ 0xff
3400bcda:	d904      	bls.n	3400bce6 <HAL_RCCEx_PeriphCLKConfig+0x19ca>
3400bcdc:	f240 71df 	movw	r1, #2015	@ 0x7df
3400bce0:	4860      	ldr	r0, [pc, #384]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bce2:	f7f6 fc27 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bce6:	4a61      	ldr	r2, [pc, #388]	@ (3400be6c <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bce8:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bcea:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bcee:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bcf0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bcf4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bcf8:	3901      	subs	r1, #1
3400bcfa:	4303      	orrs	r3, r0
3400bcfc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bd00:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bd04:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bd08:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bd0c:	f8d4 0160 	ldr.w	r0, [r4, #352]	@ 0x160
3400bd10:	f7fe fa20 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3400bd14:	6863      	ldr	r3, [r4, #4]
3400bd16:	049e      	lsls	r6, r3, #18
3400bd18:	d544      	bpl.n	3400bda4 <HAL_RCCEx_PeriphCLKConfig+0x1a88>
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
3400bd1a:	f8d4 3164 	ldr.w	r3, [r4, #356]	@ 0x164
3400bd1e:	4a58      	ldr	r2, [pc, #352]	@ (3400be80 <HAL_RCCEx_PeriphCLKConfig+0x1b64>)
3400bd20:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bd24:	4291      	cmp	r1, r2
3400bd26:	d00e      	beq.n	3400bd46 <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400bd28:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bd2c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bd30:	4291      	cmp	r1, r2
3400bd32:	d008      	beq.n	3400bd46 <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400bd34:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bd38:	4293      	cmp	r3, r2
3400bd3a:	d004      	beq.n	3400bd46 <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400bd3c:	f640 0106 	movw	r1, #2054	@ 0x806
3400bd40:	4848      	ldr	r0, [pc, #288]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd42:	f7f6 fbf7 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3400bd46:	f8d4 3164 	ldr.w	r3, [r4, #356]	@ 0x164
3400bd4a:	4a4e      	ldr	r2, [pc, #312]	@ (3400be84 <HAL_RCCEx_PeriphCLKConfig+0x1b68>)
3400bd4c:	4293      	cmp	r3, r2
3400bd4e:	f041 8199 	bne.w	3400d084 <HAL_RCCEx_PeriphCLKConfig+0x2d68>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bd52:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bd54:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bd58:	d004      	beq.n	3400bd64 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
3400bd5a:	f640 010b 	movw	r1, #2059	@ 0x80b
3400bd5e:	4841      	ldr	r0, [pc, #260]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd60:	f7f6 fbe8 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bd64:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bd66:	3b01      	subs	r3, #1
3400bd68:	2bff      	cmp	r3, #255	@ 0xff
3400bd6a:	d904      	bls.n	3400bd76 <HAL_RCCEx_PeriphCLKConfig+0x1a5a>
3400bd6c:	f640 010c 	movw	r1, #2060	@ 0x80c
3400bd70:	483c      	ldr	r0, [pc, #240]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd72:	f7f6 fbdf 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bd76:	4a3d      	ldr	r2, [pc, #244]	@ (3400be6c <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bd78:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bd7a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bd7e:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bd80:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bd84:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bd88:	3901      	subs	r1, #1
3400bd8a:	4303      	orrs	r3, r0
3400bd8c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bd90:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bd94:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bd98:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bd9c:	f8d4 0164 	ldr.w	r0, [r4, #356]	@ 0x164
3400bda0:	f7fe f9d8 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3400bda4:	6863      	ldr	r3, [r4, #4]
3400bda6:	0458      	lsls	r0, r3, #17
3400bda8:	d544      	bpl.n	3400be34 <HAL_RCCEx_PeriphCLKConfig+0x1b18>
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
3400bdaa:	f8d4 3168 	ldr.w	r3, [r4, #360]	@ 0x168
3400bdae:	4a36      	ldr	r2, [pc, #216]	@ (3400be88 <HAL_RCCEx_PeriphCLKConfig+0x1b6c>)
3400bdb0:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bdb4:	4291      	cmp	r1, r2
3400bdb6:	d00e      	beq.n	3400bdd6 <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400bdb8:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bdbc:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bdc0:	4291      	cmp	r1, r2
3400bdc2:	d008      	beq.n	3400bdd6 <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400bdc4:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bdc8:	4293      	cmp	r3, r2
3400bdca:	d004      	beq.n	3400bdd6 <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400bdcc:	f640 0133 	movw	r1, #2099	@ 0x833
3400bdd0:	4824      	ldr	r0, [pc, #144]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bdd2:	f7f6 fbaf 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3400bdd6:	f8d4 3168 	ldr.w	r3, [r4, #360]	@ 0x168
3400bdda:	4a2c      	ldr	r2, [pc, #176]	@ (3400be8c <HAL_RCCEx_PeriphCLKConfig+0x1b70>)
3400bddc:	4293      	cmp	r3, r2
3400bdde:	f041 8182 	bne.w	3400d0e6 <HAL_RCCEx_PeriphCLKConfig+0x2dca>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bde2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bde4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bde8:	d004      	beq.n	3400bdf4 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>
3400bdea:	f640 0138 	movw	r1, #2104	@ 0x838
3400bdee:	481d      	ldr	r0, [pc, #116]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bdf0:	f7f6 fba0 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bdf4:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bdf6:	3b01      	subs	r3, #1
3400bdf8:	2bff      	cmp	r3, #255	@ 0xff
3400bdfa:	d904      	bls.n	3400be06 <HAL_RCCEx_PeriphCLKConfig+0x1aea>
3400bdfc:	f640 0139 	movw	r1, #2105	@ 0x839
3400be00:	4818      	ldr	r0, [pc, #96]	@ (3400be64 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400be02:	f7f6 fb97 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400be06:	4a19      	ldr	r2, [pc, #100]	@ (3400be6c <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400be08:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400be0a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400be0e:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400be10:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400be14:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400be18:	3901      	subs	r1, #1
3400be1a:	4303      	orrs	r3, r0
3400be1c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400be20:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400be24:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400be28:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400be2c:	f8d4 0168 	ldr.w	r0, [r4, #360]	@ 0x168
3400be30:	f7fe f990 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
3400be34:	6863      	ldr	r3, [r4, #4]
3400be36:	0419      	lsls	r1, r3, #16
3400be38:	d560      	bpl.n	3400befc <HAL_RCCEx_PeriphCLKConfig+0x1be0>
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
3400be3a:	f8d4 316c 	ldr.w	r3, [r4, #364]	@ 0x16c
3400be3e:	4a14      	ldr	r2, [pc, #80]	@ (3400be90 <HAL_RCCEx_PeriphCLKConfig+0x1b74>)
3400be40:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400be44:	4291      	cmp	r1, r2
3400be46:	d02a      	beq.n	3400be9e <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400be48:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400be4c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400be50:	4291      	cmp	r1, r2
3400be52:	d024      	beq.n	3400be9e <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400be54:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400be58:	4293      	cmp	r3, r2
3400be5a:	d020      	beq.n	3400be9e <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400be5c:	e01a      	b.n	3400be94 <HAL_RCCEx_PeriphCLKConfig+0x1b78>
3400be5e:	bf00      	nop
3400be60:	07000830 	.word	0x07000830
3400be64:	3401c6ca 	.word	0x3401c6ca
3400be68:	07020830 	.word	0x07020830
3400be6c:	56028000 	.word	0x56028000
3400be70:	07000c30 	.word	0x07000c30
3400be74:	07020c30 	.word	0x07020c30
3400be78:	07001030 	.word	0x07001030
3400be7c:	07021030 	.word	0x07021030
3400be80:	07001430 	.word	0x07001430
3400be84:	07021430 	.word	0x07021430
3400be88:	07001830 	.word	0x07001830
3400be8c:	07021830 	.word	0x07021830
3400be90:	07001c30 	.word	0x07001c30
3400be94:	f44f 6106 	mov.w	r1, #2144	@ 0x860
3400be98:	48bb      	ldr	r0, [pc, #748]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400be9a:	f7f6 fb4b 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
3400be9e:	f8d4 316c 	ldr.w	r3, [r4, #364]	@ 0x16c
3400bea2:	4aba      	ldr	r2, [pc, #744]	@ (3400c18c <HAL_RCCEx_PeriphCLKConfig+0x1e70>)
3400bea4:	4293      	cmp	r3, r2
3400bea6:	f041 814f 	bne.w	3400d148 <HAL_RCCEx_PeriphCLKConfig+0x2e2c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400beaa:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400beac:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400beb0:	d004      	beq.n	3400bebc <HAL_RCCEx_PeriphCLKConfig+0x1ba0>
3400beb2:	f640 0165 	movw	r1, #2149	@ 0x865
3400beb6:	48b4      	ldr	r0, [pc, #720]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400beb8:	f7f6 fb3c 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bebc:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bebe:	3b01      	subs	r3, #1
3400bec0:	2bff      	cmp	r3, #255	@ 0xff
3400bec2:	d904      	bls.n	3400bece <HAL_RCCEx_PeriphCLKConfig+0x1bb2>
3400bec4:	f640 0166 	movw	r1, #2150	@ 0x866
3400bec8:	48af      	ldr	r0, [pc, #700]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400beca:	f7f6 fb33 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bece:	4ab0      	ldr	r2, [pc, #704]	@ (3400c190 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400bed0:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bed2:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bed6:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bed8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bedc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bee0:	3901      	subs	r1, #1
3400bee2:	4303      	orrs	r3, r0
3400bee4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bee8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400beec:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bef0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bef4:	f8d4 016c 	ldr.w	r0, [r4, #364]	@ 0x16c
3400bef8:	f7fe f92c 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3400befc:	6863      	ldr	r3, [r4, #4]
3400befe:	03da      	lsls	r2, r3, #15
3400bf00:	d544      	bpl.n	3400bf8c <HAL_RCCEx_PeriphCLKConfig+0x1c70>
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));
3400bf02:	f8d4 3170 	ldr.w	r3, [r4, #368]	@ 0x170
3400bf06:	4aa3      	ldr	r2, [pc, #652]	@ (3400c194 <HAL_RCCEx_PeriphCLKConfig+0x1e78>)
3400bf08:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bf0c:	4291      	cmp	r1, r2
3400bf0e:	d00e      	beq.n	3400bf2e <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400bf10:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bf14:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bf18:	4291      	cmp	r1, r2
3400bf1a:	d008      	beq.n	3400bf2e <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400bf1c:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bf20:	4293      	cmp	r3, r2
3400bf22:	d004      	beq.n	3400bf2e <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400bf24:	f640 018d 	movw	r1, #2189	@ 0x88d
3400bf28:	4897      	ldr	r0, [pc, #604]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bf2a:	f7f6 fb03 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3400bf2e:	f8d4 3170 	ldr.w	r3, [r4, #368]	@ 0x170
3400bf32:	4a99      	ldr	r2, [pc, #612]	@ (3400c198 <HAL_RCCEx_PeriphCLKConfig+0x1e7c>)
3400bf34:	4293      	cmp	r3, r2
3400bf36:	f041 8138 	bne.w	3400d1aa <HAL_RCCEx_PeriphCLKConfig+0x2e8e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bf3a:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bf3c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bf40:	d004      	beq.n	3400bf4c <HAL_RCCEx_PeriphCLKConfig+0x1c30>
3400bf42:	f640 0192 	movw	r1, #2194	@ 0x892
3400bf46:	4890      	ldr	r0, [pc, #576]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bf48:	f7f6 faf4 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bf4c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bf4e:	3b01      	subs	r3, #1
3400bf50:	2bff      	cmp	r3, #255	@ 0xff
3400bf52:	d904      	bls.n	3400bf5e <HAL_RCCEx_PeriphCLKConfig+0x1c42>
3400bf54:	f640 0193 	movw	r1, #2195	@ 0x893
3400bf58:	488b      	ldr	r0, [pc, #556]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bf5a:	f7f6 faeb 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bf5e:	4a8c      	ldr	r2, [pc, #560]	@ (3400c190 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400bf60:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bf62:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bf66:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bf68:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bf6c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bf70:	3901      	subs	r1, #1
3400bf72:	4303      	orrs	r3, r0
3400bf74:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bf78:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bf7c:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bf80:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bf84:	f8d4 0170 	ldr.w	r0, [r4, #368]	@ 0x170
3400bf88:	f7fe f8e4 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
3400bf8c:	6863      	ldr	r3, [r4, #4]
3400bf8e:	039b      	lsls	r3, r3, #14
3400bf90:	d544      	bpl.n	3400c01c <HAL_RCCEx_PeriphCLKConfig+0x1d00>
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));
3400bf92:	f8d4 3174 	ldr.w	r3, [r4, #372]	@ 0x174
3400bf96:	4a81      	ldr	r2, [pc, #516]	@ (3400c19c <HAL_RCCEx_PeriphCLKConfig+0x1e80>)
3400bf98:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bf9c:	4291      	cmp	r1, r2
3400bf9e:	d00e      	beq.n	3400bfbe <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400bfa0:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bfa4:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bfa8:	4291      	cmp	r1, r2
3400bfaa:	d008      	beq.n	3400bfbe <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400bfac:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bfb0:	4293      	cmp	r3, r2
3400bfb2:	d004      	beq.n	3400bfbe <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400bfb4:	f640 01ba 	movw	r1, #2234	@ 0x8ba
3400bfb8:	4873      	ldr	r0, [pc, #460]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bfba:	f7f6 fabb 	bl	34002534 <assert_failed>
    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3400bfbe:	f8d4 3174 	ldr.w	r3, [r4, #372]	@ 0x174
3400bfc2:	4a77      	ldr	r2, [pc, #476]	@ (3400c1a0 <HAL_RCCEx_PeriphCLKConfig+0x1e84>)
3400bfc4:	4293      	cmp	r3, r2
3400bfc6:	f041 8121 	bne.w	3400d20c <HAL_RCCEx_PeriphCLKConfig+0x2ef0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bfca:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bfcc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bfd0:	d004      	beq.n	3400bfdc <HAL_RCCEx_PeriphCLKConfig+0x1cc0>
3400bfd2:	f640 01bf 	movw	r1, #2239	@ 0x8bf
3400bfd6:	486c      	ldr	r0, [pc, #432]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bfd8:	f7f6 faac 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bfdc:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bfde:	3b01      	subs	r3, #1
3400bfe0:	2bff      	cmp	r3, #255	@ 0xff
3400bfe2:	d904      	bls.n	3400bfee <HAL_RCCEx_PeriphCLKConfig+0x1cd2>
3400bfe4:	f44f 610c 	mov.w	r1, #2240	@ 0x8c0
3400bfe8:	4867      	ldr	r0, [pc, #412]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bfea:	f7f6 faa3 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bfee:	4a68      	ldr	r2, [pc, #416]	@ (3400c190 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400bff0:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bff2:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bff6:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bff8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bffc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c000:	3901      	subs	r1, #1
3400c002:	4303      	orrs	r3, r0
3400c004:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c008:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c00c:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c010:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c014:	f8d4 0174 	ldr.w	r0, [r4, #372]	@ 0x174
3400c018:	f7fe f89c 	bl	3400a154 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3400c01c:	6863      	ldr	r3, [r4, #4]
3400c01e:	035e      	lsls	r6, r3, #13
3400c020:	d51e      	bpl.n	3400c060 <HAL_RCCEx_PeriphCLKConfig+0x1d44>
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));
3400c022:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3400c026:	4a5f      	ldr	r2, [pc, #380]	@ (3400c1a4 <HAL_RCCEx_PeriphCLKConfig+0x1e88>)
3400c028:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c02c:	4291      	cmp	r1, r2
3400c02e:	d00a      	beq.n	3400c046 <HAL_RCCEx_PeriphCLKConfig+0x1d2a>
3400c030:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c034:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
3400c038:	4293      	cmp	r3, r2
3400c03a:	d004      	beq.n	3400c046 <HAL_RCCEx_PeriphCLKConfig+0x1d2a>
3400c03c:	f640 01e7 	movw	r1, #2279	@ 0x8e7
3400c040:	4851      	ldr	r0, [pc, #324]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c042:	f7f6 fa77 	bl	34002534 <assert_failed>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400c046:	f8d4 0178 	ldr.w	r0, [r4, #376]	@ 0x178
  LL_RCC_SetClockSource(ClkSource);
3400c04a:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c04e:	f7fe f881 	bl	3400a154 <LL_RCC_SetClockSource>
3400c052:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3400c056:	2b00      	cmp	r3, #0
3400c058:	f281 8109 	bge.w	3400d26e <HAL_RCCEx_PeriphCLKConfig+0x2f52>
3400c05c:	f7fe f84a 	bl	3400a0f4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3400c060:	6863      	ldr	r3, [r4, #4]
3400c062:	02d8      	lsls	r0, r3, #11
3400c064:	d51e      	bpl.n	3400c0a4 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));
3400c066:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3400c06a:	4a4f      	ldr	r2, [pc, #316]	@ (3400c1a8 <HAL_RCCEx_PeriphCLKConfig+0x1e8c>)
3400c06c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c070:	4291      	cmp	r1, r2
3400c072:	d00a      	beq.n	3400c08a <HAL_RCCEx_PeriphCLKConfig+0x1d6e>
3400c074:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c078:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
3400c07c:	4293      	cmp	r3, r2
3400c07e:	d004      	beq.n	3400c08a <HAL_RCCEx_PeriphCLKConfig+0x1d6e>
3400c080:	f640 01f1 	movw	r1, #2289	@ 0x8f1
3400c084:	4840      	ldr	r0, [pc, #256]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c086:	f7f6 fa55 	bl	34002534 <assert_failed>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400c08a:	f8d4 0180 	ldr.w	r0, [r4, #384]	@ 0x180
3400c08e:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c092:	f7fe f85f 	bl	3400a154 <LL_RCC_SetClockSource>
3400c096:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3400c09a:	2b00      	cmp	r3, #0
3400c09c:	f281 80eb 	bge.w	3400d276 <HAL_RCCEx_PeriphCLKConfig+0x2f5a>
3400c0a0:	f7fe f828 	bl	3400a0f4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3400c0a4:	6863      	ldr	r3, [r4, #4]
3400c0a6:	0319      	lsls	r1, r3, #12
3400c0a8:	d549      	bpl.n	3400c13e <HAL_RCCEx_PeriphCLKConfig+0x1e22>
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));
3400c0aa:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c0ae:	4a3f      	ldr	r2, [pc, #252]	@ (3400c1ac <HAL_RCCEx_PeriphCLKConfig+0x1e90>)
3400c0b0:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c0b4:	4291      	cmp	r1, r2
3400c0b6:	d00a      	beq.n	3400c0ce <HAL_RCCEx_PeriphCLKConfig+0x1db2>
3400c0b8:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c0bc:	f502 3240 	add.w	r2, r2, #196608	@ 0x30000
3400c0c0:	4293      	cmp	r3, r2
3400c0c2:	d004      	beq.n	3400c0ce <HAL_RCCEx_PeriphCLKConfig+0x1db2>
3400c0c4:	f640 01fb 	movw	r1, #2299	@ 0x8fb
3400c0c8:	482f      	ldr	r0, [pc, #188]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c0ca:	f7f6 fa33 	bl	34002534 <assert_failed>
    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3400c0ce:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c0d2:	4a37      	ldr	r2, [pc, #220]	@ (3400c1b0 <HAL_RCCEx_PeriphCLKConfig+0x1e94>)
3400c0d4:	4293      	cmp	r3, r2
3400c0d6:	f041 80d2 	bne.w	3400d27e <HAL_RCCEx_PeriphCLKConfig+0x2f62>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c0da:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c0dc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c0e0:	d004      	beq.n	3400c0ec <HAL_RCCEx_PeriphCLKConfig+0x1dd0>
3400c0e2:	f44f 6110 	mov.w	r1, #2304	@ 0x900
3400c0e6:	4828      	ldr	r0, [pc, #160]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c0e8:	f7f6 fa24 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c0ec:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c0ee:	3b01      	subs	r3, #1
3400c0f0:	2bff      	cmp	r3, #255	@ 0xff
3400c0f2:	d904      	bls.n	3400c0fe <HAL_RCCEx_PeriphCLKConfig+0x1de2>
3400c0f4:	f640 1101 	movw	r1, #2305	@ 0x901
3400c0f8:	4823      	ldr	r0, [pc, #140]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c0fa:	f7f6 fa1b 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c0fe:	4a24      	ldr	r2, [pc, #144]	@ (3400c190 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c100:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c102:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c106:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c108:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c10c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c110:	3901      	subs	r1, #1
3400c112:	4303      	orrs	r3, r0
3400c114:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c118:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c11c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c120:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400c124:	f8d4 017c 	ldr.w	r0, [r4, #380]	@ 0x17c
  LL_RCC_SetClockSource(ClkSource);
3400c128:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c12c:	f7fe f812 	bl	3400a154 <LL_RCC_SetClockSource>
3400c130:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c134:	2b00      	cmp	r3, #0
3400c136:	f281 80ab 	bge.w	3400d290 <HAL_RCCEx_PeriphCLKConfig+0x2f74>
3400c13a:	f7fd ffdb 	bl	3400a0f4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3400c13e:	6863      	ldr	r3, [r4, #4]
3400c140:	029a      	lsls	r2, r3, #10
3400c142:	d564      	bpl.n	3400c20e <HAL_RCCEx_PeriphCLKConfig+0x1ef2>
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));
3400c144:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c148:	4a1a      	ldr	r2, [pc, #104]	@ (3400c1b4 <HAL_RCCEx_PeriphCLKConfig+0x1e98>)
3400c14a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c14e:	4291      	cmp	r1, r2
3400c150:	d00a      	beq.n	3400c168 <HAL_RCCEx_PeriphCLKConfig+0x1e4c>
3400c152:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c156:	f502 3240 	add.w	r2, r2, #196608	@ 0x30000
3400c15a:	4293      	cmp	r3, r2
3400c15c:	d004      	beq.n	3400c168 <HAL_RCCEx_PeriphCLKConfig+0x1e4c>
3400c15e:	f640 111b 	movw	r1, #2331	@ 0x91b
3400c162:	4809      	ldr	r0, [pc, #36]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c164:	f7f6 f9e6 	bl	34002534 <assert_failed>
    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3400c168:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c16c:	4a12      	ldr	r2, [pc, #72]	@ (3400c1b8 <HAL_RCCEx_PeriphCLKConfig+0x1e9c>)
3400c16e:	4293      	cmp	r3, r2
3400c170:	f041 8092 	bne.w	3400d298 <HAL_RCCEx_PeriphCLKConfig+0x2f7c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c174:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c176:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c17a:	d01f      	beq.n	3400c1bc <HAL_RCCEx_PeriphCLKConfig+0x1ea0>
3400c17c:	f44f 6112 	mov.w	r1, #2336	@ 0x920
3400c180:	4801      	ldr	r0, [pc, #4]	@ (3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c182:	f7f6 f9d7 	bl	34002534 <assert_failed>
3400c186:	e019      	b.n	3400c1bc <HAL_RCCEx_PeriphCLKConfig+0x1ea0>
3400c188:	3401c6ca 	.word	0x3401c6ca
3400c18c:	07021c30 	.word	0x07021c30
3400c190:	56028000 	.word	0x56028000
3400c194:	07000034 	.word	0x07000034
3400c198:	07020034 	.word	0x07020034
3400c19c:	07000434 	.word	0x07000434
3400c1a0:	07020434 	.word	0x07020434
3400c1a4:	01001014 	.word	0x01001014
3400c1a8:	01001814 	.word	0x01001814
3400c1ac:	03000c14 	.word	0x03000c14
3400c1b0:	03020c14 	.word	0x03020c14
3400c1b4:	03001414 	.word	0x03001414
3400c1b8:	03021414 	.word	0x03021414
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c1bc:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c1be:	3b01      	subs	r3, #1
3400c1c0:	2bff      	cmp	r3, #255	@ 0xff
3400c1c2:	d904      	bls.n	3400c1ce <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
3400c1c4:	f640 1121 	movw	r1, #2337	@ 0x921
3400c1c8:	48b1      	ldr	r0, [pc, #708]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c1ca:	f7f6 f9b3 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c1ce:	4ab1      	ldr	r2, [pc, #708]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c1d0:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c1d2:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c1d6:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c1d8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c1dc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c1e0:	3901      	subs	r1, #1
3400c1e2:	4303      	orrs	r3, r0
3400c1e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c1e8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c1ec:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c1f0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400c1f4:	f8d4 0184 	ldr.w	r0, [r4, #388]	@ 0x184
  LL_RCC_SetClockSource(ClkSource);
3400c1f8:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c1fc:	f7fd ffaa 	bl	3400a154 <LL_RCC_SetClockSource>
3400c200:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c204:	2b00      	cmp	r3, #0
3400c206:	f281 8050 	bge.w	3400d2aa <HAL_RCCEx_PeriphCLKConfig+0x2f8e>
3400c20a:	f7fd ff73 	bl	3400a0f4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
3400c20e:	6863      	ldr	r3, [r4, #4]
3400c210:	061b      	lsls	r3, r3, #24
3400c212:	d511      	bpl.n	3400c238 <HAL_RCCEx_PeriphCLKConfig+0x1f1c>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
3400c214:	f8d4 318c 	ldr.w	r3, [r4, #396]	@ 0x18c
3400c218:	2b03      	cmp	r3, #3
3400c21a:	d904      	bls.n	3400c226 <HAL_RCCEx_PeriphCLKConfig+0x1f0a>
3400c21c:	f640 113b 	movw	r1, #2363	@ 0x93b
3400c220:	489b      	ldr	r0, [pc, #620]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c222:	f7f6 f987 	bl	34002534 <assert_failed>
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400c226:	4a9b      	ldr	r2, [pc, #620]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c228:	f8d4 118c 	ldr.w	r1, [r4, #396]	@ 0x18c
3400c22c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400c22e:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400c232:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
3400c236:	6253      	str	r3, [r2, #36]	@ 0x24
}
3400c238:	1e28      	subs	r0, r5, #0
3400c23a:	bf18      	it	ne
3400c23c:	2001      	movne	r0, #1
3400c23e:	bd70      	pop	{r4, r5, r6, pc}
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400c240:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400c242:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c246:	d003      	beq.n	3400c250 <HAL_RCCEx_PeriphCLKConfig+0x1f34>
3400c248:	21f1      	movs	r1, #241	@ 0xf1
3400c24a:	4891      	ldr	r0, [pc, #580]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c24c:	f7f6 f972 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400c250:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400c252:	3b01      	subs	r3, #1
3400c254:	2bff      	cmp	r3, #255	@ 0xff
3400c256:	d903      	bls.n	3400c260 <HAL_RCCEx_PeriphCLKConfig+0x1f44>
3400c258:	21f2      	movs	r1, #242	@ 0xf2
3400c25a:	488d      	ldr	r0, [pc, #564]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c25c:	f7f6 f96a 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400c260:	4a8c      	ldr	r2, [pc, #560]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c262:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400c264:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400c268:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400c26a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c26e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c272:	3901      	subs	r1, #1
3400c274:	4303      	orrs	r3, r0
3400c276:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c27a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400c27e:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400c282:	f7fe b941 	b.w	3400a508 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c286:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c288:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c28c:	d003      	beq.n	3400c296 <HAL_RCCEx_PeriphCLKConfig+0x1f7a>
3400c28e:	21fe      	movs	r1, #254	@ 0xfe
3400c290:	487f      	ldr	r0, [pc, #508]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c292:	f7f6 f94f 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c296:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c298:	3b01      	subs	r3, #1
3400c29a:	2bff      	cmp	r3, #255	@ 0xff
3400c29c:	d903      	bls.n	3400c2a6 <HAL_RCCEx_PeriphCLKConfig+0x1f8a>
3400c29e:	21ff      	movs	r1, #255	@ 0xff
3400c2a0:	487b      	ldr	r0, [pc, #492]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c2a2:	f7f6 f947 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c2a6:	4a7b      	ldr	r2, [pc, #492]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c2a8:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c2aa:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c2ae:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c2b0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c2b4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c2b8:	3901      	subs	r1, #1
3400c2ba:	4303      	orrs	r3, r0
3400c2bc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c2c0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c2c4:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c2c8:	f7fe b91e 	b.w	3400a508 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400c2cc:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400c2d0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c2d4:	d004      	beq.n	3400c2e0 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
3400c2d6:	f240 110b 	movw	r1, #267	@ 0x10b
3400c2da:	486d      	ldr	r0, [pc, #436]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c2dc:	f7f6 f92a 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400c2e0:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
3400c2e4:	3b01      	subs	r3, #1
3400c2e6:	2bff      	cmp	r3, #255	@ 0xff
3400c2e8:	d904      	bls.n	3400c2f4 <HAL_RCCEx_PeriphCLKConfig+0x1fd8>
3400c2ea:	f44f 7186 	mov.w	r1, #268	@ 0x10c
3400c2ee:	4868      	ldr	r0, [pc, #416]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c2f0:	f7f6 f920 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400c2f4:	4a67      	ldr	r2, [pc, #412]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c2f6:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
3400c2fa:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3400c2fe:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
3400c302:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c306:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c30a:	3901      	subs	r1, #1
3400c30c:	4303      	orrs	r3, r0
3400c30e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c312:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400c316:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3400c31a:	f7fe b8f5 	b.w	3400a508 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400c31e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400c322:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c326:	d004      	beq.n	3400c332 <HAL_RCCEx_PeriphCLKConfig+0x2016>
3400c328:	f44f 718c 	mov.w	r1, #280	@ 0x118
3400c32c:	4858      	ldr	r0, [pc, #352]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c32e:	f7f6 f901 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400c332:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
3400c336:	3b01      	subs	r3, #1
3400c338:	2bff      	cmp	r3, #255	@ 0xff
3400c33a:	d904      	bls.n	3400c346 <HAL_RCCEx_PeriphCLKConfig+0x202a>
3400c33c:	f240 1119 	movw	r1, #281	@ 0x119
3400c340:	4853      	ldr	r0, [pc, #332]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c342:	f7f6 f8f7 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400c346:	4a53      	ldr	r2, [pc, #332]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c348:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
3400c34c:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3400c350:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
3400c354:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c358:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c35c:	3901      	subs	r1, #1
3400c35e:	4303      	orrs	r3, r0
3400c360:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c364:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400c368:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3400c36c:	f7fe b8cc 	b.w	3400a508 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3400c370:	4a49      	ldr	r2, [pc, #292]	@ (3400c498 <HAL_RCCEx_PeriphCLKConfig+0x217c>)
3400c372:	4293      	cmp	r3, r2
3400c374:	d123      	bne.n	3400c3be <HAL_RCCEx_PeriphCLKConfig+0x20a2>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c376:	6a23      	ldr	r3, [r4, #32]
3400c378:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c37c:	d004      	beq.n	3400c388 <HAL_RCCEx_PeriphCLKConfig+0x206c>
3400c37e:	f240 1141 	movw	r1, #321	@ 0x141
3400c382:	4843      	ldr	r0, [pc, #268]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c384:	f7f6 f8d6 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c388:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c38a:	3b01      	subs	r3, #1
3400c38c:	2bff      	cmp	r3, #255	@ 0xff
3400c38e:	d904      	bls.n	3400c39a <HAL_RCCEx_PeriphCLKConfig+0x207e>
3400c390:	f44f 71a1 	mov.w	r1, #322	@ 0x142
3400c394:	483e      	ldr	r0, [pc, #248]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c396:	f7f6 f8cd 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c39a:	4a3e      	ldr	r2, [pc, #248]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c39c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c39e:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c3a2:	6a20      	ldr	r0, [r4, #32]
3400c3a4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c3a8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c3ac:	3901      	subs	r1, #1
3400c3ae:	4303      	orrs	r3, r0
3400c3b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c3b4:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c3b8:	2308      	movs	r3, #8
3400c3ba:	f7fe b8e8 	b.w	3400a58e <HAL_RCCEx_PeriphCLKConfig+0x272>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3400c3be:	4a37      	ldr	r2, [pc, #220]	@ (3400c49c <HAL_RCCEx_PeriphCLKConfig+0x2180>)
3400c3c0:	4293      	cmp	r3, r2
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c3c2:	bf02      	ittt	eq
3400c3c4:	2240      	moveq	r2, #64	@ 0x40
3400c3c6:	4b33      	ldreq	r3, [pc, #204]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c3c8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c3cc:	f7fe b8e1 	b.w	3400a592 <HAL_RCCEx_PeriphCLKConfig+0x276>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3400c3d0:	4a33      	ldr	r2, [pc, #204]	@ (3400c4a0 <HAL_RCCEx_PeriphCLKConfig+0x2184>)
3400c3d2:	4293      	cmp	r3, r2
3400c3d4:	d123      	bne.n	3400c41e <HAL_RCCEx_PeriphCLKConfig+0x2102>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c3d6:	6a23      	ldr	r3, [r4, #32]
3400c3d8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c3dc:	d004      	beq.n	3400c3e8 <HAL_RCCEx_PeriphCLKConfig+0x20cc>
3400c3de:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3400c3e2:	482b      	ldr	r0, [pc, #172]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c3e4:	f7f6 f8a6 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c3e8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c3ea:	3b01      	subs	r3, #1
3400c3ec:	2bff      	cmp	r3, #255	@ 0xff
3400c3ee:	d904      	bls.n	3400c3fa <HAL_RCCEx_PeriphCLKConfig+0x20de>
3400c3f0:	f240 116f 	movw	r1, #367	@ 0x16f
3400c3f4:	4826      	ldr	r0, [pc, #152]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c3f6:	f7f6 f89d 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c3fa:	4a26      	ldr	r2, [pc, #152]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c3fc:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c3fe:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c402:	6a20      	ldr	r0, [r4, #32]
3400c404:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c408:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c40c:	3901      	subs	r1, #1
3400c40e:	4303      	orrs	r3, r0
3400c410:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c414:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c418:	2308      	movs	r3, #8
3400c41a:	f7fe b8f5 	b.w	3400a608 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3400c41e:	4a21      	ldr	r2, [pc, #132]	@ (3400c4a4 <HAL_RCCEx_PeriphCLKConfig+0x2188>)
3400c420:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c422:	bf02      	ittt	eq
3400c424:	2240      	moveq	r2, #64	@ 0x40
3400c426:	4b1b      	ldreq	r3, [pc, #108]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c428:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c42c:	f7fe b8ee 	b.w	3400a60c <HAL_RCCEx_PeriphCLKConfig+0x2f0>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3400c430:	4a1d      	ldr	r2, [pc, #116]	@ (3400c4a8 <HAL_RCCEx_PeriphCLKConfig+0x218c>)
3400c432:	4293      	cmp	r3, r2
3400c434:	d123      	bne.n	3400c47e <HAL_RCCEx_PeriphCLKConfig+0x2162>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c436:	6a23      	ldr	r3, [r4, #32]
3400c438:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c43c:	d004      	beq.n	3400c448 <HAL_RCCEx_PeriphCLKConfig+0x212c>
3400c43e:	f240 119b 	movw	r1, #411	@ 0x19b
3400c442:	4813      	ldr	r0, [pc, #76]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c444:	f7f6 f876 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c448:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c44a:	3b01      	subs	r3, #1
3400c44c:	2bff      	cmp	r3, #255	@ 0xff
3400c44e:	d904      	bls.n	3400c45a <HAL_RCCEx_PeriphCLKConfig+0x213e>
3400c450:	f44f 71ce 	mov.w	r1, #412	@ 0x19c
3400c454:	480e      	ldr	r0, [pc, #56]	@ (3400c490 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c456:	f7f6 f86d 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c45a:	4a0e      	ldr	r2, [pc, #56]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c45c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c45e:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c462:	6a20      	ldr	r0, [r4, #32]
3400c464:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c468:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c46c:	3901      	subs	r1, #1
3400c46e:	4303      	orrs	r3, r0
3400c470:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c474:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c478:	2308      	movs	r3, #8
3400c47a:	f7fe b902 	b.w	3400a682 <HAL_RCCEx_PeriphCLKConfig+0x366>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3400c47e:	4a0b      	ldr	r2, [pc, #44]	@ (3400c4ac <HAL_RCCEx_PeriphCLKConfig+0x2190>)
3400c480:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c482:	bf02      	ittt	eq
3400c484:	2240      	moveq	r2, #64	@ 0x40
3400c486:	4b03      	ldreq	r3, [pc, #12]	@ (3400c494 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c488:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c48c:	f7fe b8fb 	b.w	3400a686 <HAL_RCCEx_PeriphCLKConfig+0x36a>
3400c490:	3401c6ca 	.word	0x3401c6ca
3400c494:	56028000 	.word	0x56028000
3400c498:	03030014 	.word	0x03030014
3400c49c:	03010014 	.word	0x03010014
3400c4a0:	03030414 	.word	0x03030414
3400c4a4:	03010414 	.word	0x03010414
3400c4a8:	03030814 	.word	0x03030814
3400c4ac:	03010814 	.word	0x03010814
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3400c4b0:	2b30      	cmp	r3, #48	@ 0x30
3400c4b2:	d123      	bne.n	3400c4fc <HAL_RCCEx_PeriphCLKConfig+0x21e0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c4b4:	6a23      	ldr	r3, [r4, #32]
3400c4b6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c4ba:	d004      	beq.n	3400c4c6 <HAL_RCCEx_PeriphCLKConfig+0x21aa>
3400c4bc:	f44f 71e4 	mov.w	r1, #456	@ 0x1c8
3400c4c0:	48b2      	ldr	r0, [pc, #712]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c4c2:	f7f6 f837 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c4c6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c4c8:	3b01      	subs	r3, #1
3400c4ca:	2bff      	cmp	r3, #255	@ 0xff
3400c4cc:	d904      	bls.n	3400c4d8 <HAL_RCCEx_PeriphCLKConfig+0x21bc>
3400c4ce:	f240 11c9 	movw	r1, #457	@ 0x1c9
3400c4d2:	48ae      	ldr	r0, [pc, #696]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c4d4:	f7f6 f82e 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c4d8:	4aad      	ldr	r2, [pc, #692]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c4da:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c4dc:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c4e0:	6a20      	ldr	r0, [r4, #32]
3400c4e2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c4e6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c4ea:	3901      	subs	r1, #1
3400c4ec:	4303      	orrs	r3, r0
3400c4ee:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c4f2:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c4f6:	2308      	movs	r3, #8
3400c4f8:	f7fe b8fd 	b.w	3400a6f6 <HAL_RCCEx_PeriphCLKConfig+0x3da>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3400c4fc:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c4fe:	bf02      	ittt	eq
3400c500:	2240      	moveq	r2, #64	@ 0x40
3400c502:	4ba3      	ldreq	r3, [pc, #652]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c504:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c508:	f7fe b8f7 	b.w	3400a6fa <HAL_RCCEx_PeriphCLKConfig+0x3de>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3400c50c:	4aa1      	ldr	r2, [pc, #644]	@ (3400c794 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400c50e:	4293      	cmp	r3, r2
3400c510:	d123      	bne.n	3400c55a <HAL_RCCEx_PeriphCLKConfig+0x223e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400c512:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400c514:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c518:	d004      	beq.n	3400c524 <HAL_RCCEx_PeriphCLKConfig+0x2208>
3400c51a:	f240 11f5 	movw	r1, #501	@ 0x1f5
3400c51e:	489b      	ldr	r0, [pc, #620]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c520:	f7f6 f808 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400c524:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400c526:	3b01      	subs	r3, #1
3400c528:	2bff      	cmp	r3, #255	@ 0xff
3400c52a:	d904      	bls.n	3400c536 <HAL_RCCEx_PeriphCLKConfig+0x221a>
3400c52c:	f44f 71fb 	mov.w	r1, #502	@ 0x1f6
3400c530:	4896      	ldr	r0, [pc, #600]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c532:	f7f5 ffff 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400c536:	4a96      	ldr	r2, [pc, #600]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c538:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400c53a:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400c53e:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400c540:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c544:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c548:	3901      	subs	r1, #1
3400c54a:	4303      	orrs	r3, r0
3400c54c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c550:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400c554:	2310      	movs	r3, #16
3400c556:	f7fe b911 	b.w	3400a77c <HAL_RCCEx_PeriphCLKConfig+0x460>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3400c55a:	4a8f      	ldr	r2, [pc, #572]	@ (3400c798 <HAL_RCCEx_PeriphCLKConfig+0x247c>)
3400c55c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c55e:	bf02      	ittt	eq
3400c560:	2240      	moveq	r2, #64	@ 0x40
3400c562:	4b8b      	ldreq	r3, [pc, #556]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c564:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c568:	f7fe b90a 	b.w	3400a780 <HAL_RCCEx_PeriphCLKConfig+0x464>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3400c56c:	4a8b      	ldr	r2, [pc, #556]	@ (3400c79c <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400c56e:	4293      	cmp	r3, r2
3400c570:	d123      	bne.n	3400c5ba <HAL_RCCEx_PeriphCLKConfig+0x229e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400c572:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400c574:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c578:	d004      	beq.n	3400c584 <HAL_RCCEx_PeriphCLKConfig+0x2268>
3400c57a:	f240 2122 	movw	r1, #546	@ 0x222
3400c57e:	4883      	ldr	r0, [pc, #524]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c580:	f7f5 ffd8 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400c584:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400c586:	3b01      	subs	r3, #1
3400c588:	2bff      	cmp	r3, #255	@ 0xff
3400c58a:	d904      	bls.n	3400c596 <HAL_RCCEx_PeriphCLKConfig+0x227a>
3400c58c:	f240 2123 	movw	r1, #547	@ 0x223
3400c590:	487e      	ldr	r0, [pc, #504]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c592:	f7f5 ffcf 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400c596:	4a7e      	ldr	r2, [pc, #504]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c598:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400c59a:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400c59e:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400c5a0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c5a4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c5a8:	3901      	subs	r1, #1
3400c5aa:	4303      	orrs	r3, r0
3400c5ac:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c5b0:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400c5b4:	2310      	movs	r3, #16
3400c5b6:	f7fe b938 	b.w	3400a82a <HAL_RCCEx_PeriphCLKConfig+0x50e>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
3400c5ba:	4a79      	ldr	r2, [pc, #484]	@ (3400c7a0 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
3400c5bc:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c5be:	bf02      	ittt	eq
3400c5c0:	2240      	moveq	r2, #64	@ 0x40
3400c5c2:	4b73      	ldreq	r3, [pc, #460]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c5c4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c5c8:	f7fe b931 	b.w	3400a82e <HAL_RCCEx_PeriphCLKConfig+0x512>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3400c5cc:	2b30      	cmp	r3, #48	@ 0x30
3400c5ce:	d123      	bne.n	3400c618 <HAL_RCCEx_PeriphCLKConfig+0x22fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400c5d0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400c5d2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c5d6:	d004      	beq.n	3400c5e2 <HAL_RCCEx_PeriphCLKConfig+0x22c6>
3400c5d8:	f44f 7114 	mov.w	r1, #592	@ 0x250
3400c5dc:	486b      	ldr	r0, [pc, #428]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c5de:	f7f5 ffa9 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400c5e2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400c5e4:	3b01      	subs	r3, #1
3400c5e6:	2bff      	cmp	r3, #255	@ 0xff
3400c5e8:	d904      	bls.n	3400c5f4 <HAL_RCCEx_PeriphCLKConfig+0x22d8>
3400c5ea:	f240 2151 	movw	r1, #593	@ 0x251
3400c5ee:	4867      	ldr	r0, [pc, #412]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c5f0:	f7f5 ffa0 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400c5f4:	4a66      	ldr	r2, [pc, #408]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c5f6:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400c5f8:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400c5fc:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400c5fe:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c602:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c606:	3901      	subs	r1, #1
3400c608:	4303      	orrs	r3, r0
3400c60a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c60e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400c612:	2380      	movs	r3, #128	@ 0x80
3400c614:	f7fe b94f 	b.w	3400a8b6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3400c618:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c61a:	bf02      	ittt	eq
3400c61c:	2240      	moveq	r2, #64	@ 0x40
3400c61e:	4b5c      	ldreq	r3, [pc, #368]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c620:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c624:	f7fe b949 	b.w	3400a8ba <HAL_RCCEx_PeriphCLKConfig+0x59e>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3400c628:	2b03      	cmp	r3, #3
3400c62a:	d123      	bne.n	3400c674 <HAL_RCCEx_PeriphCLKConfig+0x2358>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400c62c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400c62e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c632:	d004      	beq.n	3400c63e <HAL_RCCEx_PeriphCLKConfig+0x2322>
3400c634:	f240 217e 	movw	r1, #638	@ 0x27e
3400c638:	4854      	ldr	r0, [pc, #336]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c63a:	f7f5 ff7b 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400c63e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400c640:	3b01      	subs	r3, #1
3400c642:	2bff      	cmp	r3, #255	@ 0xff
3400c644:	d904      	bls.n	3400c650 <HAL_RCCEx_PeriphCLKConfig+0x2334>
3400c646:	f240 217f 	movw	r1, #639	@ 0x27f
3400c64a:	4850      	ldr	r0, [pc, #320]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c64c:	f7f5 ff72 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400c650:	4a4f      	ldr	r2, [pc, #316]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c652:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400c654:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400c658:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400c65a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c65e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c662:	3901      	subs	r1, #1
3400c664:	4303      	orrs	r3, r0
3400c666:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c66a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400c66e:	2380      	movs	r3, #128	@ 0x80
3400c670:	f7fe b967 	b.w	3400a942 <HAL_RCCEx_PeriphCLKConfig+0x626>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
3400c674:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c676:	bf02      	ittt	eq
3400c678:	2240      	moveq	r2, #64	@ 0x40
3400c67a:	4b45      	ldreq	r3, [pc, #276]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c67c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c680:	f7fe b961 	b.w	3400a946 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3400c684:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c688:	bf02      	ittt	eq
3400c68a:	2240      	moveq	r2, #64	@ 0x40
3400c68c:	4b40      	ldreq	r3, [pc, #256]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c68e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c692:	f7fe b9ca 	b.w	3400aa2a <HAL_RCCEx_PeriphCLKConfig+0x70e>
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
3400c696:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c69a:	bf02      	ittt	eq
3400c69c:	2240      	moveq	r2, #64	@ 0x40
3400c69e:	4b3c      	ldreq	r3, [pc, #240]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c6a0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c6a4:	f7fe ba03 	b.w	3400aaae <HAL_RCCEx_PeriphCLKConfig+0x792>
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
3400c6a8:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c6aa:	bf02      	ittt	eq
3400c6ac:	2240      	moveq	r2, #64	@ 0x40
3400c6ae:	4b38      	ldreq	r3, [pc, #224]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c6b0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c6b4:	f7fe ba92 	b.w	3400abdc <HAL_RCCEx_PeriphCLKConfig+0x8c0>
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3400c6b8:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c6ba:	bf02      	ittt	eq
3400c6bc:	2240      	moveq	r2, #64	@ 0x40
3400c6be:	4b34      	ldreq	r3, [pc, #208]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c6c0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c6c4:	f7fe bad3 	b.w	3400ac6e <HAL_RCCEx_PeriphCLKConfig+0x952>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3400c6c8:	4a36      	ldr	r2, [pc, #216]	@ (3400c7a4 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
3400c6ca:	4293      	cmp	r3, r2
3400c6cc:	d124      	bne.n	3400c718 <HAL_RCCEx_PeriphCLKConfig+0x23fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c6ce:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c6d0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c6d4:	d004      	beq.n	3400c6e0 <HAL_RCCEx_PeriphCLKConfig+0x23c4>
3400c6d6:	f240 315a 	movw	r1, #858	@ 0x35a
3400c6da:	482c      	ldr	r0, [pc, #176]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c6dc:	f7f5 ff2a 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c6e0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c6e2:	3b01      	subs	r3, #1
3400c6e4:	2bff      	cmp	r3, #255	@ 0xff
3400c6e6:	d904      	bls.n	3400c6f2 <HAL_RCCEx_PeriphCLKConfig+0x23d6>
3400c6e8:	f240 315b 	movw	r1, #859	@ 0x35b
3400c6ec:	4827      	ldr	r0, [pc, #156]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c6ee:	f7f5 ff21 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c6f2:	4a27      	ldr	r2, [pc, #156]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c6f4:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c6f6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c6fa:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c6fc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c700:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c704:	3901      	subs	r1, #1
3400c706:	4303      	orrs	r3, r0
3400c708:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c70c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c710:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c714:	f7fe baf3 	b.w	3400acfe <HAL_RCCEx_PeriphCLKConfig+0x9e2>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3400c718:	4a23      	ldr	r2, [pc, #140]	@ (3400c7a8 <HAL_RCCEx_PeriphCLKConfig+0x248c>)
3400c71a:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c71c:	bf02      	ittt	eq
3400c71e:	2240      	moveq	r2, #64	@ 0x40
3400c720:	4b1b      	ldreq	r3, [pc, #108]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c722:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c726:	f7fe baec 	b.w	3400ad02 <HAL_RCCEx_PeriphCLKConfig+0x9e6>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400c72a:	4a20      	ldr	r2, [pc, #128]	@ (3400c7ac <HAL_RCCEx_PeriphCLKConfig+0x2490>)
3400c72c:	4293      	cmp	r3, r2
3400c72e:	d124      	bne.n	3400c77a <HAL_RCCEx_PeriphCLKConfig+0x245e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c730:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c732:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c736:	d004      	beq.n	3400c742 <HAL_RCCEx_PeriphCLKConfig+0x2426>
3400c738:	f240 3187 	movw	r1, #903	@ 0x387
3400c73c:	4813      	ldr	r0, [pc, #76]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c73e:	f7f5 fef9 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c742:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c744:	3b01      	subs	r3, #1
3400c746:	2bff      	cmp	r3, #255	@ 0xff
3400c748:	d904      	bls.n	3400c754 <HAL_RCCEx_PeriphCLKConfig+0x2438>
3400c74a:	f44f 7162 	mov.w	r1, #904	@ 0x388
3400c74e:	480f      	ldr	r0, [pc, #60]	@ (3400c78c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c750:	f7f5 fef0 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c754:	4a0e      	ldr	r2, [pc, #56]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c756:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c758:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c75c:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c75e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c762:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c766:	3901      	subs	r1, #1
3400c768:	4303      	orrs	r3, r0
3400c76a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c76e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c772:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c776:	f7fe bb06 	b.w	3400ad86 <HAL_RCCEx_PeriphCLKConfig+0xa6a>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3400c77a:	4a0d      	ldr	r2, [pc, #52]	@ (3400c7b0 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
3400c77c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c77e:	bf02      	ittt	eq
3400c780:	2240      	moveq	r2, #64	@ 0x40
3400c782:	4b03      	ldreq	r3, [pc, #12]	@ (3400c790 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c784:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c788:	f7fe baff 	b.w	3400ad8a <HAL_RCCEx_PeriphCLKConfig+0xa6e>
3400c78c:	3401c6ca 	.word	0x3401c6ca
3400c790:	56028000 	.word	0x56028000
3400c794:	0303001c 	.word	0x0303001c
3400c798:	0301001c 	.word	0x0301001c
3400c79c:	0303041c 	.word	0x0303041c
3400c7a0:	0301041c 	.word	0x0301041c
3400c7a4:	0703000c 	.word	0x0703000c
3400c7a8:	0701000c 	.word	0x0701000c
3400c7ac:	0703040c 	.word	0x0703040c
3400c7b0:	0701040c 	.word	0x0701040c
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
3400c7b4:	4ab1      	ldr	r2, [pc, #708]	@ (3400ca7c <HAL_RCCEx_PeriphCLKConfig+0x2760>)
3400c7b6:	4293      	cmp	r3, r2
3400c7b8:	d124      	bne.n	3400c804 <HAL_RCCEx_PeriphCLKConfig+0x24e8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c7ba:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c7bc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c7c0:	d004      	beq.n	3400c7cc <HAL_RCCEx_PeriphCLKConfig+0x24b0>
3400c7c2:	f44f 716d 	mov.w	r1, #948	@ 0x3b4
3400c7c6:	48ae      	ldr	r0, [pc, #696]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c7c8:	f7f5 feb4 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c7cc:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c7ce:	3b01      	subs	r3, #1
3400c7d0:	2bff      	cmp	r3, #255	@ 0xff
3400c7d2:	d904      	bls.n	3400c7de <HAL_RCCEx_PeriphCLKConfig+0x24c2>
3400c7d4:	f240 31b5 	movw	r1, #949	@ 0x3b5
3400c7d8:	48a9      	ldr	r0, [pc, #676]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c7da:	f7f5 feab 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c7de:	4aa9      	ldr	r2, [pc, #676]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c7e0:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c7e2:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c7e6:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c7e8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c7ec:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c7f0:	3901      	subs	r1, #1
3400c7f2:	4303      	orrs	r3, r0
3400c7f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c7f8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c7fc:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c800:	f7fe bb05 	b.w	3400ae0e <HAL_RCCEx_PeriphCLKConfig+0xaf2>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
3400c804:	4aa0      	ldr	r2, [pc, #640]	@ (3400ca88 <HAL_RCCEx_PeriphCLKConfig+0x276c>)
3400c806:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c808:	bf02      	ittt	eq
3400c80a:	2240      	moveq	r2, #64	@ 0x40
3400c80c:	4b9d      	ldreq	r3, [pc, #628]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c80e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c812:	f7fe bafe 	b.w	3400ae12 <HAL_RCCEx_PeriphCLKConfig+0xaf6>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3400c816:	4a9d      	ldr	r2, [pc, #628]	@ (3400ca8c <HAL_RCCEx_PeriphCLKConfig+0x2770>)
3400c818:	4293      	cmp	r3, r2
3400c81a:	d124      	bne.n	3400c866 <HAL_RCCEx_PeriphCLKConfig+0x254a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c81c:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c81e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c822:	d004      	beq.n	3400c82e <HAL_RCCEx_PeriphCLKConfig+0x2512>
3400c824:	f240 31e1 	movw	r1, #993	@ 0x3e1
3400c828:	4895      	ldr	r0, [pc, #596]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c82a:	f7f5 fe83 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c82e:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c830:	3b01      	subs	r3, #1
3400c832:	2bff      	cmp	r3, #255	@ 0xff
3400c834:	d904      	bls.n	3400c840 <HAL_RCCEx_PeriphCLKConfig+0x2524>
3400c836:	f240 31e2 	movw	r1, #994	@ 0x3e2
3400c83a:	4891      	ldr	r0, [pc, #580]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c83c:	f7f5 fe7a 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c840:	4a90      	ldr	r2, [pc, #576]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c842:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c844:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c848:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c84a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c84e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c852:	3901      	subs	r1, #1
3400c854:	4303      	orrs	r3, r0
3400c856:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c85a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c85e:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c862:	f7fe bb2c 	b.w	3400aebe <HAL_RCCEx_PeriphCLKConfig+0xba2>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3400c866:	4a8a      	ldr	r2, [pc, #552]	@ (3400ca90 <HAL_RCCEx_PeriphCLKConfig+0x2774>)
3400c868:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c86a:	bf02      	ittt	eq
3400c86c:	2240      	moveq	r2, #64	@ 0x40
3400c86e:	4b85      	ldreq	r3, [pc, #532]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c870:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c874:	f7fe bb25 	b.w	3400aec2 <HAL_RCCEx_PeriphCLKConfig+0xba6>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
3400c878:	4a86      	ldr	r2, [pc, #536]	@ (3400ca94 <HAL_RCCEx_PeriphCLKConfig+0x2778>)
3400c87a:	4293      	cmp	r3, r2
3400c87c:	d124      	bne.n	3400c8c8 <HAL_RCCEx_PeriphCLKConfig+0x25ac>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c87e:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c880:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c884:	d004      	beq.n	3400c890 <HAL_RCCEx_PeriphCLKConfig+0x2574>
3400c886:	f240 410e 	movw	r1, #1038	@ 0x40e
3400c88a:	487d      	ldr	r0, [pc, #500]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c88c:	f7f5 fe52 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c890:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c892:	3b01      	subs	r3, #1
3400c894:	2bff      	cmp	r3, #255	@ 0xff
3400c896:	d904      	bls.n	3400c8a2 <HAL_RCCEx_PeriphCLKConfig+0x2586>
3400c898:	f240 410f 	movw	r1, #1039	@ 0x40f
3400c89c:	4878      	ldr	r0, [pc, #480]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c89e:	f7f5 fe49 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c8a2:	4a78      	ldr	r2, [pc, #480]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c8a4:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c8a6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c8aa:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c8ac:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c8b0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c8b4:	3901      	subs	r1, #1
3400c8b6:	4303      	orrs	r3, r0
3400c8b8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c8bc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c8c0:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c8c4:	f7fe bb3f 	b.w	3400af46 <HAL_RCCEx_PeriphCLKConfig+0xc2a>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3400c8c8:	4a73      	ldr	r2, [pc, #460]	@ (3400ca98 <HAL_RCCEx_PeriphCLKConfig+0x277c>)
3400c8ca:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c8cc:	bf02      	ittt	eq
3400c8ce:	2240      	moveq	r2, #64	@ 0x40
3400c8d0:	4b6c      	ldreq	r3, [pc, #432]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c8d2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c8d6:	f7fe bb38 	b.w	3400af4a <HAL_RCCEx_PeriphCLKConfig+0xc2e>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3400c8da:	4a70      	ldr	r2, [pc, #448]	@ (3400ca9c <HAL_RCCEx_PeriphCLKConfig+0x2780>)
3400c8dc:	4293      	cmp	r3, r2
3400c8de:	d124      	bne.n	3400c92a <HAL_RCCEx_PeriphCLKConfig+0x260e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c8e0:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c8e2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c8e6:	d004      	beq.n	3400c8f2 <HAL_RCCEx_PeriphCLKConfig+0x25d6>
3400c8e8:	f240 413b 	movw	r1, #1083	@ 0x43b
3400c8ec:	4864      	ldr	r0, [pc, #400]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c8ee:	f7f5 fe21 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c8f2:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c8f4:	3b01      	subs	r3, #1
3400c8f6:	2bff      	cmp	r3, #255	@ 0xff
3400c8f8:	d904      	bls.n	3400c904 <HAL_RCCEx_PeriphCLKConfig+0x25e8>
3400c8fa:	f240 413c 	movw	r1, #1084	@ 0x43c
3400c8fe:	4860      	ldr	r0, [pc, #384]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c900:	f7f5 fe18 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c904:	4a5f      	ldr	r2, [pc, #380]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c906:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c908:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c90c:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c90e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c912:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c916:	3901      	subs	r1, #1
3400c918:	4303      	orrs	r3, r0
3400c91a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c91e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c922:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c926:	f7fe bb52 	b.w	3400afce <HAL_RCCEx_PeriphCLKConfig+0xcb2>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3400c92a:	4a5d      	ldr	r2, [pc, #372]	@ (3400caa0 <HAL_RCCEx_PeriphCLKConfig+0x2784>)
3400c92c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c92e:	bf02      	ittt	eq
3400c930:	2240      	moveq	r2, #64	@ 0x40
3400c932:	4b54      	ldreq	r3, [pc, #336]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c934:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c938:	f7fe bb4b 	b.w	3400afd2 <HAL_RCCEx_PeriphCLKConfig+0xcb6>
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3400c93c:	4a59      	ldr	r2, [pc, #356]	@ (3400caa4 <HAL_RCCEx_PeriphCLKConfig+0x2788>)
3400c93e:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c940:	bf02      	ittt	eq
3400c942:	2240      	moveq	r2, #64	@ 0x40
3400c944:	4b4f      	ldreq	r3, [pc, #316]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c946:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c94a:	f7fe bb86 	b.w	3400b05a <HAL_RCCEx_PeriphCLKConfig+0xd3e>
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3400c94e:	4a56      	ldr	r2, [pc, #344]	@ (3400caa8 <HAL_RCCEx_PeriphCLKConfig+0x278c>)
3400c950:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c952:	bf02      	ittt	eq
3400c954:	2240      	moveq	r2, #64	@ 0x40
3400c956:	4b4b      	ldreq	r3, [pc, #300]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c958:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c95c:	f7fe bbc1 	b.w	3400b0e2 <HAL_RCCEx_PeriphCLKConfig+0xdc6>
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3400c960:	4a52      	ldr	r2, [pc, #328]	@ (3400caac <HAL_RCCEx_PeriphCLKConfig+0x2790>)
3400c962:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c964:	bf02      	ittt	eq
3400c966:	2240      	moveq	r2, #64	@ 0x40
3400c968:	4b46      	ldreq	r3, [pc, #280]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c96a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c96e:	f7fe bc17 	b.w	3400b1a0 <HAL_RCCEx_PeriphCLKConfig+0xe84>
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
3400c972:	4a4f      	ldr	r2, [pc, #316]	@ (3400cab0 <HAL_RCCEx_PeriphCLKConfig+0x2794>)
3400c974:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c976:	bf02      	ittt	eq
3400c978:	2240      	moveq	r2, #64	@ 0x40
3400c97a:	4b42      	ldreq	r3, [pc, #264]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c97c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c980:	f7fe bc52 	b.w	3400b228 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3400c984:	4a4b      	ldr	r2, [pc, #300]	@ (3400cab4 <HAL_RCCEx_PeriphCLKConfig+0x2798>)
3400c986:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c988:	bf02      	ittt	eq
3400c98a:	2240      	moveq	r2, #64	@ 0x40
3400c98c:	4b3d      	ldreq	r3, [pc, #244]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c98e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c992:	f7fe bc8d 	b.w	3400b2b0 <HAL_RCCEx_PeriphCLKConfig+0xf94>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3400c996:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400c99a:	d124      	bne.n	3400c9e6 <HAL_RCCEx_PeriphCLKConfig+0x26ca>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400c99c:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400c99e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c9a2:	d004      	beq.n	3400c9ae <HAL_RCCEx_PeriphCLKConfig+0x2692>
3400c9a4:	f44f 61a1 	mov.w	r1, #1288	@ 0x508
3400c9a8:	4835      	ldr	r0, [pc, #212]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c9aa:	f7f5 fdc3 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400c9ae:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400c9b0:	3b01      	subs	r3, #1
3400c9b2:	2bff      	cmp	r3, #255	@ 0xff
3400c9b4:	d904      	bls.n	3400c9c0 <HAL_RCCEx_PeriphCLKConfig+0x26a4>
3400c9b6:	f240 5109 	movw	r1, #1289	@ 0x509
3400c9ba:	4831      	ldr	r0, [pc, #196]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c9bc:	f7f5 fdba 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400c9c0:	4a30      	ldr	r2, [pc, #192]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c9c2:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400c9c4:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400c9c8:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400c9ca:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c9ce:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c9d2:	3901      	subs	r1, #1
3400c9d4:	4303      	orrs	r3, r0
3400c9d6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c9da:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c9de:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400c9e2:	f7fe bca7 	b.w	3400b334 <HAL_RCCEx_PeriphCLKConfig+0x1018>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
3400c9e6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c9ea:	bf02      	ittt	eq
3400c9ec:	2240      	moveq	r2, #64	@ 0x40
3400c9ee:	4b25      	ldreq	r3, [pc, #148]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c9f0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c9f4:	f7fe bca0 	b.w	3400b338 <HAL_RCCEx_PeriphCLKConfig+0x101c>
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3400c9f8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c9fc:	bf02      	ittt	eq
3400c9fe:	2240      	moveq	r2, #64	@ 0x40
3400ca00:	4b20      	ldreq	r3, [pc, #128]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca02:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca06:	f7fe bcdd 	b.w	3400b3c4 <HAL_RCCEx_PeriphCLKConfig+0x10a8>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
3400ca0a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400ca0e:	d123      	bne.n	3400ca58 <HAL_RCCEx_PeriphCLKConfig+0x273c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400ca10:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400ca12:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ca16:	d004      	beq.n	3400ca22 <HAL_RCCEx_PeriphCLKConfig+0x2706>
3400ca18:	f240 5155 	movw	r1, #1365	@ 0x555
3400ca1c:	4818      	ldr	r0, [pc, #96]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400ca1e:	f7f5 fd89 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400ca22:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400ca24:	3b01      	subs	r3, #1
3400ca26:	2bff      	cmp	r3, #255	@ 0xff
3400ca28:	d904      	bls.n	3400ca34 <HAL_RCCEx_PeriphCLKConfig+0x2718>
3400ca2a:	f240 5156 	movw	r1, #1366	@ 0x556
3400ca2e:	4814      	ldr	r0, [pc, #80]	@ (3400ca80 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400ca30:	f7f5 fd80 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400ca34:	4a13      	ldr	r2, [pc, #76]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca36:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400ca38:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400ca3c:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400ca3e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ca42:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ca46:	3901      	subs	r1, #1
3400ca48:	4303      	orrs	r3, r0
3400ca4a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ca4e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400ca52:	2380      	movs	r3, #128	@ 0x80
3400ca54:	f7fe bcf8 	b.w	3400b448 <HAL_RCCEx_PeriphCLKConfig+0x112c>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3400ca58:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca5c:	bf02      	ittt	eq
3400ca5e:	2240      	moveq	r2, #64	@ 0x40
3400ca60:	4b08      	ldreq	r3, [pc, #32]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca62:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca66:	f7fe bcf1 	b.w	3400b44c <HAL_RCCEx_PeriphCLKConfig+0x1130>
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3400ca6a:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca6c:	bf02      	ittt	eq
3400ca6e:	2240      	moveq	r2, #64	@ 0x40
3400ca70:	4b04      	ldreq	r3, [pc, #16]	@ (3400ca84 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca72:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca76:	f7fe bd3b 	b.w	3400b4f0 <HAL_RCCEx_PeriphCLKConfig+0x11d4>
3400ca7a:	bf00      	nop
3400ca7c:	0703080c 	.word	0x0703080c
3400ca80:	3401c6ca 	.word	0x3401c6ca
3400ca84:	56028000 	.word	0x56028000
3400ca88:	0701080c 	.word	0x0701080c
3400ca8c:	07030c0c 	.word	0x07030c0c
3400ca90:	07010c0c 	.word	0x07010c0c
3400ca94:	0703100c 	.word	0x0703100c
3400ca98:	0701100c 	.word	0x0701100c
3400ca9c:	0703140c 	.word	0x0703140c
3400caa0:	0701140c 	.word	0x0701140c
3400caa4:	0701082c 	.word	0x0701082c
3400caa8:	07010c2c 	.word	0x07010c2c
3400caac:	0701102c 	.word	0x0701102c
3400cab0:	0701142c 	.word	0x0701142c
3400cab4:	0701182c 	.word	0x0701182c
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3400cab8:	4aa8      	ldr	r2, [pc, #672]	@ (3400cd5c <HAL_RCCEx_PeriphCLKConfig+0x2a40>)
3400caba:	4293      	cmp	r3, r2
3400cabc:	d123      	bne.n	3400cb06 <HAL_RCCEx_PeriphCLKConfig+0x27ea>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cabe:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cac0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cac4:	d004      	beq.n	3400cad0 <HAL_RCCEx_PeriphCLKConfig+0x27b4>
3400cac6:	f240 51a2 	movw	r1, #1442	@ 0x5a2
3400caca:	48a5      	ldr	r0, [pc, #660]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cacc:	f7f5 fd32 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cad0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cad2:	3b01      	subs	r3, #1
3400cad4:	2bff      	cmp	r3, #255	@ 0xff
3400cad6:	d904      	bls.n	3400cae2 <HAL_RCCEx_PeriphCLKConfig+0x27c6>
3400cad8:	f240 51a3 	movw	r1, #1443	@ 0x5a3
3400cadc:	48a0      	ldr	r0, [pc, #640]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cade:	f7f5 fd29 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cae2:	4aa0      	ldr	r2, [pc, #640]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cae4:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cae6:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400caea:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400caec:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400caf0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400caf4:	3901      	subs	r1, #1
3400caf6:	4303      	orrs	r3, r0
3400caf8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cafc:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cb00:	2380      	movs	r3, #128	@ 0x80
3400cb02:	f7fe bd3a 	b.w	3400b57a <HAL_RCCEx_PeriphCLKConfig+0x125e>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
3400cb06:	4a98      	ldr	r2, [pc, #608]	@ (3400cd68 <HAL_RCCEx_PeriphCLKConfig+0x2a4c>)
3400cb08:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cb0a:	bf02      	ittt	eq
3400cb0c:	2240      	moveq	r2, #64	@ 0x40
3400cb0e:	4b95      	ldreq	r3, [pc, #596]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cb10:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cb14:	f7fe bd33 	b.w	3400b57e <HAL_RCCEx_PeriphCLKConfig+0x1262>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
3400cb18:	4a94      	ldr	r2, [pc, #592]	@ (3400cd6c <HAL_RCCEx_PeriphCLKConfig+0x2a50>)
3400cb1a:	4293      	cmp	r3, r2
3400cb1c:	d123      	bne.n	3400cb66 <HAL_RCCEx_PeriphCLKConfig+0x284a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cb1e:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cb20:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cb24:	d004      	beq.n	3400cb30 <HAL_RCCEx_PeriphCLKConfig+0x2814>
3400cb26:	f240 51cf 	movw	r1, #1487	@ 0x5cf
3400cb2a:	488d      	ldr	r0, [pc, #564]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cb2c:	f7f5 fd02 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cb30:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cb32:	3b01      	subs	r3, #1
3400cb34:	2bff      	cmp	r3, #255	@ 0xff
3400cb36:	d904      	bls.n	3400cb42 <HAL_RCCEx_PeriphCLKConfig+0x2826>
3400cb38:	f44f 61ba 	mov.w	r1, #1488	@ 0x5d0
3400cb3c:	4888      	ldr	r0, [pc, #544]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cb3e:	f7f5 fcf9 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cb42:	4a88      	ldr	r2, [pc, #544]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cb44:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cb46:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cb4a:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cb4c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cb50:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cb54:	3901      	subs	r1, #1
3400cb56:	4303      	orrs	r3, r0
3400cb58:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cb5c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cb60:	2380      	movs	r3, #128	@ 0x80
3400cb62:	f7fe bd4b 	b.w	3400b5fc <HAL_RCCEx_PeriphCLKConfig+0x12e0>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3400cb66:	4a82      	ldr	r2, [pc, #520]	@ (3400cd70 <HAL_RCCEx_PeriphCLKConfig+0x2a54>)
3400cb68:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cb6a:	bf02      	ittt	eq
3400cb6c:	2240      	moveq	r2, #64	@ 0x40
3400cb6e:	4b7d      	ldreq	r3, [pc, #500]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cb70:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cb74:	f7fe bd44 	b.w	3400b600 <HAL_RCCEx_PeriphCLKConfig+0x12e4>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3400cb78:	2b03      	cmp	r3, #3
3400cb7a:	d123      	bne.n	3400cbc4 <HAL_RCCEx_PeriphCLKConfig+0x28a8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cb7c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cb7e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cb82:	d004      	beq.n	3400cb8e <HAL_RCCEx_PeriphCLKConfig+0x2872>
3400cb84:	f240 51fc 	movw	r1, #1532	@ 0x5fc
3400cb88:	4875      	ldr	r0, [pc, #468]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cb8a:	f7f5 fcd3 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cb8e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cb90:	3b01      	subs	r3, #1
3400cb92:	2bff      	cmp	r3, #255	@ 0xff
3400cb94:	d904      	bls.n	3400cba0 <HAL_RCCEx_PeriphCLKConfig+0x2884>
3400cb96:	f240 51fd 	movw	r1, #1533	@ 0x5fd
3400cb9a:	4871      	ldr	r0, [pc, #452]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cb9c:	f7f5 fcca 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cba0:	4a70      	ldr	r2, [pc, #448]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cba2:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cba4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cba8:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cbaa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cbae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cbb2:	3901      	subs	r1, #1
3400cbb4:	4303      	orrs	r3, r0
3400cbb6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cbba:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cbbe:	2380      	movs	r3, #128	@ 0x80
3400cbc0:	f7fe bd55 	b.w	3400b66e <HAL_RCCEx_PeriphCLKConfig+0x1352>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
3400cbc4:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cbc6:	bf02      	ittt	eq
3400cbc8:	2240      	moveq	r2, #64	@ 0x40
3400cbca:	4b66      	ldreq	r3, [pc, #408]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cbcc:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cbd0:	f7fe bd4f 	b.w	3400b672 <HAL_RCCEx_PeriphCLKConfig+0x1356>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3400cbd4:	4a67      	ldr	r2, [pc, #412]	@ (3400cd74 <HAL_RCCEx_PeriphCLKConfig+0x2a58>)
3400cbd6:	4293      	cmp	r3, r2
3400cbd8:	d124      	bne.n	3400cc24 <HAL_RCCEx_PeriphCLKConfig+0x2908>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cbda:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cbdc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cbe0:	d004      	beq.n	3400cbec <HAL_RCCEx_PeriphCLKConfig+0x28d0>
3400cbe2:	f240 6129 	movw	r1, #1577	@ 0x629
3400cbe6:	485e      	ldr	r0, [pc, #376]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cbe8:	f7f5 fca4 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400cbec:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400cbee:	3b01      	subs	r3, #1
3400cbf0:	2bff      	cmp	r3, #255	@ 0xff
3400cbf2:	d904      	bls.n	3400cbfe <HAL_RCCEx_PeriphCLKConfig+0x28e2>
3400cbf4:	f240 612a 	movw	r1, #1578	@ 0x62a
3400cbf8:	4859      	ldr	r0, [pc, #356]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cbfa:	f7f5 fc9b 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400cbfe:	4a59      	ldr	r2, [pc, #356]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc00:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400cc02:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400cc06:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400cc08:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cc0c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cc10:	3901      	subs	r1, #1
3400cc12:	4303      	orrs	r3, r0
3400cc14:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cc18:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cc1c:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cc20:	f7fe bd72 	b.w	3400b708 <HAL_RCCEx_PeriphCLKConfig+0x13ec>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3400cc24:	4a54      	ldr	r2, [pc, #336]	@ (3400cd78 <HAL_RCCEx_PeriphCLKConfig+0x2a5c>)
3400cc26:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cc28:	bf02      	ittt	eq
3400cc2a:	2240      	moveq	r2, #64	@ 0x40
3400cc2c:	4b4d      	ldreq	r3, [pc, #308]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc2e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cc32:	f7fe bd6b 	b.w	3400b70c <HAL_RCCEx_PeriphCLKConfig+0x13f0>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3400cc36:	4a51      	ldr	r2, [pc, #324]	@ (3400cd7c <HAL_RCCEx_PeriphCLKConfig+0x2a60>)
3400cc38:	4293      	cmp	r3, r2
3400cc3a:	d124      	bne.n	3400cc86 <HAL_RCCEx_PeriphCLKConfig+0x296a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cc3c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cc3e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cc42:	d004      	beq.n	3400cc4e <HAL_RCCEx_PeriphCLKConfig+0x2932>
3400cc44:	f240 6156 	movw	r1, #1622	@ 0x656
3400cc48:	4845      	ldr	r0, [pc, #276]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cc4a:	f7f5 fc73 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400cc4e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400cc50:	3b01      	subs	r3, #1
3400cc52:	2bff      	cmp	r3, #255	@ 0xff
3400cc54:	d904      	bls.n	3400cc60 <HAL_RCCEx_PeriphCLKConfig+0x2944>
3400cc56:	f240 6157 	movw	r1, #1623	@ 0x657
3400cc5a:	4841      	ldr	r0, [pc, #260]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cc5c:	f7f5 fc6a 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400cc60:	4a40      	ldr	r2, [pc, #256]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc62:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400cc64:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400cc68:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400cc6a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cc6e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cc72:	3901      	subs	r1, #1
3400cc74:	4303      	orrs	r3, r0
3400cc76:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cc7a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cc7e:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cc82:	f7fe bd88 	b.w	3400b796 <HAL_RCCEx_PeriphCLKConfig+0x147a>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3400cc86:	4a3e      	ldr	r2, [pc, #248]	@ (3400cd80 <HAL_RCCEx_PeriphCLKConfig+0x2a64>)
3400cc88:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cc8a:	bf02      	ittt	eq
3400cc8c:	2240      	moveq	r2, #64	@ 0x40
3400cc8e:	4b35      	ldreq	r3, [pc, #212]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc90:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cc94:	f7fe bd81 	b.w	3400b79a <HAL_RCCEx_PeriphCLKConfig+0x147e>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3400cc98:	4a3a      	ldr	r2, [pc, #232]	@ (3400cd84 <HAL_RCCEx_PeriphCLKConfig+0x2a68>)
3400cc9a:	4293      	cmp	r3, r2
3400cc9c:	d124      	bne.n	3400cce8 <HAL_RCCEx_PeriphCLKConfig+0x29cc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cc9e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cca0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cca4:	d004      	beq.n	3400ccb0 <HAL_RCCEx_PeriphCLKConfig+0x2994>
3400cca6:	f240 6183 	movw	r1, #1667	@ 0x683
3400ccaa:	482d      	ldr	r0, [pc, #180]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400ccac:	f7f5 fc42 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ccb0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400ccb2:	3b01      	subs	r3, #1
3400ccb4:	2bff      	cmp	r3, #255	@ 0xff
3400ccb6:	d904      	bls.n	3400ccc2 <HAL_RCCEx_PeriphCLKConfig+0x29a6>
3400ccb8:	f240 6184 	movw	r1, #1668	@ 0x684
3400ccbc:	4828      	ldr	r0, [pc, #160]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400ccbe:	f7f5 fc39 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400ccc2:	4a28      	ldr	r2, [pc, #160]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400ccc4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400ccc6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400ccca:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400cccc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ccd0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ccd4:	3901      	subs	r1, #1
3400ccd6:	4303      	orrs	r3, r0
3400ccd8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ccdc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cce0:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cce4:	f7fe bdb8 	b.w	3400b858 <HAL_RCCEx_PeriphCLKConfig+0x153c>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3400cce8:	4a27      	ldr	r2, [pc, #156]	@ (3400cd88 <HAL_RCCEx_PeriphCLKConfig+0x2a6c>)
3400ccea:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ccec:	bf02      	ittt	eq
3400ccee:	2240      	moveq	r2, #64	@ 0x40
3400ccf0:	4b1c      	ldreq	r3, [pc, #112]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400ccf2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ccf6:	f7fe bdb1 	b.w	3400b85c <HAL_RCCEx_PeriphCLKConfig+0x1540>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3400ccfa:	4a24      	ldr	r2, [pc, #144]	@ (3400cd8c <HAL_RCCEx_PeriphCLKConfig+0x2a70>)
3400ccfc:	4293      	cmp	r3, r2
3400ccfe:	d124      	bne.n	3400cd4a <HAL_RCCEx_PeriphCLKConfig+0x2a2e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cd00:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cd02:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cd06:	d004      	beq.n	3400cd12 <HAL_RCCEx_PeriphCLKConfig+0x29f6>
3400cd08:	f44f 61d6 	mov.w	r1, #1712	@ 0x6b0
3400cd0c:	4814      	ldr	r0, [pc, #80]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cd0e:	f7f5 fc11 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cd12:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cd14:	3b01      	subs	r3, #1
3400cd16:	2bff      	cmp	r3, #255	@ 0xff
3400cd18:	d904      	bls.n	3400cd24 <HAL_RCCEx_PeriphCLKConfig+0x2a08>
3400cd1a:	f240 61b1 	movw	r1, #1713	@ 0x6b1
3400cd1e:	4810      	ldr	r0, [pc, #64]	@ (3400cd60 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cd20:	f7f5 fc08 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cd24:	4a0f      	ldr	r2, [pc, #60]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cd26:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cd28:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400cd2c:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400cd2e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cd32:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cd36:	3901      	subs	r1, #1
3400cd38:	4303      	orrs	r3, r0
3400cd3a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cd3e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cd42:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cd46:	f7fe bdcf 	b.w	3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0x15cc>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3400cd4a:	4a11      	ldr	r2, [pc, #68]	@ (3400cd90 <HAL_RCCEx_PeriphCLKConfig+0x2a74>)
3400cd4c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cd4e:	bf02      	ittt	eq
3400cd50:	2240      	moveq	r2, #64	@ 0x40
3400cd52:	4b04      	ldreq	r3, [pc, #16]	@ (3400cd64 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cd54:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cd58:	f7fe bdc8 	b.w	3400b8ec <HAL_RCCEx_PeriphCLKConfig+0x15d0>
3400cd5c:	07031418 	.word	0x07031418
3400cd60:	3401c6ca 	.word	0x3401c6ca
3400cd64:	56028000 	.word	0x56028000
3400cd68:	07011418 	.word	0x07011418
3400cd6c:	07031818 	.word	0x07031818
3400cd70:	07011818 	.word	0x07011818
3400cd74:	07030420 	.word	0x07030420
3400cd78:	07010420 	.word	0x07010420
3400cd7c:	07030820 	.word	0x07030820
3400cd80:	07010820 	.word	0x07010820
3400cd84:	07030c20 	.word	0x07030c20
3400cd88:	07010c20 	.word	0x07010c20
3400cd8c:	07031020 	.word	0x07031020
3400cd90:	07011020 	.word	0x07011020
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3400cd94:	4aab      	ldr	r2, [pc, #684]	@ (3400d044 <HAL_RCCEx_PeriphCLKConfig+0x2d28>)
3400cd96:	4293      	cmp	r3, r2
3400cd98:	d124      	bne.n	3400cde4 <HAL_RCCEx_PeriphCLKConfig+0x2ac8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cd9a:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cd9c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cda0:	d004      	beq.n	3400cdac <HAL_RCCEx_PeriphCLKConfig+0x2a90>
3400cda2:	f240 61dd 	movw	r1, #1757	@ 0x6dd
3400cda6:	48a8      	ldr	r0, [pc, #672]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cda8:	f7f5 fbc4 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cdac:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cdae:	3b01      	subs	r3, #1
3400cdb0:	2bff      	cmp	r3, #255	@ 0xff
3400cdb2:	d904      	bls.n	3400cdbe <HAL_RCCEx_PeriphCLKConfig+0x2aa2>
3400cdb4:	f240 61de 	movw	r1, #1758	@ 0x6de
3400cdb8:	48a3      	ldr	r0, [pc, #652]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cdba:	f7f5 fbbb 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cdbe:	4aa3      	ldr	r2, [pc, #652]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cdc0:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cdc2:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400cdc6:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400cdc8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cdcc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cdd0:	3901      	subs	r1, #1
3400cdd2:	4303      	orrs	r3, r0
3400cdd4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cdd8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cddc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cde0:	f7fe bdca 	b.w	3400b978 <HAL_RCCEx_PeriphCLKConfig+0x165c>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3400cde4:	4a9a      	ldr	r2, [pc, #616]	@ (3400d050 <HAL_RCCEx_PeriphCLKConfig+0x2d34>)
3400cde6:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cde8:	bf02      	ittt	eq
3400cdea:	2240      	moveq	r2, #64	@ 0x40
3400cdec:	4b97      	ldreq	r3, [pc, #604]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cdee:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cdf2:	f7fe bdc3 	b.w	3400b97c <HAL_RCCEx_PeriphCLKConfig+0x1660>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
3400cdf6:	4a97      	ldr	r2, [pc, #604]	@ (3400d054 <HAL_RCCEx_PeriphCLKConfig+0x2d38>)
3400cdf8:	4293      	cmp	r3, r2
3400cdfa:	d124      	bne.n	3400ce46 <HAL_RCCEx_PeriphCLKConfig+0x2b2a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cdfc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cdfe:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ce02:	d004      	beq.n	3400ce0e <HAL_RCCEx_PeriphCLKConfig+0x2af2>
3400ce04:	f240 710a 	movw	r1, #1802	@ 0x70a
3400ce08:	488f      	ldr	r0, [pc, #572]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ce0a:	f7f5 fb93 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ce0e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400ce10:	3b01      	subs	r3, #1
3400ce12:	2bff      	cmp	r3, #255	@ 0xff
3400ce14:	d904      	bls.n	3400ce20 <HAL_RCCEx_PeriphCLKConfig+0x2b04>
3400ce16:	f240 710b 	movw	r1, #1803	@ 0x70b
3400ce1a:	488b      	ldr	r0, [pc, #556]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ce1c:	f7f5 fb8a 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400ce20:	4a8a      	ldr	r2, [pc, #552]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400ce22:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400ce24:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400ce28:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400ce2a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ce2e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ce32:	3901      	subs	r1, #1
3400ce34:	4303      	orrs	r3, r0
3400ce36:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ce3a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400ce3e:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400ce42:	f7fe bde0 	b.w	3400ba06 <HAL_RCCEx_PeriphCLKConfig+0x16ea>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3400ce46:	4a84      	ldr	r2, [pc, #528]	@ (3400d058 <HAL_RCCEx_PeriphCLKConfig+0x2d3c>)
3400ce48:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce4a:	bf02      	ittt	eq
3400ce4c:	2240      	moveq	r2, #64	@ 0x40
3400ce4e:	4b7f      	ldreq	r3, [pc, #508]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400ce50:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ce54:	f7fe bdd9 	b.w	3400ba0a <HAL_RCCEx_PeriphCLKConfig+0x16ee>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
3400ce58:	4a80      	ldr	r2, [pc, #512]	@ (3400d05c <HAL_RCCEx_PeriphCLKConfig+0x2d40>)
3400ce5a:	4293      	cmp	r3, r2
3400ce5c:	d124      	bne.n	3400cea8 <HAL_RCCEx_PeriphCLKConfig+0x2b8c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400ce5e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400ce60:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ce64:	d004      	beq.n	3400ce70 <HAL_RCCEx_PeriphCLKConfig+0x2b54>
3400ce66:	f240 7137 	movw	r1, #1847	@ 0x737
3400ce6a:	4877      	ldr	r0, [pc, #476]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ce6c:	f7f5 fb62 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400ce70:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400ce72:	3b01      	subs	r3, #1
3400ce74:	2bff      	cmp	r3, #255	@ 0xff
3400ce76:	d904      	bls.n	3400ce82 <HAL_RCCEx_PeriphCLKConfig+0x2b66>
3400ce78:	f44f 61e7 	mov.w	r1, #1848	@ 0x738
3400ce7c:	4872      	ldr	r0, [pc, #456]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ce7e:	f7f5 fb59 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400ce82:	4a72      	ldr	r2, [pc, #456]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400ce84:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400ce86:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400ce8a:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400ce8c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ce90:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ce94:	3901      	subs	r1, #1
3400ce96:	4303      	orrs	r3, r0
3400ce98:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ce9c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cea0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cea4:	f7fe bdf7 	b.w	3400ba96 <HAL_RCCEx_PeriphCLKConfig+0x177a>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
3400cea8:	4a6d      	ldr	r2, [pc, #436]	@ (3400d060 <HAL_RCCEx_PeriphCLKConfig+0x2d44>)
3400ceaa:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ceac:	bf02      	ittt	eq
3400ceae:	2240      	moveq	r2, #64	@ 0x40
3400ceb0:	4b66      	ldreq	r3, [pc, #408]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400ceb2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ceb6:	f7fe bdf0 	b.w	3400ba9a <HAL_RCCEx_PeriphCLKConfig+0x177e>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3400ceba:	4a6a      	ldr	r2, [pc, #424]	@ (3400d064 <HAL_RCCEx_PeriphCLKConfig+0x2d48>)
3400cebc:	4293      	cmp	r3, r2
3400cebe:	d124      	bne.n	3400cf0a <HAL_RCCEx_PeriphCLKConfig+0x2bee>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cec0:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cec2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cec6:	d004      	beq.n	3400ced2 <HAL_RCCEx_PeriphCLKConfig+0x2bb6>
3400cec8:	f240 7164 	movw	r1, #1892	@ 0x764
3400cecc:	485e      	ldr	r0, [pc, #376]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cece:	f7f5 fb31 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400ced2:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400ced4:	3b01      	subs	r3, #1
3400ced6:	2bff      	cmp	r3, #255	@ 0xff
3400ced8:	d904      	bls.n	3400cee4 <HAL_RCCEx_PeriphCLKConfig+0x2bc8>
3400ceda:	f240 7165 	movw	r1, #1893	@ 0x765
3400cede:	485a      	ldr	r0, [pc, #360]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cee0:	f7f5 fb28 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cee4:	4a59      	ldr	r2, [pc, #356]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cee6:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cee8:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400ceec:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400ceee:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cef2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cef6:	3901      	subs	r1, #1
3400cef8:	4303      	orrs	r3, r0
3400cefa:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cefe:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cf02:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cf06:	f7fe be27 	b.w	3400bb58 <HAL_RCCEx_PeriphCLKConfig+0x183c>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3400cf0a:	4a57      	ldr	r2, [pc, #348]	@ (3400d068 <HAL_RCCEx_PeriphCLKConfig+0x2d4c>)
3400cf0c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cf0e:	bf02      	ittt	eq
3400cf10:	2240      	moveq	r2, #64	@ 0x40
3400cf12:	4b4e      	ldreq	r3, [pc, #312]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf14:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cf18:	f7fe be20 	b.w	3400bb5c <HAL_RCCEx_PeriphCLKConfig+0x1840>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3400cf1c:	4a53      	ldr	r2, [pc, #332]	@ (3400d06c <HAL_RCCEx_PeriphCLKConfig+0x2d50>)
3400cf1e:	4293      	cmp	r3, r2
3400cf20:	d124      	bne.n	3400cf6c <HAL_RCCEx_PeriphCLKConfig+0x2c50>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cf22:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cf24:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cf28:	d004      	beq.n	3400cf34 <HAL_RCCEx_PeriphCLKConfig+0x2c18>
3400cf2a:	f240 7191 	movw	r1, #1937	@ 0x791
3400cf2e:	4846      	ldr	r0, [pc, #280]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cf30:	f7f5 fb00 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cf34:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cf36:	3b01      	subs	r3, #1
3400cf38:	2bff      	cmp	r3, #255	@ 0xff
3400cf3a:	d904      	bls.n	3400cf46 <HAL_RCCEx_PeriphCLKConfig+0x2c2a>
3400cf3c:	f240 7192 	movw	r1, #1938	@ 0x792
3400cf40:	4841      	ldr	r0, [pc, #260]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cf42:	f7f5 faf7 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cf46:	4a41      	ldr	r2, [pc, #260]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf48:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cf4a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400cf4e:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400cf50:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cf54:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cf58:	3901      	subs	r1, #1
3400cf5a:	4303      	orrs	r3, r0
3400cf5c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cf60:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cf64:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cf68:	f7fe be3e 	b.w	3400bbe8 <HAL_RCCEx_PeriphCLKConfig+0x18cc>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
3400cf6c:	4a40      	ldr	r2, [pc, #256]	@ (3400d070 <HAL_RCCEx_PeriphCLKConfig+0x2d54>)
3400cf6e:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cf70:	bf02      	ittt	eq
3400cf72:	2240      	moveq	r2, #64	@ 0x40
3400cf74:	4b35      	ldreq	r3, [pc, #212]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf76:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cf7a:	f7fe be37 	b.w	3400bbec <HAL_RCCEx_PeriphCLKConfig+0x18d0>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3400cf7e:	4a3d      	ldr	r2, [pc, #244]	@ (3400d074 <HAL_RCCEx_PeriphCLKConfig+0x2d58>)
3400cf80:	4293      	cmp	r3, r2
3400cf82:	d124      	bne.n	3400cfce <HAL_RCCEx_PeriphCLKConfig+0x2cb2>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cf84:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cf86:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cf8a:	d004      	beq.n	3400cf96 <HAL_RCCEx_PeriphCLKConfig+0x2c7a>
3400cf8c:	f240 71be 	movw	r1, #1982	@ 0x7be
3400cf90:	482d      	ldr	r0, [pc, #180]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cf92:	f7f5 facf 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cf96:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cf98:	3b01      	subs	r3, #1
3400cf9a:	2bff      	cmp	r3, #255	@ 0xff
3400cf9c:	d904      	bls.n	3400cfa8 <HAL_RCCEx_PeriphCLKConfig+0x2c8c>
3400cf9e:	f240 71bf 	movw	r1, #1983	@ 0x7bf
3400cfa2:	4829      	ldr	r0, [pc, #164]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cfa4:	f7f5 fac6 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cfa8:	4a28      	ldr	r2, [pc, #160]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cfaa:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cfac:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400cfb0:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400cfb2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cfb6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cfba:	3901      	subs	r1, #1
3400cfbc:	4303      	orrs	r3, r0
3400cfbe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cfc2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cfc6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cfca:	f7fe be55 	b.w	3400bc78 <HAL_RCCEx_PeriphCLKConfig+0x195c>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3400cfce:	4a2a      	ldr	r2, [pc, #168]	@ (3400d078 <HAL_RCCEx_PeriphCLKConfig+0x2d5c>)
3400cfd0:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cfd2:	bf02      	ittt	eq
3400cfd4:	2240      	moveq	r2, #64	@ 0x40
3400cfd6:	4b1d      	ldreq	r3, [pc, #116]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cfd8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cfdc:	f7fe be4e 	b.w	3400bc7c <HAL_RCCEx_PeriphCLKConfig+0x1960>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3400cfe0:	4a26      	ldr	r2, [pc, #152]	@ (3400d07c <HAL_RCCEx_PeriphCLKConfig+0x2d60>)
3400cfe2:	4293      	cmp	r3, r2
3400cfe4:	d124      	bne.n	3400d030 <HAL_RCCEx_PeriphCLKConfig+0x2d14>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cfe6:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cfe8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cfec:	d004      	beq.n	3400cff8 <HAL_RCCEx_PeriphCLKConfig+0x2cdc>
3400cfee:	f240 71eb 	movw	r1, #2027	@ 0x7eb
3400cff2:	4815      	ldr	r0, [pc, #84]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cff4:	f7f5 fa9e 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cff8:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cffa:	3b01      	subs	r3, #1
3400cffc:	2bff      	cmp	r3, #255	@ 0xff
3400cffe:	d904      	bls.n	3400d00a <HAL_RCCEx_PeriphCLKConfig+0x2cee>
3400d000:	f240 71ec 	movw	r1, #2028	@ 0x7ec
3400d004:	4810      	ldr	r0, [pc, #64]	@ (3400d048 <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d006:	f7f5 fa95 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d00a:	4a10      	ldr	r2, [pc, #64]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d00c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d00e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d012:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d014:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d018:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d01c:	3901      	subs	r1, #1
3400d01e:	4303      	orrs	r3, r0
3400d020:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d024:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d028:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d02c:	f7fe be6c 	b.w	3400bd08 <HAL_RCCEx_PeriphCLKConfig+0x19ec>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
3400d030:	4a13      	ldr	r2, [pc, #76]	@ (3400d080 <HAL_RCCEx_PeriphCLKConfig+0x2d64>)
3400d032:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d034:	bf02      	ittt	eq
3400d036:	2240      	moveq	r2, #64	@ 0x40
3400d038:	4b04      	ldreq	r3, [pc, #16]	@ (3400d04c <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d03a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d03e:	f7fe be65 	b.w	3400bd0c <HAL_RCCEx_PeriphCLKConfig+0x19f0>
3400d042:	bf00      	nop
3400d044:	07031420 	.word	0x07031420
3400d048:	3401c6ca 	.word	0x3401c6ca
3400d04c:	56028000 	.word	0x56028000
3400d050:	07011420 	.word	0x07011420
3400d054:	07031820 	.word	0x07031820
3400d058:	07011820 	.word	0x07011820
3400d05c:	07030030 	.word	0x07030030
3400d060:	07010030 	.word	0x07010030
3400d064:	07030430 	.word	0x07030430
3400d068:	07010430 	.word	0x07010430
3400d06c:	07030830 	.word	0x07030830
3400d070:	07010830 	.word	0x07010830
3400d074:	07030c30 	.word	0x07030c30
3400d078:	07010c30 	.word	0x07010c30
3400d07c:	07031030 	.word	0x07031030
3400d080:	07011030 	.word	0x07011030
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3400d084:	4a8b      	ldr	r2, [pc, #556]	@ (3400d2b4 <HAL_RCCEx_PeriphCLKConfig+0x2f98>)
3400d086:	4293      	cmp	r3, r2
3400d088:	d124      	bne.n	3400d0d4 <HAL_RCCEx_PeriphCLKConfig+0x2db8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d08a:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d08c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d090:	d004      	beq.n	3400d09c <HAL_RCCEx_PeriphCLKConfig+0x2d80>
3400d092:	f640 0118 	movw	r1, #2072	@ 0x818
3400d096:	4888      	ldr	r0, [pc, #544]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d098:	f7f5 fa4c 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d09c:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d09e:	3b01      	subs	r3, #1
3400d0a0:	2bff      	cmp	r3, #255	@ 0xff
3400d0a2:	d904      	bls.n	3400d0ae <HAL_RCCEx_PeriphCLKConfig+0x2d92>
3400d0a4:	f640 0119 	movw	r1, #2073	@ 0x819
3400d0a8:	4883      	ldr	r0, [pc, #524]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d0aa:	f7f5 fa43 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d0ae:	4a83      	ldr	r2, [pc, #524]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d0b0:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d0b2:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d0b6:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d0b8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d0bc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d0c0:	3901      	subs	r1, #1
3400d0c2:	4303      	orrs	r3, r0
3400d0c4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d0c8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d0cc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d0d0:	f7fe be62 	b.w	3400bd98 <HAL_RCCEx_PeriphCLKConfig+0x1a7c>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3400d0d4:	4a7a      	ldr	r2, [pc, #488]	@ (3400d2c0 <HAL_RCCEx_PeriphCLKConfig+0x2fa4>)
3400d0d6:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0d8:	bf02      	ittt	eq
3400d0da:	2240      	moveq	r2, #64	@ 0x40
3400d0dc:	4b77      	ldreq	r3, [pc, #476]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d0de:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0e2:	f7fe be5b 	b.w	3400bd9c <HAL_RCCEx_PeriphCLKConfig+0x1a80>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3400d0e6:	4a77      	ldr	r2, [pc, #476]	@ (3400d2c4 <HAL_RCCEx_PeriphCLKConfig+0x2fa8>)
3400d0e8:	4293      	cmp	r3, r2
3400d0ea:	d124      	bne.n	3400d136 <HAL_RCCEx_PeriphCLKConfig+0x2e1a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d0ec:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d0ee:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d0f2:	d004      	beq.n	3400d0fe <HAL_RCCEx_PeriphCLKConfig+0x2de2>
3400d0f4:	f640 0145 	movw	r1, #2117	@ 0x845
3400d0f8:	486f      	ldr	r0, [pc, #444]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d0fa:	f7f5 fa1b 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d0fe:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d100:	3b01      	subs	r3, #1
3400d102:	2bff      	cmp	r3, #255	@ 0xff
3400d104:	d904      	bls.n	3400d110 <HAL_RCCEx_PeriphCLKConfig+0x2df4>
3400d106:	f640 0146 	movw	r1, #2118	@ 0x846
3400d10a:	486b      	ldr	r0, [pc, #428]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d10c:	f7f5 fa12 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d110:	4a6a      	ldr	r2, [pc, #424]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d112:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d114:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d118:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d11a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d11e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d122:	3901      	subs	r1, #1
3400d124:	4303      	orrs	r3, r0
3400d126:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d12a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d12e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d132:	f7fe be79 	b.w	3400be28 <HAL_RCCEx_PeriphCLKConfig+0x1b0c>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3400d136:	4a64      	ldr	r2, [pc, #400]	@ (3400d2c8 <HAL_RCCEx_PeriphCLKConfig+0x2fac>)
3400d138:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d13a:	bf02      	ittt	eq
3400d13c:	2240      	moveq	r2, #64	@ 0x40
3400d13e:	4b5f      	ldreq	r3, [pc, #380]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d140:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d144:	f7fe be72 	b.w	3400be2c <HAL_RCCEx_PeriphCLKConfig+0x1b10>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3400d148:	4a60      	ldr	r2, [pc, #384]	@ (3400d2cc <HAL_RCCEx_PeriphCLKConfig+0x2fb0>)
3400d14a:	4293      	cmp	r3, r2
3400d14c:	d124      	bne.n	3400d198 <HAL_RCCEx_PeriphCLKConfig+0x2e7c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d14e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d150:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d154:	d004      	beq.n	3400d160 <HAL_RCCEx_PeriphCLKConfig+0x2e44>
3400d156:	f640 0172 	movw	r1, #2162	@ 0x872
3400d15a:	4857      	ldr	r0, [pc, #348]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d15c:	f7f5 f9ea 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d160:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d162:	3b01      	subs	r3, #1
3400d164:	2bff      	cmp	r3, #255	@ 0xff
3400d166:	d904      	bls.n	3400d172 <HAL_RCCEx_PeriphCLKConfig+0x2e56>
3400d168:	f640 0173 	movw	r1, #2163	@ 0x873
3400d16c:	4852      	ldr	r0, [pc, #328]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d16e:	f7f5 f9e1 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d172:	4a52      	ldr	r2, [pc, #328]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d174:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d176:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d17a:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d17c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d180:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d184:	3901      	subs	r1, #1
3400d186:	4303      	orrs	r3, r0
3400d188:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d18c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d190:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d194:	f7fe beac 	b.w	3400bef0 <HAL_RCCEx_PeriphCLKConfig+0x1bd4>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3400d198:	4a4d      	ldr	r2, [pc, #308]	@ (3400d2d0 <HAL_RCCEx_PeriphCLKConfig+0x2fb4>)
3400d19a:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d19c:	bf02      	ittt	eq
3400d19e:	2240      	moveq	r2, #64	@ 0x40
3400d1a0:	4b46      	ldreq	r3, [pc, #280]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d1a2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d1a6:	f7fe bea5 	b.w	3400bef4 <HAL_RCCEx_PeriphCLKConfig+0x1bd8>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
3400d1aa:	4a4a      	ldr	r2, [pc, #296]	@ (3400d2d4 <HAL_RCCEx_PeriphCLKConfig+0x2fb8>)
3400d1ac:	4293      	cmp	r3, r2
3400d1ae:	d124      	bne.n	3400d1fa <HAL_RCCEx_PeriphCLKConfig+0x2ede>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d1b0:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d1b2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d1b6:	d004      	beq.n	3400d1c2 <HAL_RCCEx_PeriphCLKConfig+0x2ea6>
3400d1b8:	f640 019f 	movw	r1, #2207	@ 0x89f
3400d1bc:	483e      	ldr	r0, [pc, #248]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d1be:	f7f5 f9b9 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d1c2:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d1c4:	3b01      	subs	r3, #1
3400d1c6:	2bff      	cmp	r3, #255	@ 0xff
3400d1c8:	d904      	bls.n	3400d1d4 <HAL_RCCEx_PeriphCLKConfig+0x2eb8>
3400d1ca:	f44f 610a 	mov.w	r1, #2208	@ 0x8a0
3400d1ce:	483a      	ldr	r0, [pc, #232]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d1d0:	f7f5 f9b0 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d1d4:	4a39      	ldr	r2, [pc, #228]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d1d6:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d1d8:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d1dc:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d1de:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d1e2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d1e6:	3901      	subs	r1, #1
3400d1e8:	4303      	orrs	r3, r0
3400d1ea:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d1ee:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d1f2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d1f6:	f7fe bec3 	b.w	3400bf80 <HAL_RCCEx_PeriphCLKConfig+0x1c64>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
3400d1fa:	4a37      	ldr	r2, [pc, #220]	@ (3400d2d8 <HAL_RCCEx_PeriphCLKConfig+0x2fbc>)
3400d1fc:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d1fe:	bf02      	ittt	eq
3400d200:	2240      	moveq	r2, #64	@ 0x40
3400d202:	4b2e      	ldreq	r3, [pc, #184]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d204:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d208:	f7fe bebc 	b.w	3400bf84 <HAL_RCCEx_PeriphCLKConfig+0x1c68>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3400d20c:	4a33      	ldr	r2, [pc, #204]	@ (3400d2dc <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3400d20e:	4293      	cmp	r3, r2
3400d210:	d124      	bne.n	3400d25c <HAL_RCCEx_PeriphCLKConfig+0x2f40>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d212:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d214:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d218:	d004      	beq.n	3400d224 <HAL_RCCEx_PeriphCLKConfig+0x2f08>
3400d21a:	f640 01cc 	movw	r1, #2252	@ 0x8cc
3400d21e:	4826      	ldr	r0, [pc, #152]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d220:	f7f5 f988 	bl	34002534 <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d224:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d226:	3b01      	subs	r3, #1
3400d228:	2bff      	cmp	r3, #255	@ 0xff
3400d22a:	d904      	bls.n	3400d236 <HAL_RCCEx_PeriphCLKConfig+0x2f1a>
3400d22c:	f640 01cd 	movw	r1, #2253	@ 0x8cd
3400d230:	4821      	ldr	r0, [pc, #132]	@ (3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d232:	f7f5 f97f 	bl	34002534 <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d236:	4a21      	ldr	r2, [pc, #132]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d238:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d23a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d23e:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d240:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d244:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d248:	3901      	subs	r1, #1
3400d24a:	4303      	orrs	r3, r0
3400d24c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d250:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d254:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d258:	f7fe beda 	b.w	3400c010 <HAL_RCCEx_PeriphCLKConfig+0x1cf4>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3400d25c:	4a20      	ldr	r2, [pc, #128]	@ (3400d2e0 <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
3400d25e:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d260:	bf02      	ittt	eq
3400d262:	2240      	moveq	r2, #64	@ 0x40
3400d264:	4b15      	ldreq	r3, [pc, #84]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d266:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d26a:	f7fe bed3 	b.w	3400c014 <HAL_RCCEx_PeriphCLKConfig+0x1cf8>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400d26e:	f7fc ff39 	bl	3400a0e4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d272:	f7fe bef5 	b.w	3400c060 <HAL_RCCEx_PeriphCLKConfig+0x1d44>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400d276:	f7fc ff35 	bl	3400a0e4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d27a:	f7fe bf13 	b.w	3400c0a4 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
3400d27e:	4a19      	ldr	r2, [pc, #100]	@ (3400d2e4 <HAL_RCCEx_PeriphCLKConfig+0x2fc8>)
3400d280:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d282:	bf02      	ittt	eq
3400d284:	2240      	moveq	r2, #64	@ 0x40
3400d286:	4b0d      	ldreq	r3, [pc, #52]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d288:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d28c:	f7fe bf4a 	b.w	3400c124 <HAL_RCCEx_PeriphCLKConfig+0x1e08>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400d290:	f7fc ff28 	bl	3400a0e4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d294:	f7fe bf53 	b.w	3400c13e <HAL_RCCEx_PeriphCLKConfig+0x1e22>
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3400d298:	4a13      	ldr	r2, [pc, #76]	@ (3400d2e8 <HAL_RCCEx_PeriphCLKConfig+0x2fcc>)
3400d29a:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d29c:	bf02      	ittt	eq
3400d29e:	2240      	moveq	r2, #64	@ 0x40
3400d2a0:	4b06      	ldreq	r3, [pc, #24]	@ (3400d2bc <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d2a2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d2a6:	f7fe bfa5 	b.w	3400c1f4 <HAL_RCCEx_PeriphCLKConfig+0x1ed8>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400d2aa:	f7fc ff1b 	bl	3400a0e4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d2ae:	f7fe bfae 	b.w	3400c20e <HAL_RCCEx_PeriphCLKConfig+0x1ef2>
3400d2b2:	bf00      	nop
3400d2b4:	07031430 	.word	0x07031430
3400d2b8:	3401c6ca 	.word	0x3401c6ca
3400d2bc:	56028000 	.word	0x56028000
3400d2c0:	07011430 	.word	0x07011430
3400d2c4:	07031830 	.word	0x07031830
3400d2c8:	07011830 	.word	0x07011830
3400d2cc:	07031c30 	.word	0x07031c30
3400d2d0:	07011c30 	.word	0x07011c30
3400d2d4:	07030034 	.word	0x07030034
3400d2d8:	07010034 	.word	0x07010034
3400d2dc:	07030434 	.word	0x07030434
3400d2e0:	07010434 	.word	0x07010434
3400d2e4:	03010c14 	.word	0x03010c14
3400d2e8:	03011414 	.word	0x03011414

3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>:
{
3400d2ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400d2ee:	4c1e      	ldr	r4, [pc, #120]	@ (3400d368 <HAL_RCCEx_GetPLL1CLKFreq+0x7c>)
3400d2f0:	6863      	ldr	r3, [r4, #4]
3400d2f2:	05d9      	lsls	r1, r3, #23
3400d2f4:	d506      	bpl.n	3400d304 <HAL_RCCEx_GetPLL1CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3400d2f6:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400d2fa:	005a      	lsls	r2, r3, #1
3400d2fc:	d40f      	bmi.n	3400d31e <HAL_RCCEx_GetPLL1CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d2fe:	2000      	movs	r0, #0
}
3400d300:	b003      	add	sp, #12
3400d302:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400d304:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3400d308:	011b      	lsls	r3, r3, #4
3400d30a:	d5f8      	bpl.n	3400d2fe <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400d30c:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400d310:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d314:	b003      	add	sp, #12
3400d316:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400d31a:	f7fc bf9d 	b.w	3400a258 <RCCEx_GetPLLSourceFreq>
3400d31e:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400d322:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d326:	f7fc ff97 	bl	3400a258 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d32a:	2800      	cmp	r0, #0
3400d32c:	d0e7      	beq.n	3400d2fe <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3400d32e:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
        if (divm != 0U)
3400d332:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d336:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d33a:	d0e0      	beq.n	3400d2fe <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3400d33c:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3400d340:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400d344:	f8d4 5088 	ldr.w	r5, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400d348:	f8d4 4088 	ldr.w	r4, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400d34c:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400d350:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
3400d354:	9401      	str	r4, [sp, #4]
3400d356:	9500      	str	r5, [sp, #0]
3400d358:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d35c:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d360:	f7fc ffb0 	bl	3400a2c4 <RCCEx_CalcPLLFreq>
3400d364:	e7cc      	b.n	3400d300 <HAL_RCCEx_GetPLL1CLKFreq+0x14>
3400d366:	bf00      	nop
3400d368:	56028000 	.word	0x56028000

3400d36c <HAL_RCCEx_GetPLL2CLKFreq>:
{
3400d36c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400d36e:	4c1e      	ldr	r4, [pc, #120]	@ (3400d3e8 <HAL_RCCEx_GetPLL2CLKFreq+0x7c>)
3400d370:	6863      	ldr	r3, [r4, #4]
3400d372:	0599      	lsls	r1, r3, #22
3400d374:	d506      	bpl.n	3400d384 <HAL_RCCEx_GetPLL2CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3400d376:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400d37a:	005a      	lsls	r2, r3, #1
3400d37c:	d40f      	bmi.n	3400d39e <HAL_RCCEx_GetPLL2CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d37e:	2000      	movs	r0, #0
}
3400d380:	b003      	add	sp, #12
3400d382:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400d384:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3400d388:	011b      	lsls	r3, r3, #4
3400d38a:	d5f8      	bpl.n	3400d37e <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400d38c:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400d390:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d394:	b003      	add	sp, #12
3400d396:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400d39a:	f7fc bf5d 	b.w	3400a258 <RCCEx_GetPLLSourceFreq>
3400d39e:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400d3a2:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d3a6:	f7fc ff57 	bl	3400a258 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d3aa:	2800      	cmp	r0, #0
3400d3ac:	d0e7      	beq.n	3400d37e <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3400d3ae:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
        if (divm != 0U)
3400d3b2:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d3b6:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d3ba:	d0e0      	beq.n	3400d37e <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3400d3bc:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3400d3c0:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400d3c4:	f8d4 5098 	ldr.w	r5, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400d3c8:	f8d4 4098 	ldr.w	r4, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400d3cc:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400d3d0:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3400d3d4:	9401      	str	r4, [sp, #4]
3400d3d6:	9500      	str	r5, [sp, #0]
3400d3d8:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d3dc:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d3e0:	f7fc ff70 	bl	3400a2c4 <RCCEx_CalcPLLFreq>
3400d3e4:	e7cc      	b.n	3400d380 <HAL_RCCEx_GetPLL2CLKFreq+0x14>
3400d3e6:	bf00      	nop
3400d3e8:	56028000 	.word	0x56028000

3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>:
{
3400d3ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400d3ee:	4c1e      	ldr	r4, [pc, #120]	@ (3400d468 <HAL_RCCEx_GetPLL3CLKFreq+0x7c>)
3400d3f0:	6863      	ldr	r3, [r4, #4]
3400d3f2:	0559      	lsls	r1, r3, #21
3400d3f4:	d506      	bpl.n	3400d404 <HAL_RCCEx_GetPLL3CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3400d3f6:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400d3fa:	005a      	lsls	r2, r3, #1
3400d3fc:	d40f      	bmi.n	3400d41e <HAL_RCCEx_GetPLL3CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d3fe:	2000      	movs	r0, #0
}
3400d400:	b003      	add	sp, #12
3400d402:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400d404:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400d408:	011b      	lsls	r3, r3, #4
3400d40a:	d5f8      	bpl.n	3400d3fe <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400d40c:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400d410:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d414:	b003      	add	sp, #12
3400d416:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400d41a:	f7fc bf1d 	b.w	3400a258 <RCCEx_GetPLLSourceFreq>
3400d41e:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400d422:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d426:	f7fc ff17 	bl	3400a258 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d42a:	2800      	cmp	r0, #0
3400d42c:	d0e7      	beq.n	3400d3fe <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3400d42e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
        if (divm != 0U)
3400d432:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d436:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d43a:	d0e0      	beq.n	3400d3fe <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3400d43c:	f8d4 20a0 	ldr.w	r2, [r4, #160]	@ 0xa0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3400d440:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400d444:	f8d4 50a8 	ldr.w	r5, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400d448:	f8d4 40a8 	ldr.w	r4, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400d44c:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400d450:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
3400d454:	9401      	str	r4, [sp, #4]
3400d456:	9500      	str	r5, [sp, #0]
3400d458:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d45c:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d460:	f7fc ff30 	bl	3400a2c4 <RCCEx_CalcPLLFreq>
3400d464:	e7cc      	b.n	3400d400 <HAL_RCCEx_GetPLL3CLKFreq+0x14>
3400d466:	bf00      	nop
3400d468:	56028000 	.word	0x56028000

3400d46c <HAL_RCCEx_GetPLL4CLKFreq>:
{
3400d46c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400d46e:	4c1e      	ldr	r4, [pc, #120]	@ (3400d4e8 <HAL_RCCEx_GetPLL4CLKFreq+0x7c>)
3400d470:	6863      	ldr	r3, [r4, #4]
3400d472:	0519      	lsls	r1, r3, #20
3400d474:	d506      	bpl.n	3400d484 <HAL_RCCEx_GetPLL4CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3400d476:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400d47a:	005a      	lsls	r2, r3, #1
3400d47c:	d40f      	bmi.n	3400d49e <HAL_RCCEx_GetPLL4CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d47e:	2000      	movs	r0, #0
}
3400d480:	b003      	add	sp, #12
3400d482:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400d484:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400d488:	011b      	lsls	r3, r3, #4
3400d48a:	d5f8      	bpl.n	3400d47e <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3400d48c:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400d490:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d494:	b003      	add	sp, #12
3400d496:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400d49a:	f7fc bedd 	b.w	3400a258 <RCCEx_GetPLLSourceFreq>
3400d49e:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400d4a2:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d4a6:	f7fc fed7 	bl	3400a258 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d4aa:	2800      	cmp	r0, #0
3400d4ac:	d0e7      	beq.n	3400d47e <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3400d4ae:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
        if (divm != 0U)
3400d4b2:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d4b6:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d4ba:	d0e0      	beq.n	3400d47e <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3400d4bc:	f8d4 20b0 	ldr.w	r2, [r4, #176]	@ 0xb0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3400d4c0:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400d4c4:	f8d4 50b8 	ldr.w	r5, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400d4c8:	f8d4 40b8 	ldr.w	r4, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400d4cc:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400d4d0:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
3400d4d4:	9401      	str	r4, [sp, #4]
3400d4d6:	9500      	str	r5, [sp, #0]
3400d4d8:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d4dc:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d4e0:	f7fc fef0 	bl	3400a2c4 <RCCEx_CalcPLLFreq>
3400d4e4:	e7cc      	b.n	3400d480 <HAL_RCCEx_GetPLL4CLKFreq+0x14>
3400d4e6:	bf00      	nop
3400d4e8:	56028000 	.word	0x56028000

3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>:
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3400d4ec:	4b3e      	ldr	r3, [pc, #248]	@ (3400d5e8 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
  * @param  CLKPxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
3400d4ee:	b510      	push	{r4, lr}
3400d4f0:	f8d3 2248 	ldr.w	r2, [r3, #584]	@ 0x248
3400d4f4:	0652      	lsls	r2, r2, #25
3400d4f6:	d56b      	bpl.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3400d4f8:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400d4fc:	f002 0207 	and.w	r2, r2, #7
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
3400d500:	3a01      	subs	r2, #1
3400d502:	2a06      	cmp	r2, #6
3400d504:	d805      	bhi.n	3400d512 <RCCEx_GetCLKPCLKFreq.constprop.0+0x26>
3400d506:	e8df f002 	tbb	[pc, r2]
3400d50a:	150f      	.short	0x150f
3400d50c:	3e321b48 	.word	0x3e321b48
3400d510:	54          	.byte	0x54
3400d511:	00          	.byte	0x00
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
3400d512:	f7fc fe07 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400d516:	2800      	cmp	r0, #0
3400d518:	d05a      	beq.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400d51a:	4b33      	ldr	r3, [pc, #204]	@ (3400d5e8 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400d51c:	4833      	ldr	r0, [pc, #204]	@ (3400d5ec <RCCEx_GetCLKPCLKFreq.constprop.0+0x100>)
3400d51e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d520:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400d524:	40d8      	lsrs	r0, r3
3400d526:	e054      	b.n	3400d5d2 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
3400d528:	f7fc fe04 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400d52c:	2800      	cmp	r0, #0
3400d52e:	d04f      	beq.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = MSI_VALUE;
3400d530:	482f      	ldr	r0, [pc, #188]	@ (3400d5f0 <RCCEx_GetCLKPCLKFreq.constprop.0+0x104>)
3400d532:	e04e      	b.n	3400d5d2 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
3400d534:	f7fc fdee 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400d538:	2800      	cmp	r0, #0
3400d53a:	d049      	beq.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = HSE_VALUE;
3400d53c:	482d      	ldr	r0, [pc, #180]	@ (3400d5f4 <RCCEx_GetCLKPCLKFreq.constprop.0+0x108>)
        /* Unexpected case */
        break;
    }
  }

  return clkp_frequency;
3400d53e:	e048      	b.n	3400d5d2 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400d540:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d544:	06d4      	lsls	r4, r2, #27
3400d546:	d543      	bpl.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400d548:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400d54c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400d550:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d554:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400d556:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
          switch (LL_RCC_IC20_GetSource())
3400d55a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d55e:	d03c      	beq.n	3400d5da <RCCEx_GetCLKPCLKFreq.constprop.0+0xee>
3400d560:	d833      	bhi.n	3400d5ca <RCCEx_GetCLKPCLKFreq.constprop.0+0xde>
3400d562:	bbbb      	cbnz	r3, 3400d5d4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe8>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d564:	f7ff fec2 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
              clkp_frequency = clkp_frequency / ic_divider;
3400d568:	fbb0 f0f4 	udiv	r0, r0, r4
              break;
3400d56c:	e031      	b.n	3400d5d2 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400d56e:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d572:	0590      	lsls	r0, r2, #22
3400d574:	d52c      	bpl.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400d576:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400d57a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400d57e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d582:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400d584:	e7e7      	b.n	3400d556 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
        if (LL_RCC_IC15_IsEnabled() != 0U)
3400d586:	f7fc fe4d 	bl	3400a224 <LL_RCC_IC15_IsEnabled>
3400d58a:	b308      	cbz	r0, 3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
          ic_divider = LL_RCC_IC15_GetDivider();
3400d58c:	f7fc fe52 	bl	3400a234 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400d590:	4b15      	ldr	r3, [pc, #84]	@ (3400d5e8 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
3400d592:	4604      	mov	r4, r0
3400d594:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d598:	e7dd      	b.n	3400d556 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400d59a:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d59e:	0351      	lsls	r1, r2, #13
3400d5a0:	d516      	bpl.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400d5a2:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400d5a6:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400d5aa:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d5ae:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400d5b0:	e7d1      	b.n	3400d556 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400d5b2:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d5b6:	0312      	lsls	r2, r2, #12
3400d5b8:	d50a      	bpl.n	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400d5ba:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400d5be:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400d5c2:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d5c6:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400d5c8:	e7c5      	b.n	3400d556 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
          switch (LL_RCC_IC20_GetSource())
3400d5ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d5ce:	d007      	beq.n	3400d5e0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xf4>
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d5d0:	2000      	movs	r0, #0
}
3400d5d2:	bd10      	pop	{r4, pc}
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d5d4:	f7ff feca 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400d5d8:	e7c6      	b.n	3400d568 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d5da:	f7ff ff07 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400d5de:	e7c3      	b.n	3400d568 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d5e0:	f7ff ff44 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400d5e4:	e7c0      	b.n	3400d568 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
3400d5e6:	bf00      	nop
3400d5e8:	56028000 	.word	0x56028000
3400d5ec:	03d09000 	.word	0x03d09000
3400d5f0:	003d0900 	.word	0x003d0900
3400d5f4:	02dc6c00 	.word	0x02dc6c00

3400d5f8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>:
  * @param  SPDIFRXxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
3400d5f8:	b538      	push	{r3, r4, r5, lr}
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3400d5fa:	4d2b      	ldr	r5, [pc, #172]	@ (3400d6a8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb0>)
3400d5fc:	f8d5 3164 	ldr.w	r3, [r5, #356]	@ 0x164
3400d600:	f003 0307 	and.w	r3, r3, #7
{
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400d604:	2b06      	cmp	r3, #6
3400d606:	d835      	bhi.n	3400d674 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
3400d608:	e8df f003 	tbb	[pc, r3]
3400d60c:	28110d04 	.word	0x28110d04
3400d610:	3c45      	.short	0x3c45
3400d612:	4b          	.byte	0x4b
3400d613:	00          	.byte	0x00
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400d614:	f7fc fd0c 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400d618:	f7fc fe16 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400d61c:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400d61e:	f003 0307 	and.w	r3, r3, #7
      break;

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400d622:	40d8      	lsrs	r0, r3
3400d624:	e027      	b.n	3400d676 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      /* Unexpected case */
      break;
  }

  return spdifrx_frequency;
}
3400d626:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d62a:	f7ff bf5f 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400d62e:	f7fc fdb1 	bl	3400a194 <LL_RCC_IC7_IsEnabled>
3400d632:	b1f8      	cbz	r0, 3400d674 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC7_GetDivider();
3400d634:	f7fc fdb6 	bl	3400a1a4 <LL_RCC_IC7_GetDivider>
3400d638:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400d63a:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400d63e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400d642:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d646:	d017      	beq.n	3400d678 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x80>
3400d648:	d811      	bhi.n	3400d66e <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x76>
3400d64a:	b913      	cbnz	r3, 3400d652 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5a>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d64c:	f7ff fe4e 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
3400d650:	e001      	b.n	3400d656 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d652:	f7ff fe8b 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400d656:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400d65a:	e00c      	b.n	3400d676 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400d65c:	f7fc fdac 	bl	3400a1b8 <LL_RCC_IC8_IsEnabled>
3400d660:	b140      	cbz	r0, 3400d674 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC8_GetDivider();
3400d662:	f7fc fdb1 	bl	3400a1c8 <LL_RCC_IC8_GetDivider>
3400d666:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400d66a:	4604      	mov	r4, r0
3400d66c:	e7e7      	b.n	3400d63e <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x46>
        switch (LL_RCC_IC8_GetSource())
3400d66e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d672:	d004      	beq.n	3400d67e <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x86>
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d674:	2000      	movs	r0, #0
}
3400d676:	bd38      	pop	{r3, r4, r5, pc}
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d678:	f7ff feb8 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400d67c:	e7eb      	b.n	3400d656 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d67e:	f7ff fef5 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400d682:	e7e8      	b.n	3400d656 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
      if (LL_RCC_HSI_IsReady() != 0U)
3400d684:	f7fc fd4e 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400d688:	2800      	cmp	r0, #0
3400d68a:	d0f3      	beq.n	3400d674 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400d68c:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400d68e:	4807      	ldr	r0, [pc, #28]	@ (3400d6ac <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb4>)
3400d690:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400d694:	e7c5      	b.n	3400d622 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x2a>
      if (LL_RCC_MSI_IsReady() != 0U)
3400d696:	f7fc fd4d 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400d69a:	2800      	cmp	r0, #0
3400d69c:	d0ea      	beq.n	3400d674 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        spdifrx_frequency = MSI_VALUE;
3400d69e:	4804      	ldr	r0, [pc, #16]	@ (3400d6b0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb8>)
3400d6a0:	e7e9      	b.n	3400d676 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400d6a2:	4804      	ldr	r0, [pc, #16]	@ (3400d6b4 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xbc>)
  return spdifrx_frequency;
3400d6a4:	e7e7      	b.n	3400d676 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
3400d6a6:	bf00      	nop
3400d6a8:	56028000 	.word	0x56028000
3400d6ac:	03d09000 	.word	0x03d09000
3400d6b0:	003d0900 	.word	0x003d0900
3400d6b4:	00bb8000 	.word	0x00bb8000

3400d6b8 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3400d6b8:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400d6ba:	f7fc fd5d 	bl	3400a178 <LL_RCC_GetClockSource>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d6be:	4b36      	ldr	r3, [pc, #216]	@ (3400d798 <RCCEx_GetXSPICLKFreq+0xe0>)
3400d6c0:	4298      	cmp	r0, r3
3400d6c2:	d028      	beq.n	3400d716 <RCCEx_GetXSPICLKFreq+0x5e>
3400d6c4:	d81b      	bhi.n	3400d6fe <RCCEx_GetXSPICLKFreq+0x46>
3400d6c6:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d6ca:	4298      	cmp	r0, r3
3400d6cc:	d013      	beq.n	3400d6f6 <RCCEx_GetXSPICLKFreq+0x3e>
3400d6ce:	d80b      	bhi.n	3400d6e8 <RCCEx_GetXSPICLKFreq+0x30>
3400d6d0:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400d6d4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d6d8:	429a      	cmp	r2, r3
3400d6da:	d04a      	beq.n	3400d772 <RCCEx_GetXSPICLKFreq+0xba>
3400d6dc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400d6e0:	4298      	cmp	r0, r3
3400d6e2:	d046      	beq.n	3400d772 <RCCEx_GetXSPICLKFreq+0xba>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d6e4:	2000      	movs	r0, #0
      /* Nothing to do */
      break;
  }

  return xspi_frequency;
}
3400d6e6:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d6e8:	4b2c      	ldr	r3, [pc, #176]	@ (3400d79c <RCCEx_GetXSPICLKFreq+0xe4>)
3400d6ea:	4298      	cmp	r0, r3
3400d6ec:	d003      	beq.n	3400d6f6 <RCCEx_GetXSPICLKFreq+0x3e>
3400d6ee:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d6f2:	4298      	cmp	r0, r3
3400d6f4:	d1f6      	bne.n	3400d6e4 <RCCEx_GetXSPICLKFreq+0x2c>
}
3400d6f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d6fa:	f7ff bef7 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d6fe:	4b28      	ldr	r3, [pc, #160]	@ (3400d7a0 <RCCEx_GetXSPICLKFreq+0xe8>)
3400d700:	4298      	cmp	r0, r3
3400d702:	d028      	beq.n	3400d756 <RCCEx_GetXSPICLKFreq+0x9e>
3400d704:	d820      	bhi.n	3400d748 <RCCEx_GetXSPICLKFreq+0x90>
3400d706:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400d70a:	4298      	cmp	r0, r3
3400d70c:	d003      	beq.n	3400d716 <RCCEx_GetXSPICLKFreq+0x5e>
3400d70e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d712:	4298      	cmp	r0, r3
3400d714:	d1e6      	bne.n	3400d6e4 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400d716:	4b23      	ldr	r3, [pc, #140]	@ (3400d7a4 <RCCEx_GetXSPICLKFreq+0xec>)
3400d718:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400d71c:	f010 0004 	ands.w	r0, r0, #4
3400d720:	d0e1      	beq.n	3400d6e6 <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400d722:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400d726:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400d72a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d72e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400d730:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC4_GetSource())
3400d734:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d738:	d02a      	beq.n	3400d790 <RCCEx_GetXSPICLKFreq+0xd8>
3400d73a:	d820      	bhi.n	3400d77e <RCCEx_GetXSPICLKFreq+0xc6>
3400d73c:	bb2b      	cbnz	r3, 3400d78a <RCCEx_GetXSPICLKFreq+0xd2>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d73e:	f7ff fdd5 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            xspi_frequency = xspi_frequency / ic_divider;
3400d742:	fbb0 f0f4 	udiv	r0, r0, r4
  return xspi_frequency;
3400d746:	e7ce      	b.n	3400d6e6 <RCCEx_GetXSPICLKFreq+0x2e>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d748:	4b17      	ldr	r3, [pc, #92]	@ (3400d7a8 <RCCEx_GetXSPICLKFreq+0xf0>)
3400d74a:	4298      	cmp	r0, r3
3400d74c:	d003      	beq.n	3400d756 <RCCEx_GetXSPICLKFreq+0x9e>
3400d74e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d752:	4298      	cmp	r0, r3
3400d754:	d1c6      	bne.n	3400d6e4 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400d756:	4b13      	ldr	r3, [pc, #76]	@ (3400d7a4 <RCCEx_GetXSPICLKFreq+0xec>)
3400d758:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400d75c:	f010 0008 	ands.w	r0, r0, #8
3400d760:	d0c1      	beq.n	3400d6e6 <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400d762:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400d766:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400d76a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d76e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400d770:	e7de      	b.n	3400d730 <RCCEx_GetXSPICLKFreq+0x78>
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400d772:	f7fc fc5d 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
}
3400d776:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400d77a:	f7fc bd65 	b.w	3400a248 <RCCEx_GetHCLKFreq>
        switch (LL_RCC_IC4_GetSource())
3400d77e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d782:	d1af      	bne.n	3400d6e4 <RCCEx_GetXSPICLKFreq+0x2c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d784:	f7ff fe72 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400d788:	e7db      	b.n	3400d742 <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d78a:	f7ff fdef 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400d78e:	e7d8      	b.n	3400d742 <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d790:	f7ff fe2c 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400d794:	e7d5      	b.n	3400d742 <RCCEx_GetXSPICLKFreq+0x8a>
3400d796:	bf00      	nop
3400d798:	03020014 	.word	0x03020014
3400d79c:	03010414 	.word	0x03010414
3400d7a0:	03030014 	.word	0x03030014
3400d7a4:	56028000 	.word	0x56028000
3400d7a8:	03030414 	.word	0x03030414

3400d7ac <RCCEx_GetOTGPHYCLKFreq>:
{
3400d7ac:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400d7ae:	f7fc fce3 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400d7b2:	4b2b      	ldr	r3, [pc, #172]	@ (3400d860 <RCCEx_GetOTGPHYCLKFreq+0xb4>)
3400d7b4:	4298      	cmp	r0, r3
3400d7b6:	d021      	beq.n	3400d7fc <RCCEx_GetOTGPHYCLKFreq+0x50>
3400d7b8:	d815      	bhi.n	3400d7e6 <RCCEx_GetOTGPHYCLKFreq+0x3a>
3400d7ba:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d7be:	4298      	cmp	r0, r3
3400d7c0:	d00d      	beq.n	3400d7de <RCCEx_GetOTGPHYCLKFreq+0x32>
3400d7c2:	d809      	bhi.n	3400d7d8 <RCCEx_GetOTGPHYCLKFreq+0x2c>
3400d7c4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d7c8:	4298      	cmp	r0, r3
3400d7ca:	d02d      	beq.n	3400d828 <RCCEx_GetOTGPHYCLKFreq+0x7c>
3400d7cc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400d7d0:	4298      	cmp	r0, r3
3400d7d2:	d029      	beq.n	3400d828 <RCCEx_GetOTGPHYCLKFreq+0x7c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d7d4:	2000      	movs	r0, #0
}
3400d7d6:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400d7d8:	4b22      	ldr	r3, [pc, #136]	@ (3400d864 <RCCEx_GetOTGPHYCLKFreq+0xb8>)
3400d7da:	4298      	cmp	r0, r3
3400d7dc:	d1fa      	bne.n	3400d7d4 <RCCEx_GetOTGPHYCLKFreq+0x28>
}
3400d7de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d7e2:	f7ff be83 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400d7e6:	4b20      	ldr	r3, [pc, #128]	@ (3400d868 <RCCEx_GetOTGPHYCLKFreq+0xbc>)
3400d7e8:	4298      	cmp	r0, r3
3400d7ea:	d023      	beq.n	3400d834 <RCCEx_GetOTGPHYCLKFreq+0x88>
3400d7ec:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400d7f0:	4298      	cmp	r0, r3
3400d7f2:	d01f      	beq.n	3400d834 <RCCEx_GetOTGPHYCLKFreq+0x88>
3400d7f4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d7f8:	4298      	cmp	r0, r3
3400d7fa:	d1eb      	bne.n	3400d7d4 <RCCEx_GetOTGPHYCLKFreq+0x28>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400d7fc:	f7fc fd12 	bl	3400a224 <LL_RCC_IC15_IsEnabled>
3400d800:	2800      	cmp	r0, #0
3400d802:	d0e7      	beq.n	3400d7d4 <RCCEx_GetOTGPHYCLKFreq+0x28>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
3400d804:	f7fc fd16 	bl	3400a234 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400d808:	4b18      	ldr	r3, [pc, #96]	@ (3400d86c <RCCEx_GetOTGPHYCLKFreq+0xc0>)
3400d80a:	4604      	mov	r4, r0
3400d80c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d810:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400d814:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d818:	d01f      	beq.n	3400d85a <RCCEx_GetOTGPHYCLKFreq+0xae>
3400d81a:	d815      	bhi.n	3400d848 <RCCEx_GetOTGPHYCLKFreq+0x9c>
3400d81c:	b9d3      	cbnz	r3, 3400d854 <RCCEx_GetOTGPHYCLKFreq+0xa8>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d81e:	f7ff fd65 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            usb_frequency = usb_frequency / ic_divider;
3400d822:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400d826:	e7d6      	b.n	3400d7d6 <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400d828:	f7fc fc74 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400d82c:	2800      	cmp	r0, #0
3400d82e:	d0d1      	beq.n	3400d7d4 <RCCEx_GetOTGPHYCLKFreq+0x28>
        usb_frequency = HSE_VALUE / 2U;
3400d830:	480f      	ldr	r0, [pc, #60]	@ (3400d870 <RCCEx_GetOTGPHYCLKFreq+0xc4>)
3400d832:	e7d0      	b.n	3400d7d6 <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400d834:	f7fc fc6e 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400d838:	2800      	cmp	r0, #0
3400d83a:	d0cb      	beq.n	3400d7d4 <RCCEx_GetOTGPHYCLKFreq+0x28>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400d83c:	f7fc fc62 	bl	3400a104 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3400d840:	2800      	cmp	r0, #0
3400d842:	d1f5      	bne.n	3400d830 <RCCEx_GetOTGPHYCLKFreq+0x84>
          usb_frequency = HSE_VALUE;
3400d844:	480b      	ldr	r0, [pc, #44]	@ (3400d874 <RCCEx_GetOTGPHYCLKFreq+0xc8>)
  return usb_frequency;
3400d846:	e7c6      	b.n	3400d7d6 <RCCEx_GetOTGPHYCLKFreq+0x2a>
        switch (LL_RCC_IC15_GetSource())
3400d848:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d84c:	d1c2      	bne.n	3400d7d4 <RCCEx_GetOTGPHYCLKFreq+0x28>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d84e:	f7ff fe0d 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400d852:	e7e6      	b.n	3400d822 <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d854:	f7ff fd8a 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400d858:	e7e3      	b.n	3400d822 <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d85a:	f7ff fdc7 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400d85e:	e7e0      	b.n	3400d822 <RCCEx_GetOTGPHYCLKFreq+0x76>
3400d860:	03020c14 	.word	0x03020c14
3400d864:	03011414 	.word	0x03011414
3400d868:	03030c14 	.word	0x03030c14
3400d86c:	56028000 	.word	0x56028000
3400d870:	016e3600 	.word	0x016e3600
3400d874:	02dc6c00 	.word	0x02dc6c00

3400d878 <RCCEx_GetOTGPHYCKREFCLKFreq>:
{
3400d878:	b508      	push	{r3, lr}
  return LL_RCC_GetClockSource(Periph);
3400d87a:	f7fc fc7d 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400d87e:	4b11      	ldr	r3, [pc, #68]	@ (3400d8c4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x4c>)
3400d880:	4298      	cmp	r0, r3
3400d882:	d01c      	beq.n	3400d8be <RCCEx_GetOTGPHYCKREFCLKFreq+0x46>
3400d884:	d805      	bhi.n	3400d892 <RCCEx_GetOTGPHYCKREFCLKFreq+0x1a>
3400d886:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400d88a:	4298      	cmp	r0, r3
3400d88c:	d012      	beq.n	3400d8b4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d88e:	2000      	movs	r0, #0
}
3400d890:	bd08      	pop	{r3, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400d892:	4b0d      	ldr	r3, [pc, #52]	@ (3400d8c8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x50>)
3400d894:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3400d898:	4298      	cmp	r0, r3
3400d89a:	d1f8      	bne.n	3400d88e <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
      if (LL_RCC_HSE_IsReady() != 0U)
3400d89c:	f7fc fc3a 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400d8a0:	2800      	cmp	r0, #0
3400d8a2:	d0f4      	beq.n	3400d88e <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400d8a4:	f7fc fc2e 	bl	3400a104 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
          usb_frequency = HSE_VALUE;
3400d8a8:	4b08      	ldr	r3, [pc, #32]	@ (3400d8cc <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>)
3400d8aa:	2800      	cmp	r0, #0
3400d8ac:	4808      	ldr	r0, [pc, #32]	@ (3400d8d0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x58>)
3400d8ae:	bf08      	it	eq
3400d8b0:	4618      	moveq	r0, r3
3400d8b2:	e7ed      	b.n	3400d890 <RCCEx_GetOTGPHYCKREFCLKFreq+0x18>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400d8b4:	4807      	ldr	r0, [pc, #28]	@ (3400d8d4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5c>)
}
3400d8b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400d8ba:	f7ff bf77 	b.w	3400d7ac <RCCEx_GetOTGPHYCLKFreq>
3400d8be:	4806      	ldr	r0, [pc, #24]	@ (3400d8d8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x60>)
3400d8c0:	e7f9      	b.n	3400d8b6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3e>
3400d8c2:	bf00      	nop
3400d8c4:	01001814 	.word	0x01001814
3400d8c8:	01011014 	.word	0x01011014
3400d8cc:	02dc6c00 	.word	0x02dc6c00
3400d8d0:	016e3600 	.word	0x016e3600
3400d8d4:	03000c14 	.word	0x03000c14
3400d8d8:	03001414 	.word	0x03001414

3400d8dc <RCCEx_GetUSARTCLKFreq>:
{
3400d8dc:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400d8de:	f7fc fc4b 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d8e2:	4b6f      	ldr	r3, [pc, #444]	@ (3400daa0 <RCCEx_GetUSARTCLKFreq+0x1c4>)
3400d8e4:	4298      	cmp	r0, r3
3400d8e6:	d039      	beq.n	3400d95c <RCCEx_GetUSARTCLKFreq+0x80>
3400d8e8:	d852      	bhi.n	3400d990 <RCCEx_GetUSARTCLKFreq+0xb4>
3400d8ea:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400d8ee:	4298      	cmp	r0, r3
3400d8f0:	f000 80b5 	beq.w	3400da5e <RCCEx_GetUSARTCLKFreq+0x182>
3400d8f4:	d813      	bhi.n	3400d91e <RCCEx_GetUSARTCLKFreq+0x42>
3400d8f6:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400d8fa:	4298      	cmp	r0, r3
3400d8fc:	f000 80af 	beq.w	3400da5e <RCCEx_GetUSARTCLKFreq+0x182>
3400d900:	d80b      	bhi.n	3400d91a <RCCEx_GetUSARTCLKFreq+0x3e>
3400d902:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400d906:	4298      	cmp	r0, r3
3400d908:	f000 80a9 	beq.w	3400da5e <RCCEx_GetUSARTCLKFreq+0x182>
3400d90c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d910:	4298      	cmp	r0, r3
3400d912:	f000 80ae 	beq.w	3400da72 <RCCEx_GetUSARTCLKFreq+0x196>
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d916:	2000      	movs	r0, #0
}
3400d918:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d91a:	4b62      	ldr	r3, [pc, #392]	@ (3400daa4 <RCCEx_GetUSARTCLKFreq+0x1c8>)
3400d91c:	e7f8      	b.n	3400d910 <RCCEx_GetUSARTCLKFreq+0x34>
3400d91e:	4b62      	ldr	r3, [pc, #392]	@ (3400daa8 <RCCEx_GetUSARTCLKFreq+0x1cc>)
3400d920:	4298      	cmp	r0, r3
3400d922:	d00c      	beq.n	3400d93e <RCCEx_GetUSARTCLKFreq+0x62>
3400d924:	d80f      	bhi.n	3400d946 <RCCEx_GetUSARTCLKFreq+0x6a>
3400d926:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400d92a:	4298      	cmp	r0, r3
3400d92c:	d007      	beq.n	3400d93e <RCCEx_GetUSARTCLKFreq+0x62>
3400d92e:	bf8e      	itee	hi
3400d930:	4b5e      	ldrhi	r3, [pc, #376]	@ (3400daac <RCCEx_GetUSARTCLKFreq+0x1d0>)
3400d932:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400d936:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400d93a:	4298      	cmp	r0, r3
3400d93c:	d1eb      	bne.n	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
}
3400d93e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d942:	f7ff bdd3 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d946:	4b5a      	ldr	r3, [pc, #360]	@ (3400dab0 <RCCEx_GetUSARTCLKFreq+0x1d4>)
3400d948:	4298      	cmp	r0, r3
3400d94a:	d007      	beq.n	3400d95c <RCCEx_GetUSARTCLKFreq+0x80>
3400d94c:	bf8e      	itee	hi
3400d94e:	4b59      	ldrhi	r3, [pc, #356]	@ (3400dab4 <RCCEx_GetUSARTCLKFreq+0x1d8>)
3400d950:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400d954:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400d958:	4298      	cmp	r0, r3
3400d95a:	d1dc      	bne.n	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400d95c:	f7fc fc3e 	bl	3400a1dc <LL_RCC_IC9_IsEnabled>
3400d960:	2800      	cmp	r0, #0
3400d962:	d0d8      	beq.n	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC9_GetDivider();
3400d964:	f7fc fc42 	bl	3400a1ec <LL_RCC_IC9_GetDivider>
3400d968:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400d96a:	4b53      	ldr	r3, [pc, #332]	@ (3400dab8 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400d96c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400d970:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400d974:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d978:	f000 808e 	beq.w	3400da98 <RCCEx_GetUSARTCLKFreq+0x1bc>
3400d97c:	f200 8082 	bhi.w	3400da84 <RCCEx_GetUSARTCLKFreq+0x1a8>
3400d980:	2b00      	cmp	r3, #0
3400d982:	f040 8086 	bne.w	3400da92 <RCCEx_GetUSARTCLKFreq+0x1b6>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d986:	f7ff fcb1 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            usart_frequency = usart_frequency / ic_divider;
3400d98a:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400d98e:	e7c3      	b.n	3400d918 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d990:	4b4a      	ldr	r3, [pc, #296]	@ (3400dabc <RCCEx_GetUSARTCLKFreq+0x1e0>)
3400d992:	4298      	cmp	r0, r3
3400d994:	d045      	beq.n	3400da22 <RCCEx_GetUSARTCLKFreq+0x146>
3400d996:	d833      	bhi.n	3400da00 <RCCEx_GetUSARTCLKFreq+0x124>
3400d998:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d99c:	4298      	cmp	r0, r3
3400d99e:	d028      	beq.n	3400d9f2 <RCCEx_GetUSARTCLKFreq+0x116>
3400d9a0:	d81c      	bhi.n	3400d9dc <RCCEx_GetUSARTCLKFreq+0x100>
3400d9a2:	f5a3 437b 	sub.w	r3, r3, #64256	@ 0xfb00
3400d9a6:	3bfc      	subs	r3, #252	@ 0xfc
3400d9a8:	4298      	cmp	r0, r3
3400d9aa:	d006      	beq.n	3400d9ba <RCCEx_GetUSARTCLKFreq+0xde>
3400d9ac:	d810      	bhi.n	3400d9d0 <RCCEx_GetUSARTCLKFreq+0xf4>
3400d9ae:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400d9b2:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400d9b6:	4298      	cmp	r0, r3
3400d9b8:	d1ad      	bne.n	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400d9ba:	f7fc fc21 	bl	3400a200 <LL_RCC_IC14_IsEnabled>
3400d9be:	2800      	cmp	r0, #0
3400d9c0:	d0a9      	beq.n	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC14_GetDivider();
3400d9c2:	f7fc fc25 	bl	3400a210 <LL_RCC_IC14_GetDivider>
3400d9c6:	4b3c      	ldr	r3, [pc, #240]	@ (3400dab8 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400d9c8:	4604      	mov	r4, r0
3400d9ca:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400d9ce:	e7cf      	b.n	3400d970 <RCCEx_GetUSARTCLKFreq+0x94>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d9d0:	4b3b      	ldr	r3, [pc, #236]	@ (3400dac0 <RCCEx_GetUSARTCLKFreq+0x1e4>)
3400d9d2:	4298      	cmp	r0, r3
3400d9d4:	d0f1      	beq.n	3400d9ba <RCCEx_GetUSARTCLKFreq+0xde>
3400d9d6:	f503 6340 	add.w	r3, r3, #3072	@ 0xc00
3400d9da:	e7ec      	b.n	3400d9b6 <RCCEx_GetUSARTCLKFreq+0xda>
3400d9dc:	4b39      	ldr	r3, [pc, #228]	@ (3400dac4 <RCCEx_GetUSARTCLKFreq+0x1e8>)
3400d9de:	4298      	cmp	r0, r3
3400d9e0:	d007      	beq.n	3400d9f2 <RCCEx_GetUSARTCLKFreq+0x116>
3400d9e2:	bf8e      	itee	hi
3400d9e4:	4b38      	ldrhi	r3, [pc, #224]	@ (3400dac8 <RCCEx_GetUSARTCLKFreq+0x1ec>)
3400d9e6:	f020 0004 	bicls.w	r0, r0, #4
3400d9ea:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400d9ee:	4298      	cmp	r0, r3
3400d9f0:	d191      	bne.n	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_LSE_IsReady() != 0U)
3400d9f2:	f7fc fba7 	bl	3400a144 <LL_RCC_LSE_IsReady>
3400d9f6:	3800      	subs	r0, #0
3400d9f8:	bf18      	it	ne
3400d9fa:	2001      	movne	r0, #1
3400d9fc:	03c0      	lsls	r0, r0, #15
3400d9fe:	e78b      	b.n	3400d918 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400da00:	4b32      	ldr	r3, [pc, #200]	@ (3400dacc <RCCEx_GetUSARTCLKFreq+0x1f0>)
3400da02:	4298      	cmp	r0, r3
3400da04:	d020      	beq.n	3400da48 <RCCEx_GetUSARTCLKFreq+0x16c>
3400da06:	d813      	bhi.n	3400da30 <RCCEx_GetUSARTCLKFreq+0x154>
3400da08:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400da0c:	4298      	cmp	r0, r3
3400da0e:	d008      	beq.n	3400da22 <RCCEx_GetUSARTCLKFreq+0x146>
3400da10:	bf8e      	itee	hi
3400da12:	4b2f      	ldrhi	r3, [pc, #188]	@ (3400dad0 <RCCEx_GetUSARTCLKFreq+0x1f4>)
3400da14:	f020 0004 	bicls.w	r0, r0, #4
3400da18:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400da1c:	4298      	cmp	r0, r3
3400da1e:	f47f af7a 	bne.w	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_MSI_IsReady() != 0U)
3400da22:	f7fc fb87 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400da26:	2800      	cmp	r0, #0
3400da28:	f43f af75 	beq.w	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
        usart_frequency = MSI_VALUE;
3400da2c:	4829      	ldr	r0, [pc, #164]	@ (3400dad4 <RCCEx_GetUSARTCLKFreq+0x1f8>)
  return usart_frequency;
3400da2e:	e773      	b.n	3400d918 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400da30:	4b29      	ldr	r3, [pc, #164]	@ (3400dad8 <RCCEx_GetUSARTCLKFreq+0x1fc>)
3400da32:	4298      	cmp	r0, r3
3400da34:	d008      	beq.n	3400da48 <RCCEx_GetUSARTCLKFreq+0x16c>
3400da36:	bf8e      	itee	hi
3400da38:	4b28      	ldrhi	r3, [pc, #160]	@ (3400dadc <RCCEx_GetUSARTCLKFreq+0x200>)
3400da3a:	f020 0004 	bicls.w	r0, r0, #4
3400da3e:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400da42:	4298      	cmp	r0, r3
3400da44:	f47f af67 	bne.w	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_HSI_IsReady() != 0U)
3400da48:	f7fc fb6c 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400da4c:	2800      	cmp	r0, #0
3400da4e:	f43f af62 	beq.w	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400da52:	4b19      	ldr	r3, [pc, #100]	@ (3400dab8 <RCCEx_GetUSARTCLKFreq+0x1dc>)
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400da54:	4822      	ldr	r0, [pc, #136]	@ (3400dae0 <RCCEx_GetUSARTCLKFreq+0x204>)
3400da56:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400da58:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400da5c:	e007      	b.n	3400da6e <RCCEx_GetUSARTCLKFreq+0x192>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400da5e:	f7fc fae7 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400da62:	f7fc fbf1 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400da66:	4b14      	ldr	r3, [pc, #80]	@ (3400dab8 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400da68:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400da6a:	f3c3 1302 	ubfx	r3, r3, #4, #3
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400da6e:	40d8      	lsrs	r0, r3
3400da70:	e752      	b.n	3400d918 <RCCEx_GetUSARTCLKFreq+0x3c>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400da72:	f7fc fadd 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400da76:	f7fc fbe7 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400da7a:	4b0f      	ldr	r3, [pc, #60]	@ (3400dab8 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400da7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400da7e:	f003 0307 	and.w	r3, r3, #7
3400da82:	e7f4      	b.n	3400da6e <RCCEx_GetUSARTCLKFreq+0x192>
        switch (LL_RCC_IC14_GetSource())
3400da84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400da88:	f47f af45 	bne.w	3400d916 <RCCEx_GetUSARTCLKFreq+0x3a>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400da8c:	f7ff fcee 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400da90:	e77b      	b.n	3400d98a <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400da92:	f7ff fc6b 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400da96:	e778      	b.n	3400d98a <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400da98:	f7ff fca8 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400da9c:	e775      	b.n	3400d98a <RCCEx_GetUSARTCLKFreq+0xae>
3400da9e:	bf00      	nop
3400daa0:	07021430 	.word	0x07021430
3400daa4:	07000830 	.word	0x07000830
3400daa8:	07011430 	.word	0x07011430
3400daac:	07010830 	.word	0x07010830
3400dab0:	07020434 	.word	0x07020434
3400dab4:	07020830 	.word	0x07020830
3400dab8:	56028000 	.word	0x56028000
3400dabc:	07050030 	.word	0x07050030
3400dac0:	07030830 	.word	0x07030830
3400dac4:	07040830 	.word	0x07040830
3400dac8:	07041430 	.word	0x07041430
3400dacc:	07060030 	.word	0x07060030
3400dad0:	07051430 	.word	0x07051430
3400dad4:	003d0900 	.word	0x003d0900
3400dad8:	07060830 	.word	0x07060830
3400dadc:	07061430 	.word	0x07061430
3400dae0:	03d09000 	.word	0x03d09000

3400dae4 <RCCEx_GetUARTCLKFreq>:
{
3400dae4:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400dae6:	f7fc fb47 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400daea:	4b77      	ldr	r3, [pc, #476]	@ (3400dcc8 <RCCEx_GetUARTCLKFreq+0x1e4>)
3400daec:	4298      	cmp	r0, r3
3400daee:	d03e      	beq.n	3400db6e <RCCEx_GetUARTCLKFreq+0x8a>
3400daf0:	d859      	bhi.n	3400dba6 <RCCEx_GetUARTCLKFreq+0xc2>
3400daf2:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400daf6:	4298      	cmp	r0, r3
3400daf8:	f000 80c6 	beq.w	3400dc88 <RCCEx_GetUARTCLKFreq+0x1a4>
3400dafc:	d814      	bhi.n	3400db28 <RCCEx_GetUARTCLKFreq+0x44>
3400dafe:	4b73      	ldr	r3, [pc, #460]	@ (3400dccc <RCCEx_GetUARTCLKFreq+0x1e8>)
3400db00:	4298      	cmp	r0, r3
3400db02:	f000 80cb 	beq.w	3400dc9c <RCCEx_GetUARTCLKFreq+0x1b8>
3400db06:	3b01      	subs	r3, #1
3400db08:	4298      	cmp	r0, r3
3400db0a:	d90b      	bls.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
3400db0c:	f420 6200 	bic.w	r2, r0, #2048	@ 0x800
3400db10:	f603 73fd 	addw	r3, r3, #4093	@ 0xffd
3400db14:	429a      	cmp	r2, r3
3400db16:	f000 80b7 	beq.w	3400dc88 <RCCEx_GetUARTCLKFreq+0x1a4>
3400db1a:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400db1e:	4298      	cmp	r0, r3
3400db20:	f000 80b2 	beq.w	3400dc88 <RCCEx_GetUARTCLKFreq+0x1a4>
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400db24:	2000      	movs	r0, #0
}
3400db26:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400db28:	4b69      	ldr	r3, [pc, #420]	@ (3400dcd0 <RCCEx_GetUARTCLKFreq+0x1ec>)
3400db2a:	4298      	cmp	r0, r3
3400db2c:	d00d      	beq.n	3400db4a <RCCEx_GetUARTCLKFreq+0x66>
3400db2e:	d812      	bhi.n	3400db56 <RCCEx_GetUARTCLKFreq+0x72>
3400db30:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400db34:	4298      	cmp	r0, r3
3400db36:	d008      	beq.n	3400db4a <RCCEx_GetUARTCLKFreq+0x66>
3400db38:	d80b      	bhi.n	3400db52 <RCCEx_GetUARTCLKFreq+0x6e>
3400db3a:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400db3e:	4298      	cmp	r0, r3
3400db40:	d003      	beq.n	3400db4a <RCCEx_GetUARTCLKFreq+0x66>
3400db42:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400db46:	4298      	cmp	r0, r3
3400db48:	d1ec      	bne.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
}
3400db4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400db4e:	f7ff bccd 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400db52:	4b60      	ldr	r3, [pc, #384]	@ (3400dcd4 <RCCEx_GetUARTCLKFreq+0x1f0>)
3400db54:	e7f7      	b.n	3400db46 <RCCEx_GetUARTCLKFreq+0x62>
3400db56:	4b60      	ldr	r3, [pc, #384]	@ (3400dcd8 <RCCEx_GetUARTCLKFreq+0x1f4>)
3400db58:	4298      	cmp	r0, r3
3400db5a:	d008      	beq.n	3400db6e <RCCEx_GetUARTCLKFreq+0x8a>
3400db5c:	d821      	bhi.n	3400dba2 <RCCEx_GetUARTCLKFreq+0xbe>
3400db5e:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400db62:	4298      	cmp	r0, r3
3400db64:	d003      	beq.n	3400db6e <RCCEx_GetUARTCLKFreq+0x8a>
3400db66:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400db6a:	4298      	cmp	r0, r3
3400db6c:	d1da      	bne.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400db6e:	f7fc fb35 	bl	3400a1dc <LL_RCC_IC9_IsEnabled>
3400db72:	2800      	cmp	r0, #0
3400db74:	d0d6      	beq.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC9_GetDivider();
3400db76:	f7fc fb39 	bl	3400a1ec <LL_RCC_IC9_GetDivider>
3400db7a:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400db7c:	4b57      	ldr	r3, [pc, #348]	@ (3400dcdc <RCCEx_GetUARTCLKFreq+0x1f8>)
3400db7e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400db82:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400db86:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400db8a:	f000 809a 	beq.w	3400dcc2 <RCCEx_GetUARTCLKFreq+0x1de>
3400db8e:	f200 808e 	bhi.w	3400dcae <RCCEx_GetUARTCLKFreq+0x1ca>
3400db92:	2b00      	cmp	r3, #0
3400db94:	f040 8092 	bne.w	3400dcbc <RCCEx_GetUARTCLKFreq+0x1d8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400db98:	f7ff fba8 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            uart_frequency = uart_frequency / ic_divider;
3400db9c:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400dba0:	e7c1      	b.n	3400db26 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dba2:	4b4f      	ldr	r3, [pc, #316]	@ (3400dce0 <RCCEx_GetUARTCLKFreq+0x1fc>)
3400dba4:	e7e1      	b.n	3400db6a <RCCEx_GetUARTCLKFreq+0x86>
3400dba6:	4b4f      	ldr	r3, [pc, #316]	@ (3400dce4 <RCCEx_GetUARTCLKFreq+0x200>)
3400dba8:	4298      	cmp	r0, r3
3400dbaa:	d04a      	beq.n	3400dc42 <RCCEx_GetUARTCLKFreq+0x15e>
3400dbac:	d836      	bhi.n	3400dc1c <RCCEx_GetUARTCLKFreq+0x138>
3400dbae:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400dbb2:	4298      	cmp	r0, r3
3400dbb4:	d029      	beq.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x126>
3400dbb6:	d81c      	bhi.n	3400dbf2 <RCCEx_GetUARTCLKFreq+0x10e>
3400dbb8:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400dbbc:	3b04      	subs	r3, #4
3400dbbe:	4298      	cmp	r0, r3
3400dbc0:	d008      	beq.n	3400dbd4 <RCCEx_GetUARTCLKFreq+0xf0>
3400dbc2:	d812      	bhi.n	3400dbea <RCCEx_GetUARTCLKFreq+0x106>
3400dbc4:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400dbc8:	4298      	cmp	r0, r3
3400dbca:	d003      	beq.n	3400dbd4 <RCCEx_GetUARTCLKFreq+0xf0>
3400dbcc:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400dbd0:	4298      	cmp	r0, r3
3400dbd2:	d1a7      	bne.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400dbd4:	f7fc fb14 	bl	3400a200 <LL_RCC_IC14_IsEnabled>
3400dbd8:	2800      	cmp	r0, #0
3400dbda:	d0a3      	beq.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC14_GetDivider();
3400dbdc:	f7fc fb18 	bl	3400a210 <LL_RCC_IC14_GetDivider>
3400dbe0:	4b3e      	ldr	r3, [pc, #248]	@ (3400dcdc <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dbe2:	4604      	mov	r4, r0
3400dbe4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400dbe8:	e7cb      	b.n	3400db82 <RCCEx_GetUARTCLKFreq+0x9e>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dbea:	4b3f      	ldr	r3, [pc, #252]	@ (3400dce8 <RCCEx_GetUARTCLKFreq+0x204>)
3400dbec:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400dbf0:	e7ee      	b.n	3400dbd0 <RCCEx_GetUARTCLKFreq+0xec>
3400dbf2:	4b3e      	ldr	r3, [pc, #248]	@ (3400dcec <RCCEx_GetUARTCLKFreq+0x208>)
3400dbf4:	4298      	cmp	r0, r3
3400dbf6:	d008      	beq.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x126>
3400dbf8:	d80e      	bhi.n	3400dc18 <RCCEx_GetUARTCLKFreq+0x134>
3400dbfa:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dbfe:	4298      	cmp	r0, r3
3400dc00:	d003      	beq.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x126>
3400dc02:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dc06:	4298      	cmp	r0, r3
3400dc08:	d18c      	bne.n	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_LSE_IsReady() != 0U)
3400dc0a:	f7fc fa9b 	bl	3400a144 <LL_RCC_LSE_IsReady>
3400dc0e:	3800      	subs	r0, #0
3400dc10:	bf18      	it	ne
3400dc12:	2001      	movne	r0, #1
3400dc14:	03c0      	lsls	r0, r0, #15
3400dc16:	e786      	b.n	3400db26 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dc18:	4b35      	ldr	r3, [pc, #212]	@ (3400dcf0 <RCCEx_GetUARTCLKFreq+0x20c>)
3400dc1a:	e7f4      	b.n	3400dc06 <RCCEx_GetUARTCLKFreq+0x122>
3400dc1c:	4b35      	ldr	r3, [pc, #212]	@ (3400dcf4 <RCCEx_GetUARTCLKFreq+0x210>)
3400dc1e:	4298      	cmp	r0, r3
3400dc20:	d025      	beq.n	3400dc6e <RCCEx_GetUARTCLKFreq+0x18a>
3400dc22:	d817      	bhi.n	3400dc54 <RCCEx_GetUARTCLKFreq+0x170>
3400dc24:	f5a3 4368 	sub.w	r3, r3, #59392	@ 0xe800
3400dc28:	3b04      	subs	r3, #4
3400dc2a:	4298      	cmp	r0, r3
3400dc2c:	d009      	beq.n	3400dc42 <RCCEx_GetUARTCLKFreq+0x15e>
3400dc2e:	d80f      	bhi.n	3400dc50 <RCCEx_GetUARTCLKFreq+0x16c>
3400dc30:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dc34:	4298      	cmp	r0, r3
3400dc36:	d004      	beq.n	3400dc42 <RCCEx_GetUARTCLKFreq+0x15e>
3400dc38:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dc3c:	4298      	cmp	r0, r3
3400dc3e:	f47f af71 	bne.w	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_MSI_IsReady() != 0U)
3400dc42:	f7fc fa77 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400dc46:	2800      	cmp	r0, #0
3400dc48:	f43f af6c 	beq.w	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
        uart_frequency = MSI_VALUE;
3400dc4c:	482a      	ldr	r0, [pc, #168]	@ (3400dcf8 <RCCEx_GetUARTCLKFreq+0x214>)
  return uart_frequency;
3400dc4e:	e76a      	b.n	3400db26 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dc50:	4b2a      	ldr	r3, [pc, #168]	@ (3400dcfc <RCCEx_GetUARTCLKFreq+0x218>)
3400dc52:	e7f3      	b.n	3400dc3c <RCCEx_GetUARTCLKFreq+0x158>
3400dc54:	4b2a      	ldr	r3, [pc, #168]	@ (3400dd00 <RCCEx_GetUARTCLKFreq+0x21c>)
3400dc56:	4298      	cmp	r0, r3
3400dc58:	d009      	beq.n	3400dc6e <RCCEx_GetUARTCLKFreq+0x18a>
3400dc5a:	d813      	bhi.n	3400dc84 <RCCEx_GetUARTCLKFreq+0x1a0>
3400dc5c:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dc60:	4298      	cmp	r0, r3
3400dc62:	d004      	beq.n	3400dc6e <RCCEx_GetUARTCLKFreq+0x18a>
3400dc64:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dc68:	4298      	cmp	r0, r3
3400dc6a:	f47f af5b 	bne.w	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_HSI_IsReady() != 0U)
3400dc6e:	f7fc fa59 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400dc72:	2800      	cmp	r0, #0
3400dc74:	f43f af56 	beq.w	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400dc78:	4b18      	ldr	r3, [pc, #96]	@ (3400dcdc <RCCEx_GetUARTCLKFreq+0x1f8>)
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400dc7a:	4822      	ldr	r0, [pc, #136]	@ (3400dd04 <RCCEx_GetUARTCLKFreq+0x220>)
3400dc7c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400dc7e:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400dc82:	e009      	b.n	3400dc98 <RCCEx_GetUARTCLKFreq+0x1b4>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dc84:	4b20      	ldr	r3, [pc, #128]	@ (3400dd08 <RCCEx_GetUARTCLKFreq+0x224>)
3400dc86:	e7ef      	b.n	3400dc68 <RCCEx_GetUARTCLKFreq+0x184>
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dc88:	f7fc f9d2 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400dc8c:	f7fc fadc 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400dc90:	4b12      	ldr	r3, [pc, #72]	@ (3400dcdc <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dc92:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400dc94:	f003 0307 	and.w	r3, r3, #7
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400dc98:	40d8      	lsrs	r0, r3
3400dc9a:	e744      	b.n	3400db26 <RCCEx_GetUARTCLKFreq+0x42>
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dc9c:	f7fc f9c8 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400dca0:	f7fc fad2 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400dca4:	4b0d      	ldr	r3, [pc, #52]	@ (3400dcdc <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dca6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400dca8:	f3c3 1302 	ubfx	r3, r3, #4, #3
3400dcac:	e7f4      	b.n	3400dc98 <RCCEx_GetUARTCLKFreq+0x1b4>
        switch (LL_RCC_IC14_GetSource())
3400dcae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dcb2:	f47f af37 	bne.w	3400db24 <RCCEx_GetUARTCLKFreq+0x40>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400dcb6:	f7ff fbd9 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400dcba:	e76f      	b.n	3400db9c <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400dcbc:	f7ff fb56 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400dcc0:	e76c      	b.n	3400db9c <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400dcc2:	f7ff fb93 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400dcc6:	e769      	b.n	3400db9c <RCCEx_GetUARTCLKFreq+0xb8>
3400dcc8:	07021c30 	.word	0x07021c30
3400dccc:	07000034 	.word	0x07000034
3400dcd0:	07011c30 	.word	0x07011c30
3400dcd4:	07011830 	.word	0x07011830
3400dcd8:	07021030 	.word	0x07021030
3400dcdc:	56028000 	.word	0x56028000
3400dce0:	07021830 	.word	0x07021830
3400dce4:	07050034 	.word	0x07050034
3400dce8:	07031830 	.word	0x07031830
3400dcec:	07041830 	.word	0x07041830
3400dcf0:	07041c30 	.word	0x07041c30
3400dcf4:	07060034 	.word	0x07060034
3400dcf8:	003d0900 	.word	0x003d0900
3400dcfc:	07051c30 	.word	0x07051c30
3400dd00:	07061830 	.word	0x07061830
3400dd04:	03d09000 	.word	0x03d09000
3400dd08:	07061c30 	.word	0x07061c30

3400dd0c <RCCEx_GetSPICLKFreq>:
{
3400dd0c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400dd0e:	f7fc fa33 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400dd12:	4b89      	ldr	r3, [pc, #548]	@ (3400df38 <RCCEx_GetSPICLKFreq+0x22c>)
3400dd14:	4298      	cmp	r0, r3
3400dd16:	d055      	beq.n	3400ddc4 <RCCEx_GetSPICLKFreq+0xb8>
3400dd18:	d865      	bhi.n	3400dde6 <RCCEx_GetSPICLKFreq+0xda>
3400dd1a:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
3400dd1e:	4298      	cmp	r0, r3
3400dd20:	f000 80ca 	beq.w	3400deb8 <RCCEx_GetSPICLKFreq+0x1ac>
3400dd24:	d81e      	bhi.n	3400dd64 <RCCEx_GetSPICLKFreq+0x58>
3400dd26:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dd2a:	4298      	cmp	r0, r3
3400dd2c:	f000 80ba 	beq.w	3400dea4 <RCCEx_GetSPICLKFreq+0x198>
3400dd30:	d80a      	bhi.n	3400dd48 <RCCEx_GetSPICLKFreq+0x3c>
3400dd32:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400dd36:	4298      	cmp	r0, r3
3400dd38:	d00b      	beq.n	3400dd52 <RCCEx_GetSPICLKFreq+0x46>
3400dd3a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dd3e:	4298      	cmp	r0, r3
3400dd40:	f000 80b0 	beq.w	3400dea4 <RCCEx_GetSPICLKFreq+0x198>
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400dd44:	2000      	movs	r0, #0
}
3400dd46:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400dd48:	4b7c      	ldr	r3, [pc, #496]	@ (3400df3c <RCCEx_GetSPICLKFreq+0x230>)
3400dd4a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400dd4e:	4298      	cmp	r0, r3
3400dd50:	d1f8      	bne.n	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dd52:	f7fc f96d 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400dd56:	f7fc fa77 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400dd5a:	4b79      	ldr	r3, [pc, #484]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
3400dd5c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400dd5e:	f3c3 1302 	ubfx	r3, r3, #4, #3
3400dd62:	e0a7      	b.n	3400deb4 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400dd64:	4b77      	ldr	r3, [pc, #476]	@ (3400df44 <RCCEx_GetSPICLKFreq+0x238>)
3400dd66:	4298      	cmp	r0, r3
3400dd68:	f000 80af 	beq.w	3400deca <RCCEx_GetSPICLKFreq+0x1be>
3400dd6c:	d81d      	bhi.n	3400ddaa <RCCEx_GetSPICLKFreq+0x9e>
3400dd6e:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400dd72:	4298      	cmp	r0, r3
3400dd74:	d00a      	beq.n	3400dd8c <RCCEx_GetSPICLKFreq+0x80>
3400dd76:	d80d      	bhi.n	3400dd94 <RCCEx_GetSPICLKFreq+0x88>
3400dd78:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400dd7c:	4298      	cmp	r0, r3
3400dd7e:	d005      	beq.n	3400dd8c <RCCEx_GetSPICLKFreq+0x80>
3400dd80:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3400dd84:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400dd88:	4298      	cmp	r0, r3
3400dd8a:	d1db      	bne.n	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
}
3400dd8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400dd90:	f7ff bbac 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400dd94:	4b6c      	ldr	r3, [pc, #432]	@ (3400df48 <RCCEx_GetSPICLKFreq+0x23c>)
3400dd96:	4298      	cmp	r0, r3
3400dd98:	d0f8      	beq.n	3400dd8c <RCCEx_GetSPICLKFreq+0x80>
3400dd9a:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3400dd9e:	4298      	cmp	r0, r3
3400dda0:	f000 8093 	beq.w	3400deca <RCCEx_GetSPICLKFreq+0x1be>
3400dda4:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400dda8:	e7ee      	b.n	3400dd88 <RCCEx_GetSPICLKFreq+0x7c>
3400ddaa:	4b68      	ldr	r3, [pc, #416]	@ (3400df4c <RCCEx_GetSPICLKFreq+0x240>)
3400ddac:	4298      	cmp	r0, r3
3400ddae:	d009      	beq.n	3400ddc4 <RCCEx_GetSPICLKFreq+0xb8>
3400ddb0:	d813      	bhi.n	3400ddda <RCCEx_GetSPICLKFreq+0xce>
3400ddb2:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400ddb6:	4298      	cmp	r0, r3
3400ddb8:	f000 8087 	beq.w	3400deca <RCCEx_GetSPICLKFreq+0x1be>
3400ddbc:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400ddc0:	4298      	cmp	r0, r3
3400ddc2:	d1bf      	bne.n	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400ddc4:	f7fc fa0a 	bl	3400a1dc <LL_RCC_IC9_IsEnabled>
3400ddc8:	2800      	cmp	r0, #0
3400ddca:	d0bb      	beq.n	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC9_GetDivider();
3400ddcc:	f7fc fa0e 	bl	3400a1ec <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400ddd0:	4b5b      	ldr	r3, [pc, #364]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
3400ddd2:	4604      	mov	r4, r0
3400ddd4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400ddd8:	e082      	b.n	3400dee0 <RCCEx_GetSPICLKFreq+0x1d4>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400ddda:	4b5d      	ldr	r3, [pc, #372]	@ (3400df50 <RCCEx_GetSPICLKFreq+0x244>)
3400dddc:	4298      	cmp	r0, r3
3400ddde:	d074      	beq.n	3400deca <RCCEx_GetSPICLKFreq+0x1be>
3400dde0:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3400dde4:	e7ec      	b.n	3400ddc0 <RCCEx_GetSPICLKFreq+0xb4>
3400dde6:	4b5b      	ldr	r3, [pc, #364]	@ (3400df54 <RCCEx_GetSPICLKFreq+0x248>)
3400dde8:	4298      	cmp	r0, r3
3400ddea:	d043      	beq.n	3400de74 <RCCEx_GetSPICLKFreq+0x168>
3400ddec:	d830      	bhi.n	3400de50 <RCCEx_GetSPICLKFreq+0x144>
3400ddee:	f5a3 33fa 	sub.w	r3, r3, #128000	@ 0x1f400
3400ddf2:	4298      	cmp	r0, r3
3400ddf4:	d0e6      	beq.n	3400ddc4 <RCCEx_GetSPICLKFreq+0xb8>
3400ddf6:	d808      	bhi.n	3400de0a <RCCEx_GetSPICLKFreq+0xfe>
3400ddf8:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400ddfc:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400de00:	429a      	cmp	r2, r3
3400de02:	d079      	beq.n	3400def8 <RCCEx_GetSPICLKFreq+0x1ec>
3400de04:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400de08:	e7da      	b.n	3400ddc0 <RCCEx_GetSPICLKFreq+0xb4>
3400de0a:	4b53      	ldr	r3, [pc, #332]	@ (3400df58 <RCCEx_GetSPICLKFreq+0x24c>)
3400de0c:	4298      	cmp	r0, r3
3400de0e:	d00d      	beq.n	3400de2c <RCCEx_GetSPICLKFreq+0x120>
3400de10:	d814      	bhi.n	3400de3c <RCCEx_GetSPICLKFreq+0x130>
3400de12:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400de16:	4298      	cmp	r0, r3
3400de18:	d008      	beq.n	3400de2c <RCCEx_GetSPICLKFreq+0x120>
3400de1a:	d80d      	bhi.n	3400de38 <RCCEx_GetSPICLKFreq+0x12c>
3400de1c:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400de20:	4298      	cmp	r0, r3
3400de22:	d003      	beq.n	3400de2c <RCCEx_GetSPICLKFreq+0x120>
3400de24:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400de28:	4298      	cmp	r0, r3
3400de2a:	d18b      	bne.n	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_MSI_IsReady() != 0U)
3400de2c:	f7fc f982 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400de30:	2800      	cmp	r0, #0
3400de32:	d087      	beq.n	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = MSI_VALUE;
3400de34:	4849      	ldr	r0, [pc, #292]	@ (3400df5c <RCCEx_GetSPICLKFreq+0x250>)
  return spi_frequency;
3400de36:	e786      	b.n	3400dd46 <RCCEx_GetSPICLKFreq+0x3a>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400de38:	4b49      	ldr	r3, [pc, #292]	@ (3400df60 <RCCEx_GetSPICLKFreq+0x254>)
3400de3a:	e7f5      	b.n	3400de28 <RCCEx_GetSPICLKFreq+0x11c>
3400de3c:	4b49      	ldr	r3, [pc, #292]	@ (3400df64 <RCCEx_GetSPICLKFreq+0x258>)
3400de3e:	4298      	cmp	r0, r3
3400de40:	d018      	beq.n	3400de74 <RCCEx_GetSPICLKFreq+0x168>
3400de42:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400de46:	4298      	cmp	r0, r3
3400de48:	d014      	beq.n	3400de74 <RCCEx_GetSPICLKFreq+0x168>
3400de4a:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400de4e:	e7eb      	b.n	3400de28 <RCCEx_GetSPICLKFreq+0x11c>
3400de50:	4b45      	ldr	r3, [pc, #276]	@ (3400df68 <RCCEx_GetSPICLKFreq+0x25c>)
3400de52:	4298      	cmp	r0, r3
3400de54:	d069      	beq.n	3400df2a <RCCEx_GetSPICLKFreq+0x21e>
3400de56:	d81e      	bhi.n	3400de96 <RCCEx_GetSPICLKFreq+0x18a>
3400de58:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400de5c:	4298      	cmp	r0, r3
3400de5e:	d018      	beq.n	3400de92 <RCCEx_GetSPICLKFreq+0x186>
3400de60:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3400de64:	d811      	bhi.n	3400de8a <RCCEx_GetSPICLKFreq+0x17e>
3400de66:	4a41      	ldr	r2, [pc, #260]	@ (3400df6c <RCCEx_GetSPICLKFreq+0x260>)
3400de68:	4293      	cmp	r3, r2
3400de6a:	d003      	beq.n	3400de74 <RCCEx_GetSPICLKFreq+0x168>
3400de6c:	4b40      	ldr	r3, [pc, #256]	@ (3400df70 <RCCEx_GetSPICLKFreq+0x264>)
3400de6e:	4298      	cmp	r0, r3
3400de70:	f47f af68 	bne.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_HSI_IsReady() != 0U)
3400de74:	f7fc f956 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400de78:	2800      	cmp	r0, #0
3400de7a:	f43f af63 	beq.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400de7e:	4b30      	ldr	r3, [pc, #192]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400de80:	483c      	ldr	r0, [pc, #240]	@ (3400df74 <RCCEx_GetSPICLKFreq+0x268>)
3400de82:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400de84:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400de88:	e014      	b.n	3400deb4 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400de8a:	4a3b      	ldr	r2, [pc, #236]	@ (3400df78 <RCCEx_GetSPICLKFreq+0x26c>)
3400de8c:	4293      	cmp	r3, r2
3400de8e:	f47f af59 	bne.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
3400de92:	483a      	ldr	r0, [pc, #232]	@ (3400df7c <RCCEx_GetSPICLKFreq+0x270>)
3400de94:	e757      	b.n	3400dd46 <RCCEx_GetSPICLKFreq+0x3a>
3400de96:	4b3a      	ldr	r3, [pc, #232]	@ (3400df80 <RCCEx_GetSPICLKFreq+0x274>)
3400de98:	4298      	cmp	r0, r3
3400de9a:	d046      	beq.n	3400df2a <RCCEx_GetSPICLKFreq+0x21e>
3400de9c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dea0:	4298      	cmp	r0, r3
3400dea2:	e7f4      	b.n	3400de8e <RCCEx_GetSPICLKFreq+0x182>
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dea4:	f7fc f8c4 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400dea8:	f7fc f9ce 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400deac:	4b24      	ldr	r3, [pc, #144]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
3400deae:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400deb0:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400deb4:	40d8      	lsrs	r0, r3
      break;
3400deb6:	e746      	b.n	3400dd46 <RCCEx_GetSPICLKFreq+0x3a>
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400deb8:	f7fc f8ba 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400debc:	f7fc f9c4 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400dec0:	4b1f      	ldr	r3, [pc, #124]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
3400dec2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400dec4:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400dec8:	e7f4      	b.n	3400deb4 <RCCEx_GetSPICLKFreq+0x1a8>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400deca:	f7fc f975 	bl	3400a1b8 <LL_RCC_IC8_IsEnabled>
3400dece:	2800      	cmp	r0, #0
3400ded0:	f43f af38 	beq.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC8_GetDivider();
3400ded4:	f7fc f978 	bl	3400a1c8 <LL_RCC_IC8_GetDivider>
3400ded8:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400deda:	4b19      	ldr	r3, [pc, #100]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
3400dedc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400dee0:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400dee4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dee8:	d01c      	beq.n	3400df24 <RCCEx_GetSPICLKFreq+0x218>
3400deea:	d811      	bhi.n	3400df10 <RCCEx_GetSPICLKFreq+0x204>
3400deec:	b9bb      	cbnz	r3, 3400df1e <RCCEx_GetSPICLKFreq+0x212>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400deee:	f7ff f9fd 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            spi_frequency = spi_frequency / ic_divider;
3400def2:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400def6:	e726      	b.n	3400dd46 <RCCEx_GetSPICLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400def8:	f7fc f982 	bl	3400a200 <LL_RCC_IC14_IsEnabled>
3400defc:	2800      	cmp	r0, #0
3400defe:	f43f af21 	beq.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC14_GetDivider();
3400df02:	f7fc f985 	bl	3400a210 <LL_RCC_IC14_GetDivider>
3400df06:	4b0e      	ldr	r3, [pc, #56]	@ (3400df40 <RCCEx_GetSPICLKFreq+0x234>)
3400df08:	4604      	mov	r4, r0
3400df0a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400df0e:	e7e7      	b.n	3400dee0 <RCCEx_GetSPICLKFreq+0x1d4>
        switch (LL_RCC_IC14_GetSource())
3400df10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400df14:	f47f af16 	bne.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400df18:	f7ff faa8 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400df1c:	e7e9      	b.n	3400def2 <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400df1e:	f7ff fa25 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400df22:	e7e6      	b.n	3400def2 <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400df24:	f7ff fa62 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400df28:	e7e3      	b.n	3400def2 <RCCEx_GetSPICLKFreq+0x1e6>
      if (LL_RCC_HSE_IsReady() != 0U)
3400df2a:	f7fc f8f3 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400df2e:	2800      	cmp	r0, #0
3400df30:	f43f af08 	beq.w	3400dd44 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = HSE_VALUE;
3400df34:	4813      	ldr	r0, [pc, #76]	@ (3400df84 <RCCEx_GetSPICLKFreq+0x278>)
3400df36:	e706      	b.n	3400dd46 <RCCEx_GetSPICLKFreq+0x3a>
3400df38:	07030820 	.word	0x07030820
3400df3c:	07001020 	.word	0x07001020
3400df40:	56028000 	.word	0x56028000
3400df44:	07020820 	.word	0x07020820
3400df48:	07011820 	.word	0x07011820
3400df4c:	07021420 	.word	0x07021420
3400df50:	07021820 	.word	0x07021820
3400df54:	07050c20 	.word	0x07050c20
3400df58:	07041420 	.word	0x07041420
3400df5c:	003d0900 	.word	0x003d0900
3400df60:	07041020 	.word	0x07041020
3400df64:	07050420 	.word	0x07050420
3400df68:	07061020 	.word	0x07061020
3400df6c:	07051020 	.word	0x07051020
3400df70:	07051820 	.word	0x07051820
3400df74:	03d09000 	.word	0x03d09000
3400df78:	07060820 	.word	0x07060820
3400df7c:	00bb8000 	.word	0x00bb8000
3400df80:	07061420 	.word	0x07061420
3400df84:	02dc6c00 	.word	0x02dc6c00

3400df88 <RCCEx_GetSAICLKFreq>:
{
3400df88:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400df8a:	f7fc f8f5 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400df8e:	4b49      	ldr	r3, [pc, #292]	@ (3400e0b4 <RCCEx_GetSAICLKFreq+0x12c>)
3400df90:	4298      	cmp	r0, r3
3400df92:	d04a      	beq.n	3400e02a <RCCEx_GetSAICLKFreq+0xa2>
3400df94:	d839      	bhi.n	3400e00a <RCCEx_GetSAICLKFreq+0x82>
3400df96:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400df9a:	4298      	cmp	r0, r3
3400df9c:	d021      	beq.n	3400dfe2 <RCCEx_GetSAICLKFreq+0x5a>
3400df9e:	d815      	bhi.n	3400dfcc <RCCEx_GetSAICLKFreq+0x44>
3400dfa0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400dfa4:	4298      	cmp	r0, r3
3400dfa6:	d00d      	beq.n	3400dfc4 <RCCEx_GetSAICLKFreq+0x3c>
3400dfa8:	d809      	bhi.n	3400dfbe <RCCEx_GetSAICLKFreq+0x36>
3400dfaa:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400dfae:	4298      	cmp	r0, r3
3400dfb0:	d04e      	beq.n	3400e050 <RCCEx_GetSAICLKFreq+0xc8>
3400dfb2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dfb6:	4298      	cmp	r0, r3
3400dfb8:	d04a      	beq.n	3400e050 <RCCEx_GetSAICLKFreq+0xc8>
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
3400dfba:	2000      	movs	r0, #0
}
3400dfbc:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400dfbe:	4b3e      	ldr	r3, [pc, #248]	@ (3400e0b8 <RCCEx_GetSAICLKFreq+0x130>)
3400dfc0:	4298      	cmp	r0, r3
3400dfc2:	d1fa      	bne.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
}
3400dfc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400dfc8:	f7ff ba90 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400dfcc:	4b3b      	ldr	r3, [pc, #236]	@ (3400e0bc <RCCEx_GetSAICLKFreq+0x134>)
3400dfce:	4298      	cmp	r0, r3
3400dfd0:	d04d      	beq.n	3400e06e <RCCEx_GetSAICLKFreq+0xe6>
3400dfd2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dfd6:	4298      	cmp	r0, r3
3400dfd8:	d049      	beq.n	3400e06e <RCCEx_GetSAICLKFreq+0xe6>
3400dfda:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400dfde:	4298      	cmp	r0, r3
3400dfe0:	d1eb      	bne.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400dfe2:	f7fc f8d7 	bl	3400a194 <LL_RCC_IC7_IsEnabled>
3400dfe6:	2800      	cmp	r0, #0
3400dfe8:	d0e7      	beq.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC7_GetDivider();
3400dfea:	f7fc f8db 	bl	3400a1a4 <LL_RCC_IC7_GetDivider>
3400dfee:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400dff0:	4b33      	ldr	r3, [pc, #204]	@ (3400e0c0 <RCCEx_GetSAICLKFreq+0x138>)
3400dff2:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400dff6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400dffa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dffe:	d047      	beq.n	3400e090 <RCCEx_GetSAICLKFreq+0x108>
3400e000:	d840      	bhi.n	3400e084 <RCCEx_GetSAICLKFreq+0xfc>
3400e002:	bb7b      	cbnz	r3, 3400e064 <RCCEx_GetSAICLKFreq+0xdc>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e004:	f7ff f972 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
3400e008:	e02e      	b.n	3400e068 <RCCEx_GetSAICLKFreq+0xe0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e00a:	4b2e      	ldr	r3, [pc, #184]	@ (3400e0c4 <RCCEx_GetSAICLKFreq+0x13c>)
3400e00c:	4298      	cmp	r0, r3
3400e00e:	d01d      	beq.n	3400e04c <RCCEx_GetSAICLKFreq+0xc4>
3400e010:	d811      	bhi.n	3400e036 <RCCEx_GetSAICLKFreq+0xae>
3400e012:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e016:	4298      	cmp	r0, r3
3400e018:	d03d      	beq.n	3400e096 <RCCEx_GetSAICLKFreq+0x10e>
3400e01a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e01e:	4298      	cmp	r0, r3
3400e020:	d039      	beq.n	3400e096 <RCCEx_GetSAICLKFreq+0x10e>
3400e022:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e026:	4298      	cmp	r0, r3
3400e028:	d1c7      	bne.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e02a:	f7fc f883 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400e02e:	2800      	cmp	r0, #0
3400e030:	d0c3      	beq.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
        sai_frequency = MSI_VALUE;
3400e032:	4825      	ldr	r0, [pc, #148]	@ (3400e0c8 <RCCEx_GetSAICLKFreq+0x140>)
  return sai_frequency;
3400e034:	e7c2      	b.n	3400dfbc <RCCEx_GetSAICLKFreq+0x34>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e036:	4b25      	ldr	r3, [pc, #148]	@ (3400e0cc <RCCEx_GetSAICLKFreq+0x144>)
3400e038:	4298      	cmp	r0, r3
3400e03a:	d036      	beq.n	3400e0aa <RCCEx_GetSAICLKFreq+0x122>
3400e03c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e040:	4298      	cmp	r0, r3
3400e042:	d032      	beq.n	3400e0aa <RCCEx_GetSAICLKFreq+0x122>
3400e044:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e048:	4298      	cmp	r0, r3
3400e04a:	d1b6      	bne.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
3400e04c:	4820      	ldr	r0, [pc, #128]	@ (3400e0d0 <RCCEx_GetSAICLKFreq+0x148>)
3400e04e:	e7b5      	b.n	3400dfbc <RCCEx_GetSAICLKFreq+0x34>
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e050:	f7fb ffee 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e054:	f7fc f8f8 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400e058:	4b19      	ldr	r3, [pc, #100]	@ (3400e0c0 <RCCEx_GetSAICLKFreq+0x138>)
3400e05a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e05c:	f3c3 1302 	ubfx	r3, r3, #4, #3
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e060:	40d8      	lsrs	r0, r3
3400e062:	e7ab      	b.n	3400dfbc <RCCEx_GetSAICLKFreq+0x34>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e064:	f7ff f982 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
            sai_frequency = sai_frequency / ic_divider;
3400e068:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e06c:	e7a6      	b.n	3400dfbc <RCCEx_GetSAICLKFreq+0x34>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400e06e:	f7fc f8a3 	bl	3400a1b8 <LL_RCC_IC8_IsEnabled>
3400e072:	2800      	cmp	r0, #0
3400e074:	d0a1      	beq.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC8_GetDivider();
3400e076:	f7fc f8a7 	bl	3400a1c8 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e07a:	4b11      	ldr	r3, [pc, #68]	@ (3400e0c0 <RCCEx_GetSAICLKFreq+0x138>)
3400e07c:	4604      	mov	r4, r0
3400e07e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e082:	e7b8      	b.n	3400dff6 <RCCEx_GetSAICLKFreq+0x6e>
        switch (LL_RCC_IC8_GetSource())
3400e084:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e088:	d197      	bne.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e08a:	f7ff f9ef 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400e08e:	e7eb      	b.n	3400e068 <RCCEx_GetSAICLKFreq+0xe0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e090:	f7ff f9ac 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400e094:	e7e8      	b.n	3400e068 <RCCEx_GetSAICLKFreq+0xe0>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e096:	f7fc f845 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400e09a:	2800      	cmp	r0, #0
3400e09c:	d08d      	beq.n	3400dfba <RCCEx_GetSAICLKFreq+0x32>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e09e:	4b08      	ldr	r3, [pc, #32]	@ (3400e0c0 <RCCEx_GetSAICLKFreq+0x138>)
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e0a0:	480c      	ldr	r0, [pc, #48]	@ (3400e0d4 <RCCEx_GetSAICLKFreq+0x14c>)
3400e0a2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e0a4:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e0a8:	e7da      	b.n	3400e060 <RCCEx_GetSAICLKFreq+0xd8>
}
3400e0aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400e0ae:	f7ff baa3 	b.w	3400d5f8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
3400e0b2:	bf00      	nop
3400e0b4:	07041418 	.word	0x07041418
3400e0b8:	07011818 	.word	0x07011818
3400e0bc:	07031418 	.word	0x07031418
3400e0c0:	56028000 	.word	0x56028000
3400e0c4:	07061418 	.word	0x07061418
3400e0c8:	003d0900 	.word	0x003d0900
3400e0cc:	07071418 	.word	0x07071418
3400e0d0:	00bb8000 	.word	0x00bb8000
3400e0d4:	03d09000 	.word	0x03d09000

3400e0d8 <RCCEx_GetI3CCLKFreq>:
{
3400e0d8:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e0da:	f7fc f84d 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e0de:	4b3d      	ldr	r3, [pc, #244]	@ (3400e1d4 <RCCEx_GetI3CCLKFreq+0xfc>)
3400e0e0:	4298      	cmp	r0, r3
3400e0e2:	d060      	beq.n	3400e1a6 <RCCEx_GetI3CCLKFreq+0xce>
3400e0e4:	d830      	bhi.n	3400e148 <RCCEx_GetI3CCLKFreq+0x70>
3400e0e6:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3400e0ea:	4298      	cmp	r0, r3
3400e0ec:	d057      	beq.n	3400e19e <RCCEx_GetI3CCLKFreq+0xc6>
3400e0ee:	d80d      	bhi.n	3400e10c <RCCEx_GetI3CCLKFreq+0x34>
3400e0f0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e0f4:	4298      	cmp	r0, r3
3400e0f6:	d048      	beq.n	3400e18a <RCCEx_GetI3CCLKFreq+0xb2>
3400e0f8:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3400e0fc:	4298      	cmp	r0, r3
3400e0fe:	d04e      	beq.n	3400e19e <RCCEx_GetI3CCLKFreq+0xc6>
3400e100:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e104:	4298      	cmp	r0, r3
3400e106:	d040      	beq.n	3400e18a <RCCEx_GetI3CCLKFreq+0xb2>
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e108:	2000      	movs	r0, #0
}
3400e10a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e10c:	4b32      	ldr	r3, [pc, #200]	@ (3400e1d8 <RCCEx_GetI3CCLKFreq+0x100>)
3400e10e:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e112:	4298      	cmp	r0, r3
3400e114:	d1f8      	bne.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400e116:	4b31      	ldr	r3, [pc, #196]	@ (3400e1dc <RCCEx_GetI3CCLKFreq+0x104>)
3400e118:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400e11c:	0592      	lsls	r2, r2, #22
3400e11e:	d5f3      	bpl.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e120:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400e124:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e128:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e12c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e12e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e132:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e136:	d04a      	beq.n	3400e1ce <RCCEx_GetI3CCLKFreq+0xf6>
3400e138:	d840      	bhi.n	3400e1bc <RCCEx_GetI3CCLKFreq+0xe4>
3400e13a:	2b00      	cmp	r3, #0
3400e13c:	d144      	bne.n	3400e1c8 <RCCEx_GetI3CCLKFreq+0xf0>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e13e:	f7ff f8d5 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            i3c_frequency = i3c_frequency / ic_divider;
3400e142:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e146:	e7e0      	b.n	3400e10a <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e148:	4b25      	ldr	r3, [pc, #148]	@ (3400e1e0 <RCCEx_GetI3CCLKFreq+0x108>)
3400e14a:	4298      	cmp	r0, r3
3400e14c:	d008      	beq.n	3400e160 <RCCEx_GetI3CCLKFreq+0x88>
3400e14e:	d80d      	bhi.n	3400e16c <RCCEx_GetI3CCLKFreq+0x94>
3400e150:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e154:	4298      	cmp	r0, r3
3400e156:	d026      	beq.n	3400e1a6 <RCCEx_GetI3CCLKFreq+0xce>
3400e158:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3400e15c:	4298      	cmp	r0, r3
3400e15e:	d1d3      	bne.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e160:	f7fb ffe8 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400e164:	2800      	cmp	r0, #0
3400e166:	d0cf      	beq.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
        i3c_frequency = MSI_VALUE;
3400e168:	481e      	ldr	r0, [pc, #120]	@ (3400e1e4 <RCCEx_GetI3CCLKFreq+0x10c>)
  return i3c_frequency;
3400e16a:	e7ce      	b.n	3400e10a <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e16c:	4b1e      	ldr	r3, [pc, #120]	@ (3400e1e8 <RCCEx_GetI3CCLKFreq+0x110>)
3400e16e:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e172:	4298      	cmp	r0, r3
3400e174:	d1c8      	bne.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e176:	f7fb ffd5 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400e17a:	2800      	cmp	r0, #0
3400e17c:	d0c4      	beq.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e17e:	4b17      	ldr	r3, [pc, #92]	@ (3400e1dc <RCCEx_GetI3CCLKFreq+0x104>)
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e180:	481a      	ldr	r0, [pc, #104]	@ (3400e1ec <RCCEx_GetI3CCLKFreq+0x114>)
3400e182:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e184:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e188:	e007      	b.n	3400e19a <RCCEx_GetI3CCLKFreq+0xc2>
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e18a:	f7fb ff51 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e18e:	f7fc f85b 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e192:	4b12      	ldr	r3, [pc, #72]	@ (3400e1dc <RCCEx_GetI3CCLKFreq+0x104>)
3400e194:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e196:	f003 0307 	and.w	r3, r3, #7
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e19a:	40d8      	lsrs	r0, r3
3400e19c:	e7b5      	b.n	3400e10a <RCCEx_GetI3CCLKFreq+0x32>
}
3400e19e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e1a2:	f7ff b9a3 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e1a6:	f7fc f83d 	bl	3400a224 <LL_RCC_IC15_IsEnabled>
3400e1aa:	2800      	cmp	r0, #0
3400e1ac:	d0ac      	beq.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e1ae:	f7fc f841 	bl	3400a234 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e1b2:	4b0a      	ldr	r3, [pc, #40]	@ (3400e1dc <RCCEx_GetI3CCLKFreq+0x104>)
3400e1b4:	4604      	mov	r4, r0
3400e1b6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e1ba:	e7b8      	b.n	3400e12e <RCCEx_GetI3CCLKFreq+0x56>
        switch (LL_RCC_IC15_GetSource())
3400e1bc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e1c0:	d1a2      	bne.n	3400e108 <RCCEx_GetI3CCLKFreq+0x30>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e1c2:	f7ff f953 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400e1c6:	e7bc      	b.n	3400e142 <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e1c8:	f7ff f8d0 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400e1cc:	e7b9      	b.n	3400e142 <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e1ce:	f7ff f90d 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400e1d2:	e7b6      	b.n	3400e142 <RCCEx_GetI3CCLKFreq+0x6a>
3400e1d4:	0703100c 	.word	0x0703100c
3400e1d8:	0702100c 	.word	0x0702100c
3400e1dc:	56028000 	.word	0x56028000
3400e1e0:	0704140c 	.word	0x0704140c
3400e1e4:	003d0900 	.word	0x003d0900
3400e1e8:	0705100c 	.word	0x0705100c
3400e1ec:	03d09000 	.word	0x03d09000

3400e1f0 <RCCEx_GetSDMMCCLKFreq>:
{
3400e1f0:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e1f2:	f7fb ffc1 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e1f6:	4b2d      	ldr	r3, [pc, #180]	@ (3400e2ac <RCCEx_GetSDMMCCLKFreq+0xbc>)
3400e1f8:	4298      	cmp	r0, r3
3400e1fa:	d01d      	beq.n	3400e238 <RCCEx_GetSDMMCCLKFreq+0x48>
3400e1fc:	d813      	bhi.n	3400e226 <RCCEx_GetSDMMCCLKFreq+0x36>
3400e1fe:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e202:	4298      	cmp	r0, r3
3400e204:	d00b      	beq.n	3400e21e <RCCEx_GetSDMMCCLKFreq+0x2e>
3400e206:	d807      	bhi.n	3400e218 <RCCEx_GetSDMMCCLKFreq+0x28>
3400e208:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e20c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e210:	4298      	cmp	r0, r3
3400e212:	d02a      	beq.n	3400e26a <RCCEx_GetSDMMCCLKFreq+0x7a>
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e214:	2000      	movs	r0, #0
}
3400e216:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e218:	4b25      	ldr	r3, [pc, #148]	@ (3400e2b0 <RCCEx_GetSDMMCCLKFreq+0xc0>)
3400e21a:	4298      	cmp	r0, r3
3400e21c:	d1fa      	bne.n	3400e214 <RCCEx_GetSDMMCCLKFreq+0x24>
}
3400e21e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e222:	f7ff b963 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e226:	4b23      	ldr	r3, [pc, #140]	@ (3400e2b4 <RCCEx_GetSDMMCCLKFreq+0xc4>)
3400e228:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e22c:	429a      	cmp	r2, r3
3400e22e:	d022      	beq.n	3400e276 <RCCEx_GetSDMMCCLKFreq+0x86>
3400e230:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e234:	4298      	cmp	r0, r3
3400e236:	d1ed      	bne.n	3400e214 <RCCEx_GetSDMMCCLKFreq+0x24>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400e238:	4b1f      	ldr	r3, [pc, #124]	@ (3400e2b8 <RCCEx_GetSDMMCCLKFreq+0xc8>)
3400e23a:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400e23e:	f010 0008 	ands.w	r0, r0, #8
3400e242:	d0e8      	beq.n	3400e216 <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e244:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400e248:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e24c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e250:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e252:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC5_GetSource())
3400e256:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e25a:	d023      	beq.n	3400e2a4 <RCCEx_GetSDMMCCLKFreq+0xb4>
3400e25c:	d819      	bhi.n	3400e292 <RCCEx_GetSDMMCCLKFreq+0xa2>
3400e25e:	b9f3      	cbnz	r3, 3400e29e <RCCEx_GetSDMMCCLKFreq+0xae>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e260:	f7ff f844 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400e264:	fbb0 f0f4 	udiv	r0, r0, r4
  return sdmmc_frequency;
3400e268:	e7d5      	b.n	3400e216 <RCCEx_GetSDMMCCLKFreq+0x26>
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e26a:	f7fb fee1 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
}
3400e26e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e272:	f7fb bfe9 	b.w	3400a248 <RCCEx_GetHCLKFreq>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400e276:	4b10      	ldr	r3, [pc, #64]	@ (3400e2b8 <RCCEx_GetSDMMCCLKFreq+0xc8>)
3400e278:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400e27c:	f010 0010 	ands.w	r0, r0, #16
3400e280:	d0c9      	beq.n	3400e216 <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400e282:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e286:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400e28a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e28e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e290:	e7df      	b.n	3400e252 <RCCEx_GetSDMMCCLKFreq+0x62>
        switch (LL_RCC_IC5_GetSource())
3400e292:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e296:	d1bd      	bne.n	3400e214 <RCCEx_GetSDMMCCLKFreq+0x24>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e298:	f7ff f8e8 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400e29c:	e7e2      	b.n	3400e264 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e29e:	f7ff f865 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400e2a2:	e7df      	b.n	3400e264 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e2a4:	f7ff f8a2 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400e2a8:	e7dc      	b.n	3400e264 <RCCEx_GetSDMMCCLKFreq+0x74>
3400e2aa:	bf00      	nop
3400e2ac:	0302001c 	.word	0x0302001c
3400e2b0:	0301041c 	.word	0x0301041c
3400e2b4:	0303001c 	.word	0x0303001c
3400e2b8:	56028000 	.word	0x56028000

3400e2bc <RCCEx_GetI2CCLKFreq>:
{
3400e2bc:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e2be:	f7fb ff5b 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e2c2:	4b50      	ldr	r3, [pc, #320]	@ (3400e404 <RCCEx_GetI2CCLKFreq+0x148>)
3400e2c4:	4298      	cmp	r0, r3
3400e2c6:	f000 8085 	beq.w	3400e3d4 <RCCEx_GetI2CCLKFreq+0x118>
3400e2ca:	d84b      	bhi.n	3400e364 <RCCEx_GetI2CCLKFreq+0xa8>
3400e2cc:	f5a3 33fc 	sub.w	r3, r3, #129024	@ 0x1f800
3400e2d0:	4298      	cmp	r0, r3
3400e2d2:	d01a      	beq.n	3400e30a <RCCEx_GetI2CCLKFreq+0x4e>
3400e2d4:	d81d      	bhi.n	3400e312 <RCCEx_GetI2CCLKFreq+0x56>
3400e2d6:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e2da:	4298      	cmp	r0, r3
3400e2dc:	d008      	beq.n	3400e2f0 <RCCEx_GetI2CCLKFreq+0x34>
3400e2de:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3400e2e2:	d80f      	bhi.n	3400e304 <RCCEx_GetI2CCLKFreq+0x48>
3400e2e4:	4a48      	ldr	r2, [pc, #288]	@ (3400e408 <RCCEx_GetI2CCLKFreq+0x14c>)
3400e2e6:	4293      	cmp	r3, r2
3400e2e8:	d002      	beq.n	3400e2f0 <RCCEx_GetI2CCLKFreq+0x34>
3400e2ea:	4b48      	ldr	r3, [pc, #288]	@ (3400e40c <RCCEx_GetI2CCLKFreq+0x150>)
3400e2ec:	4298      	cmp	r0, r3
3400e2ee:	d14a      	bne.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e2f0:	f7fb fe9e 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e2f4:	f7fb ffa8 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e2f8:	4b45      	ldr	r3, [pc, #276]	@ (3400e410 <RCCEx_GetI2CCLKFreq+0x154>)
3400e2fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e2fc:	f003 0307 	and.w	r3, r3, #7
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e300:	40d8      	lsrs	r0, r3
3400e302:	e041      	b.n	3400e388 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e304:	4a43      	ldr	r2, [pc, #268]	@ (3400e414 <RCCEx_GetI2CCLKFreq+0x158>)
3400e306:	4293      	cmp	r3, r2
3400e308:	d13d      	bne.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
}
3400e30a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e30e:	f7ff b8ed 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e312:	4b41      	ldr	r3, [pc, #260]	@ (3400e418 <RCCEx_GetI2CCLKFreq+0x15c>)
3400e314:	4298      	cmp	r0, r3
3400e316:	d008      	beq.n	3400e32a <RCCEx_GetI2CCLKFreq+0x6e>
3400e318:	d820      	bhi.n	3400e35c <RCCEx_GetI2CCLKFreq+0xa0>
3400e31a:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400e31e:	4298      	cmp	r0, r3
3400e320:	d0f3      	beq.n	3400e30a <RCCEx_GetI2CCLKFreq+0x4e>
3400e322:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3400e326:	4298      	cmp	r0, r3
3400e328:	d12d      	bne.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400e32a:	4b39      	ldr	r3, [pc, #228]	@ (3400e410 <RCCEx_GetI2CCLKFreq+0x154>)
3400e32c:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400e330:	0592      	lsls	r2, r2, #22
3400e332:	d528      	bpl.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e334:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400e338:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e33c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e340:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e342:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e346:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e34a:	d057      	beq.n	3400e3fc <RCCEx_GetI2CCLKFreq+0x140>
3400e34c:	d84d      	bhi.n	3400e3ea <RCCEx_GetI2CCLKFreq+0x12e>
3400e34e:	2b00      	cmp	r3, #0
3400e350:	d151      	bne.n	3400e3f6 <RCCEx_GetI2CCLKFreq+0x13a>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e352:	f7fe ffcb 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            i2c_frequency = i2c_frequency / ic_divider;
3400e356:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e35a:	e015      	b.n	3400e388 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e35c:	4b2f      	ldr	r3, [pc, #188]	@ (3400e41c <RCCEx_GetI2CCLKFreq+0x160>)
3400e35e:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e362:	e7e0      	b.n	3400e326 <RCCEx_GetI2CCLKFreq+0x6a>
3400e364:	4b2e      	ldr	r3, [pc, #184]	@ (3400e420 <RCCEx_GetI2CCLKFreq+0x164>)
3400e366:	4298      	cmp	r0, r3
3400e368:	d014      	beq.n	3400e394 <RCCEx_GetI2CCLKFreq+0xd8>
3400e36a:	d819      	bhi.n	3400e3a0 <RCCEx_GetI2CCLKFreq+0xe4>
3400e36c:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e370:	4298      	cmp	r0, r3
3400e372:	d02f      	beq.n	3400e3d4 <RCCEx_GetI2CCLKFreq+0x118>
3400e374:	d809      	bhi.n	3400e38a <RCCEx_GetI2CCLKFreq+0xce>
3400e376:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e37a:	4298      	cmp	r0, r3
3400e37c:	d02a      	beq.n	3400e3d4 <RCCEx_GetI2CCLKFreq+0x118>
3400e37e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e382:	4298      	cmp	r0, r3
3400e384:	d026      	beq.n	3400e3d4 <RCCEx_GetI2CCLKFreq+0x118>
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e386:	2000      	movs	r0, #0
}
3400e388:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e38a:	4b26      	ldr	r3, [pc, #152]	@ (3400e424 <RCCEx_GetI2CCLKFreq+0x168>)
3400e38c:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e390:	4298      	cmp	r0, r3
3400e392:	d1f8      	bne.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e394:	f7fb fece 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400e398:	2800      	cmp	r0, #0
3400e39a:	d0f4      	beq.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
        i2c_frequency = MSI_VALUE;
3400e39c:	4822      	ldr	r0, [pc, #136]	@ (3400e428 <RCCEx_GetI2CCLKFreq+0x16c>)
  return i2c_frequency;
3400e39e:	e7f3      	b.n	3400e388 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e3a0:	4b22      	ldr	r3, [pc, #136]	@ (3400e42c <RCCEx_GetI2CCLKFreq+0x170>)
3400e3a2:	4298      	cmp	r0, r3
3400e3a4:	d008      	beq.n	3400e3b8 <RCCEx_GetI2CCLKFreq+0xfc>
3400e3a6:	d811      	bhi.n	3400e3cc <RCCEx_GetI2CCLKFreq+0x110>
3400e3a8:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400e3ac:	4298      	cmp	r0, r3
3400e3ae:	d0f1      	beq.n	3400e394 <RCCEx_GetI2CCLKFreq+0xd8>
3400e3b0:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3400e3b4:	4298      	cmp	r0, r3
3400e3b6:	d1e6      	bne.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e3b8:	f7fb feb4 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400e3bc:	2800      	cmp	r0, #0
3400e3be:	d0e2      	beq.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e3c0:	4b13      	ldr	r3, [pc, #76]	@ (3400e410 <RCCEx_GetI2CCLKFreq+0x154>)
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e3c2:	481b      	ldr	r0, [pc, #108]	@ (3400e430 <RCCEx_GetI2CCLKFreq+0x174>)
3400e3c4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e3c6:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e3ca:	e799      	b.n	3400e300 <RCCEx_GetI2CCLKFreq+0x44>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e3cc:	4b19      	ldr	r3, [pc, #100]	@ (3400e434 <RCCEx_GetI2CCLKFreq+0x178>)
3400e3ce:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e3d2:	e7ef      	b.n	3400e3b4 <RCCEx_GetI2CCLKFreq+0xf8>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e3d4:	f7fb ff26 	bl	3400a224 <LL_RCC_IC15_IsEnabled>
3400e3d8:	2800      	cmp	r0, #0
3400e3da:	d0d4      	beq.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e3dc:	f7fb ff2a 	bl	3400a234 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e3e0:	4b0b      	ldr	r3, [pc, #44]	@ (3400e410 <RCCEx_GetI2CCLKFreq+0x154>)
3400e3e2:	4604      	mov	r4, r0
3400e3e4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e3e8:	e7ab      	b.n	3400e342 <RCCEx_GetI2CCLKFreq+0x86>
        switch (LL_RCC_IC15_GetSource())
3400e3ea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e3ee:	d1ca      	bne.n	3400e386 <RCCEx_GetI2CCLKFreq+0xca>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e3f0:	f7ff f83c 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400e3f4:	e7af      	b.n	3400e356 <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e3f6:	f7fe ffb9 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400e3fa:	e7ac      	b.n	3400e356 <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e3fc:	f7fe fff6 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400e400:	e7a9      	b.n	3400e356 <RCCEx_GetI2CCLKFreq+0x9a>
3400e402:	bf00      	nop
3400e404:	0703000c 	.word	0x0703000c
3400e408:	0700000c 	.word	0x0700000c
3400e40c:	0700080c 	.word	0x0700080c
3400e410:	56028000 	.word	0x56028000
3400e414:	0701000c 	.word	0x0701000c
3400e418:	0702040c 	.word	0x0702040c
3400e41c:	0702080c 	.word	0x0702080c
3400e420:	0704080c 	.word	0x0704080c
3400e424:	0704000c 	.word	0x0704000c
3400e428:	003d0900 	.word	0x003d0900
3400e42c:	0705040c 	.word	0x0705040c
3400e430:	03d09000 	.word	0x03d09000
3400e434:	0705080c 	.word	0x0705080c

3400e438 <RCCEx_GetLPTIMCLKFreq>:
{
3400e438:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e43a:	f7fb fe9d 	bl	3400a178 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e43e:	4b63      	ldr	r3, [pc, #396]	@ (3400e5cc <RCCEx_GetLPTIMCLKFreq+0x194>)
3400e440:	4298      	cmp	r0, r3
3400e442:	d03a      	beq.n	3400e4ba <RCCEx_GetLPTIMCLKFreq+0x82>
3400e444:	d850      	bhi.n	3400e4e8 <RCCEx_GetLPTIMCLKFreq+0xb0>
3400e446:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3400e44a:	4298      	cmp	r0, r3
3400e44c:	f000 80a7 	beq.w	3400e59e <RCCEx_GetLPTIMCLKFreq+0x166>
3400e450:	d813      	bhi.n	3400e47a <RCCEx_GetLPTIMCLKFreq+0x42>
3400e452:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e456:	4298      	cmp	r0, r3
3400e458:	f000 8097 	beq.w	3400e58a <RCCEx_GetLPTIMCLKFreq+0x152>
3400e45c:	3b01      	subs	r3, #1
3400e45e:	4298      	cmp	r0, r3
3400e460:	d909      	bls.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
3400e462:	f203 4301 	addw	r3, r3, #1025	@ 0x401
3400e466:	4298      	cmp	r0, r3
3400e468:	f000 8099 	beq.w	3400e59e <RCCEx_GetLPTIMCLKFreq+0x166>
3400e46c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e470:	4298      	cmp	r0, r3
3400e472:	f000 8094 	beq.w	3400e59e <RCCEx_GetLPTIMCLKFreq+0x166>
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e476:	2000      	movs	r0, #0
}
3400e478:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e47a:	4b55      	ldr	r3, [pc, #340]	@ (3400e5d0 <RCCEx_GetLPTIMCLKFreq+0x198>)
3400e47c:	4298      	cmp	r0, r3
3400e47e:	d015      	beq.n	3400e4ac <RCCEx_GetLPTIMCLKFreq+0x74>
3400e480:	d808      	bhi.n	3400e494 <RCCEx_GetLPTIMCLKFreq+0x5c>
3400e482:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e486:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e48a:	429a      	cmp	r2, r3
3400e48c:	d00e      	beq.n	3400e4ac <RCCEx_GetLPTIMCLKFreq+0x74>
3400e48e:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400e492:	e7ed      	b.n	3400e470 <RCCEx_GetLPTIMCLKFreq+0x38>
3400e494:	4b4f      	ldr	r3, [pc, #316]	@ (3400e5d4 <RCCEx_GetLPTIMCLKFreq+0x19c>)
3400e496:	4298      	cmp	r0, r3
3400e498:	d00f      	beq.n	3400e4ba <RCCEx_GetLPTIMCLKFreq+0x82>
3400e49a:	d80b      	bhi.n	3400e4b4 <RCCEx_GetLPTIMCLKFreq+0x7c>
3400e49c:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e4a0:	4298      	cmp	r0, r3
3400e4a2:	d003      	beq.n	3400e4ac <RCCEx_GetLPTIMCLKFreq+0x74>
3400e4a4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e4a8:	4298      	cmp	r0, r3
3400e4aa:	d1e4      	bne.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
}
3400e4ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e4b0:	f7ff b81c 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e4b4:	4b48      	ldr	r3, [pc, #288]	@ (3400e5d8 <RCCEx_GetLPTIMCLKFreq+0x1a0>)
3400e4b6:	4298      	cmp	r0, r3
3400e4b8:	d1dd      	bne.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e4ba:	f7fb feb3 	bl	3400a224 <LL_RCC_IC15_IsEnabled>
3400e4be:	2800      	cmp	r0, #0
3400e4c0:	d0d9      	beq.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e4c2:	f7fb feb7 	bl	3400a234 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e4c6:	4b45      	ldr	r3, [pc, #276]	@ (3400e5dc <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e4c8:	4604      	mov	r4, r0
3400e4ca:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e4ce:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e4d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e4d6:	d075      	beq.n	3400e5c4 <RCCEx_GetLPTIMCLKFreq+0x18c>
3400e4d8:	d86a      	bhi.n	3400e5b0 <RCCEx_GetLPTIMCLKFreq+0x178>
3400e4da:	2b00      	cmp	r3, #0
3400e4dc:	d16f      	bne.n	3400e5be <RCCEx_GetLPTIMCLKFreq+0x186>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e4de:	f7fe ff05 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            lptim_frequency = lptim_frequency / ic_divider;
3400e4e2:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e4e6:	e7c7      	b.n	3400e478 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e4e8:	4b3d      	ldr	r3, [pc, #244]	@ (3400e5e0 <RCCEx_GetLPTIMCLKFreq+0x1a8>)
3400e4ea:	4298      	cmp	r0, r3
3400e4ec:	d034      	beq.n	3400e558 <RCCEx_GetLPTIMCLKFreq+0x120>
3400e4ee:	d824      	bhi.n	3400e53a <RCCEx_GetLPTIMCLKFreq+0x102>
3400e4f0:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e4f4:	4298      	cmp	r0, r3
3400e4f6:	d00f      	beq.n	3400e518 <RCCEx_GetLPTIMCLKFreq+0xe0>
3400e4f8:	d815      	bhi.n	3400e526 <RCCEx_GetLPTIMCLKFreq+0xee>
3400e4fa:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e4fe:	4298      	cmp	r0, r3
3400e500:	d00a      	beq.n	3400e518 <RCCEx_GetLPTIMCLKFreq+0xe0>
3400e502:	d806      	bhi.n	3400e512 <RCCEx_GetLPTIMCLKFreq+0xda>
3400e504:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e508:	4298      	cmp	r0, r3
3400e50a:	d0d6      	beq.n	3400e4ba <RCCEx_GetLPTIMCLKFreq+0x82>
3400e50c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e510:	e7d1      	b.n	3400e4b6 <RCCEx_GetLPTIMCLKFreq+0x7e>
3400e512:	4b34      	ldr	r3, [pc, #208]	@ (3400e5e4 <RCCEx_GetLPTIMCLKFreq+0x1ac>)
3400e514:	4298      	cmp	r0, r3
3400e516:	d1ae      	bne.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_LSE_IsReady() != 0U)
3400e518:	f7fb fe14 	bl	3400a144 <LL_RCC_LSE_IsReady>
3400e51c:	3800      	subs	r0, #0
3400e51e:	bf18      	it	ne
3400e520:	2001      	movne	r0, #1
3400e522:	03c0      	lsls	r0, r0, #15
3400e524:	e7a8      	b.n	3400e478 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e526:	4b30      	ldr	r3, [pc, #192]	@ (3400e5e8 <RCCEx_GetLPTIMCLKFreq+0x1b0>)
3400e528:	4298      	cmp	r0, r3
3400e52a:	d0f5      	beq.n	3400e518 <RCCEx_GetLPTIMCLKFreq+0xe0>
3400e52c:	f503 4370 	add.w	r3, r3, #61440	@ 0xf000
3400e530:	4298      	cmp	r0, r3
3400e532:	d011      	beq.n	3400e558 <RCCEx_GetLPTIMCLKFreq+0x120>
3400e534:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e538:	e7ec      	b.n	3400e514 <RCCEx_GetLPTIMCLKFreq+0xdc>
3400e53a:	4b2c      	ldr	r3, [pc, #176]	@ (3400e5ec <RCCEx_GetLPTIMCLKFreq+0x1b4>)
3400e53c:	4298      	cmp	r0, r3
3400e53e:	d015      	beq.n	3400e56c <RCCEx_GetLPTIMCLKFreq+0x134>
3400e540:	d81b      	bhi.n	3400e57a <RCCEx_GetLPTIMCLKFreq+0x142>
3400e542:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e546:	4298      	cmp	r0, r3
3400e548:	d006      	beq.n	3400e558 <RCCEx_GetLPTIMCLKFreq+0x120>
3400e54a:	d80c      	bhi.n	3400e566 <RCCEx_GetLPTIMCLKFreq+0x12e>
3400e54c:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e550:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e554:	4298      	cmp	r0, r3
3400e556:	d18e      	bne.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400e558:	4b20      	ldr	r3, [pc, #128]	@ (3400e5dc <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e55a:	685b      	ldr	r3, [r3, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3400e55c:	07db      	lsls	r3, r3, #31
3400e55e:	d58a      	bpl.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
        lptim_frequency = LSI_VALUE;
3400e560:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return lptim_frequency;
3400e564:	e788      	b.n	3400e478 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e566:	4b22      	ldr	r3, [pc, #136]	@ (3400e5f0 <RCCEx_GetLPTIMCLKFreq+0x1b8>)
3400e568:	4298      	cmp	r0, r3
3400e56a:	d184      	bne.n	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400e56c:	f7fb fd60 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400e570:	4b1a      	ldr	r3, [pc, #104]	@ (3400e5dc <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e572:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e574:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400e578:	e00f      	b.n	3400e59a <RCCEx_GetLPTIMCLKFreq+0x162>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e57a:	4b1e      	ldr	r3, [pc, #120]	@ (3400e5f4 <RCCEx_GetLPTIMCLKFreq+0x1bc>)
3400e57c:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e580:	429a      	cmp	r2, r3
3400e582:	d0f3      	beq.n	3400e56c <RCCEx_GetLPTIMCLKFreq+0x134>
3400e584:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400e588:	e7ee      	b.n	3400e568 <RCCEx_GetLPTIMCLKFreq+0x130>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e58a:	f7fb fd51 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e58e:	f7fb fe5b 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e592:	4b12      	ldr	r3, [pc, #72]	@ (3400e5dc <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e594:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e596:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400e59a:	40d8      	lsrs	r0, r3
      break;
3400e59c:	e76c      	b.n	3400e478 <RCCEx_GetLPTIMCLKFreq+0x40>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e59e:	f7fb fd47 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e5a2:	f7fb fe51 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400e5a6:	4b0d      	ldr	r3, [pc, #52]	@ (3400e5dc <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e5a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400e5aa:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400e5ae:	e7f4      	b.n	3400e59a <RCCEx_GetLPTIMCLKFreq+0x162>
        switch (LL_RCC_IC15_GetSource())
3400e5b0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e5b4:	f47f af5f 	bne.w	3400e476 <RCCEx_GetLPTIMCLKFreq+0x3e>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e5b8:	f7fe ff58 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400e5bc:	e791      	b.n	3400e4e2 <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e5be:	f7fe fed5 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400e5c2:	e78e      	b.n	3400e4e2 <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e5c4:	f7fe ff12 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400e5c8:	e78b      	b.n	3400e4e2 <RCCEx_GetLPTIMCLKFreq+0xaa>
3400e5ca:	bf00      	nop
3400e5cc:	0702102c 	.word	0x0702102c
3400e5d0:	0701102c 	.word	0x0701102c
3400e5d4:	0702082c 	.word	0x0702082c
3400e5d8:	07020c2c 	.word	0x07020c2c
3400e5dc:	56028000 	.word	0x56028000
3400e5e0:	07040c2c 	.word	0x07040c2c
3400e5e4:	07030c2c 	.word	0x07030c2c
3400e5e8:	0703182c 	.word	0x0703182c
3400e5ec:	07050c2c 	.word	0x07050c2c
3400e5f0:	0705082c 	.word	0x0705082c
3400e5f4:	0705102c 	.word	0x0705102c

3400e5f8 <HAL_RCCEx_GetPeriphCLKFreq>:
{
3400e5f8:	b538      	push	{r3, r4, r5, lr}
  switch (PeriphClk)
3400e5fa:	f100 4360 	add.w	r3, r0, #3758096384	@ 0xe0000000
3400e5fe:	430b      	orrs	r3, r1
3400e600:	f000 8447 	beq.w	3400ee92 <HAL_RCCEx_GetPeriphCLKFreq+0x89a>
3400e604:	4bbf      	ldr	r3, [pc, #764]	@ (3400e904 <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
3400e606:	4298      	cmp	r0, r3
3400e608:	f171 0300 	sbcs.w	r3, r1, #0
3400e60c:	f080 80e6 	bcs.w	3400e7dc <HAL_RCCEx_GetPeriphCLKFreq+0x1e4>
3400e610:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
3400e614:	430b      	orrs	r3, r1
3400e616:	f000 835b 	beq.w	3400ecd0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3400e61a:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
3400e61e:	f171 0300 	sbcs.w	r3, r1, #0
3400e622:	d26a      	bcs.n	3400e6fa <HAL_RCCEx_GetPeriphCLKFreq+0x102>
3400e624:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
3400e628:	430b      	orrs	r3, r1
3400e62a:	f000 82b9 	beq.w	3400eba0 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
3400e62e:	f240 2301 	movw	r3, #513	@ 0x201
3400e632:	4298      	cmp	r0, r3
3400e634:	f171 0300 	sbcs.w	r3, r1, #0
3400e638:	d224      	bcs.n	3400e684 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
3400e63a:	2809      	cmp	r0, #9
3400e63c:	f171 0300 	sbcs.w	r3, r1, #0
3400e640:	d215      	bcs.n	3400e66e <HAL_RCCEx_GetPeriphCLKFreq+0x76>
3400e642:	ea50 0301 	orrs.w	r3, r0, r1
3400e646:	d01b      	beq.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400e648:	3801      	subs	r0, #1
3400e64a:	f141 31ff 	adc.w	r1, r1, #4294967295
3400e64e:	2808      	cmp	r0, #8
3400e650:	f171 0100 	sbcs.w	r1, r1, #0
3400e654:	d214      	bcs.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400e656:	2807      	cmp	r0, #7
3400e658:	d812      	bhi.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400e65a:	e8df f010 	tbh	[pc, r0, lsl #1]
3400e65e:	01a6      	.short	0x01a6
3400e660:	0011020f 	.word	0x0011020f
3400e664:	00110285 	.word	0x00110285
3400e668:	00110011 	.word	0x00110011
3400e66c:	0235      	.short	0x0235
3400e66e:	f1a0 0310 	sub.w	r3, r0, #16
3400e672:	430b      	orrs	r3, r1
3400e674:	f000 8242 	beq.w	3400eafc <HAL_RCCEx_GetPeriphCLKFreq+0x504>
3400e678:	3820      	subs	r0, #32
3400e67a:	4308      	orrs	r0, r1
3400e67c:	f000 8268 	beq.w	3400eb50 <HAL_RCCEx_GetPeriphCLKFreq+0x558>
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e680:	2000      	movs	r0, #0
3400e682:	e219      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3400e684:	f5a0 5300 	sub.w	r3, r0, #8192	@ 0x2000
3400e688:	430b      	orrs	r3, r1
3400e68a:	f000 831d 	beq.w	3400ecc8 <HAL_RCCEx_GetPeriphCLKFreq+0x6d0>
3400e68e:	f242 0301 	movw	r3, #8193	@ 0x2001
3400e692:	4298      	cmp	r0, r3
3400e694:	f171 0300 	sbcs.w	r3, r1, #0
3400e698:	d224      	bcs.n	3400e6e4 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
3400e69a:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
3400e69e:	430b      	orrs	r3, r1
3400e6a0:	f000 82df 	beq.w	3400ec62 <HAL_RCCEx_GetPeriphCLKFreq+0x66a>
3400e6a4:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
3400e6a8:	430b      	orrs	r3, r1
3400e6aa:	f000 8308 	beq.w	3400ecbe <HAL_RCCEx_GetPeriphCLKFreq+0x6c6>
3400e6ae:	f5a0 6080 	sub.w	r0, r0, #1024	@ 0x400
3400e6b2:	4308      	orrs	r0, r1
3400e6b4:	d1e4      	bne.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3400e6b6:	4d94      	ldr	r5, [pc, #592]	@ (3400e908 <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400e6b8:	f8d5 314c 	ldr.w	r3, [r5, #332]	@ 0x14c
3400e6bc:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
3400e6c0:	2b02      	cmp	r3, #2
3400e6c2:	f000 82c1 	beq.w	3400ec48 <HAL_RCCEx_GetPeriphCLKFreq+0x650>
3400e6c6:	2b03      	cmp	r3, #3
3400e6c8:	f000 8256 	beq.w	3400eb78 <HAL_RCCEx_GetPeriphCLKFreq+0x580>
3400e6cc:	2b01      	cmp	r3, #1
3400e6ce:	f000 824b 	beq.w	3400eb68 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e6d2:	f7fb fcad 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e6d6:	f7fb fdb7 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e6da:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400e6dc:	f003 0307 	and.w	r3, r3, #7
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e6e0:	40d8      	lsrs	r0, r3
3400e6e2:	e1e9      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3400e6e4:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
3400e6e8:	430b      	orrs	r3, r1
3400e6ea:	f000 82ef 	beq.w	3400eccc <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
3400e6ee:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
3400e6f2:	4308      	orrs	r0, r1
3400e6f4:	d1c4      	bne.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3400e6f6:	4885      	ldr	r0, [pc, #532]	@ (3400e90c <HAL_RCCEx_GetPeriphCLKFreq+0x314>)
3400e6f8:	e2e2      	b.n	3400ecc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
  switch (PeriphClk)
3400e6fa:	f5a0 0300 	sub.w	r3, r0, #8388608	@ 0x800000
3400e6fe:	430b      	orrs	r3, r1
3400e700:	f000 82f6 	beq.w	3400ecf0 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
3400e704:	4b82      	ldr	r3, [pc, #520]	@ (3400e910 <HAL_RCCEx_GetPeriphCLKFreq+0x318>)
3400e706:	4298      	cmp	r0, r3
3400e708:	f171 0300 	sbcs.w	r3, r1, #0
3400e70c:	d224      	bcs.n	3400e758 <HAL_RCCEx_GetPeriphCLKFreq+0x160>
3400e70e:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
3400e712:	430b      	orrs	r3, r1
3400e714:	f000 82e8 	beq.w	3400ece8 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
3400e718:	4b7e      	ldr	r3, [pc, #504]	@ (3400e914 <HAL_RCCEx_GetPeriphCLKFreq+0x31c>)
3400e71a:	4298      	cmp	r0, r3
3400e71c:	f171 0300 	sbcs.w	r3, r1, #0
3400e720:	d20f      	bcs.n	3400e742 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
3400e722:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
3400e726:	430b      	orrs	r3, r1
3400e728:	f000 82d7 	beq.w	3400ecda <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
3400e72c:	f5a0 2300 	sub.w	r3, r0, #524288	@ 0x80000
3400e730:	430b      	orrs	r3, r1
3400e732:	f000 82d7 	beq.w	3400ece4 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3400e736:	f5a0 3000 	sub.w	r0, r0, #131072	@ 0x20000
3400e73a:	4308      	orrs	r0, r1
3400e73c:	d1a0      	bne.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400e73e:	4876      	ldr	r0, [pc, #472]	@ (3400e918 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
3400e740:	e2c7      	b.n	3400ecd2 <HAL_RCCEx_GetPeriphCLKFreq+0x6da>
  switch (PeriphClk)
3400e742:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
3400e746:	430b      	orrs	r3, r1
3400e748:	f000 82d0 	beq.w	3400ecec <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
3400e74c:	f5a0 0080 	sub.w	r0, r0, #4194304	@ 0x400000
3400e750:	4308      	orrs	r0, r1
3400e752:	d195      	bne.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
3400e754:	4871      	ldr	r0, [pc, #452]	@ (3400e91c <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
3400e756:	e2c1      	b.n	3400ecdc <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  switch (PeriphClk)
3400e758:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
3400e75c:	430b      	orrs	r3, r1
3400e75e:	f000 834d 	beq.w	3400edfc <HAL_RCCEx_GetPeriphCLKFreq+0x804>
3400e762:	4b6f      	ldr	r3, [pc, #444]	@ (3400e920 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
3400e764:	4298      	cmp	r0, r3
3400e766:	f171 0300 	sbcs.w	r3, r1, #0
3400e76a:	d228      	bcs.n	3400e7be <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
3400e76c:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
3400e770:	430b      	orrs	r3, r1
3400e772:	f000 8302 	beq.w	3400ed7a <HAL_RCCEx_GetPeriphCLKFreq+0x782>
3400e776:	f100 407e 	add.w	r0, r0, #4261412864	@ 0xfe000000
3400e77a:	4308      	orrs	r0, r1
3400e77c:	d180      	bne.n	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3400e77e:	4d62      	ldr	r5, [pc, #392]	@ (3400e908 <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400e780:	f8d5 3154 	ldr.w	r3, [r5, #340]	@ 0x154
3400e784:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400e788:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400e78c:	f000 8195 	beq.w	3400eaba <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3400e790:	f200 8319 	bhi.w	3400edc6 <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
3400e794:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400e798:	f000 831f 	beq.w	3400edda <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
3400e79c:	f240 81e1 	bls.w	3400eb62 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3400e7a0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400e7a4:	f47f af6c 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400e7a8:	f7fb fd06 	bl	3400a1b8 <LL_RCC_IC8_IsEnabled>
3400e7ac:	2800      	cmp	r0, #0
3400e7ae:	f43f af67 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC8_GetDivider();
3400e7b2:	f7fb fd09 	bl	3400a1c8 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e7b6:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400e7ba:	4604      	mov	r4, r0
3400e7bc:	e191      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (PeriphClk)
3400e7be:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
3400e7c2:	430b      	orrs	r3, r1
3400e7c4:	f000 8344 	beq.w	3400ee50 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
3400e7c8:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
3400e7cc:	4308      	orrs	r0, r1
3400e7ce:	f47f af57 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
3400e7d2:	4854      	ldr	r0, [pc, #336]	@ (3400e924 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
}
3400e7d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400e7d8:	f7ff bbd6 	b.w	3400df88 <RCCEx_GetSAICLKFreq>
  switch (PeriphClk)
3400e7dc:	2300      	movs	r3, #0
3400e7de:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400e7e2:	4291      	cmp	r1, r2
3400e7e4:	bf08      	it	eq
3400e7e6:	4298      	cmpeq	r0, r3
3400e7e8:	f000 836f 	beq.w	3400eeca <HAL_RCCEx_GetPeriphCLKFreq+0x8d2>
3400e7ec:	4283      	cmp	r3, r0
3400e7ee:	418a      	sbcs	r2, r1
3400e7f0:	d35f      	bcc.n	3400e8b2 <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
3400e7f2:	2210      	movs	r2, #16
3400e7f4:	4291      	cmp	r1, r2
3400e7f6:	bf08      	it	eq
3400e7f8:	4298      	cmpeq	r0, r3
3400e7fa:	f000 8359 	beq.w	3400eeb0 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
3400e7fe:	4283      	cmp	r3, r0
3400e800:	418a      	sbcs	r2, r1
3400e802:	d329      	bcc.n	3400e858 <HAL_RCCEx_GetPeriphCLKFreq+0x260>
3400e804:	2202      	movs	r2, #2
3400e806:	4291      	cmp	r1, r2
3400e808:	bf08      	it	eq
3400e80a:	4298      	cmpeq	r0, r3
3400e80c:	f000 8349 	beq.w	3400eea2 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
3400e810:	4283      	cmp	r3, r0
3400e812:	418a      	sbcs	r2, r1
3400e814:	d314      	bcc.n	3400e840 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
3400e816:	4299      	cmp	r1, r3
3400e818:	bf08      	it	eq
3400e81a:	f1b0 4f00 	cmpeq.w	r0, #2147483648	@ 0x80000000
3400e81e:	f000 833a 	beq.w	3400ee96 <HAL_RCCEx_GetPeriphCLKFreq+0x89e>
3400e822:	2901      	cmp	r1, #1
3400e824:	bf08      	it	eq
3400e826:	4298      	cmpeq	r0, r3
3400e828:	f000 8337 	beq.w	3400ee9a <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
3400e82c:	f100 4040 	add.w	r0, r0, #3221225472	@ 0xc0000000
3400e830:	4308      	orrs	r0, r1
3400e832:	f47f af25 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
3400e836:	483c      	ldr	r0, [pc, #240]	@ (3400e928 <HAL_RCCEx_GetPeriphCLKFreq+0x330>)
}
3400e838:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3400e83c:	f7ff bcd8 	b.w	3400e1f0 <RCCEx_GetSDMMCCLKFreq>
  switch (PeriphClk)
3400e840:	2904      	cmp	r1, #4
3400e842:	bf08      	it	eq
3400e844:	4298      	cmpeq	r0, r3
3400e846:	f000 8331 	beq.w	3400eeac <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>
3400e84a:	2908      	cmp	r1, #8
3400e84c:	bf08      	it	eq
3400e84e:	4298      	cmpeq	r0, r3
3400e850:	f47f af16 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
3400e854:	4835      	ldr	r0, [pc, #212]	@ (3400e92c <HAL_RCCEx_GetPeriphCLKFreq+0x334>)
3400e856:	e325      	b.n	3400eea4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3400e858:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400e85c:	4291      	cmp	r1, r2
3400e85e:	bf08      	it	eq
3400e860:	4298      	cmpeq	r0, r3
3400e862:	f000 832e 	beq.w	3400eec2 <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
3400e866:	4283      	cmp	r3, r0
3400e868:	418a      	sbcs	r2, r1
3400e86a:	d311      	bcc.n	3400e890 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
3400e86c:	2940      	cmp	r1, #64	@ 0x40
3400e86e:	bf08      	it	eq
3400e870:	4298      	cmpeq	r0, r3
3400e872:	f000 831f 	beq.w	3400eeb4 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>
3400e876:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3400e87a:	bf08      	it	eq
3400e87c:	4298      	cmpeq	r0, r3
3400e87e:	f000 831b 	beq.w	3400eeb8 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>
3400e882:	2920      	cmp	r1, #32
3400e884:	bf08      	it	eq
3400e886:	2800      	cmpeq	r0, #0
3400e888:	f47f aefa 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3400e88c:	4828      	ldr	r0, [pc, #160]	@ (3400e930 <HAL_RCCEx_GetPeriphCLKFreq+0x338>)
3400e88e:	e309      	b.n	3400eea4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3400e890:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
3400e894:	bf08      	it	eq
3400e896:	4298      	cmpeq	r0, r3
3400e898:	f000 8315 	beq.w	3400eec6 <HAL_RCCEx_GetPeriphCLKFreq+0x8ce>
3400e89c:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
3400e8a0:	bf08      	it	eq
3400e8a2:	4298      	cmpeq	r0, r3
3400e8a4:	f47f aeec 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
3400e8a8:	4822      	ldr	r0, [pc, #136]	@ (3400e934 <HAL_RCCEx_GetPeriphCLKFreq+0x33c>)
}
3400e8aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400e8ae:	f7ff b919 	b.w	3400dae4 <RCCEx_GetUARTCLKFreq>
  switch (PeriphClk)
3400e8b2:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3400e8b6:	4291      	cmp	r1, r2
3400e8b8:	bf08      	it	eq
3400e8ba:	4298      	cmpeq	r0, r3
3400e8bc:	f000 830f 	beq.w	3400eede <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
3400e8c0:	4283      	cmp	r3, r0
3400e8c2:	418a      	sbcs	r2, r1
3400e8c4:	d34b      	bcc.n	3400e95e <HAL_RCCEx_GetPeriphCLKFreq+0x366>
3400e8c6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400e8ca:	4291      	cmp	r1, r2
3400e8cc:	bf08      	it	eq
3400e8ce:	4298      	cmpeq	r0, r3
3400e8d0:	f000 8301 	beq.w	3400eed6 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
3400e8d4:	4283      	cmp	r3, r0
3400e8d6:	418a      	sbcs	r2, r1
3400e8d8:	d330      	bcc.n	3400e93c <HAL_RCCEx_GetPeriphCLKFreq+0x344>
3400e8da:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
3400e8de:	bf08      	it	eq
3400e8e0:	4298      	cmpeq	r0, r3
3400e8e2:	f000 82f4 	beq.w	3400eece <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
3400e8e6:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
3400e8ea:	bf08      	it	eq
3400e8ec:	4298      	cmpeq	r0, r3
3400e8ee:	f000 82f0 	beq.w	3400eed2 <HAL_RCCEx_GetPeriphCLKFreq+0x8da>
3400e8f2:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
3400e8f6:	bf08      	it	eq
3400e8f8:	2800      	cmpeq	r0, #0
3400e8fa:	f47f aec1 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
3400e8fe:	480e      	ldr	r0, [pc, #56]	@ (3400e938 <HAL_RCCEx_GetPeriphCLKFreq+0x340>)
3400e900:	e2db      	b.n	3400eeba <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
3400e902:	bf00      	nop
3400e904:	20000001 	.word	0x20000001
3400e908:	56028000 	.word	0x56028000
3400e90c:	07000c0c 	.word	0x07000c0c
3400e910:	00800001 	.word	0x00800001
3400e914:	00100001 	.word	0x00100001
3400e918:	0700140c 	.word	0x0700140c
3400e91c:	0700182c 	.word	0x0700182c
3400e920:	04000001 	.word	0x04000001
3400e924:	07001418 	.word	0x07001418
3400e928:	0300001c 	.word	0x0300001c
3400e92c:	07000c20 	.word	0x07000c20
3400e930:	07001420 	.word	0x07001420
3400e934:	07000c30 	.word	0x07000c30
3400e938:	07001430 	.word	0x07001430
  switch (PeriphClk)
3400e93c:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
3400e940:	bf08      	it	eq
3400e942:	4298      	cmpeq	r0, r3
3400e944:	f000 82c9 	beq.w	3400eeda <HAL_RCCEx_GetPeriphCLKFreq+0x8e2>
3400e948:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
3400e94c:	bf08      	it	eq
3400e94e:	4298      	cmpeq	r0, r3
3400e950:	f47f ae96 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
3400e954:	48b4      	ldr	r0, [pc, #720]	@ (3400ec28 <HAL_RCCEx_GetPeriphCLKFreq+0x630>)
}
3400e956:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400e95a:	f7fe bf8d 	b.w	3400d878 <RCCEx_GetOTGPHYCKREFCLKFreq>
  switch (PeriphClk)
3400e95e:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
3400e962:	4291      	cmp	r1, r2
3400e964:	bf08      	it	eq
3400e966:	4298      	cmpeq	r0, r3
3400e968:	f000 82c0 	beq.w	3400eeec <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
3400e96c:	4283      	cmp	r3, r0
3400e96e:	418a      	sbcs	r2, r1
3400e970:	d30d      	bcc.n	3400e98e <HAL_RCCEx_GetPeriphCLKFreq+0x396>
3400e972:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
3400e976:	bf08      	it	eq
3400e978:	4298      	cmpeq	r0, r3
3400e97a:	f000 82b5 	beq.w	3400eee8 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
3400e97e:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
3400e982:	bf08      	it	eq
3400e984:	4298      	cmpeq	r0, r3
3400e986:	f47f ae7b 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400e98a:	48a8      	ldr	r0, [pc, #672]	@ (3400ec2c <HAL_RCCEx_GetPeriphCLKFreq+0x634>)
3400e98c:	e2a8      	b.n	3400eee0 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
  switch (PeriphClk)
3400e98e:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3400e992:	bf08      	it	eq
3400e994:	4298      	cmpeq	r0, r3
3400e996:	f000 82ae 	beq.w	3400eef6 <HAL_RCCEx_GetPeriphCLKFreq+0x8fe>
3400e99a:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
3400e99e:	bf08      	it	eq
3400e9a0:	4298      	cmpeq	r0, r3
3400e9a2:	f47f ae6d 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3400e9a6:	48a2      	ldr	r0, [pc, #648]	@ (3400ec30 <HAL_RCCEx_GetPeriphCLKFreq+0x638>)
3400e9a8:	e2a1      	b.n	3400eeee <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3400e9aa:	4da2      	ldr	r5, [pc, #648]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400e9ac:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400e9b0:	f003 0370 	and.w	r3, r3, #112	@ 0x70
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400e9b4:	2b40      	cmp	r3, #64	@ 0x40
3400e9b6:	d053      	beq.n	3400ea60 <HAL_RCCEx_GetPeriphCLKFreq+0x468>
3400e9b8:	d814      	bhi.n	3400e9e4 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
3400e9ba:	2b20      	cmp	r3, #32
3400e9bc:	d025      	beq.n	3400ea0a <HAL_RCCEx_GetPeriphCLKFreq+0x412>
3400e9be:	d805      	bhi.n	3400e9cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
3400e9c0:	bb03      	cbnz	r3, 3400ea04 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e9c2:	f7fb fb35 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400e9c6:	f7fb fc3f 	bl	3400a248 <RCCEx_GetHCLKFreq>
      break;
3400e9ca:	e002      	b.n	3400e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400e9cc:	2b30      	cmp	r3, #48	@ 0x30
3400e9ce:	d034      	beq.n	3400ea3a <HAL_RCCEx_GetPeriphCLKFreq+0x442>
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e9d0:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3400e9d2:	4b98      	ldr	r3, [pc, #608]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400e9d4:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400e9d8:	f3c3 2307 	ubfx	r3, r3, #8, #8
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3400e9dc:	3301      	adds	r3, #1
3400e9de:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
3400e9e2:	e069      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400e9e4:	2b60      	cmp	r3, #96	@ 0x60
3400e9e6:	d047      	beq.n	3400ea78 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
3400e9e8:	2b70      	cmp	r3, #112	@ 0x70
3400e9ea:	d03f      	beq.n	3400ea6c <HAL_RCCEx_GetPeriphCLKFreq+0x474>
3400e9ec:	2b50      	cmp	r3, #80	@ 0x50
3400e9ee:	d1ef      	bne.n	3400e9d0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e9f0:	f7fb fb98 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400e9f4:	2800      	cmp	r0, #0
3400e9f6:	d0eb      	beq.n	3400e9d0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e9f8:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e9fa:	488f      	ldr	r0, [pc, #572]	@ (3400ec38 <HAL_RCCEx_GetPeriphCLKFreq+0x640>)
3400e9fc:	f3c3 13c1 	ubfx	r3, r3, #7, #2
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400ea00:	40d8      	lsrs	r0, r3
      break;
3400ea02:	e7e6      	b.n	3400e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400ea04:	f7fe fd72 	bl	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400ea08:	e7e3      	b.n	3400e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400ea0a:	f7fb fbc3 	bl	3400a194 <LL_RCC_IC7_IsEnabled>
3400ea0e:	2800      	cmp	r0, #0
3400ea10:	d0de      	beq.n	3400e9d0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC7_GetDivider();
3400ea12:	f7fb fbc7 	bl	3400a1a4 <LL_RCC_IC7_GetDivider>
3400ea16:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400ea18:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400ea1c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400ea20:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ea24:	d019      	beq.n	3400ea5a <HAL_RCCEx_GetPeriphCLKFreq+0x462>
3400ea26:	d812      	bhi.n	3400ea4e <HAL_RCCEx_GetPeriphCLKFreq+0x456>
3400ea28:	b913      	cbnz	r3, 3400ea30 <HAL_RCCEx_GetPeriphCLKFreq+0x438>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ea2a:	f7fe fc5f 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
3400ea2e:	e001      	b.n	3400ea34 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ea30:	f7fe fc9c 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
            adc_frequency = adc_frequency / ic_divider;
3400ea34:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400ea38:	e7cb      	b.n	3400e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400ea3a:	f7fb fbbd 	bl	3400a1b8 <LL_RCC_IC8_IsEnabled>
3400ea3e:	2800      	cmp	r0, #0
3400ea40:	d0c6      	beq.n	3400e9d0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC8_GetDivider();
3400ea42:	f7fb fbc1 	bl	3400a1c8 <LL_RCC_IC8_GetDivider>
3400ea46:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400ea4a:	4604      	mov	r4, r0
3400ea4c:	e7e6      	b.n	3400ea1c <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        switch (LL_RCC_IC8_GetSource())
3400ea4e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ea52:	d1bd      	bne.n	3400e9d0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ea54:	f7fe fd0a 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400ea58:	e7ec      	b.n	3400ea34 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ea5a:	f7fe fcc7 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400ea5e:	e7e9      	b.n	3400ea34 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
      if (LL_RCC_MSI_IsReady() != 0U)
3400ea60:	f7fb fb68 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400ea64:	2800      	cmp	r0, #0
3400ea66:	d0b3      	beq.n	3400e9d0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        adc_frequency = MSI_VALUE;
3400ea68:	4874      	ldr	r0, [pc, #464]	@ (3400ec3c <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400ea6a:	e7b2      	b.n	3400e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400ea6c:	f7fb fae0 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400ea70:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400ea72:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400ea76:	e7c3      	b.n	3400ea00 <HAL_RCCEx_GetPeriphCLKFreq+0x408>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400ea78:	4871      	ldr	r0, [pc, #452]	@ (3400ec40 <HAL_RCCEx_GetPeriphCLKFreq+0x648>)
3400ea7a:	e7aa      	b.n	3400e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3400ea7c:	4d6d      	ldr	r5, [pc, #436]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ea7e:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400ea82:	f003 0307 	and.w	r3, r3, #7
  switch (LL_RCC_GetADFClockSource(ADFxSource))
3400ea86:	3b01      	subs	r3, #1
3400ea88:	2b06      	cmp	r3, #6
3400ea8a:	f200 80f5 	bhi.w	3400ec78 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
3400ea8e:	a201      	add	r2, pc, #4	@ (adr r2, 3400ea94 <HAL_RCCEx_GetPeriphCLKFreq+0x49c>)
3400ea90:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400ea94:	3400eb69 	.word	0x3400eb69
3400ea98:	3400eddb 	.word	0x3400eddb
3400ea9c:	3400e7a9 	.word	0x3400e7a9
3400eaa0:	3400eabb 	.word	0x3400eabb
3400eaa4:	3400eb29 	.word	0x3400eb29
3400eaa8:	3400eefb 	.word	0x3400eefb
3400eaac:	3400edf1 	.word	0x3400edf1
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400eab0:	f7fe fc5c 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
            adf_frequency = adf_frequency / ic_divider;
3400eab4:	fbb0 f0f4 	udiv	r0, r0, r4
}
3400eab8:	bd38      	pop	{r3, r4, r5, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400eaba:	f7fb fb3b 	bl	3400a134 <LL_RCC_MSI_IsReady>
3400eabe:	2800      	cmp	r0, #0
3400eac0:	f43f adde 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        adf_frequency = MSI_VALUE;
3400eac4:	485d      	ldr	r0, [pc, #372]	@ (3400ec3c <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400eac6:	e7f7      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3400eac8:	4b5a      	ldr	r3, [pc, #360]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eaca:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400eace:	0395      	lsls	r5, r2, #14
3400ead0:	f57f add6 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400ead4:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3400ead8:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400eadc:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400eae0:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400eae2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC20_GetSource())
3400eae6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eaea:	f000 81ae 	beq.w	3400ee4a <HAL_RCCEx_GetPeriphCLKFreq+0x852>
3400eaee:	f200 81a5 	bhi.w	3400ee3c <HAL_RCCEx_GetPeriphCLKFreq+0x844>
3400eaf2:	2b00      	cmp	r3, #0
3400eaf4:	d1dc      	bne.n	3400eab0 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400eaf6:	f7fe fbf9 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
3400eafa:	e7db      	b.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3400eafc:	4d4d      	ldr	r5, [pc, #308]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eafe:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400eb02:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400eb06:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400eb0a:	d014      	beq.n	3400eb36 <HAL_RCCEx_GetPeriphCLKFreq+0x53e>
3400eb0c:	d808      	bhi.n	3400eb20 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3400eb0e:	bb5b      	cbnz	r3, 3400eb68 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400eb10:	f7fb fa8e 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400eb14:	f7fb fb98 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3400eb18:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
3400eb1a:	f3c3 4302 	ubfx	r3, r3, #16, #3
3400eb1e:	e5df      	b.n	3400e6e0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400eb20:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400eb24:	f47f adac 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400eb28:	f7fb fafc 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400eb2c:	2800      	cmp	r0, #0
3400eb2e:	f43f ada7 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400eb32:	6cab      	ldr	r3, [r5, #72]	@ 0x48
3400eb34:	e136      	b.n	3400eda4 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3400eb36:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400eb3a:	03dc      	lsls	r4, r3, #15
3400eb3c:	f57f ada0 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400eb40:	f8d5 0104 	ldr.w	r0, [r5, #260]	@ 0x104
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400eb44:	f8d5 3104 	ldr.w	r3, [r5, #260]	@ 0x104
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400eb48:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400eb4c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400eb4e:	e7c8      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3400eb50:	4a38      	ldr	r2, [pc, #224]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eb52:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400eb56:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3400eb5a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400eb5e:	d012      	beq.n	3400eb86 <HAL_RCCEx_GetPeriphCLKFreq+0x58e>
3400eb60:	d806      	bhi.n	3400eb70 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400eb62:	2b00      	cmp	r3, #0
3400eb64:	f000 8088 	beq.w	3400ec78 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
}
3400eb68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400eb6c:	f7fe bcbe 	b.w	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3400eb70:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3400eb74:	f47f ad84 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSE_IsReady() != 0U)
3400eb78:	f7fb facc 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400eb7c:	2800      	cmp	r0, #0
3400eb7e:	f43f ad7f 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        eth1_frequency = HSE_VALUE;
3400eb82:	4830      	ldr	r0, [pc, #192]	@ (3400ec44 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400eb84:	e798      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3400eb86:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400eb8a:	0518      	lsls	r0, r3, #20
3400eb8c:	f57f ad78 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400eb90:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400eb94:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400eb98:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400eb9c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400eb9e:	e7a0      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3400eba0:	4a24      	ldr	r2, [pc, #144]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eba2:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400eba6:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
3400ebaa:	2b02      	cmp	r3, #2
3400ebac:	d010      	beq.n	3400ebd0 <HAL_RCCEx_GetPeriphCLKFreq+0x5d8>
3400ebae:	2b03      	cmp	r3, #3
3400ebb0:	d034      	beq.n	3400ec1c <HAL_RCCEx_GetPeriphCLKFreq+0x624>
3400ebb2:	2b01      	cmp	r3, #1
3400ebb4:	d009      	beq.n	3400ebca <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400ebb6:	f7fb fa3b 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400ebba:	f7fb fb45 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3400ebbe:	4b1d      	ldr	r3, [pc, #116]	@ (3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ebc0:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3400ebc4:	f3c3 1303 	ubfx	r3, r3, #4, #4
3400ebc8:	e708      	b.n	3400e9dc <HAL_RCCEx_GetPeriphCLKFreq+0x3e4>
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400ebca:	f7fe fc8f 	bl	3400d4ec <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400ebce:	e7f6      	b.n	3400ebbe <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3400ebd0:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400ebd4:	04d9      	lsls	r1, r3, #19
3400ebd6:	d516      	bpl.n	3400ec06 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400ebd8:	f8d2 00f4 	ldr.w	r0, [r2, #244]	@ 0xf4
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400ebdc:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400ebe0:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400ebe4:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC13_GetSource())
3400ebe8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400ebec:	f100 0401 	add.w	r4, r0, #1
3400ebf0:	d00e      	beq.n	3400ec10 <HAL_RCCEx_GetPeriphCLKFreq+0x618>
3400ebf2:	d805      	bhi.n	3400ec00 <HAL_RCCEx_GetPeriphCLKFreq+0x608>
3400ebf4:	b94b      	cbnz	r3, 3400ec0a <HAL_RCCEx_GetPeriphCLKFreq+0x612>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ebf6:	f7fe fb79 	bl	3400d2ec <HAL_RCCEx_GetPLL1CLKFreq>
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3400ebfa:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400ebfe:	e7de      	b.n	3400ebbe <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        switch (LL_RCC_IC13_GetSource())
3400ec00:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ec04:	d007      	beq.n	3400ec16 <HAL_RCCEx_GetPeriphCLKFreq+0x61e>
        eth1ptp_frequency = HSE_VALUE;
3400ec06:	2000      	movs	r0, #0
3400ec08:	e7d9      	b.n	3400ebbe <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ec0a:	f7fe fbaf 	bl	3400d36c <HAL_RCCEx_GetPLL2CLKFreq>
3400ec0e:	e7f4      	b.n	3400ebfa <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ec10:	f7fe fbec 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400ec14:	e7f1      	b.n	3400ebfa <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ec16:	f7fe fc29 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400ec1a:	e7ee      	b.n	3400ebfa <HAL_RCCEx_GetPeriphCLKFreq+0x602>
      if (LL_RCC_HSE_IsReady() != 0U)
3400ec1c:	f7fb fa7a 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400ec20:	2800      	cmp	r0, #0
3400ec22:	d0f0      	beq.n	3400ec06 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        eth1ptp_frequency = HSE_VALUE;
3400ec24:	4807      	ldr	r0, [pc, #28]	@ (3400ec44 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400ec26:	e7ca      	b.n	3400ebbe <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
3400ec28:	01001014 	.word	0x01001014
3400ec2c:	03001414 	.word	0x03001414
3400ec30:	03000814 	.word	0x03000814
3400ec34:	56028000 	.word	0x56028000
3400ec38:	03d09000 	.word	0x03d09000
3400ec3c:	003d0900 	.word	0x003d0900
3400ec40:	00bb8000 	.word	0x00bb8000
3400ec44:	02dc6c00 	.word	0x02dc6c00
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400ec48:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400ec4c:	035b      	lsls	r3, r3, #13
3400ec4e:	f57f ad17 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400ec52:	f8d5 010c 	ldr.w	r0, [r5, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400ec56:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400ec5a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ec5e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400ec60:	e73f      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3400ec62:	4ba7      	ldr	r3, [pc, #668]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ec64:	f8d3 214c 	ldr.w	r2, [r3, #332]	@ 0x14c
3400ec68:	f002 0230 	and.w	r2, r2, #48	@ 0x30
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3400ec6c:	2a20      	cmp	r2, #32
3400ec6e:	d019      	beq.n	3400eca4 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
3400ec70:	d808      	bhi.n	3400ec84 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>
3400ec72:	2a00      	cmp	r2, #0
3400ec74:	f47f af78 	bne.w	3400eb68 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400ec78:	f7fb f9da 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
}
3400ec7c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400ec80:	f7fb bae2 	b.w	3400a248 <RCCEx_GetHCLKFreq>
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3400ec84:	2a30      	cmp	r2, #48	@ 0x30
3400ec86:	f47f acfb 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400ec8a:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400ec8e:	0714      	lsls	r4, r2, #28
3400ec90:	f57f acf6 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400ec94:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400ec98:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400ec9c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400eca0:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400eca2:	e71e      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400eca4:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400eca8:	0755      	lsls	r5, r2, #29
3400ecaa:	f57f ace9 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400ecae:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400ecb2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400ecb6:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ecba:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400ecbc:	e711      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
3400ecbe:	4891      	ldr	r0, [pc, #580]	@ (3400ef04 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
}
3400ecc0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3400ecc4:	f7ff bafa 	b.w	3400e2bc <RCCEx_GetI2CCLKFreq>
3400ecc8:	488f      	ldr	r0, [pc, #572]	@ (3400ef08 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3400ecca:	e7f9      	b.n	3400ecc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
3400eccc:	488f      	ldr	r0, [pc, #572]	@ (3400ef0c <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
3400ecce:	e7f7      	b.n	3400ecc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
3400ecd0:	488f      	ldr	r0, [pc, #572]	@ (3400ef10 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
}
3400ecd2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400ecd6:	f7ff b9ff 	b.w	3400e0d8 <RCCEx_GetI3CCLKFreq>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3400ecda:	488e      	ldr	r0, [pc, #568]	@ (3400ef14 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
}
3400ecdc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
3400ece0:	f7ff bbaa 	b.w	3400e438 <RCCEx_GetLPTIMCLKFreq>
3400ece4:	488c      	ldr	r0, [pc, #560]	@ (3400ef18 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
3400ece6:	e7f9      	b.n	3400ecdc <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
3400ece8:	488c      	ldr	r0, [pc, #560]	@ (3400ef1c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3400ecea:	e7f7      	b.n	3400ecdc <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
3400ecec:	488c      	ldr	r0, [pc, #560]	@ (3400ef20 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
3400ecee:	e7f5      	b.n	3400ecdc <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3400ecf0:	4a83      	ldr	r2, [pc, #524]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ecf2:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400ecf6:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400ecfa:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400ecfe:	d031      	beq.n	3400ed64 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
3400ed00:	d812      	bhi.n	3400ed28 <HAL_RCCEx_GetPeriphCLKFreq+0x730>
3400ed02:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ed06:	f43f af2f 	beq.w	3400eb68 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
3400ed0a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400ed0e:	d01d      	beq.n	3400ed4c <HAL_RCCEx_GetPeriphCLKFreq+0x754>
3400ed10:	2b00      	cmp	r3, #0
3400ed12:	f47f acb5 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400ed16:	f7fb f98b 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
3400ed1a:	f7fb fa95 	bl	3400a248 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400ed1e:	4b78      	ldr	r3, [pc, #480]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ed20:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400ed22:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400ed26:	e4db      	b.n	3400e6e0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400ed28:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3400ed2c:	f43f aec5 	beq.w	3400eaba <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3400ed30:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400ed34:	d02f      	beq.n	3400ed96 <HAL_RCCEx_GetPeriphCLKFreq+0x79e>
3400ed36:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
  switch (LL_RCC_GetRTCClockSource())
3400ed3a:	f47f aca1 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_LSE_IsReady() != 0U)
3400ed3e:	f7fb fa01 	bl	3400a144 <LL_RCC_LSE_IsReady>
3400ed42:	3800      	subs	r0, #0
3400ed44:	bf18      	it	ne
3400ed46:	2001      	movne	r0, #1
3400ed48:	03c0      	lsls	r0, r0, #15
3400ed4a:	e6b5      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400ed4c:	f7fb fa46 	bl	3400a1dc <LL_RCC_IC9_IsEnabled>
3400ed50:	2800      	cmp	r0, #0
3400ed52:	f43f ac95 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC9_GetDivider();
3400ed56:	f7fb fa49 	bl	3400a1ec <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400ed5a:	4b69      	ldr	r3, [pc, #420]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ed5c:	4604      	mov	r4, r0
3400ed5e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400ed62:	e6be      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400ed64:	f7fb fa4c 	bl	3400a200 <LL_RCC_IC14_IsEnabled>
3400ed68:	2800      	cmp	r0, #0
3400ed6a:	f43f ac89 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC14_GetDivider();
3400ed6e:	f7fb fa4f 	bl	3400a210 <LL_RCC_IC14_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400ed72:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400ed76:	4604      	mov	r4, r0
3400ed78:	e6b3      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3400ed7a:	4d61      	ldr	r5, [pc, #388]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ed7c:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
3400ed80:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3400ed84:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400ed88:	d010      	beq.n	3400edac <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>
3400ed8a:	f67f aec0 	bls.w	3400eb0e <HAL_RCCEx_GetPeriphCLKFreq+0x516>
3400ed8e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400ed92:	f47f ac75 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400ed96:	f7fb f9c5 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400ed9a:	2800      	cmp	r0, #0
3400ed9c:	f43f ac70 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400eda0:	4b57      	ldr	r3, [pc, #348]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400eda2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400eda4:	485f      	ldr	r0, [pc, #380]	@ (3400ef24 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
3400eda6:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400edaa:	e499      	b.n	3400e6e0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3400edac:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400edb0:	0418      	lsls	r0, r3, #16
3400edb2:	f57f ac65 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400edb6:	f8d5 0100 	ldr.w	r0, [r5, #256]	@ 0x100
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400edba:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400edbe:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400edc2:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400edc4:	e68d      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400edc6:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400edca:	f000 8096 	beq.w	3400eefa <HAL_RCCEx_GetPeriphCLKFreq+0x902>
3400edce:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3400edd2:	d00d      	beq.n	3400edf0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
3400edd4:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400edd8:	e6a4      	b.n	3400eb24 <HAL_RCCEx_GetPeriphCLKFreq+0x52c>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400edda:	f7fb f9db 	bl	3400a194 <LL_RCC_IC7_IsEnabled>
3400edde:	2800      	cmp	r0, #0
3400ede0:	f43f ac4e 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC7_GetDivider();
3400ede4:	f7fb f9de 	bl	3400a1a4 <LL_RCC_IC7_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400ede8:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
3400edec:	4604      	mov	r4, r0
3400edee:	e678      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400edf0:	f7fb f91e 	bl	3400a030 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400edf4:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400edf6:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400edfa:	e471      	b.n	3400e6e0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3400edfc:	4a40      	ldr	r2, [pc, #256]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400edfe:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400ee02:	f003 0330 	and.w	r3, r3, #48	@ 0x30
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400ee06:	2b20      	cmp	r3, #32
3400ee08:	d00b      	beq.n	3400ee22 <HAL_RCCEx_GetPeriphCLKFreq+0x82a>
3400ee0a:	f67f aeaa 	bls.w	3400eb62 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3400ee0e:	2b30      	cmp	r3, #48	@ 0x30
3400ee10:	f47f ac36 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400ee14:	f7fb f986 	bl	3400a124 <LL_RCC_HSI_IsReady>
3400ee18:	2800      	cmp	r0, #0
3400ee1a:	f43f ac31 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400ee1e:	6c93      	ldr	r3, [r2, #72]	@ 0x48
3400ee20:	e7c0      	b.n	3400eda4 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400ee22:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400ee26:	0319      	lsls	r1, r3, #12
3400ee28:	f57f ac2a 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400ee2c:	f8d2 0110 	ldr.w	r0, [r2, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400ee30:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400ee34:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ee38:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400ee3a:	e652      	b.n	3400eae2 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        switch (LL_RCC_IC20_GetSource())
3400ee3c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ee40:	f47f ac1e 	bne.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ee44:	f7fe fb12 	bl	3400d46c <HAL_RCCEx_GetPLL4CLKFreq>
3400ee48:	e634      	b.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ee4a:	f7fe facf 	bl	3400d3ec <HAL_RCCEx_GetPLL3CLKFreq>
3400ee4e:	e631      	b.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400ee50:	4a2b      	ldr	r2, [pc, #172]	@ (3400ef00 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ee52:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400ee56:	f403 7340 	and.w	r3, r3, #768	@ 0x300
  switch (LL_RCC_GetRTCClockSource())
3400ee5a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400ee5e:	d005      	beq.n	3400ee6c <HAL_RCCEx_GetPeriphCLKFreq+0x874>
3400ee60:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400ee64:	d009      	beq.n	3400ee7a <HAL_RCCEx_GetPeriphCLKFreq+0x882>
3400ee66:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ee6a:	e766      	b.n	3400ed3a <HAL_RCCEx_GetPeriphCLKFreq+0x742>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400ee6c:	6853      	ldr	r3, [r2, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3400ee6e:	07db      	lsls	r3, r3, #31
3400ee70:	f57f ac06 	bpl.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        rtc_frequency = LSI_VALUE;
3400ee74:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return frequency;
3400ee78:	e61e      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_HSE_IsReady() != 0U)
3400ee7a:	f7fb f94b 	bl	3400a114 <LL_RCC_HSE_IsReady>
3400ee7e:	2800      	cmp	r0, #0
3400ee80:	f43f abfe 	beq.w	3400e680 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3400ee84:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
        rtc_frequency = HSE_VALUE / prescaler;
3400ee88:	4827      	ldr	r0, [pc, #156]	@ (3400ef28 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3400ee8a:	f3c3 3305 	ubfx	r3, r3, #12, #6
3400ee8e:	3301      	adds	r3, #1
3400ee90:	e5a5      	b.n	3400e9de <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400ee92:	4826      	ldr	r0, [pc, #152]	@ (3400ef2c <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
3400ee94:	e49e      	b.n	3400e7d4 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3400ee96:	4826      	ldr	r0, [pc, #152]	@ (3400ef30 <HAL_RCCEx_GetPeriphCLKFreq+0x938>)
3400ee98:	e4ce      	b.n	3400e838 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
}
3400ee9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400ee9e:	f7fe bbab 	b.w	3400d5f8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
3400eea2:	4824      	ldr	r0, [pc, #144]	@ (3400ef34 <HAL_RCCEx_GetPeriphCLKFreq+0x93c>)
}
3400eea4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3400eea8:	f7fe bf30 	b.w	3400dd0c <RCCEx_GetSPICLKFreq>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
3400eeac:	4822      	ldr	r0, [pc, #136]	@ (3400ef38 <HAL_RCCEx_GetPeriphCLKFreq+0x940>)
3400eeae:	e7f9      	b.n	3400eea4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
3400eeb0:	4822      	ldr	r0, [pc, #136]	@ (3400ef3c <HAL_RCCEx_GetPeriphCLKFreq+0x944>)
3400eeb2:	e7f7      	b.n	3400eea4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3400eeb4:	4822      	ldr	r0, [pc, #136]	@ (3400ef40 <HAL_RCCEx_GetPeriphCLKFreq+0x948>)
3400eeb6:	e7f5      	b.n	3400eea4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
3400eeb8:	4822      	ldr	r0, [pc, #136]	@ (3400ef44 <HAL_RCCEx_GetPeriphCLKFreq+0x94c>)
}
3400eeba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400eebe:	f7fe bd0d 	b.w	3400d8dc <RCCEx_GetUSARTCLKFreq>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3400eec2:	4821      	ldr	r0, [pc, #132]	@ (3400ef48 <HAL_RCCEx_GetPeriphCLKFreq+0x950>)
3400eec4:	e7f9      	b.n	3400eeba <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
3400eec6:	4821      	ldr	r0, [pc, #132]	@ (3400ef4c <HAL_RCCEx_GetPeriphCLKFreq+0x954>)
3400eec8:	e7f7      	b.n	3400eeba <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3400eeca:	4821      	ldr	r0, [pc, #132]	@ (3400ef50 <HAL_RCCEx_GetPeriphCLKFreq+0x958>)
3400eecc:	e4ed      	b.n	3400e8aa <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
3400eece:	4821      	ldr	r0, [pc, #132]	@ (3400ef54 <HAL_RCCEx_GetPeriphCLKFreq+0x95c>)
3400eed0:	e4eb      	b.n	3400e8aa <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
3400eed2:	4821      	ldr	r0, [pc, #132]	@ (3400ef58 <HAL_RCCEx_GetPeriphCLKFreq+0x960>)
3400eed4:	e4e9      	b.n	3400e8aa <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400eed6:	4821      	ldr	r0, [pc, #132]	@ (3400ef5c <HAL_RCCEx_GetPeriphCLKFreq+0x964>)
3400eed8:	e4e7      	b.n	3400e8aa <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400eeda:	4821      	ldr	r0, [pc, #132]	@ (3400ef60 <HAL_RCCEx_GetPeriphCLKFreq+0x968>)
3400eedc:	e7ed      	b.n	3400eeba <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400eede:	4821      	ldr	r0, [pc, #132]	@ (3400ef64 <HAL_RCCEx_GetPeriphCLKFreq+0x96c>)
}
3400eee0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400eee4:	f7fe bc62 	b.w	3400d7ac <RCCEx_GetOTGPHYCLKFreq>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400eee8:	481f      	ldr	r0, [pc, #124]	@ (3400ef68 <HAL_RCCEx_GetPeriphCLKFreq+0x970>)
3400eeea:	e534      	b.n	3400e956 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
3400eeec:	481f      	ldr	r0, [pc, #124]	@ (3400ef6c <HAL_RCCEx_GetPeriphCLKFreq+0x974>)
}
3400eeee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3400eef2:	f7fe bbe1 	b.w	3400d6b8 <RCCEx_GetXSPICLKFreq>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
3400eef6:	481e      	ldr	r0, [pc, #120]	@ (3400ef70 <HAL_RCCEx_GetPeriphCLKFreq+0x978>)
3400eef8:	e7f9      	b.n	3400eeee <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400eefa:	481e      	ldr	r0, [pc, #120]	@ (3400ef74 <HAL_RCCEx_GetPeriphCLKFreq+0x97c>)
3400eefc:	e5dc      	b.n	3400eab8 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
3400eefe:	bf00      	nop
3400ef00:	56028000 	.word	0x56028000
3400ef04:	0700000c 	.word	0x0700000c
3400ef08:	0700040c 	.word	0x0700040c
3400ef0c:	0700080c 	.word	0x0700080c
3400ef10:	0700100c 	.word	0x0700100c
3400ef14:	0700082c 	.word	0x0700082c
3400ef18:	07000c2c 	.word	0x07000c2c
3400ef1c:	0700102c 	.word	0x0700102c
3400ef20:	0700142c 	.word	0x0700142c
3400ef24:	03d09000 	.word	0x03d09000
3400ef28:	02dc6c00 	.word	0x02dc6c00
3400ef2c:	07001818 	.word	0x07001818
3400ef30:	0300041c 	.word	0x0300041c
3400ef34:	07000420 	.word	0x07000420
3400ef38:	07000820 	.word	0x07000820
3400ef3c:	07001020 	.word	0x07001020
3400ef40:	07001820 	.word	0x07001820
3400ef44:	07000030 	.word	0x07000030
3400ef48:	07000430 	.word	0x07000430
3400ef4c:	07000830 	.word	0x07000830
3400ef50:	07001030 	.word	0x07001030
3400ef54:	07001830 	.word	0x07001830
3400ef58:	07001c30 	.word	0x07001c30
3400ef5c:	07000034 	.word	0x07000034
3400ef60:	07000434 	.word	0x07000434
3400ef64:	03000c14 	.word	0x03000c14
3400ef68:	01001814 	.word	0x01001814
3400ef6c:	03000014 	.word	0x03000014
3400ef70:	03000414 	.word	0x03000414
3400ef74:	00bb8000 	.word	0x00bb8000

3400ef78 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
3400ef78:	b538      	push	{r3, r4, r5, lr}
3400ef7a:	4604      	mov	r4, r0
  uint32_t master_cid;
  uint32_t rimc_attr_val;

  /* Check the parameter */
  assert_param(pConfig != (void *)NULL);
3400ef7c:	460d      	mov	r5, r1
3400ef7e:	b921      	cbnz	r1, 3400ef8a <HAL_RIF_RIMC_ConfigMasterAttributes+0x12>
3400ef80:	f240 1111 	movw	r1, #273	@ 0x111
3400ef84:	4825      	ldr	r0, [pc, #148]	@ (3400f01c <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400ef86:	f7f3 fad5 	bl	34002534 <assert_failed>
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
3400ef8a:	2c0c      	cmp	r4, #12
3400ef8c:	d904      	bls.n	3400ef98 <HAL_RIF_RIMC_ConfigMasterAttributes+0x20>
3400ef8e:	f44f 7189 	mov.w	r1, #274	@ 0x112
3400ef92:	4822      	ldr	r0, [pc, #136]	@ (3400f01c <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400ef94:	f7f3 face 	bl	34002534 <assert_failed>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
3400ef98:	682b      	ldr	r3, [r5, #0]
3400ef9a:	2b20      	cmp	r3, #32
3400ef9c:	d838      	bhi.n	3400f010 <HAL_RIF_RIMC_ConfigMasterAttributes+0x98>
3400ef9e:	2b03      	cmp	r3, #3
3400efa0:	d82a      	bhi.n	3400eff8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x80>
3400efa2:	3b01      	subs	r3, #1
3400efa4:	2b01      	cmp	r3, #1
3400efa6:	d82d      	bhi.n	3400f004 <HAL_RIF_RIMC_ConfigMasterAttributes+0x8c>
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
3400efa8:	682b      	ldr	r3, [r5, #0]
3400efaa:	2b80      	cmp	r3, #128	@ 0x80
3400efac:	d001      	beq.n	3400efb2 <HAL_RIF_RIMC_ConfigMasterAttributes+0x3a>
3400efae:	2bff      	cmp	r3, #255	@ 0xff
3400efb0:	d904      	bls.n	3400efbc <HAL_RIF_RIMC_ConfigMasterAttributes+0x44>
3400efb2:	f44f 718a 	mov.w	r1, #276	@ 0x114
3400efb6:	4819      	ldr	r0, [pc, #100]	@ (3400f01c <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400efb8:	f7f3 fabc 	bl	34002534 <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));
3400efbc:	686b      	ldr	r3, [r5, #4]
3400efbe:	2b03      	cmp	r3, #3
3400efc0:	d904      	bls.n	3400efcc <HAL_RIF_RIMC_ConfigMasterAttributes+0x54>
3400efc2:	f240 1115 	movw	r1, #277	@ 0x115
3400efc6:	4815      	ldr	r0, [pc, #84]	@ (3400f01c <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400efc8:	f7f3 fab4 	bl	34002534 <assert_failed>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
3400efcc:	682b      	ldr	r3, [r5, #0]
3400efce:	fa93 f3a3 	rbit	r3, r3
  return __builtin_clz(value);
3400efd2:	fab3 f283 	clz	r2, r3

  master_cid = POSITION_VAL(pConfig->MasterCID);
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
3400efd6:	00a0      	lsls	r0, r4, #2
3400efd8:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
3400efdc:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
3400efe0:	f8d0 3c10 	ldr.w	r3, [r0, #3088]	@ 0xc10
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3400efe4:	6869      	ldr	r1, [r5, #4]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
3400efe6:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
3400efea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3400efee:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
3400eff2:	f8c0 3c10 	str.w	r3, [r0, #3088]	@ 0xc10
}
3400eff6:	bd38      	pop	{r3, r4, r5, pc}
3400eff8:	4a09      	ldr	r2, [pc, #36]	@ (3400f020 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa8>)
3400effa:	3b04      	subs	r3, #4
3400effc:	fa22 f303 	lsr.w	r3, r2, r3
3400f000:	07db      	lsls	r3, r3, #31
3400f002:	d4d1      	bmi.n	3400efa8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
3400f004:	f240 1113 	movw	r1, #275	@ 0x113
3400f008:	4804      	ldr	r0, [pc, #16]	@ (3400f01c <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f00a:	f7f3 fa93 	bl	34002534 <assert_failed>
3400f00e:	e7cb      	b.n	3400efa8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f010:	2b40      	cmp	r3, #64	@ 0x40
3400f012:	d0c9      	beq.n	3400efa8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f014:	2b80      	cmp	r3, #128	@ 0x80
3400f016:	d1f5      	bne.n	3400f004 <HAL_RIF_RIMC_ConfigMasterAttributes+0x8c>
3400f018:	e7c6      	b.n	3400efa8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f01a:	bf00      	nop
3400f01c:	3401c73b 	.word	0x3401c73b
3400f020:	10001011 	.word	0x10001011

3400f024 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
3400f024:	4b38      	ldr	r3, [pc, #224]	@ (3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xe4>)
{
3400f026:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400f028:	4298      	cmp	r0, r3
3400f02a:	4604      	mov	r4, r0
3400f02c:	460d      	mov	r5, r1
3400f02e:	d85c      	bhi.n	3400f0ea <HAL_RIF_RISC_SetSlaveSecureAttributes+0xc6>
3400f030:	3b1e      	subs	r3, #30
3400f032:	4298      	cmp	r0, r3
3400f034:	d83b      	bhi.n	3400f0ae <HAL_RIF_RISC_SetSlaveSecureAttributes+0x8a>
3400f036:	4b35      	ldr	r3, [pc, #212]	@ (3400f10c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xe8>)
3400f038:	4298      	cmp	r0, r3
3400f03a:	d84b      	bhi.n	3400f0d4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xb0>
3400f03c:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
3400f040:	d23a      	bcs.n	3400f0b8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x94>
3400f042:	4b33      	ldr	r3, [pc, #204]	@ (3400f110 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xec>)
3400f044:	4298      	cmp	r0, r3
3400f046:	d840      	bhi.n	3400f0ca <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa6>
3400f048:	1fc2      	subs	r2, r0, #7
3400f04a:	3b22      	subs	r3, #34	@ 0x22
3400f04c:	429a      	cmp	r2, r3
3400f04e:	d937      	bls.n	3400f0c0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x9c>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));
3400f050:	2d03      	cmp	r5, #3
3400f052:	d904      	bls.n	3400f05e <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a>
3400f054:	f44f 71b9 	mov.w	r1, #370	@ 0x172
3400f058:	482e      	ldr	r0, [pc, #184]	@ (3400f114 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf0>)
3400f05a:	f7f3 fa6b 	bl	34002534 <assert_failed>

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f05e:	2201      	movs	r2, #1
  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f060:	0f20      	lsrs	r0, r4, #28
3400f062:	0080      	lsls	r0, r0, #2
3400f064:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
3400f068:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
3400f06c:	6903      	ldr	r3, [r0, #16]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f06e:	f004 041f 	and.w	r4, r4, #31
  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f072:	9301      	str	r3, [sp, #4]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f074:	9b01      	ldr	r3, [sp, #4]
3400f076:	40a2      	lsls	r2, r4
3400f078:	ea23 0302 	bic.w	r3, r3, r2
3400f07c:	9301      	str	r3, [sp, #4]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f07e:	9901      	ldr	r1, [sp, #4]
3400f080:	f005 0301 	and.w	r3, r5, #1
3400f084:	40a3      	lsls	r3, r4
3400f086:	430b      	orrs	r3, r1
3400f088:	9301      	str	r3, [sp, #4]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f08a:	9b01      	ldr	r3, [sp, #4]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f08c:	f3c5 0140 	ubfx	r1, r5, #1, #1
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f090:	6103      	str	r3, [r0, #16]
  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f092:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f094:	40a1      	lsls	r1, r4
  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f096:	9301      	str	r3, [sp, #4]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f098:	9b01      	ldr	r3, [sp, #4]
3400f09a:	ea23 0302 	bic.w	r3, r3, r2
3400f09e:	9301      	str	r3, [sp, #4]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f0a0:	9b01      	ldr	r3, [sp, #4]
3400f0a2:	4319      	orrs	r1, r3
3400f0a4:	9101      	str	r1, [sp, #4]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f0a6:	9b01      	ldr	r3, [sp, #4]
3400f0a8:	6303      	str	r3, [r0, #48]	@ 0x30
}
3400f0aa:	b003      	add	sp, #12
3400f0ac:	bd30      	pop	{r4, r5, pc}
3400f0ae:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
3400f0b2:	4b19      	ldr	r3, [pc, #100]	@ (3400f118 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf4>)
3400f0b4:	3a02      	subs	r2, #2
3400f0b6:	e01d      	b.n	3400f0f4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd0>
3400f0b8:	4b18      	ldr	r3, [pc, #96]	@ (3400f11c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf8>)
3400f0ba:	f100 4260 	add.w	r2, r0, #3758096384	@ 0xe0000000
3400f0be:	e019      	b.n	3400f0f4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd0>
3400f0c0:	f1a0 0308 	sub.w	r3, r0, #8
3400f0c4:	2b17      	cmp	r3, #23
3400f0c6:	d9c3      	bls.n	3400f050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f0c8:	e017      	b.n	3400f0fa <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f0ca:	f100 4370 	add.w	r3, r0, #4026531840	@ 0xf0000000
3400f0ce:	3b1c      	subs	r3, #28
3400f0d0:	2b02      	cmp	r3, #2
3400f0d2:	e7f8      	b.n	3400f0c6 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa2>
3400f0d4:	4b12      	ldr	r3, [pc, #72]	@ (3400f120 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xfc>)
3400f0d6:	4298      	cmp	r0, r3
3400f0d8:	d803      	bhi.n	3400f0e2 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xbe>
3400f0da:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400f0de:	d2b7      	bcs.n	3400f050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f0e0:	e00b      	b.n	3400f0fa <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f0e2:	4b10      	ldr	r3, [pc, #64]	@ (3400f124 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x100>)
3400f0e4:	4298      	cmp	r0, r3
3400f0e6:	d0b3      	beq.n	3400f050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f0e8:	e007      	b.n	3400f0fa <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f0ea:	f100 4230 	add.w	r2, r0, #2952790016	@ 0xb0000000
3400f0ee:	2a1e      	cmp	r2, #30
3400f0f0:	d803      	bhi.n	3400f0fa <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f0f2:	4b0d      	ldr	r3, [pc, #52]	@ (3400f128 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x104>)
3400f0f4:	40d3      	lsrs	r3, r2
3400f0f6:	07db      	lsls	r3, r3, #31
3400f0f8:	d4aa      	bmi.n	3400f050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
3400f0fa:	f240 1171 	movw	r1, #369	@ 0x171
3400f0fe:	4805      	ldr	r0, [pc, #20]	@ (3400f114 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf0>)
3400f100:	f7f3 fa18 	bl	34002534 <assert_failed>
3400f104:	e7a4      	b.n	3400f050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f106:	bf00      	nop
3400f108:	4000001f 	.word	0x4000001f
3400f10c:	2000001e 	.word	0x2000001e
3400f110:	1000001a 	.word	0x1000001a
3400f114:	3401c73b 	.word	0x3401c73b
3400f118:	2e838c0b 	.word	0x2e838c0b
3400f11c:	77dff03b 	.word	0x77dff03b
3400f120:	30000008 	.word	0x30000008
3400f124:	3000000a 	.word	0x3000000a
3400f128:	49deef7f 	.word	0x49deef7f

3400f12c <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
3400f12c:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3400f12e:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f130:	e852 3f00 	ldrex	r3, [r2]
3400f134:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f138:	e842 3100 	strex	r1, r3, [r2]
   return(result);
3400f13c:	6802      	ldr	r2, [r0, #0]
3400f13e:	2900      	cmp	r1, #0
3400f140:	d1f5      	bne.n	3400f12e <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
3400f142:	4c0f      	ldr	r4, [pc, #60]	@ (3400f180 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f144:	f102 0308 	add.w	r3, r2, #8
3400f148:	e853 3f00 	ldrex	r3, [r3]
3400f14c:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f14e:	f102 0c08 	add.w	ip, r2, #8
3400f152:	e84c 3100 	strex	r1, r3, [ip]
3400f156:	2900      	cmp	r1, #0
3400f158:	d1f4      	bne.n	3400f144 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
3400f15a:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
3400f15c:	2b01      	cmp	r3, #1
3400f15e:	d107      	bne.n	3400f170 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f160:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
3400f164:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f168:	e842 3100 	strex	r1, r3, [r2]
3400f16c:	2900      	cmp	r1, #0
3400f16e:	d1f7      	bne.n	3400f160 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
3400f170:	2320      	movs	r3, #32
3400f172:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400f176:	2300      	movs	r3, #0
3400f178:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
3400f17a:	6743      	str	r3, [r0, #116]	@ 0x74
}
3400f17c:	bd10      	pop	{r4, pc}
3400f17e:	bf00      	nop
3400f180:	effffffe 	.word	0xeffffffe

3400f184 <HAL_UART_MspInit>:
}
3400f184:	4770      	bx	lr
	...

3400f188 <UART_SetConfig>:
{
3400f188:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
3400f18a:	6842      	ldr	r2, [r0, #4]
3400f18c:	4bb0      	ldr	r3, [pc, #704]	@ (3400f450 <UART_SetConfig+0x2c8>)
{
3400f18e:	4604      	mov	r4, r0
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
3400f190:	429a      	cmp	r2, r3
3400f192:	d904      	bls.n	3400f19e <UART_SetConfig+0x16>
3400f194:	f640 414c 	movw	r1, #3148	@ 0xc4c
3400f198:	48ae      	ldr	r0, [pc, #696]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f19a:	f7f3 f9cb 	bl	34002534 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
3400f19e:	68a3      	ldr	r3, [r4, #8]
3400f1a0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f1a4:	d007      	beq.n	3400f1b6 <UART_SetConfig+0x2e>
3400f1a6:	f433 5380 	bics.w	r3, r3, #4096	@ 0x1000
3400f1aa:	d004      	beq.n	3400f1b6 <UART_SetConfig+0x2e>
3400f1ac:	f640 414d 	movw	r1, #3149	@ 0xc4d
3400f1b0:	48a8      	ldr	r0, [pc, #672]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f1b2:	f7f3 f9bf 	bl	34002534 <assert_failed>
  if (UART_INSTANCE_LOWPOWER(huart))
3400f1b6:	6822      	ldr	r2, [r4, #0]
3400f1b8:	49a7      	ldr	r1, [pc, #668]	@ (3400f458 <UART_SetConfig+0x2d0>)
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
3400f1ba:	68e3      	ldr	r3, [r4, #12]
  if (UART_INSTANCE_LOWPOWER(huart))
3400f1bc:	428a      	cmp	r2, r1
3400f1be:	d004      	beq.n	3400f1ca <UART_SetConfig+0x42>
3400f1c0:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
3400f1c4:	428a      	cmp	r2, r1
3400f1c6:	f040 80af 	bne.w	3400f328 <UART_SetConfig+0x1a0>
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
3400f1ca:	f433 5300 	bics.w	r3, r3, #8192	@ 0x2000
3400f1ce:	d004      	beq.n	3400f1da <UART_SetConfig+0x52>
3400f1d0:	f44f 6145 	mov.w	r1, #3152	@ 0xc50
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
3400f1d4:	489f      	ldr	r0, [pc, #636]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f1d6:	f7f3 f9ad 	bl	34002534 <assert_failed>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
3400f1da:	6923      	ldr	r3, [r4, #16]
3400f1dc:	f433 6280 	bics.w	r2, r3, #1024	@ 0x400
3400f1e0:	d007      	beq.n	3400f1f2 <UART_SetConfig+0x6a>
3400f1e2:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400f1e6:	d004      	beq.n	3400f1f2 <UART_SetConfig+0x6a>
3400f1e8:	f640 4158 	movw	r1, #3160	@ 0xc58
3400f1ec:	4899      	ldr	r0, [pc, #612]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f1ee:	f7f3 f9a1 	bl	34002534 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
3400f1f2:	6963      	ldr	r3, [r4, #20]
3400f1f4:	f033 020c 	bics.w	r2, r3, #12
3400f1f8:	d100      	bne.n	3400f1fc <UART_SetConfig+0x74>
3400f1fa:	b923      	cbnz	r3, 3400f206 <UART_SetConfig+0x7e>
3400f1fc:	f640 4159 	movw	r1, #3161	@ 0xc59
3400f200:	4894      	ldr	r0, [pc, #592]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f202:	f7f3 f997 	bl	34002534 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
3400f206:	69a3      	ldr	r3, [r4, #24]
3400f208:	f433 7340 	bics.w	r3, r3, #768	@ 0x300
3400f20c:	d004      	beq.n	3400f218 <UART_SetConfig+0x90>
3400f20e:	f640 415a 	movw	r1, #3162	@ 0xc5a
3400f212:	4890      	ldr	r0, [pc, #576]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f214:	f7f3 f98e 	bl	34002534 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
3400f218:	69e3      	ldr	r3, [r4, #28]
3400f21a:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
3400f21e:	d004      	beq.n	3400f22a <UART_SetConfig+0xa2>
3400f220:	f640 415b 	movw	r1, #3163	@ 0xc5b
3400f224:	488b      	ldr	r0, [pc, #556]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f226:	f7f3 f985 	bl	34002534 <assert_failed>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
3400f22a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400f22c:	2b0b      	cmp	r3, #11
3400f22e:	d904      	bls.n	3400f23a <UART_SetConfig+0xb2>
3400f230:	f640 415c 	movw	r1, #3164	@ 0xc5c
3400f234:	4887      	ldr	r0, [pc, #540]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f236:	f7f3 f97d 	bl	34002534 <assert_failed>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f23a:	6921      	ldr	r1, [r4, #16]
3400f23c:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f23e:	6823      	ldr	r3, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f240:	430a      	orrs	r2, r1
3400f242:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f244:	6818      	ldr	r0, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f246:	69e5      	ldr	r5, [r4, #28]
3400f248:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f24a:	4984      	ldr	r1, [pc, #528]	@ (3400f45c <UART_SetConfig+0x2d4>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f24c:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f24e:	4001      	ands	r1, r0
3400f250:	430a      	orrs	r2, r1
3400f252:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
3400f254:	685a      	ldr	r2, [r3, #4]
3400f256:	68e1      	ldr	r1, [r4, #12]
3400f258:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
3400f25c:	430a      	orrs	r2, r1
3400f25e:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
3400f260:	4a7d      	ldr	r2, [pc, #500]	@ (3400f458 <UART_SetConfig+0x2d0>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
3400f262:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
3400f264:	4293      	cmp	r3, r2
3400f266:	d005      	beq.n	3400f274 <UART_SetConfig+0xec>
3400f268:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f26c:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
3400f26e:	bf1c      	itt	ne
3400f270:	6a22      	ldrne	r2, [r4, #32]
3400f272:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
3400f274:	689a      	ldr	r2, [r3, #8]
3400f276:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
3400f27a:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
3400f27e:	430a      	orrs	r2, r1
3400f280:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
3400f282:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400f284:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f286:	f022 020f 	bic.w	r2, r2, #15
3400f28a:	430a      	orrs	r2, r1
3400f28c:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f28e:	4a74      	ldr	r2, [pc, #464]	@ (3400f460 <UART_SetConfig+0x2d8>)
3400f290:	4293      	cmp	r3, r2
3400f292:	d07a      	beq.n	3400f38a <UART_SetConfig+0x202>
3400f294:	4a73      	ldr	r2, [pc, #460]	@ (3400f464 <UART_SetConfig+0x2dc>)
3400f296:	4293      	cmp	r3, r2
3400f298:	f000 809c 	beq.w	3400f3d4 <UART_SetConfig+0x24c>
3400f29c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f2a0:	4293      	cmp	r3, r2
3400f2a2:	f000 809b 	beq.w	3400f3dc <UART_SetConfig+0x254>
3400f2a6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f2aa:	4293      	cmp	r3, r2
3400f2ac:	f000 809a 	beq.w	3400f3e4 <UART_SetConfig+0x25c>
3400f2b0:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f2b4:	f000 809a 	beq.w	3400f3ec <UART_SetConfig+0x264>
3400f2b8:	4a6b      	ldr	r2, [pc, #428]	@ (3400f468 <UART_SetConfig+0x2e0>)
3400f2ba:	4293      	cmp	r3, r2
3400f2bc:	f000 809a 	beq.w	3400f3f4 <UART_SetConfig+0x26c>
3400f2c0:	4a6a      	ldr	r2, [pc, #424]	@ (3400f46c <UART_SetConfig+0x2e4>)
3400f2c2:	4293      	cmp	r3, r2
3400f2c4:	f000 809a 	beq.w	3400f3fc <UART_SetConfig+0x274>
3400f2c8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f2cc:	4293      	cmp	r3, r2
3400f2ce:	f000 8099 	beq.w	3400f404 <UART_SetConfig+0x27c>
3400f2d2:	4a67      	ldr	r2, [pc, #412]	@ (3400f470 <UART_SetConfig+0x2e8>)
3400f2d4:	4293      	cmp	r3, r2
3400f2d6:	f000 8099 	beq.w	3400f40c <UART_SetConfig+0x284>
3400f2da:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f2de:	4293      	cmp	r3, r2
3400f2e0:	f000 8098 	beq.w	3400f414 <UART_SetConfig+0x28c>
3400f2e4:	4a5c      	ldr	r2, [pc, #368]	@ (3400f458 <UART_SetConfig+0x2d0>)
3400f2e6:	4293      	cmp	r3, r2
3400f2e8:	d02e      	beq.n	3400f348 <UART_SetConfig+0x1c0>
  if (UART_INSTANCE_LOWPOWER(huart))
3400f2ea:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f2ee:	4293      	cmp	r3, r2
3400f2f0:	f04f 0000 	mov.w	r0, #0
3400f2f4:	f04f 0100 	mov.w	r1, #0
3400f2f8:	d14a      	bne.n	3400f390 <UART_SetConfig+0x208>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400f2fa:	f7ff f97d 	bl	3400e5f8 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
3400f2fe:	2800      	cmp	r0, #0
3400f300:	d041      	beq.n	3400f386 <UART_SetConfig+0x1fe>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400f302:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f304:	4a5b      	ldr	r2, [pc, #364]	@ (3400f474 <UART_SetConfig+0x2ec>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f306:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400f308:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f30c:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400f310:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f314:	4299      	cmp	r1, r3
3400f316:	d91b      	bls.n	3400f350 <UART_SetConfig+0x1c8>
        ret = HAL_ERROR;
3400f318:	2001      	movs	r0, #1
  huart->NbRxDataToProcess = 1;
3400f31a:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
3400f31e:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
3400f320:	2300      	movs	r3, #0
  huart->TxISR = NULL;
3400f322:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
3400f326:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
3400f328:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400f32c:	d004      	beq.n	3400f338 <UART_SetConfig+0x1b0>
3400f32e:	f640 4154 	movw	r1, #3156	@ 0xc54
3400f332:	4848      	ldr	r0, [pc, #288]	@ (3400f454 <UART_SetConfig+0x2cc>)
3400f334:	f7f3 f8fe 	bl	34002534 <assert_failed>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
3400f338:	6a23      	ldr	r3, [r4, #32]
3400f33a:	f433 6300 	bics.w	r3, r3, #2048	@ 0x800
3400f33e:	f43f af4c 	beq.w	3400f1da <UART_SetConfig+0x52>
3400f342:	f640 4155 	movw	r1, #3157	@ 0xc55
3400f346:	e745      	b.n	3400f1d4 <UART_SetConfig+0x4c>
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f348:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
3400f34c:	2100      	movs	r1, #0
3400f34e:	e7d4      	b.n	3400f2fa <UART_SetConfig+0x172>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f350:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
3400f354:	d8e0      	bhi.n	3400f318 <UART_SetConfig+0x190>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400f356:	2300      	movs	r3, #0
3400f358:	4619      	mov	r1, r3
3400f35a:	f7f2 f93f 	bl	340015dc <__aeabi_uldivmod>
3400f35e:	4606      	mov	r6, r0
3400f360:	460f      	mov	r7, r1
3400f362:	ea56 270f 	orrs.w	r7, r6, pc, lsl #8
3400f366:	0868      	lsrs	r0, r5, #1
3400f368:	1830      	adds	r0, r6, r0
3400f36a:	462a      	mov	r2, r5
3400f36c:	f04f 0300 	mov.w	r3, #0
3400f370:	f147 0100 	adc.w	r1, r7, #0
3400f374:	f7f2 f932 	bl	340015dc <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
3400f378:	4b3f      	ldr	r3, [pc, #252]	@ (3400f478 <UART_SetConfig+0x2f0>)
3400f37a:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
3400f37e:	429a      	cmp	r2, r3
3400f380:	d8ca      	bhi.n	3400f318 <UART_SetConfig+0x190>
          huart->Instance->BRR = usartdiv;
3400f382:	6823      	ldr	r3, [r4, #0]
3400f384:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
3400f386:	2000      	movs	r0, #0
3400f388:	e7c7      	b.n	3400f31a <UART_SetConfig+0x192>
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f38a:	2000      	movs	r0, #0
3400f38c:	f44f 7180 	mov.w	r1, #256	@ 0x100
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
3400f390:	f5b5 4f00 	cmp.w	r5, #32768	@ 0x8000
3400f394:	d142      	bne.n	3400f41c <UART_SetConfig+0x294>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400f396:	f7ff f92f 	bl	3400e5f8 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
3400f39a:	2800      	cmp	r0, #0
3400f39c:	d0f3      	beq.n	3400f386 <UART_SetConfig+0x1fe>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400f39e:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f3a0:	4b34      	ldr	r3, [pc, #208]	@ (3400f474 <UART_SetConfig+0x2ec>)
3400f3a2:	6862      	ldr	r2, [r4, #4]
3400f3a4:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
3400f3a8:	fbb0 f0f3 	udiv	r0, r0, r3
3400f3ac:	0853      	lsrs	r3, r2, #1
3400f3ae:	eb03 0340 	add.w	r3, r3, r0, lsl #1
3400f3b2:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3400f3b6:	f64f 72ef 	movw	r2, #65519	@ 0xffef
3400f3ba:	f1a3 0110 	sub.w	r1, r3, #16
3400f3be:	4291      	cmp	r1, r2
3400f3c0:	d8aa      	bhi.n	3400f318 <UART_SetConfig+0x190>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3400f3c2:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
3400f3c6:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3400f3c8:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
3400f3ca:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
3400f3ce:	4313      	orrs	r3, r2
3400f3d0:	60cb      	str	r3, [r1, #12]
3400f3d2:	e7d8      	b.n	3400f386 <UART_SetConfig+0x1fe>
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f3d4:	2000      	movs	r0, #0
3400f3d6:	f44f 7100 	mov.w	r1, #512	@ 0x200
3400f3da:	e7d9      	b.n	3400f390 <UART_SetConfig+0x208>
3400f3dc:	2000      	movs	r0, #0
3400f3de:	f44f 6180 	mov.w	r1, #1024	@ 0x400
3400f3e2:	e7d5      	b.n	3400f390 <UART_SetConfig+0x208>
3400f3e4:	2000      	movs	r0, #0
3400f3e6:	f44f 6100 	mov.w	r1, #2048	@ 0x800
3400f3ea:	e7d1      	b.n	3400f390 <UART_SetConfig+0x208>
3400f3ec:	2000      	movs	r0, #0
3400f3ee:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
3400f3f2:	e7cd      	b.n	3400f390 <UART_SetConfig+0x208>
3400f3f4:	2000      	movs	r0, #0
3400f3f6:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
3400f3fa:	e7c9      	b.n	3400f390 <UART_SetConfig+0x208>
3400f3fc:	2000      	movs	r0, #0
3400f3fe:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
3400f402:	e7c5      	b.n	3400f390 <UART_SetConfig+0x208>
3400f404:	2000      	movs	r0, #0
3400f406:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400f40a:	e7c1      	b.n	3400f390 <UART_SetConfig+0x208>
3400f40c:	2000      	movs	r0, #0
3400f40e:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
3400f412:	e7bd      	b.n	3400f390 <UART_SetConfig+0x208>
3400f414:	2000      	movs	r0, #0
3400f416:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
3400f41a:	e7b9      	b.n	3400f390 <UART_SetConfig+0x208>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400f41c:	f7ff f8ec 	bl	3400e5f8 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
3400f420:	2800      	cmp	r0, #0
3400f422:	d0b0      	beq.n	3400f386 <UART_SetConfig+0x1fe>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400f424:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f426:	4b13      	ldr	r3, [pc, #76]	@ (3400f474 <UART_SetConfig+0x2ec>)
3400f428:	6862      	ldr	r2, [r4, #4]
3400f42a:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
3400f42e:	fbb0 f3f3 	udiv	r3, r0, r3
3400f432:	eb03 0352 	add.w	r3, r3, r2, lsr #1
3400f436:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3400f43a:	f64f 72ef 	movw	r2, #65519	@ 0xffef
3400f43e:	f1a3 0110 	sub.w	r1, r3, #16
3400f442:	4291      	cmp	r1, r2
3400f444:	f63f af68 	bhi.w	3400f318 <UART_SetConfig+0x190>
        huart->Instance->BRR = (uint16_t)usartdiv;
3400f448:	6822      	ldr	r2, [r4, #0]
3400f44a:	60d3      	str	r3, [r2, #12]
3400f44c:	e79b      	b.n	3400f386 <UART_SetConfig+0x1fe>
3400f44e:	bf00      	nop
3400f450:	00bebc1f 	.word	0x00bebc1f
3400f454:	3401c7a9 	.word	0x3401c7a9
3400f458:	56000c00 	.word	0x56000c00
3400f45c:	cfff69f3 	.word	0xcfff69f3
3400f460:	52001000 	.word	0x52001000
3400f464:	50004400 	.word	0x50004400
3400f468:	52001400 	.word	0x52001400
3400f46c:	50007800 	.word	0x50007800
3400f470:	52001800 	.word	0x52001800
3400f474:	34034ef6 	.word	0x34034ef6
3400f478:	000ffcff 	.word	0x000ffcff

3400f47c <UART_AdvFeatureConfig>:
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3400f47c:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
3400f47e:	b510      	push	{r4, lr}
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3400f480:	2bff      	cmp	r3, #255	@ 0xff
{
3400f482:	4604      	mov	r4, r0
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3400f484:	d904      	bls.n	3400f490 <UART_AdvFeatureConfig+0x14>
3400f486:	f640 41e1 	movw	r1, #3297	@ 0xce1
3400f48a:	487e      	ldr	r0, [pc, #504]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f48c:	f7f3 f852 	bl	34002534 <assert_failed>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
3400f490:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f492:	0718      	lsls	r0, r3, #28
3400f494:	d50f      	bpl.n	3400f4b6 <UART_AdvFeatureConfig+0x3a>
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
3400f496:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400f498:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
3400f49c:	d004      	beq.n	3400f4a8 <UART_AdvFeatureConfig+0x2c>
3400f49e:	f640 41e6 	movw	r1, #3302	@ 0xce6
3400f4a2:	4878      	ldr	r0, [pc, #480]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f4a4:	f7f3 f846 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
3400f4a8:	6822      	ldr	r2, [r4, #0]
3400f4aa:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
3400f4ac:	6853      	ldr	r3, [r2, #4]
3400f4ae:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400f4b2:	430b      	orrs	r3, r1
3400f4b4:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
3400f4b6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f4b8:	07d9      	lsls	r1, r3, #31
3400f4ba:	d50f      	bpl.n	3400f4dc <UART_AdvFeatureConfig+0x60>
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
3400f4bc:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400f4be:	f433 3300 	bics.w	r3, r3, #131072	@ 0x20000
3400f4c2:	d004      	beq.n	3400f4ce <UART_AdvFeatureConfig+0x52>
3400f4c4:	f640 41ed 	movw	r1, #3309	@ 0xced
3400f4c8:	486e      	ldr	r0, [pc, #440]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f4ca:	f7f3 f833 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
3400f4ce:	6822      	ldr	r2, [r4, #0]
3400f4d0:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400f4d2:	6853      	ldr	r3, [r2, #4]
3400f4d4:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
3400f4d8:	430b      	orrs	r3, r1
3400f4da:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
3400f4dc:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f4de:	079a      	lsls	r2, r3, #30
3400f4e0:	d50f      	bpl.n	3400f502 <UART_AdvFeatureConfig+0x86>
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
3400f4e2:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400f4e4:	f433 3380 	bics.w	r3, r3, #65536	@ 0x10000
3400f4e8:	d004      	beq.n	3400f4f4 <UART_AdvFeatureConfig+0x78>
3400f4ea:	f640 41f4 	movw	r1, #3316	@ 0xcf4
3400f4ee:	4865      	ldr	r0, [pc, #404]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f4f0:	f7f3 f820 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
3400f4f4:	6822      	ldr	r2, [r4, #0]
3400f4f6:	6b21      	ldr	r1, [r4, #48]	@ 0x30
3400f4f8:	6853      	ldr	r3, [r2, #4]
3400f4fa:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400f4fe:	430b      	orrs	r3, r1
3400f500:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
3400f502:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f504:	075b      	lsls	r3, r3, #29
3400f506:	d50f      	bpl.n	3400f528 <UART_AdvFeatureConfig+0xac>
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
3400f508:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400f50a:	f433 2380 	bics.w	r3, r3, #262144	@ 0x40000
3400f50e:	d004      	beq.n	3400f51a <UART_AdvFeatureConfig+0x9e>
3400f510:	f640 41fb 	movw	r1, #3323	@ 0xcfb
3400f514:	485b      	ldr	r0, [pc, #364]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f516:	f7f3 f80d 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
3400f51a:	6822      	ldr	r2, [r4, #0]
3400f51c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3400f51e:	6853      	ldr	r3, [r2, #4]
3400f520:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
3400f524:	430b      	orrs	r3, r1
3400f526:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
3400f528:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f52a:	06d8      	lsls	r0, r3, #27
3400f52c:	d50f      	bpl.n	3400f54e <UART_AdvFeatureConfig+0xd2>
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
3400f52e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400f530:	f433 5380 	bics.w	r3, r3, #4096	@ 0x1000
3400f534:	d004      	beq.n	3400f540 <UART_AdvFeatureConfig+0xc4>
3400f536:	f640 5102 	movw	r1, #3330	@ 0xd02
3400f53a:	4852      	ldr	r0, [pc, #328]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f53c:	f7f2 fffa 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
3400f540:	6822      	ldr	r2, [r4, #0]
3400f542:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400f544:	6893      	ldr	r3, [r2, #8]
3400f546:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
3400f54a:	430b      	orrs	r3, r1
3400f54c:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
3400f54e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f550:	0699      	lsls	r1, r3, #26
3400f552:	d50f      	bpl.n	3400f574 <UART_AdvFeatureConfig+0xf8>
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
3400f554:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400f556:	f433 5300 	bics.w	r3, r3, #8192	@ 0x2000
3400f55a:	d004      	beq.n	3400f566 <UART_AdvFeatureConfig+0xea>
3400f55c:	f640 510a 	movw	r1, #3338	@ 0xd0a
3400f560:	4848      	ldr	r0, [pc, #288]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f562:	f7f2 ffe7 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
3400f566:	6822      	ldr	r2, [r4, #0]
3400f568:	6c21      	ldr	r1, [r4, #64]	@ 0x40
3400f56a:	6893      	ldr	r3, [r2, #8]
3400f56c:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
3400f570:	430b      	orrs	r3, r1
3400f572:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
3400f574:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f576:	065a      	lsls	r2, r3, #25
3400f578:	d56f      	bpl.n	3400f65a <UART_AdvFeatureConfig+0x1de>
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
3400f57a:	6823      	ldr	r3, [r4, #0]
3400f57c:	4a42      	ldr	r2, [pc, #264]	@ (3400f688 <UART_AdvFeatureConfig+0x20c>)
3400f57e:	4293      	cmp	r3, r2
3400f580:	d047      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f582:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f586:	4293      	cmp	r3, r2
3400f588:	d043      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f58a:	4a40      	ldr	r2, [pc, #256]	@ (3400f68c <UART_AdvFeatureConfig+0x210>)
3400f58c:	4293      	cmp	r3, r2
3400f58e:	d040      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f590:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f594:	4293      	cmp	r3, r2
3400f596:	d03c      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f598:	4a3d      	ldr	r2, [pc, #244]	@ (3400f690 <UART_AdvFeatureConfig+0x214>)
3400f59a:	4293      	cmp	r3, r2
3400f59c:	d039      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f59e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f5a2:	4293      	cmp	r3, r2
3400f5a4:	d035      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5a6:	4a3b      	ldr	r2, [pc, #236]	@ (3400f694 <UART_AdvFeatureConfig+0x218>)
3400f5a8:	4293      	cmp	r3, r2
3400f5aa:	d032      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5ac:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f5b0:	4293      	cmp	r3, r2
3400f5b2:	d02e      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5b4:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f5b8:	d02b      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5ba:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f5be:	4293      	cmp	r3, r2
3400f5c0:	d027      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5c2:	4a35      	ldr	r2, [pc, #212]	@ (3400f698 <UART_AdvFeatureConfig+0x21c>)
3400f5c4:	4293      	cmp	r3, r2
3400f5c6:	d024      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5c8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f5cc:	4293      	cmp	r3, r2
3400f5ce:	d020      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5d0:	4a32      	ldr	r2, [pc, #200]	@ (3400f69c <UART_AdvFeatureConfig+0x220>)
3400f5d2:	4293      	cmp	r3, r2
3400f5d4:	d01d      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5d6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f5da:	4293      	cmp	r3, r2
3400f5dc:	d019      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5de:	4a30      	ldr	r2, [pc, #192]	@ (3400f6a0 <UART_AdvFeatureConfig+0x224>)
3400f5e0:	4293      	cmp	r3, r2
3400f5e2:	d016      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5e4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f5e8:	4293      	cmp	r3, r2
3400f5ea:	d012      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5ec:	4a2d      	ldr	r2, [pc, #180]	@ (3400f6a4 <UART_AdvFeatureConfig+0x228>)
3400f5ee:	4293      	cmp	r3, r2
3400f5f0:	d00f      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5f2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f5f6:	4293      	cmp	r3, r2
3400f5f8:	d00b      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f5fa:	4a2b      	ldr	r2, [pc, #172]	@ (3400f6a8 <UART_AdvFeatureConfig+0x22c>)
3400f5fc:	4293      	cmp	r3, r2
3400f5fe:	d008      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f600:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f604:	4293      	cmp	r3, r2
3400f606:	d004      	beq.n	3400f612 <UART_AdvFeatureConfig+0x196>
3400f608:	f640 5112 	movw	r1, #3346	@ 0xd12
3400f60c:	481d      	ldr	r0, [pc, #116]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f60e:	f7f2 ff91 	bl	34002534 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
3400f612:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400f614:	f433 1380 	bics.w	r3, r3, #1048576	@ 0x100000
3400f618:	d004      	beq.n	3400f624 <UART_AdvFeatureConfig+0x1a8>
3400f61a:	f640 5113 	movw	r1, #3347	@ 0xd13
3400f61e:	4819      	ldr	r0, [pc, #100]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f620:	f7f2 ff88 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
3400f624:	6821      	ldr	r1, [r4, #0]
3400f626:	6c62      	ldr	r2, [r4, #68]	@ 0x44
3400f628:	684b      	ldr	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3400f62a:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
3400f62e:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400f632:	ea43 0302 	orr.w	r3, r3, r2
3400f636:	604b      	str	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3400f638:	d10f      	bne.n	3400f65a <UART_AdvFeatureConfig+0x1de>
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
3400f63a:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400f63c:	f433 03c0 	bics.w	r3, r3, #6291456	@ 0x600000
3400f640:	d004      	beq.n	3400f64c <UART_AdvFeatureConfig+0x1d0>
3400f642:	f640 5118 	movw	r1, #3352	@ 0xd18
3400f646:	480f      	ldr	r0, [pc, #60]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f648:	f7f2 ff74 	bl	34002534 <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
3400f64c:	6822      	ldr	r2, [r4, #0]
3400f64e:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
3400f650:	6853      	ldr	r3, [r2, #4]
3400f652:	f423 03c0 	bic.w	r3, r3, #6291456	@ 0x600000
3400f656:	430b      	orrs	r3, r1
3400f658:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
3400f65a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f65c:	061b      	lsls	r3, r3, #24
3400f65e:	d50f      	bpl.n	3400f680 <UART_AdvFeatureConfig+0x204>
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
3400f660:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400f662:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
3400f666:	d004      	beq.n	3400f672 <UART_AdvFeatureConfig+0x1f6>
3400f668:	f44f 6152 	mov.w	r1, #3360	@ 0xd20
3400f66c:	4805      	ldr	r0, [pc, #20]	@ (3400f684 <UART_AdvFeatureConfig+0x208>)
3400f66e:	f7f2 ff61 	bl	34002534 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
3400f672:	6822      	ldr	r2, [r4, #0]
3400f674:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400f676:	6853      	ldr	r3, [r2, #4]
3400f678:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
3400f67c:	430b      	orrs	r3, r1
3400f67e:	6053      	str	r3, [r2, #4]
}
3400f680:	bd10      	pop	{r4, pc}
3400f682:	bf00      	nop
3400f684:	3401c7a9 	.word	0x3401c7a9
3400f688:	52001000 	.word	0x52001000
3400f68c:	50004400 	.word	0x50004400
3400f690:	50004800 	.word	0x50004800
3400f694:	50004c00 	.word	0x50004c00
3400f698:	52001400 	.word	0x52001400
3400f69c:	50007800 	.word	0x50007800
3400f6a0:	50007c00 	.word	0x50007c00
3400f6a4:	52001800 	.word	0x52001800
3400f6a8:	52001c00 	.word	0x52001c00

3400f6ac <UART_WaitOnFlagUntilTimeout>:
{
3400f6ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3400f6b0:	4604      	mov	r4, r0
3400f6b2:	460d      	mov	r5, r1
3400f6b4:	4617      	mov	r7, r2
3400f6b6:	4698      	mov	r8, r3
3400f6b8:	f8dd 9020 	ldr.w	r9, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
3400f6bc:	6822      	ldr	r2, [r4, #0]
3400f6be:	69d3      	ldr	r3, [r2, #28]
3400f6c0:	ea35 0303 	bics.w	r3, r5, r3
3400f6c4:	bf0c      	ite	eq
3400f6c6:	2301      	moveq	r3, #1
3400f6c8:	2300      	movne	r3, #0
3400f6ca:	42bb      	cmp	r3, r7
3400f6cc:	d001      	beq.n	3400f6d2 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
3400f6ce:	2000      	movs	r0, #0
3400f6d0:	e022      	b.n	3400f718 <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
3400f6d2:	f1b9 3fff 	cmp.w	r9, #4294967295
3400f6d6:	d0f2      	beq.n	3400f6be <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400f6d8:	f7f5 f898 	bl	3400480c <HAL_GetTick>
3400f6dc:	eba0 0008 	sub.w	r0, r0, r8
3400f6e0:	4548      	cmp	r0, r9
3400f6e2:	d829      	bhi.n	3400f738 <UART_WaitOnFlagUntilTimeout+0x8c>
3400f6e4:	f1b9 0f00 	cmp.w	r9, #0
3400f6e8:	d026      	beq.n	3400f738 <UART_WaitOnFlagUntilTimeout+0x8c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
3400f6ea:	6821      	ldr	r1, [r4, #0]
3400f6ec:	680b      	ldr	r3, [r1, #0]
3400f6ee:	075a      	lsls	r2, r3, #29
3400f6f0:	d5e4      	bpl.n	3400f6bc <UART_WaitOnFlagUntilTimeout+0x10>
3400f6f2:	2d80      	cmp	r5, #128	@ 0x80
3400f6f4:	d0e2      	beq.n	3400f6bc <UART_WaitOnFlagUntilTimeout+0x10>
3400f6f6:	2d40      	cmp	r5, #64	@ 0x40
3400f6f8:	d0e0      	beq.n	3400f6bc <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
3400f6fa:	69ce      	ldr	r6, [r1, #28]
3400f6fc:	f016 0608 	ands.w	r6, r6, #8
3400f700:	d00c      	beq.n	3400f71c <UART_WaitOnFlagUntilTimeout+0x70>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
3400f702:	2508      	movs	r5, #8
          UART_EndRxTransfer(huart);
3400f704:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
3400f706:	620d      	str	r5, [r1, #32]
          UART_EndRxTransfer(huart);
3400f708:	f7ff fd10 	bl	3400f12c <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
3400f70c:	2300      	movs	r3, #0
          return HAL_ERROR;
3400f70e:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
3400f710:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
3400f714:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
3400f718:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
3400f71c:	69cb      	ldr	r3, [r1, #28]
3400f71e:	051b      	lsls	r3, r3, #20
3400f720:	d5cc      	bpl.n	3400f6bc <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
3400f722:	f44f 6300 	mov.w	r3, #2048	@ 0x800
          UART_EndRxTransfer(huart);
3400f726:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
3400f728:	620b      	str	r3, [r1, #32]
          UART_EndRxTransfer(huart);
3400f72a:	f7ff fcff 	bl	3400f12c <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
3400f72e:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
3400f730:	f884 6084 	strb.w	r6, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
3400f734:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
3400f738:	2003      	movs	r0, #3
3400f73a:	e7ed      	b.n	3400f718 <UART_WaitOnFlagUntilTimeout+0x6c>

3400f73c <HAL_UART_Transmit>:
{
3400f73c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
3400f740:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
3400f742:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
3400f746:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
3400f748:	2b20      	cmp	r3, #32
{
3400f74a:	460d      	mov	r5, r1
3400f74c:	4616      	mov	r6, r2
  if (huart->gState == HAL_UART_STATE_READY)
3400f74e:	d148      	bne.n	3400f7e2 <HAL_UART_Transmit+0xa6>
    if ((pData == NULL) || (Size == 0U))
3400f750:	2900      	cmp	r1, #0
3400f752:	d048      	beq.n	3400f7e6 <HAL_UART_Transmit+0xaa>
3400f754:	2a00      	cmp	r2, #0
3400f756:	d046      	beq.n	3400f7e6 <HAL_UART_Transmit+0xaa>
    huart->gState = HAL_UART_STATE_BUSY_TX;
3400f758:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
3400f75a:	f04f 0900 	mov.w	r9, #0
3400f75e:	f8c0 9090 	str.w	r9, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
3400f762:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
3400f766:	f7f5 f851 	bl	3400480c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3400f76a:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
3400f76c:	f8a4 6054 	strh.w	r6, [r4, #84]	@ 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3400f770:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
3400f774:	f8a4 6056 	strh.w	r6, [r4, #86]	@ 0x56
    tickstart = HAL_GetTick();
3400f778:	4607      	mov	r7, r0
      pdata16bits = NULL;
3400f77a:	464e      	mov	r6, r9
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3400f77c:	d103      	bne.n	3400f786 <HAL_UART_Transmit+0x4a>
3400f77e:	6923      	ldr	r3, [r4, #16]
3400f780:	b90b      	cbnz	r3, 3400f786 <HAL_UART_Transmit+0x4a>
      pdata16bits = (const uint16_t *) pData;
3400f782:	462e      	mov	r6, r5
      pdata8bits  = NULL;
3400f784:	461d      	mov	r5, r3
    while (huart->TxXferCount > 0U)
3400f786:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3400f78a:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
3400f78c:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3400f78e:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
3400f792:	b942      	cbnz	r2, 3400f7a6 <HAL_UART_Transmit+0x6a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
3400f794:	2140      	movs	r1, #64	@ 0x40
3400f796:	4620      	mov	r0, r4
3400f798:	f7ff ff88 	bl	3400f6ac <UART_WaitOnFlagUntilTimeout>
3400f79c:	2320      	movs	r3, #32
3400f79e:	b948      	cbnz	r0, 3400f7b4 <HAL_UART_Transmit+0x78>
    huart->gState = HAL_UART_STATE_READY;
3400f7a0:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
3400f7a4:	e009      	b.n	3400f7ba <HAL_UART_Transmit+0x7e>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3400f7a6:	2200      	movs	r2, #0
3400f7a8:	2180      	movs	r1, #128	@ 0x80
3400f7aa:	4620      	mov	r0, r4
3400f7ac:	f7ff ff7e 	bl	3400f6ac <UART_WaitOnFlagUntilTimeout>
3400f7b0:	b130      	cbz	r0, 3400f7c0 <HAL_UART_Transmit+0x84>
        huart->gState = HAL_UART_STATE_READY;
3400f7b2:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
3400f7b4:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
3400f7b6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
3400f7ba:	b003      	add	sp, #12
3400f7bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
3400f7c0:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
3400f7c2:	b95d      	cbnz	r5, 3400f7dc <HAL_UART_Transmit+0xa0>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
3400f7c4:	f836 3b02 	ldrh.w	r3, [r6], #2
3400f7c8:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
3400f7cc:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
3400f7ce:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
3400f7d2:	3a01      	subs	r2, #1
3400f7d4:	b292      	uxth	r2, r2
3400f7d6:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
3400f7da:	e7d4      	b.n	3400f786 <HAL_UART_Transmit+0x4a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
3400f7dc:	f815 3b01 	ldrb.w	r3, [r5], #1
3400f7e0:	e7f4      	b.n	3400f7cc <HAL_UART_Transmit+0x90>
    return HAL_BUSY;
3400f7e2:	2002      	movs	r0, #2
3400f7e4:	e7e9      	b.n	3400f7ba <HAL_UART_Transmit+0x7e>
      return  HAL_ERROR;
3400f7e6:	2001      	movs	r0, #1
3400f7e8:	e7e7      	b.n	3400f7ba <HAL_UART_Transmit+0x7e>

3400f7ea <UART_CheckIdleState>:
{
3400f7ea:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
3400f7ec:	2600      	movs	r6, #0
{
3400f7ee:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
3400f7f0:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
3400f7f4:	f7f5 f80a 	bl	3400480c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
3400f7f8:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
3400f7fa:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
3400f7fc:	681b      	ldr	r3, [r3, #0]
3400f7fe:	071a      	lsls	r2, r3, #28
3400f800:	d51c      	bpl.n	3400f83c <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3400f802:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3400f806:	4632      	mov	r2, r6
3400f808:	9300      	str	r3, [sp, #0]
3400f80a:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
3400f80e:	4603      	mov	r3, r0
3400f810:	4620      	mov	r0, r4
3400f812:	f7ff ff4b 	bl	3400f6ac <UART_WaitOnFlagUntilTimeout>
3400f816:	b188      	cbz	r0, 3400f83c <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
3400f818:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f81a:	e852 3f00 	ldrex	r3, [r2]
3400f81e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f822:	e842 3100 	strex	r1, r3, [r2]
3400f826:	2900      	cmp	r1, #0
3400f828:	d1f6      	bne.n	3400f818 <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
3400f82a:	2320      	movs	r3, #32
3400f82c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
3400f830:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
3400f832:	2300      	movs	r3, #0
3400f834:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
3400f838:	b002      	add	sp, #8
3400f83a:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
3400f83c:	6823      	ldr	r3, [r4, #0]
3400f83e:	681b      	ldr	r3, [r3, #0]
3400f840:	075b      	lsls	r3, r3, #29
3400f842:	d524      	bpl.n	3400f88e <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3400f844:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3400f848:	2200      	movs	r2, #0
3400f84a:	9300      	str	r3, [sp, #0]
3400f84c:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
3400f850:	462b      	mov	r3, r5
3400f852:	4620      	mov	r0, r4
3400f854:	f7ff ff2a 	bl	3400f6ac <UART_WaitOnFlagUntilTimeout>
3400f858:	b1c8      	cbz	r0, 3400f88e <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3400f85a:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f85c:	e852 3f00 	ldrex	r3, [r2]
3400f860:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f864:	e842 3100 	strex	r1, r3, [r2]
   return(result);
3400f868:	6822      	ldr	r2, [r4, #0]
3400f86a:	2900      	cmp	r1, #0
3400f86c:	d1f5      	bne.n	3400f85a <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f86e:	f102 0308 	add.w	r3, r2, #8
3400f872:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
3400f876:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f87a:	f102 0008 	add.w	r0, r2, #8
3400f87e:	e840 3100 	strex	r1, r3, [r0]
3400f882:	2900      	cmp	r1, #0
3400f884:	d1f3      	bne.n	3400f86e <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
3400f886:	2320      	movs	r3, #32
3400f888:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
3400f88c:	e7d0      	b.n	3400f830 <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
3400f88e:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400f890:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
3400f892:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
3400f896:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400f89a:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
3400f89c:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
3400f89e:	e7c8      	b.n	3400f832 <UART_CheckIdleState+0x48>

3400f8a0 <HAL_UART_Init>:
{
3400f8a0:	b510      	push	{r4, lr}
  if (huart == NULL)
3400f8a2:	4604      	mov	r4, r0
3400f8a4:	2800      	cmp	r0, #0
3400f8a6:	f000 80d0 	beq.w	3400fa4a <HAL_UART_Init+0x1aa>
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
3400f8aa:	6981      	ldr	r1, [r0, #24]
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
3400f8ac:	6803      	ldr	r3, [r0, #0]
3400f8ae:	4a68      	ldr	r2, [pc, #416]	@ (3400fa50 <HAL_UART_Init+0x1b0>)
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
3400f8b0:	2900      	cmp	r1, #0
3400f8b2:	d07c      	beq.n	3400f9ae <HAL_UART_Init+0x10e>
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
3400f8b4:	4293      	cmp	r3, r2
3400f8b6:	d04e      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8b8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f8bc:	4293      	cmp	r3, r2
3400f8be:	d04a      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8c0:	4a64      	ldr	r2, [pc, #400]	@ (3400fa54 <HAL_UART_Init+0x1b4>)
3400f8c2:	4293      	cmp	r3, r2
3400f8c4:	d047      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8c6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f8ca:	4293      	cmp	r3, r2
3400f8cc:	d043      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8ce:	4a62      	ldr	r2, [pc, #392]	@ (3400fa58 <HAL_UART_Init+0x1b8>)
3400f8d0:	4293      	cmp	r3, r2
3400f8d2:	d040      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8d4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f8d8:	4293      	cmp	r3, r2
3400f8da:	d03c      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8dc:	4a5f      	ldr	r2, [pc, #380]	@ (3400fa5c <HAL_UART_Init+0x1bc>)
3400f8de:	4293      	cmp	r3, r2
3400f8e0:	d039      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8e2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f8e6:	4293      	cmp	r3, r2
3400f8e8:	d035      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8ea:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f8ee:	d032      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8f0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f8f4:	4293      	cmp	r3, r2
3400f8f6:	d02e      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8f8:	4a59      	ldr	r2, [pc, #356]	@ (3400fa60 <HAL_UART_Init+0x1c0>)
3400f8fa:	4293      	cmp	r3, r2
3400f8fc:	d02b      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f8fe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f902:	4293      	cmp	r3, r2
3400f904:	d027      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f906:	4a57      	ldr	r2, [pc, #348]	@ (3400fa64 <HAL_UART_Init+0x1c4>)
3400f908:	4293      	cmp	r3, r2
3400f90a:	d024      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f90c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f910:	4293      	cmp	r3, r2
3400f912:	d020      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f914:	4a54      	ldr	r2, [pc, #336]	@ (3400fa68 <HAL_UART_Init+0x1c8>)
3400f916:	4293      	cmp	r3, r2
3400f918:	d01d      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f91a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f91e:	4293      	cmp	r3, r2
3400f920:	d019      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f922:	4a52      	ldr	r2, [pc, #328]	@ (3400fa6c <HAL_UART_Init+0x1cc>)
3400f924:	4293      	cmp	r3, r2
3400f926:	d016      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f928:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f92c:	4293      	cmp	r3, r2
3400f92e:	d012      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f930:	4a4f      	ldr	r2, [pc, #316]	@ (3400fa70 <HAL_UART_Init+0x1d0>)
3400f932:	4293      	cmp	r3, r2
3400f934:	d00f      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f936:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f93a:	4293      	cmp	r3, r2
3400f93c:	d00b      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f93e:	4a4d      	ldr	r2, [pc, #308]	@ (3400fa74 <HAL_UART_Init+0x1d4>)
3400f940:	4293      	cmp	r3, r2
3400f942:	d008      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f944:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f948:	4293      	cmp	r3, r2
3400f94a:	d004      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f94c:	f44f 71a0 	mov.w	r1, #320	@ 0x140
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
3400f950:	4849      	ldr	r0, [pc, #292]	@ (3400fa78 <HAL_UART_Init+0x1d8>)
3400f952:	f7f2 fdef 	bl	34002534 <assert_failed>
  if (huart->gState == HAL_UART_STATE_RESET)
3400f956:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400f95a:	b923      	cbnz	r3, 3400f966 <HAL_UART_Init+0xc6>
    HAL_UART_MspInit(huart);
3400f95c:	4620      	mov	r0, r4
    huart->Lock = HAL_UNLOCKED;
3400f95e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
    HAL_UART_MspInit(huart);
3400f962:	f7ff fc0f 	bl	3400f184 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
3400f966:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
3400f968:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
3400f96a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
3400f96e:	6813      	ldr	r3, [r2, #0]
3400f970:	f023 0301 	bic.w	r3, r3, #1
3400f974:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
3400f976:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f978:	b113      	cbz	r3, 3400f980 <HAL_UART_Init+0xe0>
    UART_AdvFeatureConfig(huart);
3400f97a:	4620      	mov	r0, r4
3400f97c:	f7ff fd7e 	bl	3400f47c <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
3400f980:	4620      	mov	r0, r4
3400f982:	f7ff fc01 	bl	3400f188 <UART_SetConfig>
3400f986:	2801      	cmp	r0, #1
3400f988:	d05f      	beq.n	3400fa4a <HAL_UART_Init+0x1aa>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
3400f98a:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
3400f98c:	4620      	mov	r0, r4
}
3400f98e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
3400f992:	685a      	ldr	r2, [r3, #4]
3400f994:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
3400f998:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
3400f99a:	689a      	ldr	r2, [r3, #8]
3400f99c:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
3400f9a0:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
3400f9a2:	681a      	ldr	r2, [r3, #0]
3400f9a4:	f042 0201 	orr.w	r2, r2, #1
3400f9a8:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
3400f9aa:	f7ff bf1e 	b.w	3400f7ea <UART_CheckIdleState>
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
3400f9ae:	4293      	cmp	r3, r2
3400f9b0:	d0d1      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9b2:	4a32      	ldr	r2, [pc, #200]	@ (3400fa7c <HAL_UART_Init+0x1dc>)
3400f9b4:	4293      	cmp	r3, r2
3400f9b6:	d0ce      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9b8:	4a26      	ldr	r2, [pc, #152]	@ (3400fa54 <HAL_UART_Init+0x1b4>)
3400f9ba:	4293      	cmp	r3, r2
3400f9bc:	d0cb      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9be:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9c2:	4293      	cmp	r3, r2
3400f9c4:	d0c7      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9c6:	4a24      	ldr	r2, [pc, #144]	@ (3400fa58 <HAL_UART_Init+0x1b8>)
3400f9c8:	4293      	cmp	r3, r2
3400f9ca:	d0c4      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9cc:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9d0:	4293      	cmp	r3, r2
3400f9d2:	d0c0      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9d4:	4a21      	ldr	r2, [pc, #132]	@ (3400fa5c <HAL_UART_Init+0x1bc>)
3400f9d6:	4293      	cmp	r3, r2
3400f9d8:	d0bd      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9da:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9de:	4293      	cmp	r3, r2
3400f9e0:	d0b9      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9e2:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f9e6:	d0b6      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9e8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f9ec:	4293      	cmp	r3, r2
3400f9ee:	d0b2      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9f0:	4a1b      	ldr	r2, [pc, #108]	@ (3400fa60 <HAL_UART_Init+0x1c0>)
3400f9f2:	4293      	cmp	r3, r2
3400f9f4:	d0af      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9f6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9fa:	4293      	cmp	r3, r2
3400f9fc:	d0ab      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400f9fe:	4a19      	ldr	r2, [pc, #100]	@ (3400fa64 <HAL_UART_Init+0x1c4>)
3400fa00:	4293      	cmp	r3, r2
3400fa02:	d0a8      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa04:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa08:	4293      	cmp	r3, r2
3400fa0a:	d0a4      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa0c:	4a16      	ldr	r2, [pc, #88]	@ (3400fa68 <HAL_UART_Init+0x1c8>)
3400fa0e:	4293      	cmp	r3, r2
3400fa10:	d0a1      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa12:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa16:	4293      	cmp	r3, r2
3400fa18:	d09d      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa1a:	4a14      	ldr	r2, [pc, #80]	@ (3400fa6c <HAL_UART_Init+0x1cc>)
3400fa1c:	4293      	cmp	r3, r2
3400fa1e:	d09a      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa20:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa24:	4293      	cmp	r3, r2
3400fa26:	d096      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa28:	4a11      	ldr	r2, [pc, #68]	@ (3400fa70 <HAL_UART_Init+0x1d0>)
3400fa2a:	4293      	cmp	r3, r2
3400fa2c:	d093      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa2e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa32:	4293      	cmp	r3, r2
3400fa34:	d08f      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa36:	4a0f      	ldr	r2, [pc, #60]	@ (3400fa74 <HAL_UART_Init+0x1d4>)
3400fa38:	4293      	cmp	r3, r2
3400fa3a:	d08c      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa3c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa40:	4293      	cmp	r3, r2
3400fa42:	d088      	beq.n	3400f956 <HAL_UART_Init+0xb6>
3400fa44:	f240 1145 	movw	r1, #325	@ 0x145
3400fa48:	e782      	b.n	3400f950 <HAL_UART_Init+0xb0>
}
3400fa4a:	2001      	movs	r0, #1
3400fa4c:	bd10      	pop	{r4, pc}
3400fa4e:	bf00      	nop
3400fa50:	52001000 	.word	0x52001000
3400fa54:	50004400 	.word	0x50004400
3400fa58:	50004800 	.word	0x50004800
3400fa5c:	50004c00 	.word	0x50004c00
3400fa60:	52001400 	.word	0x52001400
3400fa64:	50007800 	.word	0x50007800
3400fa68:	50007c00 	.word	0x50007c00
3400fa6c:	52001800 	.word	0x52001800
3400fa70:	52001c00 	.word	0x52001c00
3400fa74:	56000c00 	.word	0x56000c00
3400fa78:	3401c7a9 	.word	0x3401c7a9
3400fa7c:	42001000 	.word	0x42001000

3400fa80 <XSPI_ConfigCmd>:
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400fa80:	6802      	ldr	r2, [r0, #0]
{
3400fa82:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400fa86:	6813      	ldr	r3, [r2, #0]
{
3400fa88:	4606      	mov	r6, r0
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400fa8a:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3400fa8e:	6013      	str	r3, [r2, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400fa90:	6883      	ldr	r3, [r0, #8]
{
3400fa92:	460c      	mov	r4, r1
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400fa94:	b97b      	cbnz	r3, 3400fab6 <XSPI_ConfigCmd+0x36>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3400fa96:	684b      	ldr	r3, [r1, #4]
3400fa98:	f033 4340 	bics.w	r3, r3, #3221225472	@ 0xc0000000
3400fa9c:	d004      	beq.n	3400faa8 <XSPI_ConfigCmd+0x28>
3400fa9e:	f640 41a3 	movw	r1, #3235	@ 0xca3
3400faa2:	4876      	ldr	r0, [pc, #472]	@ (3400fc7c <XSPI_ConfigCmd+0x1fc>)
3400faa4:	f7f2 fd46 	bl	34002534 <assert_failed>
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
3400faa8:	6832      	ldr	r2, [r6, #0]
3400faaa:	6861      	ldr	r1, [r4, #4]
3400faac:	6813      	ldr	r3, [r2, #0]
3400faae:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
3400fab2:	430b      	orrs	r3, r1
3400fab4:	6013      	str	r3, [r2, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400fab6:	6823      	ldr	r3, [r4, #0]
  {
    ccr_reg = &(hxspi->Instance->WCCR);
3400fab8:	6831      	ldr	r1, [r6, #0]
  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400faba:	2b02      	cmp	r3, #2
3400fabc:	d158      	bne.n	3400fb70 <XSPI_ConfigCmd+0xf0>
    ccr_reg = &(hxspi->Instance->WCCR);
3400fabe:	f501 72c0 	add.w	r2, r1, #384	@ 0x180
    tcr_reg = &(hxspi->Instance->WTCR);
3400fac2:	f501 70c4 	add.w	r0, r1, #392	@ 0x188
    ir_reg  = &(hxspi->Instance->WIR);
3400fac6:	f501 75c8 	add.w	r5, r1, #400	@ 0x190
    abr_reg = &(hxspi->Instance->WABR);
3400faca:	f501 73d0 	add.w	r3, r1, #416	@ 0x1a0
    ir_reg  = &(hxspi->Instance->IR);
    abr_reg = &(hxspi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
3400face:	6ca7      	ldr	r7, [r4, #72]	@ 0x48
3400fad0:	6017      	str	r7, [r2, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3400fad2:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
3400fad4:	b167      	cbz	r7, 3400faf0 <XSPI_ConfigCmd+0x70>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
3400fad6:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3400fad8:	601f      	str	r7, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
3400fada:	6b67      	ldr	r7, [r4, #52]	@ 0x34
3400fadc:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400fade:	f8d2 c000 	ldr.w	ip, [r2]
3400fae2:	433b      	orrs	r3, r7
3400fae4:	6b27      	ldr	r7, [r4, #48]	@ 0x30
3400fae6:	433b      	orrs	r3, r7
3400fae8:	f42c 177c 	bic.w	r7, ip, #4128768	@ 0x3f0000
3400faec:	433b      	orrs	r3, r7
3400faee:	6013      	str	r3, [r2, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
3400faf0:	6803      	ldr	r3, [r0, #0]
3400faf2:	6c67      	ldr	r7, [r4, #68]	@ 0x44
3400faf4:	f023 031f 	bic.w	r3, r3, #31
3400faf8:	433b      	orrs	r3, r7
3400fafa:	6003      	str	r3, [r0, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fafc:	f8d4 e038 	ldr.w	lr, [r4, #56]	@ 0x38
3400fb00:	f1be 0f00 	cmp.w	lr, #0
3400fb04:	d00e      	beq.n	3400fb24 <XSPI_ConfigCmd+0xa4>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400fb06:	6823      	ldr	r3, [r4, #0]
3400fb08:	b913      	cbnz	r3, 3400fb10 <XSPI_ConfigCmd+0x90>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
3400fb0a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400fb0c:	3b01      	subs	r3, #1
3400fb0e:	640b      	str	r3, [r1, #64]	@ 0x40
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
3400fb10:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400fb12:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400fb16:	d13f      	bne.n	3400fb98 <XSPI_ConfigCmd+0x118>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400fb18:	f8d1 3108 	ldr.w	r3, [r1, #264]	@ 0x108
3400fb1c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400fb20:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400fb24:	68e3      	ldr	r3, [r4, #12]
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fb26:	f8d4 901c 	ldr.w	r9, [r4, #28]
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400fb2a:	2b00      	cmp	r3, #0
3400fb2c:	f000 8083 	beq.w	3400fc36 <XSPI_ConfigCmd+0x1b6>
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fb30:	e9d4 c804 	ldrd	ip, r8, [r4, #16]
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fb34:	f1b9 0f00 	cmp.w	r9, #0
3400fb38:	d053      	beq.n	3400fbe2 <XSPI_ConfigCmd+0x162>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fb3a:	e9d4 0708 	ldrd	r0, r7, [r4, #32]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fb3e:	f1be 0f00 	cmp.w	lr, #0
3400fb42:	d032      	beq.n	3400fbaa <XSPI_ConfigCmd+0x12a>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fb44:	ea4e 0303 	orr.w	r3, lr, r3
3400fb48:	ea43 0309 	orr.w	r3, r3, r9
3400fb4c:	ea43 0308 	orr.w	r3, r3, r8
3400fb50:	ea43 030c 	orr.w	r3, r3, ip
3400fb54:	433b      	orrs	r3, r7
3400fb56:	4303      	orrs	r3, r0
3400fb58:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400fb5a:	6816      	ldr	r6, [r2, #0]
3400fb5c:	4303      	orrs	r3, r0
3400fb5e:	4848      	ldr	r0, [pc, #288]	@ (3400fc80 <XSPI_ConfigCmd+0x200>)
3400fb60:	4030      	ands	r0, r6
3400fb62:	4303      	orrs	r3, r0

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fb64:	6013      	str	r3, [r2, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
3400fb66:	68a3      	ldr	r3, [r4, #8]
3400fb68:	602b      	str	r3, [r5, #0]
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
3400fb6a:	69a3      	ldr	r3, [r4, #24]
3400fb6c:	648b      	str	r3, [r1, #72]	@ 0x48
3400fb6e:	e04c      	b.n	3400fc0a <XSPI_ConfigCmd+0x18a>
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
3400fb70:	2b03      	cmp	r3, #3
    ccr_reg = &(hxspi->Instance->WPCCR);
3400fb72:	bf01      	itttt	eq
3400fb74:	f501 72a0 	addeq.w	r2, r1, #320	@ 0x140
    tcr_reg = &(hxspi->Instance->WPTCR);
3400fb78:	f501 70a4 	addeq.w	r0, r1, #328	@ 0x148
    ir_reg  = &(hxspi->Instance->WPIR);
3400fb7c:	f501 75a8 	addeq.w	r5, r1, #336	@ 0x150
    abr_reg = &(hxspi->Instance->WPABR);
3400fb80:	f501 73b0 	addeq.w	r3, r1, #352	@ 0x160
    ccr_reg = &(hxspi->Instance->CCR);
3400fb84:	bf1f      	itttt	ne
3400fb86:	f501 7280 	addne.w	r2, r1, #256	@ 0x100
    tcr_reg = &(hxspi->Instance->TCR);
3400fb8a:	f501 7084 	addne.w	r0, r1, #264	@ 0x108
    ir_reg  = &(hxspi->Instance->IR);
3400fb8e:	f501 7588 	addne.w	r5, r1, #272	@ 0x110
    abr_reg = &(hxspi->Instance->ABR);
3400fb92:	f501 7390 	addne.w	r3, r1, #288	@ 0x120
3400fb96:	e79a      	b.n	3400face <XSPI_ConfigCmd+0x4e>
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
3400fb98:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
3400fb9a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400fb9e:	d1c1      	bne.n	3400fb24 <XSPI_ConfigCmd+0xa4>
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400fba0:	f8d1 3108 	ldr.w	r3, [r1, #264]	@ 0x108
3400fba4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3400fba8:	e7ba      	b.n	3400fb20 <XSPI_ConfigCmd+0xa0>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fbaa:	ea43 0309 	orr.w	r3, r3, r9
3400fbae:	f8d2 e000 	ldr.w	lr, [r2]
3400fbb2:	ea43 0308 	orr.w	r3, r3, r8
3400fbb6:	ea43 030c 	orr.w	r3, r3, ip
3400fbba:	433b      	orrs	r3, r7
3400fbbc:	f42e 5e7c 	bic.w	lr, lr, #16128	@ 0x3f00
3400fbc0:	4303      	orrs	r3, r0
3400fbc2:	f02e 0e3f 	bic.w	lr, lr, #63	@ 0x3f
3400fbc6:	ea43 030e 	orr.w	r3, r3, lr
3400fbca:	6013      	str	r3, [r2, #0]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3400fbcc:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
3400fbce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fbd2:	d1c8      	bne.n	3400fb66 <XSPI_ConfigCmd+0xe6>
3400fbd4:	6963      	ldr	r3, [r4, #20]
3400fbd6:	2b08      	cmp	r3, #8
3400fbd8:	d1c5      	bne.n	3400fb66 <XSPI_ConfigCmd+0xe6>
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fbda:	6813      	ldr	r3, [r2, #0]
3400fbdc:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400fbe0:	e7c0      	b.n	3400fb64 <XSPI_ConfigCmd+0xe4>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3400fbe2:	6811      	ldr	r1, [r2, #0]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fbe4:	f1be 0f00 	cmp.w	lr, #0
3400fbe8:	d012      	beq.n	3400fc10 <XSPI_ConfigCmd+0x190>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3400fbea:	ea4e 0303 	orr.w	r3, lr, r3
3400fbee:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400fbf0:	ea43 0308 	orr.w	r3, r3, r8
3400fbf4:	ea43 030c 	orr.w	r3, r3, ip
3400fbf8:	f021 6170 	bic.w	r1, r1, #251658240	@ 0xf000000
3400fbfc:	4303      	orrs	r3, r0
3400fbfe:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
3400fc02:	430b      	orrs	r3, r1
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fc04:	6013      	str	r3, [r2, #0]
      *ir_reg = pCmd->Instruction;
3400fc06:	68a3      	ldr	r3, [r4, #8]
3400fc08:	602b      	str	r3, [r5, #0]
  HAL_StatusTypeDef status = HAL_OK;
3400fc0a:	2000      	movs	r0, #0
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
    }
  }

  return status;
}
3400fc0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
3400fc10:	ea43 0308 	orr.w	r3, r3, r8
3400fc14:	ea43 030c 	orr.w	r3, r3, ip
3400fc18:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
3400fc1c:	430b      	orrs	r3, r1
3400fc1e:	6013      	str	r3, [r2, #0]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3400fc20:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
3400fc22:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fc26:	d1ee      	bne.n	3400fc06 <XSPI_ConfigCmd+0x186>
3400fc28:	6963      	ldr	r3, [r4, #20]
3400fc2a:	2b08      	cmp	r3, #8
3400fc2c:	d1eb      	bne.n	3400fc06 <XSPI_ConfigCmd+0x186>
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fc2e:	6813      	ldr	r3, [r2, #0]
3400fc30:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400fc34:	e7e6      	b.n	3400fc04 <XSPI_ConfigCmd+0x184>
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fc36:	f1b9 0f00 	cmp.w	r9, #0
3400fc3a:	d01b      	beq.n	3400fc74 <XSPI_ConfigCmd+0x1f4>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fc3c:	e9d4 6008 	ldrd	r6, r0, [r4, #32]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fc40:	f1be 0f00 	cmp.w	lr, #0
3400fc44:	d00d      	beq.n	3400fc62 <XSPI_ConfigCmd+0x1e2>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
3400fc46:	ea4e 0309 	orr.w	r3, lr, r9
3400fc4a:	6815      	ldr	r5, [r2, #0]
3400fc4c:	4303      	orrs	r3, r0
3400fc4e:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400fc50:	4333      	orrs	r3, r6
3400fc52:	4303      	orrs	r3, r0
3400fc54:	f025 6070 	bic.w	r0, r5, #251658240	@ 0xf000000
3400fc58:	f420 507c 	bic.w	r0, r0, #16128	@ 0x3f00
3400fc5c:	4303      	orrs	r3, r0
3400fc5e:	6013      	str	r3, [r2, #0]
3400fc60:	e783      	b.n	3400fb6a <XSPI_ConfigCmd+0xea>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
3400fc62:	6813      	ldr	r3, [r2, #0]
3400fc64:	ea40 0009 	orr.w	r0, r0, r9
3400fc68:	4330      	orrs	r0, r6
3400fc6a:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400fc6e:	4318      	orrs	r0, r3
3400fc70:	6010      	str	r0, [r2, #0]
3400fc72:	e77a      	b.n	3400fb6a <XSPI_ConfigCmd+0xea>
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400fc74:	2308      	movs	r3, #8
      status = HAL_ERROR;
3400fc76:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400fc78:	65f3      	str	r3, [r6, #92]	@ 0x5c
3400fc7a:	e7c7      	b.n	3400fc0c <XSPI_ConfigCmd+0x18c>
3400fc7c:	3401c818 	.word	0x3401c818
3400fc80:	f0ffc0c0 	.word	0xf0ffc0c0

3400fc84 <XSPI_WaitFlagStateUntilTimeout>:
{
3400fc84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400fc88:	4604      	mov	r4, r0
3400fc8a:	460e      	mov	r6, r1
3400fc8c:	4615      	mov	r5, r2
3400fc8e:	461f      	mov	r7, r3
3400fc90:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3400fc94:	6822      	ldr	r2, [r4, #0]
3400fc96:	6a13      	ldr	r3, [r2, #32]
3400fc98:	4233      	tst	r3, r6
3400fc9a:	bf14      	ite	ne
3400fc9c:	2301      	movne	r3, #1
3400fc9e:	2300      	moveq	r3, #0
3400fca0:	42ab      	cmp	r3, r5
3400fca2:	d101      	bne.n	3400fca8 <XSPI_WaitFlagStateUntilTimeout+0x24>
  return HAL_OK;
3400fca4:	2000      	movs	r0, #0
3400fca6:	e00e      	b.n	3400fcc6 <XSPI_WaitFlagStateUntilTimeout+0x42>
    if (Timeout != HAL_MAX_DELAY)
3400fca8:	f1b8 3fff 	cmp.w	r8, #4294967295
3400fcac:	d0f3      	beq.n	3400fc96 <XSPI_WaitFlagStateUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400fcae:	f7f4 fdad 	bl	3400480c <HAL_GetTick>
3400fcb2:	1bc0      	subs	r0, r0, r7
3400fcb4:	4540      	cmp	r0, r8
3400fcb6:	d908      	bls.n	3400fcca <XSPI_WaitFlagStateUntilTimeout+0x46>
        hxspi->State     = HAL_XSPI_STATE_READY;
3400fcb8:	2302      	movs	r3, #2
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400fcba:	2003      	movs	r0, #3
        hxspi->State     = HAL_XSPI_STATE_READY;
3400fcbc:	65a3      	str	r3, [r4, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400fcbe:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
3400fcc0:	f043 0301 	orr.w	r3, r3, #1
3400fcc4:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
3400fcc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400fcca:	f1b8 0f00 	cmp.w	r8, #0
3400fcce:	d1e1      	bne.n	3400fc94 <XSPI_WaitFlagStateUntilTimeout+0x10>
3400fcd0:	e7f2      	b.n	3400fcb8 <XSPI_WaitFlagStateUntilTimeout+0x34>

3400fcd2 <HAL_XSPI_MspInit>:
}
3400fcd2:	4770      	bx	lr

3400fcd4 <HAL_XSPI_Init>:
{
3400fcd4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400fcd6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
3400fcd8:	f7f4 fd98 	bl	3400480c <HAL_GetTick>
3400fcdc:	4606      	mov	r6, r0
  if (hxspi == NULL)
3400fcde:	2c00      	cmp	r4, #0
3400fce0:	f000 812a 	beq.w	3400ff38 <HAL_XSPI_Init+0x264>
    assert_param(IS_XSPI_MEMORY_MODE(hxspi->Init.MemoryMode));
3400fce4:	68a3      	ldr	r3, [r4, #8]
3400fce6:	f033 0340 	bics.w	r3, r3, #64	@ 0x40
3400fcea:	d004      	beq.n	3400fcf6 <HAL_XSPI_Init+0x22>
3400fcec:	f240 1161 	movw	r1, #353	@ 0x161
3400fcf0:	4892      	ldr	r0, [pc, #584]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fcf2:	f7f2 fc1f 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_MEMORY_TYPE(hxspi->Init.MemoryType));
3400fcf6:	68e3      	ldr	r3, [r4, #12]
3400fcf8:	f033 7240 	bics.w	r2, r3, #50331648	@ 0x3000000
3400fcfc:	d009      	beq.n	3400fd12 <HAL_XSPI_Init+0x3e>
3400fcfe:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
3400fd02:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3400fd06:	d004      	beq.n	3400fd12 <HAL_XSPI_Init+0x3e>
3400fd08:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3400fd0c:	488b      	ldr	r0, [pc, #556]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd0e:	f7f2 fc11 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_MEMORY_SIZE(hxspi->Init.MemorySize));
3400fd12:	6923      	ldr	r3, [r4, #16]
3400fd14:	2b1f      	cmp	r3, #31
3400fd16:	d904      	bls.n	3400fd22 <HAL_XSPI_Init+0x4e>
3400fd18:	f240 1163 	movw	r1, #355	@ 0x163
3400fd1c:	4887      	ldr	r0, [pc, #540]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd1e:	f7f2 fc09 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_CS_HIGH_TIME_CYCLE(hxspi->Init.ChipSelectHighTimeCycle));
3400fd22:	6963      	ldr	r3, [r4, #20]
3400fd24:	3b01      	subs	r3, #1
3400fd26:	2b3f      	cmp	r3, #63	@ 0x3f
3400fd28:	d904      	bls.n	3400fd34 <HAL_XSPI_Init+0x60>
3400fd2a:	f44f 71b2 	mov.w	r1, #356	@ 0x164
3400fd2e:	4883      	ldr	r0, [pc, #524]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd30:	f7f2 fc00 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_FREE_RUN_CLK(hxspi->Init.FreeRunningClock));
3400fd34:	69a3      	ldr	r3, [r4, #24]
3400fd36:	f033 0302 	bics.w	r3, r3, #2
3400fd3a:	d004      	beq.n	3400fd46 <HAL_XSPI_Init+0x72>
3400fd3c:	f240 1165 	movw	r1, #357	@ 0x165
3400fd40:	487e      	ldr	r0, [pc, #504]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd42:	f7f2 fbf7 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_CLOCK_MODE(hxspi->Init.ClockMode));
3400fd46:	69e3      	ldr	r3, [r4, #28]
3400fd48:	2b01      	cmp	r3, #1
3400fd4a:	d904      	bls.n	3400fd56 <HAL_XSPI_Init+0x82>
3400fd4c:	f44f 71b3 	mov.w	r1, #358	@ 0x166
3400fd50:	487a      	ldr	r0, [pc, #488]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd52:	f7f2 fbef 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_WRAP_SIZE(hxspi->Init.WrapSize));
3400fd56:	6a23      	ldr	r3, [r4, #32]
3400fd58:	f433 3200 	bics.w	r2, r3, #131072	@ 0x20000
3400fd5c:	d00c      	beq.n	3400fd78 <HAL_XSPI_Init+0xa4>
3400fd5e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400fd62:	d009      	beq.n	3400fd78 <HAL_XSPI_Init+0xa4>
3400fd64:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400fd68:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400fd6c:	d004      	beq.n	3400fd78 <HAL_XSPI_Init+0xa4>
3400fd6e:	f240 1167 	movw	r1, #359	@ 0x167
3400fd72:	4872      	ldr	r0, [pc, #456]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd74:	f7f2 fbde 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_CLK_PRESCALER(hxspi->Init.ClockPrescaler));
3400fd78:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400fd7a:	2bff      	cmp	r3, #255	@ 0xff
3400fd7c:	d904      	bls.n	3400fd88 <HAL_XSPI_Init+0xb4>
3400fd7e:	f44f 71b4 	mov.w	r1, #360	@ 0x168
3400fd82:	486e      	ldr	r0, [pc, #440]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd84:	f7f2 fbd6 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_SAMPLE_SHIFTING(hxspi->Init.SampleShifting));
3400fd88:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400fd8a:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
3400fd8e:	d004      	beq.n	3400fd9a <HAL_XSPI_Init+0xc6>
3400fd90:	f240 1169 	movw	r1, #361	@ 0x169
3400fd94:	4869      	ldr	r0, [pc, #420]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fd96:	f7f2 fbcd 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_DHQC(hxspi->Init.DelayHoldQuarterCycle));
3400fd9a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400fd9c:	f033 5380 	bics.w	r3, r3, #268435456	@ 0x10000000
3400fda0:	d004      	beq.n	3400fdac <HAL_XSPI_Init+0xd8>
3400fda2:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
3400fda6:	4865      	ldr	r0, [pc, #404]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fda8:	f7f2 fbc4 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_CS_BOUND(hxspi->Init.ChipSelectBoundary));
3400fdac:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400fdae:	2b1f      	cmp	r3, #31
3400fdb0:	d904      	bls.n	3400fdbc <HAL_XSPI_Init+0xe8>
3400fdb2:	f240 116b 	movw	r1, #363	@ 0x16b
3400fdb6:	4861      	ldr	r0, [pc, #388]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fdb8:	f7f2 fbbc 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
3400fdbc:	6863      	ldr	r3, [r4, #4]
3400fdbe:	3b01      	subs	r3, #1
3400fdc0:	2b3f      	cmp	r3, #63	@ 0x3f
3400fdc2:	d904      	bls.n	3400fdce <HAL_XSPI_Init+0xfa>
3400fdc4:	f44f 71b6 	mov.w	r1, #364	@ 0x16c
3400fdc8:	485c      	ldr	r0, [pc, #368]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fdca:	f7f2 fbb3 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
3400fdce:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400fdd0:	2bff      	cmp	r3, #255	@ 0xff
3400fdd2:	d904      	bls.n	3400fdde <HAL_XSPI_Init+0x10a>
3400fdd4:	f240 116d 	movw	r1, #365	@ 0x16d
3400fdd8:	4858      	ldr	r0, [pc, #352]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fdda:	f7f2 fbab 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
3400fdde:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400fde0:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
3400fde4:	d004      	beq.n	3400fdf0 <HAL_XSPI_Init+0x11c>
3400fde6:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3400fdea:	4854      	ldr	r0, [pc, #336]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fdec:	f7f2 fba2 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
3400fdf0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400fdf2:	f433 1300 	bics.w	r3, r3, #2097152	@ 0x200000
3400fdf6:	d004      	beq.n	3400fe02 <HAL_XSPI_Init+0x12e>
3400fdf8:	f240 116f 	movw	r1, #367	@ 0x16f
3400fdfc:	484f      	ldr	r0, [pc, #316]	@ (3400ff3c <HAL_XSPI_Init+0x268>)
3400fdfe:	f7f2 fb99 	bl	34002534 <assert_failed>
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3400fe02:	2300      	movs	r3, #0
3400fe04:	65e3      	str	r3, [r4, #92]	@ 0x5c
    if (hxspi->State == HAL_XSPI_STATE_RESET)
3400fe06:	6da7      	ldr	r7, [r4, #88]	@ 0x58
3400fe08:	2f00      	cmp	r7, #0
3400fe0a:	f040 8087 	bne.w	3400ff1c <HAL_XSPI_Init+0x248>
      HAL_XSPI_MspInit(hxspi);
3400fe0e:	4620      	mov	r0, r4
3400fe10:	f7ff ff5f 	bl	3400fcd2 <HAL_XSPI_MspInit>
  hxspi->Timeout = Timeout;
3400fe14:	f241 3288 	movw	r2, #5000	@ 0x1388
      MODIFY_REG(hxspi->Instance->DCR1,
3400fe18:	69e3      	ldr	r3, [r4, #28]
3400fe1a:	68e5      	ldr	r5, [r4, #12]
3400fe1c:	6821      	ldr	r1, [r4, #0]
3400fe1e:	431d      	orrs	r5, r3
3400fe20:	6923      	ldr	r3, [r4, #16]
3400fe22:	6888      	ldr	r0, [r1, #8]
3400fe24:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
3400fe28:	4b45      	ldr	r3, [pc, #276]	@ (3400ff40 <HAL_XSPI_Init+0x26c>)
  hxspi->Timeout = Timeout;
3400fe2a:	6622      	str	r2, [r4, #96]	@ 0x60
      MODIFY_REG(hxspi->Instance->DCR1,
3400fe2c:	4003      	ands	r3, r0
3400fe2e:	431d      	orrs	r5, r3
3400fe30:	6963      	ldr	r3, [r4, #20]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400fe32:	6a20      	ldr	r0, [r4, #32]
      MODIFY_REG(hxspi->Instance->DCR1,
3400fe34:	3b01      	subs	r3, #1
3400fe36:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
3400fe3a:	608d      	str	r5, [r1, #8]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400fe3c:	68cb      	ldr	r3, [r1, #12]
3400fe3e:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400fe42:	4303      	orrs	r3, r0
3400fe44:	60cb      	str	r3, [r1, #12]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3400fe46:	690b      	ldr	r3, [r1, #16]
3400fe48:	6b20      	ldr	r0, [r4, #48]	@ 0x30
3400fe4a:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
3400fe4e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400fe52:	610b      	str	r3, [r1, #16]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3400fe54:	690b      	ldr	r3, [r1, #16]
3400fe56:	6b60      	ldr	r0, [r4, #52]	@ 0x34
3400fe58:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400fe5c:	4303      	orrs	r3, r0
3400fe5e:	610b      	str	r3, [r1, #16]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400fe60:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400fe62:	6860      	ldr	r0, [r4, #4]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400fe64:	614b      	str	r3, [r1, #20]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400fe66:	680b      	ldr	r3, [r1, #0]
3400fe68:	3801      	subs	r0, #1
3400fe6a:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400fe6e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
3400fe72:	600b      	str	r3, [r1, #0]
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400fe74:	4620      	mov	r0, r4
3400fe76:	9200      	str	r2, [sp, #0]
3400fe78:	4633      	mov	r3, r6
3400fe7a:	463a      	mov	r2, r7
3400fe7c:	2120      	movs	r1, #32
3400fe7e:	f7ff ff01 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
3400fe82:	2800      	cmp	r0, #0
3400fe84:	d156      	bne.n	3400ff34 <HAL_XSPI_Init+0x260>
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3400fe86:	6823      	ldr	r3, [r4, #0]
3400fe88:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400fe8a:	68da      	ldr	r2, [r3, #12]
3400fe8c:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
3400fe90:	430a      	orrs	r2, r1
3400fe92:	60da      	str	r2, [r3, #12]
        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3400fe94:	4a2b      	ldr	r2, [pc, #172]	@ (3400ff44 <HAL_XSPI_Init+0x270>)
3400fe96:	4293      	cmp	r3, r2
3400fe98:	d042      	beq.n	3400ff20 <HAL_XSPI_Init+0x24c>
3400fe9a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fe9e:	4293      	cmp	r3, r2
3400fea0:	d03e      	beq.n	3400ff20 <HAL_XSPI_Init+0x24c>
3400fea2:	4a29      	ldr	r2, [pc, #164]	@ (3400ff48 <HAL_XSPI_Init+0x274>)
3400fea4:	4293      	cmp	r3, r2
3400fea6:	d03b      	beq.n	3400ff20 <HAL_XSPI_Init+0x24c>
3400fea8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400feac:	4293      	cmp	r3, r2
3400feae:	d037      	beq.n	3400ff20 <HAL_XSPI_Init+0x24c>
3400feb0:	4a26      	ldr	r2, [pc, #152]	@ (3400ff4c <HAL_XSPI_Init+0x278>)
3400feb2:	4293      	cmp	r3, r2
3400feb4:	d034      	beq.n	3400ff20 <HAL_XSPI_Init+0x24c>
3400feb6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400feba:	4293      	cmp	r3, r2
3400febc:	d030      	beq.n	3400ff20 <HAL_XSPI_Init+0x24c>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
3400febe:	6823      	ldr	r3, [r4, #0]
3400fec0:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3400fec2:	6819      	ldr	r1, [r3, #0]
3400fec4:	68a2      	ldr	r2, [r4, #8]
3400fec6:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
3400feca:	4302      	orrs	r2, r0
3400fecc:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
3400fed0:	430a      	orrs	r2, r1
3400fed2:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT | XSPI_TCR_DHQC),
3400fed4:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
3400fed8:	e9d4 200a 	ldrd	r2, r0, [r4, #40]	@ 0x28
3400fedc:	f021 41a0 	bic.w	r1, r1, #1342177280	@ 0x50000000
3400fee0:	4302      	orrs	r2, r0
3400fee2:	430a      	orrs	r2, r1
3400fee4:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
        HAL_XSPI_ENABLE(hxspi);
3400fee8:	681a      	ldr	r2, [r3, #0]
3400feea:	f042 0201 	orr.w	r2, r2, #1
3400feee:	601a      	str	r2, [r3, #0]
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
3400fef0:	69a2      	ldr	r2, [r4, #24]
3400fef2:	2a02      	cmp	r2, #2
3400fef4:	d103      	bne.n	3400fefe <HAL_XSPI_Init+0x22a>
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3400fef6:	689a      	ldr	r2, [r3, #8]
3400fef8:	f042 0202 	orr.w	r2, r2, #2
3400fefc:	609a      	str	r2, [r3, #8]
        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3400fefe:	6c22      	ldr	r2, [r4, #64]	@ 0x40
3400ff00:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
3400ff04:	bf02      	ittt	eq
3400ff06:	689a      	ldreq	r2, [r3, #8]
3400ff08:	f442 1200 	orreq.w	r2, r2, #2097152	@ 0x200000
3400ff0c:	609a      	streq	r2, [r3, #8]
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3400ff0e:	68e3      	ldr	r3, [r4, #12]
3400ff10:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3400ff14:	bf0c      	ite	eq
3400ff16:	2301      	moveq	r3, #1
          hxspi->State = HAL_XSPI_STATE_READY;
3400ff18:	2302      	movne	r3, #2
3400ff1a:	65a3      	str	r3, [r4, #88]	@ 0x58
  HAL_StatusTypeDef status = HAL_OK;
3400ff1c:	2000      	movs	r0, #0
3400ff1e:	e009      	b.n	3400ff34 <HAL_XSPI_Init+0x260>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400ff20:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400ff22:	2200      	movs	r2, #0
3400ff24:	9300      	str	r3, [sp, #0]
3400ff26:	2120      	movs	r1, #32
3400ff28:	4633      	mov	r3, r6
3400ff2a:	4620      	mov	r0, r4
3400ff2c:	f7ff feaa 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
          if (status != HAL_OK)
3400ff30:	2800      	cmp	r0, #0
3400ff32:	d0c4      	beq.n	3400febe <HAL_XSPI_Init+0x1ea>
}
3400ff34:	b003      	add	sp, #12
3400ff36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_ERROR;
3400ff38:	2001      	movs	r0, #1
3400ff3a:	e7fb      	b.n	3400ff34 <HAL_XSPI_Init+0x260>
3400ff3c:	3401c818 	.word	0x3401c818
3400ff40:	f8e0c0fc 	.word	0xf8e0c0fc
3400ff44:	58025000 	.word	0x58025000
3400ff48:	5802a000 	.word	0x5802a000
3400ff4c:	5802d000 	.word	0x5802d000

3400ff50 <HAL_XSPI_Command>:
{
3400ff50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400ff52:	460c      	mov	r4, r1
3400ff54:	4605      	mov	r5, r0
3400ff56:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
3400ff58:	f7f4 fc58 	bl	3400480c <HAL_GetTick>
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
3400ff5c:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
3400ff5e:	4606      	mov	r6, r0
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
3400ff60:	2b03      	cmp	r3, #3
3400ff62:	d904      	bls.n	3400ff6e <HAL_XSPI_Command+0x1e>
3400ff64:	f240 313e 	movw	r1, #830	@ 0x33e
3400ff68:	4884      	ldr	r0, [pc, #528]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400ff6a:	f7f2 fae3 	bl	34002534 <assert_failed>
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400ff6e:	68ab      	ldr	r3, [r5, #8]
3400ff70:	b943      	cbnz	r3, 3400ff84 <HAL_XSPI_Command+0x34>
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3400ff72:	6863      	ldr	r3, [r4, #4]
3400ff74:	f033 4340 	bics.w	r3, r3, #3221225472	@ 0xc0000000
3400ff78:	d004      	beq.n	3400ff84 <HAL_XSPI_Command+0x34>
3400ff7a:	f240 3141 	movw	r1, #833	@ 0x341
3400ff7e:	487f      	ldr	r0, [pc, #508]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400ff80:	f7f2 fad8 	bl	34002534 <assert_failed>
  assert_param(IS_XSPI_INSTRUCTION_MODE(pCmd->InstructionMode));
3400ff84:	68e3      	ldr	r3, [r4, #12]
3400ff86:	2b04      	cmp	r3, #4
3400ff88:	d904      	bls.n	3400ff94 <HAL_XSPI_Command+0x44>
3400ff8a:	f44f 7151 	mov.w	r1, #836	@ 0x344
3400ff8e:	487b      	ldr	r0, [pc, #492]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400ff90:	f7f2 fad0 	bl	34002534 <assert_failed>
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400ff94:	68e3      	ldr	r3, [r4, #12]
3400ff96:	b18b      	cbz	r3, 3400ffbc <HAL_XSPI_Command+0x6c>
    assert_param(IS_XSPI_INSTRUCTION_WIDTH(pCmd->InstructionWidth));
3400ff98:	6923      	ldr	r3, [r4, #16]
3400ff9a:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400ff9e:	d004      	beq.n	3400ffaa <HAL_XSPI_Command+0x5a>
3400ffa0:	f240 3147 	movw	r1, #839	@ 0x347
3400ffa4:	4875      	ldr	r0, [pc, #468]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400ffa6:	f7f2 fac5 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_INSTRUCTION_DTR_MODE(pCmd->InstructionDTRMode));
3400ffaa:	6963      	ldr	r3, [r4, #20]
3400ffac:	f033 0308 	bics.w	r3, r3, #8
3400ffb0:	d004      	beq.n	3400ffbc <HAL_XSPI_Command+0x6c>
3400ffb2:	f44f 7152 	mov.w	r1, #840	@ 0x348
3400ffb6:	4871      	ldr	r0, [pc, #452]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400ffb8:	f7f2 fabc 	bl	34002534 <assert_failed>
  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
3400ffbc:	69e3      	ldr	r3, [r4, #28]
3400ffbe:	b303      	cbz	r3, 34010002 <HAL_XSPI_Command+0xb2>
3400ffc0:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400ffc4:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3400ffc8:	d10d      	bne.n	3400ffe6 <HAL_XSPI_Command+0x96>
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
3400ffca:	6a23      	ldr	r3, [r4, #32]
3400ffcc:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400ffd0:	d12c      	bne.n	3401002c <HAL_XSPI_Command+0xdc>
    assert_param(IS_XSPI_ADDRESS_DTR_MODE(pCmd->AddressDTRMode));
3400ffd2:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400ffd4:	f433 6300 	bics.w	r3, r3, #2048	@ 0x800
3400ffd8:	d013      	beq.n	34010002 <HAL_XSPI_Command+0xb2>
3400ffda:	f240 314f 	movw	r1, #847	@ 0x34f
3400ffde:	4867      	ldr	r0, [pc, #412]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400ffe0:	f7f2 faa8 	bl	34002534 <assert_failed>
3400ffe4:	e00d      	b.n	34010002 <HAL_XSPI_Command+0xb2>
  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
3400ffe6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400ffea:	d0ee      	beq.n	3400ffca <HAL_XSPI_Command+0x7a>
3400ffec:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400fff0:	d0eb      	beq.n	3400ffca <HAL_XSPI_Command+0x7a>
3400fff2:	f240 314b 	movw	r1, #843	@ 0x34b
3400fff6:	4861      	ldr	r0, [pc, #388]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3400fff8:	f7f2 fa9c 	bl	34002534 <assert_failed>
  if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fffc:	69e3      	ldr	r3, [r4, #28]
3400fffe:	2b00      	cmp	r3, #0
34010000:	d1e3      	bne.n	3400ffca <HAL_XSPI_Command+0x7a>
  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
34010002:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34010004:	b333      	cbz	r3, 34010054 <HAL_XSPI_Command+0x104>
34010006:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
3401000a:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
3401000e:	d113      	bne.n	34010038 <HAL_XSPI_Command+0xe8>
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
34010010:	6b23      	ldr	r3, [r4, #48]	@ 0x30
34010012:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
34010016:	d13d      	bne.n	34010094 <HAL_XSPI_Command+0x144>
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
34010018:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3401001a:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
3401001e:	d019      	beq.n	34010054 <HAL_XSPI_Command+0x104>
34010020:	f240 3156 	movw	r1, #854	@ 0x356
34010024:	4855      	ldr	r0, [pc, #340]	@ (3401017c <HAL_XSPI_Command+0x22c>)
34010026:	f7f2 fa85 	bl	34002534 <assert_failed>
3401002a:	e013      	b.n	34010054 <HAL_XSPI_Command+0x104>
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
3401002c:	f240 314e 	movw	r1, #846	@ 0x34e
34010030:	4852      	ldr	r0, [pc, #328]	@ (3401017c <HAL_XSPI_Command+0x22c>)
34010032:	f7f2 fa7f 	bl	34002534 <assert_failed>
34010036:	e7cc      	b.n	3400ffd2 <HAL_XSPI_Command+0x82>
  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
34010038:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3401003c:	d0e8      	beq.n	34010010 <HAL_XSPI_Command+0xc0>
3401003e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34010042:	d0e5      	beq.n	34010010 <HAL_XSPI_Command+0xc0>
34010044:	f240 3152 	movw	r1, #850	@ 0x352
34010048:	484c      	ldr	r0, [pc, #304]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3401004a:	f7f2 fa73 	bl	34002534 <assert_failed>
  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3401004e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34010050:	2b00      	cmp	r3, #0
34010052:	d1dd      	bne.n	34010010 <HAL_XSPI_Command+0xc0>
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
34010054:	68eb      	ldr	r3, [r5, #12]
34010056:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
34010058:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401005c:	d120      	bne.n	340100a0 <HAL_XSPI_Command+0x150>
3401005e:	b389      	cbz	r1, 340100c4 <HAL_XSPI_Command+0x174>
34010060:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
34010064:	f1b1 6f80 	cmp.w	r1, #67108864	@ 0x4000000
34010068:	d124      	bne.n	340100b4 <HAL_XSPI_Command+0x164>
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3401006a:	6823      	ldr	r3, [r4, #0]
3401006c:	2b00      	cmp	r3, #0
3401006e:	d03d      	beq.n	340100ec <HAL_XSPI_Command+0x19c>
    assert_param(IS_XSPI_DATA_DTR_MODE(pCmd->DataDTRMode));
34010070:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34010072:	f033 6300 	bics.w	r3, r3, #134217728	@ 0x8000000
34010076:	d004      	beq.n	34010082 <HAL_XSPI_Command+0x132>
34010078:	f240 3161 	movw	r1, #865	@ 0x361
3401007c:	483f      	ldr	r0, [pc, #252]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3401007e:	f7f2 fa59 	bl	34002534 <assert_failed>
    assert_param(IS_XSPI_DUMMY_CYCLES(pCmd->DummyCycles));
34010082:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010084:	2b1f      	cmp	r3, #31
34010086:	d91d      	bls.n	340100c4 <HAL_XSPI_Command+0x174>
34010088:	f240 3162 	movw	r1, #866	@ 0x362
3401008c:	483b      	ldr	r0, [pc, #236]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3401008e:	f7f2 fa51 	bl	34002534 <assert_failed>
34010092:	e017      	b.n	340100c4 <HAL_XSPI_Command+0x174>
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
34010094:	f240 3155 	movw	r1, #853	@ 0x355
34010098:	4838      	ldr	r0, [pc, #224]	@ (3401017c <HAL_XSPI_Command+0x22c>)
3401009a:	f7f2 fa4b 	bl	34002534 <assert_failed>
3401009e:	e7bb      	b.n	34010018 <HAL_XSPI_Command+0xc8>
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
340100a0:	b181      	cbz	r1, 340100c4 <HAL_XSPI_Command+0x174>
340100a2:	f021 7300 	bic.w	r3, r1, #33554432	@ 0x2000000
340100a6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340100aa:	d0de      	beq.n	3401006a <HAL_XSPI_Command+0x11a>
340100ac:	f1b1 7f00 	cmp.w	r1, #33554432	@ 0x2000000
340100b0:	d1d6      	bne.n	34010060 <HAL_XSPI_Command+0x110>
340100b2:	e7da      	b.n	3401006a <HAL_XSPI_Command+0x11a>
340100b4:	f240 3159 	movw	r1, #857	@ 0x359
340100b8:	4830      	ldr	r0, [pc, #192]	@ (3401017c <HAL_XSPI_Command+0x22c>)
340100ba:	f7f2 fa3b 	bl	34002534 <assert_failed>
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
340100be:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
340100c0:	2b00      	cmp	r3, #0
340100c2:	d1d2      	bne.n	3401006a <HAL_XSPI_Command+0x11a>
  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));
340100c4:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
340100c6:	f033 5300 	bics.w	r3, r3, #536870912	@ 0x20000000
340100ca:	d004      	beq.n	340100d6 <HAL_XSPI_Command+0x186>
340100cc:	f240 3165 	movw	r1, #869	@ 0x365
340100d0:	482a      	ldr	r0, [pc, #168]	@ (3401017c <HAL_XSPI_Command+0x22c>)
340100d2:	f7f2 fa2f 	bl	34002534 <assert_failed>
  state = hxspi->State;
340100d6:	6dab      	ldr	r3, [r5, #88]	@ 0x58
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
340100d8:	2b02      	cmp	r3, #2
340100da:	d110      	bne.n	340100fe <HAL_XSPI_Command+0x1ae>
340100dc:	68eb      	ldr	r3, [r5, #12]
340100de:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
340100e2:	d112      	bne.n	3401010a <HAL_XSPI_Command+0x1ba>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340100e4:	2310      	movs	r3, #16
    status = HAL_ERROR;
340100e6:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340100e8:	65eb      	str	r3, [r5, #92]	@ 0x5c
340100ea:	e028      	b.n	3401013e <HAL_XSPI_Command+0x1ee>
      assert_param(IS_XSPI_DATA_LENGTH(pCmd->DataLength));
340100ec:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
340100ee:	2b00      	cmp	r3, #0
340100f0:	d1be      	bne.n	34010070 <HAL_XSPI_Command+0x120>
340100f2:	f240 315f 	movw	r1, #863	@ 0x35f
340100f6:	4821      	ldr	r0, [pc, #132]	@ (3401017c <HAL_XSPI_Command+0x22c>)
340100f8:	f7f2 fa1c 	bl	34002534 <assert_failed>
340100fc:	e7b8      	b.n	34010070 <HAL_XSPI_Command+0x120>
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
340100fe:	2b14      	cmp	r3, #20
34010100:	d11f      	bne.n	34010142 <HAL_XSPI_Command+0x1f2>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
34010102:	6823      	ldr	r3, [r4, #0]
34010104:	3b02      	subs	r3, #2
34010106:	2b01      	cmp	r3, #1
34010108:	d8ec      	bhi.n	340100e4 <HAL_XSPI_Command+0x194>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3401010a:	4633      	mov	r3, r6
3401010c:	2200      	movs	r2, #0
3401010e:	2120      	movs	r1, #32
34010110:	4628      	mov	r0, r5
34010112:	9700      	str	r7, [sp, #0]
34010114:	f7ff fdb6 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
34010118:	bb70      	cbnz	r0, 34010178 <HAL_XSPI_Command+0x228>
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3401011a:	65e8      	str	r0, [r5, #92]	@ 0x5c
      status = XSPI_ConfigCmd(hxspi, pCmd);
3401011c:	4621      	mov	r1, r4
3401011e:	4628      	mov	r0, r5
34010120:	f7ff fcae 	bl	3400fa80 <XSPI_ConfigCmd>
      if (status == HAL_OK)
34010124:	b958      	cbnz	r0, 3401013e <HAL_XSPI_Command+0x1ee>
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
34010126:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
34010128:	b99b      	cbnz	r3, 34010152 <HAL_XSPI_Command+0x202>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3401012a:	4633      	mov	r3, r6
3401012c:	2201      	movs	r2, #1
3401012e:	2102      	movs	r1, #2
34010130:	4628      	mov	r0, r5
34010132:	9700      	str	r7, [sp, #0]
34010134:	f7ff fda6 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34010138:	2202      	movs	r2, #2
3401013a:	682b      	ldr	r3, [r5, #0]
3401013c:	625a      	str	r2, [r3, #36]	@ 0x24
}
3401013e:	b003      	add	sp, #12
34010140:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34010142:	2b24      	cmp	r3, #36	@ 0x24
34010144:	d1ce      	bne.n	340100e4 <HAL_XSPI_Command+0x194>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
34010146:	6823      	ldr	r3, [r4, #0]
34010148:	f023 0302 	bic.w	r3, r3, #2
3401014c:	2b01      	cmp	r3, #1
3401014e:	d1c9      	bne.n	340100e4 <HAL_XSPI_Command+0x194>
34010150:	e7db      	b.n	3401010a <HAL_XSPI_Command+0x1ba>
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34010152:	6823      	ldr	r3, [r4, #0]
34010154:	b90b      	cbnz	r3, 3401015a <HAL_XSPI_Command+0x20a>
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
34010156:	2304      	movs	r3, #4
34010158:	e005      	b.n	34010166 <HAL_XSPI_Command+0x216>
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
3401015a:	2b01      	cmp	r3, #1
3401015c:	d105      	bne.n	3401016a <HAL_XSPI_Command+0x21a>
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
3401015e:	6dab      	ldr	r3, [r5, #88]	@ 0x58
34010160:	2b24      	cmp	r3, #36	@ 0x24
34010162:	d0f8      	beq.n	34010156 <HAL_XSPI_Command+0x206>
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
34010164:	2314      	movs	r3, #20
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
34010166:	65ab      	str	r3, [r5, #88]	@ 0x58
34010168:	e7e9      	b.n	3401013e <HAL_XSPI_Command+0x1ee>
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3401016a:	2b02      	cmp	r3, #2
3401016c:	d1e7      	bne.n	3401013e <HAL_XSPI_Command+0x1ee>
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
3401016e:	6dab      	ldr	r3, [r5, #88]	@ 0x58
34010170:	2b14      	cmp	r3, #20
34010172:	d0f0      	beq.n	34010156 <HAL_XSPI_Command+0x206>
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
34010174:	2324      	movs	r3, #36	@ 0x24
34010176:	e7f6      	b.n	34010166 <HAL_XSPI_Command+0x216>
      status = HAL_BUSY;
34010178:	2002      	movs	r0, #2
3401017a:	e7e0      	b.n	3401013e <HAL_XSPI_Command+0x1ee>
3401017c:	3401c818 	.word	0x3401c818

34010180 <HAL_XSPI_Transmit>:
{
34010180:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
34010184:	4604      	mov	r4, r0
34010186:	4688      	mov	r8, r1
34010188:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
3401018a:	f7f4 fb3f 	bl	3400480c <HAL_GetTick>
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
3401018e:	6827      	ldr	r7, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
34010190:	4605      	mov	r5, r0
  if (pData == NULL)
34010192:	f1b8 0f00 	cmp.w	r8, #0
34010196:	d103      	bne.n	340101a0 <HAL_XSPI_Transmit+0x20>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34010198:	2308      	movs	r3, #8
    status = HAL_ERROR;
3401019a:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401019c:	65e3      	str	r3, [r4, #92]	@ 0x5c
3401019e:	e02e      	b.n	340101fe <HAL_XSPI_Transmit+0x7e>
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
340101a0:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340101a2:	2b04      	cmp	r3, #4
340101a4:	d12e      	bne.n	34010204 <HAL_XSPI_Transmit+0x84>
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
340101a6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
      hxspi->pBuffPtr  = (uint8_t *)pData;
340101a8:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
340101ac:	3301      	adds	r3, #1
340101ae:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
340101b0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340101b2:	64a3      	str	r3, [r4, #72]	@ 0x48
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
340101b4:	683b      	ldr	r3, [r7, #0]
340101b6:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
340101ba:	603b      	str	r3, [r7, #0]
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
340101bc:	462b      	mov	r3, r5
340101be:	2201      	movs	r2, #1
340101c0:	2104      	movs	r1, #4
340101c2:	4620      	mov	r0, r4
340101c4:	9600      	str	r6, [sp, #0]
340101c6:	f7ff fd5d 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
340101ca:	b9c0      	cbnz	r0, 340101fe <HAL_XSPI_Transmit+0x7e>
        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
340101cc:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340101ce:	781b      	ldrb	r3, [r3, #0]
340101d0:	f887 3050 	strb.w	r3, [r7, #80]	@ 0x50
        hxspi->pBuffPtr++;
340101d4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340101d6:	3301      	adds	r3, #1
340101d8:	6463      	str	r3, [r4, #68]	@ 0x44
        hxspi->XferCount--;
340101da:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340101dc:	3b01      	subs	r3, #1
340101de:	64e3      	str	r3, [r4, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
340101e0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340101e2:	2b00      	cmp	r3, #0
340101e4:	d1ea      	bne.n	340101bc <HAL_XSPI_Transmit+0x3c>
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
340101e6:	462b      	mov	r3, r5
340101e8:	2201      	movs	r2, #1
340101ea:	2102      	movs	r1, #2
340101ec:	4620      	mov	r0, r4
340101ee:	9600      	str	r6, [sp, #0]
340101f0:	f7ff fd48 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
340101f4:	b918      	cbnz	r0, 340101fe <HAL_XSPI_Transmit+0x7e>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
340101f6:	2302      	movs	r3, #2
340101f8:	6822      	ldr	r2, [r4, #0]
340101fa:	6253      	str	r3, [r2, #36]	@ 0x24
          hxspi->State = HAL_XSPI_STATE_READY;
340101fc:	65a3      	str	r3, [r4, #88]	@ 0x58
}
340101fe:	b002      	add	sp, #8
34010200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010204:	2310      	movs	r3, #16
34010206:	e7c8      	b.n	3401019a <HAL_XSPI_Transmit+0x1a>

34010208 <HAL_XSPI_Receive>:
{
34010208:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
3401020c:	4604      	mov	r4, r0
3401020e:	4616      	mov	r6, r2
34010210:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
34010212:	f7f4 fafb 	bl	3400480c <HAL_GetTick>
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
34010216:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
34010218:	4607      	mov	r7, r0
  uint32_t addr_reg = hxspi->Instance->AR;
3401021a:	6caa      	ldr	r2, [r5, #72]	@ 0x48
  uint32_t ir_reg = hxspi->Instance->IR;
3401021c:	f8d5 0110 	ldr.w	r0, [r5, #272]	@ 0x110
  if (pData == NULL)
34010220:	f1b8 0f00 	cmp.w	r8, #0
34010224:	d103      	bne.n	3401022e <HAL_XSPI_Receive+0x26>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34010226:	2308      	movs	r3, #8
    status = HAL_ERROR;
34010228:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401022a:	65e3      	str	r3, [r4, #92]	@ 0x5c
3401022c:	e035      	b.n	3401029a <HAL_XSPI_Receive+0x92>
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3401022e:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34010230:	2b04      	cmp	r3, #4
34010232:	d13d      	bne.n	340102b0 <HAL_XSPI_Receive+0xa8>
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34010234:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
      hxspi->pBuffPtr  = pData;
34010236:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401023a:	3301      	adds	r3, #1
3401023c:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
3401023e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010240:	64a3      	str	r3, [r4, #72]	@ 0x48
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34010242:	6829      	ldr	r1, [r5, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010244:	68e3      	ldr	r3, [r4, #12]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34010246:	f021 5140 	bic.w	r1, r1, #805306368	@ 0x30000000
3401024a:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401024e:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34010252:	6029      	str	r1, [r5, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010254:	d124      	bne.n	340102a0 <HAL_XSPI_Receive+0x98>
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34010256:	64aa      	str	r2, [r5, #72]	@ 0x48
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
34010258:	463b      	mov	r3, r7
3401025a:	2201      	movs	r2, #1
3401025c:	2106      	movs	r1, #6
3401025e:	4620      	mov	r0, r4
34010260:	9600      	str	r6, [sp, #0]
34010262:	f7ff fd0f 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
34010266:	b9c0      	cbnz	r0, 3401029a <HAL_XSPI_Receive+0x92>
        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
34010268:	f895 2050 	ldrb.w	r2, [r5, #80]	@ 0x50
3401026c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3401026e:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34010270:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010272:	3301      	adds	r3, #1
34010274:	6463      	str	r3, [r4, #68]	@ 0x44
        hxspi->XferCount--;
34010276:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010278:	3b01      	subs	r3, #1
3401027a:	64e3      	str	r3, [r4, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
3401027c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3401027e:	2b00      	cmp	r3, #0
34010280:	d1ea      	bne.n	34010258 <HAL_XSPI_Receive+0x50>
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
34010282:	463b      	mov	r3, r7
34010284:	2201      	movs	r2, #1
34010286:	2102      	movs	r1, #2
34010288:	4620      	mov	r0, r4
3401028a:	9600      	str	r6, [sp, #0]
3401028c:	f7ff fcfa 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
34010290:	b918      	cbnz	r0, 3401029a <HAL_XSPI_Receive+0x92>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34010292:	2302      	movs	r3, #2
34010294:	6822      	ldr	r2, [r4, #0]
34010296:	6253      	str	r3, [r2, #36]	@ 0x24
          hxspi->State = HAL_XSPI_STATE_READY;
34010298:	65a3      	str	r3, [r4, #88]	@ 0x58
}
3401029a:	b002      	add	sp, #8
3401029c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
340102a0:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
340102a4:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
340102a8:	d1d5      	bne.n	34010256 <HAL_XSPI_Receive+0x4e>
          WRITE_REG(hxspi->Instance->IR, ir_reg);
340102aa:	f8c5 0110 	str.w	r0, [r5, #272]	@ 0x110
340102ae:	e7d3      	b.n	34010258 <HAL_XSPI_Receive+0x50>
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340102b0:	2310      	movs	r3, #16
340102b2:	e7b9      	b.n	34010228 <HAL_XSPI_Receive+0x20>

340102b4 <HAL_XSPI_AutoPolling>:
{
340102b4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
340102b8:	4604      	mov	r4, r0
340102ba:	460d      	mov	r5, r1
340102bc:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
340102be:	f7f4 faa5 	bl	3400480c <HAL_GetTick>
  uint32_t addr_reg = hxspi->Instance->AR;
340102c2:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
340102c4:	4606      	mov	r6, r0
  uint32_t addr_reg = hxspi->Instance->AR;
340102c6:	f8d3 8048 	ldr.w	r8, [r3, #72]	@ 0x48
  uint32_t ir_reg = hxspi->Instance->IR;
340102ca:	f8d3 9110 	ldr.w	r9, [r3, #272]	@ 0x110
  uint32_t dlr_reg = hxspi->Instance->DLR;
340102ce:	f8d3 a040 	ldr.w	sl, [r3, #64]	@ 0x40
  assert_param(IS_XSPI_MATCH_MODE(pCfg->MatchMode));
340102d2:	68ab      	ldr	r3, [r5, #8]
340102d4:	f433 0300 	bics.w	r3, r3, #8388608	@ 0x800000
340102d8:	d004      	beq.n	340102e4 <HAL_XSPI_AutoPolling+0x30>
340102da:	f240 7133 	movw	r1, #1843	@ 0x733
340102de:	4832      	ldr	r0, [pc, #200]	@ (340103a8 <HAL_XSPI_AutoPolling+0xf4>)
340102e0:	f7f2 f928 	bl	34002534 <assert_failed>
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
340102e4:	68eb      	ldr	r3, [r5, #12]
340102e6:	f433 0380 	bics.w	r3, r3, #4194304	@ 0x400000
340102ea:	d004      	beq.n	340102f6 <HAL_XSPI_AutoPolling+0x42>
340102ec:	f240 7134 	movw	r1, #1844	@ 0x734
340102f0:	482d      	ldr	r0, [pc, #180]	@ (340103a8 <HAL_XSPI_AutoPolling+0xf4>)
340102f2:	f7f2 f91f 	bl	34002534 <assert_failed>
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
340102f6:	692b      	ldr	r3, [r5, #16]
340102f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340102fc:	d304      	bcc.n	34010308 <HAL_XSPI_AutoPolling+0x54>
340102fe:	f240 7135 	movw	r1, #1845	@ 0x735
34010302:	4829      	ldr	r0, [pc, #164]	@ (340103a8 <HAL_XSPI_AutoPolling+0xf4>)
34010304:	f7f2 f916 	bl	34002534 <assert_failed>
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));
34010308:	f1ba 0f03 	cmp.w	sl, #3
3401030c:	d904      	bls.n	34010318 <HAL_XSPI_AutoPolling+0x64>
3401030e:	f240 7136 	movw	r1, #1846	@ 0x736
34010312:	4825      	ldr	r0, [pc, #148]	@ (340103a8 <HAL_XSPI_AutoPolling+0xf4>)
34010314:	f7f2 f90e 	bl	34002534 <assert_failed>
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
34010318:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401031a:	2b04      	cmp	r3, #4
3401031c:	d13e      	bne.n	3401039c <HAL_XSPI_AutoPolling+0xe8>
3401031e:	68eb      	ldr	r3, [r5, #12]
34010320:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34010324:	d13a      	bne.n	3401039c <HAL_XSPI_AutoPolling+0xe8>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34010326:	4633      	mov	r3, r6
34010328:	2200      	movs	r2, #0
3401032a:	2120      	movs	r1, #32
3401032c:	4620      	mov	r0, r4
3401032e:	9700      	str	r7, [sp, #0]
34010330:	f7ff fca8 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
34010334:	2800      	cmp	r0, #0
34010336:	d135      	bne.n	340103a4 <HAL_XSPI_AutoPolling+0xf0>
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
34010338:	682b      	ldr	r3, [r5, #0]
3401033a:	6821      	ldr	r1, [r4, #0]
3401033c:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
34010340:	686b      	ldr	r3, [r5, #4]
34010342:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
34010346:	692b      	ldr	r3, [r5, #16]
34010348:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
3401034c:	680a      	ldr	r2, [r1, #0]
3401034e:	e9d5 3502 	ldrd	r3, r5, [r5, #8]
34010352:	431d      	orrs	r5, r3
34010354:	f022 5343 	bic.w	r3, r2, #817889280	@ 0x30c00000
34010358:	431d      	orrs	r5, r3
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401035a:	68e3      	ldr	r3, [r4, #12]
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
3401035c:	f045 5500 	orr.w	r5, r5, #536870912	@ 0x20000000
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010360:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34010364:	600d      	str	r5, [r1, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010366:	d111      	bne.n	3401038c <HAL_XSPI_AutoPolling+0xd8>
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34010368:	f8c1 8048 	str.w	r8, [r1, #72]	@ 0x48
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
3401036c:	4633      	mov	r3, r6
3401036e:	2201      	movs	r2, #1
34010370:	2108      	movs	r1, #8
34010372:	4620      	mov	r0, r4
34010374:	9700      	str	r7, [sp, #0]
34010376:	f7ff fc85 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
3401037a:	b920      	cbnz	r0, 34010386 <HAL_XSPI_AutoPolling+0xd2>
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
3401037c:	2208      	movs	r2, #8
3401037e:	6823      	ldr	r3, [r4, #0]
34010380:	625a      	str	r2, [r3, #36]	@ 0x24
        hxspi->State = HAL_XSPI_STATE_READY;
34010382:	2302      	movs	r3, #2
34010384:	65a3      	str	r3, [r4, #88]	@ 0x58
}
34010386:	b002      	add	sp, #8
34010388:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
3401038c:	f8d1 3100 	ldr.w	r3, [r1, #256]	@ 0x100
34010390:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
34010394:	d1e8      	bne.n	34010368 <HAL_XSPI_AutoPolling+0xb4>
          WRITE_REG(hxspi->Instance->IR, ir_reg);
34010396:	f8c1 9110 	str.w	r9, [r1, #272]	@ 0x110
3401039a:	e7e7      	b.n	3401036c <HAL_XSPI_AutoPolling+0xb8>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401039c:	2310      	movs	r3, #16
    status = HAL_ERROR;
3401039e:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340103a0:	65e3      	str	r3, [r4, #92]	@ 0x5c
340103a2:	e7f0      	b.n	34010386 <HAL_XSPI_AutoPolling+0xd2>
      status = HAL_BUSY;
340103a4:	2002      	movs	r0, #2
340103a6:	e7ee      	b.n	34010386 <HAL_XSPI_AutoPolling+0xd2>
340103a8:	3401c818 	.word	0x3401c818

340103ac <HAL_XSPI_MemoryMapped>:
{
340103ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
340103ae:	460c      	mov	r4, r1
340103b0:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
340103b2:	f7f4 fa2b 	bl	3400480c <HAL_GetTick>
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
340103b6:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
340103b8:	4606      	mov	r6, r0
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
340103ba:	f033 0308 	bics.w	r3, r3, #8
340103be:	d004      	beq.n	340103ca <HAL_XSPI_MemoryMapped+0x1e>
340103c0:	f240 71c7 	movw	r1, #1991	@ 0x7c7
340103c4:	482f      	ldr	r0, [pc, #188]	@ (34010484 <HAL_XSPI_MemoryMapped+0xd8>)
340103c6:	f7f2 f8b5 	bl	34002534 <assert_failed>
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));
340103ca:	68a3      	ldr	r3, [r4, #8]
340103cc:	f033 7300 	bics.w	r3, r3, #33554432	@ 0x2000000
340103d0:	d004      	beq.n	340103dc <HAL_XSPI_MemoryMapped+0x30>
340103d2:	f44f 61f9 	mov.w	r1, #1992	@ 0x7c8
340103d6:	482b      	ldr	r0, [pc, #172]	@ (34010484 <HAL_XSPI_MemoryMapped+0xd8>)
340103d8:	f7f2 f8ac 	bl	34002534 <assert_failed>
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
340103dc:	6dab      	ldr	r3, [r5, #88]	@ 0x58
340103de:	2b04      	cmp	r3, #4
340103e0:	d14b      	bne.n	3401047a <HAL_XSPI_MemoryMapped+0xce>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
340103e2:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
340103e4:	2200      	movs	r2, #0
340103e6:	9300      	str	r3, [sp, #0]
340103e8:	2120      	movs	r1, #32
340103ea:	4633      	mov	r3, r6
340103ec:	4628      	mov	r0, r5
340103ee:	f7ff fc49 	bl	3400fc84 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
340103f2:	4606      	mov	r6, r0
340103f4:	bb58      	cbnz	r0, 3401044e <HAL_XSPI_MemoryMapped+0xa2>
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
340103f6:	2388      	movs	r3, #136	@ 0x88
340103f8:	65ab      	str	r3, [r5, #88]	@ 0x58
      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
340103fa:	68a3      	ldr	r3, [r4, #8]
340103fc:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34010400:	d128      	bne.n	34010454 <HAL_XSPI_MemoryMapped+0xa8>
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
34010402:	682a      	ldr	r2, [r5, #0]
34010404:	6813      	ldr	r3, [r2, #0]
34010406:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
3401040a:	6013      	str	r3, [r2, #0]
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
3401040c:	6823      	ldr	r3, [r4, #0]
3401040e:	2b08      	cmp	r3, #8
34010410:	d112      	bne.n	34010438 <HAL_XSPI_MemoryMapped+0x8c>
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));
34010412:	6863      	ldr	r3, [r4, #4]
34010414:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34010418:	d304      	bcc.n	34010424 <HAL_XSPI_MemoryMapped+0x78>
3401041a:	f240 71e4 	movw	r1, #2020	@ 0x7e4
3401041e:	4819      	ldr	r0, [pc, #100]	@ (34010484 <HAL_XSPI_MemoryMapped+0xd8>)
34010420:	f7f2 f888 	bl	34002534 <assert_failed>
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34010424:	682b      	ldr	r3, [r5, #0]
34010426:	6862      	ldr	r2, [r4, #4]
34010428:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
3401042c:	2210      	movs	r2, #16
3401042e:	625a      	str	r2, [r3, #36]	@ 0x24
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34010430:	681a      	ldr	r2, [r3, #0]
34010432:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
34010436:	601a      	str	r2, [r3, #0]
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
34010438:	682a      	ldr	r2, [r5, #0]
3401043a:	6821      	ldr	r1, [r4, #0]
3401043c:	6813      	ldr	r3, [r2, #0]
3401043e:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
34010442:	f023 0308 	bic.w	r3, r3, #8
34010446:	430b      	orrs	r3, r1
34010448:	f043 5340 	orr.w	r3, r3, #805306368	@ 0x30000000
3401044c:	6013      	str	r3, [r2, #0]
}
3401044e:	4630      	mov	r0, r6
34010450:	b002      	add	sp, #8
34010452:	bd70      	pop	{r4, r5, r6, pc}
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));
34010454:	68e3      	ldr	r3, [r4, #12]
34010456:	f033 6380 	bics.w	r3, r3, #67108864	@ 0x4000000
3401045a:	d004      	beq.n	34010466 <HAL_XSPI_MemoryMapped+0xba>
3401045c:	f240 71dc 	movw	r1, #2012	@ 0x7dc
34010460:	4808      	ldr	r0, [pc, #32]	@ (34010484 <HAL_XSPI_MemoryMapped+0xd8>)
34010462:	f7f2 f867 	bl	34002534 <assert_failed>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
34010466:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
3401046a:	6829      	ldr	r1, [r5, #0]
3401046c:	4303      	orrs	r3, r0
3401046e:	680a      	ldr	r2, [r1, #0]
34010470:	f022 62c0 	bic.w	r2, r2, #100663296	@ 0x6000000
34010474:	4313      	orrs	r3, r2
34010476:	600b      	str	r3, [r1, #0]
34010478:	e7c8      	b.n	3401040c <HAL_XSPI_MemoryMapped+0x60>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401047a:	2310      	movs	r3, #16
    status = HAL_ERROR;
3401047c:	2601      	movs	r6, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401047e:	65eb      	str	r3, [r5, #92]	@ 0x5c
34010480:	e7e5      	b.n	3401044e <HAL_XSPI_MemoryMapped+0xa2>
34010482:	bf00      	nop
34010484:	3401c818 	.word	0x3401c818

34010488 <HAL_XSPI_SetClockPrescaler>:
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
34010488:	29ff      	cmp	r1, #255	@ 0xff
{
3401048a:	b538      	push	{r3, r4, r5, lr}
3401048c:	4604      	mov	r4, r0
3401048e:	460d      	mov	r5, r1
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
34010490:	d904      	bls.n	3401049c <HAL_XSPI_SetClockPrescaler+0x14>
34010492:	f640 2192 	movw	r1, #2706	@ 0xa92
34010496:	4809      	ldr	r0, [pc, #36]	@ (340104bc <HAL_XSPI_SetClockPrescaler+0x34>)
34010498:	f7f2 f84c 	bl	34002534 <assert_failed>
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
3401049c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401049e:	f010 0008 	ands.w	r0, r0, #8
340104a2:	d107      	bne.n	340104b4 <HAL_XSPI_SetClockPrescaler+0x2c>
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340104a4:	6822      	ldr	r2, [r4, #0]
    hxspi->Init.ClockPrescaler = Prescaler;
340104a6:	6265      	str	r5, [r4, #36]	@ 0x24
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340104a8:	68d3      	ldr	r3, [r2, #12]
340104aa:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
340104ae:	432b      	orrs	r3, r5
340104b0:	60d3      	str	r3, [r2, #12]
}
340104b2:	bd38      	pop	{r3, r4, r5, pc}
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340104b4:	2310      	movs	r3, #16
    status = HAL_ERROR;
340104b6:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340104b8:	65e3      	str	r3, [r4, #92]	@ 0x5c
340104ba:	e7fa      	b.n	340104b2 <HAL_XSPI_SetClockPrescaler+0x2a>
340104bc:	3401c818 	.word	0x3401c818

340104c0 <CB_ISP_GetSensorGain>:
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
  *Gain = Camera_Ctx.Gain;
340104c0:	4b02      	ldr	r3, [pc, #8]	@ (340104cc <CB_ISP_GetSensorGain+0xc>)
{
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
    return ISP_ERR_SENSORGAIN;

  return ISP_OK;
}
340104c2:	2000      	movs	r0, #0
  *Gain = Camera_Ctx.Gain;
340104c4:	6a1b      	ldr	r3, [r3, #32]
340104c6:	600b      	str	r3, [r1, #0]
}
340104c8:	4770      	bx	lr
340104ca:	bf00      	nop
340104cc:	34043ec4 	.word	0x34043ec4

340104d0 <CB_ISP_GetSensorExposure>:
  *exposure = Camera_Ctx.Exposure;
340104d0:	4b02      	ldr	r3, [pc, #8]	@ (340104dc <CB_ISP_GetSensorExposure+0xc>)
{
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
    return ISP_ERR_SENSOREXPOSURE;

  return ISP_OK;
}
340104d2:	2000      	movs	r0, #0
  *exposure = Camera_Ctx.Exposure;
340104d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340104d6:	600b      	str	r3, [r1, #0]
}
340104d8:	4770      	bx	lr
340104da:	bf00      	nop
340104dc:	34043ec4 	.word	0x34043ec4

340104e0 <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
340104e0:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo != NULL)
340104e2:	4b05      	ldr	r3, [pc, #20]	@ (340104f8 <CB_ISP_GetSensorInfo+0x18>)
340104e4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340104e6:	b113      	cbz	r3, 340104ee <CB_ISP_GetSensorInfo+0xe>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
340104e8:	4804      	ldr	r0, [pc, #16]	@ (340104fc <CB_ISP_GetSensorInfo+0x1c>)
340104ea:	4798      	blx	r3
340104ec:	b908      	cbnz	r0, 340104f2 <CB_ISP_GetSensorInfo+0x12>
      return ISP_ERR_SENSOREXPOSURE;
  }
  return ISP_OK;
340104ee:	2000      	movs	r0, #0
}
340104f0:	bd08      	pop	{r3, pc}
      return ISP_ERR_SENSOREXPOSURE;
340104f2:	2083      	movs	r0, #131	@ 0x83
340104f4:	e7fc      	b.n	340104f0 <CB_ISP_GetSensorInfo+0x10>
340104f6:	bf00      	nop
340104f8:	34043e58 	.word	0x34043e58
340104fc:	34043d14 	.word	0x34043d14

34010500 <CMW_CAMERA_EnablePin>:
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
34010500:	1e02      	subs	r2, r0, #0
34010502:	bf18      	it	ne
34010504:	2201      	movne	r2, #1
34010506:	2104      	movs	r1, #4
34010508:	4801      	ldr	r0, [pc, #4]	@ (34010510 <CMW_CAMERA_EnablePin+0x10>)
3401050a:	f7f7 bb55 	b.w	34007bb8 <HAL_GPIO_WritePin>
3401050e:	bf00      	nop
34010510:	56020c00 	.word	0x56020c00

34010514 <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
34010514:	1e02      	subs	r2, r0, #0
34010516:	bf18      	it	ne
34010518:	2201      	movne	r2, #1
3401051a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3401051e:	4801      	ldr	r0, [pc, #4]	@ (34010524 <CMW_CAMERA_ShutdownPin+0x10>)
34010520:	f7f7 bb4a 	b.w	34007bb8 <HAL_GPIO_WritePin>
34010524:	56020800 	.word	0x56020800

34010528 <CMW_CAMERA_Probe_Sensor.constprop.0>:

#if defined(USE_VD55G1_SENSOR)
static int32_t CMW_CAMERA_VD55G1_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
34010528:	2100      	movs	r1, #0
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
3401052a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3401052e:	4ca0      	ldr	r4, [pc, #640]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
34010530:	b099      	sub	sp, #100	@ 0x64
34010532:	4605      	mov	r5, r0
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010534:	f44f 72a2 	mov.w	r2, #324	@ 0x144
34010538:	4620      	mov	r0, r4
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401053a:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3401053e:	e9cd 1105 	strd	r1, r1, [sp, #20]
34010542:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010546:	f008 fb19 	bl	34018b7c <memset>
  camera_bsp.vd55g1_bsp.Address     = CAMERA_VD55G1_ADDRESS;
3401054a:	2320      	movs	r3, #32
3401054c:	8023      	strh	r3, [r4, #0]
  camera_bsp.vd55g1_bsp.ClockInHz   = CAMERA_VD55G1_FREQ_IN_HZ;
3401054e:	4b99      	ldr	r3, [pc, #612]	@ (340107b4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x28c>)
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
34010550:	f8df b294 	ldr.w	fp, [pc, #660]	@ 340107e8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2c0>
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
34010554:	f8df a294 	ldr.w	sl, [pc, #660]	@ 340107ec <CMW_CAMERA_Probe_Sensor.constprop.0+0x2c4>
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
34010558:	f8df 8294 	ldr.w	r8, [pc, #660]	@ 340107f0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2c8>
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
3401055c:	f8df 9294 	ldr.w	r9, [pc, #660]	@ 340107f4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2cc>
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
34010560:	4f95      	ldr	r7, [pc, #596]	@ (340107b8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x290>)
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
34010562:	4e96      	ldr	r6, [pc, #600]	@ (340107bc <CMW_CAMERA_Probe_Sensor.constprop.0+0x294>)
  camera_bsp.vd55g1_bsp.ClockInHz   = CAMERA_VD55G1_FREQ_IN_HZ;
34010564:	6063      	str	r3, [r4, #4]
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010566:	4b96      	ldr	r3, [pc, #600]	@ (340107c0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x298>)

  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
34010568:	4620      	mov	r0, r4
3401056a:	4996      	ldr	r1, [pc, #600]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
3401056c:	f8c4 b074 	str.w	fp, [r4, #116]	@ 0x74
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
34010570:	f8c4 a078 	str.w	sl, [r4, #120]	@ 0x78
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
34010574:	f8c4 807c 	str.w	r8, [r4, #124]	@ 0x7c
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
34010578:	f8c4 9080 	str.w	r9, [r4, #128]	@ 0x80
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
3401057c:	f8c4 7088 	str.w	r7, [r4, #136]	@ 0x88
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
34010580:	f8c4 608c 	str.w	r6, [r4, #140]	@ 0x8c
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010584:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
34010588:	f000 fee4 	bl	34011354 <CMW_VD55G1_Probe>
  if (ret != CMW_ERROR_NONE)
3401058c:	2800      	cmp	r0, #0
3401058e:	d135      	bne.n	340105fc <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
34010590:	682b      	ldr	r3, [r5, #0]
34010592:	4a8c      	ldr	r2, [pc, #560]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
34010594:	b10b      	cbz	r3, 3401059a <CMW_CAMERA_Probe_Sensor.constprop.0+0x72>
34010596:	686b      	ldr	r3, [r5, #4]
34010598:	b943      	cbnz	r3, 340105ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x84>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3401059a:	6d93      	ldr	r3, [r2, #88]	@ 0x58
3401059c:	4884      	ldr	r0, [pc, #528]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
3401059e:	a909      	add	r1, sp, #36	@ 0x24
340105a0:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
340105a2:	9b12      	ldr	r3, [sp, #72]	@ 0x48
    initSensors_params->height = sensor_info.height;
340105a4:	4a87      	ldr	r2, [pc, #540]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
    initSensors_params->width = sensor_info.width;
340105a6:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
340105a8:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
340105aa:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
340105ac:	4629      	mov	r1, r5
340105ae:	6813      	ldr	r3, [r2, #0]
340105b0:	487f      	ldr	r0, [pc, #508]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
340105b2:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
340105b4:	bb10      	cbnz	r0, 340105fc <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
340105b6:	f44f 7080 	mov.w	r0, #256	@ 0x100
340105ba:	2301      	movs	r3, #1
340105bc:	e9cd 0303 	strd	r0, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
340105c0:	231c      	movs	r3, #28
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
340105c2:	a903      	add	r1, sp, #12
340105c4:	4880      	ldr	r0, [pc, #512]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
340105c6:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
340105c8:	f7f4 fc14 	bl	34004df4 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
340105cc:	4601      	mov	r1, r0
340105ce:	b9a8      	cbnz	r0, 340105fc <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
340105d0:	2202      	movs	r2, #2
340105d2:	487d      	ldr	r0, [pc, #500]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
340105d4:	f7f4 fd7e 	bl	340050d4 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
340105d8:	4601      	mov	r1, r0
340105da:	b978      	cbnz	r0, 340105fc <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
340105dc:	232a      	movs	r3, #42	@ 0x2a
  csi_pipe_conf.DataTypeIDB = 0;
340105de:	e9cd 3007 	strd	r3, r0, [sp, #28]
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
340105e2:	9006      	str	r0, [sp, #24]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
340105e4:	4878      	ldr	r0, [pc, #480]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
340105e6:	aa06      	add	r2, sp, #24
340105e8:	9101      	str	r1, [sp, #4]
340105ea:	f7f4 fcbf 	bl	34004f6c <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
340105ee:	b928      	cbnz	r0, 340105fc <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
340105f0:	9901      	ldr	r1, [sp, #4]
340105f2:	3101      	adds	r1, #1
340105f4:	2903      	cmp	r1, #3
340105f6:	d1f5      	bne.n	340105e4 <CMW_CAMERA_Probe_Sensor.constprop.0+0xbc>
    return ret;
340105f8:	2002      	movs	r0, #2
340105fa:	e064      	b.n	340106c6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x19e>

#if defined(USE_VD66GY_SENSOR)
static int32_t CMW_CAMERA_VD66GY_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340105fc:	2100      	movs	r1, #0
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
340105fe:	f44f 72a2 	mov.w	r2, #324	@ 0x144
34010602:	486b      	ldr	r0, [pc, #428]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
34010604:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
34010608:	e9cd 1105 	strd	r1, r1, [sp, #20]
3401060c:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010610:	f008 fab4 	bl	34018b7c <memset>
  camera_bsp.vd66gy_bsp.Address     = CAMERA_VD66GY_ADDRESS;
34010614:	2320      	movs	r3, #32
34010616:	8023      	strh	r3, [r4, #0]
  camera_bsp.vd66gy_bsp.ClockInHz   = CAMERA_VD66GY_FREQ_IN_HZ;
34010618:	4b66      	ldr	r3, [pc, #408]	@ (340107b4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x28c>)
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
3401061a:	496a      	ldr	r1, [pc, #424]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
  camera_bsp.vd66gy_bsp.ClockInHz   = CAMERA_VD66GY_FREQ_IN_HZ;
3401061c:	6063      	str	r3, [r4, #4]
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3401061e:	4b68      	ldr	r3, [pc, #416]	@ (340107c0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x298>)
  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
34010620:	4863      	ldr	r0, [pc, #396]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010622:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
34010626:	4b68      	ldr	r3, [pc, #416]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  camera_bsp.vd66gy_bsp.DeInit      = CMW_I2C_DEINIT;
34010628:	e9c4 ba49 	strd	fp, sl, [r4, #292]	@ 0x124
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
3401062c:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
34010630:	4b66      	ldr	r3, [pc, #408]	@ (340107cc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a4>)
  camera_bsp.vd66gy_bsp.WriteReg    = CMW_I2C_WRITEREG16;
34010632:	e9c4 894b 	strd	r8, r9, [r4, #300]	@ 0x12c
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
34010636:	f8c4 3108 	str.w	r3, [r4, #264]	@ 0x108
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3401063a:	4b65      	ldr	r3, [pc, #404]	@ (340107d0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a8>)
  camera_bsp.vd66gy_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3401063c:	e9c4 764e 	strd	r7, r6, [r4, #312]	@ 0x138
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
34010640:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
34010644:	4b63      	ldr	r3, [pc, #396]	@ (340107d4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ac>)
34010646:	f8c4 3110 	str.w	r3, [r4, #272]	@ 0x110
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3401064a:	4b63      	ldr	r3, [pc, #396]	@ (340107d8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b0>)
3401064c:	f8c4 3114 	str.w	r3, [r4, #276]	@ 0x114
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
34010650:	4b62      	ldr	r3, [pc, #392]	@ (340107dc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b4>)
34010652:	f8c4 3104 	str.w	r3, [r4, #260]	@ 0x104
  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
34010656:	f001 fa09 	bl	34011a6c <CMW_VD66GY_Probe>
  if (ret != CMW_ERROR_NONE)
3401065a:	2800      	cmp	r0, #0
3401065c:	d139      	bne.n	340106d2 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3401065e:	682b      	ldr	r3, [r5, #0]
34010660:	b10b      	cbz	r3, 34010666 <CMW_CAMERA_Probe_Sensor.constprop.0+0x13e>
34010662:	686b      	ldr	r3, [r5, #4]
34010664:	b943      	cbnz	r3, 34010678 <CMW_CAMERA_Probe_Sensor.constprop.0+0x150>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
34010666:	4b57      	ldr	r3, [pc, #348]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
34010668:	4851      	ldr	r0, [pc, #324]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
3401066a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401066c:	a909      	add	r1, sp, #36	@ 0x24
3401066e:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
34010670:	9b12      	ldr	r3, [sp, #72]	@ 0x48
34010672:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
34010674:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
34010676:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
34010678:	4b52      	ldr	r3, [pc, #328]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
3401067a:	4629      	mov	r1, r5
3401067c:	681b      	ldr	r3, [r3, #0]
3401067e:	484c      	ldr	r0, [pc, #304]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010680:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010682:	bb30      	cbnz	r0, 340106d2 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34010684:	f44f 7100 	mov.w	r1, #512	@ 0x200
34010688:	2301      	movs	r3, #1
3401068a:	e9cd 1303 	strd	r1, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
3401068e:	231c      	movs	r3, #28
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010690:	a903      	add	r1, sp, #12
34010692:	484d      	ldr	r0, [pc, #308]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
34010694:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010696:	f7f4 fbad 	bl	34004df4 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
3401069a:	4601      	mov	r1, r0
3401069c:	b9c8      	cbnz	r0, 340106d2 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
3401069e:	2202      	movs	r2, #2
340106a0:	4849      	ldr	r0, [pc, #292]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
340106a2:	f7f4 fd17 	bl	340050d4 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
340106a6:	4601      	mov	r1, r0
340106a8:	b998      	cbnz	r0, 340106d2 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
340106aa:	232a      	movs	r3, #42	@ 0x2a
  csi_pipe_conf.DataTypeIDB = 0;
340106ac:	e9cd 3007 	strd	r3, r0, [sp, #28]
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
340106b0:	9006      	str	r0, [sp, #24]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
340106b2:	4845      	ldr	r0, [pc, #276]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
340106b4:	aa06      	add	r2, sp, #24
340106b6:	9101      	str	r1, [sp, #4]
340106b8:	f7f4 fc58 	bl	34004f6c <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
340106bc:	b948      	cbnz	r0, 340106d2 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
340106be:	9901      	ldr	r1, [sp, #4]
340106c0:	3101      	adds	r1, #1
340106c2:	2903      	cmp	r1, #3
340106c4:	d1f5      	bne.n	340106b2 <CMW_CAMERA_Probe_Sensor.constprop.0+0x18a>
    *sensorName = CMW_VD66GY_Sensor;
340106c6:	4b46      	ldr	r3, [pc, #280]	@ (340107e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b8>)
340106c8:	7018      	strb	r0, [r3, #0]
    return ret;
340106ca:	2000      	movs	r0, #0
}
340106cc:	b019      	add	sp, #100	@ 0x64
340106ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340106d2:	2100      	movs	r1, #0
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
340106d4:	f44f 72a2 	mov.w	r2, #324	@ 0x144
340106d8:	4835      	ldr	r0, [pc, #212]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340106da:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
340106de:	e9cd 1105 	strd	r1, r1, [sp, #20]
340106e2:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
340106e6:	f008 fa49 	bl	34018b7c <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
340106ea:	2334      	movs	r3, #52	@ 0x34
340106ec:	8023      	strh	r3, [r4, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
340106ee:	4b3d      	ldr	r3, [pc, #244]	@ (340107e4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2bc>)
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
340106f0:	4934      	ldr	r1, [pc, #208]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
340106f2:	e9c4 373d 	strd	r3, r7, [r4, #244]	@ 0xf4
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
340106f6:	4b32      	ldr	r3, [pc, #200]	@ (340107c0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x298>)
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
340106f8:	482d      	ldr	r0, [pc, #180]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
340106fa:	f8c4 3100 	str.w	r3, [r4, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
340106fe:	4b32      	ldr	r3, [pc, #200]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
34010700:	e9c4 ba39 	strd	fp, sl, [r4, #228]	@ 0xe4
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
34010704:	f8c4 30dc 	str.w	r3, [r4, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
34010708:	4b30      	ldr	r3, [pc, #192]	@ (340107cc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a4>)
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3401070a:	e9c4 893b 	strd	r8, r9, [r4, #236]	@ 0xec
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3401070e:	f8c4 30c8 	str.w	r3, [r4, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
34010712:	4b2f      	ldr	r3, [pc, #188]	@ (340107d0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a8>)
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
34010714:	f8c4 60fc 	str.w	r6, [r4, #252]	@ 0xfc
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
34010718:	f8c4 30cc 	str.w	r3, [r4, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3401071c:	4b2d      	ldr	r3, [pc, #180]	@ (340107d4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ac>)
3401071e:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
34010722:	4b2d      	ldr	r3, [pc, #180]	@ (340107d8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b0>)
34010724:	f8c4 30d4 	str.w	r3, [r4, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
34010728:	4b2c      	ldr	r3, [pc, #176]	@ (340107dc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b4>)
3401072a:	f8c4 30c4 	str.w	r3, [r4, #196]	@ 0xc4
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3401072e:	f000 fc71 	bl	34011014 <CMW_IMX335_Probe>
  if (ret != CMW_ERROR_NONE)
34010732:	2800      	cmp	r0, #0
34010734:	d139      	bne.n	340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
34010736:	682b      	ldr	r3, [r5, #0]
34010738:	4c22      	ldr	r4, [pc, #136]	@ (340107c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
3401073a:	b10b      	cbz	r3, 34010740 <CMW_CAMERA_Probe_Sensor.constprop.0+0x218>
3401073c:	686b      	ldr	r3, [r5, #4]
3401073e:	b93b      	cbnz	r3, 34010750 <CMW_CAMERA_Probe_Sensor.constprop.0+0x228>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
34010740:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34010742:	481b      	ldr	r0, [pc, #108]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010744:	a909      	add	r1, sp, #36	@ 0x24
34010746:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
34010748:	9b12      	ldr	r3, [sp, #72]	@ 0x48
3401074a:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
3401074c:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
3401074e:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
34010750:	4629      	mov	r1, r5
34010752:	6823      	ldr	r3, [r4, #0]
34010754:	4816      	ldr	r0, [pc, #88]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010756:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010758:	bb38      	cbnz	r0, 340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_24MHZ);
3401075a:	2102      	movs	r1, #2
3401075c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3401075e:	4814      	ldr	r0, [pc, #80]	@ (340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010760:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010762:	bb10      	cbnz	r0, 340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34010764:	f44f 7200 	mov.w	r2, #512	@ 0x200
34010768:	2301      	movs	r3, #1
3401076a:	e9cd 2303 	strd	r2, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3401076e:	232c      	movs	r3, #44	@ 0x2c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010770:	a903      	add	r1, sp, #12
34010772:	4815      	ldr	r0, [pc, #84]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
34010774:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010776:	f7f4 fb3d 	bl	34004df4 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
3401077a:	4601      	mov	r1, r0
3401077c:	b9a8      	cbnz	r0, 340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
3401077e:	2203      	movs	r2, #3
34010780:	4811      	ldr	r0, [pc, #68]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
34010782:	f7f4 fca7 	bl	340050d4 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
34010786:	4604      	mov	r4, r0
34010788:	b978      	cbnz	r0, 340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
3401078a:	232b      	movs	r3, #43	@ 0x2b
  csi_pipe_conf.DataTypeIDB = 0;
3401078c:	e9cd 3007 	strd	r3, r0, [sp, #28]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010790:	4d0d      	ldr	r5, [pc, #52]	@ (340107c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34010792:	9006      	str	r0, [sp, #24]
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010794:	4621      	mov	r1, r4
34010796:	4628      	mov	r0, r5
34010798:	aa06      	add	r2, sp, #24
3401079a:	f7f4 fbe7 	bl	34004f6c <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
3401079e:	b920      	cbnz	r0, 340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
340107a0:	3401      	adds	r4, #1
340107a2:	2c03      	cmp	r4, #3
340107a4:	d1f6      	bne.n	34010794 <CMW_CAMERA_Probe_Sensor.constprop.0+0x26c>
    return ret;
340107a6:	2001      	movs	r0, #1
340107a8:	e78d      	b.n	340106c6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x19e>
    return CMW_ERROR_UNKNOWN_COMPONENT;
340107aa:	f06f 0006 	mvn.w	r0, #6
340107ae:	e78d      	b.n	340106cc <CMW_CAMERA_Probe_Sensor.constprop.0+0x1a4>
340107b0:	34043d14 	.word	0x34043d14
340107b4:	00b71b00 	.word	0x00b71b00
340107b8:	34004819 	.word	0x34004819
340107bc:	34010515 	.word	0x34010515
340107c0:	34010501 	.word	0x34010501
340107c4:	34043e58 	.word	0x34043e58
340107c8:	34043eb8 	.word	0x34043eb8
340107cc:	34010a79 	.word	0x34010a79
340107d0:	340104c1 	.word	0x340104c1
340107d4:	34010abd 	.word	0x34010abd
340107d8:	340104d1 	.word	0x340104d1
340107dc:	340104e1 	.word	0x340104e1
340107e0:	34043f04 	.word	0x34043f04
340107e4:	340034d5 	.word	0x340034d5
340107e8:	340033a5 	.word	0x340033a5
340107ec:	34003315 	.word	0x34003315
340107f0:	34003465 	.word	0x34003465
340107f4:	3400349d 	.word	0x3400349d

340107f8 <CMW_CAMERA_EnableGPIOs>:
{
340107f8:	b570      	push	{r4, r5, r6, lr}
340107fa:	b088      	sub	sp, #32
  GPIO_InitTypeDef gpio_init_structure = {0};
340107fc:	2214      	movs	r2, #20
340107fe:	2100      	movs	r1, #0
34010800:	a803      	add	r0, sp, #12
34010802:	f008 f9bb 	bl	34018b7c <memset>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34010806:	2308      	movs	r3, #8
34010808:	4c13      	ldr	r4, [pc, #76]	@ (34010858 <CMW_CAMERA_EnableGPIOs+0x60>)
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3401080a:	2501      	movs	r5, #1
3401080c:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34010810:	f8d4 325c 	ldr.w	r3, [r4, #604]	@ 0x25c
34010814:	2600      	movs	r6, #0
34010816:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
34010818:	9b02      	ldr	r3, [sp, #8]
  NRST_CAM_GPIO_ENABLE_VDDIO();
3401081a:	f7f8 fba1 	bl	34008f60 <HAL_PWREx_EnableVddIO4>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3401081e:	2304      	movs	r3, #4
34010820:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34010824:	f8d4 225c 	ldr.w	r2, [r4, #604]	@ 0x25c
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34010828:	2403      	movs	r4, #3
3401082a:	9201      	str	r2, [sp, #4]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3401082c:	a903      	add	r1, sp, #12
3401082e:	480b      	ldr	r0, [pc, #44]	@ (3401085c <CMW_CAMERA_EnableGPIOs+0x64>)
  (void)tmpreg;
34010830:	9a01      	ldr	r2, [sp, #4]
  gpio_init_structure.Pin       = EN_CAM_PIN;
34010832:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34010834:	e9cd 5604 	strd	r5, r6, [sp, #16]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34010838:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3401083a:	f7f6 fe77 	bl	3400752c <HAL_GPIO_Init>
  gpio_init_structure.Pin       = NRST_CAM_PIN;
3401083e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
34010842:	4807      	ldr	r0, [pc, #28]	@ (34010860 <CMW_CAMERA_EnableGPIOs+0x68>)
34010844:	a903      	add	r1, sp, #12
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34010846:	e9cd 5604 	strd	r5, r6, [sp, #16]
  gpio_init_structure.Pin       = NRST_CAM_PIN;
3401084a:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3401084c:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
3401084e:	f7f6 fe6d 	bl	3400752c <HAL_GPIO_Init>
}
34010852:	b008      	add	sp, #32
34010854:	bd70      	pop	{r4, r5, r6, pc}
34010856:	bf00      	nop
34010858:	56028000 	.word	0x56028000
3401085c:	56020c00 	.word	0x56020c00
34010860:	56020800 	.word	0x56020800

34010864 <CMW_CAMERA_GetDCMIPPHandle>:
}
34010864:	4800      	ldr	r0, [pc, #0]	@ (34010868 <CMW_CAMERA_GetDCMIPPHandle+0x4>)
34010866:	4770      	bx	lr
34010868:	34043eb8 	.word	0x34043eb8

3401086c <CMW_CAMERA_SetPipeConfig>:
{
3401086c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
}
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010870:	2600      	movs	r6, #0
{
34010872:	4604      	mov	r4, r0
34010874:	b093      	sub	sp, #76	@ 0x4c
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
34010876:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
{
3401087a:	460d      	mov	r5, r1
3401087c:	4617      	mov	r7, r2
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3401087e:	4631      	mov	r1, r6
34010880:	2218      	movs	r2, #24
34010882:	4640      	mov	r0, r8
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
34010884:	e9cd 6604 	strd	r6, r6, [sp, #16]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010888:	9602      	str	r6, [sp, #8]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3401088a:	9606      	str	r6, [sp, #24]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3401088c:	9603      	str	r6, [sp, #12]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3401088e:	f008 f975 	bl	34018b7c <memset>
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
34010892:	2214      	movs	r2, #20
34010894:	4631      	mov	r1, r6
34010896:	a807      	add	r0, sp, #28
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010898:	f10d 0908 	add.w	r9, sp, #8
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3401089c:	f008 f96e 	bl	34018b7c <memset>
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
340108a0:	b95c      	cbnz	r4, 340108ba <CMW_CAMERA_SetPipeConfig+0x4e>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
340108a2:	4621      	mov	r1, r4
340108a4:	484f      	ldr	r0, [pc, #316]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
340108a6:	aa04      	add	r2, sp, #16
340108a8:	f7f4 fc4c 	bl	34005144 <HAL_DCMIPP_PIPE_SetConfig>
    if (ret != HAL_OK)
340108ac:	2800      	cmp	r0, #0
340108ae:	d07c      	beq.n	340109aa <CMW_CAMERA_SetPipeConfig+0x13e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
340108b0:	f06f 0004 	mvn.w	r0, #4
}
340108b4:	b013      	add	sp, #76	@ 0x4c
340108b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }

    return HAL_OK;
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
340108ba:	e9cd 9800 	strd	r9, r8, [sp]
340108be:	484a      	ldr	r0, [pc, #296]	@ (340109e8 <CMW_CAMERA_SetPipeConfig+0x17c>)
340108c0:	462a      	mov	r2, r5
340108c2:	e9d0 0100 	ldrd	r0, r1, [r0]
340108c6:	ab07      	add	r3, sp, #28
340108c8:	f000 fa10 	bl	34010cec <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
340108cc:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	@ 0x24
340108d0:	4313      	orrs	r3, r2
340108d2:	d015      	beq.n	34010900 <CMW_CAMERA_SetPipeConfig+0x94>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
340108d4:	4621      	mov	r1, r4
340108d6:	4843      	ldr	r0, [pc, #268]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
340108d8:	aa07      	add	r2, sp, #28
340108da:	f7f5 f99d 	bl	34005c18 <HAL_DCMIPP_PIPE_SetCropConfig>
    if (ret != HAL_OK)
340108de:	2800      	cmp	r0, #0
340108e0:	d1e6      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
340108e2:	4621      	mov	r1, r4
340108e4:	483f      	ldr	r0, [pc, #252]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
340108e6:	f7f5 fa3d 	bl	34005d64 <HAL_DCMIPP_PIPE_EnableCrop>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
    if (ret != HAL_OK)
340108ea:	2800      	cmp	r0, #0
340108ec:	d1e0      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
340108ee:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
340108f2:	4313      	orrs	r3, r2
340108f4:	d109      	bne.n	3401090a <CMW_CAMERA_SetPipeConfig+0x9e>
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
340108f6:	4621      	mov	r1, r4
340108f8:	483a      	ldr	r0, [pc, #232]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
340108fa:	f7f5 fb61 	bl	34005fc0 <HAL_DCMIPP_PIPE_DisableDecimation>
340108fe:	e00f      	b.n	34010920 <CMW_CAMERA_SetPipeConfig+0xb4>
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
34010900:	4621      	mov	r1, r4
34010902:	4838      	ldr	r0, [pc, #224]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
34010904:	f7f5 fa6e 	bl	34005de4 <HAL_DCMIPP_PIPE_DisableCrop>
34010908:	e7ef      	b.n	340108ea <CMW_CAMERA_SetPipeConfig+0x7e>
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
3401090a:	464a      	mov	r2, r9
3401090c:	4621      	mov	r1, r4
3401090e:	4835      	ldr	r0, [pc, #212]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
34010910:	f7f5 fae8 	bl	34005ee4 <HAL_DCMIPP_PIPE_SetDecimationConfig>
    if (ret != HAL_OK)
34010914:	2800      	cmp	r0, #0
34010916:	d1cb      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
34010918:	4621      	mov	r1, r4
3401091a:	4832      	ldr	r0, [pc, #200]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
3401091c:	f7f5 fb2e 	bl	34005f7c <HAL_DCMIPP_PIPE_EnableDecimation>
    if (ret != HAL_OK)
34010920:	2800      	cmp	r0, #0
34010922:	d1c5      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
34010924:	4642      	mov	r2, r8
34010926:	4621      	mov	r1, r4
34010928:	482e      	ldr	r0, [pc, #184]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
3401092a:	f7f5 fb6b 	bl	34006004 <HAL_DCMIPP_PIPE_SetDownsizeConfig>
  if (ret != HAL_OK)
3401092e:	4e2d      	ldr	r6, [pc, #180]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
34010930:	2800      	cmp	r0, #0
34010932:	d1bd      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
34010934:	4621      	mov	r1, r4
34010936:	4630      	mov	r0, r6
34010938:	f7f5 fbf2 	bl	34006120 <HAL_DCMIPP_PIPE_EnableDownsize>
  if (ret != HAL_OK)
3401093c:	2800      	cmp	r0, #0
3401093e:	d1b7      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if (p_conf->enable_swap)
34010940:	692b      	ldr	r3, [r5, #16]
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
34010942:	4621      	mov	r1, r4
34010944:	4630      	mov	r0, r6
  if (p_conf->enable_swap)
34010946:	2b00      	cmp	r3, #0
34010948:	d031      	beq.n	340109ae <CMW_CAMERA_SetPipeConfig+0x142>
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
3401094a:	f7f6 fa55 	bl	34006df8 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
    if (ret != HAL_OK)
3401094e:	2800      	cmp	r0, #0
34010950:	d1ae      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
34010952:	696b      	ldr	r3, [r5, #20]
34010954:	2b00      	cmp	r3, #0
34010956:	da2d      	bge.n	340109b4 <CMW_CAMERA_SetPipeConfig+0x148>
        return CMW_ERROR_COMPONENT_FAILURE;
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
34010958:	2c02      	cmp	r4, #2
3401095a:	d10f      	bne.n	3401097c <CMW_CAMERA_SetPipeConfig+0x110>
  {
    if (!is_pipe1_2_shared)
3401095c:	f8df 808c 	ldr.w	r8, [pc, #140]	@ 340109ec <CMW_CAMERA_SetPipeConfig+0x180>
34010960:	f8d8 3000 	ldr.w	r3, [r8]
34010964:	b953      	cbnz	r3, 3401097c <CMW_CAMERA_SetPipeConfig+0x110>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
34010966:	4621      	mov	r1, r4
34010968:	481e      	ldr	r0, [pc, #120]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
3401096a:	f7f6 fa95 	bl	34006e98 <HAL_DCMIPP_PIPE_CSI_EnableShare>
      if (ret != HAL_OK)
3401096e:	2800      	cmp	r0, #0
34010970:	d19e      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
      }
      is_pipe1_2_shared++;
34010972:	f8d8 3000 	ldr.w	r3, [r8]
34010976:	3301      	adds	r3, #1
34010978:	f8c8 3000 	str.w	r3, [r8]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3401097c:	2300      	movs	r3, #0
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3401097e:	68ea      	ldr	r2, [r5, #12]
  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
34010980:	9304      	str	r3, [sp, #16]
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
34010982:	682b      	ldr	r3, [r5, #0]
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
  pipe_conf.PixelPackerFormat = p_conf->output_format;
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010984:	4426      	add	r6, r4
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
34010986:	4353      	muls	r3, r2
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
34010988:	330f      	adds	r3, #15
3401098a:	f023 030f 	bic.w	r3, r3, #15
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3401098e:	68aa      	ldr	r2, [r5, #8]
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
34010990:	9305      	str	r3, [sp, #20]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010992:	7973      	ldrb	r3, [r6, #5]
  pipe_conf.PixelPackerFormat = p_conf->output_format;
34010994:	9206      	str	r2, [sp, #24]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010996:	b9c3      	cbnz	r3, 340109ca <CMW_CAMERA_SetPipeConfig+0x15e>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
34010998:	4621      	mov	r1, r4
3401099a:	4812      	ldr	r0, [pc, #72]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
3401099c:	aa04      	add	r2, sp, #16
3401099e:	f7f4 fbd1 	bl	34005144 <HAL_DCMIPP_PIPE_SetConfig>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
340109a2:	2800      	cmp	r0, #0
340109a4:	d184      	bne.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
340109a6:	9b05      	ldr	r3, [sp, #20]
340109a8:	603b      	str	r3, [r7, #0]
    return HAL_OK;
340109aa:	2000      	movs	r0, #0
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
340109ac:	e782      	b.n	340108b4 <CMW_CAMERA_SetPipeConfig+0x48>
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
340109ae:	f7f6 fa4b 	bl	34006e48 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
340109b2:	e7cc      	b.n	3401094e <CMW_CAMERA_SetPipeConfig+0xe2>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
340109b4:	4621      	mov	r1, r4
340109b6:	480b      	ldr	r0, [pc, #44]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
    if (p_conf->enable_gamma_conversion)
340109b8:	d004      	beq.n	340109c4 <CMW_CAMERA_SetPipeConfig+0x158>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
340109ba:	f7f5 fbd3 	bl	34006164 <HAL_DCMIPP_PIPE_EnableGammaConversion>
      if (ret != HAL_OK)
340109be:	2800      	cmp	r0, #0
340109c0:	d0ca      	beq.n	34010958 <CMW_CAMERA_SetPipeConfig+0xec>
340109c2:	e775      	b.n	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
340109c4:	f7f5 fbf0 	bl	340061a8 <HAL_DCMIPP_PIPE_DisableGammaConversion>
340109c8:	e7f9      	b.n	340109be <CMW_CAMERA_SetPipeConfig+0x152>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
340109ca:	4621      	mov	r1, r4
340109cc:	4805      	ldr	r0, [pc, #20]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
340109ce:	f7f6 f9e1 	bl	34006d94 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
340109d2:	2800      	cmp	r0, #0
340109d4:	f47f af6c 	bne.w	340108b0 <CMW_CAMERA_SetPipeConfig+0x44>
    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
340109d8:	4621      	mov	r1, r4
340109da:	9a05      	ldr	r2, [sp, #20]
340109dc:	4801      	ldr	r0, [pc, #4]	@ (340109e4 <CMW_CAMERA_SetPipeConfig+0x178>)
340109de:	f7f6 f9a7 	bl	34006d30 <HAL_DCMIPP_PIPE_SetPitch>
340109e2:	e7de      	b.n	340109a2 <CMW_CAMERA_SetPipeConfig+0x136>
340109e4:	34043eb8 	.word	0x34043eb8
340109e8:	34043f08 	.word	0x34043f08
340109ec:	34043d08 	.word	0x34043d08

340109f0 <CMW_CAMERA_Start>:
  if (pipe >= DCMIPP_NUM_OF_PIPES)
340109f0:	2802      	cmp	r0, #2
{
340109f2:	460b      	mov	r3, r1
340109f4:	b513      	push	{r0, r1, r4, lr}
  if (pipe >= DCMIPP_NUM_OF_PIPES)
340109f6:	d815      	bhi.n	34010a24 <CMW_CAMERA_Start+0x34>
  ret = HAL_DCMIPP_CSI_PIPE_Start(&hcamera_dcmipp, pipe, DCMIPP_VIRTUAL_CHANNEL0, (uint32_t)pbuff, mode);
340109f8:	4601      	mov	r1, r0
340109fa:	9200      	str	r2, [sp, #0]
340109fc:	480e      	ldr	r0, [pc, #56]	@ (34010a38 <CMW_CAMERA_Start+0x48>)
340109fe:	2200      	movs	r2, #0
34010a00:	f7f4 fc3e 	bl	34005280 <HAL_DCMIPP_CSI_PIPE_Start>
  if (ret != HAL_OK)
34010a04:	b988      	cbnz	r0, 34010a2a <CMW_CAMERA_Start+0x3a>
  if (!is_camera_started)
34010a06:	4c0d      	ldr	r4, [pc, #52]	@ (34010a3c <CMW_CAMERA_Start+0x4c>)
34010a08:	6823      	ldr	r3, [r4, #0]
34010a0a:	b113      	cbz	r3, 34010a12 <CMW_CAMERA_Start+0x22>
  return ret;
34010a0c:	2000      	movs	r0, #0
}
34010a0e:	b002      	add	sp, #8
34010a10:	bd10      	pop	{r4, pc}
    ret = Camera_Drv.Start(&camera_bsp);
34010a12:	4b0b      	ldr	r3, [pc, #44]	@ (34010a40 <CMW_CAMERA_Start+0x50>)
34010a14:	480b      	ldr	r0, [pc, #44]	@ (34010a44 <CMW_CAMERA_Start+0x54>)
34010a16:	689b      	ldr	r3, [r3, #8]
34010a18:	4798      	blx	r3
    if (ret != CMW_ERROR_NONE)
34010a1a:	b948      	cbnz	r0, 34010a30 <CMW_CAMERA_Start+0x40>
    is_camera_started++;
34010a1c:	6823      	ldr	r3, [r4, #0]
34010a1e:	3301      	adds	r3, #1
34010a20:	6023      	str	r3, [r4, #0]
34010a22:	e7f3      	b.n	34010a0c <CMW_CAMERA_Start+0x1c>
    return CMW_ERROR_WRONG_PARAM;
34010a24:	f06f 0001 	mvn.w	r0, #1
34010a28:	e7f1      	b.n	34010a0e <CMW_CAMERA_Start+0x1e>
    return CMW_ERROR_PERIPH_FAILURE;
34010a2a:	f06f 0003 	mvn.w	r0, #3
34010a2e:	e7ee      	b.n	34010a0e <CMW_CAMERA_Start+0x1e>
      return CMW_ERROR_COMPONENT_FAILURE;
34010a30:	f06f 0004 	mvn.w	r0, #4
34010a34:	e7eb      	b.n	34010a0e <CMW_CAMERA_Start+0x1e>
34010a36:	bf00      	nop
34010a38:	34043eb8 	.word	0x34043eb8
34010a3c:	34043d0c 	.word	0x34043d0c
34010a40:	34043e58 	.word	0x34043e58
34010a44:	34043d14 	.word	0x34043d14

34010a48 <CMW_CAMERA_SetGain>:
  if(Camera_Drv.SetGain == NULL)
34010a48:	4b08      	ldr	r3, [pc, #32]	@ (34010a6c <CMW_CAMERA_SetGain+0x24>)
{
34010a4a:	b510      	push	{r4, lr}
  if(Camera_Drv.SetGain == NULL)
34010a4c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
{
34010a4e:	4604      	mov	r4, r0
  if(Camera_Drv.SetGain == NULL)
34010a50:	b133      	cbz	r3, 34010a60 <CMW_CAMERA_SetGain+0x18>
  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
34010a52:	4601      	mov	r1, r0
34010a54:	4806      	ldr	r0, [pc, #24]	@ (34010a70 <CMW_CAMERA_SetGain+0x28>)
34010a56:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010a58:	b928      	cbnz	r0, 34010a66 <CMW_CAMERA_SetGain+0x1e>
  Camera_Ctx.Gain = Gain;
34010a5a:	4b06      	ldr	r3, [pc, #24]	@ (34010a74 <CMW_CAMERA_SetGain+0x2c>)
34010a5c:	621c      	str	r4, [r3, #32]
}
34010a5e:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010a60:	f06f 000a 	mvn.w	r0, #10
34010a64:	e7fb      	b.n	34010a5e <CMW_CAMERA_SetGain+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
34010a66:	f06f 0004 	mvn.w	r0, #4
34010a6a:	e7f8      	b.n	34010a5e <CMW_CAMERA_SetGain+0x16>
34010a6c:	34043e58 	.word	0x34043e58
34010a70:	34043d14 	.word	0x34043d14
34010a74:	34043ec4 	.word	0x34043ec4

34010a78 <CB_ISP_SetSensorGain>:
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
34010a78:	4608      	mov	r0, r1
{
34010a7a:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
34010a7c:	f7ff ffe4 	bl	34010a48 <CMW_CAMERA_SetGain>
  return ISP_OK;
34010a80:	2800      	cmp	r0, #0
}
34010a82:	bf14      	ite	ne
34010a84:	2079      	movne	r0, #121	@ 0x79
34010a86:	2000      	moveq	r0, #0
34010a88:	bd08      	pop	{r3, pc}
	...

34010a8c <CMW_CAMERA_SetExposure>:
  if(Camera_Drv.SetExposure == NULL)
34010a8c:	4b08      	ldr	r3, [pc, #32]	@ (34010ab0 <CMW_CAMERA_SetExposure+0x24>)
{
34010a8e:	b510      	push	{r4, lr}
  if(Camera_Drv.SetExposure == NULL)
34010a90:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
{
34010a92:	4604      	mov	r4, r0
  if(Camera_Drv.SetExposure == NULL)
34010a94:	b133      	cbz	r3, 34010aa4 <CMW_CAMERA_SetExposure+0x18>
  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
34010a96:	4601      	mov	r1, r0
34010a98:	4806      	ldr	r0, [pc, #24]	@ (34010ab4 <CMW_CAMERA_SetExposure+0x28>)
34010a9a:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010a9c:	b928      	cbnz	r0, 34010aaa <CMW_CAMERA_SetExposure+0x1e>
  Camera_Ctx.Exposure = exposure;
34010a9e:	4b06      	ldr	r3, [pc, #24]	@ (34010ab8 <CMW_CAMERA_SetExposure+0x2c>)
34010aa0:	625c      	str	r4, [r3, #36]	@ 0x24
}
34010aa2:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010aa4:	f06f 000a 	mvn.w	r0, #10
34010aa8:	e7fb      	b.n	34010aa2 <CMW_CAMERA_SetExposure+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
34010aaa:	f06f 0004 	mvn.w	r0, #4
34010aae:	e7f8      	b.n	34010aa2 <CMW_CAMERA_SetExposure+0x16>
34010ab0:	34043e58 	.word	0x34043e58
34010ab4:	34043d14 	.word	0x34043d14
34010ab8:	34043ec4 	.word	0x34043ec4

34010abc <CB_ISP_SetSensorExposure>:
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
34010abc:	4608      	mov	r0, r1
{
34010abe:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
34010ac0:	f7ff ffe4 	bl	34010a8c <CMW_CAMERA_SetExposure>
  return ISP_OK;
34010ac4:	2800      	cmp	r0, #0
}
34010ac6:	bf14      	ite	ne
34010ac8:	2083      	movne	r0, #131	@ 0x83
34010aca:	2000      	moveq	r0, #0
34010acc:	bd08      	pop	{r3, pc}
	...

34010ad0 <CMW_CAMERA_GetSensorInfo>:
{
34010ad0:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo == NULL)
34010ad2:	4b07      	ldr	r3, [pc, #28]	@ (34010af0 <CMW_CAMERA_GetSensorInfo+0x20>)
{
34010ad4:	4601      	mov	r1, r0
  if(Camera_Drv.GetSensorInfo == NULL)
34010ad6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34010ad8:	b133      	cbz	r3, 34010ae8 <CMW_CAMERA_GetSensorInfo+0x18>
  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
34010ada:	4806      	ldr	r0, [pc, #24]	@ (34010af4 <CMW_CAMERA_GetSensorInfo+0x24>)
34010adc:	4798      	blx	r3
    return CMW_ERROR_COMPONENT_FAILURE;
34010ade:	2800      	cmp	r0, #0
34010ae0:	bf18      	it	ne
34010ae2:	f06f 0004 	mvnne.w	r0, #4
}
34010ae6:	bd08      	pop	{r3, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010ae8:	f06f 000a 	mvn.w	r0, #10
34010aec:	e7fb      	b.n	34010ae6 <CMW_CAMERA_GetSensorInfo+0x16>
34010aee:	bf00      	nop
34010af0:	34043e58 	.word	0x34043e58
34010af4:	34043d14 	.word	0x34043d14

34010af8 <CMW_CAMERA_Init>:
{
34010af8:	b570      	push	{r4, r5, r6, lr}
34010afa:	4604      	mov	r4, r0
34010afc:	b094      	sub	sp, #80	@ 0x50
  ISP_SensorInfoTypeDef info = {0};
34010afe:	223c      	movs	r2, #60	@ 0x3c
34010b00:	2100      	movs	r1, #0
34010b02:	a805      	add	r0, sp, #20
34010b04:	f008 f83a 	bl	34018b7c <memset>
  initValues.width = initConf->width;
34010b08:	6823      	ldr	r3, [r4, #0]
  if (is_camera_init != 0)
34010b0a:	4e22      	ldr	r6, [pc, #136]	@ (34010b94 <CMW_CAMERA_Init+0x9c>)
  initValues.width = initConf->width;
34010b0c:	9300      	str	r3, [sp, #0]
  initValues.height = initConf->height;
34010b0e:	6863      	ldr	r3, [r4, #4]
34010b10:	9301      	str	r3, [sp, #4]
  initValues.fps = initConf->fps;
34010b12:	68a3      	ldr	r3, [r4, #8]
34010b14:	9302      	str	r3, [sp, #8]
  initValues.pixel_format = initConf->pixel_format;
34010b16:	68e3      	ldr	r3, [r4, #12]
34010b18:	9303      	str	r3, [sp, #12]
  initValues.mirrorFlip = initConf->mirror_flip;
34010b1a:	6963      	ldr	r3, [r4, #20]
34010b1c:	9304      	str	r3, [sp, #16]
  if (is_camera_init != 0)
34010b1e:	6833      	ldr	r3, [r6, #0]
34010b20:	2b00      	cmp	r3, #0
34010b22:	d135      	bne.n	34010b90 <CMW_CAMERA_Init+0x98>
  hcamera_dcmipp.Instance = DCMIPP;
34010b24:	4d1c      	ldr	r5, [pc, #112]	@ (34010b98 <CMW_CAMERA_Init+0xa0>)
34010b26:	4b1d      	ldr	r3, [pc, #116]	@ (34010b9c <CMW_CAMERA_Init+0xa4>)
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
34010b28:	4628      	mov	r0, r5
  hcamera_dcmipp.Instance = DCMIPP;
34010b2a:	602b      	str	r3, [r5, #0]
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
34010b2c:	f7f1 fcc3 	bl	340024b6 <MX_DCMIPP_ClockConfig>
  if (ret != HAL_OK)
34010b30:	b118      	cbz	r0, 34010b3a <CMW_CAMERA_Init+0x42>
    return CMW_ERROR_PERIPH_FAILURE;
34010b32:	f06f 0003 	mvn.w	r0, #3
}
34010b36:	b014      	add	sp, #80	@ 0x50
34010b38:	bd70      	pop	{r4, r5, r6, pc}
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
34010b3a:	4628      	mov	r0, r5
34010b3c:	f7f4 f934 	bl	34004da8 <HAL_DCMIPP_Init>
  if (ret != HAL_OK)
34010b40:	2800      	cmp	r0, #0
34010b42:	d1f6      	bne.n	34010b32 <CMW_CAMERA_Init+0x3a>
  CMW_CAMERA_EnableGPIOs();
34010b44:	f7ff fe58 	bl	340107f8 <CMW_CAMERA_EnableGPIOs>
  ret = CMW_CAMERA_Probe_Sensor(&initValues, &detected_sensor);
34010b48:	4668      	mov	r0, sp
34010b4a:	f7ff fced 	bl	34010528 <CMW_CAMERA_Probe_Sensor.constprop.0>
  if (ret != CMW_ERROR_NONE)
34010b4e:	b110      	cbz	r0, 34010b56 <CMW_CAMERA_Init+0x5e>
    return CMW_ERROR_UNKNOWN_COMPONENT;
34010b50:	f06f 0006 	mvn.w	r0, #6
34010b54:	e7ef      	b.n	34010b36 <CMW_CAMERA_Init+0x3e>
  ret = CMW_CAMERA_GetSensorInfo(&info);
34010b56:	a805      	add	r0, sp, #20
34010b58:	f7ff ffba 	bl	34010ad0 <CMW_CAMERA_GetSensorInfo>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010b5c:	3005      	adds	r0, #5
34010b5e:	d0f7      	beq.n	34010b50 <CMW_CAMERA_Init+0x58>
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
34010b60:	9812      	ldr	r0, [sp, #72]	@ 0x48
34010b62:	f7ff ff93 	bl	34010a8c <CMW_CAMERA_SetExposure>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010b66:	3005      	adds	r0, #5
34010b68:	d0f2      	beq.n	34010b50 <CMW_CAMERA_Init+0x58>
  ret = CMW_CAMERA_SetGain(info.gain_min);
34010b6a:	9810      	ldr	r0, [sp, #64]	@ 0x40
34010b6c:	f7ff ff6c 	bl	34010a48 <CMW_CAMERA_SetGain>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010b70:	3005      	adds	r0, #5
34010b72:	d0ed      	beq.n	34010b50 <CMW_CAMERA_Init+0x58>
  initConf->width = initValues.width;
34010b74:	9b00      	ldr	r3, [sp, #0]
  camera_conf = *initConf;
34010b76:	4d0a      	ldr	r5, [pc, #40]	@ (34010ba0 <CMW_CAMERA_Init+0xa8>)
  initConf->width = initValues.width;
34010b78:	6023      	str	r3, [r4, #0]
  initConf->height = initValues.height ;
34010b7a:	9b01      	ldr	r3, [sp, #4]
34010b7c:	6063      	str	r3, [r4, #4]
  camera_conf = *initConf;
34010b7e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34010b80:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  is_camera_init++;
34010b82:	6833      	ldr	r3, [r6, #0]
  camera_conf = *initConf;
34010b84:	e894 0003 	ldmia.w	r4, {r0, r1}
34010b88:	e885 0003 	stmia.w	r5, {r0, r1}
  is_camera_init++;
34010b8c:	3301      	adds	r3, #1
34010b8e:	6033      	str	r3, [r6, #0]
    return CMW_ERROR_NONE;
34010b90:	2000      	movs	r0, #0
34010b92:	e7d0      	b.n	34010b36 <CMW_CAMERA_Init+0x3e>
34010b94:	34043d10 	.word	0x34043d10
34010b98:	34043eb8 	.word	0x34043eb8
34010b9c:	58002000 	.word	0x58002000
34010ba0:	34043f08 	.word	0x34043f08

34010ba4 <CMW_CAMERA_Run>:
  if(Camera_Drv.Run != NULL)
34010ba4:	4b03      	ldr	r3, [pc, #12]	@ (34010bb4 <CMW_CAMERA_Run+0x10>)
34010ba6:	68db      	ldr	r3, [r3, #12]
34010ba8:	b10b      	cbz	r3, 34010bae <CMW_CAMERA_Run+0xa>
      return Camera_Drv.Run(&camera_bsp);
34010baa:	4803      	ldr	r0, [pc, #12]	@ (34010bb8 <CMW_CAMERA_Run+0x14>)
34010bac:	4718      	bx	r3
}
34010bae:	4618      	mov	r0, r3
34010bb0:	4770      	bx	lr
34010bb2:	bf00      	nop
34010bb4:	34043e58 	.word	0x34043e58
34010bb8:	34043d14 	.word	0x34043d14

34010bbc <CMW_CAMERA_PIPE_VsyncEventCallback>:
__weak int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
34010bbc:	2000      	movs	r0, #0
34010bbe:	4770      	bx	lr

34010bc0 <HAL_DCMIPP_PIPE_VsyncEventCallback>:
  if(Camera_Drv.VsyncEventCallback != NULL)
34010bc0:	4b05      	ldr	r3, [pc, #20]	@ (34010bd8 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x18>)
{
34010bc2:	b510      	push	{r4, lr}
  if(Camera_Drv.VsyncEventCallback != NULL)
34010bc4:	691b      	ldr	r3, [r3, #16]
{
34010bc6:	460c      	mov	r4, r1
  if(Camera_Drv.VsyncEventCallback != NULL)
34010bc8:	b10b      	cbz	r3, 34010bce <HAL_DCMIPP_PIPE_VsyncEventCallback+0xe>
      Camera_Drv.VsyncEventCallback(&camera_bsp, Pipe);
34010bca:	4804      	ldr	r0, [pc, #16]	@ (34010bdc <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>)
34010bcc:	4798      	blx	r3
  CMW_CAMERA_PIPE_VsyncEventCallback(Pipe);
34010bce:	4620      	mov	r0, r4
34010bd0:	f7ff fff4 	bl	34010bbc <CMW_CAMERA_PIPE_VsyncEventCallback>
}
34010bd4:	bd10      	pop	{r4, pc}
34010bd6:	bf00      	nop
34010bd8:	34043e58 	.word	0x34043e58
34010bdc:	34043d14 	.word	0x34043d14

34010be0 <HAL_DCMIPP_PIPE_FrameEventCallback>:
  if(Camera_Drv.FrameEventCallback != NULL)
34010be0:	4b05      	ldr	r3, [pc, #20]	@ (34010bf8 <HAL_DCMIPP_PIPE_FrameEventCallback+0x18>)
{
34010be2:	b510      	push	{r4, lr}
  if(Camera_Drv.FrameEventCallback != NULL)
34010be4:	695b      	ldr	r3, [r3, #20]
{
34010be6:	460c      	mov	r4, r1
  if(Camera_Drv.FrameEventCallback != NULL)
34010be8:	b10b      	cbz	r3, 34010bee <HAL_DCMIPP_PIPE_FrameEventCallback+0xe>
      Camera_Drv.FrameEventCallback(&camera_bsp, Pipe);
34010bea:	4804      	ldr	r0, [pc, #16]	@ (34010bfc <HAL_DCMIPP_PIPE_FrameEventCallback+0x1c>)
34010bec:	4798      	blx	r3
  CMW_CAMERA_PIPE_FrameEventCallback(Pipe);
34010bee:	4620      	mov	r0, r4
34010bf0:	f7f0 ff40 	bl	34001a74 <CMW_CAMERA_PIPE_FrameEventCallback>
}
34010bf4:	bd10      	pop	{r4, pc}
34010bf6:	bf00      	nop
34010bf8:	34043e58 	.word	0x34043e58
34010bfc:	34043d14 	.word	0x34043d14

34010c00 <HAL_DCMIPP_MspInit>:
  WRITE_REG(RCC->APB5ENSR, Periphs);
34010c00:	2304      	movs	r3, #4
{
34010c02:	b530      	push	{r4, r5, lr}
34010c04:	4c1b      	ldr	r4, [pc, #108]	@ (34010c74 <HAL_DCMIPP_MspInit+0x74>)
34010c06:	b085      	sub	sp, #20
34010c08:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34010c0c:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010c10:	f504 5580 	add.w	r5, r4, #4096	@ 0x1000
  tmpreg = READ_REG(RCC->APB5ENR);
34010c14:	9203      	str	r2, [sp, #12]
  (void)tmpreg;
34010c16:	9a03      	ldr	r2, [sp, #12]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34010c18:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34010c1c:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
  HAL_NVIC_SetPriority(DCMIPP_IRQn, 0x07, 0);
34010c20:	2107      	movs	r1, #7
34010c22:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
34010c24:	9a02      	ldr	r2, [sp, #8]
34010c26:	2030      	movs	r0, #48	@ 0x30
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34010c28:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
34010c2c:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010c2e:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
34010c32:	f7f3 ff37 	bl	34004aa4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
34010c36:	2030      	movs	r0, #48	@ 0x30
34010c38:	f7f3 ff92 	bl	34004b60 <HAL_NVIC_EnableIRQ>
  WRITE_REG(RCC->APB5ENSR, Periphs);
34010c3c:	2340      	movs	r3, #64	@ 0x40
34010c3e:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34010c42:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  HAL_NVIC_SetPriority(CSI_IRQn, 0x07, 0);
34010c46:	2107      	movs	r1, #7
34010c48:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
34010c4a:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34010c4c:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34010c50:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
34010c54:	202f      	movs	r0, #47	@ 0x2f
34010c56:	9200      	str	r2, [sp, #0]
  (void)tmpreg;
34010c58:	9a00      	ldr	r2, [sp, #0]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34010c5a:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
34010c5e:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010c60:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
34010c64:	f7f3 ff1e 	bl	34004aa4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CSI_IRQn);
34010c68:	202f      	movs	r0, #47	@ 0x2f
}
34010c6a:	b005      	add	sp, #20
34010c6c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  HAL_NVIC_EnableIRQ(CSI_IRQn);
34010c70:	f7f3 bf76 	b.w	34004b60 <HAL_NVIC_EnableIRQ>
34010c74:	56028000 	.word	0x56028000

34010c78 <CMW_UTILS_get_dec_ratio_and_update>:

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
34010c78:	b508      	push	{r3, lr}
  int dec_ratio = 1;

  while (*ratio >= 8) {
34010c7a:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
  int dec_ratio = 1;
34010c7e:	2301      	movs	r3, #1
    dec_ratio *= 2;
    *ratio /= 2;
34010c80:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
  while (*ratio >= 8) {
34010c84:	edd0 7a00 	vldr	s15, [r0]
34010c88:	eef4 7ac7 	vcmpe.f32	s15, s14
34010c8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010c90:	da08      	bge.n	34010ca4 <CMW_UTILS_get_dec_ratio_and_update+0x2c>
  switch (dec_ratio) {
34010c92:	3b01      	subs	r3, #1
34010c94:	2b07      	cmp	r3, #7
34010c96:	d81a      	bhi.n	34010cce <CMW_UTILS_get_dec_ratio_and_update+0x56>
34010c98:	e8df f003 	tbb	[pc, r3]
34010c9c:	0f190a1f 	.word	0x0f190a1f
34010ca0:	14191919 	.word	0x14191919
    *ratio /= 2;
34010ca4:	ee67 7aa6 	vmul.f32	s15, s15, s13
    dec_ratio *= 2;
34010ca8:	005b      	lsls	r3, r3, #1
    *ratio /= 2;
34010caa:	edc0 7a00 	vstr	s15, [r0]
34010cae:	e7e9      	b.n	34010c84 <CMW_UTILS_get_dec_ratio_and_update+0xc>
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
34010cb0:	2900      	cmp	r1, #0
34010cb2:	bf0c      	ite	eq
34010cb4:	2002      	moveq	r0, #2
34010cb6:	2008      	movne	r0, #8
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
}
34010cb8:	bd08      	pop	{r3, pc}
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
34010cba:	2900      	cmp	r1, #0
34010cbc:	bf0c      	ite	eq
34010cbe:	2004      	moveq	r0, #4
34010cc0:	2010      	movne	r0, #16
34010cc2:	e7f9      	b.n	34010cb8 <CMW_UTILS_get_dec_ratio_and_update+0x40>
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
34010cc4:	2900      	cmp	r1, #0
34010cc6:	bf0c      	ite	eq
34010cc8:	2006      	moveq	r0, #6
34010cca:	2018      	movne	r0, #24
34010ccc:	e7f4      	b.n	34010cb8 <CMW_UTILS_get_dec_ratio_and_update+0x40>
    assert(0);
34010cce:	2177      	movs	r1, #119	@ 0x77
34010cd0:	4b03      	ldr	r3, [pc, #12]	@ (34010ce0 <CMW_UTILS_get_dec_ratio_and_update+0x68>)
34010cd2:	4a04      	ldr	r2, [pc, #16]	@ (34010ce4 <CMW_UTILS_get_dec_ratio_and_update+0x6c>)
34010cd4:	4804      	ldr	r0, [pc, #16]	@ (34010ce8 <CMW_UTILS_get_dec_ratio_and_update+0x70>)
34010cd6:	f006 fdef 	bl	340178b8 <__assert_func>
  switch (dec_ratio) {
34010cda:	2000      	movs	r0, #0
34010cdc:	e7ec      	b.n	34010cb8 <CMW_UTILS_get_dec_ratio_and_update+0x40>
34010cde:	bf00      	nop
34010ce0:	3401d1fc 	.word	0x3401d1fc
34010ce4:	34034f0e 	.word	0x34034f0e
34010ce8:	3401c887 	.word	0x3401c887

34010cec <CMW_UTILS_GetPipeConfig>:
{
34010cec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34010cee:	4614      	mov	r4, r2
34010cf0:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
34010cf4:	6867      	ldr	r7, [r4, #4]
  if (p_conf->mode == CMW_Aspect_ratio_crop)
34010cf6:	6992      	ldr	r2, [r2, #24]
  const float ratio_height = (float)cam_height / pipe_height;
34010cf8:	ee06 7a90 	vmov	s13, r7
{
34010cfc:	ee07 0a10 	vmov	s14, r0
34010d00:	ee07 1a90 	vmov	s15, r1
  const float ratio_height = (float)cam_height / pipe_height;
34010d04:	eeb8 5a66 	vcvt.f32.u32	s10, s13
  if (p_conf->mode == CMW_Aspect_ratio_crop)
34010d08:	2a00      	cmp	r2, #0
34010d0a:	f040 808e 	bne.w	34010e2a <CMW_UTILS_GetPipeConfig+0x13e>
  const float ratio_width = (float)cam_width / pipe_width ;
34010d0e:	edd4 6a00 	vldr	s13, [r4]
34010d12:	eeb8 6a47 	vcvt.f32.u32	s12, s14
34010d16:	eef8 4a66 	vcvt.f32.u32	s9, s13
  const float ratio_height = (float)cam_height / pipe_height;
34010d1a:	eef8 6a67 	vcvt.f32.u32	s13, s15
  const float ratio_width = (float)cam_width / pipe_width ;
34010d1e:	ee86 4a24 	vdiv.f32	s8, s12, s9
  const float ratio_height = (float)cam_height / pipe_height;
34010d22:	eec6 5a85 	vdiv.f32	s11, s13, s10
  const float ratio = MIN(ratio_width, ratio_height);
34010d26:	eeb4 4a65 	vcmp.f32	s8, s11
34010d2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010d2e:	bf48      	it	mi
34010d30:	eef0 5a44 	vmovmi.f32	s11, s8
  assert(ratio >= 1);
34010d34:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
34010d38:	eef4 5ac4 	vcmpe.f32	s11, s8
34010d3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010d40:	da05      	bge.n	34010d4e <CMW_UTILS_GetPipeConfig+0x62>
34010d42:	214f      	movs	r1, #79	@ 0x4f
34010d44:	4b4f      	ldr	r3, [pc, #316]	@ (34010e84 <CMW_UTILS_GetPipeConfig+0x198>)
34010d46:	4a50      	ldr	r2, [pc, #320]	@ (34010e88 <CMW_UTILS_GetPipeConfig+0x19c>)
  assert(ratio < 64);
34010d48:	4850      	ldr	r0, [pc, #320]	@ (34010e8c <CMW_UTILS_GetPipeConfig+0x1a0>)
34010d4a:	f006 fdb5 	bl	340178b8 <__assert_func>
34010d4e:	ed9f 4a50 	vldr	s8, [pc, #320]	@ 34010e90 <CMW_UTILS_GetPipeConfig+0x1a4>
34010d52:	eef4 5ac4 	vcmpe.f32	s11, s8
34010d56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010d5a:	d403      	bmi.n	34010d64 <CMW_UTILS_GetPipeConfig+0x78>
34010d5c:	2150      	movs	r1, #80	@ 0x50
34010d5e:	4b4d      	ldr	r3, [pc, #308]	@ (34010e94 <CMW_UTILS_GetPipeConfig+0x1a8>)
34010d60:	4a49      	ldr	r2, [pc, #292]	@ (34010e88 <CMW_UTILS_GetPipeConfig+0x19c>)
34010d62:	e7f1      	b.n	34010d48 <CMW_UTILS_GetPipeConfig+0x5c>
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010d64:	ee24 4aa5 	vmul.f32	s8, s9, s11
34010d68:	eeb4 6ac4 	vcmpe.f32	s12, s8
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010d6c:	ee65 5a25 	vmul.f32	s11, s10, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010d70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010d74:	eef4 6ae5 	vcmpe.f32	s13, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010d78:	bfcc      	ite	gt
34010d7a:	eebc 6ac4 	vcvtgt.u32.f32	s12, s8
34010d7e:	eebc 6ac6 	vcvtle.u32.f32	s12, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010d82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
34010d86:	4601      	mov	r1, r0
34010d88:	ee16 2a10 	vmov	r2, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010d8c:	bfcc      	ite	gt
34010d8e:	eefc 6ae5 	vcvtgt.u32.f32	s13, s11
34010d92:	eefc 6ae6 	vcvtle.u32.f32	s13, s13
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
34010d96:	3101      	adds	r1, #1
34010d98:	1a89      	subs	r1, r1, r2
34010d9a:	0849      	lsrs	r1, r1, #1
34010d9c:	6059      	str	r1, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010d9e:	ee17 1a90 	vmov	r1, s15
34010da2:	ee16 2a90 	vmov	r2, s13
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010da6:	ed83 6a03 	vstr	s12, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010daa:	edc3 6a02 	vstr	s13, [r3, #8]
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010dae:	eeb8 6a46 	vcvt.f32.u32	s12, s12
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010db2:	eef8 6a66 	vcvt.f32.u32	s13, s13
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010db6:	3101      	adds	r1, #1
34010db8:	1a89      	subs	r1, r1, r2
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
34010dba:	2200      	movs	r2, #0
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010dbc:	eec6 5a24 	vdiv.f32	s11, s12, s9
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010dc0:	ee86 7a85 	vdiv.f32	s14, s13, s10
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010dc4:	0849      	lsrs	r1, r1, #1
34010dc6:	6019      	str	r1, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
34010dc8:	611a      	str	r2, [r3, #16]

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
34010dca:	2100      	movs	r1, #0
34010dcc:	4668      	mov	r0, sp
34010dce:	ed8d 7a01 	vstr	s14, [sp, #4]
34010dd2:	edcd 5a00 	vstr	s11, [sp]
34010dd6:	f7ff ff4f 	bl	34010c78 <CMW_UTILS_get_dec_ratio_and_update>
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010dda:	2101      	movs	r1, #1
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
34010ddc:	6068      	str	r0, [r5, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010dde:	a801      	add	r0, sp, #4
34010de0:	f7ff ff4a 	bl	34010c78 <CMW_UTILS_get_dec_ratio_and_update>
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010de4:	ed9f 7a2c 	vldr	s14, [pc, #176]	@ 34010e98 <CMW_UTILS_GetPipeConfig+0x1ac>
34010de8:	eddd 7a00 	vldr	s15, [sp]
34010dec:	ee67 7a87 	vmul.f32	s15, s15, s14
34010df0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010df4:	6028      	str	r0, [r5, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010df6:	ee17 3a90 	vmov	r3, s15
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
34010dfa:	6820      	ldr	r0, [r4, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010dfc:	edc6 7a03 	vstr	s15, [r6, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
34010e00:	eddd 7a01 	vldr	s15, [sp, #4]
34010e04:	ee67 7a87 	vmul.f32	s15, s15, s14
34010e08:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34010e0c:	ee17 2a90 	vmov	r2, s15
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010e10:	4922      	ldr	r1, [pc, #136]	@ (34010e9c <CMW_UTILS_GetPipeConfig+0x1b0>)
  down->VRatio = (uint32_t) (8192 * ratio_height);
34010e12:	edc6 7a02 	vstr	s15, [r6, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010e16:	fbb1 f3f3 	udiv	r3, r1, r3
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
34010e1a:	fbb1 f1f2 	udiv	r1, r1, r2
  down->VSize = height;
34010e1e:	e9c6 7000 	strd	r7, r0, [r6]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010e22:	6173      	str	r3, [r6, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
34010e24:	6131      	str	r1, [r6, #16]
}
34010e26:	b003      	add	sp, #12
34010e28:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
34010e2a:	2a01      	cmp	r2, #1
34010e2c:	d10c      	bne.n	34010e48 <CMW_UTILS_GetPipeConfig+0x15c>
    ratio_width = (float)cam_width / p_conf->output_width;
34010e2e:	edd4 6a00 	vldr	s13, [r4]
34010e32:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34010e36:	eef8 6a66 	vcvt.f32.u32	s13, s13
34010e3a:	eec7 5a26 	vdiv.f32	s11, s14, s13
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010e3e:	eef8 7a67 	vcvt.f32.u32	s15, s15
34010e42:	ee87 7a85 	vdiv.f32	s14, s15, s10
34010e46:	e7c0      	b.n	34010dca <CMW_UTILS_GetPipeConfig+0xde>
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
34010e48:	2a02      	cmp	r2, #2
34010e4a:	d106      	bne.n	34010e5a <CMW_UTILS_GetPipeConfig+0x16e>
    ratio_height = (float) cam_height / p_conf->output_height;
34010e4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
34010e50:	ee87 7a85 	vdiv.f32	s14, s15, s10
    ratio_width = (float) ratio_height;
34010e54:	eef0 5a47 	vmov.f32	s11, s14
34010e58:	e7b7      	b.n	34010dca <CMW_UTILS_GetPipeConfig+0xde>
  crop->HSize = roi->width;
34010e5a:	69e1      	ldr	r1, [r4, #28]
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010e5c:	ed94 7a00 	vldr	s14, [r4]
34010e60:	ee07 1a90 	vmov	s15, r1
34010e64:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34010e68:	eef8 7a67 	vcvt.f32.u32	s15, s15
  crop->HStart = roi->offset_x;
34010e6c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  crop->VSize = roi->height;
34010e6e:	6a22      	ldr	r2, [r4, #32]
  crop->HStart = roi->offset_x;
34010e70:	6058      	str	r0, [r3, #4]
  crop->VStart = roi->offset_y;
34010e72:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010e74:	eec7 5a87 	vdiv.f32	s11, s15, s14
  crop->HSize = roi->width;
34010e78:	60d9      	str	r1, [r3, #12]
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010e7a:	ee07 2a90 	vmov	s15, r2
  crop->VSize = roi->height;
34010e7e:	609a      	str	r2, [r3, #8]
  crop->VStart = roi->offset_y;
34010e80:	6018      	str	r0, [r3, #0]
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010e82:	e7dc      	b.n	34010e3e <CMW_UTILS_GetPipeConfig+0x152>
34010e84:	3401c8da 	.word	0x3401c8da
34010e88:	34034f39 	.word	0x34034f39
34010e8c:	3401c887 	.word	0x3401c887
34010e90:	42800000 	.word	0x42800000
34010e94:	3401c8e5 	.word	0x3401c8e5
34010e98:	46000000 	.word	0x46000000
34010e9c:	007fffff 	.word	0x007fffff

34010ea0 <CMW_IMX335_FrameEventCallback>:
#endif
}

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
34010ea0:	4770      	bx	lr

34010ea2 <CMW_IMX335_ReadID>:
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
34010ea2:	3008      	adds	r0, #8
34010ea4:	f000 bef2 	b.w	34011c8c <IMX335_ReadID>

34010ea8 <CMW_IMX335_SetTestPattern>:
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
34010ea8:	3008      	adds	r0, #8
34010eaa:	f000 bffb 	b.w	34011ea4 <IMX335_SetTestPattern>
	...

34010eb0 <CMW_IMX335_GetSensorInfo>:
{
34010eb0:	b508      	push	{r3, lr}
34010eb2:	460b      	mov	r3, r1
  if ((io_ctx ==  NULL) || (info == NULL))
34010eb4:	b1b8      	cbz	r0, 34010ee6 <CMW_IMX335_GetSensorInfo+0x36>
34010eb6:	b1b1      	cbz	r1, 34010ee6 <CMW_IMX335_GetSensorInfo+0x36>
    strcpy(info->name, IMX335_NAME);
34010eb8:	4618      	mov	r0, r3
34010eba:	490c      	ldr	r1, [pc, #48]	@ (34010eec <CMW_IMX335_GetSensorInfo+0x3c>)
34010ebc:	f008 f8df 	bl	3401907e <strcpy>
  info->bayer_pattern = IMX335_BAYER_PATTERN;
34010ec0:	f44f 6220 	mov.w	r2, #2560	@ 0xa00
  info->height = IMX335_HEIGHT;
34010ec4:	f44f 6122 	mov.w	r1, #2592	@ 0xa20
  info->bayer_pattern = IMX335_BAYER_PATTERN;
34010ec8:	8402      	strh	r2, [r0, #32]
  info->height = IMX335_HEIGHT;
34010eca:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
    strcpy(info->name, IMX335_NAME);
34010ece:	4603      	mov	r3, r0
  info->height = IMX335_HEIGHT;
34010ed0:	e9c0 1209 	strd	r1, r2, [r0, #36]	@ 0x24
  info->gain_max = IMX335_GAIN_MAX;
34010ed4:	2000      	movs	r0, #0
34010ed6:	4a06      	ldr	r2, [pc, #24]	@ (34010ef0 <CMW_IMX335_GetSensorInfo+0x40>)
  info->exposure_min = IMX335_EXPOSURE_MIN;
34010ed8:	6358      	str	r0, [r3, #52]	@ 0x34
  info->gain_max = IMX335_GAIN_MAX;
34010eda:	e9c3 020b 	strd	r0, r2, [r3, #44]	@ 0x2c
  info->exposure_max = IMX335_EXPOSURE_MAX;
34010ede:	f248 12f2 	movw	r2, #33266	@ 0x81f2
34010ee2:	639a      	str	r2, [r3, #56]	@ 0x38
}
34010ee4:	bd08      	pop	{r3, pc}
    return CMW_ERROR_WRONG_PARAM;
34010ee6:	f06f 0001 	mvn.w	r0, #1
34010eea:	e7fb      	b.n	34010ee4 <CMW_IMX335_GetSensorInfo+0x34>
34010eec:	3401c8f0 	.word	0x3401c8f0
34010ef0:	00011940 	.word	0x00011940

34010ef4 <CMW_IMX335_SetMirrorFlip>:
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
34010ef4:	2903      	cmp	r1, #3
34010ef6:	bf28      	it	cs
34010ef8:	2103      	movcs	r1, #3
34010efa:	3008      	adds	r0, #8
34010efc:	f000 bfb8 	b.w	34011e70 <IMX335_MirrorFlipConfig>

34010f00 <CMW_IMX335_SetFramerate>:
  return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
34010f00:	3008      	adds	r0, #8
34010f02:	f000 bf89 	b.w	34011e18 <IMX335_SetFramerate>

34010f06 <CMW_IMX335_SetFrequency>:
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
34010f06:	3008      	adds	r0, #8
34010f08:	f000 bf62 	b.w	34011dd0 <IMX335_SetFrequency>

34010f0c <CMW_IMX335_SetExposure>:
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
34010f0c:	3008      	adds	r0, #8
34010f0e:	f000 bf0d 	b.w	34011d2c <IMX335_SetExposure>

34010f12 <CMW_IMX335_SetGain>:
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
34010f12:	3008      	adds	r0, #8
34010f14:	f000 bed2 	b.w	34011cbc <IMX335_SetGain>

34010f18 <CMW_IMX335_Run>:
{
34010f18:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f1a:	3030      	adds	r0, #48	@ 0x30
34010f1c:	f003 fa20 	bl	34014360 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
34010f20:	2800      	cmp	r0, #0
}
34010f22:	bf14      	ite	ne
34010f24:	f06f 0003 	mvnne.w	r0, #3
34010f28:	2000      	moveq	r0, #0
34010f2a:	bd08      	pop	{r3, pc}

34010f2c <CMW_IMX335_DeInit>:
{
34010f2c:	b510      	push	{r4, lr}
34010f2e:	4604      	mov	r4, r0
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f30:	3030      	adds	r0, #48	@ 0x30
34010f32:	f003 f95b 	bl	340141ec <ISP_DeInit>
  if (ret)
34010f36:	b110      	cbz	r0, 34010f3e <CMW_IMX335_DeInit+0x12>
    return CMW_ERROR_COMPONENT_FAILURE;
34010f38:	f06f 0004 	mvn.w	r0, #4
}
34010f3c:	bd10      	pop	{r4, pc}
  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34010f3e:	f104 0008 	add.w	r0, r4, #8
34010f42:	f000 fe9a 	bl	34011c7a <IMX335_DeInit>
  if (ret)
34010f46:	2800      	cmp	r0, #0
34010f48:	d0f8      	beq.n	34010f3c <CMW_IMX335_DeInit+0x10>
34010f4a:	e7f5      	b.n	34010f38 <CMW_IMX335_DeInit+0xc>

34010f4c <CMW_IMX335_Start>:
{
34010f4c:	b530      	push	{r4, r5, lr}
34010f4e:	b087      	sub	sp, #28
  ISP_StatAreaTypeDef isp_stat_area = {0};
34010f50:	ab02      	add	r3, sp, #8
{
34010f52:	4604      	mov	r4, r0
  ISP_StatAreaTypeDef isp_stat_area = {0};
34010f54:	2210      	movs	r2, #16
34010f56:	2100      	movs	r1, #0
34010f58:	4618      	mov	r0, r3
34010f5a:	f007 fe0f 	bl	34018b7c <memset>
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &isp_stat_area, &ISP_IQParamCacheInit_IMX335);
34010f5e:	4a0f      	ldr	r2, [pc, #60]	@ (34010f9c <CMW_IMX335_Start+0x50>)
34010f60:	f104 0530 	add.w	r5, r4, #48	@ 0x30
34010f64:	e9cd 0200 	strd	r0, r2, [sp]
34010f68:	f104 03b8 	add.w	r3, r4, #184	@ 0xb8
34010f6c:	2200      	movs	r2, #0
34010f6e:	4628      	mov	r0, r5
34010f70:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
34010f74:	f003 f8b0 	bl	340140d8 <ISP_Init>
  if (ret != ISP_OK)
34010f78:	b948      	cbnz	r0, 34010f8e <CMW_IMX335_Start+0x42>
  ret = ISP_Start(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010f7a:	4628      	mov	r0, r5
34010f7c:	f003 f948 	bl	34014210 <ISP_Start>
  if (ret != ISP_OK)
34010f80:	b940      	cbnz	r0, 34010f94 <CMW_IMX335_Start+0x48>
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34010f82:	f104 0008 	add.w	r0, r4, #8
34010f86:	f000 fe5b 	bl	34011c40 <IMX335_Start>
}
34010f8a:	b007      	add	sp, #28
34010f8c:	bd30      	pop	{r4, r5, pc}
    return CMW_ERROR_COMPONENT_FAILURE;
34010f8e:	f06f 0004 	mvn.w	r0, #4
34010f92:	e7fa      	b.n	34010f8a <CMW_IMX335_Start+0x3e>
      return CMW_ERROR_PERIPH_FAILURE;
34010f94:	f06f 0003 	mvn.w	r0, #3
34010f98:	e7f7      	b.n	34010f8a <CMW_IMX335_Start+0x3e>
34010f9a:	bf00      	nop
34010f9c:	34034f54 	.word	0x34034f54

34010fa0 <CMW_IMX335_Init>:
{
34010fa0:	b538      	push	{r3, r4, r5, lr}
  if (width == 2592 && height == 1944)
34010fa2:	e9d1 2300 	ldrd	r2, r3, [r1]
34010fa6:	f5b2 6f22 	cmp.w	r2, #2592	@ 0xa20
{
34010faa:	4605      	mov	r5, r0
34010fac:	460c      	mov	r4, r1
  if (width == 2592 && height == 1944)
34010fae:	d002      	beq.n	34010fb6 <CMW_IMX335_Init+0x16>
    return CMW_ERROR_WRONG_PARAM;
34010fb0:	f06f 0001 	mvn.w	r0, #1
}
34010fb4:	bd38      	pop	{r3, r4, r5, pc}
  if (width == 2592 && height == 1944)
34010fb6:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
34010fba:	d1f9      	bne.n	34010fb0 <CMW_IMX335_Init+0x10>
  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
34010fbc:	6909      	ldr	r1, [r1, #16]
34010fbe:	f7ff ff99 	bl	34010ef4 <CMW_IMX335_SetMirrorFlip>
  if (ret)
34010fc2:	2800      	cmp	r0, #0
34010fc4:	d1f4      	bne.n	34010fb0 <CMW_IMX335_Init+0x10>
  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
34010fc6:	2106      	movs	r1, #6
34010fc8:	68e2      	ldr	r2, [r4, #12]
34010fca:	f105 0008 	add.w	r0, r5, #8
34010fce:	f000 fe17 	bl	34011c00 <IMX335_Init>
    return CMW_ERROR_COMPONENT_FAILURE;
34010fd2:	2800      	cmp	r0, #0
34010fd4:	bf18      	it	ne
34010fd6:	f06f 0004 	mvnne.w	r0, #4
34010fda:	e7eb      	b.n	34010fb4 <CMW_IMX335_Init+0x14>

34010fdc <CMW_IMX335_VsyncEventCallback>:
  switch (pipe)
34010fdc:	2901      	cmp	r1, #1
{
34010fde:	b510      	push	{r4, lr}
  switch (pipe)
34010fe0:	d007      	beq.n	34010ff2 <CMW_IMX335_VsyncEventCallback+0x16>
34010fe2:	2902      	cmp	r1, #2
34010fe4:	d00f      	beq.n	34011006 <CMW_IMX335_VsyncEventCallback+0x2a>
34010fe6:	b999      	cbnz	r1, 34011010 <CMW_IMX335_VsyncEventCallback+0x34>
}
34010fe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010fec:	3030      	adds	r0, #48	@ 0x30
34010fee:	f003 b9cd 	b.w	3401438c <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010ff2:	f100 0430 	add.w	r4, r0, #48	@ 0x30
34010ff6:	4620      	mov	r0, r4
34010ff8:	f003 f9c4 	bl	34014384 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010ffc:	4620      	mov	r0, r4
}
34010ffe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
34011002:	f003 b9bd 	b.w	34014380 <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
34011006:	3030      	adds	r0, #48	@ 0x30
}
34011008:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401100c:	f003 b9bc 	b.w	34014388 <ISP_IncAncillaryFrameId>
}
34011010:	bd10      	pop	{r4, pc}
	...

34011014 <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
34011014:	b573      	push	{r0, r1, r4, r5, r6, lr}
34011016:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
34011018:	8803      	ldrh	r3, [r0, #0]
{
3401101a:	460d      	mov	r5, r1
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
3401101c:	8203      	strh	r3, [r0, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
3401101e:	f8d0 30e4 	ldr.w	r3, [r0, #228]	@ 0xe4
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;

  CMW_IMX335_PowerOn(io_ctx);

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
34011022:	3408      	adds	r4, #8
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
34011024:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
34011026:	f8d0 30e8 	ldr.w	r3, [r0, #232]	@ 0xe8
3401102a:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
3401102c:	f8d0 30f4 	ldr.w	r3, [r0, #244]	@ 0xf4
34011030:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
34011032:	f8d0 30f0 	ldr.w	r3, [r0, #240]	@ 0xf0
34011036:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
34011038:	f8d0 30ec 	ldr.w	r3, [r0, #236]	@ 0xec
3401103c:	6143      	str	r3, [r0, #20]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3401103e:	f8d0 30fc 	ldr.w	r3, [r0, #252]	@ 0xfc
34011042:	2000      	movs	r0, #0
34011044:	4798      	blx	r3
  io_ctx->Delay(100);
34011046:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401104a:	2064      	movs	r0, #100	@ 0x64
3401104c:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
3401104e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
34011052:	2000      	movs	r0, #0
34011054:	4798      	blx	r3
  io_ctx->Delay(100);
34011056:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401105a:	2064      	movs	r0, #100	@ 0x64
3401105c:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3401105e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
34011062:	2001      	movs	r0, #1
34011064:	4798      	blx	r3
  io_ctx->Delay(100);
34011066:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401106a:	2064      	movs	r0, #100	@ 0x64
3401106c:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
3401106e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
34011072:	2001      	movs	r0, #1
34011074:	4798      	blx	r3
  io_ctx->Delay(100);
34011076:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401107a:	2064      	movs	r0, #100	@ 0x64
3401107c:	4798      	blx	r3
  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
3401107e:	4621      	mov	r1, r4
34011080:	4620      	mov	r0, r4
34011082:	f000 fda1 	bl	34011bc8 <IMX335_RegisterBusIO>
  if (ret != IMX335_OK)
34011086:	4606      	mov	r6, r0
34011088:	b120      	cbz	r0, 34011094 <CMW_IMX335_Probe+0x80>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401108a:	f06f 0404 	mvn.w	r4, #4
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
  return ret;
}
3401108e:	4620      	mov	r0, r4
34011090:	b002      	add	sp, #8
34011092:	bd70      	pop	{r4, r5, r6, pc}
  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
34011094:	4620      	mov	r0, r4
34011096:	a901      	add	r1, sp, #4
34011098:	f000 fdf8 	bl	34011c8c <IMX335_ReadID>
  if (ret != IMX335_OK)
3401109c:	4604      	mov	r4, r0
3401109e:	2800      	cmp	r0, #0
340110a0:	d1f3      	bne.n	3401108a <CMW_IMX335_Probe+0x76>
  if (id != IMX335_CHIP_ID)
340110a2:	9b01      	ldr	r3, [sp, #4]
  memset(imx335_if, 0, sizeof(*imx335_if));
340110a4:	2248      	movs	r2, #72	@ 0x48
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
340110a6:	2b00      	cmp	r3, #0
340110a8:	bf08      	it	eq
340110aa:	4604      	moveq	r4, r0
  memset(imx335_if, 0, sizeof(*imx335_if));
340110ac:	4631      	mov	r1, r6
340110ae:	f105 0018 	add.w	r0, r5, #24
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
340110b2:	bf18      	it	ne
340110b4:	f06f 0406 	mvnne.w	r4, #6
  memset(imx335_if, 0, sizeof(*imx335_if));
340110b8:	f007 fd60 	bl	34018b7c <memset>
  imx335_if->Init = CMW_IMX335_Init;
340110bc:	4b0e      	ldr	r3, [pc, #56]	@ (340110f8 <CMW_IMX335_Probe+0xe4>)
340110be:	602b      	str	r3, [r5, #0]
  imx335_if->Start = CMW_IMX335_Start;
340110c0:	4b0e      	ldr	r3, [pc, #56]	@ (340110fc <CMW_IMX335_Probe+0xe8>)
340110c2:	60ab      	str	r3, [r5, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
340110c4:	4b0e      	ldr	r3, [pc, #56]	@ (34011100 <CMW_IMX335_Probe+0xec>)
340110c6:	606b      	str	r3, [r5, #4]
  imx335_if->Run = CMW_IMX335_Run;
340110c8:	4b0e      	ldr	r3, [pc, #56]	@ (34011104 <CMW_IMX335_Probe+0xf0>)
340110ca:	60eb      	str	r3, [r5, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
340110cc:	4b0e      	ldr	r3, [pc, #56]	@ (34011108 <CMW_IMX335_Probe+0xf4>)
340110ce:	612b      	str	r3, [r5, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
340110d0:	4b0e      	ldr	r3, [pc, #56]	@ (3401110c <CMW_IMX335_Probe+0xf8>)
340110d2:	616b      	str	r3, [r5, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
340110d4:	4b0e      	ldr	r3, [pc, #56]	@ (34011110 <CMW_IMX335_Probe+0xfc>)
340110d6:	61eb      	str	r3, [r5, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
340110d8:	4b0e      	ldr	r3, [pc, #56]	@ (34011114 <CMW_IMX335_Probe+0x100>)
340110da:	64ab      	str	r3, [r5, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
340110dc:	4b0e      	ldr	r3, [pc, #56]	@ (34011118 <CMW_IMX335_Probe+0x104>)
340110de:	64eb      	str	r3, [r5, #76]	@ 0x4c
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
340110e0:	4b0e      	ldr	r3, [pc, #56]	@ (3401111c <CMW_IMX335_Probe+0x108>)
340110e2:	642b      	str	r3, [r5, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
340110e4:	4b0e      	ldr	r3, [pc, #56]	@ (34011120 <CMW_IMX335_Probe+0x10c>)
340110e6:	646b      	str	r3, [r5, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
340110e8:	4b0e      	ldr	r3, [pc, #56]	@ (34011124 <CMW_IMX335_Probe+0x110>)
340110ea:	62eb      	str	r3, [r5, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
340110ec:	4b0e      	ldr	r3, [pc, #56]	@ (34011128 <CMW_IMX335_Probe+0x114>)
340110ee:	65ab      	str	r3, [r5, #88]	@ 0x58
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
340110f0:	4b0e      	ldr	r3, [pc, #56]	@ (3401112c <CMW_IMX335_Probe+0x118>)
340110f2:	65eb      	str	r3, [r5, #92]	@ 0x5c
  return ret;
340110f4:	e7cb      	b.n	3401108e <CMW_IMX335_Probe+0x7a>
340110f6:	bf00      	nop
340110f8:	34010fa1 	.word	0x34010fa1
340110fc:	34010f4d 	.word	0x34010f4d
34011100:	34010f2d 	.word	0x34010f2d
34011104:	34010f19 	.word	0x34010f19
34011108:	34010fdd 	.word	0x34010fdd
3401110c:	34010ea1 	.word	0x34010ea1
34011110:	34010ea3 	.word	0x34010ea3
34011114:	34010f13 	.word	0x34010f13
34011118:	34010f0d 	.word	0x34010f0d
3401111c:	34010f07 	.word	0x34010f07
34011120:	34010f01 	.word	0x34010f01
34011124:	34010ef5 	.word	0x34010ef5
34011128:	34010eb1 	.word	0x34010eb1
3401112c:	34010ea9 	.word	0x34010ea9

34011130 <CMW_VD55G1_Read32>:
static int CMW_VD55G1_Read32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t *value)
{
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011130:	2304      	movs	r3, #4
{
34011132:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011134:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011136:	f8d0 5080 	ldr.w	r5, [r0, #128]	@ 0x80
3401113a:	eb0d 0203 	add.w	r2, sp, r3
3401113e:	8800      	ldrh	r0, [r0, #0]
34011140:	47a8      	blx	r5
  if (ret)
34011142:	b908      	cbnz	r0, 34011148 <CMW_VD55G1_Read32+0x18>
    return ret;

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
34011144:	9b01      	ldr	r3, [sp, #4]
34011146:	6023      	str	r3, [r4, #0]

  return 0;
}
34011148:	b003      	add	sp, #12
3401114a:	bd30      	pop	{r4, r5, pc}

3401114c <VD55G1_ShutdownPin>:

static void VD55G1_ShutdownPin(struct VD55G1_Ctx *ctx, int value)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  p_ctx->ShutdownPin(value);
3401114c:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
34011150:	4608      	mov	r0, r1
34011152:	4718      	bx	r3

34011154 <VD55G1_Read8>:
}

static int VD55G1_Read8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *value)
{
34011154:	b410      	push	{r4}
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011156:	6f84      	ldr	r4, [r0, #120]	@ 0x78
34011158:	2301      	movs	r3, #1
3401115a:	46a4      	mov	ip, r4
3401115c:	f830 0c08 	ldrh.w	r0, [r0, #-8]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read8(p_ctx, addr, value);
}
34011160:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011164:	4760      	bx	ip

34011166 <VD55G1_Read16>:

static int VD55G1_Read16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t *value)
{
34011166:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
34011168:	2302      	movs	r3, #2
{
3401116a:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401116c:	6f85      	ldr	r5, [r0, #120]	@ 0x78
3401116e:	aa01      	add	r2, sp, #4
34011170:	f830 0c08 	ldrh.w	r0, [r0, #-8]
34011174:	47a8      	blx	r5
  if (ret)
34011176:	b910      	cbnz	r0, 3401117e <VD55G1_Read16+0x18>
  *value = (data[1] << 8) | data[0];
34011178:	f8bd 3004 	ldrh.w	r3, [sp, #4]
3401117c:	8023      	strh	r3, [r4, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read16(p_ctx, addr, value);
}
3401117e:	b003      	add	sp, #12
34011180:	bd30      	pop	{r4, r5, pc}

34011182 <VD55G1_Read32>:

static int VD55G1_Read32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t *value)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read32(p_ctx, addr, value);
34011182:	3808      	subs	r0, #8
34011184:	f7ff bfd4 	b.w	34011130 <CMW_VD55G1_Read32>

34011188 <VD55G1_Write8>:
}

static int VD55G1_Write8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t value)
{
34011188:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3401118a:	2301      	movs	r3, #1
3401118c:	6f44      	ldr	r4, [r0, #116]	@ 0x74
3401118e:	f88d 2007 	strb.w	r2, [sp, #7]
34011192:	f830 0c08 	ldrh.w	r0, [r0, #-8]
34011196:	f10d 0207 	add.w	r2, sp, #7
3401119a:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write8(p_ctx, addr, value);
}
3401119c:	b002      	add	sp, #8
3401119e:	bd10      	pop	{r4, pc}

340111a0 <VD55G1_Write16>:

static int VD55G1_Write16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t value)
{
340111a0:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
340111a2:	2302      	movs	r3, #2
340111a4:	6f44      	ldr	r4, [r0, #116]	@ 0x74
340111a6:	f8ad 2006 	strh.w	r2, [sp, #6]
340111aa:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340111ae:	f10d 0206 	add.w	r2, sp, #6
340111b2:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write16(p_ctx, addr, value);
}
340111b4:	b002      	add	sp, #8
340111b6:	bd10      	pop	{r4, pc}

340111b8 <VD55G1_Write32>:
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340111b8:	2304      	movs	r3, #4

static int VD55G1_Write32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t value)
{
340111ba:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340111bc:	6f44      	ldr	r4, [r0, #116]	@ 0x74
340111be:	9201      	str	r2, [sp, #4]
340111c0:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340111c4:	eb0d 0203 	add.w	r2, sp, r3
340111c8:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write32(p_ctx, addr, value);
}
340111ca:	b002      	add	sp, #8
340111cc:	bd10      	pop	{r4, pc}

340111ce <VD55G1_WriteArray>:

static int VD55G1_WriteArray(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
340111ce:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340111d2:	4680      	mov	r8, r0
340111d4:	460d      	mov	r5, r1
340111d6:	4616      	mov	r6, r2
340111d8:	461c      	mov	r4, r3
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
  const unsigned int chunk_size = 128;
  uint16_t sz;
  int ret;

  while (data_len) {
340111da:	b914      	cbnz	r4, 340111e2 <VD55G1_WriteArray+0x14>
    data_len -= sz;
    addr += sz;
    data += sz;
  }

  return 0;
340111dc:	4620      	mov	r0, r4
}
340111de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sz = MIN(data_len, chunk_size);
340111e2:	2c80      	cmp	r4, #128	@ 0x80
340111e4:	46a1      	mov	r9, r4
340111e6:	bf28      	it	cs
340111e8:	f04f 0980 	movcs.w	r9, #128	@ 0x80
340111ec:	fa1f fa89 	uxth.w	sl, r9
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
340111f0:	4653      	mov	r3, sl
340111f2:	4632      	mov	r2, r6
340111f4:	4629      	mov	r1, r5
340111f6:	f8d8 7074 	ldr.w	r7, [r8, #116]	@ 0x74
340111fa:	f838 0c08 	ldrh.w	r0, [r8, #-8]
340111fe:	47b8      	blx	r7
    if (ret)
34011200:	2800      	cmp	r0, #0
34011202:	d1ec      	bne.n	340111de <VD55G1_WriteArray+0x10>
    addr += sz;
34011204:	44aa      	add	sl, r5
    data_len -= sz;
34011206:	eba4 0409 	sub.w	r4, r4, r9
    addr += sz;
3401120a:	fa1f f58a 	uxth.w	r5, sl
    data += sz;
3401120e:	444e      	add	r6, r9
34011210:	e7e3      	b.n	340111da <VD55G1_WriteArray+0xc>

34011212 <VD55G1_Delay>:

static void VD55G1_Delay(struct VD55G1_Ctx *ctx, uint32_t delay_in_ms)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  p_ctx->Delay(delay_in_ms);
34011212:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
34011216:	4608      	mov	r0, r1
34011218:	4718      	bx	r3

3401121a <VD55G1_Log>:
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3401121a:	4770      	bx	lr

3401121c <CMW_VD55G1_GetSensorInfo>:
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
static int32_t CMW_VD55G1_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
  if ((io_ctx ==  NULL) || (info == NULL))
3401121c:	b140      	cbz	r0, 34011230 <CMW_VD55G1_GetSensorInfo+0x14>
3401121e:	b139      	cbz	r1, 34011230 <CMW_VD55G1_GetSensorInfo+0x14>
    return CMW_ERROR_WRONG_PARAM;
  }

  /* Return the default full resolution */
  info->width = VD55G1_MAX_WIDTH;
  info->height = VD55G1_MAX_HEIGHT;
34011220:	f44f 7249 	mov.w	r2, #804	@ 0x324
34011224:	f44f 7330 	mov.w	r3, #704	@ 0x2c0

  return CMW_ERROR_NONE;
34011228:	2000      	movs	r0, #0
  info->height = VD55G1_MAX_HEIGHT;
3401122a:	e9c1 2309 	strd	r2, r3, [r1, #36]	@ 0x24
  return CMW_ERROR_NONE;
3401122e:	4770      	bx	lr
    return CMW_ERROR_WRONG_PARAM;
34011230:	f06f 0001 	mvn.w	r0, #1
}
34011234:	4770      	bx	lr

34011236 <CMW_VD55G1_MirrorFlipConfig>:

static int32_t CMW_VD55G1_MirrorFlipConfig(void *io_ctx, uint32_t Config)
{
  int32_t ret = CMW_ERROR_NONE;

  switch (Config) {
34011236:	2903      	cmp	r1, #3
34011238:	d80d      	bhi.n	34011256 <CMW_VD55G1_MirrorFlipConfig+0x20>
3401123a:	e8df f001 	tbb	[pc, r1]
3401123e:	0602      	.short	0x0602
34011240:	0a08      	.short	0x0a08
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP_NONE);
34011242:	2100      	movs	r1, #0
      break;
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
      break;
    case CMW_MIRRORFLIP_FLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
34011244:	3008      	adds	r0, #8
34011246:	f001 bbd2 	b.w	340129ee <VD55G1_SetFlipMirrorMode>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_FLIP);
3401124a:	2101      	movs	r1, #1
3401124c:	e7fa      	b.n	34011244 <CMW_VD55G1_MirrorFlipConfig+0xe>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
3401124e:	2102      	movs	r1, #2
34011250:	e7f8      	b.n	34011244 <CMW_VD55G1_MirrorFlipConfig+0xe>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
34011252:	2103      	movs	r1, #3
34011254:	e7f6      	b.n	34011244 <CMW_VD55G1_MirrorFlipConfig+0xe>
    default:
      ret = CMW_ERROR_PERIPH_FAILURE;
  }

  return ret;
}
34011256:	f06f 0003 	mvn.w	r0, #3
3401125a:	4770      	bx	lr

3401125c <CMW_VD55G1_Stop>:
{
3401125c:	b508      	push	{r3, lr}
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401125e:	3008      	adds	r0, #8
34011260:	f001 fbbe 	bl	340129e0 <VD55G1_Stop>
    return CMW_ERROR_PERIPH_FAILURE;
34011264:	2800      	cmp	r0, #0
}
34011266:	bf18      	it	ne
34011268:	f06f 0003 	mvnne.w	r0, #3
3401126c:	bd08      	pop	{r3, pc}

3401126e <CMW_VD55G1_Start>:
{
3401126e:	b510      	push	{r4, lr}
  ret = VD55G1_Start(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011270:	f100 0408 	add.w	r4, r0, #8
34011274:	4620      	mov	r0, r4
34011276:	f001 f927 	bl	340124c8 <VD55G1_Start>
  if (ret) {
3401127a:	b120      	cbz	r0, 34011286 <CMW_VD55G1_Start+0x18>
    VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401127c:	4620      	mov	r0, r4
3401127e:	f001 f90f 	bl	340124a0 <VD55G1_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
34011282:	f06f 0003 	mvn.w	r0, #3
}
34011286:	bd10      	pop	{r4, pc}

34011288 <CMW_VD55G1_DeInit>:
{
34011288:	b538      	push	{r3, r4, r5, lr}
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401128a:	f100 0508 	add.w	r5, r0, #8
{
3401128e:	4604      	mov	r4, r0
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011290:	4628      	mov	r0, r5
34011292:	f001 fba5 	bl	340129e0 <VD55G1_Stop>
  if (ret)
34011296:	b110      	cbz	r0, 3401129e <CMW_VD55G1_DeInit+0x16>
    return CMW_ERROR_PERIPH_FAILURE;
34011298:	f06f 0003 	mvn.w	r0, #3
}
3401129c:	bd38      	pop	{r3, r4, r5, pc}
  ret = VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401129e:	4628      	mov	r0, r5
340112a0:	f001 f8fe 	bl	340124a0 <VD55G1_DeInit>
  if (ret)
340112a4:	2800      	cmp	r0, #0
340112a6:	d1f7      	bne.n	34011298 <CMW_VD55G1_DeInit+0x10>
  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 0;
340112a8:	f884 0070 	strb.w	r0, [r4, #112]	@ 0x70
  return CMW_ERROR_NONE;
340112ac:	e7f6      	b.n	3401129c <CMW_VD55G1_DeInit+0x14>
	...

340112b0 <CMW_VD55G1_Init>:
{
340112b0:	b530      	push	{r4, r5, lr}
340112b2:	4604      	mov	r4, r0
340112b4:	b08f      	sub	sp, #60	@ 0x3c
340112b6:	460d      	mov	r5, r1
  VD55G1_Config_t config = { 0 };
340112b8:	2234      	movs	r2, #52	@ 0x34
340112ba:	2100      	movs	r1, #0
340112bc:	a801      	add	r0, sp, #4
340112be:	f007 fc5d 	bl	34018b7c <memset>
  if (((CMW_VD55G1_t *)io_ctx)->IsInitialized)
340112c2:	f894 3070 	ldrb.w	r3, [r4, #112]	@ 0x70
340112c6:	bb63      	cbnz	r3, 34011322 <CMW_VD55G1_Init+0x72>
  config.frame_rate = initSensor->fps;
340112c8:	68ab      	ldr	r3, [r5, #8]
340112ca:	9303      	str	r3, [sp, #12]
  ret = CMW_VD55G1_GetResType(initSensor->width, initSensor->height, &config.resolution);
340112cc:	e9d5 2300 	ldrd	r2, r3, [r5]
  if (width == 320 && height == 240)
340112d0:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
340112d4:	d104      	bne.n	340112e0 <CMW_VD55G1_Init+0x30>
340112d6:	2bf0      	cmp	r3, #240	@ 0xf0
340112d8:	d00b      	beq.n	340112f2 <CMW_VD55G1_Init+0x42>
    return CMW_ERROR_WRONG_PARAM;
340112da:	f06f 0001 	mvn.w	r0, #1
340112de:	e021      	b.n	34011324 <CMW_VD55G1_Init+0x74>
  else if (width == 640 && height == 480)
340112e0:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
340112e4:	d120      	bne.n	34011328 <CMW_VD55G1_Init+0x78>
340112e6:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
340112ea:	d1f6      	bne.n	340112da <CMW_VD55G1_Init+0x2a>
    *res = VD55G1_RES_VGA_640_480;
340112ec:	2301      	movs	r3, #1
      *res = VD55G1_RES_FULL_804_704;
340112ee:	f88d 3008 	strb.w	r3, [sp, #8]
  config.ext_clock_freq_in_hz = ((CMW_VD55G1_t *)io_ctx)->ClockInHz;
340112f2:	6863      	ldr	r3, [r4, #4]
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
340112f4:	a901      	add	r1, sp, #4
  config.ext_clock_freq_in_hz = ((CMW_VD55G1_t *)io_ctx)->ClockInHz;
340112f6:	9301      	str	r3, [sp, #4]
  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
340112f8:	692b      	ldr	r3, [r5, #16]
  config.out_itf.clock_lane_swap_enable = 1;
340112fa:	2501      	movs	r5, #1
  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
340112fc:	2b03      	cmp	r3, #3
340112fe:	bf28      	it	cs
34011300:	2303      	movcs	r3, #3
34011302:	f88d 3010 	strb.w	r3, [sp, #16]
  config.out_itf.clock_lane_swap_enable = 1;
34011306:	4b12      	ldr	r3, [pc, #72]	@ (34011350 <CMW_VD55G1_Init+0xa0>)
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
34011308:	f104 0008 	add.w	r0, r4, #8
  config.out_itf.clock_lane_swap_enable = 1;
3401130c:	e9cd 3505 	strd	r3, r5, [sp, #20]
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
34011310:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
  config.out_itf.data_lane_swap_enable = 1;
34011314:	9507      	str	r5, [sp, #28]
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
34011316:	930d      	str	r3, [sp, #52]	@ 0x34
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
34011318:	f000 ffbe 	bl	34012298 <VD55G1_Init>
  if (ret)
3401131c:	b9a0      	cbnz	r0, 34011348 <CMW_VD55G1_Init+0x98>
  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 1;
3401131e:	f884 5070 	strb.w	r5, [r4, #112]	@ 0x70
    return CMW_ERROR_NONE;
34011322:	2000      	movs	r0, #0
}
34011324:	b00f      	add	sp, #60	@ 0x3c
34011326:	bd30      	pop	{r4, r5, pc}
  else if (width == 800 && height == 600)
34011328:	f5b2 7f48 	cmp.w	r2, #800	@ 0x320
3401132c:	d104      	bne.n	34011338 <CMW_VD55G1_Init+0x88>
3401132e:	f5b3 7f16 	cmp.w	r3, #600	@ 0x258
34011332:	d1d2      	bne.n	340112da <CMW_VD55G1_Init+0x2a>
    *res = VD55G1_RES_SXGA_800_600;
34011334:	2302      	movs	r3, #2
34011336:	e7da      	b.n	340112ee <CMW_VD55G1_Init+0x3e>
  else if (width == 804 && height == 704)
34011338:	f5b2 7f49 	cmp.w	r2, #804	@ 0x324
3401133c:	d1cd      	bne.n	340112da <CMW_VD55G1_Init+0x2a>
3401133e:	f5b3 7f30 	cmp.w	r3, #704	@ 0x2c0
34011342:	d1ca      	bne.n	340112da <CMW_VD55G1_Init+0x2a>
      *res = VD55G1_RES_FULL_804_704;
34011344:	2303      	movs	r3, #3
34011346:	e7d2      	b.n	340112ee <CMW_VD55G1_Init+0x3e>
    return CMW_ERROR_PERIPH_FAILURE;
34011348:	f06f 0003 	mvn.w	r0, #3
3401134c:	e7ea      	b.n	34011324 <CMW_VD55G1_Init+0x74>
3401134e:	bf00      	nop
34011350:	2fec1100 	.word	0x2fec1100

34011354 <CMW_VD55G1_Probe>:
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
}

int CMW_VD55G1_Probe(CMW_VD55G1_t *io_ctx, CMW_Sensor_if_t *vd55g1_if)
{
34011354:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011356:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
34011358:	4b26      	ldr	r3, [pc, #152]	@ (340113f4 <CMW_VD55G1_Probe+0xa0>)
{
3401135a:	460d      	mov	r5, r1
  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
3401135c:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.read8 = VD55G1_Read8;
3401135e:	4b26      	ldr	r3, [pc, #152]	@ (340113f8 <CMW_VD55G1_Probe+0xa4>)
34011360:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.read16 = VD55G1_Read16;
34011362:	4b26      	ldr	r3, [pc, #152]	@ (340113fc <CMW_VD55G1_Probe+0xa8>)
34011364:	6103      	str	r3, [r0, #16]
  io_ctx->ctx_driver.read32 = VD55G1_Read32;
34011366:	4b26      	ldr	r3, [pc, #152]	@ (34011400 <CMW_VD55G1_Probe+0xac>)
34011368:	6143      	str	r3, [r0, #20]
  io_ctx->ctx_driver.write8 = VD55G1_Write8;
3401136a:	4b26      	ldr	r3, [pc, #152]	@ (34011404 <CMW_VD55G1_Probe+0xb0>)
3401136c:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.write16 = VD55G1_Write16;
3401136e:	4b26      	ldr	r3, [pc, #152]	@ (34011408 <CMW_VD55G1_Probe+0xb4>)
34011370:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.write32 = VD55G1_Write32;
34011372:	4b26      	ldr	r3, [pc, #152]	@ (3401140c <CMW_VD55G1_Probe+0xb8>)
34011374:	6203      	str	r3, [r0, #32]
  io_ctx->ctx_driver.write_array = VD55G1_WriteArray;
34011376:	4b26      	ldr	r3, [pc, #152]	@ (34011410 <CMW_VD55G1_Probe+0xbc>)
34011378:	6243      	str	r3, [r0, #36]	@ 0x24
  io_ctx->ctx_driver.delay = VD55G1_Delay;
3401137a:	4b26      	ldr	r3, [pc, #152]	@ (34011414 <CMW_VD55G1_Probe+0xc0>)
3401137c:	6283      	str	r3, [r0, #40]	@ 0x28
  io_ctx->ctx_driver.log = VD55G1_Log;
3401137e:	4b26      	ldr	r3, [pc, #152]	@ (34011418 <CMW_VD55G1_Probe+0xc4>)
34011380:	62c3      	str	r3, [r0, #44]	@ 0x2c
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34011382:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
34011386:	2000      	movs	r0, #0
34011388:	4798      	blx	r3
  io_ctx->Delay(200); /* NRST signals asserted during 200ms */
3401138a:	20c8      	movs	r0, #200	@ 0xc8
3401138c:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
34011390:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34011392:	2001      	movs	r0, #1
34011394:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
34011398:	4798      	blx	r3
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
3401139a:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3401139e:	2014      	movs	r0, #20
340113a0:	4798      	blx	r3
  if (!io_ctx->Init)
340113a2:	6f63      	ldr	r3, [r4, #116]	@ 0x74
340113a4:	b923      	cbnz	r3, 340113b0 <CMW_VD55G1_Probe+0x5c>
  CMW_VD55G1_PowerOn(io_ctx);

  ret = VD55G1_RegisterBusIO(io_ctx);
  if (ret != CMW_ERROR_NONE)
  {
    return CMW_ERROR_COMPONENT_FAILURE;
340113a6:	f06f 0404 	mvn.w	r4, #4
  vd55g1_if->Start = CMW_VD55G1_Start;
  vd55g1_if->Stop = CMW_VD55G1_Stop;
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
  return ret;
}
340113aa:	4620      	mov	r0, r4
340113ac:	b003      	add	sp, #12
340113ae:	bd30      	pop	{r4, r5, pc}
  ret = io_ctx->Init();
340113b0:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
340113b2:	4601      	mov	r1, r0
340113b4:	2800      	cmp	r0, #0
340113b6:	d1f6      	bne.n	340113a6 <CMW_VD55G1_Probe+0x52>
  ret = CMW_VD55G1_Read32(io_ctx, VD55G1_REG_MODEL_ID, &reg32);
340113b8:	4620      	mov	r0, r4
340113ba:	aa01      	add	r2, sp, #4
340113bc:	f7ff feb8 	bl	34011130 <CMW_VD55G1_Read32>
  if (ret)
340113c0:	4604      	mov	r4, r0
340113c2:	2800      	cmp	r0, #0
340113c4:	d1ef      	bne.n	340113a6 <CMW_VD55G1_Probe+0x52>
  if (id != VD55G1_CHIP_ID)
340113c6:	9a01      	ldr	r2, [sp, #4]
340113c8:	4b14      	ldr	r3, [pc, #80]	@ (3401141c <CMW_VD55G1_Probe+0xc8>)
340113ca:	429a      	cmp	r2, r3
340113cc:	d1eb      	bne.n	340113a6 <CMW_VD55G1_Probe+0x52>
  memset(vd55g1_if, 0, sizeof(*vd55g1_if));
340113ce:	4601      	mov	r1, r0
340113d0:	2254      	movs	r2, #84	@ 0x54
340113d2:	f105 000c 	add.w	r0, r5, #12
340113d6:	f007 fbd1 	bl	34018b7c <memset>
  vd55g1_if->Init = CMW_VD55G1_Init;
340113da:	4b11      	ldr	r3, [pc, #68]	@ (34011420 <CMW_VD55G1_Probe+0xcc>)
340113dc:	602b      	str	r3, [r5, #0]
  vd55g1_if->DeInit = CMW_VD55G1_DeInit;
340113de:	4b11      	ldr	r3, [pc, #68]	@ (34011424 <CMW_VD55G1_Probe+0xd0>)
340113e0:	606b      	str	r3, [r5, #4]
  vd55g1_if->Start = CMW_VD55G1_Start;
340113e2:	4b11      	ldr	r3, [pc, #68]	@ (34011428 <CMW_VD55G1_Probe+0xd4>)
340113e4:	60ab      	str	r3, [r5, #8]
  vd55g1_if->Stop = CMW_VD55G1_Stop;
340113e6:	4b11      	ldr	r3, [pc, #68]	@ (3401142c <CMW_VD55G1_Probe+0xd8>)
340113e8:	61ab      	str	r3, [r5, #24]
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
340113ea:	4b11      	ldr	r3, [pc, #68]	@ (34011430 <CMW_VD55G1_Probe+0xdc>)
340113ec:	62eb      	str	r3, [r5, #44]	@ 0x2c
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
340113ee:	4b11      	ldr	r3, [pc, #68]	@ (34011434 <CMW_VD55G1_Probe+0xe0>)
340113f0:	65ab      	str	r3, [r5, #88]	@ 0x58
  return ret;
340113f2:	e7da      	b.n	340113aa <CMW_VD55G1_Probe+0x56>
340113f4:	3401114d 	.word	0x3401114d
340113f8:	34011155 	.word	0x34011155
340113fc:	34011167 	.word	0x34011167
34011400:	34011183 	.word	0x34011183
34011404:	34011189 	.word	0x34011189
34011408:	340111a1 	.word	0x340111a1
3401140c:	340111b9 	.word	0x340111b9
34011410:	340111cf 	.word	0x340111cf
34011414:	34011213 	.word	0x34011213
34011418:	3401121b 	.word	0x3401121b
3401141c:	53354731 	.word	0x53354731
34011420:	340112b1 	.word	0x340112b1
34011424:	34011289 	.word	0x34011289
34011428:	3401126f 	.word	0x3401126f
3401142c:	3401125d 	.word	0x3401125d
34011430:	34011237 	.word	0x34011237
34011434:	3401121d 	.word	0x3401121d

34011438 <CMW_VD66GY_Read16>:
{
  return pObj->ReadReg(pObj->Address, addr, value, 1);
}

static int CMW_VD66GY_Read16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t *value)
{
34011438:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401143a:	2302      	movs	r3, #2
{
3401143c:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401143e:	f8d0 5130 	ldr.w	r5, [r0, #304]	@ 0x130
34011442:	aa01      	add	r2, sp, #4
34011444:	8800      	ldrh	r0, [r0, #0]
34011446:	47a8      	blx	r5
  if (ret)
34011448:	b910      	cbnz	r0, 34011450 <CMW_VD66GY_Read16+0x18>
    return ret;

  *value = (data[1] << 8) | data[0];
3401144a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
3401144e:	8023      	strh	r3, [r4, #0]

  return CMW_ERROR_NONE;
}
34011450:	b003      	add	sp, #12
34011452:	bd30      	pop	{r4, r5, pc}

34011454 <VD6G_ShutdownPin>:

static void VD6G_ShutdownPin(struct VD6G_Ctx *ctx, int value)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  p_ctx->ShutdownPin(value);
34011454:	f8d0 3134 	ldr.w	r3, [r0, #308]	@ 0x134
34011458:	4608      	mov	r0, r1
3401145a:	4718      	bx	r3

3401145c <VD6G_Read8>:
}

static int VD6G_Read8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *value)
{
3401145c:	b410      	push	{r4}
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3401145e:	f8d0 4128 	ldr.w	r4, [r0, #296]	@ 0x128
34011462:	2301      	movs	r3, #1
34011464:	46a4      	mov	ip, r4
34011466:	f830 0c08 	ldrh.w	r0, [r0, #-8]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read8(p_ctx, addr, value);
}
3401146a:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3401146e:	4760      	bx	ip

34011470 <VD6G_Read16>:

static int VD6G_Read16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t *value)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read16(p_ctx, addr, value);
34011470:	3808      	subs	r0, #8
34011472:	f7ff bfe1 	b.w	34011438 <CMW_VD66GY_Read16>

34011476 <VD6G_Read32>:
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011476:	2304      	movs	r3, #4
}

static int VD6G_Read32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t *value)
{
34011478:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401147a:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3401147c:	f8d0 5128 	ldr.w	r5, [r0, #296]	@ 0x128
34011480:	eb0d 0203 	add.w	r2, sp, r3
34011484:	f830 0c08 	ldrh.w	r0, [r0, #-8]
34011488:	47a8      	blx	r5
  if (ret)
3401148a:	b908      	cbnz	r0, 34011490 <VD6G_Read32+0x1a>
  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
3401148c:	9b01      	ldr	r3, [sp, #4]
3401148e:	6023      	str	r3, [r4, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read32(p_ctx, addr, value);
}
34011490:	b003      	add	sp, #12
34011492:	bd30      	pop	{r4, r5, pc}

34011494 <VD6G_Write8>:

static int VD6G_Write8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t value)
{
34011494:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
34011496:	2301      	movs	r3, #1
34011498:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
3401149c:	f88d 2007 	strb.w	r2, [sp, #7]
340114a0:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340114a4:	f10d 0207 	add.w	r2, sp, #7
340114a8:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write8(p_ctx, addr, value);
}
340114aa:	b002      	add	sp, #8
340114ac:	bd10      	pop	{r4, pc}

340114ae <VD6G_Write16>:

static int VD6G_Write16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t value)
{
340114ae:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
340114b0:	2302      	movs	r3, #2
340114b2:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
340114b6:	f8ad 2006 	strh.w	r2, [sp, #6]
340114ba:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340114be:	f10d 0206 	add.w	r2, sp, #6
340114c2:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write16(p_ctx, addr, value);
}
340114c4:	b002      	add	sp, #8
340114c6:	bd10      	pop	{r4, pc}

340114c8 <VD6G_Write32>:
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340114c8:	2304      	movs	r3, #4

static int VD6G_Write32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t value)
{
340114ca:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340114cc:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
340114d0:	9201      	str	r2, [sp, #4]
340114d2:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340114d6:	eb0d 0203 	add.w	r2, sp, r3
340114da:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write32(p_ctx, addr, value);
}
340114dc:	b002      	add	sp, #8
340114de:	bd10      	pop	{r4, pc}

340114e0 <VD6G_WriteArray>:

static int VD6G_WriteArray(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
340114e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340114e4:	4680      	mov	r8, r0
340114e6:	460d      	mov	r5, r1
340114e8:	4616      	mov	r6, r2
340114ea:	461c      	mov	r4, r3
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
  const unsigned int chunk_size = 128;
  uint16_t sz;
  int ret;

  while (data_len) {
340114ec:	b914      	cbnz	r4, 340114f4 <VD6G_WriteArray+0x14>
    data_len -= sz;
    addr += sz;
    data += sz;
  }

  return 0;
340114ee:	4620      	mov	r0, r4
}
340114f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sz = MIN(data_len, chunk_size);
340114f4:	2c80      	cmp	r4, #128	@ 0x80
340114f6:	46a1      	mov	r9, r4
340114f8:	bf28      	it	cs
340114fa:	f04f 0980 	movcs.w	r9, #128	@ 0x80
340114fe:	fa1f fa89 	uxth.w	sl, r9
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
34011502:	4653      	mov	r3, sl
34011504:	4632      	mov	r2, r6
34011506:	4629      	mov	r1, r5
34011508:	f8d8 7124 	ldr.w	r7, [r8, #292]	@ 0x124
3401150c:	f838 0c08 	ldrh.w	r0, [r8, #-8]
34011510:	47b8      	blx	r7
    if (ret)
34011512:	2800      	cmp	r0, #0
34011514:	d1ec      	bne.n	340114f0 <VD6G_WriteArray+0x10>
    addr += sz;
34011516:	44aa      	add	sl, r5
    data_len -= sz;
34011518:	eba4 0409 	sub.w	r4, r4, r9
    addr += sz;
3401151c:	fa1f f58a 	uxth.w	r5, sl
    data += sz;
34011520:	444e      	add	r6, r9
34011522:	e7e3      	b.n	340114ec <VD6G_WriteArray+0xc>

34011524 <VD6G_Delay>:

static void VD6G_Delay(struct VD6G_Ctx *ctx, uint32_t delay_in_ms)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  p_ctx->Delay(delay_in_ms);
34011524:	f8d0 3130 	ldr.w	r3, [r0, #304]	@ 0x130
34011528:	4608      	mov	r0, r1
3401152a:	4718      	bx	r3

3401152c <VD6G_Log>:
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3401152c:	4770      	bx	lr

3401152e <CMW_VD66GY_FrameEventCallback>:
#endif
}

static void CMW_VD66GY_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
3401152e:	4770      	bx	lr

34011530 <CMW_VD66GY_SetGain>:
{
34011530:	b5f0      	push	{r4, r5, r6, r7, lr}
34011532:	ed2d 8b08 	vpush	{d8-d11}
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
34011536:	f100 0608 	add.w	r6, r0, #8
{
3401153a:	b085      	sub	sp, #20
3401153c:	460d      	mov	r5, r1
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3401153e:	4630      	mov	r0, r6
34011540:	f10d 020b 	add.w	r2, sp, #11
34011544:	f10d 010a 	add.w	r1, sp, #10
34011548:	f002 f858 	bl	340135fc <VD6G_GetAnalogGainRegRange>
  if (ret)
3401154c:	2800      	cmp	r0, #0
3401154e:	f040 80bc 	bne.w	340116ca <CMW_VD66GY_SetGain+0x19a>
  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
34011552:	4630      	mov	r0, r6
34011554:	f10d 020e 	add.w	r2, sp, #14
34011558:	a903      	add	r1, sp, #12
3401155a:	f002 f8bb 	bl	340136d4 <VD6G_GetDigitalGainRegRange>
  if (ret)
3401155e:	2800      	cmp	r0, #0
34011560:	f040 80b3 	bne.w	340116ca <CMW_VD66GY_SetGain+0x19a>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011564:	2420      	movs	r4, #32
34011566:	f89d 300a 	ldrb.w	r3, [sp, #10]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401156a:	eeb3 ab04 	vmov.f64	d10, #52	@ 0x41a00000  20.0
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401156e:	f1c3 0320 	rsb	r3, r3, #32
34011572:	fb94 f3f3 	sdiv	r3, r4, r3
34011576:	ee00 3a10 	vmov	s0, r3
3401157a:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
3401157e:	f009 fbab 	bl	3401acd8 <log10>
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011582:	f89d 300b 	ldrb.w	r3, [sp, #11]
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011586:	eeb0 8b40 	vmov.f64	d8, d0
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401158a:	1ae3      	subs	r3, r4, r3
3401158c:	fb94 f3f3 	sdiv	r3, r4, r3
34011590:	ee00 3a10 	vmov	s0, r3
34011594:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
34011598:	f009 fb9e 	bl	3401acd8 <log10>
3401159c:	ed9f bb58 	vldr	d11, [pc, #352]	@ 34011700 <CMW_VD66GY_SetGain+0x1d0>
340115a0:	ee20 0b0a 	vmul.f64	d0, d0, d10
340115a4:	ee20 0b0b 	vmul.f64	d0, d0, d11
340115a8:	eefc 7bc0 	vcvt.u32.f64	s15, d0
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340115ac:	f8bd 300c 	ldrh.w	r3, [sp, #12]
340115b0:	f89d 200c 	ldrb.w	r2, [sp, #12]
340115b4:	0a1b      	lsrs	r3, r3, #8
340115b6:	ee00 3a10 	vmov	s0, r3
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340115ba:	ee17 7a90 	vmov	r7, s15
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340115be:	ee07 2a90 	vmov	s15, r2
340115c2:	ed9f 9a55 	vldr	s18, [pc, #340]	@ 34011718 <CMW_VD66GY_SetGain+0x1e8>
340115c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340115ca:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
340115ce:	eea7 0a89 	vfma.f32	s0, s15, s18
340115d2:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340115d6:	f009 fb7f 	bl	3401acd8 <log10>
340115da:	ee20 0b0a 	vmul.f64	d0, d0, d10
340115de:	ee20 0b0b 	vmul.f64	d0, d0, d11
340115e2:	eefc 7bc0 	vcvt.u32.f64	s15, d0
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340115e6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
340115ea:	f89d 200e 	ldrb.w	r2, [sp, #14]
340115ee:	0a1b      	lsrs	r3, r3, #8
340115f0:	ee00 3a10 	vmov	s0, r3
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340115f4:	ee17 4a90 	vmov	r4, s15
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340115f8:	ee07 2a90 	vmov	s15, r2
340115fc:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
34011600:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34011604:	eea7 0a89 	vfma.f32	s0, s15, s18
34011608:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
3401160c:	f009 fb64 	bl	3401acd8 <log10>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011610:	ee28 8b0a 	vmul.f64	d8, d8, d10
34011614:	ee28 8b0b 	vmul.f64	d8, d8, d11
34011618:	eebc 8bc8 	vcvt.u32.f64	s16, d8
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3401161c:	ee20 0b0a 	vmul.f64	d0, d0, d10
  if ((gain < dgain_min_mdB + again_min_mdB)
34011620:	ee18 3a10 	vmov	r3, s16
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011624:	ee20 0b0b 	vmul.f64	d0, d0, d11
  if ((gain < dgain_min_mdB + again_min_mdB)
34011628:	4423      	add	r3, r4
3401162a:	42ab      	cmp	r3, r5
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3401162c:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  if ((gain < dgain_min_mdB + again_min_mdB)
34011630:	d861      	bhi.n	340116f6 <CMW_VD66GY_SetGain+0x1c6>
      || (gain > dgain_max_mdB + again_max_mdB))
34011632:	ee10 3a10 	vmov	r3, s0
34011636:	443b      	add	r3, r7
34011638:	429d      	cmp	r5, r3
3401163a:	d85c      	bhi.n	340116f6 <CMW_VD66GY_SetGain+0x1c6>
  if (gain <= again_max_mdB)
3401163c:	42bd      	cmp	r5, r7
3401163e:	d848      	bhi.n	340116d2 <CMW_VD66GY_SetGain+0x1a2>
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
34011640:	1b2d      	subs	r5, r5, r4
34011642:	ee07 5a90 	vmov	s15, r5
34011646:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401164a:	ee87 1b0b 	vdiv.f64	d1, d7, d11
3401164e:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
34011652:	ee81 1b0a 	vdiv.f64	d1, d1, d10
34011656:	f009 fc47 	bl	3401aee8 <pow>
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)dgain_min_mdB);
3401165a:	ee07 4a90 	vmov	s15, r4
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
3401165e:	eeb0 9b40 	vmov.f64	d9, d0
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
34011662:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34011666:	ee87 1b0b 	vdiv.f64	d1, d7, d11
3401166a:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3401166e:	ee81 1b0a 	vdiv.f64	d1, d1, d10
34011672:	f009 fc39 	bl	3401aee8 <pow>
  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
34011676:	ed9f 7b24 	vldr	d7, [pc, #144]	@ 34011708 <CMW_VD66GY_SetGain+0x1d8>
3401167a:	ee87 6b09 	vdiv.f64	d6, d7, d9
3401167e:	ee37 7b46 	vsub.f64	d7, d7, d6
34011682:	eefd 7bc7 	vcvt.s32.f64	s15, d7
34011686:	4630      	mov	r0, r6
34011688:	ee17 1a90 	vmov	r1, s15
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
3401168c:	eeb0 8b40 	vmov.f64	d8, d0
  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
34011690:	f001 fff0 	bl	34013674 <VD6G_SetAnalogGain>
  if (ret)
34011694:	b9c8      	cbnz	r0, 340116ca <CMW_VD66GY_SetGain+0x19a>
  ret = VD6G_SetDigitalGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, FLOAT_TO_FP58(digital_linear_gain));
34011696:	eefc 7bc8 	vcvt.u32.f64	s15, d8
3401169a:	ee17 3a90 	vmov	r3, s15
3401169e:	b299      	uxth	r1, r3
340116a0:	ee07 1a90 	vmov	s15, r1
340116a4:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340116a8:	ee38 8b47 	vsub.f64	d8, d8, d7
340116ac:	ed9f 7b18 	vldr	d7, [pc, #96]	@ 34011710 <CMW_VD66GY_SetGain+0x1e0>
340116b0:	ee28 8b07 	vmul.f64	d8, d8, d7
340116b4:	eefc 7bc8 	vcvt.u32.f64	s15, d8
340116b8:	edcd 7a01 	vstr	s15, [sp, #4]
340116bc:	f89d 3004 	ldrb.w	r3, [sp, #4]
340116c0:	4630      	mov	r0, r6
340116c2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
340116c6:	f002 f833 	bl	34013730 <VD6G_SetDigitalGain>
}
340116ca:	b005      	add	sp, #20
340116cc:	ecbd 8b08 	vpop	{d8-d11}
340116d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
340116d2:	ee07 7a90 	vmov	s15, r7
340116d6:	eeb8 7b67 	vcvt.f64.u32	d7, s15
340116da:	ee87 1b0b 	vdiv.f64	d1, d7, d11
340116de:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
340116e2:	ee81 1b0a 	vdiv.f64	d1, d1, d10
340116e6:	f009 fbff 	bl	3401aee8 <pow>
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
340116ea:	1bed      	subs	r5, r5, r7
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
340116ec:	eeb0 9b40 	vmov.f64	d9, d0
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
340116f0:	ee07 5a90 	vmov	s15, r5
340116f4:	e7b5      	b.n	34011662 <CMW_VD66GY_SetGain+0x132>
    return -1;
340116f6:	f04f 30ff 	mov.w	r0, #4294967295
340116fa:	e7e6      	b.n	340116ca <CMW_VD66GY_SetGain+0x19a>
340116fc:	f3af 8000 	nop.w
34011700:	00000000 	.word	0x00000000
34011704:	408f4000 	.word	0x408f4000
34011708:	00000000 	.word	0x00000000
3401170c:	40400000 	.word	0x40400000
34011710:	00000000 	.word	0x00000000
34011714:	40700000 	.word	0x40700000
34011718:	3b800000 	.word	0x3b800000

3401171c <CMW_VD66GY_SetExposure>:
  return VD6G_SetExposureTime(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, exposure);
3401171c:	3008      	adds	r0, #8
3401171e:	f002 b8a9 	b.w	34013874 <VD6G_SetExposureTime>

34011722 <CMW_VD66GY_SetExposureMode>:
  switch (mode)
34011722:	2901      	cmp	r1, #1
{
34011724:	b508      	push	{r3, lr}
34011726:	f100 0008 	add.w	r0, r0, #8
  switch (mode)
3401172a:	d002      	beq.n	34011732 <CMW_VD66GY_SetExposureMode+0x10>
3401172c:	2902      	cmp	r1, #2
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_AUTO);
3401172e:	bf18      	it	ne
34011730:	2100      	movne	r1, #0
34011732:	f001 ff59 	bl	340135e8 <VD6G_SetExposureMode>
  return (ret == 0) ? CMW_ERROR_NONE : CMW_ERROR_UNKNOWN_FAILURE;
34011736:	2800      	cmp	r0, #0
}
34011738:	bf18      	it	ne
3401173a:	f06f 0005 	mvnne.w	r0, #5
3401173e:	bd08      	pop	{r3, pc}

34011740 <CMW_VD66GY_GetSensorInfo>:
{
34011740:	b570      	push	{r4, r5, r6, lr}
34011742:	ed2d 8b08 	vpush	{d8-d11}
34011746:	460c      	mov	r4, r1
  if ((!io_ctx) || (info == NULL))
34011748:	4605      	mov	r5, r0
{
3401174a:	b082      	sub	sp, #8
  if ((!io_ctx) || (info == NULL))
3401174c:	2800      	cmp	r0, #0
3401174e:	f000 80a0 	beq.w	34011892 <CMW_VD66GY_GetSensorInfo+0x152>
34011752:	2900      	cmp	r1, #0
34011754:	f000 809d 	beq.w	34011892 <CMW_VD66GY_GetSensorInfo+0x152>
    strcpy(info->name, VD66GY_NAME);
34011758:	4951      	ldr	r1, [pc, #324]	@ (340118a0 <CMW_VD66GY_GetSensorInfo+0x160>)
3401175a:	4620      	mov	r0, r4
3401175c:	f007 fc8f 	bl	3401907e <strcpy>
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
34011760:	f895 3030 	ldrb.w	r3, [r5, #48]	@ 0x30
  info->height = VD6G_MAX_HEIGHT;
34011764:	f44f 628c 	mov.w	r2, #1120	@ 0x460
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
34011768:	3b01      	subs	r3, #1
3401176a:	f884 3020 	strb.w	r3, [r4, #32]
  info->color_depth = VD6G_COLOR_DEPTH_RAW8;
3401176e:	2308      	movs	r3, #8
34011770:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  info->height = VD6G_MAX_HEIGHT;
34011774:	f240 5354 	movw	r3, #1364	@ 0x554
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
34011778:	3508      	adds	r5, #8
  info->height = VD6G_MAX_HEIGHT;
3401177a:	e9c4 2309 	strd	r2, r3, [r4, #36]	@ 0x24
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3401177e:	4628      	mov	r0, r5
34011780:	f10d 0203 	add.w	r2, sp, #3
34011784:	f10d 0102 	add.w	r1, sp, #2
34011788:	f001 ff38 	bl	340135fc <VD6G_GetAnalogGainRegRange>
  if (ret)
3401178c:	2800      	cmp	r0, #0
3401178e:	d17c      	bne.n	3401188a <CMW_VD66GY_GetSensorInfo+0x14a>
  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
34011790:	4628      	mov	r0, r5
34011792:	f10d 0206 	add.w	r2, sp, #6
34011796:	a901      	add	r1, sp, #4
34011798:	f001 ff9c 	bl	340136d4 <VD6G_GetDigitalGainRegRange>
  if (ret)
3401179c:	2800      	cmp	r0, #0
3401179e:	d174      	bne.n	3401188a <CMW_VD66GY_GetSensorInfo+0x14a>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340117a0:	2620      	movs	r6, #32
340117a2:	f89d 3002 	ldrb.w	r3, [sp, #2]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340117a6:	ed9f ba3f 	vldr	s22, [pc, #252]	@ 340118a4 <CMW_VD66GY_GetSensorInfo+0x164>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340117aa:	f1c3 0320 	rsb	r3, r3, #32
340117ae:	fb96 f3f3 	sdiv	r3, r6, r3
340117b2:	ee00 3a10 	vmov	s0, r3
340117b6:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
340117ba:	f009 fa8d 	bl	3401acd8 <log10>
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340117be:	f89d 3003 	ldrb.w	r3, [sp, #3]
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340117c2:	eeb0 9b40 	vmov.f64	d9, d0
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340117c6:	1af3      	subs	r3, r6, r3
340117c8:	fb96 f3f3 	sdiv	r3, r6, r3
340117cc:	ee00 3a10 	vmov	s0, r3
340117d0:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
340117d4:	f009 fa80 	bl	3401acd8 <log10>
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340117d8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
340117dc:	f89d 2004 	ldrb.w	r2, [sp, #4]
340117e0:	0a1b      	lsrs	r3, r3, #8
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340117e2:	eeb0 8b40 	vmov.f64	d8, d0
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340117e6:	ee07 2a90 	vmov	s15, r2
340117ea:	ee00 3a10 	vmov	s0, r3
340117ee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340117f2:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
340117f6:	eea7 0a8b 	vfma.f32	s0, s15, s22
340117fa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340117fe:	f009 fa6b 	bl	3401acd8 <log10>
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011802:	f8bd 3006 	ldrh.w	r3, [sp, #6]
34011806:	f89d 2006 	ldrb.w	r2, [sp, #6]
3401180a:	0a1b      	lsrs	r3, r3, #8
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3401180c:	eeb0 ab40 	vmov.f64	d10, d0
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011810:	ee07 2a90 	vmov	s15, r2
34011814:	ee00 3a10 	vmov	s0, r3
34011818:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3401181c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
34011820:	eea7 0a8b 	vfma.f32	s0, s15, s22
34011824:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34011828:	f009 fa56 	bl	3401acd8 <log10>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401182c:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
34011830:	ed9f 6b19 	vldr	d6, [pc, #100]	@ 34011898 <CMW_VD66GY_GetSensorInfo+0x158>
34011834:	ee29 9b07 	vmul.f64	d9, d9, d7
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011838:	ee2a ab07 	vmul.f64	d10, d10, d7
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401183c:	ee29 9b06 	vmul.f64	d9, d9, d6
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011840:	ee2a ab06 	vmul.f64	d10, d10, d6
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011844:	ee28 8b07 	vmul.f64	d8, d8, d7
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011848:	ee20 0b07 	vmul.f64	d0, d0, d7
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401184c:	eebc 9bc9 	vcvt.u32.f64	s18, d9
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011850:	eebc abca 	vcvt.u32.f64	s20, d10
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011854:	ee28 8b06 	vmul.f64	d8, d8, d6
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011858:	ee20 0b06 	vmul.f64	d0, d0, d6
  info->gain_min = again_min_mdB + dgain_min_mdB;
3401185c:	ee1a 2a10 	vmov	r2, s20
34011860:	ee19 3a10 	vmov	r3, s18
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011864:	eebc 8bc8 	vcvt.u32.f64	s16, d8
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011868:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  info->gain_min = again_min_mdB + dgain_min_mdB;
3401186c:	4413      	add	r3, r2
3401186e:	62e3      	str	r3, [r4, #44]	@ 0x2c
  info->gain_max = again_max_mdB + dgain_max_mdB;
34011870:	ee10 2a10 	vmov	r2, s0
34011874:	ee18 3a10 	vmov	r3, s16
34011878:	4413      	add	r3, r2
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
3401187a:	4628      	mov	r0, r5
  info->gain_max = again_max_mdB + dgain_max_mdB;
3401187c:	6323      	str	r3, [r4, #48]	@ 0x30
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
3401187e:	f104 0238 	add.w	r2, r4, #56	@ 0x38
34011882:	f104 0134 	add.w	r1, r4, #52	@ 0x34
34011886:	f001 ffa9 	bl	340137dc <VD6G_GetExposureRegRange>
}
3401188a:	b002      	add	sp, #8
3401188c:	ecbd 8b08 	vpop	{d8-d11}
34011890:	bd70      	pop	{r4, r5, r6, pc}
    return CMW_ERROR_WRONG_PARAM;
34011892:	f06f 0001 	mvn.w	r0, #1
34011896:	e7f8      	b.n	3401188a <CMW_VD66GY_GetSensorInfo+0x14a>
34011898:	00000000 	.word	0x00000000
3401189c:	408f4000 	.word	0x408f4000
340118a0:	3401c8f7 	.word	0x3401c8f7
340118a4:	3b800000 	.word	0x3b800000

340118a8 <CMW_VD66GY_Stop>:
{
340118a8:	b508      	push	{r3, lr}
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340118aa:	3008      	adds	r0, #8
340118ac:	f001 fe6a 	bl	34013584 <VD6G_Stop>
    return CMW_ERROR_PERIPH_FAILURE;
340118b0:	2800      	cmp	r0, #0
}
340118b2:	bf18      	it	ne
340118b4:	f06f 0003 	mvnne.w	r0, #3
340118b8:	bd08      	pop	{r3, pc}
	...

340118bc <CMW_VD66GY_Start>:
{
340118bc:	b530      	push	{r4, r5, lr}
340118be:	b087      	sub	sp, #28
  ISP_StatAreaTypeDef isp_stat_area = {0};
340118c0:	ab02      	add	r3, sp, #8
{
340118c2:	4604      	mov	r4, r0
  ISP_StatAreaTypeDef isp_stat_area = {0};
340118c4:	2210      	movs	r2, #16
340118c6:	2100      	movs	r1, #0
340118c8:	4618      	mov	r0, r3
340118ca:	f007 f957 	bl	34018b7c <memset>
  ret = ISP_Init(&((CMW_VD66GY_t *)io_ctx)->hIsp, ((CMW_VD66GY_t *)io_ctx)->hdcmipp, 0, &((CMW_VD66GY_t *)io_ctx)->appliHelpers, &isp_stat_area, &ISP_IQParamCacheInit_VD66GY);
340118ce:	4a10      	ldr	r2, [pc, #64]	@ (34011910 <CMW_VD66GY_Start+0x54>)
340118d0:	f104 0570 	add.w	r5, r4, #112	@ 0x70
340118d4:	e9cd 0200 	strd	r0, r2, [sp]
340118d8:	f104 03f8 	add.w	r3, r4, #248	@ 0xf8
340118dc:	2200      	movs	r2, #0
340118de:	4628      	mov	r0, r5
340118e0:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
340118e4:	f002 fbf8 	bl	340140d8 <ISP_Init>
  if (ret != ISP_OK)
340118e8:	b978      	cbnz	r0, 3401190a <CMW_VD66GY_Start+0x4e>
  ret = ISP_Start(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340118ea:	4628      	mov	r0, r5
340118ec:	f002 fc90 	bl	34014210 <ISP_Start>
  if (ret != ISP_OK)
340118f0:	b938      	cbnz	r0, 34011902 <CMW_VD66GY_Start+0x46>
  ret = VD6G_Start(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340118f2:	3408      	adds	r4, #8
340118f4:	4620      	mov	r0, r4
340118f6:	f001 fd01 	bl	340132fc <VD6G_Start>
  if (ret) {
340118fa:	b120      	cbz	r0, 34011906 <CMW_VD66GY_Start+0x4a>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340118fc:	4620      	mov	r0, r4
340118fe:	f001 fced 	bl	340132dc <VD6G_DeInit>
      return CMW_ERROR_PERIPH_FAILURE;
34011902:	f06f 0003 	mvn.w	r0, #3
}
34011906:	b007      	add	sp, #28
34011908:	bd30      	pop	{r4, r5, pc}
    return CMW_ERROR_COMPONENT_FAILURE;
3401190a:	f06f 0004 	mvn.w	r0, #4
3401190e:	e7fa      	b.n	34011906 <CMW_VD66GY_Start+0x4a>
34011910:	340351a8 	.word	0x340351a8

34011914 <CMW_VD66GY_DeInit>:
{
34011914:	b538      	push	{r3, r4, r5, lr}
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011916:	f100 0508 	add.w	r5, r0, #8
{
3401191a:	4604      	mov	r4, r0
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3401191c:	4628      	mov	r0, r5
3401191e:	f001 fe31 	bl	34013584 <VD6G_Stop>
  if (ret)
34011922:	b110      	cbz	r0, 3401192a <CMW_VD66GY_DeInit+0x16>
    return CMW_ERROR_PERIPH_FAILURE;
34011924:	f06f 0003 	mvn.w	r0, #3
}
34011928:	bd38      	pop	{r3, r4, r5, pc}
  ret = VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3401192a:	4628      	mov	r0, r5
3401192c:	f001 fcd6 	bl	340132dc <VD6G_DeInit>
  if (ret)
34011930:	2800      	cmp	r0, #0
34011932:	d1f7      	bne.n	34011924 <CMW_VD66GY_DeInit+0x10>
  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 0;
34011934:	f884 0120 	strb.w	r0, [r4, #288]	@ 0x120
  return CMW_ERROR_NONE;
34011938:	e7f6      	b.n	34011928 <CMW_VD66GY_DeInit+0x14>

3401193a <CMW_VD66GY_Run>:
{
3401193a:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3401193c:	3070      	adds	r0, #112	@ 0x70
3401193e:	f002 fd0f 	bl	34014360 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
34011942:	2800      	cmp	r0, #0
}
34011944:	bf14      	ite	ne
34011946:	f06f 0003 	mvnne.w	r0, #3
3401194a:	2000      	moveq	r0, #0
3401194c:	bd08      	pop	{r3, pc}

3401194e <CMW_VD66GY_Init>:
{
3401194e:	b570      	push	{r4, r5, r6, lr}
34011950:	4604      	mov	r4, r0
34011952:	b08e      	sub	sp, #56	@ 0x38
34011954:	460d      	mov	r5, r1
  VD6G_Config_t config = { 0 };
34011956:	2238      	movs	r2, #56	@ 0x38
34011958:	2100      	movs	r1, #0
3401195a:	4668      	mov	r0, sp
3401195c:	f007 f90e 	bl	34018b7c <memset>
  if (((CMW_VD66GY_t *)io_ctx)->IsInitialized)
34011960:	f894 3120 	ldrb.w	r3, [r4, #288]	@ 0x120
34011964:	2b00      	cmp	r3, #0
34011966:	d14f      	bne.n	34011a08 <CMW_VD66GY_Init+0xba>
  config.frame_rate = initSensor->fps;
34011968:	68ab      	ldr	r3, [r5, #8]
3401196a:	9302      	str	r3, [sp, #8]
  ret = CMW_VD66GY_GetResType(initSensor->width, initSensor->height, &config.resolution);
3401196c:	e9d5 2300 	ldrd	r2, r3, [r5]
  if (width == 320 && height == 240)
34011970:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
34011974:	d104      	bne.n	34011980 <CMW_VD66GY_Init+0x32>
34011976:	2bf0      	cmp	r3, #240	@ 0xf0
34011978:	d00b      	beq.n	34011992 <CMW_VD66GY_Init+0x44>
    return CMW_ERROR_WRONG_PARAM;
3401197a:	f06f 0001 	mvn.w	r0, #1
3401197e:	e029      	b.n	340119d4 <CMW_VD66GY_Init+0x86>
  else if (width == 640 && height == 480)
34011980:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
34011984:	d128      	bne.n	340119d8 <CMW_VD66GY_Init+0x8a>
34011986:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
3401198a:	d1f6      	bne.n	3401197a <CMW_VD66GY_Init+0x2c>
    *res = VD6G_RES_VGA_640_480;
3401198c:	2301      	movs	r3, #1
    *res = VD6G_RES_FULL_1120_1364;
3401198e:	f88d 3004 	strb.w	r3, [sp, #4]
  config.ext_clock_freq_in_hz = ((CMW_VD66GY_t *)io_ctx)->ClockInHz;
34011992:	6863      	ldr	r3, [r4, #4]
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
34011994:	f104 0608 	add.w	r6, r4, #8
  config.ext_clock_freq_in_hz = ((CMW_VD66GY_t *)io_ctx)->ClockInHz;
34011998:	9300      	str	r3, [sp, #0]
  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
3401199a:	692b      	ldr	r3, [r5, #16]
  config.out_itf.clock_lane_swap_enable = 1;
3401199c:	2501      	movs	r5, #1
  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
3401199e:	2b03      	cmp	r3, #3
340119a0:	bf28      	it	cs
340119a2:	2303      	movcs	r3, #3
340119a4:	f88d 300c 	strb.w	r3, [sp, #12]
  config.out_itf.clock_lane_swap_enable = 1;
340119a8:	2302      	movs	r3, #2
340119aa:	e9cd 3506 	strd	r3, r5, [sp, #24]
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
340119ae:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
340119b2:	4669      	mov	r1, sp
340119b4:	4630      	mov	r0, r6
  config.out_itf.data_lane1_swap_enable = 1;
340119b6:	e9cd 5508 	strd	r5, r5, [sp, #32]
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
340119ba:	e9cd 330b 	strd	r3, r3, [sp, #44]	@ 0x2c
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
340119be:	f001 f97d 	bl	34012cbc <VD6G_Init>
  if (ret)
340119c2:	b928      	cbnz	r0, 340119d0 <CMW_VD66GY_Init+0x82>
  if (((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer == VD6G_BAYER_NONE)
340119c4:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
340119c8:	b9e3      	cbnz	r3, 34011a04 <CMW_VD66GY_Init+0xb6>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340119ca:	4630      	mov	r0, r6
340119cc:	f001 fc86 	bl	340132dc <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
340119d0:	f06f 0003 	mvn.w	r0, #3
}
340119d4:	b00e      	add	sp, #56	@ 0x38
340119d6:	bd70      	pop	{r4, r5, r6, pc}
  else if (width == 1024 && height == 768)
340119d8:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
340119dc:	d104      	bne.n	340119e8 <CMW_VD66GY_Init+0x9a>
340119de:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340119e2:	d1ca      	bne.n	3401197a <CMW_VD66GY_Init+0x2c>
    *res = VD6G_RES_XGA_1024_768;
340119e4:	2303      	movs	r3, #3
340119e6:	e7d2      	b.n	3401198e <CMW_VD66GY_Init+0x40>
  else if (width == 1120 && height == 720)
340119e8:	f5b2 6f8c 	cmp.w	r2, #1120	@ 0x460
340119ec:	d1c5      	bne.n	3401197a <CMW_VD66GY_Init+0x2c>
340119ee:	f5b3 7f34 	cmp.w	r3, #720	@ 0x2d0
340119f2:	d101      	bne.n	340119f8 <CMW_VD66GY_Init+0xaa>
    *res = VD6G_RES_PORTRAIT_1120_720;
340119f4:	2307      	movs	r3, #7
340119f6:	e7ca      	b.n	3401198e <CMW_VD66GY_Init+0x40>
  else if (width == 1120 && height == 1364)
340119f8:	f240 5254 	movw	r2, #1364	@ 0x554
340119fc:	4293      	cmp	r3, r2
340119fe:	d1bc      	bne.n	3401197a <CMW_VD66GY_Init+0x2c>
    *res = VD6G_RES_FULL_1120_1364;
34011a00:	2308      	movs	r3, #8
34011a02:	e7c4      	b.n	3401198e <CMW_VD66GY_Init+0x40>
  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 1;
34011a04:	f884 5120 	strb.w	r5, [r4, #288]	@ 0x120
    return CMW_ERROR_NONE;
34011a08:	2000      	movs	r0, #0
34011a0a:	e7e3      	b.n	340119d4 <CMW_VD66GY_Init+0x86>

34011a0c <CMW_VD66GY_VsyncEventCallback>:
  switch (pipe)
34011a0c:	2901      	cmp	r1, #1
{
34011a0e:	b510      	push	{r4, lr}
  switch (pipe)
34011a10:	d007      	beq.n	34011a22 <CMW_VD66GY_VsyncEventCallback+0x16>
34011a12:	2902      	cmp	r1, #2
34011a14:	d00f      	beq.n	34011a36 <CMW_VD66GY_VsyncEventCallback+0x2a>
34011a16:	b999      	cbnz	r1, 34011a40 <CMW_VD66GY_VsyncEventCallback+0x34>
}
34011a18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a1c:	3070      	adds	r0, #112	@ 0x70
34011a1e:	f002 bcb5 	b.w	3401438c <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a22:	f100 0470 	add.w	r4, r0, #112	@ 0x70
34011a26:	4620      	mov	r0, r4
34011a28:	f002 fcac 	bl	34014384 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a2c:	4620      	mov	r0, r4
}
34011a2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a32:	f002 bca5 	b.w	34014380 <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a36:	3070      	adds	r0, #112	@ 0x70
}
34011a38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a3c:	f002 bca4 	b.w	34014388 <ISP_IncAncillaryFrameId>
}
34011a40:	bd10      	pop	{r4, pc}

34011a42 <VD66GY_RegisterBusIO>:

int32_t VD66GY_RegisterBusIO(CMW_VD66GY_t *io_ctx)
{
  int ret;

  if (!io_ctx)
34011a42:	b118      	cbz	r0, 34011a4c <VD66GY_RegisterBusIO+0xa>
    return CMW_ERROR_COMPONENT_FAILURE;

  if (!io_ctx->Init)
34011a44:	f8d0 3124 	ldr.w	r3, [r0, #292]	@ 0x124
34011a48:	b103      	cbz	r3, 34011a4c <VD66GY_RegisterBusIO+0xa>
    return CMW_ERROR_COMPONENT_FAILURE;

  ret = io_ctx->Init();
34011a4a:	4718      	bx	r3

  return ret;
}
34011a4c:	f06f 0004 	mvn.w	r0, #4
34011a50:	4770      	bx	lr

34011a52 <VD66GY_ReadID>:

int32_t VD66GY_ReadID(CMW_VD66GY_t *io_ctx, uint32_t *Id)
{
34011a52:	b513      	push	{r0, r1, r4, lr}
34011a54:	460c      	mov	r4, r1
  uint16_t reg16;
  int32_t ret;

  ret = CMW_VD66GY_Read16(io_ctx, VD66GY_REG_MODEL_ID, &reg16);
34011a56:	f10d 0206 	add.w	r2, sp, #6
34011a5a:	2100      	movs	r1, #0
34011a5c:	f7ff fcec 	bl	34011438 <CMW_VD66GY_Read16>
  if (ret)
34011a60:	b910      	cbnz	r0, 34011a68 <VD66GY_ReadID+0x16>
    return ret;

  *Id = reg16;
34011a62:	f8bd 3006 	ldrh.w	r3, [sp, #6]
34011a66:	6023      	str	r3, [r4, #0]

  return CMW_ERROR_NONE;
}
34011a68:	b002      	add	sp, #8
34011a6a:	bd10      	pop	{r4, pc}

34011a6c <CMW_VD66GY_Probe>:
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
}

int CMW_VD66GY_Probe(CMW_VD66GY_t *io_ctx, CMW_Sensor_if_t *vd6g_if)
{
34011a6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011a6e:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
34011a70:	4b2c      	ldr	r3, [pc, #176]	@ (34011b24 <CMW_VD66GY_Probe+0xb8>)
{
34011a72:	460d      	mov	r5, r1
  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
34011a74:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.read8 = VD6G_Read8;
34011a76:	4b2c      	ldr	r3, [pc, #176]	@ (34011b28 <CMW_VD66GY_Probe+0xbc>)
34011a78:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.read16 =VD6G_Read16;
34011a7a:	4b2c      	ldr	r3, [pc, #176]	@ (34011b2c <CMW_VD66GY_Probe+0xc0>)
34011a7c:	6103      	str	r3, [r0, #16]
  io_ctx->ctx_driver.read32 = VD6G_Read32;
34011a7e:	4b2c      	ldr	r3, [pc, #176]	@ (34011b30 <CMW_VD66GY_Probe+0xc4>)
34011a80:	6143      	str	r3, [r0, #20]
  io_ctx->ctx_driver.write8 = VD6G_Write8;
34011a82:	4b2c      	ldr	r3, [pc, #176]	@ (34011b34 <CMW_VD66GY_Probe+0xc8>)
34011a84:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.write16 = VD6G_Write16;
34011a86:	4b2c      	ldr	r3, [pc, #176]	@ (34011b38 <CMW_VD66GY_Probe+0xcc>)
34011a88:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.write32 = VD6G_Write32;
34011a8a:	4b2c      	ldr	r3, [pc, #176]	@ (34011b3c <CMW_VD66GY_Probe+0xd0>)
34011a8c:	6203      	str	r3, [r0, #32]
  io_ctx->ctx_driver.write_array = VD6G_WriteArray;
34011a8e:	4b2c      	ldr	r3, [pc, #176]	@ (34011b40 <CMW_VD66GY_Probe+0xd4>)
34011a90:	6243      	str	r3, [r0, #36]	@ 0x24
  io_ctx->ctx_driver.delay = VD6G_Delay;
34011a92:	4b2c      	ldr	r3, [pc, #176]	@ (34011b44 <CMW_VD66GY_Probe+0xd8>)
34011a94:	6283      	str	r3, [r0, #40]	@ 0x28
  io_ctx->ctx_driver.log = VD6G_Log;
34011a96:	4b2c      	ldr	r3, [pc, #176]	@ (34011b48 <CMW_VD66GY_Probe+0xdc>)
34011a98:	62c3      	str	r3, [r0, #44]	@ 0x2c
  io_ctx->EnablePin(1);
34011a9a:	f8d0 3140 	ldr.w	r3, [r0, #320]	@ 0x140
34011a9e:	2001      	movs	r0, #1
34011aa0:	4798      	blx	r3
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34011aa2:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
34011aa6:	2000      	movs	r0, #0
34011aa8:	4798      	blx	r3
  HAL_Delay(200);   /* NRST signals asserted during 200ms */
34011aaa:	20c8      	movs	r0, #200	@ 0xc8
34011aac:	f7f2 feb4 	bl	34004818 <HAL_Delay>
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34011ab0:	2001      	movs	r0, #1
34011ab2:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
34011ab6:	4798      	blx	r3
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
34011ab8:	2014      	movs	r0, #20
34011aba:	f7f2 fead 	bl	34004818 <HAL_Delay>

  CMW_VD66GY_PowerOn(io_ctx);

  ret = VD66GY_RegisterBusIO(io_ctx);
34011abe:	4620      	mov	r0, r4
34011ac0:	f7ff ffbf 	bl	34011a42 <VD66GY_RegisterBusIO>
  if (ret != CMW_ERROR_NONE)
34011ac4:	b120      	cbz	r0, 34011ad0 <CMW_VD66GY_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
34011ac6:	f06f 0404 	mvn.w	r4, #4
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
  return ret;
}
34011aca:	4620      	mov	r0, r4
34011acc:	b003      	add	sp, #12
34011ace:	bd30      	pop	{r4, r5, pc}
  ret = VD66GY_ReadID(io_ctx, &id);
34011ad0:	4620      	mov	r0, r4
34011ad2:	a901      	add	r1, sp, #4
34011ad4:	f7ff ffbd 	bl	34011a52 <VD66GY_ReadID>
  if (ret != CMW_ERROR_NONE)
34011ad8:	4604      	mov	r4, r0
34011ada:	2800      	cmp	r0, #0
34011adc:	d1f3      	bne.n	34011ac6 <CMW_VD66GY_Probe+0x5a>
  if (id != VD66GY_CHIP_ID)
34011ade:	f245 6303 	movw	r3, #22019	@ 0x5603
34011ae2:	9a01      	ldr	r2, [sp, #4]
34011ae4:	429a      	cmp	r2, r3
34011ae6:	d1ee      	bne.n	34011ac6 <CMW_VD66GY_Probe+0x5a>
  memset(vd6g_if, 0, sizeof(*vd6g_if));
34011ae8:	4601      	mov	r1, r0
34011aea:	2244      	movs	r2, #68	@ 0x44
34011aec:	f105 001c 	add.w	r0, r5, #28
34011af0:	f007 f844 	bl	34018b7c <memset>
  vd6g_if->Init = CMW_VD66GY_Init;
34011af4:	4b15      	ldr	r3, [pc, #84]	@ (34011b4c <CMW_VD66GY_Probe+0xe0>)
34011af6:	602b      	str	r3, [r5, #0]
  vd6g_if->DeInit = CMW_VD66GY_DeInit;
34011af8:	4b15      	ldr	r3, [pc, #84]	@ (34011b50 <CMW_VD66GY_Probe+0xe4>)
34011afa:	606b      	str	r3, [r5, #4]
  vd6g_if->Run = CMW_VD66GY_Run;
34011afc:	4b15      	ldr	r3, [pc, #84]	@ (34011b54 <CMW_VD66GY_Probe+0xe8>)
34011afe:	60eb      	str	r3, [r5, #12]
  vd6g_if->VsyncEventCallback = CMW_VD66GY_VsyncEventCallback;
34011b00:	4b15      	ldr	r3, [pc, #84]	@ (34011b58 <CMW_VD66GY_Probe+0xec>)
34011b02:	612b      	str	r3, [r5, #16]
  vd6g_if->FrameEventCallback = CMW_VD66GY_FrameEventCallback;
34011b04:	4b15      	ldr	r3, [pc, #84]	@ (34011b5c <CMW_VD66GY_Probe+0xf0>)
34011b06:	616b      	str	r3, [r5, #20]
  vd6g_if->Start = CMW_VD66GY_Start;
34011b08:	4b15      	ldr	r3, [pc, #84]	@ (34011b60 <CMW_VD66GY_Probe+0xf4>)
34011b0a:	60ab      	str	r3, [r5, #8]
  vd6g_if->Stop = CMW_VD66GY_Stop;
34011b0c:	4b15      	ldr	r3, [pc, #84]	@ (34011b64 <CMW_VD66GY_Probe+0xf8>)
34011b0e:	61ab      	str	r3, [r5, #24]
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
34011b10:	4b15      	ldr	r3, [pc, #84]	@ (34011b68 <CMW_VD66GY_Probe+0xfc>)
34011b12:	64ab      	str	r3, [r5, #72]	@ 0x48
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
34011b14:	4b15      	ldr	r3, [pc, #84]	@ (34011b6c <CMW_VD66GY_Probe+0x100>)
34011b16:	64eb      	str	r3, [r5, #76]	@ 0x4c
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
34011b18:	4b15      	ldr	r3, [pc, #84]	@ (34011b70 <CMW_VD66GY_Probe+0x104>)
34011b1a:	652b      	str	r3, [r5, #80]	@ 0x50
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
34011b1c:	4b15      	ldr	r3, [pc, #84]	@ (34011b74 <CMW_VD66GY_Probe+0x108>)
34011b1e:	65ab      	str	r3, [r5, #88]	@ 0x58
  return ret;
34011b20:	e7d3      	b.n	34011aca <CMW_VD66GY_Probe+0x5e>
34011b22:	bf00      	nop
34011b24:	34011455 	.word	0x34011455
34011b28:	3401145d 	.word	0x3401145d
34011b2c:	34011471 	.word	0x34011471
34011b30:	34011477 	.word	0x34011477
34011b34:	34011495 	.word	0x34011495
34011b38:	340114af 	.word	0x340114af
34011b3c:	340114c9 	.word	0x340114c9
34011b40:	340114e1 	.word	0x340114e1
34011b44:	34011525 	.word	0x34011525
34011b48:	3401152d 	.word	0x3401152d
34011b4c:	3401194f 	.word	0x3401194f
34011b50:	34011915 	.word	0x34011915
34011b54:	3401193b 	.word	0x3401193b
34011b58:	34011a0d 	.word	0x34011a0d
34011b5c:	3401152f 	.word	0x3401152f
34011b60:	340118bd 	.word	0x340118bd
34011b64:	340118a9 	.word	0x340118a9
34011b68:	34011531 	.word	0x34011531
34011b6c:	3401171d 	.word	0x3401171d
34011b70:	34011723 	.word	0x34011723
34011b74:	34011741 	.word	0x34011741

34011b78 <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
34011b78:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
34011b7a:	6904      	ldr	r4, [r0, #16]
34011b7c:	8900      	ldrh	r0, [r0, #8]
34011b7e:	46a4      	mov	ip, r4
}
34011b80:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
34011b84:	4760      	bx	ip

34011b86 <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
34011b86:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
34011b88:	68c4      	ldr	r4, [r0, #12]
34011b8a:	8900      	ldrh	r0, [r0, #8]
34011b8c:	46a4      	mov	ip, r4
}
34011b8e:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
34011b92:	4760      	bx	ip

34011b94 <IMX335_WriteTable>:
{
34011b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int32_t ret = IMX335_OK;
34011b96:	2500      	movs	r5, #0
34011b98:	1c8c      	adds	r4, r1, #2
34011b9a:	eb04 0682 	add.w	r6, r4, r2, lsl #2
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
34011b9e:	f100 0718 	add.w	r7, r0, #24
    if(ret != IMX335_ERROR)
34011ba2:	b135      	cbz	r5, 34011bb2 <IMX335_WriteTable+0x1e>
  int32_t ret = IMX335_OK;
34011ba4:	f04f 35ff 	mov.w	r5, #4294967295
  for(index=0; index<size ; index++)
34011ba8:	3404      	adds	r4, #4
34011baa:	42b4      	cmp	r4, r6
34011bac:	d1f9      	bne.n	34011ba2 <IMX335_WriteTable+0xe>
}
34011bae:	4628      	mov	r0, r5
34011bb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
34011bb2:	2301      	movs	r3, #1
34011bb4:	4622      	mov	r2, r4
34011bb6:	4638      	mov	r0, r7
34011bb8:	f834 1c02 	ldrh.w	r1, [r4, #-2]
34011bbc:	f000 f99d 	bl	34011efa <imx335_write_reg>
34011bc0:	2800      	cmp	r0, #0
34011bc2:	d1ef      	bne.n	34011ba4 <IMX335_WriteTable+0x10>
34011bc4:	e7f0      	b.n	34011ba8 <IMX335_WriteTable+0x14>
	...

34011bc8 <IMX335_RegisterBusIO>:
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
  int32_t ret;

  if (pObj == NULL)
34011bc8:	b190      	cbz	r0, 34011bf0 <IMX335_RegisterBusIO+0x28>
    ret = IMX335_ERROR;
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
    pObj->IO.DeInit    = pIO->DeInit;
34011bca:	684a      	ldr	r2, [r1, #4]
    pObj->IO.Init      = pIO->Init;
34011bcc:	680b      	ldr	r3, [r1, #0]
    pObj->IO.DeInit    = pIO->DeInit;
34011bce:	6042      	str	r2, [r0, #4]
    pObj->IO.Address   = pIO->Address;
34011bd0:	890a      	ldrh	r2, [r1, #8]
    pObj->IO.Init      = pIO->Init;
34011bd2:	6003      	str	r3, [r0, #0]
    pObj->IO.Address   = pIO->Address;
34011bd4:	8102      	strh	r2, [r0, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
34011bd6:	68ca      	ldr	r2, [r1, #12]
34011bd8:	60c2      	str	r2, [r0, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
34011bda:	690a      	ldr	r2, [r1, #16]
34011bdc:	6102      	str	r2, [r0, #16]
    pObj->IO.GetTick   = pIO->GetTick;
34011bde:	694a      	ldr	r2, [r1, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
    pObj->Ctx.handle   = pObj;
34011be0:	6200      	str	r0, [r0, #32]
    pObj->IO.GetTick   = pIO->GetTick;
34011be2:	6142      	str	r2, [r0, #20]
    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
34011be4:	4a04      	ldr	r2, [pc, #16]	@ (34011bf8 <IMX335_RegisterBusIO+0x30>)
34011be6:	61c2      	str	r2, [r0, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
34011be8:	4a04      	ldr	r2, [pc, #16]	@ (34011bfc <IMX335_RegisterBusIO+0x34>)
34011bea:	6182      	str	r2, [r0, #24]

    if(pObj->IO.Init != NULL)
34011bec:	b103      	cbz	r3, 34011bf0 <IMX335_RegisterBusIO+0x28>
    {
      ret = pObj->IO.Init();
34011bee:	4718      	bx	r3
      ret = IMX335_ERROR;
    }
  }

  return ret;
}
34011bf0:	f04f 30ff 	mov.w	r0, #4294967295
34011bf4:	4770      	bx	lr
34011bf6:	bf00      	nop
34011bf8:	34011b79 	.word	0x34011b79
34011bfc:	34011b87 	.word	0x34011b87

34011c00 <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
34011c00:	b510      	push	{r4, lr}
  int32_t ret = IMX335_OK;

  if(pObj->IsInitialized == 0U)
34011c02:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
{
34011c06:	4604      	mov	r4, r0
  if(pObj->IsInitialized == 0U)
34011c08:	b9a3      	cbnz	r3, 34011c34 <IMX335_Init+0x34>
  {
    switch (Resolution)
34011c0a:	2906      	cmp	r1, #6
34011c0c:	d002      	beq.n	34011c14 <IMX335_Init+0x14>
        }
        break;
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
34011c0e:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
34011c12:	bd10      	pop	{r4, pc}
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
34011c14:	2254      	movs	r2, #84	@ 0x54
34011c16:	4908      	ldr	r1, [pc, #32]	@ (34011c38 <IMX335_Init+0x38>)
34011c18:	f7ff ffbc 	bl	34011b94 <IMX335_WriteTable>
34011c1c:	2800      	cmp	r0, #0
34011c1e:	d1f6      	bne.n	34011c0e <IMX335_Init+0xe>
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
34011c20:	2205      	movs	r2, #5
34011c22:	4620      	mov	r0, r4
34011c24:	4905      	ldr	r1, [pc, #20]	@ (34011c3c <IMX335_Init+0x3c>)
34011c26:	f7ff ffb5 	bl	34011b94 <IMX335_WriteTable>
34011c2a:	2800      	cmp	r0, #0
34011c2c:	d1ef      	bne.n	34011c0e <IMX335_Init+0xe>
        pObj->IsInitialized = 1U;
34011c2e:	2301      	movs	r3, #1
34011c30:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
  int32_t ret = IMX335_OK;
34011c34:	2000      	movs	r0, #0
  return ret;
34011c36:	e7ec      	b.n	34011c12 <IMX335_Init+0x12>
34011c38:	3403559c 	.word	0x3403559c
34011c3c:	34035588 	.word	0x34035588

34011c40 <IMX335_Start>:
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
  uint8_t tmp;
  int32_t ret = IMX335_OK;
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
34011c40:	2300      	movs	r3, #0
{
34011c42:	b573      	push	{r0, r1, r4, r5, r6, lr}
34011c44:	4605      	mov	r5, r0
  tmp = IMX335_MODE_STREAMING;
34011c46:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
34011c4a:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
34011c4e:	2301      	movs	r3, #1
34011c50:	f10d 0207 	add.w	r2, sp, #7
34011c54:	3018      	adds	r0, #24
34011c56:	f000 f950 	bl	34011efa <imx335_write_reg>
  if (ret != IMX335_OK)
34011c5a:	4604      	mov	r4, r0
34011c5c:	b950      	cbnz	r0, 34011c74 <IMX335_Start+0x34>
  tickstart = pObj->IO.GetTick();
34011c5e:	696b      	ldr	r3, [r5, #20]
34011c60:	4798      	blx	r3
34011c62:	4606      	mov	r6, r0
  while((pObj->IO.GetTick() - tickstart) < Delay)
34011c64:	696b      	ldr	r3, [r5, #20]
34011c66:	4798      	blx	r3
34011c68:	1b83      	subs	r3, r0, r6
34011c6a:	2b13      	cmp	r3, #19
34011c6c:	d9fa      	bls.n	34011c64 <IMX335_Start+0x24>
  {
    return IMX335_ERROR;
  }
  IMX335_Delay(pObj, 20);
  return ret;
}
34011c6e:	4620      	mov	r0, r4
34011c70:	b002      	add	sp, #8
34011c72:	bd70      	pop	{r4, r5, r6, pc}
    return IMX335_ERROR;
34011c74:	f04f 34ff 	mov.w	r4, #4294967295
34011c78:	e7f9      	b.n	34011c6e <IMX335_Start+0x2e>

34011c7a <IMX335_DeInit>:
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
  if(pObj->IsInitialized == 1U)
34011c7a:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
34011c7e:	2b01      	cmp	r3, #1
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
34011c80:	bf04      	itt	eq
34011c82:	2300      	moveq	r3, #0
34011c84:	f880 3024 	strbeq.w	r3, [r0, #36]	@ 0x24
  }

  return IMX335_OK;
}
34011c88:	2000      	movs	r0, #0
34011c8a:	4770      	bx	lr

34011c8c <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
34011c8c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
34011c8e:	4604      	mov	r4, r0
34011c90:	f854 3b18 	ldr.w	r3, [r4], #24
{
34011c94:	460d      	mov	r5, r1
  pObj->IO.Init();
34011c96:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
34011c98:	2301      	movs	r3, #1
34011c9a:	f643 1112 	movw	r1, #14610	@ 0x3912
34011c9e:	4620      	mov	r0, r4
34011ca0:	f10d 0207 	add.w	r2, sp, #7
34011ca4:	f000 f922 	bl	34011eec <imx335_read_reg>
34011ca8:	b920      	cbnz	r0, 34011cb4 <IMX335_ReadID+0x28>
  {
    ret = IMX335_ERROR;
  }
  else
  {
    *Id = tmp;
34011caa:	f89d 3007 	ldrb.w	r3, [sp, #7]
34011cae:	602b      	str	r3, [r5, #0]
    ret = IMX335_OK;
  }

  /* Component status */
  return ret;
}
34011cb0:	b003      	add	sp, #12
34011cb2:	bd30      	pop	{r4, r5, pc}
    ret = IMX335_ERROR;
34011cb4:	f04f 30ff 	mov.w	r0, #4294967295
  return ret;
34011cb8:	e7fa      	b.n	34011cb0 <IMX335_ReadID+0x24>
	...

34011cbc <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
34011cbc:	b530      	push	{r4, r5, lr}
  int32_t ret = IMX335_OK;
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
34011cbe:	4b1a      	ldr	r3, [pc, #104]	@ (34011d28 <IMX335_SetGain+0x6c>)
{
34011cc0:	b085      	sub	sp, #20
  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
34011cc2:	4299      	cmp	r1, r3
34011cc4:	d903      	bls.n	34011cce <IMX335_SetGain+0x12>
  {
    ret = IMX335_ERROR;
34011cc6:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

return ret;
}
34011cca:	b005      	add	sp, #20
34011ccc:	bd30      	pop	{r4, r5, pc}
    gain /= IMX335_GAIN_UNIT_MDB;
34011cce:	f44f 7396 	mov.w	r3, #300	@ 0x12c
    hold = 1;
34011cd2:	2501      	movs	r5, #1
    gain /= IMX335_GAIN_UNIT_MDB;
34011cd4:	fb91 f1f3 	sdiv	r1, r1, r3
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cd8:	f100 0418 	add.w	r4, r0, #24
    gain /= IMX335_GAIN_UNIT_MDB;
34011cdc:	9101      	str	r1, [sp, #4]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cde:	462b      	mov	r3, r5
34011ce0:	f243 0101 	movw	r1, #12289	@ 0x3001
34011ce4:	4620      	mov	r0, r4
34011ce6:	f10d 020f 	add.w	r2, sp, #15
    hold = 1;
34011cea:	f88d 500f 	strb.w	r5, [sp, #15]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011cee:	f000 f904 	bl	34011efa <imx335_write_reg>
34011cf2:	2800      	cmp	r0, #0
34011cf4:	d1e7      	bne.n	34011cc6 <IMX335_SetGain+0xa>
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
34011cf6:	2302      	movs	r3, #2
34011cf8:	f243 01e8 	movw	r1, #12520	@ 0x30e8
34011cfc:	4620      	mov	r0, r4
34011cfe:	aa01      	add	r2, sp, #4
34011d00:	f000 f8fb 	bl	34011efa <imx335_write_reg>
34011d04:	2800      	cmp	r0, #0
34011d06:	d1de      	bne.n	34011cc6 <IMX335_SetGain+0xa>
        hold = 0;
34011d08:	f88d 000f 	strb.w	r0, [sp, #15]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011d0c:	462b      	mov	r3, r5
34011d0e:	f243 0101 	movw	r1, #12289	@ 0x3001
34011d12:	4620      	mov	r0, r4
34011d14:	f10d 020f 	add.w	r2, sp, #15
34011d18:	f000 f8ef 	bl	34011efa <imx335_write_reg>
34011d1c:	3800      	subs	r0, #0
34011d1e:	bf18      	it	ne
34011d20:	2001      	movne	r0, #1
34011d22:	4240      	negs	r0, r0
return ret;
34011d24:	e7d1      	b.n	34011cca <IMX335_SetGain+0xe>
34011d26:	bf00      	nop
34011d28:	00011940 	.word	0x00011940

34011d2c <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
34011d2c:	b530      	push	{r4, r5, lr}
34011d2e:	ed2d 8b02 	vpush	{d8}
  int32_t ret = IMX335_OK;
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
34011d32:	f100 0418 	add.w	r4, r0, #24
{
34011d36:	b085      	sub	sp, #20
34011d38:	ee08 1a10 	vmov	s16, r1
  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
34011d3c:	2304      	movs	r3, #4
34011d3e:	f243 0130 	movw	r1, #12336	@ 0x3030
34011d42:	4620      	mov	r0, r4
34011d44:	aa02      	add	r2, sp, #8
34011d46:	f000 f8d1 	bl	34011eec <imx335_read_reg>
34011d4a:	b128      	cbz	r0, 34011d58 <IMX335_SetExposure+0x2c>
  {
    ret = IMX335_ERROR;
34011d4c:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
34011d50:	b005      	add	sp, #20
34011d52:	ecbd 8b02 	vpop	{d8}
34011d56:	bd30      	pop	{r4, r5, pc}
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
34011d58:	eddd 7a02 	vldr	s15, [sp, #8]
34011d5c:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
34011d60:	eddf 6a1a 	vldr	s13, [pc, #104]	@ 34011dcc <IMX335_SetExposure+0xa0>
34011d64:	eef8 7a67 	vcvt.f32.u32	s15, s15
34011d68:	ee88 7a26 	vdiv.f32	s14, s16, s13
34011d6c:	ee77 7ac7 	vsub.f32	s15, s15, s14
34011d70:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34011d74:	ee17 3a90 	vmov	r3, s15
    if (shutter < IMX335_SHUTTER_MIN)
34011d78:	2b08      	cmp	r3, #8
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
34011d7a:	edcd 7a03 	vstr	s15, [sp, #12]
    if (shutter < IMX335_SHUTTER_MIN)
34011d7e:	d9e5      	bls.n	34011d4c <IMX335_SetExposure+0x20>
      hold = 1;
34011d80:	2501      	movs	r5, #1
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011d82:	f243 0101 	movw	r1, #12289	@ 0x3001
34011d86:	462b      	mov	r3, r5
34011d88:	4620      	mov	r0, r4
34011d8a:	f10d 0207 	add.w	r2, sp, #7
      hold = 1;
34011d8e:	f88d 5007 	strb.w	r5, [sp, #7]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011d92:	f000 f8b2 	bl	34011efa <imx335_write_reg>
34011d96:	2800      	cmp	r0, #0
34011d98:	d1d8      	bne.n	34011d4c <IMX335_SetExposure+0x20>
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
34011d9a:	2303      	movs	r3, #3
34011d9c:	f243 0158 	movw	r1, #12376	@ 0x3058
34011da0:	4620      	mov	r0, r4
34011da2:	aa03      	add	r2, sp, #12
34011da4:	f000 f8a9 	bl	34011efa <imx335_write_reg>
34011da8:	2800      	cmp	r0, #0
34011daa:	d1cf      	bne.n	34011d4c <IMX335_SetExposure+0x20>
          hold = 0;
34011dac:	f88d 0007 	strb.w	r0, [sp, #7]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011db0:	462b      	mov	r3, r5
34011db2:	f243 0101 	movw	r1, #12289	@ 0x3001
34011db6:	4620      	mov	r0, r4
34011db8:	f10d 0207 	add.w	r2, sp, #7
34011dbc:	f000 f89d 	bl	34011efa <imx335_write_reg>
34011dc0:	3800      	subs	r0, #0
34011dc2:	bf18      	it	ne
34011dc4:	2001      	movne	r0, #1
34011dc6:	4240      	negs	r0, r0
  return ret;
34011dc8:	e7c2      	b.n	34011d50 <IMX335_SetExposure+0x24>
34011dca:	bf00      	nop
34011dcc:	40ed097c 	.word	0x40ed097c

34011dd0 <IMX335_SetFrequency>:
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
  uint32_t ret = IMX335_OK;

  switch (frequency)
34011dd0:	3901      	subs	r1, #1
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011dd2:	2207      	movs	r2, #7
{
34011dd4:	b508      	push	{r3, lr}
  switch (frequency)
34011dd6:	2903      	cmp	r1, #3
34011dd8:	d811      	bhi.n	34011dfe <IMX335_SetFrequency+0x2e>
34011dda:	e8df f001 	tbb	[pc, r1]
34011dde:	0c0e      	.short	0x0c0e
34011de0:	020a      	.short	0x020a
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
34011de2:	4908      	ldr	r1, [pc, #32]	@ (34011e04 <IMX335_SetFrequency+0x34>)
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011de4:	f7ff fed6 	bl	34011b94 <IMX335_WriteTable>
34011de8:	3800      	subs	r0, #0
34011dea:	bf18      	it	ne
34011dec:	2001      	movne	r0, #1
34011dee:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
34011df0:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
34011df2:	4905      	ldr	r1, [pc, #20]	@ (34011e08 <IMX335_SetFrequency+0x38>)
34011df4:	e7f6      	b.n	34011de4 <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
34011df6:	4905      	ldr	r1, [pc, #20]	@ (34011e0c <IMX335_SetFrequency+0x3c>)
34011df8:	e7f4      	b.n	34011de4 <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
34011dfa:	4905      	ldr	r1, [pc, #20]	@ (34011e10 <IMX335_SetFrequency+0x40>)
34011dfc:	e7f2      	b.n	34011de4 <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011dfe:	4905      	ldr	r1, [pc, #20]	@ (34011e14 <IMX335_SetFrequency+0x44>)
34011e00:	e7f0      	b.n	34011de4 <IMX335_SetFrequency+0x14>
34011e02:	bf00      	nop
34011e04:	3403556c 	.word	0x3403556c
34011e08:	34035550 	.word	0x34035550
34011e0c:	34035534 	.word	0x34035534
34011e10:	34035518 	.word	0x34035518
34011e14:	340354fc 	.word	0x340354fc

34011e18 <IMX335_SetFramerate>:
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
  uint32_t ret = IMX335_OK;
  switch (framerate)
34011e18:	2914      	cmp	r1, #20
{
34011e1a:	b508      	push	{r3, lr}
34011e1c:	4603      	mov	r3, r0
  switch (framerate)
34011e1e:	d019      	beq.n	34011e54 <IMX335_SetFramerate+0x3c>
34011e20:	dc07      	bgt.n	34011e32 <IMX335_SetFramerate+0x1a>
34011e22:	290a      	cmp	r1, #10
34011e24:	d00a      	beq.n	34011e3c <IMX335_SetFramerate+0x24>
34011e26:	290f      	cmp	r1, #15
34011e28:	d011      	beq.n	34011e4e <IMX335_SetFramerate+0x36>
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
34011e2a:	2202      	movs	r2, #2
34011e2c:	4618      	mov	r0, r3
34011e2e:	490b      	ldr	r1, [pc, #44]	@ (34011e5c <IMX335_SetFramerate+0x44>)
34011e30:	e006      	b.n	34011e40 <IMX335_SetFramerate+0x28>
  switch (framerate)
34011e32:	2919      	cmp	r1, #25
34011e34:	d1f9      	bne.n	34011e2a <IMX335_SetFramerate+0x12>
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
34011e36:	2202      	movs	r2, #2
34011e38:	4909      	ldr	r1, [pc, #36]	@ (34011e60 <IMX335_SetFramerate+0x48>)
34011e3a:	e001      	b.n	34011e40 <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
34011e3c:	2202      	movs	r2, #2
34011e3e:	4909      	ldr	r1, [pc, #36]	@ (34011e64 <IMX335_SetFramerate+0x4c>)
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
34011e40:	f7ff fea8 	bl	34011b94 <IMX335_WriteTable>
34011e44:	3800      	subs	r0, #0
34011e46:	bf18      	it	ne
34011e48:	2001      	movne	r0, #1
34011e4a:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
34011e4c:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
34011e4e:	2202      	movs	r2, #2
34011e50:	4905      	ldr	r1, [pc, #20]	@ (34011e68 <IMX335_SetFramerate+0x50>)
34011e52:	e7f5      	b.n	34011e40 <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
34011e54:	2202      	movs	r2, #2
34011e56:	4905      	ldr	r1, [pc, #20]	@ (34011e6c <IMX335_SetFramerate+0x54>)
34011e58:	e7f2      	b.n	34011e40 <IMX335_SetFramerate+0x28>
34011e5a:	bf00      	nop
34011e5c:	340354d4 	.word	0x340354d4
34011e60:	340354dc 	.word	0x340354dc
34011e64:	340354f4 	.word	0x340354f4
34011e68:	340354ec 	.word	0x340354ec
34011e6c:	340354e4 	.word	0x340354e4

34011e70 <IMX335_MirrorFlipConfig>:
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
  int32_t ret = IMX335_OK;

  switch (Config)
34011e70:	2902      	cmp	r1, #2
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
      break;
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011e72:	f04f 020a 	mov.w	r2, #10
  switch (Config)
34011e76:	d006      	beq.n	34011e86 <IMX335_MirrorFlipConfig+0x16>
34011e78:	2903      	cmp	r1, #3
34011e7a:	d006      	beq.n	34011e8a <IMX335_MirrorFlipConfig+0x1a>
34011e7c:	2901      	cmp	r1, #1
34011e7e:	d106      	bne.n	34011e8e <IMX335_MirrorFlipConfig+0x1e>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
34011e80:	4904      	ldr	r1, [pc, #16]	@ (34011e94 <IMX335_MirrorFlipConfig+0x24>)
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011e82:	f7ff be87 	b.w	34011b94 <IMX335_WriteTable>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
34011e86:	4904      	ldr	r1, [pc, #16]	@ (34011e98 <IMX335_MirrorFlipConfig+0x28>)
34011e88:	e7fb      	b.n	34011e82 <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
34011e8a:	4904      	ldr	r1, [pc, #16]	@ (34011e9c <IMX335_MirrorFlipConfig+0x2c>)
34011e8c:	e7f9      	b.n	34011e82 <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011e8e:	4904      	ldr	r1, [pc, #16]	@ (34011ea0 <IMX335_MirrorFlipConfig+0x30>)
34011e90:	e7f7      	b.n	34011e82 <IMX335_MirrorFlipConfig+0x12>
34011e92:	bf00      	nop
34011e94:	3403545c 	.word	0x3403545c
34011e98:	34035484 	.word	0x34035484
34011e9c:	340354ac 	.word	0x340354ac
34011ea0:	34035434 	.word	0x34035434

34011ea4 <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
34011ea4:	b513      	push	{r0, r1, r4, lr}
  int32_t ret = IMX335_OK;
  uint8_t val;

  if (mode >= 0)
34011ea6:	2900      	cmp	r1, #0
{
34011ea8:	4604      	mov	r4, r0
  if (mode >= 0)
34011eaa:	db15      	blt.n	34011ed8 <IMX335_SetTestPattern+0x34>
  {
    /* Enable Test Pattern #mode */
    val = mode;
34011eac:	f88d 1007 	strb.w	r1, [sp, #7]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
34011eb0:	2301      	movs	r3, #1
34011eb2:	f243 219e 	movw	r1, #12958	@ 0x329e
34011eb6:	f10d 0207 	add.w	r2, sp, #7
34011eba:	3018      	adds	r0, #24
34011ebc:	f000 f81d 	bl	34011efa <imx335_write_reg>
34011ec0:	b968      	cbnz	r0, 34011ede <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
34011ec2:	2207      	movs	r2, #7
34011ec4:	4620      	mov	r0, r4
34011ec6:	4907      	ldr	r1, [pc, #28]	@ (34011ee4 <IMX335_SetTestPattern+0x40>)
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
34011ec8:	f7ff fe64 	bl	34011b94 <IMX335_WriteTable>
34011ecc:	3800      	subs	r0, #0
34011ece:	bf18      	it	ne
34011ed0:	2001      	movne	r0, #1
34011ed2:	4240      	negs	r0, r0
      return IMX335_ERROR;
    }
  }

  return ret;
}
34011ed4:	b002      	add	sp, #8
34011ed6:	bd10      	pop	{r4, pc}
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
34011ed8:	2207      	movs	r2, #7
34011eda:	4903      	ldr	r1, [pc, #12]	@ (34011ee8 <IMX335_SetTestPattern+0x44>)
34011edc:	e7f4      	b.n	34011ec8 <IMX335_SetTestPattern+0x24>
      return IMX335_ERROR;
34011ede:	f04f 30ff 	mov.w	r0, #4294967295
34011ee2:	e7f7      	b.n	34011ed4 <IMX335_SetTestPattern+0x30>
34011ee4:	34035418 	.word	0x34035418
34011ee8:	340353fc 	.word	0x340353fc

34011eec <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
34011eec:	b410      	push	{r4}
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
34011eee:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
34011ef2:	46a4      	mov	ip, r4
}
34011ef4:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
34011ef8:	4760      	bx	ip

34011efa <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
34011efa:	b410      	push	{r4}
  return ctx->WriteReg(ctx->handle, reg, data, length);
34011efc:	6804      	ldr	r4, [r0, #0]
34011efe:	6880      	ldr	r0, [r0, #8]
34011f00:	46a4      	mov	ip, r4
}
34011f02:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->WriteReg(ctx->handle, reg, data, length);
34011f06:	4760      	bx	ip

34011f08 <VD55G1_log_impl>:
    return NULL;
  }
}

static void VD55G1_log_impl(VD55G1_Ctx_t *ctx, int lvl, const char *format, ...)
{
34011f08:	b40c      	push	{r2, r3}
34011f0a:	b513      	push	{r0, r1, r4, lr}
  va_list ap;

  if (!ctx->log)
34011f0c:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34011f0e:	b11c      	cbz	r4, 34011f18 <VD55G1_log_impl+0x10>
    return ;

  va_start(ap, format);
34011f10:	ab05      	add	r3, sp, #20
  ctx->log(ctx, lvl, format, ap);
34011f12:	9a04      	ldr	r2, [sp, #16]
  va_start(ap, format);
34011f14:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, lvl, format, ap);
34011f16:	47a0      	blx	r4
  va_end(ap);
}
34011f18:	b002      	add	sp, #8
34011f1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34011f1e:	b002      	add	sp, #8
34011f20:	4770      	bx	lr
	...

34011f24 <VD55G1_PollReg8>:

  return 0;
}

static int VD55G1_PollReg8(VD55G1_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
34011f24:	b5f0      	push	{r4, r5, r6, r7, lr}
34011f26:	4604      	mov	r4, r0
34011f28:	460e      	mov	r6, r1
34011f2a:	4617      	mov	r7, r2
34011f2c:	2531      	movs	r5, #49	@ 0x31
34011f2e:	b085      	sub	sp, #20
  int loop_nb = timeout_ms / loop_delay_ms;
  uint8_t val;
  int ret;

  while (--loop_nb) {
    ret = ctx->read8(ctx, addr, &val);
34011f30:	4631      	mov	r1, r6
34011f32:	4620      	mov	r0, r4
34011f34:	6863      	ldr	r3, [r4, #4]
34011f36:	f10d 020f 	add.w	r2, sp, #15
34011f3a:	4798      	blx	r3
    if (ret < 0)
34011f3c:	2800      	cmp	r0, #0
34011f3e:	db17      	blt.n	34011f70 <VD55G1_PollReg8+0x4c>
      return ret;
    if (val == poll_val)
34011f40:	f89d 300f 	ldrb.w	r3, [sp, #15]
34011f44:	42bb      	cmp	r3, r7
34011f46:	d015      	beq.n	34011f74 <VD55G1_PollReg8+0x50>
      return 0;
    ctx->delay(ctx, loop_delay_ms);
34011f48:	210a      	movs	r1, #10
34011f4a:	4620      	mov	r0, r4
34011f4c:	6a23      	ldr	r3, [r4, #32]
34011f4e:	4798      	blx	r3
  while (--loop_nb) {
34011f50:	3d01      	subs	r5, #1
34011f52:	d1ed      	bne.n	34011f30 <VD55G1_PollReg8+0xc>
  }

  VD55G1_dbg(ctx, 0, "current state %d\n", val);
34011f54:	f89d 300f 	ldrb.w	r3, [sp, #15]
34011f58:	4620      	mov	r0, r4
34011f5a:	9301      	str	r3, [sp, #4]
34011f5c:	f240 132b 	movw	r3, #299	@ 0x12b
34011f60:	2103      	movs	r1, #3
34011f62:	9300      	str	r3, [sp, #0]
34011f64:	4a04      	ldr	r2, [pc, #16]	@ (34011f78 <VD55G1_PollReg8+0x54>)
34011f66:	462b      	mov	r3, r5
34011f68:	f7ff ffce 	bl	34011f08 <VD55G1_log_impl>

  return -1;
34011f6c:	f04f 30ff 	mov.w	r0, #4294967295
}
34011f70:	b005      	add	sp, #20
34011f72:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return 0;
34011f74:	2000      	movs	r0, #0
34011f76:	e7fb      	b.n	34011f70 <VD55G1_PollReg8+0x4c>
34011f78:	3401c8fe 	.word	0x3401c8fe

34011f7c <VD55G1_WaitState>:

  return state == VD55G1_SYSTEM_FSM_STREAMING;
}

static int VD55G1_WaitState(VD55G1_Ctx_t *ctx, int state)
{
34011f7c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34011f7e:	b2ca      	uxtb	r2, r1
{
34011f80:	460d      	mov	r5, r1
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34011f82:	211c      	movs	r1, #28
{
34011f84:	4606      	mov	r6, r0
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34011f86:	f7ff ffcd 	bl	34011f24 <VD55G1_PollReg8>

  if (ret)
34011f8a:	4604      	mov	r4, r0
34011f8c:	b150      	cbz	r0, 34011fa4 <VD55G1_WaitState+0x28>
    VD55G1_warn(ctx, "Unable to reach state %d\n", state);
34011f8e:	f240 1341 	movw	r3, #321	@ 0x141
34011f92:	2101      	movs	r1, #1
34011f94:	4630      	mov	r0, r6
34011f96:	4a09      	ldr	r2, [pc, #36]	@ (34011fbc <VD55G1_WaitState+0x40>)
34011f98:	9500      	str	r5, [sp, #0]
34011f9a:	f7ff ffb5 	bl	34011f08 <VD55G1_log_impl>
  else
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);

  return ret;
}
34011f9e:	4620      	mov	r0, r4
34011fa0:	b002      	add	sp, #8
34011fa2:	bd70      	pop	{r4, r5, r6, pc}
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);
34011fa4:	f240 1343 	movw	r3, #323	@ 0x143
34011fa8:	2103      	movs	r1, #3
34011faa:	9300      	str	r3, [sp, #0]
34011fac:	4a04      	ldr	r2, [pc, #16]	@ (34011fc0 <VD55G1_WaitState+0x44>)
34011fae:	4603      	mov	r3, r0
34011fb0:	9501      	str	r5, [sp, #4]
34011fb2:	4630      	mov	r0, r6
34011fb4:	f7ff ffa8 	bl	34011f08 <VD55G1_log_impl>
  return ret;
34011fb8:	e7f1      	b.n	34011f9e <VD55G1_WaitState+0x22>
34011fba:	bf00      	nop
34011fbc:	3401c921 	.word	0x3401c921
34011fc0:	3401c94b 	.word	0x3401c94b

34011fc4 <display_error>:
{
34011fc4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
34011fc6:	2110      	movs	r1, #16
34011fc8:	6883      	ldr	r3, [r0, #8]
34011fca:	f10d 020e 	add.w	r2, sp, #14
{
34011fce:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
34011fd0:	4798      	blx	r3
  assert(ret == 0);
34011fd2:	4601      	mov	r1, r0
34011fd4:	b128      	cbz	r0, 34011fe2 <display_error+0x1e>
34011fd6:	21fc      	movs	r1, #252	@ 0xfc
34011fd8:	4b07      	ldr	r3, [pc, #28]	@ (34011ff8 <display_error+0x34>)
34011fda:	4a08      	ldr	r2, [pc, #32]	@ (34011ffc <display_error+0x38>)
34011fdc:	4808      	ldr	r0, [pc, #32]	@ (34012000 <display_error+0x3c>)
34011fde:	f005 fc6b 	bl	340178b8 <__assert_func>
  VD55G1_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
34011fe2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34011fe6:	4620      	mov	r0, r4
34011fe8:	9300      	str	r3, [sp, #0]
34011fea:	4a06      	ldr	r2, [pc, #24]	@ (34012004 <display_error+0x40>)
34011fec:	23fd      	movs	r3, #253	@ 0xfd
34011fee:	f7ff ff8b 	bl	34011f08 <VD55G1_log_impl>
}
34011ff2:	b004      	add	sp, #16
34011ff4:	bd10      	pop	{r4, pc}
34011ff6:	bf00      	nop
34011ff8:	3401be43 	.word	0x3401be43
34011ffc:	34035847 	.word	0x34035847
34012000:	3401c96c 	.word	0x3401c96c
34012004:	3401c9cb 	.word	0x3401c9cb

34012008 <VD55G1_ApplyPatchCommon>:
  return 0;
}

static int VD55G1_ApplyPatchCommon(VD55G1_Ctx_t *ctx, uint8_t *patch_array, int patch_len, uint8_t patch_major,
                                   uint8_t patch_minor)
{
34012008:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t reg16;
  int ret;

  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
3401200a:	69c4      	ldr	r4, [r0, #28]
{
3401200c:	b087      	sub	sp, #28
3401200e:	461e      	mov	r6, r3
  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
34012010:	4613      	mov	r3, r2
34012012:	460a      	mov	r2, r1
34012014:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
{
34012018:	4605      	mov	r5, r0
3401201a:	f89d 7030 	ldrb.w	r7, [sp, #48]	@ 0x30
  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
3401201e:	47a0      	blx	r4
  VD55G1_TraceError(ctx, ret);
34012020:	4604      	mov	r4, r0
34012022:	b958      	cbnz	r0, 3401203c <VD55G1_ApplyPatchCommon+0x34>

  ret = ctx->write8(ctx, VD55G1_REG_BOOT, VD55G1_BOOT_PATCH_AND_BOOT);
34012024:	2202      	movs	r2, #2
34012026:	f44f 7100 	mov.w	r1, #512	@ 0x200
3401202a:	4628      	mov	r0, r5
3401202c:	692b      	ldr	r3, [r5, #16]
3401202e:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012030:	4604      	mov	r4, r0
34012032:	b190      	cbz	r0, 3401205a <VD55G1_ApplyPatchCommon+0x52>
34012034:	f240 1377 	movw	r3, #375	@ 0x177
34012038:	9002      	str	r0, [sp, #8]
3401203a:	e002      	b.n	34012042 <VD55G1_ApplyPatchCommon+0x3a>
  VD55G1_TraceError(ctx, ret);
3401203c:	f44f 73ba 	mov.w	r3, #372	@ 0x174
34012040:	9002      	str	r0, [sp, #8]
    return -1;
  }
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
  VD55G1_TraceError(ctx, ret);
34012042:	4a32      	ldr	r2, [pc, #200]	@ (3401210c <VD55G1_ApplyPatchCommon+0x104>)
34012044:	4628      	mov	r0, r5
34012046:	9200      	str	r2, [sp, #0]
34012048:	2100      	movs	r1, #0
3401204a:	4a31      	ldr	r2, [pc, #196]	@ (34012110 <VD55G1_ApplyPatchCommon+0x108>)
3401204c:	9301      	str	r3, [sp, #4]
3401204e:	f7ff ff5b 	bl	34011f08 <VD55G1_log_impl>
34012052:	4628      	mov	r0, r5
34012054:	f7ff ffb6 	bl	34011fc4 <display_error>
34012058:	e039      	b.n	340120ce <VD55G1_ApplyPatchCommon+0xc6>
  ret = VD55G1_PollReg8(ctx, VD55G1_REG_BOOT, VD55G1_CMD_ACK);
3401205a:	4602      	mov	r2, r0
3401205c:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012060:	4628      	mov	r0, r5
34012062:	f7ff ff5f 	bl	34011f24 <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012066:	4604      	mov	r4, r0
34012068:	b118      	cbz	r0, 34012072 <VD55G1_ApplyPatchCommon+0x6a>
3401206a:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
3401206e:	9002      	str	r0, [sp, #8]
34012070:	e7e7      	b.n	34012042 <VD55G1_ApplyPatchCommon+0x3a>
  ret = ctx->read16(ctx, VD55G1_REG_FWPATCH_REVISION, &reg16);
34012072:	2112      	movs	r1, #18
34012074:	4628      	mov	r0, r5
34012076:	68ab      	ldr	r3, [r5, #8]
34012078:	f10d 0216 	add.w	r2, sp, #22
3401207c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401207e:	4604      	mov	r4, r0
34012080:	b118      	cbz	r0, 3401208a <VD55G1_ApplyPatchCommon+0x82>
34012082:	f240 137d 	movw	r3, #381	@ 0x17d
34012086:	9002      	str	r0, [sp, #8]
34012088:	e7db      	b.n	34012042 <VD55G1_ApplyPatchCommon+0x3a>
  VD55G1_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
3401208a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
3401208e:	4a21      	ldr	r2, [pc, #132]	@ (34012114 <VD55G1_ApplyPatchCommon+0x10c>)
34012090:	9301      	str	r3, [sp, #4]
34012092:	f44f 73bf 	mov.w	r3, #382	@ 0x17e
34012096:	2103      	movs	r1, #3
34012098:	9300      	str	r3, [sp, #0]
3401209a:	4603      	mov	r3, r0
3401209c:	4628      	mov	r0, r5
3401209e:	f7ff ff33 	bl	34011f08 <VD55G1_log_impl>
  if (reg16 != (patch_major << 8) + patch_minor) {
340120a2:	f8bd 2016 	ldrh.w	r2, [sp, #22]
340120a6:	eb07 2306 	add.w	r3, r7, r6, lsl #8
340120aa:	429a      	cmp	r2, r3
340120ac:	b2d3      	uxtb	r3, r2
340120ae:	ea4f 2212 	mov.w	r2, r2, lsr #8
340120b2:	d00f      	beq.n	340120d4 <VD55G1_ApplyPatchCommon+0xcc>
    VD55G1_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor, reg16 >> 8, reg16 & 0xff);
340120b4:	e9cd 2302 	strd	r2, r3, [sp, #8]
340120b8:	4621      	mov	r1, r4
340120ba:	f240 1381 	movw	r3, #385	@ 0x181
340120be:	4628      	mov	r0, r5
340120c0:	e9cd 6700 	strd	r6, r7, [sp]
340120c4:	4a14      	ldr	r2, [pc, #80]	@ (34012118 <VD55G1_ApplyPatchCommon+0x110>)
340120c6:	f7ff ff1f 	bl	34011f08 <VD55G1_log_impl>
    return -1;
340120ca:	f04f 34ff 	mov.w	r4, #4294967295

  VD55G1_notice(ctx, "sensor boot successfully\n");

  return 0;
}
340120ce:	4620      	mov	r0, r4
340120d0:	b007      	add	sp, #28
340120d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
340120d4:	e9cd 2300 	strd	r2, r3, [sp]
340120d8:	2102      	movs	r1, #2
340120da:	f44f 73c2 	mov.w	r3, #388	@ 0x184
340120de:	4628      	mov	r0, r5
340120e0:	4a0e      	ldr	r2, [pc, #56]	@ (3401211c <VD55G1_ApplyPatchCommon+0x114>)
340120e2:	f7ff ff11 	bl	34011f08 <VD55G1_log_impl>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
340120e6:	2102      	movs	r1, #2
340120e8:	4628      	mov	r0, r5
340120ea:	f7ff ff47 	bl	34011f7c <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
340120ee:	4604      	mov	r4, r0
340120f0:	b938      	cbnz	r0, 34012102 <VD55G1_ApplyPatchCommon+0xfa>
  VD55G1_notice(ctx, "sensor boot successfully\n");
340120f2:	f240 1389 	movw	r3, #393	@ 0x189
340120f6:	2102      	movs	r1, #2
340120f8:	4628      	mov	r0, r5
340120fa:	4a09      	ldr	r2, [pc, #36]	@ (34012120 <VD55G1_ApplyPatchCommon+0x118>)
340120fc:	f7ff ff04 	bl	34011f08 <VD55G1_log_impl>
  return 0;
34012100:	e7e5      	b.n	340120ce <VD55G1_ApplyPatchCommon+0xc6>
  VD55G1_TraceError(ctx, ret);
34012102:	f240 1387 	movw	r3, #391	@ 0x187
34012106:	9002      	str	r0, [sp, #8]
34012108:	e79b      	b.n	34012042 <VD55G1_ApplyPatchCommon+0x3a>
3401210a:	bf00      	nop
3401210c:	3403581d 	.word	0x3403581d
34012110:	3401c9f0 	.word	0x3401c9f0
34012114:	3401ca15 	.word	0x3401ca15
34012118:	3401ca36 	.word	0x3401ca36
3401211c:	3401ca72 	.word	0x3401ca72
34012120:	3401ca97 	.word	0x3401ca97

34012124 <VD55G1_ComputeFrameLength>:

  return 0;
}

static int VD55G1_ComputeFrameLength(VD55G1_Ctx_t *ctx, int fps, uint16_t *frame_length)
{
34012124:	b5f0      	push	{r4, r5, r6, r7, lr}
34012126:	b089      	sub	sp, #36	@ 0x24
34012128:	460e      	mov	r6, r1
3401212a:	4617      	mov	r7, r2
  int req_frame_length;
  uint16_t line_length;
  uint16_t height;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
3401212c:	f44f 7140 	mov.w	r1, #768	@ 0x300
34012130:	6883      	ldr	r3, [r0, #8]
34012132:	aa07      	add	r2, sp, #28
{
34012134:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
34012136:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012138:	4605      	mov	r5, r0
3401213a:	b960      	cbnz	r0, 34012156 <VD55G1_ComputeFrameLength+0x32>

  ret = ctx->read16(ctx, VD55G1_REG_Y_HEIGHT, &height);
3401213c:	f240 5112 	movw	r1, #1298	@ 0x512
34012140:	4620      	mov	r0, r4
34012142:	68a3      	ldr	r3, [r4, #8]
34012144:	f10d 021e 	add.w	r2, sp, #30
34012148:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401214a:	4605      	mov	r5, r0
3401214c:	b190      	cbz	r0, 34012174 <VD55G1_ComputeFrameLength+0x50>
3401214e:	f44f 7316 	mov.w	r3, #600	@ 0x258
34012152:	9002      	str	r0, [sp, #8]
34012154:	e002      	b.n	3401215c <VD55G1_ComputeFrameLength+0x38>
  VD55G1_TraceError(ctx, ret);
34012156:	f240 2355 	movw	r3, #597	@ 0x255
3401215a:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401215c:	4a17      	ldr	r2, [pc, #92]	@ (340121bc <VD55G1_ComputeFrameLength+0x98>)
3401215e:	4620      	mov	r0, r4
34012160:	9200      	str	r2, [sp, #0]
34012162:	2100      	movs	r1, #0
34012164:	4a16      	ldr	r2, [pc, #88]	@ (340121c0 <VD55G1_ComputeFrameLength+0x9c>)
34012166:	9301      	str	r3, [sp, #4]
34012168:	f7ff fece 	bl	34011f08 <VD55G1_log_impl>
3401216c:	4620      	mov	r0, r4
3401216e:	f7ff ff29 	bl	34011fc4 <display_error>
34012172:	e01f      	b.n	340121b4 <VD55G1_ComputeFrameLength+0x90>

  min_frame_length = height + VD55G1_MIN_VBLANK;
  req_frame_length = drv_ctx->pclk / (line_length * fps);
34012174:	f8bd 201c 	ldrh.w	r2, [sp, #28]
34012178:	6b20      	ldr	r0, [r4, #48]	@ 0x30
3401217a:	4372      	muls	r2, r6
3401217c:	fbb0 f0f2 	udiv	r0, r0, r2
  min_frame_length = height + VD55G1_MIN_VBLANK;
34012180:	f8bd 301e 	ldrh.w	r3, [sp, #30]
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
34012184:	f64f 71ff 	movw	r1, #65535	@ 0xffff
  min_frame_length = height + VD55G1_MIN_VBLANK;
34012188:	3356      	adds	r3, #86	@ 0x56
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
3401218a:	4283      	cmp	r3, r0
3401218c:	461a      	mov	r2, r3
3401218e:	bfb8      	it	lt
34012190:	4602      	movlt	r2, r0
34012192:	428a      	cmp	r2, r1
34012194:	bfa8      	it	ge
34012196:	460a      	movge	r2, r1
34012198:	803a      	strh	r2, [r7, #0]

  VD55G1_dbg(ctx, 1, "frame_length to MAX(%d, %d) = %d to reach %d fps\n", min_frame_length, req_frame_length,
3401219a:	e9cd 3001 	strd	r3, r0, [sp, #4]
3401219e:	f240 235e 	movw	r3, #606	@ 0x25e
340121a2:	e9cd 2603 	strd	r2, r6, [sp, #12]
340121a6:	9300      	str	r3, [sp, #0]
340121a8:	2104      	movs	r1, #4
340121aa:	2301      	movs	r3, #1
340121ac:	4620      	mov	r0, r4
340121ae:	4a05      	ldr	r2, [pc, #20]	@ (340121c4 <VD55G1_ComputeFrameLength+0xa0>)
340121b0:	f7ff feaa 	bl	34011f08 <VD55G1_log_impl>
             *frame_length, fps);

  return 0;
}
340121b4:	4628      	mov	r0, r5
340121b6:	b009      	add	sp, #36	@ 0x24
340121b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
340121ba:	bf00      	nop
340121bc:	34035788 	.word	0x34035788
340121c0:	3401c9f0 	.word	0x3401c9f0
340121c4:	3401cac1 	.word	0x3401cac1

340121c8 <VD55G1_SetFlicker>:

  return 0;
}

static int VD55G1_SetFlicker(VD55G1_Ctx_t *ctx, VD55G1_Flicker_t flicker)
{
340121c8:	b530      	push	{r4, r5, lr}
340121ca:	2902      	cmp	r1, #2
340121cc:	4605      	mov	r5, r0
340121ce:	b085      	sub	sp, #20
340121d0:	d818      	bhi.n	34012204 <VD55G1_SetFlicker+0x3c>
    break;
  default:
    return -1;
  }

  ret = ctx->write16(ctx, VD55G1_REG_EXPOSURE_COMPILER_CONTROL_A, mode);
340121d2:	4a0e      	ldr	r2, [pc, #56]	@ (3401220c <VD55G1_SetFlicker+0x44>)
340121d4:	6943      	ldr	r3, [r0, #20]
340121d6:	5c52      	ldrb	r2, [r2, r1]
340121d8:	f240 4182 	movw	r1, #1154	@ 0x482
340121dc:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340121de:	4604      	mov	r4, r0
340121e0:	b168      	cbz	r0, 340121fe <VD55G1_SetFlicker+0x36>
340121e2:	f240 23ed 	movw	r3, #749	@ 0x2ed
340121e6:	4a0a      	ldr	r2, [pc, #40]	@ (34012210 <VD55G1_SetFlicker+0x48>)
340121e8:	9002      	str	r0, [sp, #8]
340121ea:	9200      	str	r2, [sp, #0]
340121ec:	4628      	mov	r0, r5
340121ee:	2100      	movs	r1, #0
340121f0:	4a08      	ldr	r2, [pc, #32]	@ (34012214 <VD55G1_SetFlicker+0x4c>)
340121f2:	9301      	str	r3, [sp, #4]
340121f4:	f7ff fe88 	bl	34011f08 <VD55G1_log_impl>
340121f8:	4628      	mov	r0, r5
340121fa:	f7ff fee3 	bl	34011fc4 <display_error>

  return 0;
}
340121fe:	4620      	mov	r0, r4
34012200:	b005      	add	sp, #20
34012202:	bd30      	pop	{r4, r5, pc}
    return -1;
34012204:	f04f 34ff 	mov.w	r4, #4294967295
34012208:	e7f9      	b.n	340121fe <VD55G1_SetFlicker+0x36>
3401220a:	bf00      	nop
3401220c:	340356ec 	.word	0x340356ec
34012210:	34035737 	.word	0x34035737
34012214:	3401c9f0 	.word	0x3401c9f0

34012218 <VD55G1_StopStreaming>:

  return 0;
}

static int VD55G1_StopStreaming(VD55G1_Ctx_t *ctx)
{
34012218:	b530      	push	{r4, r5, lr}
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
3401221a:	2201      	movs	r2, #1
3401221c:	f240 2102 	movw	r1, #514	@ 0x202
34012220:	6903      	ldr	r3, [r0, #16]
{
34012222:	b085      	sub	sp, #20
34012224:	4605      	mov	r5, r0
  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
34012226:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012228:	4604      	mov	r4, r0
3401222a:	b958      	cbnz	r0, 34012244 <VD55G1_StopStreaming+0x2c>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STREAMING, VD55G1_CMD_ACK);
3401222c:	4602      	mov	r2, r0
3401222e:	f240 2102 	movw	r1, #514	@ 0x202
34012232:	4628      	mov	r0, r5
34012234:	f7ff fe76 	bl	34011f24 <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012238:	4604      	mov	r4, r0
3401223a:	b190      	cbz	r0, 34012262 <VD55G1_StopStreaming+0x4a>
3401223c:	f240 3332 	movw	r3, #818	@ 0x332
34012240:	9002      	str	r0, [sp, #8]
34012242:	e002      	b.n	3401224a <VD55G1_StopStreaming+0x32>
  VD55G1_TraceError(ctx, ret);
34012244:	f240 332f 	movw	r3, #815	@ 0x32f
34012248:	9002      	str	r0, [sp, #8]

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
  VD55G1_TraceError(ctx, ret);
3401224a:	4a10      	ldr	r2, [pc, #64]	@ (3401228c <VD55G1_StopStreaming+0x74>)
3401224c:	4628      	mov	r0, r5
3401224e:	9200      	str	r2, [sp, #0]
34012250:	2100      	movs	r1, #0
34012252:	4a0f      	ldr	r2, [pc, #60]	@ (34012290 <VD55G1_StopStreaming+0x78>)
34012254:	9301      	str	r3, [sp, #4]
34012256:	f7ff fe57 	bl	34011f08 <VD55G1_log_impl>
3401225a:	4628      	mov	r0, r5
3401225c:	f7ff feb2 	bl	34011fc4 <display_error>
34012260:	e010      	b.n	34012284 <VD55G1_StopStreaming+0x6c>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
34012262:	2102      	movs	r1, #2
34012264:	4628      	mov	r0, r5
34012266:	f7ff fe89 	bl	34011f7c <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
3401226a:	4604      	mov	r4, r0
3401226c:	b118      	cbz	r0, 34012276 <VD55G1_StopStreaming+0x5e>
3401226e:	f240 3335 	movw	r3, #821	@ 0x335
34012272:	9002      	str	r0, [sp, #8]
34012274:	e7e9      	b.n	3401224a <VD55G1_StopStreaming+0x32>

  VD55G1_notice(ctx, "Streaming is off\n");
34012276:	f240 3337 	movw	r3, #823	@ 0x337
3401227a:	2102      	movs	r1, #2
3401227c:	4628      	mov	r0, r5
3401227e:	4a05      	ldr	r2, [pc, #20]	@ (34012294 <VD55G1_StopStreaming+0x7c>)
34012280:	f7ff fe42 	bl	34011f08 <VD55G1_log_impl>

  return 0;
}
34012284:	4620      	mov	r0, r4
34012286:	b005      	add	sp, #20
34012288:	bd30      	pop	{r4, r5, pc}
3401228a:	bf00      	nop
3401228c:	3403570c 	.word	0x3403570c
34012290:	3401c9f0 	.word	0x3401c9f0
34012294:	3401cb04 	.word	0x3401cb04

34012298 <VD55G1_Init>:

  return VD55G1_StartAWU(ctx);
}

int VD55G1_Init(VD55G1_Ctx_t *ctx, VD55G1_Config_t *config)
{
34012298:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  VD55G1_AWUConfig_t *awu = &config->awu;
  struct drv_ctx *drv_ctx = &ctx->ctx;
  int ret;

  if (config->frame_rate < VD55G1_MIN_FPS)
3401229c:	688b      	ldr	r3, [r1, #8]
{
3401229e:	4605      	mov	r5, r0
  if (config->frame_rate < VD55G1_MIN_FPS)
340122a0:	3b02      	subs	r3, #2
340122a2:	2ba6      	cmp	r3, #166	@ 0xa6
{
340122a4:	460c      	mov	r4, r1
340122a6:	b086      	sub	sp, #24
  if (config->frame_rate < VD55G1_MIN_FPS)
340122a8:	d802      	bhi.n	340122b0 <VD55G1_Init+0x18>
    return -1;
  if (config->frame_rate > VD55G1_MAX_FPS)
    return -1;

  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
340122aa:	790b      	ldrb	r3, [r1, #4]
340122ac:	2b03      	cmp	r3, #3
340122ae:	d905      	bls.n	340122bc <VD55G1_Init+0x24>
    return -1;
340122b0:	f04f 34ff 	mov.w	r4, #4294967295
    return ret;

  drv_ctx->state = VD55G1_ST_IDLE;

  return 0;
}
340122b4:	4620      	mov	r0, r4
340122b6:	b006      	add	sp, #24
340122b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (awu->is_enable && awu->threshold != VD55G1_AWU_THRESHOLD_DEFAULT) {
340122bc:	69cb      	ldr	r3, [r1, #28]
340122be:	b123      	cbz	r3, 340122ca <VD55G1_Init+0x32>
340122c0:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
340122c2:	b113      	cbz	r3, 340122ca <VD55G1_Init+0x32>
    if (awu->threshold < VD55G1_AWU_THRESHOLD_MIN)
340122c4:	3b02      	subs	r3, #2
340122c6:	2b7e      	cmp	r3, #126	@ 0x7e
340122c8:	d8f2      	bhi.n	340122b0 <VD55G1_Init+0x18>
  drv_ctx->config_save = *config;
340122ca:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340122cc:	f105 0634 	add.w	r6, r5, #52	@ 0x34
340122d0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340122d2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340122d4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340122d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340122d8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340122da:	6823      	ldr	r3, [r4, #0]
  ctx->shutdown_pin(ctx, 0);
340122dc:	2100      	movs	r1, #0
340122de:	4628      	mov	r0, r5
  drv_ctx->config_save = *config;
340122e0:	6033      	str	r3, [r6, #0]
  ctx->shutdown_pin(ctx, 0);
340122e2:	682b      	ldr	r3, [r5, #0]
340122e4:	4798      	blx	r3
  ctx->delay(ctx, 10);
340122e6:	210a      	movs	r1, #10
340122e8:	4628      	mov	r0, r5
340122ea:	6a2b      	ldr	r3, [r5, #32]
340122ec:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
340122ee:	2101      	movs	r1, #1
340122f0:	4628      	mov	r0, r5
340122f2:	682b      	ldr	r3, [r5, #0]
340122f4:	4798      	blx	r3
  ctx->delay(ctx, 10);
340122f6:	210a      	movs	r1, #10
340122f8:	4628      	mov	r0, r5
340122fa:	6a2b      	ldr	r3, [r5, #32]
340122fc:	4798      	blx	r3
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_READY_TO_BOOT);
340122fe:	2101      	movs	r1, #1
34012300:	4628      	mov	r0, r5
34012302:	f7ff fe3b 	bl	34011f7c <VD55G1_WaitState>
  if (ret)
34012306:	4604      	mov	r4, r0
34012308:	2800      	cmp	r0, #0
3401230a:	d1d3      	bne.n	340122b4 <VD55G1_Init+0x1c>
  ret = ctx->read32(ctx, VD55G1_REG_MODEL_ID, &reg32);
3401230c:	4601      	mov	r1, r0
3401230e:	68eb      	ldr	r3, [r5, #12]
34012310:	4628      	mov	r0, r5
34012312:	aa05      	add	r2, sp, #20
34012314:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012316:	4604      	mov	r4, r0
34012318:	b9c0      	cbnz	r0, 3401234c <VD55G1_Init+0xb4>
  VD55G1_dbg(ctx, 0, "model_id = 0x%04x\n", reg32);
3401231a:	9b05      	ldr	r3, [sp, #20]
3401231c:	4a52      	ldr	r2, [pc, #328]	@ (34012468 <VD55G1_Init+0x1d0>)
3401231e:	9301      	str	r3, [sp, #4]
34012320:	f240 1351 	movw	r3, #337	@ 0x151
34012324:	2103      	movs	r1, #3
34012326:	9300      	str	r3, [sp, #0]
34012328:	4603      	mov	r3, r0
3401232a:	4628      	mov	r0, r5
3401232c:	f7ff fdec 	bl	34011f08 <VD55G1_log_impl>
  if (reg32 != VD55G1_MODEL_ID) {
34012330:	9a05      	ldr	r2, [sp, #20]
34012332:	4b4e      	ldr	r3, [pc, #312]	@ (3401246c <VD55G1_Init+0x1d4>)
34012334:	429a      	cmp	r2, r3
34012336:	d018      	beq.n	3401236a <VD55G1_Init+0xd2>
    VD55G1_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD55G1_MODEL_ID, reg32);
34012338:	e9cd 3200 	strd	r3, r2, [sp]
3401233c:	4621      	mov	r1, r4
3401233e:	f240 1353 	movw	r3, #339	@ 0x153
34012342:	4628      	mov	r0, r5
34012344:	4a4a      	ldr	r2, [pc, #296]	@ (34012470 <VD55G1_Init+0x1d8>)
34012346:	f7ff fddf 	bl	34011f08 <VD55G1_log_impl>
  if (ret)
3401234a:	e7b1      	b.n	340122b0 <VD55G1_Init+0x18>
  VD55G1_TraceError(ctx, ret);
3401234c:	f44f 73a8 	mov.w	r3, #336	@ 0x150
34012350:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012352:	4a48      	ldr	r2, [pc, #288]	@ (34012474 <VD55G1_Init+0x1dc>)
34012354:	9301      	str	r3, [sp, #4]
    VD55G1_TraceError(ctx, ret);
34012356:	4628      	mov	r0, r5
34012358:	9200      	str	r2, [sp, #0]
3401235a:	2100      	movs	r1, #0
3401235c:	4a46      	ldr	r2, [pc, #280]	@ (34012478 <VD55G1_Init+0x1e0>)
3401235e:	f7ff fdd3 	bl	34011f08 <VD55G1_log_impl>
34012362:	4628      	mov	r0, r5
34012364:	f7ff fe2e 	bl	34011fc4 <display_error>
  if (ret)
34012368:	e7a4      	b.n	340122b4 <VD55G1_Init+0x1c>
  ret = ctx->read16(ctx, VD55G1_REG_REVISION, &reg16);
3401236a:	2104      	movs	r1, #4
3401236c:	4628      	mov	r0, r5
3401236e:	68ab      	ldr	r3, [r5, #8]
34012370:	f10d 0212 	add.w	r2, sp, #18
34012374:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012376:	4604      	mov	r4, r0
34012378:	b9f0      	cbnz	r0, 340123b8 <VD55G1_Init+0x120>
  VD55G1_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
3401237a:	f8bd 3012 	ldrh.w	r3, [sp, #18]
3401237e:	4a3f      	ldr	r2, [pc, #252]	@ (3401247c <VD55G1_Init+0x1e4>)
34012380:	9301      	str	r3, [sp, #4]
34012382:	f240 1359 	movw	r3, #345	@ 0x159
34012386:	2103      	movs	r1, #3
34012388:	9300      	str	r3, [sp, #0]
3401238a:	4603      	mov	r3, r0
3401238c:	4628      	mov	r0, r5
3401238e:	f7ff fdbb 	bl	34011f08 <VD55G1_log_impl>
  switch (reg16) {
34012392:	f241 0210 	movw	r2, #4112	@ 0x1010
34012396:	f8bd 3012 	ldrh.w	r3, [sp, #18]
3401239a:	4293      	cmp	r3, r2
3401239c:	d010      	beq.n	340123c0 <VD55G1_Init+0x128>
3401239e:	f242 0220 	movw	r2, #8224	@ 0x2020
340123a2:	4293      	cmp	r3, r2
340123a4:	d00c      	beq.n	340123c0 <VD55G1_Init+0x128>
    VD55G1_error(ctx, "Unsupported revision0x%04x\n", reg16);
340123a6:	9300      	str	r3, [sp, #0]
340123a8:	4621      	mov	r1, r4
340123aa:	f44f 73b1 	mov.w	r3, #354	@ 0x162
340123ae:	4628      	mov	r0, r5
340123b0:	4a33      	ldr	r2, [pc, #204]	@ (34012480 <VD55G1_Init+0x1e8>)
340123b2:	f7ff fda9 	bl	34011f08 <VD55G1_log_impl>
  if (ret)
340123b6:	e77b      	b.n	340122b0 <VD55G1_Init+0x18>
  VD55G1_TraceError(ctx, ret);
340123b8:	f44f 73ac 	mov.w	r3, #344	@ 0x158
340123bc:	9002      	str	r0, [sp, #8]
340123be:	e7c8      	b.n	34012352 <VD55G1_Init+0xba>
    drv_ctx->cut_version = VD55G1_REVISION_CUT_1;
340123c0:	62eb      	str	r3, [r5, #44]	@ 0x2c
  ret = ctx->read32(ctx, VD55G1_REG_ROM_REVISION, &reg32);
340123c2:	2108      	movs	r1, #8
340123c4:	4628      	mov	r0, r5
340123c6:	68eb      	ldr	r3, [r5, #12]
340123c8:	aa05      	add	r2, sp, #20
340123ca:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340123cc:	4604      	mov	r4, r0
340123ce:	b9d0      	cbnz	r0, 34012406 <VD55G1_Init+0x16e>
  VD55G1_dbg(ctx, 0, "rom = 0x%04x\n", reg32);
340123d0:	9b05      	ldr	r3, [sp, #20]
340123d2:	4a2c      	ldr	r2, [pc, #176]	@ (34012484 <VD55G1_Init+0x1ec>)
340123d4:	9301      	str	r3, [sp, #4]
340123d6:	f44f 73b4 	mov.w	r3, #360	@ 0x168
340123da:	2103      	movs	r1, #3
340123dc:	9300      	str	r3, [sp, #0]
340123de:	4603      	mov	r3, r0
340123e0:	4628      	mov	r0, r5
340123e2:	f7ff fd91 	bl	34011f08 <VD55G1_log_impl>
  switch (drv_ctx->cut_version) {
340123e6:	f241 0210 	movw	r2, #4112	@ 0x1010
340123ea:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
340123ec:	4293      	cmp	r3, r2
340123ee:	d00e      	beq.n	3401240e <VD55G1_Init+0x176>
340123f0:	f242 0220 	movw	r2, #8224	@ 0x2020
340123f4:	4293      	cmp	r3, r2
340123f6:	d02b      	beq.n	34012450 <VD55G1_Init+0x1b8>
    assert(0);
340123f8:	f44f 71cd 	mov.w	r1, #410	@ 0x19a
340123fc:	4b22      	ldr	r3, [pc, #136]	@ (34012488 <VD55G1_Init+0x1f0>)
340123fe:	4a23      	ldr	r2, [pc, #140]	@ (3401248c <VD55G1_Init+0x1f4>)
34012400:	4823      	ldr	r0, [pc, #140]	@ (34012490 <VD55G1_Init+0x1f8>)
34012402:	f005 fa59 	bl	340178b8 <__assert_func>
  VD55G1_TraceError(ctx, ret);
34012406:	f240 1367 	movw	r3, #359	@ 0x167
3401240a:	9002      	str	r0, [sp, #8]
3401240c:	e7a1      	b.n	34012352 <VD55G1_Init+0xba>
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_1, sizeof(patch_array_cut_1),
3401240e:	2316      	movs	r3, #22
34012410:	f241 22e4 	movw	r2, #4836	@ 0x12e4
34012414:	9300      	str	r3, [sp, #0]
34012416:	2301      	movs	r3, #1
34012418:	491e      	ldr	r1, [pc, #120]	@ (34012494 <VD55G1_Init+0x1fc>)
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
3401241a:	4628      	mov	r0, r5
3401241c:	f7ff fdf4 	bl	34012008 <VD55G1_ApplyPatchCommon>
34012420:	4604      	mov	r4, r0
  if (ret)
34012422:	2800      	cmp	r0, #0
34012424:	f47f af46 	bne.w	340122b4 <VD55G1_Init+0x1c>
34012428:	f240 561d 	movw	r6, #1309	@ 0x51d
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
3401242c:	f240 5821 	movw	r8, #1313	@ 0x521
34012430:	f105 0763 	add.w	r7, r5, #99	@ 0x63
    ret = ctx->write8(ctx, VD55G1_REG_GPIO_x(i), drv_ctx->config_save.gpio_ctrl[i]);
34012434:	4631      	mov	r1, r6
34012436:	4628      	mov	r0, r5
34012438:	692b      	ldr	r3, [r5, #16]
3401243a:	f817 2f01 	ldrb.w	r2, [r7, #1]!
3401243e:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
34012440:	4604      	mov	r4, r0
34012442:	b158      	cbz	r0, 3401245c <VD55G1_Init+0x1c4>
34012444:	f240 13a9 	movw	r3, #425	@ 0x1a9
34012448:	4a13      	ldr	r2, [pc, #76]	@ (34012498 <VD55G1_Init+0x200>)
3401244a:	9002      	str	r0, [sp, #8]
3401244c:	9301      	str	r3, [sp, #4]
3401244e:	e782      	b.n	34012356 <VD55G1_Init+0xbe>
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
34012450:	2302      	movs	r3, #2
34012452:	f44f 7272 	mov.w	r2, #968	@ 0x3c8
34012456:	4911      	ldr	r1, [pc, #68]	@ (3401249c <VD55G1_Init+0x204>)
34012458:	9300      	str	r3, [sp, #0]
3401245a:	e7de      	b.n	3401241a <VD55G1_Init+0x182>
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
3401245c:	3601      	adds	r6, #1
3401245e:	b2b6      	uxth	r6, r6
34012460:	4546      	cmp	r6, r8
34012462:	d1e7      	bne.n	34012434 <VD55G1_Init+0x19c>
  drv_ctx->state = VD55G1_ST_IDLE;
34012464:	62a8      	str	r0, [r5, #40]	@ 0x28
  return 0;
34012466:	e725      	b.n	340122b4 <VD55G1_Init+0x1c>
34012468:	3401cb26 	.word	0x3401cb26
3401246c:	53354731 	.word	0x53354731
34012470:	3401cb4a 	.word	0x3401cb4a
34012474:	34035855 	.word	0x34035855
34012478:	3401c9f0 	.word	0x3401c9f0
3401247c:	3401cb85 	.word	0x3401cb85
34012480:	3401cba9 	.word	0x3401cba9
34012484:	3401cbd5 	.word	0x3401cbd5
34012488:	3401d1fc 	.word	0x3401d1fc
3401248c:	34035835 	.word	0x34035835
34012490:	3401c96c 	.word	0x3401c96c
34012494:	34035ca4 	.word	0x34035ca4
34012498:	34035810 	.word	0x34035810
3401249c:	340358dc 	.word	0x340358dc

340124a0 <VD55G1_DeInit>:

int VD55G1_DeInit(VD55G1_Ctx_t *ctx)
{
  struct drv_ctx *drv_ctx = &ctx->ctx;

  if (drv_ctx->state == VD55G1_ST_STREAMING)
340124a0:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
340124a2:	b510      	push	{r4, lr}
  if (drv_ctx->state == VD55G1_ST_STREAMING)
340124a4:	2b01      	cmp	r3, #1
{
340124a6:	4604      	mov	r4, r0
  if (drv_ctx->state == VD55G1_ST_STREAMING)
340124a8:	d008      	beq.n	340124bc <VD55G1_DeInit+0x1c>
    return -1;

  ctx->shutdown_pin(ctx, 0);
340124aa:	6803      	ldr	r3, [r0, #0]
340124ac:	2100      	movs	r1, #0
340124ae:	4798      	blx	r3
  ctx->delay(ctx, 10);
340124b0:	4620      	mov	r0, r4
340124b2:	210a      	movs	r1, #10
340124b4:	6a23      	ldr	r3, [r4, #32]
340124b6:	4798      	blx	r3

  return 0;
340124b8:	2000      	movs	r0, #0
}
340124ba:	bd10      	pop	{r4, pc}
    return -1;
340124bc:	f04f 30ff 	mov.w	r0, #4294967295
340124c0:	e7fb      	b.n	340124ba <VD55G1_DeInit+0x1a>
340124c2:	0000      	movs	r0, r0
340124c4:	0000      	movs	r0, r0
	...

340124c8 <VD55G1_Start>:

int VD55G1_Start(VD55G1_Ctx_t *ctx)
{
340124c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
340124ca:	6c43      	ldr	r3, [r0, #68]	@ 0x44
340124cc:	4e8a      	ldr	r6, [pc, #552]	@ (340126f8 <VD55G1_Start+0x230>)
340124ce:	4a8b      	ldr	r2, [pc, #556]	@ (340126fc <VD55G1_Start+0x234>)
340124d0:	4433      	add	r3, r6
340124d2:	4293      	cmp	r3, r2
{
340124d4:	4605      	mov	r5, r0
340124d6:	b087      	sub	sp, #28
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
340124d8:	d87e      	bhi.n	340125d8 <VD55G1_Start+0x110>
  ret = ctx->write32(ctx, VD55G1_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
340124da:	f44f 7108 	mov.w	r1, #544	@ 0x220
340124de:	6983      	ldr	r3, [r0, #24]
340124e0:	6b42      	ldr	r2, [r0, #52]	@ 0x34
340124e2:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340124e4:	4604      	mov	r4, r0
340124e6:	b958      	cbnz	r0, 34012500 <VD55G1_Start+0x38>
  ret = ctx->write32(ctx, VD55G1_REG_MIPI_DATA_RATE, drv_ctx->config_save.out_itf.data_rate_in_mps);
340124e8:	f44f 7109 	mov.w	r1, #548	@ 0x224
340124ec:	4628      	mov	r0, r5
340124ee:	69ab      	ldr	r3, [r5, #24]
340124f0:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
340124f2:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340124f4:	4604      	mov	r4, r0
340124f6:	b300      	cbz	r0, 3401253a <VD55G1_Start+0x72>
340124f8:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
340124fc:	9002      	str	r0, [sp, #8]
340124fe:	e002      	b.n	34012506 <VD55G1_Start+0x3e>
  VD55G1_TraceError(ctx, ret);
34012500:	f240 13f5 	movw	r3, #501	@ 0x1f5
34012504:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012506:	4a7e      	ldr	r2, [pc, #504]	@ (34012700 <VD55G1_Start+0x238>)
34012508:	4628      	mov	r0, r5
3401250a:	9200      	str	r2, [sp, #0]
3401250c:	2100      	movs	r1, #0
3401250e:	4a7d      	ldr	r2, [pc, #500]	@ (34012704 <VD55G1_Start+0x23c>)
34012510:	9301      	str	r3, [sp, #4]
34012512:	f7ff fcf9 	bl	34011f08 <VD55G1_log_impl>
34012516:	4628      	mov	r0, r5
34012518:	f7ff fd54 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
3401251c:	f240 23fe 	movw	r3, #766	@ 0x2fe
34012520:	9402      	str	r4, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012522:	4a79      	ldr	r2, [pc, #484]	@ (34012708 <VD55G1_Start+0x240>)
34012524:	9301      	str	r3, [sp, #4]
  VD55G1_TraceError(ctx, ret);
34012526:	4628      	mov	r0, r5
34012528:	9200      	str	r2, [sp, #0]
3401252a:	2100      	movs	r1, #0
3401252c:	4a75      	ldr	r2, [pc, #468]	@ (34012704 <VD55G1_Start+0x23c>)
3401252e:	f7ff fceb 	bl	34011f08 <VD55G1_log_impl>
34012532:	4628      	mov	r0, r5
34012534:	f7ff fd46 	bl	34011fc4 <display_error>
  ret = VD55G1_Setup(ctx);
  if (ret)
    return ret;

  ret = VD55G1_StartStreaming(ctx);
  if (ret)
34012538:	e233      	b.n	340129a2 <VD55G1_Start+0x4da>
  ret = ctx->read32(ctx, VD55G1_REG_MIPI_DATA_RATE, &mipi_data_rate);
3401253a:	f44f 7109 	mov.w	r1, #548	@ 0x224
3401253e:	4628      	mov	r0, r5
34012540:	68eb      	ldr	r3, [r5, #12]
34012542:	aa05      	add	r2, sp, #20
34012544:	4798      	blx	r3
  if (ret)
34012546:	2800      	cmp	r0, #0
34012548:	d144      	bne.n	340125d4 <VD55G1_Start+0x10c>
  if (mipi_data_rate <= 1200000000 && mipi_data_rate > 600000000)
3401254a:	9b05      	ldr	r3, [sp, #20]
3401254c:	4a6f      	ldr	r2, [pc, #444]	@ (3401270c <VD55G1_Start+0x244>)
3401254e:	4970      	ldr	r1, [pc, #448]	@ (34012710 <VD55G1_Start+0x248>)
34012550:	441a      	add	r2, r3
34012552:	428a      	cmp	r2, r1
34012554:	496f      	ldr	r1, [pc, #444]	@ (34012714 <VD55G1_Start+0x24c>)
34012556:	d904      	bls.n	34012562 <VD55G1_Start+0x9a>
  else if (mipi_data_rate <= 600000000 && mipi_data_rate > 300000000)
34012558:	4a6f      	ldr	r2, [pc, #444]	@ (34012718 <VD55G1_Start+0x250>)
3401255a:	441a      	add	r2, r3
3401255c:	428a      	cmp	r2, r1
3401255e:	d80e      	bhi.n	3401257e <VD55G1_Start+0xb6>
    return mipi_data_rate * 2;
34012560:	005b      	lsls	r3, r3, #1
  if (system_clk <= 1200000000 && system_clk > 900000000)
34012562:	4a6e      	ldr	r2, [pc, #440]	@ (3401271c <VD55G1_Start+0x254>)
34012564:	441a      	add	r2, r3
34012566:	428a      	cmp	r2, r1
34012568:	d90e      	bls.n	34012588 <VD55G1_Start+0xc0>
  else if (system_clk <= 900000000 && system_clk > 780000000)
3401256a:	4a6d      	ldr	r2, [pc, #436]	@ (34012720 <VD55G1_Start+0x258>)
3401256c:	496d      	ldr	r1, [pc, #436]	@ (34012724 <VD55G1_Start+0x25c>)
3401256e:	441a      	add	r2, r3
34012570:	428a      	cmp	r2, r1
    return system_clk / 6;
34012572:	bf94      	ite	ls
34012574:	2206      	movls	r2, #6
    return system_clk / 5;
34012576:	2205      	movhi	r2, #5
34012578:	fbb3 f3f2 	udiv	r3, r3, r2
  if (!drv_ctx->pclk)
3401257c:	e005      	b.n	3401258a <VD55G1_Start+0xc2>
  else if (mipi_data_rate <= 300000000 && mipi_data_rate >= 250000000)
3401257e:	4a6a      	ldr	r2, [pc, #424]	@ (34012728 <VD55G1_Start+0x260>)
34012580:	441e      	add	r6, r3
34012582:	4296      	cmp	r6, r2
34012584:	d826      	bhi.n	340125d4 <VD55G1_Start+0x10c>
    return mipi_data_rate * 4;
34012586:	009b      	lsls	r3, r3, #2
    return system_clk / 8;
34012588:	08db      	lsrs	r3, r3, #3
  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
3401258a:	632b      	str	r3, [r5, #48]	@ 0x30
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
3401258c:	6cab      	ldr	r3, [r5, #72]	@ 0x48
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
3401258e:	2208      	movs	r2, #8
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34012590:	3b00      	subs	r3, #0
34012592:	bf18      	it	ne
34012594:	2301      	movne	r3, #1
34012596:	64ab      	str	r3, [r5, #72]	@ 0x48
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
34012598:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
3401259a:	f240 310a 	movw	r1, #778	@ 0x30a
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
3401259e:	3b00      	subs	r3, #0
340125a0:	bf18      	it	ne
340125a2:	2301      	movne	r3, #1
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
340125a4:	4628      	mov	r0, r5
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
340125a6:	64eb      	str	r3, [r5, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
340125a8:	692b      	ldr	r3, [r5, #16]
340125aa:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340125ac:	4604      	mov	r4, r0
340125ae:	b1b0      	cbz	r0, 340125de <VD55G1_Start+0x116>
340125b0:	f240 230d 	movw	r3, #525	@ 0x20d
340125b4:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340125b6:	4a5d      	ldr	r2, [pc, #372]	@ (3401272c <VD55G1_Start+0x264>)
340125b8:	9301      	str	r3, [sp, #4]
340125ba:	2100      	movs	r1, #0
340125bc:	4628      	mov	r0, r5
340125be:	9200      	str	r2, [sp, #0]
340125c0:	4a50      	ldr	r2, [pc, #320]	@ (34012704 <VD55G1_Start+0x23c>)
340125c2:	f7ff fca1 	bl	34011f08 <VD55G1_log_impl>
340125c6:	4628      	mov	r0, r5
340125c8:	f7ff fcfc 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
340125cc:	f240 3301 	movw	r3, #769	@ 0x301
340125d0:	9402      	str	r4, [sp, #8]
340125d2:	e7a6      	b.n	34012522 <VD55G1_Start+0x5a>
  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
340125d4:	2300      	movs	r3, #0
340125d6:	632b      	str	r3, [r5, #48]	@ 0x30
    return -1;
340125d8:	f04f 34ff 	mov.w	r4, #4294967295
340125dc:	e79e      	b.n	3401251c <VD55G1_Start+0x54>
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
340125de:	e9d5 2312 	ldrd	r2, r3, [r5, #72]	@ 0x48
340125e2:	00d2      	lsls	r2, r2, #3
340125e4:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
  ret = ctx->write16(ctx, VD55G1_REG_OIF_CTRL, oif_ctrl);
340125e8:	f44f 7143 	mov.w	r1, #780	@ 0x30c
340125ec:	4628      	mov	r0, r5
340125ee:	696b      	ldr	r3, [r5, #20]
340125f0:	b292      	uxth	r2, r2
340125f2:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340125f4:	4604      	mov	r4, r0
340125f6:	b958      	cbnz	r0, 34012610 <VD55G1_Start+0x148>
  ret = ctx->write8(ctx, VD55G1_REG_OIF_IMG_CTRL, 0x2a);
340125f8:	222a      	movs	r2, #42	@ 0x2a
340125fa:	f240 310f 	movw	r1, #783	@ 0x30f
340125fe:	4628      	mov	r0, r5
34012600:	692b      	ldr	r3, [r5, #16]
34012602:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012604:	4604      	mov	r4, r0
34012606:	b138      	cbz	r0, 34012618 <VD55G1_Start+0x150>
34012608:	f240 2317 	movw	r3, #535	@ 0x217
3401260c:	9002      	str	r0, [sp, #8]
3401260e:	e7d2      	b.n	340125b6 <VD55G1_Start+0xee>
  VD55G1_TraceError(ctx, ret);
34012610:	f240 2313 	movw	r3, #531	@ 0x213
34012614:	9002      	str	r0, [sp, #8]
34012616:	e7ce      	b.n	340125b6 <VD55G1_Start+0xee>
  mode = VD55G1_Resolution2Mode(drv_ctx->config_save.resolution);
34012618:	f895 3038 	ldrb.w	r3, [r5, #56]	@ 0x38
  switch (resolution) {
3401261c:	2b03      	cmp	r3, #3
3401261e:	f200 8102 	bhi.w	34012826 <VD55G1_Start+0x35e>
34012622:	4a43      	ldr	r2, [pc, #268]	@ (34012730 <VD55G1_Start+0x268>)
34012624:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
  if (!mode)
34012628:	2e00      	cmp	r6, #0
3401262a:	f000 80fc 	beq.w	34012826 <VD55G1_Start+0x35e>
  ret = ctx->write8(ctx, VD55G1_REG_READOUT_CTRL, mode->bin_mode);
3401262e:	f240 512e 	movw	r1, #1326	@ 0x52e
34012632:	4628      	mov	r0, r5
34012634:	692b      	ldr	r3, [r5, #16]
34012636:	7a32      	ldrb	r2, [r6, #8]
34012638:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401263a:	4604      	mov	r4, r0
3401263c:	b188      	cbz	r0, 34012662 <VD55G1_Start+0x19a>
3401263e:	f240 2327 	movw	r3, #551	@ 0x227
34012642:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012644:	4a3b      	ldr	r2, [pc, #236]	@ (34012734 <VD55G1_Start+0x26c>)
34012646:	4628      	mov	r0, r5
34012648:	9200      	str	r2, [sp, #0]
3401264a:	2100      	movs	r1, #0
3401264c:	4a2d      	ldr	r2, [pc, #180]	@ (34012704 <VD55G1_Start+0x23c>)
3401264e:	9301      	str	r3, [sp, #4]
34012650:	f7ff fc5a 	bl	34011f08 <VD55G1_log_impl>
34012654:	4628      	mov	r0, r5
34012656:	f7ff fcb5 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
3401265a:	f44f 7341 	mov.w	r3, #772	@ 0x304
3401265e:	9402      	str	r4, [sp, #8]
34012660:	e75f      	b.n	34012522 <VD55G1_Start+0x5a>
  ret = ctx->write16(ctx, VD55G1_REG_X_START, mode->crop.left);
34012662:	f240 5114 	movw	r1, #1300	@ 0x514
34012666:	4628      	mov	r0, r5
34012668:	696b      	ldr	r3, [r5, #20]
3401266a:	89b2      	ldrh	r2, [r6, #12]
3401266c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401266e:	4604      	mov	r4, r0
34012670:	b958      	cbnz	r0, 3401268a <VD55G1_Start+0x1c2>
  ret = ctx->write16(ctx, VD55G1_REG_X_WIDTH, mode->crop.width);
34012672:	f240 5116 	movw	r1, #1302	@ 0x516
34012676:	4628      	mov	r0, r5
34012678:	696b      	ldr	r3, [r5, #20]
3401267a:	8ab2      	ldrh	r2, [r6, #20]
3401267c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401267e:	4604      	mov	r4, r0
34012680:	b138      	cbz	r0, 34012692 <VD55G1_Start+0x1ca>
34012682:	f44f 730b 	mov.w	r3, #556	@ 0x22c
34012686:	9002      	str	r0, [sp, #8]
34012688:	e7dc      	b.n	34012644 <VD55G1_Start+0x17c>
  VD55G1_TraceError(ctx, ret);
3401268a:	f240 232a 	movw	r3, #554	@ 0x22a
3401268e:	9002      	str	r0, [sp, #8]
34012690:	e7d8      	b.n	34012644 <VD55G1_Start+0x17c>
  ret = ctx->write16(ctx, VD55G1_REG_Y_START, mode->crop.top);
34012692:	f44f 61a2 	mov.w	r1, #1296	@ 0x510
34012696:	4628      	mov	r0, r5
34012698:	696b      	ldr	r3, [r5, #20]
3401269a:	8a32      	ldrh	r2, [r6, #16]
3401269c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401269e:	4604      	mov	r4, r0
340126a0:	b118      	cbz	r0, 340126aa <VD55G1_Start+0x1e2>
340126a2:	f240 232e 	movw	r3, #558	@ 0x22e
340126a6:	9002      	str	r0, [sp, #8]
340126a8:	e7cc      	b.n	34012644 <VD55G1_Start+0x17c>
  ret = ctx->write16(ctx, VD55G1_REG_Y_HEIGHT, mode->crop.height);
340126aa:	f240 5112 	movw	r1, #1298	@ 0x512
340126ae:	4628      	mov	r0, r5
340126b0:	696b      	ldr	r3, [r5, #20]
340126b2:	8b32      	ldrh	r2, [r6, #24]
340126b4:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340126b6:	4604      	mov	r4, r0
340126b8:	b118      	cbz	r0, 340126c2 <VD55G1_Start+0x1fa>
340126ba:	f44f 730c 	mov.w	r3, #560	@ 0x230
340126be:	9002      	str	r0, [sp, #8]
340126c0:	e7c0      	b.n	34012644 <VD55G1_Start+0x17c>
  ret = ctx->read16(ctx, VD55G1_REG_X_WIDTH, &width);
340126c2:	f240 5116 	movw	r1, #1302	@ 0x516
340126c6:	4628      	mov	r0, r5
340126c8:	68ab      	ldr	r3, [r5, #8]
340126ca:	aa05      	add	r2, sp, #20
340126cc:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340126ce:	4604      	mov	r4, r0
340126d0:	b3a0      	cbz	r0, 3401273c <VD55G1_Start+0x274>
340126d2:	f240 233e 	movw	r3, #574	@ 0x23e
340126d6:	9002      	str	r0, [sp, #8]
340126d8:	4a17      	ldr	r2, [pc, #92]	@ (34012738 <VD55G1_Start+0x270>)
340126da:	9301      	str	r3, [sp, #4]
340126dc:	4628      	mov	r0, r5
340126de:	9200      	str	r2, [sp, #0]
340126e0:	2100      	movs	r1, #0
340126e2:	4a08      	ldr	r2, [pc, #32]	@ (34012704 <VD55G1_Start+0x23c>)
340126e4:	f7ff fc10 	bl	34011f08 <VD55G1_log_impl>
340126e8:	4628      	mov	r0, r5
340126ea:	f7ff fc6b 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
340126ee:	f240 3307 	movw	r3, #775	@ 0x307
340126f2:	9402      	str	r4, [sp, #8]
340126f4:	e715      	b.n	34012522 <VD55G1_Start+0x5a>
340126f6:	bf00      	nop
340126f8:	f1194d80 	.word	0xf1194d80
340126fc:	389fd980 	.word	0x389fd980
34012700:	340357f0 	.word	0x340357f0
34012704:	3401c9f0 	.word	0x3401c9f0
34012708:	34035803 	.word	0x34035803
3401270c:	dc3cb9ff 	.word	0xdc3cb9ff
34012710:	23c345ff 	.word	0x23c345ff
34012714:	11e1a2ff 	.word	0x11e1a2ff
34012718:	ee1e5cff 	.word	0xee1e5cff
3401271c:	ca5b16ff 	.word	0xca5b16ff
34012720:	d18224ff 	.word	0xd18224ff
34012724:	07270dff 	.word	0x07270dff
34012728:	02faf080 	.word	0x02faf080
3401272c:	340357dd 	.word	0x340357dd
34012730:	340356fc 	.word	0x340356fc
34012734:	340357cc 	.word	0x340357cc
34012738:	340357a2 	.word	0x340357a2
  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
3401273c:	f8bd 1014 	ldrh.w	r1, [sp, #20]
34012740:	6b28      	ldr	r0, [r5, #48]	@ 0x30
34012742:	00c9      	lsls	r1, r1, #3
34012744:	f501 7161 	add.w	r1, r1, #900	@ 0x384
                      / VD55G1_MIPI_DATA_RATE_HZ;
34012748:	a3a3      	add	r3, pc, #652	@ (adr r3, 340129d8 <VD55G1_Start+0x510>)
3401274a:	e9d3 2300 	ldrd	r2, r3, [r3]
3401274e:	fba1 0100 	umull	r0, r1, r1, r0
34012752:	f7ee ff43 	bl	340015dc <__aeabi_uldivmod>
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
34012756:	f5b0 6f8d 	cmp.w	r0, #1128	@ 0x468
3401275a:	bfb8      	it	lt
3401275c:	f44f 608d 	movlt.w	r0, #1128	@ 0x468
  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
34012760:	f44f 7140 	mov.w	r1, #768	@ 0x300
34012764:	b282      	uxth	r2, r0
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
34012766:	4606      	mov	r6, r0
  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
34012768:	696b      	ldr	r3, [r5, #20]
3401276a:	4628      	mov	r0, r5
3401276c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401276e:	4604      	mov	r4, r0
34012770:	2800      	cmp	r0, #0
34012772:	d14e      	bne.n	34012812 <VD55G1_Start+0x34a>
  VD55G1_dbg(ctx, 1, "line_length = %d\n", line_len);
34012774:	f240 2346 	movw	r3, #582	@ 0x246
34012778:	b2b6      	uxth	r6, r6
3401277a:	2104      	movs	r1, #4
3401277c:	4628      	mov	r0, r5
3401277e:	4a8a      	ldr	r2, [pc, #552]	@ (340129a8 <VD55G1_Start+0x4e0>)
34012780:	9300      	str	r3, [sp, #0]
34012782:	9601      	str	r6, [sp, #4]
34012784:	2301      	movs	r3, #1
34012786:	f7ff fbbf 	bl	34011f08 <VD55G1_log_impl>
  ret = VD55G1_ComputeFrameLength(ctx, drv_ctx->config_save.frame_rate, &frame_length);
3401278a:	4628      	mov	r0, r5
3401278c:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
3401278e:	aa05      	add	r2, sp, #20
34012790:	f7ff fcc8 	bl	34012124 <VD55G1_ComputeFrameLength>
  if (ret)
34012794:	4604      	mov	r4, r0
34012796:	2800      	cmp	r0, #0
34012798:	d1a9      	bne.n	340126ee <VD55G1_Start+0x226>
  VD55G1_dbg(ctx, 1, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
3401279a:	f8bd 4014 	ldrh.w	r4, [sp, #20]
3401279e:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
340127a0:	2104      	movs	r1, #4
340127a2:	e9cd 4301 	strd	r4, r3, [sp, #4]
340127a6:	f240 2372 	movw	r3, #626	@ 0x272
340127aa:	4628      	mov	r0, r5
340127ac:	4a7f      	ldr	r2, [pc, #508]	@ (340129ac <VD55G1_Start+0x4e4>)
340127ae:	9300      	str	r3, [sp, #0]
340127b0:	2301      	movs	r3, #1
340127b2:	f7ff fba9 	bl	34011f08 <VD55G1_log_impl>
  ret = ctx->write16(ctx, VD55G1_REG_FRAME_LENGTH, frame_length);
340127b6:	4622      	mov	r2, r4
340127b8:	f240 510c 	movw	r1, #1292	@ 0x50c
340127bc:	4628      	mov	r0, r5
340127be:	696b      	ldr	r3, [r5, #20]
340127c0:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340127c2:	4604      	mov	r4, r0
340127c4:	bb48      	cbnz	r0, 3401281a <VD55G1_Start+0x352>
  if (awu->is_enable)
340127c6:	6d2b      	ldr	r3, [r5, #80]	@ 0x50
  max_fps = drv_ctx->config_save.frame_rate;
340127c8:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
  if (awu->is_enable)
340127ca:	bb7b      	cbnz	r3, 3401282c <VD55G1_Start+0x364>
  ret = VD55G1_ComputeFrameLength(ctx, max_fps, &frame_length);
340127cc:	4628      	mov	r0, r5
340127ce:	aa05      	add	r2, sp, #20
340127d0:	f7ff fca8 	bl	34012124 <VD55G1_ComputeFrameLength>
  if (ret)
340127d4:	4604      	mov	r4, r0
340127d6:	b9c0      	cbnz	r0, 3401280a <VD55G1_Start+0x342>
  ret = ctx->write16(ctx, VD55G1_REG_MAX_COARSE_INTEGRATION_LINES, frame_length - 10);
340127d8:	f8bd 6014 	ldrh.w	r6, [sp, #20]
340127dc:	f240 3172 	movw	r1, #882	@ 0x372
340127e0:	3e0a      	subs	r6, #10
340127e2:	4628      	mov	r0, r5
340127e4:	696b      	ldr	r3, [r5, #20]
340127e6:	b2b2      	uxth	r2, r6
340127e8:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340127ea:	4604      	mov	r4, r0
340127ec:	b338      	cbz	r0, 3401283e <VD55G1_Start+0x376>
340127ee:	f240 238f 	movw	r3, #655	@ 0x28f
340127f2:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340127f4:	4a6e      	ldr	r2, [pc, #440]	@ (340129b0 <VD55G1_Start+0x4e8>)
340127f6:	4628      	mov	r0, r5
340127f8:	9200      	str	r2, [sp, #0]
340127fa:	2100      	movs	r1, #0
340127fc:	4a6d      	ldr	r2, [pc, #436]	@ (340129b4 <VD55G1_Start+0x4ec>)
340127fe:	9301      	str	r3, [sp, #4]
34012800:	f7ff fb82 	bl	34011f08 <VD55G1_log_impl>
34012804:	4628      	mov	r0, r5
34012806:	f7ff fbdd 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
3401280a:	f240 330a 	movw	r3, #778	@ 0x30a
3401280e:	9402      	str	r4, [sp, #8]
34012810:	e687      	b.n	34012522 <VD55G1_Start+0x5a>
  VD55G1_TraceError(ctx, ret);
34012812:	f240 2345 	movw	r3, #581	@ 0x245
34012816:	9002      	str	r0, [sp, #8]
34012818:	e75e      	b.n	340126d8 <VD55G1_Start+0x210>
  VD55G1_TraceError(ctx, ret);
3401281a:	f44f 731d 	mov.w	r3, #628	@ 0x274
3401281e:	4a66      	ldr	r2, [pc, #408]	@ (340129b8 <VD55G1_Start+0x4f0>)
34012820:	9002      	str	r0, [sp, #8]
34012822:	9301      	str	r3, [sp, #4]
34012824:	e75a      	b.n	340126dc <VD55G1_Start+0x214>
34012826:	f04f 34ff 	mov.w	r4, #4294967295
3401282a:	e716      	b.n	3401265a <VD55G1_Start+0x192>
    max_fps = MAX(max_fps, awu->convergence_frame_rate);
3401282c:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
3401282e:	4299      	cmp	r1, r3
34012830:	bfb8      	it	lt
34012832:	4619      	movlt	r1, r3
    max_fps = MAX(max_fps, awu->awu_frame_rate);
34012834:	6dab      	ldr	r3, [r5, #88]	@ 0x58
34012836:	4299      	cmp	r1, r3
34012838:	bfb8      	it	lt
3401283a:	4619      	movlt	r1, r3
3401283c:	e7c6      	b.n	340127cc <VD55G1_Start+0x304>
  VD55G1_dbg(ctx, 1, "Max coarse lines = %d\n", frame_length - 10);
3401283e:	f44f 7324 	mov.w	r3, #656	@ 0x290
34012842:	2104      	movs	r1, #4
34012844:	4628      	mov	r0, r5
34012846:	4a5d      	ldr	r2, [pc, #372]	@ (340129bc <VD55G1_Start+0x4f4>)
34012848:	9300      	str	r3, [sp, #0]
3401284a:	9601      	str	r6, [sp, #4]
3401284c:	2301      	movs	r3, #1
3401284e:	f7ff fb5b 	bl	34011f08 <VD55G1_log_impl>
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
34012852:	f895 2041 	ldrb.w	r2, [r5, #65]	@ 0x41
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
34012856:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
3401285a:	3a00      	subs	r2, #0
3401285c:	bf18      	it	ne
3401285e:	2201      	movne	r2, #1
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
34012860:	4628      	mov	r0, r5
34012862:	692b      	ldr	r3, [r5, #16]
34012864:	0052      	lsls	r2, r2, #1
34012866:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012868:	4604      	mov	r4, r0
3401286a:	b118      	cbz	r0, 34012874 <VD55G1_Start+0x3ac>
3401286c:	f240 2395 	movw	r3, #661	@ 0x295
34012870:	9002      	str	r0, [sp, #8]
34012872:	e7bf      	b.n	340127f4 <VD55G1_Start+0x32c>
  switch (drv_ctx->config_save.flip_mirror_mode) {
34012874:	f895 3040 	ldrb.w	r3, [r5, #64]	@ 0x40
34012878:	2b03      	cmp	r3, #3
3401287a:	d905      	bls.n	34012888 <VD55G1_Start+0x3c0>
    return -1;
3401287c:	f04f 34ff 	mov.w	r4, #4294967295
  VD55G1_TraceError(ctx, ret);
34012880:	f240 330d 	movw	r3, #781	@ 0x30d
34012884:	9402      	str	r4, [sp, #8]
34012886:	e64c      	b.n	34012522 <VD55G1_Start+0x5a>
  ret = ctx->write8(ctx, VD55G1_REG_ORIENTATION, mode);
34012888:	4a4d      	ldr	r2, [pc, #308]	@ (340129c0 <VD55G1_Start+0x4f8>)
3401288a:	692c      	ldr	r4, [r5, #16]
3401288c:	f240 3102 	movw	r1, #770	@ 0x302
34012890:	4628      	mov	r0, r5
34012892:	5cd2      	ldrb	r2, [r2, r3]
34012894:	47a0      	blx	r4
  VD55G1_TraceError(ctx, ret);
34012896:	4604      	mov	r4, r0
34012898:	b948      	cbnz	r0, 340128ae <VD55G1_Start+0x3e6>
  switch (drv_ctx->config_save.patgen) {
3401289a:	f895 3041 	ldrb.w	r3, [r5, #65]	@ 0x41
3401289e:	2b02      	cmp	r3, #2
340128a0:	d914      	bls.n	340128cc <VD55G1_Start+0x404>
    return -1;
340128a2:	f04f 34ff 	mov.w	r4, #4294967295
  VD55G1_TraceError(ctx, ret);
340128a6:	f44f 7344 	mov.w	r3, #784	@ 0x310
340128aa:	9402      	str	r4, [sp, #8]
340128ac:	e639      	b.n	34012522 <VD55G1_Start+0x5a>
  VD55G1_TraceError(ctx, ret);
340128ae:	f240 23b2 	movw	r3, #690	@ 0x2b2
340128b2:	4a44      	ldr	r2, [pc, #272]	@ (340129c4 <VD55G1_Start+0x4fc>)
340128b4:	9002      	str	r0, [sp, #8]
340128b6:	9200      	str	r2, [sp, #0]
340128b8:	4628      	mov	r0, r5
340128ba:	2100      	movs	r1, #0
340128bc:	4a3d      	ldr	r2, [pc, #244]	@ (340129b4 <VD55G1_Start+0x4ec>)
340128be:	9301      	str	r3, [sp, #4]
340128c0:	f7ff fb22 	bl	34011f08 <VD55G1_log_impl>
340128c4:	4628      	mov	r0, r5
340128c6:	f7ff fb7d 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
340128ca:	e7d9      	b.n	34012880 <VD55G1_Start+0x3b8>
340128cc:	4a3e      	ldr	r2, [pc, #248]	@ (340129c8 <VD55G1_Start+0x500>)
340128ce:	f832 6013 	ldrh.w	r6, [r2, r3, lsl #1]
  if (drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE)
340128d2:	b313      	cbz	r3, 3401291a <VD55G1_Start+0x452>
    ret = ctx->write8(ctx, VD55G1_REG_DUSTER_CTRL, VD55G1_DUSTER_DISABLE);
340128d4:	4602      	mov	r2, r0
340128d6:	f240 31ae 	movw	r1, #942	@ 0x3ae
340128da:	4628      	mov	r0, r5
340128dc:	692b      	ldr	r3, [r5, #16]
340128de:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
340128e0:	4604      	mov	r4, r0
340128e2:	b170      	cbz	r0, 34012902 <VD55G1_Start+0x43a>
340128e4:	f240 23ce 	movw	r3, #718	@ 0x2ce
340128e8:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340128ea:	4a38      	ldr	r2, [pc, #224]	@ (340129cc <VD55G1_Start+0x504>)
340128ec:	4628      	mov	r0, r5
340128ee:	9200      	str	r2, [sp, #0]
340128f0:	2100      	movs	r1, #0
340128f2:	4a30      	ldr	r2, [pc, #192]	@ (340129b4 <VD55G1_Start+0x4ec>)
340128f4:	9301      	str	r3, [sp, #4]
340128f6:	f7ff fb07 	bl	34011f08 <VD55G1_log_impl>
340128fa:	4628      	mov	r0, r5
340128fc:	f7ff fb62 	bl	34011fc4 <display_error>
  VD55G1_TraceError(ctx, ret);
34012900:	e7d1      	b.n	340128a6 <VD55G1_Start+0x3de>
    ret = ctx->write8(ctx, VD55G1_REG_DARKCAL_CTRL, VD55G1_DARKCAL_BYPASS_DARKAVG);
34012902:	2202      	movs	r2, #2
34012904:	f240 312a 	movw	r1, #810	@ 0x32a
34012908:	4628      	mov	r0, r5
3401290a:	692b      	ldr	r3, [r5, #16]
3401290c:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
3401290e:	4604      	mov	r4, r0
34012910:	b118      	cbz	r0, 3401291a <VD55G1_Start+0x452>
34012912:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
34012916:	9002      	str	r0, [sp, #8]
34012918:	e7e7      	b.n	340128ea <VD55G1_Start+0x422>
  ret = ctx->write16(ctx, VD55G1_REG_PATGEN_CTRL, value);
3401291a:	4632      	mov	r2, r6
3401291c:	f44f 7141 	mov.w	r1, #772	@ 0x304
34012920:	4628      	mov	r0, r5
34012922:	696b      	ldr	r3, [r5, #20]
34012924:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012926:	4604      	mov	r4, r0
34012928:	b118      	cbz	r0, 34012932 <VD55G1_Start+0x46a>
3401292a:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
3401292e:	9002      	str	r0, [sp, #8]
34012930:	e7db      	b.n	340128ea <VD55G1_Start+0x422>
  return VD55G1_SetFlicker(ctx, drv_ctx->config_save.flicker);
34012932:	4628      	mov	r0, r5
34012934:	f895 1042 	ldrb.w	r1, [r5, #66]	@ 0x42
34012938:	f7ff fc46 	bl	340121c8 <VD55G1_SetFlicker>
  VD55G1_TraceError(ctx, ret);
3401293c:	4604      	mov	r4, r0
3401293e:	b118      	cbz	r0, 34012948 <VD55G1_Start+0x480>
34012940:	f240 3313 	movw	r3, #787	@ 0x313
34012944:	9002      	str	r0, [sp, #8]
34012946:	e5ec      	b.n	34012522 <VD55G1_Start+0x5a>
  ret = ctx->write8(ctx, VD55G1_REG_STBY, VD55G1_STBY_START_STREAM);
34012948:	2201      	movs	r2, #1
3401294a:	f240 2101 	movw	r1, #513	@ 0x201
3401294e:	4628      	mov	r0, r5
34012950:	692b      	ldr	r3, [r5, #16]
34012952:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012954:	4604      	mov	r4, r0
34012956:	b128      	cbz	r0, 34012964 <VD55G1_Start+0x49c>
34012958:	f240 331d 	movw	r3, #797	@ 0x31d
3401295c:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401295e:	4a1c      	ldr	r2, [pc, #112]	@ (340129d0 <VD55G1_Start+0x508>)
34012960:	9301      	str	r3, [sp, #4]
34012962:	e5e0      	b.n	34012526 <VD55G1_Start+0x5e>
  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STBY, VD55G1_CMD_ACK);
34012964:	4602      	mov	r2, r0
34012966:	f240 2101 	movw	r1, #513	@ 0x201
3401296a:	4628      	mov	r0, r5
3401296c:	f7ff fada 	bl	34011f24 <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012970:	4604      	mov	r4, r0
34012972:	b948      	cbnz	r0, 34012988 <VD55G1_Start+0x4c0>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_STREAMING);
34012974:	2103      	movs	r1, #3
34012976:	4628      	mov	r0, r5
34012978:	f7ff fb00 	bl	34011f7c <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
3401297c:	4604      	mov	r4, r0
3401297e:	b138      	cbz	r0, 34012990 <VD55G1_Start+0x4c8>
34012980:	f240 3323 	movw	r3, #803	@ 0x323
34012984:	9002      	str	r0, [sp, #8]
34012986:	e7ea      	b.n	3401295e <VD55G1_Start+0x496>
  VD55G1_TraceError(ctx, ret);
34012988:	f44f 7348 	mov.w	r3, #800	@ 0x320
3401298c:	9002      	str	r0, [sp, #8]
3401298e:	e7e6      	b.n	3401295e <VD55G1_Start+0x496>
  VD55G1_notice(ctx, "Streaming is on\n");
34012990:	f240 3325 	movw	r3, #805	@ 0x325
34012994:	2102      	movs	r1, #2
34012996:	4628      	mov	r0, r5
34012998:	4a0e      	ldr	r2, [pc, #56]	@ (340129d4 <VD55G1_Start+0x50c>)
3401299a:	f7ff fab5 	bl	34011f08 <VD55G1_log_impl>
    return ret;
  drv_ctx->state = VD55G1_ST_STREAMING;
3401299e:	2301      	movs	r3, #1
340129a0:	62ab      	str	r3, [r5, #40]	@ 0x28

  return 0;
}
340129a2:	4620      	mov	r0, r4
340129a4:	b007      	add	sp, #28
340129a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
340129a8:	3401cbf4 	.word	0x3401cbf4
340129ac:	3401cc17 	.word	0x3401cc17
340129b0:	34035773 	.word	0x34035773
340129b4:	3401c9f0 	.word	0x3401c9f0
340129b8:	340357b6 	.word	0x340357b6
340129bc:	3401cc50 	.word	0x3401cc50
340129c0:	340356f6 	.word	0x340356f6
340129c4:	3403575c 	.word	0x3403575c
340129c8:	340356f0 	.word	0x340356f0
340129cc:	34035749 	.word	0x34035749
340129d0:	34035721 	.word	0x34035721
340129d4:	3401cc78 	.word	0x3401cc78
340129d8:	2fec1100 	.word	0x2fec1100
340129dc:	00000000 	.word	0x00000000

340129e0 <VD55G1_Stop>:

int VD55G1_Stop(VD55G1_Ctx_t *ctx)
{
340129e0:	b510      	push	{r4, lr}
340129e2:	4604      	mov	r4, r0
  struct drv_ctx *drv_ctx = &ctx->ctx;
  int ret;

  ret = VD55G1_StopStreaming(ctx);
340129e4:	f7ff fc18 	bl	34012218 <VD55G1_StopStreaming>
  if (ret)
340129e8:	b900      	cbnz	r0, 340129ec <VD55G1_Stop+0xc>
    return ret;
  drv_ctx->state = VD55G1_ST_IDLE;
340129ea:	62a0      	str	r0, [r4, #40]	@ 0x28

  return 0;
}
340129ec:	bd10      	pop	{r4, pc}

340129ee <VD55G1_SetFlipMirrorMode>:

  return 0;
}

int VD55G1_SetFlipMirrorMode(VD55G1_Ctx_t *ctx, VD55G1_MirrorFlip_t mode)
{
340129ee:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
340129f0:	6843      	ldr	r3, [r0, #4]
{
340129f2:	460d      	mov	r5, r1
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
340129f4:	f10d 0207 	add.w	r2, sp, #7
340129f8:	211c      	movs	r1, #28
{
340129fa:	4604      	mov	r4, r0
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
340129fc:	4798      	blx	r3
  if (ret)
340129fe:	2800      	cmp	r0, #0
34012a00:	d10f      	bne.n	34012a22 <VD55G1_SetFlipMirrorMode+0x34>
  return state == VD55G1_SYSTEM_FSM_STREAMING;
34012a02:	f89d 3007 	ldrb.w	r3, [sp, #7]

  is_streaming = VD55G1_IsStreaming(ctx);
  if (is_streaming < 0)
    return is_streaming;

  if (is_streaming) {
34012a06:	2b03      	cmp	r3, #3
34012a08:	d10e      	bne.n	34012a28 <VD55G1_SetFlipMirrorMode+0x3a>
    ret = VD55G1_Stop(ctx);
34012a0a:	4620      	mov	r0, r4
34012a0c:	f7ff ffe8 	bl	340129e0 <VD55G1_Stop>
    if (ret)
34012a10:	b940      	cbnz	r0, 34012a24 <VD55G1_SetFlipMirrorMode+0x36>
  }

  drv_ctx->config_save.flip_mirror_mode = mode;

  if (is_streaming) {
    ret = VD55G1_Start(ctx);
34012a12:	4620      	mov	r0, r4
  drv_ctx->config_save.flip_mirror_mode = mode;
34012a14:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    if (ret)
      return ret;
  }

  return 0;
}
34012a18:	b003      	add	sp, #12
34012a1a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    ret = VD55G1_Start(ctx);
34012a1e:	f7ff bd53 	b.w	340124c8 <VD55G1_Start>
  if (is_streaming < 0)
34012a22:	daf2      	bge.n	34012a0a <VD55G1_SetFlipMirrorMode+0x1c>
}
34012a24:	b003      	add	sp, #12
34012a26:	bd30      	pop	{r4, r5, pc}
  drv_ctx->config_save.flip_mirror_mode = mode;
34012a28:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
  if (is_streaming) {
34012a2c:	e7fa      	b.n	34012a24 <VD55G1_SetFlipMirrorMode+0x36>

34012a2e <VD6G_error>:
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
  va_end(ap);
}

static void VD6G_error(VD6G_Ctx_t *ctx, const char *format, ...)
{
34012a2e:	b40e      	push	{r1, r2, r3}
34012a30:	b517      	push	{r0, r1, r2, r4, lr}
  va_list ap;

  if (!ctx->log)
34012a32:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012a34:	b124      	cbz	r4, 34012a40 <VD6G_error+0x12>
    return ;

  va_start(ap, format);
34012a36:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
34012a38:	2100      	movs	r1, #0
34012a3a:	9a05      	ldr	r2, [sp, #20]
  va_start(ap, format);
34012a3c:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
34012a3e:	47a0      	blx	r4
  va_end(ap);
}
34012a40:	b003      	add	sp, #12
34012a42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012a46:	b003      	add	sp, #12
34012a48:	4770      	bx	lr

34012a4a <VD6G_notice>:
{
34012a4a:	b40e      	push	{r1, r2, r3}
34012a4c:	b517      	push	{r0, r1, r2, r4, lr}
  if (!ctx->log)
34012a4e:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012a50:	b124      	cbz	r4, 34012a5c <VD6G_notice+0x12>
  va_start(ap, format);
34012a52:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
34012a54:	2102      	movs	r1, #2
34012a56:	9a05      	ldr	r2, [sp, #20]
  va_start(ap, format);
34012a58:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
34012a5a:	47a0      	blx	r4
}
34012a5c:	b003      	add	sp, #12
34012a5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012a62:	b003      	add	sp, #12
34012a64:	4770      	bx	lr
	...

34012a68 <display_error>:

static void display_error(VD6G_Ctx_t *ctx)
{
34012a68:	b513      	push	{r0, r1, r4, lr}
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
34012a6a:	6883      	ldr	r3, [r0, #8]
34012a6c:	211c      	movs	r1, #28
34012a6e:	f10d 0206 	add.w	r2, sp, #6
{
34012a72:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
34012a74:	4798      	blx	r3
  assert(ret == 0);
34012a76:	b130      	cbz	r0, 34012a86 <display_error+0x1e>
34012a78:	f240 1131 	movw	r1, #305	@ 0x131
34012a7c:	4b06      	ldr	r3, [pc, #24]	@ (34012a98 <display_error+0x30>)
34012a7e:	4a07      	ldr	r2, [pc, #28]	@ (34012a9c <display_error+0x34>)
34012a80:	4807      	ldr	r0, [pc, #28]	@ (34012aa0 <display_error+0x38>)
34012a82:	f004 ff19 	bl	340178b8 <__assert_func>
  VD6G_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
34012a86:	4620      	mov	r0, r4
34012a88:	f8bd 2006 	ldrh.w	r2, [sp, #6]
34012a8c:	4905      	ldr	r1, [pc, #20]	@ (34012aa4 <display_error+0x3c>)
34012a8e:	f7ff ffce 	bl	34012a2e <VD6G_error>
}
34012a92:	b002      	add	sp, #8
34012a94:	bd10      	pop	{r4, pc}
34012a96:	bf00      	nop
34012a98:	3401be43 	.word	0x3401be43
34012a9c:	340371c3 	.word	0x340371c3
34012aa0:	3401cc99 	.word	0x3401cc99
34012aa4:	3401c9db 	.word	0x3401c9db

34012aa8 <VD6G_PollReg8>:

static int VD6G_PollReg8(VD6G_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
34012aa8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
34012aac:	4604      	mov	r4, r0
34012aae:	460f      	mov	r7, r1
34012ab0:	4690      	mov	r8, r2
34012ab2:	2631      	movs	r6, #49	@ 0x31
  int loop_nb = timeout_ms / loop_delay_ms;
  uint8_t val;
  int ret;

  while (--loop_nb) {
    ret = ctx->read8(ctx, addr, &val);
34012ab4:	4639      	mov	r1, r7
34012ab6:	4620      	mov	r0, r4
34012ab8:	6863      	ldr	r3, [r4, #4]
34012aba:	f10d 020f 	add.w	r2, sp, #15
34012abe:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34012ac0:	4605      	mov	r5, r0
34012ac2:	b938      	cbnz	r0, 34012ad4 <VD6G_PollReg8+0x2c>
    if (val == poll_val)
34012ac4:	f89d 300f 	ldrb.w	r3, [sp, #15]
34012ac8:	4543      	cmp	r3, r8
34012aca:	d10f      	bne.n	34012aec <VD6G_PollReg8+0x44>
      return 0;
    ctx->delay(ctx, loop_delay_ms);
  }

  return -1;
}
34012acc:	4628      	mov	r0, r5
34012ace:	b004      	add	sp, #16
34012ad0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    VD6G_TraceError(ctx, ret);
34012ad4:	9000      	str	r0, [sp, #0]
34012ad6:	f240 133f 	movw	r3, #319	@ 0x13f
34012ada:	4620      	mov	r0, r4
34012adc:	4a08      	ldr	r2, [pc, #32]	@ (34012b00 <VD6G_PollReg8+0x58>)
34012ade:	4909      	ldr	r1, [pc, #36]	@ (34012b04 <VD6G_PollReg8+0x5c>)
34012ae0:	f7ff ffa5 	bl	34012a2e <VD6G_error>
34012ae4:	4620      	mov	r0, r4
34012ae6:	f7ff ffbf 	bl	34012a68 <display_error>
34012aea:	e7ef      	b.n	34012acc <VD6G_PollReg8+0x24>
    ctx->delay(ctx, loop_delay_ms);
34012aec:	210a      	movs	r1, #10
34012aee:	4620      	mov	r0, r4
34012af0:	6a23      	ldr	r3, [r4, #32]
34012af2:	4798      	blx	r3
  while (--loop_nb) {
34012af4:	3e01      	subs	r6, #1
34012af6:	d1dd      	bne.n	34012ab4 <VD6G_PollReg8+0xc>
  return -1;
34012af8:	f04f 35ff 	mov.w	r5, #4294967295
34012afc:	e7e6      	b.n	34012acc <VD6G_PollReg8+0x24>
34012afe:	bf00      	nop
34012b00:	340371d1 	.word	0x340371d1
34012b04:	3401ca00 	.word	0x3401ca00

34012b08 <VD6G_SetExposureModeInternal>:

static int VD6G_SetExposureModeInternal(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
  int ret;

  if ((mode != VD6G_EXPOSURE_AUTO) &&
34012b08:	2902      	cmp	r1, #2
{
34012b0a:	b537      	push	{r0, r1, r2, r4, r5, lr}
34012b0c:	4605      	mov	r5, r0
34012b0e:	460a      	mov	r2, r1
  if ((mode != VD6G_EXPOSURE_AUTO) &&
34012b10:	d813      	bhi.n	34012b3a <VD6G_SetExposureModeInternal+0x32>
      (mode != VD6G_EXPOSURE_FREEZE_AEALGO) &&
      (mode != VD6G_EXPOSURE_MANUAL)) {
    return -1;
  }

  ret = ctx->write8(ctx, VD6G_REG_EXP_MODE, mode);
34012b12:	f240 414c 	movw	r1, #1100	@ 0x44c
34012b16:	6903      	ldr	r3, [r0, #16]
34012b18:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012b1a:	4604      	mov	r4, r0
34012b1c:	b150      	cbz	r0, 34012b34 <VD6G_SetExposureModeInternal+0x2c>
34012b1e:	9000      	str	r0, [sp, #0]
34012b20:	f240 2367 	movw	r3, #615	@ 0x267
34012b24:	4628      	mov	r0, r5
34012b26:	4a06      	ldr	r2, [pc, #24]	@ (34012b40 <VD6G_SetExposureModeInternal+0x38>)
34012b28:	4906      	ldr	r1, [pc, #24]	@ (34012b44 <VD6G_SetExposureModeInternal+0x3c>)
34012b2a:	f7ff ff80 	bl	34012a2e <VD6G_error>
34012b2e:	4628      	mov	r0, r5
34012b30:	f7ff ff9a 	bl	34012a68 <display_error>

  return 0;
}
34012b34:	4620      	mov	r0, r4
34012b36:	b003      	add	sp, #12
34012b38:	bd30      	pop	{r4, r5, pc}
    return -1;
34012b3a:	f04f 34ff 	mov.w	r4, #4294967295
34012b3e:	e7f9      	b.n	34012b34 <VD6G_SetExposureModeInternal+0x2c>
34012b40:	340370c2 	.word	0x340370c2
34012b44:	3401ca00 	.word	0x3401ca00

34012b48 <VD6G_SetFlicker>:
static int VD6G_SetFlicker(VD6G_Ctx_t *ctx, VD6G_Flicker_t flicker)
{
  uint16_t mode;
  int ret;

  switch (flicker) {
34012b48:	2902      	cmp	r1, #2
{
34012b4a:	b537      	push	{r0, r1, r2, r4, r5, lr}
34012b4c:	4605      	mov	r5, r0
34012b4e:	d815      	bhi.n	34012b7c <VD6G_SetFlicker+0x34>
    break;
  default:
    return -1;
  }

  ret = ctx->write16(ctx, VD6G_REG_AE_COMPILER_CONTROL, mode);
34012b50:	4a0c      	ldr	r2, [pc, #48]	@ (34012b84 <VD6G_SetFlicker+0x3c>)
34012b52:	6943      	ldr	r3, [r0, #20]
34012b54:	5c52      	ldrb	r2, [r2, r1]
34012b56:	f44f 6186 	mov.w	r1, #1072	@ 0x430
34012b5a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012b5c:	4604      	mov	r4, r0
34012b5e:	b150      	cbz	r0, 34012b76 <VD6G_SetFlicker+0x2e>
34012b60:	9000      	str	r0, [sp, #0]
34012b62:	f240 33b1 	movw	r3, #945	@ 0x3b1
34012b66:	4628      	mov	r0, r5
34012b68:	4a07      	ldr	r2, [pc, #28]	@ (34012b88 <VD6G_SetFlicker+0x40>)
34012b6a:	4908      	ldr	r1, [pc, #32]	@ (34012b8c <VD6G_SetFlicker+0x44>)
34012b6c:	f7ff ff5f 	bl	34012a2e <VD6G_error>
34012b70:	4628      	mov	r0, r5
34012b72:	f7ff ff79 	bl	34012a68 <display_error>

  return 0;
}
34012b76:	4620      	mov	r0, r4
34012b78:	b003      	add	sp, #12
34012b7a:	bd30      	pop	{r4, r5, pc}
    return -1;
34012b7c:	f04f 34ff 	mov.w	r4, #4294967295
34012b80:	e7f9      	b.n	34012b76 <VD6G_SetFlicker+0x2e>
34012b82:	bf00      	nop
34012b84:	34036f88 	.word	0x34036f88
34012b88:	3403708c 	.word	0x3403708c
34012b8c:	3401ca00 	.word	0x3401ca00

34012b90 <VD6G_GetLineTimeInUs>:
{
34012b90:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34012b92:	460e      	mov	r6, r1
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
34012b94:	6883      	ldr	r3, [r0, #8]
34012b96:	f44f 7140 	mov.w	r1, #768	@ 0x300
34012b9a:	f10d 020e 	add.w	r2, sp, #14
{
34012b9e:	4605      	mov	r5, r0
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
34012ba0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012ba2:	4604      	mov	r4, r0
34012ba4:	b968      	cbnz	r0, 34012bc2 <VD6G_GetLineTimeInUs+0x32>
  *line_time_in_us = ((uint64_t)line_len * 1000000) / VD6G_PIXEL_CLOCK;
34012ba6:	a311      	add	r3, pc, #68	@ (adr r3, 34012bec <VD6G_GetLineTimeInUs+0x5c>)
34012ba8:	e9d3 2300 	ldrd	r2, r3, [r3]
34012bac:	f8bd 000e 	ldrh.w	r0, [sp, #14]
34012bb0:	490b      	ldr	r1, [pc, #44]	@ (34012be0 <VD6G_GetLineTimeInUs+0x50>)
34012bb2:	fba0 0101 	umull	r0, r1, r0, r1
34012bb6:	f7ee fd11 	bl	340015dc <__aeabi_uldivmod>
34012bba:	6030      	str	r0, [r6, #0]
}
34012bbc:	4620      	mov	r0, r4
34012bbe:	b004      	add	sp, #16
34012bc0:	bd70      	pop	{r4, r5, r6, pc}
  VD6G_TraceError(ctx, ret);
34012bc2:	9000      	str	r0, [sp, #0]
34012bc4:	f44f 73a7 	mov.w	r3, #334	@ 0x14e
34012bc8:	4628      	mov	r0, r5
34012bca:	4a06      	ldr	r2, [pc, #24]	@ (34012be4 <VD6G_GetLineTimeInUs+0x54>)
34012bcc:	4906      	ldr	r1, [pc, #24]	@ (34012be8 <VD6G_GetLineTimeInUs+0x58>)
34012bce:	f7ff ff2e 	bl	34012a2e <VD6G_error>
34012bd2:	4628      	mov	r0, r5
34012bd4:	f7ff ff48 	bl	34012a68 <display_error>
34012bd8:	e7f0      	b.n	34012bbc <VD6G_GetLineTimeInUs+0x2c>
34012bda:	bf00      	nop
34012bdc:	f3af 8000 	nop.w
34012be0:	000f4240 	.word	0x000f4240
34012be4:	34036fd9 	.word	0x34036fd9
34012be8:	3401ca00 	.word	0x3401ca00
34012bec:	09959d00 	.word	0x09959d00
34012bf0:	00000000 	.word	0x00000000

34012bf4 <VD6G_warn.constprop.0>:
static void VD6G_warn(VD6G_Ctx_t *ctx, const char *format, ...)
34012bf4:	b40e      	push	{r1, r2, r3}
34012bf6:	b517      	push	{r0, r1, r2, r4, lr}
  if (!ctx->log)
34012bf8:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012bfa:	b124      	cbz	r4, 34012c06 <VD6G_warn.constprop.0+0x12>
  va_start(ap, format);
34012bfc:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
34012bfe:	2101      	movs	r1, #1
34012c00:	4a03      	ldr	r2, [pc, #12]	@ (34012c10 <VD6G_warn.constprop.0+0x1c>)
  va_start(ap, format);
34012c02:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
34012c04:	47a0      	blx	r4
}
34012c06:	b003      	add	sp, #12
34012c08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012c0c:	b003      	add	sp, #12
34012c0e:	4770      	bx	lr
34012c10:	3401c931 	.word	0x3401c931

34012c14 <VD6G_dbg.constprop.0>:
static void VD6G_dbg(VD6G_Ctx_t *ctx, int lvl, const char *format, ...)
34012c14:	b40c      	push	{r2, r3}
34012c16:	b513      	push	{r0, r1, r4, lr}
  if (!ctx->log)
34012c18:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012c1a:	b124      	cbz	r4, 34012c26 <VD6G_dbg.constprop.0+0x12>
  va_start(ap, format);
34012c1c:	ab05      	add	r3, sp, #20
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
34012c1e:	2103      	movs	r1, #3
34012c20:	9a04      	ldr	r2, [sp, #16]
  va_start(ap, format);
34012c22:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
34012c24:	47a0      	blx	r4
}
34012c26:	b002      	add	sp, #8
34012c28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012c2c:	b002      	add	sp, #8
34012c2e:	4770      	bx	lr

34012c30 <VD6G_GetTopDie>:
{
34012c30:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34012c32:	460e      	mov	r6, r1
  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
34012c34:	6883      	ldr	r3, [r0, #8]
34012c36:	2102      	movs	r1, #2
34012c38:	f10d 020e 	add.w	r2, sp, #14
{
34012c3c:	4605      	mov	r5, r0
  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
34012c3e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012c40:	4604      	mov	r4, r0
34012c42:	b968      	cbnz	r0, 34012c60 <VD6G_GetTopDie+0x30>
  VD6G_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
34012c44:	4601      	mov	r1, r0
34012c46:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34012c4a:	4628      	mov	r0, r5
34012c4c:	4a0a      	ldr	r2, [pc, #40]	@ (34012c78 <VD6G_GetTopDie+0x48>)
34012c4e:	f7ff ffe1 	bl	34012c14 <VD6G_dbg.constprop.0>
  *top_die = reg16 >> 8;
34012c52:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34012c56:	0a1b      	lsrs	r3, r3, #8
34012c58:	7033      	strb	r3, [r6, #0]
}
34012c5a:	4620      	mov	r0, r4
34012c5c:	b004      	add	sp, #16
34012c5e:	bd70      	pop	{r4, r5, r6, pc}
  VD6G_TraceError(ctx, ret);
34012c60:	9000      	str	r0, [sp, #0]
34012c62:	f240 1373 	movw	r3, #371	@ 0x173
34012c66:	4628      	mov	r0, r5
34012c68:	4a04      	ldr	r2, [pc, #16]	@ (34012c7c <VD6G_GetTopDie+0x4c>)
34012c6a:	4905      	ldr	r1, [pc, #20]	@ (34012c80 <VD6G_GetTopDie+0x50>)
34012c6c:	f7ff fedf 	bl	34012a2e <VD6G_error>
34012c70:	4628      	mov	r0, r5
34012c72:	f7ff fef9 	bl	34012a68 <display_error>
34012c76:	e7f0      	b.n	34012c5a <VD6G_GetTopDie+0x2a>
34012c78:	3401cb96 	.word	0x3401cb96
34012c7c:	340371a2 	.word	0x340371a2
34012c80:	3401ca00 	.word	0x3401ca00

34012c84 <VD6G_WaitState>:
{
34012c84:	b570      	push	{r4, r5, r6, lr}
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012c86:	b2ca      	uxtb	r2, r1
{
34012c88:	460d      	mov	r5, r1
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012c8a:	2128      	movs	r1, #40	@ 0x28
{
34012c8c:	4606      	mov	r6, r0
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012c8e:	f7ff ff0b 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
34012c92:	4604      	mov	r4, r0
34012c94:	b130      	cbz	r0, 34012ca4 <VD6G_WaitState+0x20>
    VD6G_warn(ctx, "Unable to reach state %d\n", state);
34012c96:	462a      	mov	r2, r5
34012c98:	4630      	mov	r0, r6
34012c9a:	4906      	ldr	r1, [pc, #24]	@ (34012cb4 <VD6G_WaitState+0x30>)
34012c9c:	f7ff ffaa 	bl	34012bf4 <VD6G_warn.constprop.0>
}
34012ca0:	4620      	mov	r0, r4
34012ca2:	bd70      	pop	{r4, r5, r6, pc}
    VD6G_dbg(ctx, 0, "reach state %d\n", state);
34012ca4:	4601      	mov	r1, r0
34012ca6:	462b      	mov	r3, r5
34012ca8:	4630      	mov	r0, r6
34012caa:	4a03      	ldr	r2, [pc, #12]	@ (34012cb8 <VD6G_WaitState+0x34>)
34012cac:	f7ff ffb2 	bl	34012c14 <VD6G_dbg.constprop.0>
  return ret;
34012cb0:	e7f6      	b.n	34012ca0 <VD6G_WaitState+0x1c>
34012cb2:	bf00      	nop
34012cb4:	3401c931 	.word	0x3401c931
34012cb8:	3401c95c 	.word	0x3401c95c

34012cbc <VD6G_Init>:

  return 0;
}

int VD6G_Init(VD6G_Ctx_t *ctx, VD6G_Config_t *config)
{
34012cbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
  int ret;

  if (config->frame_rate < VD6G_MIN_FPS)
34012cc0:	688b      	ldr	r3, [r1, #8]
{
34012cc2:	4605      	mov	r5, r0
  if (config->frame_rate < VD6G_MIN_FPS)
34012cc4:	3b01      	subs	r3, #1
34012cc6:	2b57      	cmp	r3, #87	@ 0x57
{
34012cc8:	460c      	mov	r4, r1
34012cca:	b087      	sub	sp, #28
  if (config->frame_rate < VD6G_MIN_FPS)
34012ccc:	d802      	bhi.n	34012cd4 <VD6G_Init+0x18>
    return -1;
  if (config->frame_rate > VD6G_MAX_FPS)
    return -1;

  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
34012cce:	790b      	ldrb	r3, [r1, #4]
34012cd0:	2b08      	cmp	r3, #8
34012cd2:	d905      	bls.n	34012ce0 <VD6G_Init+0x24>
    return -1;
34012cd4:	f04f 34ff 	mov.w	r4, #4294967295
  ret = VD6G_SetupEarly(ctx);
  if (ret)
    return ret;

  return 0;
}
34012cd8:	4620      	mov	r0, r4
34012cda:	b007      	add	sp, #28
34012cdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
34012ce0:	7b0b      	ldrb	r3, [r1, #12]
34012ce2:	2b03      	cmp	r3, #3
34012ce4:	d8f6      	bhi.n	34012cd4 <VD6G_Init+0x18>
  ctx->shutdown_pin(ctx, 0);
34012ce6:	6803      	ldr	r3, [r0, #0]
34012ce8:	2100      	movs	r1, #0
34012cea:	4798      	blx	r3
  ctx->delay(ctx, 10);
34012cec:	210a      	movs	r1, #10
34012cee:	4628      	mov	r0, r5
34012cf0:	6a2b      	ldr	r3, [r5, #32]
34012cf2:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
34012cf4:	2101      	movs	r1, #1
34012cf6:	4628      	mov	r0, r5
34012cf8:	682b      	ldr	r3, [r5, #0]
34012cfa:	4798      	blx	r3
  drv_ctx->config_save = *config;
34012cfc:	f105 0630 	add.w	r6, r5, #48	@ 0x30
  ctx->delay(ctx, 10);
34012d00:	210a      	movs	r1, #10
34012d02:	4628      	mov	r0, r5
34012d04:	6a2b      	ldr	r3, [r5, #32]
34012d06:	4798      	blx	r3
  drv_ctx->config_save = *config;
34012d08:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012d0a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34012d0c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012d0e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34012d10:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012d12:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  drv_ctx->is_streaming = 0;
34012d14:	2300      	movs	r3, #0
  drv_ctx->config_save = *config;
34012d16:	e894 0003 	ldmia.w	r4, {r0, r1}
34012d1a:	e886 0003 	stmia.w	r6, {r0, r1}
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
34012d1e:	2101      	movs	r1, #1
34012d20:	4628      	mov	r0, r5
  drv_ctx->is_streaming = 0;
34012d22:	62eb      	str	r3, [r5, #44]	@ 0x2c
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
34012d24:	f7ff ffae 	bl	34012c84 <VD6G_WaitState>
  if (ret)
34012d28:	4604      	mov	r4, r0
34012d2a:	2800      	cmp	r0, #0
34012d2c:	d1d4      	bne.n	34012cd8 <VD6G_Init+0x1c>
  ret = ctx->read16(ctx, VD6G_REG_MODEL_ID, &reg16);
34012d2e:	ae03      	add	r6, sp, #12
34012d30:	4601      	mov	r1, r0
34012d32:	4632      	mov	r2, r6
34012d34:	4628      	mov	r0, r5
34012d36:	68ab      	ldr	r3, [r5, #8]
34012d38:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012d3a:	4604      	mov	r4, r0
34012d3c:	b988      	cbnz	r0, 34012d62 <VD6G_Init+0xa6>
  VD6G_dbg(ctx, 0, "model_id = 0x%04x\n", reg16);
34012d3e:	4601      	mov	r1, r0
34012d40:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012d44:	4aaf      	ldr	r2, [pc, #700]	@ (34013004 <VD6G_Init+0x348>)
34012d46:	4628      	mov	r0, r5
34012d48:	f7ff ff64 	bl	34012c14 <VD6G_dbg.constprop.0>
  if (reg16 != VD6G_MODEL_ID) {
34012d4c:	f245 6203 	movw	r2, #22019	@ 0x5603
34012d50:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012d54:	4293      	cmp	r3, r2
34012d56:	d010      	beq.n	34012d7a <VD6G_Init+0xbe>
    VD6G_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD6G_MODEL_ID, reg16);
34012d58:	4628      	mov	r0, r5
34012d5a:	49ab      	ldr	r1, [pc, #684]	@ (34013008 <VD6G_Init+0x34c>)
34012d5c:	f7ff fe67 	bl	34012a2e <VD6G_error>
  if (ret)
34012d60:	e7b8      	b.n	34012cd4 <VD6G_Init+0x18>
  VD6G_TraceError(ctx, ret);
34012d62:	f240 1381 	movw	r3, #385	@ 0x181
34012d66:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012d68:	4aa8      	ldr	r2, [pc, #672]	@ (3401300c <VD6G_Init+0x350>)
  VD6G_TraceError(ctx, ret);
34012d6a:	4628      	mov	r0, r5
34012d6c:	49a8      	ldr	r1, [pc, #672]	@ (34013010 <VD6G_Init+0x354>)
34012d6e:	f7ff fe5e 	bl	34012a2e <VD6G_error>
34012d72:	4628      	mov	r0, r5
34012d74:	f7ff fe78 	bl	34012a68 <display_error>
34012d78:	e7ae      	b.n	34012cd8 <VD6G_Init+0x1c>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012d7a:	4628      	mov	r0, r5
34012d7c:	f10d 010b 	add.w	r1, sp, #11
34012d80:	f7ff ff56 	bl	34012c30 <VD6G_GetTopDie>
  if (ret)
34012d84:	4604      	mov	r4, r0
34012d86:	2800      	cmp	r0, #0
34012d88:	d1a6      	bne.n	34012cd8 <VD6G_Init+0x1c>
  if (top_die != VD6G_TOP_DIE_SLOW_BOOT && top_die != VD6G_TOP_DIE_FAST_BOOT) {
34012d8a:	f89d 300b 	ldrb.w	r3, [sp, #11]
34012d8e:	2b20      	cmp	r3, #32
34012d90:	d006      	beq.n	34012da0 <VD6G_Init+0xe4>
34012d92:	2b31      	cmp	r3, #49	@ 0x31
34012d94:	d004      	beq.n	34012da0 <VD6G_Init+0xe4>
    VD6G_error(ctx, "Unsupported revision\n");
34012d96:	499f      	ldr	r1, [pc, #636]	@ (34013014 <VD6G_Init+0x358>)
    VD6G_error(ctx, "External clock out of rangen\n");
34012d98:	4628      	mov	r0, r5
34012d9a:	f7ff fe48 	bl	34012a2e <VD6G_error>
  if (ret)
34012d9e:	e799      	b.n	34012cd4 <VD6G_Init+0x18>
  ret = ctx->read16(ctx, VD6G_REG_ROM_REVISION, &reg16);
34012da0:	4632      	mov	r2, r6
34012da2:	2114      	movs	r1, #20
34012da4:	4628      	mov	r0, r5
34012da6:	68ab      	ldr	r3, [r5, #8]
34012da8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012daa:	4604      	mov	r4, r0
34012dac:	b9d8      	cbnz	r0, 34012de6 <VD6G_Init+0x12a>
  VD6G_dbg(ctx, 0, "rom = 0x%04x\n", reg16);
34012dae:	4601      	mov	r1, r0
34012db0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012db4:	4628      	mov	r0, r5
34012db6:	4a98      	ldr	r2, [pc, #608]	@ (34013018 <VD6G_Init+0x35c>)
34012db8:	f7ff ff2c 	bl	34012c14 <VD6G_dbg.constprop.0>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012dbc:	4628      	mov	r0, r5
34012dbe:	f10d 010b 	add.w	r1, sp, #11
34012dc2:	f7ff ff35 	bl	34012c30 <VD6G_GetTopDie>
  if (ret)
34012dc6:	4604      	mov	r4, r0
34012dc8:	2800      	cmp	r0, #0
34012dca:	d185      	bne.n	34012cd8 <VD6G_Init+0x1c>
  switch (top_die) {
34012dcc:	f89d 300b 	ldrb.w	r3, [sp, #11]
34012dd0:	2b20      	cmp	r3, #32
34012dd2:	d00c      	beq.n	34012dee <VD6G_Init+0x132>
34012dd4:	2b31      	cmp	r3, #49	@ 0x31
34012dd6:	d057      	beq.n	34012e88 <VD6G_Init+0x1cc>
    assert(0);
34012dd8:	f44f 71e5 	mov.w	r1, #458	@ 0x1ca
34012ddc:	4b8f      	ldr	r3, [pc, #572]	@ (3401301c <VD6G_Init+0x360>)
34012dde:	4a90      	ldr	r2, [pc, #576]	@ (34013020 <VD6G_Init+0x364>)
    assert(0);
34012de0:	4890      	ldr	r0, [pc, #576]	@ (34013024 <VD6G_Init+0x368>)
34012de2:	f004 fd69 	bl	340178b8 <__assert_func>
  VD6G_TraceError(ctx, ret);
34012de6:	f240 1391 	movw	r3, #401	@ 0x191
34012dea:	9000      	str	r0, [sp, #0]
34012dec:	e7bc      	b.n	34012d68 <VD6G_Init+0xac>
  ret = ctx->write_array(ctx, 0x2000, (uint8_t *) patch_cut2, sizeof(patch_cut2));
34012dee:	69ec      	ldr	r4, [r5, #28]
34012df0:	f642 23f8 	movw	r3, #11000	@ 0x2af8
34012df4:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34012df8:	4628      	mov	r0, r5
34012dfa:	4a8b      	ldr	r2, [pc, #556]	@ (34013028 <VD6G_Init+0x36c>)
34012dfc:	47a0      	blx	r4
  VD6G_TraceError(ctx, ret);
34012dfe:	4604      	mov	r4, r0
34012e00:	b120      	cbz	r0, 34012e0c <VD6G_Init+0x150>
34012e02:	f44f 73d1 	mov.w	r3, #418	@ 0x1a2
34012e06:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012e08:	4a88      	ldr	r2, [pc, #544]	@ (3401302c <VD6G_Init+0x370>)
34012e0a:	e7ae      	b.n	34012d6a <VD6G_Init+0xae>
  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_PATCH_SETUP);
34012e0c:	2202      	movs	r2, #2
34012e0e:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012e12:	4628      	mov	r0, r5
34012e14:	692b      	ldr	r3, [r5, #16]
34012e16:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e18:	4604      	mov	r4, r0
34012e1a:	bb38      	cbnz	r0, 34012e6c <VD6G_Init+0x1b0>
  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
34012e1c:	4602      	mov	r2, r0
34012e1e:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012e22:	4628      	mov	r0, r5
34012e24:	f7ff fe40 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
34012e28:	4604      	mov	r4, r0
34012e2a:	2800      	cmp	r0, #0
34012e2c:	f47f af54 	bne.w	34012cd8 <VD6G_Init+0x1c>
  ret = ctx->read16(ctx, VD6G_REG_FWPATCH_REVISION, &reg16);
34012e30:	4632      	mov	r2, r6
34012e32:	211e      	movs	r1, #30
34012e34:	4628      	mov	r0, r5
34012e36:	68ab      	ldr	r3, [r5, #8]
34012e38:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e3a:	4604      	mov	r4, r0
34012e3c:	b9d0      	cbnz	r0, 34012e74 <VD6G_Init+0x1b8>
  VD6G_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
34012e3e:	4601      	mov	r1, r0
34012e40:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e44:	4628      	mov	r0, r5
34012e46:	4a7a      	ldr	r2, [pc, #488]	@ (34013030 <VD6G_Init+0x374>)
34012e48:	f7ff fee4 	bl	34012c14 <VD6G_dbg.constprop.0>
  if (reg16 != (patch_major << 8) + patch_minor) {
34012e4c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e50:	f5b3 7f07 	cmp.w	r3, #540	@ 0x21c
34012e54:	d012      	beq.n	34012e7c <VD6G_Init+0x1c0>
    VD6G_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor,
34012e56:	b2da      	uxtb	r2, r3
34012e58:	0a1b      	lsrs	r3, r3, #8
34012e5a:	9201      	str	r2, [sp, #4]
34012e5c:	9300      	str	r3, [sp, #0]
34012e5e:	2202      	movs	r2, #2
34012e60:	231c      	movs	r3, #28
34012e62:	4974      	ldr	r1, [pc, #464]	@ (34013034 <VD6G_Init+0x378>)
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
34012e64:	4628      	mov	r0, r5
34012e66:	f7ff fde2 	bl	34012a2e <VD6G_error>
  if (ret)
34012e6a:	e733      	b.n	34012cd4 <VD6G_Init+0x18>
  VD6G_TraceError(ctx, ret);
34012e6c:	f240 13a5 	movw	r3, #421	@ 0x1a5
34012e70:	9000      	str	r0, [sp, #0]
34012e72:	e7c9      	b.n	34012e08 <VD6G_Init+0x14c>
  VD6G_TraceError(ctx, ret);
34012e74:	f44f 73d6 	mov.w	r3, #428	@ 0x1ac
34012e78:	9000      	str	r0, [sp, #0]
34012e7a:	e7c5      	b.n	34012e08 <VD6G_Init+0x14c>
  VD6G_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
34012e7c:	231c      	movs	r3, #28
34012e7e:	2202      	movs	r2, #2
34012e80:	4628      	mov	r0, r5
34012e82:	496d      	ldr	r1, [pc, #436]	@ (34013038 <VD6G_Init+0x37c>)
34012e84:	f7ff fde1 	bl	34012a4a <VD6G_notice>
  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_BOOT);
34012e88:	2201      	movs	r2, #1
34012e8a:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012e8e:	4628      	mov	r0, r5
34012e90:	692b      	ldr	r3, [r5, #16]
34012e92:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e94:	4604      	mov	r4, r0
34012e96:	b120      	cbz	r0, 34012ea2 <VD6G_Init+0x1e6>
34012e98:	f240 13d5 	movw	r3, #469	@ 0x1d5
34012e9c:	4a67      	ldr	r2, [pc, #412]	@ (3401303c <VD6G_Init+0x380>)
34012e9e:	9000      	str	r0, [sp, #0]
34012ea0:	e763      	b.n	34012d6a <VD6G_Init+0xae>
  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
34012ea2:	4602      	mov	r2, r0
34012ea4:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012ea8:	4628      	mov	r0, r5
34012eaa:	f7ff fdfd 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
34012eae:	4604      	mov	r4, r0
34012eb0:	2800      	cmp	r0, #0
34012eb2:	f47f af11 	bne.w	34012cd8 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34012eb6:	2102      	movs	r1, #2
34012eb8:	4628      	mov	r0, r5
34012eba:	f7ff fee3 	bl	34012c84 <VD6G_WaitState>
  if (ret)
34012ebe:	4604      	mov	r4, r0
34012ec0:	2800      	cmp	r0, #0
34012ec2:	f47f af09 	bne.w	34012cd8 <VD6G_Init+0x1c>
  VD6G_notice(ctx, "sensor boot successfully\n");
34012ec6:	4628      	mov	r0, r5
34012ec8:	495d      	ldr	r1, [pc, #372]	@ (34013040 <VD6G_Init+0x384>)
34012eca:	f7ff fdbe 	bl	34012a4a <VD6G_notice>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012ece:	4628      	mov	r0, r5
34012ed0:	f10d 0109 	add.w	r1, sp, #9
34012ed4:	f7ff feac 	bl	34012c30 <VD6G_GetTopDie>
  if (ret)
34012ed8:	4604      	mov	r4, r0
34012eda:	2800      	cmp	r0, #0
34012edc:	f47f aefc 	bne.w	34012cd8 <VD6G_Init+0x1c>
  switch (top_die) {
34012ee0:	f89d 3009 	ldrb.w	r3, [sp, #9]
34012ee4:	2b20      	cmp	r3, #32
34012ee6:	d007      	beq.n	34012ef8 <VD6G_Init+0x23c>
34012ee8:	2b31      	cmp	r3, #49	@ 0x31
34012eea:	f000 80ff 	beq.w	340130ec <VD6G_Init+0x430>
    assert(0);
34012eee:	f44f 710d 	mov.w	r1, #564	@ 0x234
34012ef2:	4b4a      	ldr	r3, [pc, #296]	@ (3401301c <VD6G_Init+0x360>)
34012ef4:	4a53      	ldr	r2, [pc, #332]	@ (34013044 <VD6G_Init+0x388>)
34012ef6:	e773      	b.n	34012de0 <VD6G_Init+0x124>
  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_START_VTRAM_UPDATE);
34012ef8:	2201      	movs	r2, #1
34012efa:	f240 2103 	movw	r1, #515	@ 0x203
34012efe:	4628      	mov	r0, r5
34012f00:	692b      	ldr	r3, [r5, #16]
34012f02:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f04:	4604      	mov	r4, r0
34012f06:	b120      	cbz	r0, 34012f12 <VD6G_Init+0x256>
34012f08:	f44f 73f6 	mov.w	r3, #492	@ 0x1ec
34012f0c:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012f0e:	4a4e      	ldr	r2, [pc, #312]	@ (34013048 <VD6G_Init+0x38c>)
34012f10:	e72b      	b.n	34012d6a <VD6G_Init+0xae>
  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
34012f12:	4602      	mov	r2, r0
34012f14:	f240 2103 	movw	r1, #515	@ 0x203
34012f18:	4628      	mov	r0, r5
34012f1a:	f7ff fdc5 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
34012f1e:	4604      	mov	r4, r0
34012f20:	2800      	cmp	r0, #0
34012f22:	f47f aed9 	bne.w	34012cd8 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34012f26:	2102      	movs	r1, #2
34012f28:	4628      	mov	r0, r5
34012f2a:	f7ff feab 	bl	34012c84 <VD6G_WaitState>
  if (ret)
34012f2e:	4604      	mov	r4, r0
34012f30:	2800      	cmp	r0, #0
34012f32:	f47f aed1 	bne.w	34012cd8 <VD6G_Init+0x1c>
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f36:	4681      	mov	r9, r0
34012f38:	f8df 8110 	ldr.w	r8, [pc, #272]	@ 3401304c <VD6G_Init+0x390>
34012f3c:	f8df a110 	ldr.w	sl, [pc, #272]	@ 34013050 <VD6G_Init+0x394>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
34012f40:	f8df b110 	ldr.w	fp, [pc, #272]	@ 34013054 <VD6G_Init+0x398>
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f44:	f8da 3000 	ldr.w	r3, [sl]
34012f48:	4599      	cmp	r9, r3
34012f4a:	db13      	blt.n	34012f74 <VD6G_Init+0x2b8>
  ret = ctx->write8(ctx, 0xd9f8, VT_REVISION);
34012f4c:	2211      	movs	r2, #17
34012f4e:	f64d 11f8 	movw	r1, #55800	@ 0xd9f8
34012f52:	4628      	mov	r0, r5
34012f54:	692b      	ldr	r3, [r5, #16]
34012f56:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f58:	4604      	mov	r4, r0
34012f5a:	bb58      	cbnz	r0, 34012fb4 <VD6G_Init+0x2f8>
  ret = ctx->write8(ctx, 0xaffc, VT_REVISION);
34012f5c:	2211      	movs	r2, #17
34012f5e:	f64a 71fc 	movw	r1, #45052	@ 0xaffc
34012f62:	4628      	mov	r0, r5
34012f64:	692b      	ldr	r3, [r5, #16]
34012f66:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f68:	4604      	mov	r4, r0
34012f6a:	b338      	cbz	r0, 34012fbc <VD6G_Init+0x300>
34012f6c:	f240 13ff 	movw	r3, #511	@ 0x1ff
34012f70:	9000      	str	r0, [sp, #0]
34012f72:	e7cc      	b.n	34012f0e <VD6G_Init+0x252>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
34012f74:	69ef      	ldr	r7, [r5, #28]
34012f76:	f8d8 3004 	ldr.w	r3, [r8, #4]
34012f7a:	f8b8 1000 	ldrh.w	r1, [r8]
34012f7e:	4628      	mov	r0, r5
34012f80:	eb0b 0204 	add.w	r2, fp, r4
34012f84:	47b8      	blx	r7
    VD6G_TraceError(ctx, ret);
34012f86:	f108 0808 	add.w	r8, r8, #8
34012f8a:	4607      	mov	r7, r0
34012f8c:	b928      	cbnz	r0, 34012f9a <VD6G_Init+0x2de>
    vtpatch_offset += vtpatch_desc[i].size;
34012f8e:	f858 3c04 	ldr.w	r3, [r8, #-4]
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f92:	f109 0901 	add.w	r9, r9, #1
    vtpatch_offset += vtpatch_desc[i].size;
34012f96:	441c      	add	r4, r3
  for (i = 0; i < vtpatch_area_nb; i++) {
34012f98:	e7d4      	b.n	34012f44 <VD6G_Init+0x288>
    VD6G_TraceError(ctx, ret);
34012f9a:	f240 13f9 	movw	r3, #505	@ 0x1f9
34012f9e:	4a2a      	ldr	r2, [pc, #168]	@ (34013048 <VD6G_Init+0x38c>)
34012fa0:	491b      	ldr	r1, [pc, #108]	@ (34013010 <VD6G_Init+0x354>)
34012fa2:	9000      	str	r0, [sp, #0]
34012fa4:	4628      	mov	r0, r5
34012fa6:	f7ff fd42 	bl	34012a2e <VD6G_error>
34012faa:	4628      	mov	r0, r5
34012fac:	f7ff fd5c 	bl	34012a68 <display_error>
    return ret;
34012fb0:	463c      	mov	r4, r7
34012fb2:	e691      	b.n	34012cd8 <VD6G_Init+0x1c>
  VD6G_TraceError(ctx, ret);
34012fb4:	f240 13fd 	movw	r3, #509	@ 0x1fd
34012fb8:	9000      	str	r0, [sp, #0]
34012fba:	e7a8      	b.n	34012f0e <VD6G_Init+0x252>
  ret = ctx->write8(ctx, 0xbbb4, VT_REVISION);
34012fbc:	2211      	movs	r2, #17
34012fbe:	f64b 31b4 	movw	r1, #48052	@ 0xbbb4
34012fc2:	4628      	mov	r0, r5
34012fc4:	692b      	ldr	r3, [r5, #16]
34012fc6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012fc8:	4604      	mov	r4, r0
34012fca:	b118      	cbz	r0, 34012fd4 <VD6G_Init+0x318>
34012fcc:	f240 2301 	movw	r3, #513	@ 0x201
34012fd0:	9000      	str	r0, [sp, #0]
34012fd2:	e79c      	b.n	34012f0e <VD6G_Init+0x252>
  ret = ctx->write8(ctx, 0xb898, VT_REVISION);
34012fd4:	2211      	movs	r2, #17
34012fd6:	f64b 0198 	movw	r1, #47256	@ 0xb898
34012fda:	4628      	mov	r0, r5
34012fdc:	692b      	ldr	r3, [r5, #16]
34012fde:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012fe0:	4604      	mov	r4, r0
34012fe2:	b118      	cbz	r0, 34012fec <VD6G_Init+0x330>
34012fe4:	f240 2303 	movw	r3, #515	@ 0x203
34012fe8:	9000      	str	r0, [sp, #0]
34012fea:	e790      	b.n	34012f0e <VD6G_Init+0x252>
  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_END_VTRAM_UPDATE);
34012fec:	2202      	movs	r2, #2
34012fee:	f240 2103 	movw	r1, #515	@ 0x203
34012ff2:	4628      	mov	r0, r5
34012ff4:	692b      	ldr	r3, [r5, #16]
34012ff6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012ff8:	4604      	mov	r4, r0
34012ffa:	b368      	cbz	r0, 34013058 <VD6G_Init+0x39c>
34012ffc:	f240 2306 	movw	r3, #518	@ 0x206
34013000:	9000      	str	r0, [sp, #0]
34013002:	e784      	b.n	34012f0e <VD6G_Init+0x252>
34013004:	3401cb37 	.word	0x3401cb37
34013008:	3401cb5a 	.word	0x3401cb5a
3401300c:	340371b1 	.word	0x340371b1
34013010:	3401ca00 	.word	0x3401ca00
34013014:	3401ccf4 	.word	0x3401ccf4
34013018:	3401cbe6 	.word	0x3401cbe6
3401301c:	3401d1fc 	.word	0x3401d1fc
34013020:	34037192 	.word	0x34037192
34013024:	3401cc99 	.word	0x3401cc99
34013028:	34038aa4 	.word	0x34038aa4
3401302c:	3403717a 	.word	0x3403717a
34013030:	3401ca26 	.word	0x3401ca26
34013034:	3401ca46 	.word	0x3401ca46
34013038:	3401ca82 	.word	0x3401ca82
3401303c:	3403716d 	.word	0x3403716d
34013040:	3401caa7 	.word	0x3401caa7
34013044:	3403715b 	.word	0x3403715b
34013048:	34037141 	.word	0x34037141
3401304c:	3403eccc 	.word	0x3403eccc
34013050:	3403ecc8 	.word	0x3403ecc8
34013054:	340372dc 	.word	0x340372dc
  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
34013058:	4602      	mov	r2, r0
3401305a:	f240 2103 	movw	r1, #515	@ 0x203
3401305e:	4628      	mov	r0, r5
34013060:	f7ff fd22 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
34013064:	4604      	mov	r4, r0
34013066:	2800      	cmp	r0, #0
34013068:	f47f ae36 	bne.w	34012cd8 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3401306c:	2102      	movs	r1, #2
3401306e:	4628      	mov	r0, r5
34013070:	f7ff fe08 	bl	34012c84 <VD6G_WaitState>
  if (ret)
34013074:	4604      	mov	r4, r0
34013076:	2800      	cmp	r0, #0
34013078:	f47f ae2e 	bne.w	34012cd8 <VD6G_Init+0x1c>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_RD_REVISION, &cur_vtpatch_rd_rev);
3401307c:	2120      	movs	r1, #32
3401307e:	4628      	mov	r0, r5
34013080:	686b      	ldr	r3, [r5, #4]
34013082:	f10d 020a 	add.w	r2, sp, #10
34013086:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013088:	4604      	mov	r4, r0
3401308a:	b958      	cbnz	r0, 340130a4 <VD6G_Init+0x3e8>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GR_REVISION, &cur_vtpatch_gr_rev);
3401308c:	2124      	movs	r1, #36	@ 0x24
3401308e:	4628      	mov	r0, r5
34013090:	686b      	ldr	r3, [r5, #4]
34013092:	f10d 020b 	add.w	r2, sp, #11
34013096:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013098:	4604      	mov	r4, r0
3401309a:	b138      	cbz	r0, 340130ac <VD6G_Init+0x3f0>
3401309c:	f240 2313 	movw	r3, #531	@ 0x213
340130a0:	9000      	str	r0, [sp, #0]
340130a2:	e734      	b.n	34012f0e <VD6G_Init+0x252>
  VD6G_TraceError(ctx, ret);
340130a4:	f240 2311 	movw	r3, #529	@ 0x211
340130a8:	9000      	str	r0, [sp, #0]
340130aa:	e730      	b.n	34012f0e <VD6G_Init+0x252>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GT_REVISION, &cur_vtpatch_gt_rev);
340130ac:	4632      	mov	r2, r6
340130ae:	2126      	movs	r1, #38	@ 0x26
340130b0:	4628      	mov	r0, r5
340130b2:	686b      	ldr	r3, [r5, #4]
340130b4:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340130b6:	4604      	mov	r4, r0
340130b8:	b118      	cbz	r0, 340130c2 <VD6G_Init+0x406>
340130ba:	f240 2315 	movw	r3, #533	@ 0x215
340130be:	9000      	str	r0, [sp, #0]
340130c0:	e725      	b.n	34012f0e <VD6G_Init+0x252>
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130c2:	f89d 300a 	ldrb.w	r3, [sp, #10]
      cur_vtpatch_gr_rev != VT_REVISION ||
340130c6:	f89d 100b 	ldrb.w	r1, [sp, #11]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130ca:	2b11      	cmp	r3, #17
      cur_vtpatch_gt_rev != VT_REVISION) {
340130cc:	f89d 200c 	ldrb.w	r2, [sp, #12]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130d0:	d004      	beq.n	340130dc <VD6G_Init+0x420>
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
340130d2:	e9cd 1200 	strd	r1, r2, [sp]
340130d6:	2211      	movs	r2, #17
340130d8:	496e      	ldr	r1, [pc, #440]	@ (34013294 <VD6G_Init+0x5d8>)
340130da:	e6c3      	b.n	34012e64 <VD6G_Init+0x1a8>
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340130dc:	2911      	cmp	r1, #17
340130de:	d1f8      	bne.n	340130d2 <VD6G_Init+0x416>
      cur_vtpatch_gr_rev != VT_REVISION ||
340130e0:	2a11      	cmp	r2, #17
340130e2:	d1f6      	bne.n	340130d2 <VD6G_Init+0x416>
  VD6G_notice(ctx, "VT patch %d applied\n", VT_REVISION);
340130e4:	4628      	mov	r0, r5
340130e6:	496c      	ldr	r1, [pc, #432]	@ (34013298 <VD6G_Init+0x5dc>)
340130e8:	f7ff fcaf 	bl	34012a4a <VD6G_notice>
  ret = ctx->read8(ctx, VD6G_REG_OPTICAL_REVISION, &reg8);
340130ec:	4632      	mov	r2, r6
340130ee:	211a      	movs	r1, #26
340130f0:	4628      	mov	r0, r5
340130f2:	686b      	ldr	r3, [r5, #4]
340130f4:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340130f6:	4604      	mov	r4, r0
340130f8:	b120      	cbz	r0, 34013104 <VD6G_Init+0x448>
340130fa:	f240 2341 	movw	r3, #577	@ 0x241
340130fe:	4a67      	ldr	r2, [pc, #412]	@ (3401329c <VD6G_Init+0x5e0>)
34013100:	9000      	str	r0, [sp, #0]
34013102:	e632      	b.n	34012d6a <VD6G_Init+0xae>
  if (!(reg8 & 1)) {
34013104:	f89d 300c 	ldrb.w	r3, [sp, #12]
34013108:	f013 0301 	ands.w	r3, r3, #1
3401310c:	d008      	beq.n	34013120 <VD6G_Init+0x464>
  switch (drv_ctx->config_save.flip_mirror_mode) {
3401310e:	f895 203c 	ldrb.w	r2, [r5, #60]	@ 0x3c
34013112:	2a03      	cmp	r2, #3
34013114:	d81b      	bhi.n	3401314e <VD6G_Init+0x492>
34013116:	e8df f002 	tbb	[pc, r2]
3401311a:	021f      	.short	0x021f
3401311c:	1803      	.short	0x1803
3401311e:	2304      	movs	r3, #4
34013120:	f240 4767 	movw	r7, #1127	@ 0x467
  for (i = 0; i < VD6G_GPIO_NB; i++) {
34013124:	f240 496f 	movw	r9, #1135	@ 0x46f
    ctx->bayer = VD6G_BAYER_RGGB;
34013128:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
3401312c:	f105 085b 	add.w	r8, r5, #91	@ 0x5b
    ret = ctx->write8(ctx, VD6G_REG_GPIO_x_CTRL(i), drv_ctx->config_save.gpio_ctrl[i]);
34013130:	4639      	mov	r1, r7
34013132:	4628      	mov	r0, r5
34013134:	692b      	ldr	r3, [r5, #16]
34013136:	f818 2f01 	ldrb.w	r2, [r8, #1]!
3401313a:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
3401313c:	4604      	mov	r4, r0
3401313e:	b168      	cbz	r0, 3401315c <VD6G_Init+0x4a0>
34013140:	f44f 731d 	mov.w	r3, #628	@ 0x274
34013144:	4a56      	ldr	r2, [pc, #344]	@ (340132a0 <VD6G_Init+0x5e4>)
34013146:	9000      	str	r0, [sp, #0]
34013148:	e60f      	b.n	34012d6a <VD6G_Init+0xae>
  case VD6G_MIRROR_FLIP:
3401314a:	4613      	mov	r3, r2
3401314c:	e7e8      	b.n	34013120 <VD6G_Init+0x464>
    assert(0);
3401314e:	f240 2156 	movw	r1, #598	@ 0x256
34013152:	4b54      	ldr	r3, [pc, #336]	@ (340132a4 <VD6G_Init+0x5e8>)
34013154:	4a51      	ldr	r2, [pc, #324]	@ (3401329c <VD6G_Init+0x5e0>)
34013156:	e643      	b.n	34012de0 <VD6G_Init+0x124>
  switch (drv_ctx->config_save.flip_mirror_mode) {
34013158:	2302      	movs	r3, #2
3401315a:	e7e1      	b.n	34013120 <VD6G_Init+0x464>
  for (i = 0; i < VD6G_GPIO_NB; i++) {
3401315c:	3701      	adds	r7, #1
3401315e:	b2bf      	uxth	r7, r7
34013160:	454f      	cmp	r7, r9
34013162:	d1e5      	bne.n	34013130 <VD6G_Init+0x474>
  ret = VD6G_ComputeClocks(ctx, drv_ctx->config_save.ext_clock_freq_in_hz, &pll_prediv, &pll_mult);
34013164:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
  const unsigned int predivs[] = { 1, 2, 4 };
34013166:	4a50      	ldr	r2, [pc, #320]	@ (340132a8 <VD6G_Init+0x5ec>)
34013168:	ca07      	ldmia	r2, {r0, r1, r2}
3401316a:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  if (ext_clock < 6 * M_HZ ||
3401316e:	484f      	ldr	r0, [pc, #316]	@ (340132ac <VD6G_Init+0x5f0>)
34013170:	f5a3 02b7 	sub.w	r2, r3, #5996544	@ 0x5b8000
34013174:	f5a2 6258 	sub.w	r2, r2, #3456	@ 0xd80
34013178:	4282      	cmp	r2, r0
3401317a:	4631      	mov	r1, r6
3401317c:	d830      	bhi.n	340131e0 <VD6G_Init+0x524>
    if (ext_clock / *pll_prediv < 12 * M_HZ)
3401317e:	4a4c      	ldr	r2, [pc, #304]	@ (340132b0 <VD6G_Init+0x5f4>)
    *pll_prediv = predivs[i];
34013180:	f851 0b04 	ldr.w	r0, [r1], #4
    if (ext_clock / *pll_prediv < 12 * M_HZ)
34013184:	fa5f f880 	uxtb.w	r8, r0
34013188:	fbb3 f0f8 	udiv	r0, r3, r8
3401318c:	4290      	cmp	r0, r2
3401318e:	d302      	bcc.n	34013196 <VD6G_Init+0x4da>
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
34013190:	3401      	adds	r4, #1
34013192:	2c03      	cmp	r4, #3
34013194:	d1f4      	bne.n	34013180 <VD6G_Init+0x4c4>
  *pll_mult = (VD6G_TARGET_PLL * *pll_prediv + ext_clock / 2) / ext_clock;
34013196:	4a47      	ldr	r2, [pc, #284]	@ (340132b4 <VD6G_Init+0x5f8>)
34013198:	085f      	lsrs	r7, r3, #1
3401319a:	fb02 7708 	mla	r7, r2, r8, r7
3401319e:	fbb7 f7f3 	udiv	r7, r7, r3
  VD6G_dbg(ctx, 0, "Ext Clock = %d Hz\n", ext_clock);
340131a2:	2100      	movs	r1, #0
340131a4:	4628      	mov	r0, r5
340131a6:	4a44      	ldr	r2, [pc, #272]	@ (340132b8 <VD6G_Init+0x5fc>)
340131a8:	f7ff fd34 	bl	34012c14 <VD6G_dbg.constprop.0>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
340131ac:	b2ff      	uxtb	r7, r7
  VD6G_dbg(ctx, 0, "PLL prediv = %d\n", *pll_prediv);
340131ae:	4643      	mov	r3, r8
340131b0:	2100      	movs	r1, #0
340131b2:	4628      	mov	r0, r5
340131b4:	4a41      	ldr	r2, [pc, #260]	@ (340132bc <VD6G_Init+0x600>)
340131b6:	f7ff fd2d 	bl	34012c14 <VD6G_dbg.constprop.0>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
340131ba:	463b      	mov	r3, r7
340131bc:	2100      	movs	r1, #0
340131be:	4628      	mov	r0, r5
340131c0:	4a3f      	ldr	r2, [pc, #252]	@ (340132c0 <VD6G_Init+0x604>)
340131c2:	f7ff fd27 	bl	34012c14 <VD6G_dbg.constprop.0>
  ret = ctx->write32(ctx, VD6G_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
340131c6:	f44f 7108 	mov.w	r1, #544	@ 0x220
340131ca:	4628      	mov	r0, r5
340131cc:	69ab      	ldr	r3, [r5, #24]
340131ce:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
340131d0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340131d2:	4604      	mov	r4, r0
340131d4:	b130      	cbz	r0, 340131e4 <VD6G_Init+0x528>
340131d6:	f44f 7331 	mov.w	r3, #708	@ 0x2c4
340131da:	9000      	str	r0, [sp, #0]
    VD6G_TraceError(ctx, ret);
340131dc:	4a39      	ldr	r2, [pc, #228]	@ (340132c4 <VD6G_Init+0x608>)
340131de:	e5c4      	b.n	34012d6a <VD6G_Init+0xae>
    VD6G_error(ctx, "External clock out of rangen\n");
340131e0:	4939      	ldr	r1, [pc, #228]	@ (340132c8 <VD6G_Init+0x60c>)
340131e2:	e5d9      	b.n	34012d98 <VD6G_Init+0xdc>
  ret = ctx->write8(ctx, VD6G_REG_CLK_PLL_PREDIV, pll_prediv);
340131e4:	4642      	mov	r2, r8
340131e6:	f44f 7109 	mov.w	r1, #548	@ 0x224
340131ea:	4628      	mov	r0, r5
340131ec:	692b      	ldr	r3, [r5, #16]
340131ee:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340131f0:	4604      	mov	r4, r0
340131f2:	b958      	cbnz	r0, 3401320c <VD6G_Init+0x550>
  ret = ctx->write8(ctx, VD6G_REG_CLK_SYS_PLL_MULT, pll_mult);
340131f4:	463a      	mov	r2, r7
340131f6:	f240 2126 	movw	r1, #550	@ 0x226
340131fa:	4628      	mov	r0, r5
340131fc:	692b      	ldr	r3, [r5, #16]
340131fe:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013200:	4604      	mov	r4, r0
34013202:	b138      	cbz	r0, 34013214 <VD6G_Init+0x558>
34013204:	f240 23ca 	movw	r3, #714	@ 0x2ca
34013208:	9000      	str	r0, [sp, #0]
3401320a:	e7e7      	b.n	340131dc <VD6G_Init+0x520>
  VD6G_TraceError(ctx, ret);
3401320c:	f240 23c7 	movw	r3, #711	@ 0x2c7
34013210:	9000      	str	r0, [sp, #0]
34013212:	e7e3      	b.n	340131dc <VD6G_Init+0x520>
  if (drv_ctx->config_save.line_len) {
34013214:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
34013216:	b962      	cbnz	r2, 34013232 <VD6G_Init+0x576>
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_length);
34013218:	4632      	mov	r2, r6
3401321a:	f44f 7140 	mov.w	r1, #768	@ 0x300
3401321e:	4628      	mov	r0, r5
34013220:	68ab      	ldr	r3, [r5, #8]
34013222:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013224:	4604      	mov	r4, r0
34013226:	b188      	cbz	r0, 3401324c <VD6G_Init+0x590>
34013228:	f44f 7350 	mov.w	r3, #832	@ 0x340
3401322c:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
3401322e:	4a27      	ldr	r2, [pc, #156]	@ (340132cc <VD6G_Init+0x610>)
34013230:	e59b      	b.n	34012d6a <VD6G_Init+0xae>
    ret = ctx->write16(ctx, VD6G_LINE_LENGTH, drv_ctx->config_save.line_len);
34013232:	f44f 7140 	mov.w	r1, #768	@ 0x300
34013236:	4628      	mov	r0, r5
34013238:	696b      	ldr	r3, [r5, #20]
3401323a:	b292      	uxth	r2, r2
3401323c:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
3401323e:	4604      	mov	r4, r0
34013240:	2800      	cmp	r0, #0
34013242:	d0e9      	beq.n	34013218 <VD6G_Init+0x55c>
34013244:	f240 23ce 	movw	r3, #718	@ 0x2ce
34013248:	9000      	str	r0, [sp, #0]
3401324a:	e7c7      	b.n	340131dc <VD6G_Init+0x520>
  VD6G_dbg(ctx, 0, "Line len = %d\n", line_length);
3401324c:	4601      	mov	r1, r0
3401324e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013252:	4628      	mov	r0, r5
34013254:	4a1e      	ldr	r2, [pc, #120]	@ (340132d0 <VD6G_Init+0x614>)
34013256:	f7ff fcdd 	bl	34012c14 <VD6G_dbg.constprop.0>
  frame_length = VD6G_PIXEL_CLOCK / (line_length * drv_ctx->config_save.frame_rate);
3401325a:	6baa      	ldr	r2, [r5, #56]	@ 0x38
3401325c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013260:	4e1c      	ldr	r6, [pc, #112]	@ (340132d4 <VD6G_Init+0x618>)
34013262:	4353      	muls	r3, r2
34013264:	fb96 f6f3 	sdiv	r6, r6, r3
  VD6G_dbg(ctx, 0, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
34013268:	4621      	mov	r1, r4
3401326a:	4628      	mov	r0, r5
3401326c:	9200      	str	r2, [sp, #0]
3401326e:	b2b3      	uxth	r3, r6
34013270:	4a19      	ldr	r2, [pc, #100]	@ (340132d8 <VD6G_Init+0x61c>)
34013272:	f7ff fccf 	bl	34012c14 <VD6G_dbg.constprop.0>
  ret = ctx->write16(ctx, VD6G_FRAME_LENGTH, frame_length);
34013276:	f44f 618b 	mov.w	r1, #1112	@ 0x458
3401327a:	4628      	mov	r0, r5
3401327c:	696b      	ldr	r3, [r5, #20]
3401327e:	b2b2      	uxth	r2, r6
34013280:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013282:	4604      	mov	r4, r0
34013284:	2800      	cmp	r0, #0
34013286:	f43f ad27 	beq.w	34012cd8 <VD6G_Init+0x1c>
3401328a:	f240 3346 	movw	r3, #838	@ 0x346
3401328e:	9000      	str	r0, [sp, #0]
34013290:	e7cd      	b.n	3401322e <VD6G_Init+0x572>
34013292:	bf00      	nop
34013294:	3401cd0a 	.word	0x3401cd0a
34013298:	3401cd43 	.word	0x3401cd43
3401329c:	3403712f 	.word	0x3403712f
340132a0:	34037124 	.word	0x34037124
340132a4:	3401d1fc 	.word	0x3401d1fc
340132a8:	3401bd38 	.word	0x3401bd38
340132ac:	01406f40 	.word	0x01406f40
340132b0:	00b71b00 	.word	0x00b71b00
340132b4:	2fec1100 	.word	0x2fec1100
340132b8:	3401cd76 	.word	0x3401cd76
340132bc:	3401cd89 	.word	0x3401cd89
340132c0:	3401cd9a 	.word	0x3401cd9a
340132c4:	34037113 	.word	0x34037113
340132c8:	3401cd58 	.word	0x3401cd58
340132cc:	340370ff 	.word	0x340370ff
340132d0:	3401cda9 	.word	0x3401cda9
340132d4:	09959d00 	.word	0x09959d00
340132d8:	3401cc28 	.word	0x3401cc28

340132dc <VD6G_DeInit>:

int VD6G_DeInit(VD6G_Ctx_t *ctx)
{
340132dc:	b538      	push	{r3, r4, r5, lr}
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;

  if (drv_ctx->is_streaming)
340132de:	6ac5      	ldr	r5, [r0, #44]	@ 0x2c
{
340132e0:	4604      	mov	r4, r0
  if (drv_ctx->is_streaming)
340132e2:	b945      	cbnz	r5, 340132f6 <VD6G_DeInit+0x1a>
    return -1;

  ctx->shutdown_pin(ctx, 0);
340132e4:	6803      	ldr	r3, [r0, #0]
340132e6:	4629      	mov	r1, r5
340132e8:	4798      	blx	r3
  ctx->delay(ctx, 10);
340132ea:	210a      	movs	r1, #10
340132ec:	4620      	mov	r0, r4
340132ee:	6a23      	ldr	r3, [r4, #32]
340132f0:	4798      	blx	r3

  return 0;
}
340132f2:	4628      	mov	r0, r5
340132f4:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
340132f6:	f04f 35ff 	mov.w	r5, #4294967295
340132fa:	e7fa      	b.n	340132f2 <VD6G_DeInit+0x16>

340132fc <VD6G_Start>:
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340132fc:	6c83      	ldr	r3, [r0, #72]	@ 0x48

int VD6G_Start(VD6G_Ctx_t *ctx)
{
340132fe:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
34013300:	3b01      	subs	r3, #1
34013302:	2b01      	cmp	r3, #1
{
34013304:	4605      	mov	r5, r0
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
34013306:	d904      	bls.n	34013312 <VD6G_Start+0x16>
    return ret;
34013308:	f04f 34ff 	mov.w	r4, #4294967295
  if (ret)
    return ret;
  drv_ctx->is_streaming = 1;

  return 0;
}
3401330c:	4620      	mov	r0, r4
3401330e:	b002      	add	sp, #8
34013310:	bd70      	pop	{r4, r5, r6, pc}
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34013312:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013314:	2208      	movs	r2, #8
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34013316:	3b00      	subs	r3, #0
34013318:	bf18      	it	ne
3401331a:	2301      	movne	r3, #1
3401331c:	64c3      	str	r3, [r0, #76]	@ 0x4c
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
3401331e:	6d03      	ldr	r3, [r0, #80]	@ 0x50
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013320:	f240 310a 	movw	r1, #778	@ 0x30a
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
34013324:	3b00      	subs	r3, #0
34013326:	bf18      	it	ne
34013328:	2301      	movne	r3, #1
3401332a:	6503      	str	r3, [r0, #80]	@ 0x50
  out_itf->data_lane1_swap_enable = !!out_itf->data_lane1_swap_enable;
3401332c:	6d43      	ldr	r3, [r0, #84]	@ 0x54
3401332e:	3b00      	subs	r3, #0
34013330:	bf18      	it	ne
34013332:	2301      	movne	r3, #1
34013334:	6543      	str	r3, [r0, #84]	@ 0x54
  out_itf->data_lanes_mapping_swap_enable = !!out_itf->data_lanes_mapping_swap_enable;
34013336:	6d83      	ldr	r3, [r0, #88]	@ 0x58
34013338:	3b00      	subs	r3, #0
3401333a:	bf18      	it	ne
3401333c:	2301      	movne	r3, #1
3401333e:	6583      	str	r3, [r0, #88]	@ 0x58
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013340:	6903      	ldr	r3, [r0, #16]
34013342:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013344:	4604      	mov	r4, r0
34013346:	b9e8      	cbnz	r0, 34013384 <VD6G_Start+0x88>
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
34013348:	e9d5 0315 	ldrd	r0, r3, [r5, #84]	@ 0x54
             !out_itf->data_lanes_mapping_swap_enable << 7 |
3401334c:	6d2a      	ldr	r2, [r5, #80]	@ 0x50
             out_itf->clock_lane_swap_enable << 3 |
3401334e:	6ca9      	ldr	r1, [r5, #72]	@ 0x48
             !out_itf->data_lanes_mapping_swap_enable << 7 |
34013350:	0192      	lsls	r2, r2, #6
             out_itf->clock_lane_swap_enable << 3 |
34013352:	ea42 2240 	orr.w	r2, r2, r0, lsl #9
34013356:	430a      	orrs	r2, r1
34013358:	ea42 1203 	orr.w	r2, r2, r3, lsl #4
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
3401335c:	fab3 f383 	clz	r3, r3
             out_itf->data_lanes_mapping_swap_enable << 4 |
34013360:	6ce9      	ldr	r1, [r5, #76]	@ 0x4c
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
34013362:	095b      	lsrs	r3, r3, #5
             out_itf->clock_lane_swap_enable << 3 |
34013364:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
34013368:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
  ret = ctx->write16(ctx, VD6G_REG_OIF_CTRL, oif_ctrl);
3401336c:	f44f 7143 	mov.w	r1, #780	@ 0x30c
34013370:	4628      	mov	r0, r5
34013372:	696b      	ldr	r3, [r5, #20]
34013374:	b292      	uxth	r2, r2
34013376:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013378:	4604      	mov	r4, r0
3401337a:	b178      	cbz	r0, 3401339c <VD6G_Start+0xa0>
3401337c:	f240 23ee 	movw	r3, #750	@ 0x2ee
34013380:	9000      	str	r0, [sp, #0]
34013382:	e002      	b.n	3401338a <VD6G_Start+0x8e>
  VD6G_TraceError(ctx, ret);
34013384:	f44f 7339 	mov.w	r3, #740	@ 0x2e4
34013388:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
3401338a:	4a74      	ldr	r2, [pc, #464]	@ (3401355c <VD6G_Start+0x260>)
3401338c:	4628      	mov	r0, r5
3401338e:	4974      	ldr	r1, [pc, #464]	@ (34013560 <VD6G_Start+0x264>)
34013390:	f7ff fb4d 	bl	34012a2e <VD6G_error>
34013394:	4628      	mov	r0, r5
34013396:	f7ff fb67 	bl	34012a68 <display_error>
  if (ret)
3401339a:	e7b7      	b.n	3401330c <VD6G_Start+0x10>
  ret = ctx->write16(ctx, VD6G_REG_OIF_CSI_BITRATE, 804);
3401339c:	f44f 7249 	mov.w	r2, #804	@ 0x324
340133a0:	f240 3112 	movw	r1, #786	@ 0x312
340133a4:	4628      	mov	r0, r5
340133a6:	696b      	ldr	r3, [r5, #20]
340133a8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340133aa:	4604      	mov	r4, r0
340133ac:	b118      	cbz	r0, 340133b6 <VD6G_Start+0xba>
340133ae:	f240 23f2 	movw	r3, #754	@ 0x2f2
340133b2:	9000      	str	r0, [sp, #0]
340133b4:	e7e9      	b.n	3401338a <VD6G_Start+0x8e>
  ret = ctx->write8(ctx, VD6G_REG_OIF_IMG_CTRL, 0x2a);
340133b6:	222a      	movs	r2, #42	@ 0x2a
340133b8:	f240 310f 	movw	r1, #783	@ 0x30f
340133bc:	4628      	mov	r0, r5
340133be:	692b      	ldr	r3, [r5, #16]
340133c0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340133c2:	4604      	mov	r4, r0
340133c4:	b118      	cbz	r0, 340133ce <VD6G_Start+0xd2>
340133c6:	f240 23f6 	movw	r3, #758	@ 0x2f6
340133ca:	9000      	str	r0, [sp, #0]
340133cc:	e7dd      	b.n	3401338a <VD6G_Start+0x8e>
  mode = VD6G_Resolution2Mode(drv_ctx->config_save.resolution);
340133ce:	f895 3034 	ldrb.w	r3, [r5, #52]	@ 0x34
  switch (resolution) {
340133d2:	2b08      	cmp	r3, #8
340133d4:	d898      	bhi.n	34013308 <VD6G_Start+0xc>
340133d6:	4a63      	ldr	r2, [pc, #396]	@ (34013564 <VD6G_Start+0x268>)
340133d8:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
  if (!mode)
340133dc:	2e00      	cmp	r6, #0
340133de:	d093      	beq.n	34013308 <VD6G_Start+0xc>
  ret = ctx->write8(ctx, VD6G_REG_READOUT_CTRL, mode->bin_mode);
340133e0:	f240 417e 	movw	r1, #1150	@ 0x47e
340133e4:	4628      	mov	r0, r5
340133e6:	692b      	ldr	r3, [r5, #16]
340133e8:	7a32      	ldrb	r2, [r6, #8]
340133ea:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340133ec:	4604      	mov	r4, r0
340133ee:	b120      	cbz	r0, 340133fa <VD6G_Start+0xfe>
340133f0:	f240 3329 	movw	r3, #809	@ 0x329
340133f4:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340133f6:	4a5c      	ldr	r2, [pc, #368]	@ (34013568 <VD6G_Start+0x26c>)
340133f8:	e7c8      	b.n	3401338c <VD6G_Start+0x90>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_START, mode->crop.left);
340133fa:	f240 415e 	movw	r1, #1118	@ 0x45e
340133fe:	4628      	mov	r0, r5
34013400:	696b      	ldr	r3, [r5, #20]
34013402:	89b2      	ldrh	r2, [r6, #12]
34013404:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013406:	4604      	mov	r4, r0
34013408:	b978      	cbnz	r0, 3401342a <VD6G_Start+0x12e>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_END, mode->crop.left + mode->crop.width - 1);
3401340a:	6973      	ldr	r3, [r6, #20]
3401340c:	68f2      	ldr	r2, [r6, #12]
3401340e:	f44f 618c 	mov.w	r1, #1120	@ 0x460
34013412:	441a      	add	r2, r3
34013414:	3a01      	subs	r2, #1
34013416:	4628      	mov	r0, r5
34013418:	696b      	ldr	r3, [r5, #20]
3401341a:	b292      	uxth	r2, r2
3401341c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401341e:	4604      	mov	r4, r0
34013420:	b138      	cbz	r0, 34013432 <VD6G_Start+0x136>
34013422:	f240 332e 	movw	r3, #814	@ 0x32e
34013426:	9000      	str	r0, [sp, #0]
34013428:	e7e5      	b.n	340133f6 <VD6G_Start+0xfa>
  VD6G_TraceError(ctx, ret);
3401342a:	f44f 734b 	mov.w	r3, #812	@ 0x32c
3401342e:	9000      	str	r0, [sp, #0]
34013430:	e7e1      	b.n	340133f6 <VD6G_Start+0xfa>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_START, mode->crop.top);
34013432:	f240 4162 	movw	r1, #1122	@ 0x462
34013436:	4628      	mov	r0, r5
34013438:	696b      	ldr	r3, [r5, #20]
3401343a:	8a32      	ldrh	r2, [r6, #16]
3401343c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401343e:	4604      	mov	r4, r0
34013440:	b118      	cbz	r0, 3401344a <VD6G_Start+0x14e>
34013442:	f240 3331 	movw	r3, #817	@ 0x331
34013446:	9000      	str	r0, [sp, #0]
34013448:	e7d5      	b.n	340133f6 <VD6G_Start+0xfa>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_END, mode->crop.top + mode->crop.height - 1);
3401344a:	69b3      	ldr	r3, [r6, #24]
3401344c:	6932      	ldr	r2, [r6, #16]
3401344e:	f240 4164 	movw	r1, #1124	@ 0x464
34013452:	441a      	add	r2, r3
34013454:	3a01      	subs	r2, #1
34013456:	4628      	mov	r0, r5
34013458:	696b      	ldr	r3, [r5, #20]
3401345a:	b292      	uxth	r2, r2
3401345c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401345e:	4604      	mov	r4, r0
34013460:	b118      	cbz	r0, 3401346a <VD6G_Start+0x16e>
34013462:	f240 3333 	movw	r3, #819	@ 0x333
34013466:	9000      	str	r0, [sp, #0]
34013468:	e7c5      	b.n	340133f6 <VD6G_Start+0xfa>
  return VD6G_SetExposureModeInternal(ctx, drv_ctx->config_save.exposure_mode);
3401346a:	4628      	mov	r0, r5
3401346c:	f895 1064 	ldrb.w	r1, [r5, #100]	@ 0x64
34013470:	f7ff fb4a 	bl	34012b08 <VD6G_SetExposureModeInternal>
  if (ret)
34013474:	4604      	mov	r4, r0
34013476:	2800      	cmp	r0, #0
34013478:	f47f af48 	bne.w	3401330c <VD6G_Start+0x10>
  switch (drv_ctx->config_save.flip_mirror_mode) {
3401347c:	f895 303c 	ldrb.w	r3, [r5, #60]	@ 0x3c
34013480:	2b03      	cmp	r3, #3
34013482:	f63f af41 	bhi.w	34013308 <VD6G_Start+0xc>
  ret = ctx->write8(ctx, VD6G_REG_ORIENTATION, mode);
34013486:	4a39      	ldr	r2, [pc, #228]	@ (3401356c <VD6G_Start+0x270>)
34013488:	692c      	ldr	r4, [r5, #16]
3401348a:	f240 3102 	movw	r1, #770	@ 0x302
3401348e:	4628      	mov	r0, r5
34013490:	5cd2      	ldrb	r2, [r2, r3]
34013492:	47a0      	blx	r4
  VD6G_TraceError(ctx, ret);
34013494:	4604      	mov	r4, r0
34013496:	b9a8      	cbnz	r0, 340134c4 <VD6G_Start+0x1c8>
  switch (drv_ctx->config_save.patgen) {
34013498:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
3401349c:	2b06      	cmp	r3, #6
3401349e:	f63f af33 	bhi.w	34013308 <VD6G_Start+0xc>
340134a2:	4a33      	ldr	r2, [pc, #204]	@ (34013570 <VD6G_Start+0x274>)
340134a4:	f832 6013 	ldrh.w	r6, [r2, r3, lsl #1]
  if (drv_ctx->config_save.patgen != VD6G_PATGEN_DISABLE)
340134a8:	b1eb      	cbz	r3, 340134e6 <VD6G_Start+0x1ea>
    ret = ctx->write8(ctx, VD6G_REG_DUSTER_CTRL, VD6G_DUSTER_CTRL_DISABLE);
340134aa:	4602      	mov	r2, r0
340134ac:	f44f 7146 	mov.w	r1, #792	@ 0x318
340134b0:	4628      	mov	r0, r5
340134b2:	692b      	ldr	r3, [r5, #16]
340134b4:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
340134b6:	4604      	mov	r4, r0
340134b8:	b148      	cbz	r0, 340134ce <VD6G_Start+0x1d2>
340134ba:	f240 3392 	movw	r3, #914	@ 0x392
340134be:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340134c0:	4a2c      	ldr	r2, [pc, #176]	@ (34013574 <VD6G_Start+0x278>)
340134c2:	e763      	b.n	3401338c <VD6G_Start+0x90>
  VD6G_TraceError(ctx, ret);
340134c4:	f240 336a 	movw	r3, #874	@ 0x36a
340134c8:	4a2b      	ldr	r2, [pc, #172]	@ (34013578 <VD6G_Start+0x27c>)
340134ca:	9000      	str	r0, [sp, #0]
340134cc:	e75e      	b.n	3401338c <VD6G_Start+0x90>
    ret = ctx->write8(ctx, VD6G_REG_DARKCAL_CTRL, VD6G_DARKCAL_CTRL_DISABLE_DARKAVG);
340134ce:	2202      	movs	r2, #2
340134d0:	f44f 7150 	mov.w	r1, #832	@ 0x340
340134d4:	4628      	mov	r0, r5
340134d6:	692b      	ldr	r3, [r5, #16]
340134d8:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
340134da:	4604      	mov	r4, r0
340134dc:	b118      	cbz	r0, 340134e6 <VD6G_Start+0x1ea>
340134de:	f44f 7365 	mov.w	r3, #916	@ 0x394
340134e2:	9000      	str	r0, [sp, #0]
340134e4:	e7ec      	b.n	340134c0 <VD6G_Start+0x1c4>
  ret = ctx->write16(ctx, VD6G_REG_PATGEN_CTRL, value);
340134e6:	4632      	mov	r2, r6
340134e8:	f44f 6180 	mov.w	r1, #1024	@ 0x400
340134ec:	4628      	mov	r0, r5
340134ee:	696b      	ldr	r3, [r5, #20]
340134f0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340134f2:	4604      	mov	r4, r0
340134f4:	b118      	cbz	r0, 340134fe <VD6G_Start+0x202>
340134f6:	f44f 7366 	mov.w	r3, #920	@ 0x398
340134fa:	9000      	str	r0, [sp, #0]
340134fc:	e7e0      	b.n	340134c0 <VD6G_Start+0x1c4>
  return VD6G_SetFlicker(ctx, drv_ctx->config_save.flicker);
340134fe:	4628      	mov	r0, r5
34013500:	f895 1045 	ldrb.w	r1, [r5, #69]	@ 0x45
34013504:	f7ff fb20 	bl	34012b48 <VD6G_SetFlicker>
  if (ret)
34013508:	4604      	mov	r4, r0
3401350a:	2800      	cmp	r0, #0
3401350c:	f47f aefe 	bne.w	3401330c <VD6G_Start+0x10>
  ret = ctx->write8(ctx, VD6G_REG_STBY, VD6G_CMD_START_STREAM);
34013510:	2201      	movs	r2, #1
34013512:	f240 2101 	movw	r1, #513	@ 0x201
34013516:	4628      	mov	r0, r5
34013518:	692b      	ldr	r3, [r5, #16]
3401351a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401351c:	4604      	mov	r4, r0
3401351e:	b120      	cbz	r0, 3401352a <VD6G_Start+0x22e>
34013520:	f44f 737c 	mov.w	r3, #1008	@ 0x3f0
34013524:	4a15      	ldr	r2, [pc, #84]	@ (3401357c <VD6G_Start+0x280>)
34013526:	9000      	str	r0, [sp, #0]
34013528:	e730      	b.n	3401338c <VD6G_Start+0x90>
  ret = VD6G_PollReg8(ctx, VD6G_REG_STBY, VD6G_CMD_ACK);
3401352a:	4602      	mov	r2, r0
3401352c:	f240 2101 	movw	r1, #513	@ 0x201
34013530:	4628      	mov	r0, r5
34013532:	f7ff fab9 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
34013536:	4604      	mov	r4, r0
34013538:	2800      	cmp	r0, #0
3401353a:	f47f aee7 	bne.w	3401330c <VD6G_Start+0x10>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_STREAMING);
3401353e:	2103      	movs	r1, #3
34013540:	4628      	mov	r0, r5
34013542:	f7ff fb9f 	bl	34012c84 <VD6G_WaitState>
  if (ret)
34013546:	4604      	mov	r4, r0
34013548:	2800      	cmp	r0, #0
3401354a:	f47f aedf 	bne.w	3401330c <VD6G_Start+0x10>
  VD6G_notice(ctx, "Streaming is on\n");
3401354e:	4628      	mov	r0, r5
34013550:	490b      	ldr	r1, [pc, #44]	@ (34013580 <VD6G_Start+0x284>)
34013552:	f7ff fa7a 	bl	34012a4a <VD6G_notice>
  drv_ctx->is_streaming = 1;
34013556:	2301      	movs	r3, #1
34013558:	62eb      	str	r3, [r5, #44]	@ 0x2c
  return 0;
3401355a:	e6d7      	b.n	3401330c <VD6G_Start+0x10>
3401355c:	340370ee 	.word	0x340370ee
34013560:	3401ca00 	.word	0x3401ca00
34013564:	34036fa0 	.word	0x34036fa0
34013568:	340370df 	.word	0x340370df
3401356c:	34036f9a 	.word	0x34036f9a
34013570:	34036f8c 	.word	0x34036f8c
34013574:	3403709c 	.word	0x3403709c
34013578:	340370ad 	.word	0x340370ad
3401357c:	34037078 	.word	0x34037078
34013580:	3401cc88 	.word	0x3401cc88

34013584 <VD6G_Stop>:

int VD6G_Stop(VD6G_Ctx_t *ctx)
{
34013584:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
34013586:	6903      	ldr	r3, [r0, #16]
34013588:	2201      	movs	r2, #1
3401358a:	f240 2102 	movw	r1, #514	@ 0x202
{
3401358e:	4605      	mov	r5, r0
  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
34013590:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013592:	4604      	mov	r4, r0
34013594:	b998      	cbnz	r0, 340135be <VD6G_Stop+0x3a>
  ret = VD6G_PollReg8(ctx, VD6G_REG_STREAMING, VD6G_CMD_ACK);
34013596:	4602      	mov	r2, r0
34013598:	f240 2102 	movw	r1, #514	@ 0x202
3401359c:	4628      	mov	r0, r5
3401359e:	f7ff fa83 	bl	34012aa8 <VD6G_PollReg8>
  if (ret)
340135a2:	4604      	mov	r4, r0
340135a4:	b9b0      	cbnz	r0, 340135d4 <VD6G_Stop+0x50>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
340135a6:	2102      	movs	r1, #2
340135a8:	4628      	mov	r0, r5
340135aa:	f7ff fb6b 	bl	34012c84 <VD6G_WaitState>
  if (ret)
340135ae:	4604      	mov	r4, r0
340135b0:	b980      	cbnz	r0, 340135d4 <VD6G_Stop+0x50>
  VD6G_notice(ctx, "Streaming is off\n");
340135b2:	4628      	mov	r0, r5
340135b4:	4909      	ldr	r1, [pc, #36]	@ (340135dc <VD6G_Stop+0x58>)
340135b6:	f7ff fa48 	bl	34012a4a <VD6G_notice>
  int ret;

  ret = VD6G_StopStreaming(ctx);
  if (ret)
    return ret;
  drv_ctx->is_streaming = 0;
340135ba:	62ec      	str	r4, [r5, #44]	@ 0x2c

  return 0;
340135bc:	e00a      	b.n	340135d4 <VD6G_Stop+0x50>
  VD6G_TraceError(ctx, ret);
340135be:	9000      	str	r0, [sp, #0]
340135c0:	f240 4304 	movw	r3, #1028	@ 0x404
340135c4:	4628      	mov	r0, r5
340135c6:	4a06      	ldr	r2, [pc, #24]	@ (340135e0 <VD6G_Stop+0x5c>)
340135c8:	4906      	ldr	r1, [pc, #24]	@ (340135e4 <VD6G_Stop+0x60>)
340135ca:	f7ff fa30 	bl	34012a2e <VD6G_error>
340135ce:	4628      	mov	r0, r5
340135d0:	f7ff fa4a 	bl	34012a68 <display_error>
}
340135d4:	4620      	mov	r0, r4
340135d6:	b003      	add	sp, #12
340135d8:	bd30      	pop	{r4, r5, pc}
340135da:	bf00      	nop
340135dc:	3401cb14 	.word	0x3401cb14
340135e0:	34037065 	.word	0x34037065
340135e4:	3401ca00 	.word	0x3401ca00

340135e8 <VD6G_SetExposureMode>:

  return 0;
}

int VD6G_SetExposureMode(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
340135e8:	b538      	push	{r3, r4, r5, lr}
340135ea:	4604      	mov	r4, r0
340135ec:	460d      	mov	r5, r1
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
  int ret;

  ret = VD6G_SetExposureModeInternal(ctx, mode);
340135ee:	f7ff fa8b 	bl	34012b08 <VD6G_SetExposureModeInternal>
  if (ret)
340135f2:	b908      	cbnz	r0, 340135f8 <VD6G_SetExposureMode+0x10>
    return ret;

  drv_ctx->config_save.exposure_mode = mode;
340135f4:	f884 5064 	strb.w	r5, [r4, #100]	@ 0x64

  return 0;
}
340135f8:	bd38      	pop	{r3, r4, r5, pc}
	...

340135fc <VD6G_GetAnalogGainRegRange>:

int VD6G_GetAnalogGainRegRange(VD6G_Ctx_t *ctx, uint8_t *AGmin, uint8_t *AGmax)
{
340135fc:	b5f0      	push	{r4, r5, r6, r7, lr}
340135fe:	4605      	mov	r5, r0
34013600:	4616      	mov	r6, r2
  int ret;
  uint8_t value;

  if ((AGmin == NULL) || (AGmax == NULL))
34013602:	460f      	mov	r7, r1
{
34013604:	b085      	sub	sp, #20
  if ((AGmin == NULL) || (AGmax == NULL))
34013606:	b371      	cbz	r1, 34013666 <VD6G_GetAnalogGainRegRange+0x6a>
34013608:	b36a      	cbz	r2, 34013666 <VD6G_GetAnalogGainRegRange+0x6a>
    return -1;

  ret = ctx->read8(ctx, VD6G_REG_MIN_AG_CODED, &value);
3401360a:	f640 117e 	movw	r1, #2430	@ 0x97e
3401360e:	6843      	ldr	r3, [r0, #4]
34013610:	f10d 020f 	add.w	r2, sp, #15
34013614:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013616:	4604      	mov	r4, r0
34013618:	b988      	cbnz	r0, 3401363e <VD6G_GetAnalogGainRegRange+0x42>
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
3401361a:	f89d 300f 	ldrb.w	r3, [sp, #15]

  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
3401361e:	f44f 6116 	mov.w	r1, #2400	@ 0x960
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
34013622:	f003 031f 	and.w	r3, r3, #31
34013626:	703b      	strb	r3, [r7, #0]
  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
34013628:	4628      	mov	r0, r5
3401362a:	686b      	ldr	r3, [r5, #4]
3401362c:	f10d 020f 	add.w	r2, sp, #15
34013630:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013632:	4604      	mov	r4, r0
34013634:	b178      	cbz	r0, 34013656 <VD6G_GetAnalogGainRegRange+0x5a>
34013636:	f240 43cc 	movw	r3, #1228	@ 0x4cc
3401363a:	9000      	str	r0, [sp, #0]
3401363c:	e002      	b.n	34013644 <VD6G_GetAnalogGainRegRange+0x48>
  VD6G_TraceError(ctx, ret);
3401363e:	f44f 6399 	mov.w	r3, #1224	@ 0x4c8
34013642:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013644:	4628      	mov	r0, r5
34013646:	4a09      	ldr	r2, [pc, #36]	@ (3401366c <VD6G_GetAnalogGainRegRange+0x70>)
34013648:	4909      	ldr	r1, [pc, #36]	@ (34013670 <VD6G_GetAnalogGainRegRange+0x74>)
3401364a:	f7ff f9f0 	bl	34012a2e <VD6G_error>
3401364e:	4628      	mov	r0, r5
34013650:	f7ff fa0a 	bl	34012a68 <display_error>
34013654:	e004      	b.n	34013660 <VD6G_GetAnalogGainRegRange+0x64>
  *AGmax = value & VD6G_REG_MAX_AG_CODED_MASK;
34013656:	f89d 300f 	ldrb.w	r3, [sp, #15]
3401365a:	f003 031f 	and.w	r3, r3, #31
3401365e:	7033      	strb	r3, [r6, #0]

  return 0;
}
34013660:	4620      	mov	r0, r4
34013662:	b005      	add	sp, #20
34013664:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1;
34013666:	f04f 34ff 	mov.w	r4, #4294967295
3401366a:	e7f9      	b.n	34013660 <VD6G_GetAnalogGainRegRange+0x64>
3401366c:	3403704a 	.word	0x3403704a
34013670:	3401ca00 	.word	0x3401ca00

34013674 <VD6G_SetAnalogGain>:

int VD6G_SetAnalogGain(VD6G_Ctx_t *ctx, int gain)
{
34013674:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34013676:	460e      	mov	r6, r1
  int ret;
  uint8_t again_regmin, again_regmax;

  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
34013678:	f10d 020f 	add.w	r2, sp, #15
3401367c:	f10d 010e 	add.w	r1, sp, #14
{
34013680:	4605      	mov	r5, r0
  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
34013682:	f7ff ffbb 	bl	340135fc <VD6G_GetAnalogGainRegRange>
  if (ret)
34013686:	4604      	mov	r4, r0
34013688:	b9d0      	cbnz	r0, 340136c0 <VD6G_SetAnalogGain+0x4c>
    return ret;

  ret = CHECK_RANGE(gain, again_regmin, again_regmax);
3401368a:	f89d 300e 	ldrb.w	r3, [sp, #14]
3401368e:	42b3      	cmp	r3, r6
34013690:	dc19      	bgt.n	340136c6 <VD6G_SetAnalogGain+0x52>
34013692:	f89d 300f 	ldrb.w	r3, [sp, #15]
34013696:	42b3      	cmp	r3, r6
34013698:	db15      	blt.n	340136c6 <VD6G_SetAnalogGain+0x52>
  if (ret)
    return ret;

  ret = ctx->write8(ctx, VD6G_REG_MANUAL_ANALOG_GAIN, gain);
3401369a:	f240 414d 	movw	r1, #1101	@ 0x44d
3401369e:	4628      	mov	r0, r5
340136a0:	692b      	ldr	r3, [r5, #16]
340136a2:	b2f2      	uxtb	r2, r6
340136a4:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340136a6:	4604      	mov	r4, r0
340136a8:	b150      	cbz	r0, 340136c0 <VD6G_SetAnalogGain+0x4c>
340136aa:	9000      	str	r0, [sp, #0]
340136ac:	f44f 639c 	mov.w	r3, #1248	@ 0x4e0
340136b0:	4628      	mov	r0, r5
340136b2:	4a06      	ldr	r2, [pc, #24]	@ (340136cc <VD6G_SetAnalogGain+0x58>)
340136b4:	4906      	ldr	r1, [pc, #24]	@ (340136d0 <VD6G_SetAnalogGain+0x5c>)
340136b6:	f7ff f9ba 	bl	34012a2e <VD6G_error>
340136ba:	4628      	mov	r0, r5
340136bc:	f7ff f9d4 	bl	34012a68 <display_error>

  return 0;
}
340136c0:	4620      	mov	r0, r4
340136c2:	b004      	add	sp, #16
340136c4:	bd70      	pop	{r4, r5, r6, pc}
    return ret;
340136c6:	f04f 34ff 	mov.w	r4, #4294967295
340136ca:	e7f9      	b.n	340136c0 <VD6G_SetAnalogGain+0x4c>
340136cc:	34037037 	.word	0x34037037
340136d0:	3401ca00 	.word	0x3401ca00

340136d4 <VD6G_GetDigitalGainRegRange>:

int VD6G_GetDigitalGainRegRange(VD6G_Ctx_t *ctx, uint16_t *DGmin, uint16_t *DGmax)
{
340136d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
340136d6:	4616      	mov	r6, r2
340136d8:	4605      	mov	r5, r0
  int ret;

  if ((DGmin == NULL) && (DGmax == NULL))
340136da:	460a      	mov	r2, r1
340136dc:	b901      	cbnz	r1, 340136e0 <VD6G_GetDigitalGainRegRange+0xc>
340136de:	b306      	cbz	r6, 34013722 <VD6G_GetDigitalGainRegRange+0x4e>
    return -1;

  ret = ctx->read16(ctx, VD6G_REG_MIN_DG, DGmin);
340136e0:	f640 117c 	movw	r1, #2428	@ 0x97c
340136e4:	4628      	mov	r0, r5
340136e6:	68ab      	ldr	r3, [r5, #8]
340136e8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340136ea:	4604      	mov	r4, r0
340136ec:	b958      	cbnz	r0, 34013706 <VD6G_GetDigitalGainRegRange+0x32>

  ret = ctx->read16(ctx, VD6G_REG_MAX_DG, DGmax);
340136ee:	4632      	mov	r2, r6
340136f0:	f640 115e 	movw	r1, #2398	@ 0x95e
340136f4:	4628      	mov	r0, r5
340136f6:	68ab      	ldr	r3, [r5, #8]
340136f8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340136fa:	4604      	mov	r4, r0
340136fc:	b170      	cbz	r0, 3401371c <VD6G_GetDigitalGainRegRange+0x48>
340136fe:	f44f 639e 	mov.w	r3, #1264	@ 0x4f0
34013702:	9000      	str	r0, [sp, #0]
34013704:	e002      	b.n	3401370c <VD6G_GetDigitalGainRegRange+0x38>
  VD6G_TraceError(ctx, ret);
34013706:	f240 43ed 	movw	r3, #1261	@ 0x4ed
3401370a:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
3401370c:	4628      	mov	r0, r5
3401370e:	4a06      	ldr	r2, [pc, #24]	@ (34013728 <VD6G_GetDigitalGainRegRange+0x54>)
34013710:	4906      	ldr	r1, [pc, #24]	@ (3401372c <VD6G_GetDigitalGainRegRange+0x58>)
34013712:	f7ff f98c 	bl	34012a2e <VD6G_error>
34013716:	4628      	mov	r0, r5
34013718:	f7ff f9a6 	bl	34012a68 <display_error>

  return 0;
}
3401371c:	4620      	mov	r0, r4
3401371e:	b002      	add	sp, #8
34013720:	bd70      	pop	{r4, r5, r6, pc}
    return -1;
34013722:	f04f 34ff 	mov.w	r4, #4294967295
34013726:	e7f9      	b.n	3401371c <VD6G_GetDigitalGainRegRange+0x48>
34013728:	3403701b 	.word	0x3403701b
3401372c:	3401ca00 	.word	0x3401ca00

34013730 <VD6G_SetDigitalGain>:

int VD6G_SetDigitalGain(VD6G_Ctx_t *ctx, int gain)
{
34013730:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34013732:	460e      	mov	r6, r1
  int ret;
  uint16_t dgain_regmin, dgain_regmax;

  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
34013734:	f10d 020e 	add.w	r2, sp, #14
34013738:	a903      	add	r1, sp, #12
{
3401373a:	4605      	mov	r5, r0
  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
3401373c:	f7ff ffca 	bl	340136d4 <VD6G_GetDigitalGainRegRange>
  if (ret)
34013740:	4604      	mov	r4, r0
34013742:	bb38      	cbnz	r0, 34013794 <VD6G_SetDigitalGain+0x64>
    return ret;

  ret = CHECK_RANGE(gain, dgain_regmin, dgain_regmax);
34013744:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013748:	42b3      	cmp	r3, r6
3401374a:	dc3f      	bgt.n	340137cc <VD6G_SetDigitalGain+0x9c>
3401374c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34013750:	42b3      	cmp	r3, r6
34013752:	db3b      	blt.n	340137cc <VD6G_SetDigitalGain+0x9c>
  if (ret)
    return ret;

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH0_DIGITAL_GAIN, gain);
34013754:	b2b6      	uxth	r6, r6
34013756:	4632      	mov	r2, r6
34013758:	f44f 618a 	mov.w	r1, #1104	@ 0x450
3401375c:	4628      	mov	r0, r5
3401375e:	696b      	ldr	r3, [r5, #20]
34013760:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013762:	4604      	mov	r4, r0
34013764:	b958      	cbnz	r0, 3401377e <VD6G_SetDigitalGain+0x4e>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH1_DIGITAL_GAIN, gain);
34013766:	4632      	mov	r2, r6
34013768:	f240 4152 	movw	r1, #1106	@ 0x452
3401376c:	4628      	mov	r0, r5
3401376e:	696b      	ldr	r3, [r5, #20]
34013770:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013772:	4604      	mov	r4, r0
34013774:	b188      	cbz	r0, 3401379a <VD6G_SetDigitalGain+0x6a>
34013776:	f240 5306 	movw	r3, #1286	@ 0x506
3401377a:	9000      	str	r0, [sp, #0]
3401377c:	e002      	b.n	34013784 <VD6G_SetDigitalGain+0x54>
  VD6G_TraceError(ctx, ret);
3401377e:	f240 5303 	movw	r3, #1283	@ 0x503
34013782:	9000      	str	r0, [sp, #0]

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
  VD6G_TraceError(ctx, ret);

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
  VD6G_TraceError(ctx, ret);
34013784:	4628      	mov	r0, r5
34013786:	4a13      	ldr	r2, [pc, #76]	@ (340137d4 <VD6G_SetDigitalGain+0xa4>)
34013788:	4913      	ldr	r1, [pc, #76]	@ (340137d8 <VD6G_SetDigitalGain+0xa8>)
3401378a:	f7ff f950 	bl	34012a2e <VD6G_error>
3401378e:	4628      	mov	r0, r5
34013790:	f7ff f96a 	bl	34012a68 <display_error>

  return 0;
}
34013794:	4620      	mov	r0, r4
34013796:	b004      	add	sp, #16
34013798:	bd70      	pop	{r4, r5, r6, pc}
  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
3401379a:	4632      	mov	r2, r6
3401379c:	f240 4154 	movw	r1, #1108	@ 0x454
340137a0:	4628      	mov	r0, r5
340137a2:	696b      	ldr	r3, [r5, #20]
340137a4:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340137a6:	4604      	mov	r4, r0
340137a8:	b118      	cbz	r0, 340137b2 <VD6G_SetDigitalGain+0x82>
340137aa:	f240 5309 	movw	r3, #1289	@ 0x509
340137ae:	9000      	str	r0, [sp, #0]
340137b0:	e7e8      	b.n	34013784 <VD6G_SetDigitalGain+0x54>
  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
340137b2:	4632      	mov	r2, r6
340137b4:	f240 4156 	movw	r1, #1110	@ 0x456
340137b8:	4628      	mov	r0, r5
340137ba:	696b      	ldr	r3, [r5, #20]
340137bc:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340137be:	4604      	mov	r4, r0
340137c0:	2800      	cmp	r0, #0
340137c2:	d0e7      	beq.n	34013794 <VD6G_SetDigitalGain+0x64>
340137c4:	f240 530c 	movw	r3, #1292	@ 0x50c
340137c8:	9000      	str	r0, [sp, #0]
340137ca:	e7db      	b.n	34013784 <VD6G_SetDigitalGain+0x54>
    return ret;
340137cc:	f04f 34ff 	mov.w	r4, #4294967295
340137d0:	e7e0      	b.n	34013794 <VD6G_SetDigitalGain+0x64>
340137d2:	bf00      	nop
340137d4:	34037007 	.word	0x34037007
340137d8:	3401ca00 	.word	0x3401ca00

340137dc <VD6G_GetExposureRegRange>:

int VD6G_GetExposureRegRange(VD6G_Ctx_t *ctx, uint32_t *min_us, uint32_t *max_us)
{
340137dc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
340137e0:	4605      	mov	r5, r0
340137e2:	4616      	mov	r6, r2
  uint16_t exp_coarse_intg_margin;
  uint32_t line_time_in_us;
  uint16_t frame_length;
  int ret;

  if ((min_us == NULL) || (max_us == NULL))
340137e4:	460f      	mov	r7, r1
340137e6:	b929      	cbnz	r1, 340137f4 <VD6G_GetExposureRegRange+0x18>
    return -1;
340137e8:	f04f 34ff 	mov.w	r4, #4294967295
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
  else
    return -1;

  return 0;
}
340137ec:	4620      	mov	r0, r4
340137ee:	b004      	add	sp, #16
340137f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((min_us == NULL) || (max_us == NULL))
340137f4:	2a00      	cmp	r2, #0
340137f6:	d0f7      	beq.n	340137e8 <VD6G_GetExposureRegRange+0xc>
  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
340137f8:	a903      	add	r1, sp, #12
340137fa:	f7ff f9c9 	bl	34012b90 <VD6G_GetLineTimeInUs>
  if (ret)
340137fe:	4604      	mov	r4, r0
34013800:	2800      	cmp	r0, #0
34013802:	d1f3      	bne.n	340137ec <VD6G_GetExposureRegRange+0x10>
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
34013804:	2315      	movs	r3, #21
34013806:	f8dd 800c 	ldr.w	r8, [sp, #12]
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
3401380a:	f44f 618b 	mov.w	r1, #1112	@ 0x458
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
3401380e:	fb03 f308 	mul.w	r3, r3, r8
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
34013812:	4628      	mov	r0, r5
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
34013814:	603b      	str	r3, [r7, #0]
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
34013816:	f10d 020a 	add.w	r2, sp, #10
3401381a:	68ab      	ldr	r3, [r5, #8]
3401381c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401381e:	4604      	mov	r4, r0
34013820:	b958      	cbnz	r0, 3401383a <VD6G_GetExposureRegRange+0x5e>
  ret = ctx->read16(ctx, VD6G_REG_EXP_COARSE_INTG_MARGIN, &exp_coarse_intg_margin);
34013822:	f640 1146 	movw	r1, #2374	@ 0x946
34013826:	4628      	mov	r0, r5
34013828:	68ab      	ldr	r3, [r5, #8]
3401382a:	aa02      	add	r2, sp, #8
3401382c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401382e:	4604      	mov	r4, r0
34013830:	b178      	cbz	r0, 34013852 <VD6G_GetExposureRegRange+0x76>
34013832:	f240 5325 	movw	r3, #1317	@ 0x525
34013836:	9000      	str	r0, [sp, #0]
34013838:	e002      	b.n	34013840 <VD6G_GetExposureRegRange+0x64>
  VD6G_TraceError(ctx, ret);
3401383a:	f240 5322 	movw	r3, #1314	@ 0x522
3401383e:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013840:	4628      	mov	r0, r5
34013842:	4a0a      	ldr	r2, [pc, #40]	@ (3401386c <VD6G_GetExposureRegRange+0x90>)
34013844:	490a      	ldr	r1, [pc, #40]	@ (34013870 <VD6G_GetExposureRegRange+0x94>)
34013846:	f7ff f8f2 	bl	34012a2e <VD6G_error>
3401384a:	4628      	mov	r0, r5
3401384c:	f7ff f90c 	bl	34012a68 <display_error>
34013850:	e7cc      	b.n	340137ec <VD6G_GetExposureRegRange+0x10>
  if (exp_coarse_intg_margin >= VD6G_MIN_EXP_COARSE_INTG_MARGIN)
34013852:	f8bd 2008 	ldrh.w	r2, [sp, #8]
34013856:	2a43      	cmp	r2, #67	@ 0x43
34013858:	d9c6      	bls.n	340137e8 <VD6G_GetExposureRegRange+0xc>
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
3401385a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
3401385e:	1a9b      	subs	r3, r3, r2
34013860:	3b07      	subs	r3, #7
34013862:	fb08 f303 	mul.w	r3, r8, r3
34013866:	6033      	str	r3, [r6, #0]
  return 0;
34013868:	e7c0      	b.n	340137ec <VD6G_GetExposureRegRange+0x10>
3401386a:	bf00      	nop
3401386c:	34036fee 	.word	0x34036fee
34013870:	3401ca00 	.word	0x3401ca00

34013874 <VD6G_SetExposureTime>:

int VD6G_SetExposureTime(VD6G_Ctx_t *ctx, int exposure_us)
{
34013874:	b570      	push	{r4, r5, r6, lr}
34013876:	b086      	sub	sp, #24
34013878:	460e      	mov	r6, r1
  int32_t ret;
  uint32_t exp_min, exp_max;
  uint32_t line_time_in_us;

  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
3401387a:	aa04      	add	r2, sp, #16
3401387c:	a903      	add	r1, sp, #12
{
3401387e:	4605      	mov	r5, r0
  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
34013880:	f7ff ffac 	bl	340137dc <VD6G_GetExposureRegRange>
  if (ret)
34013884:	4604      	mov	r4, r0
34013886:	bb08      	cbnz	r0, 340138cc <VD6G_SetExposureTime+0x58>
    return ret;

  ret = CHECK_RANGE(exposure_us, exp_min, exp_max);
34013888:	9b03      	ldr	r3, [sp, #12]
3401388a:	429e      	cmp	r6, r3
3401388c:	d321      	bcc.n	340138d2 <VD6G_SetExposureTime+0x5e>
3401388e:	9b04      	ldr	r3, [sp, #16]
34013890:	429e      	cmp	r6, r3
34013892:	d81e      	bhi.n	340138d2 <VD6G_SetExposureTime+0x5e>
  if (ret)
    return ret;

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
34013894:	4628      	mov	r0, r5
34013896:	a905      	add	r1, sp, #20
34013898:	f7ff f97a 	bl	34012b90 <VD6G_GetLineTimeInUs>
  if (ret)
3401389c:	4604      	mov	r4, r0
3401389e:	b9a8      	cbnz	r0, 340138cc <VD6G_SetExposureTime+0x58>
    return ret;

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_COARSE_EXP, CEIL(exposure_us / line_time_in_us));
340138a0:	9b05      	ldr	r3, [sp, #20]
340138a2:	f240 414e 	movw	r1, #1102	@ 0x44e
340138a6:	fbb6 f2f3 	udiv	r2, r6, r3
340138aa:	4628      	mov	r0, r5
340138ac:	696b      	ldr	r3, [r5, #20]
340138ae:	b292      	uxth	r2, r2
340138b0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340138b2:	4604      	mov	r4, r0
340138b4:	b150      	cbz	r0, 340138cc <VD6G_SetExposureTime+0x58>
340138b6:	9000      	str	r0, [sp, #0]
340138b8:	f240 5342 	movw	r3, #1346	@ 0x542
340138bc:	4628      	mov	r0, r5
340138be:	4a06      	ldr	r2, [pc, #24]	@ (340138d8 <VD6G_SetExposureTime+0x64>)
340138c0:	4906      	ldr	r1, [pc, #24]	@ (340138dc <VD6G_SetExposureTime+0x68>)
340138c2:	f7ff f8b4 	bl	34012a2e <VD6G_error>
340138c6:	4628      	mov	r0, r5
340138c8:	f7ff f8ce 	bl	34012a68 <display_error>

  return 0;
}
340138cc:	4620      	mov	r0, r4
340138ce:	b006      	add	sp, #24
340138d0:	bd70      	pop	{r4, r5, r6, pc}
    return ret;
340138d2:	f04f 34ff 	mov.w	r4, #4294967295
340138d6:	e7f9      	b.n	340138cc <VD6G_SetExposureTime+0x58>
340138d8:	34036fc4 	.word	0x34036fc4
340138dc:	3401ca00 	.word	0x3401ca00

340138e0 <ISP_Algo_BadPixel_Init>:
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
340138e0:	2000      	movs	r0, #0
340138e2:	7048      	strb	r0, [r1, #1]

  return ISP_OK;
}
340138e4:	4770      	bx	lr

340138e6 <ISP_Algo_BadPixel_DeInit>:
{
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
}
340138e6:	2000      	movs	r0, #0
340138e8:	4770      	bx	lr

340138ea <ISP_Algo_AEC_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
340138ea:	2303      	movs	r3, #3
340138ec:	7043      	strb	r3, [r0, #1]

  return ISP_OK;
}
340138ee:	2000      	movs	r0, #0
340138f0:	4770      	bx	lr

340138f2 <ISP_Algo_AWB_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
340138f2:	7843      	ldrb	r3, [r0, #1]
340138f4:	b10b      	cbz	r3, 340138fa <ISP_Algo_AWB_StatCb+0x8>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
340138f6:	2303      	movs	r3, #3
340138f8:	7043      	strb	r3, [r0, #1]
  }

  return ISP_OK;
}
340138fa:	2000      	movs	r0, #0
340138fc:	4770      	bx	lr
	...

34013900 <ISP_Algo_BadPixel_Process>:
{
34013900:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34013902:	4604      	mov	r4, r0
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013904:	f001 f96e 	bl	34014be4 <ISP_SVC_IQParam_Get>
  if (IQParamConfig->badPixelAlgo.enable == false)
34013908:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401390c:	4607      	mov	r7, r0
  if (IQParamConfig->badPixelAlgo.enable == false)
3401390e:	b913      	cbnz	r3, 34013916 <ISP_Algo_BadPixel_Process+0x16>
    return ISP_OK;
34013910:	2000      	movs	r0, #0
}
34013912:	b003      	add	sp, #12
34013914:	bdf0      	pop	{r4, r5, r6, r7, pc}
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
34013916:	4620      	mov	r0, r4
34013918:	f001 f91c 	bl	34014b54 <ISP_SVC_Misc_GetMainFrameId>
  if (CurrentFrameId == LastFrameId)
3401391c:	4b1e      	ldr	r3, [pc, #120]	@ (34013998 <ISP_Algo_BadPixel_Process+0x98>)
3401391e:	681a      	ldr	r2, [r3, #0]
34013920:	4282      	cmp	r2, r0
34013922:	d0f5      	beq.n	34013910 <ISP_Algo_BadPixel_Process+0x10>
  if (Step++ >= 0)
34013924:	4d1d      	ldr	r5, [pc, #116]	@ (3401399c <ISP_Algo_BadPixel_Process+0x9c>)
  LastFrameId = CurrentFrameId;
34013926:	6018      	str	r0, [r3, #0]
  if (Step++ >= 0)
34013928:	f995 3000 	ldrsb.w	r3, [r5]
3401392c:	1c5a      	adds	r2, r3, #1
3401392e:	2b00      	cmp	r3, #0
34013930:	702a      	strb	r2, [r5, #0]
34013932:	db0a      	blt.n	3401394a <ISP_Algo_BadPixel_Process+0x4a>
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
34013934:	4669      	mov	r1, sp
34013936:	4620      	mov	r0, r4
34013938:	f000 ff0b 	bl	34014752 <ISP_SVC_ISP_GetBadPixel>
    if (ret != ISP_OK)
3401393c:	2800      	cmp	r0, #0
3401393e:	d1e8      	bne.n	34013912 <ISP_Algo_BadPixel_Process+0x12>
    BadPixelCount += BadPixelConfig.count;
34013940:	4a17      	ldr	r2, [pc, #92]	@ (340139a0 <ISP_Algo_BadPixel_Process+0xa0>)
34013942:	9b01      	ldr	r3, [sp, #4]
34013944:	6811      	ldr	r1, [r2, #0]
34013946:	440b      	add	r3, r1
34013948:	6013      	str	r3, [r2, #0]
  if (Step == 10)
3401394a:	f995 2000 	ldrsb.w	r2, [r5]
3401394e:	2a0a      	cmp	r2, #10
34013950:	d1de      	bne.n	34013910 <ISP_Algo_BadPixel_Process+0x10>
    BadPixelCount /= 10;
34013952:	4e13      	ldr	r6, [pc, #76]	@ (340139a0 <ISP_Algo_BadPixel_Process+0xa0>)
34013954:	6833      	ldr	r3, [r6, #0]
34013956:	fbb3 f3f2 	udiv	r3, r3, r2
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
3401395a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
    BadPixelCount /= 10;
3401395c:	6033      	str	r3, [r6, #0]
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
3401395e:	4293      	cmp	r3, r2
34013960:	d912      	bls.n	34013988 <ISP_Algo_BadPixel_Process+0x88>
34013962:	f89d 3001 	ldrb.w	r3, [sp, #1]
34013966:	b113      	cbz	r3, 3401396e <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength--;
34013968:	3b01      	subs	r3, #1
      BadPixelConfig.strength++;
3401396a:	f88d 3001 	strb.w	r3, [sp, #1]
    BadPixelConfig.enable = 1;
3401396e:	2301      	movs	r3, #1
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34013970:	4669      	mov	r1, sp
34013972:	4620      	mov	r0, r4
    BadPixelConfig.enable = 1;
34013974:	f88d 3000 	strb.w	r3, [sp]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34013978:	f000 fed0 	bl	3401471c <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
3401397c:	2800      	cmp	r0, #0
3401397e:	d1c8      	bne.n	34013912 <ISP_Algo_BadPixel_Process+0x12>
    Step = -1;
34013980:	23ff      	movs	r3, #255	@ 0xff
    BadPixelCount = 0;
34013982:	6030      	str	r0, [r6, #0]
    Step = -1;
34013984:	702b      	strb	r3, [r5, #0]
    BadPixelCount = 0;
34013986:	e7c4      	b.n	34013912 <ISP_Algo_BadPixel_Process+0x12>
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
34013988:	d2f1      	bcs.n	3401396e <ISP_Algo_BadPixel_Process+0x6e>
3401398a:	f89d 3001 	ldrb.w	r3, [sp, #1]
3401398e:	2b05      	cmp	r3, #5
34013990:	d8ed      	bhi.n	3401396e <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength++;
34013992:	3301      	adds	r3, #1
34013994:	e7e9      	b.n	3401396a <ISP_Algo_BadPixel_Process+0x6a>
34013996:	bf00      	nop
34013998:	34044184 	.word	0x34044184
3401399c:	34044180 	.word	0x34044180
340139a0:	3404417c 	.word	0x3404417c

340139a4 <ISP_Algo_AEC_Init>:
{
340139a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340139a6:	460d      	mov	r5, r1
340139a8:	4604      	mov	r4, r0
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340139aa:	f001 f91b 	bl	34014be4 <ISP_SVC_IQParam_Get>
340139ae:	4606      	mov	r6, r0
  pIspAEprocess = evision_api_st_ae_new(log_cb);
340139b0:	480f      	ldr	r0, [pc, #60]	@ (340139f0 <ISP_Algo_AEC_Init+0x4c>)
340139b2:	f7ed fc69 	bl	34001288 <evision_api_st_ae_new>
340139b6:	4f0f      	ldr	r7, [pc, #60]	@ (340139f4 <ISP_Algo_AEC_Init+0x50>)
340139b8:	6038      	str	r0, [r7, #0]
  if (pIspAEprocess == NULL)
340139ba:	b130      	cbz	r0, 340139ca <ISP_Algo_AEC_Init+0x26>
  e_ret = evision_api_st_ae_init(pIspAEprocess);
340139bc:	f7ed fcb8 	bl	34001330 <evision_api_st_ae_init>
  if (e_ret != EVISION_RET_SUCCESS)
340139c0:	2801      	cmp	r0, #1
340139c2:	d004      	beq.n	340139ce <ISP_Algo_AEC_Init+0x2a>
    evision_api_st_ae_delete(pIspAEprocess);
340139c4:	6838      	ldr	r0, [r7, #0]
340139c6:	f7ed fc79 	bl	340012bc <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
340139ca:	20be      	movs	r0, #190	@ 0xbe
}
340139cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  algo->state = ISP_ALGO_STATE_INIT;
340139ce:	2000      	movs	r0, #0
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
340139d0:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
340139d2:	683b      	ldr	r3, [r7, #0]
340139d4:	611a      	str	r2, [r3, #16]
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
340139d6:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
340139da:	641a      	str	r2, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
340139dc:	f8d4 2084 	ldr.w	r2, [r4, #132]	@ 0x84
340139e0:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
340139e2:	6fa2      	ldr	r2, [r4, #120]	@ 0x78
340139e4:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
340139e6:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
340139e8:	64da      	str	r2, [r3, #76]	@ 0x4c
  algo->state = ISP_ALGO_STATE_INIT;
340139ea:	7068      	strb	r0, [r5, #1]
  return ISP_OK;
340139ec:	e7ee      	b.n	340139cc <ISP_Algo_AEC_Init+0x28>
340139ee:	bf00      	nop
340139f0:	34013a0d 	.word	0x34013a0d
340139f4:	34044190 	.word	0x34044190

340139f8 <ISP_Algo_AEC_DeInit>:
{
340139f8:	b508      	push	{r3, lr}
  if (pIspAEprocess != NULL)
340139fa:	4b03      	ldr	r3, [pc, #12]	@ (34013a08 <ISP_Algo_AEC_DeInit+0x10>)
340139fc:	6818      	ldr	r0, [r3, #0]
340139fe:	b108      	cbz	r0, 34013a04 <ISP_Algo_AEC_DeInit+0xc>
    evision_api_st_ae_delete(pIspAEprocess);
34013a00:	f7ed fc5c 	bl	340012bc <evision_api_st_ae_delete>
}
34013a04:	2000      	movs	r0, #0
34013a06:	bd08      	pop	{r3, pc}
34013a08:	34044190 	.word	0x34044190

34013a0c <log_cb>:
{
34013a0c:	b508      	push	{r3, lr}
  printf(msg);
34013a0e:	f004 fee1 	bl	340187d4 <iprintf>
}
34013a12:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("\r\n");
34013a16:	4801      	ldr	r0, [pc, #4]	@ (34013a1c <log_cb+0x10>)
34013a18:	f004 bf44 	b.w	340188a4 <puts>
34013a1c:	3401cf3a 	.word	0x3401cf3a

34013a20 <ISP_Algo_AEC_Process>:
{
34013a20:	b5f0      	push	{r4, r5, r6, r7, lr}
34013a22:	b087      	sub	sp, #28
34013a24:	4605      	mov	r5, r0
34013a26:	460c      	mov	r4, r1
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013a28:	f001 f8dc 	bl	34014be4 <ISP_SVC_IQParam_Get>
34013a2c:	4603      	mov	r3, r0
  if (IQParamConfig->AECAlgo.enable == false)
34013a2e:	f890 0068 	ldrb.w	r0, [r0, #104]	@ 0x68
34013a32:	b128      	cbz	r0, 34013a40 <ISP_Algo_AEC_Process+0x20>
  switch(algo->state)
34013a34:	7862      	ldrb	r2, [r4, #1]
34013a36:	2a01      	cmp	r2, #1
34013a38:	d904      	bls.n	34013a44 <ISP_Algo_AEC_Process+0x24>
34013a3a:	2a03      	cmp	r2, #3
34013a3c:	d012      	beq.n	34013a64 <ISP_Algo_AEC_Process+0x44>
    return ISP_OK;
34013a3e:	2000      	movs	r0, #0
}
34013a40:	b007      	add	sp, #28
34013a42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN, ISP_STAT_TYPE_AVG, ALGO_SENSOR_LATENCY);
34013a44:	2301      	movs	r3, #1
34013a46:	2104      	movs	r1, #4
34013a48:	2602      	movs	r6, #2
34013a4a:	e9cd 3101 	strd	r3, r1, [sp, #4]
34013a4e:	4622      	mov	r2, r4
34013a50:	4628      	mov	r0, r5
34013a52:	4b25      	ldr	r3, [pc, #148]	@ (34013ae8 <ISP_Algo_AEC_Process+0xc8>)
34013a54:	4925      	ldr	r1, [pc, #148]	@ (34013aec <ISP_Algo_AEC_Process+0xcc>)
34013a56:	9600      	str	r6, [sp, #0]
34013a58:	f001 fb08 	bl	3401506c <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
34013a5c:	2800      	cmp	r0, #0
34013a5e:	d1ef      	bne.n	34013a40 <ISP_Algo_AEC_Process+0x20>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013a60:	7066      	strb	r6, [r4, #1]
    break;
34013a62:	e7ed      	b.n	34013a40 <ISP_Algo_AEC_Process+0x20>
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013a64:	4e22      	ldr	r6, [pc, #136]	@ (34013af0 <ISP_Algo_AEC_Process+0xd0>)
34013a66:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34013a68:	6832      	ldr	r2, [r6, #0]
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013a6a:	4628      	mov	r0, r5
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013a6c:	6113      	str	r3, [r2, #16]
    avgL = stats.down.averageL;
34013a6e:	4b1e      	ldr	r3, [pc, #120]	@ (34013ae8 <ISP_Algo_AEC_Process+0xc8>)
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013a70:	a904      	add	r1, sp, #16
    avgL = stats.down.averageL;
34013a72:	f893 7037 	ldrb.w	r7, [r3, #55]	@ 0x37
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013a76:	f001 f832 	bl	34014ade <ISP_SVC_Sensor_GetGain>
    if (ret != ISP_OK)
34013a7a:	2800      	cmp	r0, #0
34013a7c:	d1e0      	bne.n	34013a40 <ISP_Algo_AEC_Process+0x20>
    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
34013a7e:	4628      	mov	r0, r5
34013a80:	a905      	add	r1, sp, #20
34013a82:	f001 f849 	bl	34014b18 <ISP_SVC_Sensor_GetExposure>
    if (ret != ISP_OK)
34013a86:	2800      	cmp	r0, #0
34013a88:	d1da      	bne.n	34013a40 <ISP_Algo_AEC_Process+0x20>
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, avgL);
34013a8a:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
34013a8e:	463b      	mov	r3, r7
34013a90:	6830      	ldr	r0, [r6, #0]
34013a92:	f7ed fc58 	bl	34001346 <evision_api_st_ae_process>
    if (e_ret == EVISION_RET_SUCCESS)
34013a96:	2801      	cmp	r0, #1
34013a98:	d00c      	beq.n	34013ab4 <ISP_Algo_AEC_Process+0x94>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats,
34013a9a:	2301      	movs	r3, #1
34013a9c:	2204      	movs	r2, #4
34013a9e:	2602      	movs	r6, #2
34013aa0:	e9cd 3201 	strd	r3, r2, [sp, #4]
34013aa4:	4628      	mov	r0, r5
34013aa6:	4622      	mov	r2, r4
34013aa8:	4b0f      	ldr	r3, [pc, #60]	@ (34013ae8 <ISP_Algo_AEC_Process+0xc8>)
34013aaa:	4910      	ldr	r1, [pc, #64]	@ (34013aec <ISP_Algo_AEC_Process+0xcc>)
34013aac:	9600      	str	r6, [sp, #0]
34013aae:	f001 fadd 	bl	3401506c <ISP_SVC_Stats_GetNext>
34013ab2:	e7d5      	b.n	34013a60 <ISP_Algo_AEC_Process+0x40>
      if (gainConfig.gain != pIspAEprocess->new_gain)
34013ab4:	6833      	ldr	r3, [r6, #0]
34013ab6:	9a04      	ldr	r2, [sp, #16]
34013ab8:	689b      	ldr	r3, [r3, #8]
34013aba:	429a      	cmp	r2, r3
34013abc:	d10c      	bne.n	34013ad8 <ISP_Algo_AEC_Process+0xb8>
      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
34013abe:	6833      	ldr	r3, [r6, #0]
34013ac0:	9a05      	ldr	r2, [sp, #20]
34013ac2:	685b      	ldr	r3, [r3, #4]
34013ac4:	429a      	cmp	r2, r3
34013ac6:	d0e8      	beq.n	34013a9a <ISP_Algo_AEC_Process+0x7a>
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34013ac8:	4628      	mov	r0, r5
34013aca:	a905      	add	r1, sp, #20
        exposureConfig.exposure = pIspAEprocess->new_exposure;
34013acc:	9305      	str	r3, [sp, #20]
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34013ace:	f001 f814 	bl	34014afa <ISP_SVC_Sensor_SetExposure>
        if (ret != ISP_OK)
34013ad2:	2800      	cmp	r0, #0
34013ad4:	d0e1      	beq.n	34013a9a <ISP_Algo_AEC_Process+0x7a>
34013ad6:	e7b3      	b.n	34013a40 <ISP_Algo_AEC_Process+0x20>
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34013ad8:	4628      	mov	r0, r5
34013ada:	a904      	add	r1, sp, #16
        gainConfig.gain = pIspAEprocess->new_gain;
34013adc:	9304      	str	r3, [sp, #16]
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34013ade:	f000 ffef 	bl	34014ac0 <ISP_SVC_Sensor_SetGain>
        if (ret != ISP_OK)
34013ae2:	2800      	cmp	r0, #0
34013ae4:	d0eb      	beq.n	34013abe <ISP_Algo_AEC_Process+0x9e>
34013ae6:	e7ab      	b.n	34013a40 <ISP_Algo_AEC_Process+0x20>
34013ae8:	34044104 	.word	0x34044104
34013aec:	340138eb 	.word	0x340138eb
34013af0:	34044190 	.word	0x34044190

34013af4 <ISP_Algo_AWB_Init>:
{
34013af4:	b510      	push	{r4, lr}
  pIspAWBestimator = evision_api_awb_new(log_cb);
34013af6:	4806      	ldr	r0, [pc, #24]	@ (34013b10 <ISP_Algo_AWB_Init+0x1c>)
{
34013af8:	460c      	mov	r4, r1
  pIspAWBestimator = evision_api_awb_new(log_cb);
34013afa:	f7ed f8b8 	bl	34000c6e <evision_api_awb_new>
34013afe:	4b05      	ldr	r3, [pc, #20]	@ (34013b14 <ISP_Algo_AWB_Init+0x20>)
34013b00:	6018      	str	r0, [r3, #0]
  if (pIspAWBestimator == NULL)
34013b02:	b110      	cbz	r0, 34013b0a <ISP_Algo_AWB_Init+0x16>
  algo->state = ISP_ALGO_STATE_INIT;
34013b04:	2000      	movs	r0, #0
34013b06:	7060      	strb	r0, [r4, #1]
}
34013b08:	bd10      	pop	{r4, pc}
    return ISP_ERR_ALGO;
34013b0a:	20be      	movs	r0, #190	@ 0xbe
34013b0c:	e7fc      	b.n	34013b08 <ISP_Algo_AWB_Init+0x14>
34013b0e:	bf00      	nop
34013b10:	34013a0d 	.word	0x34013a0d
34013b14:	3404418c 	.word	0x3404418c

34013b18 <ISP_Algo_AWB_DeInit>:
{
34013b18:	b508      	push	{r3, lr}
  if (pIspAWBestimator != NULL)
34013b1a:	4b03      	ldr	r3, [pc, #12]	@ (34013b28 <ISP_Algo_AWB_DeInit+0x10>)
34013b1c:	6818      	ldr	r0, [r3, #0]
34013b1e:	b108      	cbz	r0, 34013b24 <ISP_Algo_AWB_DeInit+0xc>
    evision_api_awb_delete(pIspAWBestimator);
34013b20:	f7ed f8c2 	bl	34000ca8 <evision_api_awb_delete>
}
34013b24:	2000      	movs	r0, #0
34013b26:	bd08      	pop	{r3, pc}
34013b28:	3404418c 	.word	0x3404418c
34013b2c:	00000000 	.word	0x00000000

34013b30 <ISP_Algo_ApplyGammaInverse>:
{
34013b30:	b508      	push	{r3, lr}
34013b32:	ed2d 8b02 	vpush	{d8}
34013b36:	ee08 1a10 	vmov	s16, r1
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
34013b3a:	2101      	movs	r1, #1
34013b3c:	f001 f814 	bl	34014b68 <ISP_SVC_Misc_IsGammaEnabled>
34013b40:	b190      	cbz	r0, 34013b68 <ISP_Algo_ApplyGammaInverse+0x38>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
34013b42:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 34013b80 <ISP_Algo_ApplyGammaInverse+0x50>
34013b46:	eeb8 8a48 	vcvt.f32.u32	s16, s16
34013b4a:	ee88 0a27 	vdiv.f32	s0, s16, s15
34013b4e:	ed9f 1b08 	vldr	d1, [pc, #32]	@ 34013b70 <ISP_Algo_ApplyGammaInverse+0x40>
34013b52:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34013b56:	f007 f9c7 	bl	3401aee8 <pow>
34013b5a:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 34013b78 <ISP_Algo_ApplyGammaInverse+0x48>
34013b5e:	ee20 0b07 	vmul.f64	d0, d0, d7
}
34013b62:	ecbd 8b02 	vpop	{d8}
34013b66:	bd08      	pop	{r3, pc}
    out = (double) comp;
34013b68:	eeb8 0b48 	vcvt.f64.u32	d0, s16
  return out;
34013b6c:	e7f9      	b.n	34013b62 <ISP_Algo_ApplyGammaInverse+0x32>
34013b6e:	bf00      	nop
34013b70:	d1745d17 	.word	0xd1745d17
34013b74:	3fdd1745 	.word	0x3fdd1745
34013b78:	00000000 	.word	0x00000000
34013b7c:	406fe000 	.word	0x406fe000
34013b80:	437f0000 	.word	0x437f0000
34013b84:	00000000 	.word	0x00000000

34013b88 <ISP_Algo_ApplyCConv>:
{
34013b88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34013b8c:	b08b      	sub	sp, #44	@ 0x2c
34013b8e:	460e      	mov	r6, r1
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34013b90:	4669      	mov	r1, sp
{
34013b92:	4615      	mov	r5, r2
34013b94:	461c      	mov	r4, r3
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34013b96:	f000 ff3d 	bl	34014a14 <ISP_SVC_ISP_GetColorConv>
34013b9a:	4602      	mov	r2, r0
34013b9c:	2800      	cmp	r0, #0
34013b9e:	f040 8096 	bne.w	34013cce <ISP_Algo_ApplyCConv+0x146>
34013ba2:	f89d 3000 	ldrb.w	r3, [sp]
34013ba6:	2b01      	cmp	r3, #1
34013ba8:	f040 8091 	bne.w	34013cce <ISP_Algo_ApplyCConv+0x146>
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34013bac:	9b01      	ldr	r3, [sp, #4]
34013bae:	17d9      	asrs	r1, r3, #31
34013bb0:	fba3 3706 	umull	r3, r7, r3, r6
34013bb4:	fb06 7701 	mla	r7, r6, r1, r7
34013bb8:	9902      	ldr	r1, [sp, #8]
34013bba:	ea4f 7ce1 	mov.w	ip, r1, asr #31
34013bbe:	fba1 1005 	umull	r1, r0, r1, r5
34013bc2:	fb05 000c 	mla	r0, r5, ip, r0
34013bc6:	185b      	adds	r3, r3, r1
34013bc8:	eb47 0700 	adc.w	r7, r7, r0
34013bcc:	9803      	ldr	r0, [sp, #12]
34013bce:	ea4f 7ce0 	mov.w	ip, r0, asr #31
34013bd2:	fba0 0104 	umull	r0, r1, r0, r4
34013bd6:	fb04 110c 	mla	r1, r4, ip, r1
34013bda:	1818      	adds	r0, r3, r0
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34013bdc:	9b04      	ldr	r3, [sp, #16]
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34013bde:	eb41 0107 	adc.w	r1, r1, r7
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34013be2:	17df      	asrs	r7, r3, #31
34013be4:	fba3 8306 	umull	r8, r3, r3, r6
34013be8:	fb06 3307 	mla	r3, r6, r7, r3
34013bec:	9f05      	ldr	r7, [sp, #20]
34013bee:	fba7 ce05 	umull	ip, lr, r7, r5
34013bf2:	ea4f 79e7 	mov.w	r9, r7, asr #31
34013bf6:	fb05 ee09 	mla	lr, r5, r9, lr
34013bfa:	eb18 070c 	adds.w	r7, r8, ip
34013bfe:	f8dd c018 	ldr.w	ip, [sp, #24]
34013c02:	eb43 030e 	adc.w	r3, r3, lr
34013c06:	ea4f 7eec 	mov.w	lr, ip, asr #31
34013c0a:	fbac c804 	umull	ip, r8, ip, r4
34013c0e:	fb04 880e 	mla	r8, r4, lr, r8
34013c12:	eb17 070c 	adds.w	r7, r7, ip
34013c16:	eb48 0803 	adc.w	r8, r8, r3
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34013c1a:	9b07      	ldr	r3, [sp, #28]
34013c1c:	ea4f 7ce3 	mov.w	ip, r3, asr #31
34013c20:	fba3 e306 	umull	lr, r3, r3, r6
34013c24:	fb06 3c0c 	mla	ip, r6, ip, r3
34013c28:	9b08      	ldr	r3, [sp, #32]
34013c2a:	ea4f 79e3 	mov.w	r9, r3, asr #31
34013c2e:	fba3 3605 	umull	r3, r6, r3, r5
34013c32:	fb05 6509 	mla	r5, r5, r9, r6
34013c36:	eb1e 0303 	adds.w	r3, lr, r3
34013c3a:	eb4c 0c05 	adc.w	ip, ip, r5
34013c3e:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34013c40:	ea4f 7ee5 	mov.w	lr, r5, asr #31
34013c44:	fba5 5604 	umull	r5, r6, r5, r4
34013c48:	fb04 660e 	mla	r6, r4, lr, r6
34013c4c:	195c      	adds	r4, r3, r5
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013c4e:	f04f 33ff 	mov.w	r3, #4294967295
34013c52:	4d29      	ldr	r5, [pc, #164]	@ (34013cf8 <ISP_Algo_ApplyCConv+0x170>)
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34013c54:	eb46 060c 	adc.w	r6, r6, ip
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013c58:	42a8      	cmp	r0, r5
34013c5a:	eb71 0303 	sbcs.w	r3, r1, r3
34013c5e:	db3f      	blt.n	34013ce0 <ISP_Algo_ApplyCConv+0x158>
    ccR /= ISP_CCM_PRECISION_FACTOR;
34013c60:	a323      	add	r3, pc, #140	@ (adr r3, 34013cf0 <ISP_Algo_ApplyCConv+0x168>)
34013c62:	e9d3 2300 	ldrd	r2, r3, [r3]
34013c66:	f7ed fc69 	bl	3400153c <__aeabi_ldivmod>
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013c6a:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013c6e:	f171 0100 	sbcs.w	r1, r1, #0
34013c72:	4681      	mov	r9, r0
34013c74:	db01      	blt.n	34013c7a <ISP_Algo_ApplyCConv+0xf2>
34013c76:	f04f 09ff 	mov.w	r9, #255	@ 0xff
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013c7a:	f04f 33ff 	mov.w	r3, #4294967295
34013c7e:	42af      	cmp	r7, r5
34013c80:	eb78 0303 	sbcs.w	r3, r8, r3
34013c84:	db2e      	blt.n	34013ce4 <ISP_Algo_ApplyCConv+0x15c>
    ccG /= ISP_CCM_PRECISION_FACTOR;
34013c86:	a31a      	add	r3, pc, #104	@ (adr r3, 34013cf0 <ISP_Algo_ApplyCConv+0x168>)
34013c88:	e9d3 2300 	ldrd	r2, r3, [r3]
34013c8c:	4638      	mov	r0, r7
34013c8e:	4641      	mov	r1, r8
34013c90:	f7ed fc54 	bl	3400153c <__aeabi_ldivmod>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013c94:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013c98:	f171 0100 	sbcs.w	r1, r1, #0
34013c9c:	4607      	mov	r7, r0
34013c9e:	db00      	blt.n	34013ca2 <ISP_Algo_ApplyCConv+0x11a>
34013ca0:	27ff      	movs	r7, #255	@ 0xff
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013ca2:	f04f 33ff 	mov.w	r3, #4294967295
34013ca6:	42ac      	cmp	r4, r5
34013ca8:	eb76 0303 	sbcs.w	r3, r6, r3
34013cac:	db1c      	blt.n	34013ce8 <ISP_Algo_ApplyCConv+0x160>
    ccB /= ISP_CCM_PRECISION_FACTOR;
34013cae:	a310      	add	r3, pc, #64	@ (adr r3, 34013cf0 <ISP_Algo_ApplyCConv+0x168>)
34013cb0:	e9d3 2300 	ldrd	r2, r3, [r3]
34013cb4:	4620      	mov	r0, r4
34013cb6:	4631      	mov	r1, r6
34013cb8:	f7ed fc40 	bl	3400153c <__aeabi_ldivmod>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013cbc:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013cc0:	f171 0100 	sbcs.w	r1, r1, #0
34013cc4:	4604      	mov	r4, r0
34013cc6:	db00      	blt.n	34013cca <ISP_Algo_ApplyCConv+0x142>
34013cc8:	24ff      	movs	r4, #255	@ 0xff
    *outR = (uint32_t) ccR;
34013cca:	464e      	mov	r6, r9
    *outG = (uint32_t) ccG;
34013ccc:	463d      	mov	r5, r7
    *outR = (uint32_t) ccR;
34013cce:	9b12      	ldr	r3, [sp, #72]	@ 0x48
34013cd0:	601e      	str	r6, [r3, #0]
    *outG = (uint32_t) ccG;
34013cd2:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
34013cd4:	601d      	str	r5, [r3, #0]
    *outB = (uint32_t) ccB;
34013cd6:	9b14      	ldr	r3, [sp, #80]	@ 0x50
34013cd8:	601c      	str	r4, [r3, #0]
}
34013cda:	b00b      	add	sp, #44	@ 0x2c
34013cdc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013ce0:	4691      	mov	r9, r2
34013ce2:	e7ca      	b.n	34013c7a <ISP_Algo_ApplyCConv+0xf2>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013ce4:	2700      	movs	r7, #0
34013ce6:	e7dc      	b.n	34013ca2 <ISP_Algo_ApplyCConv+0x11a>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013ce8:	2400      	movs	r4, #0
34013cea:	e7ee      	b.n	34013cca <ISP_Algo_ApplyCConv+0x142>
34013cec:	f3af 8000 	nop.w
34013cf0:	05f5e100 	.word	0x05f5e100
34013cf4:	00000000 	.word	0x00000000
34013cf8:	fa0a1f01 	.word	0xfa0a1f01
34013cfc:	00000000 	.word	0x00000000

34013d00 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
34013d00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34013d04:	ed2d 8b02 	vpush	{d8}
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34013d08:	2400      	movs	r4, #0
{
34013d0a:	b09e      	sub	sp, #120	@ 0x78
34013d0c:	4606      	mov	r6, r0
34013d0e:	460f      	mov	r7, r1
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34013d10:	e9cd 4407 	strd	r4, r4, [sp, #28]
34013d14:	9409      	str	r4, [sp, #36]	@ 0x24
  double meas[3];

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013d16:	f000 ff65 	bl	34014be4 <ISP_SVC_IQParam_Get>

  if (IQParamConfig->AWBAlgo.enable == false)
34013d1a:	f890 2070 	ldrb.w	r2, [r0, #112]	@ 0x70
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013d1e:	4605      	mov	r5, r0
  if (IQParamConfig->AWBAlgo.enable == false)
34013d20:	4bc3      	ldr	r3, [pc, #780]	@ (34014030 <ISP_Algo_AWB_Process+0x330>)
34013d22:	b932      	cbnz	r2, 34013d32 <ISP_Algo_AWB_Process+0x32>
  {
    enableCurrent = false;
34013d24:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
34013d26:	2000      	movs	r0, #0
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
    break;
  }

  return ret;
}
34013d28:	b01e      	add	sp, #120	@ 0x78
34013d2a:	ecbd 8b02 	vpop	{d8}
34013d2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
34013d32:	7819      	ldrb	r1, [r3, #0]
34013d34:	b111      	cbz	r1, 34013d3c <ISP_Algo_AWB_Process+0x3c>
34013d36:	2aff      	cmp	r2, #255	@ 0xff
34013d38:	f040 80b1 	bne.w	34013e9e <ISP_Algo_AWB_Process+0x19e>
    algo->state = ISP_ALGO_STATE_INIT;
34013d3c:	2200      	movs	r2, #0
34013d3e:	707a      	strb	r2, [r7, #1]
    IQParamConfig->AWBAlgo.enable = true;
34013d40:	2201      	movs	r2, #1
    reconfigureRequest = true;
34013d42:	49bc      	ldr	r1, [pc, #752]	@ (34014034 <ISP_Algo_AWB_Process+0x334>)
    IQParamConfig->AWBAlgo.enable = true;
34013d44:	f885 2070 	strb.w	r2, [r5, #112]	@ 0x70
    reconfigureRequest = true;
34013d48:	700a      	strb	r2, [r1, #0]
    enableCurrent = true;
34013d4a:	701a      	strb	r2, [r3, #0]
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013d4c:	2400      	movs	r4, #0
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013d4e:	ed9f 8aba 	vldr	s16, [pc, #744]	@ 34014038 <ISP_Algo_AWB_Process+0x338>
34013d52:	f8df 92f0 	ldr.w	r9, [pc, #752]	@ 34014044 <ISP_Algo_AWB_Process+0x344>
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013d56:	f8df a2e8 	ldr.w	sl, [pc, #744]	@ 34014040 <ISP_Algo_AWB_Process+0x340>
34013d5a:	f505 7888 	add.w	r8, r5, #272	@ 0x110
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
34013d5e:	f8d8 0004 	ldr.w	r0, [r8, #4]
      if (colorTemp == 0)
34013d62:	2800      	cmp	r0, #0
34013d64:	f000 80aa 	beq.w	34013ebc <ISP_Algo_AWB_Process+0x1bc>
      if (profNb > 0)
34013d68:	b15c      	cbz	r4, 34013d82 <ISP_Algo_AWB_Process+0x82>
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
34013d6a:	f8d8 3000 	ldr.w	r3, [r8]
34013d6e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
34013d72:	4403      	add	r3, r0
34013d74:	089b      	lsrs	r3, r3, #2
34013d76:	ee07 3a90 	vmov	s15, r3
34013d7a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013d7e:	ed49 7a01 	vstr	s15, [r9, #-4]
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013d82:	edd8 7a06 	vldr	s15, [r8, #24]
34013d86:	eef8 7a67 	vcvt.f32.u32	s15, s15
34013d8a:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013d8e:	edd8 7a0b 	vldr	s15, [r8, #44]	@ 0x2c
34013d92:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013d96:	ed8d 7a0e 	vstr	s14, [sp, #56]	@ 0x38
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013d9a:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34013d9e:	edd8 7a10 	vldr	s15, [r8, #64]	@ 0x40
34013da2:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013da6:	ed8d 7a0f 	vstr	s14, [sp, #60]	@ 0x3c
      cfaGains[2] = cfaGains[1];
34013daa:	ed8d 7a10 	vstr	s14, [sp, #64]	@ 0x40
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34013dae:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013db2:	2324      	movs	r3, #36	@ 0x24
34013db4:	a914      	add	r1, sp, #80	@ 0x50
34013db6:	ed8d 7a11 	vstr	s14, [sp, #68]	@ 0x44
34013dba:	f04f 0c03 	mov.w	ip, #3
34013dbe:	460a      	mov	r2, r1
34013dc0:	fb03 5304 	mla	r3, r3, r4, r5
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34013dc4:	edd3 7a59 	vldr	s15, [r3, #356]	@ 0x164
34013dc8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013dcc:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013dd0:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
34013dd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013dd8:	ed81 7a00 	vstr	s14, [r1]
34013ddc:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013de0:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
34013de4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013de8:	ed81 7a01 	vstr	s14, [r1, #4]
34013dec:	ee87 7a88 	vdiv.f32	s14, s15, s16
      for (i = 0; i < 3; i++)
34013df0:	f1bc 0c01 	subs.w	ip, ip, #1
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34013df4:	ed81 7a02 	vstr	s14, [r1, #8]
      for (i = 0; i < 3; i++)
34013df8:	f103 030c 	add.w	r3, r3, #12
34013dfc:	f101 010c 	add.w	r1, r1, #12
34013e00:	d1e0      	bne.n	34013dc4 <ISP_Algo_AWB_Process+0xc4>
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013e02:	ee07 0a90 	vmov	s15, r0
34013e06:	2044      	movs	r0, #68	@ 0x44
34013e08:	eeb8 0a67 	vcvt.f32.u32	s0, s15
34013e0c:	fb00 a004 	mla	r0, r0, r4, sl
34013e10:	ab07      	add	r3, sp, #28
34013e12:	a90e      	add	r1, sp, #56	@ 0x38
      profNb++;
34013e14:	3401      	adds	r4, #1
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013e16:	f7ec ff4d 	bl	34000cb4 <evision_api_awb_set_profile>
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013e1a:	2c05      	cmp	r4, #5
34013e1c:	f108 0804 	add.w	r8, r8, #4
34013e20:	f109 0904 	add.w	r9, r9, #4
34013e24:	d19b      	bne.n	34013d5e <ISP_Algo_AWB_Process+0x5e>
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], profNb,
34013e26:	eb05 0384 	add.w	r3, r5, r4, lsl #2
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
34013e2a:	ed93 1a44 	vldr	s2, [r3, #272]	@ 0x110
34013e2e:	ed95 0a45 	vldr	s0, [r5, #276]	@ 0x114
34013e32:	4d82      	ldr	r5, [pc, #520]	@ (3401403c <ISP_Algo_AWB_Process+0x33c>)
34013e34:	eeb8 1b41 	vcvt.f64.u32	d1, s2
34013e38:	eeb8 0b40 	vcvt.f64.u32	d0, s0
34013e3c:	4b80      	ldr	r3, [pc, #512]	@ (34014040 <ISP_Algo_AWB_Process+0x340>)
34013e3e:	4a81      	ldr	r2, [pc, #516]	@ (34014044 <ISP_Algo_AWB_Process+0x344>)
34013e40:	6828      	ldr	r0, [r5, #0]
34013e42:	b2a1      	uxth	r1, r4
34013e44:	f7ec ff56 	bl	34000cf4 <evision_api_awb_init_profiles>
    if (e_ret != EVISION_RET_SUCCESS)
34013e48:	2801      	cmp	r0, #1
34013e4a:	f040 80a6 	bne.w	34013f9a <ISP_Algo_AWB_Process+0x29a>
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013e4e:	f20f 19d0 	addw	r9, pc, #464	@ 0x1d0
34013e52:	e9d9 8900 	ldrd	r8, r9, [r9]
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013e56:	eeb0 7b00 	vmov.f64	d7, #0	@ 0x40000000  2.0
34013e5a:	ed9f 6b73 	vldr	d6, [pc, #460]	@ 34014028 <ISP_Algo_AWB_Process+0x328>
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34013e5e:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013e62:	2c03      	cmp	r4, #3
34013e64:	bf98      	it	ls
34013e66:	eeb0 7b46 	vmovls.f64	d7, d6
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013e6a:	682b      	ldr	r3, [r5, #0]
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34013e6c:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34013e70:	4a75      	ldr	r2, [pc, #468]	@ (34014048 <ISP_Algo_AWB_Process+0x348>)
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013e72:	ed83 7ba8 	vstr	d7, [r3, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013e76:	e9c3 89a6 	strd	r8, r9, [r3, #664]	@ 0x298
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34013e7a:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013e7e:	2305      	movs	r3, #5
34013e80:	e9cd 0301 	strd	r0, r3, [sp, #4]
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013e84:	2402      	movs	r4, #2
34013e86:	463a      	mov	r2, r7
34013e88:	4630      	mov	r0, r6
34013e8a:	4b70      	ldr	r3, [pc, #448]	@ (3401404c <ISP_Algo_AWB_Process+0x34c>)
34013e8c:	4970      	ldr	r1, [pc, #448]	@ (34014050 <ISP_Algo_AWB_Process+0x350>)
34013e8e:	9400      	str	r4, [sp, #0]
34013e90:	f001 f8ec 	bl	3401506c <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
34013e94:	2800      	cmp	r0, #0
34013e96:	f47f af47 	bne.w	34013d28 <ISP_Algo_AWB_Process+0x28>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013e9a:	707c      	strb	r4, [r7, #1]
    break;
34013e9c:	e744      	b.n	34013d28 <ISP_Algo_AWB_Process+0x28>
  switch(algo->state)
34013e9e:	787b      	ldrb	r3, [r7, #1]
34013ea0:	2b03      	cmp	r3, #3
34013ea2:	d010      	beq.n	34013ec6 <ISP_Algo_AWB_Process+0x1c6>
34013ea4:	f63f af3f 	bhi.w	34013d26 <ISP_Algo_AWB_Process+0x26>
34013ea8:	2b00      	cmp	r3, #0
34013eaa:	f43f af4f 	beq.w	34013d4c <ISP_Algo_AWB_Process+0x4c>
34013eae:	2b01      	cmp	r3, #1
34013eb0:	f47f af39 	bne.w	34013d26 <ISP_Algo_AWB_Process+0x26>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013eb4:	2205      	movs	r2, #5
34013eb6:	e9cd 3201 	strd	r3, r2, [sp, #4]
34013eba:	e7e3      	b.n	34013e84 <ISP_Algo_AWB_Process+0x184>
      return ISP_ERR_WB_COLORTEMP;
34013ebc:	2096      	movs	r0, #150	@ 0x96
    if (profNb == 0)
34013ebe:	2c00      	cmp	r4, #0
34013ec0:	f43f af32 	beq.w	34013d28 <ISP_Algo_AWB_Process+0x28>
34013ec4:	e7af      	b.n	34013e26 <ISP_Algo_AWB_Process+0x126>
    ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
34013ec6:	ab06      	add	r3, sp, #24
34013ec8:	9302      	str	r3, [sp, #8]
34013eca:	ab05      	add	r3, sp, #20
34013ecc:	9301      	str	r3, [sp, #4]
34013ece:	495f      	ldr	r1, [pc, #380]	@ (3401404c <ISP_Algo_AWB_Process+0x34c>)
34013ed0:	ab04      	add	r3, sp, #16
34013ed2:	9300      	str	r3, [sp, #0]
34013ed4:	f891 3036 	ldrb.w	r3, [r1, #54]	@ 0x36
34013ed8:	f891 2035 	ldrb.w	r2, [r1, #53]	@ 0x35
34013edc:	4630      	mov	r0, r6
34013ede:	f891 1034 	ldrb.w	r1, [r1, #52]	@ 0x34
34013ee2:	f7ff fe51 	bl	34013b88 <ISP_Algo_ApplyCConv>
    meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34013ee6:	4630      	mov	r0, r6
34013ee8:	9904      	ldr	r1, [sp, #16]
34013eea:	f7ff fe21 	bl	34013b30 <ISP_Algo_ApplyGammaInverse>
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34013eee:	4630      	mov	r0, r6
34013ef0:	9905      	ldr	r1, [sp, #20]
    meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34013ef2:	ed8d 0b0e 	vstr	d0, [sp, #56]	@ 0x38
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34013ef6:	f7ff fe1b 	bl	34013b30 <ISP_Algo_ApplyGammaInverse>
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34013efa:	4630      	mov	r0, r6
34013efc:	9906      	ldr	r1, [sp, #24]
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34013efe:	ed8d 0b10 	vstr	d0, [sp, #64]	@ 0x40
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34013f02:	f7ff fe15 	bl	34013b30 <ISP_Algo_ApplyGammaInverse>
    e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
34013f06:	f8df 8134 	ldr.w	r8, [pc, #308]	@ 3401403c <ISP_Algo_AWB_Process+0x33c>
34013f0a:	2201      	movs	r2, #1
34013f0c:	4621      	mov	r1, r4
34013f0e:	f8d8 0000 	ldr.w	r0, [r8]
34013f12:	ab0e      	add	r3, sp, #56	@ 0x38
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34013f14:	ed8d 0b12 	vstr	d0, [sp, #72]	@ 0x48
    e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
34013f18:	f7ed f8c0 	bl	3400109c <evision_api_awb_run_average>
    if (e_ret == EVISION_RET_SUCCESS)
34013f1c:	2801      	cmp	r0, #1
34013f1e:	d13a      	bne.n	34013f96 <ISP_Algo_AWB_Process+0x296>
      if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
34013f20:	f8df 9134 	ldr.w	r9, [pc, #308]	@ 34014058 <ISP_Algo_AWB_Process+0x358>
34013f24:	f8d8 3000 	ldr.w	r3, [r8]
34013f28:	edd9 7a00 	vldr	s15, [r9]
34013f2c:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34013f30:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34013f34:	eeb4 6b47 	vcmp.f64	d6, d7
34013f38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34013f3c:	4b3d      	ldr	r3, [pc, #244]	@ (34014034 <ISP_Algo_AWB_Process+0x334>)
34013f3e:	d102      	bne.n	34013f46 <ISP_Algo_AWB_Process+0x246>
34013f40:	781a      	ldrb	r2, [r3, #0]
34013f42:	2a01      	cmp	r2, #1
34013f44:	d116      	bne.n	34013f74 <ISP_Algo_AWB_Process+0x274>
        reconfigureRequest = false;
34013f46:	f04f 0a00 	mov.w	sl, #0
34013f4a:	f883 a000 	strb.w	sl, [r3]
        for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013f4e:	2305      	movs	r3, #5
34013f50:	f505 7288 	add.w	r2, r5, #272	@ 0x110
          if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
34013f54:	ed92 7a01 	vldr	s14, [r2, #4]
34013f58:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34013f5c:	eeb4 6b47 	vcmp.f64	d6, d7
34013f60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34013f64:	f102 0204 	add.w	r2, r2, #4
34013f68:	d019      	beq.n	34013f9e <ISP_Algo_AWB_Process+0x29e>
        for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013f6a:	3b01      	subs	r3, #1
34013f6c:	f10a 0a01 	add.w	sl, sl, #1
34013f70:	d1f0      	bne.n	34013f54 <ISP_Algo_AWB_Process+0x254>
          ret  = ISP_ERR_WB_COLORTEMP;
34013f72:	2496      	movs	r4, #150	@ 0x96
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013f74:	2301      	movs	r3, #1
34013f76:	2205      	movs	r2, #5
34013f78:	2502      	movs	r5, #2
34013f7a:	e9cd 3201 	strd	r3, r2, [sp, #4]
34013f7e:	4630      	mov	r0, r6
34013f80:	463a      	mov	r2, r7
34013f82:	4b32      	ldr	r3, [pc, #200]	@ (3401404c <ISP_Algo_AWB_Process+0x34c>)
34013f84:	4932      	ldr	r1, [pc, #200]	@ (34014050 <ISP_Algo_AWB_Process+0x350>)
34013f86:	9500      	str	r5, [sp, #0]
34013f88:	f001 f870 	bl	3401506c <ISP_SVC_Stats_GetNext>
    ret = (ret != ISP_OK) ? ret : ret_stat;
34013f8c:	2c00      	cmp	r4, #0
34013f8e:	bf18      	it	ne
34013f90:	4620      	movne	r0, r4
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013f92:	707d      	strb	r5, [r7, #1]
    break;
34013f94:	e6c8      	b.n	34013d28 <ISP_Algo_AWB_Process+0x28>
      ret = ISP_ERR_ALGO;
34013f96:	24be      	movs	r4, #190	@ 0xbe
34013f98:	e7ec      	b.n	34013f74 <ISP_Algo_AWB_Process+0x274>
      return ISP_ERR_ALGO;
34013f9a:	20be      	movs	r0, #190	@ 0xbe
34013f9c:	e6c4      	b.n	34013d28 <ISP_Algo_AWB_Process+0x28>
          ColorConvConfig.enable = 1;
34013f9e:	2301      	movs	r3, #1
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34013fa0:	f04f 0e04 	mov.w	lr, #4
          ColorConvConfig.enable = 1;
34013fa4:	f88d 3050 	strb.w	r3, [sp, #80]	@ 0x50
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34013fa8:	2324      	movs	r3, #36	@ 0x24
34013faa:	f04e e001 	dls	lr, lr
34013fae:	fb03 530a 	mla	r3, r3, sl, r5
34013fb2:	aa15      	add	r2, sp, #84	@ 0x54
34013fb4:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
34013fb8:	4614      	mov	r4, r2
34013fba:	6818      	ldr	r0, [r3, #0]
34013fbc:	6859      	ldr	r1, [r3, #4]
34013fbe:	3308      	adds	r3, #8
34013fc0:	c403      	stmia	r4!, {r0, r1}
34013fc2:	4622      	mov	r2, r4
34013fc4:	f00f c009 	le	lr, 34013fb8 <ISP_Algo_AWB_Process+0x2b8>
34013fc8:	6818      	ldr	r0, [r3, #0]
          ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
34013fca:	a914      	add	r1, sp, #80	@ 0x50
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34013fcc:	6020      	str	r0, [r4, #0]
          ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
34013fce:	4630      	mov	r0, r6
34013fd0:	f000 fc98 	bl	34014904 <ISP_SVC_ISP_SetColorConv>
          if (ret == ISP_OK)
34013fd4:	4604      	mov	r4, r0
34013fd6:	2800      	cmp	r0, #0
34013fd8:	d1cc      	bne.n	34013f74 <ISP_Algo_AWB_Process+0x274>
            ISPGainConfig.enable = 1;
34013fda:	2301      	movs	r3, #1
34013fdc:	eb05 058a 	add.w	r5, r5, sl, lsl #2
34013fe0:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
            ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
34013fe4:	f8d5 3128 	ldr.w	r3, [r5, #296]	@ 0x128
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
34013fe8:	4630      	mov	r0, r6
            ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
34013fea:	930b      	str	r3, [sp, #44]	@ 0x2c
            ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
34013fec:	f8d5 313c 	ldr.w	r3, [r5, #316]	@ 0x13c
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
34013ff0:	a90a      	add	r1, sp, #40	@ 0x28
            ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
34013ff2:	930c      	str	r3, [sp, #48]	@ 0x30
            ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
34013ff4:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
34013ff8:	930d      	str	r3, [sp, #52]	@ 0x34
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
34013ffa:	f000 fbe9 	bl	340147d0 <ISP_SVC_ISP_SetGain>
            if (ret == ISP_OK)
34013ffe:	4604      	mov	r4, r0
34014000:	2800      	cmp	r0, #0
34014002:	d1b7      	bne.n	34013f74 <ISP_Algo_AWB_Process+0x274>
              currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
34014004:	f8d8 3000 	ldr.w	r3, [r8]
34014008:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3401400c:	eebc 7bc7 	vcvt.u32.f64	s14, d7
              current_awb_profId = profId;
34014010:	4b10      	ldr	r3, [pc, #64]	@ (34014054 <ISP_Algo_AWB_Process+0x354>)
              currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
34014012:	ed89 7a00 	vstr	s14, [r9]
              current_awb_profId = profId;
34014016:	f8c3 a000 	str.w	sl, [r3]
3401401a:	e7ab      	b.n	34013f74 <ISP_Algo_AWB_Process+0x274>
3401401c:	f3af 8000 	nop.w
34014020:	9999999a 	.word	0x9999999a
34014024:	3ff59999 	.word	0x3ff59999
34014028:	cccccccd 	.word	0xcccccccd
3401402c:	3ffccccc 	.word	0x3ffccccc
34014030:	34044101 	.word	0x34044101
34014034:	34044100 	.word	0x34044100
34014038:	4cbebc20 	.word	0x4cbebc20
3401403c:	3404418c 	.word	0x3404418c
34014040:	34043f9c 	.word	0x34043f9c
34014044:	340440f0 	.word	0x340440f0
34014048:	40400000 	.word	0x40400000
3401404c:	34043f24 	.word	0x34043f24
34014050:	340138f3 	.word	0x340138f3
34014054:	34044188 	.word	0x34044188
34014058:	34043f20 	.word	0x34043f20

3401405c <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
3401405c:	b538      	push	{r3, r4, r5, lr}
3401405e:	4604      	mov	r4, r0
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
34014060:	2500      	movs	r5, #0
34014062:	4b09      	ldr	r3, [pc, #36]	@ (34014088 <ISP_Algo_Init+0x2c>)
34014064:	6183      	str	r3, [r0, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
34014066:	69a3      	ldr	r3, [r4, #24]
34014068:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Init != NULL))
3401406a:	b921      	cbnz	r1, 34014076 <ISP_Algo_Init+0x1a>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401406c:	3504      	adds	r5, #4
3401406e:	2d0c      	cmp	r5, #12
34014070:	d1f9      	bne.n	34014066 <ISP_Algo_Init+0xa>
        return ret;
      }
    }
  }

  return ISP_OK;
34014072:	2000      	movs	r0, #0
}
34014074:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Init != NULL))
34014076:	684b      	ldr	r3, [r1, #4]
34014078:	2b00      	cmp	r3, #0
3401407a:	d0f7      	beq.n	3401406c <ISP_Algo_Init+0x10>
      ret = algo->Init((void*)hIsp, (void*)algo);
3401407c:	4620      	mov	r0, r4
3401407e:	4798      	blx	r3
      if (ret != ISP_OK)
34014080:	2800      	cmp	r0, #0
34014082:	d0f3      	beq.n	3401406c <ISP_Algo_Init+0x10>
34014084:	e7f6      	b.n	34014074 <ISP_Algo_Init+0x18>
34014086:	bf00      	nop
34014088:	3403ed04 	.word	0x3403ed04

3401408c <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
3401408c:	b538      	push	{r3, r4, r5, lr}
3401408e:	4604      	mov	r4, r0
34014090:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
34014092:	69a3      	ldr	r3, [r4, #24]
34014094:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->DeInit != NULL))
34014096:	b921      	cbnz	r1, 340140a2 <ISP_Algo_DeInit+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34014098:	3504      	adds	r5, #4
3401409a:	2d0c      	cmp	r5, #12
3401409c:	d1f9      	bne.n	34014092 <ISP_Algo_DeInit+0x6>
        return ret;
      }
    }
  }

  return ISP_OK;
3401409e:	2000      	movs	r0, #0
}
340140a0:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->DeInit != NULL))
340140a2:	688b      	ldr	r3, [r1, #8]
340140a4:	2b00      	cmp	r3, #0
340140a6:	d0f7      	beq.n	34014098 <ISP_Algo_DeInit+0xc>
      ret = algo->DeInit((void*)hIsp, (void*)algo);
340140a8:	4620      	mov	r0, r4
340140aa:	4798      	blx	r3
      if (ret != ISP_OK)
340140ac:	2800      	cmp	r0, #0
340140ae:	d0f3      	beq.n	34014098 <ISP_Algo_DeInit+0xc>
340140b0:	e7f6      	b.n	340140a0 <ISP_Algo_DeInit+0x14>

340140b2 <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
340140b2:	b538      	push	{r3, r4, r5, lr}
340140b4:	4604      	mov	r4, r0
340140b6:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
340140b8:	69a3      	ldr	r3, [r4, #24]
340140ba:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Process != NULL))
340140bc:	b921      	cbnz	r1, 340140c8 <ISP_Algo_Process+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
340140be:	3504      	adds	r5, #4
340140c0:	2d0c      	cmp	r5, #12
340140c2:	d1f9      	bne.n	340140b8 <ISP_Algo_Process+0x6>
      }
#endif
    }
  }

  return ISP_OK;
340140c4:	2000      	movs	r0, #0
}
340140c6:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Process != NULL))
340140c8:	68cb      	ldr	r3, [r1, #12]
340140ca:	2b00      	cmp	r3, #0
340140cc:	d0f7      	beq.n	340140be <ISP_Algo_Process+0xc>
      ret = algo->Process((void*)hIsp, (void*)algo);
340140ce:	4620      	mov	r0, r4
340140d0:	4798      	blx	r3
      if (ret != ISP_OK)
340140d2:	2800      	cmp	r0, #0
340140d4:	d0f3      	beq.n	340140be <ISP_Algo_Process+0xc>
340140d6:	e7f6      	b.n	340140c6 <ISP_Algo_Process+0x14>

340140d8 <ISP_Init>:
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           ISP_StatAreaTypeDef *pStatArea,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
340140d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
340140dc:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
340140e0:	460e      	mov	r6, r1
340140e2:	4691      	mov	r9, r2
340140e4:	461c      	mov	r4, r3
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
340140e6:	4605      	mov	r5, r0
340140e8:	2800      	cmp	r0, #0
340140ea:	d070      	beq.n	340141ce <ISP_Init+0xf6>
340140ec:	2900      	cmp	r1, #0
340140ee:	d06e      	beq.n	340141ce <ISP_Init+0xf6>
340140f0:	2b00      	cmp	r3, #0
340140f2:	d06c      	beq.n	340141ce <ISP_Init+0xf6>
  {
    return ISP_ERR_EINVAL;
  }

  memset(hIsp, 0, sizeof(*hIsp));
340140f4:	f100 0708 	add.w	r7, r0, #8
340140f8:	2280      	movs	r2, #128	@ 0x80
340140fa:	2100      	movs	r1, #0
340140fc:	4638      	mov	r0, r7
340140fe:	f004 fd3d 	bl	34018b7c <memset>
  hIsp->cameraInstance = CameraInstance;
  hIsp->MainPipe_FrameCount = 0;
  hIsp->AncillaryPipe_FrameCount = 0;
  hIsp->DumpPipe_FrameCount = 0;

  hIsp->appliHelpers = *pAppliHelpers;
34014102:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  hIsp->cameraInstance = CameraInstance;
34014104:	e9c5 6900 	strd	r6, r9, [r5]
  hIsp->appliHelpers = *pAppliHelpers;
34014108:	f105 061c 	add.w	r6, r5, #28
3401410c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3401410e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34014110:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34014112:	6823      	ldr	r3, [r4, #0]
34014114:	6033      	str	r3, [r6, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
34014116:	6aab      	ldr	r3, [r5, #40]	@ 0x28
34014118:	b93b      	cbnz	r3, 3401412a <ISP_Init+0x52>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
3401411a:	482e      	ldr	r0, [pc, #184]	@ (340141d4 <ISP_Init+0xfc>)
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
      return ISP_ERR_APP_HELPER_UNDEFINED;
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
3401411c:	f004 fbc2 	bl	340188a4 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
34014120:	24b4      	movs	r4, #180	@ 0xb4

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);

  return ISP_OK;
}
34014122:	4620      	mov	r0, r4
34014124:	b003      	add	sp, #12
34014126:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (hIsp->appliHelpers.SetSensorGain == NULL)
3401412a:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
3401412c:	b90b      	cbnz	r3, 34014132 <ISP_Init+0x5a>
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
3401412e:	482a      	ldr	r0, [pc, #168]	@ (340141d8 <ISP_Init+0x100>)
34014130:	e7f4      	b.n	3401411c <ISP_Init+0x44>
  if (hIsp->appliHelpers.GetSensorGain == NULL)
34014132:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
34014134:	b90b      	cbnz	r3, 3401413a <ISP_Init+0x62>
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
34014136:	4829      	ldr	r0, [pc, #164]	@ (340141dc <ISP_Init+0x104>)
34014138:	e7f0      	b.n	3401411c <ISP_Init+0x44>
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
3401413a:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
3401413c:	b90b      	cbnz	r3, 34014142 <ISP_Init+0x6a>
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
3401413e:	4828      	ldr	r0, [pc, #160]	@ (340141e0 <ISP_Init+0x108>)
34014140:	e7ec      	b.n	3401411c <ISP_Init+0x44>
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
34014142:	6bab      	ldr	r3, [r5, #56]	@ 0x38
34014144:	b90b      	cbnz	r3, 3401414a <ISP_Init+0x72>
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
34014146:	4827      	ldr	r0, [pc, #156]	@ (340141e4 <ISP_Init+0x10c>)
34014148:	e7e8      	b.n	3401411c <ISP_Init+0x44>
  if (pStatArea != NULL)
3401414a:	f1b8 0f00 	cmp.w	r8, #0
3401414e:	d003      	beq.n	34014158 <ISP_Init+0x80>
    hIsp->statArea = *pStatArea;
34014150:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
34014154:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
34014158:	4628      	mov	r0, r5
3401415a:	990b      	ldr	r1, [sp, #44]	@ 0x2c
3401415c:	f000 fd38 	bl	34014bd0 <ISP_SVC_IQParam_Init>
  if (ret != ISP_OK)
34014160:	4604      	mov	r4, r0
34014162:	2800      	cmp	r0, #0
34014164:	d1dd      	bne.n	34014122 <ISP_Init+0x4a>
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
34014166:	4628      	mov	r0, r5
34014168:	f105 014c 	add.w	r1, r5, #76	@ 0x4c
3401416c:	f000 fc9a 	bl	34014aa4 <ISP_SVC_Sensor_GetInfo>
  if (ret != ISP_OK)
34014170:	4604      	mov	r4, r0
34014172:	2800      	cmp	r0, #0
34014174:	d1d5      	bne.n	34014122 <ISP_Init+0x4a>
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
34014176:	6f2a      	ldr	r2, [r5, #112]	@ 0x70
34014178:	f5b2 6f28 	cmp.w	r2, #2688	@ 0xa80
3401417c:	d30f      	bcc.n	3401419e <ISP_Init+0xc6>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
3401417e:	f5b2 5fa8 	cmp.w	r2, #5376	@ 0x1500
34014182:	d320      	bcc.n	340141c6 <ISP_Init+0xee>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
34014184:	f5b2 5f28 	cmp.w	r2, #10752	@ 0x2a00
34014188:	d31f      	bcc.n	340141ca <ISP_Init+0xf2>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
3401418a:	f5b2 4fa8 	cmp.w	r2, #21504	@ 0x5400
3401418e:	f04f 0308 	mov.w	r3, #8
34014192:	d305      	bcc.n	340141a0 <ISP_Init+0xc8>
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
34014194:	4814      	ldr	r0, [pc, #80]	@ (340141e8 <ISP_Init+0x110>)
34014196:	f004 fb85 	bl	340188a4 <puts>
    return ISP_ERR_DECIMATION_EINVAL;
3401419a:	241e      	movs	r4, #30
3401419c:	e7c1      	b.n	34014122 <ISP_Init+0x4a>
3401419e:	2301      	movs	r3, #1
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
340141a0:	4628      	mov	r0, r5
340141a2:	a901      	add	r1, sp, #4
    decimation.factor = ISP_DECIM_FACTOR_1;
340141a4:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
340141a8:	f000 f9c6 	bl	34014538 <ISP_SVC_ISP_SetDecimation>
  if (ret != ISP_OK)
340141ac:	4604      	mov	r4, r0
340141ae:	2800      	cmp	r0, #0
340141b0:	d1b7      	bne.n	34014122 <ISP_Init+0x4a>
  ret = ISP_Algo_Init(hIsp);
340141b2:	4628      	mov	r0, r5
340141b4:	f7ff ff52 	bl	3401405c <ISP_Algo_Init>
  if (ret != ISP_OK)
340141b8:	4604      	mov	r4, r0
340141ba:	2800      	cmp	r0, #0
340141bc:	d1b1      	bne.n	34014122 <ISP_Init+0x4a>
  ISP_SVC_Stats_Init(hIsp);
340141be:	4628      	mov	r0, r5
340141c0:	f000 fd14 	bl	34014bec <ISP_SVC_Stats_Init>
  return ISP_OK;
340141c4:	e7ad      	b.n	34014122 <ISP_Init+0x4a>
340141c6:	2302      	movs	r3, #2
340141c8:	e7ea      	b.n	340141a0 <ISP_Init+0xc8>
340141ca:	2304      	movs	r3, #4
340141cc:	e7e8      	b.n	340141a0 <ISP_Init+0xc8>
    return ISP_ERR_EINVAL;
340141ce:	2401      	movs	r4, #1
340141d0:	e7a7      	b.n	34014122 <ISP_Init+0x4a>
340141d2:	bf00      	nop
340141d4:	3401cdb8 	.word	0x3401cdb8
340141d8:	3401cdf0 	.word	0x3401cdf0
340141dc:	3401ce28 	.word	0x3401ce28
340141e0:	3401ce60 	.word	0x3401ce60
340141e4:	3401ce9c 	.word	0x3401ce9c
340141e8:	3401ced8 	.word	0x3401ced8

340141ec <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
340141ec:	b538      	push	{r3, r4, r5, lr}
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
340141ee:	4605      	mov	r5, r0
340141f0:	b150      	cbz	r0, 34014208 <ISP_DeInit+0x1c>
  {
    return ISP_ERR_EINVAL;
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
340141f2:	f7ff ff4b 	bl	3401408c <ISP_Algo_DeInit>
  if (ret != ISP_OK)
340141f6:	4604      	mov	r4, r0
340141f8:	b920      	cbnz	r0, 34014204 <ISP_DeInit+0x18>
  {
    return ret;
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
340141fa:	4601      	mov	r1, r0
340141fc:	2288      	movs	r2, #136	@ 0x88
340141fe:	4628      	mov	r0, r5
34014200:	f004 fcbc 	bl	34018b7c <memset>

  return ISP_OK;
}
34014204:	4620      	mov	r0, r4
34014206:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
34014208:	2401      	movs	r4, #1
3401420a:	e7fb      	b.n	34014204 <ISP_DeInit+0x18>
3401420c:	0000      	movs	r0, r0
	...

34014210 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
34014210:	b573      	push	{r0, r1, r4, r5, r6, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
34014212:	4606      	mov	r6, r0
34014214:	2800      	cmp	r0, #0
34014216:	f000 809c 	beq.w	34014352 <ISP_Start+0x142>
  {
    return ISP_ERR_EINVAL;
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
3401421a:	f000 fc8b 	bl	34014b34 <ISP_SVC_Misc_IsDCMIPPReady>
  if (ret != ISP_OK)
3401421e:	2800      	cmp	r0, #0
34014220:	d171      	bne.n	34014306 <ISP_Start+0xf6>
  {
    return ret;
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34014222:	4630      	mov	r0, r6
34014224:	f000 fcde 	bl	34014be4 <ISP_SVC_IQParam_Get>
34014228:	4605      	mov	r5, r0

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
3401422a:	f100 010c 	add.w	r1, r0, #12
3401422e:	4630      	mov	r0, r6
34014230:	f000 f922 	bl	34014478 <ISP_SVC_ISP_SetDemosaicing>
  if (ret != ISP_OK)
34014234:	2800      	cmp	r0, #0
34014236:	d166      	bne.n	34014306 <ISP_Start+0xf6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
34014238:	4629      	mov	r1, r5
3401423a:	4630      	mov	r0, r6
3401423c:	f000 f95b 	bl	340144f6 <ISP_SVC_ISP_SetStatRemoval>
  if (ret != ISP_OK)
34014240:	2800      	cmp	r0, #0
34014242:	d160      	bne.n	34014306 <ISP_Start+0xf6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
34014244:	4630      	mov	r0, r6
34014246:	f105 0114 	add.w	r1, r5, #20
3401424a:	f000 f9a9 	bl	340145a0 <ISP_SVC_ISP_SetContrast>
  if (ret != ISP_OK)
3401424e:	2800      	cmp	r0, #0
34014250:	d159      	bne.n	34014306 <ISP_Start+0xf6>
  {
    return ret;
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
34014252:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
34014254:	2b00      	cmp	r3, #0
34014256:	d14b      	bne.n	340142f0 <ISP_Start+0xe0>
    {
      return ret;
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
34014258:	6d2b      	ldr	r3, [r5, #80]	@ 0x50
3401425a:	2b00      	cmp	r3, #0
3401425c:	d155      	bne.n	3401430a <ISP_Start+0xfa>
    {
      return ret;
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
3401425e:	f895 305c 	ldrb.w	r3, [r5, #92]	@ 0x5c
34014262:	b133      	cbz	r3, 34014272 <ISP_Start+0x62>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
34014264:	4630      	mov	r0, r6
34014266:	f105 015c 	add.w	r1, r5, #92	@ 0x5c
3401426a:	f000 fa57 	bl	3401471c <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
3401426e:	2800      	cmp	r0, #0
34014270:	d149      	bne.n	34014306 <ISP_Start+0xf6>
    {
      return ret;
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
34014272:	f895 3064 	ldrb.w	r3, [r5, #100]	@ 0x64
34014276:	b133      	cbz	r3, 34014286 <ISP_Start+0x76>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
34014278:	4630      	mov	r0, r6
3401427a:	f105 0164 	add.w	r1, r5, #100	@ 0x64
3401427e:	f000 fa82 	bl	34014786 <ISP_SVC_ISP_SetBlackLevel>
    if (ret != ISP_OK)
34014282:	2800      	cmp	r0, #0
34014284:	d13f      	bne.n	34014306 <ISP_Start+0xf6>
    {
      return ret;
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
34014286:	f895 3218 	ldrb.w	r3, [r5, #536]	@ 0x218
3401428a:	2b00      	cmp	r3, #0
3401428c:	d149      	bne.n	34014322 <ISP_Start+0x112>
    {
      return ret;
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401428e:	f895 3228 	ldrb.w	r3, [r5, #552]	@ 0x228
34014292:	2b00      	cmp	r3, #0
34014294:	d151      	bne.n	3401433a <ISP_Start+0x12a>
    }
  }

  /* Configure statistic area (defined by the application or by an optional static configuration) */
  /* Get its config from IQ params if it was not provided by the application at ISP_Init() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
34014296:	6933      	ldr	r3, [r6, #16]
34014298:	f106 0408 	add.w	r4, r6, #8
3401429c:	b10b      	cbz	r3, 340142a2 <ISP_Start+0x92>
3401429e:	6973      	ldr	r3, [r6, #20]
340142a0:	b923      	cbnz	r3, 340142ac <ISP_Start+0x9c>
  {
    hIsp->statArea = IQParamConfig->statAreaStatic;
340142a2:	f105 033c 	add.w	r3, r5, #60	@ 0x3c
340142a6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
340142a8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  }
  ret = ISP_SVC_ISP_SetStatArea(hIsp, &hIsp->statArea);
340142ac:	4621      	mov	r1, r4
340142ae:	4630      	mov	r0, r6
340142b0:	f000 f9f0 	bl	34014694 <ISP_SVC_ISP_SetStatArea>
  if (ret != ISP_OK)
340142b4:	bb38      	cbnz	r0, 34014306 <ISP_Start+0xf6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
340142b6:	4630      	mov	r0, r6
340142b8:	f505 7114 	add.w	r1, r5, #592	@ 0x250
340142bc:	f000 fc66 	bl	34014b8c <ISP_SVC_ISP_SetGamma>
  if (ret != ISP_OK)
340142c0:	bb08      	cbnz	r0, 34014306 <ISP_Start+0xf6>
  {
    return ret;
  }

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
340142c2:	f995 3069 	ldrsb.w	r3, [r5, #105]	@ 0x69
340142c6:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
340142ca:	ee01 3a10 	vmov	s2, r3
340142ce:	eeba 1aef 	vcvt.f32.s32	s2, s2, #1
340142d2:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
340142d6:	9001      	str	r0, [sp, #4]
340142d8:	f006 fe06 	bl	3401aee8 <pow>
340142dc:	ed9f 7b1e 	vldr	d7, [pc, #120]	@ 34014358 <ISP_Start+0x148>
340142e0:	ee20 0b07 	vmul.f64	d0, d0, d7
340142e4:	eebc 0bc0 	vcvt.u32.f64	s0, d0

  return ISP_OK;
340142e8:	9801      	ldr	r0, [sp, #4]
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
340142ea:	ed85 0a1b 	vstr	s0, [r5, #108]	@ 0x6c
  return ISP_OK;
340142ee:	e00a      	b.n	34014306 <ISP_Start+0xf6>
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
340142f0:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
340142f4:	2b00      	cmp	r3, #0
340142f6:	d1af      	bne.n	34014258 <ISP_Start+0x48>
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
340142f8:	4630      	mov	r0, r6
340142fa:	f105 014c 	add.w	r1, r5, #76	@ 0x4c
340142fe:	f000 fbdf 	bl	34014ac0 <ISP_SVC_Sensor_SetGain>
    if (ret != ISP_OK)
34014302:	2800      	cmp	r0, #0
34014304:	d0a8      	beq.n	34014258 <ISP_Start+0x48>
}
34014306:	b002      	add	sp, #8
34014308:	bd70      	pop	{r4, r5, r6, pc}
  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
3401430a:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
3401430e:	2b00      	cmp	r3, #0
34014310:	d1a5      	bne.n	3401425e <ISP_Start+0x4e>
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
34014312:	4630      	mov	r0, r6
34014314:	f105 0150 	add.w	r1, r5, #80	@ 0x50
34014318:	f000 fbef 	bl	34014afa <ISP_SVC_Sensor_SetExposure>
    if (ret != ISP_OK)
3401431c:	2800      	cmp	r0, #0
3401431e:	d09e      	beq.n	3401425e <ISP_Start+0x4e>
34014320:	e7f1      	b.n	34014306 <ISP_Start+0xf6>
  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
34014322:	f895 3070 	ldrb.w	r3, [r5, #112]	@ 0x70
34014326:	2b00      	cmp	r3, #0
34014328:	d1b1      	bne.n	3401428e <ISP_Start+0x7e>
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
3401432a:	4630      	mov	r0, r6
3401432c:	f505 7106 	add.w	r1, r5, #536	@ 0x218
34014330:	f000 fa4e 	bl	340147d0 <ISP_SVC_ISP_SetGain>
    if (ret != ISP_OK)
34014334:	2800      	cmp	r0, #0
34014336:	d0aa      	beq.n	3401428e <ISP_Start+0x7e>
34014338:	e7e5      	b.n	34014306 <ISP_Start+0xf6>
  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401433a:	f895 3070 	ldrb.w	r3, [r5, #112]	@ 0x70
3401433e:	2b00      	cmp	r3, #0
34014340:	d1a9      	bne.n	34014296 <ISP_Start+0x86>
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
34014342:	4630      	mov	r0, r6
34014344:	f505 710a 	add.w	r1, r5, #552	@ 0x228
34014348:	f000 fadc 	bl	34014904 <ISP_SVC_ISP_SetColorConv>
    if (ret != ISP_OK)
3401434c:	2800      	cmp	r0, #0
3401434e:	d0a2      	beq.n	34014296 <ISP_Start+0x86>
34014350:	e7d9      	b.n	34014306 <ISP_Start+0xf6>
    return ISP_ERR_EINVAL;
34014352:	2001      	movs	r0, #1
34014354:	e7d7      	b.n	34014306 <ISP_Start+0xf6>
34014356:	bf00      	nop
34014358:	00000000 	.word	0x00000000
3401435c:	404c0000 	.word	0x404c0000

34014360 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
34014360:	b538      	push	{r3, r4, r5, lr}
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
34014362:	4605      	mov	r5, r0
34014364:	b150      	cbz	r0, 3401437c <ISP_BackgroundProcess+0x1c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
34014366:	f000 fe43 	bl	34014ff0 <ISP_SVC_Stats_ProcessCallbacks>
3401436a:	4604      	mov	r4, r0

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
3401436c:	4628      	mov	r0, r5
3401436e:	f7ff fea0 	bl	340140b2 <ISP_Algo_Process>
  else if (retAlgo != ISP_OK)
  {
    return retAlgo;
  }

  return ISP_OK;
34014372:	2c00      	cmp	r4, #0
34014374:	bf08      	it	eq
34014376:	4604      	moveq	r4, r0
}
34014378:	4620      	mov	r0, r4
3401437a:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
3401437c:	2401      	movs	r4, #1
3401437e:	e7fb      	b.n	34014378 <ISP_BackgroundProcess+0x18>

34014380 <ISP_GatherStatistics>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Stats_Gather(hIsp);
34014380:	f000 bc3c 	b.w	34014bfc <ISP_SVC_Stats_Gather>

34014384 <ISP_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncMainFrameId(hIsp);
34014384:	f000 bbe2 	b.w	34014b4c <ISP_SVC_Misc_IncMainFrameId>

34014388 <ISP_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
34014388:	f000 bbe6 	b.w	34014b58 <ISP_SVC_Misc_IncAncillaryFrameId>

3401438c <ISP_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
3401438c:	f000 bbe8 	b.w	34014b60 <ISP_SVC_Misc_IncDumpFrameId>

34014390 <GetAvgStats>:

  return (int32_t) Val;
}

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
34014390:	b510      	push	{r4, lr}
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
34014392:	e9d0 4004 	ldrd	r4, r0, [r0, #16]
34014396:	4360      	muls	r0, r4
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
34014398:	4c0d      	ldr	r4, [pc, #52]	@ (340143d0 <GetAvgStats+0x40>)

  if (location == ISP_STAT_LOC_DOWN)
3401439a:	2902      	cmp	r1, #2
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
3401439c:	7824      	ldrb	r4, [r4, #0]
3401439e:	fb04 f404 	mul.w	r4, r4, r4
340143a2:	fbb0 f0f4 	udiv	r0, r0, r4
  if (location == ISP_STAT_LOC_DOWN)
340143a6:	d010      	beq.n	340143ca <GetAvgStats+0x3a>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
340143a8:	2a01      	cmp	r2, #1
340143aa:	bf14      	ite	ne
340143ac:	2204      	movne	r2, #4
340143ae:	2202      	moveq	r2, #2

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
340143b0:	4282      	cmp	r2, r0
  nb_comp_pix /= comp_divider;
340143b2:	bf9f      	itttt	ls
340143b4:	fbb0 f0f2 	udivls	r0, r0, r2
  {
    return 0;
  }

  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
340143b8:	0842      	lsrls	r2, r0, #1
340143ba:	eb02 2303 	addls.w	r3, r2, r3, lsl #8
340143be:	fbb3 f0f0 	udivls	r0, r3, r0
    return 0;
340143c2:	bf8c      	ite	hi
340143c4:	2000      	movhi	r0, #0
  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
340143c6:	b2c0      	uxtbls	r0, r0
}
340143c8:	bd10      	pop	{r4, pc}
    comp_divider = 1;
340143ca:	2201      	movs	r2, #1
340143cc:	e7f0      	b.n	340143b0 <GetAvgStats+0x20>
340143ce:	bf00      	nop
340143d0:	3403edc6 	.word	0x3403edc6

340143d4 <SetStatConfig>:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
  }
}

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
340143d4:	b5f0      	push	{r4, r5, r6, r7, lr}
340143d6:	460b      	mov	r3, r1
340143d8:	4606      	mov	r6, r0
  for (int i = 0; i < 3; i++)
340143da:	2400      	movs	r4, #0
  {
    statConf[i] = *refConfig;
340143dc:	270c      	movs	r7, #12
340143de:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
340143e2:	fb07 6504 	mla	r5, r7, r4, r6
  for (int i = 0; i < 3; i++)
340143e6:	3401      	adds	r4, #1
340143e8:	2c03      	cmp	r4, #3
    statConf[i] = *refConfig;
340143ea:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
340143ee:	d1f6      	bne.n	340143de <SetStatConfig+0xa>
  }
}
340143f0:	bdf0      	pop	{r4, r5, r6, r7, pc}

340143f2 <ReadStatHistogram>:
{
340143f2:	b570      	push	{r4, r5, r6, lr}
340143f4:	4606      	mov	r6, r0
340143f6:	460c      	mov	r4, r1
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
340143f8:	2501      	movs	r5, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
340143fa:	4623      	mov	r3, r4
340143fc:	b2ea      	uxtb	r2, r5
340143fe:	2101      	movs	r1, #1
34014400:	6830      	ldr	r0, [r6, #0]
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014402:	3501      	adds	r5, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
34014404:	f7f2 fd64 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014408:	2d04      	cmp	r5, #4
3401440a:	f104 0404 	add.w	r4, r4, #4
3401440e:	d1f4      	bne.n	340143fa <ReadStatHistogram+0x8>
}
34014410:	bd70      	pop	{r4, r5, r6, pc}
34014412:	0000      	movs	r0, r0
34014414:	0000      	movs	r0, r0
	...

34014418 <LuminanceFromRGB>:
  }
  return stage;
}

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
34014418:	ee07 1a10 	vmov	s14, r1
3401441c:	ee05 0a10 	vmov	s10, r0
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34014420:	ed9f 4b0f 	vldr	d4, [pc, #60]	@ 34014460 <LuminanceFromRGB+0x48>
34014424:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
{
34014428:	ee06 2a10 	vmov	s12, r2
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3401442c:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
34014430:	ee27 7b04 	vmul.f64	d7, d7, d4
34014434:	ed9f 4b0c 	vldr	d4, [pc, #48]	@ 34014468 <LuminanceFromRGB+0x50>
34014438:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
3401443c:	eea5 7b04 	vfma.f64	d7, d5, d4
34014440:	ed9f 5b0b 	vldr	d5, [pc, #44]	@ 34014470 <LuminanceFromRGB+0x58>
34014444:	eea6 7b05 	vfma.f64	d7, d6, d5
34014448:	eefc 7bc7 	vcvt.u32.f64	s15, d7
{
3401444c:	b082      	sub	sp, #8
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3401444e:	edcd 7a01 	vstr	s15, [sp, #4]
}
34014452:	f89d 0004 	ldrb.w	r0, [sp, #4]
34014456:	b002      	add	sp, #8
34014458:	4770      	bx	lr
3401445a:	bf00      	nop
3401445c:	f3af 8000 	nop.w
34014460:	39581062 	.word	0x39581062
34014464:	3fe2c8b4 	.word	0x3fe2c8b4
34014468:	e5604189 	.word	0xe5604189
3401446c:	3fd322d0 	.word	0x3fd322d0
34014470:	9fbe76c9 	.word	0x9fbe76c9
34014474:	3fbd2f1a 	.word	0x3fbd2f1a

34014478 <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
34014478:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401447a:	4604      	mov	r4, r0
{
3401447c:	b087      	sub	sp, #28
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401447e:	2800      	cmp	r0, #0
34014480:	d037      	beq.n	340144f2 <ISP_SVC_ISP_SetDemosaicing+0x7a>
34014482:	2900      	cmp	r1, #0
34014484:	d035      	beq.n	340144f2 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34014486:	788f      	ldrb	r7, [r1, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014488:	2f07      	cmp	r7, #7
3401448a:	d832      	bhi.n	340144f2 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3401448c:	78ce      	ldrb	r6, [r1, #3]
3401448e:	2e07      	cmp	r6, #7
34014490:	d82f      	bhi.n	340144f2 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34014492:	790d      	ldrb	r5, [r1, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34014494:	2d07      	cmp	r5, #7
34014496:	d82c      	bhi.n	340144f2 <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34014498:	7948      	ldrb	r0, [r1, #5]
3401449a:	2807      	cmp	r0, #7
3401449c:	d829      	bhi.n	340144f2 <ISP_SVC_ISP_SetDemosaicing+0x7a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
3401449e:	780b      	ldrb	r3, [r1, #0]
340144a0:	b113      	cbz	r3, 340144a8 <ISP_SVC_ISP_SetDemosaicing+0x30>
340144a2:	784a      	ldrb	r2, [r1, #1]
340144a4:	2a04      	cmp	r2, #4
340144a6:	d107      	bne.n	340144b8 <ISP_SVC_ISP_SetDemosaicing+0x40>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
340144a8:	2101      	movs	r1, #1
340144aa:	6820      	ldr	r0, [r4, #0]
340144ac:	f7f1 ff3c 	bl	34006328 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
340144b0:	b100      	cbz	r0, 340144b4 <ISP_SVC_ISP_SetDemosaicing+0x3c>
  {
    return ISP_ERR_DEMOSAICING_HAL;
340144b2:	200b      	movs	r0, #11
  }

  return ISP_OK;
}
340144b4:	b007      	add	sp, #28
340144b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(pConfig->type)
340144b8:	2a02      	cmp	r2, #2
340144ba:	d018      	beq.n	340144ee <ISP_SVC_ISP_SetDemosaicing+0x76>
340144bc:	1e51      	subs	r1, r2, #1
340144be:	424b      	negs	r3, r1
340144c0:	414b      	adcs	r3, r1
340144c2:	2a03      	cmp	r2, #3
340144c4:	ea4f 0343 	mov.w	r3, r3, lsl #1
340144c8:	bf08      	it	eq
340144ca:	2306      	moveq	r3, #6
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
340144cc:	9005      	str	r0, [sp, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
340144ce:	2101      	movs	r1, #1
340144d0:	6820      	ldr	r0, [r4, #0]
340144d2:	aa01      	add	r2, sp, #4
    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
340144d4:	e9cd 3703 	strd	r3, r7, [sp, #12]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
340144d8:	e9cd 6501 	strd	r6, r5, [sp, #4]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
340144dc:	f7f1 feb2 	bl	34006244 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
    if (halStatus == HAL_OK)
340144e0:	2800      	cmp	r0, #0
340144e2:	d1e6      	bne.n	340144b2 <ISP_SVC_ISP_SetDemosaicing+0x3a>
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
340144e4:	2101      	movs	r1, #1
340144e6:	6820      	ldr	r0, [r4, #0]
340144e8:	f7f1 ff06 	bl	340062f8 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
340144ec:	e7e0      	b.n	340144b0 <ISP_SVC_ISP_SetDemosaicing+0x38>
    switch(pConfig->type)
340144ee:	2304      	movs	r3, #4
340144f0:	e7ec      	b.n	340144cc <ISP_SVC_ISP_SetDemosaicing+0x54>
    return ISP_ERR_DEMOSAICING_EINVAL;
340144f2:	200a      	movs	r0, #10
340144f4:	e7de      	b.n	340144b4 <ISP_SVC_ISP_SetDemosaicing+0x3c>

340144f6 <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
340144f6:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340144f8:	4604      	mov	r4, r0
340144fa:	b1d8      	cbz	r0, 34014534 <ISP_SVC_ISP_SetStatRemoval+0x3e>
340144fc:	b1d1      	cbz	r1, 34014534 <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
340144fe:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014500:	2a07      	cmp	r2, #7
34014502:	d817      	bhi.n	34014534 <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
34014504:	f640 70fe 	movw	r0, #4094	@ 0xffe
34014508:	688b      	ldr	r3, [r1, #8]
3401450a:	4283      	cmp	r3, r0
3401450c:	d812      	bhi.n	34014534 <ISP_SVC_ISP_SetStatRemoval+0x3e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
  }

  if (pConfig->enable == 0)
3401450e:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34014510:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enable == 0)
34014512:	b921      	cbnz	r1, 3401451e <ISP_SVC_ISP_SetStatRemoval+0x28>
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34014514:	2101      	movs	r1, #1
34014516:	f7f1 ff5b 	bl	340063d0 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3401451a:	b128      	cbz	r0, 34014528 <ISP_SVC_ISP_SetStatRemoval+0x32>
3401451c:	e003      	b.n	34014526 <ISP_SVC_ISP_SetStatRemoval+0x30>
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
3401451e:	2101      	movs	r1, #1
34014520:	f7f1 ff1a 	bl	34006358 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
    if (halStatus == HAL_OK)
34014524:	b108      	cbz	r0, 3401452a <ISP_SVC_ISP_SetStatRemoval+0x34>
  {
    return ISP_ERR_STATREMOVAL_HAL;
34014526:	2015      	movs	r0, #21
  }

  return ISP_OK;
}
34014528:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3401452a:	2101      	movs	r1, #1
3401452c:	6820      	ldr	r0, [r4, #0]
3401452e:	f7f1 ff41 	bl	340063b4 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
34014532:	e7f2      	b.n	3401451a <ISP_SVC_ISP_SetStatRemoval+0x24>
    return ISP_ERR_STATREMOVAL_EINVAL;
34014534:	2014      	movs	r0, #20
34014536:	e7f7      	b.n	34014528 <ISP_SVC_ISP_SetStatRemoval+0x32>

34014538 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
34014538:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401453a:	460c      	mov	r4, r1
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401453c:	4605      	mov	r5, r0
3401453e:	b350      	cbz	r0, 34014596 <ISP_SVC_ISP_SetDecimation+0x5e>
34014540:	b349      	cbz	r1, 34014596 <ISP_SVC_ISP_SetDecimation+0x5e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
  }

  switch (pConfig->factor)
34014542:	780b      	ldrb	r3, [r1, #0]
34014544:	3b01      	subs	r3, #1
34014546:	2b07      	cmp	r3, #7
34014548:	d825      	bhi.n	34014596 <ISP_SVC_ISP_SetDecimation+0x5e>
3401454a:	e8df f003 	tbb	[pc, r3]
3401454e:	0417      	.short	0x0417
34014550:	24241124 	.word	0x24241124
34014554:	1424      	.short	0x1424
34014556:	2308      	movs	r3, #8
34014558:	2202      	movs	r2, #2
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
3401455a:	e9cd 3200 	strd	r3, r2, [sp]

  default:
    return ISP_ERR_DECIMATION_EINVAL;
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
3401455e:	2101      	movs	r1, #1
34014560:	466a      	mov	r2, sp
34014562:	6828      	ldr	r0, [r5, #0]
34014564:	f7f1 fc66 	bl	34005e34 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
34014568:	b158      	cbz	r0, 34014582 <ISP_SVC_ISP_SetDecimation+0x4a>
  {
    return ISP_ERR_DECIMATION_HAL;
3401456a:	201f      	movs	r0, #31

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;

  return ret;
}
3401456c:	b003      	add	sp, #12
3401456e:	bd30      	pop	{r4, r5, pc}
    break;
34014570:	2310      	movs	r3, #16
34014572:	2204      	movs	r2, #4
34014574:	e7f1      	b.n	3401455a <ISP_SVC_ISP_SetDecimation+0x22>
    break;
34014576:	2318      	movs	r3, #24
34014578:	2206      	movs	r2, #6
3401457a:	e7ee      	b.n	3401455a <ISP_SVC_ISP_SetDecimation+0x22>
  switch (pConfig->factor)
3401457c:	2300      	movs	r3, #0
3401457e:	461a      	mov	r2, r3
34014580:	e7eb      	b.n	3401455a <ISP_SVC_ISP_SetDecimation+0x22>
  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014582:	2101      	movs	r1, #1
34014584:	6828      	ldr	r0, [r5, #0]
34014586:	f7f1 fc93 	bl	34005eb0 <HAL_DCMIPP_PIPE_EnableISPDecimation>
3401458a:	2800      	cmp	r0, #0
3401458c:	d1ed      	bne.n	3401456a <ISP_SVC_ISP_SetDecimation+0x32>
  ISP_DecimationValue.factor = pConfig->factor;
3401458e:	7822      	ldrb	r2, [r4, #0]
34014590:	4b02      	ldr	r3, [pc, #8]	@ (3401459c <ISP_SVC_ISP_SetDecimation+0x64>)
34014592:	701a      	strb	r2, [r3, #0]
  return ret;
34014594:	e7ea      	b.n	3401456c <ISP_SVC_ISP_SetDecimation+0x34>
  switch (pConfig->factor)
34014596:	201e      	movs	r0, #30
34014598:	e7e8      	b.n	3401456c <ISP_SVC_ISP_SetDecimation+0x34>
3401459a:	bf00      	nop
3401459c:	3403edc6 	.word	0x3403edc6

340145a0 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
340145a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340145a4:	4605      	mov	r5, r0
{
340145a6:	b085      	sub	sp, #20
  if ((hIsp == NULL) || (pConfig == NULL) ||
340145a8:	2800      	cmp	r0, #0
340145aa:	d071      	beq.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
340145ac:	2900      	cmp	r1, #0
340145ae:	d06f      	beq.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145b0:	684b      	ldr	r3, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340145b2:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
340145b6:	d86b      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145b8:	f8d1 9008 	ldr.w	r9, [r1, #8]
340145bc:	f5b9 7fc5 	cmp.w	r9, #394	@ 0x18a
340145c0:	d866      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145c2:	f8d1 800c 	ldr.w	r8, [r1, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145c6:	f5b8 7fc5 	cmp.w	r8, #394	@ 0x18a
340145ca:	d861      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145cc:	f8d1 e010 	ldr.w	lr, [r1, #16]
340145d0:	f5be 7fc5 	cmp.w	lr, #394	@ 0x18a
340145d4:	d85c      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145d6:	f8d1 c014 	ldr.w	ip, [r1, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145da:	f5bc 7fc5 	cmp.w	ip, #394	@ 0x18a
340145de:	d857      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145e0:	698f      	ldr	r7, [r1, #24]
340145e2:	f5b7 7fc5 	cmp.w	r7, #394	@ 0x18a
340145e6:	d853      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145e8:	69ce      	ldr	r6, [r1, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145ea:	f5b6 7fc5 	cmp.w	r6, #394	@ 0x18a
340145ee:	d84f      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145f0:	6a0c      	ldr	r4, [r1, #32]
340145f2:	f5b4 7fc5 	cmp.w	r4, #394	@ 0x18a
340145f6:	d84b      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
340145f8:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
340145fa:	f5b2 7fc5 	cmp.w	r2, #394	@ 0x18a
340145fe:	d847      	bhi.n	34014690 <ISP_SVC_ISP_SetContrast+0xf0>
  {
    return ISP_ERR_CONTRAST_EINVAL;
  }

  if (pConfig->enable == 0)
34014600:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34014602:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
34014604:	b921      	cbnz	r1, 34014610 <ISP_SVC_ISP_SetContrast+0x70>
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34014606:	2101      	movs	r1, #1
34014608:	f7f2 fb7a 	bl	34006d00 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3401460c:	b3c0      	cbz	r0, 34014680 <ISP_SVC_ISP_SetContrast+0xe0>
3401460e:	e036      	b.n	3401467e <ISP_SVC_ISP_SetContrast+0xde>
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
34014610:	0119      	lsls	r1, r3, #4
34014612:	2364      	movs	r3, #100	@ 0x64
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
34014614:	0112      	lsls	r2, r2, #4
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
34014616:	fbb1 f1f3 	udiv	r1, r1, r3
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
3401461a:	fbb2 f2f3 	udiv	r2, r2, r3
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3401461e:	ea4f 1909 	mov.w	r9, r9, lsl #4
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
34014622:	ea4f 1808 	mov.w	r8, r8, lsl #4
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
34014626:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
3401462a:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3401462e:	013f      	lsls	r7, r7, #4
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
34014630:	0136      	lsls	r6, r6, #4
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
34014632:	0124      	lsls	r4, r4, #4
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
34014634:	fbb9 f9f3 	udiv	r9, r9, r3
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
34014638:	fbb8 f8f3 	udiv	r8, r8, r3
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3401463c:	fbbe fef3 	udiv	lr, lr, r3
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
34014640:	fbbc fcf3 	udiv	ip, ip, r3
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
34014644:	fbb7 f7f3 	udiv	r7, r7, r3
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
34014648:	fbb6 f6f3 	udiv	r6, r6, r3
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3401464c:	fbb4 f4f3 	udiv	r4, r4, r3
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
34014650:	f88d 1004 	strb.w	r1, [sp, #4]
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
34014654:	f88d 200c 	strb.w	r2, [sp, #12]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
34014658:	2101      	movs	r1, #1
3401465a:	aa01      	add	r2, sp, #4
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3401465c:	f88d 9005 	strb.w	r9, [sp, #5]
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
34014660:	f88d 8006 	strb.w	r8, [sp, #6]
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
34014664:	f88d e007 	strb.w	lr, [sp, #7]
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
34014668:	f88d c008 	strb.w	ip, [sp, #8]
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3401466c:	f88d 7009 	strb.w	r7, [sp, #9]
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
34014670:	f88d 600a 	strb.w	r6, [sp, #10]
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
34014674:	f88d 400b 	strb.w	r4, [sp, #11]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
34014678:	f7f2 faa8 	bl	34006bcc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
    if (halStatus == HAL_OK)
3401467c:	b118      	cbz	r0, 34014686 <ISP_SVC_ISP_SetContrast+0xe6>
  {
    return ISP_ERR_CONTRAST_HAL;
3401467e:	2029      	movs	r0, #41	@ 0x29
  }

  return ISP_OK;
}
34014680:	b005      	add	sp, #20
34014682:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34014686:	2101      	movs	r1, #1
34014688:	6828      	ldr	r0, [r5, #0]
3401468a:	f7f2 fb21 	bl	34006cd0 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
3401468e:	e7bd      	b.n	3401460c <ISP_SVC_ISP_SetContrast+0x6c>
    return ISP_ERR_CONTRAST_EINVAL;
34014690:	2028      	movs	r0, #40	@ 0x28
34014692:	e7f5      	b.n	34014680 <ISP_SVC_ISP_SetContrast+0xe0>

34014694 <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
34014694:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34014696:	4604      	mov	r4, r0
34014698:	2800      	cmp	r0, #0
3401469a:	d03a      	beq.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
3401469c:	2900      	cmp	r1, #0
3401469e:	d038      	beq.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
340146a0:	f640 72fe 	movw	r2, #4094	@ 0xffe
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
340146a4:	680d      	ldr	r5, [r1, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340146a6:	4295      	cmp	r5, r2
340146a8:	d833      	bhi.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
340146aa:	6848      	ldr	r0, [r1, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
340146ac:	4290      	cmp	r0, r2
340146ae:	d830      	bhi.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
340146b0:	688b      	ldr	r3, [r1, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
340146b2:	4293      	cmp	r3, r2
340146b4:	d82d      	bhi.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
340146b6:	68ca      	ldr	r2, [r1, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
340146b8:	f640 71fa 	movw	r1, #4090	@ 0xffa
340146bc:	1f16      	subs	r6, r2, #4
340146be:	428e      	cmp	r6, r1
340146c0:	d827      	bhi.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
340146c2:	2b03      	cmp	r3, #3
340146c4:	d925      	bls.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
340146c6:	6f26      	ldr	r6, [r4, #112]	@ 0x70
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
340146c8:	18e9      	adds	r1, r5, r3
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
340146ca:	42b1      	cmp	r1, r6
340146cc:	d821      	bhi.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
340146ce:	6f66      	ldr	r6, [r4, #116]	@ 0x74
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
340146d0:	1881      	adds	r1, r0, r2
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
340146d2:	42b1      	cmp	r1, r6
340146d4:	d81d      	bhi.n	34014712 <ISP_SVC_ISP_SetStatArea+0x7e>
  {
    return ISP_ERR_STATAREA_EINVAL;
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
340146d6:	4910      	ldr	r1, [pc, #64]	@ (34014718 <ISP_SVC_ISP_SetStatArea+0x84>)
340146d8:	7809      	ldrb	r1, [r1, #0]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
340146da:	fbb0 f0f1 	udiv	r0, r0, r1
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
340146de:	fbb2 f2f1 	udiv	r2, r2, r1
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
340146e2:	fbb5 f5f1 	udiv	r5, r5, r1
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
340146e6:	fbb3 f3f1 	udiv	r3, r3, r1
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
340146ea:	9000      	str	r0, [sp, #0]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
340146ec:	9202      	str	r2, [sp, #8]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
340146ee:	2101      	movs	r1, #1
340146f0:	466a      	mov	r2, sp
340146f2:	6820      	ldr	r0, [r4, #0]
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
340146f4:	9501      	str	r5, [sp, #4]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
340146f6:	9303      	str	r3, [sp, #12]
  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
340146f8:	f7f2 f94e 	bl	34006998 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
340146fc:	b110      	cbz	r0, 34014704 <ISP_SVC_ISP_SetStatArea+0x70>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
340146fe:	2033      	movs	r0, #51	@ 0x33
  {
    return ISP_ERR_STATAREA_HAL;
  }

  return ret;
}
34014700:	b004      	add	sp, #16
34014702:	bd70      	pop	{r4, r5, r6, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
34014704:	2101      	movs	r1, #1
34014706:	6820      	ldr	r0, [r4, #0]
34014708:	f7f2 f9d0 	bl	34006aac <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
  if (halStatus != HAL_OK)
3401470c:	2800      	cmp	r0, #0
3401470e:	d0f7      	beq.n	34014700 <ISP_SVC_ISP_SetStatArea+0x6c>
34014710:	e7f5      	b.n	340146fe <ISP_SVC_ISP_SetStatArea+0x6a>
    return ISP_ERR_STATAREA_EINVAL;
34014712:	2032      	movs	r0, #50	@ 0x32
34014714:	e7f4      	b.n	34014700 <ISP_SVC_ISP_SetStatArea+0x6c>
34014716:	bf00      	nop
34014718:	3403edc6 	.word	0x3403edc6

3401471c <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3401471c:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
3401471e:	4604      	mov	r4, r0
34014720:	b1a8      	cbz	r0, 3401474e <ISP_SVC_ISP_SetBadPixel+0x32>
34014722:	b1a1      	cbz	r1, 3401474e <ISP_SVC_ISP_SetBadPixel+0x32>
34014724:	784a      	ldrb	r2, [r1, #1]
34014726:	2a07      	cmp	r2, #7
34014728:	d811      	bhi.n	3401474e <ISP_SVC_ISP_SetBadPixel+0x32>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  if (pConfig->enable == 0)
3401472a:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401472c:	6800      	ldr	r0, [r0, #0]
3401472e:	2101      	movs	r1, #1
  if (pConfig->enable == 0)
34014730:	b91b      	cbnz	r3, 3401473a <ISP_SVC_ISP_SetBadPixel+0x1e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014732:	f7f1 fe9b 	bl	3400646c <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
  }

  if (halStatus != HAL_OK)
34014736:	b120      	cbz	r0, 34014742 <ISP_SVC_ISP_SetBadPixel+0x26>
34014738:	e002      	b.n	34014740 <ISP_SVC_ISP_SetBadPixel+0x24>
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
3401473a:	f7f1 fe57 	bl	340063ec <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
    if (halStatus != HAL_OK)
3401473e:	b108      	cbz	r0, 34014744 <ISP_SVC_ISP_SetBadPixel+0x28>
      return ISP_ERR_BADPIXEL_HAL;
34014740:	203d      	movs	r0, #61	@ 0x3d
  {
    return ISP_ERR_BADPIXEL_HAL;
  }

  return ISP_OK;
}
34014742:	bd10      	pop	{r4, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014744:	2101      	movs	r1, #1
34014746:	6820      	ldr	r0, [r4, #0]
34014748:	f7f1 fe78 	bl	3400643c <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
3401474c:	e7f3      	b.n	34014736 <ISP_SVC_ISP_SetBadPixel+0x1a>
    return ISP_ERR_BADPIXEL_EINVAL;
3401474e:	203c      	movs	r0, #60	@ 0x3c
34014750:	e7f7      	b.n	34014742 <ISP_SVC_ISP_SetBadPixel+0x26>

34014752 <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
34014752:	b538      	push	{r3, r4, r5, lr}
34014754:	460d      	mov	r5, r1
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014756:	4604      	mov	r4, r0
34014758:	b198      	cbz	r0, 34014782 <ISP_SVC_ISP_GetBadPixel+0x30>
3401475a:	b191      	cbz	r1, 34014782 <ISP_SVC_ISP_GetBadPixel+0x30>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401475c:	2101      	movs	r1, #1
3401475e:	6800      	ldr	r0, [r0, #0]
34014760:	f7f1 feae 	bl	340064c0 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
34014764:	7028      	strb	r0, [r5, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
34014766:	2101      	movs	r1, #1
34014768:	6820      	ldr	r0, [r4, #0]
3401476a:	f7f1 fe97 	bl	3400649c <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
3401476e:	7068      	strb	r0, [r5, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
34014770:	2101      	movs	r1, #1
34014772:	6820      	ldr	r0, [r4, #0]
34014774:	1d2a      	adds	r2, r5, #4
34014776:	f7f1 fec9 	bl	3400650c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>

  if (halStatus != HAL_OK)
  {
    return ISP_ERR_BADPIXEL_HAL;
3401477a:	2800      	cmp	r0, #0
3401477c:	bf18      	it	ne
3401477e:	203d      	movne	r0, #61	@ 0x3d
  }

  return ISP_OK;
}
34014780:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_BADPIXEL_EINVAL;
34014782:	203c      	movs	r0, #60	@ 0x3c
34014784:	e7fc      	b.n	34014780 <ISP_SVC_ISP_GetBadPixel+0x2e>

34014786 <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
34014786:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014788:	4604      	mov	r4, r0
3401478a:	b1f0      	cbz	r0, 340147ca <ISP_SVC_ISP_SetBlackLevel+0x44>
3401478c:	b1e9      	cbz	r1, 340147ca <ISP_SVC_ISP_SetBlackLevel+0x44>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
  }

  if (pConfig->enable == 0)
3401478e:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014790:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
34014792:	b923      	cbnz	r3, 3401479e <ISP_SVC_ISP_SetBlackLevel+0x18>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014794:	2101      	movs	r1, #1
34014796:	f7f2 f881 	bl	3400689c <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
3401479a:	b178      	cbz	r0, 340147bc <ISP_SVC_ISP_SetBlackLevel+0x36>
3401479c:	e00d      	b.n	340147ba <ISP_SVC_ISP_SetBlackLevel+0x34>
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
3401479e:	784b      	ldrb	r3, [r1, #1]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
340147a0:	aa01      	add	r2, sp, #4
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
340147a2:	f88d 3004 	strb.w	r3, [sp, #4]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
340147a6:	788b      	ldrb	r3, [r1, #2]
340147a8:	f88d 3005 	strb.w	r3, [sp, #5]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
340147ac:	78cb      	ldrb	r3, [r1, #3]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
340147ae:	2101      	movs	r1, #1
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
340147b0:	f88d 3006 	strb.w	r3, [sp, #6]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
340147b4:	f7f2 f838 	bl	34006828 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
    if (halStatus == HAL_OK)
340147b8:	b110      	cbz	r0, 340147c0 <ISP_SVC_ISP_SetBlackLevel+0x3a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
340147ba:	2047      	movs	r0, #71	@ 0x47
  }

  return ISP_OK;
}
340147bc:	b002      	add	sp, #8
340147be:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
340147c0:	2101      	movs	r1, #1
340147c2:	6820      	ldr	r0, [r4, #0]
340147c4:	f7f2 f852 	bl	3400686c <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
340147c8:	e7e7      	b.n	3401479a <ISP_SVC_ISP_SetBlackLevel+0x14>
    return ISP_ERR_BLACKLEVEL_EINVAL;
340147ca:	2046      	movs	r0, #70	@ 0x46
340147cc:	e7f6      	b.n	340147bc <ISP_SVC_ISP_SetBlackLevel+0x36>
	...

340147d0 <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
340147d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340147d4:	4605      	mov	r5, r0
340147d6:	2800      	cmp	r0, #0
340147d8:	f000 808b 	beq.w	340148f2 <ISP_SVC_ISP_SetGain+0x122>
340147dc:	2900      	cmp	r1, #0
340147de:	f000 8088 	beq.w	340148f2 <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
340147e2:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340147e4:	4b46      	ldr	r3, [pc, #280]	@ (34014900 <ISP_SVC_ISP_SetGain+0x130>)
340147e6:	429a      	cmp	r2, r3
340147e8:	f200 8083 	bhi.w	340148f2 <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
340147ec:	f8d1 8008 	ldr.w	r8, [r1, #8]
340147f0:	4598      	cmp	r8, r3
340147f2:	d87e      	bhi.n	340148f2 <ISP_SVC_ISP_SetGain+0x122>
340147f4:	68cf      	ldr	r7, [r1, #12]
340147f6:	429f      	cmp	r7, r3
340147f8:	d87b      	bhi.n	340148f2 <ISP_SVC_ISP_SetGain+0x122>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
  }

  if (pConfig->enable == 0)
340147fa:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
340147fc:	6806      	ldr	r6, [r0, #0]
  if (pConfig->enable == 0)
340147fe:	b933      	cbnz	r3, 3401480e <ISP_SVC_ISP_SetGain+0x3e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
34014800:	2101      	movs	r1, #1
34014802:	4630      	mov	r0, r6
34014804:	f7f2 f9ca 	bl	34006b9c <HAL_DCMIPP_PIPE_DisableISPExposure>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014808:	2800      	cmp	r0, #0
3401480a:	d05b      	beq.n	340148c4 <ISP_SVC_ISP_SetGain+0xf4>
3401480c:	e059      	b.n	340148c2 <ISP_SVC_ISP_SetGain+0xf2>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401480e:	2400      	movs	r4, #0
34014810:	4610      	mov	r0, r2
34014812:	a339      	add	r3, pc, #228	@ (adr r3, 340148f8 <ISP_SVC_ISP_SetGain+0x128>)
34014814:	e9d3 2300 	ldrd	r2, r3, [r3]
34014818:	4621      	mov	r1, r4
3401481a:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3401481e:	f7ec fedd 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
34014822:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014824:	4682      	mov	sl, r0
34014826:	468b      	mov	fp, r1
  while (Val >= 256)
34014828:	4622      	mov	r2, r4
3401482a:	f5ba 7f80 	cmp.w	sl, #256	@ 0x100
3401482e:	f17b 0000 	sbcs.w	r0, fp, #0
34014832:	f103 0101 	add.w	r1, r3, #1
34014836:	d248      	bcs.n	340148ca <ISP_SVC_ISP_SetGain+0xfa>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014838:	2400      	movs	r4, #0
  *pShift = 0;
3401483a:	2a00      	cmp	r2, #0
3401483c:	bf08      	it	eq
3401483e:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014840:	4640      	mov	r0, r8
34014842:	4621      	mov	r1, r4
  *pShift = 0;
34014844:	f88d 3000 	strb.w	r3, [sp]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014848:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3401484c:	a32a      	add	r3, pc, #168	@ (adr r3, 340148f8 <ISP_SVC_ISP_SetGain+0x128>)
3401484e:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = Val;
34014852:	f88d a001 	strb.w	sl, [sp, #1]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014856:	f7ec fec1 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
3401485a:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401485c:	4680      	mov	r8, r0
3401485e:	4689      	mov	r9, r1
  while (Val >= 256)
34014860:	4622      	mov	r2, r4
34014862:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
34014866:	f179 0000 	sbcs.w	r0, r9, #0
3401486a:	f103 0101 	add.w	r1, r3, #1
3401486e:	d231      	bcs.n	340148d4 <ISP_SVC_ISP_SetGain+0x104>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014870:	2400      	movs	r4, #0
  *pShift = 0;
34014872:	2a00      	cmp	r2, #0
34014874:	bf08      	it	eq
34014876:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014878:	4638      	mov	r0, r7
3401487a:	4621      	mov	r1, r4
  *pShift = 0;
3401487c:	f88d 3002 	strb.w	r3, [sp, #2]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014880:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
34014884:	a31c      	add	r3, pc, #112	@ (adr r3, 340148f8 <ISP_SVC_ISP_SetGain+0x128>)
34014886:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = Val;
3401488a:	f88d 8003 	strb.w	r8, [sp, #3]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401488e:	f7ec fea5 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
34014892:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014894:	4680      	mov	r8, r0
34014896:	4689      	mov	r9, r1
  while (Val >= 256)
34014898:	4622      	mov	r2, r4
3401489a:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
3401489e:	f179 0000 	sbcs.w	r0, r9, #0
340148a2:	f103 0101 	add.w	r1, r3, #1
340148a6:	d21a      	bcs.n	340148de <ISP_SVC_ISP_SetGain+0x10e>
  *pShift = 0;
340148a8:	2a00      	cmp	r2, #0
340148aa:	bf08      	it	eq
340148ac:	4613      	moveq	r3, r2
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
340148ae:	2101      	movs	r1, #1
340148b0:	466a      	mov	r2, sp
340148b2:	4630      	mov	r0, r6
  *pShift = 0;
340148b4:	f88d 3004 	strb.w	r3, [sp, #4]
  *pMultiplier = Val;
340148b8:	f88d 8005 	strb.w	r8, [sp, #5]
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
340148bc:	f7f2 f90e 	bl	34006adc <HAL_DCMIPP_PIPE_SetISPExposureConfig>
    if (halStatus == HAL_OK)
340148c0:	b190      	cbz	r0, 340148e8 <ISP_SVC_ISP_SetGain+0x118>
  {
    return ISP_ERR_ISPGAIN_HAL;
340148c2:	2051      	movs	r0, #81	@ 0x51
  }

  return ISP_OK;
}
340148c4:	b003      	add	sp, #12
340148c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Val /= 2;
340148ca:	ea5a 0b5f 	orrs.w	fp, sl, pc, lsr #1
340148ce:	460b      	mov	r3, r1
340148d0:	2201      	movs	r2, #1
340148d2:	e7aa      	b.n	3401482a <ISP_SVC_ISP_SetGain+0x5a>
340148d4:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
340148d8:	460b      	mov	r3, r1
340148da:	2201      	movs	r2, #1
340148dc:	e7c1      	b.n	34014862 <ISP_SVC_ISP_SetGain+0x92>
340148de:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
340148e2:	460b      	mov	r3, r1
340148e4:	2201      	movs	r2, #1
340148e6:	e7d8      	b.n	3401489a <ISP_SVC_ISP_SetGain+0xca>
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
340148e8:	2101      	movs	r1, #1
340148ea:	6828      	ldr	r0, [r5, #0]
340148ec:	f7f2 f93e 	bl	34006b6c <HAL_DCMIPP_PIPE_EnableISPExposure>
340148f0:	e78a      	b.n	34014808 <ISP_SVC_ISP_SetGain+0x38>
    return ISP_ERR_ISPGAIN_EINVAL;
340148f2:	2050      	movs	r0, #80	@ 0x50
340148f4:	e7e6      	b.n	340148c4 <ISP_SVC_ISP_SetGain+0xf4>
340148f6:	bf00      	nop
340148f8:	05f5e100 	.word	0x05f5e100
340148fc:	00000000 	.word	0x00000000
34014900:	5f5e1000 	.word	0x5f5e1000

34014904 <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
34014904:	b570      	push	{r4, r5, r6, lr}
34014906:	4605      	mov	r5, r0
34014908:	b088      	sub	sp, #32
3401490a:	460c      	mov	r4, r1
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
3401490c:	221a      	movs	r2, #26
3401490e:	2100      	movs	r1, #0
34014910:	a801      	add	r0, sp, #4
34014912:	f004 f933 	bl	34018b7c <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014916:	b16d      	cbz	r5, 34014934 <ISP_SVC_ISP_SetColorConv+0x30>
34014918:	b164      	cbz	r4, 34014934 <ISP_SVC_ISP_SetColorConv+0x30>
3401491a:	4623      	mov	r3, r4

  for (i = 0; i < 3; i++)
  {
    for (j = 0; j < 3; j++)
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
3401491c:	483a      	ldr	r0, [pc, #232]	@ (34014a08 <ISP_SVC_ISP_SetColorConv+0x104>)
3401491e:	4a3b      	ldr	r2, [pc, #236]	@ (34014a0c <ISP_SVC_ISP_SetColorConv+0x108>)
34014920:	f104 0624 	add.w	r6, r4, #36	@ 0x24
34014924:	6859      	ldr	r1, [r3, #4]
34014926:	4401      	add	r1, r0
34014928:	4291      	cmp	r1, r2
3401492a:	d803      	bhi.n	34014934 <ISP_SVC_ISP_SetColorConv+0x30>
3401492c:	6899      	ldr	r1, [r3, #8]
3401492e:	4401      	add	r1, r0
34014930:	4291      	cmp	r1, r2
34014932:	d901      	bls.n	34014938 <ISP_SVC_ISP_SetColorConv+0x34>
    return ISP_ERR_COLORCONV_EINVAL;
34014934:	205a      	movs	r0, #90	@ 0x5a
34014936:	e05f      	b.n	340149f8 <ISP_SVC_ISP_SetColorConv+0xf4>
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
34014938:	68d9      	ldr	r1, [r3, #12]
3401493a:	4401      	add	r1, r0
3401493c:	4291      	cmp	r1, r2
3401493e:	d8f9      	bhi.n	34014934 <ISP_SVC_ISP_SetColorConv+0x30>
  for (i = 0; i < 3; i++)
34014940:	330c      	adds	r3, #12
34014942:	42b3      	cmp	r3, r6
34014944:	d1ee      	bne.n	34014924 <ISP_SVC_ISP_SetColorConv+0x20>
        return ISP_ERR_COLORCONV_EINVAL;
      }
    }
  }

  if (pConfig->enable == 0)
34014946:	7823      	ldrb	r3, [r4, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014948:	682e      	ldr	r6, [r5, #0]
  if (pConfig->enable == 0)
3401494a:	b933      	cbnz	r3, 3401495a <ISP_SVC_ISP_SetColorConv+0x56>
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3401494c:	2101      	movs	r1, #1
3401494e:	4630      	mov	r0, r6
34014950:	f7f1 ff52 	bl	340067f8 <HAL_DCMIPP_PIPE_DisableISPColorConversion>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014954:	2800      	cmp	r0, #0
34014956:	d04f      	beq.n	340149f8 <ISP_SVC_ISP_SetColorConv+0xf4>
34014958:	e04d      	b.n	340149f6 <ISP_SVC_ISP_SetColorConv+0xf2>
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3401495a:	6860      	ldr	r0, [r4, #4]
3401495c:	2300      	movs	r3, #0
3401495e:	4a2c      	ldr	r2, [pc, #176]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014960:	17c1      	asrs	r1, r0, #31
34014962:	f7ec fdeb 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014966:	f8ad 0006 	strh.w	r0, [sp, #6]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3401496a:	68a0      	ldr	r0, [r4, #8]
3401496c:	2300      	movs	r3, #0
3401496e:	4a28      	ldr	r2, [pc, #160]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014970:	17c1      	asrs	r1, r0, #31
34014972:	f7ec fde3 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014976:	f8ad 0008 	strh.w	r0, [sp, #8]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3401497a:	68e0      	ldr	r0, [r4, #12]
3401497c:	2300      	movs	r3, #0
3401497e:	4a24      	ldr	r2, [pc, #144]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014980:	17c1      	asrs	r1, r0, #31
34014982:	f7ec fddb 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014986:	f8ad 000a 	strh.w	r0, [sp, #10]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3401498a:	6920      	ldr	r0, [r4, #16]
3401498c:	2300      	movs	r3, #0
3401498e:	4a20      	ldr	r2, [pc, #128]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014990:	17c1      	asrs	r1, r0, #31
34014992:	f7ec fdd3 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014996:	f8ad 000e 	strh.w	r0, [sp, #14]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3401499a:	6960      	ldr	r0, [r4, #20]
3401499c:	2300      	movs	r3, #0
3401499e:	4a1c      	ldr	r2, [pc, #112]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
340149a0:	17c1      	asrs	r1, r0, #31
340149a2:	f7ec fdcb 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
340149a6:	f8ad 0010 	strh.w	r0, [sp, #16]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
340149aa:	69a0      	ldr	r0, [r4, #24]
340149ac:	2300      	movs	r3, #0
340149ae:	4a18      	ldr	r2, [pc, #96]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
340149b0:	17c1      	asrs	r1, r0, #31
340149b2:	f7ec fdc3 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
340149b6:	f8ad 0012 	strh.w	r0, [sp, #18]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
340149ba:	69e0      	ldr	r0, [r4, #28]
340149bc:	2300      	movs	r3, #0
340149be:	4a14      	ldr	r2, [pc, #80]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
340149c0:	17c1      	asrs	r1, r0, #31
340149c2:	f7ec fdbb 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
340149c6:	f8ad 0016 	strh.w	r0, [sp, #22]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
340149ca:	6a20      	ldr	r0, [r4, #32]
340149cc:	2300      	movs	r3, #0
340149ce:	4a10      	ldr	r2, [pc, #64]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
340149d0:	17c1      	asrs	r1, r0, #31
340149d2:	f7ec fdb3 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
340149d6:	f8ad 0018 	strh.w	r0, [sp, #24]
  int64_t Val = Coeff;
340149da:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
340149dc:	4a0c      	ldr	r2, [pc, #48]	@ (34014a10 <ISP_SVC_ISP_SetColorConv+0x10c>)
340149de:	2300      	movs	r3, #0
340149e0:	17c1      	asrs	r1, r0, #31
340149e2:	f7ec fdab 	bl	3400153c <__aeabi_ldivmod>
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
340149e6:	2101      	movs	r1, #1
  return (int16_t) Val;
340149e8:	f8ad 001a 	strh.w	r0, [sp, #26]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
340149ec:	aa01      	add	r2, sp, #4
340149ee:	4630      	mov	r0, r6
340149f0:	f7f1 fda8 	bl	34006544 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
    if (halStatus == HAL_OK)
340149f4:	b110      	cbz	r0, 340149fc <ISP_SVC_ISP_SetColorConv+0xf8>
  {
    return ISP_ERR_COLORCONV_HAL;
340149f6:	205b      	movs	r0, #91	@ 0x5b
  }

  return ISP_OK;
}
340149f8:	b008      	add	sp, #32
340149fa:	bd70      	pop	{r4, r5, r6, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
340149fc:	2101      	movs	r1, #1
340149fe:	6828      	ldr	r0, [r5, #0]
34014a00:	f7f1 fee2 	bl	340067c8 <HAL_DCMIPP_PIPE_EnableISPColorConversion>
34014a04:	e7a6      	b.n	34014954 <ISP_SVC_ISP_SetColorConv+0x50>
34014a06:	bf00      	nop
34014a08:	17c841c0 	.word	0x17c841c0
34014a0c:	2f908380 	.word	0x2f908380
34014a10:	0005f5e1 	.word	0x0005f5e1

34014a14 <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
34014a14:	b530      	push	{r4, r5, lr}
34014a16:	460c      	mov	r4, r1
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014a18:	4605      	mov	r5, r0
{
34014a1a:	b089      	sub	sp, #36	@ 0x24
  if ((hIsp == NULL) || (pConfig == NULL))
34014a1c:	2800      	cmp	r0, #0
34014a1e:	d03c      	beq.n	34014a9a <ISP_SVC_ISP_GetColorConv+0x86>
34014a20:	2900      	cmp	r1, #0
34014a22:	d03a      	beq.n	34014a9a <ISP_SVC_ISP_GetColorConv+0x86>
  {
    return ISP_ERR_COLORCONV_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014a24:	2101      	movs	r1, #1
34014a26:	6800      	ldr	r0, [r0, #0]
34014a28:	f7f2 fb26 	bl	34007078 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
34014a2c:	7020      	strb	r0, [r4, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014a2e:	2101      	movs	r1, #1
34014a30:	6828      	ldr	r0, [r5, #0]
34014a32:	aa01      	add	r2, sp, #4
34014a34:	f7f2 fa7e 	bl	34006f34 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a38:	4b19      	ldr	r3, [pc, #100]	@ (34014aa0 <ISP_SVC_ISP_GetColorConv+0x8c>)
  int64_t Val = Reg;
34014a3a:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);

  return ISP_OK;
34014a3e:	2000      	movs	r0, #0
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a40:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a44:	6062      	str	r2, [r4, #4]
  int64_t Val = Reg;
34014a46:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a4a:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a4e:	60a2      	str	r2, [r4, #8]
  int64_t Val = Reg;
34014a50:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a54:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a58:	60e2      	str	r2, [r4, #12]
  int64_t Val = Reg;
34014a5a:	f9bd 200e 	ldrsh.w	r2, [sp, #14]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a5e:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a62:	6122      	str	r2, [r4, #16]
  int64_t Val = Reg;
34014a64:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a68:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a6c:	6162      	str	r2, [r4, #20]
  int64_t Val = Reg;
34014a6e:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a72:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a76:	61a2      	str	r2, [r4, #24]
  int64_t Val = Reg;
34014a78:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a7c:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a80:	61e2      	str	r2, [r4, #28]
  int64_t Val = Reg;
34014a82:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a86:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014a8a:	6222      	str	r2, [r4, #32]
  int64_t Val = Reg;
34014a8c:	f9bd 201a 	ldrsh.w	r2, [sp, #26]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014a90:	fba2 2303 	umull	r2, r3, r2, r3
  return (int32_t) Val;
34014a94:	6262      	str	r2, [r4, #36]	@ 0x24
}
34014a96:	b009      	add	sp, #36	@ 0x24
34014a98:	bd30      	pop	{r4, r5, pc}
    return ISP_ERR_COLORCONV_EINVAL;
34014a9a:	205a      	movs	r0, #90	@ 0x5a
34014a9c:	e7fb      	b.n	34014a96 <ISP_SVC_ISP_GetColorConv+0x82>
34014a9e:	bf00      	nop
34014aa0:	0005f5e1 	.word	0x0005f5e1

34014aa4 <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
34014aa4:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014aa6:	b138      	cbz	r0, 34014ab8 <ISP_SVC_Sensor_GetInfo+0x14>
34014aa8:	b131      	cbz	r1, 34014ab8 <ISP_SVC_Sensor_GetInfo+0x14>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
34014aaa:	6a83      	ldr	r3, [r0, #40]	@ 0x28
34014aac:	b113      	cbz	r3, 34014ab4 <ISP_SVC_Sensor_GetInfo+0x10>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
34014aae:	6840      	ldr	r0, [r0, #4]
34014ab0:	4798      	blx	r3
34014ab2:	b918      	cbnz	r0, 34014abc <ISP_SVC_Sensor_GetInfo+0x18>
    {
      return ISP_ERR_SENSORINFO;
    }
  }

  return ISP_OK;
34014ab4:	2000      	movs	r0, #0
}
34014ab6:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORINFO_EINVAL;
34014ab8:	206e      	movs	r0, #110	@ 0x6e
34014aba:	e7fc      	b.n	34014ab6 <ISP_SVC_Sensor_GetInfo+0x12>
      return ISP_ERR_SENSORINFO;
34014abc:	206f      	movs	r0, #111	@ 0x6f
34014abe:	e7fa      	b.n	34014ab6 <ISP_SVC_Sensor_GetInfo+0x12>

34014ac0 <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34014ac0:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ac2:	b140      	cbz	r0, 34014ad6 <ISP_SVC_Sensor_SetGain+0x16>
34014ac4:	b139      	cbz	r1, 34014ad6 <ISP_SVC_Sensor_SetGain+0x16>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
34014ac6:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
34014ac8:	b11b      	cbz	r3, 34014ad2 <ISP_SVC_Sensor_SetGain+0x12>
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, pConfig->gain) != 0)
34014aca:	6809      	ldr	r1, [r1, #0]
34014acc:	6840      	ldr	r0, [r0, #4]
34014ace:	4798      	blx	r3
34014ad0:	b918      	cbnz	r0, 34014ada <ISP_SVC_Sensor_SetGain+0x1a>
    {
      return ISP_ERR_SENSORGAIN;
    }
  }

  return ISP_OK;
34014ad2:	2000      	movs	r0, #0
}
34014ad4:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORGAIN_EINVAL;
34014ad6:	2078      	movs	r0, #120	@ 0x78
34014ad8:	e7fc      	b.n	34014ad4 <ISP_SVC_Sensor_SetGain+0x14>
      return ISP_ERR_SENSORGAIN;
34014ada:	2079      	movs	r0, #121	@ 0x79
34014adc:	e7fa      	b.n	34014ad4 <ISP_SVC_Sensor_SetGain+0x14>

34014ade <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34014ade:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014ae0:	b138      	cbz	r0, 34014af2 <ISP_SVC_Sensor_GetGain+0x14>
34014ae2:	b131      	cbz	r1, 34014af2 <ISP_SVC_Sensor_GetGain+0x14>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
34014ae4:	6b03      	ldr	r3, [r0, #48]	@ 0x30
34014ae6:	b113      	cbz	r3, 34014aee <ISP_SVC_Sensor_GetGain+0x10>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
34014ae8:	6840      	ldr	r0, [r0, #4]
34014aea:	4798      	blx	r3
34014aec:	b918      	cbnz	r0, 34014af6 <ISP_SVC_Sensor_GetGain+0x18>
    {
      return ISP_ERR_SENSORGAIN;
    }
  }

  return ISP_OK;
34014aee:	2000      	movs	r0, #0
}
34014af0:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORGAIN_EINVAL;
34014af2:	2078      	movs	r0, #120	@ 0x78
34014af4:	e7fc      	b.n	34014af0 <ISP_SVC_Sensor_GetGain+0x12>
      return ISP_ERR_SENSORGAIN;
34014af6:	2079      	movs	r0, #121	@ 0x79
34014af8:	e7fa      	b.n	34014af0 <ISP_SVC_Sensor_GetGain+0x12>

34014afa <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34014afa:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014afc:	b140      	cbz	r0, 34014b10 <ISP_SVC_Sensor_SetExposure+0x16>
34014afe:	b139      	cbz	r1, 34014b10 <ISP_SVC_Sensor_SetExposure+0x16>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
34014b00:	6b43      	ldr	r3, [r0, #52]	@ 0x34
34014b02:	b11b      	cbz	r3, 34014b0c <ISP_SVC_Sensor_SetExposure+0x12>
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, pConfig->exposure) != 0)
34014b04:	6809      	ldr	r1, [r1, #0]
34014b06:	6840      	ldr	r0, [r0, #4]
34014b08:	4798      	blx	r3
34014b0a:	b918      	cbnz	r0, 34014b14 <ISP_SVC_Sensor_SetExposure+0x1a>
    {
      return ISP_ERR_SENSOREXPOSURE;
    }
  }

  return ISP_OK;
34014b0c:	2000      	movs	r0, #0
}
34014b0e:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
34014b10:	2082      	movs	r0, #130	@ 0x82
34014b12:	e7fc      	b.n	34014b0e <ISP_SVC_Sensor_SetExposure+0x14>
      return ISP_ERR_SENSOREXPOSURE;
34014b14:	2083      	movs	r0, #131	@ 0x83
34014b16:	e7fa      	b.n	34014b0e <ISP_SVC_Sensor_SetExposure+0x14>

34014b18 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34014b18:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014b1a:	b138      	cbz	r0, 34014b2c <ISP_SVC_Sensor_GetExposure+0x14>
34014b1c:	b131      	cbz	r1, 34014b2c <ISP_SVC_Sensor_GetExposure+0x14>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
34014b1e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
34014b20:	b113      	cbz	r3, 34014b28 <ISP_SVC_Sensor_GetExposure+0x10>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
34014b22:	6840      	ldr	r0, [r0, #4]
34014b24:	4798      	blx	r3
34014b26:	b918      	cbnz	r0, 34014b30 <ISP_SVC_Sensor_GetExposure+0x18>
    {
      return ISP_ERR_SENSOREXPOSURE;
    }
  }

  return ISP_OK;
34014b28:	2000      	movs	r0, #0
}
34014b2a:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
34014b2c:	2082      	movs	r0, #130	@ 0x82
34014b2e:	e7fc      	b.n	34014b2a <ISP_SVC_Sensor_GetExposure+0x12>
      return ISP_ERR_SENSOREXPOSURE;
34014b30:	2083      	movs	r0, #131	@ 0x83
34014b32:	e7fa      	b.n	34014b2a <ISP_SVC_Sensor_GetExposure+0x12>

34014b34 <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
34014b34:	b508      	push	{r3, lr}
  /* Check handle validity */
  if (hIsp == NULL)
34014b36:	b138      	cbz	r0, 34014b48 <ISP_SVC_Misc_IsDCMIPPReady+0x14>
  {
    return ISP_ERR_EINVAL;
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
34014b38:	6800      	ldr	r0, [r0, #0]
34014b3a:	f7f2 fac3 	bl	340070c4 <HAL_DCMIPP_GetState>
  {
    return ISP_ERR_DCMIPP_STATE;
  }

  return ISP_OK;
34014b3e:	2802      	cmp	r0, #2
34014b40:	bf14      	ite	ne
34014b42:	208c      	movne	r0, #140	@ 0x8c
34014b44:	2000      	moveq	r0, #0
}
34014b46:	bd08      	pop	{r3, pc}
    return ISP_ERR_EINVAL;
34014b48:	2001      	movs	r0, #1
34014b4a:	e7fc      	b.n	34014b46 <ISP_SVC_Misc_IsDCMIPPReady+0x12>

34014b4c <ISP_SVC_Misc_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->MainPipe_FrameCount++;
34014b4c:	6c03      	ldr	r3, [r0, #64]	@ 0x40
34014b4e:	3301      	adds	r3, #1
34014b50:	6403      	str	r3, [r0, #64]	@ 0x40
}
34014b52:	4770      	bx	lr

34014b54 <ISP_SVC_Misc_GetMainFrameId>:
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
  return hIsp->MainPipe_FrameCount;
}
34014b54:	6c00      	ldr	r0, [r0, #64]	@ 0x40
34014b56:	4770      	bx	lr

34014b58 <ISP_SVC_Misc_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->AncillaryPipe_FrameCount++;
34014b58:	6c43      	ldr	r3, [r0, #68]	@ 0x44
34014b5a:	3301      	adds	r3, #1
34014b5c:	6443      	str	r3, [r0, #68]	@ 0x44
}
34014b5e:	4770      	bx	lr

34014b60 <ISP_SVC_Misc_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->DumpPipe_FrameCount++;
34014b60:	6c83      	ldr	r3, [r0, #72]	@ 0x48
34014b62:	3301      	adds	r3, #1
34014b64:	6483      	str	r3, [r0, #72]	@ 0x48
}
34014b66:	4770      	bx	lr

34014b68 <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
34014b68:	b508      	push	{r3, lr}
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
34014b6a:	b168      	cbz	r0, 34014b88 <ISP_SVC_Misc_IsGammaEnabled+0x20>
  {
    return ISP_ERR_EINVAL;
  }

  switch(Pipe)
34014b6c:	2901      	cmp	r1, #1
34014b6e:	d006      	beq.n	34014b7e <ISP_SVC_Misc_IsGammaEnabled+0x16>
34014b70:	2902      	cmp	r1, #2
34014b72:	d004      	beq.n	34014b7e <ISP_SVC_Misc_IsGammaEnabled+0x16>
34014b74:	2000      	movs	r0, #0
    break;
  default:
    ret = 0; /*  No gamma on pipe 0 */
  }

  return ret;
34014b76:	3800      	subs	r0, #0
34014b78:	bf18      	it	ne
34014b7a:	2001      	movne	r0, #1
}
34014b7c:	bd08      	pop	{r3, pc}
    ret = HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
34014b7e:	6800      	ldr	r0, [r0, #0]
34014b80:	f7f1 fb34 	bl	340061ec <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
34014b84:	b2c0      	uxtb	r0, r0
    break;
34014b86:	e7f6      	b.n	34014b76 <ISP_SVC_Misc_IsGammaEnabled+0xe>
    return ISP_ERR_EINVAL;
34014b88:	2001      	movs	r0, #1
34014b8a:	e7f7      	b.n	34014b7c <ISP_SVC_Misc_IsGammaEnabled+0x14>

34014b8c <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
34014b8c:	b538      	push	{r3, r4, r5, lr}
34014b8e:	460d      	mov	r5, r1
  if ((hIsp == NULL) || (pConfig == NULL))
34014b90:	4604      	mov	r4, r0
34014b92:	b908      	cbnz	r0, 34014b98 <ISP_SVC_ISP_SetGamma+0xc>
  {
    return ISP_ERR_DCMIPP_GAMMA;
34014b94:	2095      	movs	r0, #149	@ 0x95
      return ISP_ERR_DCMIPP_GAMMA;
    }
  }

  return ISP_OK;
}
34014b96:	bd38      	pop	{r3, r4, r5, pc}
  if ((hIsp == NULL) || (pConfig == NULL))
34014b98:	2900      	cmp	r1, #0
34014b9a:	d0fb      	beq.n	34014b94 <ISP_SVC_ISP_SetGamma+0x8>
  if (pConfig->enablePipe1 == 0)
34014b9c:	780b      	ldrb	r3, [r1, #0]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014b9e:	6800      	ldr	r0, [r0, #0]
34014ba0:	2101      	movs	r1, #1
  if (pConfig->enablePipe1 == 0)
34014ba2:	b953      	cbnz	r3, 34014bba <ISP_SVC_ISP_SetGamma+0x2e>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014ba4:	f7f1 fb00 	bl	340061a8 <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014ba8:	2800      	cmp	r0, #0
34014baa:	d1f3      	bne.n	34014b94 <ISP_SVC_ISP_SetGamma+0x8>
  if (pConfig->enablePipe2 == 0)
34014bac:	786b      	ldrb	r3, [r5, #1]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014bae:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enablePipe2 == 0)
34014bb0:	b133      	cbz	r3, 34014bc0 <ISP_SVC_ISP_SetGamma+0x34>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014bb2:	2102      	movs	r1, #2
34014bb4:	f7f1 fad6 	bl	34006164 <HAL_DCMIPP_PIPE_EnableGammaConversion>
34014bb8:	e005      	b.n	34014bc6 <ISP_SVC_ISP_SetGamma+0x3a>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014bba:	f7f1 fad3 	bl	34006164 <HAL_DCMIPP_PIPE_EnableGammaConversion>
34014bbe:	e7f3      	b.n	34014ba8 <ISP_SVC_ISP_SetGamma+0x1c>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014bc0:	2102      	movs	r1, #2
34014bc2:	f7f1 faf1 	bl	340061a8 <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014bc6:	2800      	cmp	r0, #0
34014bc8:	d1e4      	bne.n	34014b94 <ISP_SVC_ISP_SetGamma+0x8>
  return ISP_OK;
34014bca:	2000      	movs	r0, #0
34014bcc:	e7e3      	b.n	34014b96 <ISP_SVC_ISP_SetGamma+0xa>
	...

34014bd0 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
34014bd0:	b508      	push	{r3, lr}
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
34014bd2:	f44f 7215 	mov.w	r2, #596	@ 0x254
34014bd6:	4802      	ldr	r0, [pc, #8]	@ (34014be0 <ISP_SVC_IQParam_Init+0x10>)
34014bd8:	f004 fa67 	bl	340190aa <memcpy>
  return ISP_OK;
}
34014bdc:	2000      	movs	r0, #0
34014bde:	bd08      	pop	{r3, pc}
34014be0:	340442f4 	.word	0x340442f4

34014be4 <ISP_SVC_IQParam_Get>:
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
}
34014be4:	4800      	ldr	r0, [pc, #0]	@ (34014be8 <ISP_SVC_IQParam_Get+0x4>)
34014be6:	4770      	bx	lr
34014be8:	340442f4 	.word	0x340442f4

34014bec <ISP_SVC_Stats_Init>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
34014bec:	f44f 72b0 	mov.w	r2, #352	@ 0x160
34014bf0:	2100      	movs	r1, #0
34014bf2:	4801      	ldr	r0, [pc, #4]	@ (34014bf8 <ISP_SVC_Stats_Init+0xc>)
34014bf4:	f003 bfc2 	b.w	34018b7c <memset>
34014bf8:	34044194 	.word	0x34044194

34014bfc <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
34014bfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t i, avgR, avgG, avgB, frameId;

  /* Check handle validity */
  if (hIsp == NULL)
34014c00:	4605      	mov	r5, r0
{
34014c02:	b08d      	sub	sp, #52	@ 0x34
  if (hIsp == NULL)
34014c04:	b928      	cbnz	r0, 34014c12 <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
34014c06:	48aa      	ldr	r0, [pc, #680]	@ (34014eb0 <ISP_SVC_Stats_Gather+0x2b4>)

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
  stagePrevious1 = ISP_SVC_StatEngine.stage;
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
}
34014c08:	b00d      	add	sp, #52	@ 0x34
34014c0a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    printf("ERROR: ISP handle is NULL\r\n");
34014c0e:	f003 be49 	b.w	340188a4 <puts>
  if (hIsp->hDcmipp == NULL)
34014c12:	6800      	ldr	r0, [r0, #0]
34014c14:	2800      	cmp	r0, #0
34014c16:	f000 80b4 	beq.w	34014d82 <ISP_SVC_Stats_Gather+0x186>
  switch(stagePrevious2)
34014c1a:	f8df 92f0 	ldr.w	r9, [pc, #752]	@ 34014f0c <ISP_SVC_Stats_Gather+0x310>
34014c1e:	4ca5      	ldr	r4, [pc, #660]	@ (34014eb4 <ISP_SVC_Stats_Gather+0x2b8>)
34014c20:	f899 3000 	ldrb.w	r3, [r9]
34014c24:	2b09      	cmp	r3, #9
34014c26:	d836      	bhi.n	34014c96 <ISP_SVC_Stats_Gather+0x9a>
34014c28:	e8df f003 	tbb	[pc, r3]
34014c2c:	46443f05 	.word	0x46443f05
34014c30:	89874a48 	.word	0x89874a48
34014c34:	8d8b      	.short	0x8d8b
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34014c36:	2201      	movs	r2, #1
34014c38:	466b      	mov	r3, sp
34014c3a:	4611      	mov	r1, r2
34014c3c:	f7f2 f948 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
34014c40:	2202      	movs	r2, #2
34014c42:	2101      	movs	r1, #1
34014c44:	ab01      	add	r3, sp, #4
34014c46:	6828      	ldr	r0, [r5, #0]
34014c48:	f7f2 f942 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
34014c4c:	2203      	movs	r2, #3
34014c4e:	2101      	movs	r1, #1
34014c50:	ab02      	add	r3, sp, #8
34014c52:	6828      	ldr	r0, [r5, #0]
34014c54:	f7f2 f93c 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34014c58:	2101      	movs	r1, #1
34014c5a:	2200      	movs	r2, #0
34014c5c:	9b00      	ldr	r3, [sp, #0]
34014c5e:	4628      	mov	r0, r5
34014c60:	f7ff fb96 	bl	34014390 <GetAvgStats>
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014c64:	460a      	mov	r2, r1
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34014c66:	4606      	mov	r6, r0
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014c68:	9b01      	ldr	r3, [sp, #4]
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34014c6a:	f884 007c 	strb.w	r0, [r4, #124]	@ 0x7c
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014c6e:	4628      	mov	r0, r5
34014c70:	f7ff fb8e 	bl	34014390 <GetAvgStats>
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34014c74:	2202      	movs	r2, #2
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014c76:	4607      	mov	r7, r0
34014c78:	f884 007d 	strb.w	r0, [r4, #125]	@ 0x7d
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34014c7c:	9b02      	ldr	r3, [sp, #8]
34014c7e:	4628      	mov	r0, r5
34014c80:	f7ff fb86 	bl	34014390 <GetAvgStats>
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
34014c84:	4639      	mov	r1, r7
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34014c86:	4602      	mov	r2, r0
34014c88:	f884 007e 	strb.w	r0, [r4, #126]	@ 0x7e
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
34014c8c:	4630      	mov	r0, r6
34014c8e:	f7ff fbc3 	bl	34014418 <LuminanceFromRGB>
34014c92:	f884 007f 	strb.w	r0, [r4, #127]	@ 0x7f
  switch(ISP_SVC_StatEngine.stage)
34014c96:	7823      	ldrb	r3, [r4, #0]
34014c98:	2b09      	cmp	r3, #9
34014c9a:	d863      	bhi.n	34014d64 <ISP_SVC_Stats_Gather+0x168>
34014c9c:	e8df f003 	tbb	[pc, r3]
34014ca0:	86847f74 	.word	0x86847f74
34014ca4:	8c8a5588 	.word	0x8c8a5588
34014ca8:	908e      	.short	0x908e
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
34014caa:	4983      	ldr	r1, [pc, #524]	@ (34014eb8 <ISP_SVC_Stats_Gather+0x2bc>)
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
34014cac:	4628      	mov	r0, r5
34014cae:	f7ff fba0 	bl	340143f2 <ReadStatHistogram>
    break;
34014cb2:	e7f0      	b.n	34014c96 <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
34014cb4:	4981      	ldr	r1, [pc, #516]	@ (34014ebc <ISP_SVC_Stats_Gather+0x2c0>)
34014cb6:	e7f9      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
34014cb8:	4981      	ldr	r1, [pc, #516]	@ (34014ec0 <ISP_SVC_Stats_Gather+0x2c4>)
34014cba:	e7f7      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
34014cbc:	4981      	ldr	r1, [pc, #516]	@ (34014ec4 <ISP_SVC_Stats_Gather+0x2c8>)
34014cbe:	e7f5      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34014cc0:	2201      	movs	r2, #1
34014cc2:	466b      	mov	r3, sp
34014cc4:	4611      	mov	r1, r2
34014cc6:	f7f2 f903 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
34014cca:	2202      	movs	r2, #2
34014ccc:	2101      	movs	r1, #1
34014cce:	ab01      	add	r3, sp, #4
34014cd0:	6828      	ldr	r0, [r5, #0]
34014cd2:	f7f2 f8fd 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
34014cd6:	2203      	movs	r2, #3
34014cd8:	2101      	movs	r1, #1
34014cda:	ab02      	add	r3, sp, #8
34014cdc:	6828      	ldr	r0, [r5, #0]
34014cde:	f7f2 f8f7 	bl	34006ed0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34014ce2:	2102      	movs	r1, #2
34014ce4:	2200      	movs	r2, #0
34014ce6:	9b00      	ldr	r3, [sp, #0]
34014ce8:	4628      	mov	r0, r5
34014cea:	f7ff fb51 	bl	34014390 <GetAvgStats>
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34014cee:	2201      	movs	r2, #1
34014cf0:	9b01      	ldr	r3, [sp, #4]
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34014cf2:	f884 00b0 	strb.w	r0, [r4, #176]	@ 0xb0
34014cf6:	4607      	mov	r7, r0
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34014cf8:	4628      	mov	r0, r5
34014cfa:	f7ff fb49 	bl	34014390 <GetAvgStats>
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34014cfe:	460a      	mov	r2, r1
34014d00:	9b02      	ldr	r3, [sp, #8]
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34014d02:	f884 00b1 	strb.w	r0, [r4, #177]	@ 0xb1
34014d06:	4606      	mov	r6, r0
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34014d08:	4628      	mov	r0, r5
34014d0a:	f7ff fb41 	bl	34014390 <GetAvgStats>
34014d0e:	f884 00b2 	strb.w	r0, [r4, #178]	@ 0xb2
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34014d12:	f895 306c 	ldrb.w	r3, [r5, #108]	@ 0x6c
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34014d16:	4602      	mov	r2, r0
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34014d18:	2b04      	cmp	r3, #4
34014d1a:	d002      	beq.n	34014d22 <ISP_SVC_Stats_Gather+0x126>
34014d1c:	4b6a      	ldr	r3, [pc, #424]	@ (34014ec8 <ISP_SVC_Stats_Gather+0x2cc>)
34014d1e:	7b1b      	ldrb	r3, [r3, #12]
34014d20:	b923      	cbnz	r3, 34014d2c <ISP_SVC_Stats_Gather+0x130>
  return r + g + b;
34014d22:	443e      	add	r6, r7
34014d24:	4432      	add	r2, r6
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34014d26:	f884 20b3 	strb.w	r2, [r4, #179]	@ 0xb3
34014d2a:	e7b4      	b.n	34014c96 <ISP_SVC_Stats_Gather+0x9a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34014d2c:	4631      	mov	r1, r6
34014d2e:	4638      	mov	r0, r7
34014d30:	f7ff fb72 	bl	34014418 <LuminanceFromRGB>
34014d34:	f884 00b3 	strb.w	r0, [r4, #179]	@ 0xb3
34014d38:	e7ad      	b.n	34014c96 <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
34014d3a:	4964      	ldr	r1, [pc, #400]	@ (34014ecc <ISP_SVC_Stats_Gather+0x2d0>)
34014d3c:	e7b6      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
34014d3e:	4964      	ldr	r1, [pc, #400]	@ (34014ed0 <ISP_SVC_Stats_Gather+0x2d4>)
34014d40:	e7b4      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
34014d42:	4964      	ldr	r1, [pc, #400]	@ (34014ed4 <ISP_SVC_Stats_Gather+0x2d8>)
34014d44:	e7b2      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
34014d46:	4964      	ldr	r1, [pc, #400]	@ (34014ed8 <ISP_SVC_Stats_Gather+0x2dc>)
34014d48:	e7b0      	b.n	34014cac <ISP_SVC_Stats_Gather+0xb0>
      statConf[i].Source = avgRGBDown[i];
34014d4a:	2300      	movs	r3, #0
34014d4c:	2240      	movs	r2, #64	@ 0x40
34014d4e:	e9cd 3203 	strd	r3, r2, [sp, #12]
34014d52:	2250      	movs	r2, #80	@ 0x50
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34014d54:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Source = avgRGBDown[i];
34014d58:	2260      	movs	r2, #96	@ 0x60
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014d5a:	e9cd 3305 	strd	r3, r3, [sp, #20]
34014d5e:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34014d60:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
{
34014d64:	f04f 0801 	mov.w	r8, #1
34014d68:	af03      	add	r7, sp, #12
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
34014d6a:	fa5f f688 	uxtb.w	r6, r8
34014d6e:	463b      	mov	r3, r7
34014d70:	4632      	mov	r2, r6
34014d72:	2101      	movs	r1, #1
34014d74:	6828      	ldr	r0, [r5, #0]
34014d76:	f7f1 fda9 	bl	340068cc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
34014d7a:	b318      	cbz	r0, 34014dc4 <ISP_SVC_Stats_Gather+0x1c8>
      printf("ERROR: can't set Statistic Extraction config\r\n");
34014d7c:	4857      	ldr	r0, [pc, #348]	@ (34014edc <ISP_SVC_Stats_Gather+0x2e0>)
      printf("ERROR: can't enable Statistic Extraction config\r\n");
34014d7e:	f003 fd91 	bl	340188a4 <puts>
}
34014d82:	b00d      	add	sp, #52	@ 0x34
34014d84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014d88:	2300      	movs	r3, #0
      statConf[i].Source = avgRGBUp[i];
34014d8a:	2210      	movs	r2, #16
34014d8c:	e9cd 3303 	strd	r3, r3, [sp, #12]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34014d90:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014d94:	e9cd 3305 	strd	r3, r3, [sp, #20]
      statConf[i].Source = avgRGBUp[i];
34014d98:	2220      	movs	r2, #32
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014d9a:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Source = avgRGBUp[i];
34014d9c:	e7e0      	b.n	34014d60 <ISP_SVC_Stats_Gather+0x164>
    SetStatConfig(statConf, &statConfUpBins_0_2);
34014d9e:	4950      	ldr	r1, [pc, #320]	@ (34014ee0 <ISP_SVC_Stats_Gather+0x2e4>)
    SetStatConfig(statConf, &statConfDownBins_9_11);
34014da0:	a803      	add	r0, sp, #12
34014da2:	f7ff fb17 	bl	340143d4 <SetStatConfig>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014da6:	e7dd      	b.n	34014d64 <ISP_SVC_Stats_Gather+0x168>
    SetStatConfig(statConf, &statConfUpBins_3_5);
34014da8:	494e      	ldr	r1, [pc, #312]	@ (34014ee4 <ISP_SVC_Stats_Gather+0x2e8>)
34014daa:	e7f9      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfUpBins_6_8);
34014dac:	494e      	ldr	r1, [pc, #312]	@ (34014ee8 <ISP_SVC_Stats_Gather+0x2ec>)
34014dae:	e7f7      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfUpBins_9_11);
34014db0:	494e      	ldr	r1, [pc, #312]	@ (34014eec <ISP_SVC_Stats_Gather+0x2f0>)
34014db2:	e7f5      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_0_2);
34014db4:	494e      	ldr	r1, [pc, #312]	@ (34014ef0 <ISP_SVC_Stats_Gather+0x2f4>)
34014db6:	e7f3      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_3_5);
34014db8:	494e      	ldr	r1, [pc, #312]	@ (34014ef4 <ISP_SVC_Stats_Gather+0x2f8>)
34014dba:	e7f1      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_6_8);
34014dbc:	494e      	ldr	r1, [pc, #312]	@ (34014ef8 <ISP_SVC_Stats_Gather+0x2fc>)
34014dbe:	e7ef      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_9_11);
34014dc0:	494e      	ldr	r1, [pc, #312]	@ (34014efc <ISP_SVC_Stats_Gather+0x300>)
34014dc2:	e7ed      	b.n	34014da0 <ISP_SVC_Stats_Gather+0x1a4>
    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
34014dc4:	4632      	mov	r2, r6
34014dc6:	2101      	movs	r1, #1
34014dc8:	6828      	ldr	r0, [r5, #0]
34014dca:	f7f1 fe37 	bl	34006a3c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
34014dce:	4606      	mov	r6, r0
34014dd0:	b108      	cbz	r0, 34014dd6 <ISP_SVC_Stats_Gather+0x1da>
      printf("ERROR: can't enable Statistic Extraction config\r\n");
34014dd2:	484b      	ldr	r0, [pc, #300]	@ (34014f00 <ISP_SVC_Stats_Gather+0x304>)
34014dd4:	e7d3      	b.n	34014d7e <ISP_SVC_Stats_Gather+0x182>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014dd6:	f108 0801 	add.w	r8, r8, #1
34014dda:	f1b8 0f04 	cmp.w	r8, #4
34014dde:	f107 070c 	add.w	r7, r7, #12
34014de2:	d1c2      	bne.n	34014d6a <ISP_SVC_Stats_Gather+0x16e>
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34014de4:	f894 8158 	ldrb.w	r8, [r4, #344]	@ 0x158
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34014de8:	f899 b000 	ldrb.w	fp, [r9]
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34014dec:	f018 0f05 	tst.w	r8, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34014df0:	bf0c      	ite	eq
34014df2:	2301      	moveq	r3, #1
34014df4:	2300      	movne	r3, #0
  return hIsp->MainPipe_FrameCount;
34014df6:	f8d5 a040 	ldr.w	sl, [r5, #64]	@ 0x40
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34014dfa:	f894 7159 	ldrb.w	r7, [r4, #345]	@ 0x159
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34014dfe:	455b      	cmp	r3, fp
    ongoing->upFrameIdStart = frameId;
34014e00:	bf08      	it	eq
34014e02:	f8c4 a0e4 	streq.w	sl, [r4, #228]	@ 0xe4
      stage = ISP_STAT_CFG_DOWN_AVG;
34014e06:	f017 0f05 	tst.w	r7, #5
34014e0a:	bf0c      	ite	eq
34014e0c:	2306      	moveq	r3, #6
34014e0e:	2305      	movne	r3, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
34014e10:	459b      	cmp	fp, r3
34014e12:	d17d      	bne.n	34014f10 <ISP_SVC_Stats_Gather+0x314>
    ongoing->downFrameIdStart = frameId;
34014e14:	f8c4 a0ec 	str.w	sl, [r4, #236]	@ 0xec
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
34014e18:	f017 0f06 	tst.w	r7, #6
34014e1c:	bf0c      	ite	eq
34014e1e:	2305      	moveq	r3, #5
34014e20:	2309      	movne	r3, #9
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
34014e22:	459b      	cmp	fp, r3
34014e24:	d11e      	bne.n	34014e64 <ISP_SVC_Stats_Gather+0x268>
34014e26:	f8d4 e0ec 	ldr.w	lr, [r4, #236]	@ 0xec
34014e2a:	f1be 0f00 	cmp.w	lr, #0
34014e2e:	d019      	beq.n	34014e64 <ISP_SVC_Stats_Gather+0x268>
    ISP_SVC_StatEngine.last.down = ongoing->down;
34014e30:	4d34      	ldr	r5, [pc, #208]	@ (34014f04 <ISP_SVC_Stats_Gather+0x308>)
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
34014e32:	e9c4 ea1d 	strd	lr, sl, [r4, #116]	@ 0x74
    ISP_SVC_StatEngine.last.down = ongoing->down;
34014e36:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
34014e3a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014e3e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014e40:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014e44:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014e46:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014e4a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014e4c:	4628      	mov	r0, r5
34014e4e:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->down, 0, sizeof(ongoing->down));
34014e52:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.down = ongoing->down;
34014e54:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->down, 0, sizeof(ongoing->down));
34014e58:	2100      	movs	r1, #0
34014e5a:	f003 fe8f 	bl	34018b7c <memset>
    ongoing->downFrameIdStart = 0;
34014e5e:	2300      	movs	r3, #0
    ongoing->downFrameIdEnd = 0;
34014e60:	e9c4 333b 	strd	r3, r3, [r4, #236]	@ 0xec
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014e64:	ea48 0307 	orr.w	r3, r8, r7
34014e68:	075a      	lsls	r2, r3, #29
34014e6a:	d50b      	bpl.n	34014e84 <ISP_SVC_Stats_Gather+0x288>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
34014e6c:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
34014e70:	4553      	cmp	r3, sl
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014e72:	bf3f      	itttt	cc
34014e74:	f028 0804 	biccc.w	r8, r8, #4
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014e78:	f027 0704 	biccc.w	r7, r7, #4
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014e7c:	f884 8158 	strbcc.w	r8, [r4, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014e80:	f884 7159 	strbcc.w	r7, [r4, #345]	@ 0x159
  stagePrevious2 = stagePrevious1;
34014e84:	4b20      	ldr	r3, [pc, #128]	@ (34014f08 <ISP_SVC_Stats_Gather+0x30c>)
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014e86:	f894 1158 	ldrb.w	r1, [r4, #344]	@ 0x158
  stagePrevious2 = stagePrevious1;
34014e8a:	781a      	ldrb	r2, [r3, #0]
34014e8c:	f889 2000 	strb.w	r2, [r9]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
34014e90:	7822      	ldrb	r2, [r4, #0]
34014e92:	701a      	strb	r2, [r3, #0]
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014e94:	074b      	lsls	r3, r1, #29
34014e96:	d403      	bmi.n	34014ea0 <ISP_SVC_Stats_Gather+0x2a4>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34014e98:	f894 3159 	ldrb.w	r3, [r4, #345]	@ 0x159
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014e9c:	075f      	lsls	r7, r3, #29
34014e9e:	d561      	bpl.n	34014f64 <ISP_SVC_Stats_Gather+0x368>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
34014ea0:	1c53      	adds	r3, r2, #1
34014ea2:	b2db      	uxtb	r3, r3
34014ea4:	2a09      	cmp	r2, #9
34014ea6:	bf38      	it	cc
34014ea8:	461e      	movcc	r6, r3
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
34014eaa:	7026      	strb	r6, [r4, #0]
34014eac:	e769      	b.n	34014d82 <ISP_SVC_Stats_Gather+0x186>
34014eae:	bf00      	nop
34014eb0:	3401cf21 	.word	0x3401cf21
34014eb4:	34044194 	.word	0x34044194
34014eb8:	34044214 	.word	0x34044214
34014ebc:	34044220 	.word	0x34044220
34014ec0:	3404422c 	.word	0x3404422c
34014ec4:	34044238 	.word	0x34044238
34014ec8:	340442f4 	.word	0x340442f4
34014ecc:	34044248 	.word	0x34044248
34014ed0:	34044254 	.word	0x34044254
34014ed4:	34044260 	.word	0x34044260
34014ed8:	3404426c 	.word	0x3404426c
34014edc:	3401cf3c 	.word	0x3401cf3c
34014ee0:	3403b5f0 	.word	0x3403b5f0
34014ee4:	3403b5e4 	.word	0x3403b5e4
34014ee8:	3403b5d8 	.word	0x3403b5d8
34014eec:	3403b5cc 	.word	0x3403b5cc
34014ef0:	3403b5c0 	.word	0x3403b5c0
34014ef4:	3403b5b4 	.word	0x3403b5b4
34014ef8:	3403b5a8 	.word	0x3403b5a8
34014efc:	3403b59c 	.word	0x3403b59c
34014f00:	3401cf6a 	.word	0x3401cf6a
34014f04:	340441cc 	.word	0x340441cc
34014f08:	3403edc4 	.word	0x3403edc4
34014f0c:	3403edc5 	.word	0x3403edc5
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34014f10:	f018 0f06 	tst.w	r8, #6
34014f14:	bf14      	ite	ne
34014f16:	2301      	movne	r3, #1
34014f18:	2300      	moveq	r3, #0
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
34014f1a:	ebbb 0f83 	cmp.w	fp, r3, lsl #2
34014f1e:	f47f af7b 	bne.w	34014e18 <ISP_SVC_Stats_Gather+0x21c>
34014f22:	f8d4 e0e4 	ldr.w	lr, [r4, #228]	@ 0xe4
34014f26:	f1be 0f00 	cmp.w	lr, #0
34014f2a:	f43f af75 	beq.w	34014e18 <ISP_SVC_Stats_Gather+0x21c>
    ISP_SVC_StatEngine.last.up = ongoing->up;
34014f2e:	4d2f      	ldr	r5, [pc, #188]	@ (34014fec <ISP_SVC_Stats_Gather+0x3f0>)
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
34014f30:	e9c4 ea1b 	strd	lr, sl, [r4, #108]	@ 0x6c
    ISP_SVC_StatEngine.last.up = ongoing->up;
34014f34:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
34014f38:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014f3c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014f3e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014f42:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014f44:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014f48:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014f4a:	4628      	mov	r0, r5
34014f4c:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->up, 0, sizeof(ongoing->up));
34014f50:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.up = ongoing->up;
34014f52:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->up, 0, sizeof(ongoing->up));
34014f56:	2100      	movs	r1, #0
34014f58:	f003 fe10 	bl	34018b7c <memset>
    ongoing->upFrameIdStart = 0;
34014f5c:	2300      	movs	r3, #0
    ongoing->upFrameIdEnd = 0;
34014f5e:	e9c4 3339 	strd	r3, r3, [r4, #228]	@ 0xe4
34014f62:	e759      	b.n	34014e18 <ISP_SVC_Stats_Gather+0x21c>
  switch (current)
34014f64:	2a09      	cmp	r2, #9
34014f66:	d836      	bhi.n	34014fd6 <ISP_SVC_Stats_Gather+0x3da>
34014f68:	e8df f002 	tbb	[pc, r2]
34014f6c:	35353505 	.word	0x35353505
34014f70:	35351d11 	.word	0x35351d11
34014f74:	2a35      	.short	0x2a35
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34014f76:	078d      	lsls	r5, r1, #30
34014f78:	d434      	bmi.n	34014fe4 <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
34014f7a:	07d8      	lsls	r0, r3, #31
34014f7c:	d434      	bmi.n	34014fe8 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34014f7e:	f013 0602 	ands.w	r6, r3, #2
34014f82:	d12b      	bne.n	34014fdc <ISP_SVC_Stats_Gather+0x3e0>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34014f84:	f011 0f01 	tst.w	r1, #1
34014f88:	bf08      	it	eq
34014f8a:	2609      	moveq	r6, #9
34014f8c:	e78d      	b.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34014f8e:	07da      	lsls	r2, r3, #31
34014f90:	d42a      	bmi.n	34014fe8 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34014f92:	f013 0602 	ands.w	r6, r3, #2
34014f96:	d121      	bne.n	34014fdc <ISP_SVC_Stats_Gather+0x3e0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34014f98:	07cb      	lsls	r3, r1, #31
34014f9a:	d486      	bmi.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34014f9c:	f011 0f02 	tst.w	r1, #2
34014fa0:	bf18      	it	ne
34014fa2:	2601      	movne	r6, #1
34014fa4:	e7f0      	b.n	34014f88 <ISP_SVC_Stats_Gather+0x38c>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34014fa6:	f013 0602 	ands.w	r6, r3, #2
34014faa:	d117      	bne.n	34014fdc <ISP_SVC_Stats_Gather+0x3e0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34014fac:	07cf      	lsls	r7, r1, #31
34014fae:	f53f af7c 	bmi.w	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34014fb2:	078d      	lsls	r5, r1, #30
34014fb4:	d416      	bmi.n	34014fe4 <ISP_SVC_Stats_Gather+0x3e8>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34014fb6:	f013 0f01 	tst.w	r3, #1
34014fba:	bf18      	it	ne
34014fbc:	4616      	movne	r6, r2
34014fbe:	e7e3      	b.n	34014f88 <ISP_SVC_Stats_Gather+0x38c>
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34014fc0:	07c8      	lsls	r0, r1, #31
34014fc2:	d40d      	bmi.n	34014fe0 <ISP_SVC_Stats_Gather+0x3e4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34014fc4:	0789      	lsls	r1, r1, #30
34014fc6:	d40d      	bmi.n	34014fe4 <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34014fc8:	07da      	lsls	r2, r3, #31
34014fca:	d40d      	bmi.n	34014fe8 <ISP_SVC_Stats_Gather+0x3ec>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34014fcc:	f013 0f02 	tst.w	r3, #2
34014fd0:	bf18      	it	ne
34014fd2:	2606      	movne	r6, #6
34014fd4:	e7d8      	b.n	34014f88 <ISP_SVC_Stats_Gather+0x38c>
    next = (ISP_SVC_StatEngineStage) (current + 1);
34014fd6:	3201      	adds	r2, #1
34014fd8:	b2d6      	uxtb	r6, r2
    break;
34014fda:	e766      	b.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34014fdc:	2606      	movs	r6, #6
34014fde:	e764      	b.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
34014fe0:	2600      	movs	r6, #0
34014fe2:	e762      	b.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_UP_BINS_0_2;
34014fe4:	2601      	movs	r6, #1
34014fe6:	e760      	b.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_DOWN_AVG;
34014fe8:	2605      	movs	r6, #5
34014fea:	e75e      	b.n	34014eaa <ISP_SVC_Stats_Gather+0x2ae>
34014fec:	34044198 	.word	0x34044198

34014ff0 <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
34014ff0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
34014ff4:	2500      	movs	r5, #0
34014ff6:	4c1c      	ldr	r4, [pc, #112]	@ (34015068 <ISP_SVC_Stats_ProcessCallbacks+0x78>)
{
34014ff8:	2705      	movs	r7, #5
34014ffa:	4626      	mov	r6, r4
      {
        ret = retcb;
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
34014ffc:	46a9      	mov	r9, r5
      *(client->pStats) = *pLastStat;
34014ffe:	f104 0804 	add.w	r8, r4, #4
    if (client->callback == NULL)
34015002:	f8d4 a0f4 	ldr.w	sl, [r4, #244]	@ 0xf4
34015006:	f1ba 0f00 	cmp.w	sl, #0
3401500a:	d016      	beq.n	3401503a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3401500c:	f894 3104 	ldrb.w	r3, [r4, #260]	@ 0x104
34015010:	2b02      	cmp	r3, #2
34015012:	d119      	bne.n	34015048 <ISP_SVC_Stats_ProcessCallbacks+0x58>
34015014:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
34015018:	6f73      	ldr	r3, [r6, #116]	@ 0x74
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3401501a:	429a      	cmp	r2, r3
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
3401501c:	d80d      	bhi.n	3401503a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
      *(client->pStats) = *pLastStat;
3401501e:	2278      	movs	r2, #120	@ 0x78
34015020:	4641      	mov	r1, r8
34015022:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
34015026:	f004 f840 	bl	340190aa <memcpy>
      retcb = client->callback(client->pAlgo);
3401502a:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
3401502e:	47d0      	blx	sl
      if (retcb != ISP_OK)
34015030:	2800      	cmp	r0, #0
      client->callback = NULL;
34015032:	bf18      	it	ne
34015034:	4605      	movne	r5, r0
34015036:	f8c4 90f4 	str.w	r9, [r4, #244]	@ 0xf4
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3401503a:	3f01      	subs	r7, #1
3401503c:	f104 0414 	add.w	r4, r4, #20
34015040:	d1df      	bne.n	34015002 <ISP_SVC_Stats_ProcessCallbacks+0x12>
    }
  }

  return ret;
}
34015042:	4628      	mov	r0, r5
34015044:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
34015048:	2b01      	cmp	r3, #1
3401504a:	d103      	bne.n	34015054 <ISP_SVC_Stats_ProcessCallbacks+0x64>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3401504c:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
34015050:	6ef3      	ldr	r3, [r6, #108]	@ 0x6c
34015052:	e7e2      	b.n	3401501a <ISP_SVC_Stats_ProcessCallbacks+0x2a>
34015054:	2b03      	cmp	r3, #3
34015056:	d1f0      	bne.n	3401503a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
34015058:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3401505c:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
3401505e:	4293      	cmp	r3, r2
34015060:	d8eb      	bhi.n	3401503a <ISP_SVC_Stats_ProcessCallbacks+0x4a>
34015062:	6f72      	ldr	r2, [r6, #116]	@ 0x74
34015064:	4293      	cmp	r3, r2
34015066:	e7d9      	b.n	3401501c <ISP_SVC_Stats_ProcessCallbacks+0x2c>
34015068:	34044194 	.word	0x34044194

3401506c <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
3401506c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34015070:	4691      	mov	r9, r2
34015072:	f89d c01c 	ldrb.w	ip, [sp, #28]
34015076:	f89d 5020 	ldrb.w	r5, [sp, #32]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
3401507a:	b1b0      	cbz	r0, 340150aa <ISP_SVC_Stats_GetNext+0x3e>
3401507c:	b1ab      	cbz	r3, 340150aa <ISP_SVC_Stats_GetNext+0x3e>
  return hIsp->MainPipe_FrameCount;
3401507e:	4e1e      	ldr	r6, [pc, #120]	@ (340150f8 <ISP_SVC_Stats_GetNext+0x8c>)
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34015080:	f04f 0e00 	mov.w	lr, #0
34015084:	4634      	mov	r4, r6
34015086:	f04f 0805 	mov.w	r8, #5
  return hIsp->MainPipe_FrameCount;
3401508a:	6c00      	ldr	r0, [r0, #64]	@ 0x40
  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
3401508c:	9f09      	ldr	r7, [sp, #36]	@ 0x24
3401508e:	4407      	add	r7, r0
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
34015090:	f8d6 20f4 	ldr.w	r2, [r6, #244]	@ 0xf4
34015094:	b15a      	cbz	r2, 340150ae <ISP_SVC_Stats_GetNext+0x42>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34015096:	f1b8 0801 	subs.w	r8, r8, #1
3401509a:	f10e 0e01 	add.w	lr, lr, #1
3401509e:	f106 0614 	add.w	r6, r6, #20
340150a2:	d1f5      	bne.n	34015090 <ISP_SVC_Stats_GetNext+0x24>
  }

  if (i == ISP_SVC_STAT_MAX_CB)
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
340150a4:	20ac      	movs	r0, #172	@ 0xac
  ISP_SVC_StatEngine.client[i].location = location;
  ISP_SVC_StatEngine.client[i].type = type;
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;

  return ISP_OK;
}
340150a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return ISP_ERR_EINVAL;
340150aa:	2001      	movs	r0, #1
340150ac:	e7fb      	b.n	340150a6 <ISP_SVC_Stats_GetNext+0x3a>
  if (location & ISP_STAT_LOC_UP)
340150ae:	f01c 0f01 	tst.w	ip, #1
340150b2:	d004      	beq.n	340150be <ISP_SVC_Stats_GetNext+0x52>
    ISP_SVC_StatEngine.upRequest |= type;
340150b4:	f894 6158 	ldrb.w	r6, [r4, #344]	@ 0x158
340150b8:	432e      	orrs	r6, r5
340150ba:	f884 6158 	strb.w	r6, [r4, #344]	@ 0x158
  if (location & ISP_STAT_LOC_DOWN)
340150be:	f01c 0f02 	tst.w	ip, #2
    ISP_SVC_StatEngine.downRequest |= type;
340150c2:	bf1e      	ittt	ne
340150c4:	f894 6159 	ldrbne.w	r6, [r4, #345]	@ 0x159
340150c8:	432e      	orrne	r6, r5
340150ca:	f884 6159 	strbne.w	r6, [r4, #345]	@ 0x159
  if (type == ISP_STAT_TYPE_ALL_TMP)
340150ce:	2d04      	cmp	r5, #4
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
340150d0:	bf04      	itt	eq
340150d2:	301e      	addeq	r0, #30
340150d4:	f8c4 015c 	streq.w	r0, [r4, #348]	@ 0x15c
  ISP_SVC_StatEngine.client[i].callback = callback;
340150d8:	2014      	movs	r0, #20
340150da:	fb00 400e 	mla	r0, r0, lr, r4
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
340150de:	e9c0 193d 	strd	r1, r9, [r0, #244]	@ 0xf4
  ISP_SVC_StatEngine.client[i].pStats = pStats;
340150e2:	f8c0 30fc 	str.w	r3, [r0, #252]	@ 0xfc
  ISP_SVC_StatEngine.client[i].location = location;
340150e6:	f880 c104 	strb.w	ip, [r0, #260]	@ 0x104
  ISP_SVC_StatEngine.client[i].type = type;
340150ea:	f880 5105 	strb.w	r5, [r0, #261]	@ 0x105
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
340150ee:	f8c0 7100 	str.w	r7, [r0, #256]	@ 0x100
  return ISP_OK;
340150f2:	2000      	movs	r0, #0
340150f4:	e7d7      	b.n	340150a6 <ISP_SVC_Stats_GetNext+0x3a>
340150f6:	bf00      	nop
340150f8:	34044194 	.word	0x34044194

340150fc <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
340150fc:	b570      	push	{r4, r5, r6, lr}
  FuncDriver.GetXSize       = pDrv->GetXSize;
  FuncDriver.GetYSize       = pDrv->GetYSize;
  FuncDriver.SetLayer       = pDrv->SetLayer;
  FuncDriver.GetFormat      = pDrv->GetFormat;

  DrawProp->LcdLayer = 0;
340150fe:	2500      	movs	r5, #0
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
34015100:	4c14      	ldr	r4, [pc, #80]	@ (34015154 <UTIL_LCD_SetFuncDriver+0x58>)
34015102:	6803      	ldr	r3, [r0, #0]
  FuncDriver.GetYSize       = pDrv->GetYSize;
34015104:	6a02      	ldr	r2, [r0, #32]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
34015106:	6023      	str	r3, [r4, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
34015108:	6843      	ldr	r3, [r0, #4]
  FuncDriver.GetYSize       = pDrv->GetYSize;
3401510a:	6222      	str	r2, [r4, #32]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
3401510c:	6063      	str	r3, [r4, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
3401510e:	6883      	ldr	r3, [r0, #8]
  FuncDriver.SetLayer       = pDrv->SetLayer;
34015110:	6a42      	ldr	r2, [r0, #36]	@ 0x24
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
34015112:	60a3      	str	r3, [r4, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
34015114:	68c3      	ldr	r3, [r0, #12]
  DrawProp->LcdLayer = 0;
34015116:	4e10      	ldr	r6, [pc, #64]	@ (34015158 <UTIL_LCD_SetFuncDriver+0x5c>)
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
34015118:	60e3      	str	r3, [r4, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
3401511a:	6903      	ldr	r3, [r0, #16]
  FuncDriver.SetLayer       = pDrv->SetLayer;
3401511c:	6262      	str	r2, [r4, #36]	@ 0x24
  FuncDriver.FillRect       = pDrv->FillRect;
3401511e:	6123      	str	r3, [r4, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
34015120:	6943      	ldr	r3, [r0, #20]
  FuncDriver.GetFormat      = pDrv->GetFormat;
34015122:	6a82      	ldr	r2, [r0, #40]	@ 0x28
  FuncDriver.GetPixel       = pDrv->GetPixel;
34015124:	6163      	str	r3, [r4, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
34015126:	6983      	ldr	r3, [r0, #24]
  DrawProp->LcdDevice = 0;
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
34015128:	f106 0114 	add.w	r1, r6, #20
  FuncDriver.SetPixel       = pDrv->SetPixel;
3401512c:	61a3      	str	r3, [r4, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
3401512e:	69c3      	ldr	r3, [r0, #28]
  DrawProp->LcdDevice = 0;
34015130:	e9c6 5503 	strd	r5, r5, [r6, #12]
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
34015134:	4628      	mov	r0, r5
  FuncDriver.GetXSize       = pDrv->GetXSize;
34015136:	61e3      	str	r3, [r4, #28]
  FuncDriver.GetFormat      = pDrv->GetFormat;
34015138:	62a2      	str	r2, [r4, #40]	@ 0x28
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
3401513a:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp->LcdYsize);
3401513c:	6a23      	ldr	r3, [r4, #32]
3401513e:	f106 0118 	add.w	r1, r6, #24
34015142:	4628      	mov	r0, r5
34015144:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
34015146:	4628      	mov	r0, r5
34015148:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3401514a:	f106 011c 	add.w	r1, r6, #28
}
3401514e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
34015152:	4718      	bx	r3
34015154:	34044548 	.word	0x34044548
34015158:	34044574 	.word	0x34044574

3401515c <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
3401515c:	b570      	push	{r4, r5, r6, lr}
  if(FuncDriver.SetLayer != NULL)
3401515e:	4e10      	ldr	r6, [pc, #64]	@ (340151a0 <UTIL_LCD_SetLayer+0x44>)
{
34015160:	4605      	mov	r5, r0
  if(FuncDriver.SetLayer != NULL)
34015162:	6a73      	ldr	r3, [r6, #36]	@ 0x24
34015164:	b1db      	cbz	r3, 3401519e <UTIL_LCD_SetLayer+0x42>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
34015166:	4c0f      	ldr	r4, [pc, #60]	@ (340151a4 <UTIL_LCD_SetLayer+0x48>)
34015168:	4601      	mov	r1, r0
3401516a:	6920      	ldr	r0, [r4, #16]
3401516c:	4798      	blx	r3
3401516e:	b9b0      	cbnz	r0, 3401519e <UTIL_LCD_SetLayer+0x42>
    {
      DrawProp->LcdLayer = Layer;
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34015170:	eb04 1145 	add.w	r1, r4, r5, lsl #5
34015174:	69f3      	ldr	r3, [r6, #28]
34015176:	6920      	ldr	r0, [r4, #16]
      DrawProp->LcdLayer = Layer;
34015178:	60e5      	str	r5, [r4, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
3401517a:	3114      	adds	r1, #20
3401517c:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
3401517e:	68e1      	ldr	r1, [r4, #12]
34015180:	6a33      	ldr	r3, [r6, #32]
34015182:	eb04 1141 	add.w	r1, r4, r1, lsl #5
34015186:	6920      	ldr	r0, [r4, #16]
34015188:	3118      	adds	r1, #24
3401518a:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
3401518c:	68e1      	ldr	r1, [r4, #12]
3401518e:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
34015190:	eb04 1141 	add.w	r1, r4, r1, lsl #5
34015194:	6920      	ldr	r0, [r4, #16]
34015196:	311c      	adds	r1, #28
    }
  }
}
34015198:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
3401519c:	4718      	bx	r3
}
3401519e:	bd70      	pop	{r4, r5, r6, pc}
340151a0:	34044548 	.word	0x34044548
340151a4:	34044574 	.word	0x34044574

340151a8 <UTIL_LCD_SetTextColor>:
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
340151a8:	4a02      	ldr	r2, [pc, #8]	@ (340151b4 <UTIL_LCD_SetTextColor+0xc>)
340151aa:	68d3      	ldr	r3, [r2, #12]
340151ac:	015b      	lsls	r3, r3, #5
340151ae:	50d0      	str	r0, [r2, r3]
}
340151b0:	4770      	bx	lr
340151b2:	bf00      	nop
340151b4:	34044574 	.word	0x34044574

340151b8 <UTIL_LCD_SetBackColor>:
  * @brief  Sets the LCD background color.
  * @param  Color  Layer background color code
  */
void UTIL_LCD_SetBackColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].BackColor = Color;
340151b8:	4b02      	ldr	r3, [pc, #8]	@ (340151c4 <UTIL_LCD_SetBackColor+0xc>)
340151ba:	68da      	ldr	r2, [r3, #12]
340151bc:	eb03 1342 	add.w	r3, r3, r2, lsl #5
340151c0:	6058      	str	r0, [r3, #4]
}
340151c2:	4770      	bx	lr
340151c4:	34044574 	.word	0x34044574

340151c8 <UTIL_LCD_SetFont>:
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
340151c8:	4b02      	ldr	r3, [pc, #8]	@ (340151d4 <UTIL_LCD_SetFont+0xc>)
340151ca:	68da      	ldr	r2, [r3, #12]
340151cc:	eb03 1342 	add.w	r3, r3, r2, lsl #5
340151d0:	6098      	str	r0, [r3, #8]
}
340151d2:	4770      	bx	lr
340151d4:	34044574 	.word	0x34044574

340151d8 <UTIL_LCD_GetFont>:
  * @brief  Gets the LCD text font.
  * @retval Used layer font
  */
sFONT *UTIL_LCD_GetFont(void)
{
  return DrawProp[DrawProp->LcdLayer].pFont;
340151d8:	4b02      	ldr	r3, [pc, #8]	@ (340151e4 <UTIL_LCD_GetFont+0xc>)
340151da:	68da      	ldr	r2, [r3, #12]
340151dc:	eb03 1342 	add.w	r3, r3, r2, lsl #5
}
340151e0:	6898      	ldr	r0, [r3, #8]
340151e2:	4770      	bx	lr
340151e4:	34044574 	.word	0x34044574

340151e8 <UTIL_LCD_FillRGBRect>:
  * @param  Xpos    X position
  * @param  Ypos    Y position
  * @param  Length  Line length
  */
void UTIL_LCD_FillRGBRect(uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
340151e8:	b513      	push	{r0, r1, r4, lr}
  /* Write RGB rectangle data */
  FuncDriver.FillRGBRect(DrawProp->LcdDevice, Xpos, Ypos, pData, Width, Height);
340151ea:	9c04      	ldr	r4, [sp, #16]
340151ec:	e9cd 3400 	strd	r3, r4, [sp]
340151f0:	4b04      	ldr	r3, [pc, #16]	@ (34015204 <UTIL_LCD_FillRGBRect+0x1c>)
340151f2:	685c      	ldr	r4, [r3, #4]
340151f4:	4613      	mov	r3, r2
340151f6:	460a      	mov	r2, r1
340151f8:	4601      	mov	r1, r0
340151fa:	4803      	ldr	r0, [pc, #12]	@ (34015208 <UTIL_LCD_FillRGBRect+0x20>)
340151fc:	6900      	ldr	r0, [r0, #16]
340151fe:	47a0      	blx	r4
}
34015200:	b002      	add	sp, #8
34015202:	bd10      	pop	{r4, pc}
34015204:	34044548 	.word	0x34044548
34015208:	34044574 	.word	0x34044574

3401520c <UTIL_LCD_DrawHLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawHLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
3401520c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401520e:	4c19      	ldr	r4, [pc, #100]	@ (34015274 <UTIL_LCD_DrawHLine+0x68>)
{
34015210:	4606      	mov	r6, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015212:	68e0      	ldr	r0, [r4, #12]
34015214:	eb04 1040 	add.w	r0, r4, r0, lsl #5
34015218:	69c7      	ldr	r7, [r0, #28]
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401521a:	4817      	ldr	r0, [pc, #92]	@ (34015278 <UTIL_LCD_DrawHLine+0x6c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401521c:	2f02      	cmp	r7, #2
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401521e:	6885      	ldr	r5, [r0, #8]
34015220:	6920      	ldr	r0, [r4, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015222:	d110      	bne.n	34015246 <UTIL_LCD_DrawHLine+0x3a>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015224:	095c      	lsrs	r4, r3, #5
34015226:	0a1f      	lsrs	r7, r3, #8
34015228:	f404 64fc 	and.w	r4, r4, #2016	@ 0x7e0
3401522c:	f407 4778 	and.w	r7, r7, #63488	@ 0xf800
34015230:	433c      	orrs	r4, r7
34015232:	f3c3 03c4 	ubfx	r3, r3, #3, #5
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
34015236:	431c      	orrs	r4, r3
34015238:	9400      	str	r4, [sp, #0]
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
3401523a:	4613      	mov	r3, r2
3401523c:	460a      	mov	r2, r1
3401523e:	4631      	mov	r1, r6
34015240:	47a8      	blx	r5
  }
}
34015242:	b003      	add	sp, #12
34015244:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
34015246:	69e4      	ldr	r4, [r4, #28]
34015248:	2c01      	cmp	r4, #1
3401524a:	d103      	bne.n	34015254 <UTIL_LCD_DrawHLine+0x48>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
3401524c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015250:	9300      	str	r3, [sp, #0]
34015252:	e7f2      	b.n	3401523a <UTIL_LCD_DrawHLine+0x2e>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34015254:	2f04      	cmp	r7, #4
34015256:	d1fb      	bne.n	34015250 <UTIL_LCD_DrawHLine+0x44>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
34015258:	0f1f      	lsrs	r7, r3, #28
3401525a:	f3c3 1403 	ubfx	r4, r3, #4, #4
3401525e:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
34015262:	0a1f      	lsrs	r7, r3, #8
34015264:	f007 07f0 	and.w	r7, r7, #240	@ 0xf0
34015268:	0b1b      	lsrs	r3, r3, #12
3401526a:	433c      	orrs	r4, r7
3401526c:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34015270:	e7e1      	b.n	34015236 <UTIL_LCD_DrawHLine+0x2a>
34015272:	bf00      	nop
34015274:	34044574 	.word	0x34044574
34015278:	34044548 	.word	0x34044548

3401527c <UTIL_LCD_DrawVLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawVLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
3401527c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401527e:	4c19      	ldr	r4, [pc, #100]	@ (340152e4 <UTIL_LCD_DrawVLine+0x68>)
{
34015280:	4606      	mov	r6, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015282:	68e0      	ldr	r0, [r4, #12]
34015284:	eb04 1040 	add.w	r0, r4, r0, lsl #5
34015288:	69c7      	ldr	r7, [r0, #28]
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401528a:	4817      	ldr	r0, [pc, #92]	@ (340152e8 <UTIL_LCD_DrawVLine+0x6c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401528c:	2f02      	cmp	r7, #2
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401528e:	68c5      	ldr	r5, [r0, #12]
34015290:	6920      	ldr	r0, [r4, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015292:	d110      	bne.n	340152b6 <UTIL_LCD_DrawVLine+0x3a>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015294:	095c      	lsrs	r4, r3, #5
34015296:	0a1f      	lsrs	r7, r3, #8
34015298:	f404 64fc 	and.w	r4, r4, #2016	@ 0x7e0
3401529c:	f407 4778 	and.w	r7, r7, #63488	@ 0xf800
340152a0:	433c      	orrs	r4, r7
340152a2:	f3c3 03c4 	ubfx	r3, r3, #3, #5
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
340152a6:	431c      	orrs	r4, r3
340152a8:	9400      	str	r4, [sp, #0]
  }
  else /*LCD_PIXEL_FORMAT_ARGB888*/
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
340152aa:	4613      	mov	r3, r2
340152ac:	460a      	mov	r2, r1
340152ae:	4631      	mov	r1, r6
340152b0:	47a8      	blx	r5
  }
}
340152b2:	b003      	add	sp, #12
340152b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340152b6:	69e4      	ldr	r4, [r4, #28]
340152b8:	2c01      	cmp	r4, #1
340152ba:	d103      	bne.n	340152c4 <UTIL_LCD_DrawVLine+0x48>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
340152bc:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
340152c0:	9300      	str	r3, [sp, #0]
340152c2:	e7f2      	b.n	340152aa <UTIL_LCD_DrawVLine+0x2e>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
340152c4:	2f04      	cmp	r7, #4
340152c6:	d1fb      	bne.n	340152c0 <UTIL_LCD_DrawVLine+0x44>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
340152c8:	0f1f      	lsrs	r7, r3, #28
340152ca:	f3c3 1403 	ubfx	r4, r3, #4, #4
340152ce:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
340152d2:	0a1f      	lsrs	r7, r3, #8
340152d4:	f007 07f0 	and.w	r7, r7, #240	@ 0xf0
340152d8:	0b1b      	lsrs	r3, r3, #12
340152da:	433c      	orrs	r4, r7
340152dc:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340152e0:	e7e1      	b.n	340152a6 <UTIL_LCD_DrawVLine+0x2a>
340152e2:	bf00      	nop
340152e4:	34044574 	.word	0x34044574
340152e8:	34044548 	.word	0x34044548

340152ec <UTIL_LCD_DisplayChar>:
  * @param  Ypos Line where to display the character shape.
  * @param  Ascii Character ascii code
  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E
  */
void UTIL_LCD_DisplayChar(uint32_t Xpos, uint32_t Ypos, uint8_t Ascii)
{
340152ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
340152f0:	f8df 81e0 	ldr.w	r8, [pc, #480]	@ 340154d4 <UTIL_LCD_DisplayChar+0x1e8>
{
340152f4:	b0a3      	sub	sp, #140	@ 0x8c
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
340152f6:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
340152fa:	9108      	str	r1, [sp, #32]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
340152fc:	eb08 1343 	add.w	r3, r8, r3, lsl #5
34015300:	6899      	ldr	r1, [r3, #8]
{
34015302:	9005      	str	r0, [sp, #20]
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
34015304:	88cb      	ldrh	r3, [r1, #6]
34015306:	888c      	ldrh	r4, [r1, #4]
34015308:	9307      	str	r3, [sp, #28]
  uint8_t rgb8[24*4];
  uint16_t* rgb16 = (uint16_t*)rgb8;
  uint32_t* argb32 = (uint32_t*)rgb8;
  uint16_t* argb4444 = (uint16_t*)rgb8;

  offset =  8 *((width + 7)/8) -  width ;
3401530a:	1de3      	adds	r3, r4, #7
3401530c:	f023 0007 	bic.w	r0, r3, #7
34015310:	9003      	str	r0, [sp, #12]

  for(i = 0; i < height; i++)
  {
    pchar = ((uint8_t *)pData + (width + 7)/8 * i);
34015312:	08d8      	lsrs	r0, r3, #3
34015314:	9006      	str	r0, [sp, #24]
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
    {
      for (j = 0; j < width*3; j = j+ 3)
34015316:	eb04 0044 	add.w	r0, r4, r4, lsl #1
3401531a:	9009      	str	r0, [sp, #36]	@ 0x24
3401531c:	9808      	ldr	r0, [sp, #32]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
3401531e:	3a20      	subs	r2, #32
34015320:	3001      	adds	r0, #1
34015322:	9004      	str	r0, [sp, #16]
34015324:	9807      	ldr	r0, [sp, #28]
34015326:	680d      	ldr	r5, [r1, #0]
34015328:	4342      	muls	r2, r0
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
3401532a:	10db      	asrs	r3, r3, #3
3401532c:	fb03 5502 	mla	r5, r3, r2, r5
34015330:	9b04      	ldr	r3, [sp, #16]
  for(i = 0; i < height; i++)
34015332:	9a08      	ldr	r2, [sp, #32]
34015334:	1e59      	subs	r1, r3, #1
34015336:	1a9b      	subs	r3, r3, r2
34015338:	9a07      	ldr	r2, [sp, #28]
3401533a:	3b01      	subs	r3, #1
3401533c:	429a      	cmp	r2, r3
3401533e:	d802      	bhi.n	34015346 <UTIL_LCD_DisplayChar+0x5a>
}
34015340:	b023      	add	sp, #140	@ 0x8c
34015342:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(((width + 7)/8))
34015346:	9806      	ldr	r0, [sp, #24]
      line =  pchar[0];
34015348:	782b      	ldrb	r3, [r5, #0]
    switch(((width + 7)/8))
3401534a:	2801      	cmp	r0, #1
      line =  pchar[0];
3401534c:	461a      	mov	r2, r3
    switch(((width + 7)/8))
3401534e:	d004      	beq.n	3401535a <UTIL_LCD_DisplayChar+0x6e>
34015350:	2802      	cmp	r0, #2
34015352:	d127      	bne.n	340153a4 <UTIL_LCD_DisplayChar+0xb8>
      line =  (pchar[0]<< 8) | pchar[1];
34015354:	882a      	ldrh	r2, [r5, #0]
34015356:	ba52      	rev16	r2, r2
34015358:	b292      	uxth	r2, r2
    if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401535a:	f8d8 000c 	ldr.w	r0, [r8, #12]
3401535e:	eb08 1040 	add.w	r0, r8, r0, lsl #5
34015362:	69c7      	ldr	r7, [r0, #28]
34015364:	2f02      	cmp	r7, #2
34015366:	d13c      	bne.n	340153e2 <UTIL_LCD_DisplayChar+0xf6>
34015368:	f04f 0c01 	mov.w	ip, #1
        if(line & (1 << (width- j + offset- 1)))
3401536c:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < width; j++)
3401536e:	f04f 0e00 	mov.w	lr, #0
        if(line & (1 << (width- j + offset- 1)))
34015372:	f103 3aff 	add.w	sl, r3, #4294967295
34015376:	4663      	mov	r3, ip
34015378:	4574      	cmp	r4, lr
3401537a:	eb04 0603 	add.w	r6, r4, r3
3401537e:	bf08      	it	eq
34015380:	4666      	moveq	r6, ip
34015382:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
34015386:	3e01      	subs	r6, #1
34015388:	d113      	bne.n	340153b2 <UTIL_LCD_DisplayChar+0xc6>
        else
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&argb4444[0], width, 1);
3401538a:	f8cd c000 	str.w	ip, [sp]
        else
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].BackColor;
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
3401538e:	4623      	mov	r3, r4
34015390:	9805      	ldr	r0, [sp, #20]
34015392:	aa0a      	add	r2, sp, #40	@ 0x28
34015394:	f7ff ff28 	bl	340151e8 <UTIL_LCD_FillRGBRect>
  for(i = 0; i < height; i++)
34015398:	9b04      	ldr	r3, [sp, #16]
3401539a:	3301      	adds	r3, #1
3401539c:	9304      	str	r3, [sp, #16]
3401539e:	9b06      	ldr	r3, [sp, #24]
340153a0:	441d      	add	r5, r3
340153a2:	e7c5      	b.n	34015330 <UTIL_LCD_DisplayChar+0x44>
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
340153a4:	786a      	ldrb	r2, [r5, #1]
340153a6:	041b      	lsls	r3, r3, #16
340153a8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
340153ac:	78aa      	ldrb	r2, [r5, #2]
340153ae:	431a      	orrs	r2, r3
      break;
340153b0:	e7d3      	b.n	3401535a <UTIL_LCD_DisplayChar+0x6e>
        if(line & (1 << (width- j + offset- 1)))
340153b2:	ebaa 030e 	sub.w	r3, sl, lr
340153b6:	fa0c f303 	lsl.w	r3, ip, r3
340153ba:	4213      	tst	r3, r2
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
340153bc:	bf14      	ite	ne
340153be:	6807      	ldrne	r7, [r0, #0]
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
340153c0:	6847      	ldreq	r7, [r0, #4]
      for (j = 0; j < width; j++)
340153c2:	f10e 0e01 	add.w	lr, lr, #1
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
340153c6:	f3c7 03c4 	ubfx	r3, r7, #3, #5
340153ca:	ea4f 4bd7 	mov.w	fp, r7, lsr #19
340153ce:	097f      	lsrs	r7, r7, #5
340153d0:	ea43 23cb 	orr.w	r3, r3, fp, lsl #11
340153d4:	f407 67fc 	and.w	r7, r7, #2016	@ 0x7e0
340153d8:	433b      	orrs	r3, r7
340153da:	b29b      	uxth	r3, r3
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
340153dc:	f829 3b02 	strh.w	r3, [r9], #2
      for (j = 0; j < width; j++)
340153e0:	e7d1      	b.n	34015386 <UTIL_LCD_DisplayChar+0x9a>
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340153e2:	2f01      	cmp	r7, #1
340153e4:	d126      	bne.n	34015434 <UTIL_LCD_DisplayChar+0x148>
      for (j = 0; j < width*3; j = j+ 3)
340153e6:	f04f 0c00 	mov.w	ip, #0
        if(line & (1 << (width- j/3 + offset- 1)))
340153ea:	f04f 0b03 	mov.w	fp, #3
340153ee:	9b03      	ldr	r3, [sp, #12]
340153f0:	ae0a      	add	r6, sp, #40	@ 0x28
340153f2:	f103 3aff 	add.w	sl, r3, #4294967295
      for (j = 0; j < width*3; j = j+ 3)
340153f6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340153f8:	459c      	cmp	ip, r3
340153fa:	d302      	bcc.n	34015402 <UTIL_LCD_DisplayChar+0x116>
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
340153fc:	2301      	movs	r3, #1
340153fe:	9300      	str	r3, [sp, #0]
34015400:	e7c5      	b.n	3401538e <UTIL_LCD_DisplayChar+0xa2>
        if(line & (1 << (width- j/3 + offset- 1)))
34015402:	fbbc f3fb 	udiv	r3, ip, fp
34015406:	ebaa 0303 	sub.w	r3, sl, r3
3401540a:	fa07 f303 	lsl.w	r3, r7, r3
3401540e:	4213      	tst	r3, r2
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
34015410:	bf14      	ite	ne
34015412:	6803      	ldrne	r3, [r0, #0]
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
34015414:	6843      	ldreq	r3, [r0, #4]
      for (j = 0; j < width*3; j = j+ 3)
34015416:	f10c 0c03 	add.w	ip, ip, #3
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
3401541a:	fa5f f983 	uxtb.w	r9, r3
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 8) & 0xFFU;
3401541e:	f3c3 2e07 	ubfx	lr, r3, #8, #8
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 16) & 0xFFU;
34015422:	f3c3 4307 	ubfx	r3, r3, #16, #8
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
34015426:	f886 9000 	strb.w	r9, [r6]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 8) & 0xFFU;
3401542a:	f886 e001 	strb.w	lr, [r6, #1]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 16) & 0xFFU;
3401542e:	70b3      	strb	r3, [r6, #2]
      for (j = 0; j < width*3; j = j+ 3)
34015430:	3603      	adds	r6, #3
34015432:	e7e0      	b.n	340153f6 <UTIL_LCD_DisplayChar+0x10a>
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34015434:	2f04      	cmp	r7, #4
34015436:	d01f      	beq.n	34015478 <UTIL_LCD_DisplayChar+0x18c>
        if(line & (1 << (width- j + offset- 1)))
34015438:	f04f 0a01 	mov.w	sl, #1
      for (j = 0; j < width; j++)
3401543c:	2700      	movs	r7, #0
3401543e:	4656      	mov	r6, sl
        if(line & (1 << (width- j + offset- 1)))
34015440:	9b03      	ldr	r3, [sp, #12]
34015442:	42bc      	cmp	r4, r7
34015444:	f103 3bff 	add.w	fp, r3, #4294967295
34015448:	eb04 0306 	add.w	r3, r4, r6
3401544c:	bf14      	ite	ne
3401544e:	469c      	movne	ip, r3
34015450:	46d4      	moveq	ip, sl
34015452:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
34015456:	f1bc 0c01 	subs.w	ip, ip, #1
3401545a:	d0cf      	beq.n	340153fc <UTIL_LCD_DisplayChar+0x110>
        if(line & (1 << (width- j + offset- 1)))
3401545c:	ebab 0e07 	sub.w	lr, fp, r7
34015460:	6843      	ldr	r3, [r0, #4]
34015462:	fa0a fe0e 	lsl.w	lr, sl, lr
34015466:	ea1e 0f02 	tst.w	lr, r2
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
3401546a:	6806      	ldr	r6, [r0, #0]
        if(line & (1 << (width- j + offset- 1)))
3401546c:	bf08      	it	eq
3401546e:	461e      	moveq	r6, r3
      for (j = 0; j < width; j++)
34015470:	3701      	adds	r7, #1
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
34015472:	f849 6b04 	str.w	r6, [r9], #4
      for (j = 0; j < width; j++)
34015476:	e7ee      	b.n	34015456 <UTIL_LCD_DisplayChar+0x16a>
34015478:	f04f 0c01 	mov.w	ip, #1
        if(line & (1 << (width- j + offset- 1)))
3401547c:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < width; j++)
3401547e:	f04f 0e00 	mov.w	lr, #0
        if(line & (1 << (width- j + offset- 1)))
34015482:	f103 3bff 	add.w	fp, r3, #4294967295
34015486:	4663      	mov	r3, ip
34015488:	4574      	cmp	r4, lr
3401548a:	eb04 0603 	add.w	r6, r4, r3
3401548e:	bf08      	it	eq
34015490:	4666      	moveq	r6, ip
34015492:	f10d 0a28 	add.w	sl, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
34015496:	3e01      	subs	r6, #1
34015498:	f43f af77 	beq.w	3401538a <UTIL_LCD_DisplayChar+0x9e>
        if(line & (1 << (width- j + offset- 1)))
3401549c:	ebab 030e 	sub.w	r3, fp, lr
340154a0:	fa0c f303 	lsl.w	r3, ip, r3
340154a4:	4213      	tst	r3, r2
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
340154a6:	bf14      	ite	ne
340154a8:	6807      	ldrne	r7, [r0, #0]
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
340154aa:	6847      	ldreq	r7, [r0, #4]
      for (j = 0; j < width; j++)
340154ac:	f10e 0e01 	add.w	lr, lr, #1
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
340154b0:	0f3b      	lsrs	r3, r7, #28
340154b2:	f3c7 1903 	ubfx	r9, r7, #4, #4
340154b6:	ea49 3903 	orr.w	r9, r9, r3, lsl #12
340154ba:	0a3b      	lsrs	r3, r7, #8
340154bc:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
340154c0:	0b3f      	lsrs	r7, r7, #12
340154c2:	ea49 0303 	orr.w	r3, r9, r3
340154c6:	f407 6770 	and.w	r7, r7, #3840	@ 0xf00
340154ca:	433b      	orrs	r3, r7
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
340154cc:	f82a 3b02 	strh.w	r3, [sl], #2
      for (j = 0; j < width; j++)
340154d0:	e7e1      	b.n	34015496 <UTIL_LCD_DisplayChar+0x1aa>
340154d2:	bf00      	nop
340154d4:	34044574 	.word	0x34044574

340154d8 <UTIL_LCD_DisplayStringAt>:
{
340154d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340154dc:	f8df 8088 	ldr.w	r8, [pc, #136]	@ 34015568 <UTIL_LCD_DisplayStringAt+0x90>
{
340154e0:	4605      	mov	r5, r0
  while (*ptr++) size ++ ;
340154e2:	4610      	mov	r0, r2
{
340154e4:	4699      	mov	r9, r3
340154e6:	4616      	mov	r6, r2
340154e8:	460f      	mov	r7, r1
  while (*ptr++) size ++ ;
340154ea:	f7ec f81f 	bl	3400152c <strlen>
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340154ee:	f8d8 300c 	ldr.w	r3, [r8, #12]
  switch (Mode)
340154f2:	f1b9 0f01 	cmp.w	r9, #1
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340154f6:	eb08 1343 	add.w	r3, r8, r3, lsl #5
340154fa:	689a      	ldr	r2, [r3, #8]
340154fc:	695c      	ldr	r4, [r3, #20]
340154fe:	8892      	ldrh	r2, [r2, #4]
34015500:	fbb4 f4f2 	udiv	r4, r4, r2
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
34015504:	eba4 0400 	sub.w	r4, r4, r0
34015508:	fb02 f404 	mul.w	r4, r2, r4
  switch (Mode)
3401550c:	d01b      	beq.n	34015546 <UTIL_LCD_DisplayStringAt+0x6e>
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
3401550e:	1b64      	subs	r4, r4, r5
34015510:	f1b9 0f02 	cmp.w	r9, #2
34015514:	bf08      	it	eq
34015516:	4625      	moveq	r5, r4
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
34015518:	f647 73fe 	movw	r3, #32766	@ 0x7ffe
3401551c:	1e6a      	subs	r2, r5, #1
    refcolumn = 1;
3401551e:	429a      	cmp	r2, r3
34015520:	bf88      	it	hi
34015522:	2501      	movhi	r5, #1
34015524:	2400      	movs	r4, #0
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
34015526:	f8d8 300c 	ldr.w	r3, [r8, #12]
3401552a:	5d32      	ldrb	r2, [r6, r4]
3401552c:	eb08 1343 	add.w	r3, r8, r3, lsl #5
34015530:	6899      	ldr	r1, [r3, #8]
34015532:	695b      	ldr	r3, [r3, #20]
34015534:	8889      	ldrh	r1, [r1, #4]
34015536:	fb04 3311 	mls	r3, r4, r1, r3
3401553a:	b29b      	uxth	r3, r3
3401553c:	4299      	cmp	r1, r3
3401553e:	d800      	bhi.n	34015542 <UTIL_LCD_DisplayStringAt+0x6a>
34015540:	b922      	cbnz	r2, 3401554c <UTIL_LCD_DisplayStringAt+0x74>
}
34015542:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      refcolumn = Xpos + ((xsize - size)* DrawProp[DrawProp->LcdLayer].pFont->Width) / 2;
34015546:	eb05 0554 	add.w	r5, r5, r4, lsr #1
      break;
3401554a:	e7e5      	b.n	34015518 <UTIL_LCD_DisplayStringAt+0x40>
    UTIL_LCD_DisplayChar(refcolumn, Ypos, *Text);
3401554c:	4628      	mov	r0, r5
3401554e:	4639      	mov	r1, r7
34015550:	f7ff fecc 	bl	340152ec <UTIL_LCD_DisplayChar>
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
34015554:	f8d8 300c 	ldr.w	r3, [r8, #12]
    i++;
34015558:	3401      	adds	r4, #1
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
3401555a:	eb08 1343 	add.w	r3, r8, r3, lsl #5
3401555e:	689b      	ldr	r3, [r3, #8]
34015560:	889b      	ldrh	r3, [r3, #4]
34015562:	441d      	add	r5, r3
    i++;
34015564:	e7df      	b.n	34015526 <UTIL_LCD_DisplayStringAt+0x4e>
34015566:	bf00      	nop
34015568:	34044574 	.word	0x34044574

3401556c <UTIL_LCD_DrawRect>:
{
3401556c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34015570:	461f      	mov	r7, r3
34015572:	460e      	mov	r6, r1
34015574:	4605      	mov	r5, r0
34015576:	4614      	mov	r4, r2
34015578:	f8dd 8018 	ldr.w	r8, [sp, #24]
  UTIL_LCD_DrawHLine(Xpos, Ypos, Width, Color);
3401557c:	4643      	mov	r3, r8
3401557e:	f7ff fe45 	bl	3401520c <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawHLine(Xpos, (Ypos+ Height - 1U), Width, Color);
34015582:	1e79      	subs	r1, r7, #1
34015584:	4643      	mov	r3, r8
34015586:	4622      	mov	r2, r4
34015588:	4628      	mov	r0, r5
3401558a:	4431      	add	r1, r6
3401558c:	f7ff fe3e 	bl	3401520c <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
34015590:	3c01      	subs	r4, #1
  UTIL_LCD_DrawVLine(Xpos, Ypos, Height, Color);
34015592:	4643      	mov	r3, r8
34015594:	463a      	mov	r2, r7
34015596:	4631      	mov	r1, r6
34015598:	4628      	mov	r0, r5
3401559a:	f7ff fe6f 	bl	3401527c <UTIL_LCD_DrawVLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
3401559e:	4643      	mov	r3, r8
340155a0:	463a      	mov	r2, r7
340155a2:	4631      	mov	r1, r6
340155a4:	1960      	adds	r0, r4, r5
}
340155a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
340155aa:	f7ff be67 	b.w	3401527c <UTIL_LCD_DrawVLine>
	...

340155b0 <UTIL_LCD_FillRect>:
{
340155b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340155b2:	4d1d      	ldr	r5, [pc, #116]	@ (34015628 <UTIL_LCD_FillRect+0x78>)
{
340155b4:	4607      	mov	r7, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340155b6:	68e8      	ldr	r0, [r5, #12]
{
340155b8:	9c08      	ldr	r4, [sp, #32]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340155ba:	eb05 1040 	add.w	r0, r5, r0, lsl #5
340155be:	f8d0 c01c 	ldr.w	ip, [r0, #28]
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340155c2:	481a      	ldr	r0, [pc, #104]	@ (3401562c <UTIL_LCD_FillRect+0x7c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340155c4:	f1bc 0f02 	cmp.w	ip, #2
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340155c8:	6906      	ldr	r6, [r0, #16]
340155ca:	6928      	ldr	r0, [r5, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340155cc:	d10c      	bne.n	340155e8 <UTIL_LCD_FillRect+0x38>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340155ce:	0965      	lsrs	r5, r4, #5
340155d0:	ea4f 2c14 	mov.w	ip, r4, lsr #8
340155d4:	f405 65fc 	and.w	r5, r5, #2016	@ 0x7e0
340155d8:	f40c 4c78 	and.w	ip, ip, #63488	@ 0xf800
340155dc:	ea45 050c 	orr.w	r5, r5, ip
340155e0:	f3c4 04c4 	ubfx	r4, r4, #3, #5
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
340155e4:	432c      	orrs	r4, r5
340155e6:	e004      	b.n	340155f2 <UTIL_LCD_FillRect+0x42>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340155e8:	69ed      	ldr	r5, [r5, #28]
340155ea:	2d01      	cmp	r5, #1
340155ec:	d109      	bne.n	34015602 <UTIL_LCD_FillRect+0x52>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
340155ee:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
340155f2:	e9cd 3400 	strd	r3, r4, [sp]
340155f6:	4613      	mov	r3, r2
340155f8:	460a      	mov	r2, r1
340155fa:	4639      	mov	r1, r7
340155fc:	47b0      	blx	r6
}
340155fe:	b003      	add	sp, #12
34015600:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34015602:	f1bc 0f04 	cmp.w	ip, #4
34015606:	d1f4      	bne.n	340155f2 <UTIL_LCD_FillRect+0x42>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
34015608:	ea4f 7c14 	mov.w	ip, r4, lsr #28
3401560c:	f3c4 1503 	ubfx	r5, r4, #4, #4
34015610:	ea45 350c 	orr.w	r5, r5, ip, lsl #12
34015614:	ea4f 2c14 	mov.w	ip, r4, lsr #8
34015618:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
3401561c:	0b24      	lsrs	r4, r4, #12
3401561e:	ea45 050c 	orr.w	r5, r5, ip
34015622:	f404 6470 	and.w	r4, r4, #3840	@ 0xf00
34015626:	e7dd      	b.n	340155e4 <UTIL_LCD_FillRect+0x34>
34015628:	34044574 	.word	0x34044574
3401562c:	34044548 	.word	0x34044548

34015630 <UTIL_LCD_Clear>:
{
34015630:	b507      	push	{r0, r1, r2, lr}
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
34015632:	2100      	movs	r1, #0
34015634:	4a06      	ldr	r2, [pc, #24]	@ (34015650 <UTIL_LCD_Clear+0x20>)
34015636:	68d3      	ldr	r3, [r2, #12]
34015638:	9000      	str	r0, [sp, #0]
3401563a:	eb02 1243 	add.w	r2, r2, r3, lsl #5
3401563e:	4608      	mov	r0, r1
34015640:	e9d2 2305 	ldrd	r2, r3, [r2, #20]
34015644:	f7ff ffb4 	bl	340155b0 <UTIL_LCD_FillRect>
}
34015648:	b003      	add	sp, #12
3401564a:	f85d fb04 	ldr.w	pc, [sp], #4
3401564e:	bf00      	nop
34015650:	34044574 	.word	0x34044574

34015654 <yolov2_nms_comparator>:
static int32_t AI_YOLOV2_PP_SORT_CLASS;


int32_t yolov2_nms_comparator(const void *pa, const void *pb)
{
    float32_t a = *((float32_t *)pa + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
34015654:	4b0c      	ldr	r3, [pc, #48]	@ (34015688 <yolov2_nms_comparator+0x34>)
34015656:	681b      	ldr	r3, [r3, #0]
34015658:	3305      	adds	r3, #5
3401565a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    float32_t b = *((float32_t *)pb + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
3401565e:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    float32_t diff = 0;

    diff = a - b;
34015662:	edd0 7a00 	vldr	s15, [r0]
34015666:	ed91 7a00 	vldr	s14, [r1]
3401566a:	ee77 7ac7 	vsub.f32	s15, s15, s14

    if (diff < 0) return 1;
3401566e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34015672:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015676:	d404      	bmi.n	34015682 <yolov2_nms_comparator+0x2e>
    else if (diff > 0) return -1;
34015678:	bfcc      	ite	gt
3401567a:	f04f 30ff 	movgt.w	r0, #4294967295
3401567e:	2000      	movle	r0, #0
34015680:	4770      	bx	lr
    if (diff < 0) return 1;
34015682:	2001      	movs	r0, #1
    return 0;
}
34015684:	4770      	bx	lr
34015686:	bf00      	nop
34015688:	340445b4 	.word	0x340445b4

3401568c <yolov2_pp_nmsFiltering_centroid>:


int32_t yolov2_pp_nmsFiltering_centroid(yolov2_pp_in_t  *pInput,
                                        yolov2_pp_static_param_t *pInput_static_param)
{
3401568c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int32_t i, j, k, limit_counter;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34015690:	f8d0 9000 	ldr.w	r9, [r0]
{
34015694:	460c      	mov	r4, r1

    for (k = 0; k < pInput_static_param->nb_classes; ++k)
34015696:	46ca      	mov	sl, r9
34015698:	2700      	movs	r7, #0
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401569a:	680d      	ldr	r5, [r1, #0]
{
3401569c:	b085      	sub	sp, #20
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401569e:	3505      	adds	r5, #5
        limit_counter = 0;
        AI_YOLOV2_PP_SORT_CLASS = k;

        qsort(pInbuff,
              pInput_static_param->nb_detect,
              anch_stride * sizeof(float32_t),
340156a0:	ea4f 0885 	mov.w	r8, r5, lsl #2
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
340156a4:	6823      	ldr	r3, [r4, #0]
340156a6:	42bb      	cmp	r3, r7
340156a8:	dc03      	bgt.n	340156b2 <yolov2_pp_nmsFiltering_centroid+0x26>
            }
        }
    }

    return (AI_OD_POSTPROCESS_ERROR_NO);
}
340156aa:	2000      	movs	r0, #0
340156ac:	b005      	add	sp, #20
340156ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AI_YOLOV2_PP_SORT_CLASS = k;
340156b2:	4b2b      	ldr	r3, [pc, #172]	@ (34015760 <yolov2_pp_nmsFiltering_centroid+0xd4>)
        qsort(pInbuff,
340156b4:	4648      	mov	r0, r9
        AI_YOLOV2_PP_SORT_CLASS = k;
340156b6:	601f      	str	r7, [r3, #0]
        qsort(pInbuff,
340156b8:	4642      	mov	r2, r8
340156ba:	4b2a      	ldr	r3, [pc, #168]	@ (34015764 <yolov2_pp_nmsFiltering_centroid+0xd8>)
340156bc:	6a61      	ldr	r1, [r4, #36]	@ 0x24
340156be:	f002 fa36 	bl	34017b2e <qsort>
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
340156c2:	4656      	mov	r6, sl
340156c4:	2000      	movs	r0, #0
340156c6:	6a62      	ldr	r2, [r4, #36]	@ 0x24
340156c8:	436a      	muls	r2, r5
340156ca:	4282      	cmp	r2, r0
340156cc:	dc08      	bgt.n	340156e0 <yolov2_pp_nmsFiltering_centroid+0x54>
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
340156ce:	2300      	movs	r3, #0
340156d0:	4650      	mov	r0, sl
        limit_counter = 0;
340156d2:	461e      	mov	r6, r3
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
340156d4:	429a      	cmp	r2, r3
340156d6:	da30      	bge.n	3401573a <yolov2_pp_nmsFiltering_centroid+0xae>
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
340156d8:	3701      	adds	r7, #1
340156da:	f10a 0a04 	add.w	sl, sl, #4
340156de:	e7e1      	b.n	340156a4 <yolov2_pp_nmsFiltering_centroid+0x18>
            if (pInbuff[i + AI_YOLOV2_PP_CLASSPROB + k] == 0) continue;
340156e0:	edd6 7a05 	vldr	s15, [r6, #20]
340156e4:	eef5 7a40 	vcmp.f32	s15, #0.0
340156e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340156ec:	eb05 0200 	add.w	r2, r5, r0
340156f0:	4446      	add	r6, r8
340156f2:	d101      	bne.n	340156f8 <yolov2_pp_nmsFiltering_centroid+0x6c>
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
340156f4:	4610      	mov	r0, r2
340156f6:	e7e6      	b.n	340156c6 <yolov2_pp_nmsFiltering_centroid+0x3a>
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
340156f8:	4693      	mov	fp, r2
            float32_t *a = &(pInbuff[i + AI_YOLOV2_PP_XCENTER]);
340156fa:	4633      	mov	r3, r6
340156fc:	eb09 0080 	add.w	r0, r9, r0, lsl #2
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
34015700:	6a61      	ldr	r1, [r4, #36]	@ 0x24
34015702:	4369      	muls	r1, r5
34015704:	4559      	cmp	r1, fp
34015706:	ddf5      	ble.n	340156f4 <yolov2_pp_nmsFiltering_centroid+0x68>
                if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
34015708:	eb09 018b 	add.w	r1, r9, fp, lsl #2
3401570c:	e9cd 3202 	strd	r3, r2, [sp, #8]
34015710:	9001      	str	r0, [sp, #4]
34015712:	f000 fa39 	bl	34015b88 <vision_models_box_iou>
34015716:	e9dd 0301 	ldrd	r0, r3, [sp, #4]
3401571a:	edd4 7a07 	vldr	s15, [r4, #28]
3401571e:	eeb4 0ae7 	vcmpe.f32	s0, s15
34015722:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    pInbuff[j + AI_YOLOV2_PP_CLASSPROB + k] = 0;
34015726:	bfc8      	it	gt
34015728:	eddf 7a0f 	vldrgt	s15, [pc, #60]	@ 34015768 <yolov2_pp_nmsFiltering_centroid+0xdc>
                if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
3401572c:	9a03      	ldr	r2, [sp, #12]
                    pInbuff[j + AI_YOLOV2_PP_CLASSPROB + k] = 0;
3401572e:	bfc8      	it	gt
34015730:	edc3 7a05 	vstrgt	s15, [r3, #20]
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
34015734:	44ab      	add	fp, r5
34015736:	4443      	add	r3, r8
34015738:	e7e2      	b.n	34015700 <yolov2_pp_nmsFiltering_centroid+0x74>
            if ((limit_counter < pInput_static_param->max_boxes_limit) &&
3401573a:	6961      	ldr	r1, [r4, #20]
3401573c:	42b1      	cmp	r1, r6
3401573e:	dd0a      	ble.n	34015756 <yolov2_pp_nmsFiltering_centroid+0xca>
34015740:	edd0 7a05 	vldr	s15, [r0, #20]
34015744:	eef5 7a40 	vcmp.f32	s15, #0.0
34015748:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401574c:	d003      	beq.n	34015756 <yolov2_pp_nmsFiltering_centroid+0xca>
                limit_counter++;
3401574e:	3601      	adds	r6, #1
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
34015750:	442b      	add	r3, r5
34015752:	4440      	add	r0, r8
34015754:	e7be      	b.n	340156d4 <yolov2_pp_nmsFiltering_centroid+0x48>
                pInbuff[y + AI_YOLOV2_PP_CLASSPROB + k] = 0;
34015756:	eddf 7a04 	vldr	s15, [pc, #16]	@ 34015768 <yolov2_pp_nmsFiltering_centroid+0xdc>
3401575a:	edc0 7a05 	vstr	s15, [r0, #20]
3401575e:	e7f7      	b.n	34015750 <yolov2_pp_nmsFiltering_centroid+0xc4>
34015760:	340445b4 	.word	0x340445b4
34015764:	34015655 	.word	0x34015655
34015768:	00000000 	.word	0x00000000

3401576c <yolov2_pp_scoreFiltering_centroid>:


int32_t yolov2_pp_scoreFiltering_centroid(yolov2_pp_in_t *pInput,
                                          od_pp_out_t *pOutput,
                                          yolov2_pp_static_param_t *pInput_static_param)
{
3401576c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    float32_t best_score;
    uint32_t class_index;
    int32_t det_count = 0;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);

    if (pOutput->pOutBuff == NULL)
34015770:	680b      	ldr	r3, [r1, #0]
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015772:	6817      	ldr	r7, [r2, #0]
{
34015774:	460d      	mov	r5, r1
34015776:	4616      	mov	r6, r2
    {
      pOutput->pOutBuff = (od_pp_outBuffer_t *)pInput->pRaw_detections;
34015778:	6804      	ldr	r4, [r0, #0]
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401577a:	3705      	adds	r7, #5
    if (pOutput->pOutBuff == NULL)
3401577c:	b903      	cbnz	r3, 34015780 <yolov2_pp_scoreFiltering_centroid+0x14>
      pOutput->pOutBuff = (od_pp_outBuffer_t *)pInput->pRaw_detections;
3401577e:	600c      	str	r4, [r1, #0]
    }
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;

    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
34015780:	f04f 0900 	mov.w	r9, #0
             &best_score,
             &class_index);

        if (best_score >= pInput_static_param->conf_threshold)
        {
            pOutput->pOutBuff[det_count].x_center = pInbuff[i + AI_YOLOV2_PP_XCENTER];
34015784:	f04f 0b18 	mov.w	fp, #24
    int32_t det_count = 0;
34015788:	46c8      	mov	r8, r9
3401578a:	ea4f 0a87 	mov.w	sl, r7, lsl #2
3401578e:	3414      	adds	r4, #20
    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
34015790:	6a73      	ldr	r3, [r6, #36]	@ 0x24
34015792:	437b      	muls	r3, r7
34015794:	454b      	cmp	r3, r9
34015796:	dc05      	bgt.n	340157a4 <yolov2_pp_scoreFiltering_centroid+0x38>
        }
    }
    pOutput->nb_detect = det_count;

    return (AI_OD_POSTPROCESS_ERROR_NO);
}
34015798:	2000      	movs	r0, #0
    pOutput->nb_detect = det_count;
3401579a:	f8c5 8004 	str.w	r8, [r5, #4]
}
3401579e:	b003      	add	sp, #12
340157a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        vision_models_maxi_if32ou32(&pInbuff[i + AI_YOLOV2_PP_CLASSPROB],
340157a4:	466a      	mov	r2, sp
340157a6:	4620      	mov	r0, r4
340157a8:	6831      	ldr	r1, [r6, #0]
340157aa:	ab01      	add	r3, sp, #4
340157ac:	f000 f913 	bl	340159d6 <vision_models_maxi_if32ou32>
        if (best_score >= pInput_static_param->conf_threshold)
340157b0:	eddd 7a00 	vldr	s15, [sp]
340157b4:	ed96 7a06 	vldr	s14, [r6, #24]
340157b8:	eeb4 7ae7 	vcmpe.f32	s14, s15
340157bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340157c0:	d814      	bhi.n	340157ec <yolov2_pp_scoreFiltering_centroid+0x80>
            pOutput->pOutBuff[det_count].x_center = pInbuff[i + AI_YOLOV2_PP_XCENTER];
340157c2:	682b      	ldr	r3, [r5, #0]
340157c4:	f854 2c14 	ldr.w	r2, [r4, #-20]
340157c8:	fb0b 3308 	mla	r3, fp, r8, r3
340157cc:	601a      	str	r2, [r3, #0]
            pOutput->pOutBuff[det_count].y_center = pInbuff[i + AI_YOLOV2_PP_YCENTER];
340157ce:	f854 2c10 	ldr.w	r2, [r4, #-16]
            det_count++;
340157d2:	f108 0801 	add.w	r8, r8, #1
            pOutput->pOutBuff[det_count].y_center = pInbuff[i + AI_YOLOV2_PP_YCENTER];
340157d6:	605a      	str	r2, [r3, #4]
            pOutput->pOutBuff[det_count].width = pInbuff[i + AI_YOLOV2_PP_WIDTHREL];
340157d8:	f854 2c0c 	ldr.w	r2, [r4, #-12]
340157dc:	609a      	str	r2, [r3, #8]
            pOutput->pOutBuff[det_count].height = pInbuff[i + AI_YOLOV2_PP_HEIGHTREL];
340157de:	f854 2c08 	ldr.w	r2, [r4, #-8]
            pOutput->pOutBuff[det_count].conf = best_score;
340157e2:	edc3 7a04 	vstr	s15, [r3, #16]
            pOutput->pOutBuff[det_count].height = pInbuff[i + AI_YOLOV2_PP_HEIGHTREL];
340157e6:	60da      	str	r2, [r3, #12]
            pOutput->pOutBuff[det_count].class_index = class_index;
340157e8:	9a01      	ldr	r2, [sp, #4]
340157ea:	615a      	str	r2, [r3, #20]
    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
340157ec:	44b9      	add	r9, r7
340157ee:	4454      	add	r4, sl
340157f0:	e7ce      	b.n	34015790 <yolov2_pp_scoreFiltering_centroid+0x24>

340157f2 <yolov2_pp_getNNBoxes_centroid>:


int32_t yolov2_pp_getNNBoxes_centroid(yolov2_pp_in_t *pInput,
                                      yolov2_pp_static_param_t *pInput_static_param)
{
340157f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340157f6:	ed2d 8b04 	vpush	{d8-d9}
340157fa:	b08b      	sub	sp, #44	@ 0x2c
    float32_t best_score=0;
    uint32_t class_index;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);

    yolov2_pp_in_t *pOutput = pInput;
    float32_t grid_width_inv = 1.0f / pInput_static_param->grid_width;
340157fc:	edd1 7a02 	vldr	s15, [r1, #8]
34015800:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
34015804:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34015808:	eec7 8a27 	vdiv.f32	s17, s14, s15
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
3401580c:	edd1 7a03 	vldr	s15, [r1, #12]
    float32_t tmp_a[pInput_static_param->nb_classes];
    int32_t el_offset = 0;
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
    float32_t *pOutbuff = (float32_t *)pOutput->pRaw_detections;
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
34015810:	2500      	movs	r5, #0
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
34015812:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float32_t best_score=0;
34015816:	2300      	movs	r3, #0
{
34015818:	460c      	mov	r4, r1
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
3401581a:	ee87 9a27 	vdiv.f32	s18, s14, s15
    int32_t el_offset = 0;
3401581e:	462e      	mov	r6, r5
    int32_t count = 0;
34015820:	46aa      	mov	sl, r5
{
34015822:	af00      	add	r7, sp, #0
    float32_t best_score=0;
34015824:	623b      	str	r3, [r7, #32]
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015826:	680b      	ldr	r3, [r1, #0]
34015828:	1d5a      	adds	r2, r3, #5
    float32_t tmp_a[pInput_static_param->nb_classes];
3401582a:	009b      	lsls	r3, r3, #2
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401582c:	613a      	str	r2, [r7, #16]
    float32_t tmp_a[pInput_static_param->nb_classes];
3401582e:	1dda      	adds	r2, r3, #7
34015830:	f022 0207 	bic.w	r2, r2, #7
34015834:	ebad 0d02 	sub.w	sp, sp, r2
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34015838:	6802      	ldr	r2, [r0, #0]
3401583a:	3314      	adds	r3, #20
    float32_t tmp_a[pInput_static_param->nb_classes];
3401583c:	f8c7 d00c 	str.w	sp, [r7, #12]
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34015840:	617a      	str	r2, [r7, #20]
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
34015842:	60bb      	str	r3, [r7, #8]
    int32_t count_detect = 0;
34015844:	61bd      	str	r5, [r7, #24]
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
34015846:	68a3      	ldr	r3, [r4, #8]
34015848:	42ab      	cmp	r3, r5
3401584a:	f300 80a7 	bgt.w	3401599c <yolov2_pp_getNNBoxes_centroid+0x1aa>
        }
    }

    pInput_static_param->nb_detect = count_detect;
    return (error);
}
3401584e:	2000      	movs	r0, #0
    pInput_static_param->nb_detect = count_detect;
34015850:	69bb      	ldr	r3, [r7, #24]
}
34015852:	372c      	adds	r7, #44	@ 0x2c
    pInput_static_param->nb_detect = count_detect;
34015854:	6263      	str	r3, [r4, #36]	@ 0x24
}
34015856:	46bd      	mov	sp, r7
34015858:	ecbd 8b04 	vpop	{d8-d9}
3401585c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] = vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS]);
34015860:	ed1b 0a01 	vldr	s0, [fp, #-4]
34015864:	f000 f8f2 	bl	34015a4c <vision_models_sigmoid_f>
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34015868:	4659      	mov	r1, fp
3401586a:	68fb      	ldr	r3, [r7, #12]
3401586c:	6822      	ldr	r2, [r4, #0]
                pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] = vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS]);
3401586e:	ed0b 0a01 	vstr	s0, [fp, #-4]
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34015872:	4658      	mov	r0, fp
34015874:	f000 f8f6 	bl	34015a64 <vision_models_softmax_f>
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
34015878:	6821      	ldr	r1, [r4, #0]
3401587a:	465a      	mov	r2, fp
3401587c:	2900      	cmp	r1, #0
3401587e:	f101 0301 	add.w	r3, r1, #1
34015882:	bfb8      	it	lt
34015884:	2301      	movlt	r3, #1
34015886:	3b01      	subs	r3, #1
34015888:	d17a      	bne.n	34015980 <yolov2_pp_getNNBoxes_centroid+0x18e>
                vision_models_maxi_if32ou32(&pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401588a:	4658      	mov	r0, fp
3401588c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34015890:	f107 0220 	add.w	r2, r7, #32
34015894:	f000 f89f 	bl	340159d6 <vision_models_maxi_if32ou32>
                if (best_score >= pInput_static_param->conf_threshold)
34015898:	ed94 7a06 	vldr	s14, [r4, #24]
3401589c:	edd7 7a08 	vldr	s15, [r7, #32]
340158a0:	eeb4 7ae7 	vcmpe.f32	s14, s15
340158a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340158a8:	d851      	bhi.n	3401594e <yolov2_pp_getNNBoxes_centroid+0x15c>
                    pOutbuff[count + AI_YOLOV2_PP_OBJECTNESS] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS];
340158aa:	6979      	ldr	r1, [r7, #20]
340158ac:	f10a 0304 	add.w	r3, sl, #4
340158b0:	eb01 0883 	add.w	r8, r1, r3, lsl #2
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
340158b4:	6821      	ldr	r1, [r4, #0]
                    pOutbuff[count + AI_YOLOV2_PP_OBJECTNESS] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS];
340158b6:	f85b 2c04 	ldr.w	r2, [fp, #-4]
340158ba:	4643      	mov	r3, r8
340158bc:	2900      	cmp	r1, #0
340158be:	f8c8 2000 	str.w	r2, [r8]
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
340158c2:	46dc      	mov	ip, fp
340158c4:	f101 0201 	add.w	r2, r1, #1
340158c8:	bfb8      	it	lt
340158ca:	2201      	movlt	r2, #1
340158cc:	3304      	adds	r3, #4
340158ce:	3a01      	subs	r2, #1
340158d0:	d15f      	bne.n	34015992 <yolov2_pp_getNNBoxes_centroid+0x1a0>
                    pOutbuff[count + AI_YOLOV2_PP_XCENTER] = (col + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_XCENTER])) * grid_width_inv;
340158d2:	ed1b 0a05 	vldr	s0, [fp, #-20]	@ 0xffffffec
340158d6:	f000 f8b9 	bl	34015a4c <vision_models_sigmoid_f>
340158da:	edd7 7a07 	vldr	s15, [r7, #28]
340158de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340158e2:	ee77 7a80 	vadd.f32	s15, s15, s0
340158e6:	ee67 7aa8 	vmul.f32	s15, s15, s17
340158ea:	ed48 7a04 	vstr	s15, [r8, #-16]
                    pOutbuff[count + AI_YOLOV2_PP_YCENTER] = (row + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_YCENTER])) * grid_height_inv;
340158ee:	ed1b 0a04 	vldr	s0, [fp, #-16]
340158f2:	f000 f8ab 	bl	34015a4c <vision_models_sigmoid_f>
340158f6:	ee07 5a90 	vmov	s15, r5
340158fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340158fe:	ee77 7a80 	vadd.f32	s15, s15, s0
34015902:	ee67 7a89 	vmul.f32	s15, s15, s18
34015906:	ed48 7a03 	vstr	s15, [r8, #-12]
                    pOutbuff[count + AI_YOLOV2_PP_WIDTHREL] = (pInput_static_param->pAnchors[2 * anch] * expf(pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL])) * grid_width_inv;
3401590a:	6a23      	ldr	r3, [r4, #32]
3401590c:	ed1b 0a03 	vldr	s0, [fp, #-12]
34015910:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
34015914:	ed93 8a00 	vldr	s16, [r3]
34015918:	607b      	str	r3, [r7, #4]
3401591a:	f005 fd35 	bl	3401b388 <expf>
3401591e:	ee28 8a00 	vmul.f32	s16, s16, s0
34015922:	ee28 8a28 	vmul.f32	s16, s16, s17
34015926:	ed08 8a02 	vstr	s16, [r8, #-8]
                    pOutbuff[count + AI_YOLOV2_PP_HEIGHTREL] = (pInput_static_param->pAnchors[2 * anch + 1] * expf(pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL])) * grid_height_inv;
3401592a:	687b      	ldr	r3, [r7, #4]
3401592c:	ed1b 0a02 	vldr	s0, [fp, #-8]
34015930:	ed93 8a01 	vldr	s16, [r3, #4]
34015934:	f005 fd28 	bl	3401b388 <expf>
34015938:	ee28 8a00 	vmul.f32	s16, s16, s0
3401593c:	ee28 8a09 	vmul.f32	s16, s16, s18
34015940:	ed08 8a01 	vstr	s16, [r8, #-4]
                    count += anch_stride;
34015944:	693b      	ldr	r3, [r7, #16]
34015946:	449a      	add	sl, r3
                    count_detect++;
34015948:	69bb      	ldr	r3, [r7, #24]
3401594a:	3301      	adds	r3, #1
3401594c:	61bb      	str	r3, [r7, #24]
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
3401594e:	68bb      	ldr	r3, [r7, #8]
34015950:	f109 0901 	add.w	r9, r9, #1
34015954:	449b      	add	fp, r3
34015956:	693b      	ldr	r3, [r7, #16]
34015958:	441e      	add	r6, r3
3401595a:	6863      	ldr	r3, [r4, #4]
3401595c:	454b      	cmp	r3, r9
3401595e:	f73f af7f 	bgt.w	34015860 <yolov2_pp_getNNBoxes_centroid+0x6e>
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
34015962:	69fb      	ldr	r3, [r7, #28]
34015964:	3e05      	subs	r6, #5
34015966:	3301      	adds	r3, #1
34015968:	61fb      	str	r3, [r7, #28]
3401596a:	69fa      	ldr	r2, [r7, #28]
3401596c:	68e3      	ldr	r3, [r4, #12]
3401596e:	4293      	cmp	r3, r2
34015970:	dd16      	ble.n	340159a0 <yolov2_pp_getNNBoxes_centroid+0x1ae>
34015972:	697b      	ldr	r3, [r7, #20]
34015974:	3605      	adds	r6, #5
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015976:	f04f 0900 	mov.w	r9, #0
3401597a:	eb03 0b86 	add.w	fp, r3, r6, lsl #2
3401597e:	e7ec      	b.n	3401595a <yolov2_pp_getNNBoxes_centroid+0x168>
                                                                       pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
34015980:	ed92 7a00 	vldr	s14, [r2]
                    pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] *
34015984:	ed5b 7a01 	vldr	s15, [fp, #-4]
34015988:	ee67 7a87 	vmul.f32	s15, s15, s14
3401598c:	ece2 7a01 	vstmia	r2!, {s15}
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
34015990:	e779      	b.n	34015886 <yolov2_pp_getNNBoxes_centroid+0x94>
                        pOutbuff[count + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
34015992:	f85c 1b04 	ldr.w	r1, [ip], #4
34015996:	f843 1b04 	str.w	r1, [r3], #4
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
3401599a:	e798      	b.n	340158ce <yolov2_pp_getNNBoxes_centroid+0xdc>
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
3401599c:	2300      	movs	r3, #0
3401599e:	e7e3      	b.n	34015968 <yolov2_pp_getNNBoxes_centroid+0x176>
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
340159a0:	3501      	adds	r5, #1
340159a2:	e750      	b.n	34015846 <yolov2_pp_getNNBoxes_centroid+0x54>

340159a4 <od_yolov2_pp_reset>:


/* ----------------------       Exported routines      ---------------------- */

int32_t od_yolov2_pp_reset(yolov2_pp_static_param_t *pInput_static_param)
{
340159a4:	4603      	mov	r3, r0
    /* Initializations */
    pInput_static_param->nb_detect = 0;
340159a6:	2000      	movs	r0, #0
340159a8:	6258      	str	r0, [r3, #36]	@ 0x24

	return (AI_OD_POSTPROCESS_ERROR_NO);
}
340159aa:	4770      	bx	lr

340159ac <od_yolov2_pp_process>:


int32_t od_yolov2_pp_process(yolov2_pp_in_t *pInput,
                                    od_pp_out_t *pOutput,
                                    yolov2_pp_static_param_t *pInput_static_param)
{
340159ac:	b570      	push	{r4, r5, r6, lr}
340159ae:	460e      	mov	r6, r1
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;

    /* Call Get NN boxes first */
    error = yolov2_pp_getNNBoxes_centroid(pInput,
340159b0:	4611      	mov	r1, r2
{
340159b2:	4605      	mov	r5, r0
340159b4:	4614      	mov	r4, r2
    error = yolov2_pp_getNNBoxes_centroid(pInput,
340159b6:	f7ff ff1c 	bl	340157f2 <yolov2_pp_getNNBoxes_centroid>
                                          pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
340159ba:	b958      	cbnz	r0, 340159d4 <od_yolov2_pp_process+0x28>

    /* Then NMS */
    error = yolov2_pp_nmsFiltering_centroid(pInput,
340159bc:	4621      	mov	r1, r4
340159be:	4628      	mov	r0, r5
340159c0:	f7ff fe64 	bl	3401568c <yolov2_pp_nmsFiltering_centroid>
                                            pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
340159c4:	b930      	cbnz	r0, 340159d4 <od_yolov2_pp_process+0x28>

    /* And score re-filtering */
    error = yolov2_pp_scoreFiltering_centroid(pInput,
340159c6:	4622      	mov	r2, r4
340159c8:	4631      	mov	r1, r6
340159ca:	4628      	mov	r0, r5
                                              pOutput,
                                              pInput_static_param);

    return (error);
}
340159cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    error = yolov2_pp_scoreFiltering_centroid(pInput,
340159d0:	f7ff becc 	b.w	3401576c <yolov2_pp_scoreFiltering_centroid>
}
340159d4:	bd70      	pop	{r4, r5, r6, pc}

340159d6 <vision_models_maxi_if32ou32>:
#include "stdio.h"

/* return max value and it's index from an array */
#if defined(AI_OD_YOLOV5_PP_MVEF_OPTIM) || defined(AI_SPE_MOVENET_PP_MVEF_OPTIM)
void vision_models_maxi_if32ou32(float32_t *arr, uint32_t len_arr, float32_t *maxim, uint32_t *index)
{
340159d6:	b5f0      	push	{r4, r5, r6, r7, lr}

__extension__ extern __inline uint32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_u32 (uint32_t __a)
{
  return __builtin_mve_vdupq_n_uv4si (__a);
340159d8:	2400      	movs	r4, #0

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_f32 (float32_t __a)
{
  return __builtin_mve_vdupq_n_fv4sf (__a);
340159da:	f46f 0500 	mvn.w	r5, #8388608	@ 0x800000
  return __builtin_mve_vdupq_n_uv4si (__a);
340159de:	eea6 4b10 	vdup.32	q3, r4
  return __builtin_mve_vidupq_n_uv4si (__a, __imm);
340159e2:	ee25 2f6e 	cdp	15, 2, cr2, cr5, cr14, {3}

    // according to p0: update with s8x16_val or keep s8x16_blk_minmax_val
    f32x4_max_val = vpselq_f32(f32x4_val, f32x4_max_val, p0);
    /* according to p0: store per-lane extrema indexes*/
    u32x4_max_idx = vpselq_u32(u32x4_idx, u32x4_max_idx, p0);
    u32x4_idx+=4;
340159e6:	1ccc      	adds	r4, r1, #3
340159e8:	08a4      	lsrs	r4, r4, #2
340159ea:	f111 0f04 	cmn.w	r1, #4
340159ee:	f104 0401 	add.w	r4, r4, #1
{
340159f2:	ed2d 8b04 	vpush	{d8-d9}
  return __builtin_mve_vdupq_n_fv4sf (__a);
340159f6:	eea4 5b10 	vdup.32	q2, r5
  int32_t iter = len_arr;
340159fa:	460f      	mov	r7, r1
    u32x4_idx+=4;
340159fc:	ef80 8054 	vmov.i32	q4, #4	@ 0x00000004
34015a00:	bfcc      	ite	gt
34015a02:	4626      	movgt	r6, r4
34015a04:	2601      	movle	r6, #1
  while(iter > 0)
34015a06:	3e01      	subs	r6, #1
34015a08:	d10e      	bne.n	34015a28 <vision_models_maxi_if32ou32+0x52>
  /*
   * Get min index which is thus for a max value
   */
  *index = (int32_t)vminvq_u32(len_arr, indexVec);

}
34015a0a:	ecbd 8b04 	vpop	{d8-d9}

__extension__ extern __inline float32_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vmaxnmvq_f32 (float32_t __a, float32x4_t __b)
{
  return __builtin_mve_vmaxnmvq_fv4sf (__a, __b);
34015a0e:	eeee 5f04 	cdp	15, 14, cr5, cr14, cr4, {0}
  return __builtin_mve_vcmpgeq_n_fv4sf (__a, __b);
34015a12:	ee35 1f45 	cdp	15, 3, cr1, cr5, cr5, {2}
  return __builtin_mve_vdupq_n_uv4si (__a);
34015a16:	eea4 1b10 	vdup.32	q2, r1
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
34015a1a:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}
  return __builtin_mve_vminvq_uv4si (__a, __b);
34015a1e:	feea 1f86 	cdp2	15, 14, cr1, cr10, cr6, {4}
  *maxim = vmaxnmvq_f32(F32_MIN, f32x4_max_val);
34015a22:	6015      	str	r5, [r2, #0]
  *index = (int32_t)vminvq_u32(len_arr, indexVec);
34015a24:	6019      	str	r1, [r3, #0]
}
34015a26:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return __builtin_mve_vctp32qv4bi (__a);
34015a28:	f027 e801 	bfcsel	0, 34014a2e <ISP_SVC_ISP_GetColorConv+0x1a>, 4, ls

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vldrwq_z_f32 (float32_t const * __base, mve_pred16_t __p)
{
  return __builtin_mve_vldrwq_z_fv4sf((__builtin_neon_si *) __base, __p);
34015a2c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34015a30:	ecb0 1f04 	ldc	15, cr1, [r0], #16
  return __builtin_mve_vcmpgtq_m_fv4sf (__a, __b, __p);
34015a34:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34015a38:	ee31 1f05 	cdp	15, 3, cr1, cr1, cr5, {0}
    iter-=4;
34015a3c:	3f04      	subs	r7, #4
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
34015a3e:	fe33 6f07 	cdp2	15, 3, cr6, cr3, cr7, {0}
  return __builtin_mve_vpselq_fv4sf (__a, __b, __p);
34015a42:	fe31 4f05 	cdp2	15, 3, cr4, cr1, cr5, {0}
    u32x4_idx+=4;
34015a46:	ef22 2848 	vadd.i32	q1, q1, q4
    iter-=4;
34015a4a:	e7dc      	b.n	34015a06 <vision_models_maxi_if32ou32+0x30>

34015a4c <vision_models_sigmoid_f>:
    }
  }
}

float32_t vision_models_sigmoid_f(float32_t x)
{
34015a4c:	b508      	push	{r3, lr}
  return (1.0f / (1.0f + expf(-x)));
34015a4e:	eeb1 0a40 	vneg.f32	s0, s0
34015a52:	f005 fc99 	bl	3401b388 <expf>
34015a56:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34015a5a:	ee30 0a27 	vadd.f32	s0, s0, s15
}
34015a5e:	ee87 0a80 	vdiv.f32	s0, s15, s0
34015a62:	bd08      	pop	{r3, pc}

34015a64 <vision_models_softmax_f>:


void vision_models_softmax_f(float32_t *input_x, float32_t *output_x, int32_t len_x, float32_t *tmp_x)
{
34015a64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34015a68:	460f      	mov	r7, r1
34015a6a:	ed2d 8b02 	vpush	{d8}
34015a6e:	4614      	mov	r4, r2
34015a70:	461d      	mov	r5, r3
34015a72:	4606      	mov	r6, r0
34015a74:	4698      	mov	r8, r3
  float32_t sum = 0;

  for (int32_t i = 0; i < len_x; ++i)
34015a76:	469a      	mov	sl, r3
34015a78:	f04f 0900 	mov.w	r9, #0
  float32_t sum = 0;
34015a7c:	ed9f 8a14 	vldr	s16, [pc, #80]	@ 34015ad0 <vision_models_softmax_f+0x6c>
  for (int32_t i = 0; i < len_x; ++i)
34015a80:	45a1      	cmp	r9, r4
34015a82:	db13      	blt.n	34015aac <vision_models_softmax_f+0x48>
  {
    tmp_x[i] = expf(input_x[i]);
    sum = sum + tmp_x[i];
  }
  sum = 1.0f / sum;
34015a84:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34015a88:	2c00      	cmp	r4, #0
34015a8a:	f104 0201 	add.w	r2, r4, #1
34015a8e:	ee87 7a88 	vdiv.f32	s14, s15, s16
  for (int32_t i = 0; i < len_x; ++i)
34015a92:	bfb8      	it	lt
34015a94:	2201      	movlt	r2, #1
34015a96:	3a01      	subs	r2, #1
34015a98:	d113      	bne.n	34015ac2 <vision_models_softmax_f+0x5e>
  {
    tmp_x[i] *= sum;
  }
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
}
34015a9a:	ecbd 8b02 	vpop	{d8}
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
34015a9e:	4629      	mov	r1, r5
34015aa0:	4638      	mov	r0, r7
34015aa2:	00a2      	lsls	r2, r4, #2
}
34015aa4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
34015aa8:	f003 baff 	b.w	340190aa <memcpy>
    tmp_x[i] = expf(input_x[i]);
34015aac:	ecb6 0a01 	vldmia	r6!, {s0}
34015ab0:	f005 fc6a 	bl	3401b388 <expf>
  for (int32_t i = 0; i < len_x; ++i)
34015ab4:	f109 0901 	add.w	r9, r9, #1
    tmp_x[i] = expf(input_x[i]);
34015ab8:	ecaa 0a01 	vstmia	sl!, {s0}
    sum = sum + tmp_x[i];
34015abc:	ee38 8a00 	vadd.f32	s16, s16, s0
  for (int32_t i = 0; i < len_x; ++i)
34015ac0:	e7de      	b.n	34015a80 <vision_models_softmax_f+0x1c>
    tmp_x[i] *= sum;
34015ac2:	edd8 7a00 	vldr	s15, [r8]
34015ac6:	ee67 7a87 	vmul.f32	s15, s15, s14
34015aca:	ece8 7a01 	vstmia	r8!, {s15}
  for (int32_t i = 0; i < len_x; ++i)
34015ace:	e7e2      	b.n	34015a96 <vision_models_softmax_f+0x32>
34015ad0:	00000000 	.word	0x00000000

34015ad4 <overlap>:

//***************iou ********
//inline
float32_t overlap(float32_t x1, float32_t w1, float32_t x2, float32_t w2)
{
  float32_t l1 = x1 - w1 / 2;
34015ad4:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
34015ad8:	ee60 0aa7 	vmul.f32	s1, s1, s15
  float32_t l2 = x2 - w2 / 2;
34015adc:	ee61 1aa7 	vmul.f32	s3, s3, s15
  float32_t l1 = x1 - w1 / 2;
34015ae0:	ee30 7a60 	vsub.f32	s14, s0, s1
  float32_t l2 = x2 - w2 / 2;
34015ae4:	ee71 7a61 	vsub.f32	s15, s2, s3
  float32_t left = l1 > l2 ? l1 : l2;
  float32_t r1 = x1 + w1 / 2;
34015ae8:	ee70 0a80 	vadd.f32	s1, s1, s0
  float32_t left = l1 > l2 ? l1 : l2;
34015aec:	eeb4 7a67 	vcmp.f32	s14, s15
  float32_t r2 = x2 + w2 / 2;
34015af0:	ee31 1a81 	vadd.f32	s2, s3, s2
  float32_t left = l1 > l2 ? l1 : l2;
34015af4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t right = r1 < r2 ? r1 : r2;
34015af8:	eef4 0a41 	vcmp.f32	s1, s2
  float32_t left = l1 > l2 ? l1 : l2;
34015afc:	fe77 7a27 	vselgt.f32	s15, s14, s15
  float32_t right = r1 < r2 ? r1 : r2;
34015b00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015b04:	bf48      	it	mi
34015b06:	eeb0 1a60 	vmovmi.f32	s2, s1
  return (right - left);
}
34015b0a:	ee31 0a67 	vsub.f32	s0, s2, s15
34015b0e:	4770      	bx	lr

34015b10 <box_intersection>:

//inline
float32_t box_intersection(float32_t *a, float32_t *b)
{
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34015b10:	edd1 1a02 	vldr	s3, [r1, #8]
34015b14:	ed91 1a00 	vldr	s2, [r1]
34015b18:	edd0 0a02 	vldr	s1, [r0, #8]
34015b1c:	ed90 0a00 	vldr	s0, [r0]
{
34015b20:	b508      	push	{r3, lr}
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34015b22:	f7ff ffd7 	bl	34015ad4 <overlap>
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
  if (w < 0 || h < 0) return 0;
34015b26:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
34015b2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34015b2e:	eef0 6a40 	vmov.f32	s13, s0
  if (w < 0 || h < 0) return 0;
34015b32:	d411      	bmi.n	34015b58 <box_intersection+0x48>
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
34015b34:	edd1 1a03 	vldr	s3, [r1, #12]
34015b38:	ed91 1a01 	vldr	s2, [r1, #4]
34015b3c:	edd0 0a03 	vldr	s1, [r0, #12]
34015b40:	ed90 0a01 	vldr	s0, [r0, #4]
34015b44:	f7ff ffc6 	bl	34015ad4 <overlap>
  if (w < 0 || h < 0) return 0;
34015b48:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
34015b4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015b50:	d402      	bmi.n	34015b58 <box_intersection+0x48>
  float32_t area = w * h;
34015b52:	ee26 0a80 	vmul.f32	s0, s13, s0
  return (area);
}
34015b56:	bd08      	pop	{r3, pc}
  if (w < 0 || h < 0) return 0;
34015b58:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34015b60 <box_intersection+0x50>
34015b5c:	e7fb      	b.n	34015b56 <box_intersection+0x46>
34015b5e:	bf00      	nop
34015b60:	00000000 	.word	0x00000000

34015b64 <box_union>:

//inline
float32_t box_union(float32_t *a, float32_t *b)
{
34015b64:	b510      	push	{r4, lr}
  float32_t i = box_intersection(a, b);
34015b66:	f7ff ffd3 	bl	34015b10 <box_intersection>
  float32_t u = a[2] * a[3] + b[2] * b[3] - i;
34015b6a:	ed91 7a03 	vldr	s14, [r1, #12]
34015b6e:	edd1 7a02 	vldr	s15, [r1, #8]
34015b72:	edd0 6a02 	vldr	s13, [r0, #8]
34015b76:	ee67 7a87 	vmul.f32	s15, s15, s14
34015b7a:	ed90 7a03 	vldr	s14, [r0, #12]
34015b7e:	eee6 7a87 	vfma.f32	s15, s13, s14
  return (u);
}
34015b82:	ee37 0ac0 	vsub.f32	s0, s15, s0
34015b86:	bd10      	pop	{r4, pc}

34015b88 <vision_models_box_iou>:


float32_t vision_models_box_iou(float32_t *a, float32_t *b)
{
34015b88:	b508      	push	{r3, lr}

  float32_t I = box_intersection(a, b);
34015b8a:	f7ff ffc1 	bl	34015b10 <box_intersection>
  float32_t U = box_union(a, b);
 if (I == 0 || U == 0)
34015b8e:	eeb5 0a40 	vcmp.f32	s0, #0.0
34015b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t I = box_intersection(a, b);
34015b96:	eeb0 6a40 	vmov.f32	s12, s0
 if (I == 0 || U == 0)
34015b9a:	d00b      	beq.n	34015bb4 <vision_models_box_iou+0x2c>
  float32_t U = box_union(a, b);
34015b9c:	f7ff ffe2 	bl	34015b64 <box_union>
 if (I == 0 || U == 0)
34015ba0:	eeb5 0a40 	vcmp.f32	s0, #0.0
34015ba4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t U = box_union(a, b);
34015ba8:	eef0 7a40 	vmov.f32	s15, s0
 if (I == 0 || U == 0)
34015bac:	d002      	beq.n	34015bb4 <vision_models_box_iou+0x2c>
  {
    return 0;
  }
  return (I / U);
34015bae:	ee86 0a27 	vdiv.f32	s0, s12, s15
}
34015bb2:	bd08      	pop	{r3, pc}
    return 0;
34015bb4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34015bbc <vision_models_box_iou+0x34>
34015bb8:	e7fb      	b.n	34015bb2 <vision_models_box_iou+0x2a>
34015bba:	bf00      	nop
34015bbc:	00000000 	.word	0x00000000

34015bc0 <LL_ATON_Init>:
/**
 * @brief  ATON global initialization. Initializes clocks and bus interfaces. Must be called before anything else
 * @retval Always zero
 */
int LL_ATON_Init(void)
{
34015bc0:	b510      	push	{r4, lr}
  if (done != 0)
34015bc2:	4ba3      	ldr	r3, [pc, #652]	@ (34015e50 <LL_ATON_Init+0x290>)
{
34015bc4:	b088      	sub	sp, #32
  if (done != 0)
34015bc6:	781a      	ldrb	r2, [r3, #0]
34015bc8:	b90a      	cbnz	r2, 34015bce <LL_ATON_Init+0xe>
  done = 1;
34015bca:	2201      	movs	r2, #1
34015bcc:	701a      	strb	r2, [r3, #0]
  int i;

  ll_aton_static_checks();

  /* Clear pipeline */
  t = ATON_CLKCTRL_CTRL_GET(0);
34015bce:	4ba1      	ldr	r3, [pc, #644]	@ (34015e54 <LL_ATON_Init+0x294>)
34015bd0:	681a      	ldr	r2, [r3, #0]
  t = ATON_CLKCTRL_CTRL_SET_CLR(t, 1);
34015bd2:	f042 0202 	orr.w	r2, r2, #2
  ATON_CLKCTRL_CTRL_SET(0, t);
34015bd6:	601a      	str	r2, [r3, #0]

  /* Enable all ATON clocks */
  ATON_CLKCTRL_CTRL_SET(0, 1);
34015bd8:	2201      	movs	r2, #1
34015bda:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES0_SET(0, 0xffffffff);
34015bdc:	f04f 32ff 	mov.w	r2, #4294967295
34015be0:	609a      	str	r2, [r3, #8]
  ATON_CLKCTRL_AGATES1_SET(0, 0xffffffff);
34015be2:	60da      	str	r2, [r3, #12]

#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ATON_CLKCTRL_BGATES_SET(0, (1 << ATON_EPOCHCTRL_CLKB_CLK(0)));
#else
  ATON_CLKCTRL_BGATES_SET(0, 0x0);
34015be4:	2200      	movs	r2, #0
34015be6:	611a      	str	r2, [r3, #16]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0xffffffff);
#endif

  /* Check that RTL and ATON.h match. Only check first unit */
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34015be8:	f503 43a0 	add.w	r3, r3, #20480	@ 0x5000
34015bec:	685c      	ldr	r4, [r3, #4]
34015bee:	2c00      	cmp	r4, #0
34015bf0:	d0fc      	beq.n	34015bec <LL_ATON_Init+0x2c>
34015bf2:	f245 0301 	movw	r3, #20481	@ 0x5001
34015bf6:	b2a2      	uxth	r2, r4
34015bf8:	429a      	cmp	r2, r3
34015bfa:	f040 8092 	bne.w	34015d22 <LL_ATON_Init+0x162>

#ifdef ATON_CONVACC_NUM
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34015bfe:	4b96      	ldr	r3, [pc, #600]	@ (34015e58 <LL_ATON_Init+0x298>)
34015c00:	685c      	ldr	r4, [r3, #4]
34015c02:	2c00      	cmp	r4, #0
34015c04:	d0fc      	beq.n	34015c00 <LL_ATON_Init+0x40>
34015c06:	f245 1317 	movw	r3, #20759	@ 0x5117
34015c0a:	b2a2      	uxth	r2, r4
34015c0c:	429a      	cmp	r2, r3
34015c0e:	f040 80b0 	bne.w	34015d72 <LL_ATON_Init+0x1b2>
#endif

#ifdef ATON_POOL_NUM
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
34015c12:	4b92      	ldr	r3, [pc, #584]	@ (34015e5c <LL_ATON_Init+0x29c>)
34015c14:	685c      	ldr	r4, [r3, #4]
34015c16:	2c00      	cmp	r4, #0
34015c18:	d0fc      	beq.n	34015c14 <LL_ATON_Init+0x54>
34015c1a:	f241 131c 	movw	r3, #4380	@ 0x111c
34015c1e:	b2a2      	uxth	r2, r4
34015c20:	429a      	cmp	r2, r3
34015c22:	f040 80cc 	bne.w	34015dbe <LL_ATON_Init+0x1fe>
#endif

#ifdef ATON_ARITH_NUM
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
34015c26:	4b8e      	ldr	r3, [pc, #568]	@ (34015e60 <LL_ATON_Init+0x2a0>)
34015c28:	685c      	ldr	r4, [r3, #4]
34015c2a:	2c00      	cmp	r4, #0
34015c2c:	d0fc      	beq.n	34015c28 <LL_ATON_Init+0x68>
34015c2e:	f241 031a 	movw	r3, #4122	@ 0x101a
34015c32:	b2a2      	uxth	r2, r4
34015c34:	429a      	cmp	r2, r3
34015c36:	f040 80e6 	bne.w	34015e06 <LL_ATON_Init+0x246>
#endif

#ifdef ATON_ACTIV_NUM
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
34015c3a:	4b8a      	ldr	r3, [pc, #552]	@ (34015e64 <LL_ATON_Init+0x2a4>)
34015c3c:	685c      	ldr	r4, [r3, #4]
34015c3e:	2c00      	cmp	r4, #0
34015c40:	d0fc      	beq.n	34015c3c <LL_ATON_Init+0x7c>
34015c42:	f241 131b 	movw	r3, #4379	@ 0x111b
34015c46:	b2a2      	uxth	r2, r4
34015c48:	429a      	cmp	r2, r3
34015c4a:	f040 812d 	bne.w	34015ea8 <LL_ATON_Init+0x2e8>
#endif

#ifdef ATON_DECUN_NUM
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
34015c4e:	4b86      	ldr	r3, [pc, #536]	@ (34015e68 <LL_ATON_Init+0x2a8>)
34015c50:	685c      	ldr	r4, [r3, #4]
34015c52:	2c00      	cmp	r4, #0
34015c54:	d0fc      	beq.n	34015c50 <LL_ATON_Init+0x90>
34015c56:	f641 2319 	movw	r3, #6681	@ 0x1a19
34015c5a:	b2a2      	uxth	r2, r4
34015c5c:	429a      	cmp	r2, r3
34015c5e:	f040 8147 	bne.w	34015ef0 <LL_ATON_Init+0x330>
#endif

#ifdef ATON_EPOCHCTRL_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
34015c62:	4b82      	ldr	r3, [pc, #520]	@ (34015e6c <LL_ATON_Init+0x2ac>)
34015c64:	685c      	ldr	r4, [r3, #4]
34015c66:	2c00      	cmp	r4, #0
34015c68:	d0fc      	beq.n	34015c64 <LL_ATON_Init+0xa4>
34015c6a:	f241 1321 	movw	r3, #4385	@ 0x1121
34015c6e:	b2a2      	uxth	r2, r4
34015c70:	429a      	cmp	r2, r3
34015c72:	f040 8162 	bne.w	34015f3a <LL_ATON_Init+0x37a>
#endif

#ifdef ATON_RECBUF_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
34015c76:	4b7e      	ldr	r3, [pc, #504]	@ (34015e70 <LL_ATON_Init+0x2b0>)
34015c78:	685c      	ldr	r4, [r3, #4]
34015c7a:	2c00      	cmp	r4, #0
34015c7c:	d0fc      	beq.n	34015c78 <LL_ATON_Init+0xb8>
34015c7e:	f243 2320 	movw	r3, #12832	@ 0x3220
34015c82:	b2a2      	uxth	r2, r4
34015c84:	429a      	cmp	r2, r3
34015c86:	f040 817c 	bne.w	34015f82 <LL_ATON_Init+0x3c2>

#ifdef ATON_IMC_NUM
  ASSERT_UNITS_VERS_W_MSG(IMC, t);
#endif

  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
34015c8a:	4b72      	ldr	r3, [pc, #456]	@ (34015e54 <LL_ATON_Init+0x294>)
34015c8c:	685c      	ldr	r4, [r3, #4]
34015c8e:	2c00      	cmp	r4, #0
34015c90:	d0fc      	beq.n	34015c8c <LL_ATON_Init+0xcc>
34015c92:	f241 231f 	movw	r3, #4639	@ 0x121f
34015c96:	b2a2      	uxth	r2, r4
34015c98:	429a      	cmp	r2, r3
34015c9a:	f040 8198 	bne.w	34015fce <LL_ATON_Init+0x40e>

  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
34015c9e:	4b75      	ldr	r3, [pc, #468]	@ (34015e74 <LL_ATON_Init+0x2b4>)
34015ca0:	685c      	ldr	r4, [r3, #4]
34015ca2:	2c00      	cmp	r4, #0
34015ca4:	d0fc      	beq.n	34015ca0 <LL_ATON_Init+0xe0>
34015ca6:	f241 131e 	movw	r3, #4382	@ 0x111e
34015caa:	b2a2      	uxth	r2, r4
34015cac:	429a      	cmp	r2, r3
34015cae:	f040 81b4 	bne.w	3401601a <LL_ATON_Init+0x45a>

  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
34015cb2:	4b71      	ldr	r3, [pc, #452]	@ (34015e78 <LL_ATON_Init+0x2b8>)
34015cb4:	685c      	ldr	r4, [r3, #4]
34015cb6:	2c00      	cmp	r4, #0
34015cb8:	d0fc      	beq.n	34015cb4 <LL_ATON_Init+0xf4>
34015cba:	b2a3      	uxth	r3, r4
34015cbc:	f5b3 5fb0 	cmp.w	r3, #5632	@ 0x1600
34015cc0:	f040 81cf 	bne.w	34016062 <LL_ATON_Init+0x4a2>

  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
34015cc4:	4a6d      	ldr	r2, [pc, #436]	@ (34015e7c <LL_ATON_Init+0x2bc>)
34015cc6:	6854      	ldr	r4, [r2, #4]
34015cc8:	2c00      	cmp	r4, #0
34015cca:	d0fc      	beq.n	34015cc6 <LL_ATON_Init+0x106>
34015ccc:	f245 031d 	movw	r3, #20509	@ 0x501d
34015cd0:	b2a1      	uxth	r1, r4
34015cd2:	4299      	cmp	r1, r3
34015cd4:	f000 81ec 	beq.w	340160b0 <LL_ATON_Init+0x4f0>
34015cd8:	f003 f9a4 	bl	34019024 <__errno>
34015cdc:	6803      	ldr	r3, [r0, #0]
34015cde:	2b00      	cmp	r3, #0
34015ce0:	f000 81e4 	beq.w	340160ac <LL_ATON_Init+0x4ec>
34015ce4:	f003 f99e 	bl	34019024 <__errno>
34015ce8:	6800      	ldr	r0, [r0, #0]
34015cea:	f003 f935 	bl	34018f58 <strerror>
34015cee:	4603      	mov	r3, r0
34015cf0:	2205      	movs	r2, #5
34015cf2:	2100      	movs	r1, #0
34015cf4:	e9cd 2105 	strd	r2, r1, [sp, #20]
34015cf8:	221d      	movs	r2, #29
34015cfa:	9204      	str	r2, [sp, #16]
34015cfc:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015d00:	9203      	str	r2, [sp, #12]
34015d02:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015d06:	9202      	str	r2, [sp, #8]
34015d08:	4a5d      	ldr	r2, [pc, #372]	@ (34015e80 <LL_ATON_Init+0x2c0>)
34015d0a:	b2e4      	uxtb	r4, r4
34015d0c:	495d      	ldr	r1, [pc, #372]	@ (34015e84 <LL_ATON_Init+0x2c4>)
34015d0e:	9200      	str	r2, [sp, #0]
34015d10:	485d      	ldr	r0, [pc, #372]	@ (34015e88 <LL_ATON_Init+0x2c8>)
34015d12:	22fd      	movs	r2, #253	@ 0xfd
34015d14:	9401      	str	r4, [sp, #4]
34015d16:	f002 fd5d 	bl	340187d4 <iprintf>
34015d1a:	21fd      	movs	r1, #253	@ 0xfd
34015d1c:	4b5b      	ldr	r3, [pc, #364]	@ (34015e8c <LL_ATON_Init+0x2cc>)
34015d1e:	4a5c      	ldr	r2, [pc, #368]	@ (34015e90 <LL_ATON_Init+0x2d0>)
34015d20:	e022      	b.n	34015d68 <LL_ATON_Init+0x1a8>
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34015d22:	f003 f97f 	bl	34019024 <__errno>
34015d26:	6803      	ldr	r3, [r0, #0]
34015d28:	b30b      	cbz	r3, 34015d6e <LL_ATON_Init+0x1ae>
34015d2a:	f003 f97b 	bl	34019024 <__errno>
34015d2e:	6800      	ldr	r0, [r0, #0]
34015d30:	f003 f912 	bl	34018f58 <strerror>
34015d34:	4603      	mov	r3, r0
34015d36:	2205      	movs	r2, #5
34015d38:	f04f 0e00 	mov.w	lr, #0
34015d3c:	e9cd 2e05 	strd	r2, lr, [sp, #20]
34015d40:	2201      	movs	r2, #1
34015d42:	9204      	str	r2, [sp, #16]
34015d44:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015d48:	9203      	str	r2, [sp, #12]
34015d4a:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015d4e:	9202      	str	r2, [sp, #8]
34015d50:	4a50      	ldr	r2, [pc, #320]	@ (34015e94 <LL_ATON_Init+0x2d4>)
34015d52:	b2e4      	uxtb	r4, r4
34015d54:	494b      	ldr	r1, [pc, #300]	@ (34015e84 <LL_ATON_Init+0x2c4>)
34015d56:	9200      	str	r2, [sp, #0]
34015d58:	484b      	ldr	r0, [pc, #300]	@ (34015e88 <LL_ATON_Init+0x2c8>)
34015d5a:	22c9      	movs	r2, #201	@ 0xc9
34015d5c:	9401      	str	r4, [sp, #4]
34015d5e:	f002 fd39 	bl	340187d4 <iprintf>
34015d62:	21c9      	movs	r1, #201	@ 0xc9
34015d64:	4b49      	ldr	r3, [pc, #292]	@ (34015e8c <LL_ATON_Init+0x2cc>)
34015d66:	4a4a      	ldr	r2, [pc, #296]	@ (34015e90 <LL_ATON_Init+0x2d0>)
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34015d68:	4846      	ldr	r0, [pc, #280]	@ (34015e84 <LL_ATON_Init+0x2c4>)
34015d6a:	f001 fda5 	bl	340178b8 <__assert_func>
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34015d6e:	4b4a      	ldr	r3, [pc, #296]	@ (34015e98 <LL_ATON_Init+0x2d8>)
34015d70:	e7e1      	b.n	34015d36 <LL_ATON_Init+0x176>
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34015d72:	f003 f957 	bl	34019024 <__errno>
34015d76:	6803      	ldr	r3, [r0, #0]
34015d78:	b1fb      	cbz	r3, 34015dba <LL_ATON_Init+0x1fa>
34015d7a:	f003 f953 	bl	34019024 <__errno>
34015d7e:	6800      	ldr	r0, [r0, #0]
34015d80:	f003 f8ea 	bl	34018f58 <strerror>
34015d84:	4603      	mov	r3, r0
34015d86:	2205      	movs	r2, #5
34015d88:	f04f 0c01 	mov.w	ip, #1
34015d8c:	e9cd 2c05 	strd	r2, ip, [sp, #20]
34015d90:	2217      	movs	r2, #23
34015d92:	9204      	str	r2, [sp, #16]
34015d94:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015d98:	9203      	str	r2, [sp, #12]
34015d9a:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015d9e:	9202      	str	r2, [sp, #8]
34015da0:	4a3e      	ldr	r2, [pc, #248]	@ (34015e9c <LL_ATON_Init+0x2dc>)
34015da2:	b2e4      	uxtb	r4, r4
34015da4:	4937      	ldr	r1, [pc, #220]	@ (34015e84 <LL_ATON_Init+0x2c4>)
34015da6:	9200      	str	r2, [sp, #0]
34015da8:	4837      	ldr	r0, [pc, #220]	@ (34015e88 <LL_ATON_Init+0x2c8>)
34015daa:	22cc      	movs	r2, #204	@ 0xcc
34015dac:	9401      	str	r4, [sp, #4]
34015dae:	f002 fd11 	bl	340187d4 <iprintf>
34015db2:	21cc      	movs	r1, #204	@ 0xcc
34015db4:	4b35      	ldr	r3, [pc, #212]	@ (34015e8c <LL_ATON_Init+0x2cc>)
34015db6:	4a36      	ldr	r2, [pc, #216]	@ (34015e90 <LL_ATON_Init+0x2d0>)
34015db8:	e7d6      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015dba:	4b37      	ldr	r3, [pc, #220]	@ (34015e98 <LL_ATON_Init+0x2d8>)
34015dbc:	e7e3      	b.n	34015d86 <LL_ATON_Init+0x1c6>
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
34015dbe:	f003 f931 	bl	34019024 <__errno>
34015dc2:	6803      	ldr	r3, [r0, #0]
34015dc4:	b1eb      	cbz	r3, 34015e02 <LL_ATON_Init+0x242>
34015dc6:	f003 f92d 	bl	34019024 <__errno>
34015dca:	6800      	ldr	r0, [r0, #0]
34015dcc:	f003 f8c4 	bl	34018f58 <strerror>
34015dd0:	4603      	mov	r3, r0
34015dd2:	2201      	movs	r2, #1
34015dd4:	e9cd 2205 	strd	r2, r2, [sp, #20]
34015dd8:	221c      	movs	r2, #28
34015dda:	9204      	str	r2, [sp, #16]
34015ddc:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015de0:	9203      	str	r2, [sp, #12]
34015de2:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015de6:	9202      	str	r2, [sp, #8]
34015de8:	4a2d      	ldr	r2, [pc, #180]	@ (34015ea0 <LL_ATON_Init+0x2e0>)
34015dea:	b2e4      	uxtb	r4, r4
34015dec:	4925      	ldr	r1, [pc, #148]	@ (34015e84 <LL_ATON_Init+0x2c4>)
34015dee:	9200      	str	r2, [sp, #0]
34015df0:	4825      	ldr	r0, [pc, #148]	@ (34015e88 <LL_ATON_Init+0x2c8>)
34015df2:	22d0      	movs	r2, #208	@ 0xd0
34015df4:	9401      	str	r4, [sp, #4]
34015df6:	f002 fced 	bl	340187d4 <iprintf>
34015dfa:	21d0      	movs	r1, #208	@ 0xd0
34015dfc:	4b23      	ldr	r3, [pc, #140]	@ (34015e8c <LL_ATON_Init+0x2cc>)
34015dfe:	4a24      	ldr	r2, [pc, #144]	@ (34015e90 <LL_ATON_Init+0x2d0>)
34015e00:	e7b2      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015e02:	4b25      	ldr	r3, [pc, #148]	@ (34015e98 <LL_ATON_Init+0x2d8>)
34015e04:	e7e5      	b.n	34015dd2 <LL_ATON_Init+0x212>
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
34015e06:	f003 f90d 	bl	34019024 <__errno>
34015e0a:	6803      	ldr	r3, [r0, #0]
34015e0c:	b1f3      	cbz	r3, 34015e4c <LL_ATON_Init+0x28c>
34015e0e:	f003 f909 	bl	34019024 <__errno>
34015e12:	6800      	ldr	r0, [r0, #0]
34015e14:	f003 f8a0 	bl	34018f58 <strerror>
34015e18:	4603      	mov	r3, r0
34015e1a:	2201      	movs	r2, #1
34015e1c:	2000      	movs	r0, #0
34015e1e:	e9cd 2005 	strd	r2, r0, [sp, #20]
34015e22:	221a      	movs	r2, #26
34015e24:	9204      	str	r2, [sp, #16]
34015e26:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015e2a:	9203      	str	r2, [sp, #12]
34015e2c:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015e30:	9202      	str	r2, [sp, #8]
34015e32:	4a1c      	ldr	r2, [pc, #112]	@ (34015ea4 <LL_ATON_Init+0x2e4>)
34015e34:	b2e4      	uxtb	r4, r4
34015e36:	4913      	ldr	r1, [pc, #76]	@ (34015e84 <LL_ATON_Init+0x2c4>)
34015e38:	9200      	str	r2, [sp, #0]
34015e3a:	4813      	ldr	r0, [pc, #76]	@ (34015e88 <LL_ATON_Init+0x2c8>)
34015e3c:	22d4      	movs	r2, #212	@ 0xd4
34015e3e:	9401      	str	r4, [sp, #4]
34015e40:	f002 fcc8 	bl	340187d4 <iprintf>
34015e44:	21d4      	movs	r1, #212	@ 0xd4
34015e46:	4b11      	ldr	r3, [pc, #68]	@ (34015e8c <LL_ATON_Init+0x2cc>)
34015e48:	4a11      	ldr	r2, [pc, #68]	@ (34015e90 <LL_ATON_Init+0x2d0>)
34015e4a:	e78d      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015e4c:	4b12      	ldr	r3, [pc, #72]	@ (34015e98 <LL_ATON_Init+0x2d8>)
34015e4e:	e7e4      	b.n	34015e1a <LL_ATON_Init+0x25a>
34015e50:	340445b8 	.word	0x340445b8
34015e54:	580e0000 	.word	0x580e0000
34015e58:	580ef000 	.word	0x580ef000
34015e5c:	580fb000 	.word	0x580fb000
34015e60:	580f7000 	.word	0x580f7000
34015e64:	580f5000 	.word	0x580f5000
34015e68:	580f3000 	.word	0x580f3000
34015e6c:	580fe000 	.word	0x580fe000
34015e70:	580fd000 	.word	0x580fd000
34015e74:	580e1000 	.word	0x580e1000
34015e78:	580e4000 	.word	0x580e4000
34015e7c:	580e2000 	.word	0x580e2000
34015e80:	3401d0ab 	.word	0x3401d0ab
34015e84:	3401cfa0 	.word	0x3401cfa0
34015e88:	3401cff6 	.word	0x3401cff6
34015e8c:	3401d1fc 	.word	0x3401d1fc
34015e90:	3403c4d4 	.word	0x3403c4d4
34015e94:	3401d05a 	.word	0x3401d05a
34015e98:	3401cf9b 	.word	0x3401cf9b
34015e9c:	3401d061 	.word	0x3401d061
34015ea0:	3401d069 	.word	0x3401d069
34015ea4:	3401d06e 	.word	0x3401d06e
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
34015ea8:	f003 f8bc 	bl	34019024 <__errno>
34015eac:	6803      	ldr	r3, [r0, #0]
34015eae:	b1eb      	cbz	r3, 34015eec <LL_ATON_Init+0x32c>
34015eb0:	f003 f8b8 	bl	34019024 <__errno>
34015eb4:	6800      	ldr	r0, [r0, #0]
34015eb6:	f003 f84f 	bl	34018f58 <strerror>
34015eba:	4603      	mov	r3, r0
34015ebc:	2201      	movs	r2, #1
34015ebe:	e9cd 2205 	strd	r2, r2, [sp, #20]
34015ec2:	221b      	movs	r2, #27
34015ec4:	9204      	str	r2, [sp, #16]
34015ec6:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015eca:	9203      	str	r2, [sp, #12]
34015ecc:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015ed0:	9202      	str	r2, [sp, #8]
34015ed2:	4a7c      	ldr	r2, [pc, #496]	@ (340160c4 <LL_ATON_Init+0x504>)
34015ed4:	b2e4      	uxtb	r4, r4
34015ed6:	497c      	ldr	r1, [pc, #496]	@ (340160c8 <LL_ATON_Init+0x508>)
34015ed8:	9200      	str	r2, [sp, #0]
34015eda:	487c      	ldr	r0, [pc, #496]	@ (340160cc <LL_ATON_Init+0x50c>)
34015edc:	22d8      	movs	r2, #216	@ 0xd8
34015ede:	9401      	str	r4, [sp, #4]
34015ee0:	f002 fc78 	bl	340187d4 <iprintf>
34015ee4:	21d8      	movs	r1, #216	@ 0xd8
34015ee6:	4b7a      	ldr	r3, [pc, #488]	@ (340160d0 <LL_ATON_Init+0x510>)
34015ee8:	4a7a      	ldr	r2, [pc, #488]	@ (340160d4 <LL_ATON_Init+0x514>)
34015eea:	e73d      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015eec:	4b7a      	ldr	r3, [pc, #488]	@ (340160d8 <LL_ATON_Init+0x518>)
34015eee:	e7e5      	b.n	34015ebc <LL_ATON_Init+0x2fc>
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
34015ef0:	f003 f898 	bl	34019024 <__errno>
34015ef4:	6803      	ldr	r3, [r0, #0]
34015ef6:	b1f3      	cbz	r3, 34015f36 <LL_ATON_Init+0x376>
34015ef8:	f003 f894 	bl	34019024 <__errno>
34015efc:	6800      	ldr	r0, [r0, #0]
34015efe:	f003 f82b 	bl	34018f58 <strerror>
34015f02:	4603      	mov	r3, r0
34015f04:	2201      	movs	r2, #1
34015f06:	210a      	movs	r1, #10
34015f08:	e9cd 2105 	strd	r2, r1, [sp, #20]
34015f0c:	2219      	movs	r2, #25
34015f0e:	9204      	str	r2, [sp, #16]
34015f10:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015f14:	9203      	str	r2, [sp, #12]
34015f16:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015f1a:	9202      	str	r2, [sp, #8]
34015f1c:	4a6f      	ldr	r2, [pc, #444]	@ (340160dc <LL_ATON_Init+0x51c>)
34015f1e:	b2e4      	uxtb	r4, r4
34015f20:	4969      	ldr	r1, [pc, #420]	@ (340160c8 <LL_ATON_Init+0x508>)
34015f22:	9200      	str	r2, [sp, #0]
34015f24:	4869      	ldr	r0, [pc, #420]	@ (340160cc <LL_ATON_Init+0x50c>)
34015f26:	22dc      	movs	r2, #220	@ 0xdc
34015f28:	9401      	str	r4, [sp, #4]
34015f2a:	f002 fc53 	bl	340187d4 <iprintf>
34015f2e:	21dc      	movs	r1, #220	@ 0xdc
34015f30:	4b67      	ldr	r3, [pc, #412]	@ (340160d0 <LL_ATON_Init+0x510>)
34015f32:	4a68      	ldr	r2, [pc, #416]	@ (340160d4 <LL_ATON_Init+0x514>)
34015f34:	e718      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015f36:	4b68      	ldr	r3, [pc, #416]	@ (340160d8 <LL_ATON_Init+0x518>)
34015f38:	e7e4      	b.n	34015f04 <LL_ATON_Init+0x344>
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
34015f3a:	f003 f873 	bl	34019024 <__errno>
34015f3e:	6803      	ldr	r3, [r0, #0]
34015f40:	b1eb      	cbz	r3, 34015f7e <LL_ATON_Init+0x3be>
34015f42:	f003 f86f 	bl	34019024 <__errno>
34015f46:	6800      	ldr	r0, [r0, #0]
34015f48:	f003 f806 	bl	34018f58 <strerror>
34015f4c:	4603      	mov	r3, r0
34015f4e:	2201      	movs	r2, #1
34015f50:	e9cd 2205 	strd	r2, r2, [sp, #20]
34015f54:	2221      	movs	r2, #33	@ 0x21
34015f56:	9204      	str	r2, [sp, #16]
34015f58:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015f5c:	9203      	str	r2, [sp, #12]
34015f5e:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015f62:	9202      	str	r2, [sp, #8]
34015f64:	4a5e      	ldr	r2, [pc, #376]	@ (340160e0 <LL_ATON_Init+0x520>)
34015f66:	b2e4      	uxtb	r4, r4
34015f68:	4957      	ldr	r1, [pc, #348]	@ (340160c8 <LL_ATON_Init+0x508>)
34015f6a:	9200      	str	r2, [sp, #0]
34015f6c:	4857      	ldr	r0, [pc, #348]	@ (340160cc <LL_ATON_Init+0x50c>)
34015f6e:	22e0      	movs	r2, #224	@ 0xe0
34015f70:	9401      	str	r4, [sp, #4]
34015f72:	f002 fc2f 	bl	340187d4 <iprintf>
34015f76:	21e0      	movs	r1, #224	@ 0xe0
34015f78:	4b55      	ldr	r3, [pc, #340]	@ (340160d0 <LL_ATON_Init+0x510>)
34015f7a:	4a56      	ldr	r2, [pc, #344]	@ (340160d4 <LL_ATON_Init+0x514>)
34015f7c:	e6f4      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015f7e:	4b56      	ldr	r3, [pc, #344]	@ (340160d8 <LL_ATON_Init+0x518>)
34015f80:	e7e5      	b.n	34015f4e <LL_ATON_Init+0x38e>
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
34015f82:	f003 f84f 	bl	34019024 <__errno>
34015f86:	6803      	ldr	r3, [r0, #0]
34015f88:	b1fb      	cbz	r3, 34015fca <LL_ATON_Init+0x40a>
34015f8a:	f003 f84b 	bl	34019024 <__errno>
34015f8e:	6800      	ldr	r0, [r0, #0]
34015f90:	f002 ffe2 	bl	34018f58 <strerror>
34015f94:	4603      	mov	r3, r0
34015f96:	2203      	movs	r2, #3
34015f98:	f04f 0e02 	mov.w	lr, #2
34015f9c:	e9cd 2e05 	strd	r2, lr, [sp, #20]
34015fa0:	2220      	movs	r2, #32
34015fa2:	9204      	str	r2, [sp, #16]
34015fa4:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015fa8:	9203      	str	r2, [sp, #12]
34015faa:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015fae:	9202      	str	r2, [sp, #8]
34015fb0:	4a4c      	ldr	r2, [pc, #304]	@ (340160e4 <LL_ATON_Init+0x524>)
34015fb2:	b2e4      	uxtb	r4, r4
34015fb4:	4944      	ldr	r1, [pc, #272]	@ (340160c8 <LL_ATON_Init+0x508>)
34015fb6:	9200      	str	r2, [sp, #0]
34015fb8:	4844      	ldr	r0, [pc, #272]	@ (340160cc <LL_ATON_Init+0x50c>)
34015fba:	22e4      	movs	r2, #228	@ 0xe4
34015fbc:	9401      	str	r4, [sp, #4]
34015fbe:	f002 fc09 	bl	340187d4 <iprintf>
34015fc2:	21e4      	movs	r1, #228	@ 0xe4
34015fc4:	4b42      	ldr	r3, [pc, #264]	@ (340160d0 <LL_ATON_Init+0x510>)
34015fc6:	4a43      	ldr	r2, [pc, #268]	@ (340160d4 <LL_ATON_Init+0x514>)
34015fc8:	e6ce      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34015fca:	4b43      	ldr	r3, [pc, #268]	@ (340160d8 <LL_ATON_Init+0x518>)
34015fcc:	e7e3      	b.n	34015f96 <LL_ATON_Init+0x3d6>
  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
34015fce:	f003 f829 	bl	34019024 <__errno>
34015fd2:	6803      	ldr	r3, [r0, #0]
34015fd4:	b1fb      	cbz	r3, 34016016 <LL_ATON_Init+0x456>
34015fd6:	f003 f825 	bl	34019024 <__errno>
34015fda:	6800      	ldr	r0, [r0, #0]
34015fdc:	f002 ffbc 	bl	34018f58 <strerror>
34015fe0:	4603      	mov	r3, r0
34015fe2:	2201      	movs	r2, #1
34015fe4:	f04f 0c02 	mov.w	ip, #2
34015fe8:	e9cd 2c05 	strd	r2, ip, [sp, #20]
34015fec:	221f      	movs	r2, #31
34015fee:	9204      	str	r2, [sp, #16]
34015ff0:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015ff4:	9203      	str	r2, [sp, #12]
34015ff6:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015ffa:	9202      	str	r2, [sp, #8]
34015ffc:	4a3a      	ldr	r2, [pc, #232]	@ (340160e8 <LL_ATON_Init+0x528>)
34015ffe:	b2e4      	uxtb	r4, r4
34016000:	4931      	ldr	r1, [pc, #196]	@ (340160c8 <LL_ATON_Init+0x508>)
34016002:	9200      	str	r2, [sp, #0]
34016004:	4831      	ldr	r0, [pc, #196]	@ (340160cc <LL_ATON_Init+0x50c>)
34016006:	22f7      	movs	r2, #247	@ 0xf7
34016008:	9401      	str	r4, [sp, #4]
3401600a:	f002 fbe3 	bl	340187d4 <iprintf>
3401600e:	21f7      	movs	r1, #247	@ 0xf7
34016010:	4b2f      	ldr	r3, [pc, #188]	@ (340160d0 <LL_ATON_Init+0x510>)
34016012:	4a30      	ldr	r2, [pc, #192]	@ (340160d4 <LL_ATON_Init+0x514>)
34016014:	e6a8      	b.n	34015d68 <LL_ATON_Init+0x1a8>
34016016:	4b30      	ldr	r3, [pc, #192]	@ (340160d8 <LL_ATON_Init+0x518>)
34016018:	e7e3      	b.n	34015fe2 <LL_ATON_Init+0x422>
  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
3401601a:	f003 f803 	bl	34019024 <__errno>
3401601e:	6803      	ldr	r3, [r0, #0]
34016020:	b1eb      	cbz	r3, 3401605e <LL_ATON_Init+0x49e>
34016022:	f002 ffff 	bl	34019024 <__errno>
34016026:	6800      	ldr	r0, [r0, #0]
34016028:	f002 ff96 	bl	34018f58 <strerror>
3401602c:	4603      	mov	r3, r0
3401602e:	2201      	movs	r2, #1
34016030:	e9cd 2205 	strd	r2, r2, [sp, #20]
34016034:	221e      	movs	r2, #30
34016036:	9204      	str	r2, [sp, #16]
34016038:	f3c4 2203 	ubfx	r2, r4, #8, #4
3401603c:	9203      	str	r2, [sp, #12]
3401603e:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016042:	9202      	str	r2, [sp, #8]
34016044:	4a29      	ldr	r2, [pc, #164]	@ (340160ec <LL_ATON_Init+0x52c>)
34016046:	b2e4      	uxtb	r4, r4
34016048:	491f      	ldr	r1, [pc, #124]	@ (340160c8 <LL_ATON_Init+0x508>)
3401604a:	9200      	str	r2, [sp, #0]
3401604c:	481f      	ldr	r0, [pc, #124]	@ (340160cc <LL_ATON_Init+0x50c>)
3401604e:	22f9      	movs	r2, #249	@ 0xf9
34016050:	9401      	str	r4, [sp, #4]
34016052:	f002 fbbf 	bl	340187d4 <iprintf>
34016056:	21f9      	movs	r1, #249	@ 0xf9
34016058:	4b1d      	ldr	r3, [pc, #116]	@ (340160d0 <LL_ATON_Init+0x510>)
3401605a:	4a1e      	ldr	r2, [pc, #120]	@ (340160d4 <LL_ATON_Init+0x514>)
3401605c:	e684      	b.n	34015d68 <LL_ATON_Init+0x1a8>
3401605e:	4b1e      	ldr	r3, [pc, #120]	@ (340160d8 <LL_ATON_Init+0x518>)
34016060:	e7e5      	b.n	3401602e <LL_ATON_Init+0x46e>
  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
34016062:	f002 ffdf 	bl	34019024 <__errno>
34016066:	6803      	ldr	r3, [r0, #0]
34016068:	b1f3      	cbz	r3, 340160a8 <LL_ATON_Init+0x4e8>
3401606a:	f002 ffdb 	bl	34019024 <__errno>
3401606e:	6800      	ldr	r0, [r0, #0]
34016070:	f002 ff72 	bl	34018f58 <strerror>
34016074:	4603      	mov	r3, r0
34016076:	2201      	movs	r2, #1
34016078:	2006      	movs	r0, #6
3401607a:	e9cd 2005 	strd	r2, r0, [sp, #20]
3401607e:	2200      	movs	r2, #0
34016080:	9204      	str	r2, [sp, #16]
34016082:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016086:	9203      	str	r2, [sp, #12]
34016088:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401608c:	9202      	str	r2, [sp, #8]
3401608e:	4a18      	ldr	r2, [pc, #96]	@ (340160f0 <LL_ATON_Init+0x530>)
34016090:	b2e4      	uxtb	r4, r4
34016092:	490d      	ldr	r1, [pc, #52]	@ (340160c8 <LL_ATON_Init+0x508>)
34016094:	9200      	str	r2, [sp, #0]
34016096:	480d      	ldr	r0, [pc, #52]	@ (340160cc <LL_ATON_Init+0x50c>)
34016098:	22fb      	movs	r2, #251	@ 0xfb
3401609a:	9401      	str	r4, [sp, #4]
3401609c:	f002 fb9a 	bl	340187d4 <iprintf>
340160a0:	21fb      	movs	r1, #251	@ 0xfb
340160a2:	4b0b      	ldr	r3, [pc, #44]	@ (340160d0 <LL_ATON_Init+0x510>)
340160a4:	4a0b      	ldr	r2, [pc, #44]	@ (340160d4 <LL_ATON_Init+0x514>)
340160a6:	e65f      	b.n	34015d68 <LL_ATON_Init+0x1a8>
340160a8:	4b0b      	ldr	r3, [pc, #44]	@ (340160d8 <LL_ATON_Init+0x518>)
340160aa:	e7e4      	b.n	34016076 <LL_ATON_Init+0x4b6>
  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
340160ac:	4b0a      	ldr	r3, [pc, #40]	@ (340160d8 <LL_ATON_Init+0x518>)
340160ae:	e61f      	b.n	34015cf0 <LL_ATON_Init+0x130>

  /* Enable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
  {
    ATON_BUSIF_CTRL_SET(i, 1);
340160b0:	2301      	movs	r3, #1

  /* Enable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 1);

  return 0;
}
340160b2:	2000      	movs	r0, #0
    ATON_BUSIF_CTRL_SET(i, 1);
340160b4:	6013      	str	r3, [r2, #0]
340160b6:	4a0f      	ldr	r2, [pc, #60]	@ (340160f4 <LL_ATON_Init+0x534>)
340160b8:	6013      	str	r3, [r2, #0]
  ATON_INTCTRL_CTRL_SET(0, 1);
340160ba:	f5a2 5200 	sub.w	r2, r2, #8192	@ 0x2000
340160be:	6013      	str	r3, [r2, #0]
}
340160c0:	b008      	add	sp, #32
340160c2:	bd10      	pop	{r4, pc}
340160c4:	3401d074 	.word	0x3401d074
340160c8:	3401cfa0 	.word	0x3401cfa0
340160cc:	3401cff6 	.word	0x3401cff6
340160d0:	3401d1fc 	.word	0x3401d1fc
340160d4:	3403c4d4 	.word	0x3403c4d4
340160d8:	3401cf9b 	.word	0x3401cf9b
340160dc:	3401d07a 	.word	0x3401d07a
340160e0:	3401d080 	.word	0x3401d080
340160e4:	3401d08a 	.word	0x3401d08a
340160e8:	3401d091 	.word	0x3401d091
340160ec:	3401d099 	.word	0x3401d099
340160f0:	3401d0a1 	.word	0x3401d0a1
340160f4:	580e3000 	.word	0x580e3000

340160f8 <LL_ATON_DeInit>:
int LL_ATON_DeInit(void)
{
  int i;

  /* Disable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 0);
340160f8:	2000      	movs	r0, #0
340160fa:	4b07      	ldr	r3, [pc, #28]	@ (34016118 <LL_ATON_DeInit+0x20>)
340160fc:	6018      	str	r0, [r3, #0]

  /* Disable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
  {
    ATON_BUSIF_CTRL_SET(i, 0);
340160fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34016102:	6018      	str	r0, [r3, #0]
34016104:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34016108:	6018      	str	r0, [r3, #0]
  }

  /* Disable all ATON clocks */
  ATON_CLKCTRL_AGATES0_SET(0, 0);
3401610a:	f5a3 5340 	sub.w	r3, r3, #12288	@ 0x3000
3401610e:	6098      	str	r0, [r3, #8]
  ATON_CLKCTRL_AGATES1_SET(0, 0);
34016110:	60d8      	str	r0, [r3, #12]
  ATON_CLKCTRL_BGATES_SET(0, 0);
34016112:	6118      	str	r0, [r3, #16]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0);
#endif
  ATON_CLKCTRL_CTRL_SET(0, 0);
34016114:	6018      	str	r0, [r3, #0]

  return 0;
}
34016116:	4770      	bx	lr
34016118:	580e1000 	.word	0x580e1000

3401611c <LL_ATON_EnableClock>:
  return bloblines * 4;
}
#endif // ATON_EPOCHCTRL_NUM

void LL_ATON_EnableClock(unsigned int clock)
{
3401611c:	b530      	push	{r4, r5, lr}
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  LL_ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 1);
3401611e:	2401      	movs	r4, #1
34016120:	2500      	movs	r5, #0
34016122:	2301      	movs	r3, #1
34016124:	ea54 050d 	orrs.w	r5, r4, sp
34016128:	4a03      	ldr	r2, [pc, #12]	@ (34016138 <LL_ATON_EnableClock+0x1c>)
3401612a:	4083      	lsls	r3, r0
3401612c:	6911      	ldr	r1, [r2, #16]
3401612e:	404b      	eors	r3, r1
34016130:	4023      	ands	r3, r4
34016132:	404b      	eors	r3, r1
34016134:	6113      	str	r3, [r2, #16]
#endif
}
34016136:	bd30      	pop	{r4, r5, pc}
34016138:	580e0000 	.word	0x580e0000

3401613c <LL_EpochCtrl_Init>:
  if (id >= ATON_EPOCHCTRL_NUM)
3401613c:	2800      	cmp	r0, #0
{
3401613e:	b510      	push	{r4, lr}
34016140:	460c      	mov	r4, r1
  if (id >= ATON_EPOCHCTRL_NUM)
34016142:	dc0e      	bgt.n	34016162 <LL_EpochCtrl_Init+0x26>
  LL_ATON_EnableClock(ATON_EPOCHCTRL_CLKB_CLK(id));
34016144:	3019      	adds	r0, #25
34016146:	f7ff ffe9 	bl	3401611c <LL_ATON_EnableClock>
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
3401614a:	7923      	ldrb	r3, [r4, #4]
  ATON_EPOCHCTRL_CTRL_SET(id, t);
3401614c:	4a08      	ldr	r2, [pc, #32]	@ (34016170 <LL_EpochCtrl_Init+0x34>)
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
3401614e:	f003 0301 	and.w	r3, r3, #1
34016152:	00db      	lsls	r3, r3, #3
  ATON_EPOCHCTRL_CTRL_SET(id, t);
34016154:	6013      	str	r3, [r2, #0]
  if (conf->blobaddr & 0x7)
34016156:	6823      	ldr	r3, [r4, #0]
34016158:	f013 0007 	ands.w	r0, r3, #7
3401615c:	d104      	bne.n	34016168 <LL_EpochCtrl_Init+0x2c>
  ATON_EPOCHCTRL_ADDR_SET(id, conf->blobaddr);
3401615e:	6093      	str	r3, [r2, #8]
}
34016160:	bd10      	pop	{r4, pc}
    return LL_ATON_INVALID_ID;
34016162:	f04f 30ff 	mov.w	r0, #4294967295
34016166:	e7fb      	b.n	34016160 <LL_EpochCtrl_Init+0x24>
    return LL_ATON_INVALID_PARAM;
34016168:	f06f 0001 	mvn.w	r0, #1
3401616c:	e7f8      	b.n	34016160 <LL_EpochCtrl_Init+0x24>
3401616e:	bf00      	nop
34016170:	580fe000 	.word	0x580fe000

34016174 <LL_ATON_DisableClock>:

void LL_ATON_DisableClock(unsigned int clock)
{
34016174:	b530      	push	{r4, r5, lr}
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  LL_ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 0);
34016176:	2401      	movs	r4, #1
34016178:	2500      	movs	r5, #0
3401617a:	ea54 050d 	orrs.w	r5, r4, sp
3401617e:	4a03      	ldr	r2, [pc, #12]	@ (3401618c <LL_ATON_DisableClock+0x18>)
34016180:	6913      	ldr	r3, [r2, #16]
34016182:	ea23 0304 	bic.w	r3, r3, r4
34016186:	6113      	str	r3, [r2, #16]
#endif
}
34016188:	bd30      	pop	{r4, r5, pc}
3401618a:	bf00      	nop
3401618c:	580e0000 	.word	0x580e0000

34016190 <LL_ATON_RT_Main>:
 *                         and the network interface, or macros
 *                         `LL_ATON_DECLARE_NAMED_NN_INTERFACE()` & `LL_ATON_DECLARE_NAMED_NN_INSTANCE()` to
 *                         create/instantiate the objects separately.
 */
void LL_ATON_RT_Main(NN_Instance_TypeDef *network_instance)
{
34016190:	b510      	push	{r4, lr}

  /*** Start of user initialization code ***/

  /*** End of user initialization code ***/

  LL_ATON_ASSERT(network_instance != NULL);
34016192:	4604      	mov	r4, r0
34016194:	b928      	cbnz	r0, 340161a2 <LL_ATON_RT_Main+0x12>
34016196:	2130      	movs	r1, #48	@ 0x30
34016198:	4b0f      	ldr	r3, [pc, #60]	@ (340161d8 <LL_ATON_RT_Main+0x48>)
3401619a:	4a10      	ldr	r2, [pc, #64]	@ (340161dc <LL_ATON_RT_Main+0x4c>)
  LL_ATON_ASSERT(network_instance->network != NULL);
3401619c:	4810      	ldr	r0, [pc, #64]	@ (340161e0 <LL_ATON_RT_Main+0x50>)
3401619e:	f001 fb8b 	bl	340178b8 <__assert_func>
340161a2:	6803      	ldr	r3, [r0, #0]
340161a4:	b91b      	cbnz	r3, 340161ae <LL_ATON_RT_Main+0x1e>
340161a6:	2131      	movs	r1, #49	@ 0x31
340161a8:	4b0e      	ldr	r3, [pc, #56]	@ (340161e4 <LL_ATON_RT_Main+0x54>)
340161aa:	4a0c      	ldr	r2, [pc, #48]	@ (340161dc <LL_ATON_RT_Main+0x4c>)
340161ac:	e7f6      	b.n	3401619c <LL_ATON_RT_Main+0xc>
  LL_ATON_RT_RuntimeInit();                  // Initialize runtime
340161ae:	f000 fa05 	bl	340165bc <LL_ATON_RT_RuntimeInit>
  LL_ATON_RT_Init_Network(network_instance); // Initialize passed network instance object
340161b2:	4620      	mov	r0, r4
340161b4:	f000 f9c0 	bl	34016538 <LL_ATON_RT_Init_Network>

  do
  {
    /* Execute first/next step of Cube.AI/ATON runtime */
    ll_aton_rt_ret = LL_ATON_RT_RunEpochBlock(network_instance);
340161b8:	4620      	mov	r0, r4
340161ba:	f000 fa79 	bl	340166b0 <LL_ATON_RT_RunEpochBlock>
    /*** Start of user event handling code ***/

    /*** End of user event handling code ***/

    /* Wait for next event */
    if (ll_aton_rt_ret == LL_ATON_RT_WFE)
340161be:	2801      	cmp	r0, #1
340161c0:	d101      	bne.n	340161c6 <LL_ATON_RT_Main+0x36>
    { /*** subject to change to fit also user code requirements ***/
      LL_ATON_OSAL_WFE();
340161c2:	bf20      	wfe
    }
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE); /*** subject to change to fit also user code requirements ***/
340161c4:	e7f8      	b.n	340161b8 <LL_ATON_RT_Main+0x28>
340161c6:	2802      	cmp	r0, #2
340161c8:	d1f6      	bne.n	340161b8 <LL_ATON_RT_Main+0x28>

  LL_ATON_RT_DeInit_Network(network_instance); // De-initialize the network instance object
340161ca:	4620      	mov	r0, r4
340161cc:	f000 f9d8 	bl	34016580 <LL_ATON_RT_DeInit_Network>
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime

  /*** Start of user de-initialization code ***/

  /*** End of user de-initialization code ***/
}
340161d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime
340161d4:	f000 ba3c 	b.w	34016650 <LL_ATON_RT_RuntimeDeInit>
340161d8:	3401d0b1 	.word	0x3401d0b1
340161dc:	3403c4e1 	.word	0x3403c4e1
340161e0:	3401d0d1 	.word	0x3401d0d1
340161e4:	3401d12f 	.word	0x3401d12f

340161e8 <__LL_ATON_RT_Init_Network>:
                          // wait for
  }
}

static inline void __LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
340161e8:	b510      	push	{r4, lr}
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
340161ea:	4604      	mov	r4, r0
340161ec:	b310      	cbz	r0, 34016234 <__LL_ATON_RT_Init_Network+0x4c>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
340161ee:	6803      	ldr	r3, [r0, #0]
340161f0:	b303      	cbz	r3, 34016234 <__LL_ATON_RT_Init_Network+0x4c>
    return;
  }

  /** Initialize static variables **/
  /* set context */
  const LL_ATON_RT_EpochBlockItem_t *eb_list = nn_instance->network->epoch_block_items();
340161f2:	69db      	ldr	r3, [r3, #28]
340161f4:	4798      	blx	r3
  nn_instance->exec_state.current_epoch_block = eb_list;
  nn_instance->exec_state.first_epoch_block = eb_list;
  nn_instance->exec_state.next_epoch_block = NULL;
340161f6:	2300      	movs	r3, #0
  nn_instance->exec_state.current_epoch_block = eb_list;
340161f8:	6060      	str	r0, [r4, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
340161fa:	60a0      	str	r0, [r4, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
340161fc:	60e3      	str	r3, [r4, #12]

  /* set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
340161fe:	6123      	str	r3, [r4, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
34016200:	6163      	str	r3, [r4, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
34016202:	6863      	ldr	r3, [r4, #4]
  if (list != NULL)
34016204:	b9a3      	cbnz	r3, 34016230 <__LL_ATON_RT_Init_Network+0x48>
  int i = 0;
34016206:	461a      	mov	r2, r3
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
34016208:	6262      	str	r2, [r4, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401620a:	2200      	movs	r2, #0
  nn_instance->exec_state.triggered_events = 0x0;
  nn_instance->exec_state.current_epoch_block_started = false;
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_Init` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401620c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401620e:	62a2      	str	r2, [r4, #40]	@ 0x28
  nn_instance->exec_state.inference_started = false;
34016210:	7622      	strb	r2, [r4, #24]
  nn_instance->exec_state.triggered_events = 0x0;
34016212:	61e2      	str	r2, [r4, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
34016214:	f884 2020 	strb.w	r2, [r4, #32]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34016218:	b163      	cbz	r3, 34016234 <__LL_ATON_RT_Init_Network+0x4c>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
3401621a:	4621      	mov	r1, r4
  }
}
3401621c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
34016220:	2004      	movs	r0, #4
34016222:	4718      	bx	r3
      list++;
34016224:	3314      	adds	r3, #20
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
34016226:	3201      	adds	r2, #1
34016228:	8a19      	ldrh	r1, [r3, #16]
3401622a:	0709      	lsls	r1, r1, #28
3401622c:	d5fa      	bpl.n	34016224 <__LL_ATON_RT_Init_Network+0x3c>
3401622e:	e7eb      	b.n	34016208 <__LL_ATON_RT_Init_Network+0x20>
34016230:	2201      	movs	r2, #1
34016232:	e7f9      	b.n	34016228 <__LL_ATON_RT_Init_Network+0x40>
}
34016234:	bd10      	pop	{r4, pc}
	...

34016238 <__ll_clear_aton_owner>:

    __ll_current_aton_ip_owner = new_owner;
  }

  static inline void __ll_clear_aton_owner(NN_Instance_TypeDef *current_owner)
  {
34016238:	b508      	push	{r3, lr}
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(current_owner == __ll_current_aton_ip_owner);
3401623a:	4b09      	ldr	r3, [pc, #36]	@ (34016260 <__ll_clear_aton_owner+0x28>)
3401623c:	681a      	ldr	r2, [r3, #0]
3401623e:	4282      	cmp	r2, r0
34016240:	d005      	beq.n	3401624e <__ll_clear_aton_owner+0x16>
34016242:	2142      	movs	r1, #66	@ 0x42
34016244:	4b07      	ldr	r3, [pc, #28]	@ (34016264 <__ll_clear_aton_owner+0x2c>)
34016246:	4a08      	ldr	r2, [pc, #32]	@ (34016268 <__ll_clear_aton_owner+0x30>)

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
34016248:	4808      	ldr	r0, [pc, #32]	@ (3401626c <__ll_clear_aton_owner+0x34>)
3401624a:	f001 fb35 	bl	340178b8 <__assert_func>
3401624e:	4a08      	ldr	r2, [pc, #32]	@ (34016270 <__ll_clear_aton_owner+0x38>)
34016250:	6812      	ldr	r2, [r2, #0]
34016252:	b11a      	cbz	r2, 3401625c <__ll_clear_aton_owner+0x24>
34016254:	2146      	movs	r1, #70	@ 0x46
34016256:	4b07      	ldr	r3, [pc, #28]	@ (34016274 <__ll_clear_aton_owner+0x3c>)
34016258:	4a03      	ldr	r2, [pc, #12]	@ (34016268 <__ll_clear_aton_owner+0x30>)
3401625a:	e7f5      	b.n	34016248 <__ll_clear_aton_owner+0x10>
#endif // NDEBUG

    __ll_current_aton_ip_owner = NULL;
3401625c:	601a      	str	r2, [r3, #0]
    LL_ATON_UNLOCK_ATON();
  }
3401625e:	bd08      	pop	{r3, pc}
34016260:	340445c4 	.word	0x340445c4
34016264:	3401d158 	.word	0x3401d158
34016268:	3403c63f 	.word	0x3403c63f
3401626c:	3401d184 	.word	0x3401d184
34016270:	340445c0 	.word	0x340445c0
34016274:	3401d1e2 	.word	0x3401d1e2

34016278 <__LL_ATON_RT_SetWaitMask>:
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
  }

  /* set wait mask(s) in interrupt controller */
  static inline void __LL_ATON_RT_SetWaitMask(uint32_t wait_mask)
  {
34016278:	b508      	push	{r3, lr}
#ifndef NDEBUG
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401627a:	4b07      	ldr	r3, [pc, #28]	@ (34016298 <__LL_ATON_RT_SetWaitMask+0x20>)
3401627c:	681b      	ldr	r3, [r3, #0]
3401627e:	b92b      	cbnz	r3, 3401628c <__LL_ATON_RT_SetWaitMask+0x14>
34016280:	2175      	movs	r1, #117	@ 0x75
34016282:	4b06      	ldr	r3, [pc, #24]	@ (3401629c <__LL_ATON_RT_SetWaitMask+0x24>)
34016284:	4a06      	ldr	r2, [pc, #24]	@ (340162a0 <__LL_ATON_RT_SetWaitMask+0x28>)
34016286:	4807      	ldr	r0, [pc, #28]	@ (340162a4 <__LL_ATON_RT_SetWaitMask+0x2c>)
34016288:	f001 fb16 	bl	340178b8 <__assert_func>

    extern uint32_t volatile __ll_current_wait_mask;
    __ll_current_wait_mask = wait_mask;
3401628c:	4b06      	ldr	r3, [pc, #24]	@ (340162a8 <__LL_ATON_RT_SetWaitMask+0x30>)
3401628e:	6018      	str	r0, [r3, #0]

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    wait_mask <<= ATON_STRENG_INT(0);
#ifndef LL_ATON_RT_USE_IRQ_OR_MASK
    /* configure interrupt controller AND mask for epoch block */
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
34016290:	43c0      	mvns	r0, r0
34016292:	4b06      	ldr	r3, [pc, #24]	@ (340162ac <__LL_ATON_RT_SetWaitMask+0x34>)
34016294:	6258      	str	r0, [r3, #36]	@ 0x24
                                                                // (all other events & errors are enabled)
    val &= ~wait_mask;
    ATON_INTCTRL_STD_INTORMSK_SET(val);
#endif // LL_ATON_RT_USE_IRQ_OR_MASK
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  }
34016296:	bd08      	pop	{r3, pc}
34016298:	340445c4 	.word	0x340445c4
3401629c:	3401d1fe 	.word	0x3401d1fe
340162a0:	3403c592 	.word	0x3403c592
340162a4:	3401d184 	.word	0x3401d184
340162a8:	340445c0 	.word	0x340445c0
340162ac:	580e1000 	.word	0x580e1000

340162b0 <EpochBlock_EpochControllerUnit>:
  {
    return ((eb->flags & EpochBlock_Flags_internal) != 0);
  }

  static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
  {
340162b0:	b508      	push	{r3, lr}
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
340162b2:	8a03      	ldrh	r3, [r0, #16]
340162b4:	075b      	lsls	r3, r3, #29
340162b6:	d406      	bmi.n	340162c6 <EpochBlock_EpochControllerUnit+0x16>
340162b8:	f240 212a 	movw	r1, #554	@ 0x22a
340162bc:	4b03      	ldr	r3, [pc, #12]	@ (340162cc <EpochBlock_EpochControllerUnit+0x1c>)
340162be:	4a04      	ldr	r2, [pc, #16]	@ (340162d0 <EpochBlock_EpochControllerUnit+0x20>)
340162c0:	4804      	ldr	r0, [pc, #16]	@ (340162d4 <EpochBlock_EpochControllerUnit+0x24>)
340162c2:	f001 faf9 	bl	340178b8 <__assert_func>
    return eb->wait_mask;
  }
340162c6:	68c0      	ldr	r0, [r0, #12]
340162c8:	bd08      	pop	{r3, pc}
340162ca:	bf00      	nop
340162cc:	3401d228 	.word	0x3401d228
340162d0:	3403c573 	.word	0x3403c573
340162d4:	3401d243 	.word	0x3401d243

340162d8 <__LL_ATON_RT_ExecEndEpochBlock>:
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340162d8:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
{
340162da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
340162de:	4605      	mov	r5, r0
340162e0:	460c      	mov	r4, r1
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340162e2:	b113      	cbz	r3, 340162ea <__LL_ATON_RT_ExecEndEpochBlock+0x12>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_END, nn_instance, eb);
340162e4:	4602      	mov	r2, r0
340162e6:	2002      	movs	r0, #2
340162e8:	4798      	blx	r3
  if (EpochBlock_IsEpochBlob(eb))
340162ea:	8a2b      	ldrh	r3, [r5, #16]
340162ec:	0758      	lsls	r0, r3, #29
340162ee:	d518      	bpl.n	34016322 <__LL_ATON_RT_ExecEndEpochBlock+0x4a>
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
340162f0:	4628      	mov	r0, r5
340162f2:	f7ff ffdd 	bl	340162b0 <EpochBlock_EpochControllerUnit>
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
340162f6:	b128      	cbz	r0, 34016304 <__LL_ATON_RT_ExecEndEpochBlock+0x2c>
340162f8:	21b5      	movs	r1, #181	@ 0xb5
340162fa:	4b25      	ldr	r3, [pc, #148]	@ (34016390 <__LL_ATON_RT_ExecEndEpochBlock+0xb8>)
340162fc:	4a25      	ldr	r2, [pc, #148]	@ (34016394 <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
340162fe:	4826      	ldr	r0, [pc, #152]	@ (34016398 <__LL_ATON_RT_ExecEndEpochBlock+0xc0>)
34016300:	f001 fada 	bl	340178b8 <__assert_func>
    ATON_DISABLE_CLR_CONFCLR(EPOCHCTRL, ecId);
34016304:	2202      	movs	r2, #2
34016306:	4b25      	ldr	r3, [pc, #148]	@ (3401639c <__LL_ATON_RT_ExecEndEpochBlock+0xc4>)
34016308:	601a      	str	r2, [r3, #0]
3401630a:	681a      	ldr	r2, [r3, #0]
3401630c:	0791      	lsls	r1, r2, #30
3401630e:	d4fc      	bmi.n	3401630a <__LL_ATON_RT_ExecEndEpochBlock+0x32>
34016310:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34016314:	601a      	str	r2, [r3, #0]
34016316:	681a      	ldr	r2, [r3, #0]
34016318:	0052      	lsls	r2, r2, #1
3401631a:	d4fc      	bmi.n	34016316 <__LL_ATON_RT_ExecEndEpochBlock+0x3e>
    LL_ATON_DisableClock(ATON_EPOCHCTRL_CLKB_CLK(ecId));
3401631c:	2019      	movs	r0, #25
3401631e:	f7ff ff29 	bl	34016174 <LL_ATON_DisableClock>
  if (eb->end_epoch_block != NULL)
34016322:	686b      	ldr	r3, [r5, #4]
34016324:	b10b      	cbz	r3, 3401632a <__LL_ATON_RT_ExecEndEpochBlock+0x52>
    eb->end_epoch_block((const void *)eb);
34016326:	4628      	mov	r0, r5
34016328:	4798      	blx	r3
    return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
3401632a:	8a2e      	ldrh	r6, [r5, #16]
  if (EpochBlock_IsEpochPureHW(eb) ||
3401632c:	f016 0f90 	tst.w	r6, #144	@ 0x90
34016330:	f006 07c0 	and.w	r7, r6, #192	@ 0xc0
34016334:	d108      	bne.n	34016348 <__LL_ATON_RT_ExecEndEpochBlock+0x70>
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
34016336:	bb0f      	cbnz	r7, 3401637c <__LL_ATON_RT_ExecEndEpochBlock+0xa4>
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
34016338:	4b19      	ldr	r3, [pc, #100]	@ (340163a0 <__LL_ATON_RT_ExecEndEpochBlock+0xc8>)
3401633a:	681b      	ldr	r3, [r3, #0]
3401633c:	42a3      	cmp	r3, r4
3401633e:	d115      	bne.n	3401636c <__LL_ATON_RT_ExecEndEpochBlock+0x94>
34016340:	21d5      	movs	r1, #213	@ 0xd5
34016342:	4b18      	ldr	r3, [pc, #96]	@ (340163a4 <__LL_ATON_RT_ExecEndEpochBlock+0xcc>)
34016344:	4a13      	ldr	r2, [pc, #76]	@ (34016394 <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
34016346:	e7da      	b.n	340162fe <__LL_ATON_RT_ExecEndEpochBlock+0x26>
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
34016348:	4b15      	ldr	r3, [pc, #84]	@ (340163a0 <__LL_ATON_RT_ExecEndEpochBlock+0xc8>)
3401634a:	681b      	ldr	r3, [r3, #0]
3401634c:	42a3      	cmp	r3, r4
3401634e:	d003      	beq.n	34016358 <__LL_ATON_RT_ExecEndEpochBlock+0x80>
34016350:	21c9      	movs	r1, #201	@ 0xc9
34016352:	4b15      	ldr	r3, [pc, #84]	@ (340163a8 <__LL_ATON_RT_ExecEndEpochBlock+0xd0>)
34016354:	4a0f      	ldr	r2, [pc, #60]	@ (34016394 <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
34016356:	e7d2      	b.n	340162fe <__LL_ATON_RT_ExecEndEpochBlock+0x26>
    __LL_ATON_RT_SetWaitMask(0);
34016358:	2000      	movs	r0, #0
3401635a:	f7ff ff8d 	bl	34016278 <__LL_ATON_RT_SetWaitMask>
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401635e:	06f3      	lsls	r3, r6, #27
34016360:	d5e9      	bpl.n	34016336 <__LL_ATON_RT_ExecEndEpochBlock+0x5e>
    __ll_clear_aton_owner(nn_instance);
34016362:	4620      	mov	r0, r4
34016364:	f7ff ff68 	bl	34016238 <__ll_clear_aton_owner>
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
34016368:	2f00      	cmp	r7, #0
3401636a:	d0e5      	beq.n	34016338 <__LL_ATON_RT_ExecEndEpochBlock+0x60>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401636c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3401636e:	b163      	cbz	r3, 3401638a <__LL_ATON_RT_ExecEndEpochBlock+0xb2>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
34016370:	462a      	mov	r2, r5
34016372:	4621      	mov	r1, r4
}
34016374:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
34016378:	2003      	movs	r0, #3
3401637a:	4718      	bx	r3
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401637c:	6923      	ldr	r3, [r4, #16]
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401637e:	2b00      	cmp	r3, #0
34016380:	d1f4      	bne.n	3401636c <__LL_ATON_RT_ExecEndEpochBlock+0x94>
                                       (nn_instance->exec_state.next_epoch_block ==
34016382:	68e3      	ldr	r3, [r4, #12]
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
34016384:	2b00      	cmp	r3, #0
34016386:	d1f1      	bne.n	3401636c <__LL_ATON_RT_ExecEndEpochBlock+0x94>
34016388:	e7eb      	b.n	34016362 <__LL_ATON_RT_ExecEndEpochBlock+0x8a>
}
3401638a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401638e:	bf00      	nop
34016390:	3401d2a6 	.word	0x3401d2a6
34016394:	3403c554 	.word	0x3403c554
34016398:	3401d2af 	.word	0x3401d2af
3401639c:	580fe000 	.word	0x580fe000
340163a0:	340445c4 	.word	0x340445c4
340163a4:	3401d337 	.word	0x3401d337
340163a8:	3401d30d 	.word	0x3401d30d

340163ac <__LL_ATON_RT_DetermineNextEpochBlock>:
{
340163ac:	b508      	push	{r3, lr}
  LL_ATON_ASSERT(nn_instance != NULL);
340163ae:	b928      	cbnz	r0, 340163bc <__LL_ATON_RT_DetermineNextEpochBlock+0x10>
340163b0:	21e0      	movs	r1, #224	@ 0xe0
340163b2:	4b19      	ldr	r3, [pc, #100]	@ (34016418 <__LL_ATON_RT_DetermineNextEpochBlock+0x6c>)
340163b4:	4a19      	ldr	r2, [pc, #100]	@ (3401641c <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
  LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
340163b6:	481a      	ldr	r0, [pc, #104]	@ (34016420 <__LL_ATON_RT_DetermineNextEpochBlock+0x74>)
340163b8:	f001 fa7e 	bl	340178b8 <__assert_func>
340163bc:	69c3      	ldr	r3, [r0, #28]
340163be:	b11b      	cbz	r3, 340163c8 <__LL_ATON_RT_DetermineNextEpochBlock+0x1c>
340163c0:	21e2      	movs	r1, #226	@ 0xe2
340163c2:	4b18      	ldr	r3, [pc, #96]	@ (34016424 <__LL_ATON_RT_DetermineNextEpochBlock+0x78>)
340163c4:	4a15      	ldr	r2, [pc, #84]	@ (3401641c <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
340163c6:	e7f6      	b.n	340163b6 <__LL_ATON_RT_DetermineNextEpochBlock+0xa>
  if ((nn_instance->exec_state.next_epoch_block != NULL))
340163c8:	68c3      	ldr	r3, [r0, #12]
340163ca:	b30b      	cbz	r3, 34016410 <__LL_ATON_RT_DetermineNextEpochBlock+0x64>
    LL_ATON_ASSERT(nn_instance->exec_state.saved_current_epoch_block == NULL);
340163cc:	6903      	ldr	r3, [r0, #16]
340163ce:	b11b      	cbz	r3, 340163d8 <__LL_ATON_RT_DetermineNextEpochBlock+0x2c>
340163d0:	21ea      	movs	r1, #234	@ 0xea
340163d2:	4b15      	ldr	r3, [pc, #84]	@ (34016428 <__LL_ATON_RT_DetermineNextEpochBlock+0x7c>)
340163d4:	4a11      	ldr	r2, [pc, #68]	@ (3401641c <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
340163d6:	e7ee      	b.n	340163b6 <__LL_ATON_RT_DetermineNextEpochBlock+0xa>
    nn_instance->exec_state.saved_current_epoch_block = nn_instance->exec_state.current_epoch_block;
340163d8:	6843      	ldr	r3, [r0, #4]
340163da:	6103      	str	r3, [r0, #16]
    nn_instance->exec_state.saved_first_epoch_block = nn_instance->exec_state.first_epoch_block;
340163dc:	6883      	ldr	r3, [r0, #8]
340163de:	6143      	str	r3, [r0, #20]
    nn_instance->exec_state.saved_nr_of_epoch_blocks = nn_instance->exec_state.nr_of_epoch_blocks;
340163e0:	6a43      	ldr	r3, [r0, #36]	@ 0x24
340163e2:	6283      	str	r3, [r0, #40]	@ 0x28
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.next_epoch_block;
340163e4:	68c3      	ldr	r3, [r0, #12]
340163e6:	6043      	str	r3, [r0, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.next_epoch_block;
340163e8:	68c3      	ldr	r3, [r0, #12]
340163ea:	6083      	str	r3, [r0, #8]
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
340163ec:	6883      	ldr	r3, [r0, #8]
  if (list != NULL)
340163ee:	b96b      	cbnz	r3, 3401640c <__LL_ATON_RT_DetermineNextEpochBlock+0x60>
  int i = 0;
340163f0:	461a      	mov	r2, r3
    nn_instance->exec_state.next_epoch_block = NULL;
340163f2:	2300      	movs	r3, #0
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
340163f4:	6242      	str	r2, [r0, #36]	@ 0x24
    nn_instance->exec_state.next_epoch_block = NULL;
340163f6:	60c3      	str	r3, [r0, #12]
  nn_instance->exec_state.current_epoch_block_started = false;
340163f8:	2300      	movs	r3, #0
340163fa:	f880 3020 	strb.w	r3, [r0, #32]
}
340163fe:	bd08      	pop	{r3, pc}
      list++;
34016400:	3314      	adds	r3, #20
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
34016402:	3201      	adds	r2, #1
34016404:	8a19      	ldrh	r1, [r3, #16]
34016406:	0709      	lsls	r1, r1, #28
34016408:	d5fa      	bpl.n	34016400 <__LL_ATON_RT_DetermineNextEpochBlock+0x54>
3401640a:	e7f2      	b.n	340163f2 <__LL_ATON_RT_DetermineNextEpochBlock+0x46>
3401640c:	2201      	movs	r2, #1
3401640e:	e7f9      	b.n	34016404 <__LL_ATON_RT_DetermineNextEpochBlock+0x58>
    nn_instance->exec_state.current_epoch_block++;
34016410:	6843      	ldr	r3, [r0, #4]
34016412:	3314      	adds	r3, #20
34016414:	6043      	str	r3, [r0, #4]
34016416:	e7ef      	b.n	340163f8 <__LL_ATON_RT_DetermineNextEpochBlock+0x4c>
34016418:	3401d3a5 	.word	0x3401d3a5
3401641c:	3403c52f 	.word	0x3403c52f
34016420:	3401d2af 	.word	0x3401d2af
34016424:	3401d3c0 	.word	0x3401d3c0
34016428:	3401d3f0 	.word	0x3401d3f0

3401642c <dump_dma_state>:
LL_ATON_WEAK void dump_dma_state(void){};
3401642c:	4770      	bx	lr
	...

34016430 <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
34016430:	b538      	push	{r3, r4, r5, lr}
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
34016432:	4604      	mov	r4, r0
34016434:	2800      	cmp	r0, #0
34016436:	d056      	beq.n	340164e6 <__LL_ATON_RT_IrqErr+0xb6>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
34016438:	4b2b      	ldr	r3, [pc, #172]	@ (340164e8 <__LL_ATON_RT_IrqErr+0xb8>)
3401643a:	4218      	tst	r0, r3
3401643c:	d002      	beq.n	34016444 <__LL_ATON_RT_IrqErr+0x14>
  {
    LL_ATON_PRINTF("Streaming engine error interrupt\n");
3401643e:	482b      	ldr	r0, [pc, #172]	@ (340164ec <__LL_ATON_RT_IrqErr+0xbc>)
34016440:	f002 fa30 	bl	340188a4 <puts>
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
34016444:	f3c4 0309 	ubfx	r3, r4, #0, #10
34016448:	b113      	cbz	r3, 34016450 <__LL_ATON_RT_IrqErr+0x20>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
3401644a:	4829      	ldr	r0, [pc, #164]	@ (340164f0 <__LL_ATON_RT_IrqErr+0xc0>)
3401644c:	f002 fa2a 	bl	340188a4 <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
34016450:	f414 0f70 	tst.w	r4, #15728640	@ 0xf00000
34016454:	d002      	beq.n	3401645c <__LL_ATON_RT_IrqErr+0x2c>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
34016456:	4827      	ldr	r0, [pc, #156]	@ (340164f4 <__LL_ATON_RT_IrqErr+0xc4>)
34016458:	f002 fa24 	bl	340188a4 <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
3401645c:	01e5      	lsls	r5, r4, #7
3401645e:	d502      	bpl.n	34016466 <__LL_ATON_RT_IrqErr+0x36>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
34016460:	4825      	ldr	r0, [pc, #148]	@ (340164f8 <__LL_ATON_RT_IrqErr+0xc8>)
34016462:	f002 fa1f 	bl	340188a4 <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
34016466:	f014 6fc0 	tst.w	r4, #100663296	@ 0x6000000
3401646a:	d00e      	beq.n	3401648a <__LL_ATON_RT_IrqErr+0x5a>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
3401646c:	4823      	ldr	r0, [pc, #140]	@ (340164fc <__LL_ATON_RT_IrqErr+0xcc>)
3401646e:	f002 fa19 	bl	340188a4 <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
34016472:	4b23      	ldr	r3, [pc, #140]	@ (34016500 <__LL_ATON_RT_IrqErr+0xd0>)
34016474:	2100      	movs	r1, #0
34016476:	691a      	ldr	r2, [r3, #16]
34016478:	4822      	ldr	r0, [pc, #136]	@ (34016504 <__LL_ATON_RT_IrqErr+0xd4>)
3401647a:	f002 f9ab 	bl	340187d4 <iprintf>
3401647e:	4b22      	ldr	r3, [pc, #136]	@ (34016508 <__LL_ATON_RT_IrqErr+0xd8>)
34016480:	2101      	movs	r1, #1
34016482:	691a      	ldr	r2, [r3, #16]
34016484:	481f      	ldr	r0, [pc, #124]	@ (34016504 <__LL_ATON_RT_IrqErr+0xd4>)
34016486:	f002 f9a5 	bl	340187d4 <iprintf>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
3401648a:	0120      	lsls	r0, r4, #4
3401648c:	d502      	bpl.n	34016494 <__LL_ATON_RT_IrqErr+0x64>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
3401648e:	481f      	ldr	r0, [pc, #124]	@ (3401650c <__LL_ATON_RT_IrqErr+0xdc>)
34016490:	f002 fa08 	bl	340188a4 <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
34016494:	0061      	lsls	r1, r4, #1
34016496:	d50c      	bpl.n	340164b2 <__LL_ATON_RT_IrqErr+0x82>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
34016498:	4d1d      	ldr	r5, [pc, #116]	@ (34016510 <__LL_ATON_RT_IrqErr+0xe0>)
3401649a:	481e      	ldr	r0, [pc, #120]	@ (34016514 <__LL_ATON_RT_IrqErr+0xe4>)
3401649c:	68e9      	ldr	r1, [r5, #12]
3401649e:	f002 f999 	bl	340187d4 <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
340164a2:	6a29      	ldr	r1, [r5, #32]
340164a4:	481c      	ldr	r0, [pc, #112]	@ (34016518 <__LL_ATON_RT_IrqErr+0xe8>)
340164a6:	f002 f995 	bl	340187d4 <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
340164aa:	69e9      	ldr	r1, [r5, #28]
340164ac:	481b      	ldr	r0, [pc, #108]	@ (3401651c <__LL_ATON_RT_IrqErr+0xec>)
340164ae:	f002 f991 	bl	340187d4 <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
340164b2:	00a2      	lsls	r2, r4, #2
340164b4:	d502      	bpl.n	340164bc <__LL_ATON_RT_IrqErr+0x8c>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
340164b6:	481a      	ldr	r0, [pc, #104]	@ (34016520 <__LL_ATON_RT_IrqErr+0xf0>)
340164b8:	f002 f9f4 	bl	340188a4 <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
340164bc:	00e3      	lsls	r3, r4, #3
340164be:	d502      	bpl.n	340164c6 <__LL_ATON_RT_IrqErr+0x96>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
340164c0:	4818      	ldr	r0, [pc, #96]	@ (34016524 <__LL_ATON_RT_IrqErr+0xf4>)
340164c2:	f002 f9ef 	bl	340188a4 <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
340164c6:	f7ff ffb1 	bl	3401642c <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
340164ca:	4622      	mov	r2, r4
340164cc:	2300      	movs	r3, #0
340164ce:	f240 21fb 	movw	r1, #763	@ 0x2fb
340164d2:	4815      	ldr	r0, [pc, #84]	@ (34016528 <__LL_ATON_RT_IrqErr+0xf8>)
340164d4:	f002 f97e 	bl	340187d4 <iprintf>
#if (LL_ATON_HAVE_FFLUSH)
  LL_ATON_FFLUSH(stdout);
#endif
  LL_ATON_ASSERT(false); // may never happen
340164d8:	f240 21ff 	movw	r1, #767	@ 0x2ff
340164dc:	4b13      	ldr	r3, [pc, #76]	@ (3401652c <__LL_ATON_RT_IrqErr+0xfc>)
340164de:	4a14      	ldr	r2, [pc, #80]	@ (34016530 <__LL_ATON_RT_IrqErr+0x100>)
340164e0:	4814      	ldr	r0, [pc, #80]	@ (34016534 <__LL_ATON_RT_IrqErr+0x104>)
340164e2:	f001 f9e9 	bl	340178b8 <__assert_func>
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
340164e6:	bd38      	pop	{r3, r4, r5, pc}
340164e8:	000ffc00 	.word	0x000ffc00
340164ec:	3401d431 	.word	0x3401d431
340164f0:	3401d452 	.word	0x3401d452
340164f4:	3401d478 	.word	0x3401d478
340164f8:	3401d49c 	.word	0x3401d49c
340164fc:	3401d4bc 	.word	0x3401d4bc
34016500:	580e2000 	.word	0x580e2000
34016504:	3401d4d4 	.word	0x3401d4d4
34016508:	580e3000 	.word	0x580e3000
3401650c:	3401d4e9 	.word	0x3401d4e9
34016510:	580fe000 	.word	0x580fe000
34016514:	3401d501 	.word	0x3401d501
34016518:	3401d535 	.word	0x3401d535
3401651c:	3401d55f 	.word	0x3401d55f
34016520:	3401d580 	.word	0x3401d580
34016524:	3401d5a1 	.word	0x3401d5a1
34016528:	3401d5bc 	.word	0x3401d5bc
3401652c:	3401d1fc 	.word	0x3401d1fc
34016530:	3403c50b 	.word	0x3403c50b
34016534:	3401d2af 	.word	0x3401d2af

34016538 <LL_ATON_RT_Init_Network>:
{
34016538:	b510      	push	{r4, lr}
  if (nn_instance == NULL)
3401653a:	4604      	mov	r4, r0
3401653c:	b1b0      	cbz	r0, 3401656c <LL_ATON_RT_Init_Network+0x34>
  if (nn_instance->network == NULL)
3401653e:	6803      	ldr	r3, [r0, #0]
34016540:	b1a3      	cbz	r3, 3401656c <LL_ATON_RT_Init_Network+0x34>
  LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
34016542:	685b      	ldr	r3, [r3, #4]
34016544:	b933      	cbnz	r3, 34016554 <LL_ATON_RT_Init_Network+0x1c>
34016546:	f44f 71bb 	mov.w	r1, #374	@ 0x176
3401654a:	4b09      	ldr	r3, [pc, #36]	@ (34016570 <LL_ATON_RT_Init_Network+0x38>)
3401654c:	4a09      	ldr	r2, [pc, #36]	@ (34016574 <LL_ATON_RT_Init_Network+0x3c>)
  LL_ATON_ASSERT(ret == true);
3401654e:	480a      	ldr	r0, [pc, #40]	@ (34016578 <LL_ATON_RT_Init_Network+0x40>)
34016550:	f001 f9b2 	bl	340178b8 <__assert_func>
  bool ret = nn_instance->network->ec_network_init();
34016554:	4798      	blx	r3
  LL_ATON_ASSERT(ret == true);
34016556:	b920      	cbnz	r0, 34016562 <LL_ATON_RT_Init_Network+0x2a>
34016558:	f44f 71bc 	mov.w	r1, #376	@ 0x178
3401655c:	4b07      	ldr	r3, [pc, #28]	@ (3401657c <LL_ATON_RT_Init_Network+0x44>)
3401655e:	4a05      	ldr	r2, [pc, #20]	@ (34016574 <LL_ATON_RT_Init_Network+0x3c>)
34016560:	e7f5      	b.n	3401654e <LL_ATON_RT_Init_Network+0x16>
  __LL_ATON_RT_Init_Network(nn_instance);
34016562:	4620      	mov	r0, r4
}
34016564:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __LL_ATON_RT_Init_Network(nn_instance);
34016568:	f7ff be3e 	b.w	340161e8 <__LL_ATON_RT_Init_Network>
}
3401656c:	bd10      	pop	{r4, pc}
3401656e:	bf00      	nop
34016570:	3401d5e3 	.word	0x3401d5e3
34016574:	3403c655 	.word	0x3403c655
34016578:	3401d2af 	.word	0x3401d2af
3401657c:	3401d618 	.word	0x3401d618

34016580 <LL_ATON_RT_DeInit_Network>:
{
34016580:	b510      	push	{r4, lr}
  if (nn_instance == NULL)
34016582:	4604      	mov	r4, r0
34016584:	b1b8      	cbz	r0, 340165b6 <LL_ATON_RT_DeInit_Network+0x36>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34016586:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
34016588:	b11b      	cbz	r3, 34016592 <LL_ATON_RT_DeInit_Network+0x12>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_DeInit, nn_instance, NULL);
3401658a:	4601      	mov	r1, r0
3401658c:	2200      	movs	r2, #0
3401658e:	2005      	movs	r0, #5
34016590:	4798      	blx	r3
  if (nn_instance == __ll_current_aton_ip_owner)
34016592:	4b09      	ldr	r3, [pc, #36]	@ (340165b8 <LL_ATON_RT_DeInit_Network+0x38>)
34016594:	681b      	ldr	r3, [r3, #0]
34016596:	42a3      	cmp	r3, r4
34016598:	d102      	bne.n	340165a0 <LL_ATON_RT_DeInit_Network+0x20>
    __ll_clear_aton_owner(nn_instance);
3401659a:	4620      	mov	r0, r4
3401659c:	f7ff fe4c 	bl	34016238 <__ll_clear_aton_owner>
  nn_instance->exec_state.current_epoch_block = eb_list;
340165a0:	2300      	movs	r3, #0
340165a2:	6063      	str	r3, [r4, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
340165a4:	60a3      	str	r3, [r4, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
340165a6:	60e3      	str	r3, [r4, #12]
  nn_instance->exec_state.saved_current_epoch_block = NULL;
340165a8:	6123      	str	r3, [r4, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
340165aa:	6163      	str	r3, [r4, #20]
  nn_instance->exec_state.nr_of_epoch_blocks = 0;
340165ac:	6263      	str	r3, [r4, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
340165ae:	62a3      	str	r3, [r4, #40]	@ 0x28
  nn_instance->exec_state.triggered_events = 0x0;
340165b0:	61e3      	str	r3, [r4, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
340165b2:	f884 3020 	strb.w	r3, [r4, #32]
}
340165b6:	bd10      	pop	{r4, pc}
340165b8:	340445c4 	.word	0x340445c4

340165bc <LL_ATON_RT_RuntimeInit>:
{
340165bc:	b510      	push	{r4, lr}
  LL_ATON_Init();
340165be:	f7ff faff 	bl	34015bc0 <LL_ATON_Init>
    ATON_DISABLE_CLR_CONFCLR(INTCTRL, 0);
340165c2:	2202      	movs	r2, #2
340165c4:	4b1f      	ldr	r3, [pc, #124]	@ (34016644 <LL_ATON_RT_RuntimeInit+0x88>)
340165c6:	601a      	str	r2, [r3, #0]
340165c8:	681a      	ldr	r2, [r3, #0]
340165ca:	0791      	lsls	r1, r2, #30
340165cc:	d4fc      	bmi.n	340165c8 <LL_ATON_RT_RuntimeInit+0xc>
340165ce:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
340165d2:	601a      	str	r2, [r3, #0]
340165d4:	681a      	ldr	r2, [r3, #0]
340165d6:	0052      	lsls	r2, r2, #1
340165d8:	d4fc      	bmi.n	340165d4 <LL_ATON_RT_RuntimeInit+0x18>
    ATON_INTCTRL_STD_INTORMSK_SET(ATON_STRENG_INT_MASK(
340165da:	f240 32ff 	movw	r2, #1023	@ 0x3ff
340165de:	615a      	str	r2, [r3, #20]
    ATON_INTCTRL_STD_INTANDMSK_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
340165e0:	f04f 32ff 	mov.w	r2, #4294967295
340165e4:	625a      	str	r2, [r3, #36]	@ 0x24
    ATON_ENABLE(INTCTRL, 0);
340165e6:	681a      	ldr	r2, [r3, #0]
340165e8:	f042 0201 	orr.w	r2, r2, #1
340165ec:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340165ee:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
340165f2:	4b15      	ldr	r3, [pc, #84]	@ (34016648 <LL_ATON_RT_RuntimeInit+0x8c>)
340165f4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340165f8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340165fc:	f3bf 8f6f 	isb	sy
34016600:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
34016604:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016608:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401660c:	f3bf 8f6f 	isb	sy
34016610:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
34016614:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016618:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401661c:	f3bf 8f6f 	isb	sy
34016620:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
34016624:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016628:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401662c:	f3bf 8f6f 	isb	sy
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34016630:	605a      	str	r2, [r3, #4]
  if (ll_aton_init_deinit_trace)
34016632:	4b06      	ldr	r3, [pc, #24]	@ (3401664c <LL_ATON_RT_RuntimeInit+0x90>)
34016634:	681b      	ldr	r3, [r3, #0]
34016636:	b11b      	cbz	r3, 34016640 <LL_ATON_RT_RuntimeInit+0x84>
}
34016638:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Init);
3401663c:	2006      	movs	r0, #6
3401663e:	4718      	bx	r3
}
34016640:	bd10      	pop	{r4, pc}
34016642:	bf00      	nop
34016644:	580e1000 	.word	0x580e1000
34016648:	e000e100 	.word	0xe000e100
3401664c:	340445bc 	.word	0x340445bc

34016650 <LL_ATON_RT_RuntimeDeInit>:
{
34016650:	b508      	push	{r3, lr}
  if (ll_aton_init_deinit_trace)
34016652:	4b15      	ldr	r3, [pc, #84]	@ (340166a8 <LL_ATON_RT_RuntimeDeInit+0x58>)
34016654:	681b      	ldr	r3, [r3, #0]
34016656:	b10b      	cbz	r3, 3401665c <LL_ATON_RT_RuntimeDeInit+0xc>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Deinit);
34016658:	2007      	movs	r0, #7
3401665a:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401665c:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34016660:	4b12      	ldr	r3, [pc, #72]	@ (340166ac <LL_ATON_RT_RuntimeDeInit+0x5c>)
34016662:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016666:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401666a:	f3bf 8f6f 	isb	sy
3401666e:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
34016672:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016676:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401667a:	f3bf 8f6f 	isb	sy
3401667e:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34016682:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016686:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401668a:	f3bf 8f6f 	isb	sy
3401668e:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34016692:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016696:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401669a:	f3bf 8f6f 	isb	sy
}
3401669e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LL_ATON_DeInit();
340166a2:	f7ff bd29 	b.w	340160f8 <LL_ATON_DeInit>
340166a6:	bf00      	nop
340166a8:	340445bc 	.word	0x340445bc
340166ac:	e000e100 	.word	0xe000e100

340166b0 <LL_ATON_RT_RunEpochBlock>:
{
340166b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  LL_ATON_ASSERT(nn_instance != NULL);
340166b2:	4604      	mov	r4, r0
340166b4:	b930      	cbnz	r0, 340166c4 <LL_ATON_RT_RunEpochBlock+0x14>
340166b6:	f240 210f 	movw	r1, #527	@ 0x20f
340166ba:	4b8c      	ldr	r3, [pc, #560]	@ (340168ec <LL_ATON_RT_RunEpochBlock+0x23c>)
340166bc:	4a8c      	ldr	r2, [pc, #560]	@ (340168f0 <LL_ATON_RT_RunEpochBlock+0x240>)
  LL_ATON_ASSERT(nn_instance->exec_state.current_epoch_block != NULL); // should never happen
340166be:	488d      	ldr	r0, [pc, #564]	@ (340168f4 <LL_ATON_RT_RunEpochBlock+0x244>)
340166c0:	f001 f8fa 	bl	340178b8 <__assert_func>
340166c4:	6843      	ldr	r3, [r0, #4]
340166c6:	b923      	cbnz	r3, 340166d2 <LL_ATON_RT_RunEpochBlock+0x22>
340166c8:	f240 2112 	movw	r1, #530	@ 0x212
340166cc:	4b8a      	ldr	r3, [pc, #552]	@ (340168f8 <LL_ATON_RT_RunEpochBlock+0x248>)
340166ce:	4a88      	ldr	r2, [pc, #544]	@ (340168f0 <LL_ATON_RT_RunEpochBlock+0x240>)
340166d0:	e7f5      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
  if (nn_instance->exec_state.inference_started == false)
340166d2:	7e03      	ldrb	r3, [r0, #24]
340166d4:	b98b      	cbnz	r3, 340166fa <LL_ATON_RT_RunEpochBlock+0x4a>
    LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
340166d6:	6803      	ldr	r3, [r0, #0]
340166d8:	b10b      	cbz	r3, 340166de <LL_ATON_RT_RunEpochBlock+0x2e>
340166da:	689b      	ldr	r3, [r3, #8]
340166dc:	b923      	cbnz	r3, 340166e8 <LL_ATON_RT_RunEpochBlock+0x38>
340166de:	f44f 7106 	mov.w	r1, #536	@ 0x218
340166e2:	4b86      	ldr	r3, [pc, #536]	@ (340168fc <LL_ATON_RT_RunEpochBlock+0x24c>)
340166e4:	4a82      	ldr	r2, [pc, #520]	@ (340168f0 <LL_ATON_RT_RunEpochBlock+0x240>)
340166e6:	e7ea      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
    bool ret = nn_instance->network->ec_inference_init();
340166e8:	4798      	blx	r3
    LL_ATON_ASSERT(ret == true);
340166ea:	b920      	cbnz	r0, 340166f6 <LL_ATON_RT_RunEpochBlock+0x46>
340166ec:	f240 211a 	movw	r1, #538	@ 0x21a
340166f0:	4b83      	ldr	r3, [pc, #524]	@ (34016900 <LL_ATON_RT_RunEpochBlock+0x250>)
340166f2:	4a7f      	ldr	r2, [pc, #508]	@ (340168f0 <LL_ATON_RT_RunEpochBlock+0x240>)
340166f4:	e7e3      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
    nn_instance->exec_state.inference_started = true;
340166f6:	2301      	movs	r3, #1
340166f8:	7623      	strb	r3, [r4, #24]
    uint32_t _wait_mask = __LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block);
340166fa:	6860      	ldr	r0, [r4, #4]
  if (EpochBlock_IsEpochBlob(eb))
340166fc:	8a03      	ldrh	r3, [r0, #16]
340166fe:	075a      	lsls	r2, r3, #29
34016700:	d512      	bpl.n	34016728 <LL_ATON_RT_RunEpochBlock+0x78>
    return (1 << EpochBlock_EpochControllerUnit(eb));
34016702:	f7ff fdd5 	bl	340162b0 <EpochBlock_EpochControllerUnit>
34016706:	2301      	movs	r3, #1
34016708:	fa03 f000 	lsl.w	r0, r3, r0
    if (nn_instance->exec_state.current_epoch_block_started && (_wait_mask != 0))
3401670c:	f894 3020 	ldrb.w	r3, [r4, #32]
34016710:	f003 06ff 	and.w	r6, r3, #255	@ 0xff
34016714:	b343      	cbz	r3, 34016768 <LL_ATON_RT_RunEpochBlock+0xb8>
34016716:	2800      	cmp	r0, #0
34016718:	d036      	beq.n	34016788 <LL_ATON_RT_RunEpochBlock+0xd8>
      if ((nn_instance->exec_state.triggered_events & _wait_mask) == _wait_mask)
3401671a:	69e3      	ldr	r3, [r4, #28]
3401671c:	ea30 0303 	bics.w	r3, r0, r3
34016720:	d004      	beq.n	3401672c <LL_ATON_RT_RunEpochBlock+0x7c>
        return LL_ATON_RT_WFE;
34016722:	2001      	movs	r0, #1
}
34016724:	b002      	add	sp, #8
34016726:	bd70      	pop	{r4, r5, r6, pc}
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
34016728:	68c0      	ldr	r0, [r0, #12]
3401672a:	e7ef      	b.n	3401670c <LL_ATON_RT_RunEpochBlock+0x5c>
        LL_ATON_ASSERT(__ll_current_aton_ip_owner ==
3401672c:	4b75      	ldr	r3, [pc, #468]	@ (34016904 <LL_ATON_RT_RunEpochBlock+0x254>)
3401672e:	681b      	ldr	r3, [r3, #0]
34016730:	42a3      	cmp	r3, r4
34016732:	d004      	beq.n	3401673e <LL_ATON_RT_RunEpochBlock+0x8e>
34016734:	f240 2132 	movw	r1, #562	@ 0x232
34016738:	4b73      	ldr	r3, [pc, #460]	@ (34016908 <LL_ATON_RT_RunEpochBlock+0x258>)
3401673a:	4a6d      	ldr	r2, [pc, #436]	@ (340168f0 <LL_ATON_RT_RunEpochBlock+0x240>)
3401673c:	e7bf      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
3401673e:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
34016742:	4a72      	ldr	r2, [pc, #456]	@ (3401690c <LL_ATON_RT_RunEpochBlock+0x25c>)
34016744:	f8c2 1084 	str.w	r1, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016748:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3401674c:	f3bf 8f6f 	isb	sy
        nn_instance->exec_state.triggered_events &= ~_wait_mask;
34016750:	69e3      	ldr	r3, [r4, #28]
34016752:	ea23 0300 	bic.w	r3, r3, r0
34016756:	61e3      	str	r3, [r4, #28]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34016758:	6051      	str	r1, [r2, #4]
        __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401675a:	6860      	ldr	r0, [r4, #4]
3401675c:	4621      	mov	r1, r4
3401675e:	f7ff fdbb 	bl	340162d8 <__LL_ATON_RT_ExecEndEpochBlock>
        __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
34016762:	4620      	mov	r0, r4
34016764:	f7ff fe22 	bl	340163ac <__LL_ATON_RT_DetermineNextEpochBlock>
    if (EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block))
34016768:	6863      	ldr	r3, [r4, #4]
3401676a:	8a1b      	ldrh	r3, [r3, #16]
3401676c:	071b      	lsls	r3, r3, #28
3401676e:	d534      	bpl.n	340167da <LL_ATON_RT_RunEpochBlock+0x12a>
      if (nn_instance->exec_state.saved_current_epoch_block != NULL)
34016770:	6923      	ldr	r3, [r4, #16]
34016772:	2b00      	cmp	r3, #0
34016774:	f000 80b7 	beq.w	340168e6 <LL_ATON_RT_RunEpochBlock+0x236>
      LL_ATON_ASSERT(nn_instance == NULL);

      nn_instance = __ll_current_aton_ip_owner;
    }

    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34016778:	4b62      	ldr	r3, [pc, #392]	@ (34016904 <LL_ATON_RT_RunEpochBlock+0x254>)
3401677a:	681a      	ldr	r2, [r3, #0]
3401677c:	b932      	cbnz	r2, 3401678c <LL_ATON_RT_RunEpochBlock+0xdc>
3401677e:	2197      	movs	r1, #151	@ 0x97
34016780:	4b63      	ldr	r3, [pc, #396]	@ (34016910 <LL_ATON_RT_RunEpochBlock+0x260>)
34016782:	4a64      	ldr	r2, [pc, #400]	@ (34016914 <LL_ATON_RT_RunEpochBlock+0x264>)
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
34016784:	4864      	ldr	r0, [pc, #400]	@ (34016918 <LL_ATON_RT_RunEpochBlock+0x268>)
34016786:	e79b      	b.n	340166c0 <LL_ATON_RT_RunEpochBlock+0x10>
  bool this_run_executed_end_epoch = false;
34016788:	4606      	mov	r6, r0
3401678a:	e7ed      	b.n	34016768 <LL_ATON_RT_RunEpochBlock+0xb8>
    LL_ATON_ASSERT(unlock ? EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block)
3401678c:	6862      	ldr	r2, [r4, #4]
3401678e:	8a12      	ldrh	r2, [r2, #16]
34016790:	0716      	lsls	r6, r2, #28
34016792:	d403      	bmi.n	3401679c <LL_ATON_RT_RunEpochBlock+0xec>
34016794:	2198      	movs	r1, #152	@ 0x98
34016796:	4b61      	ldr	r3, [pc, #388]	@ (3401691c <LL_ATON_RT_RunEpochBlock+0x26c>)
34016798:	4a5e      	ldr	r2, [pc, #376]	@ (34016914 <LL_ATON_RT_RunEpochBlock+0x264>)
3401679a:	e7f3      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>
                          : EpochBlock_IsEpochInternal(nn_instance->exec_state.current_epoch_block));
    LL_ATON_ASSERT(EpochBlock_IsEpochHybrid(nn_instance->exec_state.saved_current_epoch_block));
3401679c:	6922      	ldr	r2, [r4, #16]
3401679e:	8a12      	ldrh	r2, [r2, #16]
340167a0:	0655      	lsls	r5, r2, #25
340167a2:	d403      	bmi.n	340167ac <LL_ATON_RT_RunEpochBlock+0xfc>
340167a4:	219a      	movs	r1, #154	@ 0x9a
340167a6:	4b5e      	ldr	r3, [pc, #376]	@ (34016920 <LL_ATON_RT_RunEpochBlock+0x270>)
340167a8:	4a5a      	ldr	r2, [pc, #360]	@ (34016914 <LL_ATON_RT_RunEpochBlock+0x264>)
340167aa:	e7eb      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>

    /* Clear owner */
    if (unlock)
    {
      __ll_clear_aton_owner(__ll_current_aton_ip_owner);
340167ac:	6818      	ldr	r0, [r3, #0]
340167ae:	f7ff fd43 	bl	34016238 <__ll_clear_aton_owner>
    }

    /* set old context */
    LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
340167b2:	68e3      	ldr	r3, [r4, #12]
340167b4:	b11b      	cbz	r3, 340167be <LL_ATON_RT_RunEpochBlock+0x10e>
340167b6:	21a3      	movs	r1, #163	@ 0xa3
340167b8:	4b5a      	ldr	r3, [pc, #360]	@ (34016924 <LL_ATON_RT_RunEpochBlock+0x274>)
340167ba:	4a56      	ldr	r2, [pc, #344]	@ (34016914 <LL_ATON_RT_RunEpochBlock+0x264>)
340167bc:	e7e2      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.saved_current_epoch_block;
340167be:	6922      	ldr	r2, [r4, #16]
340167c0:	6062      	str	r2, [r4, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.saved_first_epoch_block;
340167c2:	6962      	ldr	r2, [r4, #20]
340167c4:	60a2      	str	r2, [r4, #8]

#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = nn_instance->exec_state.saved_nr_of_epoch_blocks;
340167c6:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
340167c8:	6262      	str	r2, [r4, #36]	@ 0x24
#endif

    /* reset saved context */
    nn_instance->exec_state.saved_current_epoch_block = NULL;
340167ca:	6123      	str	r3, [r4, #16]
    nn_instance->exec_state.saved_first_epoch_block = NULL;
340167cc:	6163      	str	r3, [r4, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
340167ce:	62a3      	str	r3, [r4, #40]	@ 0x28
        nn_instance->exec_state.current_epoch_block++;
340167d0:	6863      	ldr	r3, [r4, #4]
340167d2:	3314      	adds	r3, #20
340167d4:	6063      	str	r3, [r4, #4]
        return LL_ATON_RT_NO_WFE;
340167d6:	2000      	movs	r0, #0
340167d8:	e7a4      	b.n	34016724 <LL_ATON_RT_RunEpochBlock+0x74>
    if (this_run_executed_end_epoch)
340167da:	2e00      	cmp	r6, #0
340167dc:	d1fb      	bne.n	340167d6 <LL_ATON_RT_RunEpochBlock+0x126>
    if (!nn_instance->exec_state.current_epoch_block_started)
340167de:	f894 3020 	ldrb.w	r3, [r4, #32]
340167e2:	2b00      	cmp	r3, #0
340167e4:	d169      	bne.n	340168ba <LL_ATON_RT_RunEpochBlock+0x20a>
      nn_instance->exec_state.current_epoch_block_started = true;
340167e6:	2301      	movs	r3, #1
340167e8:	f884 3020 	strb.w	r3, [r4, #32]
      __LL_ATON_RT_ExecStartEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
340167ec:	6865      	ldr	r5, [r4, #4]
  LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
340167ee:	68e3      	ldr	r3, [r4, #12]
340167f0:	b11b      	cbz	r3, 340167fa <LL_ATON_RT_RunEpochBlock+0x14a>
340167f2:	215f      	movs	r1, #95	@ 0x5f
340167f4:	4b4b      	ldr	r3, [pc, #300]	@ (34016924 <LL_ATON_RT_RunEpochBlock+0x274>)
340167f6:	4a4c      	ldr	r2, [pc, #304]	@ (34016928 <LL_ATON_RT_RunEpochBlock+0x278>)
340167f8:	e761      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340167fa:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
340167fc:	b11b      	cbz	r3, 34016806 <LL_ATON_RT_RunEpochBlock+0x156>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_START, nn_instance, eb);
340167fe:	462a      	mov	r2, r5
34016800:	4621      	mov	r1, r4
34016802:	4630      	mov	r0, r6
34016804:	4798      	blx	r3
    return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
34016806:	8a2b      	ldrh	r3, [r5, #16]
  if (EpochBlock_IsEpochStart(eb))
34016808:	07d8      	lsls	r0, r3, #31
3401680a:	d505      	bpl.n	34016818 <LL_ATON_RT_RunEpochBlock+0x168>
    LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401680c:	69e2      	ldr	r2, [r4, #28]
3401680e:	b11a      	cbz	r2, 34016818 <LL_ATON_RT_RunEpochBlock+0x168>
34016810:	2156      	movs	r1, #86	@ 0x56
34016812:	4b46      	ldr	r3, [pc, #280]	@ (3401692c <LL_ATON_RT_RunEpochBlock+0x27c>)
34016814:	4a46      	ldr	r2, [pc, #280]	@ (34016930 <LL_ATON_RT_RunEpochBlock+0x280>)
34016816:	e7b5      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>
  if (EpochBlock_IsEpochPureHW(eb) ||
34016818:	f013 0f50 	tst.w	r3, #80	@ 0x50
3401681c:	d015      	beq.n	3401684a <LL_ATON_RT_RunEpochBlock+0x19a>
    LL_ATON_ASSERT(new_owner != __ll_current_aton_ip_owner);
3401681e:	4a39      	ldr	r2, [pc, #228]	@ (34016904 <LL_ATON_RT_RunEpochBlock+0x254>)
34016820:	6811      	ldr	r1, [r2, #0]
34016822:	428c      	cmp	r4, r1
34016824:	d103      	bne.n	3401682e <LL_ATON_RT_RunEpochBlock+0x17e>
34016826:	2131      	movs	r1, #49	@ 0x31
34016828:	4b42      	ldr	r3, [pc, #264]	@ (34016934 <LL_ATON_RT_RunEpochBlock+0x284>)
3401682a:	4a43      	ldr	r2, [pc, #268]	@ (34016938 <LL_ATON_RT_RunEpochBlock+0x288>)
3401682c:	e7aa      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(__ll_current_aton_ip_owner == NULL);
3401682e:	6811      	ldr	r1, [r2, #0]
34016830:	b119      	cbz	r1, 3401683a <LL_ATON_RT_RunEpochBlock+0x18a>
34016832:	2135      	movs	r1, #53	@ 0x35
34016834:	4b41      	ldr	r3, [pc, #260]	@ (3401693c <LL_ATON_RT_RunEpochBlock+0x28c>)
34016836:	4a40      	ldr	r2, [pc, #256]	@ (34016938 <LL_ATON_RT_RunEpochBlock+0x288>)
34016838:	e7a4      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401683a:	4941      	ldr	r1, [pc, #260]	@ (34016940 <LL_ATON_RT_RunEpochBlock+0x290>)
3401683c:	6809      	ldr	r1, [r1, #0]
3401683e:	b119      	cbz	r1, 34016848 <LL_ATON_RT_RunEpochBlock+0x198>
34016840:	2139      	movs	r1, #57	@ 0x39
34016842:	4b40      	ldr	r3, [pc, #256]	@ (34016944 <LL_ATON_RT_RunEpochBlock+0x294>)
34016844:	4a3c      	ldr	r2, [pc, #240]	@ (34016938 <LL_ATON_RT_RunEpochBlock+0x288>)
34016846:	e79d      	b.n	34016784 <LL_ATON_RT_RunEpochBlock+0xd4>
    __ll_current_aton_ip_owner = new_owner;
34016848:	6014      	str	r4, [r2, #0]
  if (!EpochBlock_IsEpochBlob(eb))
3401684a:	0759      	lsls	r1, r3, #29
3401684c:	d41c      	bmi.n	34016888 <LL_ATON_RT_RunEpochBlock+0x1d8>
    if (EpochBlock_IsEpochPureHW(eb) || EpochBlock_IsEpochInternal(eb))
3401684e:	f013 0f90 	tst.w	r3, #144	@ 0x90
34016852:	d00a      	beq.n	3401686a <LL_ATON_RT_RunEpochBlock+0x1ba>
      LL_ATON_ASSERT(__ll_current_aton_ip_owner == nn_instance);
34016854:	4b2b      	ldr	r3, [pc, #172]	@ (34016904 <LL_ATON_RT_RunEpochBlock+0x254>)
34016856:	681b      	ldr	r3, [r3, #0]
34016858:	429c      	cmp	r4, r3
3401685a:	d003      	beq.n	34016864 <LL_ATON_RT_RunEpochBlock+0x1b4>
3401685c:	2176      	movs	r1, #118	@ 0x76
3401685e:	4b2a      	ldr	r3, [pc, #168]	@ (34016908 <LL_ATON_RT_RunEpochBlock+0x258>)
34016860:	4a31      	ldr	r2, [pc, #196]	@ (34016928 <LL_ATON_RT_RunEpochBlock+0x278>)
34016862:	e72c      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
      __LL_ATON_RT_SetWaitMask(eb->wait_mask);
34016864:	68e8      	ldr	r0, [r5, #12]
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
34016866:	f7ff fd07 	bl	34016278 <__LL_ATON_RT_SetWaitMask>
  if (eb->start_epoch_block != NULL)
3401686a:	682b      	ldr	r3, [r5, #0]
3401686c:	b10b      	cbz	r3, 34016872 <LL_ATON_RT_RunEpochBlock+0x1c2>
    eb->start_epoch_block((const void *)eb);
3401686e:	4628      	mov	r0, r5
34016870:	4798      	blx	r3
  if (EpochBlock_IsEpochBlob(eb))
34016872:	8a2b      	ldrh	r3, [r5, #16]
34016874:	075a      	lsls	r2, r3, #29
34016876:	d51a      	bpl.n	340168ae <LL_ATON_RT_RunEpochBlock+0x1fe>
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
34016878:	4628      	mov	r0, r5
3401687a:	f7ff fd19 	bl	340162b0 <EpochBlock_EpochControllerUnit>
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401687e:	b130      	cbz	r0, 3401688e <LL_ATON_RT_RunEpochBlock+0x1de>
34016880:	2197      	movs	r1, #151	@ 0x97
34016882:	4b31      	ldr	r3, [pc, #196]	@ (34016948 <LL_ATON_RT_RunEpochBlock+0x298>)
34016884:	4a28      	ldr	r2, [pc, #160]	@ (34016928 <LL_ATON_RT_RunEpochBlock+0x278>)
34016886:	e71a      	b.n	340166be <LL_ATON_RT_RunEpochBlock+0xe>
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
34016888:	f240 30ff 	movw	r0, #1023	@ 0x3ff
3401688c:	e7eb      	b.n	34016866 <LL_ATON_RT_RunEpochBlock+0x1b6>
    conf.stepmode = 0;
3401688e:	f89d 2004 	ldrb.w	r2, [sp, #4]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
34016892:	68ab      	ldr	r3, [r5, #8]
    conf.stepmode = 0;
34016894:	f360 0200 	bfi	r2, r0, #0, #1
    LL_EpochCtrl_Init(ecId, &conf);
34016898:	4669      	mov	r1, sp
    conf.stepmode = 0;
3401689a:	f88d 2004 	strb.w	r2, [sp, #4]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
3401689e:	9300      	str	r3, [sp, #0]
    LL_EpochCtrl_Init(ecId, &conf);
340168a0:	f7ff fc4c 	bl	3401613c <LL_EpochCtrl_Init>
    ATON_ENABLE(EPOCHCTRL, ecId);
340168a4:	4a29      	ldr	r2, [pc, #164]	@ (3401694c <LL_ATON_RT_RunEpochBlock+0x29c>)
340168a6:	6813      	ldr	r3, [r2, #0]
340168a8:	f043 0301 	orr.w	r3, r3, #1
340168ac:	6013      	str	r3, [r2, #0]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340168ae:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
340168b0:	b11b      	cbz	r3, 340168ba <LL_ATON_RT_RunEpochBlock+0x20a>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_START, nn_instance, eb);
340168b2:	462a      	mov	r2, r5
340168b4:	4621      	mov	r1, r4
340168b6:	2001      	movs	r0, #1
340168b8:	4798      	blx	r3
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
340168ba:	6860      	ldr	r0, [r4, #4]
  if (EpochBlock_IsEpochBlob(eb))
340168bc:	8a03      	ldrh	r3, [r0, #16]
340168be:	075b      	lsls	r3, r3, #29
340168c0:	d50f      	bpl.n	340168e2 <LL_ATON_RT_RunEpochBlock+0x232>
    return (1 << EpochBlock_EpochControllerUnit(eb));
340168c2:	f7ff fcf5 	bl	340162b0 <EpochBlock_EpochControllerUnit>
340168c6:	2301      	movs	r3, #1
340168c8:	fa03 f000 	lsl.w	r0, r3, r0
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
340168cc:	2800      	cmp	r0, #0
340168ce:	f47f af28 	bne.w	34016722 <LL_ATON_RT_RunEpochBlock+0x72>
      __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
340168d2:	6860      	ldr	r0, [r4, #4]
340168d4:	4621      	mov	r1, r4
340168d6:	f7ff fcff 	bl	340162d8 <__LL_ATON_RT_ExecEndEpochBlock>
      __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
340168da:	4620      	mov	r0, r4
340168dc:	f7ff fd66 	bl	340163ac <__LL_ATON_RT_DetermineNextEpochBlock>
      return LL_ATON_RT_NO_WFE;
340168e0:	e779      	b.n	340167d6 <LL_ATON_RT_RunEpochBlock+0x126>
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
340168e2:	68c0      	ldr	r0, [r0, #12]
340168e4:	e7f2      	b.n	340168cc <LL_ATON_RT_RunEpochBlock+0x21c>
        return LL_ATON_RT_DONE;
340168e6:	2002      	movs	r0, #2
340168e8:	e71c      	b.n	34016724 <LL_ATON_RT_RunEpochBlock+0x74>
340168ea:	bf00      	nop
340168ec:	3401d3a5 	.word	0x3401d3a5
340168f0:	3403c626 	.word	0x3403c626
340168f4:	3401d2af 	.word	0x3401d2af
340168f8:	3401d621 	.word	0x3401d621
340168fc:	3401d65c 	.word	0x3401d65c
34016900:	3401d618 	.word	0x3401d618
34016904:	340445c4 	.word	0x340445c4
34016908:	3401d6be 	.word	0x3401d6be
3401690c:	e000e100 	.word	0xe000e100
34016910:	3401d1fe 	.word	0x3401d1fe
34016914:	3403c5ff 	.word	0x3403c5ff
34016918:	3401d184 	.word	0x3401d184
3401691c:	3401d6e8 	.word	0x3401d6e8
34016920:	3401d784 	.word	0x3401d784
34016924:	3401d7d0 	.word	0x3401d7d0
34016928:	3403c5de 	.word	0x3403c5de
3401692c:	3401d3c0 	.word	0x3401d3c0
34016930:	3403c5bf 	.word	0x3403c5bf
34016934:	3401d808 	.word	0x3401d808
34016938:	3403c5ab 	.word	0x3403c5ab
3401693c:	3401d830 	.word	0x3401d830
34016940:	340445c0 	.word	0x340445c0
34016944:	3401d1e2 	.word	0x3401d1e2
34016948:	3401d2a6 	.word	0x3401d2a6
3401694c:	580fe000 	.word	0x580fe000

34016950 <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
34016950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
34016952:	4b38      	ldr	r3, [pc, #224]	@ (34016a34 <NPU0_IRQHandler+0xe4>)
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
34016954:	4c38      	ldr	r4, [pc, #224]	@ (34016a38 <NPU0_IRQHandler+0xe8>)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
34016956:	689d      	ldr	r5, [r3, #8]
  if (__ll_current_aton_ip_owner != NULL)
34016958:	6823      	ldr	r3, [r4, #0]
3401695a:	b343      	cbz	r3, 340169ae <NPU0_IRQHandler+0x5e>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
3401695c:	6823      	ldr	r3, [r4, #0]
3401695e:	685b      	ldr	r3, [r3, #4]
34016960:	b933      	cbnz	r3, 34016970 <NPU0_IRQHandler+0x20>
34016962:	f240 3162 	movw	r1, #866	@ 0x362
34016966:	4b35      	ldr	r3, [pc, #212]	@ (34016a3c <NPU0_IRQHandler+0xec>)
34016968:	4a35      	ldr	r2, [pc, #212]	@ (34016a40 <NPU0_IRQHandler+0xf0>)
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401696a:	4836      	ldr	r0, [pc, #216]	@ (34016a44 <NPU0_IRQHandler+0xf4>)
3401696c:	f000 ffa4 	bl	340178b8 <__assert_func>
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
34016970:	6823      	ldr	r3, [r4, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
34016972:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
34016974:	8a1b      	ldrh	r3, [r3, #16]
34016976:	075b      	lsls	r3, r3, #29
34016978:	d40c      	bmi.n	34016994 <NPU0_IRQHandler+0x44>
      __LL_ATON_RT_IrqErr(
3401697a:	f425 707f 	bic.w	r0, r5, #1020	@ 0x3fc
3401697e:	f020 0003 	bic.w	r0, r0, #3
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
34016982:	f7ff fd55 	bl	34016430 <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34016986:	6823      	ldr	r3, [r4, #0]
34016988:	b99b      	cbnz	r3, 340169b2 <NPU0_IRQHandler+0x62>
3401698a:	f240 3183 	movw	r1, #899	@ 0x383
3401698e:	4b2e      	ldr	r3, [pc, #184]	@ (34016a48 <NPU0_IRQHandler+0xf8>)
34016990:	4a2b      	ldr	r2, [pc, #172]	@ (34016a40 <NPU0_IRQHandler+0xf0>)
34016992:	e7ea      	b.n	3401696a <NPU0_IRQHandler+0x1a>
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
34016994:	6823      	ldr	r3, [r4, #0]
34016996:	6858      	ldr	r0, [r3, #4]
34016998:	f7ff fc8a 	bl	340162b0 <EpochBlock_EpochControllerUnit>
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401699c:	b120      	cbz	r0, 340169a8 <NPU0_IRQHandler+0x58>
3401699e:	f240 316f 	movw	r1, #879	@ 0x36f
340169a2:	4b2a      	ldr	r3, [pc, #168]	@ (34016a4c <NPU0_IRQHandler+0xfc>)
340169a4:	4a26      	ldr	r2, [pc, #152]	@ (34016a40 <NPU0_IRQHandler+0xf0>)
340169a6:	e7e0      	b.n	3401696a <NPU0_IRQHandler+0x1a>
      __LL_ATON_RT_IrqErr(
340169a8:	f025 5080 	bic.w	r0, r5, #268435456	@ 0x10000000
340169ac:	e7e9      	b.n	34016982 <NPU0_IRQHandler+0x32>
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
340169ae:	4628      	mov	r0, r5
340169b0:	e7e7      	b.n	34016982 <NPU0_IRQHandler+0x32>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
340169b2:	6823      	ldr	r3, [r4, #0]
340169b4:	685b      	ldr	r3, [r3, #4]
340169b6:	8a1b      	ldrh	r3, [r3, #16]
340169b8:	f013 0304 	ands.w	r3, r3, #4
340169bc:	d123      	bne.n	34016a06 <NPU0_IRQHandler+0xb6>
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
340169be:	6822      	ldr	r2, [r4, #0]
340169c0:	6852      	ldr	r2, [r2, #4]
  wait_irqs =
340169c2:	68d2      	ldr	r2, [r2, #12]
  if (wait_irqs)
340169c4:	402a      	ands	r2, r5
340169c6:	d017      	beq.n	340169f8 <NPU0_IRQHandler+0xa8>
        _tmp_triggered_events |= (1 << i);
340169c8:	f04f 0c01 	mov.w	ip, #1
340169cc:	200a      	movs	r0, #10
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
340169ce:	6821      	ldr	r1, [r4, #0]
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
340169d0:	4e1f      	ldr	r6, [pc, #124]	@ (34016a50 <NPU0_IRQHandler+0x100>)
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
340169d2:	69c9      	ldr	r1, [r1, #28]
      if ((wait_irqs >> i) & 1)
340169d4:	fa22 f703 	lsr.w	r7, r2, r3
340169d8:	07ff      	lsls	r7, r7, #31
340169da:	d507      	bpl.n	340169ec <NPU0_IRQHandler+0x9c>
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
340169dc:	031f      	lsls	r7, r3, #12
340169de:	f857 e006 	ldr.w	lr, [r7, r6]
        ATON_STRENG_IRQ_SET(
340169e2:	f847 e006 	str.w	lr, [r7, r6]
        _tmp_triggered_events |= (1 << i);
340169e6:	fa0c f703 	lsl.w	r7, ip, r3
340169ea:	4339      	orrs	r1, r7
    for (i = 0; i < ATON_STRENG_NUM; i++)
340169ec:	3801      	subs	r0, #1
340169ee:	f103 0301 	add.w	r3, r3, #1
340169f2:	d1ef      	bne.n	340169d4 <NPU0_IRQHandler+0x84>
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
340169f4:	6823      	ldr	r3, [r4, #0]
340169f6:	61d9      	str	r1, [r3, #28]
  __ASM volatile ("dsb 0xF":::"memory");
340169f8:	f3bf 8f4f 	dsb	sy
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
340169fc:	4b0d      	ldr	r3, [pc, #52]	@ (34016a34 <NPU0_IRQHandler+0xe4>)
340169fe:	611d      	str	r5, [r3, #16]
34016a00:	f3bf 8f4f 	dsb	sy
  LL_ATON_OSAL_SIGNAL_EVENT();

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
}
34016a04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
34016a06:	6823      	ldr	r3, [r4, #0]
34016a08:	6858      	ldr	r0, [r3, #4]
34016a0a:	f7ff fc51 	bl	340162b0 <EpochBlock_EpochControllerUnit>
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
34016a0e:	b120      	cbz	r0, 34016a1a <NPU0_IRQHandler+0xca>
34016a10:	f240 3142 	movw	r1, #834	@ 0x342
34016a14:	4b0d      	ldr	r3, [pc, #52]	@ (34016a4c <NPU0_IRQHandler+0xfc>)
34016a16:	4a0f      	ldr	r2, [pc, #60]	@ (34016a54 <NPU0_IRQHandler+0x104>)
34016a18:	e7a7      	b.n	3401696a <NPU0_IRQHandler+0x1a>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
34016a1a:	00eb      	lsls	r3, r5, #3
34016a1c:	d5ec      	bpl.n	340169f8 <NPU0_IRQHandler+0xa8>
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
34016a1e:	4b0e      	ldr	r3, [pc, #56]	@ (34016a58 <NPU0_IRQHandler+0x108>)
34016a20:	68da      	ldr	r2, [r3, #12]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
34016a22:	60da      	str	r2, [r3, #12]
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
34016a24:	6823      	ldr	r3, [r4, #0]
34016a26:	69db      	ldr	r3, [r3, #28]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34016a28:	6822      	ldr	r2, [r4, #0]
    _tmp_triggered_events |= (1 << ecId);
34016a2a:	f043 0301 	orr.w	r3, r3, #1
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34016a2e:	61d3      	str	r3, [r2, #28]
34016a30:	e7e2      	b.n	340169f8 <NPU0_IRQHandler+0xa8>
34016a32:	bf00      	nop
34016a34:	580e1000 	.word	0x580e1000
34016a38:	340445c4 	.word	0x340445c4
34016a3c:	3401d85a 	.word	0x3401d85a
34016a40:	3403c51f 	.word	0x3403c51f
34016a44:	3401d2af 	.word	0x3401d2af
34016a48:	3401d1fe 	.word	0x3401d1fe
34016a4c:	3401d2a6 	.word	0x3401d2a6
34016a50:	580e503c 	.word	0x580e503c
34016a54:	3403c4f1 	.word	0x3403c4f1
34016a58:	580fe000 	.word	0x580fe000

34016a5c <ll_sw_forward_dequantizelinear>:
{
  Dequantizelinear_sw_info *sw_info = (Dequantizelinear_sw_info *)sw_info_struct;

  // array init
  int32_t format = sw_info->general.input.format.is_signed ? (AI_ARRAY_FORMAT_S8 | AI_FMT_FLAG_IS_IO)
                                                           : (AI_ARRAY_FORMAT_U8 | AI_FMT_FLAG_IS_IO);
34016a5c:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
34016a60:	4a47      	ldr	r2, [pc, #284]	@ (34016b80 <ll_sw_forward_dequantizelinear+0x124>)
34016a62:	2b00      	cmp	r3, #0
34016a64:	4b47      	ldr	r3, [pc, #284]	@ (34016b84 <ll_sw_forward_dequantizelinear+0x128>)
34016a66:	bf18      	it	ne
34016a68:	4613      	movne	r3, r2
{
34016a6a:	b510      	push	{r4, lr}
34016a6c:	b0c4      	sub	sp, #272	@ 0x110
  AI_ARRAY_OBJ_DECLARE(input_output_array, format, sw_info->general.input.mem.start_offset,
34016a6e:	930a      	str	r3, [sp, #40]	@ 0x28
34016a70:	6943      	ldr	r3, [r0, #20]
                                  .info = (const ai_intq_info[1]){{
                                      .scale = ((float *)sw_info->is.mem.start_offset),
                                      .zeropoint = ((void *)sw_info->izp.mem.start_offset),
                                  }}};

  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016a72:	f04f 7482 	mov.w	r4, #17039360	@ 0x1040000
  AI_ARRAY_OBJ_DECLARE(input_output_array, format, sw_info->general.input.mem.start_offset,
34016a76:	930b      	str	r3, [sp, #44]	@ 0x2c
34016a78:	6a83      	ldr	r3, [r0, #40]	@ 0x28
34016a7a:	e9cd 330c 	strd	r3, r3, [sp, #48]	@ 0x30
  AI_ARRAY_OBJ_DECLARE(dequantize_output_array, FORMAT, sw_info->general.output.mem.start_offset,
34016a7e:	4b42      	ldr	r3, [pc, #264]	@ (34016b88 <ll_sw_forward_dequantizelinear+0x12c>)
34016a80:	930e      	str	r3, [sp, #56]	@ 0x38
34016a82:	6c03      	ldr	r3, [r0, #64]	@ 0x40
34016a84:	930f      	str	r3, [sp, #60]	@ 0x3c
34016a86:	6d43      	ldr	r3, [r0, #84]	@ 0x54
34016a88:	e9cd 3310 	strd	r3, r3, [sp, #64]	@ 0x40
  uint16_t offset_format =
34016a8c:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
34016a90:	2b00      	cmp	r3, #0
34016a92:	bf0c      	ite	eq
34016a94:	2202      	moveq	r2, #2
34016a96:	2204      	movne	r2, #4
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
34016a98:	f042 0201 	orr.w	r2, r2, #1
34016a9c:	f8ad 2010 	strh.w	r2, [sp, #16]
34016aa0:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
34016aa2:	ab04      	add	r3, sp, #16
34016aa4:	f8ad 2012 	strh.w	r2, [sp, #18]
                                  .info = (const ai_intq_info[1]){{
34016aa8:	f8d0 2080 	ldr.w	r2, [r0, #128]	@ 0x80
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016aac:	9322      	str	r3, [sp, #136]	@ 0x88
                                  .info = (const ai_intq_info[1]){{
34016aae:	9206      	str	r2, [sp, #24]
34016ab0:	f8d0 20ac 	ldr.w	r2, [r0, #172]	@ 0xac
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016ab4:	6903      	ldr	r3, [r0, #16]
                                  .info = (const ai_intq_info[1]){{
34016ab6:	9207      	str	r2, [sp, #28]
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
34016ab8:	aa06      	add	r2, sp, #24
34016aba:	9205      	str	r2, [sp, #20]
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016abc:	f240 4201 	movw	r2, #1025	@ 0x401
34016ac0:	9312      	str	r3, [sp, #72]	@ 0x48
34016ac2:	68c3      	ldr	r3, [r0, #12]
34016ac4:	e9cd 4223 	strd	r4, r2, [sp, #140]	@ 0x8c
34016ac8:	9313      	str	r3, [sp, #76]	@ 0x4c
34016aca:	6883      	ldr	r3, [r0, #8]
34016acc:	6a41      	ldr	r1, [r0, #36]	@ 0x24
34016ace:	9314      	str	r3, [sp, #80]	@ 0x50
34016ad0:	9116      	str	r1, [sp, #88]	@ 0x58
34016ad2:	6a01      	ldr	r1, [r0, #32]
34016ad4:	6843      	ldr	r3, [r0, #4]
34016ad6:	9117      	str	r1, [sp, #92]	@ 0x5c
34016ad8:	69c1      	ldr	r1, [r0, #28]
34016ada:	9315      	str	r3, [sp, #84]	@ 0x54
34016adc:	ab12      	add	r3, sp, #72	@ 0x48
34016ade:	9325      	str	r3, [sp, #148]	@ 0x94
34016ae0:	9118      	str	r1, [sp, #96]	@ 0x60
34016ae2:	f240 4302 	movw	r3, #1026	@ 0x402
34016ae6:	6981      	ldr	r1, [r0, #24]
                                   sw_info->general.input.dim.tensor_c, sw_info->general.input.dim.tensor_b),
                        STRIDE_INIT(sw_info->general.input.stride.h, sw_info->general.input.stride.w,
                                    sw_info->general.input.stride.c, sw_info->general.input.stride.b),
                        1, &input_output_array, &input_intq);

  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016ae8:	922b      	str	r2, [sp, #172]	@ 0xac
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016aea:	9119      	str	r1, [sp, #100]	@ 0x64
34016aec:	a916      	add	r1, sp, #88	@ 0x58
34016aee:	9127      	str	r1, [sp, #156]	@ 0x9c
34016af0:	a90a      	add	r1, sp, #40	@ 0x28
34016af2:	9128      	str	r1, [sp, #160]	@ 0xa0
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016af4:	2100      	movs	r1, #0
34016af6:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016af8:	9326      	str	r3, [sp, #152]	@ 0x98
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016afa:	921a      	str	r2, [sp, #104]	@ 0x68
34016afc:	6b82      	ldr	r2, [r0, #56]	@ 0x38
34016afe:	e9cd 1429 	strd	r1, r4, [sp, #164]	@ 0xa4
34016b02:	921b      	str	r2, [sp, #108]	@ 0x6c
34016b04:	6b42      	ldr	r2, [r0, #52]	@ 0x34
34016b06:	921c      	str	r2, [sp, #112]	@ 0x70
34016b08:	6b02      	ldr	r2, [r0, #48]	@ 0x30
34016b0a:	921d      	str	r2, [sp, #116]	@ 0x74
34016b0c:	aa1a      	add	r2, sp, #104	@ 0x68
34016b0e:	e9cd 232c 	strd	r2, r3, [sp, #176]	@ 0xb0
34016b12:	6d03      	ldr	r3, [r0, #80]	@ 0x50
                        STRIDE_INIT(sw_info->general.output.stride.h, sw_info->general.output.stride.w,
                                    sw_info->general.output.stride.c, sw_info->general.output.stride.b),
                        1, &dequantize_output_array, NULL);

  // tensor chain initialization
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b14:	aa22      	add	r2, sp, #136	@ 0x88
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016b16:	931e      	str	r3, [sp, #120]	@ 0x78
34016b18:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
34016b1a:	931f      	str	r3, [sp, #124]	@ 0x7c
34016b1c:	6c83      	ldr	r3, [r0, #72]	@ 0x48
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b1e:	9200      	str	r2, [sp, #0]
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016b20:	9320      	str	r3, [sp, #128]	@ 0x80
34016b22:	6c43      	ldr	r3, [r0, #68]	@ 0x44
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b24:	aa29      	add	r2, sp, #164	@ 0xa4
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016b26:	9321      	str	r3, [sp, #132]	@ 0x84
34016b28:	ab1e      	add	r3, sp, #120	@ 0x78
34016b2a:	932e      	str	r3, [sp, #184]	@ 0xb8
34016b2c:	ab0e      	add	r3, sp, #56	@ 0x38
34016b2e:	932f      	str	r3, [sp, #188]	@ 0xbc
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b30:	2304      	movs	r3, #4
34016b32:	9308      	str	r3, [sp, #32]
34016b34:	2301      	movs	r3, #1
34016b36:	e9cd 133a 	strd	r1, r3, [sp, #232]	@ 0xe8
34016b3a:	9338      	str	r3, [sp, #224]	@ 0xe0
34016b3c:	ab01      	add	r3, sp, #4
34016b3e:	e9cd 313c 	strd	r3, r1, [sp, #240]	@ 0xf0
34016b42:	ab02      	add	r3, sp, #8
34016b44:	e9cd 313f 	strd	r3, r1, [sp, #252]	@ 0xfc
34016b48:	ab03      	add	r3, sp, #12
34016b4a:	e9cd 3142 	strd	r3, r1, [sp, #264]	@ 0x108
34016b4e:	ab38      	add	r3, sp, #224	@ 0xe0
34016b50:	9309      	str	r3, [sp, #36]	@ 0x24
                              AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&dequantize_output)),
                              AI_TENSOR_LIST_OBJ_EMPTY, AI_TENSOR_LIST_OBJ_EMPTY)

  // layer initialization
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016b52:	4b0e      	ldr	r3, [pc, #56]	@ (34016b8c <ll_sw_forward_dequantizelinear+0x130>)
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b54:	9201      	str	r2, [sp, #4]
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016b56:	a831      	add	r0, sp, #196	@ 0xc4
34016b58:	221c      	movs	r2, #28
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b5a:	913e      	str	r1, [sp, #248]	@ 0xf8
34016b5c:	9102      	str	r1, [sp, #8]
34016b5e:	9141      	str	r1, [sp, #260]	@ 0x104
34016b60:	9103      	str	r1, [sp, #12]
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016b62:	9330      	str	r3, [sp, #192]	@ 0xc0
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016b64:	f8cd d0e4 	str.w	sp, [sp, #228]	@ 0xe4
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016b68:	f002 f808 	bl	34018b7c <memset>
34016b6c:	4b08      	ldr	r3, [pc, #32]	@ (34016b90 <ll_sw_forward_dequantizelinear+0x134>)
                       NULL, )
  dequantize_layer.forward(AI_LAYER_OBJ(&dequantize_layer));
34016b6e:	a830      	add	r0, sp, #192	@ 0xc0
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016b70:	9335      	str	r3, [sp, #212]	@ 0xd4
34016b72:	ab08      	add	r3, sp, #32
34016b74:	9336      	str	r3, [sp, #216]	@ 0xd8
  dequantize_layer.forward(AI_LAYER_OBJ(&dequantize_layer));
34016b76:	f000 f83d 	bl	34016bf4 <node_convert>
}
34016b7a:	b044      	add	sp, #272	@ 0x110
34016b7c:	bd10      	pop	{r4, pc}
34016b7e:	bf00      	nop
34016b80:	08840440 	.word	0x08840440
34016b84:	08040440 	.word	0x08040440
34016b88:	00821040 	.word	0x00821040
34016b8c:	00010107 	.word	0x00010107
34016b90:	34016bf5 	.word	0x34016bf5

34016b94 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34016b94:	480f      	ldr	r0, [pc, #60]	@ (34016bd4 <LoopForever+0x4>)
  msr   MSPLIM, r0
34016b96:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34016b9a:	480f      	ldr	r0, [pc, #60]	@ (34016bd8 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34016b9c:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34016b9e:	f7ed fc59 	bl	34004454 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34016ba2:	480e      	ldr	r0, [pc, #56]	@ (34016bdc <LoopForever+0xc>)
  ldr r1, =_edata
34016ba4:	490e      	ldr	r1, [pc, #56]	@ (34016be0 <LoopForever+0x10>)
  ldr r2, =_sidata
34016ba6:	4a0f      	ldr	r2, [pc, #60]	@ (34016be4 <LoopForever+0x14>)
  movs r3, #0
34016ba8:	2300      	movs	r3, #0
  b LoopCopyDataInit
34016baa:	e002      	b.n	34016bb2 <LoopCopyDataInit>

34016bac <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34016bac:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34016bae:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34016bb0:	3304      	adds	r3, #4

34016bb2 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34016bb2:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34016bb4:	428c      	cmp	r4, r1
  bcc CopyDataInit
34016bb6:	d3f9      	bcc.n	34016bac <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34016bb8:	4a0b      	ldr	r2, [pc, #44]	@ (34016be8 <LoopForever+0x18>)
  ldr r4, =_ebss
34016bba:	4c0c      	ldr	r4, [pc, #48]	@ (34016bec <LoopForever+0x1c>)
  movs r3, #0
34016bbc:	2300      	movs	r3, #0
  b LoopFillZerobss
34016bbe:	e001      	b.n	34016bc4 <LoopFillZerobss>

34016bc0 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34016bc0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34016bc2:	3204      	adds	r2, #4

34016bc4 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34016bc4:	42a2      	cmp	r2, r4
  bcc FillZerobss
34016bc6:	d3fb      	bcc.n	34016bc0 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34016bc8:	f002 fa32 	bl	34019030 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34016bcc:	f7eb f874 	bl	34001cb8 <main>

34016bd0 <LoopForever>:

LoopForever:
  b LoopForever
34016bd0:	e7fe      	b.n	34016bd0 <LoopForever>
34016bd2:	0000      	.short	0x0000
  ldr   r0, =_sstack
34016bd4:	340fc000 	.word	0x340fc000
  ldr   r0, =_estack
34016bd8:	34100000 	.word	0x34100000
  ldr r0, =_sdata
34016bdc:	3403ec4c 	.word	0x3403ec4c
  ldr r1, =_edata
34016be0:	3403ef98 	.word	0x3403ef98
  ldr r2, =_sidata
34016be4:	3403ec4c 	.word	0x3403ec4c
  ldr r2, =_sbss
34016be8:	3403ef98 	.word	0x3403ef98
  ldr r4, =_ebss
34016bec:	34044718 	.word	0x34044718

34016bf0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34016bf0:	e7fe      	b.n	34016bf0 <ADC1_2_IRQHandler>
	...

34016bf4 <node_convert>:
34016bf4:	6982      	ldr	r2, [r0, #24]
34016bf6:	8813      	ldrh	r3, [r2, #0]
34016bf8:	2b00      	cmp	r3, #0
34016bfa:	d048      	beq.n	34016c8e <node_convert+0x9a>
34016bfc:	6852      	ldr	r2, [r2, #4]
34016bfe:	6851      	ldr	r1, [r2, #4]
34016c00:	b101      	cbz	r1, 34016c04 <node_convert+0x10>
34016c02:	6809      	ldr	r1, [r1, #0]
34016c04:	2b01      	cmp	r3, #1
34016c06:	f000 8147 	beq.w	34016e98 <node_convert+0x2a4>
34016c0a:	b5f0      	push	{r4, r5, r6, r7, lr}
34016c0c:	6910      	ldr	r0, [r2, #16]
34016c0e:	b083      	sub	sp, #12
34016c10:	b100      	cbz	r0, 34016c14 <node_convert+0x20>
34016c12:	6800      	ldr	r0, [r0, #0]
34016c14:	688b      	ldr	r3, [r1, #8]
34016c16:	2401      	movs	r4, #1
34016c18:	0a1a      	lsrs	r2, r3, #8
34016c1a:	d011      	beq.n	34016c40 <node_convert+0x4c>
34016c1c:	ea4f 0e82 	mov.w	lr, r2, lsl #2
34016c20:	f1ae 0e04 	sub.w	lr, lr, #4
34016c24:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
34016c28:	44a6      	add	lr, r4
34016c2a:	f04e e001 	dls	lr, lr
34016c2e:	68cb      	ldr	r3, [r1, #12]
34016c30:	eb03 0382 	add.w	r3, r3, r2, lsl #2
34016c34:	f853 2d04 	ldr.w	r2, [r3, #-4]!
34016c38:	fb02 f404 	mul.w	r4, r2, r4
34016c3c:	f00f c007 	le	lr, 34016c34 <node_convert+0x40>
34016c40:	698a      	ldr	r2, [r1, #24]
34016c42:	6985      	ldr	r5, [r0, #24]
34016c44:	6813      	ldr	r3, [r2, #0]
34016c46:	f3c3 4c43 	ubfx	ip, r3, #17, #4
34016c4a:	f1bc 0f01 	cmp.w	ip, #1
34016c4e:	d020      	beq.n	34016c92 <node_convert+0x9e>
34016c50:	680e      	ldr	r6, [r1, #0]
34016c52:	68ad      	ldr	r5, [r5, #8]
34016c54:	2e00      	cmp	r6, #0
34016c56:	d03a      	beq.n	34016cce <node_convert+0xda>
34016c58:	6871      	ldr	r1, [r6, #4]
34016c5a:	6890      	ldr	r0, [r2, #8]
34016c5c:	f3c3 52c0 	ubfx	r2, r3, #23, #1
34016c60:	2900      	cmp	r1, #0
34016c62:	f000 8099 	beq.w	34016d98 <node_convert+0x1a4>
34016c66:	8873      	ldrh	r3, [r6, #2]
34016c68:	2b00      	cmp	r3, #0
34016c6a:	f000 8082 	beq.w	34016d72 <node_convert+0x17e>
34016c6e:	680b      	ldr	r3, [r1, #0]
34016c70:	ed93 0a00 	vldr	s0, [r3]
34016c74:	684b      	ldr	r3, [r1, #4]
34016c76:	2a00      	cmp	r2, #0
34016c78:	f000 809a 	beq.w	34016db0 <node_convert+0x1bc>
34016c7c:	f993 3000 	ldrsb.w	r3, [r3]
34016c80:	4622      	mov	r2, r4
34016c82:	4629      	mov	r1, r5
34016c84:	b003      	add	sp, #12
34016c86:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016c8a:	f000 b909 	b.w	34016ea0 <forward_lite_node_convert_integer_is8of32>
34016c8e:	685b      	ldr	r3, [r3, #4]
34016c90:	deff      	udf	#255	@ 0xff
34016c92:	6806      	ldr	r6, [r0, #0]
34016c94:	6890      	ldr	r0, [r2, #8]
34016c96:	2e00      	cmp	r6, #0
34016c98:	f000 8092 	beq.w	34016dc0 <node_convert+0x1cc>
34016c9c:	682b      	ldr	r3, [r5, #0]
34016c9e:	6872      	ldr	r2, [r6, #4]
34016ca0:	68a9      	ldr	r1, [r5, #8]
34016ca2:	f3c3 53c0 	ubfx	r3, r3, #23, #1
34016ca6:	2a00      	cmp	r2, #0
34016ca8:	d067      	beq.n	34016d7a <node_convert+0x186>
34016caa:	8875      	ldrh	r5, [r6, #2]
34016cac:	2d00      	cmp	r5, #0
34016cae:	d069      	beq.n	34016d84 <node_convert+0x190>
34016cb0:	6815      	ldr	r5, [r2, #0]
34016cb2:	ed95 0a00 	vldr	s0, [r5]
34016cb6:	2b00      	cmp	r3, #0
34016cb8:	f000 80e3 	beq.w	34016e82 <node_convert+0x28e>
34016cbc:	6853      	ldr	r3, [r2, #4]
34016cbe:	f993 3000 	ldrsb.w	r3, [r3]
34016cc2:	4622      	mov	r2, r4
34016cc4:	b003      	add	sp, #12
34016cc6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016cca:	f000 b8ed 	b.w	34016ea8 <forward_lite_node_convert_integer_if32os8>
34016cce:	f3c3 11c6 	ubfx	r1, r3, #7, #7
34016cd2:	f003 067f 	and.w	r6, r3, #127	@ 0x7f
34016cd6:	1b8e      	subs	r6, r1, r6
34016cd8:	3640      	adds	r6, #64	@ 0x40
34016cda:	f3c3 53c0 	ubfx	r3, r3, #23, #1
34016cde:	2908      	cmp	r1, #8
34016ce0:	6890      	ldr	r0, [r2, #8]
34016ce2:	4629      	mov	r1, r5
34016ce4:	4622      	mov	r2, r4
34016ce6:	eba6 0603 	sub.w	r6, r6, r3
34016cea:	f000 80bc 	beq.w	34016e66 <node_convert+0x272>
34016cee:	f000 fd55 	bl	3401779c <st_int16_to_f32>
34016cf2:	b3e6      	cbz	r6, 34016d6e <node_convert+0x17a>
34016cf4:	ee07 6a90 	vmov	s15, r6
34016cf8:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
34016cfc:	eef8 0ae7 	vcvt.f32.s32	s1, s15
34016d00:	f004 fbce 	bl	3401b4a0 <powf>
34016d04:	b39c      	cbz	r4, 34016d6e <node_convert+0x17a>
34016d06:	1e63      	subs	r3, r4, #1
34016d08:	2b02      	cmp	r3, #2
34016d0a:	f240 80c1 	bls.w	34016e90 <node_convert+0x29c>
34016d0e:	ee10 3a10 	vmov	r3, s0
34016d12:	08a2      	lsrs	r2, r4, #2
34016d14:	eea4 3b10 	vdup.32	q2, r3
34016d18:	f042 e001 	dls	lr, r2
34016d1c:	462b      	mov	r3, r5
34016d1e:	ed93 7f00 	ldc	15, cr7, [r3]
34016d22:	461a      	mov	r2, r3
34016d24:	ff06 6d54 	vmul.f32	q3, q3, q2
34016d28:	3310      	adds	r3, #16
34016d2a:	ed82 7f00 	stc	15, cr7, [r2]
34016d2e:	f00f c00b 	le	lr, 34016d1e <node_convert+0x12a>
34016d32:	f024 0303 	bic.w	r3, r4, #3
34016d36:	429c      	cmp	r4, r3
34016d38:	eb05 0583 	add.w	r5, r5, r3, lsl #2
34016d3c:	d017      	beq.n	34016d6e <node_convert+0x17a>
34016d3e:	edd5 7a00 	vldr	s15, [r5]
34016d42:	ee67 7a80 	vmul.f32	s15, s15, s0
34016d46:	1c5a      	adds	r2, r3, #1
34016d48:	4294      	cmp	r4, r2
34016d4a:	edc5 7a00 	vstr	s15, [r5]
34016d4e:	d90e      	bls.n	34016d6e <node_convert+0x17a>
34016d50:	edd5 7a01 	vldr	s15, [r5, #4]
34016d54:	ee67 7a80 	vmul.f32	s15, s15, s0
34016d58:	3302      	adds	r3, #2
34016d5a:	429c      	cmp	r4, r3
34016d5c:	edc5 7a01 	vstr	s15, [r5, #4]
34016d60:	d905      	bls.n	34016d6e <node_convert+0x17a>
34016d62:	edd5 7a02 	vldr	s15, [r5, #8]
34016d66:	ee67 7a80 	vmul.f32	s15, s15, s0
34016d6a:	edc5 7a02 	vstr	s15, [r5, #8]
34016d6e:	b003      	add	sp, #12
34016d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
34016d72:	b19a      	cbz	r2, 34016d9c <node_convert+0x1a8>
34016d74:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016d78:	e782      	b.n	34016c80 <node_convert+0x8c>
34016d7a:	b12b      	cbz	r3, 34016d88 <node_convert+0x194>
34016d7c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016d80:	4613      	mov	r3, r2
34016d82:	e79e      	b.n	34016cc2 <node_convert+0xce>
34016d84:	2b00      	cmp	r3, #0
34016d86:	d17f      	bne.n	34016e88 <node_convert+0x294>
34016d88:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016d8c:	4622      	mov	r2, r4
34016d8e:	b003      	add	sp, #12
34016d90:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016d94:	f000 b88a 	b.w	34016eac <forward_lite_node_convert_integer_if32ou8>
34016d98:	2a00      	cmp	r2, #0
34016d9a:	d167      	bne.n	34016e6c <node_convert+0x278>
34016d9c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016da0:	2300      	movs	r3, #0
34016da2:	4622      	mov	r2, r4
34016da4:	4629      	mov	r1, r5
34016da6:	b003      	add	sp, #12
34016da8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016dac:	f000 b87a 	b.w	34016ea4 <forward_lite_node_convert_integer_iu8of32>
34016db0:	4622      	mov	r2, r4
34016db2:	4629      	mov	r1, r5
34016db4:	781b      	ldrb	r3, [r3, #0]
34016db6:	b003      	add	sp, #12
34016db8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016dbc:	f000 b872 	b.w	34016ea4 <forward_lite_node_convert_integer_iu8of32>
34016dc0:	682a      	ldr	r2, [r5, #0]
34016dc2:	f3c2 17c6 	ubfx	r7, r2, #7, #7
34016dc6:	f002 037f 	and.w	r3, r2, #127	@ 0x7f
34016dca:	1afb      	subs	r3, r7, r3
34016dcc:	3340      	adds	r3, #64	@ 0x40
34016dce:	f3c2 52c0 	ubfx	r2, r2, #23, #1
34016dd2:	1a9b      	subs	r3, r3, r2
34016dd4:	d03e      	beq.n	34016e54 <node_convert+0x260>
34016dd6:	425b      	negs	r3, r3
34016dd8:	ee00 3a90 	vmov	s1, r3
34016ddc:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
34016de0:	eef8 0ae0 	vcvt.f32.s32	s1, s1
34016de4:	9001      	str	r0, [sp, #4]
34016de6:	f004 fb5b 	bl	3401b4a0 <powf>
34016dea:	9801      	ldr	r0, [sp, #4]
34016dec:	b394      	cbz	r4, 34016e54 <node_convert+0x260>
34016dee:	1e63      	subs	r3, r4, #1
34016df0:	2b02      	cmp	r3, #2
34016df2:	d94f      	bls.n	34016e94 <node_convert+0x2a0>
34016df4:	ee10 2a10 	vmov	r2, s0
34016df8:	08a3      	lsrs	r3, r4, #2
34016dfa:	f043 e001 	dls	lr, r3
34016dfe:	eea4 2b10 	vdup.32	q2, r2
34016e02:	4603      	mov	r3, r0
34016e04:	ed93 7f00 	ldc	15, cr7, [r3]
34016e08:	461a      	mov	r2, r3
34016e0a:	ff06 6d54 	vmul.f32	q3, q3, q2
34016e0e:	3310      	adds	r3, #16
34016e10:	ed82 7f00 	stc	15, cr7, [r2]
34016e14:	f00f c00b 	le	lr, 34016e04 <node_convert+0x210>
34016e18:	f024 0603 	bic.w	r6, r4, #3
34016e1c:	42a6      	cmp	r6, r4
34016e1e:	eb00 0386 	add.w	r3, r0, r6, lsl #2
34016e22:	d017      	beq.n	34016e54 <node_convert+0x260>
34016e24:	edd3 7a00 	vldr	s15, [r3]
34016e28:	ee67 7a80 	vmul.f32	s15, s15, s0
34016e2c:	1c72      	adds	r2, r6, #1
34016e2e:	42a2      	cmp	r2, r4
34016e30:	edc3 7a00 	vstr	s15, [r3]
34016e34:	d20e      	bcs.n	34016e54 <node_convert+0x260>
34016e36:	edd3 7a01 	vldr	s15, [r3, #4]
34016e3a:	ee67 7a80 	vmul.f32	s15, s15, s0
34016e3e:	3602      	adds	r6, #2
34016e40:	42b4      	cmp	r4, r6
34016e42:	edc3 7a01 	vstr	s15, [r3, #4]
34016e46:	d905      	bls.n	34016e54 <node_convert+0x260>
34016e48:	edd3 7a02 	vldr	s15, [r3, #8]
34016e4c:	ee67 7a80 	vmul.f32	s15, s15, s0
34016e50:	edc3 7a02 	vstr	s15, [r3, #8]
34016e54:	2f08      	cmp	r7, #8
34016e56:	d00d      	beq.n	34016e74 <node_convert+0x280>
34016e58:	4622      	mov	r2, r4
34016e5a:	68a9      	ldr	r1, [r5, #8]
34016e5c:	b003      	add	sp, #12
34016e5e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016e62:	f000 ba05 	b.w	34017270 <st_f32_to_int16>
34016e66:	f000 fcdb 	bl	34017820 <st_int8_to_f32>
34016e6a:	e742      	b.n	34016cf2 <node_convert+0xfe>
34016e6c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016e70:	460b      	mov	r3, r1
34016e72:	e705      	b.n	34016c80 <node_convert+0x8c>
34016e74:	4622      	mov	r2, r4
34016e76:	68a9      	ldr	r1, [r5, #8]
34016e78:	b003      	add	sp, #12
34016e7a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016e7e:	f000 bacb 	b.w	34017418 <st_f32_to_int8>
34016e82:	6853      	ldr	r3, [r2, #4]
34016e84:	781b      	ldrb	r3, [r3, #0]
34016e86:	e781      	b.n	34016d8c <node_convert+0x198>
34016e88:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016e8c:	462b      	mov	r3, r5
34016e8e:	e718      	b.n	34016cc2 <node_convert+0xce>
34016e90:	2300      	movs	r3, #0
34016e92:	e754      	b.n	34016d3e <node_convert+0x14a>
34016e94:	4603      	mov	r3, r0
34016e96:	e7c5      	b.n	34016e24 <node_convert+0x230>
34016e98:	2300      	movs	r3, #0
34016e9a:	685b      	ldr	r3, [r3, #4]
34016e9c:	deff      	udf	#255	@ 0xff
34016e9e:	bf00      	nop

34016ea0 <forward_lite_node_convert_integer_is8of32>:
34016ea0:	f000 b806 	b.w	34016eb0 <lite_convert_is8of32>

34016ea4 <forward_lite_node_convert_integer_iu8of32>:
34016ea4:	f000 b83a 	b.w	34016f1c <lite_convert_iu8of32>

34016ea8 <forward_lite_node_convert_integer_if32os8>:
34016ea8:	f000 b85e 	b.w	34016f68 <lite_convert_if32os8>

34016eac <forward_lite_node_convert_integer_if32ou8>:
34016eac:	f000 b954 	b.w	34017158 <lite_convert_if32ou8>

34016eb0 <lite_convert_is8of32>:
34016eb0:	2a00      	cmp	r2, #0
34016eb2:	dd31      	ble.n	34016f18 <lite_convert_is8of32+0x68>
34016eb4:	b570      	push	{r4, r5, r6, lr}
34016eb6:	1885      	adds	r5, r0, r2
34016eb8:	1e50      	subs	r0, r2, #1
34016eba:	f020 0003 	bic.w	r0, r0, #3
34016ebe:	1f16      	subs	r6, r2, #4
34016ec0:	ea4f 0c92 	mov.w	ip, r2, lsr #2
34016ec4:	ee10 4a10 	vmov	r4, s0
34016ec8:	1a36      	subs	r6, r6, r0
34016eca:	f10c 0c01 	add.w	ip, ip, #1
34016ece:	e008      	b.n	34016ee2 <lite_convert_is8of32+0x32>
34016ed0:	4608      	mov	r0, r1
34016ed2:	4296      	cmp	r6, r2
34016ed4:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016ed8:	ed80 7f00 	stc	15, cr7, [r0]
34016edc:	f101 0110 	add.w	r1, r1, #16
34016ee0:	d019      	beq.n	34016f16 <lite_convert_is8of32+0x66>
34016ee2:	f022 e801 	bfcsel	0, 34016ee8 <lite_convert_is8of32+0x38>, 4, hi
34016ee6:	1aa8      	subs	r0, r5, r2
34016ee8:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016eec:	ed90 6f00 	ldc	15, cr6, [r0]
34016ef0:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
34016ef4:	ffbb 6646 	vcvt.f32.s32	q3, q3
34016ef8:	f1bc 0c01 	subs.w	ip, ip, #1
34016efc:	eefd ea10 	vmrs	lr, <impl def 0xd>
34016f00:	ee37 6e64 	cdp	14, 3, cr6, cr7, cr4, {3}
34016f04:	f1a2 0204 	sub.w	r2, r2, #4
34016f08:	d1e2      	bne.n	34016ed0 <lite_convert_is8of32+0x20>
34016f0a:	eeed ea10 	vmsr	<impl def 0xd>, lr
34016f0e:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016f12:	ed81 7f00 	stc	15, cr7, [r1]
34016f16:	bd70      	pop	{r4, r5, r6, pc}
34016f18:	4770      	bx	lr
34016f1a:	bf00      	nop

34016f1c <lite_convert_iu8of32>:
34016f1c:	2a00      	cmp	r2, #0
34016f1e:	dd22      	ble.n	34016f66 <lite_convert_iu8of32+0x4a>
34016f20:	b530      	push	{r4, r5, lr}
34016f22:	f102 3eff 	add.w	lr, r2, #4294967295
34016f26:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
34016f2a:	f10e 0e01 	add.w	lr, lr, #1
34016f2e:	ee10 5a10 	vmov	r5, s0
34016f32:	f04e e001 	dls	lr, lr
34016f36:	1884      	adds	r4, r0, r2
34016f38:	f022 e801 	bfcsel	0, 34016f3e <lite_convert_iu8of32+0x22>, 4, hi
34016f3c:	1aa0      	subs	r0, r4, r2
34016f3e:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016f42:	fd90 6f00 	ldc2	15, cr6, [r0]
34016f46:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
34016f4a:	ffbb 6646 	vcvt.f32.s32	q3, q3
34016f4e:	4608      	mov	r0, r1
34016f50:	ee37 6e65 	cdp	14, 3, cr6, cr7, cr5, {3}
34016f54:	3a04      	subs	r2, #4
34016f56:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016f5a:	ed80 7f00 	stc	15, cr7, [r0]
34016f5e:	3110      	adds	r1, #16
34016f60:	f00f c017 	le	lr, 34016f38 <lite_convert_iu8of32+0x1c>
34016f64:	bd30      	pop	{r4, r5, pc}
34016f66:	4770      	bx	lr

34016f68 <lite_convert_if32os8>:
34016f68:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34016f6c:	ee07 3a10 	vmov	s14, r3
34016f70:	eec7 7a80 	vdiv.f32	s15, s15, s0
34016f74:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34016f78:	ee17 ca90 	vmov	ip, s15
34016f7c:	b500      	push	{lr}
34016f7e:	ed2d 8b10 	vpush	{d8-d15}
34016f82:	ee17 3a10 	vmov	r3, s14
34016f86:	eea8 cb10 	vdup.32	q4, ip
34016f8a:	b09d      	sub	sp, #116	@ 0x74
34016f8c:	eea0 3b10 	vdup.32	q0, r3
34016f90:	2a00      	cmp	r2, #0
34016f92:	ab10      	add	r3, sp, #64	@ 0x40
34016f94:	ed83 9f00 	stc	15, cr9, [r3]
34016f98:	dd6a      	ble.n	34017070 <lite_convert_if32os8+0x108>
34016f9a:	2a0f      	cmp	r2, #15
34016f9c:	dd6d      	ble.n	3401707a <lite_convert_if32os8+0x112>
34016f9e:	f1a2 0c10 	sub.w	ip, r2, #16
34016fa2:	ea4f 131c 	mov.w	r3, ip, lsr #4
34016fa6:	3301      	adds	r3, #1
34016fa8:	f1bc 0f00 	cmp.w	ip, #0
34016fac:	f04f 0e01 	mov.w	lr, #1
34016fb0:	ed9f 2b61 	vldr	d2, [pc, #388]	@ 34017138 <lite_convert_if32os8+0x1d0>
34016fb4:	ed9f 3b62 	vldr	d3, [pc, #392]	@ 34017140 <lite_convert_if32os8+0x1d8>
34016fb8:	bfa8      	it	ge
34016fba:	469e      	movge	lr, r3
34016fbc:	ab14      	add	r3, sp, #80	@ 0x50
34016fbe:	ed9f 4b62 	vldr	d4, [pc, #392]	@ 34017148 <lite_convert_if32os8+0x1e0>
34016fc2:	ed9f 5b63 	vldr	d5, [pc, #396]	@ 34017150 <lite_convert_if32os8+0x1e8>
34016fc6:	f04e e001 	dls	lr, lr
34016fca:	ef22 6152 	vorr	q3, q1, q1
34016fce:	ed83 9f00 	stc	15, cr9, [r3]
34016fd2:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
34016fd6:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
34016fda:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
34016fde:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
34016fe2:	466b      	mov	r3, sp
34016fe4:	ec8d 8b10 	vstmia	sp, {d8-d15}
34016fe8:	ed93 df00 	ldc	15, cr13, [r3]
34016fec:	ab14      	add	r3, sp, #80	@ 0x50
34016fee:	ed93 ff00 	ldc	15, cr15, [r3]
34016ff2:	ef20 a150 	vorr	q5, q0, q0
34016ff6:	ef0c ac5e 	vfma.f32	q5, q6, q7
34016ffa:	ffbb a04a 	vcvta.s32.f32	q5, q5
34016ffe:	ab04      	add	r3, sp, #16
34017000:	ed93 df00 	ldc	15, cr13, [r3]
34017004:	ee37 6e0b 	cdp	14, 3, cr6, cr7, cr11, {0}
34017008:	ef20 a150 	vorr	q5, q0, q0
3401700c:	ef0c ac5e 	vfma.f32	q5, q6, q7
34017010:	ffbb a04a 	vcvta.s32.f32	q5, q5
34017014:	ab08      	add	r3, sp, #32
34017016:	ee37 2e0b 	cdp	14, 3, cr2, cr7, cr11, {0}
3401701a:	ef20 c150 	vorr	q6, q0, q0
3401701e:	ed93 bf00 	ldc	15, cr11, [r3]
34017022:	ab0c      	add	r3, sp, #48	@ 0x30
34017024:	ef0a cc5e 	vfma.f32	q6, q5, q7
34017028:	ed93 9f00 	ldc	15, cr9, [r3]
3401702c:	ef20 a150 	vorr	q5, q0, q0
34017030:	ffbb c04c 	vcvta.s32.f32	q6, q6
34017034:	ef08 ac5e 	vfma.f32	q5, q4, q7
34017038:	ee37 7e0d 	cdp	14, 3, cr7, cr7, cr13, {0}
3401703c:	ffbb a04a 	vcvta.s32.f32	q5, q5
34017040:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
34017044:	ee37 3e0b 	cdp	14, 3, cr3, cr7, cr11, {0}
34017048:	f002 e801 	bfcsel	0, 3401704e <lite_convert_if32os8+0xe6>, 4, eq
3401704c:	468c      	mov	ip, r1
3401704e:	ee33 5e03 	cdp	14, 3, cr5, cr3, cr3, {0}
34017052:	3110      	adds	r1, #16
34017054:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34017058:	ed8c 5e00 	stc	14, cr5, [ip]
3401705c:	3a10      	subs	r2, #16
3401705e:	f00f c049 	le	lr, 34016fd2 <lite_convert_if32os8+0x6a>
34017062:	ab14      	add	r3, sp, #80	@ 0x50
34017064:	ed83 5e00 	stc	14, cr5, [r3]
34017068:	ab18      	add	r3, sp, #96	@ 0x60
3401706a:	ed83 3e80 	stc	14, cr3, [r3, #512]	@ 0x200
3401706e:	b9a2      	cbnz	r2, 3401709a <lite_convert_if32os8+0x132>
34017070:	b01d      	add	sp, #116	@ 0x74
34017072:	ecbd 8b10 	vpop	{d8-d15}
34017076:	f85d fb04 	ldr.w	pc, [sp], #4
3401707a:	ed9f 4b2f 	vldr	d4, [pc, #188]	@ 34017138 <lite_convert_if32os8+0x1d0>
3401707e:	ed9f 5b30 	vldr	d5, [pc, #192]	@ 34017140 <lite_convert_if32os8+0x1d8>
34017082:	ed9f 6b31 	vldr	d6, [pc, #196]	@ 34017148 <lite_convert_if32os8+0x1e0>
34017086:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 34017150 <lite_convert_if32os8+0x1e8>
3401708a:	ab18      	add	r3, sp, #96	@ 0x60
3401708c:	ed83 5e80 	stc	14, cr5, [r3, #512]	@ 0x200
34017090:	ab14      	add	r3, sp, #80	@ 0x50
34017092:	ed83 7e00 	stc	14, cr7, [r3]
34017096:	ef24 6154 	vorr	q3, q2, q2
3401709a:	f002 e801 	bfcsel	0, 340170a0 <lite_convert_if32os8+0x138>, 4, eq
3401709e:	aa10      	add	r2, sp, #64	@ 0x40
340170a0:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
340170a4:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
340170a8:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
340170ac:	fc90 9f61 	ldc2	15, cr9, [r0], {97}	@ 0x61
340170b0:	ed92 5f00 	ldc	15, cr5, [r2]
340170b4:	ef20 2150 	vorr	q1, q0, q0
340170b8:	ef08 2c54 	vfma.f32	q1, q4, q2
340170bc:	ffbb 4042 	vcvta.s32.f32	q2, q1
340170c0:	466a      	mov	r2, sp
340170c2:	ee37 6e05 	cdp	14, 3, cr6, cr7, cr5, {0}
340170c6:	ed82 7e80 	stc	14, cr7, [r2, #512]	@ 0x200
340170ca:	aa10      	add	r2, sp, #64	@ 0x40
340170cc:	ed92 5f00 	ldc	15, cr5, [r2]
340170d0:	ef20 2150 	vorr	q1, q0, q0
340170d4:	ef0a 2c54 	vfma.f32	q1, q5, q2
340170d8:	aa18      	add	r2, sp, #96	@ 0x60
340170da:	ffbb 6042 	vcvta.s32.f32	q3, q1
340170de:	ed92 3e80 	ldc	14, cr3, [r2, #512]	@ 0x200
340170e2:	ee37 2e07 	cdp	14, 3, cr2, cr7, cr7, {0}
340170e6:	aa10      	add	r2, sp, #64	@ 0x40
340170e8:	ef22 4152 	vorr	q2, q1, q1
340170ec:	ed92 3f00 	ldc	15, cr3, [r2]
340170f0:	ef20 6150 	vorr	q3, q0, q0
340170f4:	ef0e 0c52 	vfma.f32	q0, q7, q1
340170f8:	ef0c 6c52 	vfma.f32	q3, q6, q1
340170fc:	466a      	mov	r2, sp
340170fe:	ef20 2150 	vorr	q1, q0, q0
34017102:	ffbb 0046 	vcvta.s32.f32	q0, q3
34017106:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401710a:	ed92 7e80 	ldc	14, cr7, [r2, #512]	@ 0x200
3401710e:	aa14      	add	r2, sp, #80	@ 0x50
34017110:	ee37 5e03 	cdp	14, 3, cr5, cr7, cr3, {0}
34017114:	ee37 7e01 	cdp	14, 3, cr7, cr7, cr1, {0}
34017118:	ed92 3e00 	ldc	14, cr3, [r2]
3401711c:	ee33 2e07 	cdp	14, 3, cr2, cr3, cr7, {0}
34017120:	ee33 3e05 	cdp	14, 3, cr3, cr3, cr5, {0}
34017124:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34017128:	ed81 3e00 	stc	14, cr3, [r1]
3401712c:	b01d      	add	sp, #116	@ 0x74
3401712e:	ecbd 8b10 	vpop	{d8-d15}
34017132:	f85d fb04 	ldr.w	pc, [sp], #4
34017136:	bf00      	nop
	...

34017158 <lite_convert_if32ou8>:
34017158:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401715c:	2a00      	cmp	r2, #0
3401715e:	eec7 7a80 	vdiv.f32	s15, s15, s0
34017162:	dd72      	ble.n	3401724a <lite_convert_if32ou8+0xf2>
34017164:	ee07 3a10 	vmov	s14, r3
34017168:	eeb8 7a47 	vcvt.f32.u32	s14, s14
3401716c:	ee17 ca90 	vmov	ip, s15
34017170:	b500      	push	{lr}
34017172:	ed2d 8b10 	vpush	{d8-d15}
34017176:	ee17 3a10 	vmov	r3, s14
3401717a:	eea8 cb10 	vdup.32	q4, ip
3401717e:	ed9f 6b34 	vldr	d6, [pc, #208]	@ 34017250 <lite_convert_if32ou8+0xf8>
34017182:	ed9f 7b35 	vldr	d7, [pc, #212]	@ 34017258 <lite_convert_if32ou8+0x100>
34017186:	f102 3eff 	add.w	lr, r2, #4294967295
3401718a:	b095      	sub	sp, #84	@ 0x54
3401718c:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
34017190:	eea0 3b10 	vdup.32	q0, r3
34017194:	f10e 0e01 	add.w	lr, lr, #1
34017198:	ab10      	add	r3, sp, #64	@ 0x40
3401719a:	ed9f 2b31 	vldr	d2, [pc, #196]	@ 34017260 <lite_convert_if32ou8+0x108>
3401719e:	ed9f 3b32 	vldr	d3, [pc, #200]	@ 34017268 <lite_convert_if32ou8+0x110>
340171a2:	f04e e001 	dls	lr, lr
340171a6:	ef26 4156 	vorr	q2, q3, q3
340171aa:	ed83 9f00 	stc	15, cr9, [r3]
340171ae:	4411      	add	r1, r2
340171b0:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
340171b4:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
340171b8:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
340171bc:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
340171c0:	466b      	mov	r3, sp
340171c2:	ec8d 8b10 	vstmia	sp, {d8-d15}
340171c6:	ed93 df00 	ldc	15, cr13, [r3]
340171ca:	ab10      	add	r3, sp, #64	@ 0x40
340171cc:	ed93 ff00 	ldc	15, cr15, [r3]
340171d0:	ef20 a150 	vorr	q5, q0, q0
340171d4:	ef0c ac5e 	vfma.f32	q5, q6, q7
340171d8:	ffbb a0ca 	vcvta.u32.f32	q5, q5
340171dc:	ab04      	add	r3, sp, #16
340171de:	ed93 df00 	ldc	15, cr13, [r3]
340171e2:	fe37 4e0b 	cdp2	14, 3, cr4, cr7, cr11, {0}
340171e6:	ef20 a150 	vorr	q5, q0, q0
340171ea:	ef0c ac5e 	vfma.f32	q5, q6, q7
340171ee:	ffbb a0ca 	vcvta.u32.f32	q5, q5
340171f2:	ab08      	add	r3, sp, #32
340171f4:	fe37 6e0b 	cdp2	14, 3, cr6, cr7, cr11, {0}
340171f8:	ef20 c150 	vorr	q6, q0, q0
340171fc:	ed93 bf00 	ldc	15, cr11, [r3]
34017200:	ab0c      	add	r3, sp, #48	@ 0x30
34017202:	ef0a cc5e 	vfma.f32	q6, q5, q7
34017206:	ed93 9f00 	ldc	15, cr9, [r3]
3401720a:	ef20 a150 	vorr	q5, q0, q0
3401720e:	ffbb c0cc 	vcvta.u32.f32	q6, q6
34017212:	ef08 ac5e 	vfma.f32	q5, q4, q7
34017216:	fe37 5e0d 	cdp2	14, 3, cr5, cr7, cr13, {0}
3401721a:	ffbb a0ca 	vcvta.u32.f32	q5, q5
3401721e:	fe33 2e05 	cdp2	14, 3, cr2, cr3, cr5, {0}
34017222:	fe37 7e0b 	cdp2	14, 3, cr7, cr7, cr11, {0}
34017226:	f022 e801 	bfcsel	0, 3401722c <lite_convert_if32ou8+0xd4>, 4, hi
3401722a:	fe33 3e07 	cdp2	14, 3, cr3, cr3, cr7, {0}
3401722e:	eba1 0c02 	sub.w	ip, r1, r2
34017232:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34017236:	ed8c 3e00 	stc	14, cr3, [ip]
3401723a:	3a10      	subs	r2, #16
3401723c:	f00f c049 	le	lr, 340171b0 <lite_convert_if32ou8+0x58>
34017240:	b015      	add	sp, #84	@ 0x54
34017242:	ecbd 8b10 	vpop	{d8-d15}
34017246:	f85d fb04 	ldr.w	pc, [sp], #4
3401724a:	4770      	bx	lr
3401724c:	f3af 8000 	nop.w
	...

34017270 <st_f32_to_int16>:
34017270:	b570      	push	{r4, r5, r6, lr}
34017272:	08d5      	lsrs	r5, r2, #3
34017274:	ed2d 8b08 	vpush	{d8-d11}
34017278:	d022      	beq.n	340172c0 <st_f32_to_int16+0x50>
3401727a:	460c      	mov	r4, r1
3401727c:	ed9f 6b60 	vldr	d6, [pc, #384]	@ 34017400 <st_f32_to_int16+0x190>
34017280:	ed9f 7b61 	vldr	d7, [pc, #388]	@ 34017408 <st_f32_to_int16+0x198>
34017284:	4684      	mov	ip, r0
34017286:	f045 e001 	dls	lr, r5
3401728a:	4b61      	ldr	r3, [pc, #388]	@ (34017410 <st_f32_to_int16+0x1a0>)
3401728c:	fc9c 9f00 	ldc2	15, cr9, [ip], {0}
34017290:	fcbc 9f20 	ldc2	15, cr9, [ip], #128	@ 0x80
34017294:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
34017298:	ee3b 4e63 	cdp	14, 3, cr4, cr11, cr3, {3}
3401729c:	ffbb 2042 	vcvta.s32.f32	q1, q1
340172a0:	ffbb 4044 	vcvta.s32.f32	q2, q2
340172a4:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
340172a8:	4626      	mov	r6, r4
340172aa:	ee37 7e05 	cdp	14, 3, cr7, cr7, cr5, {0}
340172ae:	3410      	adds	r4, #16
340172b0:	ed86 7e80 	stc	14, cr7, [r6, #512]	@ 0x200
340172b4:	f00f c017 	le	lr, 3401728c <st_f32_to_int16+0x1c>
340172b8:	eb00 1045 	add.w	r0, r0, r5, lsl #5
340172bc:	eb01 1105 	add.w	r1, r1, r5, lsl #4
340172c0:	f012 0207 	ands.w	r2, r2, #7
340172c4:	f000 8097 	beq.w	340173f6 <st_f32_to_int16+0x186>
340172c8:	edd0 5a00 	vldr	s11, [r0]
340172cc:	ed9f 6a51 	vldr	s12, [pc, #324]	@ 34017414 <st_f32_to_int16+0x1a4>
340172d0:	ee65 5a86 	vmul.f32	s11, s11, s12
340172d4:	eef5 5ac0 	vcmpe.f32	s11, #0.0
340172d8:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
340172dc:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
340172e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340172e4:	fe77 7a26 	vselgt.f32	s15, s14, s13
340172e8:	ee77 7aa5 	vadd.f32	s15, s15, s11
340172ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340172f0:	ee17 3a90 	vmov	r3, s15
340172f4:	f303 030f 	ssat	r3, #16, r3
340172f8:	2a01      	cmp	r2, #1
340172fa:	800b      	strh	r3, [r1, #0]
340172fc:	d07b      	beq.n	340173f6 <st_f32_to_int16+0x186>
340172fe:	edd0 7a01 	vldr	s15, [r0, #4]
34017302:	ee67 7a86 	vmul.f32	s15, s15, s12
34017306:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401730a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401730e:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017312:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017316:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401731a:	ee17 3a90 	vmov	r3, s15
3401731e:	f303 030f 	ssat	r3, #16, r3
34017322:	2a02      	cmp	r2, #2
34017324:	804b      	strh	r3, [r1, #2]
34017326:	d066      	beq.n	340173f6 <st_f32_to_int16+0x186>
34017328:	edd0 7a02 	vldr	s15, [r0, #8]
3401732c:	ee67 7a86 	vmul.f32	s15, s15, s12
34017330:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017334:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017338:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401733c:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017340:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017344:	ee17 3a90 	vmov	r3, s15
34017348:	f303 030f 	ssat	r3, #16, r3
3401734c:	2a03      	cmp	r2, #3
3401734e:	808b      	strh	r3, [r1, #4]
34017350:	d051      	beq.n	340173f6 <st_f32_to_int16+0x186>
34017352:	edd0 7a03 	vldr	s15, [r0, #12]
34017356:	ee67 7a86 	vmul.f32	s15, s15, s12
3401735a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401735e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017362:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017366:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401736a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401736e:	ee17 3a90 	vmov	r3, s15
34017372:	f303 030f 	ssat	r3, #16, r3
34017376:	2a04      	cmp	r2, #4
34017378:	80cb      	strh	r3, [r1, #6]
3401737a:	d03c      	beq.n	340173f6 <st_f32_to_int16+0x186>
3401737c:	edd0 7a04 	vldr	s15, [r0, #16]
34017380:	ee67 7a86 	vmul.f32	s15, s15, s12
34017384:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017388:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401738c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017390:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017394:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017398:	ee17 3a90 	vmov	r3, s15
3401739c:	f303 030f 	ssat	r3, #16, r3
340173a0:	3a05      	subs	r2, #5
340173a2:	810b      	strh	r3, [r1, #8]
340173a4:	d027      	beq.n	340173f6 <st_f32_to_int16+0x186>
340173a6:	edd0 7a05 	vldr	s15, [r0, #20]
340173aa:	ee67 7a86 	vmul.f32	s15, s15, s12
340173ae:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340173b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340173b6:	fe77 5a26 	vselgt.f32	s11, s14, s13
340173ba:	ee77 7aa5 	vadd.f32	s15, s15, s11
340173be:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340173c2:	ee17 3a90 	vmov	r3, s15
340173c6:	f303 030f 	ssat	r3, #16, r3
340173ca:	2a01      	cmp	r2, #1
340173cc:	814b      	strh	r3, [r1, #10]
340173ce:	d012      	beq.n	340173f6 <st_f32_to_int16+0x186>
340173d0:	edd0 7a06 	vldr	s15, [r0, #24]
340173d4:	ee67 7a86 	vmul.f32	s15, s15, s12
340173d8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340173dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340173e0:	fe37 7a26 	vselgt.f32	s14, s14, s13
340173e4:	ee37 7a27 	vadd.f32	s14, s14, s15
340173e8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
340173ec:	ee17 3a10 	vmov	r3, s14
340173f0:	f303 030f 	ssat	r3, #16, r3
340173f4:	818b      	strh	r3, [r1, #12]
340173f6:	ecbd 8b08 	vpop	{d8-d11}
340173fa:	bd70      	pop	{r4, r5, r6, pc}
340173fc:	f3af 8000 	nop.w
	...
34017410:	46fffe00 	.word	0x46fffe00
34017414:	47000000 	.word	0x47000000

34017418 <st_f32_to_int8>:
34017418:	b570      	push	{r4, r5, r6, lr}
3401741a:	0915      	lsrs	r5, r2, #4
3401741c:	ed2d 8b10 	vpush	{d8-d15}
34017420:	f000 81a5 	beq.w	3401776e <st_f32_to_int8+0x356>
34017424:	ed9f 0bd4 	vldr	d0, [pc, #848]	@ 34017778 <st_f32_to_int8+0x360>
34017428:	ed9f 1bd5 	vldr	d1, [pc, #852]	@ 34017780 <st_f32_to_int8+0x368>
3401742c:	ea4f 1e05 	mov.w	lr, r5, lsl #4
34017430:	f1ae 0e10 	sub.w	lr, lr, #16
34017434:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
34017438:	f10e 0e01 	add.w	lr, lr, #1
3401743c:	ed9f 4bd2 	vldr	d4, [pc, #840]	@ 34017788 <st_f32_to_int8+0x370>
34017440:	ed9f 5bd3 	vldr	d5, [pc, #844]	@ 34017790 <st_f32_to_int8+0x378>
34017444:	f04f 4386 	mov.w	r3, #1124073472	@ 0x43000000
34017448:	f04e e001 	dls	lr, lr
3401744c:	4684      	mov	ip, r0
3401744e:	ef20 6150 	vorr	q3, q0, q0
34017452:	eb01 1405 	add.w	r4, r1, r5, lsl #4
34017456:	fc9c 9f01 	ldc2	15, cr9, [ip], {1}
3401745a:	fc9c 9f21 	ldc2	15, cr9, [ip], {33}	@ 0x21
3401745e:	fc9c 9f41 	ldc2	15, cr9, [ip], {65}	@ 0x41
34017462:	fcbc 9f61 	ldc2	15, cr9, [ip], #388	@ 0x184
34017466:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
3401746a:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401746e:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
34017472:	ee3b 2e63 	cdp	14, 3, cr2, cr11, cr3, {3}
34017476:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401747a:	ee37 0e03 	cdp	14, 3, cr0, cr7, cr3, {0}
3401747e:	ee3d 2e63 	cdp	14, 3, cr2, cr13, cr3, {3}
34017482:	ee3f 8e63 	cdp	14, 3, cr8, cr15, cr3, {3}
34017486:	ffbb 2042 	vcvta.s32.f32	q1, q1
3401748a:	ffbb 8048 	vcvta.s32.f32	q4, q4
3401748e:	ee37 7e03 	cdp	14, 3, cr7, cr7, cr3, {0}
34017492:	ee37 1e09 	cdp	14, 3, cr1, cr7, cr9, {0}
34017496:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
3401749a:	460e      	mov	r6, r1
3401749c:	ee33 5e01 	cdp	14, 3, cr5, cr3, cr1, {0}
340174a0:	3110      	adds	r1, #16
340174a2:	ed86 5e00 	stc	14, cr5, [r6]
340174a6:	f00f c02b 	le	lr, 34017456 <st_f32_to_int8+0x3e>
340174aa:	eb00 1085 	add.w	r0, r0, r5, lsl #6
340174ae:	f012 030f 	ands.w	r3, r2, #15
340174b2:	f000 8159 	beq.w	34017768 <st_f32_to_int8+0x350>
340174b6:	edd0 5a00 	vldr	s11, [r0]
340174ba:	ed9f 6ab7 	vldr	s12, [pc, #732]	@ 34017798 <st_f32_to_int8+0x380>
340174be:	ee65 5a86 	vmul.f32	s11, s11, s12
340174c2:	eef5 5ac0 	vcmpe.f32	s11, #0.0
340174c6:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
340174ca:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
340174ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340174d2:	fe77 7a26 	vselgt.f32	s15, s14, s13
340174d6:	ee77 7aa5 	vadd.f32	s15, s15, s11
340174da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340174de:	ee17 2a90 	vmov	r2, s15
340174e2:	b212      	sxth	r2, r2
340174e4:	f302 0207 	ssat	r2, #8, r2
340174e8:	2b01      	cmp	r3, #1
340174ea:	7022      	strb	r2, [r4, #0]
340174ec:	f000 813c 	beq.w	34017768 <st_f32_to_int8+0x350>
340174f0:	edd0 7a01 	vldr	s15, [r0, #4]
340174f4:	ee67 7a86 	vmul.f32	s15, s15, s12
340174f8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340174fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017500:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017504:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017508:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401750c:	ee17 2a90 	vmov	r2, s15
34017510:	b212      	sxth	r2, r2
34017512:	f302 0207 	ssat	r2, #8, r2
34017516:	2b02      	cmp	r3, #2
34017518:	7062      	strb	r2, [r4, #1]
3401751a:	f000 8125 	beq.w	34017768 <st_f32_to_int8+0x350>
3401751e:	edd0 7a02 	vldr	s15, [r0, #8]
34017522:	ee67 7a86 	vmul.f32	s15, s15, s12
34017526:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401752a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401752e:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017532:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017536:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401753a:	ee17 2a90 	vmov	r2, s15
3401753e:	b212      	sxth	r2, r2
34017540:	f302 0207 	ssat	r2, #8, r2
34017544:	2b03      	cmp	r3, #3
34017546:	70a2      	strb	r2, [r4, #2]
34017548:	f000 810e 	beq.w	34017768 <st_f32_to_int8+0x350>
3401754c:	edd0 7a03 	vldr	s15, [r0, #12]
34017550:	ee67 7a86 	vmul.f32	s15, s15, s12
34017554:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017558:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401755c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017560:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017564:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017568:	ee17 2a90 	vmov	r2, s15
3401756c:	b212      	sxth	r2, r2
3401756e:	f302 0207 	ssat	r2, #8, r2
34017572:	2b04      	cmp	r3, #4
34017574:	70e2      	strb	r2, [r4, #3]
34017576:	f000 80f7 	beq.w	34017768 <st_f32_to_int8+0x350>
3401757a:	edd0 7a04 	vldr	s15, [r0, #16]
3401757e:	ee67 7a86 	vmul.f32	s15, s15, s12
34017582:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017586:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401758a:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401758e:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017592:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017596:	ee17 2a90 	vmov	r2, s15
3401759a:	b212      	sxth	r2, r2
3401759c:	f302 0207 	ssat	r2, #8, r2
340175a0:	2b05      	cmp	r3, #5
340175a2:	7122      	strb	r2, [r4, #4]
340175a4:	f000 80e0 	beq.w	34017768 <st_f32_to_int8+0x350>
340175a8:	edd0 7a05 	vldr	s15, [r0, #20]
340175ac:	ee67 7a86 	vmul.f32	s15, s15, s12
340175b0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340175b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340175b8:	fe77 5a26 	vselgt.f32	s11, s14, s13
340175bc:	ee77 7aa5 	vadd.f32	s15, s15, s11
340175c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340175c4:	ee17 2a90 	vmov	r2, s15
340175c8:	b212      	sxth	r2, r2
340175ca:	f302 0207 	ssat	r2, #8, r2
340175ce:	2b06      	cmp	r3, #6
340175d0:	7162      	strb	r2, [r4, #5]
340175d2:	f000 80c9 	beq.w	34017768 <st_f32_to_int8+0x350>
340175d6:	edd0 7a06 	vldr	s15, [r0, #24]
340175da:	ee67 7a86 	vmul.f32	s15, s15, s12
340175de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340175e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340175e6:	fe77 5a26 	vselgt.f32	s11, s14, s13
340175ea:	ee77 7aa5 	vadd.f32	s15, s15, s11
340175ee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340175f2:	ee17 2a90 	vmov	r2, s15
340175f6:	b212      	sxth	r2, r2
340175f8:	f302 0207 	ssat	r2, #8, r2
340175fc:	2b07      	cmp	r3, #7
340175fe:	71a2      	strb	r2, [r4, #6]
34017600:	f000 80b2 	beq.w	34017768 <st_f32_to_int8+0x350>
34017604:	edd0 7a07 	vldr	s15, [r0, #28]
34017608:	ee67 7a86 	vmul.f32	s15, s15, s12
3401760c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017610:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017614:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017618:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401761c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017620:	ee17 2a90 	vmov	r2, s15
34017624:	b212      	sxth	r2, r2
34017626:	f302 0207 	ssat	r2, #8, r2
3401762a:	2b08      	cmp	r3, #8
3401762c:	71e2      	strb	r2, [r4, #7]
3401762e:	f000 809b 	beq.w	34017768 <st_f32_to_int8+0x350>
34017632:	edd0 7a08 	vldr	s15, [r0, #32]
34017636:	ee67 7a86 	vmul.f32	s15, s15, s12
3401763a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401763e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017642:	fe37 7a26 	vselgt.f32	s14, s14, s13
34017646:	ee77 7a87 	vadd.f32	s15, s15, s14
3401764a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401764e:	ee17 2a90 	vmov	r2, s15
34017652:	b212      	sxth	r2, r2
34017654:	f302 0207 	ssat	r2, #8, r2
34017658:	2b09      	cmp	r3, #9
3401765a:	7222      	strb	r2, [r4, #8]
3401765c:	f000 8084 	beq.w	34017768 <st_f32_to_int8+0x350>
34017660:	edd0 7a09 	vldr	s15, [r0, #36]	@ 0x24
34017664:	ee67 7a86 	vmul.f32	s15, s15, s12
34017668:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401766c:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34017670:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017674:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017678:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401767c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017680:	ee17 2a90 	vmov	r2, s15
34017684:	b212      	sxth	r2, r2
34017686:	f302 0207 	ssat	r2, #8, r2
3401768a:	2b0a      	cmp	r3, #10
3401768c:	7262      	strb	r2, [r4, #9]
3401768e:	d06b      	beq.n	34017768 <st_f32_to_int8+0x350>
34017690:	edd0 7a0a 	vldr	s15, [r0, #40]	@ 0x28
34017694:	ee67 7a86 	vmul.f32	s15, s15, s12
34017698:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401769c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340176a0:	fe77 5a26 	vselgt.f32	s11, s14, s13
340176a4:	ee77 7aa5 	vadd.f32	s15, s15, s11
340176a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340176ac:	ee17 2a90 	vmov	r2, s15
340176b0:	b212      	sxth	r2, r2
340176b2:	f302 0207 	ssat	r2, #8, r2
340176b6:	2b0b      	cmp	r3, #11
340176b8:	72a2      	strb	r2, [r4, #10]
340176ba:	d055      	beq.n	34017768 <st_f32_to_int8+0x350>
340176bc:	edd0 7a0b 	vldr	s15, [r0, #44]	@ 0x2c
340176c0:	ee67 7a86 	vmul.f32	s15, s15, s12
340176c4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340176c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340176cc:	fe77 5a26 	vselgt.f32	s11, s14, s13
340176d0:	ee77 7aa5 	vadd.f32	s15, s15, s11
340176d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340176d8:	ee17 2a90 	vmov	r2, s15
340176dc:	b212      	sxth	r2, r2
340176de:	f302 0207 	ssat	r2, #8, r2
340176e2:	2b0c      	cmp	r3, #12
340176e4:	72e2      	strb	r2, [r4, #11]
340176e6:	d03f      	beq.n	34017768 <st_f32_to_int8+0x350>
340176e8:	edd0 7a0c 	vldr	s15, [r0, #48]	@ 0x30
340176ec:	ee67 7a86 	vmul.f32	s15, s15, s12
340176f0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340176f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340176f8:	fe77 5a26 	vselgt.f32	s11, s14, s13
340176fc:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017700:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017704:	ee17 2a90 	vmov	r2, s15
34017708:	b212      	sxth	r2, r2
3401770a:	f302 0207 	ssat	r2, #8, r2
3401770e:	3b0d      	subs	r3, #13
34017710:	7322      	strb	r2, [r4, #12]
34017712:	d029      	beq.n	34017768 <st_f32_to_int8+0x350>
34017714:	edd0 7a0d 	vldr	s15, [r0, #52]	@ 0x34
34017718:	ee67 7a86 	vmul.f32	s15, s15, s12
3401771c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017720:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017724:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017728:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401772c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017730:	ee17 2a90 	vmov	r2, s15
34017734:	b212      	sxth	r2, r2
34017736:	f302 0207 	ssat	r2, #8, r2
3401773a:	2b01      	cmp	r3, #1
3401773c:	7362      	strb	r2, [r4, #13]
3401773e:	d013      	beq.n	34017768 <st_f32_to_int8+0x350>
34017740:	edd0 7a0e 	vldr	s15, [r0, #56]	@ 0x38
34017744:	ee27 6a86 	vmul.f32	s12, s15, s12
34017748:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
3401774c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017750:	fe77 7a26 	vselgt.f32	s15, s14, s13
34017754:	ee77 7a86 	vadd.f32	s15, s15, s12
34017758:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401775c:	ee17 3a90 	vmov	r3, s15
34017760:	b21b      	sxth	r3, r3
34017762:	f303 0307 	ssat	r3, #8, r3
34017766:	73a3      	strb	r3, [r4, #14]
34017768:	ecbd 8b10 	vpop	{d8-d15}
3401776c:	bd70      	pop	{r4, r5, r6, pc}
3401776e:	460c      	mov	r4, r1
34017770:	e69d      	b.n	340174ae <st_f32_to_int8+0x96>
34017772:	bf00      	nop
34017774:	f3af 8000 	nop.w
	...
34017798:	43000000 	.word	0x43000000

3401779c <st_int16_to_f32>:
3401779c:	ea5f 0c92 	movs.w	ip, r2, lsr #2
340177a0:	b530      	push	{r4, r5, lr}
340177a2:	d013      	beq.n	340177cc <st_int16_to_f32+0x30>
340177a4:	4604      	mov	r4, r0
340177a6:	460b      	mov	r3, r1
340177a8:	f04c e001 	dls	lr, ip
340177ac:	4625      	mov	r5, r4
340177ae:	ed9d 6f00 	ldc	15, cr6, [sp]
340177b2:	461d      	mov	r5, r3
340177b4:	efb1 6e56 	vcvt.f32.s32	q3, q3, #15
340177b8:	3408      	adds	r4, #8
340177ba:	ed85 7f00 	stc	15, cr7, [r5]
340177be:	3310      	adds	r3, #16
340177c0:	f00f c00d 	le	lr, 340177ac <st_int16_to_f32+0x10>
340177c4:	eb01 110c 	add.w	r1, r1, ip, lsl #4
340177c8:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
340177cc:	f012 0203 	ands.w	r2, r2, #3
340177d0:	d023      	beq.n	3401781a <st_int16_to_f32+0x7e>
340177d2:	f9b0 3000 	ldrsh.w	r3, [r0]
340177d6:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 3401781c <st_int16_to_f32+0x80>
340177da:	ee07 3a90 	vmov	s15, r3
340177de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340177e2:	ee67 7a87 	vmul.f32	s15, s15, s14
340177e6:	3a01      	subs	r2, #1
340177e8:	edc1 7a00 	vstr	s15, [r1]
340177ec:	d015      	beq.n	3401781a <st_int16_to_f32+0x7e>
340177ee:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
340177f2:	2a01      	cmp	r2, #1
340177f4:	ee07 3a90 	vmov	s15, r3
340177f8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340177fc:	ee67 7a87 	vmul.f32	s15, s15, s14
34017800:	edc1 7a01 	vstr	s15, [r1, #4]
34017804:	d009      	beq.n	3401781a <st_int16_to_f32+0x7e>
34017806:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
3401780a:	ee07 3a90 	vmov	s15, r3
3401780e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34017812:	ee67 7a87 	vmul.f32	s15, s15, s14
34017816:	edc1 7a02 	vstr	s15, [r1, #8]
3401781a:	bd30      	pop	{r4, r5, pc}
3401781c:	38000000 	.word	0x38000000

34017820 <st_int8_to_f32>:
34017820:	ea5f 0c92 	movs.w	ip, r2, lsr #2
34017824:	b530      	push	{r4, r5, lr}
34017826:	d042      	beq.n	340178ae <st_int8_to_f32+0x8e>
34017828:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
3401782c:	f1ae 0e04 	sub.w	lr, lr, #4
34017830:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
34017834:	f10e 0e01 	add.w	lr, lr, #1
34017838:	f04e e001 	dls	lr, lr
3401783c:	460b      	mov	r3, r1
3401783e:	eb00 048c 	add.w	r4, r0, ip, lsl #2
34017842:	4605      	mov	r5, r0
34017844:	ed95 6f00 	ldc	15, cr6, [r5]
34017848:	461d      	mov	r5, r3
3401784a:	efb9 6e56 	vcvt.f32.s32	q3, q3, #7
3401784e:	3004      	adds	r0, #4
34017850:	ed85 7f00 	stc	15, cr7, [r5]
34017854:	3310      	adds	r3, #16
34017856:	f00f c00d 	le	lr, 34017842 <st_int8_to_f32+0x22>
3401785a:	eb01 110c 	add.w	r1, r1, ip, lsl #4
3401785e:	f012 0203 	ands.w	r2, r2, #3
34017862:	d023      	beq.n	340178ac <st_int8_to_f32+0x8c>
34017864:	f994 3000 	ldrsb.w	r3, [r4]
34017868:	ed9f 7a12 	vldr	s14, [pc, #72]	@ 340178b4 <st_int8_to_f32+0x94>
3401786c:	ee07 3a90 	vmov	s15, r3
34017870:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34017874:	ee67 7a87 	vmul.f32	s15, s15, s14
34017878:	3a01      	subs	r2, #1
3401787a:	edc1 7a00 	vstr	s15, [r1]
3401787e:	d015      	beq.n	340178ac <st_int8_to_f32+0x8c>
34017880:	f994 3001 	ldrsb.w	r3, [r4, #1]
34017884:	2a01      	cmp	r2, #1
34017886:	ee07 3a90 	vmov	s15, r3
3401788a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3401788e:	ee67 7a87 	vmul.f32	s15, s15, s14
34017892:	edc1 7a01 	vstr	s15, [r1, #4]
34017896:	d009      	beq.n	340178ac <st_int8_to_f32+0x8c>
34017898:	f994 3002 	ldrsb.w	r3, [r4, #2]
3401789c:	ee07 3a90 	vmov	s15, r3
340178a0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340178a4:	ee67 7a87 	vmul.f32	s15, s15, s14
340178a8:	edc1 7a02 	vstr	s15, [r1, #8]
340178ac:	bd30      	pop	{r4, r5, pc}
340178ae:	4604      	mov	r4, r0
340178b0:	e7d5      	b.n	3401785e <st_int8_to_f32+0x3e>
340178b2:	bf00      	nop
340178b4:	3c000000 	.word	0x3c000000

340178b8 <__assert_func>:
340178b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
340178ba:	4614      	mov	r4, r2
340178bc:	461a      	mov	r2, r3
340178be:	4b09      	ldr	r3, [pc, #36]	@ (340178e4 <__assert_func+0x2c>)
340178c0:	4605      	mov	r5, r0
340178c2:	681b      	ldr	r3, [r3, #0]
340178c4:	68d8      	ldr	r0, [r3, #12]
340178c6:	b14c      	cbz	r4, 340178dc <__assert_func+0x24>
340178c8:	4b07      	ldr	r3, [pc, #28]	@ (340178e8 <__assert_func+0x30>)
340178ca:	9100      	str	r1, [sp, #0]
340178cc:	4907      	ldr	r1, [pc, #28]	@ (340178ec <__assert_func+0x34>)
340178ce:	e9cd 3401 	strd	r3, r4, [sp, #4]
340178d2:	462b      	mov	r3, r5
340178d4:	f000 ff4e 	bl	34018774 <fiprintf>
340178d8:	f001 fbf4 	bl	340190c4 <abort>
340178dc:	4b04      	ldr	r3, [pc, #16]	@ (340178f0 <__assert_func+0x38>)
340178de:	461c      	mov	r4, r3
340178e0:	e7f3      	b.n	340178ca <__assert_func+0x12>
340178e2:	bf00      	nop
340178e4:	3403eddc 	.word	0x3403eddc
340178e8:	3401df49 	.word	0x3401df49
340178ec:	3401df56 	.word	0x3401df56
340178f0:	3401d059 	.word	0x3401d059

340178f4 <malloc>:
340178f4:	4b02      	ldr	r3, [pc, #8]	@ (34017900 <malloc+0xc>)
340178f6:	4601      	mov	r1, r0
340178f8:	6818      	ldr	r0, [r3, #0]
340178fa:	f000 b825 	b.w	34017948 <_malloc_r>
340178fe:	bf00      	nop
34017900:	3403eddc 	.word	0x3403eddc

34017904 <sbrk_aligned>:
34017904:	b570      	push	{r4, r5, r6, lr}
34017906:	4e0f      	ldr	r6, [pc, #60]	@ (34017944 <sbrk_aligned+0x40>)
34017908:	460c      	mov	r4, r1
3401790a:	4605      	mov	r5, r0
3401790c:	6831      	ldr	r1, [r6, #0]
3401790e:	b911      	cbnz	r1, 34017916 <sbrk_aligned+0x12>
34017910:	f001 fb66 	bl	34018fe0 <_sbrk_r>
34017914:	6030      	str	r0, [r6, #0]
34017916:	4621      	mov	r1, r4
34017918:	4628      	mov	r0, r5
3401791a:	f001 fb61 	bl	34018fe0 <_sbrk_r>
3401791e:	1c43      	adds	r3, r0, #1
34017920:	d103      	bne.n	3401792a <sbrk_aligned+0x26>
34017922:	f04f 34ff 	mov.w	r4, #4294967295
34017926:	4620      	mov	r0, r4
34017928:	bd70      	pop	{r4, r5, r6, pc}
3401792a:	1cc4      	adds	r4, r0, #3
3401792c:	f024 0403 	bic.w	r4, r4, #3
34017930:	42a0      	cmp	r0, r4
34017932:	d0f8      	beq.n	34017926 <sbrk_aligned+0x22>
34017934:	1a21      	subs	r1, r4, r0
34017936:	4628      	mov	r0, r5
34017938:	f001 fb52 	bl	34018fe0 <_sbrk_r>
3401793c:	3001      	adds	r0, #1
3401793e:	d1f2      	bne.n	34017926 <sbrk_aligned+0x22>
34017940:	e7ef      	b.n	34017922 <sbrk_aligned+0x1e>
34017942:	bf00      	nop
34017944:	340445c8 	.word	0x340445c8

34017948 <_malloc_r>:
34017948:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401794c:	1ccd      	adds	r5, r1, #3
3401794e:	4606      	mov	r6, r0
34017950:	f025 0503 	bic.w	r5, r5, #3
34017954:	3508      	adds	r5, #8
34017956:	2d0c      	cmp	r5, #12
34017958:	bf38      	it	cc
3401795a:	250c      	movcc	r5, #12
3401795c:	2d00      	cmp	r5, #0
3401795e:	db01      	blt.n	34017964 <_malloc_r+0x1c>
34017960:	42a9      	cmp	r1, r5
34017962:	d904      	bls.n	3401796e <_malloc_r+0x26>
34017964:	230c      	movs	r3, #12
34017966:	6033      	str	r3, [r6, #0]
34017968:	2000      	movs	r0, #0
3401796a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401796e:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 34017a44 <_malloc_r+0xfc>
34017972:	f000 f869 	bl	34017a48 <__malloc_lock>
34017976:	f8d8 3000 	ldr.w	r3, [r8]
3401797a:	461c      	mov	r4, r3
3401797c:	bb44      	cbnz	r4, 340179d0 <_malloc_r+0x88>
3401797e:	4629      	mov	r1, r5
34017980:	4630      	mov	r0, r6
34017982:	f7ff ffbf 	bl	34017904 <sbrk_aligned>
34017986:	1c43      	adds	r3, r0, #1
34017988:	4604      	mov	r4, r0
3401798a:	d158      	bne.n	34017a3e <_malloc_r+0xf6>
3401798c:	f8d8 4000 	ldr.w	r4, [r8]
34017990:	4627      	mov	r7, r4
34017992:	2f00      	cmp	r7, #0
34017994:	d143      	bne.n	34017a1e <_malloc_r+0xd6>
34017996:	2c00      	cmp	r4, #0
34017998:	d04b      	beq.n	34017a32 <_malloc_r+0xea>
3401799a:	6823      	ldr	r3, [r4, #0]
3401799c:	4639      	mov	r1, r7
3401799e:	4630      	mov	r0, r6
340179a0:	eb04 0903 	add.w	r9, r4, r3
340179a4:	f001 fb1c 	bl	34018fe0 <_sbrk_r>
340179a8:	4581      	cmp	r9, r0
340179aa:	d142      	bne.n	34017a32 <_malloc_r+0xea>
340179ac:	6821      	ldr	r1, [r4, #0]
340179ae:	4630      	mov	r0, r6
340179b0:	1a6d      	subs	r5, r5, r1
340179b2:	4629      	mov	r1, r5
340179b4:	f7ff ffa6 	bl	34017904 <sbrk_aligned>
340179b8:	3001      	adds	r0, #1
340179ba:	d03a      	beq.n	34017a32 <_malloc_r+0xea>
340179bc:	6823      	ldr	r3, [r4, #0]
340179be:	442b      	add	r3, r5
340179c0:	6023      	str	r3, [r4, #0]
340179c2:	f8d8 3000 	ldr.w	r3, [r8]
340179c6:	685a      	ldr	r2, [r3, #4]
340179c8:	bb62      	cbnz	r2, 34017a24 <_malloc_r+0xdc>
340179ca:	f8c8 7000 	str.w	r7, [r8]
340179ce:	e00f      	b.n	340179f0 <_malloc_r+0xa8>
340179d0:	6822      	ldr	r2, [r4, #0]
340179d2:	1b52      	subs	r2, r2, r5
340179d4:	d420      	bmi.n	34017a18 <_malloc_r+0xd0>
340179d6:	2a0b      	cmp	r2, #11
340179d8:	d917      	bls.n	34017a0a <_malloc_r+0xc2>
340179da:	1961      	adds	r1, r4, r5
340179dc:	42a3      	cmp	r3, r4
340179de:	6025      	str	r5, [r4, #0]
340179e0:	bf18      	it	ne
340179e2:	6059      	strne	r1, [r3, #4]
340179e4:	6863      	ldr	r3, [r4, #4]
340179e6:	bf08      	it	eq
340179e8:	f8c8 1000 	streq.w	r1, [r8]
340179ec:	5162      	str	r2, [r4, r5]
340179ee:	604b      	str	r3, [r1, #4]
340179f0:	4630      	mov	r0, r6
340179f2:	f000 f82f 	bl	34017a54 <__malloc_unlock>
340179f6:	f104 000b 	add.w	r0, r4, #11
340179fa:	1d23      	adds	r3, r4, #4
340179fc:	f020 0007 	bic.w	r0, r0, #7
34017a00:	1ac2      	subs	r2, r0, r3
34017a02:	bf1c      	itt	ne
34017a04:	1a1b      	subne	r3, r3, r0
34017a06:	50a3      	strne	r3, [r4, r2]
34017a08:	e7af      	b.n	3401796a <_malloc_r+0x22>
34017a0a:	6862      	ldr	r2, [r4, #4]
34017a0c:	42a3      	cmp	r3, r4
34017a0e:	bf0c      	ite	eq
34017a10:	f8c8 2000 	streq.w	r2, [r8]
34017a14:	605a      	strne	r2, [r3, #4]
34017a16:	e7eb      	b.n	340179f0 <_malloc_r+0xa8>
34017a18:	4623      	mov	r3, r4
34017a1a:	6864      	ldr	r4, [r4, #4]
34017a1c:	e7ae      	b.n	3401797c <_malloc_r+0x34>
34017a1e:	463c      	mov	r4, r7
34017a20:	687f      	ldr	r7, [r7, #4]
34017a22:	e7b6      	b.n	34017992 <_malloc_r+0x4a>
34017a24:	461a      	mov	r2, r3
34017a26:	685b      	ldr	r3, [r3, #4]
34017a28:	42a3      	cmp	r3, r4
34017a2a:	d1fb      	bne.n	34017a24 <_malloc_r+0xdc>
34017a2c:	2300      	movs	r3, #0
34017a2e:	6053      	str	r3, [r2, #4]
34017a30:	e7de      	b.n	340179f0 <_malloc_r+0xa8>
34017a32:	230c      	movs	r3, #12
34017a34:	4630      	mov	r0, r6
34017a36:	6033      	str	r3, [r6, #0]
34017a38:	f000 f80c 	bl	34017a54 <__malloc_unlock>
34017a3c:	e794      	b.n	34017968 <_malloc_r+0x20>
34017a3e:	6005      	str	r5, [r0, #0]
34017a40:	e7d6      	b.n	340179f0 <_malloc_r+0xa8>
34017a42:	bf00      	nop
34017a44:	340445cc 	.word	0x340445cc

34017a48 <__malloc_lock>:
34017a48:	4801      	ldr	r0, [pc, #4]	@ (34017a50 <__malloc_lock+0x8>)
34017a4a:	f001 bb16 	b.w	3401907a <__retarget_lock_acquire_recursive>
34017a4e:	bf00      	nop
34017a50:	34044710 	.word	0x34044710

34017a54 <__malloc_unlock>:
34017a54:	4801      	ldr	r0, [pc, #4]	@ (34017a5c <__malloc_unlock+0x8>)
34017a56:	f001 bb11 	b.w	3401907c <__retarget_lock_release_recursive>
34017a5a:	bf00      	nop
34017a5c:	34044710 	.word	0x34044710

34017a60 <_realloc_r>:
34017a60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34017a64:	4607      	mov	r7, r0
34017a66:	4614      	mov	r4, r2
34017a68:	460d      	mov	r5, r1
34017a6a:	b921      	cbnz	r1, 34017a76 <_realloc_r+0x16>
34017a6c:	4611      	mov	r1, r2
34017a6e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34017a72:	f7ff bf69 	b.w	34017948 <_malloc_r>
34017a76:	b92a      	cbnz	r2, 34017a84 <_realloc_r+0x24>
34017a78:	4625      	mov	r5, r4
34017a7a:	f002 f917 	bl	34019cac <_free_r>
34017a7e:	4628      	mov	r0, r5
34017a80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34017a84:	f002 fcde 	bl	3401a444 <_malloc_usable_size_r>
34017a88:	4284      	cmp	r4, r0
34017a8a:	4606      	mov	r6, r0
34017a8c:	d802      	bhi.n	34017a94 <_realloc_r+0x34>
34017a8e:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
34017a92:	d8f4      	bhi.n	34017a7e <_realloc_r+0x1e>
34017a94:	4621      	mov	r1, r4
34017a96:	4638      	mov	r0, r7
34017a98:	f7ff ff56 	bl	34017948 <_malloc_r>
34017a9c:	4680      	mov	r8, r0
34017a9e:	b908      	cbnz	r0, 34017aa4 <_realloc_r+0x44>
34017aa0:	4645      	mov	r5, r8
34017aa2:	e7ec      	b.n	34017a7e <_realloc_r+0x1e>
34017aa4:	42b4      	cmp	r4, r6
34017aa6:	4622      	mov	r2, r4
34017aa8:	4629      	mov	r1, r5
34017aaa:	bf28      	it	cs
34017aac:	4632      	movcs	r2, r6
34017aae:	f001 fafc 	bl	340190aa <memcpy>
34017ab2:	4629      	mov	r1, r5
34017ab4:	4638      	mov	r0, r7
34017ab6:	f002 f8f9 	bl	34019cac <_free_r>
34017aba:	e7f1      	b.n	34017aa0 <_realloc_r+0x40>

34017abc <swapfunc>:
34017abc:	2b02      	cmp	r3, #2
34017abe:	b510      	push	{r4, lr}
34017ac0:	d00a      	beq.n	34017ad8 <swapfunc+0x1c>
34017ac2:	0892      	lsrs	r2, r2, #2
34017ac4:	3a01      	subs	r2, #1
34017ac6:	6803      	ldr	r3, [r0, #0]
34017ac8:	680c      	ldr	r4, [r1, #0]
34017aca:	2a00      	cmp	r2, #0
34017acc:	f840 4b04 	str.w	r4, [r0], #4
34017ad0:	f841 3b04 	str.w	r3, [r1], #4
34017ad4:	dcf6      	bgt.n	34017ac4 <swapfunc+0x8>
34017ad6:	bd10      	pop	{r4, pc}
34017ad8:	4402      	add	r2, r0
34017ada:	7803      	ldrb	r3, [r0, #0]
34017adc:	780c      	ldrb	r4, [r1, #0]
34017ade:	f800 4b01 	strb.w	r4, [r0], #1
34017ae2:	f801 3b01 	strb.w	r3, [r1], #1
34017ae6:	1a13      	subs	r3, r2, r0
34017ae8:	2b00      	cmp	r3, #0
34017aea:	dcf6      	bgt.n	34017ada <swapfunc+0x1e>
34017aec:	e7f3      	b.n	34017ad6 <swapfunc+0x1a>

34017aee <med3.constprop.0>:
34017aee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34017af0:	460f      	mov	r7, r1
34017af2:	4616      	mov	r6, r2
34017af4:	4604      	mov	r4, r0
34017af6:	461d      	mov	r5, r3
34017af8:	4798      	blx	r3
34017afa:	2800      	cmp	r0, #0
34017afc:	4631      	mov	r1, r6
34017afe:	4638      	mov	r0, r7
34017b00:	da0c      	bge.n	34017b1c <med3.constprop.0+0x2e>
34017b02:	47a8      	blx	r5
34017b04:	2800      	cmp	r0, #0
34017b06:	da02      	bge.n	34017b0e <med3.constprop.0+0x20>
34017b08:	463c      	mov	r4, r7
34017b0a:	4620      	mov	r0, r4
34017b0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34017b0e:	4631      	mov	r1, r6
34017b10:	4620      	mov	r0, r4
34017b12:	47a8      	blx	r5
34017b14:	2800      	cmp	r0, #0
34017b16:	daf8      	bge.n	34017b0a <med3.constprop.0+0x1c>
34017b18:	4634      	mov	r4, r6
34017b1a:	e7f6      	b.n	34017b0a <med3.constprop.0+0x1c>
34017b1c:	47a8      	blx	r5
34017b1e:	2800      	cmp	r0, #0
34017b20:	dcf2      	bgt.n	34017b08 <med3.constprop.0+0x1a>
34017b22:	4631      	mov	r1, r6
34017b24:	4620      	mov	r0, r4
34017b26:	47a8      	blx	r5
34017b28:	2800      	cmp	r0, #0
34017b2a:	daf5      	bge.n	34017b18 <med3.constprop.0+0x2a>
34017b2c:	e7ed      	b.n	34017b0a <med3.constprop.0+0x1c>

34017b2e <qsort>:
34017b2e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34017b32:	b095      	sub	sp, #84	@ 0x54
34017b34:	4607      	mov	r7, r0
34017b36:	4615      	mov	r5, r2
34017b38:	9300      	str	r3, [sp, #0]
34017b3a:	ea40 0302 	orr.w	r3, r0, r2
34017b3e:	079b      	lsls	r3, r3, #30
34017b40:	d119      	bne.n	34017b76 <qsort+0x48>
34017b42:	f1b2 0804 	subs.w	r8, r2, #4
34017b46:	bf18      	it	ne
34017b48:	f04f 0801 	movne.w	r8, #1
34017b4c:	2300      	movs	r3, #0
34017b4e:	9301      	str	r3, [sp, #4]
34017b50:	fb05 f401 	mul.w	r4, r5, r1
34017b54:	2906      	cmp	r1, #6
34017b56:	eb07 0b05 	add.w	fp, r7, r5
34017b5a:	eb07 0304 	add.w	r3, r7, r4
34017b5e:	9302      	str	r3, [sp, #8]
34017b60:	d828      	bhi.n	34017bb4 <qsort+0x86>
34017b62:	9b02      	ldr	r3, [sp, #8]
34017b64:	459b      	cmp	fp, r3
34017b66:	d310      	bcc.n	34017b8a <qsort+0x5c>
34017b68:	9b01      	ldr	r3, [sp, #4]
34017b6a:	2b00      	cmp	r3, #0
34017b6c:	f040 8117 	bne.w	34017d9e <qsort+0x270>
34017b70:	b015      	add	sp, #84	@ 0x54
34017b72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34017b76:	f04f 0802 	mov.w	r8, #2
34017b7a:	e7e7      	b.n	34017b4c <qsort+0x1e>
34017b7c:	4643      	mov	r3, r8
34017b7e:	462a      	mov	r2, r5
34017b80:	4631      	mov	r1, r6
34017b82:	4620      	mov	r0, r4
34017b84:	f7ff ff9a 	bl	34017abc <swapfunc>
34017b88:	e00f      	b.n	34017baa <qsort+0x7c>
34017b8a:	465c      	mov	r4, fp
34017b8c:	e00e      	b.n	34017bac <qsort+0x7e>
34017b8e:	1b66      	subs	r6, r4, r5
34017b90:	4621      	mov	r1, r4
34017b92:	9b00      	ldr	r3, [sp, #0]
34017b94:	4630      	mov	r0, r6
34017b96:	4798      	blx	r3
34017b98:	2800      	cmp	r0, #0
34017b9a:	dd09      	ble.n	34017bb0 <qsort+0x82>
34017b9c:	f1b8 0f00 	cmp.w	r8, #0
34017ba0:	d1ec      	bne.n	34017b7c <qsort+0x4e>
34017ba2:	6823      	ldr	r3, [r4, #0]
34017ba4:	6832      	ldr	r2, [r6, #0]
34017ba6:	6022      	str	r2, [r4, #0]
34017ba8:	6033      	str	r3, [r6, #0]
34017baa:	4634      	mov	r4, r6
34017bac:	42a7      	cmp	r7, r4
34017bae:	d3ee      	bcc.n	34017b8e <qsort+0x60>
34017bb0:	44ab      	add	fp, r5
34017bb2:	e7d6      	b.n	34017b62 <qsort+0x34>
34017bb4:	ea4f 0951 	mov.w	r9, r1, lsr #1
34017bb8:	1b64      	subs	r4, r4, r5
34017bba:	2907      	cmp	r1, #7
34017bbc:	fb05 7909 	mla	r9, r5, r9, r7
34017bc0:	443c      	add	r4, r7
34017bc2:	d021      	beq.n	34017c08 <qsort+0xda>
34017bc4:	2928      	cmp	r1, #40	@ 0x28
34017bc6:	d944      	bls.n	34017c52 <qsort+0x124>
34017bc8:	08ce      	lsrs	r6, r1, #3
34017bca:	9b00      	ldr	r3, [sp, #0]
34017bcc:	4638      	mov	r0, r7
34017bce:	436e      	muls	r6, r5
34017bd0:	eb07 0246 	add.w	r2, r7, r6, lsl #1
34017bd4:	19b9      	adds	r1, r7, r6
34017bd6:	f7ff ff8a 	bl	34017aee <med3.constprop.0>
34017bda:	4649      	mov	r1, r9
34017bdc:	eb09 0206 	add.w	r2, r9, r6
34017be0:	9b00      	ldr	r3, [sp, #0]
34017be2:	4682      	mov	sl, r0
34017be4:	1b88      	subs	r0, r1, r6
34017be6:	f7ff ff82 	bl	34017aee <med3.constprop.0>
34017bea:	4622      	mov	r2, r4
34017bec:	4681      	mov	r9, r0
34017bee:	9b00      	ldr	r3, [sp, #0]
34017bf0:	1ba1      	subs	r1, r4, r6
34017bf2:	eba4 0046 	sub.w	r0, r4, r6, lsl #1
34017bf6:	f7ff ff7a 	bl	34017aee <med3.constprop.0>
34017bfa:	4602      	mov	r2, r0
34017bfc:	4649      	mov	r1, r9
34017bfe:	9b00      	ldr	r3, [sp, #0]
34017c00:	4650      	mov	r0, sl
34017c02:	f7ff ff74 	bl	34017aee <med3.constprop.0>
34017c06:	4681      	mov	r9, r0
34017c08:	f1b8 0f00 	cmp.w	r8, #0
34017c0c:	d124      	bne.n	34017c58 <qsort+0x12a>
34017c0e:	683b      	ldr	r3, [r7, #0]
34017c10:	f8d9 2000 	ldr.w	r2, [r9]
34017c14:	603a      	str	r2, [r7, #0]
34017c16:	f8c9 3000 	str.w	r3, [r9]
34017c1a:	46d9      	mov	r9, fp
34017c1c:	46a2      	mov	sl, r4
34017c1e:	465e      	mov	r6, fp
34017c20:	2300      	movs	r3, #0
34017c22:	45a1      	cmp	r9, r4
34017c24:	d836      	bhi.n	34017c94 <qsort+0x166>
34017c26:	9303      	str	r3, [sp, #12]
34017c28:	4639      	mov	r1, r7
34017c2a:	9b00      	ldr	r3, [sp, #0]
34017c2c:	4648      	mov	r0, r9
34017c2e:	4798      	blx	r3
34017c30:	2800      	cmp	r0, #0
34017c32:	9b03      	ldr	r3, [sp, #12]
34017c34:	dc2c      	bgt.n	34017c90 <qsort+0x162>
34017c36:	d10a      	bne.n	34017c4e <qsort+0x120>
34017c38:	f1b8 0f00 	cmp.w	r8, #0
34017c3c:	d113      	bne.n	34017c66 <qsort+0x138>
34017c3e:	6833      	ldr	r3, [r6, #0]
34017c40:	f8d9 2000 	ldr.w	r2, [r9]
34017c44:	6032      	str	r2, [r6, #0]
34017c46:	f8c9 3000 	str.w	r3, [r9]
34017c4a:	442e      	add	r6, r5
34017c4c:	2301      	movs	r3, #1
34017c4e:	44a9      	add	r9, r5
34017c50:	e7e7      	b.n	34017c22 <qsort+0xf4>
34017c52:	4622      	mov	r2, r4
34017c54:	46ba      	mov	sl, r7
34017c56:	e7d1      	b.n	34017bfc <qsort+0xce>
34017c58:	4643      	mov	r3, r8
34017c5a:	462a      	mov	r2, r5
34017c5c:	4649      	mov	r1, r9
34017c5e:	4638      	mov	r0, r7
34017c60:	f7ff ff2c 	bl	34017abc <swapfunc>
34017c64:	e7d9      	b.n	34017c1a <qsort+0xec>
34017c66:	4643      	mov	r3, r8
34017c68:	462a      	mov	r2, r5
34017c6a:	4649      	mov	r1, r9
34017c6c:	4630      	mov	r0, r6
34017c6e:	f7ff ff25 	bl	34017abc <swapfunc>
34017c72:	e7ea      	b.n	34017c4a <qsort+0x11c>
34017c74:	d10b      	bne.n	34017c8e <qsort+0x160>
34017c76:	f1b8 0f00 	cmp.w	r8, #0
34017c7a:	d113      	bne.n	34017ca4 <qsort+0x176>
34017c7c:	6823      	ldr	r3, [r4, #0]
34017c7e:	f8da 2000 	ldr.w	r2, [sl]
34017c82:	6022      	str	r2, [r4, #0]
34017c84:	f8ca 3000 	str.w	r3, [sl]
34017c88:	ebaa 0a05 	sub.w	sl, sl, r5
34017c8c:	2301      	movs	r3, #1
34017c8e:	1b64      	subs	r4, r4, r5
34017c90:	45a1      	cmp	r9, r4
34017c92:	d90e      	bls.n	34017cb2 <qsort+0x184>
34017c94:	2b00      	cmp	r3, #0
34017c96:	d140      	bne.n	34017d1a <qsort+0x1ec>
34017c98:	9b02      	ldr	r3, [sp, #8]
34017c9a:	459b      	cmp	fp, r3
34017c9c:	f4bf af64 	bcs.w	34017b68 <qsort+0x3a>
34017ca0:	465c      	mov	r4, fp
34017ca2:	e036      	b.n	34017d12 <qsort+0x1e4>
34017ca4:	4643      	mov	r3, r8
34017ca6:	462a      	mov	r2, r5
34017ca8:	4651      	mov	r1, sl
34017caa:	4620      	mov	r0, r4
34017cac:	f7ff ff06 	bl	34017abc <swapfunc>
34017cb0:	e7ea      	b.n	34017c88 <qsort+0x15a>
34017cb2:	9303      	str	r3, [sp, #12]
34017cb4:	4639      	mov	r1, r7
34017cb6:	9b00      	ldr	r3, [sp, #0]
34017cb8:	4620      	mov	r0, r4
34017cba:	4798      	blx	r3
34017cbc:	2800      	cmp	r0, #0
34017cbe:	9b03      	ldr	r3, [sp, #12]
34017cc0:	dad8      	bge.n	34017c74 <qsort+0x146>
34017cc2:	f1b8 0f00 	cmp.w	r8, #0
34017cc6:	d107      	bne.n	34017cd8 <qsort+0x1aa>
34017cc8:	f8d9 3000 	ldr.w	r3, [r9]
34017ccc:	6822      	ldr	r2, [r4, #0]
34017cce:	f8c9 2000 	str.w	r2, [r9]
34017cd2:	6023      	str	r3, [r4, #0]
34017cd4:	1b64      	subs	r4, r4, r5
34017cd6:	e7b9      	b.n	34017c4c <qsort+0x11e>
34017cd8:	4643      	mov	r3, r8
34017cda:	462a      	mov	r2, r5
34017cdc:	4621      	mov	r1, r4
34017cde:	4648      	mov	r0, r9
34017ce0:	f7ff feec 	bl	34017abc <swapfunc>
34017ce4:	e7f6      	b.n	34017cd4 <qsort+0x1a6>
34017ce6:	4643      	mov	r3, r8
34017ce8:	462a      	mov	r2, r5
34017cea:	4631      	mov	r1, r6
34017cec:	4620      	mov	r0, r4
34017cee:	f7ff fee5 	bl	34017abc <swapfunc>
34017cf2:	e00d      	b.n	34017d10 <qsort+0x1e2>
34017cf4:	1b66      	subs	r6, r4, r5
34017cf6:	4621      	mov	r1, r4
34017cf8:	9b00      	ldr	r3, [sp, #0]
34017cfa:	4630      	mov	r0, r6
34017cfc:	4798      	blx	r3
34017cfe:	2800      	cmp	r0, #0
34017d00:	dd09      	ble.n	34017d16 <qsort+0x1e8>
34017d02:	f1b8 0f00 	cmp.w	r8, #0
34017d06:	d1ee      	bne.n	34017ce6 <qsort+0x1b8>
34017d08:	6823      	ldr	r3, [r4, #0]
34017d0a:	6832      	ldr	r2, [r6, #0]
34017d0c:	6022      	str	r2, [r4, #0]
34017d0e:	6033      	str	r3, [r6, #0]
34017d10:	4634      	mov	r4, r6
34017d12:	42a7      	cmp	r7, r4
34017d14:	d3ee      	bcc.n	34017cf4 <qsort+0x1c6>
34017d16:	44ab      	add	fp, r5
34017d18:	e7be      	b.n	34017c98 <qsort+0x16a>
34017d1a:	eba9 0b06 	sub.w	fp, r9, r6
34017d1e:	1bf2      	subs	r2, r6, r7
34017d20:	455a      	cmp	r2, fp
34017d22:	bfa8      	it	ge
34017d24:	465a      	movge	r2, fp
34017d26:	b12a      	cbz	r2, 34017d34 <qsort+0x206>
34017d28:	4643      	mov	r3, r8
34017d2a:	eba9 0102 	sub.w	r1, r9, r2
34017d2e:	4638      	mov	r0, r7
34017d30:	f7ff fec4 	bl	34017abc <swapfunc>
34017d34:	9b02      	ldr	r3, [sp, #8]
34017d36:	ebaa 0404 	sub.w	r4, sl, r4
34017d3a:	eba3 020a 	sub.w	r2, r3, sl
34017d3e:	1b52      	subs	r2, r2, r5
34017d40:	42a2      	cmp	r2, r4
34017d42:	bf28      	it	cs
34017d44:	4622      	movcs	r2, r4
34017d46:	b12a      	cbz	r2, 34017d54 <qsort+0x226>
34017d48:	9902      	ldr	r1, [sp, #8]
34017d4a:	4643      	mov	r3, r8
34017d4c:	4648      	mov	r0, r9
34017d4e:	1a89      	subs	r1, r1, r2
34017d50:	f7ff feb4 	bl	34017abc <swapfunc>
34017d54:	9b02      	ldr	r3, [sp, #8]
34017d56:	455c      	cmp	r4, fp
34017d58:	eba3 0604 	sub.w	r6, r3, r4
34017d5c:	d805      	bhi.n	34017d6a <qsort+0x23c>
34017d5e:	4623      	mov	r3, r4
34017d60:	465c      	mov	r4, fp
34017d62:	469b      	mov	fp, r3
34017d64:	4633      	mov	r3, r6
34017d66:	463e      	mov	r6, r7
34017d68:	461f      	mov	r7, r3
34017d6a:	45ab      	cmp	fp, r5
34017d6c:	d920      	bls.n	34017db0 <qsort+0x282>
34017d6e:	9b01      	ldr	r3, [sp, #4]
34017d70:	2b07      	cmp	r3, #7
34017d72:	fbbb f1f5 	udiv	r1, fp, r5
34017d76:	d80b      	bhi.n	34017d90 <qsort+0x262>
34017d78:	aa14      	add	r2, sp, #80	@ 0x50
34017d7a:	fbb4 f4f5 	udiv	r4, r4, r5
34017d7e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34017d82:	f843 6c40 	str.w	r6, [r3, #-64]
34017d86:	f843 4c3c 	str.w	r4, [r3, #-60]
34017d8a:	9b01      	ldr	r3, [sp, #4]
34017d8c:	3301      	adds	r3, #1
34017d8e:	e6de      	b.n	34017b4e <qsort+0x20>
34017d90:	9b00      	ldr	r3, [sp, #0]
34017d92:	462a      	mov	r2, r5
34017d94:	4638      	mov	r0, r7
34017d96:	f7ff feca 	bl	34017b2e <qsort>
34017d9a:	42ac      	cmp	r4, r5
34017d9c:	d80b      	bhi.n	34017db6 <qsort+0x288>
34017d9e:	9b01      	ldr	r3, [sp, #4]
34017da0:	aa14      	add	r2, sp, #80	@ 0x50
34017da2:	3b01      	subs	r3, #1
34017da4:	9301      	str	r3, [sp, #4]
34017da6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34017daa:	e953 7110 	ldrd	r7, r1, [r3, #-64]	@ 0x40
34017dae:	e6cf      	b.n	34017b50 <qsort+0x22>
34017db0:	42ac      	cmp	r4, r5
34017db2:	f67f aed9 	bls.w	34017b68 <qsort+0x3a>
34017db6:	4637      	mov	r7, r6
34017db8:	fbb4 f1f5 	udiv	r1, r4, r5
34017dbc:	e6c8      	b.n	34017b50 <qsort+0x22>

34017dbe <__cvt>:
34017dbe:	b5f0      	push	{r4, r5, r6, r7, lr}
34017dc0:	ed2d 8b02 	vpush	{d8}
34017dc4:	eeb0 8b40 	vmov.f64	d8, d0
34017dc8:	b085      	sub	sp, #20
34017dca:	4617      	mov	r7, r2
34017dcc:	460c      	mov	r4, r1
34017dce:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
34017dd0:	ee18 2a90 	vmov	r2, s17
34017dd4:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
34017dd6:	f025 0520 	bic.w	r5, r5, #32
34017dda:	2a00      	cmp	r2, #0
34017ddc:	bfb6      	itet	lt
34017dde:	222d      	movlt	r2, #45	@ 0x2d
34017de0:	2200      	movge	r2, #0
34017de2:	eeb1 8b40 	vneglt.f64	d8, d0
34017de6:	2d46      	cmp	r5, #70	@ 0x46
34017de8:	701a      	strb	r2, [r3, #0]
34017dea:	d004      	beq.n	34017df6 <__cvt+0x38>
34017dec:	2d45      	cmp	r5, #69	@ 0x45
34017dee:	d100      	bne.n	34017df2 <__cvt+0x34>
34017df0:	3401      	adds	r4, #1
34017df2:	2102      	movs	r1, #2
34017df4:	e000      	b.n	34017df8 <__cvt+0x3a>
34017df6:	2103      	movs	r1, #3
34017df8:	ab03      	add	r3, sp, #12
34017dfa:	eeb0 0b48 	vmov.f64	d0, d8
34017dfe:	4622      	mov	r2, r4
34017e00:	9301      	str	r3, [sp, #4]
34017e02:	ab02      	add	r3, sp, #8
34017e04:	9300      	str	r3, [sp, #0]
34017e06:	4633      	mov	r3, r6
34017e08:	f001 f9f2 	bl	340191f0 <_dtoa_r>
34017e0c:	2d47      	cmp	r5, #71	@ 0x47
34017e0e:	d114      	bne.n	34017e3a <__cvt+0x7c>
34017e10:	07fb      	lsls	r3, r7, #31
34017e12:	d50a      	bpl.n	34017e2a <__cvt+0x6c>
34017e14:	1902      	adds	r2, r0, r4
34017e16:	eeb5 8b40 	vcmp.f64	d8, #0.0
34017e1a:	2130      	movs	r1, #48	@ 0x30
34017e1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017e20:	bf08      	it	eq
34017e22:	9203      	streq	r2, [sp, #12]
34017e24:	9b03      	ldr	r3, [sp, #12]
34017e26:	4293      	cmp	r3, r2
34017e28:	d319      	bcc.n	34017e5e <__cvt+0xa0>
34017e2a:	9b03      	ldr	r3, [sp, #12]
34017e2c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
34017e2e:	1a1b      	subs	r3, r3, r0
34017e30:	6013      	str	r3, [r2, #0]
34017e32:	b005      	add	sp, #20
34017e34:	ecbd 8b02 	vpop	{d8}
34017e38:	bdf0      	pop	{r4, r5, r6, r7, pc}
34017e3a:	2d46      	cmp	r5, #70	@ 0x46
34017e3c:	eb00 0204 	add.w	r2, r0, r4
34017e40:	d1e9      	bne.n	34017e16 <__cvt+0x58>
34017e42:	7803      	ldrb	r3, [r0, #0]
34017e44:	2b30      	cmp	r3, #48	@ 0x30
34017e46:	d107      	bne.n	34017e58 <__cvt+0x9a>
34017e48:	eeb5 8b40 	vcmp.f64	d8, #0.0
34017e4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017e50:	bf1c      	itt	ne
34017e52:	f1c4 0401 	rsbne	r4, r4, #1
34017e56:	6034      	strne	r4, [r6, #0]
34017e58:	6833      	ldr	r3, [r6, #0]
34017e5a:	441a      	add	r2, r3
34017e5c:	e7db      	b.n	34017e16 <__cvt+0x58>
34017e5e:	1c5c      	adds	r4, r3, #1
34017e60:	9403      	str	r4, [sp, #12]
34017e62:	7019      	strb	r1, [r3, #0]
34017e64:	e7de      	b.n	34017e24 <__cvt+0x66>

34017e66 <__exponent>:
34017e66:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34017e68:	2900      	cmp	r1, #0
34017e6a:	7002      	strb	r2, [r0, #0]
34017e6c:	bfba      	itte	lt
34017e6e:	4249      	neglt	r1, r1
34017e70:	232d      	movlt	r3, #45	@ 0x2d
34017e72:	232b      	movge	r3, #43	@ 0x2b
34017e74:	2909      	cmp	r1, #9
34017e76:	7043      	strb	r3, [r0, #1]
34017e78:	dd28      	ble.n	34017ecc <__exponent+0x66>
34017e7a:	f10d 0307 	add.w	r3, sp, #7
34017e7e:	270a      	movs	r7, #10
34017e80:	461d      	mov	r5, r3
34017e82:	461a      	mov	r2, r3
34017e84:	3b01      	subs	r3, #1
34017e86:	fbb1 f6f7 	udiv	r6, r1, r7
34017e8a:	fb07 1416 	mls	r4, r7, r6, r1
34017e8e:	3430      	adds	r4, #48	@ 0x30
34017e90:	f802 4c01 	strb.w	r4, [r2, #-1]
34017e94:	460c      	mov	r4, r1
34017e96:	4631      	mov	r1, r6
34017e98:	2c63      	cmp	r4, #99	@ 0x63
34017e9a:	dcf2      	bgt.n	34017e82 <__exponent+0x1c>
34017e9c:	3130      	adds	r1, #48	@ 0x30
34017e9e:	1e94      	subs	r4, r2, #2
34017ea0:	f803 1c01 	strb.w	r1, [r3, #-1]
34017ea4:	1c41      	adds	r1, r0, #1
34017ea6:	4623      	mov	r3, r4
34017ea8:	42ab      	cmp	r3, r5
34017eaa:	d30a      	bcc.n	34017ec2 <__exponent+0x5c>
34017eac:	f10d 0309 	add.w	r3, sp, #9
34017eb0:	1a9b      	subs	r3, r3, r2
34017eb2:	42ac      	cmp	r4, r5
34017eb4:	bf88      	it	hi
34017eb6:	2300      	movhi	r3, #0
34017eb8:	3302      	adds	r3, #2
34017eba:	4403      	add	r3, r0
34017ebc:	1a18      	subs	r0, r3, r0
34017ebe:	b003      	add	sp, #12
34017ec0:	bdf0      	pop	{r4, r5, r6, r7, pc}
34017ec2:	f813 6b01 	ldrb.w	r6, [r3], #1
34017ec6:	f801 6f01 	strb.w	r6, [r1, #1]!
34017eca:	e7ed      	b.n	34017ea8 <__exponent+0x42>
34017ecc:	2330      	movs	r3, #48	@ 0x30
34017ece:	3130      	adds	r1, #48	@ 0x30
34017ed0:	7083      	strb	r3, [r0, #2]
34017ed2:	1d03      	adds	r3, r0, #4
34017ed4:	70c1      	strb	r1, [r0, #3]
34017ed6:	e7f1      	b.n	34017ebc <__exponent+0x56>

34017ed8 <_printf_float>:
34017ed8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34017edc:	b08d      	sub	sp, #52	@ 0x34
34017ede:	460c      	mov	r4, r1
34017ee0:	4616      	mov	r6, r2
34017ee2:	461f      	mov	r7, r3
34017ee4:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
34017ee8:	4605      	mov	r5, r0
34017eea:	f001 f841 	bl	34018f70 <_localeconv_r>
34017eee:	f8d0 b000 	ldr.w	fp, [r0]
34017ef2:	4658      	mov	r0, fp
34017ef4:	f7e9 fb1a 	bl	3400152c <strlen>
34017ef8:	2300      	movs	r3, #0
34017efa:	f894 9018 	ldrb.w	r9, [r4, #24]
34017efe:	930a      	str	r3, [sp, #40]	@ 0x28
34017f00:	f8d8 3000 	ldr.w	r3, [r8]
34017f04:	6822      	ldr	r2, [r4, #0]
34017f06:	3307      	adds	r3, #7
34017f08:	9005      	str	r0, [sp, #20]
34017f0a:	f023 0307 	bic.w	r3, r3, #7
34017f0e:	f103 0108 	add.w	r1, r3, #8
34017f12:	f8c8 1000 	str.w	r1, [r8]
34017f16:	ed93 0b00 	vldr	d0, [r3]
34017f1a:	ed9f 6b97 	vldr	d6, [pc, #604]	@ 34018178 <_printf_float+0x2a0>
34017f1e:	eeb0 7bc0 	vabs.f64	d7, d0
34017f22:	ed84 0b12 	vstr	d0, [r4, #72]	@ 0x48
34017f26:	eeb4 7b46 	vcmp.f64	d7, d6
34017f2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017f2e:	dd24      	ble.n	34017f7a <_printf_float+0xa2>
34017f30:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34017f34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017f38:	d502      	bpl.n	34017f40 <_printf_float+0x68>
34017f3a:	232d      	movs	r3, #45	@ 0x2d
34017f3c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34017f40:	498f      	ldr	r1, [pc, #572]	@ (34018180 <_printf_float+0x2a8>)
34017f42:	4b90      	ldr	r3, [pc, #576]	@ (34018184 <_printf_float+0x2ac>)
34017f44:	f1b9 0f47 	cmp.w	r9, #71	@ 0x47
34017f48:	bf8c      	ite	hi
34017f4a:	4688      	movhi	r8, r1
34017f4c:	4698      	movls	r8, r3
34017f4e:	f022 0204 	bic.w	r2, r2, #4
34017f52:	2303      	movs	r3, #3
34017f54:	f04f 0a00 	mov.w	sl, #0
34017f58:	6022      	str	r2, [r4, #0]
34017f5a:	6123      	str	r3, [r4, #16]
34017f5c:	4633      	mov	r3, r6
34017f5e:	aa0b      	add	r2, sp, #44	@ 0x2c
34017f60:	4621      	mov	r1, r4
34017f62:	4628      	mov	r0, r5
34017f64:	9700      	str	r7, [sp, #0]
34017f66:	f000 f9d1 	bl	3401830c <_printf_common>
34017f6a:	3001      	adds	r0, #1
34017f6c:	f040 8089 	bne.w	34018082 <_printf_float+0x1aa>
34017f70:	f04f 30ff 	mov.w	r0, #4294967295
34017f74:	b00d      	add	sp, #52	@ 0x34
34017f76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34017f7a:	eeb4 0b40 	vcmp.f64	d0, d0
34017f7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017f82:	d709      	bvc.n	34017f98 <_printf_float+0xc0>
34017f84:	ee10 3a90 	vmov	r3, s1
34017f88:	497f      	ldr	r1, [pc, #508]	@ (34018188 <_printf_float+0x2b0>)
34017f8a:	2b00      	cmp	r3, #0
34017f8c:	bfbc      	itt	lt
34017f8e:	232d      	movlt	r3, #45	@ 0x2d
34017f90:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
34017f94:	4b7d      	ldr	r3, [pc, #500]	@ (3401818c <_printf_float+0x2b4>)
34017f96:	e7d5      	b.n	34017f44 <_printf_float+0x6c>
34017f98:	6863      	ldr	r3, [r4, #4]
34017f9a:	f009 0adf 	and.w	sl, r9, #223	@ 0xdf
34017f9e:	1c59      	adds	r1, r3, #1
34017fa0:	d139      	bne.n	34018016 <_printf_float+0x13e>
34017fa2:	2306      	movs	r3, #6
34017fa4:	6063      	str	r3, [r4, #4]
34017fa6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
34017faa:	2300      	movs	r3, #0
34017fac:	4628      	mov	r0, r5
34017fae:	6022      	str	r2, [r4, #0]
34017fb0:	9303      	str	r3, [sp, #12]
34017fb2:	ab0a      	add	r3, sp, #40	@ 0x28
34017fb4:	e9cd 9301 	strd	r9, r3, [sp, #4]
34017fb8:	ab09      	add	r3, sp, #36	@ 0x24
34017fba:	9300      	str	r3, [sp, #0]
34017fbc:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
34017fc0:	6861      	ldr	r1, [r4, #4]
34017fc2:	f7ff fefc 	bl	34017dbe <__cvt>
34017fc6:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
34017fca:	4680      	mov	r8, r0
34017fcc:	9909      	ldr	r1, [sp, #36]	@ 0x24
34017fce:	d129      	bne.n	34018024 <_printf_float+0x14c>
34017fd0:	1cc8      	adds	r0, r1, #3
34017fd2:	db02      	blt.n	34017fda <_printf_float+0x102>
34017fd4:	6863      	ldr	r3, [r4, #4]
34017fd6:	4299      	cmp	r1, r3
34017fd8:	dd41      	ble.n	3401805e <_printf_float+0x186>
34017fda:	f1a9 0902 	sub.w	r9, r9, #2
34017fde:	fa5f f989 	uxtb.w	r9, r9
34017fe2:	3901      	subs	r1, #1
34017fe4:	464a      	mov	r2, r9
34017fe6:	f104 0050 	add.w	r0, r4, #80	@ 0x50
34017fea:	9109      	str	r1, [sp, #36]	@ 0x24
34017fec:	f7ff ff3b 	bl	34017e66 <__exponent>
34017ff0:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
34017ff2:	4682      	mov	sl, r0
34017ff4:	1813      	adds	r3, r2, r0
34017ff6:	2a01      	cmp	r2, #1
34017ff8:	6123      	str	r3, [r4, #16]
34017ffa:	dc02      	bgt.n	34018002 <_printf_float+0x12a>
34017ffc:	6822      	ldr	r2, [r4, #0]
34017ffe:	07d2      	lsls	r2, r2, #31
34018000:	d501      	bpl.n	34018006 <_printf_float+0x12e>
34018002:	3301      	adds	r3, #1
34018004:	6123      	str	r3, [r4, #16]
34018006:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
3401800a:	2b00      	cmp	r3, #0
3401800c:	d0a6      	beq.n	34017f5c <_printf_float+0x84>
3401800e:	232d      	movs	r3, #45	@ 0x2d
34018010:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34018014:	e7a2      	b.n	34017f5c <_printf_float+0x84>
34018016:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
3401801a:	d1c4      	bne.n	34017fa6 <_printf_float+0xce>
3401801c:	2b00      	cmp	r3, #0
3401801e:	d1c2      	bne.n	34017fa6 <_printf_float+0xce>
34018020:	2301      	movs	r3, #1
34018022:	e7bf      	b.n	34017fa4 <_printf_float+0xcc>
34018024:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
34018028:	d9db      	bls.n	34017fe2 <_printf_float+0x10a>
3401802a:	f1b9 0f66 	cmp.w	r9, #102	@ 0x66
3401802e:	d118      	bne.n	34018062 <_printf_float+0x18a>
34018030:	2900      	cmp	r1, #0
34018032:	6863      	ldr	r3, [r4, #4]
34018034:	dd0b      	ble.n	3401804e <_printf_float+0x176>
34018036:	6121      	str	r1, [r4, #16]
34018038:	b913      	cbnz	r3, 34018040 <_printf_float+0x168>
3401803a:	6822      	ldr	r2, [r4, #0]
3401803c:	07d0      	lsls	r0, r2, #31
3401803e:	d502      	bpl.n	34018046 <_printf_float+0x16e>
34018040:	3301      	adds	r3, #1
34018042:	440b      	add	r3, r1
34018044:	6123      	str	r3, [r4, #16]
34018046:	f04f 0a00 	mov.w	sl, #0
3401804a:	65a1      	str	r1, [r4, #88]	@ 0x58
3401804c:	e7db      	b.n	34018006 <_printf_float+0x12e>
3401804e:	b913      	cbnz	r3, 34018056 <_printf_float+0x17e>
34018050:	6822      	ldr	r2, [r4, #0]
34018052:	07d2      	lsls	r2, r2, #31
34018054:	d501      	bpl.n	3401805a <_printf_float+0x182>
34018056:	3302      	adds	r3, #2
34018058:	e7f4      	b.n	34018044 <_printf_float+0x16c>
3401805a:	2301      	movs	r3, #1
3401805c:	e7f2      	b.n	34018044 <_printf_float+0x16c>
3401805e:	f04f 0967 	mov.w	r9, #103	@ 0x67
34018062:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34018064:	4299      	cmp	r1, r3
34018066:	db05      	blt.n	34018074 <_printf_float+0x19c>
34018068:	6823      	ldr	r3, [r4, #0]
3401806a:	6121      	str	r1, [r4, #16]
3401806c:	07d8      	lsls	r0, r3, #31
3401806e:	d5ea      	bpl.n	34018046 <_printf_float+0x16e>
34018070:	1c4b      	adds	r3, r1, #1
34018072:	e7e7      	b.n	34018044 <_printf_float+0x16c>
34018074:	2900      	cmp	r1, #0
34018076:	bfd4      	ite	le
34018078:	f1c1 0202 	rsble	r2, r1, #2
3401807c:	2201      	movgt	r2, #1
3401807e:	4413      	add	r3, r2
34018080:	e7e0      	b.n	34018044 <_printf_float+0x16c>
34018082:	6823      	ldr	r3, [r4, #0]
34018084:	055a      	lsls	r2, r3, #21
34018086:	d407      	bmi.n	34018098 <_printf_float+0x1c0>
34018088:	6923      	ldr	r3, [r4, #16]
3401808a:	4642      	mov	r2, r8
3401808c:	4631      	mov	r1, r6
3401808e:	4628      	mov	r0, r5
34018090:	47b8      	blx	r7
34018092:	3001      	adds	r0, #1
34018094:	d12a      	bne.n	340180ec <_printf_float+0x214>
34018096:	e76b      	b.n	34017f70 <_printf_float+0x98>
34018098:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
3401809c:	f240 80e0 	bls.w	34018260 <_printf_float+0x388>
340180a0:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
340180a4:	eeb5 7b40 	vcmp.f64	d7, #0.0
340180a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340180ac:	d133      	bne.n	34018116 <_printf_float+0x23e>
340180ae:	2301      	movs	r3, #1
340180b0:	4a37      	ldr	r2, [pc, #220]	@ (34018190 <_printf_float+0x2b8>)
340180b2:	4631      	mov	r1, r6
340180b4:	4628      	mov	r0, r5
340180b6:	47b8      	blx	r7
340180b8:	3001      	adds	r0, #1
340180ba:	f43f af59 	beq.w	34017f70 <_printf_float+0x98>
340180be:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
340180c2:	4543      	cmp	r3, r8
340180c4:	db02      	blt.n	340180cc <_printf_float+0x1f4>
340180c6:	6823      	ldr	r3, [r4, #0]
340180c8:	07d8      	lsls	r0, r3, #31
340180ca:	d50f      	bpl.n	340180ec <_printf_float+0x214>
340180cc:	9b05      	ldr	r3, [sp, #20]
340180ce:	465a      	mov	r2, fp
340180d0:	4631      	mov	r1, r6
340180d2:	4628      	mov	r0, r5
340180d4:	47b8      	blx	r7
340180d6:	3001      	adds	r0, #1
340180d8:	f43f af4a 	beq.w	34017f70 <_printf_float+0x98>
340180dc:	f04f 0900 	mov.w	r9, #0
340180e0:	f108 38ff 	add.w	r8, r8, #4294967295
340180e4:	f104 0a1a 	add.w	sl, r4, #26
340180e8:	45c8      	cmp	r8, r9
340180ea:	dc09      	bgt.n	34018100 <_printf_float+0x228>
340180ec:	6823      	ldr	r3, [r4, #0]
340180ee:	079b      	lsls	r3, r3, #30
340180f0:	f100 8107 	bmi.w	34018302 <_printf_float+0x42a>
340180f4:	68e0      	ldr	r0, [r4, #12]
340180f6:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
340180f8:	4298      	cmp	r0, r3
340180fa:	bfb8      	it	lt
340180fc:	4618      	movlt	r0, r3
340180fe:	e739      	b.n	34017f74 <_printf_float+0x9c>
34018100:	2301      	movs	r3, #1
34018102:	4652      	mov	r2, sl
34018104:	4631      	mov	r1, r6
34018106:	4628      	mov	r0, r5
34018108:	47b8      	blx	r7
3401810a:	3001      	adds	r0, #1
3401810c:	f43f af30 	beq.w	34017f70 <_printf_float+0x98>
34018110:	f109 0901 	add.w	r9, r9, #1
34018114:	e7e8      	b.n	340180e8 <_printf_float+0x210>
34018116:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34018118:	2b00      	cmp	r3, #0
3401811a:	dc3b      	bgt.n	34018194 <_printf_float+0x2bc>
3401811c:	2301      	movs	r3, #1
3401811e:	4a1c      	ldr	r2, [pc, #112]	@ (34018190 <_printf_float+0x2b8>)
34018120:	4631      	mov	r1, r6
34018122:	4628      	mov	r0, r5
34018124:	47b8      	blx	r7
34018126:	3001      	adds	r0, #1
34018128:	f43f af22 	beq.w	34017f70 <_printf_float+0x98>
3401812c:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
34018130:	ea59 0303 	orrs.w	r3, r9, r3
34018134:	d102      	bne.n	3401813c <_printf_float+0x264>
34018136:	6823      	ldr	r3, [r4, #0]
34018138:	07d9      	lsls	r1, r3, #31
3401813a:	d5d7      	bpl.n	340180ec <_printf_float+0x214>
3401813c:	9b05      	ldr	r3, [sp, #20]
3401813e:	465a      	mov	r2, fp
34018140:	4631      	mov	r1, r6
34018142:	4628      	mov	r0, r5
34018144:	47b8      	blx	r7
34018146:	3001      	adds	r0, #1
34018148:	f43f af12 	beq.w	34017f70 <_printf_float+0x98>
3401814c:	f04f 0a00 	mov.w	sl, #0
34018150:	f104 0b1a 	add.w	fp, r4, #26
34018154:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34018156:	425b      	negs	r3, r3
34018158:	4553      	cmp	r3, sl
3401815a:	dc01      	bgt.n	34018160 <_printf_float+0x288>
3401815c:	464b      	mov	r3, r9
3401815e:	e794      	b.n	3401808a <_printf_float+0x1b2>
34018160:	2301      	movs	r3, #1
34018162:	465a      	mov	r2, fp
34018164:	4631      	mov	r1, r6
34018166:	4628      	mov	r0, r5
34018168:	47b8      	blx	r7
3401816a:	3001      	adds	r0, #1
3401816c:	f43f af00 	beq.w	34017f70 <_printf_float+0x98>
34018170:	f10a 0a01 	add.w	sl, sl, #1
34018174:	e7ee      	b.n	34018154 <_printf_float+0x27c>
34018176:	bf00      	nop
34018178:	ffffffff 	.word	0xffffffff
3401817c:	7fefffff 	.word	0x7fefffff
34018180:	3401df89 	.word	0x3401df89
34018184:	3401df85 	.word	0x3401df85
34018188:	3401df91 	.word	0x3401df91
3401818c:	3401df8d 	.word	0x3401df8d
34018190:	3401d1fc 	.word	0x3401d1fc
34018194:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34018196:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
3401819a:	4553      	cmp	r3, sl
3401819c:	bfa8      	it	ge
3401819e:	4653      	movge	r3, sl
340181a0:	2b00      	cmp	r3, #0
340181a2:	4699      	mov	r9, r3
340181a4:	dc37      	bgt.n	34018216 <_printf_float+0x33e>
340181a6:	2300      	movs	r3, #0
340181a8:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
340181ac:	f104 021a 	add.w	r2, r4, #26
340181b0:	9307      	str	r3, [sp, #28]
340181b2:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340181b4:	9907      	ldr	r1, [sp, #28]
340181b6:	9306      	str	r3, [sp, #24]
340181b8:	eba3 0309 	sub.w	r3, r3, r9
340181bc:	428b      	cmp	r3, r1
340181be:	dc31      	bgt.n	34018224 <_printf_float+0x34c>
340181c0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340181c2:	459a      	cmp	sl, r3
340181c4:	dc3b      	bgt.n	3401823e <_printf_float+0x366>
340181c6:	6823      	ldr	r3, [r4, #0]
340181c8:	07da      	lsls	r2, r3, #31
340181ca:	d438      	bmi.n	3401823e <_printf_float+0x366>
340181cc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340181ce:	ebaa 0903 	sub.w	r9, sl, r3
340181d2:	9b06      	ldr	r3, [sp, #24]
340181d4:	ebaa 0303 	sub.w	r3, sl, r3
340181d8:	4599      	cmp	r9, r3
340181da:	bfa8      	it	ge
340181dc:	4699      	movge	r9, r3
340181de:	f1b9 0f00 	cmp.w	r9, #0
340181e2:	dc34      	bgt.n	3401824e <_printf_float+0x376>
340181e4:	f04f 0800 	mov.w	r8, #0
340181e8:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
340181ec:	f104 0b1a 	add.w	fp, r4, #26
340181f0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340181f2:	ebaa 0303 	sub.w	r3, sl, r3
340181f6:	eba3 0309 	sub.w	r3, r3, r9
340181fa:	4543      	cmp	r3, r8
340181fc:	f77f af76 	ble.w	340180ec <_printf_float+0x214>
34018200:	2301      	movs	r3, #1
34018202:	465a      	mov	r2, fp
34018204:	4631      	mov	r1, r6
34018206:	4628      	mov	r0, r5
34018208:	47b8      	blx	r7
3401820a:	3001      	adds	r0, #1
3401820c:	f43f aeb0 	beq.w	34017f70 <_printf_float+0x98>
34018210:	f108 0801 	add.w	r8, r8, #1
34018214:	e7ec      	b.n	340181f0 <_printf_float+0x318>
34018216:	4642      	mov	r2, r8
34018218:	4631      	mov	r1, r6
3401821a:	4628      	mov	r0, r5
3401821c:	47b8      	blx	r7
3401821e:	3001      	adds	r0, #1
34018220:	d1c1      	bne.n	340181a6 <_printf_float+0x2ce>
34018222:	e6a5      	b.n	34017f70 <_printf_float+0x98>
34018224:	2301      	movs	r3, #1
34018226:	4631      	mov	r1, r6
34018228:	4628      	mov	r0, r5
3401822a:	9206      	str	r2, [sp, #24]
3401822c:	47b8      	blx	r7
3401822e:	3001      	adds	r0, #1
34018230:	f43f ae9e 	beq.w	34017f70 <_printf_float+0x98>
34018234:	9b07      	ldr	r3, [sp, #28]
34018236:	9a06      	ldr	r2, [sp, #24]
34018238:	3301      	adds	r3, #1
3401823a:	9307      	str	r3, [sp, #28]
3401823c:	e7b9      	b.n	340181b2 <_printf_float+0x2da>
3401823e:	9b05      	ldr	r3, [sp, #20]
34018240:	465a      	mov	r2, fp
34018242:	4631      	mov	r1, r6
34018244:	4628      	mov	r0, r5
34018246:	47b8      	blx	r7
34018248:	3001      	adds	r0, #1
3401824a:	d1bf      	bne.n	340181cc <_printf_float+0x2f4>
3401824c:	e690      	b.n	34017f70 <_printf_float+0x98>
3401824e:	9a06      	ldr	r2, [sp, #24]
34018250:	464b      	mov	r3, r9
34018252:	4631      	mov	r1, r6
34018254:	4628      	mov	r0, r5
34018256:	4442      	add	r2, r8
34018258:	47b8      	blx	r7
3401825a:	3001      	adds	r0, #1
3401825c:	d1c2      	bne.n	340181e4 <_printf_float+0x30c>
3401825e:	e687      	b.n	34017f70 <_printf_float+0x98>
34018260:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
34018264:	f1b9 0f01 	cmp.w	r9, #1
34018268:	dc01      	bgt.n	3401826e <_printf_float+0x396>
3401826a:	07db      	lsls	r3, r3, #31
3401826c:	d536      	bpl.n	340182dc <_printf_float+0x404>
3401826e:	2301      	movs	r3, #1
34018270:	4642      	mov	r2, r8
34018272:	4631      	mov	r1, r6
34018274:	4628      	mov	r0, r5
34018276:	47b8      	blx	r7
34018278:	3001      	adds	r0, #1
3401827a:	f43f ae79 	beq.w	34017f70 <_printf_float+0x98>
3401827e:	9b05      	ldr	r3, [sp, #20]
34018280:	465a      	mov	r2, fp
34018282:	4631      	mov	r1, r6
34018284:	4628      	mov	r0, r5
34018286:	47b8      	blx	r7
34018288:	3001      	adds	r0, #1
3401828a:	f43f ae71 	beq.w	34017f70 <_printf_float+0x98>
3401828e:	f109 39ff 	add.w	r9, r9, #4294967295
34018292:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
34018296:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401829a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401829e:	d018      	beq.n	340182d2 <_printf_float+0x3fa>
340182a0:	464b      	mov	r3, r9
340182a2:	f108 0201 	add.w	r2, r8, #1
340182a6:	4631      	mov	r1, r6
340182a8:	4628      	mov	r0, r5
340182aa:	47b8      	blx	r7
340182ac:	3001      	adds	r0, #1
340182ae:	d10c      	bne.n	340182ca <_printf_float+0x3f2>
340182b0:	e65e      	b.n	34017f70 <_printf_float+0x98>
340182b2:	2301      	movs	r3, #1
340182b4:	465a      	mov	r2, fp
340182b6:	4631      	mov	r1, r6
340182b8:	4628      	mov	r0, r5
340182ba:	47b8      	blx	r7
340182bc:	3001      	adds	r0, #1
340182be:	f43f ae57 	beq.w	34017f70 <_printf_float+0x98>
340182c2:	f108 0801 	add.w	r8, r8, #1
340182c6:	45c8      	cmp	r8, r9
340182c8:	dbf3      	blt.n	340182b2 <_printf_float+0x3da>
340182ca:	4653      	mov	r3, sl
340182cc:	f104 0250 	add.w	r2, r4, #80	@ 0x50
340182d0:	e6dc      	b.n	3401808c <_printf_float+0x1b4>
340182d2:	f04f 0800 	mov.w	r8, #0
340182d6:	f104 0b1a 	add.w	fp, r4, #26
340182da:	e7f4      	b.n	340182c6 <_printf_float+0x3ee>
340182dc:	2301      	movs	r3, #1
340182de:	4642      	mov	r2, r8
340182e0:	e7e1      	b.n	340182a6 <_printf_float+0x3ce>
340182e2:	2301      	movs	r3, #1
340182e4:	464a      	mov	r2, r9
340182e6:	4631      	mov	r1, r6
340182e8:	4628      	mov	r0, r5
340182ea:	47b8      	blx	r7
340182ec:	3001      	adds	r0, #1
340182ee:	f43f ae3f 	beq.w	34017f70 <_printf_float+0x98>
340182f2:	f108 0801 	add.w	r8, r8, #1
340182f6:	68e3      	ldr	r3, [r4, #12]
340182f8:	990b      	ldr	r1, [sp, #44]	@ 0x2c
340182fa:	1a5b      	subs	r3, r3, r1
340182fc:	4543      	cmp	r3, r8
340182fe:	dcf0      	bgt.n	340182e2 <_printf_float+0x40a>
34018300:	e6f8      	b.n	340180f4 <_printf_float+0x21c>
34018302:	f04f 0800 	mov.w	r8, #0
34018306:	f104 0919 	add.w	r9, r4, #25
3401830a:	e7f4      	b.n	340182f6 <_printf_float+0x41e>

3401830c <_printf_common>:
3401830c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34018310:	4616      	mov	r6, r2
34018312:	4698      	mov	r8, r3
34018314:	688a      	ldr	r2, [r1, #8]
34018316:	4607      	mov	r7, r0
34018318:	690b      	ldr	r3, [r1, #16]
3401831a:	460c      	mov	r4, r1
3401831c:	f8dd 9020 	ldr.w	r9, [sp, #32]
34018320:	4293      	cmp	r3, r2
34018322:	bfb8      	it	lt
34018324:	4613      	movlt	r3, r2
34018326:	6033      	str	r3, [r6, #0]
34018328:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
3401832c:	b10a      	cbz	r2, 34018332 <_printf_common+0x26>
3401832e:	3301      	adds	r3, #1
34018330:	6033      	str	r3, [r6, #0]
34018332:	6823      	ldr	r3, [r4, #0]
34018334:	0699      	lsls	r1, r3, #26
34018336:	bf42      	ittt	mi
34018338:	6833      	ldrmi	r3, [r6, #0]
3401833a:	3302      	addmi	r3, #2
3401833c:	6033      	strmi	r3, [r6, #0]
3401833e:	6825      	ldr	r5, [r4, #0]
34018340:	f015 0506 	ands.w	r5, r5, #6
34018344:	d106      	bne.n	34018354 <_printf_common+0x48>
34018346:	f104 0a19 	add.w	sl, r4, #25
3401834a:	68e3      	ldr	r3, [r4, #12]
3401834c:	6832      	ldr	r2, [r6, #0]
3401834e:	1a9b      	subs	r3, r3, r2
34018350:	42ab      	cmp	r3, r5
34018352:	dc2b      	bgt.n	340183ac <_printf_common+0xa0>
34018354:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
34018358:	6822      	ldr	r2, [r4, #0]
3401835a:	3b00      	subs	r3, #0
3401835c:	bf18      	it	ne
3401835e:	2301      	movne	r3, #1
34018360:	0692      	lsls	r2, r2, #26
34018362:	d430      	bmi.n	340183c6 <_printf_common+0xba>
34018364:	f104 0243 	add.w	r2, r4, #67	@ 0x43
34018368:	4641      	mov	r1, r8
3401836a:	4638      	mov	r0, r7
3401836c:	47c8      	blx	r9
3401836e:	3001      	adds	r0, #1
34018370:	d023      	beq.n	340183ba <_printf_common+0xae>
34018372:	6823      	ldr	r3, [r4, #0]
34018374:	341a      	adds	r4, #26
34018376:	f854 2c0a 	ldr.w	r2, [r4, #-10]
3401837a:	f003 0306 	and.w	r3, r3, #6
3401837e:	2b04      	cmp	r3, #4
34018380:	bf0a      	itet	eq
34018382:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
34018386:	2500      	movne	r5, #0
34018388:	6833      	ldreq	r3, [r6, #0]
3401838a:	f04f 0600 	mov.w	r6, #0
3401838e:	bf08      	it	eq
34018390:	1aed      	subeq	r5, r5, r3
34018392:	f854 3c12 	ldr.w	r3, [r4, #-18]
34018396:	bf08      	it	eq
34018398:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
3401839c:	4293      	cmp	r3, r2
3401839e:	bfc4      	itt	gt
340183a0:	1a9b      	subgt	r3, r3, r2
340183a2:	18ed      	addgt	r5, r5, r3
340183a4:	42b5      	cmp	r5, r6
340183a6:	d11a      	bne.n	340183de <_printf_common+0xd2>
340183a8:	2000      	movs	r0, #0
340183aa:	e008      	b.n	340183be <_printf_common+0xb2>
340183ac:	2301      	movs	r3, #1
340183ae:	4652      	mov	r2, sl
340183b0:	4641      	mov	r1, r8
340183b2:	4638      	mov	r0, r7
340183b4:	47c8      	blx	r9
340183b6:	3001      	adds	r0, #1
340183b8:	d103      	bne.n	340183c2 <_printf_common+0xb6>
340183ba:	f04f 30ff 	mov.w	r0, #4294967295
340183be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
340183c2:	3501      	adds	r5, #1
340183c4:	e7c1      	b.n	3401834a <_printf_common+0x3e>
340183c6:	18e1      	adds	r1, r4, r3
340183c8:	1c5a      	adds	r2, r3, #1
340183ca:	2030      	movs	r0, #48	@ 0x30
340183cc:	3302      	adds	r3, #2
340183ce:	4422      	add	r2, r4
340183d0:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
340183d4:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
340183d8:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
340183dc:	e7c2      	b.n	34018364 <_printf_common+0x58>
340183de:	2301      	movs	r3, #1
340183e0:	4622      	mov	r2, r4
340183e2:	4641      	mov	r1, r8
340183e4:	4638      	mov	r0, r7
340183e6:	47c8      	blx	r9
340183e8:	3001      	adds	r0, #1
340183ea:	d0e6      	beq.n	340183ba <_printf_common+0xae>
340183ec:	3601      	adds	r6, #1
340183ee:	e7d9      	b.n	340183a4 <_printf_common+0x98>

340183f0 <_printf_i>:
340183f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
340183f4:	7e0f      	ldrb	r7, [r1, #24]
340183f6:	4691      	mov	r9, r2
340183f8:	4680      	mov	r8, r0
340183fa:	460c      	mov	r4, r1
340183fc:	2f78      	cmp	r7, #120	@ 0x78
340183fe:	469a      	mov	sl, r3
34018400:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
34018402:	f101 0243 	add.w	r2, r1, #67	@ 0x43
34018406:	d807      	bhi.n	34018418 <_printf_i+0x28>
34018408:	2f62      	cmp	r7, #98	@ 0x62
3401840a:	d80a      	bhi.n	34018422 <_printf_i+0x32>
3401840c:	2f00      	cmp	r7, #0
3401840e:	f000 80d1 	beq.w	340185b4 <_printf_i+0x1c4>
34018412:	2f58      	cmp	r7, #88	@ 0x58
34018414:	f000 80b8 	beq.w	34018588 <_printf_i+0x198>
34018418:	f104 0642 	add.w	r6, r4, #66	@ 0x42
3401841c:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
34018420:	e03a      	b.n	34018498 <_printf_i+0xa8>
34018422:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
34018426:	2b15      	cmp	r3, #21
34018428:	d8f6      	bhi.n	34018418 <_printf_i+0x28>
3401842a:	a101      	add	r1, pc, #4	@ (adr r1, 34018430 <_printf_i+0x40>)
3401842c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
34018430:	34018489 	.word	0x34018489
34018434:	3401849d 	.word	0x3401849d
34018438:	34018419 	.word	0x34018419
3401843c:	34018419 	.word	0x34018419
34018440:	34018419 	.word	0x34018419
34018444:	34018419 	.word	0x34018419
34018448:	3401849d 	.word	0x3401849d
3401844c:	34018419 	.word	0x34018419
34018450:	34018419 	.word	0x34018419
34018454:	34018419 	.word	0x34018419
34018458:	34018419 	.word	0x34018419
3401845c:	3401859b 	.word	0x3401859b
34018460:	340184c7 	.word	0x340184c7
34018464:	34018555 	.word	0x34018555
34018468:	34018419 	.word	0x34018419
3401846c:	34018419 	.word	0x34018419
34018470:	340185bd 	.word	0x340185bd
34018474:	34018419 	.word	0x34018419
34018478:	340184c7 	.word	0x340184c7
3401847c:	34018419 	.word	0x34018419
34018480:	34018419 	.word	0x34018419
34018484:	3401855d 	.word	0x3401855d
34018488:	6833      	ldr	r3, [r6, #0]
3401848a:	1d1a      	adds	r2, r3, #4
3401848c:	681b      	ldr	r3, [r3, #0]
3401848e:	6032      	str	r2, [r6, #0]
34018490:	f104 0642 	add.w	r6, r4, #66	@ 0x42
34018494:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
34018498:	2301      	movs	r3, #1
3401849a:	e09c      	b.n	340185d6 <_printf_i+0x1e6>
3401849c:	6833      	ldr	r3, [r6, #0]
3401849e:	6820      	ldr	r0, [r4, #0]
340184a0:	1d19      	adds	r1, r3, #4
340184a2:	6031      	str	r1, [r6, #0]
340184a4:	0606      	lsls	r6, r0, #24
340184a6:	d501      	bpl.n	340184ac <_printf_i+0xbc>
340184a8:	681d      	ldr	r5, [r3, #0]
340184aa:	e003      	b.n	340184b4 <_printf_i+0xc4>
340184ac:	0645      	lsls	r5, r0, #25
340184ae:	d5fb      	bpl.n	340184a8 <_printf_i+0xb8>
340184b0:	f9b3 5000 	ldrsh.w	r5, [r3]
340184b4:	2d00      	cmp	r5, #0
340184b6:	da03      	bge.n	340184c0 <_printf_i+0xd0>
340184b8:	232d      	movs	r3, #45	@ 0x2d
340184ba:	426d      	negs	r5, r5
340184bc:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340184c0:	4858      	ldr	r0, [pc, #352]	@ (34018624 <_printf_i+0x234>)
340184c2:	230a      	movs	r3, #10
340184c4:	e011      	b.n	340184ea <_printf_i+0xfa>
340184c6:	6821      	ldr	r1, [r4, #0]
340184c8:	6833      	ldr	r3, [r6, #0]
340184ca:	0608      	lsls	r0, r1, #24
340184cc:	f853 5b04 	ldr.w	r5, [r3], #4
340184d0:	d402      	bmi.n	340184d8 <_printf_i+0xe8>
340184d2:	0649      	lsls	r1, r1, #25
340184d4:	bf48      	it	mi
340184d6:	b2ad      	uxthmi	r5, r5
340184d8:	2f6f      	cmp	r7, #111	@ 0x6f
340184da:	6033      	str	r3, [r6, #0]
340184dc:	4851      	ldr	r0, [pc, #324]	@ (34018624 <_printf_i+0x234>)
340184de:	bf14      	ite	ne
340184e0:	230a      	movne	r3, #10
340184e2:	2308      	moveq	r3, #8
340184e4:	2100      	movs	r1, #0
340184e6:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
340184ea:	6866      	ldr	r6, [r4, #4]
340184ec:	2e00      	cmp	r6, #0
340184ee:	60a6      	str	r6, [r4, #8]
340184f0:	db05      	blt.n	340184fe <_printf_i+0x10e>
340184f2:	6821      	ldr	r1, [r4, #0]
340184f4:	432e      	orrs	r6, r5
340184f6:	f021 0104 	bic.w	r1, r1, #4
340184fa:	6021      	str	r1, [r4, #0]
340184fc:	d04b      	beq.n	34018596 <_printf_i+0x1a6>
340184fe:	4616      	mov	r6, r2
34018500:	fbb5 f1f3 	udiv	r1, r5, r3
34018504:	fb03 5711 	mls	r7, r3, r1, r5
34018508:	5dc7      	ldrb	r7, [r0, r7]
3401850a:	f806 7d01 	strb.w	r7, [r6, #-1]!
3401850e:	462f      	mov	r7, r5
34018510:	460d      	mov	r5, r1
34018512:	42bb      	cmp	r3, r7
34018514:	d9f4      	bls.n	34018500 <_printf_i+0x110>
34018516:	2b08      	cmp	r3, #8
34018518:	d10b      	bne.n	34018532 <_printf_i+0x142>
3401851a:	6823      	ldr	r3, [r4, #0]
3401851c:	07df      	lsls	r7, r3, #31
3401851e:	d508      	bpl.n	34018532 <_printf_i+0x142>
34018520:	6923      	ldr	r3, [r4, #16]
34018522:	6861      	ldr	r1, [r4, #4]
34018524:	4299      	cmp	r1, r3
34018526:	bfde      	ittt	le
34018528:	2330      	movle	r3, #48	@ 0x30
3401852a:	f806 3c01 	strble.w	r3, [r6, #-1]
3401852e:	f106 36ff 	addle.w	r6, r6, #4294967295
34018532:	1b92      	subs	r2, r2, r6
34018534:	6122      	str	r2, [r4, #16]
34018536:	464b      	mov	r3, r9
34018538:	aa03      	add	r2, sp, #12
3401853a:	4621      	mov	r1, r4
3401853c:	4640      	mov	r0, r8
3401853e:	f8cd a000 	str.w	sl, [sp]
34018542:	f7ff fee3 	bl	3401830c <_printf_common>
34018546:	3001      	adds	r0, #1
34018548:	d14a      	bne.n	340185e0 <_printf_i+0x1f0>
3401854a:	f04f 30ff 	mov.w	r0, #4294967295
3401854e:	b004      	add	sp, #16
34018550:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34018554:	6823      	ldr	r3, [r4, #0]
34018556:	f043 0320 	orr.w	r3, r3, #32
3401855a:	6023      	str	r3, [r4, #0]
3401855c:	2778      	movs	r7, #120	@ 0x78
3401855e:	4832      	ldr	r0, [pc, #200]	@ (34018628 <_printf_i+0x238>)
34018560:	6823      	ldr	r3, [r4, #0]
34018562:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
34018566:	061f      	lsls	r7, r3, #24
34018568:	6831      	ldr	r1, [r6, #0]
3401856a:	f851 5b04 	ldr.w	r5, [r1], #4
3401856e:	d402      	bmi.n	34018576 <_printf_i+0x186>
34018570:	065f      	lsls	r7, r3, #25
34018572:	bf48      	it	mi
34018574:	b2ad      	uxthmi	r5, r5
34018576:	6031      	str	r1, [r6, #0]
34018578:	07d9      	lsls	r1, r3, #31
3401857a:	bf44      	itt	mi
3401857c:	f043 0320 	orrmi.w	r3, r3, #32
34018580:	6023      	strmi	r3, [r4, #0]
34018582:	b11d      	cbz	r5, 3401858c <_printf_i+0x19c>
34018584:	2310      	movs	r3, #16
34018586:	e7ad      	b.n	340184e4 <_printf_i+0xf4>
34018588:	4826      	ldr	r0, [pc, #152]	@ (34018624 <_printf_i+0x234>)
3401858a:	e7e9      	b.n	34018560 <_printf_i+0x170>
3401858c:	6823      	ldr	r3, [r4, #0]
3401858e:	f023 0320 	bic.w	r3, r3, #32
34018592:	6023      	str	r3, [r4, #0]
34018594:	e7f6      	b.n	34018584 <_printf_i+0x194>
34018596:	4616      	mov	r6, r2
34018598:	e7bd      	b.n	34018516 <_printf_i+0x126>
3401859a:	6833      	ldr	r3, [r6, #0]
3401859c:	6825      	ldr	r5, [r4, #0]
3401859e:	1d18      	adds	r0, r3, #4
340185a0:	6961      	ldr	r1, [r4, #20]
340185a2:	6030      	str	r0, [r6, #0]
340185a4:	062e      	lsls	r6, r5, #24
340185a6:	681b      	ldr	r3, [r3, #0]
340185a8:	d501      	bpl.n	340185ae <_printf_i+0x1be>
340185aa:	6019      	str	r1, [r3, #0]
340185ac:	e002      	b.n	340185b4 <_printf_i+0x1c4>
340185ae:	0668      	lsls	r0, r5, #25
340185b0:	d5fb      	bpl.n	340185aa <_printf_i+0x1ba>
340185b2:	8019      	strh	r1, [r3, #0]
340185b4:	2300      	movs	r3, #0
340185b6:	4616      	mov	r6, r2
340185b8:	6123      	str	r3, [r4, #16]
340185ba:	e7bc      	b.n	34018536 <_printf_i+0x146>
340185bc:	6833      	ldr	r3, [r6, #0]
340185be:	2100      	movs	r1, #0
340185c0:	1d1a      	adds	r2, r3, #4
340185c2:	6032      	str	r2, [r6, #0]
340185c4:	681e      	ldr	r6, [r3, #0]
340185c6:	6862      	ldr	r2, [r4, #4]
340185c8:	4630      	mov	r0, r6
340185ca:	f000 fd60 	bl	3401908e <memchr>
340185ce:	b108      	cbz	r0, 340185d4 <_printf_i+0x1e4>
340185d0:	1b80      	subs	r0, r0, r6
340185d2:	6060      	str	r0, [r4, #4]
340185d4:	6863      	ldr	r3, [r4, #4]
340185d6:	6123      	str	r3, [r4, #16]
340185d8:	2300      	movs	r3, #0
340185da:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340185de:	e7aa      	b.n	34018536 <_printf_i+0x146>
340185e0:	6923      	ldr	r3, [r4, #16]
340185e2:	4632      	mov	r2, r6
340185e4:	4649      	mov	r1, r9
340185e6:	4640      	mov	r0, r8
340185e8:	47d0      	blx	sl
340185ea:	3001      	adds	r0, #1
340185ec:	d0ad      	beq.n	3401854a <_printf_i+0x15a>
340185ee:	6823      	ldr	r3, [r4, #0]
340185f0:	079b      	lsls	r3, r3, #30
340185f2:	d413      	bmi.n	3401861c <_printf_i+0x22c>
340185f4:	68e0      	ldr	r0, [r4, #12]
340185f6:	9b03      	ldr	r3, [sp, #12]
340185f8:	4298      	cmp	r0, r3
340185fa:	bfb8      	it	lt
340185fc:	4618      	movlt	r0, r3
340185fe:	e7a6      	b.n	3401854e <_printf_i+0x15e>
34018600:	2301      	movs	r3, #1
34018602:	4632      	mov	r2, r6
34018604:	4649      	mov	r1, r9
34018606:	4640      	mov	r0, r8
34018608:	47d0      	blx	sl
3401860a:	3001      	adds	r0, #1
3401860c:	d09d      	beq.n	3401854a <_printf_i+0x15a>
3401860e:	3501      	adds	r5, #1
34018610:	68e3      	ldr	r3, [r4, #12]
34018612:	9903      	ldr	r1, [sp, #12]
34018614:	1a5b      	subs	r3, r3, r1
34018616:	42ab      	cmp	r3, r5
34018618:	dcf2      	bgt.n	34018600 <_printf_i+0x210>
3401861a:	e7eb      	b.n	340185f4 <_printf_i+0x204>
3401861c:	2500      	movs	r5, #0
3401861e:	f104 0619 	add.w	r6, r4, #25
34018622:	e7f5      	b.n	34018610 <_printf_i+0x220>
34018624:	3401df95 	.word	0x3401df95
34018628:	3401dfa6 	.word	0x3401dfa6

3401862c <std>:
3401862c:	2300      	movs	r3, #0
3401862e:	b510      	push	{r4, lr}
34018630:	4604      	mov	r4, r0
34018632:	6083      	str	r3, [r0, #8]
34018634:	8181      	strh	r1, [r0, #12]
34018636:	4619      	mov	r1, r3
34018638:	6643      	str	r3, [r0, #100]	@ 0x64
3401863a:	81c2      	strh	r2, [r0, #14]
3401863c:	2208      	movs	r2, #8
3401863e:	6183      	str	r3, [r0, #24]
34018640:	e9c0 3300 	strd	r3, r3, [r0]
34018644:	e9c0 3304 	strd	r3, r3, [r0, #16]
34018648:	305c      	adds	r0, #92	@ 0x5c
3401864a:	f000 fa97 	bl	34018b7c <memset>
3401864e:	4b0d      	ldr	r3, [pc, #52]	@ (34018684 <std+0x58>)
34018650:	6224      	str	r4, [r4, #32]
34018652:	6263      	str	r3, [r4, #36]	@ 0x24
34018654:	4b0c      	ldr	r3, [pc, #48]	@ (34018688 <std+0x5c>)
34018656:	62a3      	str	r3, [r4, #40]	@ 0x28
34018658:	4b0c      	ldr	r3, [pc, #48]	@ (3401868c <std+0x60>)
3401865a:	62e3      	str	r3, [r4, #44]	@ 0x2c
3401865c:	4b0c      	ldr	r3, [pc, #48]	@ (34018690 <std+0x64>)
3401865e:	6323      	str	r3, [r4, #48]	@ 0x30
34018660:	4b0c      	ldr	r3, [pc, #48]	@ (34018694 <std+0x68>)
34018662:	429c      	cmp	r4, r3
34018664:	d006      	beq.n	34018674 <std+0x48>
34018666:	f103 0268 	add.w	r2, r3, #104	@ 0x68
3401866a:	4294      	cmp	r4, r2
3401866c:	d002      	beq.n	34018674 <std+0x48>
3401866e:	33d0      	adds	r3, #208	@ 0xd0
34018670:	429c      	cmp	r4, r3
34018672:	d105      	bne.n	34018680 <std+0x54>
34018674:	f104 0058 	add.w	r0, r4, #88	@ 0x58
34018678:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401867c:	f000 bcfc 	b.w	34019078 <__retarget_lock_init_recursive>
34018680:	bd10      	pop	{r4, pc}
34018682:	bf00      	nop
34018684:	34018921 	.word	0x34018921
34018688:	34018943 	.word	0x34018943
3401868c:	3401897b 	.word	0x3401897b
34018690:	3401899f 	.word	0x3401899f
34018694:	340445d0 	.word	0x340445d0

34018698 <stdio_exit_handler>:
34018698:	4a02      	ldr	r2, [pc, #8]	@ (340186a4 <stdio_exit_handler+0xc>)
3401869a:	4903      	ldr	r1, [pc, #12]	@ (340186a8 <stdio_exit_handler+0x10>)
3401869c:	4803      	ldr	r0, [pc, #12]	@ (340186ac <stdio_exit_handler+0x14>)
3401869e:	f000 b87b 	b.w	34018798 <_fwalk_sglue>
340186a2:	bf00      	nop
340186a4:	3403edd0 	.word	0x3403edd0
340186a8:	3401aa91 	.word	0x3401aa91
340186ac:	3403ede0 	.word	0x3403ede0

340186b0 <cleanup_stdio>:
340186b0:	6841      	ldr	r1, [r0, #4]
340186b2:	4b0c      	ldr	r3, [pc, #48]	@ (340186e4 <cleanup_stdio+0x34>)
340186b4:	4299      	cmp	r1, r3
340186b6:	b510      	push	{r4, lr}
340186b8:	4604      	mov	r4, r0
340186ba:	d001      	beq.n	340186c0 <cleanup_stdio+0x10>
340186bc:	f002 f9e8 	bl	3401aa90 <_fflush_r>
340186c0:	68a1      	ldr	r1, [r4, #8]
340186c2:	4b09      	ldr	r3, [pc, #36]	@ (340186e8 <cleanup_stdio+0x38>)
340186c4:	4299      	cmp	r1, r3
340186c6:	d002      	beq.n	340186ce <cleanup_stdio+0x1e>
340186c8:	4620      	mov	r0, r4
340186ca:	f002 f9e1 	bl	3401aa90 <_fflush_r>
340186ce:	68e1      	ldr	r1, [r4, #12]
340186d0:	4b06      	ldr	r3, [pc, #24]	@ (340186ec <cleanup_stdio+0x3c>)
340186d2:	4299      	cmp	r1, r3
340186d4:	d004      	beq.n	340186e0 <cleanup_stdio+0x30>
340186d6:	4620      	mov	r0, r4
340186d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
340186dc:	f002 b9d8 	b.w	3401aa90 <_fflush_r>
340186e0:	bd10      	pop	{r4, pc}
340186e2:	bf00      	nop
340186e4:	340445d0 	.word	0x340445d0
340186e8:	34044638 	.word	0x34044638
340186ec:	340446a0 	.word	0x340446a0

340186f0 <global_stdio_init.part.0>:
340186f0:	b510      	push	{r4, lr}
340186f2:	4b0b      	ldr	r3, [pc, #44]	@ (34018720 <global_stdio_init.part.0+0x30>)
340186f4:	2104      	movs	r1, #4
340186f6:	4c0b      	ldr	r4, [pc, #44]	@ (34018724 <global_stdio_init.part.0+0x34>)
340186f8:	4a0b      	ldr	r2, [pc, #44]	@ (34018728 <global_stdio_init.part.0+0x38>)
340186fa:	4620      	mov	r0, r4
340186fc:	601a      	str	r2, [r3, #0]
340186fe:	2200      	movs	r2, #0
34018700:	f7ff ff94 	bl	3401862c <std>
34018704:	f104 0068 	add.w	r0, r4, #104	@ 0x68
34018708:	2201      	movs	r2, #1
3401870a:	2109      	movs	r1, #9
3401870c:	f7ff ff8e 	bl	3401862c <std>
34018710:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
34018714:	2202      	movs	r2, #2
34018716:	2112      	movs	r1, #18
34018718:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401871c:	f7ff bf86 	b.w	3401862c <std>
34018720:	34044708 	.word	0x34044708
34018724:	340445d0 	.word	0x340445d0
34018728:	34018699 	.word	0x34018699

3401872c <__sfp_lock_acquire>:
3401872c:	4801      	ldr	r0, [pc, #4]	@ (34018734 <__sfp_lock_acquire+0x8>)
3401872e:	f000 bca4 	b.w	3401907a <__retarget_lock_acquire_recursive>
34018732:	bf00      	nop
34018734:	34044711 	.word	0x34044711

34018738 <__sfp_lock_release>:
34018738:	4801      	ldr	r0, [pc, #4]	@ (34018740 <__sfp_lock_release+0x8>)
3401873a:	f000 bc9f 	b.w	3401907c <__retarget_lock_release_recursive>
3401873e:	bf00      	nop
34018740:	34044711 	.word	0x34044711

34018744 <__sinit>:
34018744:	b510      	push	{r4, lr}
34018746:	4604      	mov	r4, r0
34018748:	f7ff fff0 	bl	3401872c <__sfp_lock_acquire>
3401874c:	6a23      	ldr	r3, [r4, #32]
3401874e:	b11b      	cbz	r3, 34018758 <__sinit+0x14>
34018750:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34018754:	f7ff bff0 	b.w	34018738 <__sfp_lock_release>
34018758:	4b04      	ldr	r3, [pc, #16]	@ (3401876c <__sinit+0x28>)
3401875a:	6223      	str	r3, [r4, #32]
3401875c:	4b04      	ldr	r3, [pc, #16]	@ (34018770 <__sinit+0x2c>)
3401875e:	681b      	ldr	r3, [r3, #0]
34018760:	2b00      	cmp	r3, #0
34018762:	d1f5      	bne.n	34018750 <__sinit+0xc>
34018764:	f7ff ffc4 	bl	340186f0 <global_stdio_init.part.0>
34018768:	e7f2      	b.n	34018750 <__sinit+0xc>
3401876a:	bf00      	nop
3401876c:	340186b1 	.word	0x340186b1
34018770:	34044708 	.word	0x34044708

34018774 <fiprintf>:
34018774:	b40e      	push	{r1, r2, r3}
34018776:	b503      	push	{r0, r1, lr}
34018778:	ab03      	add	r3, sp, #12
3401877a:	4601      	mov	r1, r0
3401877c:	4805      	ldr	r0, [pc, #20]	@ (34018794 <fiprintf+0x20>)
3401877e:	f853 2b04 	ldr.w	r2, [r3], #4
34018782:	6800      	ldr	r0, [r0, #0]
34018784:	9301      	str	r3, [sp, #4]
34018786:	f001 ffe7 	bl	3401a758 <_vfiprintf_r>
3401878a:	b002      	add	sp, #8
3401878c:	f85d eb04 	ldr.w	lr, [sp], #4
34018790:	b003      	add	sp, #12
34018792:	4770      	bx	lr
34018794:	3403eddc 	.word	0x3403eddc

34018798 <_fwalk_sglue>:
34018798:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401879c:	4607      	mov	r7, r0
3401879e:	4688      	mov	r8, r1
340187a0:	4614      	mov	r4, r2
340187a2:	2600      	movs	r6, #0
340187a4:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
340187a8:	f1b9 0901 	subs.w	r9, r9, #1
340187ac:	d505      	bpl.n	340187ba <_fwalk_sglue+0x22>
340187ae:	6824      	ldr	r4, [r4, #0]
340187b0:	2c00      	cmp	r4, #0
340187b2:	d1f7      	bne.n	340187a4 <_fwalk_sglue+0xc>
340187b4:	4630      	mov	r0, r6
340187b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
340187ba:	89ab      	ldrh	r3, [r5, #12]
340187bc:	2b01      	cmp	r3, #1
340187be:	d907      	bls.n	340187d0 <_fwalk_sglue+0x38>
340187c0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
340187c4:	3301      	adds	r3, #1
340187c6:	d003      	beq.n	340187d0 <_fwalk_sglue+0x38>
340187c8:	4629      	mov	r1, r5
340187ca:	4638      	mov	r0, r7
340187cc:	47c0      	blx	r8
340187ce:	4306      	orrs	r6, r0
340187d0:	3568      	adds	r5, #104	@ 0x68
340187d2:	e7e9      	b.n	340187a8 <_fwalk_sglue+0x10>

340187d4 <iprintf>:
340187d4:	b40f      	push	{r0, r1, r2, r3}
340187d6:	b507      	push	{r0, r1, r2, lr}
340187d8:	4906      	ldr	r1, [pc, #24]	@ (340187f4 <iprintf+0x20>)
340187da:	ab04      	add	r3, sp, #16
340187dc:	6808      	ldr	r0, [r1, #0]
340187de:	f853 2b04 	ldr.w	r2, [r3], #4
340187e2:	6881      	ldr	r1, [r0, #8]
340187e4:	9301      	str	r3, [sp, #4]
340187e6:	f001 ffb7 	bl	3401a758 <_vfiprintf_r>
340187ea:	b003      	add	sp, #12
340187ec:	f85d eb04 	ldr.w	lr, [sp], #4
340187f0:	b004      	add	sp, #16
340187f2:	4770      	bx	lr
340187f4:	3403eddc 	.word	0x3403eddc

340187f8 <_puts_r>:
340187f8:	6a03      	ldr	r3, [r0, #32]
340187fa:	b570      	push	{r4, r5, r6, lr}
340187fc:	4605      	mov	r5, r0
340187fe:	460e      	mov	r6, r1
34018800:	6884      	ldr	r4, [r0, #8]
34018802:	b90b      	cbnz	r3, 34018808 <_puts_r+0x10>
34018804:	f7ff ff9e 	bl	34018744 <__sinit>
34018808:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401880a:	07db      	lsls	r3, r3, #31
3401880c:	d405      	bmi.n	3401881a <_puts_r+0x22>
3401880e:	89a3      	ldrh	r3, [r4, #12]
34018810:	0598      	lsls	r0, r3, #22
34018812:	d402      	bmi.n	3401881a <_puts_r+0x22>
34018814:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34018816:	f000 fc30 	bl	3401907a <__retarget_lock_acquire_recursive>
3401881a:	89a3      	ldrh	r3, [r4, #12]
3401881c:	0719      	lsls	r1, r3, #28
3401881e:	d502      	bpl.n	34018826 <_puts_r+0x2e>
34018820:	6923      	ldr	r3, [r4, #16]
34018822:	2b00      	cmp	r3, #0
34018824:	d135      	bne.n	34018892 <_puts_r+0x9a>
34018826:	4621      	mov	r1, r4
34018828:	4628      	mov	r0, r5
3401882a:	f000 f937 	bl	34018a9c <__swsetup_r>
3401882e:	b380      	cbz	r0, 34018892 <_puts_r+0x9a>
34018830:	f04f 35ff 	mov.w	r5, #4294967295
34018834:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34018836:	07da      	lsls	r2, r3, #31
34018838:	d405      	bmi.n	34018846 <_puts_r+0x4e>
3401883a:	89a3      	ldrh	r3, [r4, #12]
3401883c:	059b      	lsls	r3, r3, #22
3401883e:	d402      	bmi.n	34018846 <_puts_r+0x4e>
34018840:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34018842:	f000 fc1b 	bl	3401907c <__retarget_lock_release_recursive>
34018846:	4628      	mov	r0, r5
34018848:	bd70      	pop	{r4, r5, r6, pc}
3401884a:	2b00      	cmp	r3, #0
3401884c:	da04      	bge.n	34018858 <_puts_r+0x60>
3401884e:	69a2      	ldr	r2, [r4, #24]
34018850:	429a      	cmp	r2, r3
34018852:	dc17      	bgt.n	34018884 <_puts_r+0x8c>
34018854:	290a      	cmp	r1, #10
34018856:	d015      	beq.n	34018884 <_puts_r+0x8c>
34018858:	6823      	ldr	r3, [r4, #0]
3401885a:	1c5a      	adds	r2, r3, #1
3401885c:	6022      	str	r2, [r4, #0]
3401885e:	7019      	strb	r1, [r3, #0]
34018860:	68a3      	ldr	r3, [r4, #8]
34018862:	f816 1f01 	ldrb.w	r1, [r6, #1]!
34018866:	3b01      	subs	r3, #1
34018868:	60a3      	str	r3, [r4, #8]
3401886a:	2900      	cmp	r1, #0
3401886c:	d1ed      	bne.n	3401884a <_puts_r+0x52>
3401886e:	2b00      	cmp	r3, #0
34018870:	da11      	bge.n	34018896 <_puts_r+0x9e>
34018872:	4622      	mov	r2, r4
34018874:	210a      	movs	r1, #10
34018876:	4628      	mov	r0, r5
34018878:	f000 f8d2 	bl	34018a20 <__swbuf_r>
3401887c:	3001      	adds	r0, #1
3401887e:	d0d7      	beq.n	34018830 <_puts_r+0x38>
34018880:	250a      	movs	r5, #10
34018882:	e7d7      	b.n	34018834 <_puts_r+0x3c>
34018884:	4622      	mov	r2, r4
34018886:	4628      	mov	r0, r5
34018888:	f000 f8ca 	bl	34018a20 <__swbuf_r>
3401888c:	3001      	adds	r0, #1
3401888e:	d1e7      	bne.n	34018860 <_puts_r+0x68>
34018890:	e7ce      	b.n	34018830 <_puts_r+0x38>
34018892:	3e01      	subs	r6, #1
34018894:	e7e4      	b.n	34018860 <_puts_r+0x68>
34018896:	6823      	ldr	r3, [r4, #0]
34018898:	1c5a      	adds	r2, r3, #1
3401889a:	6022      	str	r2, [r4, #0]
3401889c:	220a      	movs	r2, #10
3401889e:	701a      	strb	r2, [r3, #0]
340188a0:	e7ee      	b.n	34018880 <_puts_r+0x88>
	...

340188a4 <puts>:
340188a4:	4b02      	ldr	r3, [pc, #8]	@ (340188b0 <puts+0xc>)
340188a6:	4601      	mov	r1, r0
340188a8:	6818      	ldr	r0, [r3, #0]
340188aa:	f7ff bfa5 	b.w	340187f8 <_puts_r>
340188ae:	bf00      	nop
340188b0:	3403eddc 	.word	0x3403eddc

340188b4 <sniprintf>:
340188b4:	b40c      	push	{r2, r3}
340188b6:	4b19      	ldr	r3, [pc, #100]	@ (3401891c <sniprintf+0x68>)
340188b8:	b530      	push	{r4, r5, lr}
340188ba:	1e0c      	subs	r4, r1, #0
340188bc:	b09d      	sub	sp, #116	@ 0x74
340188be:	681d      	ldr	r5, [r3, #0]
340188c0:	da08      	bge.n	340188d4 <sniprintf+0x20>
340188c2:	238b      	movs	r3, #139	@ 0x8b
340188c4:	f04f 30ff 	mov.w	r0, #4294967295
340188c8:	602b      	str	r3, [r5, #0]
340188ca:	b01d      	add	sp, #116	@ 0x74
340188cc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
340188d0:	b002      	add	sp, #8
340188d2:	4770      	bx	lr
340188d4:	f44f 7302 	mov.w	r3, #520	@ 0x208
340188d8:	9002      	str	r0, [sp, #8]
340188da:	9006      	str	r0, [sp, #24]
340188dc:	a902      	add	r1, sp, #8
340188de:	f8ad 3014 	strh.w	r3, [sp, #20]
340188e2:	f04f 0300 	mov.w	r3, #0
340188e6:	9a20      	ldr	r2, [sp, #128]	@ 0x80
340188e8:	4628      	mov	r0, r5
340188ea:	931b      	str	r3, [sp, #108]	@ 0x6c
340188ec:	bf14      	ite	ne
340188ee:	f104 33ff 	addne.w	r3, r4, #4294967295
340188f2:	4623      	moveq	r3, r4
340188f4:	9304      	str	r3, [sp, #16]
340188f6:	9307      	str	r3, [sp, #28]
340188f8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
340188fc:	f8ad 3016 	strh.w	r3, [sp, #22]
34018900:	ab21      	add	r3, sp, #132	@ 0x84
34018902:	9301      	str	r3, [sp, #4]
34018904:	f001 fe02 	bl	3401a50c <_svfiprintf_r>
34018908:	1c43      	adds	r3, r0, #1
3401890a:	bfbc      	itt	lt
3401890c:	238b      	movlt	r3, #139	@ 0x8b
3401890e:	602b      	strlt	r3, [r5, #0]
34018910:	2c00      	cmp	r4, #0
34018912:	d0da      	beq.n	340188ca <sniprintf+0x16>
34018914:	9b02      	ldr	r3, [sp, #8]
34018916:	2200      	movs	r2, #0
34018918:	701a      	strb	r2, [r3, #0]
3401891a:	e7d6      	b.n	340188ca <sniprintf+0x16>
3401891c:	3403eddc 	.word	0x3403eddc

34018920 <__sread>:
34018920:	b510      	push	{r4, lr}
34018922:	460c      	mov	r4, r1
34018924:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34018928:	f000 fb48 	bl	34018fbc <_read_r>
3401892c:	2800      	cmp	r0, #0
3401892e:	bfab      	itete	ge
34018930:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
34018932:	89a3      	ldrhlt	r3, [r4, #12]
34018934:	181b      	addge	r3, r3, r0
34018936:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
3401893a:	bfac      	ite	ge
3401893c:	6563      	strge	r3, [r4, #84]	@ 0x54
3401893e:	81a3      	strhlt	r3, [r4, #12]
34018940:	bd10      	pop	{r4, pc}

34018942 <__swrite>:
34018942:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34018946:	461f      	mov	r7, r3
34018948:	898b      	ldrh	r3, [r1, #12]
3401894a:	4605      	mov	r5, r0
3401894c:	460c      	mov	r4, r1
3401894e:	05db      	lsls	r3, r3, #23
34018950:	4616      	mov	r6, r2
34018952:	d505      	bpl.n	34018960 <__swrite+0x1e>
34018954:	2302      	movs	r3, #2
34018956:	2200      	movs	r2, #0
34018958:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401895c:	f000 fb1c 	bl	34018f98 <_lseek_r>
34018960:	89a3      	ldrh	r3, [r4, #12]
34018962:	4632      	mov	r2, r6
34018964:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
34018968:	4628      	mov	r0, r5
3401896a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
3401896e:	81a3      	strh	r3, [r4, #12]
34018970:	463b      	mov	r3, r7
34018972:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34018976:	f000 bb43 	b.w	34019000 <_write_r>

3401897a <__sseek>:
3401897a:	b510      	push	{r4, lr}
3401897c:	460c      	mov	r4, r1
3401897e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34018982:	f000 fb09 	bl	34018f98 <_lseek_r>
34018986:	1c43      	adds	r3, r0, #1
34018988:	89a3      	ldrh	r3, [r4, #12]
3401898a:	bf15      	itete	ne
3401898c:	6560      	strne	r0, [r4, #84]	@ 0x54
3401898e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
34018992:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
34018996:	81a3      	strheq	r3, [r4, #12]
34018998:	bf18      	it	ne
3401899a:	81a3      	strhne	r3, [r4, #12]
3401899c:	bd10      	pop	{r4, pc}

3401899e <__sclose>:
3401899e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
340189a2:	f000 bae9 	b.w	34018f78 <_close_r>

340189a6 <_vsniprintf_r>:
340189a6:	b530      	push	{r4, r5, lr}
340189a8:	4614      	mov	r4, r2
340189aa:	b09b      	sub	sp, #108	@ 0x6c
340189ac:	4605      	mov	r5, r0
340189ae:	461a      	mov	r2, r3
340189b0:	2c00      	cmp	r4, #0
340189b2:	da05      	bge.n	340189c0 <_vsniprintf_r+0x1a>
340189b4:	238b      	movs	r3, #139	@ 0x8b
340189b6:	6003      	str	r3, [r0, #0]
340189b8:	f04f 30ff 	mov.w	r0, #4294967295
340189bc:	b01b      	add	sp, #108	@ 0x6c
340189be:	bd30      	pop	{r4, r5, pc}
340189c0:	f44f 7302 	mov.w	r3, #520	@ 0x208
340189c4:	9100      	str	r1, [sp, #0]
340189c6:	9104      	str	r1, [sp, #16]
340189c8:	4669      	mov	r1, sp
340189ca:	f8ad 300c 	strh.w	r3, [sp, #12]
340189ce:	f04f 0300 	mov.w	r3, #0
340189d2:	9319      	str	r3, [sp, #100]	@ 0x64
340189d4:	bf14      	ite	ne
340189d6:	f104 33ff 	addne.w	r3, r4, #4294967295
340189da:	4623      	moveq	r3, r4
340189dc:	9302      	str	r3, [sp, #8]
340189de:	9305      	str	r3, [sp, #20]
340189e0:	f64f 73ff 	movw	r3, #65535	@ 0xffff
340189e4:	f8ad 300e 	strh.w	r3, [sp, #14]
340189e8:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
340189ea:	f001 fd8f 	bl	3401a50c <_svfiprintf_r>
340189ee:	1c43      	adds	r3, r0, #1
340189f0:	bfbc      	itt	lt
340189f2:	238b      	movlt	r3, #139	@ 0x8b
340189f4:	602b      	strlt	r3, [r5, #0]
340189f6:	2c00      	cmp	r4, #0
340189f8:	d0e0      	beq.n	340189bc <_vsniprintf_r+0x16>
340189fa:	9b00      	ldr	r3, [sp, #0]
340189fc:	2200      	movs	r2, #0
340189fe:	701a      	strb	r2, [r3, #0]
34018a00:	e7dc      	b.n	340189bc <_vsniprintf_r+0x16>
	...

34018a04 <vsniprintf>:
34018a04:	b507      	push	{r0, r1, r2, lr}
34018a06:	9300      	str	r3, [sp, #0]
34018a08:	4613      	mov	r3, r2
34018a0a:	460a      	mov	r2, r1
34018a0c:	4601      	mov	r1, r0
34018a0e:	4803      	ldr	r0, [pc, #12]	@ (34018a1c <vsniprintf+0x18>)
34018a10:	6800      	ldr	r0, [r0, #0]
34018a12:	f7ff ffc8 	bl	340189a6 <_vsniprintf_r>
34018a16:	b003      	add	sp, #12
34018a18:	f85d fb04 	ldr.w	pc, [sp], #4
34018a1c:	3403eddc 	.word	0x3403eddc

34018a20 <__swbuf_r>:
34018a20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34018a22:	460e      	mov	r6, r1
34018a24:	4614      	mov	r4, r2
34018a26:	4605      	mov	r5, r0
34018a28:	b118      	cbz	r0, 34018a32 <__swbuf_r+0x12>
34018a2a:	6a03      	ldr	r3, [r0, #32]
34018a2c:	b90b      	cbnz	r3, 34018a32 <__swbuf_r+0x12>
34018a2e:	f7ff fe89 	bl	34018744 <__sinit>
34018a32:	69a3      	ldr	r3, [r4, #24]
34018a34:	60a3      	str	r3, [r4, #8]
34018a36:	89a3      	ldrh	r3, [r4, #12]
34018a38:	071a      	lsls	r2, r3, #28
34018a3a:	d501      	bpl.n	34018a40 <__swbuf_r+0x20>
34018a3c:	6923      	ldr	r3, [r4, #16]
34018a3e:	b943      	cbnz	r3, 34018a52 <__swbuf_r+0x32>
34018a40:	4621      	mov	r1, r4
34018a42:	4628      	mov	r0, r5
34018a44:	f000 f82a 	bl	34018a9c <__swsetup_r>
34018a48:	b118      	cbz	r0, 34018a52 <__swbuf_r+0x32>
34018a4a:	f04f 37ff 	mov.w	r7, #4294967295
34018a4e:	4638      	mov	r0, r7
34018a50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34018a52:	6823      	ldr	r3, [r4, #0]
34018a54:	b2f6      	uxtb	r6, r6
34018a56:	6922      	ldr	r2, [r4, #16]
34018a58:	4637      	mov	r7, r6
34018a5a:	1a98      	subs	r0, r3, r2
34018a5c:	6963      	ldr	r3, [r4, #20]
34018a5e:	4283      	cmp	r3, r0
34018a60:	dc05      	bgt.n	34018a6e <__swbuf_r+0x4e>
34018a62:	4621      	mov	r1, r4
34018a64:	4628      	mov	r0, r5
34018a66:	f002 f813 	bl	3401aa90 <_fflush_r>
34018a6a:	2800      	cmp	r0, #0
34018a6c:	d1ed      	bne.n	34018a4a <__swbuf_r+0x2a>
34018a6e:	68a3      	ldr	r3, [r4, #8]
34018a70:	3b01      	subs	r3, #1
34018a72:	60a3      	str	r3, [r4, #8]
34018a74:	6823      	ldr	r3, [r4, #0]
34018a76:	1c5a      	adds	r2, r3, #1
34018a78:	6022      	str	r2, [r4, #0]
34018a7a:	701e      	strb	r6, [r3, #0]
34018a7c:	1c43      	adds	r3, r0, #1
34018a7e:	6962      	ldr	r2, [r4, #20]
34018a80:	429a      	cmp	r2, r3
34018a82:	d004      	beq.n	34018a8e <__swbuf_r+0x6e>
34018a84:	89a3      	ldrh	r3, [r4, #12]
34018a86:	07db      	lsls	r3, r3, #31
34018a88:	d5e1      	bpl.n	34018a4e <__swbuf_r+0x2e>
34018a8a:	2e0a      	cmp	r6, #10
34018a8c:	d1df      	bne.n	34018a4e <__swbuf_r+0x2e>
34018a8e:	4621      	mov	r1, r4
34018a90:	4628      	mov	r0, r5
34018a92:	f001 fffd 	bl	3401aa90 <_fflush_r>
34018a96:	2800      	cmp	r0, #0
34018a98:	d0d9      	beq.n	34018a4e <__swbuf_r+0x2e>
34018a9a:	e7d6      	b.n	34018a4a <__swbuf_r+0x2a>

34018a9c <__swsetup_r>:
34018a9c:	b538      	push	{r3, r4, r5, lr}
34018a9e:	4b29      	ldr	r3, [pc, #164]	@ (34018b44 <__swsetup_r+0xa8>)
34018aa0:	4605      	mov	r5, r0
34018aa2:	460c      	mov	r4, r1
34018aa4:	6818      	ldr	r0, [r3, #0]
34018aa6:	b118      	cbz	r0, 34018ab0 <__swsetup_r+0x14>
34018aa8:	6a03      	ldr	r3, [r0, #32]
34018aaa:	b90b      	cbnz	r3, 34018ab0 <__swsetup_r+0x14>
34018aac:	f7ff fe4a 	bl	34018744 <__sinit>
34018ab0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34018ab4:	0719      	lsls	r1, r3, #28
34018ab6:	d422      	bmi.n	34018afe <__swsetup_r+0x62>
34018ab8:	06da      	lsls	r2, r3, #27
34018aba:	d407      	bmi.n	34018acc <__swsetup_r+0x30>
34018abc:	2209      	movs	r2, #9
34018abe:	602a      	str	r2, [r5, #0]
34018ac0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34018ac4:	f04f 30ff 	mov.w	r0, #4294967295
34018ac8:	81a3      	strh	r3, [r4, #12]
34018aca:	e033      	b.n	34018b34 <__swsetup_r+0x98>
34018acc:	0758      	lsls	r0, r3, #29
34018ace:	d512      	bpl.n	34018af6 <__swsetup_r+0x5a>
34018ad0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
34018ad2:	b141      	cbz	r1, 34018ae6 <__swsetup_r+0x4a>
34018ad4:	f104 0344 	add.w	r3, r4, #68	@ 0x44
34018ad8:	4299      	cmp	r1, r3
34018ada:	d002      	beq.n	34018ae2 <__swsetup_r+0x46>
34018adc:	4628      	mov	r0, r5
34018ade:	f001 f8e5 	bl	34019cac <_free_r>
34018ae2:	2300      	movs	r3, #0
34018ae4:	6363      	str	r3, [r4, #52]	@ 0x34
34018ae6:	89a3      	ldrh	r3, [r4, #12]
34018ae8:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
34018aec:	81a3      	strh	r3, [r4, #12]
34018aee:	2300      	movs	r3, #0
34018af0:	6063      	str	r3, [r4, #4]
34018af2:	6923      	ldr	r3, [r4, #16]
34018af4:	6023      	str	r3, [r4, #0]
34018af6:	89a3      	ldrh	r3, [r4, #12]
34018af8:	f043 0308 	orr.w	r3, r3, #8
34018afc:	81a3      	strh	r3, [r4, #12]
34018afe:	6923      	ldr	r3, [r4, #16]
34018b00:	b94b      	cbnz	r3, 34018b16 <__swsetup_r+0x7a>
34018b02:	89a3      	ldrh	r3, [r4, #12]
34018b04:	f403 7320 	and.w	r3, r3, #640	@ 0x280
34018b08:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34018b0c:	d003      	beq.n	34018b16 <__swsetup_r+0x7a>
34018b0e:	4621      	mov	r1, r4
34018b10:	4628      	mov	r0, r5
34018b12:	f002 f80a 	bl	3401ab2a <__smakebuf_r>
34018b16:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34018b1a:	f013 0201 	ands.w	r2, r3, #1
34018b1e:	d00a      	beq.n	34018b36 <__swsetup_r+0x9a>
34018b20:	2200      	movs	r2, #0
34018b22:	60a2      	str	r2, [r4, #8]
34018b24:	6962      	ldr	r2, [r4, #20]
34018b26:	4252      	negs	r2, r2
34018b28:	61a2      	str	r2, [r4, #24]
34018b2a:	6922      	ldr	r2, [r4, #16]
34018b2c:	b942      	cbnz	r2, 34018b40 <__swsetup_r+0xa4>
34018b2e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
34018b32:	d1c5      	bne.n	34018ac0 <__swsetup_r+0x24>
34018b34:	bd38      	pop	{r3, r4, r5, pc}
34018b36:	0799      	lsls	r1, r3, #30
34018b38:	bf58      	it	pl
34018b3a:	6962      	ldrpl	r2, [r4, #20]
34018b3c:	60a2      	str	r2, [r4, #8]
34018b3e:	e7f4      	b.n	34018b2a <__swsetup_r+0x8e>
34018b40:	2000      	movs	r0, #0
34018b42:	e7f7      	b.n	34018b34 <__swsetup_r+0x98>
34018b44:	3403eddc 	.word	0x3403eddc

34018b48 <memmove>:
34018b48:	4288      	cmp	r0, r1
34018b4a:	b510      	push	{r4, lr}
34018b4c:	eb01 0402 	add.w	r4, r1, r2
34018b50:	d902      	bls.n	34018b58 <memmove+0x10>
34018b52:	4284      	cmp	r4, r0
34018b54:	4623      	mov	r3, r4
34018b56:	d807      	bhi.n	34018b68 <memmove+0x20>
34018b58:	1e43      	subs	r3, r0, #1
34018b5a:	42a1      	cmp	r1, r4
34018b5c:	d008      	beq.n	34018b70 <memmove+0x28>
34018b5e:	f811 2b01 	ldrb.w	r2, [r1], #1
34018b62:	f803 2f01 	strb.w	r2, [r3, #1]!
34018b66:	e7f8      	b.n	34018b5a <memmove+0x12>
34018b68:	4402      	add	r2, r0
34018b6a:	4601      	mov	r1, r0
34018b6c:	428a      	cmp	r2, r1
34018b6e:	d100      	bne.n	34018b72 <memmove+0x2a>
34018b70:	bd10      	pop	{r4, pc}
34018b72:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
34018b76:	f802 4d01 	strb.w	r4, [r2, #-1]!
34018b7a:	e7f7      	b.n	34018b6c <memmove+0x24>

34018b7c <memset>:
34018b7c:	4402      	add	r2, r0
34018b7e:	4603      	mov	r3, r0
34018b80:	4293      	cmp	r3, r2
34018b82:	d100      	bne.n	34018b86 <memset+0xa>
34018b84:	4770      	bx	lr
34018b86:	f803 1b01 	strb.w	r1, [r3], #1
34018b8a:	e7f9      	b.n	34018b80 <memset+0x4>

34018b8c <_strerror_r>:
34018b8c:	b510      	push	{r4, lr}
34018b8e:	4604      	mov	r4, r0
34018b90:	4608      	mov	r0, r1
34018b92:	4611      	mov	r1, r2
34018b94:	461a      	mov	r2, r3
34018b96:	288e      	cmp	r0, #142	@ 0x8e
34018b98:	f200 8130 	bhi.w	34018dfc <_strerror_r+0x270>
34018b9c:	e8df f010 	tbh	[pc, r0, lsl #1]
34018ba0:	0138008f 	.word	0x0138008f
34018ba4:	00940092 	.word	0x00940092
34018ba8:	00980096 	.word	0x00980096
34018bac:	009c009a 	.word	0x009c009a
34018bb0:	00a2009e 	.word	0x00a2009e
34018bb4:	00a800a4 	.word	0x00a800a4
34018bb8:	00ac00aa 	.word	0x00ac00aa
34018bbc:	012e00ae 	.word	0x012e00ae
34018bc0:	00b200b0 	.word	0x00b200b0
34018bc4:	00b600b4 	.word	0x00b600b4
34018bc8:	00be00b8 	.word	0x00be00b8
34018bcc:	00c600c0 	.word	0x00c600c0
34018bd0:	00ca00c8 	.word	0x00ca00c8
34018bd4:	00ce00cc 	.word	0x00ce00cc
34018bd8:	00d600d2 	.word	0x00d600d2
34018bdc:	00da00d8 	.word	0x00da00d8
34018be0:	00de00dc 	.word	0x00de00dc
34018be4:	00e200e0 	.word	0x00e200e0
34018be8:	012e00e4 	.word	0x012e00e4
34018bec:	012e012e 	.word	0x012e012e
34018bf0:	012e012e 	.word	0x012e012e
34018bf4:	012e012e 	.word	0x012e012e
34018bf8:	00e8012e 	.word	0x00e8012e
34018bfc:	012e00ec 	.word	0x012e00ec
34018c00:	012e012e 	.word	0x012e012e
34018c04:	012e012e 	.word	0x012e012e
34018c08:	012e012e 	.word	0x012e012e
34018c0c:	012e012e 	.word	0x012e012e
34018c10:	012e012e 	.word	0x012e012e
34018c14:	012e012e 	.word	0x012e012e
34018c18:	010800ee 	.word	0x010800ee
34018c1c:	00f200f0 	.word	0x00f200f0
34018c20:	012e012e 	.word	0x012e012e
34018c24:	00f4012e 	.word	0x00f4012e
34018c28:	012e012e 	.word	0x012e012e
34018c2c:	00f6012e 	.word	0x00f6012e
34018c30:	012e012e 	.word	0x012e012e
34018c34:	012e00fa 	.word	0x012e00fa
34018c38:	00fc012e 	.word	0x00fc012e
34018c3c:	012e012e 	.word	0x012e012e
34018c40:	012e012e 	.word	0x012e012e
34018c44:	012e012e 	.word	0x012e012e
34018c48:	012e012e 	.word	0x012e012e
34018c4c:	012e012e 	.word	0x012e012e
34018c50:	012e00fe 	.word	0x012e00fe
34018c54:	01020100 	.word	0x01020100
34018c58:	012e0104 	.word	0x012e0104
34018c5c:	0126012e 	.word	0x0126012e
34018c60:	012e012e 	.word	0x012e012e
34018c64:	012e012e 	.word	0x012e012e
34018c68:	012e012e 	.word	0x012e012e
34018c6c:	012e012e 	.word	0x012e012e
34018c70:	01060114 	.word	0x01060114
34018c74:	010c010a 	.word	0x010c010a
34018c78:	0110010e 	.word	0x0110010e
34018c7c:	0112012e 	.word	0x0112012e
34018c80:	011a0116 	.word	0x011a0116
34018c84:	00c200ea 	.word	0x00c200ea
34018c88:	00ba012c 	.word	0x00ba012c
34018c8c:	00bc00d0 	.word	0x00bc00d0
34018c90:	00a600a0 	.word	0x00a600a0
34018c94:	00f8012a 	.word	0x00f8012a
34018c98:	0118012e 	.word	0x0118012e
34018c9c:	011e00c4 	.word	0x011e00c4
34018ca0:	012e011c 	.word	0x012e011c
34018ca4:	012e012e 	.word	0x012e012e
34018ca8:	012e012e 	.word	0x012e012e
34018cac:	012e00d4 	.word	0x012e00d4
34018cb0:	012e012e 	.word	0x012e012e
34018cb4:	012800e6 	.word	0x012800e6
34018cb8:	01220120 	.word	0x01220120
34018cbc:	0124      	.short	0x0124
34018cbe:	4b55      	ldr	r3, [pc, #340]	@ (34018e14 <_strerror_r+0x288>)
34018cc0:	4618      	mov	r0, r3
34018cc2:	bd10      	pop	{r4, pc}
34018cc4:	4b54      	ldr	r3, [pc, #336]	@ (34018e18 <_strerror_r+0x28c>)
34018cc6:	e7fb      	b.n	34018cc0 <_strerror_r+0x134>
34018cc8:	4b54      	ldr	r3, [pc, #336]	@ (34018e1c <_strerror_r+0x290>)
34018cca:	e7f9      	b.n	34018cc0 <_strerror_r+0x134>
34018ccc:	4b54      	ldr	r3, [pc, #336]	@ (34018e20 <_strerror_r+0x294>)
34018cce:	e7f7      	b.n	34018cc0 <_strerror_r+0x134>
34018cd0:	4b54      	ldr	r3, [pc, #336]	@ (34018e24 <_strerror_r+0x298>)
34018cd2:	e7f5      	b.n	34018cc0 <_strerror_r+0x134>
34018cd4:	4b54      	ldr	r3, [pc, #336]	@ (34018e28 <_strerror_r+0x29c>)
34018cd6:	e7f3      	b.n	34018cc0 <_strerror_r+0x134>
34018cd8:	4b54      	ldr	r3, [pc, #336]	@ (34018e2c <_strerror_r+0x2a0>)
34018cda:	e7f1      	b.n	34018cc0 <_strerror_r+0x134>
34018cdc:	4b54      	ldr	r3, [pc, #336]	@ (34018e30 <_strerror_r+0x2a4>)
34018cde:	e7ef      	b.n	34018cc0 <_strerror_r+0x134>
34018ce0:	4b54      	ldr	r3, [pc, #336]	@ (34018e34 <_strerror_r+0x2a8>)
34018ce2:	e7ed      	b.n	34018cc0 <_strerror_r+0x134>
34018ce4:	4b54      	ldr	r3, [pc, #336]	@ (34018e38 <_strerror_r+0x2ac>)
34018ce6:	e7eb      	b.n	34018cc0 <_strerror_r+0x134>
34018ce8:	4b54      	ldr	r3, [pc, #336]	@ (34018e3c <_strerror_r+0x2b0>)
34018cea:	e7e9      	b.n	34018cc0 <_strerror_r+0x134>
34018cec:	4b54      	ldr	r3, [pc, #336]	@ (34018e40 <_strerror_r+0x2b4>)
34018cee:	e7e7      	b.n	34018cc0 <_strerror_r+0x134>
34018cf0:	4b54      	ldr	r3, [pc, #336]	@ (34018e44 <_strerror_r+0x2b8>)
34018cf2:	e7e5      	b.n	34018cc0 <_strerror_r+0x134>
34018cf4:	4b54      	ldr	r3, [pc, #336]	@ (34018e48 <_strerror_r+0x2bc>)
34018cf6:	e7e3      	b.n	34018cc0 <_strerror_r+0x134>
34018cf8:	4b54      	ldr	r3, [pc, #336]	@ (34018e4c <_strerror_r+0x2c0>)
34018cfa:	e7e1      	b.n	34018cc0 <_strerror_r+0x134>
34018cfc:	4b54      	ldr	r3, [pc, #336]	@ (34018e50 <_strerror_r+0x2c4>)
34018cfe:	e7df      	b.n	34018cc0 <_strerror_r+0x134>
34018d00:	4b54      	ldr	r3, [pc, #336]	@ (34018e54 <_strerror_r+0x2c8>)
34018d02:	e7dd      	b.n	34018cc0 <_strerror_r+0x134>
34018d04:	4b54      	ldr	r3, [pc, #336]	@ (34018e58 <_strerror_r+0x2cc>)
34018d06:	e7db      	b.n	34018cc0 <_strerror_r+0x134>
34018d08:	4b54      	ldr	r3, [pc, #336]	@ (34018e5c <_strerror_r+0x2d0>)
34018d0a:	e7d9      	b.n	34018cc0 <_strerror_r+0x134>
34018d0c:	4b54      	ldr	r3, [pc, #336]	@ (34018e60 <_strerror_r+0x2d4>)
34018d0e:	e7d7      	b.n	34018cc0 <_strerror_r+0x134>
34018d10:	4b54      	ldr	r3, [pc, #336]	@ (34018e64 <_strerror_r+0x2d8>)
34018d12:	e7d5      	b.n	34018cc0 <_strerror_r+0x134>
34018d14:	4b54      	ldr	r3, [pc, #336]	@ (34018e68 <_strerror_r+0x2dc>)
34018d16:	e7d3      	b.n	34018cc0 <_strerror_r+0x134>
34018d18:	4b54      	ldr	r3, [pc, #336]	@ (34018e6c <_strerror_r+0x2e0>)
34018d1a:	e7d1      	b.n	34018cc0 <_strerror_r+0x134>
34018d1c:	4b54      	ldr	r3, [pc, #336]	@ (34018e70 <_strerror_r+0x2e4>)
34018d1e:	e7cf      	b.n	34018cc0 <_strerror_r+0x134>
34018d20:	4b54      	ldr	r3, [pc, #336]	@ (34018e74 <_strerror_r+0x2e8>)
34018d22:	e7cd      	b.n	34018cc0 <_strerror_r+0x134>
34018d24:	4b54      	ldr	r3, [pc, #336]	@ (34018e78 <_strerror_r+0x2ec>)
34018d26:	e7cb      	b.n	34018cc0 <_strerror_r+0x134>
34018d28:	4b54      	ldr	r3, [pc, #336]	@ (34018e7c <_strerror_r+0x2f0>)
34018d2a:	e7c9      	b.n	34018cc0 <_strerror_r+0x134>
34018d2c:	4b54      	ldr	r3, [pc, #336]	@ (34018e80 <_strerror_r+0x2f4>)
34018d2e:	e7c7      	b.n	34018cc0 <_strerror_r+0x134>
34018d30:	4b54      	ldr	r3, [pc, #336]	@ (34018e84 <_strerror_r+0x2f8>)
34018d32:	e7c5      	b.n	34018cc0 <_strerror_r+0x134>
34018d34:	4b54      	ldr	r3, [pc, #336]	@ (34018e88 <_strerror_r+0x2fc>)
34018d36:	e7c3      	b.n	34018cc0 <_strerror_r+0x134>
34018d38:	4b54      	ldr	r3, [pc, #336]	@ (34018e8c <_strerror_r+0x300>)
34018d3a:	e7c1      	b.n	34018cc0 <_strerror_r+0x134>
34018d3c:	4b54      	ldr	r3, [pc, #336]	@ (34018e90 <_strerror_r+0x304>)
34018d3e:	e7bf      	b.n	34018cc0 <_strerror_r+0x134>
34018d40:	4b54      	ldr	r3, [pc, #336]	@ (34018e94 <_strerror_r+0x308>)
34018d42:	e7bd      	b.n	34018cc0 <_strerror_r+0x134>
34018d44:	4b54      	ldr	r3, [pc, #336]	@ (34018e98 <_strerror_r+0x30c>)
34018d46:	e7bb      	b.n	34018cc0 <_strerror_r+0x134>
34018d48:	4b54      	ldr	r3, [pc, #336]	@ (34018e9c <_strerror_r+0x310>)
34018d4a:	e7b9      	b.n	34018cc0 <_strerror_r+0x134>
34018d4c:	4b54      	ldr	r3, [pc, #336]	@ (34018ea0 <_strerror_r+0x314>)
34018d4e:	e7b7      	b.n	34018cc0 <_strerror_r+0x134>
34018d50:	4b54      	ldr	r3, [pc, #336]	@ (34018ea4 <_strerror_r+0x318>)
34018d52:	e7b5      	b.n	34018cc0 <_strerror_r+0x134>
34018d54:	4b54      	ldr	r3, [pc, #336]	@ (34018ea8 <_strerror_r+0x31c>)
34018d56:	e7b3      	b.n	34018cc0 <_strerror_r+0x134>
34018d58:	4b54      	ldr	r3, [pc, #336]	@ (34018eac <_strerror_r+0x320>)
34018d5a:	e7b1      	b.n	34018cc0 <_strerror_r+0x134>
34018d5c:	4b54      	ldr	r3, [pc, #336]	@ (34018eb0 <_strerror_r+0x324>)
34018d5e:	e7af      	b.n	34018cc0 <_strerror_r+0x134>
34018d60:	4b54      	ldr	r3, [pc, #336]	@ (34018eb4 <_strerror_r+0x328>)
34018d62:	e7ad      	b.n	34018cc0 <_strerror_r+0x134>
34018d64:	4b54      	ldr	r3, [pc, #336]	@ (34018eb8 <_strerror_r+0x32c>)
34018d66:	e7ab      	b.n	34018cc0 <_strerror_r+0x134>
34018d68:	4b54      	ldr	r3, [pc, #336]	@ (34018ebc <_strerror_r+0x330>)
34018d6a:	e7a9      	b.n	34018cc0 <_strerror_r+0x134>
34018d6c:	4b54      	ldr	r3, [pc, #336]	@ (34018ec0 <_strerror_r+0x334>)
34018d6e:	e7a7      	b.n	34018cc0 <_strerror_r+0x134>
34018d70:	4b54      	ldr	r3, [pc, #336]	@ (34018ec4 <_strerror_r+0x338>)
34018d72:	e7a5      	b.n	34018cc0 <_strerror_r+0x134>
34018d74:	4b54      	ldr	r3, [pc, #336]	@ (34018ec8 <_strerror_r+0x33c>)
34018d76:	e7a3      	b.n	34018cc0 <_strerror_r+0x134>
34018d78:	4b54      	ldr	r3, [pc, #336]	@ (34018ecc <_strerror_r+0x340>)
34018d7a:	e7a1      	b.n	34018cc0 <_strerror_r+0x134>
34018d7c:	4b54      	ldr	r3, [pc, #336]	@ (34018ed0 <_strerror_r+0x344>)
34018d7e:	e79f      	b.n	34018cc0 <_strerror_r+0x134>
34018d80:	4b54      	ldr	r3, [pc, #336]	@ (34018ed4 <_strerror_r+0x348>)
34018d82:	e79d      	b.n	34018cc0 <_strerror_r+0x134>
34018d84:	4b54      	ldr	r3, [pc, #336]	@ (34018ed8 <_strerror_r+0x34c>)
34018d86:	e79b      	b.n	34018cc0 <_strerror_r+0x134>
34018d88:	4b54      	ldr	r3, [pc, #336]	@ (34018edc <_strerror_r+0x350>)
34018d8a:	e799      	b.n	34018cc0 <_strerror_r+0x134>
34018d8c:	4b54      	ldr	r3, [pc, #336]	@ (34018ee0 <_strerror_r+0x354>)
34018d8e:	e797      	b.n	34018cc0 <_strerror_r+0x134>
34018d90:	4b54      	ldr	r3, [pc, #336]	@ (34018ee4 <_strerror_r+0x358>)
34018d92:	e795      	b.n	34018cc0 <_strerror_r+0x134>
34018d94:	4b54      	ldr	r3, [pc, #336]	@ (34018ee8 <_strerror_r+0x35c>)
34018d96:	e793      	b.n	34018cc0 <_strerror_r+0x134>
34018d98:	4b54      	ldr	r3, [pc, #336]	@ (34018eec <_strerror_r+0x360>)
34018d9a:	e791      	b.n	34018cc0 <_strerror_r+0x134>
34018d9c:	4b54      	ldr	r3, [pc, #336]	@ (34018ef0 <_strerror_r+0x364>)
34018d9e:	e78f      	b.n	34018cc0 <_strerror_r+0x134>
34018da0:	4b54      	ldr	r3, [pc, #336]	@ (34018ef4 <_strerror_r+0x368>)
34018da2:	e78d      	b.n	34018cc0 <_strerror_r+0x134>
34018da4:	4b54      	ldr	r3, [pc, #336]	@ (34018ef8 <_strerror_r+0x36c>)
34018da6:	e78b      	b.n	34018cc0 <_strerror_r+0x134>
34018da8:	4b54      	ldr	r3, [pc, #336]	@ (34018efc <_strerror_r+0x370>)
34018daa:	e789      	b.n	34018cc0 <_strerror_r+0x134>
34018dac:	4b54      	ldr	r3, [pc, #336]	@ (34018f00 <_strerror_r+0x374>)
34018dae:	e787      	b.n	34018cc0 <_strerror_r+0x134>
34018db0:	4b54      	ldr	r3, [pc, #336]	@ (34018f04 <_strerror_r+0x378>)
34018db2:	e785      	b.n	34018cc0 <_strerror_r+0x134>
34018db4:	4b54      	ldr	r3, [pc, #336]	@ (34018f08 <_strerror_r+0x37c>)
34018db6:	e783      	b.n	34018cc0 <_strerror_r+0x134>
34018db8:	4b54      	ldr	r3, [pc, #336]	@ (34018f0c <_strerror_r+0x380>)
34018dba:	e781      	b.n	34018cc0 <_strerror_r+0x134>
34018dbc:	4b54      	ldr	r3, [pc, #336]	@ (34018f10 <_strerror_r+0x384>)
34018dbe:	e77f      	b.n	34018cc0 <_strerror_r+0x134>
34018dc0:	4b54      	ldr	r3, [pc, #336]	@ (34018f14 <_strerror_r+0x388>)
34018dc2:	e77d      	b.n	34018cc0 <_strerror_r+0x134>
34018dc4:	4b54      	ldr	r3, [pc, #336]	@ (34018f18 <_strerror_r+0x38c>)
34018dc6:	e77b      	b.n	34018cc0 <_strerror_r+0x134>
34018dc8:	4b54      	ldr	r3, [pc, #336]	@ (34018f1c <_strerror_r+0x390>)
34018dca:	e779      	b.n	34018cc0 <_strerror_r+0x134>
34018dcc:	4b54      	ldr	r3, [pc, #336]	@ (34018f20 <_strerror_r+0x394>)
34018dce:	e777      	b.n	34018cc0 <_strerror_r+0x134>
34018dd0:	4b54      	ldr	r3, [pc, #336]	@ (34018f24 <_strerror_r+0x398>)
34018dd2:	e775      	b.n	34018cc0 <_strerror_r+0x134>
34018dd4:	4b54      	ldr	r3, [pc, #336]	@ (34018f28 <_strerror_r+0x39c>)
34018dd6:	e773      	b.n	34018cc0 <_strerror_r+0x134>
34018dd8:	4b54      	ldr	r3, [pc, #336]	@ (34018f2c <_strerror_r+0x3a0>)
34018dda:	e771      	b.n	34018cc0 <_strerror_r+0x134>
34018ddc:	4b54      	ldr	r3, [pc, #336]	@ (34018f30 <_strerror_r+0x3a4>)
34018dde:	e76f      	b.n	34018cc0 <_strerror_r+0x134>
34018de0:	4b54      	ldr	r3, [pc, #336]	@ (34018f34 <_strerror_r+0x3a8>)
34018de2:	e76d      	b.n	34018cc0 <_strerror_r+0x134>
34018de4:	4b54      	ldr	r3, [pc, #336]	@ (34018f38 <_strerror_r+0x3ac>)
34018de6:	e76b      	b.n	34018cc0 <_strerror_r+0x134>
34018de8:	4b54      	ldr	r3, [pc, #336]	@ (34018f3c <_strerror_r+0x3b0>)
34018dea:	e769      	b.n	34018cc0 <_strerror_r+0x134>
34018dec:	4b54      	ldr	r3, [pc, #336]	@ (34018f40 <_strerror_r+0x3b4>)
34018dee:	e767      	b.n	34018cc0 <_strerror_r+0x134>
34018df0:	4b54      	ldr	r3, [pc, #336]	@ (34018f44 <_strerror_r+0x3b8>)
34018df2:	e765      	b.n	34018cc0 <_strerror_r+0x134>
34018df4:	4b54      	ldr	r3, [pc, #336]	@ (34018f48 <_strerror_r+0x3bc>)
34018df6:	e763      	b.n	34018cc0 <_strerror_r+0x134>
34018df8:	4b54      	ldr	r3, [pc, #336]	@ (34018f4c <_strerror_r+0x3c0>)
34018dfa:	e761      	b.n	34018cc0 <_strerror_r+0x134>
34018dfc:	2a00      	cmp	r2, #0
34018dfe:	bf08      	it	eq
34018e00:	4622      	moveq	r2, r4
34018e02:	f000 f8b3 	bl	34018f6c <_user_strerror>
34018e06:	4b52      	ldr	r3, [pc, #328]	@ (34018f50 <_strerror_r+0x3c4>)
34018e08:	2800      	cmp	r0, #0
34018e0a:	bf18      	it	ne
34018e0c:	4603      	movne	r3, r0
34018e0e:	e757      	b.n	34018cc0 <_strerror_r+0x134>
34018e10:	4b50      	ldr	r3, [pc, #320]	@ (34018f54 <_strerror_r+0x3c8>)
34018e12:	e755      	b.n	34018cc0 <_strerror_r+0x134>
34018e14:	3401dfb7 	.word	0x3401dfb7
34018e18:	3401dfc9 	.word	0x3401dfc9
34018e1c:	3401dfe3 	.word	0x3401dfe3
34018e20:	3401dff3 	.word	0x3401dff3
34018e24:	3401e00b 	.word	0x3401e00b
34018e28:	3401e015 	.word	0x3401e015
34018e2c:	3401e02f 	.word	0x3401e02f
34018e30:	3401e041 	.word	0x3401e041
34018e34:	3401e053 	.word	0x3401e053
34018e38:	3401e06c 	.word	0x3401e06c
34018e3c:	3401e07c 	.word	0x3401e07c
34018e40:	3401e088 	.word	0x3401e088
34018e44:	3401e0a5 	.word	0x3401e0a5
34018e48:	3401e0b7 	.word	0x3401e0b7
34018e4c:	3401e0c8 	.word	0x3401e0c8
34018e50:	3401e0da 	.word	0x3401e0da
34018e54:	3401e0e6 	.word	0x3401e0e6
34018e58:	3401e0fe 	.word	0x3401e0fe
34018e5c:	3401e10a 	.word	0x3401e10a
34018e60:	3401e11c 	.word	0x3401e11c
34018e64:	3401e12b 	.word	0x3401e12b
34018e68:	3401e13b 	.word	0x3401e13b
34018e6c:	3401e148 	.word	0x3401e148
34018e70:	3401e167 	.word	0x3401e167
34018e74:	3401e176 	.word	0x3401e176
34018e78:	3401e187 	.word	0x3401e187
34018e7c:	3401e1ab 	.word	0x3401e1ab
34018e80:	3401e1c9 	.word	0x3401e1c9
34018e84:	3401e1e7 	.word	0x3401e1e7
34018e88:	3401e207 	.word	0x3401e207
34018e8c:	3401e21e 	.word	0x3401e21e
34018e90:	3401e22d 	.word	0x3401e22d
34018e94:	3401e23c 	.word	0x3401e23c
34018e98:	3401e250 	.word	0x3401e250
34018e9c:	3401e268 	.word	0x3401e268
34018ea0:	3401e276 	.word	0x3401e276
34018ea4:	3401e283 	.word	0x3401e283
34018ea8:	3401e299 	.word	0x3401e299
34018eac:	3401e2a8 	.word	0x3401e2a8
34018eb0:	3401e2b4 	.word	0x3401e2b4
34018eb4:	3401e2e3 	.word	0x3401e2e3
34018eb8:	3401e2f4 	.word	0x3401e2f4
34018ebc:	3401e30f 	.word	0x3401e30f
34018ec0:	3401e322 	.word	0x3401e322
34018ec4:	3401e338 	.word	0x3401e338
34018ec8:	3401e341 	.word	0x3401e341
34018ecc:	3401e358 	.word	0x3401e358
34018ed0:	3401e360 	.word	0x3401e360
34018ed4:	3401e36d 	.word	0x3401e36d
34018ed8:	3401e382 	.word	0x3401e382
34018edc:	3401e396 	.word	0x3401e396
34018ee0:	3401e3ae 	.word	0x3401e3ae
34018ee4:	3401e3bd 	.word	0x3401e3bd
34018ee8:	3401e3ce 	.word	0x3401e3ce
34018eec:	3401e3e1 	.word	0x3401e3e1
34018ef0:	3401e3ed 	.word	0x3401e3ed
34018ef4:	3401e406 	.word	0x3401e406
34018ef8:	3401e41a 	.word	0x3401e41a
34018efc:	3401e435 	.word	0x3401e435
34018f00:	3401e44d 	.word	0x3401e44d
34018f04:	3401e467 	.word	0x3401e467
34018f08:	3401e46f 	.word	0x3401e46f
34018f0c:	3401e49f 	.word	0x3401e49f
34018f10:	3401e4be 	.word	0x3401e4be
34018f14:	3401e4dd 	.word	0x3401e4dd
34018f18:	3401e4f4 	.word	0x3401e4f4
34018f1c:	3401e507 	.word	0x3401e507
34018f20:	3401e520 	.word	0x3401e520
34018f24:	3401e537 	.word	0x3401e537
34018f28:	3401e54d 	.word	0x3401e54d
34018f2c:	3401e56e 	.word	0x3401e56e
34018f30:	3401e586 	.word	0x3401e586
34018f34:	3401e5a2 	.word	0x3401e5a2
34018f38:	3401e5b5 	.word	0x3401e5b5
34018f3c:	3401e5cb 	.word	0x3401e5cb
34018f40:	3401e5df 	.word	0x3401e5df
34018f44:	3401e601 	.word	0x3401e601
34018f48:	3401e627 	.word	0x3401e627
34018f4c:	3401e638 	.word	0x3401e638
34018f50:	3401d059 	.word	0x3401d059
34018f54:	3401dfbf 	.word	0x3401dfbf

34018f58 <strerror>:
34018f58:	4601      	mov	r1, r0
34018f5a:	2300      	movs	r3, #0
34018f5c:	4802      	ldr	r0, [pc, #8]	@ (34018f68 <strerror+0x10>)
34018f5e:	461a      	mov	r2, r3
34018f60:	6800      	ldr	r0, [r0, #0]
34018f62:	f7ff be13 	b.w	34018b8c <_strerror_r>
34018f66:	bf00      	nop
34018f68:	3403eddc 	.word	0x3403eddc

34018f6c <_user_strerror>:
34018f6c:	2000      	movs	r0, #0
34018f6e:	4770      	bx	lr

34018f70 <_localeconv_r>:
34018f70:	4800      	ldr	r0, [pc, #0]	@ (34018f74 <_localeconv_r+0x4>)
34018f72:	4770      	bx	lr
34018f74:	3403ef1c 	.word	0x3403ef1c

34018f78 <_close_r>:
34018f78:	b538      	push	{r3, r4, r5, lr}
34018f7a:	2300      	movs	r3, #0
34018f7c:	4d05      	ldr	r5, [pc, #20]	@ (34018f94 <_close_r+0x1c>)
34018f7e:	4604      	mov	r4, r0
34018f80:	4608      	mov	r0, r1
34018f82:	602b      	str	r3, [r5, #0]
34018f84:	f7e9 fc73 	bl	3400286e <_close>
34018f88:	1c43      	adds	r3, r0, #1
34018f8a:	d102      	bne.n	34018f92 <_close_r+0x1a>
34018f8c:	682b      	ldr	r3, [r5, #0]
34018f8e:	b103      	cbz	r3, 34018f92 <_close_r+0x1a>
34018f90:	6023      	str	r3, [r4, #0]
34018f92:	bd38      	pop	{r3, r4, r5, pc}
34018f94:	3404470c 	.word	0x3404470c

34018f98 <_lseek_r>:
34018f98:	b538      	push	{r3, r4, r5, lr}
34018f9a:	4604      	mov	r4, r0
34018f9c:	4d06      	ldr	r5, [pc, #24]	@ (34018fb8 <_lseek_r+0x20>)
34018f9e:	4608      	mov	r0, r1
34018fa0:	4611      	mov	r1, r2
34018fa2:	2200      	movs	r2, #0
34018fa4:	602a      	str	r2, [r5, #0]
34018fa6:	461a      	mov	r2, r3
34018fa8:	f7e9 fc6b 	bl	34002882 <_lseek>
34018fac:	1c43      	adds	r3, r0, #1
34018fae:	d102      	bne.n	34018fb6 <_lseek_r+0x1e>
34018fb0:	682b      	ldr	r3, [r5, #0]
34018fb2:	b103      	cbz	r3, 34018fb6 <_lseek_r+0x1e>
34018fb4:	6023      	str	r3, [r4, #0]
34018fb6:	bd38      	pop	{r3, r4, r5, pc}
34018fb8:	3404470c 	.word	0x3404470c

34018fbc <_read_r>:
34018fbc:	b538      	push	{r3, r4, r5, lr}
34018fbe:	4604      	mov	r4, r0
34018fc0:	4d06      	ldr	r5, [pc, #24]	@ (34018fdc <_read_r+0x20>)
34018fc2:	4608      	mov	r0, r1
34018fc4:	4611      	mov	r1, r2
34018fc6:	2200      	movs	r2, #0
34018fc8:	602a      	str	r2, [r5, #0]
34018fca:	461a      	mov	r2, r3
34018fcc:	f7e9 fc33 	bl	34002836 <_read>
34018fd0:	1c43      	adds	r3, r0, #1
34018fd2:	d102      	bne.n	34018fda <_read_r+0x1e>
34018fd4:	682b      	ldr	r3, [r5, #0]
34018fd6:	b103      	cbz	r3, 34018fda <_read_r+0x1e>
34018fd8:	6023      	str	r3, [r4, #0]
34018fda:	bd38      	pop	{r3, r4, r5, pc}
34018fdc:	3404470c 	.word	0x3404470c

34018fe0 <_sbrk_r>:
34018fe0:	b538      	push	{r3, r4, r5, lr}
34018fe2:	2300      	movs	r3, #0
34018fe4:	4d05      	ldr	r5, [pc, #20]	@ (34018ffc <_sbrk_r+0x1c>)
34018fe6:	4604      	mov	r4, r0
34018fe8:	4608      	mov	r0, r1
34018fea:	602b      	str	r3, [r5, #0]
34018fec:	f002 fd70 	bl	3401bad0 <_sbrk>
34018ff0:	1c43      	adds	r3, r0, #1
34018ff2:	d102      	bne.n	34018ffa <_sbrk_r+0x1a>
34018ff4:	682b      	ldr	r3, [r5, #0]
34018ff6:	b103      	cbz	r3, 34018ffa <_sbrk_r+0x1a>
34018ff8:	6023      	str	r3, [r4, #0]
34018ffa:	bd38      	pop	{r3, r4, r5, pc}
34018ffc:	3404470c 	.word	0x3404470c

34019000 <_write_r>:
34019000:	b538      	push	{r3, r4, r5, lr}
34019002:	4604      	mov	r4, r0
34019004:	4d06      	ldr	r5, [pc, #24]	@ (34019020 <_write_r+0x20>)
34019006:	4608      	mov	r0, r1
34019008:	4611      	mov	r1, r2
3401900a:	2200      	movs	r2, #0
3401900c:	602a      	str	r2, [r5, #0]
3401900e:	461a      	mov	r2, r3
34019010:	f7e9 fc1f 	bl	34002852 <_write>
34019014:	1c43      	adds	r3, r0, #1
34019016:	d102      	bne.n	3401901e <_write_r+0x1e>
34019018:	682b      	ldr	r3, [r5, #0]
3401901a:	b103      	cbz	r3, 3401901e <_write_r+0x1e>
3401901c:	6023      	str	r3, [r4, #0]
3401901e:	bd38      	pop	{r3, r4, r5, pc}
34019020:	3404470c 	.word	0x3404470c

34019024 <__errno>:
34019024:	4b01      	ldr	r3, [pc, #4]	@ (3401902c <__errno+0x8>)
34019026:	6818      	ldr	r0, [r3, #0]
34019028:	4770      	bx	lr
3401902a:	bf00      	nop
3401902c:	3403eddc 	.word	0x3403eddc

34019030 <__libc_init_array>:
34019030:	b570      	push	{r4, r5, r6, lr}
34019032:	4d0d      	ldr	r5, [pc, #52]	@ (34019068 <__libc_init_array+0x38>)
34019034:	2600      	movs	r6, #0
34019036:	4c0d      	ldr	r4, [pc, #52]	@ (3401906c <__libc_init_array+0x3c>)
34019038:	1b64      	subs	r4, r4, r5
3401903a:	10a4      	asrs	r4, r4, #2
3401903c:	42a6      	cmp	r6, r4
3401903e:	d109      	bne.n	34019054 <__libc_init_array+0x24>
34019040:	4d0b      	ldr	r5, [pc, #44]	@ (34019070 <__libc_init_array+0x40>)
34019042:	2600      	movs	r6, #0
34019044:	4c0b      	ldr	r4, [pc, #44]	@ (34019074 <__libc_init_array+0x44>)
34019046:	f002 fd51 	bl	3401baec <_init>
3401904a:	1b64      	subs	r4, r4, r5
3401904c:	10a4      	asrs	r4, r4, #2
3401904e:	42a6      	cmp	r6, r4
34019050:	d105      	bne.n	3401905e <__libc_init_array+0x2e>
34019052:	bd70      	pop	{r4, r5, r6, pc}
34019054:	f855 3b04 	ldr.w	r3, [r5], #4
34019058:	3601      	adds	r6, #1
3401905a:	4798      	blx	r3
3401905c:	e7ee      	b.n	3401903c <__libc_init_array+0xc>
3401905e:	f855 3b04 	ldr.w	r3, [r5], #4
34019062:	3601      	adds	r6, #1
34019064:	4798      	blx	r3
34019066:	e7f2      	b.n	3401904e <__libc_init_array+0x1e>
34019068:	3403ec44 	.word	0x3403ec44
3401906c:	3403ec44 	.word	0x3403ec44
34019070:	3403ec44 	.word	0x3403ec44
34019074:	3403ec48 	.word	0x3403ec48

34019078 <__retarget_lock_init_recursive>:
34019078:	4770      	bx	lr

3401907a <__retarget_lock_acquire_recursive>:
3401907a:	4770      	bx	lr

3401907c <__retarget_lock_release_recursive>:
3401907c:	4770      	bx	lr

3401907e <strcpy>:
3401907e:	4603      	mov	r3, r0
34019080:	f811 2b01 	ldrb.w	r2, [r1], #1
34019084:	f803 2b01 	strb.w	r2, [r3], #1
34019088:	2a00      	cmp	r2, #0
3401908a:	d1f9      	bne.n	34019080 <strcpy+0x2>
3401908c:	4770      	bx	lr

3401908e <memchr>:
3401908e:	b2c9      	uxtb	r1, r1
34019090:	4603      	mov	r3, r0
34019092:	4402      	add	r2, r0
34019094:	b510      	push	{r4, lr}
34019096:	4293      	cmp	r3, r2
34019098:	4618      	mov	r0, r3
3401909a:	d101      	bne.n	340190a0 <memchr+0x12>
3401909c:	2000      	movs	r0, #0
3401909e:	e003      	b.n	340190a8 <memchr+0x1a>
340190a0:	7804      	ldrb	r4, [r0, #0]
340190a2:	3301      	adds	r3, #1
340190a4:	428c      	cmp	r4, r1
340190a6:	d1f6      	bne.n	34019096 <memchr+0x8>
340190a8:	bd10      	pop	{r4, pc}

340190aa <memcpy>:
340190aa:	440a      	add	r2, r1
340190ac:	1e43      	subs	r3, r0, #1
340190ae:	4291      	cmp	r1, r2
340190b0:	d100      	bne.n	340190b4 <memcpy+0xa>
340190b2:	4770      	bx	lr
340190b4:	b510      	push	{r4, lr}
340190b6:	f811 4b01 	ldrb.w	r4, [r1], #1
340190ba:	4291      	cmp	r1, r2
340190bc:	f803 4f01 	strb.w	r4, [r3, #1]!
340190c0:	d1f9      	bne.n	340190b6 <memcpy+0xc>
340190c2:	bd10      	pop	{r4, pc}

340190c4 <abort>:
340190c4:	2006      	movs	r0, #6
340190c6:	b508      	push	{r3, lr}
340190c8:	f001 fd94 	bl	3401abf4 <raise>
340190cc:	2001      	movs	r0, #1
340190ce:	f7e9 fbac 	bl	3400282a <_exit>

340190d2 <quorem>:
340190d2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340190d6:	6903      	ldr	r3, [r0, #16]
340190d8:	4607      	mov	r7, r0
340190da:	690c      	ldr	r4, [r1, #16]
340190dc:	42a3      	cmp	r3, r4
340190de:	f2c0 8083 	blt.w	340191e8 <quorem+0x116>
340190e2:	3c01      	subs	r4, #1
340190e4:	f100 0514 	add.w	r5, r0, #20
340190e8:	f101 0814 	add.w	r8, r1, #20
340190ec:	00a3      	lsls	r3, r4, #2
340190ee:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
340190f2:	eb08 0984 	add.w	r9, r8, r4, lsl #2
340190f6:	9300      	str	r3, [sp, #0]
340190f8:	eb05 0384 	add.w	r3, r5, r4, lsl #2
340190fc:	9301      	str	r3, [sp, #4]
340190fe:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
34019102:	3301      	adds	r3, #1
34019104:	429a      	cmp	r2, r3
34019106:	fbb2 f6f3 	udiv	r6, r2, r3
3401910a:	d331      	bcc.n	34019170 <quorem+0x9e>
3401910c:	f04f 0a00 	mov.w	sl, #0
34019110:	46c4      	mov	ip, r8
34019112:	46ae      	mov	lr, r5
34019114:	46d3      	mov	fp, sl
34019116:	f85c 3b04 	ldr.w	r3, [ip], #4
3401911a:	b298      	uxth	r0, r3
3401911c:	45e1      	cmp	r9, ip
3401911e:	ea4f 4313 	mov.w	r3, r3, lsr #16
34019122:	fb06 a000 	mla	r0, r6, r0, sl
34019126:	ea4f 4210 	mov.w	r2, r0, lsr #16
3401912a:	b280      	uxth	r0, r0
3401912c:	fb06 2303 	mla	r3, r6, r3, r2
34019130:	f8de 2000 	ldr.w	r2, [lr]
34019134:	b292      	uxth	r2, r2
34019136:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401913a:	eba2 0200 	sub.w	r2, r2, r0
3401913e:	b29b      	uxth	r3, r3
34019140:	f8de 0000 	ldr.w	r0, [lr]
34019144:	445a      	add	r2, fp
34019146:	ebc3 4322 	rsb	r3, r3, r2, asr #16
3401914a:	b292      	uxth	r2, r2
3401914c:	eb03 4310 	add.w	r3, r3, r0, lsr #16
34019150:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
34019154:	ea4f 4b23 	mov.w	fp, r3, asr #16
34019158:	f84e 2b04 	str.w	r2, [lr], #4
3401915c:	d2db      	bcs.n	34019116 <quorem+0x44>
3401915e:	9b00      	ldr	r3, [sp, #0]
34019160:	58eb      	ldr	r3, [r5, r3]
34019162:	b92b      	cbnz	r3, 34019170 <quorem+0x9e>
34019164:	9b01      	ldr	r3, [sp, #4]
34019166:	3b04      	subs	r3, #4
34019168:	429d      	cmp	r5, r3
3401916a:	461a      	mov	r2, r3
3401916c:	d330      	bcc.n	340191d0 <quorem+0xfe>
3401916e:	613c      	str	r4, [r7, #16]
34019170:	4638      	mov	r0, r7
34019172:	f001 f85b 	bl	3401a22c <__mcmp>
34019176:	2800      	cmp	r0, #0
34019178:	db26      	blt.n	340191c8 <quorem+0xf6>
3401917a:	4629      	mov	r1, r5
3401917c:	2000      	movs	r0, #0
3401917e:	f858 2b04 	ldr.w	r2, [r8], #4
34019182:	f8d1 c000 	ldr.w	ip, [r1]
34019186:	fa1f fe82 	uxth.w	lr, r2
3401918a:	45c1      	cmp	r9, r8
3401918c:	fa1f f38c 	uxth.w	r3, ip
34019190:	ea4f 4212 	mov.w	r2, r2, lsr #16
34019194:	eba3 030e 	sub.w	r3, r3, lr
34019198:	4403      	add	r3, r0
3401919a:	ebc2 4223 	rsb	r2, r2, r3, asr #16
3401919e:	b29b      	uxth	r3, r3
340191a0:	eb02 421c 	add.w	r2, r2, ip, lsr #16
340191a4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
340191a8:	ea4f 4022 	mov.w	r0, r2, asr #16
340191ac:	f841 3b04 	str.w	r3, [r1], #4
340191b0:	d2e5      	bcs.n	3401917e <quorem+0xac>
340191b2:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
340191b6:	eb05 0384 	add.w	r3, r5, r4, lsl #2
340191ba:	b922      	cbnz	r2, 340191c6 <quorem+0xf4>
340191bc:	3b04      	subs	r3, #4
340191be:	429d      	cmp	r5, r3
340191c0:	461a      	mov	r2, r3
340191c2:	d30b      	bcc.n	340191dc <quorem+0x10a>
340191c4:	613c      	str	r4, [r7, #16]
340191c6:	3601      	adds	r6, #1
340191c8:	4630      	mov	r0, r6
340191ca:	b003      	add	sp, #12
340191cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340191d0:	6812      	ldr	r2, [r2, #0]
340191d2:	3b04      	subs	r3, #4
340191d4:	2a00      	cmp	r2, #0
340191d6:	d1ca      	bne.n	3401916e <quorem+0x9c>
340191d8:	3c01      	subs	r4, #1
340191da:	e7c5      	b.n	34019168 <quorem+0x96>
340191dc:	6812      	ldr	r2, [r2, #0]
340191de:	3b04      	subs	r3, #4
340191e0:	2a00      	cmp	r2, #0
340191e2:	d1ef      	bne.n	340191c4 <quorem+0xf2>
340191e4:	3c01      	subs	r4, #1
340191e6:	e7ea      	b.n	340191be <quorem+0xec>
340191e8:	2000      	movs	r0, #0
340191ea:	e7ee      	b.n	340191ca <quorem+0xf8>
340191ec:	0000      	movs	r0, r0
	...

340191f0 <_dtoa_r>:
340191f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340191f4:	69c7      	ldr	r7, [r0, #28]
340191f6:	4681      	mov	r9, r0
340191f8:	ed2d 8b02 	vpush	{d8}
340191fc:	b091      	sub	sp, #68	@ 0x44
340191fe:	ec55 4b10 	vmov	r4, r5, d0
34019202:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
34019204:	9107      	str	r1, [sp, #28]
34019206:	9209      	str	r2, [sp, #36]	@ 0x24
34019208:	930d      	str	r3, [sp, #52]	@ 0x34
3401920a:	ed8d 0b02 	vstr	d0, [sp, #8]
3401920e:	b97f      	cbnz	r7, 34019230 <_dtoa_r+0x40>
34019210:	2010      	movs	r0, #16
34019212:	f7fe fb6f 	bl	340178f4 <malloc>
34019216:	4602      	mov	r2, r0
34019218:	f8c9 001c 	str.w	r0, [r9, #28]
3401921c:	b920      	cbnz	r0, 34019228 <_dtoa_r+0x38>
3401921e:	4ba0      	ldr	r3, [pc, #640]	@ (340194a0 <_dtoa_r+0x2b0>)
34019220:	21ef      	movs	r1, #239	@ 0xef
34019222:	48a0      	ldr	r0, [pc, #640]	@ (340194a4 <_dtoa_r+0x2b4>)
34019224:	f7fe fb48 	bl	340178b8 <__assert_func>
34019228:	e9c0 7701 	strd	r7, r7, [r0, #4]
3401922c:	6007      	str	r7, [r0, #0]
3401922e:	60c7      	str	r7, [r0, #12]
34019230:	f8d9 301c 	ldr.w	r3, [r9, #28]
34019234:	6819      	ldr	r1, [r3, #0]
34019236:	b159      	cbz	r1, 34019250 <_dtoa_r+0x60>
34019238:	685a      	ldr	r2, [r3, #4]
3401923a:	2301      	movs	r3, #1
3401923c:	4648      	mov	r0, r9
3401923e:	4093      	lsls	r3, r2
34019240:	604a      	str	r2, [r1, #4]
34019242:	608b      	str	r3, [r1, #8]
34019244:	f000 fdbc 	bl	34019dc0 <_Bfree>
34019248:	f8d9 301c 	ldr.w	r3, [r9, #28]
3401924c:	2200      	movs	r2, #0
3401924e:	601a      	str	r2, [r3, #0]
34019250:	1e2b      	subs	r3, r5, #0
34019252:	bfb7      	itett	lt
34019254:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
34019258:	2300      	movge	r3, #0
3401925a:	2201      	movlt	r2, #1
3401925c:	9303      	strlt	r3, [sp, #12]
3401925e:	bfac      	ite	ge
34019260:	6033      	strge	r3, [r6, #0]
34019262:	6032      	strlt	r2, [r6, #0]
34019264:	4b90      	ldr	r3, [pc, #576]	@ (340194a8 <_dtoa_r+0x2b8>)
34019266:	9e03      	ldr	r6, [sp, #12]
34019268:	43b3      	bics	r3, r6
3401926a:	d110      	bne.n	3401928e <_dtoa_r+0x9e>
3401926c:	f242 730f 	movw	r3, #9999	@ 0x270f
34019270:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
34019272:	6013      	str	r3, [r2, #0]
34019274:	f3c6 0313 	ubfx	r3, r6, #0, #20
34019278:	4323      	orrs	r3, r4
3401927a:	f000 84e6 	beq.w	34019c4a <_dtoa_r+0xa5a>
3401927e:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34019280:	4f8a      	ldr	r7, [pc, #552]	@ (340194ac <_dtoa_r+0x2bc>)
34019282:	2b00      	cmp	r3, #0
34019284:	f000 84e8 	beq.w	34019c58 <_dtoa_r+0xa68>
34019288:	1cfb      	adds	r3, r7, #3
3401928a:	f000 bce3 	b.w	34019c54 <_dtoa_r+0xa64>
3401928e:	ed9d 8b02 	vldr	d8, [sp, #8]
34019292:	eeb5 8b40 	vcmp.f64	d8, #0.0
34019296:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401929a:	d10a      	bne.n	340192b2 <_dtoa_r+0xc2>
3401929c:	2301      	movs	r3, #1
3401929e:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
340192a0:	6013      	str	r3, [r2, #0]
340192a2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
340192a4:	b113      	cbz	r3, 340192ac <_dtoa_r+0xbc>
340192a6:	4b82      	ldr	r3, [pc, #520]	@ (340194b0 <_dtoa_r+0x2c0>)
340192a8:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
340192aa:	6013      	str	r3, [r2, #0]
340192ac:	4f81      	ldr	r7, [pc, #516]	@ (340194b4 <_dtoa_r+0x2c4>)
340192ae:	f000 bcd3 	b.w	34019c58 <_dtoa_r+0xa68>
340192b2:	aa0e      	add	r2, sp, #56	@ 0x38
340192b4:	eeb0 0b48 	vmov.f64	d0, d8
340192b8:	a90f      	add	r1, sp, #60	@ 0x3c
340192ba:	4648      	mov	r0, r9
340192bc:	f001 f86a 	bl	3401a394 <__d2b>
340192c0:	f3c6 530a 	ubfx	r3, r6, #20, #11
340192c4:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340192c6:	9001      	str	r0, [sp, #4]
340192c8:	2b00      	cmp	r3, #0
340192ca:	d045      	beq.n	34019358 <_dtoa_r+0x168>
340192cc:	ee18 1a90 	vmov	r1, s17
340192d0:	eeb0 7b48 	vmov.f64	d7, d8
340192d4:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
340192d8:	2500      	movs	r5, #0
340192da:	f3c1 0113 	ubfx	r1, r1, #0, #20
340192de:	f041 517f 	orr.w	r1, r1, #1069547520	@ 0x3fc00000
340192e2:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
340192e6:	eeb7 6b08 	vmov.f64	d6, #120	@ 0x3fc00000  1.5
340192ea:	ee07 1a90 	vmov	s15, r1
340192ee:	ed9f 5b66 	vldr	d5, [pc, #408]	@ 34019488 <_dtoa_r+0x298>
340192f2:	ee37 7b46 	vsub.f64	d7, d7, d6
340192f6:	ed9f 6b66 	vldr	d6, [pc, #408]	@ 34019490 <_dtoa_r+0x2a0>
340192fa:	eea7 6b05 	vfma.f64	d6, d7, d5
340192fe:	ee07 3a90 	vmov	s15, r3
34019302:	eeb8 4be7 	vcvt.f64.s32	d4, s15
34019306:	ed9f 5b64 	vldr	d5, [pc, #400]	@ 34019498 <_dtoa_r+0x2a8>
3401930a:	eeb0 7b46 	vmov.f64	d7, d6
3401930e:	eea4 7b05 	vfma.f64	d7, d4, d5
34019312:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
34019316:	eefd 6bc7 	vcvt.s32.f64	s13, d7
3401931a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401931e:	ee16 8a90 	vmov	r8, s13
34019322:	d508      	bpl.n	34019336 <_dtoa_r+0x146>
34019324:	eeb8 6be6 	vcvt.f64.s32	d6, s13
34019328:	eeb4 6b47 	vcmp.f64	d6, d7
3401932c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019330:	bf18      	it	ne
34019332:	f108 38ff 	addne.w	r8, r8, #4294967295
34019336:	f1b8 0f16 	cmp.w	r8, #22
3401933a:	d82d      	bhi.n	34019398 <_dtoa_r+0x1a8>
3401933c:	495e      	ldr	r1, [pc, #376]	@ (340194b8 <_dtoa_r+0x2c8>)
3401933e:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
34019342:	ed91 7b00 	vldr	d7, [r1]
34019346:	eeb4 8bc7 	vcmpe.f64	d8, d7
3401934a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401934e:	d501      	bpl.n	34019354 <_dtoa_r+0x164>
34019350:	f108 38ff 	add.w	r8, r8, #4294967295
34019354:	2100      	movs	r1, #0
34019356:	e020      	b.n	3401939a <_dtoa_r+0x1aa>
34019358:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
3401935a:	2501      	movs	r5, #1
3401935c:	4413      	add	r3, r2
3401935e:	f203 4132 	addw	r1, r3, #1074	@ 0x432
34019362:	2920      	cmp	r1, #32
34019364:	bfc9      	itett	gt
34019366:	f1c1 0140 	rsbgt	r1, r1, #64	@ 0x40
3401936a:	f1c1 0120 	rsble	r1, r1, #32
3401936e:	408e      	lslgt	r6, r1
34019370:	f203 4112 	addwgt	r1, r3, #1042	@ 0x412
34019374:	bfd8      	it	le
34019376:	fa04 f101 	lslle.w	r1, r4, r1
3401937a:	f103 33ff 	add.w	r3, r3, #4294967295
3401937e:	bfc4      	itt	gt
34019380:	fa24 f101 	lsrgt.w	r1, r4, r1
34019384:	4331      	orrgt	r1, r6
34019386:	ee07 1a90 	vmov	s15, r1
3401938a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401938e:	ee17 1a90 	vmov	r1, s15
34019392:	f1a1 71f8 	sub.w	r1, r1, #32505856	@ 0x1f00000
34019396:	e7a6      	b.n	340192e6 <_dtoa_r+0xf6>
34019398:	2101      	movs	r1, #1
3401939a:	1ad2      	subs	r2, r2, r3
3401939c:	910c      	str	r1, [sp, #48]	@ 0x30
3401939e:	1e53      	subs	r3, r2, #1
340193a0:	9306      	str	r3, [sp, #24]
340193a2:	bf49      	itett	mi
340193a4:	f1c2 0301 	rsbmi	r3, r2, #1
340193a8:	2300      	movpl	r3, #0
340193aa:	9304      	strmi	r3, [sp, #16]
340193ac:	2300      	movmi	r3, #0
340193ae:	bf54      	ite	pl
340193b0:	9304      	strpl	r3, [sp, #16]
340193b2:	9306      	strmi	r3, [sp, #24]
340193b4:	f1b8 0f00 	cmp.w	r8, #0
340193b8:	db16      	blt.n	340193e8 <_dtoa_r+0x1f8>
340193ba:	9b06      	ldr	r3, [sp, #24]
340193bc:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
340193c0:	4443      	add	r3, r8
340193c2:	9306      	str	r3, [sp, #24]
340193c4:	2300      	movs	r3, #0
340193c6:	9a07      	ldr	r2, [sp, #28]
340193c8:	2a09      	cmp	r2, #9
340193ca:	d843      	bhi.n	34019454 <_dtoa_r+0x264>
340193cc:	2a05      	cmp	r2, #5
340193ce:	bfc5      	ittet	gt
340193d0:	3a04      	subgt	r2, #4
340193d2:	2400      	movgt	r4, #0
340193d4:	2401      	movle	r4, #1
340193d6:	9207      	strgt	r2, [sp, #28]
340193d8:	9a07      	ldr	r2, [sp, #28]
340193da:	3a02      	subs	r2, #2
340193dc:	2a03      	cmp	r2, #3
340193de:	d844      	bhi.n	3401946a <_dtoa_r+0x27a>
340193e0:	e8df f002 	tbb	[pc, r2]
340193e4:	0b173634 	.word	0x0b173634
340193e8:	9b04      	ldr	r3, [sp, #16]
340193ea:	2200      	movs	r2, #0
340193ec:	eba3 0308 	sub.w	r3, r3, r8
340193f0:	920a      	str	r2, [sp, #40]	@ 0x28
340193f2:	9304      	str	r3, [sp, #16]
340193f4:	f1c8 0300 	rsb	r3, r8, #0
340193f8:	e7e5      	b.n	340193c6 <_dtoa_r+0x1d6>
340193fa:	2201      	movs	r2, #1
340193fc:	9208      	str	r2, [sp, #32]
340193fe:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34019400:	eb08 0b02 	add.w	fp, r8, r2
34019404:	f10b 0a01 	add.w	sl, fp, #1
34019408:	4652      	mov	r2, sl
3401940a:	2a01      	cmp	r2, #1
3401940c:	bfb8      	it	lt
3401940e:	2201      	movlt	r2, #1
34019410:	e006      	b.n	34019420 <_dtoa_r+0x230>
34019412:	2201      	movs	r2, #1
34019414:	9208      	str	r2, [sp, #32]
34019416:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34019418:	2a00      	cmp	r2, #0
3401941a:	dd29      	ble.n	34019470 <_dtoa_r+0x280>
3401941c:	4693      	mov	fp, r2
3401941e:	4692      	mov	sl, r2
34019420:	f8d9 701c 	ldr.w	r7, [r9, #28]
34019424:	2100      	movs	r1, #0
34019426:	2004      	movs	r0, #4
34019428:	f100 0614 	add.w	r6, r0, #20
3401942c:	4296      	cmp	r6, r2
3401942e:	d926      	bls.n	3401947e <_dtoa_r+0x28e>
34019430:	6079      	str	r1, [r7, #4]
34019432:	4648      	mov	r0, r9
34019434:	9305      	str	r3, [sp, #20]
34019436:	f000 fc83 	bl	34019d40 <_Balloc>
3401943a:	9b05      	ldr	r3, [sp, #20]
3401943c:	4607      	mov	r7, r0
3401943e:	2800      	cmp	r0, #0
34019440:	d13e      	bne.n	340194c0 <_dtoa_r+0x2d0>
34019442:	4b1e      	ldr	r3, [pc, #120]	@ (340194bc <_dtoa_r+0x2cc>)
34019444:	4602      	mov	r2, r0
34019446:	f240 11af 	movw	r1, #431	@ 0x1af
3401944a:	e6ea      	b.n	34019222 <_dtoa_r+0x32>
3401944c:	2200      	movs	r2, #0
3401944e:	e7e1      	b.n	34019414 <_dtoa_r+0x224>
34019450:	2200      	movs	r2, #0
34019452:	e7d3      	b.n	340193fc <_dtoa_r+0x20c>
34019454:	2401      	movs	r4, #1
34019456:	2200      	movs	r2, #0
34019458:	e9cd 2407 	strd	r2, r4, [sp, #28]
3401945c:	f04f 3bff 	mov.w	fp, #4294967295
34019460:	2100      	movs	r1, #0
34019462:	2212      	movs	r2, #18
34019464:	46da      	mov	sl, fp
34019466:	9109      	str	r1, [sp, #36]	@ 0x24
34019468:	e7da      	b.n	34019420 <_dtoa_r+0x230>
3401946a:	2201      	movs	r2, #1
3401946c:	9208      	str	r2, [sp, #32]
3401946e:	e7f5      	b.n	3401945c <_dtoa_r+0x26c>
34019470:	f04f 0b01 	mov.w	fp, #1
34019474:	46da      	mov	sl, fp
34019476:	465a      	mov	r2, fp
34019478:	f8cd b024 	str.w	fp, [sp, #36]	@ 0x24
3401947c:	e7d0      	b.n	34019420 <_dtoa_r+0x230>
3401947e:	3101      	adds	r1, #1
34019480:	0040      	lsls	r0, r0, #1
34019482:	e7d1      	b.n	34019428 <_dtoa_r+0x238>
34019484:	f3af 8000 	nop.w
34019488:	636f4361 	.word	0x636f4361
3401948c:	3fd287a7 	.word	0x3fd287a7
34019490:	8b60c8b3 	.word	0x8b60c8b3
34019494:	3fc68a28 	.word	0x3fc68a28
34019498:	509f79fb 	.word	0x509f79fb
3401949c:	3fd34413 	.word	0x3fd34413
340194a0:	3401e65a 	.word	0x3401e65a
340194a4:	3401e671 	.word	0x3401e671
340194a8:	7ff00000 	.word	0x7ff00000
340194ac:	3401e656 	.word	0x3401e656
340194b0:	3401d1fd 	.word	0x3401d1fd
340194b4:	3401d1fc 	.word	0x3401d1fc
340194b8:	3403c6a8 	.word	0x3403c6a8
340194bc:	3401e6c9 	.word	0x3401e6c9
340194c0:	f8d9 201c 	ldr.w	r2, [r9, #28]
340194c4:	f1ba 0f0e 	cmp.w	sl, #14
340194c8:	6010      	str	r0, [r2, #0]
340194ca:	d86e      	bhi.n	340195aa <_dtoa_r+0x3ba>
340194cc:	2c00      	cmp	r4, #0
340194ce:	d06c      	beq.n	340195aa <_dtoa_r+0x3ba>
340194d0:	f1b8 0f00 	cmp.w	r8, #0
340194d4:	f340 80b4 	ble.w	34019640 <_dtoa_r+0x450>
340194d8:	f008 010f 	and.w	r1, r8, #15
340194dc:	4ac7      	ldr	r2, [pc, #796]	@ (340197fc <_dtoa_r+0x60c>)
340194de:	f418 7f80 	tst.w	r8, #256	@ 0x100
340194e2:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
340194e6:	ea4f 1128 	mov.w	r1, r8, asr #4
340194ea:	ed92 7b00 	vldr	d7, [r2]
340194ee:	f000 809b 	beq.w	34019628 <_dtoa_r+0x438>
340194f2:	4ac3      	ldr	r2, [pc, #780]	@ (34019800 <_dtoa_r+0x610>)
340194f4:	f001 010f 	and.w	r1, r1, #15
340194f8:	ed92 6b08 	vldr	d6, [r2, #32]
340194fc:	2203      	movs	r2, #3
340194fe:	ee88 6b06 	vdiv.f64	d6, d8, d6
34019502:	ed8d 6b02 	vstr	d6, [sp, #8]
34019506:	48be      	ldr	r0, [pc, #760]	@ (34019800 <_dtoa_r+0x610>)
34019508:	2900      	cmp	r1, #0
3401950a:	f040 808f 	bne.w	3401962c <_dtoa_r+0x43c>
3401950e:	ed9d 6b02 	vldr	d6, [sp, #8]
34019512:	ee86 7b07 	vdiv.f64	d7, d6, d7
34019516:	ed8d 7b02 	vstr	d7, [sp, #8]
3401951a:	990c      	ldr	r1, [sp, #48]	@ 0x30
3401951c:	ed9d 7b02 	vldr	d7, [sp, #8]
34019520:	2900      	cmp	r1, #0
34019522:	f000 80b3 	beq.w	3401968c <_dtoa_r+0x49c>
34019526:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3401952a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401952e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019532:	f140 80ab 	bpl.w	3401968c <_dtoa_r+0x49c>
34019536:	f1ba 0f00 	cmp.w	sl, #0
3401953a:	f000 80a7 	beq.w	3401968c <_dtoa_r+0x49c>
3401953e:	f1bb 0f00 	cmp.w	fp, #0
34019542:	dd30      	ble.n	340195a6 <_dtoa_r+0x3b6>
34019544:	eeb2 6b04 	vmov.f64	d6, #36	@ 0x41200000  10.0
34019548:	f108 31ff 	add.w	r1, r8, #4294967295
3401954c:	3201      	adds	r2, #1
3401954e:	465c      	mov	r4, fp
34019550:	9105      	str	r1, [sp, #20]
34019552:	ee27 7b06 	vmul.f64	d7, d7, d6
34019556:	ed8d 7b02 	vstr	d7, [sp, #8]
3401955a:	ee07 2a90 	vmov	s15, r2
3401955e:	eeb1 5b0c 	vmov.f64	d5, #28	@ 0x40e00000  7.0
34019562:	ed9d 6b02 	vldr	d6, [sp, #8]
34019566:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401956a:	eea7 5b06 	vfma.f64	d5, d7, d6
3401956e:	ee15 2a90 	vmov	r2, s11
34019572:	ec51 0b15 	vmov	r0, r1, d5
34019576:	f1a2 7150 	sub.w	r1, r2, #54525952	@ 0x3400000
3401957a:	2c00      	cmp	r4, #0
3401957c:	f040 808a 	bne.w	34019694 <_dtoa_r+0x4a4>
34019580:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
34019584:	ee36 6b47 	vsub.f64	d6, d6, d7
34019588:	ec41 0b17 	vmov	d7, r0, r1
3401958c:	eeb4 6bc7 	vcmpe.f64	d6, d7
34019590:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019594:	f300 826a 	bgt.w	34019a6c <_dtoa_r+0x87c>
34019598:	eeb1 7b47 	vneg.f64	d7, d7
3401959c:	eeb4 6bc7 	vcmpe.f64	d6, d7
340195a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340195a4:	d423      	bmi.n	340195ee <_dtoa_r+0x3fe>
340195a6:	ed8d 8b02 	vstr	d8, [sp, #8]
340195aa:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
340195ac:	2a00      	cmp	r2, #0
340195ae:	f2c0 8129 	blt.w	34019804 <_dtoa_r+0x614>
340195b2:	f1b8 0f0e 	cmp.w	r8, #14
340195b6:	f300 8125 	bgt.w	34019804 <_dtoa_r+0x614>
340195ba:	4b90      	ldr	r3, [pc, #576]	@ (340197fc <_dtoa_r+0x60c>)
340195bc:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
340195c0:	ed93 6b00 	vldr	d6, [r3]
340195c4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340195c6:	2b00      	cmp	r3, #0
340195c8:	f280 80c8 	bge.w	3401975c <_dtoa_r+0x56c>
340195cc:	f1ba 0f00 	cmp.w	sl, #0
340195d0:	f300 80c4 	bgt.w	3401975c <_dtoa_r+0x56c>
340195d4:	d10b      	bne.n	340195ee <_dtoa_r+0x3fe>
340195d6:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
340195da:	ee26 6b07 	vmul.f64	d6, d6, d7
340195de:	ed9d 7b02 	vldr	d7, [sp, #8]
340195e2:	eeb4 6bc7 	vcmpe.f64	d6, d7
340195e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340195ea:	f2c0 823c 	blt.w	34019a66 <_dtoa_r+0x876>
340195ee:	2400      	movs	r4, #0
340195f0:	4625      	mov	r5, r4
340195f2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340195f4:	463e      	mov	r6, r7
340195f6:	43db      	mvns	r3, r3
340195f8:	9305      	str	r3, [sp, #20]
340195fa:	f04f 0800 	mov.w	r8, #0
340195fe:	4621      	mov	r1, r4
34019600:	4648      	mov	r0, r9
34019602:	f000 fbdd 	bl	34019dc0 <_Bfree>
34019606:	2d00      	cmp	r5, #0
34019608:	f000 80a2 	beq.w	34019750 <_dtoa_r+0x560>
3401960c:	f1b8 0f00 	cmp.w	r8, #0
34019610:	d005      	beq.n	3401961e <_dtoa_r+0x42e>
34019612:	45a8      	cmp	r8, r5
34019614:	d003      	beq.n	3401961e <_dtoa_r+0x42e>
34019616:	4641      	mov	r1, r8
34019618:	4648      	mov	r0, r9
3401961a:	f000 fbd1 	bl	34019dc0 <_Bfree>
3401961e:	4629      	mov	r1, r5
34019620:	4648      	mov	r0, r9
34019622:	f000 fbcd 	bl	34019dc0 <_Bfree>
34019626:	e093      	b.n	34019750 <_dtoa_r+0x560>
34019628:	2202      	movs	r2, #2
3401962a:	e76c      	b.n	34019506 <_dtoa_r+0x316>
3401962c:	07cc      	lsls	r4, r1, #31
3401962e:	d504      	bpl.n	3401963a <_dtoa_r+0x44a>
34019630:	3201      	adds	r2, #1
34019632:	ed90 6b00 	vldr	d6, [r0]
34019636:	ee27 7b06 	vmul.f64	d7, d7, d6
3401963a:	1049      	asrs	r1, r1, #1
3401963c:	3008      	adds	r0, #8
3401963e:	e763      	b.n	34019508 <_dtoa_r+0x318>
34019640:	d022      	beq.n	34019688 <_dtoa_r+0x498>
34019642:	f1c8 0100 	rsb	r1, r8, #0
34019646:	4a6d      	ldr	r2, [pc, #436]	@ (340197fc <_dtoa_r+0x60c>)
34019648:	2400      	movs	r4, #0
3401964a:	f001 000f 	and.w	r0, r1, #15
3401964e:	1109      	asrs	r1, r1, #4
34019650:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
34019654:	486a      	ldr	r0, [pc, #424]	@ (34019800 <_dtoa_r+0x610>)
34019656:	ed92 7b00 	vldr	d7, [r2]
3401965a:	2202      	movs	r2, #2
3401965c:	ee28 7b07 	vmul.f64	d7, d8, d7
34019660:	ed8d 7b02 	vstr	d7, [sp, #8]
34019664:	b929      	cbnz	r1, 34019672 <_dtoa_r+0x482>
34019666:	2c00      	cmp	r4, #0
34019668:	f43f af57 	beq.w	3401951a <_dtoa_r+0x32a>
3401966c:	ed8d 7b02 	vstr	d7, [sp, #8]
34019670:	e753      	b.n	3401951a <_dtoa_r+0x32a>
34019672:	07ce      	lsls	r6, r1, #31
34019674:	d505      	bpl.n	34019682 <_dtoa_r+0x492>
34019676:	3201      	adds	r2, #1
34019678:	2401      	movs	r4, #1
3401967a:	ed90 6b00 	vldr	d6, [r0]
3401967e:	ee27 7b06 	vmul.f64	d7, d7, d6
34019682:	1049      	asrs	r1, r1, #1
34019684:	3008      	adds	r0, #8
34019686:	e7ed      	b.n	34019664 <_dtoa_r+0x474>
34019688:	2202      	movs	r2, #2
3401968a:	e746      	b.n	3401951a <_dtoa_r+0x32a>
3401968c:	4654      	mov	r4, sl
3401968e:	f8cd 8014 	str.w	r8, [sp, #20]
34019692:	e762      	b.n	3401955a <_dtoa_r+0x36a>
34019694:	4a59      	ldr	r2, [pc, #356]	@ (340197fc <_dtoa_r+0x60c>)
34019696:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
3401969a:	443c      	add	r4, r7
3401969c:	ed12 4b02 	vldr	d4, [r2, #-8]
340196a0:	9a08      	ldr	r2, [sp, #32]
340196a2:	ec41 0b17 	vmov	d7, r0, r1
340196a6:	b34a      	cbz	r2, 340196fc <_dtoa_r+0x50c>
340196a8:	eeb6 3b00 	vmov.f64	d3, #96	@ 0x3f000000  0.5
340196ac:	463e      	mov	r6, r7
340196ae:	eeb7 2b00 	vmov.f64	d2, #112	@ 0x3f800000  1.0
340196b2:	ee83 5b04 	vdiv.f64	d5, d3, d4
340196b6:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
340196ba:	ee35 7b47 	vsub.f64	d7, d5, d7
340196be:	eefd 4bc6 	vcvt.s32.f64	s9, d6
340196c2:	eeb8 5be4 	vcvt.f64.s32	d5, s9
340196c6:	ee14 2a90 	vmov	r2, s9
340196ca:	3230      	adds	r2, #48	@ 0x30
340196cc:	ee36 6b45 	vsub.f64	d6, d6, d5
340196d0:	f806 2b01 	strb.w	r2, [r6], #1
340196d4:	eeb4 6bc7 	vcmpe.f64	d6, d7
340196d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340196dc:	d438      	bmi.n	34019750 <_dtoa_r+0x560>
340196de:	ee32 5b46 	vsub.f64	d5, d2, d6
340196e2:	eeb4 5bc7 	vcmpe.f64	d5, d7
340196e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340196ea:	d46e      	bmi.n	340197ca <_dtoa_r+0x5da>
340196ec:	42a6      	cmp	r6, r4
340196ee:	f43f af5a 	beq.w	340195a6 <_dtoa_r+0x3b6>
340196f2:	ee27 7b03 	vmul.f64	d7, d7, d3
340196f6:	ee26 6b03 	vmul.f64	d6, d6, d3
340196fa:	e7e0      	b.n	340196be <_dtoa_r+0x4ce>
340196fc:	ee27 7b04 	vmul.f64	d7, d7, d4
34019700:	4621      	mov	r1, r4
34019702:	463e      	mov	r6, r7
34019704:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
34019708:	eefd 4bc6 	vcvt.s32.f64	s9, d6
3401970c:	ee14 2a90 	vmov	r2, s9
34019710:	eeb8 5be4 	vcvt.f64.s32	d5, s9
34019714:	3230      	adds	r2, #48	@ 0x30
34019716:	ee36 6b45 	vsub.f64	d6, d6, d5
3401971a:	f806 2b01 	strb.w	r2, [r6], #1
3401971e:	42a6      	cmp	r6, r4
34019720:	d119      	bne.n	34019756 <_dtoa_r+0x566>
34019722:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34019726:	ee37 4b05 	vadd.f64	d4, d7, d5
3401972a:	eeb4 6bc4 	vcmpe.f64	d6, d4
3401972e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019732:	dc4a      	bgt.n	340197ca <_dtoa_r+0x5da>
34019734:	ee35 5b47 	vsub.f64	d5, d5, d7
34019738:	eeb4 6bc5 	vcmpe.f64	d6, d5
3401973c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019740:	f57f af31 	bpl.w	340195a6 <_dtoa_r+0x3b6>
34019744:	460e      	mov	r6, r1
34019746:	3901      	subs	r1, #1
34019748:	f816 3c01 	ldrb.w	r3, [r6, #-1]
3401974c:	2b30      	cmp	r3, #48	@ 0x30
3401974e:	d0f9      	beq.n	34019744 <_dtoa_r+0x554>
34019750:	f8dd 8014 	ldr.w	r8, [sp, #20]
34019754:	e027      	b.n	340197a6 <_dtoa_r+0x5b6>
34019756:	ee26 6b03 	vmul.f64	d6, d6, d3
3401975a:	e7d5      	b.n	34019708 <_dtoa_r+0x518>
3401975c:	ed9d 7b02 	vldr	d7, [sp, #8]
34019760:	eeb2 4b04 	vmov.f64	d4, #36	@ 0x41200000  10.0
34019764:	463e      	mov	r6, r7
34019766:	ee87 5b06 	vdiv.f64	d5, d7, d6
3401976a:	eebd 5bc5 	vcvt.s32.f64	s10, d5
3401976e:	ee15 3a10 	vmov	r3, s10
34019772:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
34019776:	3330      	adds	r3, #48	@ 0x30
34019778:	eea3 7b46 	vfms.f64	d7, d3, d6
3401977c:	f806 3b01 	strb.w	r3, [r6], #1
34019780:	1bf3      	subs	r3, r6, r7
34019782:	459a      	cmp	sl, r3
34019784:	d132      	bne.n	340197ec <_dtoa_r+0x5fc>
34019786:	ee37 7b07 	vadd.f64	d7, d7, d7
3401978a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401978e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019792:	dc18      	bgt.n	340197c6 <_dtoa_r+0x5d6>
34019794:	eeb4 7b46 	vcmp.f64	d7, d6
34019798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401979c:	d103      	bne.n	340197a6 <_dtoa_r+0x5b6>
3401979e:	ee15 3a10 	vmov	r3, s10
340197a2:	07db      	lsls	r3, r3, #31
340197a4:	d40f      	bmi.n	340197c6 <_dtoa_r+0x5d6>
340197a6:	9901      	ldr	r1, [sp, #4]
340197a8:	4648      	mov	r0, r9
340197aa:	f000 fb09 	bl	34019dc0 <_Bfree>
340197ae:	2300      	movs	r3, #0
340197b0:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
340197b2:	7033      	strb	r3, [r6, #0]
340197b4:	f108 0301 	add.w	r3, r8, #1
340197b8:	6013      	str	r3, [r2, #0]
340197ba:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
340197bc:	2b00      	cmp	r3, #0
340197be:	f000 824b 	beq.w	34019c58 <_dtoa_r+0xa68>
340197c2:	601e      	str	r6, [r3, #0]
340197c4:	e248      	b.n	34019c58 <_dtoa_r+0xa68>
340197c6:	f8cd 8014 	str.w	r8, [sp, #20]
340197ca:	4633      	mov	r3, r6
340197cc:	461e      	mov	r6, r3
340197ce:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
340197d2:	2a39      	cmp	r2, #57	@ 0x39
340197d4:	d106      	bne.n	340197e4 <_dtoa_r+0x5f4>
340197d6:	429f      	cmp	r7, r3
340197d8:	d1f8      	bne.n	340197cc <_dtoa_r+0x5dc>
340197da:	9a05      	ldr	r2, [sp, #20]
340197dc:	3201      	adds	r2, #1
340197de:	9205      	str	r2, [sp, #20]
340197e0:	2230      	movs	r2, #48	@ 0x30
340197e2:	703a      	strb	r2, [r7, #0]
340197e4:	781a      	ldrb	r2, [r3, #0]
340197e6:	3201      	adds	r2, #1
340197e8:	701a      	strb	r2, [r3, #0]
340197ea:	e7b1      	b.n	34019750 <_dtoa_r+0x560>
340197ec:	ee27 7b04 	vmul.f64	d7, d7, d4
340197f0:	eeb5 7b40 	vcmp.f64	d7, #0.0
340197f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340197f8:	d1b5      	bne.n	34019766 <_dtoa_r+0x576>
340197fa:	e7d4      	b.n	340197a6 <_dtoa_r+0x5b6>
340197fc:	3403c6a8 	.word	0x3403c6a8
34019800:	3403c680 	.word	0x3403c680
34019804:	9908      	ldr	r1, [sp, #32]
34019806:	2900      	cmp	r1, #0
34019808:	f000 80e9 	beq.w	340199de <_dtoa_r+0x7ee>
3401980c:	9907      	ldr	r1, [sp, #28]
3401980e:	2901      	cmp	r1, #1
34019810:	f300 80cb 	bgt.w	340199aa <_dtoa_r+0x7ba>
34019814:	2d00      	cmp	r5, #0
34019816:	f000 80c4 	beq.w	340199a2 <_dtoa_r+0x7b2>
3401981a:	f202 4233 	addw	r2, r2, #1075	@ 0x433
3401981e:	461c      	mov	r4, r3
34019820:	9e04      	ldr	r6, [sp, #16]
34019822:	9305      	str	r3, [sp, #20]
34019824:	2101      	movs	r1, #1
34019826:	9b04      	ldr	r3, [sp, #16]
34019828:	4648      	mov	r0, r9
3401982a:	4413      	add	r3, r2
3401982c:	9304      	str	r3, [sp, #16]
3401982e:	9b06      	ldr	r3, [sp, #24]
34019830:	4413      	add	r3, r2
34019832:	9306      	str	r3, [sp, #24]
34019834:	f000 fb7a 	bl	34019f2c <__i2b>
34019838:	9b05      	ldr	r3, [sp, #20]
3401983a:	4605      	mov	r5, r0
3401983c:	b166      	cbz	r6, 34019858 <_dtoa_r+0x668>
3401983e:	9a06      	ldr	r2, [sp, #24]
34019840:	2a00      	cmp	r2, #0
34019842:	dd09      	ble.n	34019858 <_dtoa_r+0x668>
34019844:	42b2      	cmp	r2, r6
34019846:	9904      	ldr	r1, [sp, #16]
34019848:	bfa8      	it	ge
3401984a:	4632      	movge	r2, r6
3401984c:	1a89      	subs	r1, r1, r2
3401984e:	1ab6      	subs	r6, r6, r2
34019850:	9104      	str	r1, [sp, #16]
34019852:	9906      	ldr	r1, [sp, #24]
34019854:	1a8a      	subs	r2, r1, r2
34019856:	9206      	str	r2, [sp, #24]
34019858:	b30b      	cbz	r3, 3401989e <_dtoa_r+0x6ae>
3401985a:	9a08      	ldr	r2, [sp, #32]
3401985c:	2a00      	cmp	r2, #0
3401985e:	f000 80c5 	beq.w	340199ec <_dtoa_r+0x7fc>
34019862:	2c00      	cmp	r4, #0
34019864:	f000 80bf 	beq.w	340199e6 <_dtoa_r+0x7f6>
34019868:	4629      	mov	r1, r5
3401986a:	4622      	mov	r2, r4
3401986c:	4648      	mov	r0, r9
3401986e:	930b      	str	r3, [sp, #44]	@ 0x2c
34019870:	f000 fc16 	bl	3401a0a0 <__pow5mult>
34019874:	9a01      	ldr	r2, [sp, #4]
34019876:	4601      	mov	r1, r0
34019878:	4605      	mov	r5, r0
3401987a:	4648      	mov	r0, r9
3401987c:	f000 fb6c 	bl	34019f58 <__multiply>
34019880:	9901      	ldr	r1, [sp, #4]
34019882:	9005      	str	r0, [sp, #20]
34019884:	4648      	mov	r0, r9
34019886:	f000 fa9b 	bl	34019dc0 <_Bfree>
3401988a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
3401988c:	1b1b      	subs	r3, r3, r4
3401988e:	f000 80b0 	beq.w	340199f2 <_dtoa_r+0x802>
34019892:	461a      	mov	r2, r3
34019894:	9905      	ldr	r1, [sp, #20]
34019896:	4648      	mov	r0, r9
34019898:	f000 fc02 	bl	3401a0a0 <__pow5mult>
3401989c:	9001      	str	r0, [sp, #4]
3401989e:	2101      	movs	r1, #1
340198a0:	4648      	mov	r0, r9
340198a2:	f000 fb43 	bl	34019f2c <__i2b>
340198a6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340198a8:	4604      	mov	r4, r0
340198aa:	2b00      	cmp	r3, #0
340198ac:	f000 81da 	beq.w	34019c64 <_dtoa_r+0xa74>
340198b0:	461a      	mov	r2, r3
340198b2:	4601      	mov	r1, r0
340198b4:	4648      	mov	r0, r9
340198b6:	f000 fbf3 	bl	3401a0a0 <__pow5mult>
340198ba:	9b07      	ldr	r3, [sp, #28]
340198bc:	4604      	mov	r4, r0
340198be:	2b01      	cmp	r3, #1
340198c0:	f300 80a0 	bgt.w	34019a04 <_dtoa_r+0x814>
340198c4:	9b02      	ldr	r3, [sp, #8]
340198c6:	2b00      	cmp	r3, #0
340198c8:	f040 8096 	bne.w	340199f8 <_dtoa_r+0x808>
340198cc:	9b03      	ldr	r3, [sp, #12]
340198ce:	f3c3 0213 	ubfx	r2, r3, #0, #20
340198d2:	2a00      	cmp	r2, #0
340198d4:	f040 8092 	bne.w	340199fc <_dtoa_r+0x80c>
340198d8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
340198dc:	0d12      	lsrs	r2, r2, #20
340198de:	0512      	lsls	r2, r2, #20
340198e0:	2a00      	cmp	r2, #0
340198e2:	f000 808d 	beq.w	34019a00 <_dtoa_r+0x810>
340198e6:	9b04      	ldr	r3, [sp, #16]
340198e8:	3301      	adds	r3, #1
340198ea:	9304      	str	r3, [sp, #16]
340198ec:	9b06      	ldr	r3, [sp, #24]
340198ee:	3301      	adds	r3, #1
340198f0:	9306      	str	r3, [sp, #24]
340198f2:	2301      	movs	r3, #1
340198f4:	930b      	str	r3, [sp, #44]	@ 0x2c
340198f6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340198f8:	2b00      	cmp	r3, #0
340198fa:	f000 81b9 	beq.w	34019c70 <_dtoa_r+0xa80>
340198fe:	6922      	ldr	r2, [r4, #16]
34019900:	eb04 0282 	add.w	r2, r4, r2, lsl #2
34019904:	6910      	ldr	r0, [r2, #16]
34019906:	f000 fac5 	bl	34019e94 <__hi0bits>
3401990a:	f1c0 0020 	rsb	r0, r0, #32
3401990e:	9b06      	ldr	r3, [sp, #24]
34019910:	4418      	add	r0, r3
34019912:	f010 001f 	ands.w	r0, r0, #31
34019916:	f000 8081 	beq.w	34019a1c <_dtoa_r+0x82c>
3401991a:	f1c0 0220 	rsb	r2, r0, #32
3401991e:	2a04      	cmp	r2, #4
34019920:	dd73      	ble.n	34019a0a <_dtoa_r+0x81a>
34019922:	f1c0 001c 	rsb	r0, r0, #28
34019926:	9b04      	ldr	r3, [sp, #16]
34019928:	4403      	add	r3, r0
3401992a:	4406      	add	r6, r0
3401992c:	9304      	str	r3, [sp, #16]
3401992e:	9b06      	ldr	r3, [sp, #24]
34019930:	4403      	add	r3, r0
34019932:	9306      	str	r3, [sp, #24]
34019934:	9b04      	ldr	r3, [sp, #16]
34019936:	2b00      	cmp	r3, #0
34019938:	dd05      	ble.n	34019946 <_dtoa_r+0x756>
3401993a:	461a      	mov	r2, r3
3401993c:	9901      	ldr	r1, [sp, #4]
3401993e:	4648      	mov	r0, r9
34019940:	f000 fc08 	bl	3401a154 <__lshift>
34019944:	9001      	str	r0, [sp, #4]
34019946:	9b06      	ldr	r3, [sp, #24]
34019948:	2b00      	cmp	r3, #0
3401994a:	dd05      	ble.n	34019958 <_dtoa_r+0x768>
3401994c:	4621      	mov	r1, r4
3401994e:	461a      	mov	r2, r3
34019950:	4648      	mov	r0, r9
34019952:	f000 fbff 	bl	3401a154 <__lshift>
34019956:	4604      	mov	r4, r0
34019958:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
3401995a:	2b00      	cmp	r3, #0
3401995c:	d060      	beq.n	34019a20 <_dtoa_r+0x830>
3401995e:	4621      	mov	r1, r4
34019960:	9801      	ldr	r0, [sp, #4]
34019962:	f000 fc63 	bl	3401a22c <__mcmp>
34019966:	2800      	cmp	r0, #0
34019968:	da5a      	bge.n	34019a20 <_dtoa_r+0x830>
3401996a:	f108 33ff 	add.w	r3, r8, #4294967295
3401996e:	220a      	movs	r2, #10
34019970:	9901      	ldr	r1, [sp, #4]
34019972:	4648      	mov	r0, r9
34019974:	9305      	str	r3, [sp, #20]
34019976:	2300      	movs	r3, #0
34019978:	f000 fa44 	bl	34019e04 <__multadd>
3401997c:	9b08      	ldr	r3, [sp, #32]
3401997e:	9001      	str	r0, [sp, #4]
34019980:	2b00      	cmp	r3, #0
34019982:	f000 8177 	beq.w	34019c74 <_dtoa_r+0xa84>
34019986:	4629      	mov	r1, r5
34019988:	2300      	movs	r3, #0
3401998a:	220a      	movs	r2, #10
3401998c:	4648      	mov	r0, r9
3401998e:	f000 fa39 	bl	34019e04 <__multadd>
34019992:	f1bb 0f00 	cmp.w	fp, #0
34019996:	4605      	mov	r5, r0
34019998:	dc6e      	bgt.n	34019a78 <_dtoa_r+0x888>
3401999a:	9b07      	ldr	r3, [sp, #28]
3401999c:	2b02      	cmp	r3, #2
3401999e:	dc48      	bgt.n	34019a32 <_dtoa_r+0x842>
340199a0:	e06a      	b.n	34019a78 <_dtoa_r+0x888>
340199a2:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340199a4:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
340199a8:	e739      	b.n	3401981e <_dtoa_r+0x62e>
340199aa:	f10a 34ff 	add.w	r4, sl, #4294967295
340199ae:	42a3      	cmp	r3, r4
340199b0:	db07      	blt.n	340199c2 <_dtoa_r+0x7d2>
340199b2:	f1ba 0f00 	cmp.w	sl, #0
340199b6:	eba3 0404 	sub.w	r4, r3, r4
340199ba:	db0b      	blt.n	340199d4 <_dtoa_r+0x7e4>
340199bc:	9e04      	ldr	r6, [sp, #16]
340199be:	4652      	mov	r2, sl
340199c0:	e72f      	b.n	34019822 <_dtoa_r+0x632>
340199c2:	1ae2      	subs	r2, r4, r3
340199c4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340199c6:	9e04      	ldr	r6, [sp, #16]
340199c8:	4413      	add	r3, r2
340199ca:	4652      	mov	r2, sl
340199cc:	930a      	str	r3, [sp, #40]	@ 0x28
340199ce:	4623      	mov	r3, r4
340199d0:	2400      	movs	r4, #0
340199d2:	e726      	b.n	34019822 <_dtoa_r+0x632>
340199d4:	9a04      	ldr	r2, [sp, #16]
340199d6:	eba2 060a 	sub.w	r6, r2, sl
340199da:	2200      	movs	r2, #0
340199dc:	e721      	b.n	34019822 <_dtoa_r+0x632>
340199de:	461c      	mov	r4, r3
340199e0:	9e04      	ldr	r6, [sp, #16]
340199e2:	9d08      	ldr	r5, [sp, #32]
340199e4:	e72a      	b.n	3401983c <_dtoa_r+0x64c>
340199e6:	9a01      	ldr	r2, [sp, #4]
340199e8:	9205      	str	r2, [sp, #20]
340199ea:	e752      	b.n	34019892 <_dtoa_r+0x6a2>
340199ec:	461a      	mov	r2, r3
340199ee:	9901      	ldr	r1, [sp, #4]
340199f0:	e751      	b.n	34019896 <_dtoa_r+0x6a6>
340199f2:	9b05      	ldr	r3, [sp, #20]
340199f4:	9301      	str	r3, [sp, #4]
340199f6:	e752      	b.n	3401989e <_dtoa_r+0x6ae>
340199f8:	2300      	movs	r3, #0
340199fa:	e77b      	b.n	340198f4 <_dtoa_r+0x704>
340199fc:	9b02      	ldr	r3, [sp, #8]
340199fe:	e779      	b.n	340198f4 <_dtoa_r+0x704>
34019a00:	920b      	str	r2, [sp, #44]	@ 0x2c
34019a02:	e778      	b.n	340198f6 <_dtoa_r+0x706>
34019a04:	2300      	movs	r3, #0
34019a06:	930b      	str	r3, [sp, #44]	@ 0x2c
34019a08:	e779      	b.n	340198fe <_dtoa_r+0x70e>
34019a0a:	d093      	beq.n	34019934 <_dtoa_r+0x744>
34019a0c:	321c      	adds	r2, #28
34019a0e:	9b04      	ldr	r3, [sp, #16]
34019a10:	4413      	add	r3, r2
34019a12:	4416      	add	r6, r2
34019a14:	9304      	str	r3, [sp, #16]
34019a16:	9b06      	ldr	r3, [sp, #24]
34019a18:	4413      	add	r3, r2
34019a1a:	e78a      	b.n	34019932 <_dtoa_r+0x742>
34019a1c:	4602      	mov	r2, r0
34019a1e:	e7f5      	b.n	34019a0c <_dtoa_r+0x81c>
34019a20:	f1ba 0f00 	cmp.w	sl, #0
34019a24:	46d3      	mov	fp, sl
34019a26:	f8cd 8014 	str.w	r8, [sp, #20]
34019a2a:	dc21      	bgt.n	34019a70 <_dtoa_r+0x880>
34019a2c:	9b07      	ldr	r3, [sp, #28]
34019a2e:	2b02      	cmp	r3, #2
34019a30:	dd1e      	ble.n	34019a70 <_dtoa_r+0x880>
34019a32:	f1bb 0f00 	cmp.w	fp, #0
34019a36:	f47f addc 	bne.w	340195f2 <_dtoa_r+0x402>
34019a3a:	4621      	mov	r1, r4
34019a3c:	465b      	mov	r3, fp
34019a3e:	2205      	movs	r2, #5
34019a40:	4648      	mov	r0, r9
34019a42:	f000 f9df 	bl	34019e04 <__multadd>
34019a46:	4601      	mov	r1, r0
34019a48:	4604      	mov	r4, r0
34019a4a:	9801      	ldr	r0, [sp, #4]
34019a4c:	f000 fbee 	bl	3401a22c <__mcmp>
34019a50:	2800      	cmp	r0, #0
34019a52:	f77f adce 	ble.w	340195f2 <_dtoa_r+0x402>
34019a56:	2331      	movs	r3, #49	@ 0x31
34019a58:	463e      	mov	r6, r7
34019a5a:	f806 3b01 	strb.w	r3, [r6], #1
34019a5e:	9b05      	ldr	r3, [sp, #20]
34019a60:	3301      	adds	r3, #1
34019a62:	9305      	str	r3, [sp, #20]
34019a64:	e5c9      	b.n	340195fa <_dtoa_r+0x40a>
34019a66:	4654      	mov	r4, sl
34019a68:	f8cd 8014 	str.w	r8, [sp, #20]
34019a6c:	4625      	mov	r5, r4
34019a6e:	e7f2      	b.n	34019a56 <_dtoa_r+0x866>
34019a70:	9b08      	ldr	r3, [sp, #32]
34019a72:	2b00      	cmp	r3, #0
34019a74:	f000 8102 	beq.w	34019c7c <_dtoa_r+0xa8c>
34019a78:	2e00      	cmp	r6, #0
34019a7a:	dd05      	ble.n	34019a88 <_dtoa_r+0x898>
34019a7c:	4629      	mov	r1, r5
34019a7e:	4632      	mov	r2, r6
34019a80:	4648      	mov	r0, r9
34019a82:	f000 fb67 	bl	3401a154 <__lshift>
34019a86:	4605      	mov	r5, r0
34019a88:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34019a8a:	2b00      	cmp	r3, #0
34019a8c:	d058      	beq.n	34019b40 <_dtoa_r+0x950>
34019a8e:	6869      	ldr	r1, [r5, #4]
34019a90:	4648      	mov	r0, r9
34019a92:	f000 f955 	bl	34019d40 <_Balloc>
34019a96:	4606      	mov	r6, r0
34019a98:	b928      	cbnz	r0, 34019aa6 <_dtoa_r+0x8b6>
34019a9a:	4b82      	ldr	r3, [pc, #520]	@ (34019ca4 <_dtoa_r+0xab4>)
34019a9c:	4602      	mov	r2, r0
34019a9e:	f240 21ef 	movw	r1, #751	@ 0x2ef
34019aa2:	f7ff bbbe 	b.w	34019222 <_dtoa_r+0x32>
34019aa6:	692a      	ldr	r2, [r5, #16]
34019aa8:	f105 010c 	add.w	r1, r5, #12
34019aac:	300c      	adds	r0, #12
34019aae:	3202      	adds	r2, #2
34019ab0:	0092      	lsls	r2, r2, #2
34019ab2:	f7ff fafa 	bl	340190aa <memcpy>
34019ab6:	2201      	movs	r2, #1
34019ab8:	4631      	mov	r1, r6
34019aba:	4648      	mov	r0, r9
34019abc:	f000 fb4a 	bl	3401a154 <__lshift>
34019ac0:	1c7b      	adds	r3, r7, #1
34019ac2:	46a8      	mov	r8, r5
34019ac4:	4605      	mov	r5, r0
34019ac6:	9304      	str	r3, [sp, #16]
34019ac8:	eb07 030b 	add.w	r3, r7, fp
34019acc:	9309      	str	r3, [sp, #36]	@ 0x24
34019ace:	9b02      	ldr	r3, [sp, #8]
34019ad0:	f003 0301 	and.w	r3, r3, #1
34019ad4:	9308      	str	r3, [sp, #32]
34019ad6:	9b04      	ldr	r3, [sp, #16]
34019ad8:	4621      	mov	r1, r4
34019ada:	9801      	ldr	r0, [sp, #4]
34019adc:	f103 3bff 	add.w	fp, r3, #4294967295
34019ae0:	f7ff faf7 	bl	340190d2 <quorem>
34019ae4:	4641      	mov	r1, r8
34019ae6:	9002      	str	r0, [sp, #8]
34019ae8:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
34019aec:	9801      	ldr	r0, [sp, #4]
34019aee:	f000 fb9d 	bl	3401a22c <__mcmp>
34019af2:	462a      	mov	r2, r5
34019af4:	9006      	str	r0, [sp, #24]
34019af6:	4621      	mov	r1, r4
34019af8:	4648      	mov	r0, r9
34019afa:	f000 fbb3 	bl	3401a264 <__mdiff>
34019afe:	68c2      	ldr	r2, [r0, #12]
34019b00:	4606      	mov	r6, r0
34019b02:	b9fa      	cbnz	r2, 34019b44 <_dtoa_r+0x954>
34019b04:	4601      	mov	r1, r0
34019b06:	9801      	ldr	r0, [sp, #4]
34019b08:	f000 fb90 	bl	3401a22c <__mcmp>
34019b0c:	4602      	mov	r2, r0
34019b0e:	4631      	mov	r1, r6
34019b10:	4648      	mov	r0, r9
34019b12:	920a      	str	r2, [sp, #40]	@ 0x28
34019b14:	f000 f954 	bl	34019dc0 <_Bfree>
34019b18:	9b07      	ldr	r3, [sp, #28]
34019b1a:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
34019b1c:	9e04      	ldr	r6, [sp, #16]
34019b1e:	ea42 0103 	orr.w	r1, r2, r3
34019b22:	9b08      	ldr	r3, [sp, #32]
34019b24:	4319      	orrs	r1, r3
34019b26:	d10f      	bne.n	34019b48 <_dtoa_r+0x958>
34019b28:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34019b2c:	d028      	beq.n	34019b80 <_dtoa_r+0x990>
34019b2e:	9b06      	ldr	r3, [sp, #24]
34019b30:	2b00      	cmp	r3, #0
34019b32:	dd02      	ble.n	34019b3a <_dtoa_r+0x94a>
34019b34:	9b02      	ldr	r3, [sp, #8]
34019b36:	f103 0a31 	add.w	sl, r3, #49	@ 0x31
34019b3a:	f88b a000 	strb.w	sl, [fp]
34019b3e:	e55e      	b.n	340195fe <_dtoa_r+0x40e>
34019b40:	4628      	mov	r0, r5
34019b42:	e7bd      	b.n	34019ac0 <_dtoa_r+0x8d0>
34019b44:	2201      	movs	r2, #1
34019b46:	e7e2      	b.n	34019b0e <_dtoa_r+0x91e>
34019b48:	9b06      	ldr	r3, [sp, #24]
34019b4a:	2b00      	cmp	r3, #0
34019b4c:	db04      	blt.n	34019b58 <_dtoa_r+0x968>
34019b4e:	9907      	ldr	r1, [sp, #28]
34019b50:	430b      	orrs	r3, r1
34019b52:	9908      	ldr	r1, [sp, #32]
34019b54:	430b      	orrs	r3, r1
34019b56:	d120      	bne.n	34019b9a <_dtoa_r+0x9aa>
34019b58:	2a00      	cmp	r2, #0
34019b5a:	ddee      	ble.n	34019b3a <_dtoa_r+0x94a>
34019b5c:	2201      	movs	r2, #1
34019b5e:	9901      	ldr	r1, [sp, #4]
34019b60:	4648      	mov	r0, r9
34019b62:	f000 faf7 	bl	3401a154 <__lshift>
34019b66:	4621      	mov	r1, r4
34019b68:	9001      	str	r0, [sp, #4]
34019b6a:	f000 fb5f 	bl	3401a22c <__mcmp>
34019b6e:	2800      	cmp	r0, #0
34019b70:	dc03      	bgt.n	34019b7a <_dtoa_r+0x98a>
34019b72:	d1e2      	bne.n	34019b3a <_dtoa_r+0x94a>
34019b74:	f01a 0f01 	tst.w	sl, #1
34019b78:	d0df      	beq.n	34019b3a <_dtoa_r+0x94a>
34019b7a:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34019b7e:	d1d9      	bne.n	34019b34 <_dtoa_r+0x944>
34019b80:	2339      	movs	r3, #57	@ 0x39
34019b82:	f88b 3000 	strb.w	r3, [fp]
34019b86:	4633      	mov	r3, r6
34019b88:	461e      	mov	r6, r3
34019b8a:	3b01      	subs	r3, #1
34019b8c:	f816 2c01 	ldrb.w	r2, [r6, #-1]
34019b90:	2a39      	cmp	r2, #57	@ 0x39
34019b92:	d052      	beq.n	34019c3a <_dtoa_r+0xa4a>
34019b94:	3201      	adds	r2, #1
34019b96:	701a      	strb	r2, [r3, #0]
34019b98:	e531      	b.n	340195fe <_dtoa_r+0x40e>
34019b9a:	2a00      	cmp	r2, #0
34019b9c:	dd07      	ble.n	34019bae <_dtoa_r+0x9be>
34019b9e:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34019ba2:	d0ed      	beq.n	34019b80 <_dtoa_r+0x990>
34019ba4:	f10a 0301 	add.w	r3, sl, #1
34019ba8:	f88b 3000 	strb.w	r3, [fp]
34019bac:	e527      	b.n	340195fe <_dtoa_r+0x40e>
34019bae:	9b04      	ldr	r3, [sp, #16]
34019bb0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34019bb2:	f803 ac01 	strb.w	sl, [r3, #-1]
34019bb6:	4293      	cmp	r3, r2
34019bb8:	d029      	beq.n	34019c0e <_dtoa_r+0xa1e>
34019bba:	2300      	movs	r3, #0
34019bbc:	220a      	movs	r2, #10
34019bbe:	9901      	ldr	r1, [sp, #4]
34019bc0:	4648      	mov	r0, r9
34019bc2:	f000 f91f 	bl	34019e04 <__multadd>
34019bc6:	45a8      	cmp	r8, r5
34019bc8:	9001      	str	r0, [sp, #4]
34019bca:	f04f 0300 	mov.w	r3, #0
34019bce:	f04f 020a 	mov.w	r2, #10
34019bd2:	4641      	mov	r1, r8
34019bd4:	4648      	mov	r0, r9
34019bd6:	d107      	bne.n	34019be8 <_dtoa_r+0x9f8>
34019bd8:	f000 f914 	bl	34019e04 <__multadd>
34019bdc:	4680      	mov	r8, r0
34019bde:	4605      	mov	r5, r0
34019be0:	9b04      	ldr	r3, [sp, #16]
34019be2:	3301      	adds	r3, #1
34019be4:	9304      	str	r3, [sp, #16]
34019be6:	e776      	b.n	34019ad6 <_dtoa_r+0x8e6>
34019be8:	f000 f90c 	bl	34019e04 <__multadd>
34019bec:	4629      	mov	r1, r5
34019bee:	4680      	mov	r8, r0
34019bf0:	2300      	movs	r3, #0
34019bf2:	220a      	movs	r2, #10
34019bf4:	4648      	mov	r0, r9
34019bf6:	f000 f905 	bl	34019e04 <__multadd>
34019bfa:	4605      	mov	r5, r0
34019bfc:	e7f0      	b.n	34019be0 <_dtoa_r+0x9f0>
34019bfe:	f1bb 0f00 	cmp.w	fp, #0
34019c02:	f04f 0800 	mov.w	r8, #0
34019c06:	bfcc      	ite	gt
34019c08:	465e      	movgt	r6, fp
34019c0a:	2601      	movle	r6, #1
34019c0c:	443e      	add	r6, r7
34019c0e:	2201      	movs	r2, #1
34019c10:	9901      	ldr	r1, [sp, #4]
34019c12:	4648      	mov	r0, r9
34019c14:	f000 fa9e 	bl	3401a154 <__lshift>
34019c18:	4621      	mov	r1, r4
34019c1a:	9001      	str	r0, [sp, #4]
34019c1c:	f000 fb06 	bl	3401a22c <__mcmp>
34019c20:	2800      	cmp	r0, #0
34019c22:	dcb0      	bgt.n	34019b86 <_dtoa_r+0x996>
34019c24:	d102      	bne.n	34019c2c <_dtoa_r+0xa3c>
34019c26:	f01a 0f01 	tst.w	sl, #1
34019c2a:	d1ac      	bne.n	34019b86 <_dtoa_r+0x996>
34019c2c:	4633      	mov	r3, r6
34019c2e:	461e      	mov	r6, r3
34019c30:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
34019c34:	2a30      	cmp	r2, #48	@ 0x30
34019c36:	d0fa      	beq.n	34019c2e <_dtoa_r+0xa3e>
34019c38:	e4e1      	b.n	340195fe <_dtoa_r+0x40e>
34019c3a:	429f      	cmp	r7, r3
34019c3c:	d1a4      	bne.n	34019b88 <_dtoa_r+0x998>
34019c3e:	9b05      	ldr	r3, [sp, #20]
34019c40:	3301      	adds	r3, #1
34019c42:	9305      	str	r3, [sp, #20]
34019c44:	2331      	movs	r3, #49	@ 0x31
34019c46:	703b      	strb	r3, [r7, #0]
34019c48:	e4d9      	b.n	340195fe <_dtoa_r+0x40e>
34019c4a:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34019c4c:	4f16      	ldr	r7, [pc, #88]	@ (34019ca8 <_dtoa_r+0xab8>)
34019c4e:	b11b      	cbz	r3, 34019c58 <_dtoa_r+0xa68>
34019c50:	f107 0308 	add.w	r3, r7, #8
34019c54:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
34019c56:	6013      	str	r3, [r2, #0]
34019c58:	4638      	mov	r0, r7
34019c5a:	b011      	add	sp, #68	@ 0x44
34019c5c:	ecbd 8b02 	vpop	{d8}
34019c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34019c64:	9b07      	ldr	r3, [sp, #28]
34019c66:	2b01      	cmp	r3, #1
34019c68:	f77f ae2c 	ble.w	340198c4 <_dtoa_r+0x6d4>
34019c6c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34019c6e:	930b      	str	r3, [sp, #44]	@ 0x2c
34019c70:	2001      	movs	r0, #1
34019c72:	e64c      	b.n	3401990e <_dtoa_r+0x71e>
34019c74:	f1bb 0f00 	cmp.w	fp, #0
34019c78:	f77f aed8 	ble.w	34019a2c <_dtoa_r+0x83c>
34019c7c:	463e      	mov	r6, r7
34019c7e:	4621      	mov	r1, r4
34019c80:	9801      	ldr	r0, [sp, #4]
34019c82:	f7ff fa26 	bl	340190d2 <quorem>
34019c86:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
34019c8a:	f806 ab01 	strb.w	sl, [r6], #1
34019c8e:	1bf2      	subs	r2, r6, r7
34019c90:	4593      	cmp	fp, r2
34019c92:	ddb4      	ble.n	34019bfe <_dtoa_r+0xa0e>
34019c94:	2300      	movs	r3, #0
34019c96:	220a      	movs	r2, #10
34019c98:	9901      	ldr	r1, [sp, #4]
34019c9a:	4648      	mov	r0, r9
34019c9c:	f000 f8b2 	bl	34019e04 <__multadd>
34019ca0:	9001      	str	r0, [sp, #4]
34019ca2:	e7ec      	b.n	34019c7e <_dtoa_r+0xa8e>
34019ca4:	3401e6c9 	.word	0x3401e6c9
34019ca8:	3401e64d 	.word	0x3401e64d

34019cac <_free_r>:
34019cac:	b538      	push	{r3, r4, r5, lr}
34019cae:	4605      	mov	r5, r0
34019cb0:	2900      	cmp	r1, #0
34019cb2:	d041      	beq.n	34019d38 <_free_r+0x8c>
34019cb4:	f851 3c04 	ldr.w	r3, [r1, #-4]
34019cb8:	1f0c      	subs	r4, r1, #4
34019cba:	2b00      	cmp	r3, #0
34019cbc:	bfb8      	it	lt
34019cbe:	18e4      	addlt	r4, r4, r3
34019cc0:	f7fd fec2 	bl	34017a48 <__malloc_lock>
34019cc4:	4a1d      	ldr	r2, [pc, #116]	@ (34019d3c <_free_r+0x90>)
34019cc6:	6813      	ldr	r3, [r2, #0]
34019cc8:	b933      	cbnz	r3, 34019cd8 <_free_r+0x2c>
34019cca:	6063      	str	r3, [r4, #4]
34019ccc:	6014      	str	r4, [r2, #0]
34019cce:	4628      	mov	r0, r5
34019cd0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
34019cd4:	f7fd bebe 	b.w	34017a54 <__malloc_unlock>
34019cd8:	42a3      	cmp	r3, r4
34019cda:	d908      	bls.n	34019cee <_free_r+0x42>
34019cdc:	6820      	ldr	r0, [r4, #0]
34019cde:	1821      	adds	r1, r4, r0
34019ce0:	428b      	cmp	r3, r1
34019ce2:	bf01      	itttt	eq
34019ce4:	6819      	ldreq	r1, [r3, #0]
34019ce6:	685b      	ldreq	r3, [r3, #4]
34019ce8:	1809      	addeq	r1, r1, r0
34019cea:	6021      	streq	r1, [r4, #0]
34019cec:	e7ed      	b.n	34019cca <_free_r+0x1e>
34019cee:	461a      	mov	r2, r3
34019cf0:	685b      	ldr	r3, [r3, #4]
34019cf2:	b10b      	cbz	r3, 34019cf8 <_free_r+0x4c>
34019cf4:	42a3      	cmp	r3, r4
34019cf6:	d9fa      	bls.n	34019cee <_free_r+0x42>
34019cf8:	6811      	ldr	r1, [r2, #0]
34019cfa:	1850      	adds	r0, r2, r1
34019cfc:	42a0      	cmp	r0, r4
34019cfe:	d10b      	bne.n	34019d18 <_free_r+0x6c>
34019d00:	6820      	ldr	r0, [r4, #0]
34019d02:	4401      	add	r1, r0
34019d04:	1850      	adds	r0, r2, r1
34019d06:	6011      	str	r1, [r2, #0]
34019d08:	4283      	cmp	r3, r0
34019d0a:	d1e0      	bne.n	34019cce <_free_r+0x22>
34019d0c:	6818      	ldr	r0, [r3, #0]
34019d0e:	685b      	ldr	r3, [r3, #4]
34019d10:	4408      	add	r0, r1
34019d12:	6053      	str	r3, [r2, #4]
34019d14:	6010      	str	r0, [r2, #0]
34019d16:	e7da      	b.n	34019cce <_free_r+0x22>
34019d18:	d902      	bls.n	34019d20 <_free_r+0x74>
34019d1a:	230c      	movs	r3, #12
34019d1c:	602b      	str	r3, [r5, #0]
34019d1e:	e7d6      	b.n	34019cce <_free_r+0x22>
34019d20:	6820      	ldr	r0, [r4, #0]
34019d22:	1821      	adds	r1, r4, r0
34019d24:	428b      	cmp	r3, r1
34019d26:	bf02      	ittt	eq
34019d28:	6819      	ldreq	r1, [r3, #0]
34019d2a:	685b      	ldreq	r3, [r3, #4]
34019d2c:	1809      	addeq	r1, r1, r0
34019d2e:	6063      	str	r3, [r4, #4]
34019d30:	bf08      	it	eq
34019d32:	6021      	streq	r1, [r4, #0]
34019d34:	6054      	str	r4, [r2, #4]
34019d36:	e7ca      	b.n	34019cce <_free_r+0x22>
34019d38:	bd38      	pop	{r3, r4, r5, pc}
34019d3a:	bf00      	nop
34019d3c:	340445cc 	.word	0x340445cc

34019d40 <_Balloc>:
34019d40:	b570      	push	{r4, r5, r6, lr}
34019d42:	69c6      	ldr	r6, [r0, #28]
34019d44:	4604      	mov	r4, r0
34019d46:	460d      	mov	r5, r1
34019d48:	b976      	cbnz	r6, 34019d68 <_Balloc+0x28>
34019d4a:	2010      	movs	r0, #16
34019d4c:	f7fd fdd2 	bl	340178f4 <malloc>
34019d50:	4602      	mov	r2, r0
34019d52:	61e0      	str	r0, [r4, #28]
34019d54:	b920      	cbnz	r0, 34019d60 <_Balloc+0x20>
34019d56:	4b18      	ldr	r3, [pc, #96]	@ (34019db8 <_Balloc+0x78>)
34019d58:	216b      	movs	r1, #107	@ 0x6b
34019d5a:	4818      	ldr	r0, [pc, #96]	@ (34019dbc <_Balloc+0x7c>)
34019d5c:	f7fd fdac 	bl	340178b8 <__assert_func>
34019d60:	e9c0 6601 	strd	r6, r6, [r0, #4]
34019d64:	6006      	str	r6, [r0, #0]
34019d66:	60c6      	str	r6, [r0, #12]
34019d68:	69e6      	ldr	r6, [r4, #28]
34019d6a:	68f3      	ldr	r3, [r6, #12]
34019d6c:	b183      	cbz	r3, 34019d90 <_Balloc+0x50>
34019d6e:	69e3      	ldr	r3, [r4, #28]
34019d70:	68db      	ldr	r3, [r3, #12]
34019d72:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
34019d76:	b9b8      	cbnz	r0, 34019da8 <_Balloc+0x68>
34019d78:	2101      	movs	r1, #1
34019d7a:	4620      	mov	r0, r4
34019d7c:	fa01 f605 	lsl.w	r6, r1, r5
34019d80:	1d72      	adds	r2, r6, #5
34019d82:	0092      	lsls	r2, r2, #2
34019d84:	f000 ff74 	bl	3401ac70 <_calloc_r>
34019d88:	b160      	cbz	r0, 34019da4 <_Balloc+0x64>
34019d8a:	e9c0 5601 	strd	r5, r6, [r0, #4]
34019d8e:	e00e      	b.n	34019dae <_Balloc+0x6e>
34019d90:	2221      	movs	r2, #33	@ 0x21
34019d92:	2104      	movs	r1, #4
34019d94:	4620      	mov	r0, r4
34019d96:	f000 ff6b 	bl	3401ac70 <_calloc_r>
34019d9a:	69e3      	ldr	r3, [r4, #28]
34019d9c:	60f0      	str	r0, [r6, #12]
34019d9e:	68db      	ldr	r3, [r3, #12]
34019da0:	2b00      	cmp	r3, #0
34019da2:	d1e4      	bne.n	34019d6e <_Balloc+0x2e>
34019da4:	2000      	movs	r0, #0
34019da6:	bd70      	pop	{r4, r5, r6, pc}
34019da8:	6802      	ldr	r2, [r0, #0]
34019daa:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
34019dae:	2300      	movs	r3, #0
34019db0:	e9c0 3303 	strd	r3, r3, [r0, #12]
34019db4:	e7f7      	b.n	34019da6 <_Balloc+0x66>
34019db6:	bf00      	nop
34019db8:	3401e65a 	.word	0x3401e65a
34019dbc:	3401e6da 	.word	0x3401e6da

34019dc0 <_Bfree>:
34019dc0:	b570      	push	{r4, r5, r6, lr}
34019dc2:	69c6      	ldr	r6, [r0, #28]
34019dc4:	4605      	mov	r5, r0
34019dc6:	460c      	mov	r4, r1
34019dc8:	b976      	cbnz	r6, 34019de8 <_Bfree+0x28>
34019dca:	2010      	movs	r0, #16
34019dcc:	f7fd fd92 	bl	340178f4 <malloc>
34019dd0:	4602      	mov	r2, r0
34019dd2:	61e8      	str	r0, [r5, #28]
34019dd4:	b920      	cbnz	r0, 34019de0 <_Bfree+0x20>
34019dd6:	4b09      	ldr	r3, [pc, #36]	@ (34019dfc <_Bfree+0x3c>)
34019dd8:	218f      	movs	r1, #143	@ 0x8f
34019dda:	4809      	ldr	r0, [pc, #36]	@ (34019e00 <_Bfree+0x40>)
34019ddc:	f7fd fd6c 	bl	340178b8 <__assert_func>
34019de0:	e9c0 6601 	strd	r6, r6, [r0, #4]
34019de4:	6006      	str	r6, [r0, #0]
34019de6:	60c6      	str	r6, [r0, #12]
34019de8:	b13c      	cbz	r4, 34019dfa <_Bfree+0x3a>
34019dea:	69eb      	ldr	r3, [r5, #28]
34019dec:	6862      	ldr	r2, [r4, #4]
34019dee:	68db      	ldr	r3, [r3, #12]
34019df0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
34019df4:	6021      	str	r1, [r4, #0]
34019df6:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
34019dfa:	bd70      	pop	{r4, r5, r6, pc}
34019dfc:	3401e65a 	.word	0x3401e65a
34019e00:	3401e6da 	.word	0x3401e6da

34019e04 <__multadd>:
34019e04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34019e08:	f101 0c14 	add.w	ip, r1, #20
34019e0c:	4607      	mov	r7, r0
34019e0e:	460c      	mov	r4, r1
34019e10:	461e      	mov	r6, r3
34019e12:	690d      	ldr	r5, [r1, #16]
34019e14:	2000      	movs	r0, #0
34019e16:	f8dc 3000 	ldr.w	r3, [ip]
34019e1a:	3001      	adds	r0, #1
34019e1c:	b299      	uxth	r1, r3
34019e1e:	4285      	cmp	r5, r0
34019e20:	fb02 6101 	mla	r1, r2, r1, r6
34019e24:	ea4f 4613 	mov.w	r6, r3, lsr #16
34019e28:	ea4f 4311 	mov.w	r3, r1, lsr #16
34019e2c:	b289      	uxth	r1, r1
34019e2e:	fb02 3306 	mla	r3, r2, r6, r3
34019e32:	eb01 4103 	add.w	r1, r1, r3, lsl #16
34019e36:	ea4f 4613 	mov.w	r6, r3, lsr #16
34019e3a:	f84c 1b04 	str.w	r1, [ip], #4
34019e3e:	dcea      	bgt.n	34019e16 <__multadd+0x12>
34019e40:	b30e      	cbz	r6, 34019e86 <__multadd+0x82>
34019e42:	68a3      	ldr	r3, [r4, #8]
34019e44:	42ab      	cmp	r3, r5
34019e46:	dc19      	bgt.n	34019e7c <__multadd+0x78>
34019e48:	6861      	ldr	r1, [r4, #4]
34019e4a:	4638      	mov	r0, r7
34019e4c:	3101      	adds	r1, #1
34019e4e:	f7ff ff77 	bl	34019d40 <_Balloc>
34019e52:	4680      	mov	r8, r0
34019e54:	b928      	cbnz	r0, 34019e62 <__multadd+0x5e>
34019e56:	4602      	mov	r2, r0
34019e58:	4b0c      	ldr	r3, [pc, #48]	@ (34019e8c <__multadd+0x88>)
34019e5a:	21ba      	movs	r1, #186	@ 0xba
34019e5c:	480c      	ldr	r0, [pc, #48]	@ (34019e90 <__multadd+0x8c>)
34019e5e:	f7fd fd2b 	bl	340178b8 <__assert_func>
34019e62:	6922      	ldr	r2, [r4, #16]
34019e64:	f104 010c 	add.w	r1, r4, #12
34019e68:	300c      	adds	r0, #12
34019e6a:	3202      	adds	r2, #2
34019e6c:	0092      	lsls	r2, r2, #2
34019e6e:	f7ff f91c 	bl	340190aa <memcpy>
34019e72:	4621      	mov	r1, r4
34019e74:	4644      	mov	r4, r8
34019e76:	4638      	mov	r0, r7
34019e78:	f7ff ffa2 	bl	34019dc0 <_Bfree>
34019e7c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
34019e80:	3501      	adds	r5, #1
34019e82:	615e      	str	r6, [r3, #20]
34019e84:	6125      	str	r5, [r4, #16]
34019e86:	4620      	mov	r0, r4
34019e88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34019e8c:	3401e6c9 	.word	0x3401e6c9
34019e90:	3401e6da 	.word	0x3401e6da

34019e94 <__hi0bits>:
34019e94:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
34019e98:	4603      	mov	r3, r0
34019e9a:	bf36      	itet	cc
34019e9c:	0403      	lslcc	r3, r0, #16
34019e9e:	2000      	movcs	r0, #0
34019ea0:	2010      	movcc	r0, #16
34019ea2:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34019ea6:	bf3c      	itt	cc
34019ea8:	021b      	lslcc	r3, r3, #8
34019eaa:	3008      	addcc	r0, #8
34019eac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34019eb0:	bf3c      	itt	cc
34019eb2:	011b      	lslcc	r3, r3, #4
34019eb4:	3004      	addcc	r0, #4
34019eb6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34019eba:	bf3c      	itt	cc
34019ebc:	009b      	lslcc	r3, r3, #2
34019ebe:	3002      	addcc	r0, #2
34019ec0:	2b00      	cmp	r3, #0
34019ec2:	db05      	blt.n	34019ed0 <__hi0bits+0x3c>
34019ec4:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
34019ec8:	f100 0001 	add.w	r0, r0, #1
34019ecc:	bf08      	it	eq
34019ece:	2020      	moveq	r0, #32
34019ed0:	4770      	bx	lr

34019ed2 <__lo0bits>:
34019ed2:	6803      	ldr	r3, [r0, #0]
34019ed4:	4602      	mov	r2, r0
34019ed6:	f013 0007 	ands.w	r0, r3, #7
34019eda:	d00b      	beq.n	34019ef4 <__lo0bits+0x22>
34019edc:	07d9      	lsls	r1, r3, #31
34019ede:	d421      	bmi.n	34019f24 <__lo0bits+0x52>
34019ee0:	0798      	lsls	r0, r3, #30
34019ee2:	bf47      	ittee	mi
34019ee4:	085b      	lsrmi	r3, r3, #1
34019ee6:	2001      	movmi	r0, #1
34019ee8:	089b      	lsrpl	r3, r3, #2
34019eea:	2002      	movpl	r0, #2
34019eec:	bf4c      	ite	mi
34019eee:	6013      	strmi	r3, [r2, #0]
34019ef0:	6013      	strpl	r3, [r2, #0]
34019ef2:	4770      	bx	lr
34019ef4:	b299      	uxth	r1, r3
34019ef6:	b909      	cbnz	r1, 34019efc <__lo0bits+0x2a>
34019ef8:	0c1b      	lsrs	r3, r3, #16
34019efa:	2010      	movs	r0, #16
34019efc:	b2d9      	uxtb	r1, r3
34019efe:	b909      	cbnz	r1, 34019f04 <__lo0bits+0x32>
34019f00:	3008      	adds	r0, #8
34019f02:	0a1b      	lsrs	r3, r3, #8
34019f04:	0719      	lsls	r1, r3, #28
34019f06:	bf04      	itt	eq
34019f08:	091b      	lsreq	r3, r3, #4
34019f0a:	3004      	addeq	r0, #4
34019f0c:	0799      	lsls	r1, r3, #30
34019f0e:	bf04      	itt	eq
34019f10:	089b      	lsreq	r3, r3, #2
34019f12:	3002      	addeq	r0, #2
34019f14:	07d9      	lsls	r1, r3, #31
34019f16:	d403      	bmi.n	34019f20 <__lo0bits+0x4e>
34019f18:	085b      	lsrs	r3, r3, #1
34019f1a:	f100 0001 	add.w	r0, r0, #1
34019f1e:	d003      	beq.n	34019f28 <__lo0bits+0x56>
34019f20:	6013      	str	r3, [r2, #0]
34019f22:	4770      	bx	lr
34019f24:	2000      	movs	r0, #0
34019f26:	4770      	bx	lr
34019f28:	2020      	movs	r0, #32
34019f2a:	4770      	bx	lr

34019f2c <__i2b>:
34019f2c:	b510      	push	{r4, lr}
34019f2e:	460c      	mov	r4, r1
34019f30:	2101      	movs	r1, #1
34019f32:	f7ff ff05 	bl	34019d40 <_Balloc>
34019f36:	4602      	mov	r2, r0
34019f38:	b928      	cbnz	r0, 34019f46 <__i2b+0x1a>
34019f3a:	4b05      	ldr	r3, [pc, #20]	@ (34019f50 <__i2b+0x24>)
34019f3c:	f240 1145 	movw	r1, #325	@ 0x145
34019f40:	4804      	ldr	r0, [pc, #16]	@ (34019f54 <__i2b+0x28>)
34019f42:	f7fd fcb9 	bl	340178b8 <__assert_func>
34019f46:	2301      	movs	r3, #1
34019f48:	6144      	str	r4, [r0, #20]
34019f4a:	6103      	str	r3, [r0, #16]
34019f4c:	bd10      	pop	{r4, pc}
34019f4e:	bf00      	nop
34019f50:	3401e6c9 	.word	0x3401e6c9
34019f54:	3401e6da 	.word	0x3401e6da

34019f58 <__multiply>:
34019f58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34019f5c:	4617      	mov	r7, r2
34019f5e:	690a      	ldr	r2, [r1, #16]
34019f60:	4689      	mov	r9, r1
34019f62:	b085      	sub	sp, #20
34019f64:	693b      	ldr	r3, [r7, #16]
34019f66:	429a      	cmp	r2, r3
34019f68:	bfa2      	ittt	ge
34019f6a:	463b      	movge	r3, r7
34019f6c:	460f      	movge	r7, r1
34019f6e:	4699      	movge	r9, r3
34019f70:	693d      	ldr	r5, [r7, #16]
34019f72:	68bb      	ldr	r3, [r7, #8]
34019f74:	f8d9 a010 	ldr.w	sl, [r9, #16]
34019f78:	6879      	ldr	r1, [r7, #4]
34019f7a:	eb05 060a 	add.w	r6, r5, sl
34019f7e:	42b3      	cmp	r3, r6
34019f80:	bfb8      	it	lt
34019f82:	3101      	addlt	r1, #1
34019f84:	f7ff fedc 	bl	34019d40 <_Balloc>
34019f88:	b930      	cbnz	r0, 34019f98 <__multiply+0x40>
34019f8a:	4602      	mov	r2, r0
34019f8c:	4b42      	ldr	r3, [pc, #264]	@ (3401a098 <__multiply+0x140>)
34019f8e:	f44f 71b1 	mov.w	r1, #354	@ 0x162
34019f92:	4842      	ldr	r0, [pc, #264]	@ (3401a09c <__multiply+0x144>)
34019f94:	f7fd fc90 	bl	340178b8 <__assert_func>
34019f98:	f100 0414 	add.w	r4, r0, #20
34019f9c:	2200      	movs	r2, #0
34019f9e:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
34019fa2:	4623      	mov	r3, r4
34019fa4:	4573      	cmp	r3, lr
34019fa6:	d320      	bcc.n	34019fea <__multiply+0x92>
34019fa8:	f107 0814 	add.w	r8, r7, #20
34019fac:	f109 0114 	add.w	r1, r9, #20
34019fb0:	eb08 0585 	add.w	r5, r8, r5, lsl #2
34019fb4:	eb01 038a 	add.w	r3, r1, sl, lsl #2
34019fb8:	9302      	str	r3, [sp, #8]
34019fba:	1beb      	subs	r3, r5, r7
34019fbc:	3715      	adds	r7, #21
34019fbe:	3b15      	subs	r3, #21
34019fc0:	f023 0303 	bic.w	r3, r3, #3
34019fc4:	3304      	adds	r3, #4
34019fc6:	42bd      	cmp	r5, r7
34019fc8:	bf38      	it	cc
34019fca:	2304      	movcc	r3, #4
34019fcc:	9301      	str	r3, [sp, #4]
34019fce:	9b02      	ldr	r3, [sp, #8]
34019fd0:	9103      	str	r1, [sp, #12]
34019fd2:	428b      	cmp	r3, r1
34019fd4:	d80c      	bhi.n	34019ff0 <__multiply+0x98>
34019fd6:	2e00      	cmp	r6, #0
34019fd8:	dd03      	ble.n	34019fe2 <__multiply+0x8a>
34019fda:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
34019fde:	2b00      	cmp	r3, #0
34019fe0:	d057      	beq.n	3401a092 <__multiply+0x13a>
34019fe2:	6106      	str	r6, [r0, #16]
34019fe4:	b005      	add	sp, #20
34019fe6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34019fea:	f843 2b04 	str.w	r2, [r3], #4
34019fee:	e7d9      	b.n	34019fa4 <__multiply+0x4c>
34019ff0:	f8b1 a000 	ldrh.w	sl, [r1]
34019ff4:	f1ba 0f00 	cmp.w	sl, #0
34019ff8:	d021      	beq.n	3401a03e <__multiply+0xe6>
34019ffa:	46c4      	mov	ip, r8
34019ffc:	46a1      	mov	r9, r4
34019ffe:	2700      	movs	r7, #0
3401a000:	f85c 2b04 	ldr.w	r2, [ip], #4
3401a004:	f8d9 3000 	ldr.w	r3, [r9]
3401a008:	fa1f fb82 	uxth.w	fp, r2
3401a00c:	4565      	cmp	r5, ip
3401a00e:	b29b      	uxth	r3, r3
3401a010:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401a014:	fb0a 330b 	mla	r3, sl, fp, r3
3401a018:	443b      	add	r3, r7
3401a01a:	f8d9 7000 	ldr.w	r7, [r9]
3401a01e:	ea4f 4717 	mov.w	r7, r7, lsr #16
3401a022:	fb0a 7202 	mla	r2, sl, r2, r7
3401a026:	eb02 4213 	add.w	r2, r2, r3, lsr #16
3401a02a:	b29b      	uxth	r3, r3
3401a02c:	ea4f 4712 	mov.w	r7, r2, lsr #16
3401a030:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401a034:	f849 3b04 	str.w	r3, [r9], #4
3401a038:	d8e2      	bhi.n	3401a000 <__multiply+0xa8>
3401a03a:	9b01      	ldr	r3, [sp, #4]
3401a03c:	50e7      	str	r7, [r4, r3]
3401a03e:	9b03      	ldr	r3, [sp, #12]
3401a040:	3104      	adds	r1, #4
3401a042:	f8b3 9002 	ldrh.w	r9, [r3, #2]
3401a046:	f1b9 0f00 	cmp.w	r9, #0
3401a04a:	d020      	beq.n	3401a08e <__multiply+0x136>
3401a04c:	6823      	ldr	r3, [r4, #0]
3401a04e:	4647      	mov	r7, r8
3401a050:	46a4      	mov	ip, r4
3401a052:	f04f 0a00 	mov.w	sl, #0
3401a056:	f8b7 b000 	ldrh.w	fp, [r7]
3401a05a:	b29b      	uxth	r3, r3
3401a05c:	f8bc 2002 	ldrh.w	r2, [ip, #2]
3401a060:	fb09 220b 	mla	r2, r9, fp, r2
3401a064:	4452      	add	r2, sl
3401a066:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401a06a:	f84c 3b04 	str.w	r3, [ip], #4
3401a06e:	f857 3b04 	ldr.w	r3, [r7], #4
3401a072:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401a076:	f8bc 3000 	ldrh.w	r3, [ip]
3401a07a:	42bd      	cmp	r5, r7
3401a07c:	fb09 330a 	mla	r3, r9, sl, r3
3401a080:	eb03 4312 	add.w	r3, r3, r2, lsr #16
3401a084:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401a088:	d8e5      	bhi.n	3401a056 <__multiply+0xfe>
3401a08a:	9a01      	ldr	r2, [sp, #4]
3401a08c:	50a3      	str	r3, [r4, r2]
3401a08e:	3404      	adds	r4, #4
3401a090:	e79d      	b.n	34019fce <__multiply+0x76>
3401a092:	3e01      	subs	r6, #1
3401a094:	e79f      	b.n	34019fd6 <__multiply+0x7e>
3401a096:	bf00      	nop
3401a098:	3401e6c9 	.word	0x3401e6c9
3401a09c:	3401e6da 	.word	0x3401e6da

3401a0a0 <__pow5mult>:
3401a0a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401a0a4:	4615      	mov	r5, r2
3401a0a6:	f012 0203 	ands.w	r2, r2, #3
3401a0aa:	4607      	mov	r7, r0
3401a0ac:	460e      	mov	r6, r1
3401a0ae:	d007      	beq.n	3401a0c0 <__pow5mult+0x20>
3401a0b0:	3a01      	subs	r2, #1
3401a0b2:	4c25      	ldr	r4, [pc, #148]	@ (3401a148 <__pow5mult+0xa8>)
3401a0b4:	2300      	movs	r3, #0
3401a0b6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
3401a0ba:	f7ff fea3 	bl	34019e04 <__multadd>
3401a0be:	4606      	mov	r6, r0
3401a0c0:	10ad      	asrs	r5, r5, #2
3401a0c2:	d03d      	beq.n	3401a140 <__pow5mult+0xa0>
3401a0c4:	69fc      	ldr	r4, [r7, #28]
3401a0c6:	b97c      	cbnz	r4, 3401a0e8 <__pow5mult+0x48>
3401a0c8:	2010      	movs	r0, #16
3401a0ca:	f7fd fc13 	bl	340178f4 <malloc>
3401a0ce:	4602      	mov	r2, r0
3401a0d0:	61f8      	str	r0, [r7, #28]
3401a0d2:	b928      	cbnz	r0, 3401a0e0 <__pow5mult+0x40>
3401a0d4:	4b1d      	ldr	r3, [pc, #116]	@ (3401a14c <__pow5mult+0xac>)
3401a0d6:	f240 11b3 	movw	r1, #435	@ 0x1b3
3401a0da:	481d      	ldr	r0, [pc, #116]	@ (3401a150 <__pow5mult+0xb0>)
3401a0dc:	f7fd fbec 	bl	340178b8 <__assert_func>
3401a0e0:	e9c0 4401 	strd	r4, r4, [r0, #4]
3401a0e4:	6004      	str	r4, [r0, #0]
3401a0e6:	60c4      	str	r4, [r0, #12]
3401a0e8:	f8d7 801c 	ldr.w	r8, [r7, #28]
3401a0ec:	f8d8 4008 	ldr.w	r4, [r8, #8]
3401a0f0:	b94c      	cbnz	r4, 3401a106 <__pow5mult+0x66>
3401a0f2:	f240 2171 	movw	r1, #625	@ 0x271
3401a0f6:	4638      	mov	r0, r7
3401a0f8:	f7ff ff18 	bl	34019f2c <__i2b>
3401a0fc:	2300      	movs	r3, #0
3401a0fe:	4604      	mov	r4, r0
3401a100:	f8c8 0008 	str.w	r0, [r8, #8]
3401a104:	6003      	str	r3, [r0, #0]
3401a106:	f04f 0900 	mov.w	r9, #0
3401a10a:	07eb      	lsls	r3, r5, #31
3401a10c:	d50a      	bpl.n	3401a124 <__pow5mult+0x84>
3401a10e:	4631      	mov	r1, r6
3401a110:	4622      	mov	r2, r4
3401a112:	4638      	mov	r0, r7
3401a114:	f7ff ff20 	bl	34019f58 <__multiply>
3401a118:	4680      	mov	r8, r0
3401a11a:	4631      	mov	r1, r6
3401a11c:	4638      	mov	r0, r7
3401a11e:	4646      	mov	r6, r8
3401a120:	f7ff fe4e 	bl	34019dc0 <_Bfree>
3401a124:	106d      	asrs	r5, r5, #1
3401a126:	d00b      	beq.n	3401a140 <__pow5mult+0xa0>
3401a128:	6820      	ldr	r0, [r4, #0]
3401a12a:	b938      	cbnz	r0, 3401a13c <__pow5mult+0x9c>
3401a12c:	4622      	mov	r2, r4
3401a12e:	4621      	mov	r1, r4
3401a130:	4638      	mov	r0, r7
3401a132:	f7ff ff11 	bl	34019f58 <__multiply>
3401a136:	6020      	str	r0, [r4, #0]
3401a138:	f8c0 9000 	str.w	r9, [r0]
3401a13c:	4604      	mov	r4, r0
3401a13e:	e7e4      	b.n	3401a10a <__pow5mult+0x6a>
3401a140:	4630      	mov	r0, r6
3401a142:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401a146:	bf00      	nop
3401a148:	3403c670 	.word	0x3403c670
3401a14c:	3401e65a 	.word	0x3401e65a
3401a150:	3401e6da 	.word	0x3401e6da

3401a154 <__lshift>:
3401a154:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401a158:	460c      	mov	r4, r1
3401a15a:	4607      	mov	r7, r0
3401a15c:	4691      	mov	r9, r2
3401a15e:	ea4f 1a62 	mov.w	sl, r2, asr #5
3401a162:	6923      	ldr	r3, [r4, #16]
3401a164:	6849      	ldr	r1, [r1, #4]
3401a166:	eb03 1862 	add.w	r8, r3, r2, asr #5
3401a16a:	68a3      	ldr	r3, [r4, #8]
3401a16c:	f108 0601 	add.w	r6, r8, #1
3401a170:	42b3      	cmp	r3, r6
3401a172:	db0b      	blt.n	3401a18c <__lshift+0x38>
3401a174:	4638      	mov	r0, r7
3401a176:	f7ff fde3 	bl	34019d40 <_Balloc>
3401a17a:	4605      	mov	r5, r0
3401a17c:	b948      	cbnz	r0, 3401a192 <__lshift+0x3e>
3401a17e:	4602      	mov	r2, r0
3401a180:	4b28      	ldr	r3, [pc, #160]	@ (3401a224 <__lshift+0xd0>)
3401a182:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3401a186:	4828      	ldr	r0, [pc, #160]	@ (3401a228 <__lshift+0xd4>)
3401a188:	f7fd fb96 	bl	340178b8 <__assert_func>
3401a18c:	3101      	adds	r1, #1
3401a18e:	005b      	lsls	r3, r3, #1
3401a190:	e7ee      	b.n	3401a170 <__lshift+0x1c>
3401a192:	2300      	movs	r3, #0
3401a194:	f100 0114 	add.w	r1, r0, #20
3401a198:	f100 0210 	add.w	r2, r0, #16
3401a19c:	4618      	mov	r0, r3
3401a19e:	4553      	cmp	r3, sl
3401a1a0:	db33      	blt.n	3401a20a <__lshift+0xb6>
3401a1a2:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
3401a1a6:	f104 0314 	add.w	r3, r4, #20
3401a1aa:	6920      	ldr	r0, [r4, #16]
3401a1ac:	f019 091f 	ands.w	r9, r9, #31
3401a1b0:	eb01 018a 	add.w	r1, r1, sl, lsl #2
3401a1b4:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
3401a1b8:	d02b      	beq.n	3401a212 <__lshift+0xbe>
3401a1ba:	f1c9 0e20 	rsb	lr, r9, #32
3401a1be:	468a      	mov	sl, r1
3401a1c0:	2200      	movs	r2, #0
3401a1c2:	6818      	ldr	r0, [r3, #0]
3401a1c4:	fa00 f009 	lsl.w	r0, r0, r9
3401a1c8:	4310      	orrs	r0, r2
3401a1ca:	f84a 0b04 	str.w	r0, [sl], #4
3401a1ce:	f853 2b04 	ldr.w	r2, [r3], #4
3401a1d2:	459c      	cmp	ip, r3
3401a1d4:	fa22 f20e 	lsr.w	r2, r2, lr
3401a1d8:	d8f3      	bhi.n	3401a1c2 <__lshift+0x6e>
3401a1da:	ebac 0304 	sub.w	r3, ip, r4
3401a1de:	f104 0015 	add.w	r0, r4, #21
3401a1e2:	3b15      	subs	r3, #21
3401a1e4:	f023 0303 	bic.w	r3, r3, #3
3401a1e8:	3304      	adds	r3, #4
3401a1ea:	4560      	cmp	r0, ip
3401a1ec:	bf88      	it	hi
3401a1ee:	2304      	movhi	r3, #4
3401a1f0:	50ca      	str	r2, [r1, r3]
3401a1f2:	b10a      	cbz	r2, 3401a1f8 <__lshift+0xa4>
3401a1f4:	f108 0602 	add.w	r6, r8, #2
3401a1f8:	3e01      	subs	r6, #1
3401a1fa:	4638      	mov	r0, r7
3401a1fc:	4621      	mov	r1, r4
3401a1fe:	612e      	str	r6, [r5, #16]
3401a200:	f7ff fdde 	bl	34019dc0 <_Bfree>
3401a204:	4628      	mov	r0, r5
3401a206:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401a20a:	3301      	adds	r3, #1
3401a20c:	f842 0f04 	str.w	r0, [r2, #4]!
3401a210:	e7c5      	b.n	3401a19e <__lshift+0x4a>
3401a212:	3904      	subs	r1, #4
3401a214:	f853 2b04 	ldr.w	r2, [r3], #4
3401a218:	459c      	cmp	ip, r3
3401a21a:	f841 2f04 	str.w	r2, [r1, #4]!
3401a21e:	d8f9      	bhi.n	3401a214 <__lshift+0xc0>
3401a220:	e7ea      	b.n	3401a1f8 <__lshift+0xa4>
3401a222:	bf00      	nop
3401a224:	3401e6c9 	.word	0x3401e6c9
3401a228:	3401e6da 	.word	0x3401e6da

3401a22c <__mcmp>:
3401a22c:	4603      	mov	r3, r0
3401a22e:	690a      	ldr	r2, [r1, #16]
3401a230:	6900      	ldr	r0, [r0, #16]
3401a232:	1a80      	subs	r0, r0, r2
3401a234:	b530      	push	{r4, r5, lr}
3401a236:	d10e      	bne.n	3401a256 <__mcmp+0x2a>
3401a238:	3314      	adds	r3, #20
3401a23a:	3114      	adds	r1, #20
3401a23c:	eb03 0482 	add.w	r4, r3, r2, lsl #2
3401a240:	eb01 0182 	add.w	r1, r1, r2, lsl #2
3401a244:	f854 5d04 	ldr.w	r5, [r4, #-4]!
3401a248:	f851 2d04 	ldr.w	r2, [r1, #-4]!
3401a24c:	4295      	cmp	r5, r2
3401a24e:	d003      	beq.n	3401a258 <__mcmp+0x2c>
3401a250:	d205      	bcs.n	3401a25e <__mcmp+0x32>
3401a252:	f04f 30ff 	mov.w	r0, #4294967295
3401a256:	bd30      	pop	{r4, r5, pc}
3401a258:	42a3      	cmp	r3, r4
3401a25a:	d3f3      	bcc.n	3401a244 <__mcmp+0x18>
3401a25c:	e7fb      	b.n	3401a256 <__mcmp+0x2a>
3401a25e:	2001      	movs	r0, #1
3401a260:	e7f9      	b.n	3401a256 <__mcmp+0x2a>
	...

3401a264 <__mdiff>:
3401a264:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a268:	4689      	mov	r9, r1
3401a26a:	4606      	mov	r6, r0
3401a26c:	4611      	mov	r1, r2
3401a26e:	4614      	mov	r4, r2
3401a270:	4648      	mov	r0, r9
3401a272:	f7ff ffdb 	bl	3401a22c <__mcmp>
3401a276:	1e05      	subs	r5, r0, #0
3401a278:	d112      	bne.n	3401a2a0 <__mdiff+0x3c>
3401a27a:	4629      	mov	r1, r5
3401a27c:	4630      	mov	r0, r6
3401a27e:	f7ff fd5f 	bl	34019d40 <_Balloc>
3401a282:	4602      	mov	r2, r0
3401a284:	b928      	cbnz	r0, 3401a292 <__mdiff+0x2e>
3401a286:	4b41      	ldr	r3, [pc, #260]	@ (3401a38c <__mdiff+0x128>)
3401a288:	f240 2137 	movw	r1, #567	@ 0x237
3401a28c:	4840      	ldr	r0, [pc, #256]	@ (3401a390 <__mdiff+0x12c>)
3401a28e:	f7fd fb13 	bl	340178b8 <__assert_func>
3401a292:	2301      	movs	r3, #1
3401a294:	e9c0 3504 	strd	r3, r5, [r0, #16]
3401a298:	4610      	mov	r0, r2
3401a29a:	b003      	add	sp, #12
3401a29c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a2a0:	bfbc      	itt	lt
3401a2a2:	464b      	movlt	r3, r9
3401a2a4:	46a1      	movlt	r9, r4
3401a2a6:	4630      	mov	r0, r6
3401a2a8:	bfb8      	it	lt
3401a2aa:	2501      	movlt	r5, #1
3401a2ac:	f8d9 1004 	ldr.w	r1, [r9, #4]
3401a2b0:	bfb4      	ite	lt
3401a2b2:	461c      	movlt	r4, r3
3401a2b4:	2500      	movge	r5, #0
3401a2b6:	f7ff fd43 	bl	34019d40 <_Balloc>
3401a2ba:	4602      	mov	r2, r0
3401a2bc:	b918      	cbnz	r0, 3401a2c6 <__mdiff+0x62>
3401a2be:	4b33      	ldr	r3, [pc, #204]	@ (3401a38c <__mdiff+0x128>)
3401a2c0:	f240 2145 	movw	r1, #581	@ 0x245
3401a2c4:	e7e2      	b.n	3401a28c <__mdiff+0x28>
3401a2c6:	f8d9 7010 	ldr.w	r7, [r9, #16]
3401a2ca:	f104 0e14 	add.w	lr, r4, #20
3401a2ce:	6926      	ldr	r6, [r4, #16]
3401a2d0:	f100 0b14 	add.w	fp, r0, #20
3401a2d4:	60c5      	str	r5, [r0, #12]
3401a2d6:	f109 0514 	add.w	r5, r9, #20
3401a2da:	f109 0310 	add.w	r3, r9, #16
3401a2de:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
3401a2e2:	eb05 0887 	add.w	r8, r5, r7, lsl #2
3401a2e6:	46d9      	mov	r9, fp
3401a2e8:	f04f 0c00 	mov.w	ip, #0
3401a2ec:	9301      	str	r3, [sp, #4]
3401a2ee:	9b01      	ldr	r3, [sp, #4]
3401a2f0:	f85e 0b04 	ldr.w	r0, [lr], #4
3401a2f4:	f853 af04 	ldr.w	sl, [r3, #4]!
3401a2f8:	4576      	cmp	r6, lr
3401a2fa:	9301      	str	r3, [sp, #4]
3401a2fc:	fa1f f38a 	uxth.w	r3, sl
3401a300:	4619      	mov	r1, r3
3401a302:	b283      	uxth	r3, r0
3401a304:	ea4f 4010 	mov.w	r0, r0, lsr #16
3401a308:	eba1 0303 	sub.w	r3, r1, r3
3401a30c:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
3401a310:	4463      	add	r3, ip
3401a312:	eb00 4023 	add.w	r0, r0, r3, asr #16
3401a316:	b29b      	uxth	r3, r3
3401a318:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401a31c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3401a320:	f849 3b04 	str.w	r3, [r9], #4
3401a324:	d8e3      	bhi.n	3401a2ee <__mdiff+0x8a>
3401a326:	1b33      	subs	r3, r6, r4
3401a328:	3415      	adds	r4, #21
3401a32a:	3b15      	subs	r3, #21
3401a32c:	f023 0303 	bic.w	r3, r3, #3
3401a330:	3304      	adds	r3, #4
3401a332:	42a6      	cmp	r6, r4
3401a334:	bf38      	it	cc
3401a336:	2304      	movcc	r3, #4
3401a338:	441d      	add	r5, r3
3401a33a:	445b      	add	r3, fp
3401a33c:	462c      	mov	r4, r5
3401a33e:	461e      	mov	r6, r3
3401a340:	4544      	cmp	r4, r8
3401a342:	d30e      	bcc.n	3401a362 <__mdiff+0xfe>
3401a344:	f108 0103 	add.w	r1, r8, #3
3401a348:	1b49      	subs	r1, r1, r5
3401a34a:	3d03      	subs	r5, #3
3401a34c:	f021 0103 	bic.w	r1, r1, #3
3401a350:	45a8      	cmp	r8, r5
3401a352:	bf38      	it	cc
3401a354:	2100      	movcc	r1, #0
3401a356:	440b      	add	r3, r1
3401a358:	f853 1d04 	ldr.w	r1, [r3, #-4]!
3401a35c:	b199      	cbz	r1, 3401a386 <__mdiff+0x122>
3401a35e:	6117      	str	r7, [r2, #16]
3401a360:	e79a      	b.n	3401a298 <__mdiff+0x34>
3401a362:	f854 1b04 	ldr.w	r1, [r4], #4
3401a366:	46e6      	mov	lr, ip
3401a368:	fa1f fc81 	uxth.w	ip, r1
3401a36c:	0c08      	lsrs	r0, r1, #16
3401a36e:	4471      	add	r1, lr
3401a370:	44f4      	add	ip, lr
3401a372:	b289      	uxth	r1, r1
3401a374:	eb00 402c 	add.w	r0, r0, ip, asr #16
3401a378:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
3401a37c:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401a380:	f846 1b04 	str.w	r1, [r6], #4
3401a384:	e7dc      	b.n	3401a340 <__mdiff+0xdc>
3401a386:	3f01      	subs	r7, #1
3401a388:	e7e6      	b.n	3401a358 <__mdiff+0xf4>
3401a38a:	bf00      	nop
3401a38c:	3401e6c9 	.word	0x3401e6c9
3401a390:	3401e6da 	.word	0x3401e6da

3401a394 <__d2b>:
3401a394:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
3401a398:	460f      	mov	r7, r1
3401a39a:	2101      	movs	r1, #1
3401a39c:	4616      	mov	r6, r2
3401a39e:	ec59 8b10 	vmov	r8, r9, d0
3401a3a2:	f7ff fccd 	bl	34019d40 <_Balloc>
3401a3a6:	4604      	mov	r4, r0
3401a3a8:	b930      	cbnz	r0, 3401a3b8 <__d2b+0x24>
3401a3aa:	4602      	mov	r2, r0
3401a3ac:	4b23      	ldr	r3, [pc, #140]	@ (3401a43c <__d2b+0xa8>)
3401a3ae:	f240 310f 	movw	r1, #783	@ 0x30f
3401a3b2:	4823      	ldr	r0, [pc, #140]	@ (3401a440 <__d2b+0xac>)
3401a3b4:	f7fd fa80 	bl	340178b8 <__assert_func>
3401a3b8:	f3c9 550a 	ubfx	r5, r9, #20, #11
3401a3bc:	f3c9 0313 	ubfx	r3, r9, #0, #20
3401a3c0:	b10d      	cbz	r5, 3401a3c6 <__d2b+0x32>
3401a3c2:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
3401a3c6:	9301      	str	r3, [sp, #4]
3401a3c8:	f1b8 0300 	subs.w	r3, r8, #0
3401a3cc:	d023      	beq.n	3401a416 <__d2b+0x82>
3401a3ce:	4668      	mov	r0, sp
3401a3d0:	9300      	str	r3, [sp, #0]
3401a3d2:	f7ff fd7e 	bl	34019ed2 <__lo0bits>
3401a3d6:	e9dd 1200 	ldrd	r1, r2, [sp]
3401a3da:	b1d0      	cbz	r0, 3401a412 <__d2b+0x7e>
3401a3dc:	f1c0 0320 	rsb	r3, r0, #32
3401a3e0:	fa02 f303 	lsl.w	r3, r2, r3
3401a3e4:	40c2      	lsrs	r2, r0
3401a3e6:	430b      	orrs	r3, r1
3401a3e8:	9201      	str	r2, [sp, #4]
3401a3ea:	6163      	str	r3, [r4, #20]
3401a3ec:	9b01      	ldr	r3, [sp, #4]
3401a3ee:	2b00      	cmp	r3, #0
3401a3f0:	61a3      	str	r3, [r4, #24]
3401a3f2:	bf0c      	ite	eq
3401a3f4:	2201      	moveq	r2, #1
3401a3f6:	2202      	movne	r2, #2
3401a3f8:	6122      	str	r2, [r4, #16]
3401a3fa:	b1a5      	cbz	r5, 3401a426 <__d2b+0x92>
3401a3fc:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
3401a400:	4405      	add	r5, r0
3401a402:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
3401a406:	603d      	str	r5, [r7, #0]
3401a408:	6030      	str	r0, [r6, #0]
3401a40a:	4620      	mov	r0, r4
3401a40c:	b003      	add	sp, #12
3401a40e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
3401a412:	6161      	str	r1, [r4, #20]
3401a414:	e7ea      	b.n	3401a3ec <__d2b+0x58>
3401a416:	a801      	add	r0, sp, #4
3401a418:	f7ff fd5b 	bl	34019ed2 <__lo0bits>
3401a41c:	9b01      	ldr	r3, [sp, #4]
3401a41e:	3020      	adds	r0, #32
3401a420:	2201      	movs	r2, #1
3401a422:	6163      	str	r3, [r4, #20]
3401a424:	e7e8      	b.n	3401a3f8 <__d2b+0x64>
3401a426:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
3401a42a:	eb04 0382 	add.w	r3, r4, r2, lsl #2
3401a42e:	6038      	str	r0, [r7, #0]
3401a430:	6918      	ldr	r0, [r3, #16]
3401a432:	f7ff fd2f 	bl	34019e94 <__hi0bits>
3401a436:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
3401a43a:	e7e5      	b.n	3401a408 <__d2b+0x74>
3401a43c:	3401e6c9 	.word	0x3401e6c9
3401a440:	3401e6da 	.word	0x3401e6da

3401a444 <_malloc_usable_size_r>:
3401a444:	f851 3c04 	ldr.w	r3, [r1, #-4]
3401a448:	1f18      	subs	r0, r3, #4
3401a44a:	2b00      	cmp	r3, #0
3401a44c:	bfbc      	itt	lt
3401a44e:	580b      	ldrlt	r3, [r1, r0]
3401a450:	18c0      	addlt	r0, r0, r3
3401a452:	4770      	bx	lr

3401a454 <__ssputs_r>:
3401a454:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401a458:	461f      	mov	r7, r3
3401a45a:	688e      	ldr	r6, [r1, #8]
3401a45c:	4682      	mov	sl, r0
3401a45e:	460c      	mov	r4, r1
3401a460:	42be      	cmp	r6, r7
3401a462:	4690      	mov	r8, r2
3401a464:	680b      	ldr	r3, [r1, #0]
3401a466:	d82d      	bhi.n	3401a4c4 <__ssputs_r+0x70>
3401a468:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401a46c:	f412 6f90 	tst.w	r2, #1152	@ 0x480
3401a470:	d026      	beq.n	3401a4c0 <__ssputs_r+0x6c>
3401a472:	6965      	ldr	r5, [r4, #20]
3401a474:	6909      	ldr	r1, [r1, #16]
3401a476:	eb05 0545 	add.w	r5, r5, r5, lsl #1
3401a47a:	eba3 0901 	sub.w	r9, r3, r1
3401a47e:	1c7b      	adds	r3, r7, #1
3401a480:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
3401a484:	444b      	add	r3, r9
3401a486:	106d      	asrs	r5, r5, #1
3401a488:	429d      	cmp	r5, r3
3401a48a:	bf38      	it	cc
3401a48c:	461d      	movcc	r5, r3
3401a48e:	0553      	lsls	r3, r2, #21
3401a490:	d527      	bpl.n	3401a4e2 <__ssputs_r+0x8e>
3401a492:	4629      	mov	r1, r5
3401a494:	f7fd fa58 	bl	34017948 <_malloc_r>
3401a498:	4606      	mov	r6, r0
3401a49a:	b360      	cbz	r0, 3401a4f6 <__ssputs_r+0xa2>
3401a49c:	464a      	mov	r2, r9
3401a49e:	6921      	ldr	r1, [r4, #16]
3401a4a0:	f7fe fe03 	bl	340190aa <memcpy>
3401a4a4:	89a3      	ldrh	r3, [r4, #12]
3401a4a6:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
3401a4aa:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401a4ae:	81a3      	strh	r3, [r4, #12]
3401a4b0:	6126      	str	r6, [r4, #16]
3401a4b2:	444e      	add	r6, r9
3401a4b4:	6165      	str	r5, [r4, #20]
3401a4b6:	eba5 0509 	sub.w	r5, r5, r9
3401a4ba:	6026      	str	r6, [r4, #0]
3401a4bc:	463e      	mov	r6, r7
3401a4be:	60a5      	str	r5, [r4, #8]
3401a4c0:	42be      	cmp	r6, r7
3401a4c2:	d900      	bls.n	3401a4c6 <__ssputs_r+0x72>
3401a4c4:	463e      	mov	r6, r7
3401a4c6:	4632      	mov	r2, r6
3401a4c8:	4641      	mov	r1, r8
3401a4ca:	6820      	ldr	r0, [r4, #0]
3401a4cc:	f7fe fb3c 	bl	34018b48 <memmove>
3401a4d0:	68a3      	ldr	r3, [r4, #8]
3401a4d2:	2000      	movs	r0, #0
3401a4d4:	1b9b      	subs	r3, r3, r6
3401a4d6:	60a3      	str	r3, [r4, #8]
3401a4d8:	6823      	ldr	r3, [r4, #0]
3401a4da:	4433      	add	r3, r6
3401a4dc:	6023      	str	r3, [r4, #0]
3401a4de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401a4e2:	462a      	mov	r2, r5
3401a4e4:	f7fd fabc 	bl	34017a60 <_realloc_r>
3401a4e8:	4606      	mov	r6, r0
3401a4ea:	2800      	cmp	r0, #0
3401a4ec:	d1e0      	bne.n	3401a4b0 <__ssputs_r+0x5c>
3401a4ee:	6921      	ldr	r1, [r4, #16]
3401a4f0:	4650      	mov	r0, sl
3401a4f2:	f7ff fbdb 	bl	34019cac <_free_r>
3401a4f6:	230c      	movs	r3, #12
3401a4f8:	f04f 30ff 	mov.w	r0, #4294967295
3401a4fc:	f8ca 3000 	str.w	r3, [sl]
3401a500:	89a3      	ldrh	r3, [r4, #12]
3401a502:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401a506:	81a3      	strh	r3, [r4, #12]
3401a508:	e7e9      	b.n	3401a4de <__ssputs_r+0x8a>
	...

3401a50c <_svfiprintf_r>:
3401a50c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a510:	4698      	mov	r8, r3
3401a512:	898b      	ldrh	r3, [r1, #12]
3401a514:	b09d      	sub	sp, #116	@ 0x74
3401a516:	4607      	mov	r7, r0
3401a518:	061b      	lsls	r3, r3, #24
3401a51a:	460d      	mov	r5, r1
3401a51c:	4614      	mov	r4, r2
3401a51e:	d510      	bpl.n	3401a542 <_svfiprintf_r+0x36>
3401a520:	690b      	ldr	r3, [r1, #16]
3401a522:	b973      	cbnz	r3, 3401a542 <_svfiprintf_r+0x36>
3401a524:	2140      	movs	r1, #64	@ 0x40
3401a526:	f7fd fa0f 	bl	34017948 <_malloc_r>
3401a52a:	6028      	str	r0, [r5, #0]
3401a52c:	6128      	str	r0, [r5, #16]
3401a52e:	b930      	cbnz	r0, 3401a53e <_svfiprintf_r+0x32>
3401a530:	230c      	movs	r3, #12
3401a532:	603b      	str	r3, [r7, #0]
3401a534:	f04f 30ff 	mov.w	r0, #4294967295
3401a538:	b01d      	add	sp, #116	@ 0x74
3401a53a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a53e:	2340      	movs	r3, #64	@ 0x40
3401a540:	616b      	str	r3, [r5, #20]
3401a542:	2300      	movs	r3, #0
3401a544:	f8cd 800c 	str.w	r8, [sp, #12]
3401a548:	f04f 0901 	mov.w	r9, #1
3401a54c:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 3401a6f0 <_svfiprintf_r+0x1e4>
3401a550:	9309      	str	r3, [sp, #36]	@ 0x24
3401a552:	2320      	movs	r3, #32
3401a554:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401a558:	2330      	movs	r3, #48	@ 0x30
3401a55a:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401a55e:	4623      	mov	r3, r4
3401a560:	469a      	mov	sl, r3
3401a562:	f813 2b01 	ldrb.w	r2, [r3], #1
3401a566:	b10a      	cbz	r2, 3401a56c <_svfiprintf_r+0x60>
3401a568:	2a25      	cmp	r2, #37	@ 0x25
3401a56a:	d1f9      	bne.n	3401a560 <_svfiprintf_r+0x54>
3401a56c:	ebba 0b04 	subs.w	fp, sl, r4
3401a570:	d00b      	beq.n	3401a58a <_svfiprintf_r+0x7e>
3401a572:	465b      	mov	r3, fp
3401a574:	4622      	mov	r2, r4
3401a576:	4629      	mov	r1, r5
3401a578:	4638      	mov	r0, r7
3401a57a:	f7ff ff6b 	bl	3401a454 <__ssputs_r>
3401a57e:	3001      	adds	r0, #1
3401a580:	f000 80a7 	beq.w	3401a6d2 <_svfiprintf_r+0x1c6>
3401a584:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401a586:	445a      	add	r2, fp
3401a588:	9209      	str	r2, [sp, #36]	@ 0x24
3401a58a:	f89a 3000 	ldrb.w	r3, [sl]
3401a58e:	2b00      	cmp	r3, #0
3401a590:	f000 809f 	beq.w	3401a6d2 <_svfiprintf_r+0x1c6>
3401a594:	2300      	movs	r3, #0
3401a596:	f04f 32ff 	mov.w	r2, #4294967295
3401a59a:	f10a 0a01 	add.w	sl, sl, #1
3401a59e:	9304      	str	r3, [sp, #16]
3401a5a0:	9307      	str	r3, [sp, #28]
3401a5a2:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401a5a6:	931a      	str	r3, [sp, #104]	@ 0x68
3401a5a8:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401a5ac:	4654      	mov	r4, sl
3401a5ae:	2205      	movs	r2, #5
3401a5b0:	484f      	ldr	r0, [pc, #316]	@ (3401a6f0 <_svfiprintf_r+0x1e4>)
3401a5b2:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a5b6:	f7fe fd6a 	bl	3401908e <memchr>
3401a5ba:	9a04      	ldr	r2, [sp, #16]
3401a5bc:	b9d8      	cbnz	r0, 3401a5f6 <_svfiprintf_r+0xea>
3401a5be:	06d0      	lsls	r0, r2, #27
3401a5c0:	bf44      	itt	mi
3401a5c2:	2320      	movmi	r3, #32
3401a5c4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a5c8:	0711      	lsls	r1, r2, #28
3401a5ca:	bf44      	itt	mi
3401a5cc:	232b      	movmi	r3, #43	@ 0x2b
3401a5ce:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a5d2:	f89a 3000 	ldrb.w	r3, [sl]
3401a5d6:	2b2a      	cmp	r3, #42	@ 0x2a
3401a5d8:	d015      	beq.n	3401a606 <_svfiprintf_r+0xfa>
3401a5da:	9a07      	ldr	r2, [sp, #28]
3401a5dc:	4654      	mov	r4, sl
3401a5de:	2000      	movs	r0, #0
3401a5e0:	f04f 0c0a 	mov.w	ip, #10
3401a5e4:	4621      	mov	r1, r4
3401a5e6:	f811 3b01 	ldrb.w	r3, [r1], #1
3401a5ea:	3b30      	subs	r3, #48	@ 0x30
3401a5ec:	2b09      	cmp	r3, #9
3401a5ee:	d94b      	bls.n	3401a688 <_svfiprintf_r+0x17c>
3401a5f0:	b1b0      	cbz	r0, 3401a620 <_svfiprintf_r+0x114>
3401a5f2:	9207      	str	r2, [sp, #28]
3401a5f4:	e014      	b.n	3401a620 <_svfiprintf_r+0x114>
3401a5f6:	eba0 0308 	sub.w	r3, r0, r8
3401a5fa:	46a2      	mov	sl, r4
3401a5fc:	fa09 f303 	lsl.w	r3, r9, r3
3401a600:	4313      	orrs	r3, r2
3401a602:	9304      	str	r3, [sp, #16]
3401a604:	e7d2      	b.n	3401a5ac <_svfiprintf_r+0xa0>
3401a606:	9b03      	ldr	r3, [sp, #12]
3401a608:	1d19      	adds	r1, r3, #4
3401a60a:	681b      	ldr	r3, [r3, #0]
3401a60c:	2b00      	cmp	r3, #0
3401a60e:	9103      	str	r1, [sp, #12]
3401a610:	bfbb      	ittet	lt
3401a612:	425b      	neglt	r3, r3
3401a614:	f042 0202 	orrlt.w	r2, r2, #2
3401a618:	9307      	strge	r3, [sp, #28]
3401a61a:	9307      	strlt	r3, [sp, #28]
3401a61c:	bfb8      	it	lt
3401a61e:	9204      	strlt	r2, [sp, #16]
3401a620:	7823      	ldrb	r3, [r4, #0]
3401a622:	2b2e      	cmp	r3, #46	@ 0x2e
3401a624:	d10a      	bne.n	3401a63c <_svfiprintf_r+0x130>
3401a626:	7863      	ldrb	r3, [r4, #1]
3401a628:	2b2a      	cmp	r3, #42	@ 0x2a
3401a62a:	d132      	bne.n	3401a692 <_svfiprintf_r+0x186>
3401a62c:	9b03      	ldr	r3, [sp, #12]
3401a62e:	3402      	adds	r4, #2
3401a630:	1d1a      	adds	r2, r3, #4
3401a632:	681b      	ldr	r3, [r3, #0]
3401a634:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401a638:	9203      	str	r2, [sp, #12]
3401a63a:	9305      	str	r3, [sp, #20]
3401a63c:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 3401a700 <_svfiprintf_r+0x1f4>
3401a640:	2203      	movs	r2, #3
3401a642:	7821      	ldrb	r1, [r4, #0]
3401a644:	4650      	mov	r0, sl
3401a646:	f7fe fd22 	bl	3401908e <memchr>
3401a64a:	b138      	cbz	r0, 3401a65c <_svfiprintf_r+0x150>
3401a64c:	eba0 000a 	sub.w	r0, r0, sl
3401a650:	2240      	movs	r2, #64	@ 0x40
3401a652:	9b04      	ldr	r3, [sp, #16]
3401a654:	3401      	adds	r4, #1
3401a656:	4082      	lsls	r2, r0
3401a658:	4313      	orrs	r3, r2
3401a65a:	9304      	str	r3, [sp, #16]
3401a65c:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a660:	2206      	movs	r2, #6
3401a662:	4824      	ldr	r0, [pc, #144]	@ (3401a6f4 <_svfiprintf_r+0x1e8>)
3401a664:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401a668:	f7fe fd11 	bl	3401908e <memchr>
3401a66c:	2800      	cmp	r0, #0
3401a66e:	d036      	beq.n	3401a6de <_svfiprintf_r+0x1d2>
3401a670:	4b21      	ldr	r3, [pc, #132]	@ (3401a6f8 <_svfiprintf_r+0x1ec>)
3401a672:	bb1b      	cbnz	r3, 3401a6bc <_svfiprintf_r+0x1b0>
3401a674:	9b03      	ldr	r3, [sp, #12]
3401a676:	3307      	adds	r3, #7
3401a678:	f023 0307 	bic.w	r3, r3, #7
3401a67c:	3308      	adds	r3, #8
3401a67e:	9303      	str	r3, [sp, #12]
3401a680:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401a682:	4433      	add	r3, r6
3401a684:	9309      	str	r3, [sp, #36]	@ 0x24
3401a686:	e76a      	b.n	3401a55e <_svfiprintf_r+0x52>
3401a688:	fb0c 3202 	mla	r2, ip, r2, r3
3401a68c:	460c      	mov	r4, r1
3401a68e:	2001      	movs	r0, #1
3401a690:	e7a8      	b.n	3401a5e4 <_svfiprintf_r+0xd8>
3401a692:	2300      	movs	r3, #0
3401a694:	3401      	adds	r4, #1
3401a696:	f04f 0c0a 	mov.w	ip, #10
3401a69a:	4619      	mov	r1, r3
3401a69c:	9305      	str	r3, [sp, #20]
3401a69e:	4620      	mov	r0, r4
3401a6a0:	f810 2b01 	ldrb.w	r2, [r0], #1
3401a6a4:	3a30      	subs	r2, #48	@ 0x30
3401a6a6:	2a09      	cmp	r2, #9
3401a6a8:	d903      	bls.n	3401a6b2 <_svfiprintf_r+0x1a6>
3401a6aa:	2b00      	cmp	r3, #0
3401a6ac:	d0c6      	beq.n	3401a63c <_svfiprintf_r+0x130>
3401a6ae:	9105      	str	r1, [sp, #20]
3401a6b0:	e7c4      	b.n	3401a63c <_svfiprintf_r+0x130>
3401a6b2:	fb0c 2101 	mla	r1, ip, r1, r2
3401a6b6:	4604      	mov	r4, r0
3401a6b8:	2301      	movs	r3, #1
3401a6ba:	e7f0      	b.n	3401a69e <_svfiprintf_r+0x192>
3401a6bc:	ab03      	add	r3, sp, #12
3401a6be:	462a      	mov	r2, r5
3401a6c0:	a904      	add	r1, sp, #16
3401a6c2:	4638      	mov	r0, r7
3401a6c4:	9300      	str	r3, [sp, #0]
3401a6c6:	4b0d      	ldr	r3, [pc, #52]	@ (3401a6fc <_svfiprintf_r+0x1f0>)
3401a6c8:	f7fd fc06 	bl	34017ed8 <_printf_float>
3401a6cc:	1c42      	adds	r2, r0, #1
3401a6ce:	4606      	mov	r6, r0
3401a6d0:	d1d6      	bne.n	3401a680 <_svfiprintf_r+0x174>
3401a6d2:	89ab      	ldrh	r3, [r5, #12]
3401a6d4:	065b      	lsls	r3, r3, #25
3401a6d6:	f53f af2d 	bmi.w	3401a534 <_svfiprintf_r+0x28>
3401a6da:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401a6dc:	e72c      	b.n	3401a538 <_svfiprintf_r+0x2c>
3401a6de:	ab03      	add	r3, sp, #12
3401a6e0:	462a      	mov	r2, r5
3401a6e2:	a904      	add	r1, sp, #16
3401a6e4:	4638      	mov	r0, r7
3401a6e6:	9300      	str	r3, [sp, #0]
3401a6e8:	4b04      	ldr	r3, [pc, #16]	@ (3401a6fc <_svfiprintf_r+0x1f0>)
3401a6ea:	f7fd fe81 	bl	340183f0 <_printf_i>
3401a6ee:	e7ed      	b.n	3401a6cc <_svfiprintf_r+0x1c0>
3401a6f0:	3401e733 	.word	0x3401e733
3401a6f4:	3401e73d 	.word	0x3401e73d
3401a6f8:	34017ed9 	.word	0x34017ed9
3401a6fc:	3401a455 	.word	0x3401a455
3401a700:	3401e739 	.word	0x3401e739

3401a704 <__sfputc_r>:
3401a704:	6893      	ldr	r3, [r2, #8]
3401a706:	3b01      	subs	r3, #1
3401a708:	2b00      	cmp	r3, #0
3401a70a:	b410      	push	{r4}
3401a70c:	6093      	str	r3, [r2, #8]
3401a70e:	da08      	bge.n	3401a722 <__sfputc_r+0x1e>
3401a710:	6994      	ldr	r4, [r2, #24]
3401a712:	42a3      	cmp	r3, r4
3401a714:	db01      	blt.n	3401a71a <__sfputc_r+0x16>
3401a716:	290a      	cmp	r1, #10
3401a718:	d103      	bne.n	3401a722 <__sfputc_r+0x1e>
3401a71a:	f85d 4b04 	ldr.w	r4, [sp], #4
3401a71e:	f7fe b97f 	b.w	34018a20 <__swbuf_r>
3401a722:	6813      	ldr	r3, [r2, #0]
3401a724:	1c58      	adds	r0, r3, #1
3401a726:	6010      	str	r0, [r2, #0]
3401a728:	4608      	mov	r0, r1
3401a72a:	7019      	strb	r1, [r3, #0]
3401a72c:	f85d 4b04 	ldr.w	r4, [sp], #4
3401a730:	4770      	bx	lr

3401a732 <__sfputs_r>:
3401a732:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401a734:	4606      	mov	r6, r0
3401a736:	460f      	mov	r7, r1
3401a738:	4614      	mov	r4, r2
3401a73a:	18d5      	adds	r5, r2, r3
3401a73c:	42ac      	cmp	r4, r5
3401a73e:	d101      	bne.n	3401a744 <__sfputs_r+0x12>
3401a740:	2000      	movs	r0, #0
3401a742:	e007      	b.n	3401a754 <__sfputs_r+0x22>
3401a744:	463a      	mov	r2, r7
3401a746:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a74a:	4630      	mov	r0, r6
3401a74c:	f7ff ffda 	bl	3401a704 <__sfputc_r>
3401a750:	1c43      	adds	r3, r0, #1
3401a752:	d1f3      	bne.n	3401a73c <__sfputs_r+0xa>
3401a754:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

3401a758 <_vfiprintf_r>:
3401a758:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a75c:	460d      	mov	r5, r1
3401a75e:	b09d      	sub	sp, #116	@ 0x74
3401a760:	4614      	mov	r4, r2
3401a762:	4698      	mov	r8, r3
3401a764:	4606      	mov	r6, r0
3401a766:	b118      	cbz	r0, 3401a770 <_vfiprintf_r+0x18>
3401a768:	6a03      	ldr	r3, [r0, #32]
3401a76a:	b90b      	cbnz	r3, 3401a770 <_vfiprintf_r+0x18>
3401a76c:	f7fd ffea 	bl	34018744 <__sinit>
3401a770:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401a772:	07d9      	lsls	r1, r3, #31
3401a774:	d405      	bmi.n	3401a782 <_vfiprintf_r+0x2a>
3401a776:	89ab      	ldrh	r3, [r5, #12]
3401a778:	059a      	lsls	r2, r3, #22
3401a77a:	d402      	bmi.n	3401a782 <_vfiprintf_r+0x2a>
3401a77c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401a77e:	f7fe fc7c 	bl	3401907a <__retarget_lock_acquire_recursive>
3401a782:	89ab      	ldrh	r3, [r5, #12]
3401a784:	071b      	lsls	r3, r3, #28
3401a786:	d501      	bpl.n	3401a78c <_vfiprintf_r+0x34>
3401a788:	692b      	ldr	r3, [r5, #16]
3401a78a:	b99b      	cbnz	r3, 3401a7b4 <_vfiprintf_r+0x5c>
3401a78c:	4629      	mov	r1, r5
3401a78e:	4630      	mov	r0, r6
3401a790:	f7fe f984 	bl	34018a9c <__swsetup_r>
3401a794:	b170      	cbz	r0, 3401a7b4 <_vfiprintf_r+0x5c>
3401a796:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401a798:	07dc      	lsls	r4, r3, #31
3401a79a:	d504      	bpl.n	3401a7a6 <_vfiprintf_r+0x4e>
3401a79c:	f04f 30ff 	mov.w	r0, #4294967295
3401a7a0:	b01d      	add	sp, #116	@ 0x74
3401a7a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a7a6:	89ab      	ldrh	r3, [r5, #12]
3401a7a8:	0598      	lsls	r0, r3, #22
3401a7aa:	d4f7      	bmi.n	3401a79c <_vfiprintf_r+0x44>
3401a7ac:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401a7ae:	f7fe fc65 	bl	3401907c <__retarget_lock_release_recursive>
3401a7b2:	e7f3      	b.n	3401a79c <_vfiprintf_r+0x44>
3401a7b4:	2300      	movs	r3, #0
3401a7b6:	f8cd 800c 	str.w	r8, [sp, #12]
3401a7ba:	f04f 0901 	mov.w	r9, #1
3401a7be:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 3401a974 <_vfiprintf_r+0x21c>
3401a7c2:	9309      	str	r3, [sp, #36]	@ 0x24
3401a7c4:	2320      	movs	r3, #32
3401a7c6:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401a7ca:	2330      	movs	r3, #48	@ 0x30
3401a7cc:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401a7d0:	4623      	mov	r3, r4
3401a7d2:	469a      	mov	sl, r3
3401a7d4:	f813 2b01 	ldrb.w	r2, [r3], #1
3401a7d8:	b10a      	cbz	r2, 3401a7de <_vfiprintf_r+0x86>
3401a7da:	2a25      	cmp	r2, #37	@ 0x25
3401a7dc:	d1f9      	bne.n	3401a7d2 <_vfiprintf_r+0x7a>
3401a7de:	ebba 0b04 	subs.w	fp, sl, r4
3401a7e2:	d00b      	beq.n	3401a7fc <_vfiprintf_r+0xa4>
3401a7e4:	465b      	mov	r3, fp
3401a7e6:	4622      	mov	r2, r4
3401a7e8:	4629      	mov	r1, r5
3401a7ea:	4630      	mov	r0, r6
3401a7ec:	f7ff ffa1 	bl	3401a732 <__sfputs_r>
3401a7f0:	3001      	adds	r0, #1
3401a7f2:	f000 80a7 	beq.w	3401a944 <_vfiprintf_r+0x1ec>
3401a7f6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401a7f8:	445a      	add	r2, fp
3401a7fa:	9209      	str	r2, [sp, #36]	@ 0x24
3401a7fc:	f89a 3000 	ldrb.w	r3, [sl]
3401a800:	2b00      	cmp	r3, #0
3401a802:	f000 809f 	beq.w	3401a944 <_vfiprintf_r+0x1ec>
3401a806:	2300      	movs	r3, #0
3401a808:	f04f 32ff 	mov.w	r2, #4294967295
3401a80c:	f10a 0a01 	add.w	sl, sl, #1
3401a810:	9304      	str	r3, [sp, #16]
3401a812:	9307      	str	r3, [sp, #28]
3401a814:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401a818:	931a      	str	r3, [sp, #104]	@ 0x68
3401a81a:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401a81e:	4654      	mov	r4, sl
3401a820:	2205      	movs	r2, #5
3401a822:	4854      	ldr	r0, [pc, #336]	@ (3401a974 <_vfiprintf_r+0x21c>)
3401a824:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a828:	f7fe fc31 	bl	3401908e <memchr>
3401a82c:	9a04      	ldr	r2, [sp, #16]
3401a82e:	b9d8      	cbnz	r0, 3401a868 <_vfiprintf_r+0x110>
3401a830:	06d1      	lsls	r1, r2, #27
3401a832:	bf44      	itt	mi
3401a834:	2320      	movmi	r3, #32
3401a836:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a83a:	0713      	lsls	r3, r2, #28
3401a83c:	bf44      	itt	mi
3401a83e:	232b      	movmi	r3, #43	@ 0x2b
3401a840:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a844:	f89a 3000 	ldrb.w	r3, [sl]
3401a848:	2b2a      	cmp	r3, #42	@ 0x2a
3401a84a:	d015      	beq.n	3401a878 <_vfiprintf_r+0x120>
3401a84c:	9a07      	ldr	r2, [sp, #28]
3401a84e:	4654      	mov	r4, sl
3401a850:	2000      	movs	r0, #0
3401a852:	f04f 0c0a 	mov.w	ip, #10
3401a856:	4621      	mov	r1, r4
3401a858:	f811 3b01 	ldrb.w	r3, [r1], #1
3401a85c:	3b30      	subs	r3, #48	@ 0x30
3401a85e:	2b09      	cmp	r3, #9
3401a860:	d94b      	bls.n	3401a8fa <_vfiprintf_r+0x1a2>
3401a862:	b1b0      	cbz	r0, 3401a892 <_vfiprintf_r+0x13a>
3401a864:	9207      	str	r2, [sp, #28]
3401a866:	e014      	b.n	3401a892 <_vfiprintf_r+0x13a>
3401a868:	eba0 0308 	sub.w	r3, r0, r8
3401a86c:	46a2      	mov	sl, r4
3401a86e:	fa09 f303 	lsl.w	r3, r9, r3
3401a872:	4313      	orrs	r3, r2
3401a874:	9304      	str	r3, [sp, #16]
3401a876:	e7d2      	b.n	3401a81e <_vfiprintf_r+0xc6>
3401a878:	9b03      	ldr	r3, [sp, #12]
3401a87a:	1d19      	adds	r1, r3, #4
3401a87c:	681b      	ldr	r3, [r3, #0]
3401a87e:	2b00      	cmp	r3, #0
3401a880:	9103      	str	r1, [sp, #12]
3401a882:	bfbb      	ittet	lt
3401a884:	425b      	neglt	r3, r3
3401a886:	f042 0202 	orrlt.w	r2, r2, #2
3401a88a:	9307      	strge	r3, [sp, #28]
3401a88c:	9307      	strlt	r3, [sp, #28]
3401a88e:	bfb8      	it	lt
3401a890:	9204      	strlt	r2, [sp, #16]
3401a892:	7823      	ldrb	r3, [r4, #0]
3401a894:	2b2e      	cmp	r3, #46	@ 0x2e
3401a896:	d10a      	bne.n	3401a8ae <_vfiprintf_r+0x156>
3401a898:	7863      	ldrb	r3, [r4, #1]
3401a89a:	2b2a      	cmp	r3, #42	@ 0x2a
3401a89c:	d132      	bne.n	3401a904 <_vfiprintf_r+0x1ac>
3401a89e:	9b03      	ldr	r3, [sp, #12]
3401a8a0:	3402      	adds	r4, #2
3401a8a2:	1d1a      	adds	r2, r3, #4
3401a8a4:	681b      	ldr	r3, [r3, #0]
3401a8a6:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401a8aa:	9203      	str	r2, [sp, #12]
3401a8ac:	9305      	str	r3, [sp, #20]
3401a8ae:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 3401a984 <_vfiprintf_r+0x22c>
3401a8b2:	2203      	movs	r2, #3
3401a8b4:	7821      	ldrb	r1, [r4, #0]
3401a8b6:	4650      	mov	r0, sl
3401a8b8:	f7fe fbe9 	bl	3401908e <memchr>
3401a8bc:	b138      	cbz	r0, 3401a8ce <_vfiprintf_r+0x176>
3401a8be:	eba0 000a 	sub.w	r0, r0, sl
3401a8c2:	2240      	movs	r2, #64	@ 0x40
3401a8c4:	9b04      	ldr	r3, [sp, #16]
3401a8c6:	3401      	adds	r4, #1
3401a8c8:	4082      	lsls	r2, r0
3401a8ca:	4313      	orrs	r3, r2
3401a8cc:	9304      	str	r3, [sp, #16]
3401a8ce:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a8d2:	2206      	movs	r2, #6
3401a8d4:	4828      	ldr	r0, [pc, #160]	@ (3401a978 <_vfiprintf_r+0x220>)
3401a8d6:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401a8da:	f7fe fbd8 	bl	3401908e <memchr>
3401a8de:	2800      	cmp	r0, #0
3401a8e0:	d03f      	beq.n	3401a962 <_vfiprintf_r+0x20a>
3401a8e2:	4b26      	ldr	r3, [pc, #152]	@ (3401a97c <_vfiprintf_r+0x224>)
3401a8e4:	bb1b      	cbnz	r3, 3401a92e <_vfiprintf_r+0x1d6>
3401a8e6:	9b03      	ldr	r3, [sp, #12]
3401a8e8:	3307      	adds	r3, #7
3401a8ea:	f023 0307 	bic.w	r3, r3, #7
3401a8ee:	3308      	adds	r3, #8
3401a8f0:	9303      	str	r3, [sp, #12]
3401a8f2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401a8f4:	443b      	add	r3, r7
3401a8f6:	9309      	str	r3, [sp, #36]	@ 0x24
3401a8f8:	e76a      	b.n	3401a7d0 <_vfiprintf_r+0x78>
3401a8fa:	fb0c 3202 	mla	r2, ip, r2, r3
3401a8fe:	460c      	mov	r4, r1
3401a900:	2001      	movs	r0, #1
3401a902:	e7a8      	b.n	3401a856 <_vfiprintf_r+0xfe>
3401a904:	2300      	movs	r3, #0
3401a906:	3401      	adds	r4, #1
3401a908:	f04f 0c0a 	mov.w	ip, #10
3401a90c:	4619      	mov	r1, r3
3401a90e:	9305      	str	r3, [sp, #20]
3401a910:	4620      	mov	r0, r4
3401a912:	f810 2b01 	ldrb.w	r2, [r0], #1
3401a916:	3a30      	subs	r2, #48	@ 0x30
3401a918:	2a09      	cmp	r2, #9
3401a91a:	d903      	bls.n	3401a924 <_vfiprintf_r+0x1cc>
3401a91c:	2b00      	cmp	r3, #0
3401a91e:	d0c6      	beq.n	3401a8ae <_vfiprintf_r+0x156>
3401a920:	9105      	str	r1, [sp, #20]
3401a922:	e7c4      	b.n	3401a8ae <_vfiprintf_r+0x156>
3401a924:	fb0c 2101 	mla	r1, ip, r1, r2
3401a928:	4604      	mov	r4, r0
3401a92a:	2301      	movs	r3, #1
3401a92c:	e7f0      	b.n	3401a910 <_vfiprintf_r+0x1b8>
3401a92e:	ab03      	add	r3, sp, #12
3401a930:	462a      	mov	r2, r5
3401a932:	a904      	add	r1, sp, #16
3401a934:	4630      	mov	r0, r6
3401a936:	9300      	str	r3, [sp, #0]
3401a938:	4b11      	ldr	r3, [pc, #68]	@ (3401a980 <_vfiprintf_r+0x228>)
3401a93a:	f7fd facd 	bl	34017ed8 <_printf_float>
3401a93e:	4607      	mov	r7, r0
3401a940:	1c78      	adds	r0, r7, #1
3401a942:	d1d6      	bne.n	3401a8f2 <_vfiprintf_r+0x19a>
3401a944:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401a946:	07d9      	lsls	r1, r3, #31
3401a948:	d405      	bmi.n	3401a956 <_vfiprintf_r+0x1fe>
3401a94a:	89ab      	ldrh	r3, [r5, #12]
3401a94c:	059a      	lsls	r2, r3, #22
3401a94e:	d402      	bmi.n	3401a956 <_vfiprintf_r+0x1fe>
3401a950:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401a952:	f7fe fb93 	bl	3401907c <__retarget_lock_release_recursive>
3401a956:	89ab      	ldrh	r3, [r5, #12]
3401a958:	065b      	lsls	r3, r3, #25
3401a95a:	f53f af1f 	bmi.w	3401a79c <_vfiprintf_r+0x44>
3401a95e:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401a960:	e71e      	b.n	3401a7a0 <_vfiprintf_r+0x48>
3401a962:	ab03      	add	r3, sp, #12
3401a964:	462a      	mov	r2, r5
3401a966:	a904      	add	r1, sp, #16
3401a968:	4630      	mov	r0, r6
3401a96a:	9300      	str	r3, [sp, #0]
3401a96c:	4b04      	ldr	r3, [pc, #16]	@ (3401a980 <_vfiprintf_r+0x228>)
3401a96e:	f7fd fd3f 	bl	340183f0 <_printf_i>
3401a972:	e7e4      	b.n	3401a93e <_vfiprintf_r+0x1e6>
3401a974:	3401e733 	.word	0x3401e733
3401a978:	3401e73d 	.word	0x3401e73d
3401a97c:	34017ed9 	.word	0x34017ed9
3401a980:	3401a733 	.word	0x3401a733
3401a984:	3401e739 	.word	0x3401e739

3401a988 <__sflush_r>:
3401a988:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401a98c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401a990:	0716      	lsls	r6, r2, #28
3401a992:	4605      	mov	r5, r0
3401a994:	460c      	mov	r4, r1
3401a996:	d454      	bmi.n	3401aa42 <__sflush_r+0xba>
3401a998:	684b      	ldr	r3, [r1, #4]
3401a99a:	2b00      	cmp	r3, #0
3401a99c:	dc02      	bgt.n	3401a9a4 <__sflush_r+0x1c>
3401a99e:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
3401a9a0:	2b00      	cmp	r3, #0
3401a9a2:	dd48      	ble.n	3401aa36 <__sflush_r+0xae>
3401a9a4:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401a9a6:	2e00      	cmp	r6, #0
3401a9a8:	d045      	beq.n	3401aa36 <__sflush_r+0xae>
3401a9aa:	2300      	movs	r3, #0
3401a9ac:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
3401a9b0:	682f      	ldr	r7, [r5, #0]
3401a9b2:	6a21      	ldr	r1, [r4, #32]
3401a9b4:	602b      	str	r3, [r5, #0]
3401a9b6:	d030      	beq.n	3401aa1a <__sflush_r+0x92>
3401a9b8:	6d62      	ldr	r2, [r4, #84]	@ 0x54
3401a9ba:	89a3      	ldrh	r3, [r4, #12]
3401a9bc:	0759      	lsls	r1, r3, #29
3401a9be:	d505      	bpl.n	3401a9cc <__sflush_r+0x44>
3401a9c0:	6863      	ldr	r3, [r4, #4]
3401a9c2:	1ad2      	subs	r2, r2, r3
3401a9c4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3401a9c6:	b10b      	cbz	r3, 3401a9cc <__sflush_r+0x44>
3401a9c8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3401a9ca:	1ad2      	subs	r2, r2, r3
3401a9cc:	2300      	movs	r3, #0
3401a9ce:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401a9d0:	6a21      	ldr	r1, [r4, #32]
3401a9d2:	4628      	mov	r0, r5
3401a9d4:	47b0      	blx	r6
3401a9d6:	1c43      	adds	r3, r0, #1
3401a9d8:	89a3      	ldrh	r3, [r4, #12]
3401a9da:	d106      	bne.n	3401a9ea <__sflush_r+0x62>
3401a9dc:	6829      	ldr	r1, [r5, #0]
3401a9de:	291d      	cmp	r1, #29
3401a9e0:	d82b      	bhi.n	3401aa3a <__sflush_r+0xb2>
3401a9e2:	4a2a      	ldr	r2, [pc, #168]	@ (3401aa8c <__sflush_r+0x104>)
3401a9e4:	40ca      	lsrs	r2, r1
3401a9e6:	07d6      	lsls	r6, r2, #31
3401a9e8:	d527      	bpl.n	3401aa3a <__sflush_r+0xb2>
3401a9ea:	2200      	movs	r2, #0
3401a9ec:	04d9      	lsls	r1, r3, #19
3401a9ee:	6062      	str	r2, [r4, #4]
3401a9f0:	6922      	ldr	r2, [r4, #16]
3401a9f2:	6022      	str	r2, [r4, #0]
3401a9f4:	d504      	bpl.n	3401aa00 <__sflush_r+0x78>
3401a9f6:	1c42      	adds	r2, r0, #1
3401a9f8:	d101      	bne.n	3401a9fe <__sflush_r+0x76>
3401a9fa:	682b      	ldr	r3, [r5, #0]
3401a9fc:	b903      	cbnz	r3, 3401aa00 <__sflush_r+0x78>
3401a9fe:	6560      	str	r0, [r4, #84]	@ 0x54
3401aa00:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3401aa02:	602f      	str	r7, [r5, #0]
3401aa04:	b1b9      	cbz	r1, 3401aa36 <__sflush_r+0xae>
3401aa06:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3401aa0a:	4299      	cmp	r1, r3
3401aa0c:	d002      	beq.n	3401aa14 <__sflush_r+0x8c>
3401aa0e:	4628      	mov	r0, r5
3401aa10:	f7ff f94c 	bl	34019cac <_free_r>
3401aa14:	2300      	movs	r3, #0
3401aa16:	6363      	str	r3, [r4, #52]	@ 0x34
3401aa18:	e00d      	b.n	3401aa36 <__sflush_r+0xae>
3401aa1a:	2301      	movs	r3, #1
3401aa1c:	4628      	mov	r0, r5
3401aa1e:	47b0      	blx	r6
3401aa20:	4602      	mov	r2, r0
3401aa22:	1c50      	adds	r0, r2, #1
3401aa24:	d1c9      	bne.n	3401a9ba <__sflush_r+0x32>
3401aa26:	682b      	ldr	r3, [r5, #0]
3401aa28:	2b00      	cmp	r3, #0
3401aa2a:	d0c6      	beq.n	3401a9ba <__sflush_r+0x32>
3401aa2c:	2b1d      	cmp	r3, #29
3401aa2e:	d001      	beq.n	3401aa34 <__sflush_r+0xac>
3401aa30:	2b16      	cmp	r3, #22
3401aa32:	d11d      	bne.n	3401aa70 <__sflush_r+0xe8>
3401aa34:	602f      	str	r7, [r5, #0]
3401aa36:	2000      	movs	r0, #0
3401aa38:	e021      	b.n	3401aa7e <__sflush_r+0xf6>
3401aa3a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401aa3e:	b21b      	sxth	r3, r3
3401aa40:	e01a      	b.n	3401aa78 <__sflush_r+0xf0>
3401aa42:	690f      	ldr	r7, [r1, #16]
3401aa44:	2f00      	cmp	r7, #0
3401aa46:	d0f6      	beq.n	3401aa36 <__sflush_r+0xae>
3401aa48:	0793      	lsls	r3, r2, #30
3401aa4a:	680e      	ldr	r6, [r1, #0]
3401aa4c:	600f      	str	r7, [r1, #0]
3401aa4e:	bf0c      	ite	eq
3401aa50:	694b      	ldreq	r3, [r1, #20]
3401aa52:	2300      	movne	r3, #0
3401aa54:	eba6 0807 	sub.w	r8, r6, r7
3401aa58:	608b      	str	r3, [r1, #8]
3401aa5a:	f1b8 0f00 	cmp.w	r8, #0
3401aa5e:	ddea      	ble.n	3401aa36 <__sflush_r+0xae>
3401aa60:	4643      	mov	r3, r8
3401aa62:	463a      	mov	r2, r7
3401aa64:	6a21      	ldr	r1, [r4, #32]
3401aa66:	4628      	mov	r0, r5
3401aa68:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
3401aa6a:	47b0      	blx	r6
3401aa6c:	2800      	cmp	r0, #0
3401aa6e:	dc08      	bgt.n	3401aa82 <__sflush_r+0xfa>
3401aa70:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401aa74:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401aa78:	f04f 30ff 	mov.w	r0, #4294967295
3401aa7c:	81a3      	strh	r3, [r4, #12]
3401aa7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401aa82:	4407      	add	r7, r0
3401aa84:	eba8 0800 	sub.w	r8, r8, r0
3401aa88:	e7e7      	b.n	3401aa5a <__sflush_r+0xd2>
3401aa8a:	bf00      	nop
3401aa8c:	20400001 	.word	0x20400001

3401aa90 <_fflush_r>:
3401aa90:	b538      	push	{r3, r4, r5, lr}
3401aa92:	690b      	ldr	r3, [r1, #16]
3401aa94:	4605      	mov	r5, r0
3401aa96:	460c      	mov	r4, r1
3401aa98:	b913      	cbnz	r3, 3401aaa0 <_fflush_r+0x10>
3401aa9a:	2500      	movs	r5, #0
3401aa9c:	4628      	mov	r0, r5
3401aa9e:	bd38      	pop	{r3, r4, r5, pc}
3401aaa0:	b118      	cbz	r0, 3401aaaa <_fflush_r+0x1a>
3401aaa2:	6a03      	ldr	r3, [r0, #32]
3401aaa4:	b90b      	cbnz	r3, 3401aaaa <_fflush_r+0x1a>
3401aaa6:	f7fd fe4d 	bl	34018744 <__sinit>
3401aaaa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401aaae:	2b00      	cmp	r3, #0
3401aab0:	d0f3      	beq.n	3401aa9a <_fflush_r+0xa>
3401aab2:	6e62      	ldr	r2, [r4, #100]	@ 0x64
3401aab4:	07d0      	lsls	r0, r2, #31
3401aab6:	d404      	bmi.n	3401aac2 <_fflush_r+0x32>
3401aab8:	0599      	lsls	r1, r3, #22
3401aaba:	d402      	bmi.n	3401aac2 <_fflush_r+0x32>
3401aabc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401aabe:	f7fe fadc 	bl	3401907a <__retarget_lock_acquire_recursive>
3401aac2:	4628      	mov	r0, r5
3401aac4:	4621      	mov	r1, r4
3401aac6:	f7ff ff5f 	bl	3401a988 <__sflush_r>
3401aaca:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401aacc:	4605      	mov	r5, r0
3401aace:	07da      	lsls	r2, r3, #31
3401aad0:	d4e4      	bmi.n	3401aa9c <_fflush_r+0xc>
3401aad2:	89a3      	ldrh	r3, [r4, #12]
3401aad4:	059b      	lsls	r3, r3, #22
3401aad6:	d4e1      	bmi.n	3401aa9c <_fflush_r+0xc>
3401aad8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401aada:	f7fe facf 	bl	3401907c <__retarget_lock_release_recursive>
3401aade:	e7dd      	b.n	3401aa9c <_fflush_r+0xc>

3401aae0 <__swhatbuf_r>:
3401aae0:	b570      	push	{r4, r5, r6, lr}
3401aae2:	460c      	mov	r4, r1
3401aae4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401aae8:	b096      	sub	sp, #88	@ 0x58
3401aaea:	4615      	mov	r5, r2
3401aaec:	2900      	cmp	r1, #0
3401aaee:	461e      	mov	r6, r3
3401aaf0:	da0c      	bge.n	3401ab0c <__swhatbuf_r+0x2c>
3401aaf2:	89a3      	ldrh	r3, [r4, #12]
3401aaf4:	2100      	movs	r1, #0
3401aaf6:	f013 0f80 	tst.w	r3, #128	@ 0x80
3401aafa:	bf14      	ite	ne
3401aafc:	2340      	movne	r3, #64	@ 0x40
3401aafe:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
3401ab02:	2000      	movs	r0, #0
3401ab04:	6031      	str	r1, [r6, #0]
3401ab06:	602b      	str	r3, [r5, #0]
3401ab08:	b016      	add	sp, #88	@ 0x58
3401ab0a:	bd70      	pop	{r4, r5, r6, pc}
3401ab0c:	466a      	mov	r2, sp
3401ab0e:	f000 f879 	bl	3401ac04 <_fstat_r>
3401ab12:	2800      	cmp	r0, #0
3401ab14:	dbed      	blt.n	3401aaf2 <__swhatbuf_r+0x12>
3401ab16:	9901      	ldr	r1, [sp, #4]
3401ab18:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
3401ab1c:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
3401ab20:	4259      	negs	r1, r3
3401ab22:	4159      	adcs	r1, r3
3401ab24:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401ab28:	e7eb      	b.n	3401ab02 <__swhatbuf_r+0x22>

3401ab2a <__smakebuf_r>:
3401ab2a:	898b      	ldrh	r3, [r1, #12]
3401ab2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401ab2e:	079d      	lsls	r5, r3, #30
3401ab30:	4606      	mov	r6, r0
3401ab32:	460c      	mov	r4, r1
3401ab34:	d507      	bpl.n	3401ab46 <__smakebuf_r+0x1c>
3401ab36:	f104 0347 	add.w	r3, r4, #71	@ 0x47
3401ab3a:	6023      	str	r3, [r4, #0]
3401ab3c:	6123      	str	r3, [r4, #16]
3401ab3e:	2301      	movs	r3, #1
3401ab40:	6163      	str	r3, [r4, #20]
3401ab42:	b003      	add	sp, #12
3401ab44:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401ab46:	ab01      	add	r3, sp, #4
3401ab48:	466a      	mov	r2, sp
3401ab4a:	f7ff ffc9 	bl	3401aae0 <__swhatbuf_r>
3401ab4e:	9f00      	ldr	r7, [sp, #0]
3401ab50:	4605      	mov	r5, r0
3401ab52:	4630      	mov	r0, r6
3401ab54:	4639      	mov	r1, r7
3401ab56:	f7fc fef7 	bl	34017948 <_malloc_r>
3401ab5a:	b948      	cbnz	r0, 3401ab70 <__smakebuf_r+0x46>
3401ab5c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401ab60:	059a      	lsls	r2, r3, #22
3401ab62:	d4ee      	bmi.n	3401ab42 <__smakebuf_r+0x18>
3401ab64:	f023 0303 	bic.w	r3, r3, #3
3401ab68:	f043 0302 	orr.w	r3, r3, #2
3401ab6c:	81a3      	strh	r3, [r4, #12]
3401ab6e:	e7e2      	b.n	3401ab36 <__smakebuf_r+0xc>
3401ab70:	89a3      	ldrh	r3, [r4, #12]
3401ab72:	6020      	str	r0, [r4, #0]
3401ab74:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401ab78:	81a3      	strh	r3, [r4, #12]
3401ab7a:	9b01      	ldr	r3, [sp, #4]
3401ab7c:	e9c4 0704 	strd	r0, r7, [r4, #16]
3401ab80:	b15b      	cbz	r3, 3401ab9a <__smakebuf_r+0x70>
3401ab82:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3401ab86:	4630      	mov	r0, r6
3401ab88:	f000 f84e 	bl	3401ac28 <_isatty_r>
3401ab8c:	b128      	cbz	r0, 3401ab9a <__smakebuf_r+0x70>
3401ab8e:	89a3      	ldrh	r3, [r4, #12]
3401ab90:	f023 0303 	bic.w	r3, r3, #3
3401ab94:	f043 0301 	orr.w	r3, r3, #1
3401ab98:	81a3      	strh	r3, [r4, #12]
3401ab9a:	89a3      	ldrh	r3, [r4, #12]
3401ab9c:	431d      	orrs	r5, r3
3401ab9e:	81a5      	strh	r5, [r4, #12]
3401aba0:	e7cf      	b.n	3401ab42 <__smakebuf_r+0x18>

3401aba2 <_raise_r>:
3401aba2:	291f      	cmp	r1, #31
3401aba4:	b538      	push	{r3, r4, r5, lr}
3401aba6:	4605      	mov	r5, r0
3401aba8:	460c      	mov	r4, r1
3401abaa:	d904      	bls.n	3401abb6 <_raise_r+0x14>
3401abac:	2316      	movs	r3, #22
3401abae:	6003      	str	r3, [r0, #0]
3401abb0:	f04f 30ff 	mov.w	r0, #4294967295
3401abb4:	bd38      	pop	{r3, r4, r5, pc}
3401abb6:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
3401abb8:	b112      	cbz	r2, 3401abc0 <_raise_r+0x1e>
3401abba:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
3401abbe:	b94b      	cbnz	r3, 3401abd4 <_raise_r+0x32>
3401abc0:	4628      	mov	r0, r5
3401abc2:	f000 f853 	bl	3401ac6c <_getpid_r>
3401abc6:	4622      	mov	r2, r4
3401abc8:	4601      	mov	r1, r0
3401abca:	4628      	mov	r0, r5
3401abcc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3401abd0:	f000 b83a 	b.w	3401ac48 <_kill_r>
3401abd4:	2b01      	cmp	r3, #1
3401abd6:	d00a      	beq.n	3401abee <_raise_r+0x4c>
3401abd8:	1c59      	adds	r1, r3, #1
3401abda:	d103      	bne.n	3401abe4 <_raise_r+0x42>
3401abdc:	2316      	movs	r3, #22
3401abde:	6003      	str	r3, [r0, #0]
3401abe0:	2001      	movs	r0, #1
3401abe2:	e7e7      	b.n	3401abb4 <_raise_r+0x12>
3401abe4:	2100      	movs	r1, #0
3401abe6:	4620      	mov	r0, r4
3401abe8:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
3401abec:	4798      	blx	r3
3401abee:	2000      	movs	r0, #0
3401abf0:	e7e0      	b.n	3401abb4 <_raise_r+0x12>
	...

3401abf4 <raise>:
3401abf4:	4b02      	ldr	r3, [pc, #8]	@ (3401ac00 <raise+0xc>)
3401abf6:	4601      	mov	r1, r0
3401abf8:	6818      	ldr	r0, [r3, #0]
3401abfa:	f7ff bfd2 	b.w	3401aba2 <_raise_r>
3401abfe:	bf00      	nop
3401ac00:	3403eddc 	.word	0x3403eddc

3401ac04 <_fstat_r>:
3401ac04:	b538      	push	{r3, r4, r5, lr}
3401ac06:	2300      	movs	r3, #0
3401ac08:	4d06      	ldr	r5, [pc, #24]	@ (3401ac24 <_fstat_r+0x20>)
3401ac0a:	4604      	mov	r4, r0
3401ac0c:	4608      	mov	r0, r1
3401ac0e:	4611      	mov	r1, r2
3401ac10:	602b      	str	r3, [r5, #0]
3401ac12:	f7e7 fe2f 	bl	34002874 <_fstat>
3401ac16:	1c43      	adds	r3, r0, #1
3401ac18:	d102      	bne.n	3401ac20 <_fstat_r+0x1c>
3401ac1a:	682b      	ldr	r3, [r5, #0]
3401ac1c:	b103      	cbz	r3, 3401ac20 <_fstat_r+0x1c>
3401ac1e:	6023      	str	r3, [r4, #0]
3401ac20:	bd38      	pop	{r3, r4, r5, pc}
3401ac22:	bf00      	nop
3401ac24:	3404470c 	.word	0x3404470c

3401ac28 <_isatty_r>:
3401ac28:	b538      	push	{r3, r4, r5, lr}
3401ac2a:	2300      	movs	r3, #0
3401ac2c:	4d05      	ldr	r5, [pc, #20]	@ (3401ac44 <_isatty_r+0x1c>)
3401ac2e:	4604      	mov	r4, r0
3401ac30:	4608      	mov	r0, r1
3401ac32:	602b      	str	r3, [r5, #0]
3401ac34:	f7e7 fe23 	bl	3400287e <_isatty>
3401ac38:	1c43      	adds	r3, r0, #1
3401ac3a:	d102      	bne.n	3401ac42 <_isatty_r+0x1a>
3401ac3c:	682b      	ldr	r3, [r5, #0]
3401ac3e:	b103      	cbz	r3, 3401ac42 <_isatty_r+0x1a>
3401ac40:	6023      	str	r3, [r4, #0]
3401ac42:	bd38      	pop	{r3, r4, r5, pc}
3401ac44:	3404470c 	.word	0x3404470c

3401ac48 <_kill_r>:
3401ac48:	b538      	push	{r3, r4, r5, lr}
3401ac4a:	2300      	movs	r3, #0
3401ac4c:	4d06      	ldr	r5, [pc, #24]	@ (3401ac68 <_kill_r+0x20>)
3401ac4e:	4604      	mov	r4, r0
3401ac50:	4608      	mov	r0, r1
3401ac52:	4611      	mov	r1, r2
3401ac54:	602b      	str	r3, [r5, #0]
3401ac56:	f7e7 fde0 	bl	3400281a <_kill>
3401ac5a:	1c43      	adds	r3, r0, #1
3401ac5c:	d102      	bne.n	3401ac64 <_kill_r+0x1c>
3401ac5e:	682b      	ldr	r3, [r5, #0]
3401ac60:	b103      	cbz	r3, 3401ac64 <_kill_r+0x1c>
3401ac62:	6023      	str	r3, [r4, #0]
3401ac64:	bd38      	pop	{r3, r4, r5, pc}
3401ac66:	bf00      	nop
3401ac68:	3404470c 	.word	0x3404470c

3401ac6c <_getpid_r>:
3401ac6c:	f7e7 bdd3 	b.w	34002816 <_getpid>

3401ac70 <_calloc_r>:
3401ac70:	b570      	push	{r4, r5, r6, lr}
3401ac72:	fba1 5402 	umull	r5, r4, r1, r2
3401ac76:	b934      	cbnz	r4, 3401ac86 <_calloc_r+0x16>
3401ac78:	4629      	mov	r1, r5
3401ac7a:	f7fc fe65 	bl	34017948 <_malloc_r>
3401ac7e:	4606      	mov	r6, r0
3401ac80:	b928      	cbnz	r0, 3401ac8e <_calloc_r+0x1e>
3401ac82:	4630      	mov	r0, r6
3401ac84:	bd70      	pop	{r4, r5, r6, pc}
3401ac86:	220c      	movs	r2, #12
3401ac88:	2600      	movs	r6, #0
3401ac8a:	6002      	str	r2, [r0, #0]
3401ac8c:	e7f9      	b.n	3401ac82 <_calloc_r+0x12>
3401ac8e:	462a      	mov	r2, r5
3401ac90:	4621      	mov	r1, r4
3401ac92:	f7fd ff73 	bl	34018b7c <memset>
3401ac96:	e7f4      	b.n	3401ac82 <_calloc_r+0x12>

3401ac98 <__ascii_mbtowc>:
3401ac98:	b082      	sub	sp, #8
3401ac9a:	b901      	cbnz	r1, 3401ac9e <__ascii_mbtowc+0x6>
3401ac9c:	a901      	add	r1, sp, #4
3401ac9e:	b142      	cbz	r2, 3401acb2 <__ascii_mbtowc+0x1a>
3401aca0:	b14b      	cbz	r3, 3401acb6 <__ascii_mbtowc+0x1e>
3401aca2:	7813      	ldrb	r3, [r2, #0]
3401aca4:	600b      	str	r3, [r1, #0]
3401aca6:	7812      	ldrb	r2, [r2, #0]
3401aca8:	1e10      	subs	r0, r2, #0
3401acaa:	bf18      	it	ne
3401acac:	2001      	movne	r0, #1
3401acae:	b002      	add	sp, #8
3401acb0:	4770      	bx	lr
3401acb2:	4610      	mov	r0, r2
3401acb4:	e7fb      	b.n	3401acae <__ascii_mbtowc+0x16>
3401acb6:	f06f 0001 	mvn.w	r0, #1
3401acba:	e7f8      	b.n	3401acae <__ascii_mbtowc+0x16>

3401acbc <__ascii_wctomb>:
3401acbc:	4603      	mov	r3, r0
3401acbe:	4608      	mov	r0, r1
3401acc0:	b141      	cbz	r1, 3401acd4 <__ascii_wctomb+0x18>
3401acc2:	2aff      	cmp	r2, #255	@ 0xff
3401acc4:	d904      	bls.n	3401acd0 <__ascii_wctomb+0x14>
3401acc6:	228a      	movs	r2, #138	@ 0x8a
3401acc8:	f04f 30ff 	mov.w	r0, #4294967295
3401accc:	601a      	str	r2, [r3, #0]
3401acce:	4770      	bx	lr
3401acd0:	2001      	movs	r0, #1
3401acd2:	700a      	strb	r2, [r1, #0]
3401acd4:	4770      	bx	lr
	...

3401acd8 <log10>:
3401acd8:	b508      	push	{r3, lr}
3401acda:	ed2d 8b02 	vpush	{d8}
3401acde:	eeb0 8b40 	vmov.f64	d8, d0
3401ace2:	f000 fd8d 	bl	3401b800 <__ieee754_log10>
3401ace6:	eeb4 8b48 	vcmp.f64	d8, d8
3401acea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401acee:	d60f      	bvs.n	3401ad10 <log10+0x38>
3401acf0:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
3401acf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401acf8:	d80a      	bhi.n	3401ad10 <log10+0x38>
3401acfa:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401acfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ad02:	d108      	bne.n	3401ad16 <log10+0x3e>
3401ad04:	f7fe f98e 	bl	34019024 <__errno>
3401ad08:	2322      	movs	r3, #34	@ 0x22
3401ad0a:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 3401ad30 <log10+0x58>
3401ad0e:	6003      	str	r3, [r0, #0]
3401ad10:	ecbd 8b02 	vpop	{d8}
3401ad14:	bd08      	pop	{r3, pc}
3401ad16:	f7fe f985 	bl	34019024 <__errno>
3401ad1a:	2321      	movs	r3, #33	@ 0x21
3401ad1c:	ecbd 8b02 	vpop	{d8}
3401ad20:	6003      	str	r3, [r0, #0]
3401ad22:	4805      	ldr	r0, [pc, #20]	@ (3401ad38 <log10+0x60>)
3401ad24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
3401ad28:	f000 b82a 	b.w	3401ad80 <nan>
3401ad2c:	f3af 8000 	nop.w
3401ad30:	00000000 	.word	0x00000000
3401ad34:	fff00000 	.word	0xfff00000
3401ad38:	3401d059 	.word	0x3401d059
3401ad3c:	00000000 	.word	0x00000000

3401ad40 <sqrt>:
3401ad40:	b508      	push	{r3, lr}
3401ad42:	ed2d 8b04 	vpush	{d8-d9}
3401ad46:	eeb0 8b40 	vmov.f64	d8, d0
3401ad4a:	f000 fd56 	bl	3401b7fa <__ieee754_sqrt>
3401ad4e:	eeb4 8b48 	vcmp.f64	d8, d8
3401ad52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ad56:	d60c      	bvs.n	3401ad72 <sqrt+0x32>
3401ad58:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 3401ad78 <sqrt+0x38>
3401ad5c:	eeb4 8bc9 	vcmpe.f64	d8, d9
3401ad60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ad64:	d505      	bpl.n	3401ad72 <sqrt+0x32>
3401ad66:	f7fe f95d 	bl	34019024 <__errno>
3401ad6a:	ee89 0b09 	vdiv.f64	d0, d9, d9
3401ad6e:	2321      	movs	r3, #33	@ 0x21
3401ad70:	6003      	str	r3, [r0, #0]
3401ad72:	ecbd 8b04 	vpop	{d8-d9}
3401ad76:	bd08      	pop	{r3, pc}
	...

3401ad80 <nan>:
3401ad80:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401ad88 <nan+0x8>
3401ad84:	4770      	bx	lr
3401ad86:	bf00      	nop
3401ad88:	00000000 	.word	0x00000000
3401ad8c:	7ff80000 	.word	0x7ff80000

3401ad90 <with_errno>:
3401ad90:	b510      	push	{r4, lr}
3401ad92:	ed2d 8b02 	vpush	{d8}
3401ad96:	eeb0 8b40 	vmov.f64	d8, d0
3401ad9a:	4604      	mov	r4, r0
3401ad9c:	f7fe f942 	bl	34019024 <__errno>
3401ada0:	6004      	str	r4, [r0, #0]
3401ada2:	eeb0 0b48 	vmov.f64	d0, d8
3401ada6:	ecbd 8b02 	vpop	{d8}
3401adaa:	bd10      	pop	{r4, pc}

3401adac <xflow>:
3401adac:	b082      	sub	sp, #8
3401adae:	b158      	cbz	r0, 3401adc8 <xflow+0x1c>
3401adb0:	eeb1 7b40 	vneg.f64	d7, d0
3401adb4:	2022      	movs	r0, #34	@ 0x22
3401adb6:	ed8d 7b00 	vstr	d7, [sp]
3401adba:	ed9d 7b00 	vldr	d7, [sp]
3401adbe:	ee20 0b07 	vmul.f64	d0, d0, d7
3401adc2:	b002      	add	sp, #8
3401adc4:	f7ff bfe4 	b.w	3401ad90 <with_errno>
3401adc8:	eeb0 7b40 	vmov.f64	d7, d0
3401adcc:	e7f2      	b.n	3401adb4 <xflow+0x8>
	...

3401add0 <__math_uflow>:
3401add0:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401add8 <__math_uflow+0x8>
3401add4:	f7ff bfea 	b.w	3401adac <xflow>
3401add8:	00000000 	.word	0x00000000
3401addc:	10000000 	.word	0x10000000

3401ade0 <__math_oflow>:
3401ade0:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401ade8 <__math_oflow+0x8>
3401ade4:	f7ff bfe2 	b.w	3401adac <xflow>
3401ade8:	00000000 	.word	0x00000000
3401adec:	70000000 	.word	0x70000000

3401adf0 <__math_divzero>:
3401adf0:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3401adf4:	b082      	sub	sp, #8
3401adf6:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3401adfa:	2800      	cmp	r0, #0
3401adfc:	f04f 0022 	mov.w	r0, #34	@ 0x22
3401ae00:	fe07 7b06 	vseleq.f64	d7, d7, d6
3401ae04:	ed8d 7b00 	vstr	d7, [sp]
3401ae08:	ed9d 0b00 	vldr	d0, [sp]
3401ae0c:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 3401ae20 <__math_divzero+0x30>
3401ae10:	ee80 0b07 	vdiv.f64	d0, d0, d7
3401ae14:	b002      	add	sp, #8
3401ae16:	f7ff bfbb 	b.w	3401ad90 <with_errno>
3401ae1a:	bf00      	nop
3401ae1c:	f3af 8000 	nop.w
	...

3401ae28 <__math_invalid>:
3401ae28:	eeb0 7b40 	vmov.f64	d7, d0
3401ae2c:	ee30 6b40 	vsub.f64	d6, d0, d0
3401ae30:	eeb4 7b47 	vcmp.f64	d7, d7
3401ae34:	ee86 0b06 	vdiv.f64	d0, d6, d6
3401ae38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ae3c:	d602      	bvs.n	3401ae44 <__math_invalid+0x1c>
3401ae3e:	2021      	movs	r0, #33	@ 0x21
3401ae40:	f7ff bfa6 	b.w	3401ad90 <with_errno>
3401ae44:	4770      	bx	lr

3401ae46 <__math_check_uflow>:
3401ae46:	eeb5 0b40 	vcmp.f64	d0, #0.0
3401ae4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ae4e:	d102      	bne.n	3401ae56 <__math_check_uflow+0x10>
3401ae50:	2022      	movs	r0, #34	@ 0x22
3401ae52:	f7ff bf9d 	b.w	3401ad90 <with_errno>
3401ae56:	4770      	bx	lr

3401ae58 <__math_check_oflow>:
3401ae58:	eeb0 7bc0 	vabs.f64	d7, d0
3401ae5c:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 3401ae78 <__math_check_oflow+0x20>
3401ae60:	eeb4 7b46 	vcmp.f64	d7, d6
3401ae64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ae68:	dd02      	ble.n	3401ae70 <__math_check_oflow+0x18>
3401ae6a:	2022      	movs	r0, #34	@ 0x22
3401ae6c:	f7ff bf90 	b.w	3401ad90 <with_errno>
3401ae70:	4770      	bx	lr
3401ae72:	bf00      	nop
3401ae74:	f3af 8000 	nop.w
3401ae78:	ffffffff 	.word	0xffffffff
3401ae7c:	7fefffff 	.word	0x7fefffff

3401ae80 <checkint>:
3401ae80:	f3c1 520a 	ubfx	r2, r1, #20, #11
3401ae84:	f240 33fe 	movw	r3, #1022	@ 0x3fe
3401ae88:	429a      	cmp	r2, r3
3401ae8a:	b570      	push	{r4, r5, r6, lr}
3401ae8c:	dd2a      	ble.n	3401aee4 <checkint+0x64>
3401ae8e:	f240 4333 	movw	r3, #1075	@ 0x433
3401ae92:	429a      	cmp	r2, r3
3401ae94:	dc24      	bgt.n	3401aee0 <checkint+0x60>
3401ae96:	1a9b      	subs	r3, r3, r2
3401ae98:	f04f 32ff 	mov.w	r2, #4294967295
3401ae9c:	f1a3 0620 	sub.w	r6, r3, #32
3401aea0:	fa02 f403 	lsl.w	r4, r2, r3
3401aea4:	f1c3 0520 	rsb	r5, r3, #32
3401aea8:	fa02 f606 	lsl.w	r6, r2, r6
3401aeac:	fa22 f505 	lsr.w	r5, r2, r5
3401aeb0:	409a      	lsls	r2, r3
3401aeb2:	4334      	orrs	r4, r6
3401aeb4:	ea20 0202 	bic.w	r2, r0, r2
3401aeb8:	432c      	orrs	r4, r5
3401aeba:	ea21 0404 	bic.w	r4, r1, r4
3401aebe:	4322      	orrs	r2, r4
3401aec0:	f1a3 0420 	sub.w	r4, r3, #32
3401aec4:	f1c3 0220 	rsb	r2, r3, #32
3401aec8:	d10c      	bne.n	3401aee4 <checkint+0x64>
3401aeca:	40d8      	lsrs	r0, r3
3401aecc:	fa01 f302 	lsl.w	r3, r1, r2
3401aed0:	40e1      	lsrs	r1, r4
3401aed2:	4318      	orrs	r0, r3
3401aed4:	4308      	orrs	r0, r1
3401aed6:	f000 0001 	and.w	r0, r0, #1
3401aeda:	f1d0 0002 	rsbs	r0, r0, #2
3401aede:	bd70      	pop	{r4, r5, r6, pc}
3401aee0:	2002      	movs	r0, #2
3401aee2:	e7fc      	b.n	3401aede <checkint+0x5e>
3401aee4:	2000      	movs	r0, #0
3401aee6:	e7fa      	b.n	3401aede <checkint+0x5e>

3401aee8 <pow>:
3401aee8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401aeec:	ee10 4a90 	vmov	r4, s1
3401aef0:	f240 73fd 	movw	r3, #2045	@ 0x7fd
3401aef4:	ee11 aa90 	vmov	sl, s3
3401aef8:	ee10 5a10 	vmov	r5, s0
3401aefc:	ea4f 5814 	mov.w	r8, r4, lsr #20
3401af00:	ee11 0a10 	vmov	r0, s2
3401af04:	ea4f 561a 	mov.w	r6, sl, lsr #20
3401af08:	f108 32ff 	add.w	r2, r8, #4294967295
3401af0c:	46c4      	mov	ip, r8
3401af0e:	429a      	cmp	r2, r3
3401af10:	ed2d 8b0a 	vpush	{d8-d12}
3401af14:	b087      	sub	sp, #28
3401af16:	d806      	bhi.n	3401af26 <pow+0x3e>
3401af18:	f3c6 030a 	ubfx	r3, r6, #0, #11
3401af1c:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
3401af20:	2b7f      	cmp	r3, #127	@ 0x7f
3401af22:	f240 8157 	bls.w	3401b1d4 <pow+0x2ec>
3401af26:	1802      	adds	r2, r0, r0
3401af28:	f06f 0b01 	mvn.w	fp, #1
3401af2c:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
3401af30:	eb4a 010a 	adc.w	r1, sl, sl
3401af34:	1e57      	subs	r7, r2, #1
3401af36:	f141 33ff 	adc.w	r3, r1, #4294967295
3401af3a:	45bb      	cmp	fp, r7
3401af3c:	eb7e 0303 	sbcs.w	r3, lr, r3
3401af40:	d242      	bcs.n	3401afc8 <pow+0xe0>
3401af42:	ea52 0301 	orrs.w	r3, r2, r1
3401af46:	f04f 0300 	mov.w	r3, #0
3401af4a:	d10c      	bne.n	3401af66 <pow+0x7e>
3401af4c:	196d      	adds	r5, r5, r5
3401af4e:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
3401af52:	4164      	adcs	r4, r4
3401af54:	42ab      	cmp	r3, r5
3401af56:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
3401af5a:	41a3      	sbcs	r3, r4
3401af5c:	f0c0 808f 	bcc.w	3401b07e <pow+0x196>
3401af60:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401af64:	e02b      	b.n	3401afbe <pow+0xd6>
3401af66:	4ed4      	ldr	r6, [pc, #848]	@ (3401b2b8 <pow+0x3d0>)
3401af68:	42b4      	cmp	r4, r6
3401af6a:	bf08      	it	eq
3401af6c:	429d      	cmpeq	r5, r3
3401af6e:	d109      	bne.n	3401af84 <pow+0x9c>
3401af70:	1800      	adds	r0, r0, r0
3401af72:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
3401af76:	eb4a 0a0a 	adc.w	sl, sl, sl
3401af7a:	4283      	cmp	r3, r0
3401af7c:	4bcf      	ldr	r3, [pc, #828]	@ (3401b2bc <pow+0x3d4>)
3401af7e:	eb73 030a 	sbcs.w	r3, r3, sl
3401af82:	e7eb      	b.n	3401af5c <pow+0x74>
3401af84:	196d      	adds	r5, r5, r5
3401af86:	48ce      	ldr	r0, [pc, #824]	@ (3401b2c0 <pow+0x3d8>)
3401af88:	4164      	adcs	r4, r4
3401af8a:	42ab      	cmp	r3, r5
3401af8c:	eb70 0604 	sbcs.w	r6, r0, r4
3401af90:	d375      	bcc.n	3401b07e <pow+0x196>
3401af92:	4281      	cmp	r1, r0
3401af94:	bf08      	it	eq
3401af96:	429a      	cmpeq	r2, r3
3401af98:	d171      	bne.n	3401b07e <pow+0x196>
3401af9a:	4aca      	ldr	r2, [pc, #808]	@ (3401b2c4 <pow+0x3dc>)
3401af9c:	4294      	cmp	r4, r2
3401af9e:	bf08      	it	eq
3401afa0:	429d      	cmpeq	r5, r3
3401afa2:	d0dd      	beq.n	3401af60 <pow+0x78>
3401afa4:	4294      	cmp	r4, r2
3401afa6:	ea6f 0a0a 	mvn.w	sl, sl
3401afaa:	bf34      	ite	cc
3401afac:	2400      	movcc	r4, #0
3401afae:	2401      	movcs	r4, #1
3401afb0:	ea4f 7ada 	mov.w	sl, sl, lsr #31
3401afb4:	4554      	cmp	r4, sl
3401afb6:	f040 81dc 	bne.w	3401b372 <pow+0x48a>
3401afba:	ee21 0b01 	vmul.f64	d0, d1, d1
3401afbe:	b007      	add	sp, #28
3401afc0:	ecbd 8b0a 	vpop	{d8-d12}
3401afc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401afc8:	196f      	adds	r7, r5, r5
3401afca:	eb44 0904 	adc.w	r9, r4, r4
3401afce:	1e7a      	subs	r2, r7, #1
3401afd0:	f169 0300 	sbc.w	r3, r9, #0
3401afd4:	4593      	cmp	fp, r2
3401afd6:	eb7e 0303 	sbcs.w	r3, lr, r3
3401afda:	d225      	bcs.n	3401b028 <pow+0x140>
3401afdc:	2c00      	cmp	r4, #0
3401afde:	ee20 0b00 	vmul.f64	d0, d0, d0
3401afe2:	da13      	bge.n	3401b00c <pow+0x124>
3401afe4:	4651      	mov	r1, sl
3401afe6:	f7ff ff4b 	bl	3401ae80 <checkint>
3401afea:	2801      	cmp	r0, #1
3401afec:	d10e      	bne.n	3401b00c <pow+0x124>
3401afee:	eeb1 0b40 	vneg.f64	d0, d0
3401aff2:	ea57 0909 	orrs.w	r9, r7, r9
3401aff6:	d10b      	bne.n	3401b010 <pow+0x128>
3401aff8:	f1ba 0f00 	cmp.w	sl, #0
3401affc:	dadf      	bge.n	3401afbe <pow+0xd6>
3401affe:	b007      	add	sp, #28
3401b000:	ecbd 8b0a 	vpop	{d8-d12}
3401b004:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b008:	f7ff bef2 	b.w	3401adf0 <__math_divzero>
3401b00c:	2000      	movs	r0, #0
3401b00e:	e7f0      	b.n	3401aff2 <pow+0x10a>
3401b010:	f1ba 0f00 	cmp.w	sl, #0
3401b014:	dad3      	bge.n	3401afbe <pow+0xd6>
3401b016:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3401b01a:	ee86 7b00 	vdiv.f64	d7, d6, d0
3401b01e:	ed8d 7b00 	vstr	d7, [sp]
3401b022:	ed9d 0b00 	vldr	d0, [sp]
3401b026:	e7ca      	b.n	3401afbe <pow+0xd6>
3401b028:	2c00      	cmp	r4, #0
3401b02a:	da2b      	bge.n	3401b084 <pow+0x19c>
3401b02c:	4651      	mov	r1, sl
3401b02e:	f7ff ff27 	bl	3401ae80 <checkint>
3401b032:	b930      	cbnz	r0, 3401b042 <pow+0x15a>
3401b034:	b007      	add	sp, #28
3401b036:	ecbd 8b0a 	vpop	{d8-d12}
3401b03a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b03e:	f7ff bef3 	b.w	3401ae28 <__math_invalid>
3401b042:	1e41      	subs	r1, r0, #1
3401b044:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
3401b048:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
3401b04c:	4248      	negs	r0, r1
3401b04e:	4148      	adcs	r0, r1
3401b050:	0480      	lsls	r0, r0, #18
3401b052:	f3c6 020a 	ubfx	r2, r6, #0, #11
3401b056:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
3401b05a:	2b7f      	cmp	r3, #127	@ 0x7f
3401b05c:	d92d      	bls.n	3401b0ba <pow+0x1d2>
3401b05e:	2000      	movs	r0, #0
3401b060:	4b95      	ldr	r3, [pc, #596]	@ (3401b2b8 <pow+0x3d0>)
3401b062:	429c      	cmp	r4, r3
3401b064:	bf08      	it	eq
3401b066:	4285      	cmpeq	r5, r0
3401b068:	f43f af7a 	beq.w	3401af60 <pow+0x78>
3401b06c:	f240 31bd 	movw	r1, #957	@ 0x3bd
3401b070:	428a      	cmp	r2, r1
3401b072:	d80c      	bhi.n	3401b08e <pow+0x1a6>
3401b074:	42a8      	cmp	r0, r5
3401b076:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b07a:	41a3      	sbcs	r3, r4
3401b07c:	d204      	bcs.n	3401b088 <pow+0x1a0>
3401b07e:	ee31 0b00 	vadd.f64	d0, d1, d0
3401b082:	e79c      	b.n	3401afbe <pow+0xd6>
3401b084:	2000      	movs	r0, #0
3401b086:	e7e4      	b.n	3401b052 <pow+0x16a>
3401b088:	ee30 0b41 	vsub.f64	d0, d0, d1
3401b08c:	e797      	b.n	3401afbe <pow+0xd6>
3401b08e:	2d01      	cmp	r5, #1
3401b090:	f240 72ff 	movw	r2, #2047	@ 0x7ff
3401b094:	eb74 0303 	sbcs.w	r3, r4, r3
3401b098:	bf34      	ite	cc
3401b09a:	2301      	movcc	r3, #1
3401b09c:	2300      	movcs	r3, #0
3401b09e:	4296      	cmp	r6, r2
3401b0a0:	bf8c      	ite	hi
3401b0a2:	2600      	movhi	r6, #0
3401b0a4:	2601      	movls	r6, #1
3401b0a6:	42b3      	cmp	r3, r6
3401b0a8:	f000 809c 	beq.w	3401b1e4 <pow+0x2fc>
3401b0ac:	b007      	add	sp, #28
3401b0ae:	ecbd 8b0a 	vpop	{d8-d12}
3401b0b2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b0b6:	f7ff be93 	b.w	3401ade0 <__math_oflow>
3401b0ba:	f1bc 0f00 	cmp.w	ip, #0
3401b0be:	d10a      	bne.n	3401b0d6 <pow+0x1ee>
3401b0c0:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 3401b2a8 <pow+0x3c0>
3401b0c4:	ee20 7b07 	vmul.f64	d7, d0, d7
3401b0c8:	ec53 2b17 	vmov	r2, r3, d7
3401b0cc:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
3401b0d0:	4615      	mov	r5, r2
3401b0d2:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
3401b0d6:	4a7c      	ldr	r2, [pc, #496]	@ (3401b2c8 <pow+0x3e0>)
3401b0d8:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3401b0dc:	4422      	add	r2, r4
3401b0de:	1513      	asrs	r3, r2, #20
3401b0e0:	f3c2 3146 	ubfx	r1, r2, #13, #7
3401b0e4:	f36f 0213 	bfc	r2, #0, #20
3401b0e8:	ee03 3a10 	vmov	s6, r3
3401b0ec:	4b77      	ldr	r3, [pc, #476]	@ (3401b2cc <pow+0x3e4>)
3401b0ee:	1aa7      	subs	r7, r4, r2
3401b0f0:	eb03 1641 	add.w	r6, r3, r1, lsl #5
3401b0f4:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
3401b0f8:	eb03 1241 	add.w	r2, r3, r1, lsl #5
3401b0fc:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
3401b100:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
3401b104:	1e2e      	subs	r6, r5, #0
3401b106:	ec47 6b14 	vmov	d4, r6, r7
3401b10a:	eea4 6b05 	vfma.f64	d6, d4, d5
3401b10e:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
3401b112:	ed93 5b00 	vldr	d5, [r3]
3401b116:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
3401b11a:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
3401b11e:	eea3 2b05 	vfma.f64	d2, d3, d5
3401b122:	ed93 5b02 	vldr	d5, [r3, #8]
3401b126:	eea3 7b05 	vfma.f64	d7, d3, d5
3401b12a:	ee36 4b02 	vadd.f64	d4, d6, d2
3401b12e:	ed93 5b04 	vldr	d5, [r3, #16]
3401b132:	ee32 2b44 	vsub.f64	d2, d2, d4
3401b136:	ee26 5b05 	vmul.f64	d5, d6, d5
3401b13a:	ee32 2b06 	vadd.f64	d2, d2, d6
3401b13e:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
3401b142:	ee26 0b05 	vmul.f64	d0, d6, d5
3401b146:	ee37 7b02 	vadd.f64	d7, d7, d2
3401b14a:	ee34 8b00 	vadd.f64	d8, d4, d0
3401b14e:	eeb0 9b40 	vmov.f64	d9, d0
3401b152:	ee26 bb00 	vmul.f64	d11, d6, d0
3401b156:	ee34 4b48 	vsub.f64	d4, d4, d8
3401b15a:	ee96 9b05 	vfnms.f64	d9, d6, d5
3401b15e:	ee34 ab00 	vadd.f64	d10, d4, d0
3401b162:	ed93 5b06 	vldr	d5, [r3, #24]
3401b166:	ed93 4b08 	vldr	d4, [r3, #32]
3401b16a:	eea6 5b04 	vfma.f64	d5, d6, d4
3401b16e:	ee37 7b09 	vadd.f64	d7, d7, d9
3401b172:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
3401b176:	ee37 7b0a 	vadd.f64	d7, d7, d10
3401b17a:	eea6 4b03 	vfma.f64	d4, d6, d3
3401b17e:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
3401b182:	eea6 3b0c 	vfma.f64	d3, d6, d12
3401b186:	eea0 4b03 	vfma.f64	d4, d0, d3
3401b18a:	eea0 5b04 	vfma.f64	d5, d0, d4
3401b18e:	eeab 7b05 	vfma.f64	d7, d11, d5
3401b192:	ee38 4b07 	vadd.f64	d4, d8, d7
3401b196:	ee21 6b04 	vmul.f64	d6, d1, d4
3401b19a:	ee38 8b44 	vsub.f64	d8, d8, d4
3401b19e:	eeb0 5b46 	vmov.f64	d5, d6
3401b1a2:	ee16 3a90 	vmov	r3, s13
3401b1a6:	ee38 8b07 	vadd.f64	d8, d8, d7
3401b1aa:	f3c3 560a 	ubfx	r6, r3, #20, #11
3401b1ae:	ee91 5b04 	vfnms.f64	d5, d1, d4
3401b1b2:	18b2      	adds	r2, r6, r2
3401b1b4:	2a3e      	cmp	r2, #62	@ 0x3e
3401b1b6:	eea1 5b08 	vfma.f64	d5, d1, d8
3401b1ba:	d91b      	bls.n	3401b1f4 <pow+0x30c>
3401b1bc:	2a00      	cmp	r2, #0
3401b1be:	da0b      	bge.n	3401b1d8 <pow+0x2f0>
3401b1c0:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b1c4:	ee36 0b00 	vadd.f64	d0, d6, d0
3401b1c8:	2800      	cmp	r0, #0
3401b1ca:	f43f aef8 	beq.w	3401afbe <pow+0xd6>
3401b1ce:	eeb1 0b40 	vneg.f64	d0, d0
3401b1d2:	e6f4      	b.n	3401afbe <pow+0xd6>
3401b1d4:	2000      	movs	r0, #0
3401b1d6:	e77e      	b.n	3401b0d6 <pow+0x1ee>
3401b1d8:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
3401b1dc:	d909      	bls.n	3401b1f2 <pow+0x30a>
3401b1de:	2b00      	cmp	r3, #0
3401b1e0:	f6bf af64 	bge.w	3401b0ac <pow+0x1c4>
3401b1e4:	b007      	add	sp, #28
3401b1e6:	ecbd 8b0a 	vpop	{d8-d12}
3401b1ea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b1ee:	f7ff bdef 	b.w	3401add0 <__math_uflow>
3401b1f2:	2600      	movs	r6, #0
3401b1f4:	4936      	ldr	r1, [pc, #216]	@ (3401b2d0 <pow+0x3e8>)
3401b1f6:	2700      	movs	r7, #0
3401b1f8:	ed91 4b02 	vldr	d4, [r1, #8]
3401b1fc:	ed91 3b00 	vldr	d3, [r1]
3401b200:	eeb0 7b44 	vmov.f64	d7, d4
3401b204:	eea6 7b03 	vfma.f64	d7, d6, d3
3401b208:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
3401b20c:	ee17 5a10 	vmov	r5, s14
3401b210:	ee37 7b44 	vsub.f64	d7, d7, d4
3401b214:	ed91 4b04 	vldr	d4, [r1, #16]
3401b218:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
3401b21c:	eea7 6b04 	vfma.f64	d6, d7, d4
3401b220:	18dc      	adds	r4, r3, r3
3401b222:	1940      	adds	r0, r0, r5
3401b224:	f104 030f 	add.w	r3, r4, #15
3401b228:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
3401b22c:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
3401b230:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
3401b234:	ed91 4b06 	vldr	d4, [r1, #24]
3401b238:	f8d2 e004 	ldr.w	lr, [r2, #4]
3401b23c:	eb17 020c 	adds.w	r2, r7, ip
3401b240:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
3401b244:	eea7 6b04 	vfma.f64	d6, d7, d4
3401b248:	ed91 4b08 	vldr	d4, [r1, #32]
3401b24c:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3401b250:	ee35 5b06 	vadd.f64	d5, d5, d6
3401b254:	eea5 4b03 	vfma.f64	d4, d5, d3
3401b258:	ee25 6b05 	vmul.f64	d6, d5, d5
3401b25c:	ee35 7b07 	vadd.f64	d7, d5, d7
3401b260:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
3401b264:	eea6 7b04 	vfma.f64	d7, d6, d4
3401b268:	ee26 6b06 	vmul.f64	d6, d6, d6
3401b26c:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
3401b270:	eea5 4b03 	vfma.f64	d4, d5, d3
3401b274:	eea6 7b04 	vfma.f64	d7, d6, d4
3401b278:	2e00      	cmp	r6, #0
3401b27a:	d175      	bne.n	3401b368 <pow+0x480>
3401b27c:	42bd      	cmp	r5, r7
3401b27e:	db29      	blt.n	3401b2d4 <pow+0x3ec>
3401b280:	f103 4140 	add.w	r1, r3, #3221225472	@ 0xc0000000
3401b284:	4610      	mov	r0, r2
3401b286:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
3401b28a:	ec41 0b10 	vmov	d0, r0, r1
3401b28e:	eea7 0b00 	vfma.f64	d0, d7, d0
3401b292:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 3401b2b0 <pow+0x3c8>
3401b296:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b29a:	b007      	add	sp, #28
3401b29c:	ecbd 8b0a 	vpop	{d8-d12}
3401b2a0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b2a4:	f7ff bdd8 	b.w	3401ae58 <__math_check_oflow>
3401b2a8:	00000000 	.word	0x00000000
3401b2ac:	43300000 	.word	0x43300000
3401b2b0:	00000000 	.word	0x00000000
3401b2b4:	7f000000 	.word	0x7f000000
3401b2b8:	3ff00000 	.word	0x3ff00000
3401b2bc:	fff00000 	.word	0xfff00000
3401b2c0:	ffe00000 	.word	0xffe00000
3401b2c4:	7fe00000 	.word	0x7fe00000
3401b2c8:	c0196aab 	.word	0xc0196aab
3401b2cc:	3403d0e8 	.word	0x3403d0e8
3401b2d0:	3403c878 	.word	0x3403c878
3401b2d4:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
3401b2d8:	4610      	mov	r0, r2
3401b2da:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
3401b2de:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
3401b2e2:	ec41 0b15 	vmov	d5, r0, r1
3401b2e6:	ee27 6b05 	vmul.f64	d6, d7, d5
3401b2ea:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 3401b378 <pow+0x490>
3401b2ee:	ee35 7b06 	vadd.f64	d7, d5, d6
3401b2f2:	eeb0 4bc7 	vabs.f64	d4, d7
3401b2f6:	eeb4 4bc3 	vcmpe.f64	d4, d3
3401b2fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b2fe:	d52a      	bpl.n	3401b356 <pow+0x46e>
3401b300:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3401b304:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
3401b308:	ee35 5b47 	vsub.f64	d5, d5, d7
3401b30c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b310:	ee35 5b06 	vadd.f64	d5, d5, d6
3401b314:	bf58      	it	pl
3401b316:	eeb0 4b43 	vmovpl.f64	d4, d3
3401b31a:	ee37 3b04 	vadd.f64	d3, d7, d4
3401b31e:	ee34 6b43 	vsub.f64	d6, d4, d3
3401b322:	ee36 6b07 	vadd.f64	d6, d6, d7
3401b326:	ee36 6b05 	vadd.f64	d6, d6, d5
3401b32a:	ee36 6b03 	vadd.f64	d6, d6, d3
3401b32e:	ee36 7b44 	vsub.f64	d7, d6, d4
3401b332:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401b336:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b33a:	d104      	bne.n	3401b346 <pow+0x45e>
3401b33c:	4632      	mov	r2, r6
3401b33e:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
3401b342:	ec43 2b17 	vmov	d7, r2, r3
3401b346:	ed8d 0b02 	vstr	d0, [sp, #8]
3401b34a:	ed9d 6b02 	vldr	d6, [sp, #8]
3401b34e:	ee26 6b00 	vmul.f64	d6, d6, d0
3401b352:	ed8d 6b04 	vstr	d6, [sp, #16]
3401b356:	ee27 0b00 	vmul.f64	d0, d7, d0
3401b35a:	b007      	add	sp, #28
3401b35c:	ecbd 8b0a 	vpop	{d8-d12}
3401b360:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b364:	f7ff bd6f 	b.w	3401ae46 <__math_check_uflow>
3401b368:	ec43 2b10 	vmov	d0, r2, r3
3401b36c:	eea7 0b00 	vfma.f64	d0, d7, d0
3401b370:	e625      	b.n	3401afbe <pow+0xd6>
3401b372:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 3401b380 <pow+0x498>
3401b376:	e622      	b.n	3401afbe <pow+0xd6>
3401b378:	00000000 	.word	0x00000000
3401b37c:	00100000 	.word	0x00100000
	...

3401b388 <expf>:
3401b388:	ee10 2a10 	vmov	r2, s0
3401b38c:	f240 412a 	movw	r1, #1066	@ 0x42a
3401b390:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
3401b394:	f3c2 530a 	ubfx	r3, r2, #20, #11
3401b398:	428b      	cmp	r3, r1
3401b39a:	b430      	push	{r4, r5}
3401b39c:	d92a      	bls.n	3401b3f4 <expf+0x6c>
3401b39e:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
3401b3a2:	d058      	beq.n	3401b456 <expf+0xce>
3401b3a4:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
3401b3a8:	d303      	bcc.n	3401b3b2 <expf+0x2a>
3401b3aa:	ee30 0a00 	vadd.f32	s0, s0, s0
3401b3ae:	bc30      	pop	{r4, r5}
3401b3b0:	4770      	bx	lr
3401b3b2:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 3401b45c <expf+0xd4>
3401b3b6:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401b3ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b3be:	dd03      	ble.n	3401b3c8 <expf+0x40>
3401b3c0:	2000      	movs	r0, #0
3401b3c2:	bc30      	pop	{r4, r5}
3401b3c4:	f000 b9f2 	b.w	3401b7ac <__math_oflowf>
3401b3c8:	eddf 7a25 	vldr	s15, [pc, #148]	@ 3401b460 <expf+0xd8>
3401b3cc:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401b3d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b3d4:	d503      	bpl.n	3401b3de <expf+0x56>
3401b3d6:	2000      	movs	r0, #0
3401b3d8:	bc30      	pop	{r4, r5}
3401b3da:	f000 b9db 	b.w	3401b794 <__math_uflowf>
3401b3de:	eddf 7a21 	vldr	s15, [pc, #132]	@ 3401b464 <expf+0xdc>
3401b3e2:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401b3e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b3ea:	d503      	bpl.n	3401b3f4 <expf+0x6c>
3401b3ec:	2000      	movs	r0, #0
3401b3ee:	bc30      	pop	{r4, r5}
3401b3f0:	f000 b9d6 	b.w	3401b7a0 <__math_may_uflowf>
3401b3f4:	4b1c      	ldr	r3, [pc, #112]	@ (3401b468 <expf+0xe0>)
3401b3f6:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b3fa:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
3401b3fe:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
3401b402:	eeb0 7b44 	vmov.f64	d7, d4
3401b406:	eea5 7b06 	vfma.f64	d7, d5, d6
3401b40a:	ee17 0a10 	vmov	r0, s14
3401b40e:	ee37 7b44 	vsub.f64	d7, d7, d4
3401b412:	f000 021f 	and.w	r2, r0, #31
3401b416:	ee95 7b06 	vfnms.f64	d7, d5, d6
3401b41a:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
3401b41e:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
3401b422:	684d      	ldr	r5, [r1, #4]
3401b424:	2100      	movs	r1, #0
3401b426:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
3401b42a:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
3401b42e:	190a      	adds	r2, r1, r4
3401b430:	eea5 6b07 	vfma.f64	d6, d5, d7
3401b434:	ee27 4b07 	vmul.f64	d4, d7, d7
3401b438:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
3401b43c:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3401b440:	eea5 0b07 	vfma.f64	d0, d5, d7
3401b444:	ec43 2b17 	vmov	d7, r2, r3
3401b448:	eea6 0b04 	vfma.f64	d0, d6, d4
3401b44c:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b450:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401b454:	e7ab      	b.n	3401b3ae <expf+0x26>
3401b456:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3401b46c <expf+0xe4>
3401b45a:	e7a8      	b.n	3401b3ae <expf+0x26>
3401b45c:	42b17217 	.word	0x42b17217
3401b460:	c2cff1b4 	.word	0xc2cff1b4
3401b464:	c2ce8ecf 	.word	0xc2ce8ecf
3401b468:	3403e130 	.word	0x3403e130
3401b46c:	00000000 	.word	0x00000000

3401b470 <checkint>:
3401b470:	f3c0 53c7 	ubfx	r3, r0, #23, #8
3401b474:	2b7e      	cmp	r3, #126	@ 0x7e
3401b476:	d910      	bls.n	3401b49a <checkint+0x2a>
3401b478:	2b96      	cmp	r3, #150	@ 0x96
3401b47a:	d80c      	bhi.n	3401b496 <checkint+0x26>
3401b47c:	2201      	movs	r2, #1
3401b47e:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
3401b482:	fa02 f303 	lsl.w	r3, r2, r3
3401b486:	1e5a      	subs	r2, r3, #1
3401b488:	4202      	tst	r2, r0
3401b48a:	d106      	bne.n	3401b49a <checkint+0x2a>
3401b48c:	4203      	tst	r3, r0
3401b48e:	bf14      	ite	ne
3401b490:	2001      	movne	r0, #1
3401b492:	2002      	moveq	r0, #2
3401b494:	4770      	bx	lr
3401b496:	2002      	movs	r0, #2
3401b498:	4770      	bx	lr
3401b49a:	2000      	movs	r0, #0
3401b49c:	4770      	bx	lr
	...

3401b4a0 <powf>:
3401b4a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401b4a2:	ee10 1a10 	vmov	r1, s0
3401b4a6:	ee10 4a90 	vmov	r4, s1
3401b4aa:	eef0 7a40 	vmov.f32	s15, s0
3401b4ae:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
3401b4b2:	0063      	lsls	r3, r4, #1
3401b4b4:	eeb0 7a60 	vmov.f32	s14, s1
3401b4b8:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
3401b4bc:	f103 30ff 	add.w	r0, r3, #4294967295
3401b4c0:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
3401b4c4:	d252      	bcs.n	3401b56c <powf+0xcc>
3401b4c6:	4290      	cmp	r0, r2
3401b4c8:	d258      	bcs.n	3401b57c <powf+0xdc>
3401b4ca:	2000      	movs	r0, #0
3401b4cc:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
3401b4d0:	4a9f      	ldr	r2, [pc, #636]	@ (3401b750 <powf+0x2b0>)
3401b4d2:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
3401b4d6:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
3401b4da:	f3c3 44c3 	ubfx	r4, r3, #19, #4
3401b4de:	f36f 0316 	bfc	r3, #0, #23
3401b4e2:	1ac9      	subs	r1, r1, r3
3401b4e4:	eb02 1404 	add.w	r4, r2, r4, lsl #4
3401b4e8:	15db      	asrs	r3, r3, #23
3401b4ea:	ee07 1a90 	vmov	s15, r1
3401b4ee:	ed94 4b00 	vldr	d4, [r4]
3401b4f2:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
3401b4f6:	ee07 3a90 	vmov	s15, r3
3401b4fa:	ed94 5b02 	vldr	d5, [r4, #8]
3401b4fe:	eea4 2b06 	vfma.f64	d2, d4, d6
3401b502:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3401b506:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3401b50a:	ee36 6b05 	vadd.f64	d6, d6, d5
3401b50e:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
3401b512:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
3401b516:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
3401b51a:	ee22 4b02 	vmul.f64	d4, d2, d2
3401b51e:	eea2 1b05 	vfma.f64	d1, d2, d5
3401b522:	ee24 0b04 	vmul.f64	d0, d4, d4
3401b526:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
3401b52a:	eea2 5b03 	vfma.f64	d5, d2, d3
3401b52e:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
3401b532:	eea2 6b03 	vfma.f64	d6, d2, d3
3401b536:	eea4 6b05 	vfma.f64	d6, d4, d5
3401b53a:	eea1 6b00 	vfma.f64	d6, d1, d0
3401b53e:	ee27 7b06 	vmul.f64	d7, d7, d6
3401b542:	ee17 3a90 	vmov	r3, s15
3401b546:	f3c3 32cf 	ubfx	r2, r3, #15, #16
3401b54a:	f248 03bf 	movw	r3, #32959	@ 0x80bf
3401b54e:	429a      	cmp	r2, r3
3401b550:	f0c0 8098 	bcc.w	3401b684 <powf+0x1e4>
3401b554:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 3401b730 <powf+0x290>
3401b558:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b55c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b560:	dd79      	ble.n	3401b656 <powf+0x1b6>
3401b562:	b003      	add	sp, #12
3401b564:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b568:	f000 b920 	b.w	3401b7ac <__math_oflowf>
3401b56c:	4290      	cmp	r0, r2
3401b56e:	d330      	bcc.n	3401b5d2 <powf+0x132>
3401b570:	b12b      	cbz	r3, 3401b57e <powf+0xde>
3401b572:	0049      	lsls	r1, r1, #1
3401b574:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
3401b578:	d808      	bhi.n	3401b58c <powf+0xec>
3401b57a:	e015      	b.n	3401b5a8 <powf+0x108>
3401b57c:	b953      	cbnz	r3, 3401b594 <powf+0xf4>
3401b57e:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
3401b582:	0049      	lsls	r1, r1, #1
3401b584:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
3401b588:	f240 80ca 	bls.w	3401b720 <powf+0x280>
3401b58c:	ee37 0a87 	vadd.f32	s0, s15, s14
3401b590:	b003      	add	sp, #12
3401b592:	bd30      	pop	{r4, r5, pc}
3401b594:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
3401b598:	d105      	bne.n	3401b5a6 <powf+0x106>
3401b59a:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
3401b59e:	0064      	lsls	r4, r4, #1
3401b5a0:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
3401b5a4:	e7f0      	b.n	3401b588 <powf+0xe8>
3401b5a6:	0049      	lsls	r1, r1, #1
3401b5a8:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
3401b5ac:	d1ee      	bne.n	3401b58c <powf+0xec>
3401b5ae:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3401b5b2:	f000 80b5 	beq.w	3401b720 <powf+0x280>
3401b5b6:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3401b5ba:	ea6f 0404 	mvn.w	r4, r4
3401b5be:	bf34      	ite	cc
3401b5c0:	2100      	movcc	r1, #0
3401b5c2:	2101      	movcs	r1, #1
3401b5c4:	0fe4      	lsrs	r4, r4, #31
3401b5c6:	42a1      	cmp	r1, r4
3401b5c8:	f040 80ad 	bne.w	3401b726 <powf+0x286>
3401b5cc:	ee27 0a07 	vmul.f32	s0, s14, s14
3401b5d0:	e7de      	b.n	3401b590 <powf+0xf0>
3401b5d2:	004d      	lsls	r5, r1, #1
3401b5d4:	1e6b      	subs	r3, r5, #1
3401b5d6:	4293      	cmp	r3, r2
3401b5d8:	d31b      	bcc.n	3401b612 <powf+0x172>
3401b5da:	2900      	cmp	r1, #0
3401b5dc:	ee20 0a00 	vmul.f32	s0, s0, s0
3401b5e0:	da0e      	bge.n	3401b600 <powf+0x160>
3401b5e2:	4620      	mov	r0, r4
3401b5e4:	f7ff ff44 	bl	3401b470 <checkint>
3401b5e8:	2801      	cmp	r0, #1
3401b5ea:	d109      	bne.n	3401b600 <powf+0x160>
3401b5ec:	eeb1 0a40 	vneg.f32	s0, s0
3401b5f0:	b945      	cbnz	r5, 3401b604 <powf+0x164>
3401b5f2:	2c00      	cmp	r4, #0
3401b5f4:	dacc      	bge.n	3401b590 <powf+0xf0>
3401b5f6:	b003      	add	sp, #12
3401b5f8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b5fc:	f000 b8dc 	b.w	3401b7b8 <__math_divzerof>
3401b600:	2000      	movs	r0, #0
3401b602:	e7f5      	b.n	3401b5f0 <powf+0x150>
3401b604:	2c00      	cmp	r4, #0
3401b606:	dac3      	bge.n	3401b590 <powf+0xf0>
3401b608:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401b60c:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401b610:	e7be      	b.n	3401b590 <powf+0xf0>
3401b612:	2900      	cmp	r1, #0
3401b614:	da1d      	bge.n	3401b652 <powf+0x1b2>
3401b616:	4620      	mov	r0, r4
3401b618:	f7ff ff2a 	bl	3401b470 <checkint>
3401b61c:	b920      	cbnz	r0, 3401b628 <powf+0x188>
3401b61e:	b003      	add	sp, #12
3401b620:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b624:	f000 b8da 	b.w	3401b7dc <__math_invalidf>
3401b628:	1e43      	subs	r3, r0, #1
3401b62a:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
3401b62e:	4258      	negs	r0, r3
3401b630:	4158      	adcs	r0, r3
3401b632:	0400      	lsls	r0, r0, #16
3401b634:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3401b638:	f4bf af48 	bcs.w	3401b4cc <powf+0x2c>
3401b63c:	eddf 6a45 	vldr	s13, [pc, #276]	@ 3401b754 <powf+0x2b4>
3401b640:	ee27 0aa6 	vmul.f32	s0, s15, s13
3401b644:	ee10 3a10 	vmov	r3, s0
3401b648:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3401b64c:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
3401b650:	e73c      	b.n	3401b4cc <powf+0x2c>
3401b652:	2000      	movs	r0, #0
3401b654:	e7ee      	b.n	3401b634 <powf+0x194>
3401b656:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 3401b738 <powf+0x298>
3401b65a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b65e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b662:	dd45      	ble.n	3401b6f0 <powf+0x250>
3401b664:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
3401b668:	b3d0      	cbz	r0, 3401b6e0 <powf+0x240>
3401b66a:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
3401b66e:	9301      	str	r3, [sp, #4]
3401b670:	eddd 6a01 	vldr	s13, [sp, #4]
3401b674:	ee76 6a66 	vsub.f32	s13, s12, s13
3401b678:	eef4 6a46 	vcmp.f32	s13, s12
3401b67c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b680:	f47f af6f 	bne.w	3401b562 <powf+0xc2>
3401b684:	4b34      	ldr	r3, [pc, #208]	@ (3401b758 <powf+0x2b8>)
3401b686:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b68a:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
3401b68e:	ee37 6b05 	vadd.f64	d6, d7, d5
3401b692:	ee16 2a10 	vmov	r2, s12
3401b696:	ee36 6b45 	vsub.f64	d6, d6, d5
3401b69a:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
3401b69e:	ee37 7b46 	vsub.f64	d7, d7, d6
3401b6a2:	f002 011f 	and.w	r1, r2, #31
3401b6a6:	1880      	adds	r0, r0, r2
3401b6a8:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
3401b6ac:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
3401b6b0:	ee27 4b07 	vmul.f64	d4, d7, d7
3401b6b4:	2100      	movs	r1, #0
3401b6b6:	686d      	ldr	r5, [r5, #4]
3401b6b8:	190a      	adds	r2, r1, r4
3401b6ba:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
3401b6be:	eea7 6b05 	vfma.f64	d6, d7, d5
3401b6c2:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
3401b6c6:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3401b6ca:	eea7 0b05 	vfma.f64	d0, d7, d5
3401b6ce:	ec43 2b17 	vmov	d7, r2, r3
3401b6d2:	eea6 0b04 	vfma.f64	d0, d6, d4
3401b6d6:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b6da:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401b6de:	e757      	b.n	3401b590 <powf+0xf0>
3401b6e0:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
3401b6e4:	9300      	str	r3, [sp, #0]
3401b6e6:	eddd 6a00 	vldr	s13, [sp]
3401b6ea:	ee76 6a86 	vadd.f32	s13, s13, s12
3401b6ee:	e7c3      	b.n	3401b678 <powf+0x1d8>
3401b6f0:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 3401b740 <powf+0x2a0>
3401b6f4:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b6f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b6fc:	d804      	bhi.n	3401b708 <powf+0x268>
3401b6fe:	b003      	add	sp, #12
3401b700:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b704:	f000 b846 	b.w	3401b794 <__math_uflowf>
3401b708:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 3401b748 <powf+0x2a8>
3401b70c:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b710:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b714:	d5b6      	bpl.n	3401b684 <powf+0x1e4>
3401b716:	b003      	add	sp, #12
3401b718:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b71c:	f000 b840 	b.w	3401b7a0 <__math_may_uflowf>
3401b720:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401b724:	e734      	b.n	3401b590 <powf+0xf0>
3401b726:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 3401b75c <powf+0x2bc>
3401b72a:	e731      	b.n	3401b590 <powf+0xf0>
3401b72c:	f3af 8000 	nop.w
3401b730:	ffd1d571 	.word	0xffd1d571
3401b734:	405fffff 	.word	0x405fffff
3401b738:	ffa3aae2 	.word	0xffa3aae2
3401b73c:	405fffff 	.word	0x405fffff
3401b740:	00000000 	.word	0x00000000
3401b744:	c062c000 	.word	0xc062c000
3401b748:	00000000 	.word	0x00000000
3401b74c:	c062a000 	.word	0xc062a000
3401b750:	3403eb08 	.word	0x3403eb08
3401b754:	4b000000 	.word	0x4b000000
3401b758:	3403e130 	.word	0x3403e130
3401b75c:	00000000 	.word	0x00000000

3401b760 <with_errnof>:
3401b760:	b510      	push	{r4, lr}
3401b762:	ed2d 8b02 	vpush	{d8}
3401b766:	eeb0 8a40 	vmov.f32	s16, s0
3401b76a:	4604      	mov	r4, r0
3401b76c:	f7fd fc5a 	bl	34019024 <__errno>
3401b770:	6004      	str	r4, [r0, #0]
3401b772:	eeb0 0a48 	vmov.f32	s0, s16
3401b776:	ecbd 8b02 	vpop	{d8}
3401b77a:	bd10      	pop	{r4, pc}

3401b77c <xflowf>:
3401b77c:	b130      	cbz	r0, 3401b78c <xflowf+0x10>
3401b77e:	eef1 7a40 	vneg.f32	s15, s0
3401b782:	ee27 0a80 	vmul.f32	s0, s15, s0
3401b786:	2022      	movs	r0, #34	@ 0x22
3401b788:	f7ff bfea 	b.w	3401b760 <with_errnof>
3401b78c:	eef0 7a40 	vmov.f32	s15, s0
3401b790:	e7f7      	b.n	3401b782 <xflowf+0x6>
	...

3401b794 <__math_uflowf>:
3401b794:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401b79c <__math_uflowf+0x8>
3401b798:	f7ff bff0 	b.w	3401b77c <xflowf>
3401b79c:	10000000 	.word	0x10000000

3401b7a0 <__math_may_uflowf>:
3401b7a0:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401b7a8 <__math_may_uflowf+0x8>
3401b7a4:	f7ff bfea 	b.w	3401b77c <xflowf>
3401b7a8:	1a200000 	.word	0x1a200000

3401b7ac <__math_oflowf>:
3401b7ac:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401b7b4 <__math_oflowf+0x8>
3401b7b0:	f7ff bfe4 	b.w	3401b77c <xflowf>
3401b7b4:	70000000 	.word	0x70000000

3401b7b8 <__math_divzerof>:
3401b7b8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401b7bc:	2800      	cmp	r0, #0
3401b7be:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
3401b7c2:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3401b7d8 <__math_divzerof+0x20>
3401b7c6:	f04f 0022 	mov.w	r0, #34	@ 0x22
3401b7ca:	fe47 7a87 	vseleq.f32	s15, s15, s14
3401b7ce:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401b7d2:	f7ff bfc5 	b.w	3401b760 <with_errnof>
3401b7d6:	bf00      	nop
3401b7d8:	00000000 	.word	0x00000000

3401b7dc <__math_invalidf>:
3401b7dc:	eef0 7a40 	vmov.f32	s15, s0
3401b7e0:	ee30 7a40 	vsub.f32	s14, s0, s0
3401b7e4:	eef4 7a67 	vcmp.f32	s15, s15
3401b7e8:	ee87 0a07 	vdiv.f32	s0, s14, s14
3401b7ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b7f0:	d602      	bvs.n	3401b7f8 <__math_invalidf+0x1c>
3401b7f2:	2021      	movs	r0, #33	@ 0x21
3401b7f4:	f7ff bfb4 	b.w	3401b760 <with_errnof>
3401b7f8:	4770      	bx	lr

3401b7fa <__ieee754_sqrt>:
3401b7fa:	eeb1 0bc0 	vsqrt.f64	d0, d0
3401b7fe:	4770      	bx	lr

3401b800 <__ieee754_log10>:
3401b800:	ee10 3a90 	vmov	r3, s1
3401b804:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401b808:	b510      	push	{r4, lr}
3401b80a:	ed2d 8b02 	vpush	{d8}
3401b80e:	da21      	bge.n	3401b854 <__ieee754_log10+0x54>
3401b810:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3401b814:	ee10 1a10 	vmov	r1, s0
3401b818:	430a      	orrs	r2, r1
3401b81a:	d108      	bne.n	3401b82e <__ieee754_log10+0x2e>
3401b81c:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 3401b8a8 <__ieee754_log10+0xa8>
3401b820:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 3401b8b0 <__ieee754_log10+0xb0>
3401b824:	ee86 0b07 	vdiv.f64	d0, d6, d7
3401b828:	ecbd 8b02 	vpop	{d8}
3401b82c:	bd10      	pop	{r4, pc}
3401b82e:	2b00      	cmp	r3, #0
3401b830:	da02      	bge.n	3401b838 <__ieee754_log10+0x38>
3401b832:	ee30 6b40 	vsub.f64	d6, d0, d0
3401b836:	e7f3      	b.n	3401b820 <__ieee754_log10+0x20>
3401b838:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 3401b8b8 <__ieee754_log10+0xb8>
3401b83c:	f06f 0235 	mvn.w	r2, #53	@ 0x35
3401b840:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b844:	ee10 3a90 	vmov	r3, s1
3401b848:	4923      	ldr	r1, [pc, #140]	@ (3401b8d8 <__ieee754_log10+0xd8>)
3401b84a:	428b      	cmp	r3, r1
3401b84c:	dd04      	ble.n	3401b858 <__ieee754_log10+0x58>
3401b84e:	ee30 0b00 	vadd.f64	d0, d0, d0
3401b852:	e7e9      	b.n	3401b828 <__ieee754_log10+0x28>
3401b854:	2200      	movs	r2, #0
3401b856:	e7f7      	b.n	3401b848 <__ieee754_log10+0x48>
3401b858:	1518      	asrs	r0, r3, #20
3401b85a:	f240 34ff 	movw	r4, #1023	@ 0x3ff
3401b85e:	f3c3 0113 	ubfx	r1, r3, #0, #20
3401b862:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
3401b866:	4410      	add	r0, r2
3401b868:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
3401b86c:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
3401b870:	ee08 3a10 	vmov	s16, r3
3401b874:	ec53 2b10 	vmov	r2, r3, d0
3401b878:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
3401b87c:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
3401b880:	ec43 2b10 	vmov	d0, r2, r3
3401b884:	f000 f82c 	bl	3401b8e0 <log>
3401b888:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401b8c0 <__ieee754_log10+0xc0>
3401b88c:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b890:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401b8c8 <__ieee754_log10+0xc8>
3401b894:	eea8 0b07 	vfma.f64	d0, d8, d7
3401b898:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401b8d0 <__ieee754_log10+0xd0>
3401b89c:	eea8 0b07 	vfma.f64	d0, d8, d7
3401b8a0:	e7c2      	b.n	3401b828 <__ieee754_log10+0x28>
3401b8a2:	bf00      	nop
3401b8a4:	f3af 8000 	nop.w
3401b8a8:	00000000 	.word	0x00000000
3401b8ac:	c3500000 	.word	0xc3500000
	...
3401b8bc:	43500000 	.word	0x43500000
3401b8c0:	1526e50e 	.word	0x1526e50e
3401b8c4:	3fdbcb7b 	.word	0x3fdbcb7b
3401b8c8:	11f12b36 	.word	0x11f12b36
3401b8cc:	3d59fef3 	.word	0x3d59fef3
3401b8d0:	509f6000 	.word	0x509f6000
3401b8d4:	3fd34413 	.word	0x3fd34413
3401b8d8:	7fefffff 	.word	0x7fefffff
3401b8dc:	00000000 	.word	0x00000000

3401b8e0 <log>:
3401b8e0:	ee10 0a90 	vmov	r0, s1
3401b8e4:	ee10 3a10 	vmov	r3, s0
3401b8e8:	b4f0      	push	{r4, r5, r6, r7}
3401b8ea:	f100 4140 	add.w	r1, r0, #3221225472	@ 0xc0000000
3401b8ee:	f04f 34ff 	mov.w	r4, #4294967295
3401b8f2:	0c02      	lsrs	r2, r0, #16
3401b8f4:	429c      	cmp	r4, r3
3401b8f6:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
3401b8fa:	4c71      	ldr	r4, [pc, #452]	@ (3401bac0 <log+0x1e0>)
3401b8fc:	418c      	sbcs	r4, r1
3401b8fe:	ed2d 8b02 	vpush	{d8}
3401b902:	d35a      	bcc.n	3401b9ba <log+0xda>
3401b904:	4a6f      	ldr	r2, [pc, #444]	@ (3401bac4 <log+0x1e4>)
3401b906:	4290      	cmp	r0, r2
3401b908:	bf08      	it	eq
3401b90a:	2b00      	cmpeq	r3, #0
3401b90c:	f000 80c7 	beq.w	3401ba9e <log+0x1be>
3401b910:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3401b914:	4b6c      	ldr	r3, [pc, #432]	@ (3401bac8 <log+0x1e8>)
3401b916:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3401b91a:	ee30 0b47 	vsub.f64	d0, d0, d7
3401b91e:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
3401b922:	ee20 2b00 	vmul.f64	d2, d0, d0
3401b926:	eea6 7b00 	vfma.f64	d7, d6, d0
3401b92a:	ee20 4b02 	vmul.f64	d4, d0, d2
3401b92e:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
3401b932:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
3401b936:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
3401b93a:	eea6 7b02 	vfma.f64	d7, d6, d2
3401b93e:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
3401b942:	eea5 6b00 	vfma.f64	d6, d5, d0
3401b946:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
3401b94a:	eea5 6b02 	vfma.f64	d6, d5, d2
3401b94e:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
3401b952:	eea3 5b00 	vfma.f64	d5, d3, d0
3401b956:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
3401b95a:	eea3 5b02 	vfma.f64	d5, d3, d2
3401b95e:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
3401b962:	eea3 5b04 	vfma.f64	d5, d3, d4
3401b966:	eeb0 3b40 	vmov.f64	d3, d0
3401b96a:	eea5 6b04 	vfma.f64	d6, d5, d4
3401b96e:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
3401b972:	eea6 7b04 	vfma.f64	d7, d6, d4
3401b976:	eeb0 6b40 	vmov.f64	d6, d0
3401b97a:	eeb0 2b47 	vmov.f64	d2, d7
3401b97e:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 3401baa8 <log+0x1c8>
3401b982:	eea0 6b07 	vfma.f64	d6, d0, d7
3401b986:	eea0 6b47 	vfms.f64	d6, d0, d7
3401b98a:	ee26 1b06 	vmul.f64	d1, d6, d6
3401b98e:	ee30 8b46 	vsub.f64	d8, d0, d6
3401b992:	eea1 3b05 	vfma.f64	d3, d1, d5
3401b996:	ee30 7b43 	vsub.f64	d7, d0, d3
3401b99a:	ee30 0b06 	vadd.f64	d0, d0, d6
3401b99e:	eea1 7b05 	vfma.f64	d7, d1, d5
3401b9a2:	ee25 5b08 	vmul.f64	d5, d5, d8
3401b9a6:	eea5 7b00 	vfma.f64	d7, d5, d0
3401b9aa:	eea2 7b04 	vfma.f64	d7, d2, d4
3401b9ae:	ee33 0b07 	vadd.f64	d0, d3, d7
3401b9b2:	ecbd 8b02 	vpop	{d8}
3401b9b6:	bcf0      	pop	{r4, r5, r6, r7}
3401b9b8:	4770      	bx	lr
3401b9ba:	f1a2 0410 	sub.w	r4, r2, #16
3401b9be:	f647 71df 	movw	r1, #32735	@ 0x7fdf
3401b9c2:	428c      	cmp	r4, r1
3401b9c4:	d923      	bls.n	3401ba0e <log+0x12e>
3401b9c6:	18d9      	adds	r1, r3, r3
3401b9c8:	eb40 0400 	adc.w	r4, r0, r0
3401b9cc:	4321      	orrs	r1, r4
3401b9ce:	d105      	bne.n	3401b9dc <log+0xfc>
3401b9d0:	2001      	movs	r0, #1
3401b9d2:	ecbd 8b02 	vpop	{d8}
3401b9d6:	bcf0      	pop	{r4, r5, r6, r7}
3401b9d8:	f7ff ba0a 	b.w	3401adf0 <__math_divzero>
3401b9dc:	493b      	ldr	r1, [pc, #236]	@ (3401bacc <log+0x1ec>)
3401b9de:	4288      	cmp	r0, r1
3401b9e0:	bf08      	it	eq
3401b9e2:	2b00      	cmpeq	r3, #0
3401b9e4:	d0e5      	beq.n	3401b9b2 <log+0xd2>
3401b9e6:	0413      	lsls	r3, r2, #16
3401b9e8:	d403      	bmi.n	3401b9f2 <log+0x112>
3401b9ea:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
3401b9ee:	4393      	bics	r3, r2
3401b9f0:	d104      	bne.n	3401b9fc <log+0x11c>
3401b9f2:	ecbd 8b02 	vpop	{d8}
3401b9f6:	bcf0      	pop	{r4, r5, r6, r7}
3401b9f8:	f7ff ba16 	b.w	3401ae28 <__math_invalid>
3401b9fc:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 3401bab0 <log+0x1d0>
3401ba00:	ee20 7b07 	vmul.f64	d7, d0, d7
3401ba04:	ec53 2b17 	vmov	r2, r3, d7
3401ba08:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
3401ba0c:	4613      	mov	r3, r2
3401ba0e:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
3401ba12:	492d      	ldr	r1, [pc, #180]	@ (3401bac8 <log+0x1e8>)
3401ba14:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
3401ba18:	1e1e      	subs	r6, r3, #0
3401ba1a:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
3401ba1e:	f3c2 3446 	ubfx	r4, r2, #13, #7
3401ba22:	ea4f 5c12 	mov.w	ip, r2, lsr #20
3401ba26:	1512      	asrs	r2, r2, #20
3401ba28:	eb01 1504 	add.w	r5, r1, r4, lsl #4
3401ba2c:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
3401ba30:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
3401ba34:	eba0 070c 	sub.w	r7, r0, ip
3401ba38:	ec47 6b16 	vmov	d6, r6, r7
3401ba3c:	eea7 5b06 	vfma.f64	d5, d7, d6
3401ba40:	ee07 2a90 	vmov	s15, r2
3401ba44:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3401ba48:	ed91 4b00 	vldr	d4, [r1]
3401ba4c:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
3401ba50:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
3401ba54:	eea4 7b06 	vfma.f64	d7, d4, d6
3401ba58:	ee25 2b05 	vmul.f64	d2, d5, d5
3401ba5c:	ee35 4b07 	vadd.f64	d4, d5, d7
3401ba60:	ee25 1b02 	vmul.f64	d1, d5, d2
3401ba64:	ee37 0b44 	vsub.f64	d0, d7, d4
3401ba68:	ed91 7b02 	vldr	d7, [r1, #8]
3401ba6c:	ee30 0b05 	vadd.f64	d0, d0, d5
3401ba70:	eea7 0b06 	vfma.f64	d0, d7, d6
3401ba74:	ed91 7b04 	vldr	d7, [r1, #16]
3401ba78:	ed91 6b08 	vldr	d6, [r1, #32]
3401ba7c:	eea7 0b02 	vfma.f64	d0, d7, d2
3401ba80:	ed91 7b06 	vldr	d7, [r1, #24]
3401ba84:	eea6 7b05 	vfma.f64	d7, d6, d5
3401ba88:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
3401ba8c:	eea3 6b05 	vfma.f64	d6, d3, d5
3401ba90:	eea6 7b02 	vfma.f64	d7, d6, d2
3401ba94:	eea1 0b07 	vfma.f64	d0, d1, d7
3401ba98:	ee30 0b04 	vadd.f64	d0, d0, d4
3401ba9c:	e789      	b.n	3401b9b2 <log+0xd2>
3401ba9e:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 3401bab8 <log+0x1d8>
3401baa2:	e786      	b.n	3401b9b2 <log+0xd2>
3401baa4:	f3af 8000 	nop.w
3401baa8:	00000000 	.word	0x00000000
3401baac:	41a00000 	.word	0x41a00000
3401bab0:	00000000 	.word	0x00000000
3401bab4:	43300000 	.word	0x43300000
	...
3401bac0:	000308ff 	.word	0x000308ff
3401bac4:	3ff00000 	.word	0x3ff00000
3401bac8:	3403e278 	.word	0x3403e278
3401bacc:	7ff00000 	.word	0x7ff00000

3401bad0 <_sbrk>:
3401bad0:	4a04      	ldr	r2, [pc, #16]	@ (3401bae4 <_sbrk+0x14>)
3401bad2:	4603      	mov	r3, r0
3401bad4:	6811      	ldr	r1, [r2, #0]
3401bad6:	b909      	cbnz	r1, 3401badc <_sbrk+0xc>
3401bad8:	4903      	ldr	r1, [pc, #12]	@ (3401bae8 <_sbrk+0x18>)
3401bada:	6011      	str	r1, [r2, #0]
3401badc:	6810      	ldr	r0, [r2, #0]
3401bade:	4403      	add	r3, r0
3401bae0:	6013      	str	r3, [r2, #0]
3401bae2:	4770      	bx	lr
3401bae4:	34044714 	.word	0x34044714
3401bae8:	34044718 	.word	0x34044718

3401baec <_init>:
3401baec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401baee:	bf00      	nop
3401baf0:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401baf2:	bc08      	pop	{r3}
3401baf4:	469e      	mov	lr, r3
3401baf6:	4770      	bx	lr

3401baf8 <_fini>:
3401baf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401bafa:	bf00      	nop
3401bafc:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401bafe:	bc08      	pop	{r3}
3401bb00:	469e      	mov	lr, r3
3401bb02:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3401bb20 <SECURE_SystemCoreClockUpdate>:
3401bb20:	e97f e97f 	sg
3401bb24:	f7e8 be1a 	b.w	3400475c <__acle_se_SECURE_SystemCoreClockUpdate>
	...
