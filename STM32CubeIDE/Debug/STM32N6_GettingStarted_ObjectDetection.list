
STM32N6_GettingStarted_ObjectDetection.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001b49c  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .gnu.sgstubs  00000020  3401bc00  3401bc00  0001bc00  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00023120  3401bc20  3401bc20  0001bc20  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .version      0000000c  3403ed40  3403ed40  0003ed40  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.extab    00000000  3403ed4c  3403ed4c  0003f0a8  2**0
                  CONTENTS
  6 .ARM          00000008  3403ed4c  3403ed4c  0003ed4c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .preinit_array 00000000  3403ed54  3403f0a8  0003f0a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .init_array   00000004  3403ed54  3403ed54  0003ed54  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .fini_array   00000004  3403ed58  3403ed58  0003ed58  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .data         0000034c  3403ed5c  3403ed5c  0003ed5c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          00019284  3403f0a8  3403f0a8  0003f0a8  2**3
                  ALLOC
 12 ._user_heap_stack 00004204  3405832c  3405832c  0003f0a8  2**0
                  ALLOC
 13 .psram_section 00232800  91000000  91000000  00040000  2**5
                  ALLOC
 14 .ARM.attributes 0000003a  00000000  00000000  0003f0a8  2**0
                  CONTENTS, READONLY
 15 .debug_info   000830e7  00000000  00000000  0003f0e2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000b7eb  00000000  00000000  000c21c9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loclists 0002fff3  00000000  00000000  000cd9b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000033d8  00000000  00000000  000fd9a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00004856  00000000  00000000  00100d80  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00095543  00000000  00000000  001055d6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0005faf6  00000000  00000000  0019ab19  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    003b6589  00000000  00000000  001fa60f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000086  00000000  00000000  005b0b98  2**0
                  CONTENTS, READONLY
 24 .debug_frame  0000b5d4  00000000  00000000  005b0c20  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 000000c7  00000000  00000000  005bc1f4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	3403f0a8 	.word	0x3403f0a8
3400076c:	00000000 	.word	0x00000000
34000770:	3401bbd4 	.word	0x3401bbd4

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	3403f0ac 	.word	0x3403f0ac
3400078c:	3401bbd4 	.word	0x3401bbd4

34000790 <vsvAKZpqpB>:
34000790:	ed90 6aad 	vldr	s12, [r0, #692]	@ 0x2b4
34000794:	b530      	push	{r4, r5, lr}
34000796:	ed2d 8b10 	vpush	{d8-d15}
3400079a:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
3400079e:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
340007a2:	b087      	sub	sp, #28
340007a4:	ed8d 7b02 	vstr	d7, [sp, #8]
340007a8:	2300      	movs	r3, #0
340007aa:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
340007ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340007b2:	ed91 5a01 	vldr	s10, [r1, #4]
340007b6:	ed91 4a00 	vldr	s8, [r1]
340007ba:	ed91 fb02 	vldr	d15, [r1, #8]
340007be:	ed91 eb04 	vldr	d14, [r1, #16]
340007c2:	4604      	mov	r4, r0
340007c4:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
340007c8:	ed90 cbaa 	vldr	d12, [r0, #680]	@ 0x2a8
340007cc:	ed90 ab16 	vldr	d10, [r0, #88]	@ 0x58
340007d0:	ed8d 7b04 	vstr	d7, [sp, #16]
340007d4:	ed90 bba6 	vldr	d11, [r0, #664]	@ 0x298
340007d8:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
340007dc:	dc09      	bgt.n	340007f2 <vsvAKZpqpB+0x62>
340007de:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
340007e2:	48d1      	ldr	r0, [pc, #836]	@ (34000b28 <vsvAKZpqpB+0x398>)
340007e4:	4798      	blx	r3
340007e6:	f04f 30ff 	mov.w	r0, #4294967295
340007ea:	b007      	add	sp, #28
340007ec:	ecbd 8b10 	vpop	{d8-d15}
340007f0:	bd30      	pop	{r4, r5, pc}
340007f2:	eeb8 5b45 	vcvt.f64.u32	d5, s10
340007f6:	ed9f 7bbe 	vldr	d7, [pc, #760]	@ 34000af0 <vsvAKZpqpB+0x360>
340007fa:	eeb8 4b44 	vcvt.f64.u32	d4, s8
340007fe:	ee25 7b07 	vmul.f64	d7, d5, d7
34000802:	eeb4 7bc4 	vcmpe.f64	d7, d4
34000806:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400080a:	dd0f      	ble.n	3400082c <vsvAKZpqpB+0x9c>
3400080c:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
34000810:	ed9f 2bb9 	vldr	d2, [pc, #740]	@ 34000af8 <vsvAKZpqpB+0x368>
34000814:	ee37 2b02 	vadd.f64	d2, d7, d2
34000818:	ed9f 7bb9 	vldr	d7, [pc, #740]	@ 34000b00 <vsvAKZpqpB+0x370>
3400081c:	eeb4 2bc7 	vcmpe.f64	d2, d7
34000820:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000824:	fe37 7b02 	vselgt.f64	d7, d7, d2
34000828:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
3400082c:	ed9f 7bb6 	vldr	d7, [pc, #728]	@ 34000b08 <vsvAKZpqpB+0x378>
34000830:	ee25 5b07 	vmul.f64	d5, d5, d7
34000834:	eeb4 5bc4 	vcmpe.f64	d5, d4
34000838:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400083c:	d510      	bpl.n	34000860 <vsvAKZpqpB+0xd0>
3400083e:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
34000842:	ed9f 5bad 	vldr	d5, [pc, #692]	@ 34000af8 <vsvAKZpqpB+0x368>
34000846:	ee37 7b45 	vsub.f64	d7, d7, d5
3400084a:	ed9f 5bb1 	vldr	d5, [pc, #708]	@ 34000b10 <vsvAKZpqpB+0x380>
3400084e:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000852:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000856:	bf58      	it	pl
34000858:	eeb0 5b47 	vmovpl.f64	d5, d7
3400085c:	ed84 5b1c 	vstr	d5, [r4, #112]	@ 0x70
34000860:	ee83 8b0c 	vdiv.f64	d8, d3, d12
34000864:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34000868:	eeb8 8b48 	vcvt.f64.u32	d8, s16
3400086c:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34000870:	ee28 8b0c 	vmul.f64	d8, d8, d12
34000874:	2d01      	cmp	r5, #1
34000876:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3400087a:	f040 80ac 	bne.w	340009d6 <vsvAKZpqpB+0x246>
3400087e:	ed9f 7ba6 	vldr	d7, [pc, #664]	@ 34000b18 <vsvAKZpqpB+0x388>
34000882:	ee3f 5b4e 	vsub.f64	d5, d15, d14
34000886:	ee85 db07 	vdiv.f64	d13, d5, d7
3400088a:	ee3f 5b0e 	vadd.f64	d5, d15, d14
3400088e:	ee85 9b07 	vdiv.f64	d9, d5, d7
34000892:	eeb0 7bcd 	vabs.f64	d7, d13
34000896:	eeb4 6bc7 	vcmpe.f64	d6, d7
3400089a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400089e:	eeb0 5bc9 	vabs.f64	d5, d9
340008a2:	db1f      	blt.n	340008e4 <vsvAKZpqpB+0x154>
340008a4:	eeb4 6bc5 	vcmpe.f64	d6, d5
340008a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008ac:	db1a      	blt.n	340008e4 <vsvAKZpqpB+0x154>
340008ae:	2300      	movs	r3, #0
340008b0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
340008b4:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
340008b8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
340008bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008c0:	f340 8134 	ble.w	34000b2c <vsvAKZpqpB+0x39c>
340008c4:	2301      	movs	r3, #1
340008c6:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340008ca:	ed9d 7b02 	vldr	d7, [sp, #8]
340008ce:	eeb4 abc7 	vcmpe.f64	d10, d7
340008d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008d6:	f140 813c 	bpl.w	34000b52 <vsvAKZpqpB+0x3c2>
340008da:	ed9d 7b04 	vldr	d7, [sp, #16]
340008de:	ee3a bb07 	vadd.f64	d11, d10, d7
340008e2:	e128      	b.n	34000b36 <vsvAKZpqpB+0x3a6>
340008e4:	eeb4 6bc5 	vcmpe.f64	d6, d5
340008e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340008ec:	d50c      	bpl.n	34000908 <vsvAKZpqpB+0x178>
340008ee:	ee89 5b0d 	vdiv.f64	d5, d9, d13
340008f2:	ed94 6aae 	vldr	s12, [r4, #696]	@ 0x2b8
340008f6:	eeb0 5bc5 	vabs.f64	d5, d5
340008fa:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
340008fe:	eeb4 5bc6 	vcmpe.f64	d5, d6
34000902:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000906:	dad5      	bge.n	340008b4 <vsvAKZpqpB+0x124>
34000908:	eef7 0bca 	vcvt.f32.f64	s1, d10
3400090c:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
34000910:	f01a fe3a 	bl	3401b588 <powf>
34000914:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34000918:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
3400091c:	ee20 0b07 	vmul.f64	d0, d0, d7
34000920:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34000924:	eeb0 6bce 	vabs.f64	d6, d14
34000928:	edcd 7a01 	vstr	s15, [sp, #4]
3400092c:	eeb0 7bcf 	vabs.f64	d7, d15
34000930:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000938:	dc62      	bgt.n	34000a00 <vsvAKZpqpB+0x270>
3400093a:	eeb5 ebc0 	vcmpe.f64	d14, #0.0
3400093e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000942:	d562      	bpl.n	34000a0a <vsvAKZpqpB+0x27a>
34000944:	ee38 0b00 	vadd.f64	d0, d8, d0
34000948:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
3400094c:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000954:	d503      	bpl.n	3400095e <vsvAKZpqpB+0x1ce>
34000956:	eeb0 ab4b 	vmov.f64	d10, d11
3400095a:	eeb0 0b47 	vmov.f64	d0, d7
3400095e:	ed94 7b3a 	vldr	d7, [r4, #232]	@ 0xe8
34000962:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000966:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400096a:	dd03      	ble.n	34000974 <vsvAKZpqpB+0x1e4>
3400096c:	eeb0 ab4b 	vmov.f64	d10, d11
34000970:	eeb0 0b47 	vmov.f64	d0, d7
34000974:	ee80 8b0c 	vdiv.f64	d8, d0, d12
34000978:	eebc 8bc8 	vcvt.u32.f64	s16, d8
3400097c:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34000980:	2d01      	cmp	r5, #1
34000982:	ee2c 8b08 	vmul.f64	d8, d12, d8
34000986:	d116      	bne.n	340009b6 <vsvAKZpqpB+0x226>
34000988:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
3400098c:	2b02      	cmp	r3, #2
3400098e:	d83f      	bhi.n	34000a10 <vsvAKZpqpB+0x280>
34000990:	eddd 7a01 	vldr	s15, [sp, #4]
34000994:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000998:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
3400099c:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
340009a0:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
340009a4:	eb04 1203 	add.w	r2, r4, r3, lsl #4
340009a8:	3301      	adds	r3, #1
340009aa:	ed82 db2c 	vstr	d13, [r2, #176]	@ 0xb0
340009ae:	ed82 9b2e 	vstr	d9, [r2, #184]	@ 0xb8
340009b2:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
340009b6:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
340009ba:	2b01      	cmp	r3, #1
340009bc:	d007      	beq.n	340009ce <vsvAKZpqpB+0x23e>
340009be:	eefc 7bc8 	vcvt.u32.f64	s15, d8
340009c2:	ee17 3a90 	vmov	r3, s15
340009c6:	9a01      	ldr	r2, [sp, #4]
340009c8:	4293      	cmp	r3, r2
340009ca:	f43f af73 	beq.w	340008b4 <vsvAKZpqpB+0x124>
340009ce:	2301      	movs	r3, #1
340009d0:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
340009d4:	e76e      	b.n	340008b4 <vsvAKZpqpB+0x124>
340009d6:	eeb0 7bcf 	vabs.f64	d7, d15
340009da:	eeb0 5bce 	vabs.f64	d5, d14
340009de:	eeb4 5b47 	vcmp.f64	d5, d7
340009e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009e6:	fe35 7b07 	vselgt.f64	d7, d5, d7
340009ea:	eeb4 7bc6 	vcmpe.f64	d7, d6
340009ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340009f2:	f67f af5f 	bls.w	340008b4 <vsvAKZpqpB+0x124>
340009f6:	ed9f 9b4a 	vldr	d9, [pc, #296]	@ 34000b20 <vsvAKZpqpB+0x390>
340009fa:	eeb0 db49 	vmov.f64	d13, d9
340009fe:	e783      	b.n	34000908 <vsvAKZpqpB+0x178>
34000a00:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34000a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a08:	d59c      	bpl.n	34000944 <vsvAKZpqpB+0x1b4>
34000a0a:	ee38 0b40 	vsub.f64	d0, d8, d0
34000a0e:	e79b      	b.n	34000948 <vsvAKZpqpB+0x1b8>
34000a10:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34000a14:	ed94 6aaf 	vldr	s12, [r4, #700]	@ 0x2bc
34000a18:	ee38 7b47 	vsub.f64	d7, d8, d7
34000a1c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34000a20:	eeb0 7bc7 	vabs.f64	d7, d7
34000a24:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000a28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a2c:	db56      	blt.n	34000adc <vsvAKZpqpB+0x34c>
34000a2e:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34000a32:	ee38 7b47 	vsub.f64	d7, d8, d7
34000a36:	eeb0 7bc7 	vabs.f64	d7, d7
34000a3a:	eeb4 6bc7 	vcmpe.f64	d6, d7
34000a3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a42:	dd4b      	ble.n	34000adc <vsvAKZpqpB+0x34c>
34000a44:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34000a48:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34000a4c:	ee39 0b40 	vsub.f64	d0, d9, d0
34000a50:	ee3d 7b47 	vsub.f64	d7, d13, d7
34000a54:	ee20 0b00 	vmul.f64	d0, d0, d0
34000a58:	eea7 0b07 	vfma.f64	d0, d7, d7
34000a5c:	f01a f9e4 	bl	3401ae28 <sqrt>
34000a60:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34000a64:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000a68:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000a6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a70:	d534      	bpl.n	34000adc <vsvAKZpqpB+0x34c>
34000a72:	eddd 7a01 	vldr	s15, [sp, #4]
34000a76:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34000a7a:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34000a7e:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000a82:	2b00      	cmp	r3, #0
34000a84:	d197      	bne.n	340009b6 <vsvAKZpqpB+0x226>
34000a86:	2210      	movs	r2, #16
34000a88:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34000a8c:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34000a90:	f018 f8ce 	bl	34018c30 <memmove>
34000a94:	2210      	movs	r2, #16
34000a96:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
34000a9a:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34000a9e:	f018 f8c7 	bl	34018c30 <memmove>
34000aa2:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
34000aa6:	eddd 7a01 	vldr	s15, [sp, #4]
34000aaa:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000aae:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34000ab2:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34000ab6:	ed84 7b24 	vstr	d7, [r4, #144]	@ 0x90
34000aba:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
34000abe:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34000ac2:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
34000ac6:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
34000aca:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
34000ace:	ed84 db34 	vstr	d13, [r4, #208]	@ 0xd0
34000ad2:	ed84 9b36 	vstr	d9, [r4, #216]	@ 0xd8
34000ad6:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
34000ada:	e76c      	b.n	340009b6 <vsvAKZpqpB+0x226>
34000adc:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000ae0:	2b01      	cmp	r3, #1
34000ae2:	bf04      	itt	eq
34000ae4:	2300      	moveq	r3, #0
34000ae6:	f884 3078 	strbeq.w	r3, [r4, #120]	@ 0x78
34000aea:	e7c8      	b.n	34000a7e <vsvAKZpqpB+0x2ee>
34000aec:	f3af 8000 	nop.w
34000af0:	9999999a 	.word	0x9999999a
34000af4:	3fa99999 	.word	0x3fa99999
34000af8:	47ae147b 	.word	0x47ae147b
34000afc:	3f847ae1 	.word	0x3f847ae1
34000b00:	33333334 	.word	0x33333334
34000b04:	3fc33333 	.word	0x3fc33333
34000b08:	33333333 	.word	0x33333333
34000b0c:	3fc33333 	.word	0x3fc33333
34000b10:	11111111 	.word	0x11111111
34000b14:	3fb11111 	.word	0x3fb11111
34000b18:	667f3bcd 	.word	0x667f3bcd
34000b1c:	3ff6a09e 	.word	0x3ff6a09e
	...
34000b28:	3401d9ae 	.word	0x3401d9ae
34000b2c:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34000b30:	2b00      	cmp	r3, #0
34000b32:	f47f aeca 	bne.w	340008ca <vsvAKZpqpB+0x13a>
34000b36:	ee88 7b0c 	vdiv.f64	d7, d8, d12
34000b3a:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34000b3e:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34000b42:	ee27 7b0c 	vmul.f64	d7, d7, d12
34000b46:	ed84 bb16 	vstr	d11, [r4, #88]	@ 0x58
34000b4a:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34000b4e:	2001      	movs	r0, #1
34000b50:	e64b      	b.n	340007ea <vsvAKZpqpB+0x5a>
34000b52:	ed9d bb02 	vldr	d11, [sp, #8]
34000b56:	e7ee      	b.n	34000b36 <vsvAKZpqpB+0x3a6>

34000b58 <JxZhqVLLqu>:
34000b58:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34000b5c:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000b60:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34000b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b68:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34000b6c:	eeb0 7b46 	vmov.f64	d7, d6
34000b70:	bfdf      	itttt	le
34000b72:	ee84 7b05 	vdivle.f64	d7, d4, d5
34000b76:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34000b7a:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34000b7e:	ee27 7b05 	vmulle.f64	d7, d7, d5
34000b82:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34000b86:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34000b8a:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000b8e:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b96:	bfc8      	it	gt
34000b98:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34000b9c:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34000ba0:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000ba4:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000ba8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bac:	bf48      	it	mi
34000bae:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34000bb2:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34000bb6:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34000bba:	b530      	push	{r4, r5, lr}
34000bbc:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34000bc0:	ed93 5a00 	vldr	s10, [r3]
34000bc4:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34000bc8:	eeb4 5ac7 	vcmpe.f32	s10, s14
34000bcc:	eef1 5a67 	vneg.f32	s11, s15
34000bd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bd4:	f04f 0100 	mov.w	r1, #0
34000bd8:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34000bdc:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34000be0:	3b01      	subs	r3, #1
34000be2:	b28a      	uxth	r2, r1
34000be4:	4293      	cmp	r3, r2
34000be6:	d805      	bhi.n	34000bf4 <JxZhqVLLqu+0x9c>
34000be8:	2244      	movs	r2, #68	@ 0x44
34000bea:	fb02 0303 	mla	r3, r2, r3, r0
34000bee:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34000bf2:	e011      	b.n	34000c18 <JxZhqVLLqu+0xc0>
34000bf4:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34000bf8:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34000bfc:	ee77 5aa5 	vadd.f32	s11, s15, s11
34000c00:	eef4 5ac7 	vcmpe.f32	s11, s14
34000c04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c08:	f101 0101 	add.w	r1, r1, #1
34000c0c:	dbe9      	blt.n	34000be2 <JxZhqVLLqu+0x8a>
34000c0e:	2344      	movs	r3, #68	@ 0x44
34000c10:	fb03 0202 	mla	r2, r3, r2, r0
34000c14:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34000c18:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000c1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c20:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34000c24:	dc05      	bgt.n	34000c32 <JxZhqVLLqu+0xda>
34000c26:	ed93 7a00 	vldr	s14, [r3]
34000c2a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000c2e:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34000c32:	685a      	ldr	r2, [r3, #4]
34000c34:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34000c38:	6042      	str	r2, [r0, #4]
34000c3a:	689a      	ldr	r2, [r3, #8]
34000c3c:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34000c40:	6082      	str	r2, [r0, #8]
34000c42:	68da      	ldr	r2, [r3, #12]
34000c44:	60c2      	str	r2, [r0, #12]
34000c46:	691a      	ldr	r2, [r3, #16]
34000c48:	6102      	str	r2, [r0, #16]
34000c4a:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34000c4e:	695d      	ldr	r5, [r3, #20]
34000c50:	330c      	adds	r3, #12
34000c52:	6145      	str	r5, [r0, #20]
34000c54:	68dd      	ldr	r5, [r3, #12]
34000c56:	300c      	adds	r0, #12
34000c58:	60c5      	str	r5, [r0, #12]
34000c5a:	691d      	ldr	r5, [r3, #16]
34000c5c:	42a3      	cmp	r3, r4
34000c5e:	6105      	str	r5, [r0, #16]
34000c60:	f851 5b04 	ldr.w	r5, [r1], #4
34000c64:	f842 5b04 	str.w	r5, [r2], #4
34000c68:	d1f1      	bne.n	34000c4e <JxZhqVLLqu+0xf6>
34000c6a:	2001      	movs	r0, #1
34000c6c:	bd30      	pop	{r4, r5, pc}

34000c6e <evision_api_awb_new>:
34000c6e:	b510      	push	{r4, lr}
34000c70:	4604      	mov	r4, r0
34000c72:	b090      	sub	sp, #64	@ 0x40
34000c74:	b170      	cbz	r0, 34000c94 <evision_api_awb_new+0x26>
34000c76:	2300      	movs	r3, #0
34000c78:	4c08      	ldr	r4, [pc, #32]	@ (34000c9c <evision_api_awb_new+0x2e>)
34000c7a:	2140      	movs	r1, #64	@ 0x40
34000c7c:	7023      	strb	r3, [r4, #0]
34000c7e:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34000c82:	4b07      	ldr	r3, [pc, #28]	@ (34000ca0 <evision_api_awb_new+0x32>)
34000c84:	4668      	mov	r0, sp
34000c86:	4a07      	ldr	r2, [pc, #28]	@ (34000ca4 <evision_api_awb_new+0x36>)
34000c88:	f017 fe88 	bl	3401899c <sniprintf>
34000c8c:	4668      	mov	r0, sp
34000c8e:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000c92:	4798      	blx	r3
34000c94:	4620      	mov	r0, r4
34000c96:	b010      	add	sp, #64	@ 0x40
34000c98:	bd10      	pop	{r4, pc}
34000c9a:	bf00      	nop
34000c9c:	3403f0c8 	.word	0x3403f0c8
34000ca0:	3403ed40 	.word	0x3403ed40
34000ca4:	3401d9ee 	.word	0x3401d9ee

34000ca8 <evision_api_awb_delete>:
34000ca8:	2800      	cmp	r0, #0
34000caa:	bf14      	ite	ne
34000cac:	2001      	movne	r0, #1
34000cae:	f04f 30ff 	moveq.w	r0, #4294967295
34000cb2:	4770      	bx	lr

34000cb4 <evision_api_awb_set_profile>:
34000cb4:	ed80 0a00 	vstr	s0, [r0]
34000cb8:	b530      	push	{r4, r5, lr}
34000cba:	680c      	ldr	r4, [r1, #0]
34000cbc:	6044      	str	r4, [r0, #4]
34000cbe:	684c      	ldr	r4, [r1, #4]
34000cc0:	6084      	str	r4, [r0, #8]
34000cc2:	688c      	ldr	r4, [r1, #8]
34000cc4:	60c4      	str	r4, [r0, #12]
34000cc6:	68c9      	ldr	r1, [r1, #12]
34000cc8:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34000ccc:	6101      	str	r1, [r0, #16]
34000cce:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34000cd2:	6815      	ldr	r5, [r2, #0]
34000cd4:	320c      	adds	r2, #12
34000cd6:	6145      	str	r5, [r0, #20]
34000cd8:	f852 5c08 	ldr.w	r5, [r2, #-8]
34000cdc:	300c      	adds	r0, #12
34000cde:	60c5      	str	r5, [r0, #12]
34000ce0:	f852 5c04 	ldr.w	r5, [r2, #-4]
34000ce4:	42a2      	cmp	r2, r4
34000ce6:	6105      	str	r5, [r0, #16]
34000ce8:	f853 5b04 	ldr.w	r5, [r3], #4
34000cec:	f841 5b04 	str.w	r5, [r1], #4
34000cf0:	d1ef      	bne.n	34000cd2 <evision_api_awb_set_profile+0x1e>
34000cf2:	bd30      	pop	{r4, r5, pc}

34000cf4 <evision_api_awb_init_profiles>:
34000cf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000cf8:	ed2d 8b06 	vpush	{d8-d10}
34000cfc:	460e      	mov	r6, r1
34000cfe:	eeb0 9b40 	vmov.f64	d9, d0
34000d02:	eeb0 8b41 	vmov.f64	d8, d1
34000d06:	461d      	mov	r5, r3
34000d08:	4604      	mov	r4, r0
34000d0a:	b0c7      	sub	sp, #284	@ 0x11c
34000d0c:	2800      	cmp	r0, #0
34000d0e:	f000 818f 	beq.w	34001030 <evision_api_awb_init_profiles+0x33c>
34000d12:	ed9f abcb 	vldr	d10, [pc, #812]	@ 34001040 <evision_api_awb_init_profiles+0x34c>
34000d16:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34000d1a:	2000      	movs	r0, #0
34000d1c:	49ce      	ldr	r1, [pc, #824]	@ (34001058 <evision_api_awb_init_profiles+0x364>)
34000d1e:	f04f 0800 	mov.w	r8, #0
34000d22:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34000d26:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34000d2a:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34000d2e:	49cb      	ldr	r1, [pc, #812]	@ (3400105c <evision_api_awb_init_profiles+0x368>)
34000d30:	f8df 935c 	ldr.w	r9, [pc, #860]	@ 34001090 <evision_api_awb_init_profiles+0x39c>
34000d34:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34000d38:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34000d3c:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34000d40:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34000d44:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34000d48:	f20f 29fc 	addw	r9, pc, #764	@ 0x2fc
34000d4c:	e9d9 8900 	ldrd	r8, r9, [r9]
34000d50:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34000d54:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
34000d58:	f04f 0800 	mov.w	r8, #0
34000d5c:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34000d60:	49bf      	ldr	r1, [pc, #764]	@ (34001060 <evision_api_awb_init_profiles+0x36c>)
34000d62:	f8df 9330 	ldr.w	r9, [pc, #816]	@ 34001094 <evision_api_awb_init_profiles+0x3a0>
34000d66:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
34000d6a:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34000d6e:	2300      	movs	r3, #0
34000d70:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34000d74:	2701      	movs	r7, #1
34000d76:	f04f 0800 	mov.w	r8, #0
34000d7a:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34000d7e:	1e71      	subs	r1, r6, #1
34000d80:	f8df 9314 	ldr.w	r9, [pc, #788]	@ 34001098 <evision_api_awb_init_profiles+0x3a4>
34000d84:	b288      	uxth	r0, r1
34000d86:	2804      	cmp	r0, #4
34000d88:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34000d8c:	f20f 29c0 	addw	r9, pc, #704	@ 0x2c0
34000d90:	e9d9 8900 	ldrd	r8, r9, [r9]
34000d94:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000d98:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34000d9c:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34000da0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34000da4:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
34000da8:	d914      	bls.n	34000dd4 <evision_api_awb_init_profiles+0xe0>
34000daa:	2305      	movs	r3, #5
34000dac:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000db0:	4aac      	ldr	r2, [pc, #688]	@ (34001064 <evision_api_awb_init_profiles+0x370>)
34000db2:	a806      	add	r0, sp, #24
34000db4:	f017 fdf2 	bl	3401899c <sniprintf>
34000db8:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000dbc:	a806      	add	r0, sp, #24
34000dbe:	4798      	blx	r3
34000dc0:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34000dc4:	4620      	mov	r0, r4
34000dc6:	b047      	add	sp, #284	@ 0x11c
34000dc8:	ecbd 8b06 	vpop	{d8-d10}
34000dcc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000dd0:	f7ff bec2 	b.w	34000b58 <JxZhqVLLqu>
34000dd4:	ed95 7a00 	vldr	s14, [r5]
34000dd8:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000ddc:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000de0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000de4:	dd12      	ble.n	34000e0c <evision_api_awb_init_profiles+0x118>
34000de6:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000dea:	489f      	ldr	r0, [pc, #636]	@ (34001068 <evision_api_awb_init_profiles+0x374>)
34000dec:	4798      	blx	r3
34000dee:	ed95 7a00 	vldr	s14, [r5]
34000df2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000df6:	ed8d 9b00 	vstr	d9, [sp]
34000dfa:	ed8d 7b02 	vstr	d7, [sp, #8]
34000dfe:	4a9b      	ldr	r2, [pc, #620]	@ (3400106c <evision_api_awb_init_profiles+0x378>)
34000e00:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000e04:	a806      	add	r0, sp, #24
34000e06:	f017 fdc9 	bl	3401899c <sniprintf>
34000e0a:	e7d5      	b.n	34000db8 <evision_api_awb_init_profiles+0xc4>
34000e0c:	f04f 0c44 	mov.w	ip, #68	@ 0x44
34000e10:	fb0c 5806 	mla	r8, ip, r6, r5
34000e14:	ed18 7a11 	vldr	s14, [r8, #-68]	@ 0xffffffbc
34000e18:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e1c:	eeb4 1bc7 	vcmpe.f64	d1, d7
34000e20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e24:	d541      	bpl.n	34000eaa <evision_api_awb_init_profiles+0x1b6>
34000e26:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000e2a:	4891      	ldr	r0, [pc, #580]	@ (34001070 <evision_api_awb_init_profiles+0x37c>)
34000e2c:	4798      	blx	r3
34000e2e:	ed98 7a00 	vldr	s14, [r8]
34000e32:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e36:	ed8d 8b00 	vstr	d8, [sp]
34000e3a:	ed8d 7b02 	vstr	d7, [sp, #8]
34000e3e:	4a8d      	ldr	r2, [pc, #564]	@ (34001074 <evision_api_awb_init_profiles+0x380>)
34000e40:	e7de      	b.n	34000e00 <evision_api_awb_init_profiles+0x10c>
34000e42:	fb0c f708 	mul.w	r7, ip, r8
34000e46:	eb05 0907 	add.w	r9, r5, r7
34000e4a:	3744      	adds	r7, #68	@ 0x44
34000e4c:	442f      	add	r7, r5
34000e4e:	ed99 7a00 	vldr	s14, [r9]
34000e52:	edd7 7a00 	vldr	s15, [r7]
34000e56:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000e5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e5e:	f108 0a01 	add.w	sl, r8, #1
34000e62:	f100 0001 	add.w	r0, r0, #1
34000e66:	db21      	blt.n	34000eac <evision_api_awb_init_profiles+0x1b8>
34000e68:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000e6c:	4882      	ldr	r0, [pc, #520]	@ (34001078 <evision_api_awb_init_profiles+0x384>)
34000e6e:	4798      	blx	r3
34000e70:	ed97 7a00 	vldr	s14, [r7]
34000e74:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e78:	ed8d 7b04 	vstr	d7, [sp, #16]
34000e7c:	f8cd a008 	str.w	sl, [sp, #8]
34000e80:	ed99 7a00 	vldr	s14, [r9]
34000e84:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e88:	4643      	mov	r3, r8
34000e8a:	ed8d 7b00 	vstr	d7, [sp]
34000e8e:	4a7b      	ldr	r2, [pc, #492]	@ (3400107c <evision_api_awb_init_profiles+0x388>)
34000e90:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000e94:	a806      	add	r0, sp, #24
34000e96:	f017 fd81 	bl	3401899c <sniprintf>
34000e9a:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000e9e:	a806      	add	r0, sp, #24
34000ea0:	4798      	blx	r3
34000ea2:	2301      	movs	r3, #1
34000ea4:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34000ea8:	e78c      	b.n	34000dc4 <evision_api_awb_init_profiles+0xd0>
34000eaa:	4618      	mov	r0, r3
34000eac:	fa1f f880 	uxth.w	r8, r0
34000eb0:	4541      	cmp	r1, r8
34000eb2:	d8c6      	bhi.n	34000e42 <evision_api_awb_init_profiles+0x14e>
34000eb4:	2300      	movs	r3, #0
34000eb6:	f04f 0c44 	mov.w	ip, #68	@ 0x44
34000eba:	1eb0      	subs	r0, r6, #2
34000ebc:	b29f      	uxth	r7, r3
34000ebe:	42b9      	cmp	r1, r7
34000ec0:	d839      	bhi.n	34000f36 <evision_api_awb_init_profiles+0x242>
34000ec2:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
34000ec6:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
34000eca:	2000      	movs	r0, #0
34000ecc:	f8a4 60f8 	strh.w	r6, [r4, #248]	@ 0xf8
34000ed0:	b283      	uxth	r3, r0
34000ed2:	4299      	cmp	r1, r3
34000ed4:	f100 0001 	add.w	r0, r0, #1
34000ed8:	f200 808b 	bhi.w	34000ff2 <evision_api_awb_init_profiles+0x2fe>
34000edc:	2700      	movs	r7, #0
34000ede:	46b8      	mov	r8, r7
34000ee0:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34000ee4:	f504 7990 	add.w	r9, r4, #288	@ 0x120
34000ee8:	eb05 0b07 	add.w	fp, r5, r7
34000eec:	eb09 0007 	add.w	r0, r9, r7
34000ef0:	2244      	movs	r2, #68	@ 0x44
34000ef2:	4659      	mov	r1, fp
34000ef4:	f018 f94d 	bl	34019192 <memcpy>
34000ef8:	f8db 3000 	ldr.w	r3, [fp]
34000efc:	f108 0801 	add.w	r8, r8, #1
34000f00:	f84a 3b04 	str.w	r3, [sl], #4
34000f04:	fa1f f388 	uxth.w	r3, r8
34000f08:	429e      	cmp	r6, r3
34000f0a:	f107 0744 	add.w	r7, r7, #68	@ 0x44
34000f0e:	d8eb      	bhi.n	34000ee8 <evision_api_awb_init_profiles+0x1f4>
34000f10:	1e73      	subs	r3, r6, #1
34000f12:	b29b      	uxth	r3, r3
34000f14:	2e00      	cmp	r6, #0
34000f16:	f103 0301 	add.w	r3, r3, #1
34000f1a:	bf14      	ite	ne
34000f1c:	461a      	movne	r2, r3
34000f1e:	2201      	moveq	r2, #1
34000f20:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
34000f24:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
34000f28:	3a01      	subs	r2, #1
34000f2a:	d16a      	bne.n	34001002 <evision_api_awb_init_profiles+0x30e>
34000f2c:	2301      	movs	r3, #1
34000f2e:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34000f32:	7023      	strb	r3, [r4, #0]
34000f34:	e746      	b.n	34000dc4 <evision_api_awb_init_profiles+0xd0>
34000f36:	eb02 0987 	add.w	r9, r2, r7, lsl #2
34000f3a:	42b8      	cmp	r0, r7
34000f3c:	edd9 7a00 	vldr	s15, [r9]
34000f40:	ea4f 0887 	mov.w	r8, r7, lsl #2
34000f44:	f107 0a01 	add.w	sl, r7, #1
34000f48:	d91e      	bls.n	34000f88 <evision_api_awb_init_profiles+0x294>
34000f4a:	f108 0804 	add.w	r8, r8, #4
34000f4e:	4490      	add	r8, r2
34000f50:	ed98 7a00 	vldr	s14, [r8]
34000f54:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000f5c:	d814      	bhi.n	34000f88 <evision_api_awb_init_profiles+0x294>
34000f5e:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000f62:	4847      	ldr	r0, [pc, #284]	@ (34001080 <evision_api_awb_init_profiles+0x38c>)
34000f64:	4798      	blx	r3
34000f66:	ed98 7a00 	vldr	s14, [r8]
34000f6a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f6e:	ed8d 7b04 	vstr	d7, [sp, #16]
34000f72:	f8cd a008 	str.w	sl, [sp, #8]
34000f76:	ed99 7a00 	vldr	s14, [r9]
34000f7a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000f7e:	463b      	mov	r3, r7
34000f80:	ed8d 7b00 	vstr	d7, [sp]
34000f84:	4a3f      	ldr	r2, [pc, #252]	@ (34001084 <evision_api_awb_init_profiles+0x390>)
34000f86:	e783      	b.n	34000e90 <evision_api_awb_init_profiles+0x19c>
34000f88:	fb0c f807 	mul.w	r8, ip, r7
34000f8c:	eb05 0a08 	add.w	sl, r5, r8
34000f90:	ed9a 7a00 	vldr	s14, [sl]
34000f94:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000f98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000f9c:	f108 0844 	add.w	r8, r8, #68	@ 0x44
34000fa0:	44a8      	add	r8, r5
34000fa2:	da08      	bge.n	34000fb6 <evision_api_awb_init_profiles+0x2c2>
34000fa4:	ed98 7a00 	vldr	s14, [r8]
34000fa8:	eeb4 7ae7 	vcmpe.f32	s14, s15
34000fac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000fb0:	f103 0301 	add.w	r3, r3, #1
34000fb4:	d882      	bhi.n	34000ebc <evision_api_awb_init_profiles+0x1c8>
34000fb6:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000fba:	4833      	ldr	r0, [pc, #204]	@ (34001088 <evision_api_awb_init_profiles+0x394>)
34000fbc:	4798      	blx	r3
34000fbe:	ed98 7a00 	vldr	s14, [r8]
34000fc2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fc6:	ed8d 7b04 	vstr	d7, [sp, #16]
34000fca:	ed9a 7a00 	vldr	s14, [sl]
34000fce:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fd2:	ed8d 7b02 	vstr	d7, [sp, #8]
34000fd6:	ed99 7a00 	vldr	s14, [r9]
34000fda:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000fde:	463b      	mov	r3, r7
34000fe0:	ed8d 7b00 	vstr	d7, [sp]
34000fe4:	f44f 7180 	mov.w	r1, #256	@ 0x100
34000fe8:	4a28      	ldr	r2, [pc, #160]	@ (3400108c <evision_api_awb_init_profiles+0x398>)
34000fea:	a806      	add	r0, sp, #24
34000fec:	f017 fcd6 	bl	3401899c <sniprintf>
34000ff0:	e753      	b.n	34000e9a <evision_api_awb_init_profiles+0x1a6>
34000ff2:	eb02 0783 	add.w	r7, r2, r3, lsl #2
34000ff6:	683f      	ldr	r7, [r7, #0]
34000ff8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
34000ffc:	f8c3 7110 	str.w	r7, [r3, #272]	@ 0x110
34001000:	e766      	b.n	34000ed0 <evision_api_awb_init_profiles+0x1dc>
34001002:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
34001006:	ed91 6a00 	vldr	s12, [r1]
3400100a:	ed93 7a00 	vldr	s14, [r3]
3400100e:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34001012:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001016:	ee36 6b4a 	vsub.f64	d6, d6, d10
3400101a:	ee37 7b4a 	vsub.f64	d7, d7, d10
3400101e:	eeb4 6bc7 	vcmpe.f64	d6, d7
34001022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001026:	bf48      	it	mi
34001028:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
3400102c:	3144      	adds	r1, #68	@ 0x44
3400102e:	e77b      	b.n	34000f28 <evision_api_awb_init_profiles+0x234>
34001030:	f04f 30ff 	mov.w	r0, #4294967295
34001034:	b047      	add	sp, #284	@ 0x11c
34001036:	ecbd 8b06 	vpop	{d8-d10}
3400103a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400103e:	bf00      	nop
34001040:	00000000 	.word	0x00000000
34001044:	40b38800 	.word	0x40b38800
34001048:	9999999a 	.word	0x9999999a
3400104c:	3fb99999 	.word	0x3fb99999
34001050:	00000000 	.word	0x00000000
34001054:	406ea000 	.word	0x406ea000
34001058:	3ff00000 	.word	0x3ff00000
3400105c:	42480000 	.word	0x42480000
34001060:	432f0000 	.word	0x432f0000
34001064:	3401d9fe 	.word	0x3401d9fe
34001068:	3401da42 	.word	0x3401da42
3400106c:	3401dac9 	.word	0x3401dac9
34001070:	3401db27 	.word	0x3401db27
34001074:	3401dbaf 	.word	0x3401dbaf
34001078:	3401dc0c 	.word	0x3401dc0c
3400107c:	3401dc70 	.word	0x3401dc70
34001080:	3401dcc8 	.word	0x3401dcc8
34001084:	3401dd37 	.word	0x3401dd37
34001088:	3401dda1 	.word	0x3401dda1
3400108c:	3401ddf8 	.word	0x3401ddf8
34001090:	bff00000 	.word	0xbff00000
34001094:	40080000 	.word	0x40080000
34001098:	40240000 	.word	0x40240000

3400109c <evision_api_awb_run_average>:
3400109c:	b530      	push	{r4, r5, lr}
3400109e:	4605      	mov	r5, r0
340010a0:	4614      	mov	r4, r2
340010a2:	b08d      	sub	sp, #52	@ 0x34
340010a4:	b952      	cbnz	r2, 340010bc <evision_api_awb_run_average+0x20>
340010a6:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
340010aa:	481d      	ldr	r0, [pc, #116]	@ (34001120 <evision_api_awb_run_average+0x84>)
340010ac:	4798      	blx	r3
340010ae:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
340010b2:	481c      	ldr	r0, [pc, #112]	@ (34001124 <evision_api_awb_run_average+0x88>)
340010b4:	4798      	blx	r3
340010b6:	4620      	mov	r0, r4
340010b8:	b00d      	add	sp, #52	@ 0x34
340010ba:	bd30      	pop	{r4, r5, pc}
340010bc:	ed93 2b04 	vldr	d2, [r3, #16]
340010c0:	ed93 1b02 	vldr	d1, [r3, #8]
340010c4:	ed93 0b00 	vldr	d0, [r3]
340010c8:	aa0a      	add	r2, sp, #40	@ 0x28
340010ca:	a908      	add	r1, sp, #32
340010cc:	a806      	add	r0, sp, #24
340010ce:	f000 f82f 	bl	34001130 <LOXtOTiCQC>
340010d2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
340010d6:	e9cd 2302 	strd	r2, r3, [sp, #8]
340010da:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
340010de:	e9cd 2304 	strd	r2, r3, [sp, #16]
340010e2:	2301      	movs	r3, #1
340010e4:	4298      	cmp	r0, r3
340010e6:	4604      	mov	r4, r0
340010e8:	e9cd 3300 	strd	r3, r3, [sp]
340010ec:	d1df      	bne.n	340010ae <evision_api_awb_run_average+0x12>
340010ee:	4669      	mov	r1, sp
340010f0:	4628      	mov	r0, r5
340010f2:	f7ff fb4d 	bl	34000790 <vsvAKZpqpB>
340010f6:	2801      	cmp	r0, #1
340010f8:	4604      	mov	r4, r0
340010fa:	d003      	beq.n	34001104 <evision_api_awb_run_average+0x68>
340010fc:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
34001100:	4809      	ldr	r0, [pc, #36]	@ (34001128 <evision_api_awb_run_average+0x8c>)
34001102:	e7d7      	b.n	340010b4 <evision_api_awb_run_average+0x18>
34001104:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
34001108:	2b01      	cmp	r3, #1
3400110a:	d1d4      	bne.n	340010b6 <evision_api_awb_run_average+0x1a>
3400110c:	4628      	mov	r0, r5
3400110e:	f7ff fd23 	bl	34000b58 <JxZhqVLLqu>
34001112:	2801      	cmp	r0, #1
34001114:	4604      	mov	r4, r0
34001116:	d0ce      	beq.n	340010b6 <evision_api_awb_run_average+0x1a>
34001118:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3400111c:	4803      	ldr	r0, [pc, #12]	@ (3400112c <evision_api_awb_run_average+0x90>)
3400111e:	e7c9      	b.n	340010b4 <evision_api_awb_run_average+0x18>
34001120:	3401de7e 	.word	0x3401de7e
34001124:	3401dedf 	.word	0x3401dedf
34001128:	3401df08 	.word	0x3401df08
3400112c:	3401df3c 	.word	0x3401df3c

34001130 <LOXtOTiCQC>:
34001130:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34001134:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001138:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3400113a:	d409      	bmi.n	34001150 <LOXtOTiCQC+0x20>
3400113c:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
34001140:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001144:	d404      	bmi.n	34001150 <LOXtOTiCQC+0x20>
34001146:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
3400114a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400114e:	d50d      	bpl.n	3400116c <LOXtOTiCQC+0x3c>
34001150:	ed8d 2b02 	vstr	d2, [sp, #8]
34001154:	ed8d 1b00 	vstr	d1, [sp]
34001158:	ec53 2b10 	vmov	r2, r3, d0
3400115c:	4844      	ldr	r0, [pc, #272]	@ (34001270 <LOXtOTiCQC+0x140>)
3400115e:	f017 fbad 	bl	340188bc <iprintf>
34001162:	f04f 30ff 	mov.w	r0, #4294967295
34001166:	b005      	add	sp, #20
34001168:	f85d fb04 	ldr.w	pc, [sp], #4
3400116c:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 34001238 <LOXtOTiCQC+0x108>
34001170:	eeb4 0bc7 	vcmpe.f64	d0, d7
34001174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001178:	dc09      	bgt.n	3400118e <LOXtOTiCQC+0x5e>
3400117a:	eeb4 1bc7 	vcmpe.f64	d1, d7
3400117e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001182:	dc04      	bgt.n	3400118e <LOXtOTiCQC+0x5e>
34001184:	eeb4 2bc7 	vcmpe.f64	d2, d7
34001188:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400118c:	dd07      	ble.n	3400119e <LOXtOTiCQC+0x6e>
3400118e:	ed8d 2b02 	vstr	d2, [sp, #8]
34001192:	ed8d 1b00 	vstr	d1, [sp]
34001196:	ec53 2b10 	vmov	r2, r3, d0
3400119a:	4836      	ldr	r0, [pc, #216]	@ (34001274 <LOXtOTiCQC+0x144>)
3400119c:	e7df      	b.n	3400115e <LOXtOTiCQC+0x2e>
3400119e:	b128      	cbz	r0, 340011ac <LOXtOTiCQC+0x7c>
340011a0:	b189      	cbz	r1, 340011c6 <LOXtOTiCQC+0x96>
340011a2:	b9b2      	cbnz	r2, 340011d2 <LOXtOTiCQC+0xa2>
340011a4:	4934      	ldr	r1, [pc, #208]	@ (34001278 <LOXtOTiCQC+0x148>)
340011a6:	4b35      	ldr	r3, [pc, #212]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011a8:	4608      	mov	r0, r1
340011aa:	e007      	b.n	340011bc <LOXtOTiCQC+0x8c>
340011ac:	b171      	cbz	r1, 340011cc <LOXtOTiCQC+0x9c>
340011ae:	4933      	ldr	r1, [pc, #204]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011b0:	4831      	ldr	r0, [pc, #196]	@ (34001278 <LOXtOTiCQC+0x148>)
340011b2:	2a00      	cmp	r2, #0
340011b4:	4a30      	ldr	r2, [pc, #192]	@ (34001278 <LOXtOTiCQC+0x148>)
340011b6:	4b31      	ldr	r3, [pc, #196]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011b8:	bf18      	it	ne
340011ba:	4613      	movne	r3, r2
340011bc:	4602      	mov	r2, r0
340011be:	4830      	ldr	r0, [pc, #192]	@ (34001280 <LOXtOTiCQC+0x150>)
340011c0:	f017 fb7c 	bl	340188bc <iprintf>
340011c4:	e7cd      	b.n	34001162 <LOXtOTiCQC+0x32>
340011c6:	492c      	ldr	r1, [pc, #176]	@ (34001278 <LOXtOTiCQC+0x148>)
340011c8:	482c      	ldr	r0, [pc, #176]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011ca:	e7f2      	b.n	340011b2 <LOXtOTiCQC+0x82>
340011cc:	492b      	ldr	r1, [pc, #172]	@ (3400127c <LOXtOTiCQC+0x14c>)
340011ce:	4608      	mov	r0, r1
340011d0:	e7ef      	b.n	340011b2 <LOXtOTiCQC+0x82>
340011d2:	ed9f 7b1b 	vldr	d7, [pc, #108]	@ 34001240 <LOXtOTiCQC+0x110>
340011d6:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 34001248 <LOXtOTiCQC+0x118>
340011da:	ee21 7b07 	vmul.f64	d7, d1, d7
340011de:	eeb3 5b00 	vmov.f64	d5, #48	@ 0x41800000  16.0
340011e2:	eea0 7b06 	vfma.f64	d7, d0, d6
340011e6:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 34001250 <LOXtOTiCQC+0x120>
340011ea:	eea2 7b05 	vfma.f64	d7, d2, d5
340011ee:	eea7 5b06 	vfma.f64	d5, d7, d6
340011f2:	ed9f 7b19 	vldr	d7, [pc, #100]	@ 34001258 <LOXtOTiCQC+0x128>
340011f6:	ed80 5b00 	vstr	d5, [r0]
340011fa:	ee27 7b41 	vnmul.f64	d7, d7, d1
340011fe:	eebb 5b0a 	vmov.f64	d5, #186	@ 0xc1d00000 -26.0
34001202:	eea0 7b05 	vfma.f64	d7, d0, d5
34001206:	ed9f 5b16 	vldr	d5, [pc, #88]	@ 34001260 <LOXtOTiCQC+0x130>
3400120a:	eea2 7b05 	vfma.f64	d7, d2, d5
3400120e:	ee27 7b06 	vmul.f64	d7, d7, d6
34001212:	ed81 7b00 	vstr	d7, [r1]
34001216:	ed9f 7b14 	vldr	d7, [pc, #80]	@ 34001268 <LOXtOTiCQC+0x138>
3400121a:	ee27 1b41 	vnmul.f64	d1, d7, d1
3400121e:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34001222:	eea0 1b05 	vfma.f64	d1, d0, d5
34001226:	eea2 1b47 	vfms.f64	d1, d2, d7
3400122a:	ee21 1b06 	vmul.f64	d1, d1, d6
3400122e:	2001      	movs	r0, #1
34001230:	ed82 1b00 	vstr	d1, [r2]
34001234:	e797      	b.n	34001166 <LOXtOTiCQC+0x36>
34001236:	bf00      	nop
34001238:	00000000 	.word	0x00000000
3400123c:	406fe000 	.word	0x406fe000
34001240:	00000000 	.word	0x00000000
34001244:	4063a000 	.word	0x4063a000
34001248:	00000000 	.word	0x00000000
3400124c:	40478000 	.word	0x40478000
34001250:	00000000 	.word	0x00000000
34001254:	3f700000 	.word	0x3f700000
34001258:	00000000 	.word	0x00000000
3400125c:	40558000 	.word	0x40558000
34001260:	00000000 	.word	0x00000000
34001264:	405c0000 	.word	0x405c0000
34001268:	00000000 	.word	0x00000000
3400126c:	40598000 	.word	0x40598000
34001270:	3401df79 	.word	0x3401df79
34001274:	3401dfb7 	.word	0x3401dfb7
34001278:	3401df73 	.word	0x3401df73
3400127c:	3401df71 	.word	0x3401df71
34001280:	3401dff7 	.word	0x3401dff7
34001284:	00000000 	.word	0x00000000

34001288 <evision_api_st_ae_new>:
34001288:	b510      	push	{r4, lr}
3400128a:	4604      	mov	r4, r0
3400128c:	b090      	sub	sp, #64	@ 0x40
3400128e:	b160      	cbz	r0, 340012aa <evision_api_st_ae_new+0x22>
34001290:	2300      	movs	r3, #0
34001292:	4c07      	ldr	r4, [pc, #28]	@ (340012b0 <evision_api_st_ae_new+0x28>)
34001294:	2140      	movs	r1, #64	@ 0x40
34001296:	7023      	strb	r3, [r4, #0]
34001298:	65a0      	str	r0, [r4, #88]	@ 0x58
3400129a:	4b06      	ldr	r3, [pc, #24]	@ (340012b4 <evision_api_st_ae_new+0x2c>)
3400129c:	4668      	mov	r0, sp
3400129e:	4a06      	ldr	r2, [pc, #24]	@ (340012b8 <evision_api_st_ae_new+0x30>)
340012a0:	f017 fb7c 	bl	3401899c <sniprintf>
340012a4:	4668      	mov	r0, sp
340012a6:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340012a8:	4798      	blx	r3
340012aa:	4620      	mov	r0, r4
340012ac:	b010      	add	sp, #64	@ 0x40
340012ae:	bd10      	pop	{r4, pc}
340012b0:	3403f398 	.word	0x3403f398
340012b4:	3403ed46 	.word	0x3403ed46
340012b8:	3401e041 	.word	0x3401e041

340012bc <evision_api_st_ae_delete>:
340012bc:	2800      	cmp	r0, #0
340012be:	bf14      	ite	ne
340012c0:	2001      	movne	r0, #1
340012c2:	f04f 30ff 	moveq.w	r0, #4294967295
340012c6:	4770      	bx	lr

340012c8 <AagifFaCgc>:
340012c8:	2238      	movs	r2, #56	@ 0x38
340012ca:	230a      	movs	r3, #10
340012cc:	e9c0 2304 	strd	r2, r3, [r0, #16]
340012d0:	2364      	movs	r3, #100	@ 0x64
340012d2:	222d      	movs	r2, #45	@ 0x2d
340012d4:	2178      	movs	r1, #120	@ 0x78
340012d6:	e9c0 3206 	strd	r3, r2, [r0, #24]
340012da:	f240 52dc 	movw	r2, #1500	@ 0x5dc
340012de:	b530      	push	{r4, r5, lr}
340012e0:	e9c0 1208 	strd	r1, r2, [r0, #32]
340012e4:	f241 7470 	movw	r4, #6000	@ 0x1770
340012e8:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
340012ec:	e9c0 420a 	strd	r4, r2, [r0, #40]	@ 0x28
340012f0:	a50b      	add	r5, pc, #44	@ (adr r5, 34001320 <AagifFaCgc+0x58>)
340012f2:	e9d5 4500 	ldrd	r4, r5, [r5]
340012f6:	2205      	movs	r2, #5
340012f8:	f04f 0c00 	mov.w	ip, #0
340012fc:	6502      	str	r2, [r0, #80]	@ 0x50
340012fe:	f248 02e8 	movw	r2, #33000	@ 0x80e8
34001302:	e9c0 c210 	strd	ip, r2, [r0, #64]	@ 0x40
34001306:	2201      	movs	r2, #1
34001308:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
3400130c:	a506      	add	r5, pc, #24	@ (adr r5, 34001328 <AagifFaCgc+0x60>)
3400130e:	e9d5 4500 	ldrd	r4, r5, [r5]
34001312:	e9c0 2312 	strd	r2, r3, [r0, #72]	@ 0x48
34001316:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
3400131a:	bd30      	pop	{r4, r5, pc}
3400131c:	f3af 8000 	nop.w
34001320:	40000000 	.word	0x40000000
34001324:	3f947ae1 	.word	0x3f947ae1
34001328:	e0000000 	.word	0xe0000000
3400132c:	3f70624d 	.word	0x3f70624d

34001330 <evision_api_st_ae_init>:
34001330:	b510      	push	{r4, lr}
34001332:	4604      	mov	r4, r0
34001334:	b120      	cbz	r0, 34001340 <evision_api_st_ae_init+0x10>
34001336:	f7ff ffc7 	bl	340012c8 <AagifFaCgc>
3400133a:	2001      	movs	r0, #1
3400133c:	7020      	strb	r0, [r4, #0]
3400133e:	bd10      	pop	{r4, pc}
34001340:	f04f 30ff 	mov.w	r0, #4294967295
34001344:	e7fb      	b.n	3400133e <evision_api_st_ae_init+0xe>

34001346 <evision_api_st_ae_process>:
34001346:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400134a:	460e      	mov	r6, r1
3400134c:	4604      	mov	r4, r0
3400134e:	2800      	cmp	r0, #0
34001350:	f000 80e1 	beq.w	34001516 <evision_api_st_ae_process+0x1d0>
34001354:	7801      	ldrb	r1, [r0, #0]
34001356:	2901      	cmp	r1, #1
34001358:	d10b      	bne.n	34001372 <evision_api_st_ae_process+0x2c>
3400135a:	2102      	movs	r1, #2
3400135c:	7001      	strb	r1, [r0, #0]
3400135e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
34001360:	e9c4 2601 	strd	r2, r6, [r4, #4]
34001364:	42b5      	cmp	r5, r6
34001366:	d208      	bcs.n	3400137a <evision_api_st_ae_process+0x34>
34001368:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400136a:	4291      	cmp	r1, r2
3400136c:	d905      	bls.n	3400137a <evision_api_st_ae_process+0x34>
3400136e:	60a5      	str	r5, [r4, #8]
34001370:	e04c      	b.n	3400140c <evision_api_st_ae_process+0xc6>
34001372:	2902      	cmp	r1, #2
34001374:	d0f3      	beq.n	3400135e <evision_api_st_ae_process+0x18>
34001376:	2000      	movs	r0, #0
34001378:	e049      	b.n	3400140e <evision_api_st_ae_process+0xc8>
3400137a:	f8d4 c010 	ldr.w	ip, [r4, #16]
3400137e:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34001382:	ee07 ca90 	vmov	s15, ip
34001386:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3400138a:	ee07 3a90 	vmov	s15, r3
3400138e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34001392:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34001396:	ee37 7b05 	vadd.f64	d7, d7, d5
3400139a:	ee86 0b07 	vdiv.f64	d0, d6, d7
3400139e:	6d21      	ldr	r1, [r4, #80]	@ 0x50
340013a0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
340013a4:	428b      	cmp	r3, r1
340013a6:	d24b      	bcs.n	34001440 <evision_api_st_ae_process+0xfa>
340013a8:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
340013ac:	eeb4 0ae7 	vcmpe.f32	s0, s15
340013b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013b4:	d444      	bmi.n	34001440 <evision_api_st_ae_process+0xfa>
340013b6:	6c61      	ldr	r1, [r4, #68]	@ 0x44
340013b8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
340013bc:	428a      	cmp	r2, r1
340013be:	d220      	bcs.n	34001402 <evision_api_st_ae_process+0xbc>
340013c0:	2a01      	cmp	r2, #1
340013c2:	4613      	mov	r3, r2
340013c4:	bf38      	it	cc
340013c6:	2301      	movcc	r3, #1
340013c8:	ee07 3a90 	vmov	s15, r3
340013cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340013d0:	ee67 7a80 	vmul.f32	s15, s15, s0
340013d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340013d8:	ee17 3a90 	vmov	r3, s15
340013dc:	428b      	cmp	r3, r1
340013de:	bfc1      	itttt	gt
340013e0:	ee07 1a90 	vmovgt	s15, r1
340013e4:	eeb8 6ae7 	vcvtgt.f32.s32	s12, s15
340013e8:	ee07 2a90 	vmovgt	s15, r2
340013ec:	eef8 6a67 	vcvtgt.f32.u32	s13, s15
340013f0:	bfc3      	ittte	gt
340013f2:	eec6 7a26 	vdivgt.f32	s15, s12, s13
340013f6:	460b      	movgt	r3, r1
340013f8:	ee80 0a27 	vdivgt.f32	s0, s0, s15
340013fc:	eeb0 0a47 	vmovle.f32	s0, s14
34001400:	6063      	str	r3, [r4, #4]
34001402:	eeb4 0ac7 	vcmpe.f32	s0, s14
34001406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400140a:	dc02      	bgt.n	34001412 <evision_api_st_ae_process+0xcc>
3400140c:	2001      	movs	r0, #1
3400140e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34001412:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34001416:	f019 fcd3 	bl	3401adc0 <log10>
3400141a:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
3400141e:	ee20 0b07 	vmul.f64	d0, d0, d7
34001422:	ed9f 7b3f 	vldr	d7, [pc, #252]	@ 34001520 <evision_api_st_ae_process+0x1da>
34001426:	ee20 0b07 	vmul.f64	d0, d0, d7
3400142a:	eebd 0bc0 	vcvt.s32.f64	s0, d0
3400142e:	ee10 3a10 	vmov	r3, s0
34001432:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
34001434:	4433      	add	r3, r6
34001436:	4293      	cmp	r3, r2
34001438:	bfd4      	ite	le
3400143a:	60a3      	strle	r3, [r4, #8]
3400143c:	60a2      	strgt	r2, [r4, #8]
3400143e:	e7e5      	b.n	3400140c <evision_api_st_ae_process+0xc6>
34001440:	ebac 0703 	sub.w	r7, ip, r3
34001444:	69e1      	ldr	r1, [r4, #28]
34001446:	ea87 70e7 	eor.w	r0, r7, r7, asr #31
3400144a:	eba0 70e7 	sub.w	r0, r0, r7, asr #31
3400144e:	4288      	cmp	r0, r1
34001450:	d847      	bhi.n	340014e2 <evision_api_st_ae_process+0x19c>
34001452:	6a60      	ldr	r0, [r4, #36]	@ 0x24
34001454:	f8d4 e014 	ldr.w	lr, [r4, #20]
34001458:	69a1      	ldr	r1, [r4, #24]
3400145a:	eb0e 080c 	add.w	r8, lr, ip
3400145e:	4598      	cmp	r8, r3
34001460:	fb07 f101 	mul.w	r1, r7, r1
34001464:	d243      	bcs.n	340014ee <evision_api_st_ae_process+0x1a8>
34001466:	ee07 0a90 	vmov	s15, r0
3400146a:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 34001528 <evision_api_st_ae_process+0x1e2>
3400146e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34001472:	ee67 7a87 	vmul.f32	s15, s15, s14
34001476:	ee07 1a10 	vmov	s14, r1
3400147a:	eef1 6a67 	vneg.f32	s13, s15
3400147e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34001482:	eeb4 7ae6 	vcmpe.f32	s14, s13
34001486:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400148a:	d504      	bpl.n	34001496 <evision_api_st_ae_process+0x150>
3400148c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001490:	ee17 3a90 	vmov	r3, s15
34001494:	4259      	negs	r1, r3
34001496:	2900      	cmp	r1, #0
34001498:	d0b8      	beq.n	3400140c <evision_api_st_ae_process+0xc6>
3400149a:	42b5      	cmp	r5, r6
3400149c:	d132      	bne.n	34001504 <evision_api_st_ae_process+0x1be>
3400149e:	6c60      	ldr	r0, [r4, #68]	@ 0x44
340014a0:	4290      	cmp	r0, r2
340014a2:	d801      	bhi.n	340014a8 <evision_api_st_ae_process+0x162>
340014a4:	2900      	cmp	r1, #0
340014a6:	da2d      	bge.n	34001504 <evision_api_st_ae_process+0x1be>
340014a8:	fb02 7707 	mla	r7, r2, r7, r7
340014ac:	ee07 2a90 	vmov	s15, r2
340014b0:	ee06 7a90 	vmov	s13, r7
340014b4:	2900      	cmp	r1, #0
340014b6:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340014ba:	eeb8 6be6 	vcvt.f64.s32	d6, s13
340014be:	da1e      	bge.n	340014fe <evision_api_st_ae_process+0x1b8>
340014c0:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
340014c4:	eea5 7b06 	vfma.f64	d7, d5, d6
340014c8:	eebd 7bc7 	vcvt.s32.f64	s14, d7
340014cc:	ee17 2a10 	vmov	r2, s14
340014d0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
340014d2:	429a      	cmp	r2, r3
340014d4:	bfb8      	it	lt
340014d6:	461a      	movlt	r2, r3
340014d8:	4282      	cmp	r2, r0
340014da:	bfd4      	ite	le
340014dc:	6062      	strle	r2, [r4, #4]
340014de:	6060      	strgt	r0, [r4, #4]
340014e0:	e794      	b.n	3400140c <evision_api_st_ae_process+0xc6>
340014e2:	6a21      	ldr	r1, [r4, #32]
340014e4:	4288      	cmp	r0, r1
340014e6:	bf2c      	ite	cs
340014e8:	6ae0      	ldrcs	r0, [r4, #44]	@ 0x2c
340014ea:	6aa0      	ldrcc	r0, [r4, #40]	@ 0x28
340014ec:	e7b2      	b.n	34001454 <evision_api_st_ae_process+0x10e>
340014ee:	ebac 0c0e 	sub.w	ip, ip, lr
340014f2:	459c      	cmp	ip, r3
340014f4:	dd8a      	ble.n	3400140c <evision_api_st_ae_process+0xc6>
340014f6:	4281      	cmp	r1, r0
340014f8:	bfa8      	it	ge
340014fa:	4601      	movge	r1, r0
340014fc:	e7cb      	b.n	34001496 <evision_api_st_ae_process+0x150>
340014fe:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
34001502:	e7df      	b.n	340014c4 <evision_api_st_ae_process+0x17e>
34001504:	440e      	add	r6, r1
34001506:	42b5      	cmp	r5, r6
34001508:	f73f af31 	bgt.w	3400136e <evision_api_st_ae_process+0x28>
3400150c:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
3400150e:	42b5      	cmp	r5, r6
34001510:	bfa8      	it	ge
34001512:	4635      	movge	r5, r6
34001514:	e72b      	b.n	3400136e <evision_api_st_ae_process+0x28>
34001516:	f04f 30ff 	mov.w	r0, #4294967295
3400151a:	e778      	b.n	3400140e <evision_api_st_ae_process+0xc8>
3400151c:	f3af 8000 	nop.w
34001520:	00000000 	.word	0x00000000
34001524:	408f4000 	.word	0x408f4000
34001528:	3f59999a 	.word	0x3f59999a

3400152c <strlen>:
3400152c:	4603      	mov	r3, r0
3400152e:	f813 2b01 	ldrb.w	r2, [r3], #1
34001532:	2a00      	cmp	r2, #0
34001534:	d1fb      	bne.n	3400152e <strlen+0x2>
34001536:	1a18      	subs	r0, r3, r0
34001538:	3801      	subs	r0, #1
3400153a:	4770      	bx	lr

3400153c <__aeabi_ldivmod>:
3400153c:	b97b      	cbnz	r3, 3400155e <__aeabi_ldivmod+0x22>
3400153e:	b972      	cbnz	r2, 3400155e <__aeabi_ldivmod+0x22>
34001540:	2900      	cmp	r1, #0
34001542:	bfbe      	ittt	lt
34001544:	2000      	movlt	r0, #0
34001546:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
3400154a:	e006      	blt.n	3400155a <__aeabi_ldivmod+0x1e>
3400154c:	bf08      	it	eq
3400154e:	2800      	cmpeq	r0, #0
34001550:	bf1c      	itt	ne
34001552:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34001556:	f04f 30ff 	movne.w	r0, #4294967295
3400155a:	f000 b9fb 	b.w	34001954 <__aeabi_idiv0>
3400155e:	f1ad 0c08 	sub.w	ip, sp, #8
34001562:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34001566:	2900      	cmp	r1, #0
34001568:	db09      	blt.n	3400157e <__aeabi_ldivmod+0x42>
3400156a:	2b00      	cmp	r3, #0
3400156c:	db1a      	blt.n	340015a4 <__aeabi_ldivmod+0x68>
3400156e:	f000 f84d 	bl	3400160c <__udivmoddi4>
34001572:	f8dd e004 	ldr.w	lr, [sp, #4]
34001576:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
3400157a:	b004      	add	sp, #16
3400157c:	4770      	bx	lr
3400157e:	4240      	negs	r0, r0
34001580:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001584:	2b00      	cmp	r3, #0
34001586:	db1b      	blt.n	340015c0 <__aeabi_ldivmod+0x84>
34001588:	f000 f840 	bl	3400160c <__udivmoddi4>
3400158c:	f8dd e004 	ldr.w	lr, [sp, #4]
34001590:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001594:	b004      	add	sp, #16
34001596:	4240      	negs	r0, r0
34001598:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
3400159c:	4252      	negs	r2, r2
3400159e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015a2:	4770      	bx	lr
340015a4:	4252      	negs	r2, r2
340015a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015aa:	f000 f82f 	bl	3400160c <__udivmoddi4>
340015ae:	f8dd e004 	ldr.w	lr, [sp, #4]
340015b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340015b6:	b004      	add	sp, #16
340015b8:	4240      	negs	r0, r0
340015ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
340015be:	4770      	bx	lr
340015c0:	4252      	negs	r2, r2
340015c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015c6:	f000 f821 	bl	3400160c <__udivmoddi4>
340015ca:	f8dd e004 	ldr.w	lr, [sp, #4]
340015ce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340015d2:	b004      	add	sp, #16
340015d4:	4252      	negs	r2, r2
340015d6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
340015da:	4770      	bx	lr

340015dc <__aeabi_uldivmod>:
340015dc:	b953      	cbnz	r3, 340015f4 <__aeabi_uldivmod+0x18>
340015de:	b94a      	cbnz	r2, 340015f4 <__aeabi_uldivmod+0x18>
340015e0:	2900      	cmp	r1, #0
340015e2:	bf08      	it	eq
340015e4:	2800      	cmpeq	r0, #0
340015e6:	bf1c      	itt	ne
340015e8:	f04f 31ff 	movne.w	r1, #4294967295
340015ec:	f04f 30ff 	movne.w	r0, #4294967295
340015f0:	f000 b9b0 	b.w	34001954 <__aeabi_idiv0>
340015f4:	f1ad 0c08 	sub.w	ip, sp, #8
340015f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
340015fc:	f000 f806 	bl	3400160c <__udivmoddi4>
34001600:	f8dd e004 	ldr.w	lr, [sp, #4]
34001604:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001608:	b004      	add	sp, #16
3400160a:	4770      	bx	lr

3400160c <__udivmoddi4>:
3400160c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001610:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34001612:	4688      	mov	r8, r1
34001614:	4604      	mov	r4, r0
34001616:	468e      	mov	lr, r1
34001618:	2b00      	cmp	r3, #0
3400161a:	d14a      	bne.n	340016b2 <__udivmoddi4+0xa6>
3400161c:	428a      	cmp	r2, r1
3400161e:	4617      	mov	r7, r2
34001620:	d95f      	bls.n	340016e2 <__udivmoddi4+0xd6>
34001622:	fab2 f682 	clz	r6, r2
34001626:	b14e      	cbz	r6, 3400163c <__udivmoddi4+0x30>
34001628:	f1c6 0320 	rsb	r3, r6, #32
3400162c:	fa01 fe06 	lsl.w	lr, r1, r6
34001630:	40b7      	lsls	r7, r6
34001632:	40b4      	lsls	r4, r6
34001634:	fa20 f303 	lsr.w	r3, r0, r3
34001638:	ea43 0e0e 	orr.w	lr, r3, lr
3400163c:	ea4f 4817 	mov.w	r8, r7, lsr #16
34001640:	fa1f fc87 	uxth.w	ip, r7
34001644:	0c23      	lsrs	r3, r4, #16
34001646:	fbbe f1f8 	udiv	r1, lr, r8
3400164a:	fb08 ee11 	mls	lr, r8, r1, lr
3400164e:	fb01 f20c 	mul.w	r2, r1, ip
34001652:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34001656:	429a      	cmp	r2, r3
34001658:	d907      	bls.n	3400166a <__udivmoddi4+0x5e>
3400165a:	18fb      	adds	r3, r7, r3
3400165c:	f101 30ff 	add.w	r0, r1, #4294967295
34001660:	d202      	bcs.n	34001668 <__udivmoddi4+0x5c>
34001662:	429a      	cmp	r2, r3
34001664:	f200 8154 	bhi.w	34001910 <__udivmoddi4+0x304>
34001668:	4601      	mov	r1, r0
3400166a:	1a9b      	subs	r3, r3, r2
3400166c:	b2a2      	uxth	r2, r4
3400166e:	fbb3 f0f8 	udiv	r0, r3, r8
34001672:	fb08 3310 	mls	r3, r8, r0, r3
34001676:	fb00 fc0c 	mul.w	ip, r0, ip
3400167a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3400167e:	4594      	cmp	ip, r2
34001680:	d90b      	bls.n	3400169a <__udivmoddi4+0x8e>
34001682:	18ba      	adds	r2, r7, r2
34001684:	f100 33ff 	add.w	r3, r0, #4294967295
34001688:	bf2c      	ite	cs
3400168a:	2401      	movcs	r4, #1
3400168c:	2400      	movcc	r4, #0
3400168e:	4594      	cmp	ip, r2
34001690:	d902      	bls.n	34001698 <__udivmoddi4+0x8c>
34001692:	2c00      	cmp	r4, #0
34001694:	f000 813f 	beq.w	34001916 <__udivmoddi4+0x30a>
34001698:	4618      	mov	r0, r3
3400169a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
3400169e:	eba2 020c 	sub.w	r2, r2, ip
340016a2:	2100      	movs	r1, #0
340016a4:	b11d      	cbz	r5, 340016ae <__udivmoddi4+0xa2>
340016a6:	40f2      	lsrs	r2, r6
340016a8:	2300      	movs	r3, #0
340016aa:	e9c5 2300 	strd	r2, r3, [r5]
340016ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340016b2:	428b      	cmp	r3, r1
340016b4:	d905      	bls.n	340016c2 <__udivmoddi4+0xb6>
340016b6:	b10d      	cbz	r5, 340016bc <__udivmoddi4+0xb0>
340016b8:	e9c5 0100 	strd	r0, r1, [r5]
340016bc:	2100      	movs	r1, #0
340016be:	4608      	mov	r0, r1
340016c0:	e7f5      	b.n	340016ae <__udivmoddi4+0xa2>
340016c2:	fab3 f183 	clz	r1, r3
340016c6:	2900      	cmp	r1, #0
340016c8:	d14e      	bne.n	34001768 <__udivmoddi4+0x15c>
340016ca:	4543      	cmp	r3, r8
340016cc:	f0c0 8112 	bcc.w	340018f4 <__udivmoddi4+0x2e8>
340016d0:	4282      	cmp	r2, r0
340016d2:	f240 810f 	bls.w	340018f4 <__udivmoddi4+0x2e8>
340016d6:	4608      	mov	r0, r1
340016d8:	2d00      	cmp	r5, #0
340016da:	d0e8      	beq.n	340016ae <__udivmoddi4+0xa2>
340016dc:	e9c5 4e00 	strd	r4, lr, [r5]
340016e0:	e7e5      	b.n	340016ae <__udivmoddi4+0xa2>
340016e2:	2a00      	cmp	r2, #0
340016e4:	f000 80ac 	beq.w	34001840 <__udivmoddi4+0x234>
340016e8:	fab2 f682 	clz	r6, r2
340016ec:	2e00      	cmp	r6, #0
340016ee:	f040 80bb 	bne.w	34001868 <__udivmoddi4+0x25c>
340016f2:	1a8b      	subs	r3, r1, r2
340016f4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
340016f8:	b2bc      	uxth	r4, r7
340016fa:	2101      	movs	r1, #1
340016fc:	0c02      	lsrs	r2, r0, #16
340016fe:	b280      	uxth	r0, r0
34001700:	fbb3 fcfe 	udiv	ip, r3, lr
34001704:	fb0e 331c 	mls	r3, lr, ip, r3
34001708:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
3400170c:	fb04 f20c 	mul.w	r2, r4, ip
34001710:	429a      	cmp	r2, r3
34001712:	d90e      	bls.n	34001732 <__udivmoddi4+0x126>
34001714:	18fb      	adds	r3, r7, r3
34001716:	f10c 38ff 	add.w	r8, ip, #4294967295
3400171a:	bf2c      	ite	cs
3400171c:	f04f 0901 	movcs.w	r9, #1
34001720:	f04f 0900 	movcc.w	r9, #0
34001724:	429a      	cmp	r2, r3
34001726:	d903      	bls.n	34001730 <__udivmoddi4+0x124>
34001728:	f1b9 0f00 	cmp.w	r9, #0
3400172c:	f000 80ec 	beq.w	34001908 <__udivmoddi4+0x2fc>
34001730:	46c4      	mov	ip, r8
34001732:	1a9b      	subs	r3, r3, r2
34001734:	fbb3 f8fe 	udiv	r8, r3, lr
34001738:	fb0e 3318 	mls	r3, lr, r8, r3
3400173c:	fb04 f408 	mul.w	r4, r4, r8
34001740:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34001744:	4294      	cmp	r4, r2
34001746:	d90b      	bls.n	34001760 <__udivmoddi4+0x154>
34001748:	18ba      	adds	r2, r7, r2
3400174a:	f108 33ff 	add.w	r3, r8, #4294967295
3400174e:	bf2c      	ite	cs
34001750:	2001      	movcs	r0, #1
34001752:	2000      	movcc	r0, #0
34001754:	4294      	cmp	r4, r2
34001756:	d902      	bls.n	3400175e <__udivmoddi4+0x152>
34001758:	2800      	cmp	r0, #0
3400175a:	f000 80d1 	beq.w	34001900 <__udivmoddi4+0x2f4>
3400175e:	4698      	mov	r8, r3
34001760:	1b12      	subs	r2, r2, r4
34001762:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34001766:	e79d      	b.n	340016a4 <__udivmoddi4+0x98>
34001768:	f1c1 0620 	rsb	r6, r1, #32
3400176c:	408b      	lsls	r3, r1
3400176e:	fa08 f401 	lsl.w	r4, r8, r1
34001772:	fa00 f901 	lsl.w	r9, r0, r1
34001776:	fa22 f706 	lsr.w	r7, r2, r6
3400177a:	fa28 f806 	lsr.w	r8, r8, r6
3400177e:	408a      	lsls	r2, r1
34001780:	431f      	orrs	r7, r3
34001782:	fa20 f306 	lsr.w	r3, r0, r6
34001786:	0c38      	lsrs	r0, r7, #16
34001788:	4323      	orrs	r3, r4
3400178a:	fa1f fc87 	uxth.w	ip, r7
3400178e:	0c1c      	lsrs	r4, r3, #16
34001790:	fbb8 fef0 	udiv	lr, r8, r0
34001794:	fb00 881e 	mls	r8, r0, lr, r8
34001798:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
3400179c:	fb0e f80c 	mul.w	r8, lr, ip
340017a0:	45a0      	cmp	r8, r4
340017a2:	d90e      	bls.n	340017c2 <__udivmoddi4+0x1b6>
340017a4:	193c      	adds	r4, r7, r4
340017a6:	f10e 3aff 	add.w	sl, lr, #4294967295
340017aa:	bf2c      	ite	cs
340017ac:	f04f 0b01 	movcs.w	fp, #1
340017b0:	f04f 0b00 	movcc.w	fp, #0
340017b4:	45a0      	cmp	r8, r4
340017b6:	d903      	bls.n	340017c0 <__udivmoddi4+0x1b4>
340017b8:	f1bb 0f00 	cmp.w	fp, #0
340017bc:	f000 80b8 	beq.w	34001930 <__udivmoddi4+0x324>
340017c0:	46d6      	mov	lr, sl
340017c2:	eba4 0408 	sub.w	r4, r4, r8
340017c6:	fa1f f883 	uxth.w	r8, r3
340017ca:	fbb4 f3f0 	udiv	r3, r4, r0
340017ce:	fb00 4413 	mls	r4, r0, r3, r4
340017d2:	fb03 fc0c 	mul.w	ip, r3, ip
340017d6:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
340017da:	45a4      	cmp	ip, r4
340017dc:	d90e      	bls.n	340017fc <__udivmoddi4+0x1f0>
340017de:	193c      	adds	r4, r7, r4
340017e0:	f103 30ff 	add.w	r0, r3, #4294967295
340017e4:	bf2c      	ite	cs
340017e6:	f04f 0801 	movcs.w	r8, #1
340017ea:	f04f 0800 	movcc.w	r8, #0
340017ee:	45a4      	cmp	ip, r4
340017f0:	d903      	bls.n	340017fa <__udivmoddi4+0x1ee>
340017f2:	f1b8 0f00 	cmp.w	r8, #0
340017f6:	f000 809f 	beq.w	34001938 <__udivmoddi4+0x32c>
340017fa:	4603      	mov	r3, r0
340017fc:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34001800:	eba4 040c 	sub.w	r4, r4, ip
34001804:	fba0 ec02 	umull	lr, ip, r0, r2
34001808:	4564      	cmp	r4, ip
3400180a:	4673      	mov	r3, lr
3400180c:	46e0      	mov	r8, ip
3400180e:	d302      	bcc.n	34001816 <__udivmoddi4+0x20a>
34001810:	d107      	bne.n	34001822 <__udivmoddi4+0x216>
34001812:	45f1      	cmp	r9, lr
34001814:	d205      	bcs.n	34001822 <__udivmoddi4+0x216>
34001816:	ebbe 0302 	subs.w	r3, lr, r2
3400181a:	eb6c 0c07 	sbc.w	ip, ip, r7
3400181e:	3801      	subs	r0, #1
34001820:	46e0      	mov	r8, ip
34001822:	b15d      	cbz	r5, 3400183c <__udivmoddi4+0x230>
34001824:	ebb9 0203 	subs.w	r2, r9, r3
34001828:	eb64 0408 	sbc.w	r4, r4, r8
3400182c:	fa04 f606 	lsl.w	r6, r4, r6
34001830:	fa22 f301 	lsr.w	r3, r2, r1
34001834:	40cc      	lsrs	r4, r1
34001836:	431e      	orrs	r6, r3
34001838:	e9c5 6400 	strd	r6, r4, [r5]
3400183c:	2100      	movs	r1, #0
3400183e:	e736      	b.n	340016ae <__udivmoddi4+0xa2>
34001840:	fbb1 fcf2 	udiv	ip, r1, r2
34001844:	0c01      	lsrs	r1, r0, #16
34001846:	4614      	mov	r4, r2
34001848:	b280      	uxth	r0, r0
3400184a:	4696      	mov	lr, r2
3400184c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001850:	2620      	movs	r6, #32
34001852:	4690      	mov	r8, r2
34001854:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34001858:	4610      	mov	r0, r2
3400185a:	fbb1 f1f2 	udiv	r1, r1, r2
3400185e:	eba3 0308 	sub.w	r3, r3, r8
34001862:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34001866:	e74b      	b.n	34001700 <__udivmoddi4+0xf4>
34001868:	40b7      	lsls	r7, r6
3400186a:	f1c6 0320 	rsb	r3, r6, #32
3400186e:	fa01 f206 	lsl.w	r2, r1, r6
34001872:	fa21 f803 	lsr.w	r8, r1, r3
34001876:	ea4f 4e17 	mov.w	lr, r7, lsr #16
3400187a:	fa20 f303 	lsr.w	r3, r0, r3
3400187e:	b2bc      	uxth	r4, r7
34001880:	40b0      	lsls	r0, r6
34001882:	4313      	orrs	r3, r2
34001884:	0c02      	lsrs	r2, r0, #16
34001886:	0c19      	lsrs	r1, r3, #16
34001888:	b280      	uxth	r0, r0
3400188a:	fbb8 f9fe 	udiv	r9, r8, lr
3400188e:	fb0e 8819 	mls	r8, lr, r9, r8
34001892:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001896:	fb09 f804 	mul.w	r8, r9, r4
3400189a:	4588      	cmp	r8, r1
3400189c:	d951      	bls.n	34001942 <__udivmoddi4+0x336>
3400189e:	1879      	adds	r1, r7, r1
340018a0:	f109 3cff 	add.w	ip, r9, #4294967295
340018a4:	bf2c      	ite	cs
340018a6:	f04f 0a01 	movcs.w	sl, #1
340018aa:	f04f 0a00 	movcc.w	sl, #0
340018ae:	4588      	cmp	r8, r1
340018b0:	d902      	bls.n	340018b8 <__udivmoddi4+0x2ac>
340018b2:	f1ba 0f00 	cmp.w	sl, #0
340018b6:	d031      	beq.n	3400191c <__udivmoddi4+0x310>
340018b8:	eba1 0108 	sub.w	r1, r1, r8
340018bc:	fbb1 f9fe 	udiv	r9, r1, lr
340018c0:	fb09 f804 	mul.w	r8, r9, r4
340018c4:	fb0e 1119 	mls	r1, lr, r9, r1
340018c8:	b29b      	uxth	r3, r3
340018ca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
340018ce:	4543      	cmp	r3, r8
340018d0:	d235      	bcs.n	3400193e <__udivmoddi4+0x332>
340018d2:	18fb      	adds	r3, r7, r3
340018d4:	f109 31ff 	add.w	r1, r9, #4294967295
340018d8:	bf2c      	ite	cs
340018da:	f04f 0a01 	movcs.w	sl, #1
340018de:	f04f 0a00 	movcc.w	sl, #0
340018e2:	4543      	cmp	r3, r8
340018e4:	d2bb      	bcs.n	3400185e <__udivmoddi4+0x252>
340018e6:	f1ba 0f00 	cmp.w	sl, #0
340018ea:	d1b8      	bne.n	3400185e <__udivmoddi4+0x252>
340018ec:	f1a9 0102 	sub.w	r1, r9, #2
340018f0:	443b      	add	r3, r7
340018f2:	e7b4      	b.n	3400185e <__udivmoddi4+0x252>
340018f4:	1a84      	subs	r4, r0, r2
340018f6:	eb68 0203 	sbc.w	r2, r8, r3
340018fa:	2001      	movs	r0, #1
340018fc:	4696      	mov	lr, r2
340018fe:	e6eb      	b.n	340016d8 <__udivmoddi4+0xcc>
34001900:	443a      	add	r2, r7
34001902:	f1a8 0802 	sub.w	r8, r8, #2
34001906:	e72b      	b.n	34001760 <__udivmoddi4+0x154>
34001908:	f1ac 0c02 	sub.w	ip, ip, #2
3400190c:	443b      	add	r3, r7
3400190e:	e710      	b.n	34001732 <__udivmoddi4+0x126>
34001910:	3902      	subs	r1, #2
34001912:	443b      	add	r3, r7
34001914:	e6a9      	b.n	3400166a <__udivmoddi4+0x5e>
34001916:	443a      	add	r2, r7
34001918:	3802      	subs	r0, #2
3400191a:	e6be      	b.n	3400169a <__udivmoddi4+0x8e>
3400191c:	eba7 0808 	sub.w	r8, r7, r8
34001920:	f1a9 0c02 	sub.w	ip, r9, #2
34001924:	4441      	add	r1, r8
34001926:	fbb1 f9fe 	udiv	r9, r1, lr
3400192a:	fb09 f804 	mul.w	r8, r9, r4
3400192e:	e7c9      	b.n	340018c4 <__udivmoddi4+0x2b8>
34001930:	f1ae 0e02 	sub.w	lr, lr, #2
34001934:	443c      	add	r4, r7
34001936:	e744      	b.n	340017c2 <__udivmoddi4+0x1b6>
34001938:	3b02      	subs	r3, #2
3400193a:	443c      	add	r4, r7
3400193c:	e75e      	b.n	340017fc <__udivmoddi4+0x1f0>
3400193e:	4649      	mov	r1, r9
34001940:	e78d      	b.n	3400185e <__udivmoddi4+0x252>
34001942:	eba1 0108 	sub.w	r1, r1, r8
34001946:	46cc      	mov	ip, r9
34001948:	fbb1 f9fe 	udiv	r9, r1, lr
3400194c:	fb09 f804 	mul.w	r8, r9, r4
34001950:	e7b8      	b.n	340018c4 <__udivmoddi4+0x2b8>
34001952:	bf00      	nop

34001954 <__aeabi_idiv0>:
34001954:	4770      	bx	lr
34001956:	bf00      	nop

34001958 <CAM_Init>:
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
  assert(ret == HAL_OK);
}

void CAM_Init(uint32_t *lcd_bg_width, uint32_t *lcd_bg_height, uint32_t *pitch_nn)
{
34001958:	b570      	push	{r4, r5, r6, lr}
  int ret;
  CMW_CameraInit_t cam_conf;

  cam_conf.width = CAMERA_WIDTH;
3400195a:	2300      	movs	r3, #0
{
3400195c:	4614      	mov	r4, r2
  cam_conf.height = CAMERA_HEIGHT;
  cam_conf.fps = CAMERA_FPS;
3400195e:	221e      	movs	r2, #30
{
34001960:	b092      	sub	sp, #72	@ 0x48
34001962:	4606      	mov	r6, r0
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
  cam_conf.anti_flicker = 0;
  cam_conf.mirror_flip = CAMERA_FLIP;

  ret = CMW_CAMERA_Init(&cam_conf);
34001964:	a801      	add	r0, sp, #4
{
34001966:	460d      	mov	r5, r1
  cam_conf.height = CAMERA_HEIGHT;
34001968:	e9cd 3301 	strd	r3, r3, [sp, #4]
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
3400196c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  cam_conf.mirror_flip = CAMERA_FLIP;
34001970:	e9cd 3305 	strd	r3, r3, [sp, #20]
  ret = CMW_CAMERA_Init(&cam_conf);
34001974:	f00f f932 	bl	34010bdc <CMW_CAMERA_Init>
  assert(ret == CMW_ERROR_NONE);
34001978:	b128      	cbz	r0, 34001986 <CAM_Init+0x2e>
3400197a:	218c      	movs	r1, #140	@ 0x8c
3400197c:	4b1a      	ldr	r3, [pc, #104]	@ (340019e8 <CAM_Init+0x90>)
3400197e:	4a1b      	ldr	r2, [pc, #108]	@ (340019ec <CAM_Init+0x94>)
  assert(ret == HAL_OK);
34001980:	481b      	ldr	r0, [pc, #108]	@ (340019f0 <CAM_Init+0x98>)
34001982:	f016 f80d 	bl	340179a0 <__assert_func>
  if (camConf->height <= 480)
34001986:	9b02      	ldr	r3, [sp, #8]
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
34001988:	e9cd 000b 	strd	r0, r0, [sp, #44]	@ 0x2c
  if (camConf->height <= 480)
3400198c:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34001990:	bf28      	it	cs
34001992:	f44f 73f0 	movcs.w	r3, #480	@ 0x1e0
  *bg_width = lcd_bg_width;
34001996:	6033      	str	r3, [r6, #0]
  *bg_height = lcd_bg_height;
34001998:	602b      	str	r3, [r5, #0]
  dcmipp_conf.output_bpp = CAPTURE_BPP;
3400199a:	2501      	movs	r5, #1
3400199c:	2602      	movs	r6, #2
  dcmipp_conf.mode = aspect_ratio;
3400199e:	900d      	str	r0, [sp, #52]	@ 0x34
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
340019a0:	466a      	mov	r2, sp
340019a2:	4628      	mov	r0, r5
340019a4:	a907      	add	r1, sp, #28
  dcmipp_conf.output_height = lcd_bg_height;
340019a6:	e9cd 3307 	strd	r3, r3, [sp, #28]
  dcmipp_conf.output_bpp = CAPTURE_BPP;
340019aa:	e9cd 5609 	strd	r5, r6, [sp, #36]	@ 0x24
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
340019ae:	f00e ffcf 	bl	34010950 <CMW_CAMERA_SetPipeConfig>
  assert(ret == HAL_OK);
340019b2:	b118      	cbz	r0, 340019bc <CAM_Init+0x64>
340019b4:	215a      	movs	r1, #90	@ 0x5a
340019b6:	4b0f      	ldr	r3, [pc, #60]	@ (340019f4 <CAM_Init+0x9c>)
340019b8:	4a0f      	ldr	r2, [pc, #60]	@ (340019f8 <CAM_Init+0xa0>)
340019ba:	e7e1      	b.n	34001980 <CAM_Init+0x28>
  dcmipp_conf.output_width = NN_WIDTH;
340019bc:	23e0      	movs	r3, #224	@ 0xe0
  dcmipp_conf.output_height = NN_HEIGHT;
340019be:	e9cd 3307 	strd	r3, r3, [sp, #28]
  dcmipp_conf.output_bpp = NN_BPP;
340019c2:	2303      	movs	r3, #3
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
340019c4:	e9cd 500b 	strd	r5, r0, [sp, #44]	@ 0x2c
  dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
340019c8:	9009      	str	r0, [sp, #36]	@ 0x24
  dcmipp_conf.mode = aspect_ratio;
340019ca:	900d      	str	r0, [sp, #52]	@ 0x34
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
340019cc:	4622      	mov	r2, r4
340019ce:	4630      	mov	r0, r6
340019d0:	a907      	add	r1, sp, #28
  dcmipp_conf.output_bpp = NN_BPP;
340019d2:	930a      	str	r3, [sp, #40]	@ 0x28
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
340019d4:	f00e ffbc 	bl	34010950 <CMW_CAMERA_SetPipeConfig>
  assert(ret == HAL_OK);
340019d8:	b118      	cbz	r0, 340019e2 <CAM_Init+0x8a>
340019da:	217c      	movs	r1, #124	@ 0x7c
340019dc:	4b05      	ldr	r3, [pc, #20]	@ (340019f4 <CAM_Init+0x9c>)
340019de:	4a07      	ldr	r2, [pc, #28]	@ (340019fc <CAM_Init+0xa4>)
340019e0:	e7ce      	b.n	34001980 <CAM_Init+0x28>
  DCMIPP_PipeInitDisplay(&cam_conf, lcd_bg_width, lcd_bg_height);
  DCMIPP_PipeInitNn(pitch_nn);
}
340019e2:	b012      	add	sp, #72	@ 0x48
340019e4:	bd70      	pop	{r4, r5, r6, pc}
340019e6:	bf00      	nop
340019e8:	3401be24 	.word	0x3401be24
340019ec:	3401e8b4 	.word	0x3401e8b4
340019f0:	3401be3a 	.word	0x3401be3a
340019f4:	3401be71 	.word	0x3401be71
340019f8:	3401e89d 	.word	0x3401e89d
340019fc:	3401e88b 	.word	0x3401e88b

34001a00 <CAM_DisplayPipe_Start>:
  ret = CMW_CAMERA_DeInit();
  assert(ret == CMW_ERROR_NONE);
}

void CAM_DisplayPipe_Start(uint8_t *display_pipe_dst, uint32_t cam_mode)
{
34001a00:	460a      	mov	r2, r1
34001a02:	b508      	push	{r3, lr}
  int ret;
  ret = CMW_CAMERA_Start(DCMIPP_PIPE1, display_pipe_dst, cam_mode);
34001a04:	4601      	mov	r1, r0
34001a06:	2001      	movs	r0, #1
34001a08:	f00f f864 	bl	34010ad4 <CMW_CAMERA_Start>
  assert(ret == CMW_ERROR_NONE);
34001a0c:	b128      	cbz	r0, 34001a1a <CAM_DisplayPipe_Start+0x1a>
34001a0e:	219c      	movs	r1, #156	@ 0x9c
34001a10:	4b02      	ldr	r3, [pc, #8]	@ (34001a1c <CAM_DisplayPipe_Start+0x1c>)
34001a12:	4a03      	ldr	r2, [pc, #12]	@ (34001a20 <CAM_DisplayPipe_Start+0x20>)
34001a14:	4803      	ldr	r0, [pc, #12]	@ (34001a24 <CAM_DisplayPipe_Start+0x24>)
34001a16:	f015 ffc3 	bl	340179a0 <__assert_func>
}
34001a1a:	bd08      	pop	{r3, pc}
34001a1c:	3401be24 	.word	0x3401be24
34001a20:	3401e875 	.word	0x3401e875
34001a24:	3401be3a 	.word	0x3401be3a

34001a28 <CAM_NNPipe_Start>:

void CAM_NNPipe_Start(uint8_t *nn_pipe_dst, uint32_t cam_mode)
{
34001a28:	460a      	mov	r2, r1
34001a2a:	b508      	push	{r3, lr}
  int ret;

  ret = CMW_CAMERA_Start(DCMIPP_PIPE2, nn_pipe_dst, cam_mode);
34001a2c:	4601      	mov	r1, r0
34001a2e:	2002      	movs	r0, #2
34001a30:	f00f f850 	bl	34010ad4 <CMW_CAMERA_Start>
  assert(ret == CMW_ERROR_NONE);
34001a34:	b128      	cbz	r0, 34001a42 <CAM_NNPipe_Start+0x1a>
34001a36:	21a4      	movs	r1, #164	@ 0xa4
34001a38:	4b02      	ldr	r3, [pc, #8]	@ (34001a44 <CAM_NNPipe_Start+0x1c>)
34001a3a:	4a03      	ldr	r2, [pc, #12]	@ (34001a48 <CAM_NNPipe_Start+0x20>)
34001a3c:	4803      	ldr	r0, [pc, #12]	@ (34001a4c <CAM_NNPipe_Start+0x24>)
34001a3e:	f015 ffaf 	bl	340179a0 <__assert_func>
}
34001a42:	bd08      	pop	{r3, pc}
34001a44:	3401be24 	.word	0x3401be24
34001a48:	3401e864 	.word	0x3401e864
34001a4c:	3401be3a 	.word	0x3401be3a

34001a50 <CAM_IspUpdate>:
  ret = CMW_CAMERA_Suspend(DCMIPP_PIPE1);
  assert(ret == CMW_ERROR_NONE);
}

void CAM_IspUpdate(void)
{
34001a50:	b508      	push	{r3, lr}
  int ret = CMW_ERROR_NONE;
  ret = CMW_CAMERA_Run();
34001a52:	f00f f919 	bl	34010c88 <CMW_CAMERA_Run>
  assert(ret == CMW_ERROR_NONE);
34001a56:	b128      	cbz	r0, 34001a64 <CAM_IspUpdate+0x14>
34001a58:	21b2      	movs	r1, #178	@ 0xb2
34001a5a:	4b03      	ldr	r3, [pc, #12]	@ (34001a68 <CAM_IspUpdate+0x18>)
34001a5c:	4a03      	ldr	r2, [pc, #12]	@ (34001a6c <CAM_IspUpdate+0x1c>)
34001a5e:	4804      	ldr	r0, [pc, #16]	@ (34001a70 <CAM_IspUpdate+0x20>)
34001a60:	f015 ff9e 	bl	340179a0 <__assert_func>
}
34001a64:	bd08      	pop	{r3, pc}
34001a66:	bf00      	nop
34001a68:	3401be24 	.word	0x3401be24
34001a6c:	3401e856 	.word	0x3401e856
34001a70:	3401be3a 	.word	0x3401be3a

34001a74 <CMW_CAMERA_PIPE_FrameEventCallback>:
  * @param  hdcmipp pointer to the DCMIPP handle
  * @retval None
  */
int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
{
  switch (pipe)
34001a74:	2802      	cmp	r0, #2
  {
    case DCMIPP_PIPE2 :
      cameraFrameReceived++;
34001a76:	bf08      	it	eq
34001a78:	4a03      	ldreq	r2, [pc, #12]	@ (34001a88 <CMW_CAMERA_PIPE_FrameEventCallback+0x14>)
      break;
  }
  return 0;
}
34001a7a:	f04f 0000 	mov.w	r0, #0
      cameraFrameReceived++;
34001a7e:	bf02      	ittt	eq
34001a80:	6813      	ldreq	r3, [r2, #0]
34001a82:	3301      	addeq	r3, #1
34001a84:	6013      	streq	r3, [r2, #0]
}
34001a86:	4770      	bx	lr
34001a88:	3403f42c 	.word	0x3403f42c

34001a8c <Fuse_Programming>:
/**
  * @brief  Check specific fuse configuration and update it if needed.
  * @retval None
  */
void Fuse_Programming(void)
{
34001a8c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t fuse_id, bit_mask, data;

  BSEC_HandleTypeDef sBsecHandler;

  sBsecHandler.Instance = BSEC;
34001a8e:	4b15      	ldr	r3, [pc, #84]	@ (34001ae4 <Fuse_Programming+0x58>)

  /* Read current value of fuse */
  fuse_id = BSEC_FUSE_ADDRESS;
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001a90:	217c      	movs	r1, #124	@ 0x7c
34001a92:	aa01      	add	r2, sp, #4
34001a94:	a802      	add	r0, sp, #8
  sBsecHandler.Instance = BSEC;
34001a96:	9302      	str	r3, [sp, #8]
  if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001a98:	f002 ff84 	bl	340049a4 <HAL_BSEC_OTP_Read>
34001a9c:	4603      	mov	r3, r0
34001a9e:	b9e0      	cbnz	r0, 34001ada <Fuse_Programming+0x4e>
  {
    /* Check if bit has already been set */
    bit_mask = BSEC_FUSE_MASK;
    if ((data & bit_mask) != bit_mask)
34001aa0:	9a01      	ldr	r2, [sp, #4]
34001aa2:	f402 31c0 	and.w	r1, r2, #98304	@ 0x18000
34001aa6:	f5b1 3fc0 	cmp.w	r1, #98304	@ 0x18000
34001aaa:	d017      	beq.n	34001adc <Fuse_Programming+0x50>
    {
      data |= bit_mask;
34001aac:	f442 32c0 	orr.w	r2, r2, #98304	@ 0x18000
      /* Bitwise programming of lower bits */
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34001ab0:	217c      	movs	r1, #124	@ 0x7c
34001ab2:	a802      	add	r0, sp, #8
      data |= bit_mask;
34001ab4:	9201      	str	r2, [sp, #4]
      if (HAL_BSEC_OTP_Program(&sBsecHandler, fuse_id, data, HAL_BSEC_NORMAL_PROG) == HAL_OK)
34001ab6:	f002 ff91 	bl	340049dc <HAL_BSEC_OTP_Program>
34001aba:	b968      	cbnz	r0, 34001ad8 <Fuse_Programming+0x4c>
      {
        /* Read lower bits to verify the correct programming */
        if (HAL_BSEC_OTP_Read(&sBsecHandler, fuse_id, &data) == HAL_OK)
34001abc:	217c      	movs	r1, #124	@ 0x7c
34001abe:	aa01      	add	r2, sp, #4
34001ac0:	a802      	add	r0, sp, #8
34001ac2:	f002 ff6f 	bl	340049a4 <HAL_BSEC_OTP_Read>
34001ac6:	b930      	cbnz	r0, 34001ad6 <Fuse_Programming+0x4a>
        {
          if ((data & bit_mask) != bit_mask)
34001ac8:	9b01      	ldr	r3, [sp, #4]
34001aca:	f403 33c0 	and.w	r3, r3, #98304	@ 0x18000
34001ace:	f5b3 3fc0 	cmp.w	r3, #98304	@ 0x18000
34001ad2:	d003      	beq.n	34001adc <Fuse_Programming+0x50>
34001ad4:	e7fe      	b.n	34001ad4 <Fuse_Programming+0x48>
34001ad6:	e7fe      	b.n	34001ad6 <Fuse_Programming+0x4a>
34001ad8:	e7fe      	b.n	34001ad8 <Fuse_Programming+0x4c>
34001ada:	e7fe      	b.n	34001ada <Fuse_Programming+0x4e>
  else
  {
    /* Error  : Fuse read unsuccessful */
    ErrorHandler();
  }
}
34001adc:	b005      	add	sp, #20
34001ade:	f85d fb04 	ldr.w	pc, [sp], #4
34001ae2:	bf00      	nop
34001ae4:	56009000 	.word	0x56009000

34001ae8 <app_postprocess_init>:
int32_t app_postprocess_init(void *params_postprocess)
{
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
  yolov2_pp_static_param_t *params = (yolov2_pp_static_param_t *) params_postprocess;
  params->conf_threshold = AI_OBJDETECT_YOLOV2_PP_CONF_THRESHOLD;
34001ae8:	4a09      	ldr	r2, [pc, #36]	@ (34001b10 <app_postprocess_init+0x28>)
  params->iou_threshold = AI_OBJDETECT_YOLOV2_PP_IOU_THRESHOLD;
  params->nb_anchors = AI_OBJDETECT_YOLOV2_PP_NB_ANCHORS;
  params->nb_classes = AI_OBJDETECT_YOLOV2_PP_NB_CLASSES;
34001aea:	2105      	movs	r1, #5
  params->conf_threshold = AI_OBJDETECT_YOLOV2_PP_CONF_THRESHOLD;
34001aec:	6182      	str	r2, [r0, #24]
  params->iou_threshold = AI_OBJDETECT_YOLOV2_PP_IOU_THRESHOLD;
34001aee:	4a09      	ldr	r2, [pc, #36]	@ (34001b14 <app_postprocess_init+0x2c>)
34001af0:	61c2      	str	r2, [r0, #28]
  params->nb_classes = AI_OBJDETECT_YOLOV2_PP_NB_CLASSES;
34001af2:	2201      	movs	r2, #1
34001af4:	e9c0 2100 	strd	r2, r1, [r0]
  params->grid_height = AI_OBJDETECT_YOLOV2_PP_GRID_HEIGHT;
34001af8:	2207      	movs	r2, #7
  params->grid_width = AI_OBJDETECT_YOLOV2_PP_GRID_WIDTH;
34001afa:	e9c0 2202 	strd	r2, r2, [r0, #8]
  params->nb_input_boxes = AI_OBJDETECT_YOLOV2_PP_NB_INPUT_BOXES;
34001afe:	2231      	movs	r2, #49	@ 0x31
34001b00:	6102      	str	r2, [r0, #16]
  params->pAnchors = AI_OBJDETECT_YOLOV2_PP_ANCHORS;
34001b02:	4a05      	ldr	r2, [pc, #20]	@ (34001b18 <app_postprocess_init+0x30>)
34001b04:	6202      	str	r2, [r0, #32]
  params->max_boxes_limit = AI_OBJDETECT_YOLOV2_PP_MAX_BOXES_LIMIT;
34001b06:	220a      	movs	r2, #10
34001b08:	6142      	str	r2, [r0, #20]
  error = od_yolov2_pp_reset(params);
34001b0a:	f013 bfbf 	b.w	34015a8c <od_yolov2_pp_reset>
34001b0e:	bf00      	nop
34001b10:	3f19999a 	.word	0x3f19999a
34001b14:	3e99999a 	.word	0x3e99999a
34001b18:	3401e8d4 	.word	0x3401e8d4

34001b1c <app_postprocess_run>:

  return error;
}

int32_t app_postprocess_run(void *pInput[], int nb_input, void *pOutput, void *pInput_param)
{
34001b1c:	b513      	push	{r0, r1, r4, lr}
34001b1e:	460c      	mov	r4, r1
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  assert(nb_input == 1);
34001b20:	2c01      	cmp	r4, #1
{
34001b22:	4611      	mov	r1, r2
34001b24:	461a      	mov	r2, r3
  assert(nb_input == 1);
34001b26:	d005      	beq.n	34001b34 <app_postprocess_run+0x18>
34001b28:	21c4      	movs	r1, #196	@ 0xc4
34001b2a:	4b06      	ldr	r3, [pc, #24]	@ (34001b44 <app_postprocess_run+0x28>)
34001b2c:	4a06      	ldr	r2, [pc, #24]	@ (34001b48 <app_postprocess_run+0x2c>)
34001b2e:	4807      	ldr	r0, [pc, #28]	@ (34001b4c <app_postprocess_run+0x30>)
34001b30:	f015 ff36 	bl	340179a0 <__assert_func>
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
  yolov2_pp_in_t pp_input = {
34001b34:	6803      	ldr	r3, [r0, #0]
    .pRaw_detections = (float32_t *) pInput[0]
  };
  error = od_yolov2_pp_process(&pp_input, (od_pp_out_t *) pOutput,
34001b36:	a801      	add	r0, sp, #4
  yolov2_pp_in_t pp_input = {
34001b38:	9301      	str	r3, [sp, #4]
  error = od_yolov2_pp_process(&pp_input, (od_pp_out_t *) pOutput,
34001b3a:	f013 ffab 	bl	34015a94 <od_yolov2_pp_process>
#else
  #error "PostProcessing type not supported"
#endif

  return error;
}
34001b3e:	b002      	add	sp, #8
34001b40:	bd10      	pop	{r4, pc}
34001b42:	bf00      	nop
34001b44:	3401be7f 	.word	0x3401be7f
34001b48:	3401e8bd 	.word	0x3401e8bd
34001b4c:	3401be8d 	.word	0x3401be8d

34001b50 <img_crop>:
#include <assert.h>

void img_crop(uint8_t *src_image, uint8_t *dst_img, const uint32_t src_stride,
              const uint16_t dst_width, const uint16_t height,
              const uint16_t dst_bpp)
{
34001b50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34001b54:	460d      	mov	r5, r1
  const uint8_t *pIn = src_image;
  uint8_t *pOut = dst_img;
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34001b56:	4604      	mov	r4, r0

  /* Copy line per line */
  for (uint32_t i = 0; i < height; i++)
34001b58:	2700      	movs	r7, #0
{
34001b5a:	4690      	mov	r8, r2
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34001b5c:	f8bd 2024 	ldrh.w	r2, [sp, #36]	@ 0x24
{
34001b60:	f8bd 9020 	ldrh.w	r9, [sp, #32]
  const uint32_t dst_line_size = (dst_width * dst_bpp);
34001b64:	fb02 f603 	mul.w	r6, r2, r3
  for (uint32_t i = 0; i < height; i++)
34001b68:	45b9      	cmp	r9, r7
34001b6a:	d801      	bhi.n	34001b70 <img_crop+0x20>
  {
    memcpy(pOut, pIn + (i * src_stride), dst_line_size);
    pOut += dst_line_size;
  }
34001b6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    memcpy(pOut, pIn + (i * src_stride), dst_line_size);
34001b70:	4621      	mov	r1, r4
34001b72:	4628      	mov	r0, r5
34001b74:	4632      	mov	r2, r6
34001b76:	f017 fb0c 	bl	34019192 <memcpy>
    pOut += dst_line_size;
34001b7a:	4435      	add	r5, r6
  for (uint32_t i = 0; i < height; i++)
34001b7c:	3701      	adds	r7, #1
34001b7e:	4444      	add	r4, r8
34001b80:	e7f2      	b.n	34001b68 <img_crop+0x18>
	...

34001b84 <LL_MEM_EnableClock>:
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClock(uint32_t Memories)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMENSR, Memories);
34001b84:	4b04      	ldr	r3, [pc, #16]	@ (34001b98 <LL_MEM_EnableClock+0x14>)
{
34001b86:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMENSR, Memories);
34001b88:	f8c3 0a4c 	str.w	r0, [r3, #2636]	@ 0xa4c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMENR);
34001b8c:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
34001b90:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001b92:	9b01      	ldr	r3, [sp, #4]
}
34001b94:	b002      	add	sp, #8
34001b96:	4770      	bx	lr
34001b98:	56028000 	.word	0x56028000

34001b9c <LL_MEM_EnableClockLowPower>:
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClockLowPower(uint32_t Memories)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMLPENSR, Memories);
34001b9c:	4b04      	ldr	r3, [pc, #16]	@ (34001bb0 <LL_MEM_EnableClockLowPower+0x14>)
{
34001b9e:	b082      	sub	sp, #8
  WRITE_REG(RCC->MEMLPENSR, Memories);
34001ba0:	f8c3 0a8c 	str.w	r0, [r3, #2700]	@ 0xa8c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMLPENR);
34001ba4:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
34001ba8:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001baa:	9b01      	ldr	r3, [sp, #4]
}
34001bac:	b002      	add	sp, #8
34001bae:	4770      	bx	lr
34001bb0:	56028000 	.word	0x56028000

34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>:
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
34001bb4:	4b04      	ldr	r3, [pc, #16]	@ (34001bc8 <LL_AHB5_GRP1_EnableClockLowPower+0x14>)
{
34001bb6:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
34001bb8:	f8c3 0aa0 	str.w	r0, [r3, #2720]	@ 0xaa0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5LPENR);
34001bbc:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
34001bc0:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34001bc2:	9b01      	ldr	r3, [sp, #4]
}
34001bc4:	b002      	add	sp, #8
34001bc6:	4770      	bx	lr
34001bc8:	56028000 	.word	0x56028000

34001bcc <SystemClock_Config>:

  return ret;
}

static void SystemClock_Config(void)
{
34001bcc:	b530      	push	{r4, r5, lr}
34001bce:	f5ad 7d1b 	sub.w	sp, sp, #620	@ 0x26c
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34001bd2:	2240      	movs	r2, #64	@ 0x40
34001bd4:	2100      	movs	r1, #0
34001bd6:	4668      	mov	r0, sp
34001bd8:	f017 f844 	bl	34018c64 <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34001bdc:	2298      	movs	r2, #152	@ 0x98
34001bde:	2100      	movs	r1, #0
34001be0:	a810      	add	r0, sp, #64	@ 0x40
34001be2:	f017 f83f 	bl	34018c64 <memset>
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34001be6:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34001bea:	2100      	movs	r1, #0
34001bec:	a836      	add	r0, sp, #216	@ 0xd8
34001bee:	f017 f839 	bl	34018c64 <memset>

  /* Ensure VDDCORE=0.9V before increasing the system frequency */
  BSP_SMPS_Init(SMPS_VOLTAGE_OVERDRIVE);
34001bf2:	2001      	movs	r0, #1
34001bf4:	f001 fa32 	bl	3400305c <BSP_SMPS_Init>
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL1.PLLM = 2;
  RCC_OscInitStruct.PLL1.PLLN = 25;
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34001bf8:	2401      	movs	r4, #1
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34001bfa:	2300      	movs	r3, #0
  RCC_OscInitStruct.PLL1.PLLN = 25;
34001bfc:	2219      	movs	r2, #25
  /* PLL2 = 64 x 125 / 8 = 1000MHz */
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL2.PLLM = 8;
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
  RCC_OscInitStruct.PLL2.PLLN = 125;
34001bfe:	217d      	movs	r1, #125	@ 0x7d
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34001c00:	2502      	movs	r5, #2
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34001c02:	e9cd 321d 	strd	r3, r2, [sp, #116]	@ 0x74
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
34001c06:	e9cd 1425 	strd	r1, r4, [sp, #148]	@ 0x94
  RCC_OscInitStruct.PLL2.PLLM = 8;
34001c0a:	2208      	movs	r2, #8

  /* PLL3 = (64 x 225 / 8) / (1 * 2) = 900MHz */
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL3.PLLM = 8;
  RCC_OscInitStruct.PLL3.PLLN = 225;
34001c0c:	21e1      	movs	r1, #225	@ 0xe1
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34001c0e:	e9cd 531a 	strd	r5, r3, [sp, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34001c12:	e9cd 5321 	strd	r5, r3, [sp, #132]	@ 0x84
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
34001c16:	e9cd 2323 	strd	r2, r3, [sp, #140]	@ 0x8c
  RCC_OscInitStruct.PLL3.PLLM = 8;
34001c1a:	e9cd 3229 	strd	r3, r2, [sp, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34001c1e:	e9cd 312b 	strd	r3, r1, [sp, #172]	@ 0xac
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
  RCC_OscInitStruct.PLL3.PLLP2 = 2;

  /* PLL4 = (64 x 225 / 8) / (6 * 6) = 50 MHz */
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34001c22:	e9cd 532f 	strd	r5, r3, [sp, #188]	@ 0xbc
  RCC_OscInitStruct.PLL4.PLLM = 8;
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34001c26:	e9cd 2331 	strd	r2, r3, [sp, #196]	@ 0xc4
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34001c2a:	9310      	str	r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL4.PLLN = 225;
  RCC_OscInitStruct.PLL4.PLLP1 = 6;
34001c2c:	2306      	movs	r3, #6
  RCC_OscInitStruct.PLL4.PLLP2 = 6;

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34001c2e:	a810      	add	r0, sp, #64	@ 0x40
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34001c30:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
34001c34:	e9cd 4527 	strd	r4, r5, [sp, #156]	@ 0x9c
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34001c38:	e9cd 452d 	strd	r4, r5, [sp, #180]	@ 0xb4
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
34001c3c:	e9cd 3334 	strd	r3, r3, [sp, #208]	@ 0xd0
  RCC_OscInitStruct.PLL1.PLLM = 2;
34001c40:	951c      	str	r5, [sp, #112]	@ 0x70
  RCC_OscInitStruct.PLL4.PLLN = 225;
34001c42:	9133      	str	r1, [sp, #204]	@ 0xcc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34001c44:	f007 fc2a 	bl	3400949c <HAL_RCC_OscConfig>
34001c48:	b100      	cbz	r0, 34001c4c <SystemClock_Config+0x80>
  {
    while(1);
34001c4a:	e7fe      	b.n	34001c4a <SystemClock_Config+0x7e>
                                 RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
                                 RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK4 |
                                 RCC_CLOCKTYPE_PCLK5);

  /* CPU CLock (sysa_ck) = ic1_ck = PLL1 output/ic1_divider = 800 MHz */
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34001c4c:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34001c50:	227f      	movs	r2, #127	@ 0x7f
34001c52:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34001c56:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34001c5a:	9302      	str	r3, [sp, #8]
  /* AXI Clock (sysb_ck) = ic2_ck = PLL1 output/ic2_divider = 400 MHz */
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;

  /* NPU Clock (sysc_ck) = ic6_ck = PLL2 output/ic6_divider = 1000 MHz */
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34001c5c:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34001c60:	e9cd 340c 	strd	r3, r4, [sp, #48]	@ 0x30

  /* AXISRAM3/4/5/6 Clock (sysd_ck) = ic11_ck = PLL3 output/ic11_divider = 900 MHz */
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34001c64:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
34001c68:	e9cd 340e 	strd	r3, r4, [sp, #56]	@ 0x38

  /* HCLK = sysb_ck / HCLK divider = 200 MHz */
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34001c6c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34001c70:	e9cd 0408 	strd	r0, r4, [sp, #32]
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34001c74:	e9cd 050a 	strd	r0, r5, [sp, #40]	@ 0x28

  /* PCLKx = HCLK / PCLKx divider = 200 MHz */
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34001c78:	e9cd 3003 	strd	r3, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34001c7c:	e9cd 0005 	strd	r0, r0, [sp, #20]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34001c80:	9007      	str	r0, [sp, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34001c82:	4668      	mov	r0, sp
34001c84:	f008 f806 	bl	34009c94 <HAL_RCC_ClockConfig>
34001c88:	b100      	cbz	r0, 34001c8c <SystemClock_Config+0xc0>
  {
    while(1);
34001c8a:	e7fe      	b.n	34001c8a <SystemClock_Config+0xbe>

  RCC_PeriphCLKInitStruct.PeriphClockSelection = 0;

  /* XSPI1 kernel clock (ck_ker_xspi1) = HCLK = 200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI1;
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34001c8c:	4b08      	ldr	r3, [pc, #32]	@ (34001cb0 <SystemClock_Config+0xe4>)

  /* XSPI2 kernel clock (ck_ker_xspi1) = HCLK =  200MHz */
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34001c8e:	2200      	movs	r2, #0
  RCC_PeriphCLKInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34001c90:	9361      	str	r3, [sp, #388]	@ 0x184
  RCC_PeriphCLKInitStruct.PeriphClockSelection |= RCC_PERIPHCLK_XSPI2;
34001c92:	f44f 0340 	mov.w	r3, #12582912	@ 0xc00000
34001c96:	e9cd 2336 	strd	r2, r3, [sp, #216]	@ 0xd8
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34001c9a:	4b06      	ldr	r3, [pc, #24]	@ (34001cb4 <SystemClock_Config+0xe8>)

  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34001c9c:	a836      	add	r0, sp, #216	@ 0xd8
  RCC_PeriphCLKInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34001c9e:	9362      	str	r3, [sp, #392]	@ 0x188
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34001ca0:	f008 fbae 	bl	3400a400 <HAL_RCCEx_PeriphCLKConfig>
34001ca4:	b100      	cbz	r0, 34001ca8 <SystemClock_Config+0xdc>
  {
    while (1);
34001ca6:	e7fe      	b.n	34001ca6 <SystemClock_Config+0xda>
  }
}
34001ca8:	f50d 7d1b 	add.w	sp, sp, #620	@ 0x26c
34001cac:	bd30      	pop	{r4, r5, pc}
34001cae:	bf00      	nop
34001cb0:	03000014 	.word	0x03000014
34001cb4:	03000414 	.word	0x03000414

34001cb8 <main>:
{
34001cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34001cbc:	4ac8      	ldr	r2, [pc, #800]	@ (34001fe0 <main+0x328>)
{
34001cbe:	b09b      	sub	sp, #108	@ 0x6c
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34001cc0:	6813      	ldr	r3, [r2, #0]
34001cc2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34001cc6:	6013      	str	r3, [r2, #0]
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_IC1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCpuClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, Source);
34001cc8:	4bc6      	ldr	r3, [pc, #792]	@ (34001fe4 <main+0x32c>)
34001cca:	6a1a      	ldr	r2, [r3, #32]
34001ccc:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
34001cd0:	621a      	str	r2, [r3, #32]
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_IC2_IC6_IC11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, Source);
34001cd2:	6a1a      	ldr	r2, [r3, #32]
34001cd4:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
34001cd8:	621a      	str	r2, [r3, #32]
  HAL_Init();
34001cda:	f002 fdeb 	bl	340048b4 <HAL_Init>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34001cde:	4bc2      	ldr	r3, [pc, #776]	@ (34001fe8 <main+0x330>)
34001ce0:	695a      	ldr	r2, [r3, #20]
34001ce2:	f412 3200 	ands.w	r2, r2, #131072	@ 0x20000
34001ce6:	d111      	bne.n	34001d0c <main+0x54>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34001ce8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001cec:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34001cf0:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34001cf4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001cf8:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
34001cfc:	695a      	ldr	r2, [r3, #20]
34001cfe:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
34001d02:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34001d04:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001d08:	f3bf 8f6f 	isb	sy
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
34001d0c:	4ab4      	ldr	r2, [pc, #720]	@ (34001fe0 <main+0x328>)
34001d0e:	6813      	ldr	r3, [r2, #0]
34001d10:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34001d14:	6013      	str	r3, [r2, #0]
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34001d16:	f5a2 4273 	sub.w	r2, r2, #62208	@ 0xf300
34001d1a:	6953      	ldr	r3, [r2, #20]
34001d1c:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
34001d20:	d128      	bne.n	34001d74 <main+0xbc>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
34001d22:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34001d26:	f3bf 8f4f 	dsb	sy
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34001d2a:	f643 74e0 	movw	r4, #16352	@ 0x3fe0
    ccsidr = SCB->CCSIDR;
34001d2e:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34001d32:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
34001d36:	f3c3 334e 	ubfx	r3, r3, #13, #15
34001d3a:	015b      	lsls	r3, r3, #5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34001d3c:	f100 0e01 	add.w	lr, r0, #1
34001d40:	4601      	mov	r1, r0
34001d42:	f04e e001 	dls	lr, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34001d46:	ea03 0604 	and.w	r6, r3, r4
34001d4a:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
34001d4e:	f8c2 5260 	str.w	r5, [r2, #608]	@ 0x260
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34001d52:	3901      	subs	r1, #1
34001d54:	f00f c807 	le	lr, 34001d4a <main+0x92>
    } while(sets-- != 0U);
34001d58:	3b20      	subs	r3, #32
34001d5a:	f113 0f20 	cmn.w	r3, #32
34001d5e:	d1ed      	bne.n	34001d3c <main+0x84>
34001d60:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
34001d64:	6953      	ldr	r3, [r2, #20]
34001d66:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34001d6a:	6153      	str	r3, [r2, #20]
34001d6c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34001d70:	f3bf 8f6f 	isb	sy
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001d74:	f04f 4700 	mov.w	r7, #2147483648	@ 0x80000000
  WRITE_REG(RCC->AHB2ENSR, Periphs);
34001d78:	f44f 5980 	mov.w	r9, #4096	@ 0x1000
  RAMCFG_HandleTypeDef hramcfg = {0};
34001d7c:	2500      	movs	r5, #0
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001d7e:	4c99      	ldr	r4, [pc, #612]	@ (34001fe4 <main+0x32c>)
  SystemClock_Config();
34001d80:	f7ff ff24 	bl	34001bcc <SystemClock_Config>
34001d84:	f8c4 7a60 	str.w	r7, [r4, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34001d88:	f8d4 3260 	ldr.w	r3, [r4, #608]	@ 0x260
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34001d8c:	f8df a2a4 	ldr.w	sl, [pc, #676]	@ 34002034 <main+0x37c>
  tmpreg = READ_REG(RCC->AHB5ENR);
34001d90:	930a      	str	r3, [sp, #40]	@ 0x28
  (void)tmpreg;
34001d92:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
34001d94:	2001      	movs	r0, #1
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34001d96:	f8c4 7a20 	str.w	r7, [r4, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34001d9a:	f8ca 7220 	str.w	r7, [sl, #544]	@ 0x220
34001d9e:	f7ff fef1 	bl	34001b84 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
34001da2:	2002      	movs	r0, #2
34001da4:	f7ff feee 	bl	34001b84 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
34001da8:	2004      	movs	r0, #4
34001daa:	f7ff feeb 	bl	34001b84 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
34001dae:	2008      	movs	r0, #8
34001db0:	f7ff fee8 	bl	34001b84 <LL_MEM_EnableClock>
  WRITE_REG(RCC->AHB2ENSR, Periphs);
34001db4:	f8c4 9a54 	str.w	r9, [r4, #2644]	@ 0xa54
  tmpreg = READ_REG(RCC->AHB2ENR);
34001db8:	f8d4 3254 	ldr.w	r3, [r4, #596]	@ 0x254
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dbc:	a815      	add	r0, sp, #84	@ 0x54
34001dbe:	9309      	str	r3, [sp, #36]	@ 0x24
  (void)tmpreg;
34001dc0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
34001dc2:	4b8a      	ldr	r3, [pc, #552]	@ (34001fec <main+0x334>)
  RAMCFG_HandleTypeDef hramcfg = {0};
34001dc4:	e9cd 5516 	strd	r5, r5, [sp, #88]	@ 0x58
  hramcfg.Instance =  RAMCFG_SRAM3_AXI;
34001dc8:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dca:	f007 f943 	bl	34009054 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
34001dce:	4b88      	ldr	r3, [pc, #544]	@ (34001ff0 <main+0x338>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dd0:	a815      	add	r0, sp, #84	@ 0x54
  hramcfg.Instance =  RAMCFG_SRAM4_AXI;
34001dd2:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dd4:	f007 f93e 	bl	34009054 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
34001dd8:	4b86      	ldr	r3, [pc, #536]	@ (34001ff4 <main+0x33c>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dda:	a815      	add	r0, sp, #84	@ 0x54
  hramcfg.Instance =  RAMCFG_SRAM5_AXI;
34001ddc:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001dde:	f007 f939 	bl	34009054 <HAL_RAMCFG_EnableAXISRAM>
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
34001de2:	4b85      	ldr	r3, [pc, #532]	@ (34001ff8 <main+0x340>)
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001de4:	a815      	add	r0, sp, #84	@ 0x54
  hramcfg.Instance =  RAMCFG_SRAM6_AXI;
34001de6:	9315      	str	r3, [sp, #84]	@ 0x54
  HAL_RAMCFG_EnableAXISRAM(&hramcfg);
34001de8:	f007 f934 	bl	34009054 <HAL_RAMCFG_EnableAXISRAM>
  Fuse_Programming();
34001dec:	f7ff fe4e 	bl	34001a8c <Fuse_Programming>
  npu_cache_init();
34001df0:	f000 fc70 	bl	340026d4 <npu_cache_init>
  npu_cache_enable();
34001df4:	f000 fc78 	bl	340026e8 <npu_cache_enable>
  PC_STREAM_Init();
34001df8:	f000 fc80 	bl	340026fc <PC_STREAM_Init>
  BSP_XSPI_RAM_Init(0);
34001dfc:	4628      	mov	r0, r5
34001dfe:	f002 fa61 	bl	340042c4 <BSP_XSPI_RAM_Init>
  BSP_XSPI_RAM_EnableMemoryMappedMode(0);
34001e02:	4628      	mov	r0, r5
34001e04:	f002 fb82 	bl	3400450c <BSP_XSPI_RAM_EnableMemoryMappedMode>
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34001e08:	f240 1301 	movw	r3, #257	@ 0x101
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34001e0c:	f44f 7800 	mov.w	r8, #512	@ 0x200
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34001e10:	a907      	add	r1, sp, #28
34001e12:	4628      	mov	r0, r5
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001e14:	2602      	movs	r6, #2
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
34001e16:	f8ad 301c 	strh.w	r3, [sp, #28]
  BSP_XSPI_NOR_Init(0, &NOR_Init);
34001e1a:	f002 f90f 	bl	3400403c <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34001e1e:	4628      	mov	r0, r5
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001e20:	2503      	movs	r5, #3
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34001e22:	f002 f879 	bl	34003f18 <BSP_XSPI_NOR_EnableMemoryMappedMode>
34001e26:	f8c4 8a58 	str.w	r8, [r4, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34001e2a:	f8d4 3258 	ldr.w	r3, [r4, #600]	@ 0x258
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34001e2e:	2001      	movs	r0, #1
34001e30:	930b      	str	r3, [sp, #44]	@ 0x2c
34001e32:	a915      	add	r1, sp, #84	@ 0x54
  (void)tmpreg;
34001e34:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34001e36:	e9cd 6515 	strd	r6, r5, [sp, #84]	@ 0x54
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34001e3a:	f00d f90f 	bl	3400f05c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34001e3e:	2008      	movs	r0, #8
34001e40:	a915      	add	r1, sp, #84	@ 0x54
34001e42:	f00d f90b 	bl	3400f05c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34001e46:	2009      	movs	r0, #9
34001e48:	a915      	add	r1, sp, #84	@ 0x54
34001e4a:	f00d f907 	bl	3400f05c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34001e4e:	200a      	movs	r0, #10
34001e50:	a915      	add	r1, sp, #84	@ 0x54
34001e52:	f00d f903 	bl	3400f05c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34001e56:	200b      	movs	r0, #11
34001e58:	a915      	add	r1, sp, #84	@ 0x54
34001e5a:	f00d f8ff 	bl	3400f05c <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e5e:	4629      	mov	r1, r5
34001e60:	4866      	ldr	r0, [pc, #408]	@ (34001ffc <main+0x344>)
34001e62:	f00d f951 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e66:	4629      	mov	r1, r5
34001e68:	4865      	ldr	r0, [pc, #404]	@ (34002000 <main+0x348>)
34001e6a:	f00d f94d 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI    , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e6e:	4629      	mov	r1, r5
34001e70:	4864      	ldr	r0, [pc, #400]	@ (34002004 <main+0x34c>)
34001e72:	f00d f949 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e76:	4629      	mov	r1, r5
34001e78:	4863      	ldr	r0, [pc, #396]	@ (34002008 <main+0x350>)
34001e7a:	f00d f945 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e7e:	4629      	mov	r1, r5
34001e80:	4862      	ldr	r0, [pc, #392]	@ (3400200c <main+0x354>)
34001e82:	f00d f941 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e86:	4629      	mov	r1, r5
34001e88:	4861      	ldr	r0, [pc, #388]	@ (34002010 <main+0x358>)
34001e8a:	f00d f93d 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34001e8e:	4629      	mov	r1, r5
34001e90:	4860      	ldr	r0, [pc, #384]	@ (34002014 <main+0x35c>)
34001e92:	f00d f939 	bl	3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34001e96:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34001e9a:	f8c4 3a58 	str.w	r3, [r4, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34001e9e:	f8d4 2258 	ldr.w	r2, [r4, #600]	@ 0x258
  __HAL_RCC_XSPI1_CLK_SLEEP_ENABLE();    /* For display frame buffer */
34001ea2:	2020      	movs	r0, #32
34001ea4:	920c      	str	r2, [sp, #48]	@ 0x30
  (void)tmpreg;
34001ea6:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001ea8:	2204      	movs	r2, #4
  WRITE_REG(RCC->AHB3RSTSR, Periphs);
34001eaa:	f8c4 3a18 	str.w	r3, [r4, #2584]	@ 0xa18
  WRITE_REG(RCC->AHB3RSTCR, Periphs);
34001eae:	f8ca 3218 	str.w	r3, [sl, #536]	@ 0x218
34001eb2:	f7ff fe7f 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_XSPI2_CLK_SLEEP_ENABLE();    /* For NN weights */
34001eb6:	4648      	mov	r0, r9
34001eb8:	f7ff fe7c 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_NPU_CLK_SLEEP_ENABLE();      /* For NN inference */
34001ebc:	4638      	mov	r0, r7
34001ebe:	f7ff fe79 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CACHEAXI_CLK_SLEEP_ENABLE(); /* For NN inference */
34001ec2:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34001ec6:	f7ff fe75 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001eca:	f8c4 6abc 	str.w	r6, [r4, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
34001ece:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE();    /* For display */
34001ed2:	4630      	mov	r0, r6
34001ed4:	930f      	str	r3, [sp, #60]	@ 0x3c
  (void)tmpreg;
34001ed6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
34001ed8:	f7ff fe6c 	bl	34001bb4 <LL_AHB5_GRP1_EnableClockLowPower>
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001edc:	f8c4 2abc 	str.w	r2, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34001ee0:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  __HAL_RCC_FLEXRAM_MEM_CLK_SLEEP_ENABLE();
34001ee4:	4640      	mov	r0, r8
34001ee6:	930e      	str	r3, [sp, #56]	@ 0x38
  (void)tmpreg;
34001ee8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34001eea:	2340      	movs	r3, #64	@ 0x40
34001eec:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34001ef0:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
34001ef4:	930d      	str	r3, [sp, #52]	@ 0x34
  (void)tmpreg;
34001ef6:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
34001ef8:	f7ff fe50 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM1_MEM_CLK_SLEEP_ENABLE();
34001efc:	2080      	movs	r0, #128	@ 0x80
34001efe:	f7ff fe4d 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM2_MEM_CLK_SLEEP_ENABLE();
34001f02:	f44f 7080 	mov.w	r0, #256	@ 0x100
34001f06:	f7ff fe49 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM3_MEM_CLK_SLEEP_ENABLE();
34001f0a:	2001      	movs	r0, #1
34001f0c:	f7ff fe46 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM4_MEM_CLK_SLEEP_ENABLE();
34001f10:	4630      	mov	r0, r6
34001f12:	f7ff fe43 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM5_MEM_CLK_SLEEP_ENABLE();
34001f16:	4610      	mov	r0, r2
34001f18:	f7ff fe40 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  __HAL_RCC_AXISRAM6_MEM_CLK_SLEEP_ENABLE(); 
34001f1c:	2008      	movs	r0, #8
34001f1e:	f7ff fe3d 	bl	34001b9c <LL_MEM_EnableClockLowPower>
  const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_Default();
34001f22:	f000 fbcb 	bl	340026bc <LL_ATON_Input_Buffers_Info_Default>
34001f26:	4604      	mov	r4, r0
  const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_Default();
34001f28:	f000 fbcc 	bl	340026c4 <LL_ATON_Output_Buffers_Info_Default>
34001f2c:	6861      	ldr	r1, [r4, #4]
34001f2e:	4602      	mov	r2, r0
    return eb->blob_address;
  }

  static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
  {
    if (buf->is_user_allocated)
34001f30:	7d20      	ldrb	r0, [r4, #20]
    {
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
      return *tmp;
    }
    return buf->addr_base.p;
34001f32:	460b      	mov	r3, r1
    if (buf->is_user_allocated)
34001f34:	b100      	cbz	r0, 34001f38 <main+0x280>
      return *tmp;
34001f36:	680b      	ldr	r3, [r1, #0]
  int number_output = 0;
34001f38:	f04f 0900 	mov.w	r9, #0
34001f3c:	2538      	movs	r5, #56	@ 0x38
  }

  static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
  {
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34001f3e:	68a0      	ldr	r0, [r4, #8]
  nn_in = (uint8_t *) LL_Buffer_addr_start(&nn_in_info[0]);
34001f40:	4935      	ldr	r1, [pc, #212]	@ (34002018 <main+0x360>)
34001f42:	4403      	add	r3, r0
34001f44:	600b      	str	r3, [r1, #0]
  while (nn_out_info[number_output].name != NULL)
34001f46:	fb05 f309 	mul.w	r3, r5, r9
34001f4a:	58d1      	ldr	r1, [r2, r3]
34001f4c:	2900      	cmp	r1, #0
34001f4e:	f040 8103 	bne.w	34002158 <main+0x4a0>
  assert(number_output <= MAX_NUMBER_OUTPUT);
34001f52:	f1b9 0f05 	cmp.w	r9, #5
34001f56:	f300 8102 	bgt.w	3400215e <main+0x4a6>
34001f5a:	4930      	ldr	r1, [pc, #192]	@ (3400201c <main+0x364>)
34001f5c:	08db      	lsrs	r3, r3, #3
34001f5e:	434b      	muls	r3, r1
34001f60:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
34001f64:	ad10      	add	r5, sp, #64	@ 0x40
34001f66:	ae15      	add	r6, sp, #84	@ 0x54
34001f68:	3301      	adds	r3, #1
  for (int i = 0; i < number_output; i++)
34001f6a:	3b01      	subs	r3, #1
34001f6c:	f040 80fd 	bne.w	3400216a <main+0x4b2>
  uint32_t pitch_nn = 0;
34001f70:	2500      	movs	r5, #0
    return LL_Buffer_addr_base(buf) + buf->offset_limit;
  }

  static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
  {
    return buf->offset_end - buf->offset_start;
34001f72:	68e3      	ldr	r3, [r4, #12]
  CAM_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
34001f74:	4c2a      	ldr	r4, [pc, #168]	@ (34002020 <main+0x368>)
34001f76:	1a1b      	subs	r3, r3, r0
  app_postprocess_init(&pp_params);
34001f78:	482a      	ldr	r0, [pc, #168]	@ (34002024 <main+0x36c>)
34001f7a:	9302      	str	r3, [sp, #8]
  uint32_t pitch_nn = 0;
34001f7c:	9508      	str	r5, [sp, #32]
  app_postprocess_init(&pp_params);
34001f7e:	f7ff fdb3 	bl	34001ae8 <app_postprocess_init>
  CAM_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
34001f82:	4621      	mov	r1, r4
34001f84:	aa08      	add	r2, sp, #32
34001f86:	1f20      	subs	r0, r4, #4
34001f88:	f7ff fce6 	bl	34001958 <CAM_Init>
  LayerConfig.X0          = lcd_bg_area.X0;
34001f8c:	f1a4 070c 	sub.w	r7, r4, #12
  BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
34001f90:	2101      	movs	r1, #1
34001f92:	4628      	mov	r0, r5
34001f94:	f001 fece 	bl	34003d34 <BSP_LCD_Init>
  LayerConfig.X0          = lcd_bg_area.X0;
34001f98:	f854 1c0c 	ldr.w	r1, [r4, #-12]
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34001f9c:	68bb      	ldr	r3, [r7, #8]
  LayerConfig.X0          = lcd_bg_area.X0;
34001f9e:	4c22      	ldr	r4, [pc, #136]	@ (34002028 <main+0x370>)
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34001fa0:	440b      	add	r3, r1
  LayerConfig.Y0          = lcd_bg_area.Y0;
34001fa2:	687a      	ldr	r2, [r7, #4]
  LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34001fa4:	6063      	str	r3, [r4, #4]
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34001fa6:	68fb      	ldr	r3, [r7, #12]
  LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34001fa8:	f8df a08c 	ldr.w	sl, [pc, #140]	@ 34002038 <main+0x380>
  LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34001fac:	4413      	add	r3, r2
34001fae:	60e3      	str	r3, [r4, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34001fb0:	2302      	movs	r3, #2
  LayerConfig.X0          = lcd_bg_area.X0;
34001fb2:	6021      	str	r1, [r4, #0]
  LayerConfig.Y0          = lcd_bg_area.Y0;
34001fb4:	60a2      	str	r2, [r4, #8]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34001fb6:	4629      	mov	r1, r5
34001fb8:	4622      	mov	r2, r4
34001fba:	4628      	mov	r0, r5
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34001fbc:	6123      	str	r3, [r4, #16]
  LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34001fbe:	f8c4 a014 	str.w	sl, [r4, #20]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34001fc2:	f001 fec3 	bl	34003d4c <BSP_LCD_ConfigLayer>
  LayerConfig.X0 = lcd_fg_area.X0;
34001fc6:	4b19      	ldr	r3, [pc, #100]	@ (3400202c <main+0x374>)
34001fc8:	6818      	ldr	r0, [r3, #0]
  LayerConfig.Y0 = lcd_fg_area.Y0;
34001fca:	6859      	ldr	r1, [r3, #4]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34001fcc:	689a      	ldr	r2, [r3, #8]
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34001fce:	68db      	ldr	r3, [r3, #12]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34001fd0:	4402      	add	r2, r0
  LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34001fd2:	440b      	add	r3, r1
34001fd4:	60e3      	str	r3, [r4, #12]
  LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34001fd6:	2304      	movs	r3, #4
34001fd8:	6123      	str	r3, [r4, #16]
  LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
34001fda:	4b15      	ldr	r3, [pc, #84]	@ (34002030 <main+0x378>)
  LayerConfig.X0 = lcd_fg_area.X0;
34001fdc:	6020      	str	r0, [r4, #0]
34001fde:	e02d      	b.n	3400203c <main+0x384>
34001fe0:	e001e000 	.word	0xe001e000
34001fe4:	56028000 	.word	0x56028000
34001fe8:	e000ed00 	.word	0xe000ed00
34001fec:	52023100 	.word	0x52023100
34001ff0:	52023180 	.word	0x52023180
34001ff4:	52023200 	.word	0x52023200
34001ff8:	52023280 	.word	0x52023280
34001ffc:	3000000a 	.word	0x3000000a
34002000:	30000005 	.word	0x30000005
34002004:	2000001c 	.word	0x2000001c
34002008:	2000001d 	.word	0x2000001d
3400200c:	30000006 	.word	0x30000006
34002010:	30000007 	.word	0x30000007
34002014:	30000008 	.word	0x30000008
34002018:	3403f428 	.word	0x3403f428
3400201c:	16db6db7 	.word	0x16db6db7
34002020:	3403eda8 	.word	0x3403eda8
34002024:	3403f430 	.word	0x3403f430
34002028:	3403f410 	.word	0x3403f410
3400202c:	3403ed8c 	.word	0x3403ed8c
34002030:	91000000 	.word	0x91000000
34002034:	56029000 	.word	0x56029000
34002038:	91177000 	.word	0x91177000
  LayerConfig.Y0 = lcd_fg_area.Y0;
3400203c:	60a1      	str	r1, [r4, #8]
  LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
3400203e:	6062      	str	r2, [r4, #4]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
34002040:	2101      	movs	r1, #1
34002042:	4622      	mov	r2, r4
34002044:	4628      	mov	r0, r5
  LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
34002046:	6163      	str	r3, [r4, #20]
  BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
34002048:	f001 fe80 	bl	34003d4c <BSP_LCD_ConfigLayer>
  UTIL_LCD_SetFuncDriver(&LCD_Driver);
3400204c:	48a2      	ldr	r0, [pc, #648]	@ (340022d8 <main+0x620>)
3400204e:	f013 f8c9 	bl	340151e4 <UTIL_LCD_SetFuncDriver>
  UTIL_LCD_SetLayer(LTDC_LAYER_2);
34002052:	2001      	movs	r0, #1
34002054:	f013 f8f6 	bl	34015244 <UTIL_LCD_SetLayer>
  UTIL_LCD_Clear(0x00000000);
34002058:	4628      	mov	r0, r5
3400205a:	f013 fb5d 	bl	34015718 <UTIL_LCD_Clear>
  UTIL_LCD_SetFont(&Font20);
3400205e:	489f      	ldr	r0, [pc, #636]	@ (340022dc <main+0x624>)
34002060:	f013 f926 	bl	340152b0 <UTIL_LCD_SetFont>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
34002064:	f04f 30ff 	mov.w	r0, #4294967295
34002068:	f013 f912 	bl	34015290 <UTIL_LCD_SetTextColor>
  CAM_DisplayPipe_Start(lcd_bg_buffer, CMW_MODE_CONTINUOUS);
3400206c:	4629      	mov	r1, r5
3400206e:	4650      	mov	r0, sl
34002070:	f7ff fcc6 	bl	34001a00 <CAM_DisplayPipe_Start>
    CAM_IspUpdate();
34002074:	f7ff fcec 	bl	34001a50 <CAM_IspUpdate>
    if (pitch_nn != (NN_WIDTH * NN_BPP))
34002078:	9b08      	ldr	r3, [sp, #32]
      CAM_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
3400207a:	2104      	movs	r1, #4
    if (pitch_nn != (NN_WIDTH * NN_BPP))
3400207c:	f5b3 7f28 	cmp.w	r3, #672	@ 0x2a0
      CAM_NNPipe_Start(dcmipp_out_nn, CMW_MODE_SNAPSHOT);
34002080:	bf14      	ite	ne
34002082:	4b97      	ldrne	r3, [pc, #604]	@ (340022e0 <main+0x628>)
      CAM_NNPipe_Start(nn_in, CMW_MODE_SNAPSHOT);
34002084:	4b97      	ldreq	r3, [pc, #604]	@ (340022e4 <main+0x62c>)
34002086:	6818      	ldr	r0, [r3, #0]
34002088:	f7ff fcce 	bl	34001a28 <CAM_NNPipe_Start>
    while (cameraFrameReceived == 0) {};
3400208c:	4b96      	ldr	r3, [pc, #600]	@ (340022e8 <main+0x630>)
3400208e:	681a      	ldr	r2, [r3, #0]
34002090:	2a00      	cmp	r2, #0
34002092:	d0fc      	beq.n	3400208e <main+0x3d6>
    cameraFrameReceived = 0;
34002094:	2200      	movs	r2, #0
34002096:	601a      	str	r2, [r3, #0]
    if (pitch_nn != (NN_WIDTH * NN_BPP))
34002098:	9b08      	ldr	r3, [sp, #32]
3400209a:	f5b3 7f28 	cmp.w	r3, #672	@ 0x2a0
3400209e:	d044      	beq.n	3400212a <main+0x472>
      SCB_InvalidateDCache_by_Addr(dcmipp_out_nn, sizeof(dcmipp_out_nn));
340020a0:	488f      	ldr	r0, [pc, #572]	@ (340022e0 <main+0x628>)
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340020a2:	6801      	ldr	r1, [r0, #0]
340020a4:	f001 021f 	and.w	r2, r1, #31
  __ASM volatile ("dsb 0xF":::"memory");
340020a8:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;

      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340020ac:	1cd3      	adds	r3, r2, #3
340020ae:	3a1c      	subs	r2, #28
340020b0:	095b      	lsrs	r3, r3, #5
340020b2:	3220      	adds	r2, #32
340020b4:	f103 0e01 	add.w	lr, r3, #1
340020b8:	bfd8      	it	le
340020ba:	f04f 0e01 	movle.w	lr, #1
340020be:	f04e e001 	dls	lr, lr
340020c2:	4c8a      	ldr	r4, [pc, #552]	@ (340022ec <main+0x634>)
340020c4:	f8c4 125c 	str.w	r1, [r4, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
340020c8:	3120      	adds	r1, #32
        op_size -= __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
340020ca:	f00f c805 	le	lr, 340020c4 <main+0x40c>
340020ce:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340020d2:	f3bf 8f6f 	isb	sy
      img_crop(dcmipp_out_nn, nn_in, pitch_nn, NN_WIDTH, NN_HEIGHT, NN_BPP);
340020d6:	23e0      	movs	r3, #224	@ 0xe0
340020d8:	2203      	movs	r2, #3
340020da:	e9cd 3200 	strd	r3, r2, [sp]
340020de:	4c81      	ldr	r4, [pc, #516]	@ (340022e4 <main+0x62c>)
340020e0:	9a08      	ldr	r2, [sp, #32]
340020e2:	6821      	ldr	r1, [r4, #0]
340020e4:	6800      	ldr	r0, [r0, #0]
340020e6:	f7ff fd33 	bl	34001b50 <img_crop>
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
340020ea:	9a02      	ldr	r2, [sp, #8]
      SCB_CleanInvalidateDCache_by_Addr(nn_in, nn_in_len);
340020ec:	6823      	ldr	r3, [r4, #0]
340020ee:	2a00      	cmp	r2, #0
340020f0:	dd1b      	ble.n	3400212a <main+0x472>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340020f2:	f003 011f 	and.w	r1, r3, #31
340020f6:	4411      	add	r1, r2
  __ASM volatile ("dsb 0xF":::"memory");
340020f8:	f3bf 8f4f 	dsb	sy

      do {
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
        op_size -=          __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
340020fc:	43da      	mvns	r2, r3
340020fe:	185c      	adds	r4, r3, r1
34002100:	4422      	add	r2, r4
34002102:	3920      	subs	r1, #32
34002104:	0952      	lsrs	r2, r2, #5
34002106:	3120      	adds	r1, #32
34002108:	f102 0e01 	add.w	lr, r2, #1
3400210c:	bfd8      	it	le
3400210e:	f04f 0e01 	movle.w	lr, #1
34002112:	f04e e001 	dls	lr, lr
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002116:	4875      	ldr	r0, [pc, #468]	@ (340022ec <main+0x634>)
34002118:	f8c0 3270 	str.w	r3, [r0, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
3400211c:	3320      	adds	r3, #32
      } while ( op_size > 0 );
3400211e:	f00f c805 	le	lr, 34002118 <main+0x460>
34002122:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002126:	f3bf 8f6f 	isb	sy
    ts[0] = HAL_GetTick();
3400212a:	f002 fbe1 	bl	340048f0 <HAL_GetTick>
3400212e:	4605      	mov	r5, r0
    LL_ATON_RT_Main(&NN_Instance_Default);
34002130:	486f      	ldr	r0, [pc, #444]	@ (340022f0 <main+0x638>)
34002132:	f014 f8a1 	bl	34016278 <LL_ATON_RT_Main>
    ts[1] = HAL_GetTick();
34002136:	f002 fbdb 	bl	340048f0 <HAL_GetTick>
    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
3400213a:	4c6e      	ldr	r4, [pc, #440]	@ (340022f4 <main+0x63c>)
    ts[1] = HAL_GetTick();
3400213c:	4606      	mov	r6, r0
    int32_t ret = app_postprocess_run((void **) nn_out, number_output, &pp_output, &pp_params);
3400213e:	4622      	mov	r2, r4
34002140:	4649      	mov	r1, r9
34002142:	4b6d      	ldr	r3, [pc, #436]	@ (340022f8 <main+0x640>)
34002144:	a810      	add	r0, sp, #64	@ 0x40
34002146:	f7ff fce9 	bl	34001b1c <app_postprocess_run>
    assert(ret == 0);
3400214a:	4680      	mov	r8, r0
3400214c:	b1e0      	cbz	r0, 34002188 <main+0x4d0>
3400214e:	f240 1107 	movw	r1, #263	@ 0x107
34002152:	4b6a      	ldr	r3, [pc, #424]	@ (340022fc <main+0x644>)
34002154:	4a6a      	ldr	r2, [pc, #424]	@ (34002300 <main+0x648>)
34002156:	e005      	b.n	34002164 <main+0x4ac>
    number_output++;
34002158:	f109 0901 	add.w	r9, r9, #1
3400215c:	e6f3      	b.n	34001f46 <main+0x28e>
  assert(number_output <= MAX_NUMBER_OUTPUT);
3400215e:	21cc      	movs	r1, #204	@ 0xcc
34002160:	4b68      	ldr	r3, [pc, #416]	@ (34002304 <main+0x64c>)
34002162:	4a67      	ldr	r2, [pc, #412]	@ (34002300 <main+0x648>)
    assert(ret == 0);
34002164:	4868      	ldr	r0, [pc, #416]	@ (34002308 <main+0x650>)
34002166:	f015 fc1b 	bl	340179a0 <__assert_func>
    if (buf->is_user_allocated)
3400216a:	7d17      	ldrb	r7, [r2, #20]
      unsigned char **tmp = (unsigned char **)buf->addr_base.p;
3400216c:	6851      	ldr	r1, [r2, #4]
    if (buf->is_user_allocated)
3400216e:	b107      	cbz	r7, 34002172 <main+0x4ba>
      return *tmp;
34002170:	6809      	ldr	r1, [r1, #0]
    return LL_Buffer_addr_base(buf) + buf->offset_start;
34002172:	6897      	ldr	r7, [r2, #8]
34002174:	3238      	adds	r2, #56	@ 0x38
34002176:	4439      	add	r1, r7
    nn_out[i] = (float32_t *) LL_Buffer_addr_start(&nn_out_info[i]);
34002178:	f845 1b04 	str.w	r1, [r5], #4
    return buf->offset_end - buf->offset_start;
3400217c:	f852 1c2c 	ldr.w	r1, [r2, #-44]
34002180:	1bc9      	subs	r1, r1, r7
    nn_out_len[i] = LL_Buffer_len(&nn_out_info[i]);
34002182:	f846 1b04 	str.w	r1, [r6], #4
  for (int i = 0; i < number_output; i++)
34002186:	e6f0      	b.n	34001f6a <main+0x2b2>
    Display_NetworkOutput(&pp_output, ts[1] - ts[0]);
34002188:	1b73      	subs	r3, r6, r5
3400218a:	9304      	str	r3, [sp, #16]
  uint32_t nb_rois = p_postprocess->nb_detect;
3400218c:	e9d4 5300 	ldrd	r5, r3, [r4]
34002190:	9303      	str	r3, [sp, #12]
  ret = HAL_LTDC_SetAddress_NoReload(&hlcd_ltdc, (uint32_t) lcd_fg_buffer[lcd_fg_buffer_rd_idx], LTDC_LAYER_2);
34002192:	4b5e      	ldr	r3, [pc, #376]	@ (3400230c <main+0x654>)
34002194:	485e      	ldr	r0, [pc, #376]	@ (34002310 <main+0x658>)
34002196:	6819      	ldr	r1, [r3, #0]
34002198:	4b5e      	ldr	r3, [pc, #376]	@ (34002314 <main+0x65c>)
3400219a:	2201      	movs	r2, #1
3400219c:	fb00 3101 	mla	r1, r0, r1, r3
340021a0:	485d      	ldr	r0, [pc, #372]	@ (34002318 <main+0x660>)
340021a2:	f006 fec5 	bl	34008f30 <HAL_LTDC_SetAddress_NoReload>
  assert(ret == HAL_OK);
340021a6:	b120      	cbz	r0, 340021b2 <main+0x4fa>
340021a8:	f240 117d 	movw	r1, #381	@ 0x17d
340021ac:	4b5b      	ldr	r3, [pc, #364]	@ (3400231c <main+0x664>)
340021ae:	4a5c      	ldr	r2, [pc, #368]	@ (34002320 <main+0x668>)
340021b0:	e7d8      	b.n	34002164 <main+0x4ac>
  UTIL_LCD_FillRect(lcd_fg_area.X0, lcd_fg_area.Y0, lcd_fg_area.XSize, lcd_fg_area.YSize, 0x00000000); /* Clear previous boxes */
340021b2:	485c      	ldr	r0, [pc, #368]	@ (34002324 <main+0x66c>)
340021b4:	f8cd 8000 	str.w	r8, [sp]
340021b8:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
340021bc:	e9d0 0100 	ldrd	r0, r1, [r0]
340021c0:	f013 fa6a 	bl	34015698 <UTIL_LCD_FillRect>
  for (int32_t i = 0; i < nb_rois; i++)
340021c4:	46c3      	mov	fp, r8
340021c6:	9b03      	ldr	r3, [sp, #12]
340021c8:	455b      	cmp	r3, fp
340021ca:	f040 80bf 	bne.w	3400234c <main+0x694>
  UTIL_LCD_SetBackColor(0x40000000);
340021ce:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
340021d2:	f013 f865 	bl	340152a0 <UTIL_LCD_SetBackColor>
  UTIL_LCDEx_PrintfAt(0, LINE(2), CENTER_MODE, "Objects %u", nb_rois);
340021d6:	f013 f873 	bl	340152c0 <UTIL_LCD_GetFont>
340021da:	2201      	movs	r2, #1
340021dc:	88c1      	ldrh	r1, [r0, #6]
340021de:	9b03      	ldr	r3, [sp, #12]
340021e0:	4091      	lsls	r1, r2
340021e2:	2000      	movs	r0, #0
340021e4:	9300      	str	r3, [sp, #0]
340021e6:	4b50      	ldr	r3, [pc, #320]	@ (34002328 <main+0x670>)
340021e8:	f000 fb52 	bl	34002890 <UTIL_LCDEx_PrintfAt>
  UTIL_LCDEx_PrintfAt(0, LINE(20), CENTER_MODE, "Inference: %ums", inference_ms);
340021ec:	f013 f868 	bl	340152c0 <UTIL_LCD_GetFont>
340021f0:	88c1      	ldrh	r1, [r0, #6]
340021f2:	2014      	movs	r0, #20
340021f4:	9b04      	ldr	r3, [sp, #16]
340021f6:	4341      	muls	r1, r0
340021f8:	2201      	movs	r2, #1
340021fa:	2000      	movs	r0, #0
340021fc:	9300      	str	r3, [sp, #0]
  if (t0 == 0)
340021fe:	4c4b      	ldr	r4, [pc, #300]	@ (3400232c <main+0x674>)
  UTIL_LCDEx_PrintfAt(0, LINE(20), CENTER_MODE, "Inference: %ums", inference_ms);
34002200:	4b4b      	ldr	r3, [pc, #300]	@ (34002330 <main+0x678>)
34002202:	f000 fb45 	bl	34002890 <UTIL_LCDEx_PrintfAt>
  UTIL_LCD_SetBackColor(0);
34002206:	2000      	movs	r0, #0
34002208:	f013 f84a 	bl	340152a0 <UTIL_LCD_SetBackColor>
  if (t0 == 0)
3400220c:	6823      	ldr	r3, [r4, #0]
3400220e:	b913      	cbnz	r3, 34002216 <main+0x55e>
    t0 = HAL_GetTick();
34002210:	f002 fb6e 	bl	340048f0 <HAL_GetTick>
34002214:	6020      	str	r0, [r4, #0]
  if (HAL_GetTick() - t0 < 4000)
34002216:	f002 fb6b 	bl	340048f0 <HAL_GetTick>
3400221a:	6823      	ldr	r3, [r4, #0]
3400221c:	1ac0      	subs	r0, r0, r3
3400221e:	f5b0 6f7a 	cmp.w	r0, #4000	@ 0xfa0
34002222:	d22c      	bcs.n	3400227e <main+0x5c6>
    UTIL_LCD_FillRGBRect(300, 100, (uint8_t *) stlogo, 200, 107);
34002224:	236b      	movs	r3, #107	@ 0x6b
34002226:	2164      	movs	r1, #100	@ 0x64
34002228:	4a42      	ldr	r2, [pc, #264]	@ (34002334 <main+0x67c>)
3400222a:	f44f 7096 	mov.w	r0, #300	@ 0x12c
3400222e:	9300      	str	r3, [sp, #0]
34002230:	23c8      	movs	r3, #200	@ 0xc8
34002232:	f013 f84d 	bl	340152d0 <UTIL_LCD_FillRGBRect>
    UTIL_LCD_SetBackColor(0x40000000);
34002236:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3400223a:	f013 f831 	bl	340152a0 <UTIL_LCD_SetBackColor>
    UTIL_LCDEx_PrintfAt(0, LINE(16), CENTER_MODE, "Object detection");
3400223e:	f013 f83f 	bl	340152c0 <UTIL_LCD_GetFont>
34002242:	88c1      	ldrh	r1, [r0, #6]
34002244:	2201      	movs	r2, #1
34002246:	4b3c      	ldr	r3, [pc, #240]	@ (34002338 <main+0x680>)
34002248:	0109      	lsls	r1, r1, #4
3400224a:	2000      	movs	r0, #0
3400224c:	f000 fb20 	bl	34002890 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, LINE(17), CENTER_MODE, WELCOME_MSG_1);
34002250:	f013 f836 	bl	340152c0 <UTIL_LCD_GetFont>
34002254:	88c1      	ldrh	r1, [r0, #6]
34002256:	2201      	movs	r2, #1
34002258:	4b38      	ldr	r3, [pc, #224]	@ (3400233c <main+0x684>)
3400225a:	eb01 1101 	add.w	r1, r1, r1, lsl #4
3400225e:	2000      	movs	r0, #0
34002260:	f000 fb16 	bl	34002890 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(0, LINE(18), CENTER_MODE, WELCOME_MSG_2);
34002264:	f013 f82c 	bl	340152c0 <UTIL_LCD_GetFont>
34002268:	88c1      	ldrh	r1, [r0, #6]
3400226a:	2012      	movs	r0, #18
3400226c:	2201      	movs	r2, #1
3400226e:	4341      	muls	r1, r0
34002270:	4b33      	ldr	r3, [pc, #204]	@ (34002340 <main+0x688>)
34002272:	2000      	movs	r0, #0
34002274:	f000 fb0c 	bl	34002890 <UTIL_LCDEx_PrintfAt>
    UTIL_LCD_SetBackColor(0);
34002278:	2000      	movs	r0, #0
3400227a:	f013 f811 	bl	340152a0 <UTIL_LCD_SetBackColor>
  __ASM volatile ("dsb 0xF":::"memory");
3400227e:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002282:	f645 5ec0 	movw	lr, #24000	@ 0x5dc0
}
34002286:	2300      	movs	r3, #0
34002288:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400228c:	4a17      	ldr	r2, [pc, #92]	@ (340022ec <main+0x634>)
3400228e:	eb03 010a 	add.w	r1, r3, sl
34002292:	f8c2 125c 	str.w	r1, [r2, #604]	@ 0x25c
      } while ( op_size > 0 );
34002296:	3320      	adds	r3, #32
34002298:	f00f c807 	le	lr, 3400228e <main+0x5d6>
  __ASM volatile ("dsb 0xF":::"memory");
3400229c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340022a0:	f3bf 8f6f 	isb	sy
   PC_STREAM_SendFrame(lcd_bg_buffer, lcd_bg_area.XSize, lcd_bg_area.YSize, 2);
340022a4:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
340022a8:	2302      	movs	r3, #2
340022aa:	4826      	ldr	r0, [pc, #152]	@ (34002344 <main+0x68c>)
340022ac:	f000 fa2c 	bl	34002708 <PC_STREAM_SendFrame>
   PC_STREAM_SendDetections(p_postprocess, stream_frame_id++);
340022b0:	4b25      	ldr	r3, [pc, #148]	@ (34002348 <main+0x690>)
340022b2:	4810      	ldr	r0, [pc, #64]	@ (340022f4 <main+0x63c>)
340022b4:	6819      	ldr	r1, [r3, #0]
340022b6:	1c4a      	adds	r2, r1, #1
340022b8:	601a      	str	r2, [r3, #0]
340022ba:	f000 fa8b 	bl	340027d4 <PC_STREAM_SendDetections>
  ret = HAL_LTDC_ReloadLayer(&hlcd_ltdc, LTDC_RELOAD_VERTICAL_BLANKING, LTDC_LAYER_2);
340022be:	2201      	movs	r2, #1
340022c0:	2102      	movs	r1, #2
340022c2:	4815      	ldr	r0, [pc, #84]	@ (34002318 <main+0x660>)
340022c4:	f006 fe0c 	bl	34008ee0 <HAL_LTDC_ReloadLayer>
  assert(ret == HAL_OK);
340022c8:	2800      	cmp	r0, #0
340022ca:	f000 80bc 	beq.w	34002446 <main+0x78e>
340022ce:	f240 11a3 	movw	r1, #419	@ 0x1a3
340022d2:	4b12      	ldr	r3, [pc, #72]	@ (3400231c <main+0x664>)
340022d4:	4a12      	ldr	r2, [pc, #72]	@ (34002320 <main+0x668>)
340022d6:	e745      	b.n	34002164 <main+0x4ac>
340022d8:	34034fbc 	.word	0x34034fbc
340022dc:	3403eed8 	.word	0x3403eed8
340022e0:	3403f404 	.word	0x3403f404
340022e4:	3403f428 	.word	0x3403f428
340022e8:	3403f42c 	.word	0x3403f42c
340022ec:	e000ed00 	.word	0xe000ed00
340022f0:	3403ed5c 	.word	0x3403ed5c
340022f4:	3403f408 	.word	0x3403f408
340022f8:	3403f430 	.word	0x3403f430
340022fc:	3401bf23 	.word	0x3401bf23
34002300:	3401e940 	.word	0x3401e940
34002304:	3401becc 	.word	0x3401becc
34002308:	3401beef 	.word	0x3401beef
3400230c:	3403f400 	.word	0x3403f400
34002310:	000bb800 	.word	0x000bb800
34002314:	91000000 	.word	0x91000000
34002318:	34057738 	.word	0x34057738
3400231c:	3401be71 	.word	0x3401be71
34002320:	3401e8fc 	.word	0x3401e8fc
34002324:	3403ed8c 	.word	0x3403ed8c
34002328:	3401bf33 	.word	0x3401bf33
3400232c:	3403f3f8 	.word	0x3403f3f8
34002330:	3401bf3e 	.word	0x3401bf3e
34002334:	3401e970 	.word	0x3401e970
34002338:	3401bf4e 	.word	0x3401bf4e
3400233c:	3401bf5f 	.word	0x3401bf5f
34002340:	3401bf82 	.word	0x3401bf82
34002344:	91177000 	.word	0x91177000
34002348:	3403f3fc 	.word	0x3403f3fc
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
3400234c:	edd5 6a02 	vldr	s13, [r5, #8]
34002350:	edd5 7a00 	vldr	s15, [r5]
34002354:	ed97 7a02 	vldr	s14, [r7, #8]
34002358:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
3400235c:	eef8 5a47 	vcvt.f32.u32	s11, s14
34002360:	eee6 7ac6 	vfms.f32	s15, s13, s12
34002364:	ee67 7aa5 	vmul.f32	s15, s15, s11
34002368:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
3400236c:	ed95 7a01 	vldr	s14, [r5, #4]
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
34002370:	ee17 4a90 	vmov	r4, s15
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
34002374:	edd5 7a03 	vldr	s15, [r5, #12]
34002378:	eea7 7ac6 	vfms.f32	s14, s15, s12
3400237c:	ed97 6a03 	vldr	s12, [r7, #12]
34002380:	eeb8 6a46 	vcvt.f32.u32	s12, s12
34002384:	ee27 7a06 	vmul.f32	s14, s14, s12
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002388:	ee66 6aa5 	vmul.f32	s13, s13, s11
    uint32_t y0 = (uint32_t) ((rois[i].y_center - rois[i].height / 2) * ((float32_t) lcd_bg_area.YSize));
3400238c:	eebc 7ac7 	vcvt.u32.f32	s14, s14
34002390:	ee17 1a10 	vmov	r1, s14
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
34002394:	eebc 7ae6 	vcvt.u32.f32	s14, s13
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
34002398:	ee67 7a86 	vmul.f32	s15, s15, s12
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
3400239c:	6838      	ldr	r0, [r7, #0]
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
3400239e:	68bb      	ldr	r3, [r7, #8]
    uint32_t x0 = (uint32_t) ((rois[i].x_center - rois[i].width / 2) * ((float32_t) lcd_bg_area.XSize)) + lcd_bg_area.X0;
340023a0:	4404      	add	r4, r0
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023a2:	4418      	add	r0, r3
340023a4:	f100 3eff 	add.w	lr, r0, #4294967295
340023a8:	4284      	cmp	r4, r0
    uint32_t width = (uint32_t) (rois[i].width * ((float32_t) lcd_bg_area.XSize));
340023aa:	ee17 6a10 	vmov	r6, s14
    x0 = x0 < lcd_bg_area.X0 + lcd_bg_area.XSize ? x0 : lcd_bg_area.X0 + lcd_bg_area.XSize - 1;
340023ae:	bf28      	it	cs
340023b0:	4674      	movcs	r4, lr
    uint32_t height = (uint32_t) (rois[i].height * ((float32_t) lcd_bg_area.YSize));
340023b2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023b6:	68fb      	ldr	r3, [r7, #12]
340023b8:	687a      	ldr	r2, [r7, #4]
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
340023ba:	ebae 0e04 	sub.w	lr, lr, r4
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023be:	441a      	add	r2, r3
340023c0:	4291      	cmp	r1, r2
340023c2:	f102 3cff 	add.w	ip, r2, #4294967295
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
340023c6:	eb06 0304 	add.w	r3, r6, r4
    y0 = y0 < lcd_bg_area.Y0 + lcd_bg_area.YSize ? y0 : lcd_bg_area.Y0 + lcd_bg_area.YSize  - 1;
340023ca:	bf28      	it	cs
340023cc:	4661      	movcs	r1, ip
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
340023ce:	4298      	cmp	r0, r3
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
340023d0:	ee17 3a90 	vmov	r3, s15
340023d4:	eb03 0001 	add.w	r0, r3, r1
    width = ((x0 + width) < lcd_bg_area.X0 + lcd_bg_area.XSize) ? width : (lcd_bg_area.X0 + lcd_bg_area.XSize - x0 - 1);
340023d8:	bf98      	it	ls
340023da:	4676      	movls	r6, lr
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
340023dc:	4282      	cmp	r2, r0
    UTIL_LCD_DrawRect(x0, y0, width, height, colors[rois[i].class_index % NUMBER_COLORS]);
340023de:	f04f 000a 	mov.w	r0, #10
340023e2:	696a      	ldr	r2, [r5, #20]
340023e4:	4b2f      	ldr	r3, [pc, #188]	@ (340024a4 <main+0x7ec>)
340023e6:	fb92 fef0 	sdiv	lr, r2, r0
340023ea:	fb00 221e 	mls	r2, r0, lr, r2
340023ee:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    height = ((y0 + height) < lcd_bg_area.Y0 + lcd_bg_area.YSize) ? height : (lcd_bg_area.Y0 + lcd_bg_area.YSize - y0 - 1);
340023f2:	ebac 0c01 	sub.w	ip, ip, r1
    UTIL_LCD_DrawRect(x0, y0, width, height, colors[rois[i].class_index % NUMBER_COLORS]);
340023f6:	ee17 3a90 	vmov	r3, s15
340023fa:	4620      	mov	r0, r4
340023fc:	bf98      	it	ls
340023fe:	4663      	movls	r3, ip
34002400:	9200      	str	r2, [sp, #0]
34002402:	4632      	mov	r2, r6
34002404:	9105      	str	r1, [sp, #20]
34002406:	f013 f925 	bl	34015654 <UTIL_LCD_DrawRect>
    UTIL_LCDEx_PrintfAt(x0, y0, LEFT_MODE, classes_table[rois[i].class_index]);
3400240a:	696a      	ldr	r2, [r5, #20]
3400240c:	4b26      	ldr	r3, [pc, #152]	@ (340024a8 <main+0x7f0>)
3400240e:	4620      	mov	r0, r4
34002410:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34002414:	9905      	ldr	r1, [sp, #20]
34002416:	2203      	movs	r2, #3
34002418:	f000 fa3a 	bl	34002890 <UTIL_LCDEx_PrintfAt>
    UTIL_LCDEx_PrintfAt(-x0-width, y0, RIGHT_MODE, "%.0f%%", rois[i].conf*100.0f);
3400241c:	ed95 7a04 	vldr	s14, [r5, #16]
34002420:	eddf 7a22 	vldr	s15, [pc, #136]	@ 340024ac <main+0x7f4>
34002424:	ee27 7a27 	vmul.f32	s14, s14, s15
34002428:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400242c:	19a0      	adds	r0, r4, r6
3400242e:	ed8d 7b00 	vstr	d7, [sp]
34002432:	2202      	movs	r2, #2
34002434:	4b1e      	ldr	r3, [pc, #120]	@ (340024b0 <main+0x7f8>)
34002436:	9905      	ldr	r1, [sp, #20]
34002438:	4240      	negs	r0, r0
3400243a:	f000 fa29 	bl	34002890 <UTIL_LCDEx_PrintfAt>
  for (int32_t i = 0; i < nb_rois; i++)
3400243e:	f10b 0b01 	add.w	fp, fp, #1
34002442:	3518      	adds	r5, #24
34002444:	e6bf      	b.n	340021c6 <main+0x50e>
  lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
34002446:	4a1b      	ldr	r2, [pc, #108]	@ (340024b4 <main+0x7fc>)
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002448:	4c1b      	ldr	r4, [pc, #108]	@ (340024b8 <main+0x800>)
3400244a:	6813      	ldr	r3, [r2, #0]
}
3400244c:	a915      	add	r1, sp, #84	@ 0x54
  lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
3400244e:	f1c3 0301 	rsb	r3, r3, #1
34002452:	6013      	str	r3, [r2, #0]
      float32_t *tmp = nn_out[i];
34002454:	a810      	add	r0, sp, #64	@ 0x40
    for (int i = 0; i < number_output; i++)
34002456:	45c1      	cmp	r9, r8
34002458:	f43f ae0c 	beq.w	34002074 <main+0x3bc>
      SCB_InvalidateDCache_by_Addr(tmp, nn_out_len[i]);
3400245c:	f851 2b04 	ldr.w	r2, [r1], #4
    if ( dsize > 0 ) {
34002460:	2a00      	cmp	r2, #0
34002462:	dd1c      	ble.n	3400249e <main+0x7e6>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002464:	f850 3028 	ldr.w	r3, [r0, r8, lsl #2]
34002468:	f003 051f 	and.w	r5, r3, #31
3400246c:	4415      	add	r5, r2
  __ASM volatile ("dsb 0xF":::"memory");
3400246e:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
34002472:	43da      	mvns	r2, r3
34002474:	195e      	adds	r6, r3, r5
34002476:	4432      	add	r2, r6
34002478:	3d20      	subs	r5, #32
3400247a:	0952      	lsrs	r2, r2, #5
3400247c:	3520      	adds	r5, #32
3400247e:	f102 0e01 	add.w	lr, r2, #1
34002482:	bfd8      	it	le
34002484:	f04f 0e01 	movle.w	lr, #1
34002488:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3400248c:	f8c4 325c 	str.w	r3, [r4, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34002490:	3320      	adds	r3, #32
      } while ( op_size > 0 );
34002492:	f00f c805 	le	lr, 3400248c <main+0x7d4>
34002496:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
3400249a:	f3bf 8f6f 	isb	sy
    for (int i = 0; i < number_output; i++)
3400249e:	f108 0801 	add.w	r8, r8, #1
340024a2:	e7d8      	b.n	34002456 <main+0x79e>
340024a4:	3401e948 	.word	0x3401e948
340024a8:	3403edac 	.word	0x3403edac
340024ac:	42c80000 	.word	0x42c80000
340024b0:	3401bf2c 	.word	0x3401bf2c
340024b4:	3403f400 	.word	0x3403f400
340024b8:	e000ed00 	.word	0xe000ed00

340024bc <IAC_IRQHandler>:
  while (1)
340024bc:	e7fe      	b.n	340024bc <IAC_IRQHandler>

340024be <MX_DCMIPP_ClockConfig>:
{
340024be:	b500      	push	{lr}
340024c0:	b0e5      	sub	sp, #404	@ 0x194
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
340024c2:	f44f 72c8 	mov.w	r2, #400	@ 0x190
340024c6:	2100      	movs	r1, #0
340024c8:	4668      	mov	r0, sp
340024ca:	f016 fbcb 	bl	34018c64 <memset>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP;
340024ce:	2300      	movs	r3, #0
340024d0:	2210      	movs	r2, #16
340024d2:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
340024d6:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
340024da:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
  RCC_PeriphCLKInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
340024de:	9332      	str	r3, [sp, #200]	@ 0xc8
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
340024e0:	2303      	movs	r3, #3
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024e2:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
340024e4:	e9cd 1322 	strd	r1, r3, [sp, #136]	@ 0x88
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024e8:	f007 ff8a 	bl	3400a400 <HAL_RCCEx_PeriphCLKConfig>
  if (ret)
340024ec:	b948      	cbnz	r0, 34002502 <MX_DCMIPP_ClockConfig+0x44>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CSI;
340024ee:	2300      	movs	r3, #0
340024f0:	2208      	movs	r2, #8
340024f2:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockDivider = 40;
340024f6:	2328      	movs	r3, #40	@ 0x28
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL1;
340024f8:	9024      	str	r0, [sp, #144]	@ 0x90
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024fa:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC18].ClockDivider = 40;
340024fc:	9325      	str	r3, [sp, #148]	@ 0x94
  ret = HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct);
340024fe:	f007 ff7f 	bl	3400a400 <HAL_RCCEx_PeriphCLKConfig>
}
34002502:	b065      	add	sp, #404	@ 0x194
34002504:	f85d fb04 	ldr.w	pc, [sp], #4

34002508 <HAL_CACHEAXI_MspInit>:

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34002508:	b507      	push	{r0, r1, r2, lr}
  WRITE_REG(RCC->AHB5ENSR, Periphs);
3400250a:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
  __HAL_RCC_CACHEAXIRAM_MEM_CLK_ENABLE();
3400250e:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34002512:	f7ff fb37 	bl	34001b84 <LL_MEM_EnableClock>
34002516:	4b08      	ldr	r3, [pc, #32]	@ (34002538 <HAL_CACHEAXI_MspInit+0x30>)
34002518:	f8c3 2a60 	str.w	r2, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
3400251c:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
34002520:	9101      	str	r1, [sp, #4]
  (void)tmpreg;
34002522:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34002524:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34002528:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400252c:	f8c3 2220 	str.w	r2, [r3, #544]	@ 0x220
  __HAL_RCC_CACHEAXI_CLK_ENABLE();
  __HAL_RCC_CACHEAXI_FORCE_RESET();
  __HAL_RCC_CACHEAXI_RELEASE_RESET();
}
34002530:	b003      	add	sp, #12
34002532:	f85d fb04 	ldr.w	pc, [sp], #4
34002536:	bf00      	nop
34002538:	56028000 	.word	0x56028000

3400253c <assert_failed>:
  */
void assert_failed(uint8_t* file, uint32_t line)
{
  UNUSED(file);
  UNUSED(line);
  __BKPT(0);
3400253c:	be00      	bkpt	0x0000
  while (1)
3400253e:	e7fe      	b.n	3400253e <assert_failed+0x2>

34002540 <mcu_cache_invalidate_range>:
  }  
  return 0;
}

int mcu_cache_invalidate_range(uint32_t start_addr, uint32_t end_addr) 
{
34002540:	b530      	push	{r4, r5, lr}

#include "stm32n6xx_hal.h"

__STATIC_FORCEINLINE int mcu_cache_enabled(void) {
#if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
34002542:	4d13      	ldr	r5, [pc, #76]	@ (34002590 <mcu_cache_invalidate_range+0x50>)
34002544:	696b      	ldr	r3, [r5, #20]
34002546:	03db      	lsls	r3, r3, #15
34002548:	d51f      	bpl.n	3400258a <mcu_cache_invalidate_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_InvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
3400254a:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
3400254c:	2a00      	cmp	r2, #0
3400254e:	dd1c      	ble.n	3400258a <mcu_cache_invalidate_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002550:	f000 031f 	and.w	r3, r0, #31
34002554:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
34002556:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
3400255a:	1884      	adds	r4, r0, r2
3400255c:	43c2      	mvns	r2, r0
3400255e:	1a1b      	subs	r3, r3, r0
34002560:	440b      	add	r3, r1
34002562:	4422      	add	r2, r4
34002564:	3b20      	subs	r3, #32
34002566:	0952      	lsrs	r2, r2, #5
34002568:	3320      	adds	r3, #32
3400256a:	f102 0e01 	add.w	lr, r2, #1
3400256e:	bfd8      	it	le
34002570:	f04f 0e01 	movle.w	lr, #1
34002574:	f04e e001 	dls	lr, lr
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002578:	f8c5 025c 	str.w	r0, [r5, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
3400257c:	3020      	adds	r0, #32
      } while ( op_size > 0 );
3400257e:	f00f c805 	le	lr, 34002578 <mcu_cache_invalidate_range+0x38>
34002582:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34002586:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
3400258a:	2000      	movs	r0, #0
3400258c:	bd30      	pop	{r4, r5, pc}
3400258e:	bf00      	nop
34002590:	e000ed00 	.word	0xe000ed00

34002594 <mcu_cache_clean_range>:

int mcu_cache_clean_range(uint32_t start_addr, uint32_t end_addr) {
34002594:	b530      	push	{r4, r5, lr}
34002596:	4d13      	ldr	r5, [pc, #76]	@ (340025e4 <mcu_cache_clean_range+0x50>)
34002598:	696b      	ldr	r3, [r5, #20]
3400259a:	03db      	lsls	r3, r3, #15
3400259c:	d51f      	bpl.n	340025de <mcu_cache_clean_range+0x4a>
  if(mcu_cache_enabled()) {
    SCB_CleanDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
3400259e:	1a0a      	subs	r2, r1, r0
    if ( dsize > 0 ) {
340025a0:	2a00      	cmp	r2, #0
340025a2:	dd1c      	ble.n	340025de <mcu_cache_clean_range+0x4a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340025a4:	f000 031f 	and.w	r3, r0, #31
340025a8:	441a      	add	r2, r3
  __ASM volatile ("dsb 0xF":::"memory");
340025aa:	f3bf 8f4f 	dsb	sy
      } while ( op_size > 0 );
340025ae:	1884      	adds	r4, r0, r2
340025b0:	43c2      	mvns	r2, r0
340025b2:	1a1b      	subs	r3, r3, r0
340025b4:	440b      	add	r3, r1
340025b6:	4422      	add	r2, r4
340025b8:	3b20      	subs	r3, #32
340025ba:	0952      	lsrs	r2, r2, #5
340025bc:	3320      	adds	r3, #32
340025be:	f102 0e01 	add.w	lr, r2, #1
340025c2:	bfd8      	it	le
340025c4:	f04f 0e01 	movle.w	lr, #1
340025c8:	f04e e001 	dls	lr, lr
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340025cc:	f8c5 0268 	str.w	r0, [r5, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340025d0:	3020      	adds	r0, #32
      } while ( op_size > 0 );
340025d2:	f00f c805 	le	lr, 340025cc <mcu_cache_clean_range+0x38>
340025d6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340025da:	f3bf 8f6f 	isb	sy
  }
  return 0;
}
340025de:	2000      	movs	r0, #0
340025e0:	bd30      	pop	{r4, r5, pc}
340025e2:	bf00      	nop
340025e4:	e000ed00 	.word	0xe000ed00

340025e8 <_ec_blob_cache_start_func_1>:
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26560) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 28032) */
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26560) /* Equivalent hex address = 0x342e67c0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 28032) /* Equivalent hex address = 0x342e6d80UL */);
340025e8:	4901      	ldr	r1, [pc, #4]	@ (340025f0 <_ec_blob_cache_start_func_1+0x8>)
340025ea:	4802      	ldr	r0, [pc, #8]	@ (340025f4 <_ec_blob_cache_start_func_1+0xc>)
340025ec:	f7ff bfa8 	b.w	34002540 <mcu_cache_invalidate_range>
340025f0:	342e6d80 	.word	0x342e6d80
340025f4:	342e67c0 	.word	0x342e67c0

340025f8 <LL_ATON_End_EpochBlock_20>:


/* scheduling epoch=20   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_20(const void *epoch_block)
{
340025f8:	b530      	push	{r4, r5, lr}
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) */
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856) /* Equivalent hex address = 0x342e16e0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) /* Equivalent hex address = 0x342e1700UL */);
340025fa:	4d23      	ldr	r5, [pc, #140]	@ (34002688 <LL_ATON_End_EpochBlock_20+0x90>)
{
340025fc:	b0af      	sub	sp, #188	@ 0xbc
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5856) /* Equivalent hex address = 0x342e16e0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) /* Equivalent hex address = 0x342e1700UL */);
340025fe:	4629      	mov	r1, r5
34002600:	4822      	ldr	r0, [pc, #136]	@ (3400268c <LL_ATON_End_EpochBlock_20+0x94>)
34002602:	f7ff ff9d 	bl	34002540 <mcu_cache_invalidate_range>
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=Dequantize_54 */
  Dequantizelinear_sw_info dequantizelinear1_sw_info = {
34002606:	22b4      	movs	r2, #180	@ 0xb4
34002608:	2100      	movs	r1, #0
3400260a:	a801      	add	r0, sp, #4
3400260c:	f016 fb2a 	bl	34018c64 <memset>
34002610:	24d2      	movs	r4, #210	@ 0xd2
34002612:	f240 51be 	movw	r1, #1470	@ 0x5be
34002616:	2207      	movs	r2, #7
34002618:	232a      	movs	r3, #42	@ 0x2a
3400261a:	201e      	movs	r0, #30
3400261c:	e9cd 1406 	strd	r1, r4, [sp, #24]
34002620:	e9cd 2202 	strd	r2, r2, [sp, #8]
34002624:	e9cd 220d 	strd	r2, r2, [sp, #52]	@ 0x34
34002628:	f88d 3004 	strb.w	r3, [sp, #4]
3400262c:	910a      	str	r1, [sp, #40]	@ 0x28
3400262e:	2301      	movs	r3, #1
34002630:	9111      	str	r1, [sp, #68]	@ 0x44
34002632:	2278      	movs	r2, #120	@ 0x78
34002634:	f44f 7152 	mov.w	r1, #840	@ 0x348
34002638:	e9cd 0304 	strd	r0, r3, [sp, #16]
3400263c:	e9cd 0308 	strd	r0, r3, [sp, #32]
34002640:	e9cd 030f 	strd	r0, r3, [sp, #60]	@ 0x3c
34002644:	e9cd 1212 	strd	r1, r2, [sp, #72]	@ 0x48
34002648:	2004      	movs	r0, #4
3400264a:	f241 62f8 	movw	r2, #5880	@ 0x16f8
3400264e:	4c10      	ldr	r4, [pc, #64]	@ (34002690 <LL_ATON_End_EpochBlock_20+0x98>)
34002650:	e9cd 0214 	strd	r0, r2, [sp, #80]	@ 0x50
34002654:	4a0f      	ldr	r2, [pc, #60]	@ (34002694 <LL_ATON_End_EpochBlock_20+0x9c>)
34002656:	940b      	str	r4, [sp, #44]	@ 0x2c
34002658:	4c0f      	ldr	r4, [pc, #60]	@ (34002698 <LL_ATON_End_EpochBlock_20+0xa0>)
3400265a:	9221      	str	r2, [sp, #132]	@ 0x84
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Dequantize_54 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear1_sw_info);
3400265c:	a801      	add	r0, sp, #4
  Dequantizelinear_sw_info dequantizelinear1_sw_info = {
3400265e:	3230      	adds	r2, #48	@ 0x30
34002660:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
34002664:	f88d 305c 	strb.w	r3, [sp, #92]	@ 0x5c
34002668:	931c      	str	r3, [sp, #112]	@ 0x70
3400266a:	f88d 3088 	strb.w	r3, [sp, #136]	@ 0x88
3400266e:	9327      	str	r3, [sp, #156]	@ 0x9c
34002670:	922c      	str	r2, [sp, #176]	@ 0xb0
34002672:	f88d 30b4 	strb.w	r3, [sp, #180]	@ 0xb4
34002676:	9416      	str	r4, [sp, #88]	@ 0x58
  ll_sw_forward_dequantizelinear(&dequantizelinear1_sw_info);
34002678:	f014 fa64 	bl	34016b44 <ll_sw_forward_dequantizelinear>
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) */
  mcu_cache_clean_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0) /* Equivalent hex address = 0x342e0000UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5888) /* Equivalent hex address = 0x342e1700UL */);
3400267c:	4629      	mov	r1, r5
3400267e:	4620      	mov	r0, r4
34002680:	f7ff ff88 	bl	34002594 <mcu_cache_clean_range>
#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)

  // Un-lock MCU cache
  LL_ATON_UNLOCK_MCU_CACHE();

}
34002684:	b02f      	add	sp, #188	@ 0xbc
34002686:	bd30      	pop	{r4, r5, pc}
34002688:	342e1700 	.word	0x342e1700
3400268c:	342e16e0 	.word	0x342e16e0
34002690:	342e67c0 	.word	0x342e67c0
34002694:	70e0d3e0 	.word	0x70e0d3e0
34002698:	342e0000 	.word	0x342e0000

3400269c <LL_ATON_Set_User_Input_Buffer_Default>:
}
3400269c:	2003      	movs	r0, #3
3400269e:	4770      	bx	lr

340026a0 <LL_ATON_Get_User_Input_Buffer_Default>:
}
340026a0:	2000      	movs	r0, #0
340026a2:	4770      	bx	lr

340026a4 <LL_ATON_Set_User_Output_Buffer_Default>:
LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
340026a4:	2003      	movs	r0, #3
340026a6:	4770      	bx	lr

340026a8 <LL_ATON_Get_User_Output_Buffer_Default>:
void *LL_ATON_Get_User_Output_Buffer_Default(uint32_t num)
340026a8:	2000      	movs	r0, #0
340026aa:	4770      	bx	lr

340026ac <LL_ATON_EC_Network_Init_Default>:
bool LL_ATON_EC_Network_Init_Default(void)
{


  return true;
}
340026ac:	2001      	movs	r0, #1
340026ae:	4770      	bx	lr

340026b0 <LL_ATON_EC_Inference_Init_Default>:

// this function should be called before each inference
bool LL_ATON_EC_Inference_Init_Default(void)
340026b0:	2001      	movs	r0, #1
340026b2:	4770      	bx	lr

340026b4 <LL_ATON_EpochBlockItems_Default>:
    },
  };


  return ll_atonn_rt_epoch_block_array;
}
340026b4:	4800      	ldr	r0, [pc, #0]	@ (340026b8 <LL_ATON_EpochBlockItems_Default+0x4>)
340026b6:	4770      	bx	lr
340026b8:	34029a50 	.word	0x34029a50

340026bc <LL_ATON_Input_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
340026bc:	4800      	ldr	r0, [pc, #0]	@ (340026c0 <LL_ATON_Input_Buffers_Info_Default+0x4>)
340026be:	4770      	bx	lr
340026c0:	340299e0 	.word	0x340299e0

340026c4 <LL_ATON_Output_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
340026c4:	4800      	ldr	r0, [pc, #0]	@ (340026c8 <LL_ATON_Output_Buffers_Info_Default+0x4>)
340026c6:	4770      	bx	lr
340026c8:	34029948 	.word	0x34029948

340026cc <LL_ATON_Internal_Buffers_Info_Default>:
      .name = NULL,
    }
  };

  return buff_info;
}
340026cc:	4800      	ldr	r0, [pc, #0]	@ (340026d0 <LL_ATON_Internal_Buffers_Info_Default+0x4>)
340026ce:	4770      	bx	lr
340026d0:	34029340 	.word	0x34029340

340026d4 <npu_cache_init>:

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
  hcacheaxi_s.Instance = CACHEAXI;
340026d4:	4802      	ldr	r0, [pc, #8]	@ (340026e0 <npu_cache_init+0xc>)
340026d6:	4b03      	ldr	r3, [pc, #12]	@ (340026e4 <npu_cache_init+0x10>)
340026d8:	6003      	str	r3, [r0, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
340026da:	f002 ba13 	b.w	34004b04 <HAL_CACHEAXI_Init>
340026de:	bf00      	nop
340026e0:	3403f458 	.word	0x3403f458
340026e4:	580dfc00 	.word	0x580dfc00

340026e8 <npu_cache_enable>:
}

void npu_cache_enable(void)
{
340026e8:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status;
  // Enable is wrapped in a loop because most of times, the first call returns
  //    HAL_BUSY, resulting in a cache not enabled.
  do
  {
    status = HAL_CACHEAXI_Enable(&hcacheaxi_s);
340026ea:	4c03      	ldr	r4, [pc, #12]	@ (340026f8 <npu_cache_enable+0x10>)
340026ec:	4620      	mov	r0, r4
340026ee:	f002 f9d5 	bl	34004a9c <HAL_CACHEAXI_Enable>
  } while (status == HAL_BUSY);
340026f2:	2802      	cmp	r0, #2
340026f4:	d0fa      	beq.n	340026ec <npu_cache_enable+0x4>
}
340026f6:	bd10      	pop	{r4, pc}
340026f8:	3403f458 	.word	0x3403f458

340026fc <PC_STREAM_Init>:
    .HwFlowCtl = UART_HWCONTROL_NONE
};

void PC_STREAM_Init(void)
{
    BSP_COM_Init(COM1, &PcUartInit);
340026fc:	2000      	movs	r0, #0
340026fe:	4901      	ldr	r1, [pc, #4]	@ (34002704 <PC_STREAM_Init+0x8>)
34002700:	f000 bcf6 	b.w	340030f0 <BSP_COM_Init>
34002704:	3403edb4 	.word	0x3403edb4

34002708 <PC_STREAM_SendFrame>:

void PC_STREAM_SendFrame(const uint8_t *frame, uint32_t width, uint32_t height, uint32_t bpp)
{
    (void)bpp; /* expect RGB565 */

    uint32_t sw = width / STREAM_SCALE;
34002708:	f240 3321 	movw	r3, #801	@ 0x321
3400270c:	4299      	cmp	r1, r3
{
3400270e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t sh = height / STREAM_SCALE;
34002712:	ea4f 0552 	mov.w	r5, r2, lsr #1
    uint32_t sw = width / STREAM_SCALE;
34002716:	ea4f 0451 	mov.w	r4, r1, lsr #1
3400271a:	bf88      	it	hi
3400271c:	f44f 74c8 	movhi.w	r4, #400	@ 0x190
    uint32_t sh = height / STREAM_SCALE;
34002720:	f5b2 7ff1 	cmp.w	r2, #482	@ 0x1e2
    if (sw > STREAM_MAX_WIDTH)  sw = STREAM_MAX_WIDTH;
    if (sh > STREAM_MAX_HEIGHT) sh = STREAM_MAX_HEIGHT;

    const uint16_t *src = (const uint16_t *)frame;
    for (uint32_t y = 0; y < sh; y++)
34002724:	f04f 0200 	mov.w	r2, #0
    uint32_t sh = height / STREAM_SCALE;
34002728:	bf28      	it	cs
3400272a:	25f0      	movcs	r5, #240	@ 0xf0
    for (uint32_t y = 0; y < sh; y++)
3400272c:	4694      	mov	ip, r2
3400272e:	4617      	mov	r7, r2
{
34002730:	b08d      	sub	sp, #52	@ 0x34
34002732:	9003      	str	r0, [sp, #12]
    for (uint32_t y = 0; y < sh; y++)
34002734:	42bd      	cmp	r5, r7
34002736:	d119      	bne.n	3400276c <PC_STREAM_SendFrame+0x64>
            stream_buffer[y * sw + x] = rgb565_to_gray(px);
        }
    }

    char header[32];
    int hl = snprintf(header, sizeof(header), "FRAME %u %u 1\n", (unsigned)sw, (unsigned)sh);
34002738:	4623      	mov	r3, r4
3400273a:	2120      	movs	r1, #32
3400273c:	4a22      	ldr	r2, [pc, #136]	@ (340027c8 <PC_STREAM_SendFrame+0xc0>)
3400273e:	9500      	str	r5, [sp, #0]
34002740:	a804      	add	r0, sp, #16
34002742:	f016 f92b 	bl	3401899c <sniprintf>
    if (hl > 0)
    {
        HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)header, (uint16_t)hl, HAL_MAX_DELAY);
34002746:	a904      	add	r1, sp, #16
34002748:	b282      	uxth	r2, r0
3400274a:	f04f 33ff 	mov.w	r3, #4294967295
3400274e:	481f      	ldr	r0, [pc, #124]	@ (340027cc <PC_STREAM_SendFrame+0xc4>)
34002750:	f00d f866 	bl	3400f820 <HAL_UART_Transmit>
    }
    HAL_UART_Transmit(&hcom_uart[COM1], stream_buffer, sw * sh, HAL_MAX_DELAY);
34002754:	fb14 f205 	smulbb	r2, r4, r5
34002758:	f04f 33ff 	mov.w	r3, #4294967295
3400275c:	491c      	ldr	r1, [pc, #112]	@ (340027d0 <PC_STREAM_SendFrame+0xc8>)
3400275e:	b292      	uxth	r2, r2
34002760:	481a      	ldr	r0, [pc, #104]	@ (340027cc <PC_STREAM_SendFrame+0xc4>)
34002762:	f00d f85d 	bl	3400f820 <HAL_UART_Transmit>
}
34002766:	b00d      	add	sp, #52	@ 0x34
34002768:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (uint32_t x = 0; x < sw; x++)
3400276c:	f04f 0800 	mov.w	r8, #0
34002770:	4b17      	ldr	r3, [pc, #92]	@ (340027d0 <PC_STREAM_SendFrame+0xc8>)
    return (uint8_t)((r8 * 30 + g8 * 59 + b8 * 11) / 100);
34002772:	f104 0e01 	add.w	lr, r4, #1
34002776:	eb02 0903 	add.w	r9, r2, r3
3400277a:	9b03      	ldr	r3, [sp, #12]
3400277c:	eb03 0a8c 	add.w	sl, r3, ip, lsl #2
        for (uint32_t x = 0; x < sw; x++)
34002780:	f1be 0e01 	subs.w	lr, lr, #1
34002784:	d103      	bne.n	3400278e <PC_STREAM_SendFrame+0x86>
    for (uint32_t y = 0; y < sh; y++)
34002786:	3701      	adds	r7, #1
34002788:	448c      	add	ip, r1
3400278a:	4422      	add	r2, r4
3400278c:	e7d2      	b.n	34002734 <PC_STREAM_SendFrame+0x2c>
            uint16_t px = line[x * STREAM_SCALE];
3400278e:	f83a 0028 	ldrh.w	r0, [sl, r8, lsl #2]
        for (uint32_t x = 0; x < sw; x++)
34002792:	f108 0801 	add.w	r8, r8, #1
    uint8_t b8 = (pixel & 0x1F) << 3;
34002796:	00c3      	lsls	r3, r0, #3
    uint8_t r8 = ((pixel >> 11) & 0x1F) << 3;
34002798:	0ac6      	lsrs	r6, r0, #11
    uint8_t g8 = ((pixel >> 5) & 0x3F) << 2;
3400279a:	08c0      	lsrs	r0, r0, #3
    return (uint8_t)((r8 * 30 + g8 * 59 + b8 * 11) / 100);
3400279c:	f000 00fc 	and.w	r0, r0, #252	@ 0xfc
340027a0:	ebc0 1b00 	rsb	fp, r0, r0, lsl #4
340027a4:	ebc0 008b 	rsb	r0, r0, fp, lsl #2
340027a8:	f04f 0b1e 	mov.w	fp, #30
340027ac:	00f6      	lsls	r6, r6, #3
340027ae:	fb1b 0606 	smlabb	r6, fp, r6, r0
340027b2:	200b      	movs	r0, #11
340027b4:	b2db      	uxtb	r3, r3
340027b6:	fb10 6303 	smlabb	r3, r0, r3, r6
340027ba:	2064      	movs	r0, #100	@ 0x64
340027bc:	fbb3 f3f0 	udiv	r3, r3, r0
340027c0:	f809 3b01 	strb.w	r3, [r9], #1
        for (uint32_t x = 0; x < sw; x++)
340027c4:	e7dc      	b.n	34002780 <PC_STREAM_SendFrame+0x78>
340027c6:	bf00      	nop
340027c8:	3401c25a 	.word	0x3401c25a
340027cc:	34056b94 	.word	0x34056b94
340027d0:	3403f464 	.word	0x3403f464

340027d4 <PC_STREAM_SendDetections>:

void PC_STREAM_SendDetections(const od_pp_out_t *detections, uint32_t frame_id)
{
340027d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    char line[64];
    int ll = snprintf(line, sizeof(line), "DETS %lu %d\n", (unsigned long)frame_id, (int)detections->nb_detect);
340027d8:	6842      	ldr	r2, [r0, #4]
{
340027da:	b09a      	sub	sp, #104	@ 0x68
340027dc:	460b      	mov	r3, r1
    int ll = snprintf(line, sizeof(line), "DETS %lu %d\n", (unsigned long)frame_id, (int)detections->nb_detect);
340027de:	9200      	str	r2, [sp, #0]
340027e0:	2140      	movs	r1, #64	@ 0x40
340027e2:	4a27      	ldr	r2, [pc, #156]	@ (34002880 <PC_STREAM_SendDetections+0xac>)
{
340027e4:	4604      	mov	r4, r0
    int ll = snprintf(line, sizeof(line), "DETS %lu %d\n", (unsigned long)frame_id, (int)detections->nb_detect);
340027e6:	a80a      	add	r0, sp, #40	@ 0x28
340027e8:	f016 f8d8 	bl	3401899c <sniprintf>
    if (ll > 0)
    {
        HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)line, (uint16_t)ll, HAL_MAX_DELAY);
340027ec:	f04f 33ff 	mov.w	r3, #4294967295
340027f0:	b282      	uxth	r2, r0
340027f2:	a90a      	add	r1, sp, #40	@ 0x28
340027f4:	4823      	ldr	r0, [pc, #140]	@ (34002884 <PC_STREAM_SendDetections+0xb0>)
340027f6:	f00d f813 	bl	3400f820 <HAL_UART_Transmit>
340027fa:	2500      	movs	r5, #0
    }
    for(int i=0; i<detections->nb_detect; i++)
    {
        const od_pp_outBuffer_t *r = &detections->pOutBuff[i];
340027fc:	2618      	movs	r6, #24
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
340027fe:	4f22      	ldr	r7, [pc, #136]	@ (34002888 <PC_STREAM_SendDetections+0xb4>)
                      (double)r->x_center, (double)r->y_center, (double)r->width,
                      (double)r->height, (double)r->conf);
        if (ll > 0)
        {
            HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)line, (uint16_t)ll, HAL_MAX_DELAY);
34002800:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 34002884 <PC_STREAM_SendDetections+0xb0>
    for(int i=0; i<detections->nb_detect; i++)
34002804:	6863      	ldr	r3, [r4, #4]
34002806:	42ab      	cmp	r3, r5
34002808:	dc09      	bgt.n	3400281e <PC_STREAM_SendDetections+0x4a>
        }
    }
    static const char end_marker[] = "END\n";
    HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)end_marker, sizeof(end_marker) - 1, HAL_MAX_DELAY);
3400280a:	f04f 33ff 	mov.w	r3, #4294967295
3400280e:	2204      	movs	r2, #4
34002810:	491e      	ldr	r1, [pc, #120]	@ (3400288c <PC_STREAM_SendDetections+0xb8>)
34002812:	481c      	ldr	r0, [pc, #112]	@ (34002884 <PC_STREAM_SendDetections+0xb0>)
34002814:	f00d f804 	bl	3400f820 <HAL_UART_Transmit>
}
34002818:	b01a      	add	sp, #104	@ 0x68
3400281a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        const od_pp_outBuffer_t *r = &detections->pOutBuff[i];
3400281e:	6823      	ldr	r3, [r4, #0]
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
34002820:	463a      	mov	r2, r7
        const od_pp_outBuffer_t *r = &detections->pOutBuff[i];
34002822:	fb06 3305 	mla	r3, r6, r5, r3
        ll = snprintf(line, sizeof(line), "%d %.3f %.3f %.3f %.3f %.2f\n", (int)r->class_index,
34002826:	ed93 7a04 	vldr	s14, [r3, #16]
3400282a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400282e:	ed8d 7b08 	vstr	d7, [sp, #32]
34002832:	ed93 7a03 	vldr	s14, [r3, #12]
34002836:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400283a:	ed8d 7b06 	vstr	d7, [sp, #24]
3400283e:	ed93 7a02 	vldr	s14, [r3, #8]
34002842:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34002846:	ed8d 7b04 	vstr	d7, [sp, #16]
3400284a:	ed93 7a01 	vldr	s14, [r3, #4]
3400284e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34002852:	ed8d 7b02 	vstr	d7, [sp, #8]
34002856:	ed93 7a00 	vldr	s14, [r3]
3400285a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400285e:	ed8d 7b00 	vstr	d7, [sp]
34002862:	2140      	movs	r1, #64	@ 0x40
34002864:	695b      	ldr	r3, [r3, #20]
34002866:	a80a      	add	r0, sp, #40	@ 0x28
34002868:	f016 f898 	bl	3401899c <sniprintf>
            HAL_UART_Transmit(&hcom_uart[COM1], (uint8_t *)line, (uint16_t)ll, HAL_MAX_DELAY);
3400286c:	f04f 33ff 	mov.w	r3, #4294967295
34002870:	b282      	uxth	r2, r0
34002872:	a90a      	add	r1, sp, #40	@ 0x28
34002874:	4640      	mov	r0, r8
34002876:	f00c ffd3 	bl	3400f820 <HAL_UART_Transmit>
    for(int i=0; i<detections->nb_detect; i++)
3400287a:	3501      	adds	r5, #1
3400287c:	e7c2      	b.n	34002804 <PC_STREAM_SendDetections+0x30>
3400287e:	bf00      	nop
34002880:	3401c269 	.word	0x3401c269
34002884:	34056b94 	.word	0x34056b94
34002888:	3401c276 	.word	0x3401c276
3400288c:	34034fb0 	.word	0x34034fb0

34002890 <UTIL_LCDEx_PrintfAt>:
  UTIL_LCD_DisplayStringAtLine(line, (uint8_t *) buffer);
  va_end(args);
}

void UTIL_LCDEx_PrintfAt(uint32_t x_pos, uint32_t y_pos, Text_AlignModeTypdef mode, const char * format, ...)
{
34002890:	b408      	push	{r3}
34002892:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
34002894:	4604      	mov	r4, r0
34002896:	460d      	mov	r5, r1
34002898:	4616      	mov	r6, r2
3400289a:	ab07      	add	r3, sp, #28
  static char buffer[N_PRINTABLE_CHARS + 1];
  va_list args;
  va_start(args, format);
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
3400289c:	4f09      	ldr	r7, [pc, #36]	@ (340028c4 <UTIL_LCDEx_PrintfAt+0x34>)
{
3400289e:	f853 2b04 	ldr.w	r2, [r3], #4
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
340028a2:	2130      	movs	r1, #48	@ 0x30
340028a4:	4638      	mov	r0, r7
  va_start(args, format);
340028a6:	9301      	str	r3, [sp, #4]
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
340028a8:	f016 f920 	bl	34018aec <vsniprintf>
  UTIL_LCD_DisplayStringAt(x_pos, y_pos, (uint8_t *) buffer, mode);
340028ac:	4633      	mov	r3, r6
340028ae:	463a      	mov	r2, r7
340028b0:	4629      	mov	r1, r5
340028b2:	4620      	mov	r0, r4
340028b4:	f012 fe84 	bl	340155c0 <UTIL_LCD_DisplayStringAt>
  va_end(args);
}
340028b8:	b002      	add	sp, #8
340028ba:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
340028be:	b001      	add	sp, #4
340028c0:	4770      	bx	lr
340028c2:	bf00      	nop
340028c4:	34056b64 	.word	0x34056b64

340028c8 <NMI_Handler>:
/**
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
340028c8:	4770      	bx	lr

340028ca <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
340028ca:	e7fe      	b.n	340028ca <HardFault_Handler>

340028cc <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
340028cc:	e7fe      	b.n	340028cc <MemManage_Handler>

340028ce <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
340028ce:	e7fe      	b.n	340028ce <BusFault_Handler>

340028d0 <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
340028d0:	e7fe      	b.n	340028d0 <UsageFault_Handler>

340028d2 <SecureFault_Handler>:
  * @retval None
  */
void SecureFault_Handler(void)
{
  /* Go to infinite loop when Secure Fault exception occurs */
  while (1)
340028d2:	e7fe      	b.n	340028d2 <SecureFault_Handler>

340028d4 <SVC_Handler>:
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
}
340028d4:	4770      	bx	lr

340028d6 <DebugMon_Handler>:
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
  while (1)
340028d6:	e7fe      	b.n	340028d6 <DebugMon_Handler>

340028d8 <PendSV_Handler>:
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
  while (1)
340028d8:	e7fe      	b.n	340028d8 <PendSV_Handler>

340028da <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
340028da:	f001 bffd 	b.w	340048d8 <HAL_IncTick>

340028de <CSI_IRQHandler>:
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32n6xx.s).                                               */
/******************************************************************************/
void CSI_IRQHandler(void)
{
340028de:	b508      	push	{r3, lr}
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
340028e0:	f00e f832 	bl	34010948 <CMW_CAMERA_GetDCMIPPHandle>
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
}
340028e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DCMIPP_CSI_IRQHandler(hcamera_dcmipp);
340028e8:	f002 beba 	b.w	34005660 <HAL_DCMIPP_CSI_IRQHandler>

340028ec <DCMIPP_IRQHandler>:

void DCMIPP_IRQHandler(void)
{
340028ec:	b508      	push	{r3, lr}
  DCMIPP_HandleTypeDef *hcamera_dcmipp = CMW_CAMERA_GetDCMIPPHandle();
340028ee:	f00e f82b 	bl	34010948 <CMW_CAMERA_GetDCMIPPHandle>
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
340028f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_DCMIPP_IRQHandler(hcamera_dcmipp);
340028f6:	f002 bd7d 	b.w	340053f4 <HAL_DCMIPP_IRQHandler>

340028fa <_getpid>:
}

int _getpid(void)
{
  return 1;
}
340028fa:	2001      	movs	r0, #1
340028fc:	4770      	bx	lr

340028fe <_kill>:

int _kill(int pid, int sig)
{
340028fe:	b508      	push	{r3, lr}
  (void)pid;
  (void)sig;
  errno = EINVAL;
34002900:	f016 fc04 	bl	3401910c <__errno>
34002904:	2316      	movs	r3, #22
34002906:	6003      	str	r3, [r0, #0]
  return -1;
}
34002908:	f04f 30ff 	mov.w	r0, #4294967295
3400290c:	bd08      	pop	{r3, pc}

3400290e <_exit>:

void _exit (int status)
{
3400290e:	b508      	push	{r3, lr}
  errno = EINVAL;
34002910:	f016 fbfc 	bl	3401910c <__errno>
34002914:	2316      	movs	r3, #22
34002916:	6003      	str	r3, [r0, #0]
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
34002918:	e7fe      	b.n	34002918 <_exit+0xa>

3400291a <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
3400291a:	b570      	push	{r4, r5, r6, lr}
3400291c:	460d      	mov	r5, r1
3400291e:	4614      	mov	r4, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002920:	460e      	mov	r6, r1
34002922:	1b73      	subs	r3, r6, r5
34002924:	429c      	cmp	r4, r3
34002926:	dc01      	bgt.n	3400292c <_read+0x12>
  {
    *ptr++ = __io_getchar();
  }

  return len;
}
34002928:	4620      	mov	r0, r4
3400292a:	bd70      	pop	{r4, r5, r6, pc}
    *ptr++ = __io_getchar();
3400292c:	f3af 8000 	nop.w
34002930:	f806 0b01 	strb.w	r0, [r6], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002934:	e7f5      	b.n	34002922 <_read+0x8>

34002936 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
34002936:	b570      	push	{r4, r5, r6, lr}
34002938:	460d      	mov	r5, r1
3400293a:	4614      	mov	r4, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
3400293c:	460e      	mov	r6, r1
3400293e:	1b73      	subs	r3, r6, r5
34002940:	429c      	cmp	r4, r3
34002942:	dc01      	bgt.n	34002948 <_write+0x12>
  {
    __io_putchar(*ptr++);
  }
  return len;
}
34002944:	4620      	mov	r0, r4
34002946:	bd70      	pop	{r4, r5, r6, pc}
    __io_putchar(*ptr++);
34002948:	f816 0b01 	ldrb.w	r0, [r6], #1
3400294c:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34002950:	e7f5      	b.n	3400293e <_write+0x8>

34002952 <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
34002952:	f04f 30ff 	mov.w	r0, #4294967295
34002956:	4770      	bx	lr

34002958 <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
34002958:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  return 0;
}
3400295c:	2000      	movs	r0, #0
  st->st_mode = S_IFCHR;
3400295e:	604b      	str	r3, [r1, #4]
}
34002960:	4770      	bx	lr

34002962 <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
34002962:	2001      	movs	r0, #1
34002964:	4770      	bx	lr

34002966 <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
34002966:	2000      	movs	r0, #0
34002968:	4770      	bx	lr

3400296a <APS256XX_EnableMemoryMappedMode>:
  * @param  BurstType Type of burst used for the access
  * @retval Memory status
  */
int32_t APS256XX_EnableMemoryMappedMode(XSPI_HandleTypeDef *Ctx, uint32_t ReadLatencyCode, uint32_t WriteLatencyCode,
                                        uint32_t IOMode, uint32_t BurstType)
{
3400296a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400296e:	b098      	sub	sp, #96	@ 0x60
34002970:	4605      	mov	r5, r0
34002972:	4617      	mov	r7, r2
34002974:	460e      	mov	r6, r1
  XSPI_RegularCmdTypeDef   sCommand = {0};
34002976:	223c      	movs	r2, #60	@ 0x3c
34002978:	2100      	movs	r1, #0
3400297a:	a806      	add	r0, sp, #24
{
3400297c:	4698      	mov	r8, r3
3400297e:	9c1e      	ldr	r4, [sp, #120]	@ 0x78
  XSPI_RegularCmdTypeDef   sCommand = {0};
34002980:	f016 f970 	bl	34018c64 <memset>
  XSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
34002984:	2210      	movs	r2, #16
34002986:	2100      	movs	r1, #0
34002988:	a801      	add	r0, sp, #4
3400298a:	f016 f96b 	bl	34018c64 <memset>

  /* Initialize the write command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_WRITE_CFG;
3400298e:	2302      	movs	r3, #2
34002990:	9305      	str	r3, [sp, #20]
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
34002992:	2304      	movs	r3, #4
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
34002994:	2c00      	cmp	r4, #0
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
34002996:	9308      	str	r3, [sp, #32]
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
34002998:	bf14      	ite	ne
3400299a:	2380      	movne	r3, #128	@ 0x80
3400299c:	23a0      	moveq	r3, #160	@ 0xa0
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3400299e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
340029a2:	9307      	str	r3, [sp, #28]
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
340029a4:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340029a8:	e9cd 130c 	strd	r1, r3, [sp, #48]	@ 0x30
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
340029ac:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
340029b0:	f1b8 0f00 	cmp.w	r8, #0
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
340029b4:	930e      	str	r3, [sp, #56]	@ 0x38
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
340029b6:	bf14      	ite	ne
340029b8:	f04f 63a0 	movne.w	r3, #83886080	@ 0x5000000
340029bc:	f04f 6380 	moveq.w	r3, #67108864	@ 0x4000000
340029c0:	9313      	str	r3, [sp, #76]	@ 0x4c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
340029c2:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
340029c6:	9315      	str	r3, [sp, #84]	@ 0x54
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
340029c8:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
340029cc:	3f01      	subs	r7, #1
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340029ce:	f241 3288 	movw	r2, #5000	@ 0x1388
340029d2:	4628      	mov	r0, r5
340029d4:	a905      	add	r1, sp, #20
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
340029d6:	9716      	str	r7, [sp, #88]	@ 0x58
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
340029d8:	9317      	str	r3, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340029da:	f00d fb2b 	bl	34010034 <HAL_XSPI_Command>
340029de:	b120      	cbz	r0, 340029ea <APS256XX_EnableMemoryMappedMode+0x80>
  {
    return APS256XX_ERROR;
340029e0:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return APS256XX_ERROR;
  }

  return APS256XX_OK;
}
340029e4:	b018      	add	sp, #96	@ 0x60
340029e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  sCommand.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
340029ea:	2301      	movs	r3, #1
340029ec:	9305      	str	r3, [sp, #20]
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
340029ee:	fab4 f384 	clz	r3, r4
340029f2:	095b      	lsrs	r3, r3, #5
340029f4:	015b      	lsls	r3, r3, #5
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
340029f6:	3e01      	subs	r6, #1
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340029f8:	f241 3288 	movw	r2, #5000	@ 0x1388
340029fc:	4628      	mov	r0, r5
340029fe:	a905      	add	r1, sp, #20
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
34002a00:	9307      	str	r3, [sp, #28]
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
34002a02:	9616      	str	r6, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a04:	f00d fb16 	bl	34010034 <HAL_XSPI_Command>
34002a08:	2800      	cmp	r0, #0
34002a0a:	d1e9      	bne.n	340029e0 <APS256XX_EnableMemoryMappedMode+0x76>
  sMemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34002a0c:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &sMemMappedCfg) != HAL_OK)
34002a0e:	a901      	add	r1, sp, #4
34002a10:	4628      	mov	r0, r5
34002a12:	f00d fd3d 	bl	34010490 <HAL_XSPI_MemoryMapped>
34002a16:	3800      	subs	r0, #0
34002a18:	bf18      	it	ne
34002a1a:	2001      	movne	r0, #1
34002a1c:	4240      	negs	r0, r0
34002a1e:	e7e1      	b.n	340029e4 <APS256XX_EnableMemoryMappedMode+0x7a>

34002a20 <APS256XX_WriteReg>:
  * @param  Address Register address
  * @param  Value Value to write to register
  * @retval error status
  */
int32_t APS256XX_WriteReg(XSPI_HandleTypeDef *Ctx, uint32_t Address, uint8_t Value)
{
34002a20:	b530      	push	{r4, r5, lr}
34002a22:	b097      	sub	sp, #92	@ 0x5c
34002a24:	460d      	mov	r5, r1
34002a26:	4604      	mov	r4, r0
  XSPI_RegularCmdTypeDef sCommand = {0};
34002a28:	2100      	movs	r1, #0
{
34002a2a:	f88d 2007 	strb.w	r2, [sp, #7]
  XSPI_RegularCmdTypeDef sCommand = {0};
34002a2e:	a803      	add	r0, sp, #12
34002a30:	224c      	movs	r2, #76	@ 0x4c
34002a32:	f016 f917 	bl	34018c64 <memset>
  /* Initialize the write register command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_COMMON_CFG;
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
34002a36:	23c0      	movs	r3, #192	@ 0xc0
34002a38:	2204      	movs	r2, #4
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
34002a3a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
34002a3e:	e9cd 3205 	strd	r3, r2, [sp, #20]
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
34002a42:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002a46:	e9cd 130a 	strd	r1, r3, [sp, #40]	@ 0x28
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34002a4a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34002a4e:	930c      	str	r3, [sp, #48]	@ 0x30
  sCommand.Address             = Address;
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
34002a50:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  sCommand.Address             = Address;
34002a54:	9509      	str	r5, [sp, #36]	@ 0x24
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
34002a56:	9311      	str	r3, [sp, #68]	@ 0x44
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
  sCommand.DataLength          = 2;
34002a58:	f04f 6500 	mov.w	r5, #134217728	@ 0x8000000
34002a5c:	2302      	movs	r3, #2
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Configure the command */
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a5e:	f241 3288 	movw	r2, #5000	@ 0x1388
34002a62:	4620      	mov	r0, r4
34002a64:	a903      	add	r1, sp, #12
  sCommand.DataLength          = 2;
34002a66:	e9cd 3512 	strd	r3, r5, [sp, #72]	@ 0x48
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a6a:	f00d fae3 	bl	34010034 <HAL_XSPI_Command>
34002a6e:	b960      	cbnz	r0, 34002a8a <APS256XX_WriteReg+0x6a>
  {
    return APS256XX_ERROR;
  }

  /* Transmission of the data */
  if (HAL_XSPI_Transmit(Ctx, (uint8_t *)(&Value), HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002a70:	f241 3288 	movw	r2, #5000	@ 0x1388
34002a74:	4620      	mov	r0, r4
34002a76:	f10d 0107 	add.w	r1, sp, #7
34002a7a:	f00d fbf3 	bl	34010264 <HAL_XSPI_Transmit>
34002a7e:	3800      	subs	r0, #0
34002a80:	bf18      	it	ne
34002a82:	2001      	movne	r0, #1
34002a84:	4240      	negs	r0, r0
  {
    return APS256XX_ERROR;
  }

  return APS256XX_OK;
}
34002a86:	b017      	add	sp, #92	@ 0x5c
34002a88:	bd30      	pop	{r4, r5, pc}
    return APS256XX_ERROR;
34002a8a:	f04f 30ff 	mov.w	r0, #4294967295
34002a8e:	e7fa      	b.n	34002a86 <APS256XX_WriteReg+0x66>

34002a90 <MX66UW1G45G_GetFlashInfo>:
  */
int32_t MX66UW1G45G_GetFlashInfo(MX66UW1G45G_Info_t *pInfo)
{
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize = MX66UW1G45G_FLASH_SIZE;
  pInfo->EraseSectorSize = MX66UW1G45G_BLOCK_64K;
34002a90:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34002a94:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
34002a98:	e9c0 2300 	strd	r2, r3, [r0]
  pInfo->EraseSectorsNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_64K);
  pInfo->EraseSubSectorSize = MX66UW1G45G_BLOCK_4K;
34002a9c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34002aa0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34002aa4:	e9c0 3202 	strd	r3, r2, [r0, #8]
  pInfo->EraseSubSectorNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
34002aa8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
  pInfo->ProgPageSize = MX66UW1G45G_PAGE_SIZE;
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
34002aac:	f44f 7180 	mov.w	r1, #256	@ 0x100
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
34002ab0:	e9c0 3204 	strd	r3, r2, [r0, #16]
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
34002ab4:	6183      	str	r3, [r0, #24]
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
34002ab6:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
34002aba:	e9c0 1307 	strd	r1, r3, [r0, #28]

  return MX66UW1G45G_OK;
};
34002abe:	2000      	movs	r0, #0
34002ac0:	4770      	bx	lr

34002ac2 <MX66UW1G45G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX66UW1G45G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                        MX66UW1G45G_Transfer_t Rate)
{
34002ac2:	b570      	push	{r4, r5, r6, lr}
34002ac4:	460d      	mov	r5, r1
34002ac6:	b098      	sub	sp, #96	@ 0x60
  XSPI_RegularCmdTypeDef s_command = {0};
34002ac8:	2100      	movs	r1, #0
{
34002aca:	4606      	mov	r6, r0
34002acc:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002ace:	a805      	add	r0, sp, #20
34002ad0:	224c      	movs	r2, #76	@ 0x4c
34002ad2:	f016 f8c7 	bl	34018c64 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
34002ad6:	2214      	movs	r2, #20
34002ad8:	2100      	movs	r1, #0
34002ada:	4668      	mov	r0, sp
34002adc:	f016 f8c2 	bl	34018c64 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002ae0:	b92d      	cbnz	r5, 34002aee <MX66UW1G45G_AutoPollingMemReady+0x2c>
34002ae2:	2c01      	cmp	r4, #1
34002ae4:	d14d      	bne.n	34002b82 <MX66UW1G45G_AutoPollingMemReady+0xc0>
  {
    return MX66UW1G45G_ERROR;
34002ae6:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002aea:	b018      	add	sp, #96	@ 0x60
34002aec:	bd70      	pop	{r4, r5, r6, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002aee:	2204      	movs	r2, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002af0:	f104 3cff 	add.w	ip, r4, #4294967295
34002af4:	f1dc 0300 	rsbs	r3, ip, #0
34002af8:	eb43 030c 	adc.w	r3, r3, ip
34002afc:	00db      	lsls	r3, r3, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002afe:	9208      	str	r2, [sp, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002b00:	930a      	str	r3, [sp, #40]	@ 0x28
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002b02:	2d00      	cmp	r5, #0
34002b04:	d040      	beq.n	34002b88 <MX66UW1G45G_AutoPollingMemReady+0xc6>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002b06:	2310      	movs	r3, #16
34002b08:	f240 52fa 	movw	r2, #1530	@ 0x5fa
34002b0c:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002b0e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002b12:	1e60      	subs	r0, r4, #1
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002b14:	930c      	str	r3, [sp, #48]	@ 0x30
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002b16:	4243      	negs	r3, r0
34002b18:	4143      	adcs	r3, r0
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002b1a:	9207      	str	r2, [sp, #28]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002b1c:	02da      	lsls	r2, r3, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002b1e:	920e      	str	r2, [sp, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002b20:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002b24:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002b26:	920d      	str	r2, [sp, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002b28:	bf14      	ite	ne
34002b2a:	f04f 6280 	movne.w	r2, #67108864	@ 0x4000000
34002b2e:	f04f 7280 	moveq.w	r2, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34002b32:	ea4f 63c3 	mov.w	r3, r3, lsl #27
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002b36:	9213      	str	r2, [sp, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002b38:	9315      	str	r3, [sp, #84]	@ 0x54
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002b3a:	d02d      	beq.n	34002b98 <MX66UW1G45G_AutoPollingMemReady+0xd6>
34002b3c:	2c01      	cmp	r4, #1
34002b3e:	d126      	bne.n	34002b8e <MX66UW1G45G_AutoPollingMemReady+0xcc>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002b40:	2305      	movs	r3, #5
34002b42:	9316      	str	r3, [sp, #88]	@ 0x58
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002b44:	2202      	movs	r2, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002b46:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34002b4a:	9317      	str	r3, [sp, #92]	@ 0x5c
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34002b4c:	2301      	movs	r3, #1
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002b4e:	2110      	movs	r1, #16
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34002b50:	9301      	str	r3, [sp, #4]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002b52:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34002b56:	9214      	str	r2, [sp, #80]	@ 0x50
34002b58:	e9cd 3103 	strd	r3, r1, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b5c:	f241 3288 	movw	r2, #5000	@ 0x1388
34002b60:	4630      	mov	r0, r6
34002b62:	a905      	add	r1, sp, #20
34002b64:	f00d fa66 	bl	34010034 <HAL_XSPI_Command>
34002b68:	2800      	cmp	r0, #0
34002b6a:	d1bc      	bne.n	34002ae6 <MX66UW1G45G_AutoPollingMemReady+0x24>
  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002b6c:	f241 3288 	movw	r2, #5000	@ 0x1388
34002b70:	4669      	mov	r1, sp
34002b72:	4630      	mov	r0, r6
34002b74:	f00d fc10 	bl	34010398 <HAL_XSPI_AutoPolling>
34002b78:	3800      	subs	r0, #0
34002b7a:	bf18      	it	ne
34002b7c:	2001      	movne	r0, #1
34002b7e:	4240      	negs	r0, r0
34002b80:	e7b3      	b.n	34002aea <MX66UW1G45G_AutoPollingMemReady+0x28>
34002b82:	2201      	movs	r2, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002b84:	462b      	mov	r3, r5
34002b86:	e7ba      	b.n	34002afe <MX66UW1G45G_AutoPollingMemReady+0x3c>
34002b88:	2205      	movs	r2, #5
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002b8a:	462b      	mov	r3, r5
34002b8c:	e7c1      	b.n	34002b12 <MX66UW1G45G_AutoPollingMemReady+0x50>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002b8e:	2304      	movs	r3, #4
34002b90:	9316      	str	r3, [sp, #88]	@ 0x58
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002b92:	2201      	movs	r2, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002b94:	2300      	movs	r3, #0
34002b96:	e7d8      	b.n	34002b4a <MX66UW1G45G_AutoPollingMemReady+0x88>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002b98:	2c01      	cmp	r4, #1
34002b9a:	d1fa      	bne.n	34002b92 <MX66UW1G45G_AutoPollingMemReady+0xd0>
34002b9c:	e7d2      	b.n	34002b44 <MX66UW1G45G_AutoPollingMemReady+0x82>

34002b9e <MX66UW1G45G_EnableSTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                              MX66UW1G45G_AddressWidth_t AddressWidth)
{
34002b9e:	b570      	push	{r4, r5, r6, lr}
34002ba0:	460c      	mov	r4, r1
34002ba2:	b098      	sub	sp, #96	@ 0x60
  XSPI_RegularCmdTypeDef s_command = {0};
34002ba4:	2100      	movs	r1, #0
{
34002ba6:	4606      	mov	r6, r0
34002ba8:	4615      	mov	r5, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002baa:	a805      	add	r0, sp, #20
34002bac:	224c      	movs	r2, #76	@ 0x4c
34002bae:	f016 f859 	bl	34018c64 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34002bb2:	2210      	movs	r2, #16
34002bb4:	2100      	movs	r1, #0
34002bb6:	a801      	add	r0, sp, #4
34002bb8:	f016 f854 	bl	34018c64 <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX66UW1G45G_OPI_MODE) && (AddressWidth == MX66UW1G45G_3BYTES_SIZE))
34002bbc:	2c01      	cmp	r4, #1
34002bbe:	d144      	bne.n	34002c4a <MX66UW1G45G_EnableSTRMemoryMappedMode+0xac>
34002bc0:	b91d      	cbnz	r5, 34002bca <MX66UW1G45G_EnableSTRMemoryMappedMode+0x2c>
  {
    return MX66UW1G45G_ERROR;
34002bc2:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002bc6:	b018      	add	sp, #96	@ 0x60
34002bc8:	bd70      	pop	{r4, r5, r6, pc}
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002bca:	9405      	str	r4, [sp, #20]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002bcc:	2204      	movs	r2, #4
34002bce:	2310      	movs	r3, #16
34002bd0:	e9cd 2308 	strd	r2, r3, [sp, #32]
34002bd4:	f64e 4213 	movw	r2, #60435	@ 0xec13
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002bd8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
                               : HAL_XSPI_ADDRESS_32_BITS;
34002bdc:	2d00      	cmp	r5, #0
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002bde:	930c      	str	r3, [sp, #48]	@ 0x30
                               : HAL_XSPI_ADDRESS_32_BITS;
34002be0:	bf14      	ite	ne
34002be2:	f44f 5340 	movne.w	r3, #12288	@ 0x3000
34002be6:	f44f 5300 	moveq.w	r3, #8192	@ 0x2000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002bea:	2c00      	cmp	r4, #0
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002bec:	9207      	str	r2, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002bee:	bf0c      	ite	eq
34002bf0:	f04f 7280 	moveq.w	r2, #16777216	@ 0x1000000
34002bf4:	f04f 6280 	movne.w	r2, #67108864	@ 0x4000000
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
34002bf8:	930d      	str	r3, [sp, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002bfa:	bf0c      	ite	eq
34002bfc:	2308      	moveq	r3, #8
34002bfe:	230a      	movne	r3, #10
34002c00:	9213      	str	r2, [sp, #76]	@ 0x4c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c02:	4630      	mov	r0, r6
34002c04:	f241 3288 	movw	r2, #5000	@ 0x1388
34002c08:	a905      	add	r1, sp, #20
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
34002c0a:	9316      	str	r3, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c0c:	f00d fa12 	bl	34010034 <HAL_XSPI_Command>
34002c10:	2800      	cmp	r0, #0
34002c12:	d1d6      	bne.n	34002bc2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x24>
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
34002c14:	2302      	movs	r3, #2
34002c16:	9305      	str	r3, [sp, #20]
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002c18:	bb1c      	cbnz	r4, 34002c62 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xc4>
34002c1a:	2d00      	cmp	r5, #0
34002c1c:	bf18      	it	ne
34002c1e:	2312      	movne	r3, #18
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002c20:	9307      	str	r3, [sp, #28]
  s_command.DummyCycles = 0U;
34002c22:	2300      	movs	r3, #0
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c24:	f241 3288 	movw	r2, #5000	@ 0x1388
34002c28:	4630      	mov	r0, r6
34002c2a:	a905      	add	r1, sp, #20
  s_command.DummyCycles = 0U;
34002c2c:	9316      	str	r3, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002c2e:	f00d fa01 	bl	34010034 <HAL_XSPI_Command>
34002c32:	2800      	cmp	r0, #0
34002c34:	d1c5      	bne.n	34002bc2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x24>
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34002c36:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34002c38:	a901      	add	r1, sp, #4
34002c3a:	4630      	mov	r0, r6
34002c3c:	f00d fc28 	bl	34010490 <HAL_XSPI_MemoryMapped>
34002c40:	3800      	subs	r0, #0
34002c42:	bf18      	it	ne
34002c44:	2001      	movne	r0, #1
34002c46:	4240      	negs	r0, r0
34002c48:	e7bd      	b.n	34002bc6 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x28>
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002c4a:	2301      	movs	r3, #1
34002c4c:	9305      	str	r3, [sp, #20]
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34002c4e:	2c00      	cmp	r4, #0
34002c50:	d1bc      	bne.n	34002bcc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x2e>
                              : MX66UW1G45G_OCTA_READ_CMD;
34002c52:	2d00      	cmp	r5, #0
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002c54:	9308      	str	r3, [sp, #32]
                              : MX66UW1G45G_OCTA_READ_CMD;
34002c56:	bf14      	ite	ne
34002c58:	220c      	movne	r2, #12
34002c5a:	220b      	moveq	r2, #11
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002c5c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002c60:	e7bc      	b.n	34002bdc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002c62:	f241 23ed 	movw	r3, #4845	@ 0x12ed
34002c66:	e7db      	b.n	34002c20 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x82>

34002c68 <MX66UW1G45G_EnableDTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode)
{
34002c68:	b530      	push	{r4, r5, lr}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef s_command = {0};
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34002c6a:	2510      	movs	r5, #16
{
34002c6c:	b099      	sub	sp, #100	@ 0x64
34002c6e:	4604      	mov	r4, r0
  XSPI_RegularCmdTypeDef s_command = {0};
34002c70:	223c      	movs	r2, #60	@ 0x3c
34002c72:	2100      	movs	r1, #0
34002c74:	a806      	add	r0, sp, #24
34002c76:	f015 fff5 	bl	34018c64 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34002c7a:	462a      	mov	r2, r5
34002c7c:	2100      	movs	r1, #0
34002c7e:	a801      	add	r0, sp, #4
34002c80:	f015 fff0 	bl	34018c64 <memset>

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34002c84:	2301      	movs	r3, #1
34002c86:	9305      	str	r3, [sp, #20]
  s_command.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
34002c88:	2304      	movs	r3, #4
34002c8a:	9308      	str	r3, [sp, #32]
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
34002c8c:	2308      	movs	r3, #8
  s_command.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
34002c8e:	e9cd 5309 	strd	r5, r3, [sp, #36]	@ 0x24
  s_command.Instruction = MX66UW1G45G_OCTA_READ_DTR_CMD;
34002c92:	f64e 6311 	movw	r3, #60945	@ 0xee11
34002c96:	9307      	str	r3, [sp, #28]
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34002c98:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002c9c:	f44f 6e00 	mov.w	lr, #2048	@ 0x800
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34002ca0:	930c      	str	r3, [sp, #48]	@ 0x30
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002ca2:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34002ca6:	e9cd 3e0d 	strd	r3, lr, [sp, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
34002caa:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
34002cae:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
34002cb2:	9313      	str	r3, [sp, #76]	@ 0x4c
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
34002cb4:	230a      	movs	r3, #10
34002cb6:	e9cd 1315 	strd	r1, r3, [sp, #84]	@ 0x54
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
34002cba:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002cbe:	f241 3288 	movw	r2, #5000	@ 0x1388
34002cc2:	4620      	mov	r0, r4
34002cc4:	a905      	add	r1, sp, #20
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
34002cc6:	9317      	str	r3, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002cc8:	f00d f9b4 	bl	34010034 <HAL_XSPI_Command>
34002ccc:	b118      	cbz	r0, 34002cd6 <MX66UW1G45G_EnableDTRMemoryMappedMode+0x6e>
  {
    return MX66UW1G45G_ERROR;
34002cce:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002cd2:	b019      	add	sp, #100	@ 0x64
34002cd4:	bd30      	pop	{r4, r5, pc}
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
34002cd6:	2302      	movs	r3, #2
34002cd8:	9305      	str	r3, [sp, #20]
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002cda:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34002cde:	e9cd 0016 	strd	r0, r0, [sp, #88]	@ 0x58
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002ce2:	f241 3288 	movw	r2, #5000	@ 0x1388
34002ce6:	4620      	mov	r0, r4
34002ce8:	a905      	add	r1, sp, #20
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34002cea:	9307      	str	r3, [sp, #28]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002cec:	f00d f9a2 	bl	34010034 <HAL_XSPI_Command>
34002cf0:	2800      	cmp	r0, #0
34002cf2:	d1ec      	bne.n	34002cce <MX66UW1G45G_EnableDTRMemoryMappedMode+0x66>
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34002cf4:	9001      	str	r0, [sp, #4]
  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34002cf6:	a901      	add	r1, sp, #4
34002cf8:	4620      	mov	r0, r4
34002cfa:	f00d fbc9 	bl	34010490 <HAL_XSPI_MemoryMapped>
34002cfe:	3800      	subs	r0, #0
34002d00:	bf18      	it	ne
34002d02:	2001      	movne	r0, #1
34002d04:	4240      	negs	r0, r0
34002d06:	e7e4      	b.n	34002cd2 <MX66UW1G45G_EnableDTRMemoryMappedMode+0x6a>

34002d08 <MX66UW1G45G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34002d08:	b5f0      	push	{r4, r5, r6, r7, lr}
34002d0a:	460c      	mov	r4, r1
34002d0c:	b099      	sub	sp, #100	@ 0x64
  XSPI_RegularCmdTypeDef s_command = {0};
34002d0e:	2100      	movs	r1, #0
{
34002d10:	4606      	mov	r6, r0
34002d12:	4615      	mov	r5, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002d14:	a805      	add	r0, sp, #20
34002d16:	224c      	movs	r2, #76	@ 0x4c
34002d18:	f015 ffa4 	bl	34018c64 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
34002d1c:	2214      	movs	r2, #20
34002d1e:	2100      	movs	r1, #0
34002d20:	4668      	mov	r0, sp
34002d22:	f015 ff9f 	bl	34018c64 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002d26:	b92c      	cbnz	r4, 34002d34 <MX66UW1G45G_WriteEnable+0x2c>
34002d28:	2d01      	cmp	r5, #1
34002d2a:	d15d      	bne.n	34002de8 <MX66UW1G45G_WriteEnable+0xe0>
  {
    return MX66UW1G45G_ERROR;
34002d2c:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002d30:	b019      	add	sp, #100	@ 0x64
34002d32:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002d34:	2204      	movs	r2, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002d36:	1e69      	subs	r1, r5, #1
34002d38:	424b      	negs	r3, r1
34002d3a:	414b      	adcs	r3, r1
34002d3c:	00db      	lsls	r3, r3, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002d3e:	9208      	str	r2, [sp, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002d40:	930a      	str	r3, [sp, #40]	@ 0x28
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002d42:	2c00      	cmp	r4, #0
34002d44:	d053      	beq.n	34002dee <MX66UW1G45G_WriteEnable+0xe6>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002d46:	2310      	movs	r3, #16
34002d48:	9309      	str	r3, [sp, #36]	@ 0x24
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
34002d4a:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002d4e:	f241 3288 	movw	r2, #5000	@ 0x1388
34002d52:	4630      	mov	r0, r6
34002d54:	a905      	add	r1, sp, #20
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002d56:	9307      	str	r3, [sp, #28]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002d58:	f00d f96c 	bl	34010034 <HAL_XSPI_Command>
34002d5c:	4603      	mov	r3, r0
34002d5e:	2800      	cmp	r0, #0
34002d60:	d1e4      	bne.n	34002d2c <MX66UW1G45G_WriteEnable+0x24>
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002d62:	2c00      	cmp	r4, #0
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002d64:	f105 32ff 	add.w	r2, r5, #4294967295
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002d68:	f240 5cfa 	movw	ip, #1530	@ 0x5fa
34002d6c:	bf12      	itee	ne
34002d6e:	f44f 6e80 	movne.w	lr, #1024	@ 0x400
34002d72:	f04f 0c05 	moveq.w	ip, #5
34002d76:	f04f 0e00 	moveq.w	lr, #0
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002d7a:	4257      	negs	r7, r2
34002d7c:	4157      	adcs	r7, r2
34002d7e:	02ff      	lsls	r7, r7, #11
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d80:	2c00      	cmp	r4, #0
34002d82:	d036      	beq.n	34002df2 <MX66UW1G45G_WriteEnable+0xea>
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002d84:	2d01      	cmp	r5, #1
34002d86:	d03a      	beq.n	34002dfe <MX66UW1G45G_WriteEnable+0xf6>
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d88:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002d8c:	2404      	movs	r4, #4
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002d8e:	2101      	movs	r1, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002d90:	461a      	mov	r2, r3
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002d92:	f44f 5540 	mov.w	r5, #12288	@ 0x3000
34002d96:	950d      	str	r5, [sp, #52]	@ 0x34
  s_command.Address = 0U;
34002d98:	2500      	movs	r5, #0
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002d9a:	9013      	str	r0, [sp, #76]	@ 0x4c
34002d9c:	9114      	str	r1, [sp, #80]	@ 0x50
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002d9e:	9217      	str	r2, [sp, #92]	@ 0x5c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002da0:	4630      	mov	r0, r6
34002da2:	f241 3288 	movw	r2, #5000	@ 0x1388
34002da6:	a905      	add	r1, sp, #20
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002da8:	e9cd 3415 	strd	r3, r4, [sp, #84]	@ 0x54
34002dac:	f8cd c01c 	str.w	ip, [sp, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34002db0:	f8cd e030 	str.w	lr, [sp, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002db4:	970e      	str	r7, [sp, #56]	@ 0x38
  s_command.Address = 0U;
34002db6:	950b      	str	r5, [sp, #44]	@ 0x2c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002db8:	f00d f93c 	bl	34010034 <HAL_XSPI_Command>
34002dbc:	2800      	cmp	r0, #0
34002dbe:	d1b5      	bne.n	34002d2c <MX66UW1G45G_WriteEnable+0x24>
  s_config.MatchValue = 2U;
34002dc0:	2302      	movs	r3, #2
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002dc2:	2210      	movs	r2, #16
  s_config.MatchMask = 2U;
34002dc4:	e9cd 3300 	strd	r3, r3, [sp]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002dc8:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
34002dcc:	9002      	str	r0, [sp, #8]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34002dce:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002dd2:	4669      	mov	r1, sp
34002dd4:	f241 3288 	movw	r2, #5000	@ 0x1388
34002dd8:	4630      	mov	r0, r6
34002dda:	f00d fadd 	bl	34010398 <HAL_XSPI_AutoPolling>
34002dde:	1b40      	subs	r0, r0, r5
34002de0:	bf18      	it	ne
34002de2:	2001      	movne	r0, #1
34002de4:	4240      	negs	r0, r0
34002de6:	e7a3      	b.n	34002d30 <MX66UW1G45G_WriteEnable+0x28>
34002de8:	2201      	movs	r2, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002dea:	4623      	mov	r3, r4
34002dec:	e7a7      	b.n	34002d3e <MX66UW1G45G_WriteEnable+0x36>
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
34002dee:	2306      	movs	r3, #6
34002df0:	e7ad      	b.n	34002d4e <MX66UW1G45G_WriteEnable+0x46>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002df2:	2d01      	cmp	r5, #1
34002df4:	d00c      	beq.n	34002e10 <MX66UW1G45G_WriteEnable+0x108>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34002df6:	4623      	mov	r3, r4
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002df8:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
34002dfc:	e7c7      	b.n	34002d8e <MX66UW1G45G_WriteEnable+0x86>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34002dfe:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e02:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
34002e06:	2405      	movs	r4, #5
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002e08:	2102      	movs	r1, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002e0a:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34002e0e:	e7c0      	b.n	34002d92 <MX66UW1G45G_WriteEnable+0x8a>
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34002e10:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e14:	f04f 7080 	mov.w	r0, #16777216	@ 0x1000000
34002e18:	e7f6      	b.n	34002e08 <MX66UW1G45G_WriteEnable+0x100>

34002e1a <MX66UW1G45G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX66UW1G45G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                      MX66UW1G45G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
34002e1a:	b5f0      	push	{r4, r5, r6, r7, lr}
34002e1c:	460d      	mov	r5, r1
34002e1e:	b095      	sub	sp, #84	@ 0x54
34002e20:	4606      	mov	r6, r0
34002e22:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002e24:	2100      	movs	r1, #0
34002e26:	224c      	movs	r2, #76	@ 0x4c
34002e28:	a801      	add	r0, sp, #4
{
34002e2a:	461f      	mov	r7, r3
  XSPI_RegularCmdTypeDef s_command = {0};
34002e2c:	f015 ff1a 	bl	34018c64 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002e30:	b92d      	cbnz	r5, 34002e3e <MX66UW1G45G_WriteCfg2Register+0x24>
34002e32:	2c01      	cmp	r4, #1
34002e34:	d140      	bne.n	34002eb8 <MX66UW1G45G_WriteCfg2Register+0x9e>
  {
    return MX66UW1G45G_ERROR;
34002e36:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002e3a:	b015      	add	sp, #84	@ 0x54
34002e3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e3e:	2304      	movs	r3, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002e40:	1e61      	subs	r1, r4, #1
34002e42:	424a      	negs	r2, r1
34002e44:	414a      	adcs	r2, r1
34002e46:	00d2      	lsls	r2, r2, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002e48:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e4a:	9206      	str	r2, [sp, #24]
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002e4c:	2d00      	cmp	r5, #0
34002e4e:	d036      	beq.n	34002ebe <MX66UW1G45G_WriteCfg2Register+0xa4>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002e50:	2310      	movs	r3, #16
34002e52:	f247 228d 	movw	r2, #29325	@ 0x728d
34002e56:	9305      	str	r3, [sp, #20]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002e58:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002e5c:	9308      	str	r3, [sp, #32]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002e5e:	1e63      	subs	r3, r4, #1
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002e60:	9203      	str	r2, [sp, #12]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002e62:	425a      	negs	r2, r3
34002e64:	415a      	adcs	r2, r3
34002e66:	02d3      	lsls	r3, r2, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e68:	930a      	str	r3, [sp, #40]	@ 0x28
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002e6a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e6e:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002e70:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e72:	bf14      	ite	ne
34002e74:	f04f 6380 	movne.w	r3, #67108864	@ 0x4000000
34002e78:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34002e7c:	ea4f 62c2 	mov.w	r2, r2, lsl #27
  s_command.Address = WriteAddr;
34002e80:	9707      	str	r7, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002e82:	930f      	str	r3, [sp, #60]	@ 0x3c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002e84:	9211      	str	r2, [sp, #68]	@ 0x44
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34002e86:	d01e      	beq.n	34002ec6 <MX66UW1G45G_WriteCfg2Register+0xac>
34002e88:	2c01      	cmp	r4, #1
34002e8a:	bf0c      	ite	eq
34002e8c:	2302      	moveq	r3, #2
34002e8e:	2301      	movne	r3, #1
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e90:	f241 3288 	movw	r2, #5000	@ 0x1388
34002e94:	4630      	mov	r0, r6
34002e96:	a901      	add	r1, sp, #4
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34002e98:	9310      	str	r3, [sp, #64]	@ 0x40
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002e9a:	f00d f8cb 	bl	34010034 <HAL_XSPI_Command>
34002e9e:	2800      	cmp	r0, #0
34002ea0:	d1c9      	bne.n	34002e36 <MX66UW1G45G_WriteCfg2Register+0x1c>
  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002ea2:	f241 3288 	movw	r2, #5000	@ 0x1388
34002ea6:	4630      	mov	r0, r6
34002ea8:	a91a      	add	r1, sp, #104	@ 0x68
34002eaa:	f00d f9db 	bl	34010264 <HAL_XSPI_Transmit>
34002eae:	3800      	subs	r0, #0
34002eb0:	bf18      	it	ne
34002eb2:	2001      	movne	r0, #1
34002eb4:	4240      	negs	r0, r0
34002eb6:	e7c0      	b.n	34002e3a <MX66UW1G45G_WriteCfg2Register+0x20>
34002eb8:	2301      	movs	r3, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002eba:	462a      	mov	r2, r5
34002ebc:	e7c4      	b.n	34002e48 <MX66UW1G45G_WriteCfg2Register+0x2e>
34002ebe:	2272      	movs	r2, #114	@ 0x72
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002ec0:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002ec4:	e7ca      	b.n	34002e5c <MX66UW1G45G_WriteCfg2Register+0x42>
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34002ec6:	2301      	movs	r3, #1
34002ec8:	e7e2      	b.n	34002e90 <MX66UW1G45G_WriteCfg2Register+0x76>

34002eca <MX66UW1G45G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX66UW1G45G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                     MX66UW1G45G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
34002eca:	b5f0      	push	{r4, r5, r6, r7, lr}
34002ecc:	460d      	mov	r5, r1
34002ece:	b095      	sub	sp, #84	@ 0x54
34002ed0:	4606      	mov	r6, r0
34002ed2:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002ed4:	2100      	movs	r1, #0
34002ed6:	224c      	movs	r2, #76	@ 0x4c
34002ed8:	a801      	add	r0, sp, #4
{
34002eda:	461f      	mov	r7, r3
  XSPI_RegularCmdTypeDef s_command = {0};
34002edc:	f015 fec2 	bl	34018c64 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002ee0:	b92d      	cbnz	r5, 34002eee <MX66UW1G45G_ReadCfg2Register+0x24>
34002ee2:	2c01      	cmp	r4, #1
34002ee4:	d144      	bne.n	34002f70 <MX66UW1G45G_ReadCfg2Register+0xa6>
  {
    return MX66UW1G45G_ERROR;
34002ee6:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002eea:	b015      	add	sp, #84	@ 0x54
34002eec:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002eee:	2304      	movs	r3, #4
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002ef0:	1e61      	subs	r1, r4, #1
34002ef2:	424a      	negs	r2, r1
34002ef4:	414a      	adcs	r2, r1
34002ef6:	00d2      	lsls	r2, r2, #3
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002ef8:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002efa:	9206      	str	r2, [sp, #24]
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002efc:	2d00      	cmp	r5, #0
34002efe:	d03a      	beq.n	34002f76 <MX66UW1G45G_ReadCfg2Register+0xac>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002f00:	2310      	movs	r3, #16
34002f02:	f247 128e 	movw	r2, #29070	@ 0x718e
34002f06:	9305      	str	r3, [sp, #20]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002f08:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34002f0c:	9308      	str	r3, [sp, #32]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002f0e:	1e63      	subs	r3, r4, #1
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002f10:	9203      	str	r2, [sp, #12]
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34002f12:	425a      	negs	r2, r3
34002f14:	415a      	adcs	r2, r3
34002f16:	02d3      	lsls	r3, r2, #11
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002f18:	930a      	str	r3, [sp, #40]	@ 0x28
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002f1a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002f1e:	2d00      	cmp	r5, #0
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34002f20:	9309      	str	r3, [sp, #36]	@ 0x24
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002f22:	bf14      	ite	ne
34002f24:	f04f 6380 	movne.w	r3, #67108864	@ 0x4000000
34002f28:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
                              : HAL_XSPI_DATA_DTR_DISABLE;
34002f2c:	ea4f 62c2 	mov.w	r2, r2, lsl #27
  s_command.Address = ReadAddr;
34002f30:	9707      	str	r7, [sp, #28]
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34002f32:	930f      	str	r3, [sp, #60]	@ 0x3c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002f34:	9211      	str	r2, [sp, #68]	@ 0x44
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34002f36:	d027      	beq.n	34002f88 <MX66UW1G45G_ReadCfg2Register+0xbe>
34002f38:	2c01      	cmp	r4, #1
34002f3a:	d120      	bne.n	34002f7e <MX66UW1G45G_ReadCfg2Register+0xb4>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002f3c:	2305      	movs	r3, #5
34002f3e:	9312      	str	r3, [sp, #72]	@ 0x48
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002f40:	2202      	movs	r2, #2
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002f42:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34002f46:	9210      	str	r2, [sp, #64]	@ 0x40
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002f48:	4630      	mov	r0, r6
34002f4a:	f241 3288 	movw	r2, #5000	@ 0x1388
34002f4e:	a901      	add	r1, sp, #4
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002f50:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002f52:	f00d f86f 	bl	34010034 <HAL_XSPI_Command>
34002f56:	2800      	cmp	r0, #0
34002f58:	d1c5      	bne.n	34002ee6 <MX66UW1G45G_ReadCfg2Register+0x1c>
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002f5a:	f241 3288 	movw	r2, #5000	@ 0x1388
34002f5e:	4630      	mov	r0, r6
34002f60:	991a      	ldr	r1, [sp, #104]	@ 0x68
34002f62:	f00d f9c3 	bl	340102ec <HAL_XSPI_Receive>
34002f66:	3800      	subs	r0, #0
34002f68:	bf18      	it	ne
34002f6a:	2001      	movne	r0, #1
34002f6c:	4240      	negs	r0, r0
34002f6e:	e7bc      	b.n	34002eea <MX66UW1G45G_ReadCfg2Register+0x20>
34002f70:	2301      	movs	r3, #1
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002f72:	462a      	mov	r2, r5
34002f74:	e7c0      	b.n	34002ef8 <MX66UW1G45G_ReadCfg2Register+0x2e>
34002f76:	2271      	movs	r2, #113	@ 0x71
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34002f78:	f44f 7380 	mov.w	r3, #256	@ 0x100
34002f7c:	e7c6      	b.n	34002f0c <MX66UW1G45G_ReadCfg2Register+0x42>
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34002f7e:	2304      	movs	r3, #4
34002f80:	9312      	str	r3, [sp, #72]	@ 0x48
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002f82:	2201      	movs	r2, #1
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34002f84:	2300      	movs	r3, #0
34002f86:	e7de      	b.n	34002f46 <MX66UW1G45G_ReadCfg2Register+0x7c>
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34002f88:	2c01      	cmp	r4, #1
34002f8a:	d1fa      	bne.n	34002f82 <MX66UW1G45G_ReadCfg2Register+0xb8>
34002f8c:	e7d8      	b.n	34002f40 <MX66UW1G45G_ReadCfg2Register+0x76>

34002f8e <MX66UW1G45G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34002f8e:	b570      	push	{r4, r5, r6, lr}
34002f90:	460d      	mov	r5, r1
34002f92:	b094      	sub	sp, #80	@ 0x50
34002f94:	4606      	mov	r6, r0
34002f96:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002f98:	2100      	movs	r1, #0
34002f9a:	224c      	movs	r2, #76	@ 0x4c
34002f9c:	a801      	add	r0, sp, #4
34002f9e:	f015 fe61 	bl	34018c64 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002fa2:	b9d5      	cbnz	r5, 34002fda <MX66UW1G45G_ResetEnable+0x4c>
34002fa4:	2c01      	cmp	r4, #1
34002fa6:	d01c      	beq.n	34002fe2 <MX66UW1G45G_ResetEnable+0x54>
  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
  s_command.IOSelect =  HAL_XSPI_SELECT_IO_3_0;
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34002fa8:	2301      	movs	r3, #1
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34002faa:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34002fac:	1e63      	subs	r3, r4, #1
34002fae:	425c      	negs	r4, r3
34002fb0:	415c      	adcs	r4, r3
34002fb2:	00e4      	lsls	r4, r4, #3
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34002fb4:	9406      	str	r4, [sp, #24]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34002fb6:	b195      	cbz	r5, 34002fde <MX66UW1G45G_ResetEnable+0x50>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34002fb8:	2310      	movs	r3, #16
34002fba:	9305      	str	r3, [sp, #20]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_ENABLE_CMD
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34002fbc:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.DummyCycles = 0U;
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;


  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002fc0:	f241 3288 	movw	r2, #5000	@ 0x1388
34002fc4:	4630      	mov	r0, r6
34002fc6:	a901      	add	r1, sp, #4
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34002fc8:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34002fca:	f00d f833 	bl	34010034 <HAL_XSPI_Command>
34002fce:	3800      	subs	r0, #0
34002fd0:	bf18      	it	ne
34002fd2:	2001      	movne	r0, #1
34002fd4:	4240      	negs	r0, r0
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
34002fd6:	b014      	add	sp, #80	@ 0x50
34002fd8:	bd70      	pop	{r4, r5, r6, pc}
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34002fda:	2304      	movs	r3, #4
34002fdc:	e7e5      	b.n	34002faa <MX66UW1G45G_ResetEnable+0x1c>
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34002fde:	2366      	movs	r3, #102	@ 0x66
34002fe0:	e7ee      	b.n	34002fc0 <MX66UW1G45G_ResetEnable+0x32>
    return MX66UW1G45G_ERROR;
34002fe2:	f04f 30ff 	mov.w	r0, #4294967295
34002fe6:	e7f6      	b.n	34002fd6 <MX66UW1G45G_ResetEnable+0x48>

34002fe8 <MX66UW1G45G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34002fe8:	b570      	push	{r4, r5, r6, lr}
34002fea:	460d      	mov	r5, r1
34002fec:	b094      	sub	sp, #80	@ 0x50
34002fee:	4606      	mov	r6, r0
34002ff0:	4614      	mov	r4, r2
  XSPI_RegularCmdTypeDef s_command = {0};
34002ff2:	2100      	movs	r1, #0
34002ff4:	224c      	movs	r2, #76	@ 0x4c
34002ff6:	a801      	add	r0, sp, #4
34002ff8:	f015 fe34 	bl	34018c64 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34002ffc:	b9bd      	cbnz	r5, 3400302e <MX66UW1G45G_ResetMemory+0x46>
34002ffe:	2c01      	cmp	r4, #1
34003000:	d01d      	beq.n	3400303e <MX66UW1G45G_ResetMemory+0x56>
34003002:	2301      	movs	r3, #1
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34003004:	462c      	mov	r4, r5
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34003006:	9304      	str	r3, [sp, #16]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34003008:	9406      	str	r4, [sp, #24]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
3400300a:	b1b5      	cbz	r5, 3400303a <MX66UW1G45G_ResetMemory+0x52>
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
3400300c:	2310      	movs	r3, #16
3400300e:	9305      	str	r3, [sp, #20]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_MEMORY_CMD
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34003010:	f649 1366 	movw	r3, #39270	@ 0x9966
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003014:	f241 3288 	movw	r2, #5000	@ 0x1388
34003018:	4630      	mov	r0, r6
3400301a:	a901      	add	r1, sp, #4
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3400301c:	9303      	str	r3, [sp, #12]
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400301e:	f00d f809 	bl	34010034 <HAL_XSPI_Command>
34003022:	3800      	subs	r0, #0
34003024:	bf18      	it	ne
34003026:	2001      	movne	r0, #1
34003028:	4240      	negs	r0, r0
  {
    return MX66UW1G45G_ERROR;
  }

  return MX66UW1G45G_OK;
}
3400302a:	b014      	add	sp, #80	@ 0x50
3400302c:	bd70      	pop	{r4, r5, r6, pc}
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3400302e:	1e63      	subs	r3, r4, #1
34003030:	425c      	negs	r4, r3
34003032:	415c      	adcs	r4, r3
34003034:	00e4      	lsls	r4, r4, #3
34003036:	2304      	movs	r3, #4
34003038:	e7e5      	b.n	34003006 <MX66UW1G45G_ResetMemory+0x1e>
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
3400303a:	2399      	movs	r3, #153	@ 0x99
3400303c:	e7ea      	b.n	34003014 <MX66UW1G45G_ResetMemory+0x2c>
    return MX66UW1G45G_ERROR;
3400303e:	f04f 30ff 	mov.w	r0, #4294967295
34003042:	e7f2      	b.n	3400302a <MX66UW1G45G_ResetMemory+0x42>

34003044 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003044:	4b04      	ldr	r3, [pc, #16]	@ (34003058 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34003046:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003048:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3400304c:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003050:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003052:	9b01      	ldr	r3, [sp, #4]
}
34003054:	b002      	add	sp, #8
34003056:	4770      	bx	lr
34003058:	56028000 	.word	0x56028000

3400305c <BSP_SMPS_Init>:
  * @param Voltage configuration
  *          This parameter can be one of the following values:
  *            @arg  SMPS_VOLTAGE_NOMINAL
  *            @arg  SMPS_VOLTAGE_OVERDRIVE
  */
void BSP_SMPS_Init(SMPSVoltage_TypeDef Voltage){
3400305c:	b570      	push	{r4, r5, r6, lr}
3400305e:	4604      	mov	r4, r0
34003060:	b086      	sub	sp, #24
  SMPS_GPIO_CLK_ENABLE();
34003062:	2020      	movs	r0, #32
34003064:	f7ff ffee 	bl	34003044 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitTypeDef  gpio_init_structure = {0};
34003068:	2300      	movs	r3, #0
  /* configure the external SMPS control pin */
  gpio_init_structure.Pin = SMPS_GPIO_PIN;
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
3400306a:	2610      	movs	r6, #16
  GPIO_InitTypeDef  gpio_init_structure = {0};
3400306c:	9303      	str	r3, [sp, #12]
3400306e:	9305      	str	r3, [sp, #20]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34003070:	2301      	movs	r3, #1
34003072:	e9cd 6301 	strd	r6, r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34003076:	2303      	movs	r3, #3
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34003078:	4d06      	ldr	r5, [pc, #24]	@ (34003094 <BSP_SMPS_Init+0x38>)
3400307a:	a901      	add	r1, sp, #4
3400307c:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3400307e:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init (SMPS_GPIO_PORT, &gpio_init_structure);
34003080:	f004 fac6 	bl	34007610 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(SMPS_GPIO_PORT, SMPS_GPIO_PIN, (GPIO_PinState) Voltage);
34003084:	4622      	mov	r2, r4
34003086:	4631      	mov	r1, r6
34003088:	4628      	mov	r0, r5
3400308a:	f004 fe07 	bl	34007c9c <HAL_GPIO_WritePin>
}
3400308e:	b006      	add	sp, #24
34003090:	bd70      	pop	{r4, r5, r6, pc}
34003092:	bf00      	nop
34003094:	56021400 	.word	0x56021400

34003098 <MX_USART1_Init>:
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
  /* USART configuration */
  huart->Instance          = COM_UART[COM1];
34003098:	4a09      	ldr	r2, [pc, #36]	@ (340030c0 <MX_USART1_Init+0x28>)
3400309a:	6812      	ldr	r2, [r2, #0]
3400309c:	6002      	str	r2, [r0, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
3400309e:	680a      	ldr	r2, [r1, #0]
340030a0:	6042      	str	r2, [r0, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
340030a2:	220c      	movs	r2, #12
340030a4:	6142      	str	r2, [r0, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
340030a6:	894a      	ldrh	r2, [r1, #10]
340030a8:	6102      	str	r2, [r0, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
340030aa:	684a      	ldr	r2, [r1, #4]
340030ac:	6082      	str	r2, [r0, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
340030ae:	890a      	ldrh	r2, [r1, #8]
340030b0:	60c2      	str	r2, [r0, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
340030b2:	898a      	ldrh	r2, [r1, #12]
340030b4:	6182      	str	r2, [r0, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
340030b6:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340030ba:	61c2      	str	r2, [r0, #28]

  return HAL_UART_Init(huart);
340030bc:	f00c bc62 	b.w	3400f984 <HAL_UART_Init>
340030c0:	3403edc4 	.word	0x3403edc4

340030c4 <MX_USART2_Init>:
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART2_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
  /* USART configuration */
  huart->Instance          = COM_UART[COM2];
340030c4:	4a09      	ldr	r2, [pc, #36]	@ (340030ec <MX_USART2_Init+0x28>)
340030c6:	6852      	ldr	r2, [r2, #4]
340030c8:	6002      	str	r2, [r0, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
340030ca:	680a      	ldr	r2, [r1, #0]
340030cc:	6042      	str	r2, [r0, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
340030ce:	220c      	movs	r2, #12
340030d0:	6142      	str	r2, [r0, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
340030d2:	894a      	ldrh	r2, [r1, #10]
340030d4:	6102      	str	r2, [r0, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
340030d6:	684a      	ldr	r2, [r1, #4]
340030d8:	6082      	str	r2, [r0, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
340030da:	890a      	ldrh	r2, [r1, #8]
340030dc:	60c2      	str	r2, [r0, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
340030de:	898a      	ldrh	r2, [r1, #12]
340030e0:	6182      	str	r2, [r0, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
340030e2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340030e6:	61c2      	str	r2, [r0, #28]

  return HAL_UART_Init(huart);
340030e8:	f00c bc4c 	b.w	3400f984 <HAL_UART_Init>
340030ec:	3403edc4 	.word	0x3403edc4

340030f0 <BSP_COM_Init>:
{
340030f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(COM >= COMn)
340030f4:	2801      	cmp	r0, #1
{
340030f6:	4604      	mov	r4, r0
340030f8:	460f      	mov	r7, r1
340030fa:	b08e      	sub	sp, #56	@ 0x38
  if(COM >= COMn)
340030fc:	d870      	bhi.n	340031e0 <BSP_COM_Init+0xf0>
    hcom_uart[COM].Instance = COM_UART[COM];
340030fe:	2294      	movs	r2, #148	@ 0x94
34003100:	4b39      	ldr	r3, [pc, #228]	@ (340031e8 <BSP_COM_Init+0xf8>)
34003102:	4342      	muls	r2, r0
34003104:	4939      	ldr	r1, [pc, #228]	@ (340031ec <BSP_COM_Init+0xfc>)
34003106:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    UART_MspInit(&hcom_uart[COM]);
3400310a:	4245      	negs	r5, r0
3400310c:	f005 0594 	and.w	r5, r5, #148	@ 0x94
    hcom_uart[COM].Instance = COM_UART[COM];
34003110:	508b      	str	r3, [r1, r2]
    UART_MspInit(&hcom_uart[COM]);
34003112:	440d      	add	r5, r1
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
  GPIO_InitTypeDef GPIO_Init;
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
34003114:	4a36      	ldr	r2, [pc, #216]	@ (340031f0 <BSP_COM_Init+0x100>)
34003116:	4937      	ldr	r1, [pc, #220]	@ (340031f4 <BSP_COM_Init+0x104>)
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
34003118:	9207      	str	r2, [sp, #28]
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT, COM2_TX_GPIO_PORT};
3400311a:	e9cd 2105 	strd	r2, r1, [sp, #20]
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT, COM2_RX_GPIO_PORT};
3400311e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
34003122:	9208      	str	r2, [sp, #32]
  uint16_t         COM_TX_PIN[COMn]  = {COM1_TX_PIN, COM2_TX_PIN};
  uint16_t         COM_RX_PIN[COMn]  = {COM1_RX_PIN, COM2_RX_PIN};
34003124:	f04f 1240 	mov.w	r2, #4194368	@ 0x400040
34003128:	9202      	str	r2, [sp, #8]
  uint8_t          COM_TX_AF[COMn]   = {COM1_TX_AF, COM2_TX_AF};
  uint8_t          COM_RX_AF[COMn]   = {COM1_RX_AF, COM2_RX_AF};
3400312a:	f240 7207 	movw	r2, #1799	@ 0x707
3400312e:	f8ad 2004 	strh.w	r2, [sp, #4]
  COM_TypeDef      COM;

  /* Get COM according instance */
  if (huart->Instance == COM1_UART)
34003132:	4a31      	ldr	r2, [pc, #196]	@ (340031f8 <BSP_COM_Init+0x108>)
34003134:	4293      	cmp	r3, r2
34003136:	d13a      	bne.n	340031ae <BSP_COM_Init+0xbe>
  {
    COM = COM1;
    /* Enable COM and GPIO clocks */
    COM1_TX_GPIO_CLK_ENABLE();
34003138:	2010      	movs	r0, #16
    COM = COM1;
3400313a:	2600      	movs	r6, #0
    COM1_TX_GPIO_CLK_ENABLE();
3400313c:	f7ff ff82 	bl	34003044 <LL_AHB4_GRP1_EnableClock>
    COM1_RX_GPIO_CLK_ENABLE();
34003140:	f7ff ff80 	bl	34003044 <LL_AHB4_GRP1_EnableClock>
  WRITE_REG(RCC->APB2ENSR, Periphs);
34003144:	4b2d      	ldr	r3, [pc, #180]	@ (340031fc <BSP_COM_Init+0x10c>)
34003146:	f8c3 0a6c 	str.w	r0, [r3, #2668]	@ 0xa6c
  tmpreg = READ_REG(RCC->APB2ENR);
3400314a:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
3400314e:	9303      	str	r3, [sp, #12]
  (void)tmpreg;
34003150:	9b03      	ldr	r3, [sp, #12]
      return;
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
34003152:	2302      	movs	r3, #2
34003154:	2220      	movs	r2, #32
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
34003156:	930c      	str	r3, [sp, #48]	@ 0x30
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
34003158:	e9cd 2309 	strd	r2, r3, [sp, #36]	@ 0x24
  GPIO_Init.Pull      = GPIO_PULLUP;
3400315c:	2301      	movs	r3, #1
3400315e:	930b      	str	r3, [sp, #44]	@ 0x2c
  GPIO_Init.Alternate = COM_TX_AF[COM];
34003160:	2307      	movs	r3, #7
34003162:	930d      	str	r3, [sp, #52]	@ 0x34
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
34003164:	ab0e      	add	r3, sp, #56	@ 0x38
34003166:	eb03 0886 	add.w	r8, r3, r6, lsl #2
3400316a:	f858 0c24 	ldr.w	r0, [r8, #-36]
3400316e:	a909      	add	r1, sp, #36	@ 0x24
34003170:	f004 fa4e 	bl	34007610 <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
34003174:	ab0e      	add	r3, sp, #56	@ 0x38
34003176:	eb03 0346 	add.w	r3, r3, r6, lsl #1
3400317a:	f833 3c30 	ldrh.w	r3, [r3, #-48]
  GPIO_Init.Alternate = COM_RX_AF[COM];
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
3400317e:	f858 0c1c 	ldr.w	r0, [r8, #-28]
  GPIO_Init.Pin       = COM_RX_PIN[COM];
34003182:	9309      	str	r3, [sp, #36]	@ 0x24
  GPIO_Init.Alternate = COM_RX_AF[COM];
34003184:	f106 0338 	add.w	r3, r6, #56	@ 0x38
34003188:	eb0d 0603 	add.w	r6, sp, r3
3400318c:	f816 3c34 	ldrb.w	r3, [r6, #-52]
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
34003190:	a909      	add	r1, sp, #36	@ 0x24
  GPIO_Init.Alternate = COM_RX_AF[COM];
34003192:	930d      	str	r3, [sp, #52]	@ 0x34
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
34003194:	f004 fa3c 	bl	34007610 <HAL_GPIO_Init>
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
34003198:	4639      	mov	r1, r7
3400319a:	4628      	mov	r0, r5
      if (COM == COM1)
3400319c:	b9ec      	cbnz	r4, 340031da <BSP_COM_Init+0xea>
        if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
3400319e:	f7ff ff7b 	bl	34003098 <MX_USART1_Init>
340031a2:	b1c0      	cbz	r0, 340031d6 <BSP_COM_Init+0xe6>
          ret = BSP_ERROR_PERIPH_FAILURE;
340031a4:	f06f 0003 	mvn.w	r0, #3
}
340031a8:	b00e      	add	sp, #56	@ 0x38
340031aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (huart->Instance == COM2_UART)
340031ae:	4a14      	ldr	r2, [pc, #80]	@ (34003200 <BSP_COM_Init+0x110>)
340031b0:	4293      	cmp	r3, r2
340031b2:	d1f1      	bne.n	34003198 <BSP_COM_Init+0xa8>
  WRITE_REG(RCC->APB1ENSR1, Periphs);
340031b4:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
    COM2_TX_GPIO_CLK_ENABLE();
340031b8:	2008      	movs	r0, #8
340031ba:	f7ff ff43 	bl	34003044 <LL_AHB4_GRP1_EnableClock>
    COM2_RX_GPIO_CLK_ENABLE();
340031be:	2020      	movs	r0, #32
340031c0:	f7ff ff40 	bl	34003044 <LL_AHB4_GRP1_EnableClock>
340031c4:	4b0d      	ldr	r3, [pc, #52]	@ (340031fc <BSP_COM_Init+0x10c>)
    COM = COM2;
340031c6:	2601      	movs	r6, #1
340031c8:	f8c3 2a64 	str.w	r2, [r3, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
340031cc:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
340031d0:	9304      	str	r3, [sp, #16]
  (void)tmpreg;
340031d2:	9b04      	ldr	r3, [sp, #16]
}
340031d4:	e7bd      	b.n	34003152 <BSP_COM_Init+0x62>
  int32_t ret = BSP_ERROR_NONE;
340031d6:	2000      	movs	r0, #0
340031d8:	e7e6      	b.n	340031a8 <BSP_COM_Init+0xb8>
        if (MX_USART2_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
340031da:	f7ff ff73 	bl	340030c4 <MX_USART2_Init>
340031de:	e7e0      	b.n	340031a2 <BSP_COM_Init+0xb2>
    ret = BSP_ERROR_WRONG_PARAM;
340031e0:	f06f 0001 	mvn.w	r0, #1
  return ret;
340031e4:	e7e0      	b.n	340031a8 <BSP_COM_Init+0xb8>
340031e6:	bf00      	nop
340031e8:	3403edc4 	.word	0x3403edc4
340031ec:	34056b94 	.word	0x34056b94
340031f0:	56021000 	.word	0x56021000
340031f4:	56020c00 	.word	0x56020c00
340031f8:	52001000 	.word	0x52001000
340031fc:	56028000 	.word	0x56028000
34003200:	50004400 	.word	0x50004400

34003204 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003204:	4b04      	ldr	r3, [pc, #16]	@ (34003218 <LL_AHB4_GRP1_EnableClock+0x14>)
{
34003206:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003208:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3400320c:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003210:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003212:	9b01      	ldr	r3, [sp, #4]
}
34003214:	b002      	add	sp, #8
34003216:	4770      	bx	lr
34003218:	56028000 	.word	0x56028000

3400321c <I2C_GetTiming.constprop.0>:
  * @brief  Compute I2C timing according current I2C clock source and required I2C clock.
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
3400321c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34003220:	b08b      	sub	sp, #44	@ 0x2c
{
  uint32_t ret = 0;
  uint32_t speed;
  uint32_t idx;

  if ((clock_src_freq != 0U) && (i2c_freq != 0U))
34003222:	b918      	cbnz	r0, 3400322c <I2C_GetTiming.constprop.0+0x10>
  uint32_t ret = 0;
34003224:	2000      	movs	r0, #0
      }
    }
  }

  return ret;
}
34003226:	b00b      	add	sp, #44	@ 0x2c
34003228:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint32_t scldel;
  uint32_t sdadel;
  uint32_t tafdel_min;
  uint32_t tafdel_max;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
3400322c:	4b6f      	ldr	r3, [pc, #444]	@ (340033ec <I2C_GetTiming.constprop.0+0x1d0>)
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / tPRESC */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
3400322e:	f640 15f6 	movw	r5, #2550	@ 0x9f6
  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34003232:	eb03 0350 	add.w	r3, r3, r0, lsr #1
34003236:	fbb3 f3f0 	udiv	r3, r3, r0
3400323a:	9300      	str	r3, [sp, #0]
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
3400323c:	005b      	lsls	r3, r3, #1
3400323e:	9301      	str	r3, [sp, #4]
34003240:	9b00      	ldr	r3, [sp, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
34003242:	f04f 0b10 	mov.w	fp, #16
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34003246:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
3400324a:	eba5 0583 	sub.w	r5, r5, r3, lsl #2
  if (tsdadel_min <= 0)
  {
    tsdadel_min = 0;
  }

  if (tsdadel_max <= 0)
3400324e:	4619      	mov	r1, r3
34003250:	2300      	movs	r3, #0
34003252:	469a      	mov	sl, r3
34003254:	f8df c19c 	ldr.w	ip, [pc, #412]	@ 340033f4 <I2C_GetTiming.constprop.0+0x1d8>
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34003258:	f1c4 24ff 	rsb	r4, r4, #4278255360	@ 0xff00ff00
3400325c:	f504 047f 	add.w	r4, r4, #16711680	@ 0xff0000
34003260:	34e2      	adds	r4, #226	@ 0xe2
34003262:	f8dc 2000 	ldr.w	r2, [ip]
  if (tsdadel_min <= 0)
34003266:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
  if (tsdadel_max <= 0)
3400326a:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
3400326e:	468e      	mov	lr, r1
    tsdadel_max = 0;
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
34003270:	2700      	movs	r7, #0
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;

      if (tscldel >= (uint32_t)tscldel_min)
34003272:	f240 3079 	movw	r0, #889	@ 0x379
34003276:	4586      	cmp	lr, r0
34003278:	9702      	str	r7, [sp, #8]
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
3400327a:	f107 0701 	add.w	r7, r7, #1
      if (tscldel >= (uint32_t)tscldel_min)
3400327e:	d950      	bls.n	34003322 <I2C_GetTiming.constprop.0+0x106>
34003280:	2600      	movs	r6, #0
34003282:	f04f 0810 	mov.w	r8, #16
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34003286:	46b1      	mov	r9, r6
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
34003288:	42b4      	cmp	r4, r6
3400328a:	d844      	bhi.n	34003316 <I2C_GetTiming.constprop.0+0xfa>
3400328c:	42b5      	cmp	r5, r6
3400328e:	d342      	bcc.n	34003316 <I2C_GetTiming.constprop.0+0xfa>
          {
            if (presc != prev_presc)
34003290:	459b      	cmp	fp, r3
34003292:	d040      	beq.n	34003316 <I2C_GetTiming.constprop.0+0xfa>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
34003294:	2014      	movs	r0, #20
34003296:	fb00 fb02 	mul.w	fp, r0, r2
3400329a:	4855      	ldr	r0, [pc, #340]	@ (340033f0 <I2C_GetTiming.constprop.0+0x1d4>)
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
              prev_presc = presc;
              I2c_valid_timing_nbr ++;
3400329c:	3201      	adds	r2, #1
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
3400329e:	eb00 0a0b 	add.w	sl, r0, fp
340032a2:	f840 300b 	str.w	r3, [r0, fp]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
340032a6:	9802      	ldr	r0, [sp, #8]

              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
340032a8:	2a7f      	cmp	r2, #127	@ 0x7f
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
340032aa:	e9ca 0901 	strd	r0, r9, [sl, #4]
              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
340032ae:	d92f      	bls.n	34003310 <I2C_GetTiming.constprop.0+0xf4>
340032b0:	f8cc 2000 	str.w	r2, [ip]
  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;

  prev_error = ti2cspeed;

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340032b4:	f8dc 3000 	ldr.w	r3, [ip]
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
340032b8:	2600      	movs	r6, #0
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340032ba:	9306      	str	r3, [sp, #24]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
340032bc:	f242 7310 	movw	r3, #10000	@ 0x2710
340032c0:	f04f 32ff 	mov.w	r2, #4294967295
340032c4:	9304      	str	r3, [sp, #16]
340032c6:	9b01      	ldr	r3, [sp, #4]
340032c8:	4949      	ldr	r1, [pc, #292]	@ (340033f0 <I2C_GetTiming.constprop.0+0x1d4>)
340032ca:	3332      	adds	r3, #50	@ 0x32
340032cc:	9309      	str	r3, [sp, #36]	@ 0x24
340032ce:	9b01      	ldr	r3, [sp, #4]
340032d0:	f5c3 5e90 	rsb	lr, r3, #4608	@ 0x1200
340032d4:	f10e 0e0c 	add.w	lr, lr, #12
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340032d8:	9b06      	ldr	r3, [sp, #24]
340032da:	429e      	cmp	r6, r3
340032dc:	d12d      	bne.n	3400333a <I2C_GetTiming.constprop.0+0x11e>
        if (idx < I2C_VALID_TIMING_NBR)
340032de:	2a7f      	cmp	r2, #127	@ 0x7f
340032e0:	d8a0      	bhi.n	34003224 <I2C_GetTiming.constprop.0+0x8>
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
340032e2:	2114      	movs	r1, #20
340032e4:	434a      	muls	r2, r1
340032e6:	4b42      	ldr	r3, [pc, #264]	@ (340033f0 <I2C_GetTiming.constprop.0+0x1d4>)
340032e8:	1899      	adds	r1, r3, r2
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
340032ea:	7c08      	ldrb	r0, [r1, #16]
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
340032ec:	589b      	ldr	r3, [r3, r2]
340032ee:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
340032f2:	684b      	ldr	r3, [r1, #4]
340032f4:	051b      	lsls	r3, r3, #20
340032f6:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
340032fa:	4318      	orrs	r0, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
340032fc:	688b      	ldr	r3, [r1, #8]
340032fe:	041b      	lsls	r3, r3, #16
34003300:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34003304:	4318      	orrs	r0, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
34003306:	68cb      	ldr	r3, [r1, #12]
34003308:	021b      	lsls	r3, r3, #8
3400330a:	b29b      	uxth	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
3400330c:	4318      	orrs	r0, r3
  return ret;
3400330e:	e78a      	b.n	34003226 <I2C_GetTiming.constprop.0+0xa>
              prev_presc = presc;
34003310:	469b      	mov	fp, r3
34003312:	f04f 0a01 	mov.w	sl, #1
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34003316:	f1b8 0801 	subs.w	r8, r8, #1
3400331a:	f109 0901 	add.w	r9, r9, #1
3400331e:	440e      	add	r6, r1
34003320:	d1b2      	bne.n	34003288 <I2C_GetTiming.constprop.0+0x6c>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
34003322:	2f10      	cmp	r7, #16
34003324:	448e      	add	lr, r1
34003326:	d1a4      	bne.n	34003272 <I2C_GetTiming.constprop.0+0x56>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34003328:	9800      	ldr	r0, [sp, #0]
3400332a:	3301      	adds	r3, #1
3400332c:	2b10      	cmp	r3, #16
3400332e:	4401      	add	r1, r0
34003330:	d19d      	bne.n	3400326e <I2C_GetTiming.constprop.0+0x52>
34003332:	f1ba 0f00 	cmp.w	sl, #0
34003336:	d1bb      	bne.n	340032b0 <I2C_GetTiming.constprop.0+0x94>
34003338:	e7bc      	b.n	340032b4 <I2C_GetTiming.constprop.0+0x98>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
3400333a:	2700      	movs	r7, #0
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
3400333c:	9800      	ldr	r0, [sp, #0]
3400333e:	680b      	ldr	r3, [r1, #0]
34003340:	fb03 0300 	mla	r3, r3, r0, r0
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34003344:	9809      	ldr	r0, [sp, #36]	@ 0x24
34003346:	ebae 0403 	sub.w	r4, lr, r3
3400334a:	4418      	add	r0, r3
3400334c:	9003      	str	r0, [sp, #12]
3400334e:	9801      	ldr	r0, [sp, #4]
34003350:	ea4f 0b44 	mov.w	fp, r4, lsl #1
34003354:	181d      	adds	r5, r3, r0
34003356:	f5a5 5011 	sub.w	r0, r5, #9280	@ 0x2440
3400335a:	380a      	subs	r0, #10
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
3400335c:	9c03      	ldr	r4, [sp, #12]
3400335e:	9002      	str	r0, [sp, #8]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34003360:	f241 205c 	movw	r0, #4700	@ 0x125c
34003364:	4284      	cmp	r4, r0
34003366:	9708      	str	r7, [sp, #32]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34003368:	f107 0701 	add.w	r7, r7, #1
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
3400336c:	d935      	bls.n	340033da <I2C_GetTiming.constprop.0+0x1be>
3400336e:	9800      	ldr	r0, [sp, #0]
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34003370:	f1a4 0532 	sub.w	r5, r4, #50	@ 0x32
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34003374:	ebb0 0f95 	cmp.w	r0, r5, lsr #2
34003378:	d22f      	bcs.n	340033da <I2C_GetTiming.constprop.0+0x1be>
3400337a:	9802      	ldr	r0, [sp, #8]
3400337c:	46d8      	mov	r8, fp
3400337e:	1905      	adds	r5, r0, r4
            if ((uint32_t)error < prev_error)
            {
              prev_error = (uint32_t)error;
              I2c_valid_timing[count].scll = scll;
              I2c_valid_timing[count].sclh = sclh;
              ret = count;
34003380:	f44f 7080 	mov.w	r0, #256	@ 0x100
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
34003384:	f04f 0900 	mov.w	r9, #0
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34003388:	f8dd c00c 	ldr.w	ip, [sp, #12]
              ret = count;
3400338c:	9005      	str	r0, [sp, #20]
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
3400338e:	f241 0047 	movw	r0, #4167	@ 0x1047
34003392:	f205 6a83 	addw	sl, r5, #1667	@ 0x683
34003396:	4582      	cmp	sl, r0
34003398:	f8cd 901c 	str.w	r9, [sp, #28]
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
3400339c:	f109 0901 	add.w	r9, r9, #1
          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
340033a0:	d813      	bhi.n	340033ca <I2C_GetTiming.constprop.0+0x1ae>
340033a2:	f5bc 6f7a 	cmp.w	ip, #4000	@ 0xfa0
340033a6:	d310      	bcc.n	340033ca <I2C_GetTiming.constprop.0+0x1ae>
340033a8:	9800      	ldr	r0, [sp, #0]
340033aa:	4560      	cmp	r0, ip
340033ac:	d20d      	bcs.n	340033ca <I2C_GetTiming.constprop.0+0x1ae>
              error = -error;
340033ae:	2d00      	cmp	r5, #0
340033b0:	bfac      	ite	ge
340033b2:	46aa      	movge	sl, r5
340033b4:	46c2      	movlt	sl, r8
            if ((uint32_t)error < prev_error)
340033b6:	9804      	ldr	r0, [sp, #16]
340033b8:	4582      	cmp	sl, r0
340033ba:	d206      	bcs.n	340033ca <I2C_GetTiming.constprop.0+0x1ae>
              I2c_valid_timing[count].scll = scll;
340033bc:	9a08      	ldr	r2, [sp, #32]
              prev_error = (uint32_t)error;
340033be:	f8cd a010 	str.w	sl, [sp, #16]
              I2c_valid_timing[count].scll = scll;
340033c2:	610a      	str	r2, [r1, #16]
              I2c_valid_timing[count].sclh = sclh;
340033c4:	9a07      	ldr	r2, [sp, #28]
340033c6:	60ca      	str	r2, [r1, #12]
              ret = count;
340033c8:	4632      	mov	r2, r6
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
340033ca:	9805      	ldr	r0, [sp, #20]
340033cc:	449c      	add	ip, r3
340033ce:	3801      	subs	r0, #1
340033d0:	441d      	add	r5, r3
340033d2:	eba8 0803 	sub.w	r8, r8, r3
340033d6:	9005      	str	r0, [sp, #20]
340033d8:	d1d9      	bne.n	3400338e <I2C_GetTiming.constprop.0+0x172>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
340033da:	f5b7 7f80 	cmp.w	r7, #256	@ 0x100
340033de:	441c      	add	r4, r3
340033e0:	ebab 0b03 	sub.w	fp, fp, r3
340033e4:	d1bc      	bne.n	34003360 <I2C_GetTiming.constprop.0+0x144>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
340033e6:	3601      	adds	r6, #1
340033e8:	3114      	adds	r1, #20
340033ea:	e775      	b.n	340032d8 <I2C_GetTiming.constprop.0+0xbc>
340033ec:	3b9aca00 	.word	0x3b9aca00
340033f0:	34056d14 	.word	0x34056d14
340033f4:	34056d10 	.word	0x34056d10

340033f8 <BSP_I2C1_DeInit>:
  I2c1InitCounter--;
340033f8:	4a0e      	ldr	r2, [pc, #56]	@ (34003434 <BSP_I2C1_DeInit+0x3c>)
{
340033fa:	b508      	push	{r3, lr}
  I2c1InitCounter--;
340033fc:	6813      	ldr	r3, [r2, #0]
340033fe:	3b01      	subs	r3, #1
34003400:	6013      	str	r3, [r2, #0]
  if (I2c1InitCounter == 0U)
34003402:	b10b      	cbz	r3, 34003408 <BSP_I2C1_DeInit+0x10>
  int32_t ret = BSP_ERROR_NONE;
34003404:	2000      	movs	r0, #0
}
34003406:	bd08      	pop	{r3, pc}
  HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, gpio_init_structure.Pin );
34003408:	f44f 7100 	mov.w	r1, #512	@ 0x200
3400340c:	480a      	ldr	r0, [pc, #40]	@ (34003438 <BSP_I2C1_DeInit+0x40>)
3400340e:	f004 fb17 	bl	34007a40 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, gpio_init_structure.Pin);
34003412:	480a      	ldr	r0, [pc, #40]	@ (3400343c <BSP_I2C1_DeInit+0x44>)
34003414:	2102      	movs	r1, #2
34003416:	f004 fb13 	bl	34007a40 <HAL_GPIO_DeInit>
  WRITE_REG(RCC->APB1ENCR1, Periphs);
3400341a:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
3400341e:	4b08      	ldr	r3, [pc, #32]	@ (34003440 <BSP_I2C1_DeInit+0x48>)
    if (HAL_I2C_DeInit(&hbus_i2c1) != HAL_OK)
34003420:	4808      	ldr	r0, [pc, #32]	@ (34003444 <BSP_I2C1_DeInit+0x4c>)
34003422:	f8c3 2264 	str.w	r2, [r3, #612]	@ 0x264
34003426:	f004 fe99 	bl	3400815c <HAL_I2C_DeInit>
3400342a:	2800      	cmp	r0, #0
3400342c:	d0ea      	beq.n	34003404 <BSP_I2C1_DeInit+0xc>
      ret = BSP_ERROR_BUS_FAILURE;
3400342e:	f06f 0007 	mvn.w	r0, #7
  return ret;
34003432:	e7e8      	b.n	34003406 <BSP_I2C1_DeInit+0xe>
34003434:	34057714 	.word	0x34057714
34003438:	56021c00 	.word	0x56021c00
3400343c:	56020800 	.word	0x56020800
34003440:	56029000 	.word	0x56029000
34003444:	34056cbc 	.word	0x34056cbc

34003448 <MX_I2C1_Init>:
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
34003448:	2300      	movs	r3, #0
3400344a:	2201      	movs	r2, #1
{
3400344c:	b510      	push	{r4, lr}
  hI2c->Init.Timing           = timing;
3400344e:	6041      	str	r1, [r0, #4]
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
34003450:	e9c0 3202 	strd	r3, r2, [r0, #8]
  hI2c->Init.OwnAddress2      = 0;
34003454:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
34003458:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
3400345c:	6203      	str	r3, [r0, #32]
{
3400345e:	4604      	mov	r4, r0
  if (HAL_I2C_Init(hI2c) != HAL_OK)
34003460:	f004 fdba 	bl	34007fd8 <HAL_I2C_Init>
34003464:	4601      	mov	r1, r0
34003466:	b108      	cbz	r0, 3400346c <MX_I2C1_Init+0x24>
    status = HAL_ERROR;
34003468:	2001      	movs	r0, #1
}
3400346a:	bd10      	pop	{r4, pc}
    if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
3400346c:	4620      	mov	r0, r4
3400346e:	f005 f88f 	bl	34008590 <HAL_I2CEx_ConfigAnalogFilter>
34003472:	4601      	mov	r1, r0
34003474:	2800      	cmp	r0, #0
34003476:	d1f7      	bne.n	34003468 <MX_I2C1_Init+0x20>
      if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
34003478:	4620      	mov	r0, r4
3400347a:	f005 f8e3 	bl	34008644 <HAL_I2CEx_ConfigDigitalFilter>
3400347e:	3800      	subs	r0, #0
34003480:	bf18      	it	ne
34003482:	2001      	movne	r0, #1
34003484:	e7f1      	b.n	3400346a <MX_I2C1_Init+0x22>
	...

34003488 <BSP_I2C1_Init>:
{
34003488:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hbus_i2c1.Instance = BUS_I2C1;
3400348c:	4b28      	ldr	r3, [pc, #160]	@ (34003530 <BSP_I2C1_Init+0xa8>)
3400348e:	4e29      	ldr	r6, [pc, #164]	@ (34003534 <BSP_I2C1_Init+0xac>)
{
34003490:	b086      	sub	sp, #24
  hbus_i2c1.Instance = BUS_I2C1;
34003492:	6033      	str	r3, [r6, #0]
  if (I2c1InitCounter == 0U)
34003494:	4b28      	ldr	r3, [pc, #160]	@ (34003538 <BSP_I2C1_Init+0xb0>)
34003496:	681a      	ldr	r2, [r3, #0]
34003498:	b11a      	cbz	r2, 340034a2 <BSP_I2C1_Init+0x1a>
  int32_t ret = BSP_ERROR_NONE;
3400349a:	2000      	movs	r0, #0
}
3400349c:	b006      	add	sp, #24
3400349e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    I2c1InitCounter++;
340034a2:	2201      	movs	r2, #1
    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
340034a4:	4630      	mov	r0, r6
    I2c1InitCounter++;
340034a6:	601a      	str	r2, [r3, #0]
    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
340034a8:	f005 f86c 	bl	34008584 <HAL_I2C_GetState>
340034ac:	4604      	mov	r4, r0
340034ae:	2800      	cmp	r0, #0
340034b0:	d1f3      	bne.n	3400349a <BSP_I2C1_Init+0x12>
  HAL_PWREx_EnableVddIO4();
340034b2:	f005 fdc7 	bl	34009044 <HAL_PWREx_EnableVddIO4>
  BUS_I2C1_SCL_GPIO_CLK_ENABLE();
340034b6:	2080      	movs	r0, #128	@ 0x80
340034b8:	f7ff fea4 	bl	34003204 <LL_AHB4_GRP1_EnableClock>
  BUS_I2C1_SDA_GPIO_CLK_ENABLE();
340034bc:	2004      	movs	r0, #4
340034be:	f7ff fea1 	bl	34003204 <LL_AHB4_GRP1_EnableClock>
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
340034c2:	2702      	movs	r7, #2
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340034c4:	f44f 7300 	mov.w	r3, #512	@ 0x200
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
340034c8:	4605      	mov	r5, r0
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340034ca:	f04f 0812 	mov.w	r8, #18
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
340034ce:	eb0d 0100 	add.w	r1, sp, r0
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
340034d2:	9005      	str	r0, [sp, #20]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
340034d4:	4819      	ldr	r0, [pc, #100]	@ (3400353c <BSP_I2C1_Init+0xb4>)
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340034d6:	e9cd 3801 	strd	r3, r8, [sp, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
340034da:	9403      	str	r4, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
340034dc:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
340034de:	f004 f897 	bl	34007610 <HAL_GPIO_Init>
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
340034e2:	4817      	ldr	r0, [pc, #92]	@ (34003540 <BSP_I2C1_Init+0xb8>)
340034e4:	eb0d 0105 	add.w	r1, sp, r5
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
340034e8:	e9cd 7801 	strd	r7, r8, [sp, #4]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
340034ec:	e9cd 4703 	strd	r4, r7, [sp, #12]
  gpio_init_structure.Alternate = BUS_I2C1_SDA_AF;
340034f0:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
340034f2:	f004 f88d 	bl	34007610 <HAL_GPIO_Init>
  WRITE_REG(RCC->APB1ENSR1, Periphs);
340034f6:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
340034fa:	4a12      	ldr	r2, [pc, #72]	@ (34003544 <BSP_I2C1_Init+0xbc>)
340034fc:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
34003500:	f8d2 1264 	ldr.w	r1, [r2, #612]	@ 0x264
34003504:	9100      	str	r1, [sp, #0]
  (void)tmpreg;
34003506:	9900      	ldr	r1, [sp, #0]
  WRITE_REG(RCC->APB1RSTSR1, Periphs);
34003508:	f8c2 3a24 	str.w	r3, [r2, #2596]	@ 0xa24
  WRITE_REG(RCC->APB1RSTCR1, Periphs);
3400350c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003510:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
        if (MX_I2C1_Init(&hbus_i2c1, I2C_GetTiming(HAL_RCC_GetPCLK1Freq(), BUS_I2C1_FREQUENCY)) != HAL_OK)
34003514:	f006 fe48 	bl	3400a1a8 <HAL_RCC_GetPCLK1Freq>
34003518:	f7ff fe80 	bl	3400321c <I2C_GetTiming.constprop.0>
3400351c:	4601      	mov	r1, r0
3400351e:	4630      	mov	r0, r6
34003520:	f7ff ff92 	bl	34003448 <MX_I2C1_Init>
34003524:	2800      	cmp	r0, #0
34003526:	d0b8      	beq.n	3400349a <BSP_I2C1_Init+0x12>
          ret = BSP_ERROR_BUS_FAILURE;
34003528:	f06f 0007 	mvn.w	r0, #7
  return ret;
3400352c:	e7b6      	b.n	3400349c <BSP_I2C1_Init+0x14>
3400352e:	bf00      	nop
34003530:	50005400 	.word	0x50005400
34003534:	34056cbc 	.word	0x34056cbc
34003538:	34057714 	.word	0x34057714
3400353c:	56021c00 	.word	0x56021c00
34003540:	56020800 	.word	0x56020800
34003544:	56028000 	.word	0x56028000

34003548 <BSP_I2C1_WriteReg16>:
{
34003548:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
3400354a:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
3400354e:	9200      	str	r2, [sp, #0]
34003550:	e9cd 3401 	strd	r3, r4, [sp, #4]
34003554:	460a      	mov	r2, r1
34003556:	2302      	movs	r3, #2
34003558:	4601      	mov	r1, r0
3400355a:	4808      	ldr	r0, [pc, #32]	@ (3400357c <BSP_I2C1_WriteReg16+0x34>)
3400355c:	f004 fe46 	bl	340081ec <HAL_I2C_Mem_Write>
    ret = BSP_ERROR_NONE;
34003560:	2300      	movs	r3, #0
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003562:	b140      	cbz	r0, 34003576 <BSP_I2C1_WriteReg16+0x2e>
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34003564:	4805      	ldr	r0, [pc, #20]	@ (3400357c <BSP_I2C1_WriteReg16+0x34>)
34003566:	f005 f810 	bl	3400858a <HAL_I2C_GetError>
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
3400356a:	2804      	cmp	r0, #4
3400356c:	bf14      	ite	ne
3400356e:	f06f 0303 	mvnne.w	r3, #3
34003572:	f06f 0365 	mvneq.w	r3, #101	@ 0x65
}
34003576:	4618      	mov	r0, r3
34003578:	b004      	add	sp, #16
3400357a:	bd10      	pop	{r4, pc}
3400357c:	34056cbc 	.word	0x34056cbc

34003580 <BSP_I2C1_ReadReg16>:
{
34003580:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34003582:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
34003586:	9200      	str	r2, [sp, #0]
34003588:	e9cd 3401 	strd	r3, r4, [sp, #4]
3400358c:	460a      	mov	r2, r1
3400358e:	2302      	movs	r3, #2
34003590:	4601      	mov	r1, r0
34003592:	4808      	ldr	r0, [pc, #32]	@ (340035b4 <BSP_I2C1_ReadReg16+0x34>)
34003594:	f004 ff0e 	bl	340083b4 <HAL_I2C_Mem_Read>
    ret = BSP_ERROR_NONE;
34003598:	2300      	movs	r3, #0
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
3400359a:	b140      	cbz	r0, 340035ae <BSP_I2C1_ReadReg16+0x2e>
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
3400359c:	4805      	ldr	r0, [pc, #20]	@ (340035b4 <BSP_I2C1_ReadReg16+0x34>)
3400359e:	f004 fff4 	bl	3400858a <HAL_I2C_GetError>
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
340035a2:	2804      	cmp	r0, #4
340035a4:	bf14      	ite	ne
340035a6:	f06f 0303 	mvnne.w	r3, #3
340035aa:	f06f 0365 	mvneq.w	r3, #101	@ 0x65
}
340035ae:	4618      	mov	r0, r3
340035b0:	b004      	add	sp, #16
340035b2:	bd10      	pop	{r4, pc}
340035b4:	34056cbc 	.word	0x34056cbc

340035b8 <BSP_GetTick>:
  return (int32_t)HAL_GetTick();
340035b8:	f001 b99a 	b.w	340048f0 <HAL_GetTick>

340035bc <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340035bc:	4b04      	ldr	r3, [pc, #16]	@ (340035d0 <LL_AHB4_GRP1_EnableClock+0x14>)
{
340035be:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340035c0:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
340035c4:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
340035c8:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
340035ca:	9b01      	ldr	r3, [sp, #4]
}
340035cc:	b002      	add	sp, #8
340035ce:	4770      	bx	lr
340035d0:	56028000 	.word	0x56028000

340035d4 <BSP_LCD_GetPixelFormat>:
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
340035d4:	b918      	cbnz	r0, 340035de <BSP_LCD_GetPixelFormat+0xa>
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat =  Lcd_Ctx[Instance].PixelFormat;
340035d6:	4b03      	ldr	r3, [pc, #12]	@ (340035e4 <BSP_LCD_GetPixelFormat+0x10>)
340035d8:	68db      	ldr	r3, [r3, #12]
340035da:	600b      	str	r3, [r1, #0]
340035dc:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
340035de:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
340035e2:	4770      	bx	lr
340035e4:	34057718 	.word	0x34057718

340035e8 <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
340035e8:	b510      	push	{r4, lr}
  int32_t ret = BSP_ERROR_NONE;
  LTDC_LayerCfgTypeDef *pLayerCfg;

  if(Instance >= LCD_INSTANCES_NBR)
340035ea:	bb08      	cbnz	r0, 34003630 <BSP_LCD_SetActiveLayer+0x48>
  else
  {
    pLayerCfg = &hlcd_ltdc.LayerCfg[LayerIndex];

    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
340035ec:	2434      	movs	r4, #52	@ 0x34
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
340035ee:	4b12      	ldr	r3, [pc, #72]	@ (34003638 <BSP_LCD_SetActiveLayer+0x50>)
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
340035f0:	4a12      	ldr	r2, [pc, #72]	@ (3400363c <BSP_LCD_SetActiveLayer+0x54>)
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
340035f2:	6099      	str	r1, [r3, #8]
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
340035f4:	fb04 2101 	mla	r1, r4, r1, r2
340035f8:	6e0a      	ldr	r2, [r1, #96]	@ 0x60
340035fa:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize = pLayerCfg->ImageHeight;
340035fc:	6e4a      	ldr	r2, [r1, #100]	@ 0x64
340035fe:	605a      	str	r2, [r3, #4]

    if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB565)
34003600:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
34003602:	2a04      	cmp	r2, #4
34003604:	d104      	bne.n	34003610 <BSP_LCD_SetActiveLayer+0x28>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
34003606:	2202      	movs	r2, #2
34003608:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB565;
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
    {
      Lcd_Ctx[Instance].BppFactor = 2;
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
3400360a:	60da      	str	r2, [r3, #12]
  int32_t ret = BSP_ERROR_NONE;
3400360c:	2000      	movs	r0, #0
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
    }
  }

  return ret;
}
3400360e:	bd10      	pop	{r4, pc}
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
34003610:	2a08      	cmp	r2, #8
34003612:	d103      	bne.n	3400361c <BSP_LCD_SetActiveLayer+0x34>
      Lcd_Ctx[Instance].BppFactor = 2;
34003614:	2202      	movs	r2, #2
34003616:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34003618:	2204      	movs	r2, #4
3400361a:	e7f6      	b.n	3400360a <BSP_LCD_SetActiveLayer+0x22>
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB888)
3400361c:	2a06      	cmp	r2, #6
3400361e:	d103      	bne.n	34003628 <BSP_LCD_SetActiveLayer+0x40>
      Lcd_Ctx[Instance].BppFactor = 3;
34003620:	2203      	movs	r2, #3
34003622:	611a      	str	r2, [r3, #16]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB888;
34003624:	2201      	movs	r2, #1
34003626:	e7f0      	b.n	3400360a <BSP_LCD_SetActiveLayer+0x22>
      Lcd_Ctx[Instance].BppFactor = 4;
34003628:	2204      	movs	r2, #4
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
3400362a:	e9c3 0203 	strd	r0, r2, [r3, #12]
3400362e:	e7ed      	b.n	3400360c <BSP_LCD_SetActiveLayer+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
34003630:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003634:	e7eb      	b.n	3400360e <BSP_LCD_SetActiveLayer+0x26>
34003636:	bf00      	nop
34003638:	34057718 	.word	0x34057718
3400363c:	34057738 	.word	0x34057738

34003640 <BSP_LCD_GetXSize>:
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
34003640:	b918      	cbnz	r0, 3400364a <BSP_LCD_GetXSize+0xa>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
34003642:	4b03      	ldr	r3, [pc, #12]	@ (34003650 <BSP_LCD_GetXSize+0x10>)
34003644:	681b      	ldr	r3, [r3, #0]
34003646:	600b      	str	r3, [r1, #0]
34003648:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
3400364a:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
3400364e:	4770      	bx	lr
34003650:	34057718 	.word	0x34057718

34003654 <BSP_LCD_GetYSize>:
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
  int32_t ret = BSP_ERROR_NONE;

  if(Instance >= LCD_INSTANCES_NBR)
34003654:	b918      	cbnz	r0, 3400365e <BSP_LCD_GetYSize+0xa>
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34003656:	4b03      	ldr	r3, [pc, #12]	@ (34003664 <BSP_LCD_GetYSize+0x10>)
34003658:	685b      	ldr	r3, [r3, #4]
3400365a:	600b      	str	r3, [r1, #0]
3400365c:	4770      	bx	lr
    ret = BSP_ERROR_WRONG_PARAM;
3400365e:	f06f 0001 	mvn.w	r0, #1
  }

  return ret;
}
34003662:	4770      	bx	lr
34003664:	34057718 	.word	0x34057718

34003668 <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
34003668:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
3400366a:	2734      	movs	r7, #52	@ 0x34
3400366c:	4d0f      	ldr	r5, [pc, #60]	@ (340036ac <BSP_LCD_ReadPixel+0x44>)
3400366e:	0146      	lsls	r6, r0, #5
34003670:	eb05 1040 	add.w	r0, r5, r0, lsl #5
34003674:	6884      	ldr	r4, [r0, #8]
34003676:	480e      	ldr	r0, [pc, #56]	@ (340036b0 <BSP_LCD_ReadPixel+0x48>)
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003678:	59ad      	ldr	r5, [r5, r6]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
3400367a:	fb07 0004 	mla	r0, r7, r4, r0
3400367e:	6c84      	ldr	r4, [r0, #72]	@ 0x48
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003680:	fb05 1202 	mla	r2, r5, r2, r1
34003684:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34003686:	b924      	cbnz	r4, 34003692 <BSP_LCD_ReadPixel+0x2a>
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003688:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
    /* Read data value from RAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
  }

  return BSP_ERROR_NONE;
}
3400368c:	2000      	movs	r0, #0
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
3400368e:	601a      	str	r2, [r3, #0]
}
34003690:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34003692:	2c06      	cmp	r4, #6
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34003694:	bf05      	ittet	eq
34003696:	eb02 0242 	addeq.w	r2, r2, r2, lsl #1
3400369a:	5812      	ldreq	r2, [r2, r0]
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
3400369c:	f830 2012 	ldrhne.w	r2, [r0, r2, lsl #1]
    *Color = CONVERTARGB88882RGB888(*Color);
340036a0:	f022 427f 	biceq.w	r2, r2, #4278190080	@ 0xff000000
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
340036a4:	bf18      	it	ne
340036a6:	b292      	uxthne	r2, r2
340036a8:	e7f0      	b.n	3400368c <BSP_LCD_ReadPixel+0x24>
340036aa:	bf00      	nop
340036ac:	34057718 	.word	0x34057718
340036b0:	34057738 	.word	0x34057738

340036b4 <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
340036b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340036b8:	2734      	movs	r7, #52	@ 0x34
340036ba:	4e24      	ldr	r6, [pc, #144]	@ (3400374c <BSP_LCD_WritePixel+0x98>)
340036bc:	ea4f 1c40 	mov.w	ip, r0, lsl #5
340036c0:	eb06 1040 	add.w	r0, r6, r0, lsl #5
340036c4:	6884      	ldr	r4, [r0, #8]
340036c6:	4d22      	ldr	r5, [pc, #136]	@ (34003750 <BSP_LCD_WritePixel+0x9c>)
340036c8:	fb07 5404 	mla	r4, r7, r4, r5
340036cc:	f8d4 8048 	ldr.w	r8, [r4, #72]	@ 0x48
  {
    /* Write data value to RAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
340036d0:	f8d4 e05c 	ldr.w	lr, [r4, #92]	@ 0x5c
340036d4:	f856 400c 	ldr.w	r4, [r6, ip]
340036d8:	fb04 1402 	mla	r4, r4, r2, r1
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
340036dc:	f1b8 0f00 	cmp.w	r8, #0
340036e0:	d104      	bne.n	340036ec <BSP_LCD_WritePixel+0x38>
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
340036e2:	f84e 3024 	str.w	r3, [lr, r4, lsl #2]
    /* Write data value to RAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
  }

  return BSP_ERROR_NONE;
}
340036e6:	2000      	movs	r0, #0
340036e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
340036ec:	f1b8 0f06 	cmp.w	r8, #6
340036f0:	d127      	bne.n	34003742 <BSP_LCD_WritePixel+0x8e>
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-3U)) = (uint8_t) (Color);
340036f2:	fa5f f883 	uxtb.w	r8, r3
340036f6:	eb04 0444 	add.w	r4, r4, r4, lsl #1
340036fa:	f1ae 0e03 	sub.w	lr, lr, #3
340036fe:	f804 800e 	strb.w	r8, [r4, lr]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34003702:	f856 400c 	ldr.w	r4, [r6, ip]
34003706:	f3c3 2807 	ubfx	r8, r3, #8, #8
3400370a:	fb04 1402 	mla	r4, r4, r2, r1
3400370e:	eb04 0944 	add.w	r9, r4, r4, lsl #1
34003712:	6884      	ldr	r4, [r0, #8]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34003714:	f3c3 4307 	ubfx	r3, r3, #16, #8
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34003718:	fb07 5e04 	mla	lr, r7, r4, r5
3400371c:	f8de e05c 	ldr.w	lr, [lr, #92]	@ 0x5c
34003720:	f1ae 0e02 	sub.w	lr, lr, #2
34003724:	f809 800e 	strb.w	r8, [r9, lr]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34003728:	f856 400c 	ldr.w	r4, [r6, ip]
3400372c:	fb04 1202 	mla	r2, r4, r2, r1
34003730:	6881      	ldr	r1, [r0, #8]
34003732:	eb02 0242 	add.w	r2, r2, r2, lsl #1
34003736:	fb07 5501 	mla	r5, r7, r1, r5
3400373a:	6de9      	ldr	r1, [r5, #92]	@ 0x5c
3400373c:	3901      	subs	r1, #1
3400373e:	5453      	strb	r3, [r2, r1]
34003740:	e7d1      	b.n	340036e6 <BSP_LCD_WritePixel+0x32>
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
34003742:	b29b      	uxth	r3, r3
34003744:	f82e 3014 	strh.w	r3, [lr, r4, lsl #1]
34003748:	e7cd      	b.n	340036e6 <BSP_LCD_WritePixel+0x32>
3400374a:	bf00      	nop
3400374c:	34057718 	.word	0x34057718
34003750:	34057738 	.word	0x34057738

34003754 <BSP_LCD_FillRGBRect>:
{
34003754:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34003758:	4680      	mov	r8, r0
3400375a:	460e      	mov	r6, r1
3400375c:	4614      	mov	r4, r2
3400375e:	461d      	mov	r5, r3
  for(i = 0; i < Height; i++)
34003760:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34003762:	eb03 0902 	add.w	r9, r3, r2
      pdata += Lcd_Ctx[Instance].BppFactor;
34003766:	4b0d      	ldr	r3, [pc, #52]	@ (3400379c <BSP_LCD_FillRGBRect+0x48>)
34003768:	eb03 1a40 	add.w	sl, r3, r0, lsl #5
  for(i = 0; i < Height; i++)
3400376c:	454c      	cmp	r4, r9
3400376e:	d012      	beq.n	34003796 <BSP_LCD_FillRGBRect+0x42>
34003770:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34003772:	4637      	mov	r7, r6
34003774:	eb03 0b06 	add.w	fp, r3, r6
34003778:	e009      	b.n	3400378e <BSP_LCD_FillRGBRect+0x3a>
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
3400377a:	682b      	ldr	r3, [r5, #0]
3400377c:	4639      	mov	r1, r7
3400377e:	4622      	mov	r2, r4
34003780:	4640      	mov	r0, r8
34003782:	f7ff ff97 	bl	340036b4 <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
34003786:	f8da 3010 	ldr.w	r3, [sl, #16]
3400378a:	3701      	adds	r7, #1
3400378c:	441d      	add	r5, r3
    for(j = 0; j < Width; j++)
3400378e:	455f      	cmp	r7, fp
34003790:	d1f3      	bne.n	3400377a <BSP_LCD_FillRGBRect+0x26>
  for(i = 0; i < Height; i++)
34003792:	3401      	adds	r4, #1
34003794:	e7ea      	b.n	3400376c <BSP_LCD_FillRGBRect+0x18>
}
34003796:	2000      	movs	r0, #0
34003798:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400379c:	34057718 	.word	0x34057718

340037a0 <BSP_LCD_DrawBitmap>:
{
340037a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340037a4:	2634      	movs	r6, #52	@ 0x34
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
340037a6:	f8d3 4012 	ldr.w	r4, [r3, #18]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340037aa:	4f39      	ldr	r7, [pc, #228]	@ (34003890 <BSP_LCD_DrawBitmap+0xf0>)
340037ac:	ea4f 1840 	mov.w	r8, r0, lsl #5
{
340037b0:	b085      	sub	sp, #20
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
340037b2:	9402      	str	r4, [sp, #8]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340037b4:	f857 4008 	ldr.w	r4, [r7, r8]
340037b8:	eb07 1040 	add.w	r0, r7, r0, lsl #5
340037bc:	fb04 1202 	mla	r2, r4, r2, r1
340037c0:	6904      	ldr	r4, [r0, #16]
340037c2:	4934      	ldr	r1, [pc, #208]	@ (34003894 <BSP_LCD_DrawBitmap+0xf4>)
340037c4:	6880      	ldr	r0, [r0, #8]
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
340037c6:	8b9d      	ldrh	r5, [r3, #28]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340037c8:	fb06 1100 	mla	r1, r6, r0, r1
340037cc:	6dce      	ldr	r6, [r1, #92]	@ 0x5c
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
340037ce:	f8d3 c00a 	ldr.w	ip, [r3, #10]
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
340037d2:	fb04 6602 	mla	r6, r4, r2, r6
  if ((bit_pixel/8U) == 4U)
340037d6:	f1a5 0220 	sub.w	r2, r5, #32
340037da:	2a07      	cmp	r2, #7
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
340037dc:	f8d3 a016 	ldr.w	sl, [r3, #22]
  if ((bit_pixel/8U) == 4U)
340037e0:	d91b      	bls.n	3400381a <BSP_LCD_DrawBitmap+0x7a>
  else if ((bit_pixel/8U) == 2U)
340037e2:	f1a5 0210 	sub.w	r2, r5, #16
    input_color_mode = DMA2D_INPUT_RGB565;
340037e6:	2a07      	cmp	r2, #7
340037e8:	bf8c      	ite	hi
340037ea:	f04f 0b01 	movhi.w	fp, #1
340037ee:	f04f 0b02 	movls.w	fp, #2
  for(index=0; index < height; index++)
340037f2:	f04f 0900 	mov.w	r9, #0
340037f6:	9a02      	ldr	r2, [sp, #8]
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
340037f8:	08ed      	lsrs	r5, r5, #3
340037fa:	4355      	muls	r5, r2
340037fc:	f10a 32ff 	add.w	r2, sl, #4294967295
34003800:	fb05 cc02 	mla	ip, r5, r2, ip
34003804:	eb03 040c 	add.w	r4, r3, ip
    pbmp -= width*(bit_pixel/8U);
34003808:	426b      	negs	r3, r5
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
    break;
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
3400380a:	4d23      	ldr	r5, [pc, #140]	@ (34003898 <BSP_LCD_DrawBitmap+0xf8>)
    pbmp -= width*(bit_pixel/8U);
3400380c:	9303      	str	r3, [sp, #12]
  for(index=0; index < height; index++)
3400380e:	45d1      	cmp	r9, sl
34003810:	d106      	bne.n	34003820 <BSP_LCD_DrawBitmap+0x80>
}
34003812:	2000      	movs	r0, #0
34003814:	b005      	add	sp, #20
34003816:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    input_color_mode = DMA2D_INPUT_ARGB8888;
3400381a:	f04f 0b00 	mov.w	fp, #0
3400381e:	e7e8      	b.n	340037f2 <BSP_LCD_DrawBitmap+0x52>
  switch(Lcd_Ctx[Instance].PixelFormat)
34003820:	eb07 0308 	add.w	r3, r7, r8
34003824:	68db      	ldr	r3, [r3, #12]
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;

  hlcd_dma2d.Instance = DMA2D;

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34003826:	481c      	ldr	r0, [pc, #112]	@ (34003898 <BSP_LCD_DrawBitmap+0xf8>)
34003828:	3b01      	subs	r3, #1
3400382a:	2b03      	cmp	r3, #3
3400382c:	bf96      	itet	ls
3400382e:	4a1b      	ldrls	r2, [pc, #108]	@ (3400389c <BSP_LCD_DrawBitmap+0xfc>)
  switch(Lcd_Ctx[Instance].PixelFormat)
34003830:	2300      	movhi	r3, #0
34003832:	5cd3      	ldrbls	r3, [r2, r3]
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
34003834:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34003838:	e9c5 2301 	strd	r2, r3, [r5, #4]
  hlcd_dma2d.Init.OutputOffset = 0;
3400383c:	2300      	movs	r3, #0
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
3400383e:	22ff      	movs	r2, #255	@ 0xff
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
34003840:	e9c5 3b11 	strd	r3, fp, [r5, #68]	@ 0x44
  hlcd_dma2d.Init.OutputOffset = 0;
34003844:	60eb      	str	r3, [r5, #12]
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34003846:	64eb      	str	r3, [r5, #76]	@ 0x4c
  hlcd_dma2d.Instance = DMA2D;
34003848:	4b15      	ldr	r3, [pc, #84]	@ (340038a0 <BSP_LCD_DrawBitmap+0x100>)
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
3400384a:	652a      	str	r2, [r5, #80]	@ 0x50
  hlcd_dma2d.Instance = DMA2D;
3400384c:	602b      	str	r3, [r5, #0]
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
3400384e:	f003 fcf3 	bl	34007238 <HAL_DMA2D_Init>
34003852:	b988      	cbnz	r0, 34003878 <BSP_LCD_DrawBitmap+0xd8>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
34003854:	2101      	movs	r1, #1
34003856:	4628      	mov	r0, r5
34003858:	f003 fe2a 	bl	340074b0 <HAL_DMA2D_ConfigLayer>
3400385c:	b960      	cbnz	r0, 34003878 <BSP_LCD_DrawBitmap+0xd8>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
3400385e:	2301      	movs	r3, #1
34003860:	4632      	mov	r2, r6
34003862:	9300      	str	r3, [sp, #0]
34003864:	4621      	mov	r1, r4
34003866:	9b02      	ldr	r3, [sp, #8]
34003868:	480b      	ldr	r0, [pc, #44]	@ (34003898 <BSP_LCD_DrawBitmap+0xf8>)
3400386a:	f003 fd6d 	bl	34007348 <HAL_DMA2D_Start>
3400386e:	b918      	cbnz	r0, 34003878 <BSP_LCD_DrawBitmap+0xd8>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34003870:	2132      	movs	r1, #50	@ 0x32
34003872:	4809      	ldr	r0, [pc, #36]	@ (34003898 <BSP_LCD_DrawBitmap+0xf8>)
34003874:	f003 fd9e 	bl	340073b4 <HAL_DMA2D_PollForTransfer>
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
34003878:	eb07 0308 	add.w	r3, r7, r8
3400387c:	691b      	ldr	r3, [r3, #16]
3400387e:	f857 2008 	ldr.w	r2, [r7, r8]
  for(index=0; index < height; index++)
34003882:	f109 0901 	add.w	r9, r9, #1
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
34003886:	fb03 6602 	mla	r6, r3, r2, r6
    pbmp -= width*(bit_pixel/8U);
3400388a:	9b03      	ldr	r3, [sp, #12]
3400388c:	441c      	add	r4, r3
  for(index=0; index < height; index++)
3400388e:	e7be      	b.n	3400380e <BSP_LCD_DrawBitmap+0x6e>
34003890:	34057718 	.word	0x34057718
34003894:	34057738 	.word	0x34057738
34003898:	340577e0 	.word	0x340577e0
3400389c:	34034fb5 	.word	0x34034fb5
340038a0:	58021000 	.word	0x58021000

340038a4 <LL_FillBuffer>:
{
340038a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
340038a8:	461f      	mov	r7, r3
  switch(Lcd_Ctx[Instance].PixelFormat)
340038aa:	4b34      	ldr	r3, [pc, #208]	@ (3400397c <LL_FillBuffer+0xd8>)
{
340038ac:	4616      	mov	r6, r2
  switch(Lcd_Ctx[Instance].PixelFormat)
340038ae:	eb03 1340 	add.w	r3, r3, r0, lsl #5
340038b2:	68da      	ldr	r2, [r3, #12]
{
340038b4:	460d      	mov	r5, r1
340038b6:	e9dd 1408 	ldrd	r1, r4, [sp, #32]
  switch(Lcd_Ctx[Instance].PixelFormat)
340038ba:	2a02      	cmp	r2, #2
340038bc:	d023      	beq.n	34003906 <LL_FillBuffer+0x62>
340038be:	2a04      	cmp	r2, #4
340038c0:	d03e      	beq.n	34003940 <LL_FillBuffer+0x9c>
340038c2:	2a01      	cmp	r2, #1
340038c4:	d054      	beq.n	34003970 <LL_FillBuffer+0xcc>
340038c6:	2200      	movs	r2, #0
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
340038c8:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
340038cc:	f8df 80b4 	ldr.w	r8, [pc, #180]	@ 34003984 <LL_FillBuffer+0xe0>
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
340038d0:	e9c8 3201 	strd	r3, r2, [r8, #4]
  hlcd_dma2d.Instance = DMA2D;
340038d4:	4b2a      	ldr	r3, [pc, #168]	@ (34003980 <LL_FillBuffer+0xdc>)
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
340038d6:	4640      	mov	r0, r8
  hlcd_dma2d.Init.OutputOffset = OffLine;
340038d8:	f8c8 100c 	str.w	r1, [r8, #12]
  hlcd_dma2d.Instance = DMA2D;
340038dc:	f8c8 3000 	str.w	r3, [r8]
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
340038e0:	f003 fcaa 	bl	34007238 <HAL_DMA2D_Init>
340038e4:	2800      	cmp	r0, #0
340038e6:	d146      	bne.n	34003976 <LL_FillBuffer+0xd2>
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
340038e8:	4633      	mov	r3, r6
340038ea:	462a      	mov	r2, r5
340038ec:	4621      	mov	r1, r4
340038ee:	4640      	mov	r0, r8
340038f0:	9700      	str	r7, [sp, #0]
340038f2:	f003 fd29 	bl	34007348 <HAL_DMA2D_Start>
340038f6:	bbf0      	cbnz	r0, 34003976 <LL_FillBuffer+0xd2>
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
340038f8:	2132      	movs	r1, #50	@ 0x32
340038fa:	4640      	mov	r0, r8
}
340038fc:	b002      	add	sp, #8
340038fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34003902:	f003 bd57 	b.w	340073b4 <HAL_DMA2D_PollForTransfer>
    input_color = CONVERTRGB5652ARGB8888(Color);
34003906:	f240 1e03 	movw	lr, #259	@ 0x103
3400390a:	f240 2c0f 	movw	ip, #527	@ 0x20f
3400390e:	f3c4 1045 	ubfx	r0, r4, #5, #6
34003912:	f3c4 23c4 	ubfx	r3, r4, #11, #5
34003916:	fb0e f000 	mul.w	r0, lr, r0
3400391a:	fb0c f303 	mul.w	r3, ip, r3
3400391e:	f004 041f 	and.w	r4, r4, #31
34003922:	fb0c f404 	mul.w	r4, ip, r4
34003926:	3021      	adds	r0, #33	@ 0x21
34003928:	3317      	adds	r3, #23
3400392a:	0980      	lsrs	r0, r0, #6
3400392c:	099b      	lsrs	r3, r3, #6
3400392e:	0200      	lsls	r0, r0, #8
34003930:	3417      	adds	r4, #23
34003932:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
34003936:	ea40 1094 	orr.w	r0, r0, r4, lsr #6
3400393a:	f040 447f 	orr.w	r4, r0, #4278190080	@ 0xff000000
    break;
3400393e:	e7c3      	b.n	340038c8 <LL_FillBuffer+0x24>
    input_color = CONVERTARGB44442ARGB8888(Color);
34003940:	f3c4 3303 	ubfx	r3, r4, #12, #4
34003944:	eb03 1003 	add.w	r0, r3, r3, lsl #4
34003948:	f3c4 2303 	ubfx	r3, r4, #8, #4
3400394c:	eb03 1303 	add.w	r3, r3, r3, lsl #4
34003950:	041b      	lsls	r3, r3, #16
34003952:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
34003956:	f004 000f 	and.w	r0, r4, #15
3400395a:	eb00 1000 	add.w	r0, r0, r0, lsl #4
3400395e:	4303      	orrs	r3, r0
34003960:	f3c4 1003 	ubfx	r0, r4, #4, #4
34003964:	f004 04f0 	and.w	r4, r4, #240	@ 0xf0
34003968:	4404      	add	r4, r0
3400396a:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
    break;
3400396e:	e7ab      	b.n	340038c8 <LL_FillBuffer+0x24>
    input_color = CONVERTRGB8882ARGB8888(Color);
34003970:	f044 447f 	orr.w	r4, r4, #4278190080	@ 0xff000000
    break;
34003974:	e7a8      	b.n	340038c8 <LL_FillBuffer+0x24>
}
34003976:	b002      	add	sp, #8
34003978:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3400397c:	34057718 	.word	0x34057718
34003980:	58021000 	.word	0x58021000
34003984:	340577e0 	.word	0x340577e0

34003988 <BSP_LCD_DrawHLine>:
{
34003988:	b573      	push	{r0, r1, r4, r5, r6, lr}
3400398a:	4615      	mov	r5, r2
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
3400398c:	4c0d      	ldr	r4, [pc, #52]	@ (340039c4 <BSP_LCD_DrawHLine+0x3c>)
3400398e:	0146      	lsls	r6, r0, #5
{
34003990:	461a      	mov	r2, r3
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003992:	eb04 1340 	add.w	r3, r4, r0, lsl #5
34003996:	59a4      	ldr	r4, [r4, r6]
34003998:	691e      	ldr	r6, [r3, #16]
3400399a:	fb04 1105 	mla	r1, r4, r5, r1
3400399e:	2534      	movs	r5, #52	@ 0x34
340039a0:	689c      	ldr	r4, [r3, #8]
340039a2:	4b09      	ldr	r3, [pc, #36]	@ (340039c8 <BSP_LCD_DrawHLine+0x40>)
340039a4:	fb05 3304 	mla	r3, r5, r4, r3
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
340039a8:	2400      	movs	r4, #0
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340039aa:	6ddd      	ldr	r5, [r3, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
340039ac:	9b06      	ldr	r3, [sp, #24]
340039ae:	fb06 5101 	mla	r1, r6, r1, r5
340039b2:	9301      	str	r3, [sp, #4]
340039b4:	9400      	str	r4, [sp, #0]
340039b6:	2301      	movs	r3, #1
340039b8:	f7ff ff74 	bl	340038a4 <LL_FillBuffer>
}
340039bc:	4620      	mov	r0, r4
340039be:	b002      	add	sp, #8
340039c0:	bd70      	pop	{r4, r5, r6, pc}
340039c2:	bf00      	nop
340039c4:	34057718 	.word	0x34057718
340039c8:	34057738 	.word	0x34057738

340039cc <BSP_LCD_DrawVLine>:
{
340039cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340039ce:	2734      	movs	r7, #52	@ 0x34
340039d0:	4d0c      	ldr	r5, [pc, #48]	@ (34003a04 <BSP_LCD_DrawVLine+0x38>)
340039d2:	0146      	lsls	r6, r0, #5
340039d4:	eb05 1440 	add.w	r4, r5, r0, lsl #5
340039d8:	59ad      	ldr	r5, [r5, r6]
340039da:	6926      	ldr	r6, [r4, #16]
340039dc:	fb02 1105 	mla	r1, r2, r5, r1
340039e0:	68a4      	ldr	r4, [r4, #8]
340039e2:	4a09      	ldr	r2, [pc, #36]	@ (34003a08 <BSP_LCD_DrawVLine+0x3c>)
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
340039e4:	3d01      	subs	r5, #1
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340039e6:	fb07 2204 	mla	r2, r7, r4, r2
340039ea:	6dd4      	ldr	r4, [r2, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
340039ec:	9a08      	ldr	r2, [sp, #32]
340039ee:	fb06 4101 	mla	r1, r6, r1, r4
340039f2:	9201      	str	r2, [sp, #4]
340039f4:	9500      	str	r5, [sp, #0]
340039f6:	2201      	movs	r2, #1
340039f8:	f7ff ff54 	bl	340038a4 <LL_FillBuffer>
}
340039fc:	2000      	movs	r0, #0
340039fe:	b003      	add	sp, #12
34003a00:	bdf0      	pop	{r4, r5, r6, r7, pc}
34003a02:	bf00      	nop
34003a04:	34057718 	.word	0x34057718
34003a08:	34057738 	.word	0x34057738

34003a0c <BSP_LCD_FillRect>:
{
34003a0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34003a0e:	4615      	mov	r5, r2
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003a10:	2734      	movs	r7, #52	@ 0x34
{
34003a12:	461a      	mov	r2, r3
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003a14:	4b0c      	ldr	r3, [pc, #48]	@ (34003a48 <BSP_LCD_FillRect+0x3c>)
34003a16:	0146      	lsls	r6, r0, #5
34003a18:	eb03 1440 	add.w	r4, r3, r0, lsl #5
34003a1c:	599b      	ldr	r3, [r3, r6]
34003a1e:	6926      	ldr	r6, [r4, #16]
34003a20:	fb05 1503 	mla	r5, r5, r3, r1
34003a24:	68a1      	ldr	r1, [r4, #8]
34003a26:	4c09      	ldr	r4, [pc, #36]	@ (34003a4c <BSP_LCD_FillRect+0x40>)
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34003a28:	1a9b      	subs	r3, r3, r2
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34003a2a:	fb07 4401 	mla	r4, r7, r1, r4
34003a2e:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34003a30:	9c09      	ldr	r4, [sp, #36]	@ 0x24
34003a32:	9300      	str	r3, [sp, #0]
34003a34:	fb06 1105 	mla	r1, r6, r5, r1
34003a38:	9b08      	ldr	r3, [sp, #32]
34003a3a:	9401      	str	r4, [sp, #4]
34003a3c:	f7ff ff32 	bl	340038a4 <LL_FillBuffer>
}
34003a40:	2000      	movs	r0, #0
34003a42:	b003      	add	sp, #12
34003a44:	bdf0      	pop	{r4, r5, r6, r7, pc}
34003a46:	bf00      	nop
34003a48:	34057718 	.word	0x34057718
34003a4c:	34057738 	.word	0x34057738

34003a50 <MX_LTDC_Init>:
{
34003a50:	b4f0      	push	{r4, r5, r6, r7}
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34003a52:	2400      	movs	r4, #0
34003a54:	4d0c      	ldr	r5, [pc, #48]	@ (34003a88 <MX_LTDC_Init+0x38>)
  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34003a56:	2603      	movs	r6, #3
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34003a58:	e9c0 5400 	strd	r5, r4, [r0]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34003a5c:	250b      	movs	r5, #11
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34003a5e:	194f      	adds	r7, r1, r5
  hltdc->Init.TotalWidth         = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP + RK050HR18_HFP - 1U;
34003a60:	3113      	adds	r1, #19
34003a62:	62c1      	str	r1, [r0, #44]	@ 0x2c
  hltdc->Init.Backcolor.Blue  = 0x0;
34003a64:	8684      	strh	r4, [r0, #52]	@ 0x34
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34003a66:	1951      	adds	r1, r2, r5
  hltdc->Init.Backcolor.Red   = 0x0;
34003a68:	f880 4036 	strb.w	r4, [r0, #54]	@ 0x36
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34003a6c:	3213      	adds	r2, #19
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
34003a6e:	e9c0 4402 	strd	r4, r4, [r0, #8]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
34003a72:	6104      	str	r4, [r0, #16]
  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34003a74:	6146      	str	r6, [r0, #20]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34003a76:	61c5      	str	r5, [r0, #28]
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34003a78:	6247      	str	r7, [r0, #36]	@ 0x24
  hltdc->Init.VerticalSync       = (uint32_t)RK050HR18_VSYNC - 1U;
34003a7a:	6186      	str	r6, [r0, #24]
  hltdc->Init.AccumulatedVBP     = (uint32_t)RK050HR18_VSYNC + (uint32_t)RK050HR18_VBP - 1U;
34003a7c:	6205      	str	r5, [r0, #32]
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34003a7e:	6281      	str	r1, [r0, #40]	@ 0x28
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34003a80:	6302      	str	r2, [r0, #48]	@ 0x30
}
34003a82:	bcf0      	pop	{r4, r5, r6, r7}
  return HAL_LTDC_Init(hltdc);
34003a84:	f005 b8b4 	b.w	34008bf0 <HAL_LTDC_Init>
34003a88:	58001000 	.word	0x58001000

34003a8c <MX_LTDC_ConfigLayer>:
{
34003a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
34003a8e:	4614      	mov	r4, r2
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
34003a90:	221c      	movs	r2, #28
{
34003a92:	b08f      	sub	sp, #60	@ 0x3c
34003a94:	4606      	mov	r6, r0
34003a96:	460f      	mov	r7, r1
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
34003a98:	eb0d 0002 	add.w	r0, sp, r2
34003a9c:	2100      	movs	r1, #0
34003a9e:	f015 f8e1 	bl	34018c64 <memset>
  pLayerCfg.PixelFormat = Config->PixelFormat;
34003aa2:	6920      	ldr	r0, [r4, #16]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34003aa4:	f44f 6ec0 	mov.w	lr, #1536	@ 0x600
  pLayerCfg.PixelFormat = Config->PixelFormat;
34003aa8:	9005      	str	r0, [sp, #20]
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
34003aaa:	20ff      	movs	r0, #255	@ 0xff
34003aac:	9006      	str	r0, [sp, #24]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34003aae:	2007      	movs	r0, #7
  pLayerCfg.WindowX0 = Config->X0;
34003ab0:	6821      	ldr	r1, [r4, #0]
  pLayerCfg.WindowY0 = Config->Y0;
34003ab2:	68a2      	ldr	r2, [r4, #8]
  pLayerCfg.WindowX1 = Config->X1;
34003ab4:	6865      	ldr	r5, [r4, #4]
  pLayerCfg.WindowY1 = Config->Y1;
34003ab6:	68e3      	ldr	r3, [r4, #12]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34003ab8:	e9cd e008 	strd	lr, r0, [sp, #32]
  pLayerCfg.FBStartAdress = Config->Address;
34003abc:	6960      	ldr	r0, [r4, #20]
  pLayerCfg.WindowX0 = Config->X0;
34003abe:	9101      	str	r1, [sp, #4]
  pLayerCfg.WindowX1 = Config->X1;
34003ac0:	9502      	str	r5, [sp, #8]
  pLayerCfg.WindowY0 = Config->Y0;
34003ac2:	9203      	str	r2, [sp, #12]
  pLayerCfg.WindowY1 = Config->Y1;
34003ac4:	9304      	str	r3, [sp, #16]
  pLayerCfg.FBStartAdress = Config->Address;
34003ac6:	900a      	str	r0, [sp, #40]	@ 0x28
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
34003ac8:	1a9b      	subs	r3, r3, r2
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
34003aca:	1a6d      	subs	r5, r5, r1
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
34003acc:	463a      	mov	r2, r7
34003ace:	4630      	mov	r0, r6
34003ad0:	a901      	add	r1, sp, #4
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
34003ad2:	950b      	str	r5, [sp, #44]	@ 0x2c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
34003ad4:	930c      	str	r3, [sp, #48]	@ 0x30
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
34003ad6:	f005 f95d 	bl	34008d94 <HAL_LTDC_ConfigLayer>
}
34003ada:	b00f      	add	sp, #60	@ 0x3c
34003adc:	bdf0      	pop	{r4, r5, r6, r7, pc}

34003ade <MX_LTDC_ClockConfig>:
{
34003ade:	b500      	push	{lr}
34003ae0:	b0e5      	sub	sp, #404	@ 0x194
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34003ae2:	f44f 72c8 	mov.w	r2, #400	@ 0x190
34003ae6:	2100      	movs	r1, #0
34003ae8:	4668      	mov	r0, sp
34003aea:	f015 f8bb 	bl	34018c64 <memset>
  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34003aee:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34003af2:	2300      	movs	r3, #0
34003af4:	e9cd 2300 	strd	r2, r3, [sp]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34003af8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34003afc:	f04f 5140 	mov.w	r1, #805306368	@ 0x30000000
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34003b00:	9346      	str	r3, [sp, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34003b02:	2302      	movs	r3, #2
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34003b04:	4668      	mov	r0, sp
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34003b06:	e9cd 1320 	strd	r1, r3, [sp, #128]	@ 0x80
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34003b0a:	f006 fc79 	bl	3400a400 <HAL_RCCEx_PeriphCLKConfig>
}
34003b0e:	3800      	subs	r0, #0
34003b10:	bf18      	it	ne
34003b12:	2001      	movne	r0, #1
34003b14:	b065      	add	sp, #404	@ 0x194
34003b16:	f85d fb04 	ldr.w	pc, [sp], #4
	...

34003b1c <BSP_LCD_InitEx>:
{
34003b1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34003b20:	4614      	mov	r4, r2
  MX_LTDC_LayerConfig_t config = {0};
34003b22:	2218      	movs	r2, #24
{
34003b24:	460e      	mov	r6, r1
34003b26:	b08d      	sub	sp, #52	@ 0x34
34003b28:	4605      	mov	r5, r0
  MX_LTDC_LayerConfig_t config = {0};
34003b2a:	2100      	movs	r1, #0
34003b2c:	eb0d 0002 	add.w	r0, sp, r2
{
34003b30:	4699      	mov	r9, r3
  MX_LTDC_LayerConfig_t config = {0};
34003b32:	f015 f897 	bl	34018c64 <memset>
  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
34003b36:	2e01      	cmp	r6, #1
34003b38:	f200 80da 	bhi.w	34003cf0 <BSP_LCD_InitEx+0x1d4>
34003b3c:	2d00      	cmp	r5, #0
34003b3e:	f040 80d7 	bne.w	34003cf0 <BSP_LCD_InitEx+0x1d4>
34003b42:	2c02      	cmp	r4, #2
34003b44:	f240 80ad 	bls.w	34003ca2 <BSP_LCD_InitEx+0x186>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
34003b48:	2c04      	cmp	r4, #4
34003b4a:	f040 80d1 	bne.w	34003cf0 <BSP_LCD_InitEx+0x1d4>
34003b4e:	2302      	movs	r3, #2
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
34003b50:	2508      	movs	r5, #8
      Lcd_Ctx[Instance].BppFactor = 2U;
34003b52:	f8df 81d4 	ldr.w	r8, [pc, #468]	@ 34003d28 <BSP_LCD_InitEx+0x20c>
    hlcd_ltdc.Instance = LTDC;
34003b56:	4a68      	ldr	r2, [pc, #416]	@ (34003cf8 <BSP_LCD_InitEx+0x1dc>)
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
34003b58:	e9c8 4303 	strd	r4, r3, [r8, #12]
  WRITE_REG(RCC->APB5ENSR, Periphs);
34003b5c:	2402      	movs	r4, #2
    Lcd_Ctx[Instance].YSize  = Height;
34003b5e:	9b16      	ldr	r3, [sp, #88]	@ 0x58
34003b60:	4e66      	ldr	r6, [pc, #408]	@ (34003cfc <BSP_LCD_InitEx+0x1e0>)
34003b62:	f8c8 3004 	str.w	r3, [r8, #4]
    hlcd_ltdc.Instance = LTDC;
34003b66:	4b66      	ldr	r3, [pc, #408]	@ (34003d00 <BSP_LCD_InitEx+0x1e4>)
    hlcd_dma2d.Instance = DMA2D;
34003b68:	f8df b1c0 	ldr.w	fp, [pc, #448]	@ 34003d2c <BSP_LCD_InitEx+0x210>
    hlcd_ltdc.Instance = LTDC;
34003b6c:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
34003b6e:	4b65      	ldr	r3, [pc, #404]	@ (34003d04 <BSP_LCD_InitEx+0x1e8>)
    Lcd_Ctx[Instance].XSize  = Width;
34003b70:	f8c8 9000 	str.w	r9, [r8]
    hlcd_dma2d.Instance = DMA2D;
34003b74:	f8cb 3000 	str.w	r3, [fp]
34003b78:	f8c6 4a7c 	str.w	r4, [r6, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34003b7c:	f8d6 327c 	ldr.w	r3, [r6, #636]	@ 0x27c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34003b80:	f8df a1ac 	ldr.w	sl, [pc, #428]	@ 34003d30 <BSP_LCD_InitEx+0x214>
  tmpreg = READ_REG(RCC->APB5ENR);
34003b84:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
34003b86:	9b00      	ldr	r3, [sp, #0]
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
34003b88:	2001      	movs	r0, #1
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34003b8a:	f8c6 4a3c 	str.w	r4, [r6, #2620]	@ 0xa3c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34003b8e:	f8ca 423c 	str.w	r4, [sl, #572]	@ 0x23c
34003b92:	f7ff fd13 	bl	340035bc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
34003b96:	4620      	mov	r0, r4
34003b98:	f7ff fd10 	bl	340035bc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
34003b9c:	2008      	movs	r0, #8
34003b9e:	f7ff fd0d 	bl	340035bc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
34003ba2:	2010      	movs	r0, #16
34003ba4:	f7ff fd0a 	bl	340035bc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
34003ba8:	2040      	movs	r0, #64	@ 0x40
34003baa:	f7ff fd07 	bl	340035bc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34003bae:	2080      	movs	r0, #128	@ 0x80
34003bb0:	f7ff fd04 	bl	340035bc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
34003bb4:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34003bb8:	f7ff fd00 	bl	340035bc <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
    gpio_init_structure.Pull      = GPIO_NOPULL;
34003bbc:	2300      	movs	r3, #0
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003bbe:	270e      	movs	r7, #14
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34003bc0:	e9cd 3403 	strd	r3, r4, [sp, #12]
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34003bc4:	f248 1387 	movw	r3, #33159	@ 0x8187
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
34003bc8:	484f      	ldr	r0, [pc, #316]	@ (34003d08 <BSP_LCD_InitEx+0x1ec>)
34003bca:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34003bcc:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003bce:	9705      	str	r7, [sp, #20]
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
34003bd0:	9402      	str	r4, [sp, #8]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
34003bd2:	f003 fd1d 	bl	34007610 <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34003bd6:	f64f 0314 	movw	r3, #63508	@ 0xf814
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34003bda:	484c      	ldr	r0, [pc, #304]	@ (34003d0c <BSP_LCD_InitEx+0x1f0>)
34003bdc:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34003bde:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003be0:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34003be2:	f003 fd15 	bl	34007610 <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34003be6:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34003bea:	4849      	ldr	r0, [pc, #292]	@ (34003d10 <BSP_LCD_InitEx+0x1f4>)
34003bec:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34003bee:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003bf0:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34003bf2:	f003 fd0d 	bl	34007610 <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
34003bf6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003bfa:	4846      	ldr	r0, [pc, #280]	@ (34003d14 <BSP_LCD_InitEx+0x1f8>)
34003bfc:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_11;
34003bfe:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003c00:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003c02:	f003 fd05 	bl	34007610 <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34003c06:	f641 1343 	movw	r3, #6467	@ 0x1943
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003c0a:	4843      	ldr	r0, [pc, #268]	@ (34003d18 <BSP_LCD_InitEx+0x1fc>)
34003c0c:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34003c0e:	9301      	str	r3, [sp, #4]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003c10:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003c12:	f003 fcfd 	bl	34007610 <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34003c16:	2358      	movs	r3, #88	@ 0x58
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34003c18:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003c1a:	2701      	movs	r7, #1
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34003c1c:	483f      	ldr	r0, [pc, #252]	@ (34003d1c <BSP_LCD_InitEx+0x200>)
34003c1e:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34003c20:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34003c22:	f003 fcf5 	bl	34007610 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003c26:	483b      	ldr	r0, [pc, #236]	@ (34003d14 <BSP_LCD_InitEx+0x1f8>)
34003c28:	a901      	add	r1, sp, #4
    gpio_init_structure.Pin       = GPIO_PIN_1;
34003c2a:	9401      	str	r4, [sp, #4]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003c2c:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34003c2e:	f003 fcef 	bl	34007610 <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
34003c32:	2348      	movs	r3, #72	@ 0x48
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34003c34:	483a      	ldr	r0, [pc, #232]	@ (34003d20 <BSP_LCD_InitEx+0x204>)
34003c36:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003c38:	e9cd 3701 	strd	r3, r7, [sp, #4]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34003c3c:	f003 fce8 	bl	34007610 <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
34003c40:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003c44:	4834      	ldr	r0, [pc, #208]	@ (34003d18 <BSP_LCD_InitEx+0x1fc>)
34003c46:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34003c48:	e9cd 3701 	strd	r3, r7, [sp, #4]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34003c4c:	f003 fce0 	bl	34007610 <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
34003c50:	463a      	mov	r2, r7
34003c52:	2108      	movs	r1, #8
34003c54:	4832      	ldr	r0, [pc, #200]	@ (34003d20 <BSP_LCD_InitEx+0x204>)
34003c56:	f004 f821 	bl	34007c9c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
34003c5a:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34003c5e:	463a      	mov	r2, r7
34003c60:	4619      	mov	r1, r3
34003c62:	482d      	ldr	r0, [pc, #180]	@ (34003d18 <BSP_LCD_InitEx+0x1fc>)
34003c64:	f004 f81a 	bl	34007c9c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
34003c68:	463a      	mov	r2, r7
34003c6a:	2140      	movs	r1, #64	@ 0x40
34003c6c:	482c      	ldr	r0, [pc, #176]	@ (34003d20 <BSP_LCD_InitEx+0x204>)
34003c6e:	f004 f815 	bl	34007c9c <HAL_GPIO_WritePin>
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
  if(hdma2d->Instance == DMA2D)
34003c72:	f8db 3000 	ldr.w	r3, [fp]
34003c76:	4a23      	ldr	r2, [pc, #140]	@ (34003d04 <BSP_LCD_InitEx+0x1e8>)
34003c78:	4293      	cmp	r3, r2
34003c7a:	d109      	bne.n	34003c90 <BSP_LCD_InitEx+0x174>
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34003c7c:	f8c6 4a60 	str.w	r4, [r6, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34003c80:	f8d6 3260 	ldr.w	r3, [r6, #608]	@ 0x260
34003c84:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003c86:	9b01      	ldr	r3, [sp, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34003c88:	f8c6 4a20 	str.w	r4, [r6, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34003c8c:	f8ca 4220 	str.w	r4, [sl, #544]	@ 0x220
    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34003c90:	481b      	ldr	r0, [pc, #108]	@ (34003d00 <BSP_LCD_InitEx+0x1e4>)
34003c92:	f7ff ff24 	bl	34003ade <MX_LTDC_ClockConfig>
34003c96:	b170      	cbz	r0, 34003cb6 <BSP_LCD_InitEx+0x19a>
      ret = BSP_ERROR_PERIPH_FAILURE;
34003c98:	f06f 0003 	mvn.w	r0, #3
}
34003c9c:	b00d      	add	sp, #52	@ 0x34
34003c9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
34003ca2:	d005      	beq.n	34003cb0 <BSP_LCD_InitEx+0x194>
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
34003ca4:	2c01      	cmp	r4, #1
34003ca6:	bf0a      	itet	eq
34003ca8:	2303      	moveq	r3, #3
34003caa:	2304      	movne	r3, #4
34003cac:	2506      	moveq	r5, #6
34003cae:	e750      	b.n	34003b52 <BSP_LCD_InitEx+0x36>
34003cb0:	4623      	mov	r3, r4
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
34003cb2:	2504      	movs	r5, #4
34003cb4:	e74d      	b.n	34003b52 <BSP_LCD_InitEx+0x36>
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
34003cb6:	4649      	mov	r1, r9
34003cb8:	9a16      	ldr	r2, [sp, #88]	@ 0x58
34003cba:	4811      	ldr	r0, [pc, #68]	@ (34003d00 <BSP_LCD_InitEx+0x1e4>)
34003cbc:	f7ff fec8 	bl	34003a50 <MX_LTDC_Init>
34003cc0:	4601      	mov	r1, r0
34003cc2:	2800      	cmp	r0, #0
34003cc4:	d1e8      	bne.n	34003c98 <BSP_LCD_InitEx+0x17c>
        config.Y1          = Height;
34003cc6:	9b16      	ldr	r3, [sp, #88]	@ 0x58
        config.X1          = Width;
34003cc8:	e9cd 0906 	strd	r0, r9, [sp, #24]
        config.PixelFormat = ltdc_pixel_format;
34003ccc:	e9cd 3509 	strd	r3, r5, [sp, #36]	@ 0x24
        config.Address     = LCD_LAYER_0_ADDRESS;
34003cd0:	4b14      	ldr	r3, [pc, #80]	@ (34003d24 <BSP_LCD_InitEx+0x208>)
        config.Y0          = 0;
34003cd2:	9008      	str	r0, [sp, #32]
        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34003cd4:	aa06      	add	r2, sp, #24
34003cd6:	480a      	ldr	r0, [pc, #40]	@ (34003d00 <BSP_LCD_InitEx+0x1e4>)
        config.Address     = LCD_LAYER_0_ADDRESS;
34003cd8:	930b      	str	r3, [sp, #44]	@ 0x2c
        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34003cda:	f7ff fed7 	bl	34003a8c <MX_LTDC_ConfigLayer>
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34003cde:	2301      	movs	r3, #1
  int32_t ret = BSP_ERROR_NONE;
34003ce0:	2800      	cmp	r0, #0
34003ce2:	bf14      	ite	ne
34003ce4:	f06f 0003 	mvnne.w	r0, #3
34003ce8:	2000      	moveq	r0, #0
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34003cea:	f8c8 3018 	str.w	r3, [r8, #24]
34003cee:	e7d5      	b.n	34003c9c <BSP_LCD_InitEx+0x180>
    ret = BSP_ERROR_WRONG_PARAM;
34003cf0:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003cf4:	e7d2      	b.n	34003c9c <BSP_LCD_InitEx+0x180>
34003cf6:	bf00      	nop
34003cf8:	58001000 	.word	0x58001000
34003cfc:	56028000 	.word	0x56028000
34003d00:	34057738 	.word	0x34057738
34003d04:	58021000 	.word	0x58021000
34003d08:	56020000 	.word	0x56020000
34003d0c:	56020400 	.word	0x56020400
34003d10:	56020c00 	.word	0x56020c00
34003d14:	56021000 	.word	0x56021000
34003d18:	56021800 	.word	0x56021800
34003d1c:	56021c00 	.word	0x56021c00
34003d20:	56024000 	.word	0x56024000
34003d24:	34200000 	.word	0x34200000
34003d28:	34057718 	.word	0x34057718
34003d2c:	340577e0 	.word	0x340577e0
34003d30:	56029000 	.word	0x56029000

34003d34 <BSP_LCD_Init>:
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34003d34:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
{
34003d38:	b507      	push	{r0, r1, r2, lr}
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34003d3a:	2202      	movs	r2, #2
34003d3c:	9300      	str	r3, [sp, #0]
34003d3e:	f44f 7348 	mov.w	r3, #800	@ 0x320
34003d42:	f7ff feeb 	bl	34003b1c <BSP_LCD_InitEx>
}
34003d46:	b003      	add	sp, #12
34003d48:	f85d fb04 	ldr.w	pc, [sp], #4

34003d4c <BSP_LCD_ConfigLayer>:
{
34003d4c:	b508      	push	{r3, lr}
  if(Instance >= LCD_INSTANCES_NBR)
34003d4e:	b9a8      	cbnz	r0, 34003d7c <BSP_LCD_ConfigLayer+0x30>
    if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_RGB565)
34003d50:	6913      	ldr	r3, [r2, #16]
34003d52:	2b02      	cmp	r3, #2
34003d54:	d10a      	bne.n	34003d6c <BSP_LCD_ConfigLayer+0x20>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
34003d56:	2304      	movs	r3, #4
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
34003d58:	6113      	str	r3, [r2, #16]
    if (MX_LTDC_ConfigLayer(&hlcd_ltdc, LayerIndex, Config) != HAL_OK)
34003d5a:	480a      	ldr	r0, [pc, #40]	@ (34003d84 <BSP_LCD_ConfigLayer+0x38>)
34003d5c:	f7ff fe96 	bl	34003a8c <MX_LTDC_ConfigLayer>
  int32_t ret = BSP_ERROR_NONE;
34003d60:	2800      	cmp	r0, #0
34003d62:	bf14      	ite	ne
34003d64:	f06f 0003 	mvnne.w	r0, #3
34003d68:	2000      	moveq	r0, #0
}
34003d6a:	bd08      	pop	{r3, pc}
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB4444)
34003d6c:	2b04      	cmp	r3, #4
34003d6e:	d101      	bne.n	34003d74 <BSP_LCD_ConfigLayer+0x28>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34003d70:	2308      	movs	r3, #8
34003d72:	e7f1      	b.n	34003d58 <BSP_LCD_ConfigLayer+0xc>
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB8888)
34003d74:	2b00      	cmp	r3, #0
34003d76:	d0f0      	beq.n	34003d5a <BSP_LCD_ConfigLayer+0xe>
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
34003d78:	2306      	movs	r3, #6
34003d7a:	e7ed      	b.n	34003d58 <BSP_LCD_ConfigLayer+0xc>
    ret = BSP_ERROR_WRONG_PARAM;
34003d7c:	f06f 0001 	mvn.w	r0, #1
34003d80:	e7f3      	b.n	34003d6a <BSP_LCD_ConfigLayer+0x1e>
34003d82:	bf00      	nop
34003d84:	34057738 	.word	0x34057738

34003d88 <LL_AHB4_GRP1_EnableClock>:
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003d88:	4b04      	ldr	r3, [pc, #16]	@ (34003d9c <LL_AHB4_GRP1_EnableClock+0x14>)
{
34003d8a:	b082      	sub	sp, #8
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34003d8c:	f8c3 0a5c 	str.w	r0, [r3, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34003d90:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34003d94:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
34003d96:	9b01      	ldr	r3, [sp, #4]
}
34003d98:	b002      	add	sp, #8
34003d9a:	4770      	bx	lr
34003d9c:	56028000 	.word	0x56028000

34003da0 <XSPI_NOR_EnterSOPIMode.constprop.0>:
/**
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
34003da0:	b530      	push	{r4, r5, lr}
{
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003da2:	4c20      	ldr	r4, [pc, #128]	@ (34003e24 <XSPI_NOR_EnterSOPIMode.constprop.0+0x84>)
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
34003da4:	b085      	sub	sp, #20
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003da6:	78a2      	ldrb	r2, [r4, #2]
34003da8:	7861      	ldrb	r1, [r4, #1]
34003daa:	481f      	ldr	r0, [pc, #124]	@ (34003e28 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003dac:	f7fe ffac 	bl	34002d08 <MX66UW1G45G_WriteEnable>
34003db0:	b118      	cbz	r0, 34003dba <XSPI_NOR_EnterSOPIMode.constprop.0+0x1a>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003db2:	f06f 0004 	mvn.w	r0, #4
    }
  }

  /* Return BSP status */
  return ret;
}
34003db6:	b005      	add	sp, #20
34003db8:	bd30      	pop	{r4, r5, pc}
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003dba:	9000      	str	r0, [sp, #0]
34003dbc:	f44f 7340 	mov.w	r3, #768	@ 0x300
34003dc0:	78a2      	ldrb	r2, [r4, #2]
34003dc2:	7861      	ldrb	r1, [r4, #1]
34003dc4:	4818      	ldr	r0, [pc, #96]	@ (34003e28 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003dc6:	f7ff f828 	bl	34002e1a <MX66UW1G45G_WriteCfg2Register>
34003dca:	2800      	cmp	r0, #0
34003dcc:	d1f1      	bne.n	34003db2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003dce:	78a2      	ldrb	r2, [r4, #2]
34003dd0:	7861      	ldrb	r1, [r4, #1]
34003dd2:	4815      	ldr	r0, [pc, #84]	@ (34003e28 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003dd4:	f7fe ff98 	bl	34002d08 <MX66UW1G45G_WriteEnable>
34003dd8:	4603      	mov	r3, r0
34003dda:	2800      	cmp	r0, #0
34003ddc:	d1e9      	bne.n	34003db2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003dde:	2501      	movs	r5, #1
34003de0:	9500      	str	r5, [sp, #0]
34003de2:	78a2      	ldrb	r2, [r4, #2]
34003de4:	7861      	ldrb	r1, [r4, #1]
34003de6:	4810      	ldr	r0, [pc, #64]	@ (34003e28 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003de8:	f7ff f817 	bl	34002e1a <MX66UW1G45G_WriteCfg2Register>
34003dec:	4604      	mov	r4, r0
34003dee:	2800      	cmp	r0, #0
34003df0:	d1df      	bne.n	34003db2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34003df2:	2028      	movs	r0, #40	@ 0x28
34003df4:	f000 fd82 	bl	340048fc <HAL_Delay>
    if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34003df8:	4622      	mov	r2, r4
34003dfa:	4629      	mov	r1, r5
34003dfc:	480a      	ldr	r0, [pc, #40]	@ (34003e28 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003dfe:	f7fe fe60 	bl	34002ac2 <MX66UW1G45G_AutoPollingMemReady>
34003e02:	4603      	mov	r3, r0
34003e04:	2800      	cmp	r0, #0
34003e06:	d1d4      	bne.n	34003db2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34003e08:	aa03      	add	r2, sp, #12
34003e0a:	9200      	str	r2, [sp, #0]
34003e0c:	4629      	mov	r1, r5
34003e0e:	4602      	mov	r2, r0
34003e10:	4805      	ldr	r0, [pc, #20]	@ (34003e28 <XSPI_NOR_EnterSOPIMode.constprop.0+0x88>)
34003e12:	f7ff f85a 	bl	34002eca <MX66UW1G45G_ReadCfg2Register>
34003e16:	2800      	cmp	r0, #0
34003e18:	d1cb      	bne.n	34003db2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
    else if (reg[0] != MX66UW1G45G_CR2_SOPI)
34003e1a:	f89d 300c 	ldrb.w	r3, [sp, #12]
34003e1e:	42ab      	cmp	r3, r5
34003e20:	d0c9      	beq.n	34003db6 <XSPI_NOR_EnterSOPIMode.constprop.0+0x16>
34003e22:	e7c6      	b.n	34003db2 <XSPI_NOR_EnterSOPIMode.constprop.0+0x12>
34003e24:	340578b0 	.word	0x340578b0
34003e28:	340578b4 	.word	0x340578b4

34003e2c <XSPI_NOR_EnterDOPIMode.constprop.0>:
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
34003e2c:	b530      	push	{r4, r5, lr}
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003e2e:	4d27      	ldr	r5, [pc, #156]	@ (34003ecc <XSPI_NOR_EnterDOPIMode.constprop.0+0xa0>)
34003e30:	4c27      	ldr	r4, [pc, #156]	@ (34003ed0 <XSPI_NOR_EnterDOPIMode.constprop.0+0xa4>)
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
34003e32:	b085      	sub	sp, #20
  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003e34:	4620      	mov	r0, r4
34003e36:	78aa      	ldrb	r2, [r5, #2]
34003e38:	7869      	ldrb	r1, [r5, #1]
34003e3a:	f7fe ff65 	bl	34002d08 <MX66UW1G45G_WriteEnable>
34003e3e:	b118      	cbz	r0, 34003e48 <XSPI_NOR_EnterDOPIMode.constprop.0+0x1c>
    ret = BSP_ERROR_COMPONENT_FAILURE;
34003e40:	f06f 0004 	mvn.w	r0, #4
}
34003e44:	b005      	add	sp, #20
34003e46:	bd30      	pop	{r4, r5, pc}
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003e48:	9000      	str	r0, [sp, #0]
34003e4a:	f44f 7340 	mov.w	r3, #768	@ 0x300
34003e4e:	4620      	mov	r0, r4
34003e50:	78aa      	ldrb	r2, [r5, #2]
34003e52:	7869      	ldrb	r1, [r5, #1]
34003e54:	f7fe ffe1 	bl	34002e1a <MX66UW1G45G_WriteCfg2Register>
34003e58:	2800      	cmp	r0, #0
34003e5a:	d1f1      	bne.n	34003e40 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003e5c:	4620      	mov	r0, r4
34003e5e:	78aa      	ldrb	r2, [r5, #2]
34003e60:	7869      	ldrb	r1, [r5, #1]
34003e62:	f7fe ff51 	bl	34002d08 <MX66UW1G45G_WriteEnable>
34003e66:	4603      	mov	r3, r0
34003e68:	2800      	cmp	r0, #0
34003e6a:	d1e9      	bne.n	34003e40 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003e6c:	2202      	movs	r2, #2
34003e6e:	9200      	str	r2, [sp, #0]
34003e70:	4620      	mov	r0, r4
34003e72:	78aa      	ldrb	r2, [r5, #2]
34003e74:	7869      	ldrb	r1, [r5, #1]
34003e76:	f7fe ffd0 	bl	34002e1a <MX66UW1G45G_WriteCfg2Register>
34003e7a:	2800      	cmp	r0, #0
34003e7c:	d1e0      	bne.n	34003e40 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34003e7e:	2028      	movs	r0, #40	@ 0x28
34003e80:	f000 fd3c 	bl	340048fc <HAL_Delay>
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34003e84:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34003e88:	60e3      	str	r3, [r4, #12]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003e8a:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003e8e:	4620      	mov	r0, r4
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003e90:	62e3      	str	r3, [r4, #44]	@ 0x2c
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003e92:	f00b ff91 	bl	3400fdb8 <HAL_XSPI_Init>
34003e96:	b9a8      	cbnz	r0, 34003ec4 <XSPI_NOR_EnterDOPIMode.constprop.0+0x98>
    else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34003e98:	2201      	movs	r2, #1
34003e9a:	4620      	mov	r0, r4
34003e9c:	4611      	mov	r1, r2
34003e9e:	f7fe fe10 	bl	34002ac2 <MX66UW1G45G_AutoPollingMemReady>
34003ea2:	4603      	mov	r3, r0
34003ea4:	2800      	cmp	r0, #0
34003ea6:	d1cb      	bne.n	34003e40 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
34003ea8:	aa03      	add	r2, sp, #12
34003eaa:	9200      	str	r2, [sp, #0]
34003eac:	2201      	movs	r2, #1
34003eae:	4620      	mov	r0, r4
34003eb0:	4611      	mov	r1, r2
34003eb2:	f7ff f80a 	bl	34002eca <MX66UW1G45G_ReadCfg2Register>
34003eb6:	2800      	cmp	r0, #0
34003eb8:	d1c2      	bne.n	34003e40 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
    else if (reg[0] != MX66UW1G45G_CR2_DOPI)
34003eba:	f89d 300c 	ldrb.w	r3, [sp, #12]
34003ebe:	2b02      	cmp	r3, #2
34003ec0:	d0c0      	beq.n	34003e44 <XSPI_NOR_EnterDOPIMode.constprop.0+0x18>
34003ec2:	e7bd      	b.n	34003e40 <XSPI_NOR_EnterDOPIMode.constprop.0+0x14>
      ret = BSP_ERROR_PERIPH_FAILURE;
34003ec4:	f06f 0003 	mvn.w	r0, #3
  return ret;
34003ec8:	e7bc      	b.n	34003e44 <XSPI_NOR_EnterDOPIMode.constprop.0+0x18>
34003eca:	bf00      	nop
34003ecc:	340578b0 	.word	0x340578b0
34003ed0:	340578b4 	.word	0x340578b4

34003ed4 <MX_XSPI_NOR_Init>:
  hxspi->Init.FifoThresholdByte       = 1;
34003ed4:	2301      	movs	r3, #1
34003ed6:	4a0f      	ldr	r2, [pc, #60]	@ (34003f14 <MX_XSPI_NOR_Init+0x40>)
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34003ed8:	f04f 0c02 	mov.w	ip, #2
  hxspi->Init.FifoThresholdByte       = 1;
34003edc:	e9c0 2300 	strd	r2, r3, [r0]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
34003ee0:	680b      	ldr	r3, [r1, #0]
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
34003ee2:	684a      	ldr	r2, [r1, #4]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
34003ee4:	6103      	str	r3, [r0, #16]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34003ee6:	2300      	movs	r3, #0
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
34003ee8:	6242      	str	r2, [r0, #36]	@ 0x24
  hxspi->Init.DelayHoldQuarterCycle   = HAL_XSPI_DHQC_DISABLE;
34003eea:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34003eec:	688a      	ldr	r2, [r1, #8]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34003eee:	e9c0 c305 	strd	ip, r3, [r0, #20]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
34003ef2:	61c3      	str	r3, [r0, #28]
  hxspi->Init.ChipSelectBoundary      = HAL_XSPI_BONDARYOF_NONE;
34003ef4:	6303      	str	r3, [r0, #48]	@ 0x30
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
34003ef6:	6083      	str	r3, [r0, #8]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
34003ef8:	6203      	str	r3, [r0, #32]
  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34003efa:	68cb      	ldr	r3, [r1, #12]
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34003efc:	6282      	str	r2, [r0, #40]	@ 0x28
  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
34003efe:	2b01      	cmp	r3, #1
34003f00:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34003f04:	60c3      	str	r3, [r0, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34003f06:	bf04      	itt	eq
34003f08:	f04f 5380 	moveq.w	r3, #268435456	@ 0x10000000
34003f0c:	62c3      	streq	r3, [r0, #44]	@ 0x2c
  return HAL_XSPI_Init(hxspi);
34003f0e:	f00b bf53 	b.w	3400fdb8 <HAL_XSPI_Init>
34003f12:	bf00      	nop
34003f14:	5802a000 	.word	0x5802a000

34003f18 <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003f18:	4601      	mov	r1, r0
{
34003f1a:	b510      	push	{r4, lr}
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003f1c:	b9b0      	cbnz	r0, 34003f4c <BSP_XSPI_NOR_EnableMemoryMappedMode+0x34>
    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34003f1e:	4c0d      	ldr	r4, [pc, #52]	@ (34003f54 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x3c>)
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
34003f20:	480d      	ldr	r0, [pc, #52]	@ (34003f58 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
34003f22:	f00c fb23 	bl	3401056c <HAL_XSPI_SetClockPrescaler>
    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34003f26:	78a3      	ldrb	r3, [r4, #2]
34003f28:	7861      	ldrb	r1, [r4, #1]
34003f2a:	b95b      	cbnz	r3, 34003f44 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x2c>
      if (MX66UW1G45G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003f2c:	2201      	movs	r2, #1
34003f2e:	480a      	ldr	r0, [pc, #40]	@ (34003f58 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
34003f30:	f7fe fe35 	bl	34002b9e <MX66UW1G45G_EnableSTRMemoryMappedMode>
34003f34:	b110      	cbz	r0, 34003f3c <BSP_XSPI_NOR_EnableMemoryMappedMode+0x24>
        ret = BSP_ERROR_COMPONENT_FAILURE;
34003f36:	f06f 0004 	mvn.w	r0, #4
}
34003f3a:	bd10      	pop	{r4, pc}
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
34003f3c:	2302      	movs	r3, #2
  int32_t ret = BSP_ERROR_NONE;
34003f3e:	2000      	movs	r0, #0
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
34003f40:	7023      	strb	r3, [r4, #0]
34003f42:	e7fa      	b.n	34003f3a <BSP_XSPI_NOR_EnableMemoryMappedMode+0x22>
      if (MX66UW1G45G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
34003f44:	4804      	ldr	r0, [pc, #16]	@ (34003f58 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x40>)
34003f46:	f7fe fe8f 	bl	34002c68 <MX66UW1G45G_EnableDTRMemoryMappedMode>
34003f4a:	e7f3      	b.n	34003f34 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1c>
    ret = BSP_ERROR_WRONG_PARAM;
34003f4c:	f06f 0001 	mvn.w	r0, #1
  return ret;
34003f50:	e7f3      	b.n	34003f3a <BSP_XSPI_NOR_EnableMemoryMappedMode+0x22>
34003f52:	bf00      	nop
34003f54:	340578b0 	.word	0x340578b0
34003f58:	340578b4 	.word	0x340578b4

34003f5c <BSP_XSPI_NOR_ConfigFlash>:
{
34003f5c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
34003f60:	460d      	mov	r5, r1
34003f62:	4616      	mov	r6, r2
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34003f64:	2800      	cmp	r0, #0
34003f66:	d15f      	bne.n	34004028 <BSP_XSPI_NOR_ConfigFlash+0xcc>
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
34003f68:	4c32      	ldr	r4, [pc, #200]	@ (34004034 <BSP_XSPI_NOR_ConfigFlash+0xd8>)
34003f6a:	7823      	ldrb	r3, [r4, #0]
34003f6c:	2b02      	cmp	r3, #2
34003f6e:	d05e      	beq.n	3400402e <BSP_XSPI_NOR_ConfigFlash+0xd2>
      switch (XSPI_Nor_Ctx[Instance].InterfaceMode)
34003f70:	7863      	ldrb	r3, [r4, #1]
34003f72:	2b01      	cmp	r3, #1
34003f74:	d14f      	bne.n	34004016 <BSP_XSPI_NOR_ConfigFlash+0xba>
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != XSPI_Nor_Ctx[Instance].TransferRate))
34003f76:	2901      	cmp	r1, #1
34003f78:	78a2      	ldrb	r2, [r4, #2]
34003f7a:	d109      	bne.n	34003f90 <BSP_XSPI_NOR_ConfigFlash+0x34>
34003f7c:	4296      	cmp	r6, r2
34003f7e:	d107      	bne.n	34003f90 <BSP_XSPI_NOR_ConfigFlash+0x34>
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34003f80:	2301      	movs	r3, #1
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34003f82:	2000      	movs	r0, #0
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34003f84:	7023      	strb	r3, [r4, #0]
        XSPI_Nor_Ctx[Instance].InterfaceMode = Mode;
34003f86:	7065      	strb	r5, [r4, #1]
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34003f88:	70a6      	strb	r6, [r4, #2]
}
34003f8a:	b004      	add	sp, #16
34003f8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
  int32_t ret = BSP_ERROR_NONE;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003f90:	4f29      	ldr	r7, [pc, #164]	@ (34004038 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34003f92:	2101      	movs	r1, #1
34003f94:	4638      	mov	r0, r7
34003f96:	f7fe feb7 	bl	34002d08 <MX66UW1G45G_WriteEnable>
34003f9a:	4603      	mov	r3, r0
34003f9c:	b110      	cbz	r0, 34003fa4 <BSP_XSPI_NOR_ConfigFlash+0x48>
            ret = XSPI_NOR_ExitOPIMode(Instance);
34003f9e:	f06f 0004 	mvn.w	r0, #4
34003fa2:	e7f2      	b.n	34003f8a <BSP_XSPI_NOR_ConfigFlash+0x2e>
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
    reg[1] = 0;
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003fa4:	9000      	str	r0, [sp, #0]
    reg[0] = 0;
34003fa6:	f8ad 000c 	strh.w	r0, [sp, #12]
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34003faa:	78a2      	ldrb	r2, [r4, #2]
34003fac:	4638      	mov	r0, r7
34003fae:	7861      	ldrb	r1, [r4, #1]
34003fb0:	f7fe ff33 	bl	34002e1a <MX66UW1G45G_WriteCfg2Register>
34003fb4:	4680      	mov	r8, r0
34003fb6:	2800      	cmp	r0, #0
34003fb8:	d1f1      	bne.n	34003f9e <BSP_XSPI_NOR_ConfigFlash+0x42>
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34003fba:	2028      	movs	r0, #40	@ 0x28
34003fbc:	f000 fc9e 	bl	340048fc <HAL_Delay>

      if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
34003fc0:	78a3      	ldrb	r3, [r4, #2]
34003fc2:	2b01      	cmp	r3, #1
34003fc4:	d01b      	beq.n	34003ffe <BSP_XSPI_NOR_ConfigFlash+0xa2>
      }

      if (ret == BSP_ERROR_NONE)
      {
        /* Check Flash busy ? */
        if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34003fc6:	2200      	movs	r2, #0
34003fc8:	481b      	ldr	r0, [pc, #108]	@ (34004038 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34003fca:	4611      	mov	r1, r2
34003fcc:	f7fe fd79 	bl	34002ac2 <MX66UW1G45G_AutoPollingMemReady>
34003fd0:	4603      	mov	r3, r0
34003fd2:	2800      	cmp	r0, #0
34003fd4:	d1e3      	bne.n	34003f9e <BSP_XSPI_NOR_ConfigFlash+0x42>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        /* Check the configuration has been correctly done */
        else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34003fd6:	aa03      	add	r2, sp, #12
34003fd8:	4601      	mov	r1, r0
34003fda:	9200      	str	r2, [sp, #0]
34003fdc:	4602      	mov	r2, r0
34003fde:	4816      	ldr	r0, [pc, #88]	@ (34004038 <BSP_XSPI_NOR_ConfigFlash+0xdc>)
34003fe0:	f7fe ff73 	bl	34002eca <MX66UW1G45G_ReadCfg2Register>
34003fe4:	2800      	cmp	r0, #0
34003fe6:	d1da      	bne.n	34003f9e <BSP_XSPI_NOR_ConfigFlash+0x42>
                                               MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        else if (reg[0] != 0U)
34003fe8:	f89d 300c 	ldrb.w	r3, [sp, #12]
34003fec:	2b00      	cmp	r3, #0
34003fee:	d1d6      	bne.n	34003f9e <BSP_XSPI_NOR_ConfigFlash+0x42>
            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
34003ff0:	2d01      	cmp	r5, #1
34003ff2:	d1c5      	bne.n	34003f80 <BSP_XSPI_NOR_ConfigFlash+0x24>
              if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34003ff4:	78a3      	ldrb	r3, [r4, #2]
34003ff6:	b993      	cbnz	r3, 3400401e <BSP_XSPI_NOR_ConfigFlash+0xc2>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
34003ff8:	f7ff ff18 	bl	34003e2c <XSPI_NOR_EnterDOPIMode.constprop.0>
34003ffc:	e011      	b.n	34004022 <BSP_XSPI_NOR_ConfigFlash+0xc6>
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34003ffe:	4638      	mov	r0, r7
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
34004000:	f8c7 800c 	str.w	r8, [r7, #12]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34004004:	f8c7 802c 	str.w	r8, [r7, #44]	@ 0x2c
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34004008:	f00b fed6 	bl	3400fdb8 <HAL_XSPI_Init>
3400400c:	2800      	cmp	r0, #0
3400400e:	d0da      	beq.n	34003fc6 <BSP_XSPI_NOR_ConfigFlash+0x6a>
            ret = XSPI_NOR_ExitOPIMode(Instance);
34004010:	f06f 0003 	mvn.w	r0, #3
34004014:	e7b9      	b.n	34003f8a <BSP_XSPI_NOR_ConfigFlash+0x2e>
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
34004016:	2901      	cmp	r1, #1
34004018:	d1b2      	bne.n	34003f80 <BSP_XSPI_NOR_ConfigFlash+0x24>
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
3400401a:	2a00      	cmp	r2, #0
3400401c:	d1ec      	bne.n	34003ff8 <BSP_XSPI_NOR_ConfigFlash+0x9c>
              ret = XSPI_NOR_EnterSOPIMode(Instance);
3400401e:	f7ff febf 	bl	34003da0 <XSPI_NOR_EnterSOPIMode.constprop.0>
      if (ret == BSP_ERROR_NONE)
34004022:	2800      	cmp	r0, #0
34004024:	d1b1      	bne.n	34003f8a <BSP_XSPI_NOR_ConfigFlash+0x2e>
34004026:	e7ab      	b.n	34003f80 <BSP_XSPI_NOR_ConfigFlash+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
34004028:	f06f 0001 	mvn.w	r0, #1
3400402c:	e7ad      	b.n	34003f8a <BSP_XSPI_NOR_ConfigFlash+0x2e>
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
3400402e:	f06f 0019 	mvn.w	r0, #25
  return ret;
34004032:	e7aa      	b.n	34003f8a <BSP_XSPI_NOR_ConfigFlash+0x2e>
34004034:	340578b0 	.word	0x340578b0
34004038:	340578b4 	.word	0x340578b4

3400403c <BSP_XSPI_NOR_Init>:
{
3400403c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34004040:	4689      	mov	r9, r1
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34004042:	4604      	mov	r4, r0
34004044:	4e81      	ldr	r6, [pc, #516]	@ (3400424c <BSP_XSPI_NOR_Init+0x210>)
{
34004046:	b08e      	sub	sp, #56	@ 0x38
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34004048:	2800      	cmp	r0, #0
3400404a:	f040 80f8 	bne.w	3400423e <BSP_XSPI_NOR_Init+0x202>
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
3400404e:	f8df 8208 	ldr.w	r8, [pc, #520]	@ 34004258 <BSP_XSPI_NOR_Init+0x21c>
34004052:	f898 3000 	ldrb.w	r3, [r8]
34004056:	b153      	cbz	r3, 3400406e <BSP_XSPI_NOR_Init+0x32>
      ret = BSP_ERROR_NONE;
34004058:	2500      	movs	r5, #0
 (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
3400405a:	2064      	movs	r0, #100	@ 0x64
3400405c:	2100      	movs	r1, #0
3400405e:	fb00 6004 	mla	r0, r0, r4, r6
34004062:	f00c fa83 	bl	3401056c <HAL_XSPI_SetClockPrescaler>
}
34004066:	4628      	mov	r0, r5
34004068:	b00e      	add	sp, #56	@ 0x38
3400406a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  WRITE_REG(RCC->AHB5ENSR, Periphs);
3400406e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34004072:	4a77      	ldr	r2, [pc, #476]	@ (34004250 <BSP_XSPI_NOR_Init+0x214>)
  __HAL_RCC_PWR_CLK_ENABLE();
34004074:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34004078:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
3400407c:	f8d2 1260 	ldr.w	r1, [r2, #608]	@ 0x260
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34004080:	2509      	movs	r5, #9
34004082:	9100      	str	r1, [sp, #0]
  (void)tmpreg;
34004084:	9900      	ldr	r1, [sp, #0]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34004086:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400408a:	441a      	add	r2, r3
3400408c:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
  __HAL_RCC_PWR_CLK_ENABLE();
34004090:	f7ff fe7a 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
34004094:	f004 ffce 	bl	34009034 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
34004098:	2101      	movs	r1, #1
3400409a:	2002      	movs	r0, #2
3400409c:	f004 ff7c 	bl	34008f98 <HAL_PWREx_ConfigVddIORange>
  XSPI_NOR_CLK_GPIO_CLK_ENABLE();
340040a0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340040a4:	f7ff fe70 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340040a8:	2701      	movs	r7, #1
  XSPI_NOR_DQS_GPIO_CLK_ENABLE();
340040aa:	f7ff fe6d 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_CS_GPIO_CLK_ENABLE();
340040ae:	f7ff fe6b 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D0_GPIO_CLK_ENABLE();
340040b2:	f7ff fe69 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D1_GPIO_CLK_ENABLE();
340040b6:	f7ff fe67 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D2_GPIO_CLK_ENABLE();
340040ba:	f7ff fe65 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D3_GPIO_CLK_ENABLE();
340040be:	f7ff fe63 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D4_GPIO_CLK_ENABLE();
340040c2:	f7ff fe61 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D5_GPIO_CLK_ENABLE();
340040c6:	f7ff fe5f 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D6_GPIO_CLK_ENABLE();
340040ca:	f7ff fe5d 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D7_GPIO_CLK_ENABLE();
340040ce:	f7ff fe5b 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  GPIO_InitStruct.Pin       = XSPI_NOR_CS_PIN;
340040d2:	2302      	movs	r3, #2
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
340040d4:	485f      	ldr	r0, [pc, #380]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
340040d6:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
340040d8:	e9cd 3305 	strd	r3, r3, [sp, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
340040dc:	e9cd 7307 	strd	r7, r3, [sp, #28]
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
340040e0:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
340040e2:	f003 fa95 	bl	34007610 <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
340040e6:	485b      	ldr	r0, [pc, #364]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
340040e8:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_DQS_PIN;
340040ea:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_DQS_PIN_AF;
340040ec:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
340040ee:	f003 fa8f 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
340040f2:	2340      	movs	r3, #64	@ 0x40
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
340040f4:	4857      	ldr	r0, [pc, #348]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
340040f6:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
340040f8:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
340040fa:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Alternate = XSPI_NOR_CLK_PIN_AF;
340040fc:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
340040fe:	f003 fa87 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
34004102:	2304      	movs	r3, #4
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34004104:	4853      	ldr	r0, [pc, #332]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004106:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
34004108:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D0_PIN_AF;
3400410a:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
3400410c:	f003 fa80 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
34004110:	2308      	movs	r3, #8
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
34004112:	4850      	ldr	r0, [pc, #320]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004114:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
34004116:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D1_PIN_AF;
34004118:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
3400411a:	f003 fa79 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
3400411e:	2310      	movs	r3, #16
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
34004120:	f04f 0a20 	mov.w	sl, #32
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
34004124:	484b      	ldr	r0, [pc, #300]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004126:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
34004128:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D2_PIN_AF;
3400412a:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
3400412c:	f003 fa70 	bl	34007610 <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
34004130:	4848      	ldr	r0, [pc, #288]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004132:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
34004134:	f8cd a014 	str.w	sl, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D3_PIN_AF;
34004138:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
3400413a:	f003 fa69 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
3400413e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
34004142:	4844      	ldr	r0, [pc, #272]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004144:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
34004146:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D4_PIN_AF;
34004148:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
3400414a:	f003 fa61 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
3400414e:	f44f 7300 	mov.w	r3, #512	@ 0x200
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
34004152:	4840      	ldr	r0, [pc, #256]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004154:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
34004156:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D5_PIN_AF;
34004158:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
3400415a:	f003 fa59 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
3400415e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
34004162:	483c      	ldr	r0, [pc, #240]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
34004164:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
34004166:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D6_PIN_AF;
34004168:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
3400416a:	f003 fa51 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
3400416e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
34004172:	a905      	add	r1, sp, #20
34004174:	4837      	ldr	r0, [pc, #220]	@ (34004254 <BSP_XSPI_NOR_Init+0x218>)
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
34004176:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_D7_PIN_AF;
34004178:	9509      	str	r5, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
3400417a:	f003 fa49 	bl	34007610 <HAL_GPIO_Init>
      (void)MX66UW1G45G_GetFlashInfo(&pInfo);
3400417e:	a805      	add	r0, sp, #20
34004180:	f7fe fc86 	bl	34002a90 <MX66UW1G45G_GetFlashInfo>
      xspi_init.ClockPrescaler = 0x03; /* XSPI clock = 200MHz / ClockPrescaler = 50MHz, then switch to 200MHz*/
34004184:	2303      	movs	r3, #3
34004186:	9302      	str	r3, [sp, #8]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34004188:	9b05      	ldr	r3, [sp, #20]
3400418a:	fa93 f3a3 	rbit	r3, r3
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
3400418e:	2b00      	cmp	r3, #0
34004190:	fab3 f283 	clz	r2, r3
34004194:	bf08      	it	eq
34004196:	4652      	moveq	r2, sl
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
34004198:	f899 3001 	ldrb.w	r3, [r9, #1]
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
3400419c:	4630      	mov	r0, r6
3400419e:	a901      	add	r1, sp, #4
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
340041a0:	9201      	str	r2, [sp, #4]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
340041a2:	9403      	str	r4, [sp, #12]
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
340041a4:	9304      	str	r3, [sp, #16]
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
340041a6:	f7ff fe95 	bl	34003ed4 <MX_XSPI_NOR_Init>
340041aa:	2800      	cmp	r0, #0
340041ac:	d14a      	bne.n	34004244 <BSP_XSPI_NOR_Init+0x208>
  if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
340041ae:	4622      	mov	r2, r4
340041b0:	4621      	mov	r1, r4
340041b2:	4630      	mov	r0, r6
340041b4:	f7fe feeb 	bl	34002f8e <MX66UW1G45G_ResetEnable>
340041b8:	b110      	cbz	r0, 340041c0 <BSP_XSPI_NOR_Init+0x184>
        ret = BSP_ERROR_COMPONENT_FAILURE;
340041ba:	f06f 0504 	mvn.w	r5, #4
340041be:	e74c      	b.n	3400405a <BSP_XSPI_NOR_Init+0x1e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
340041c0:	4622      	mov	r2, r4
340041c2:	4621      	mov	r1, r4
340041c4:	4630      	mov	r0, r6
340041c6:	f7fe ff0f 	bl	34002fe8 <MX66UW1G45G_ResetMemory>
340041ca:	2800      	cmp	r0, #0
340041cc:	d1f5      	bne.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340041ce:	4622      	mov	r2, r4
340041d0:	4639      	mov	r1, r7
340041d2:	4630      	mov	r0, r6
340041d4:	f7fe fedb 	bl	34002f8e <MX66UW1G45G_ResetEnable>
340041d8:	2800      	cmp	r0, #0
340041da:	d1ee      	bne.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340041dc:	4622      	mov	r2, r4
340041de:	4639      	mov	r1, r7
340041e0:	4630      	mov	r0, r6
340041e2:	f7fe ff01 	bl	34002fe8 <MX66UW1G45G_ResetMemory>
340041e6:	2800      	cmp	r0, #0
340041e8:	d1e7      	bne.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340041ea:	463a      	mov	r2, r7
340041ec:	4639      	mov	r1, r7
340041ee:	4630      	mov	r0, r6
340041f0:	f7fe fecd 	bl	34002f8e <MX66UW1G45G_ResetEnable>
340041f4:	2800      	cmp	r0, #0
340041f6:	d1e0      	bne.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
340041f8:	463a      	mov	r2, r7
340041fa:	4639      	mov	r1, r7
340041fc:	4630      	mov	r0, r6
340041fe:	f7fe fef3 	bl	34002fe8 <MX66UW1G45G_ResetMemory>
34004202:	2800      	cmp	r0, #0
34004204:	d1d9      	bne.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34004206:	2064      	movs	r0, #100	@ 0x64
    XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;     /* After reset S/W setting to indirect access  */
34004208:	f888 7000 	strb.w	r7, [r8]
    XSPI_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;    /* After reset H/W back to SPI mode by default */
3400420c:	f888 4001 	strb.w	r4, [r8, #1]
    XSPI_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode        */
34004210:	f888 4002 	strb.w	r4, [r8, #2]
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34004214:	f000 fb72 	bl	340048fc <HAL_Delay>
      else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34004218:	4630      	mov	r0, r6
3400421a:	f898 2002 	ldrb.w	r2, [r8, #2]
3400421e:	f898 1001 	ldrb.w	r1, [r8, #1]
34004222:	f7fe fc4e 	bl	34002ac2 <MX66UW1G45G_AutoPollingMemReady>
34004226:	2800      	cmp	r0, #0
34004228:	d1c7      	bne.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
3400422a:	f899 2001 	ldrb.w	r2, [r9, #1]
3400422e:	f899 1000 	ldrb.w	r1, [r9]
34004232:	f7ff fe93 	bl	34003f5c <BSP_XSPI_NOR_ConfigFlash>
34004236:	2800      	cmp	r0, #0
34004238:	f43f af0e 	beq.w	34004058 <BSP_XSPI_NOR_Init+0x1c>
3400423c:	e7bd      	b.n	340041ba <BSP_XSPI_NOR_Init+0x17e>
    ret = BSP_ERROR_WRONG_PARAM;
3400423e:	f06f 0501 	mvn.w	r5, #1
34004242:	e70a      	b.n	3400405a <BSP_XSPI_NOR_Init+0x1e>
        ret = BSP_ERROR_PERIPH_FAILURE;
34004244:	f06f 0503 	mvn.w	r5, #3
34004248:	e707      	b.n	3400405a <BSP_XSPI_NOR_Init+0x1e>
3400424a:	bf00      	nop
3400424c:	340578b4 	.word	0x340578b4
34004250:	56028000 	.word	0x56028000
34004254:	56023400 	.word	0x56023400
34004258:	340578b0 	.word	0x340578b0

3400425c <MX_XSPI_RAM_Init>:
{
3400425c:	b538      	push	{r3, r4, r5, lr}
3400425e:	4604      	mov	r4, r0
34004260:	460d      	mov	r5, r1
  uint32_t hspi_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1);
34004262:	2000      	movs	r0, #0
34004264:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
34004268:	f00a fa38 	bl	3400e6dc <HAL_RCCEx_GetPeriphCLKFreq>
  hxspi->Init.FifoThresholdByte          = 8;
3400426c:	2308      	movs	r3, #8
3400426e:	4a13      	ldr	r2, [pc, #76]	@ (340042bc <MX_XSPI_RAM_Init+0x60>)
  hxspi->Init.SampleShifting             = Init->SampleShifting;
34004270:	68a9      	ldr	r1, [r5, #8]
  hxspi->Init.FifoThresholdByte          = 8;
34004272:	e9c4 2300 	strd	r2, r3, [r4]
  hxspi->Init.MemoryMode                 = HAL_XSPI_SINGLE_MEM;
34004276:	2200      	movs	r2, #0
34004278:	f04f 63c0 	mov.w	r3, #100663296	@ 0x6000000
3400427c:	e9c4 2302 	strd	r2, r3, [r4, #8]
  hxspi->Init.MemorySize                 = Init->MemorySize;
34004280:	682b      	ldr	r3, [r5, #0]
  hxspi->Init.MemorySelect               = HAL_XSPI_CSSEL_NCS1;
34004282:	63e2      	str	r2, [r4, #60]	@ 0x3c
  hxspi->Init.MemorySize                 = Init->MemorySize;
34004284:	6123      	str	r3, [r4, #16]
  hxspi->Init.ChipSelectHighTimeCycle    = 1;
34004286:	2301      	movs	r3, #1
34004288:	6163      	str	r3, [r4, #20]
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
3400428a:	686b      	ldr	r3, [r5, #4]
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
3400428c:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
  hxspi->Init.SampleShifting             = Init->SampleShifting;
34004290:	62a1      	str	r1, [r4, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
34004292:	210b      	movs	r1, #11
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
34004294:	6263      	str	r3, [r4, #36]	@ 0x24
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
34004296:	fbb0 f3f3 	udiv	r3, r0, r3
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
3400429a:	e9c4 510b 	strd	r5, r1, [r4, #44]	@ 0x2c
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
3400429e:	4908      	ldr	r1, [pc, #32]	@ (340042c0 <MX_XSPI_RAM_Init+0x64>)
340042a0:	005b      	lsls	r3, r3, #1
340042a2:	fbb3 f3f1 	udiv	r3, r3, r1
340042a6:	3b04      	subs	r3, #4
  return HAL_XSPI_Init(hxspi);
340042a8:	4620      	mov	r0, r4
  hxspi->Init.ClockMode                  = HAL_XSPI_CLOCK_MODE_0;
340042aa:	61e2      	str	r2, [r4, #28]
  hxspi->Init.FreeRunningClock           = HAL_XSPI_FREERUNCLK_DISABLE;
340042ac:	61a2      	str	r2, [r4, #24]
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
340042ae:	63a3      	str	r3, [r4, #56]	@ 0x38
  hxspi->Init.WrapSize                   = HAL_XSPI_WRAP_NOT_SUPPORTED;
340042b0:	6222      	str	r2, [r4, #32]
}
340042b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return HAL_XSPI_Init(hxspi);
340042b6:	f00b bd7f 	b.w	3400fdb8 <HAL_XSPI_Init>
340042ba:	bf00      	nop
340042bc:	58025000 	.word	0x58025000
340042c0:	000f4240 	.word	0x000f4240

340042c4 <BSP_XSPI_RAM_Init>:
{
340042c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
340042c8:	4604      	mov	r4, r0
{
340042ca:	b08b      	sub	sp, #44	@ 0x2c
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
340042cc:	2800      	cmp	r0, #0
340042ce:	f040 810d 	bne.w	340044ec <BSP_XSPI_RAM_Init+0x228>
    if (XSPI_Ram_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
340042d2:	4e88      	ldr	r6, [pc, #544]	@ (340044f4 <BSP_XSPI_RAM_Init+0x230>)
340042d4:	7833      	ldrb	r3, [r6, #0]
340042d6:	9301      	str	r3, [sp, #4]
340042d8:	2b00      	cmp	r3, #0
340042da:	f040 80f0 	bne.w	340044be <BSP_XSPI_RAM_Init+0x1fa>

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

 /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
340042de:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
340042e2:	f7ff fd51 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO2();
340042e6:	f004 fe9d 	bl	34009024 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2, PWR_VDDIO_RANGE_1V8);
340042ea:	2101      	movs	r1, #1
  WRITE_REG(RCC->AHB5ENSR, Periphs);
340042ec:	f04f 0820 	mov.w	r8, #32
340042f0:	f44f 5700 	mov.w	r7, #8192	@ 0x2000
340042f4:	4608      	mov	r0, r1
340042f6:	f004 fe4f 	bl	34008f98 <HAL_PWREx_ConfigVddIORange>
340042fa:	4b7f      	ldr	r3, [pc, #508]	@ (340044f8 <BSP_XSPI_RAM_Init+0x234>)
  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CS_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
340042fc:	2409      	movs	r4, #9
340042fe:	f8c3 8a60 	str.w	r8, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34004302:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34004306:	2501      	movs	r5, #1
34004308:	9204      	str	r2, [sp, #16]
  (void)tmpreg;
3400430a:	9a04      	ldr	r2, [sp, #16]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400430c:	4a7b      	ldr	r2, [pc, #492]	@ (340044fc <BSP_XSPI_RAM_Init+0x238>)
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
3400430e:	f8c3 8a20 	str.w	r8, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34004312:	f8c2 8220 	str.w	r8, [r2, #544]	@ 0x220
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34004316:	f8c3 7a60 	str.w	r7, [r3, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
3400431a:	f8d3 1260 	ldr.w	r1, [r3, #608]	@ 0x260
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
3400431e:	f04f 0903 	mov.w	r9, #3
34004322:	9103      	str	r1, [sp, #12]
  (void)tmpreg;
34004324:	9903      	ldr	r1, [sp, #12]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34004326:	f8c3 7a20 	str.w	r7, [r3, #2592]	@ 0xa20
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
3400432a:	f8c2 7220 	str.w	r7, [r2, #544]	@ 0x220
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
3400432e:	2202      	movs	r2, #2
  XSPI_RAM_CLK_GPIO_CLK_ENABLE();
34004330:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34004334:	f7ff fd28 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_DQS_GPIO_CLK_ENABLE();
34004338:	f7ff fd26 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_CS_GPIO_CLK_ENABLE();
3400433c:	f7ff fd24 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D0_GPIO_CLK_ENABLE();
34004340:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34004344:	f7ff fd20 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
34004348:	a905      	add	r1, sp, #20
  XSPI_RAM_D1_GPIO_CLK_ENABLE();
3400434a:	f7ff fd1d 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D2_GPIO_CLK_ENABLE();
3400434e:	f7ff fd1b 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D3_GPIO_CLK_ENABLE();
34004352:	f7ff fd19 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D4_GPIO_CLK_ENABLE();
34004356:	f7ff fd17 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D5_GPIO_CLK_ENABLE();
3400435a:	f7ff fd15 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D6_GPIO_CLK_ENABLE();
3400435e:	f7ff fd13 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D7_GPIO_CLK_ENABLE();
34004362:	f7ff fd11 	bl	34003d88 <LL_AHB4_GRP1_EnableClock>
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
34004366:	4866      	ldr	r0, [pc, #408]	@ (34004500 <BSP_XSPI_RAM_Init+0x23c>)
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34004368:	e9cd 5205 	strd	r5, r2, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
3400436c:	e9cd 9408 	strd	r9, r4, [sp, #32]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004370:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
34004372:	f003 f94d 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI DQS0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
34004376:	2304      	movs	r3, #4
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);

  /* XSPI DQS1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
34004378:	f04f 0b08 	mov.w	fp, #8
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
3400437c:	f04f 0a10 	mov.w	sl, #16
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
34004380:	485f      	ldr	r0, [pc, #380]	@ (34004500 <BSP_XSPI_RAM_Init+0x23c>)
34004382:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
34004384:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
34004386:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004388:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
3400438a:	f003 f941 	bl	34007610 <HAL_GPIO_Init>
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
3400438e:	485c      	ldr	r0, [pc, #368]	@ (34004500 <BSP_XSPI_RAM_Init+0x23c>)
34004390:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
34004392:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
34004394:	f8cd b014 	str.w	fp, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34004398:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
3400439a:	f003 f939 	bl	34007610 <HAL_GPIO_Init>
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
3400439e:	4858      	ldr	r0, [pc, #352]	@ (34004500 <BSP_XSPI_RAM_Init+0x23c>)
340043a0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
340043a2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
340043a4:	f8cd a014 	str.w	sl, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340043a8:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
340043aa:	f003 f931 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
340043ae:	4855      	ldr	r0, [pc, #340]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
340043b0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
340043b2:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
340043b4:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
340043b6:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
340043b8:	f003 f92a 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
340043bc:	2202      	movs	r2, #2
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
340043be:	4851      	ldr	r0, [pc, #324]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
340043c0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
340043c2:	9205      	str	r2, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
340043c4:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
340043c6:	f003 f923 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
340043ca:	2304      	movs	r3, #4
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
340043cc:	484d      	ldr	r0, [pc, #308]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
340043ce:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
340043d0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
340043d2:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
340043d4:	f003 f91c 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
340043d8:	484a      	ldr	r0, [pc, #296]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
340043da:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
340043dc:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
340043de:	f8cd b014 	str.w	fp, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
340043e2:	f003 f915 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
340043e6:	4847      	ldr	r0, [pc, #284]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
340043e8:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
340043ea:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
340043ec:	f8cd a014 	str.w	sl, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
340043f0:	f003 f90e 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
340043f4:	4843      	ldr	r0, [pc, #268]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
340043f6:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
340043f8:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
340043fa:	f8cd 8014 	str.w	r8, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
340043fe:	f003 f907 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
34004402:	2340      	movs	r3, #64	@ 0x40
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34004404:	483f      	ldr	r0, [pc, #252]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004406:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
34004408:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
3400440a:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
3400440c:	f003 f900 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
34004410:	2380      	movs	r3, #128	@ 0x80
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
34004412:	483c      	ldr	r0, [pc, #240]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004414:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
34004416:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
34004418:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
3400441a:	f003 f8f9 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D8 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
3400441e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
34004422:	4838      	ldr	r0, [pc, #224]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004424:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
34004426:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
34004428:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
3400442a:	f003 f8f1 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D9 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
3400442e:	f44f 7300 	mov.w	r3, #512	@ 0x200
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
34004432:	4834      	ldr	r0, [pc, #208]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004434:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
34004436:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
34004438:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
3400443a:	f003 f8e9 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D10 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
3400443e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
34004442:	4830      	ldr	r0, [pc, #192]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004444:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
34004446:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
34004448:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
3400444a:	f003 f8e1 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D11 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
3400444e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
34004452:	482c      	ldr	r0, [pc, #176]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004454:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
34004456:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
34004458:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
3400445a:	f003 f8d9 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D12 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
3400445e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
34004462:	4828      	ldr	r0, [pc, #160]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004464:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
34004466:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
34004468:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
3400446a:	f003 f8d1 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D13 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
3400446e:	4825      	ldr	r0, [pc, #148]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004470:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
34004472:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
34004474:	9705      	str	r7, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
34004476:	f003 f8cb 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D14 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
3400447a:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
3400447e:	4821      	ldr	r0, [pc, #132]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004480:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
34004482:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34004484:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
34004486:	f003 f8c3 	bl	34007610 <HAL_GPIO_Init>

  /* XSPI D15 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
3400448a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
3400448e:	481d      	ldr	r0, [pc, #116]	@ (34004504 <BSP_XSPI_RAM_Init+0x240>)
34004490:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
34004492:	9409      	str	r4, [sp, #36]	@ 0x24
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
34004494:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
34004496:	f003 f8bb 	bl	34007610 <HAL_GPIO_Init>
      xspi_init.MemorySize     = HAL_XSPI_SIZE_256MB;
3400449a:	2318      	movs	r3, #24
3400449c:	9305      	str	r3, [sp, #20]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3400449e:	9b01      	ldr	r3, [sp, #4]
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
340044a0:	4819      	ldr	r0, [pc, #100]	@ (34004508 <BSP_XSPI_RAM_Init+0x244>)
340044a2:	a905      	add	r1, sp, #20
      xspi_init.ClockPrescaler = 3;
340044a4:	f8cd 9018 	str.w	r9, [sp, #24]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
340044a8:	9307      	str	r3, [sp, #28]
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
340044aa:	f7ff fed7 	bl	3400425c <MX_XSPI_RAM_Init>
  int32_t ret = BSP_ERROR_NONE;
340044ae:	2800      	cmp	r0, #0
340044b0:	bf14      	ite	ne
340044b2:	f06f 0403 	mvnne.w	r4, #3
340044b6:	2400      	moveq	r4, #0
      XSPI_Ram_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
340044b8:	7035      	strb	r5, [r6, #0]
      XSPI_Ram_Ctx[Instance].LatencyType   = BSP_XSPI_RAM_FIXED_LATENCY;
340044ba:	7075      	strb	r5, [r6, #1]
      XSPI_Ram_Ctx[Instance].BurstType     = BSP_XSPI_RAM_LINEAR_BURST;
340044bc:	70b5      	strb	r5, [r6, #2]
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 0, 0x30));
340044be:	2230      	movs	r2, #48	@ 0x30
340044c0:	2100      	movs	r1, #0
340044c2:	4811      	ldr	r0, [pc, #68]	@ (34004508 <BSP_XSPI_RAM_Init+0x244>)
340044c4:	f7fe faac 	bl	34002a20 <APS256XX_WriteReg>
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 4, 0x20));
340044c8:	2220      	movs	r2, #32
340044ca:	2104      	movs	r1, #4
340044cc:	480e      	ldr	r0, [pc, #56]	@ (34004508 <BSP_XSPI_RAM_Init+0x244>)
340044ce:	f7fe faa7 	bl	34002a20 <APS256XX_WriteReg>
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 8, 0x40));
340044d2:	2108      	movs	r1, #8
340044d4:	2240      	movs	r2, #64	@ 0x40
340044d6:	480c      	ldr	r0, [pc, #48]	@ (34004508 <BSP_XSPI_RAM_Init+0x244>)
340044d8:	f7fe faa2 	bl	34002a20 <APS256XX_WriteReg>
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_ram[Instance], 0));
340044dc:	2100      	movs	r1, #0
340044de:	480a      	ldr	r0, [pc, #40]	@ (34004508 <BSP_XSPI_RAM_Init+0x244>)
340044e0:	f00c f844 	bl	3401056c <HAL_XSPI_SetClockPrescaler>
}
340044e4:	4620      	mov	r0, r4
340044e6:	b00b      	add	sp, #44	@ 0x2c
340044e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = BSP_ERROR_WRONG_PARAM;
340044ec:	f06f 0401 	mvn.w	r4, #1
  return ret;
340044f0:	e7f8      	b.n	340044e4 <BSP_XSPI_RAM_Init+0x220>
340044f2:	bf00      	nop
340044f4:	34057848 	.word	0x34057848
340044f8:	56028000 	.word	0x56028000
340044fc:	56029000 	.word	0x56029000
34004500:	56023800 	.word	0x56023800
34004504:	56023c00 	.word	0x56023c00
34004508:	3405784c 	.word	0x3405784c

3400450c <BSP_XSPI_RAM_EnableMemoryMappedMode>:
{
3400450c:	b507      	push	{r0, r1, r2, lr}
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
3400450e:	b968      	cbnz	r0, 3400452c <BSP_XSPI_RAM_EnableMemoryMappedMode+0x20>
    if (APS256XX_EnableMemoryMappedMode(&hxspi_ram[Instance], 7, 7, 1, 0) != APS256XX_OK)
34004510:	2207      	movs	r2, #7
34004512:	9000      	str	r0, [sp, #0]
34004514:	2301      	movs	r3, #1
34004516:	4611      	mov	r1, r2
34004518:	4806      	ldr	r0, [pc, #24]	@ (34004534 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x28>)
3400451a:	f7fe fa26 	bl	3400296a <APS256XX_EnableMemoryMappedMode>
      ret = BSP_ERROR_PERIPH_FAILURE;
3400451e:	2800      	cmp	r0, #0
34004520:	bf18      	it	ne
34004522:	f06f 0003 	mvnne.w	r0, #3
}
34004526:	b003      	add	sp, #12
34004528:	f85d fb04 	ldr.w	pc, [sp], #4
    ret = BSP_ERROR_WRONG_PARAM;
3400452c:	f06f 0001 	mvn.w	r0, #1
34004530:	e7f9      	b.n	34004526 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x1a>
34004532:	bf00      	nop
34004534:	3405784c 	.word	0x3405784c

34004538 <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34004538:	4b44      	ldr	r3, [pc, #272]	@ (3400464c <SystemInit+0x114>)
3400453a:	4a45      	ldr	r2, [pc, #276]	@ (34004650 <SystemInit+0x118>)
{
3400453c:	b570      	push	{r4, r5, r6, lr}
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
3400453e:	2001      	movs	r0, #1
  SCB->VTOR = INTVECT_START;
34004540:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
  SAU->RLAR = 0;
  SAU->RNR = 1;
  SAU->RBAR = 0;
  SAU->RLAR = 0;
  SAU->RNR = 2;
34004542:	2502      	movs	r5, #2
  SAU->RNR = 0;
34004544:	2200      	movs	r2, #0
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
34004546:	4943      	ldr	r1, [pc, #268]	@ (34004654 <SystemInit+0x11c>)
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34004548:	4e43      	ldr	r6, [pc, #268]	@ (34004658 <SystemInit+0x120>)
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
3400454a:	f501 5480 	add.w	r4, r1, #4096	@ 0x1000
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
3400454e:	f8c1 0a18 	str.w	r0, [r1, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34004552:	f8c4 0218 	str.w	r0, [r4, #536]	@ 0x218
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34004556:	f8c4 0258 	str.w	r0, [r4, #600]	@ 0x258
  SAU->RNR = 0;
3400455a:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
3400455e:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004562:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 1;
34004566:	f8c3 00d8 	str.w	r0, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
3400456a:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
3400456e:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 2;
34004572:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 3;
34004576:	2503      	movs	r5, #3
  SAU->RBAR = 0;
34004578:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
3400457c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 3;
34004580:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 4;
34004584:	2504      	movs	r5, #4
  SAU->RBAR = 0;
34004586:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
3400458a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 4;
3400458e:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 5;
34004592:	2505      	movs	r5, #5
  SAU->RBAR = 0;
34004594:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
34004598:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 5;
3400459c:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 6;
340045a0:	2506      	movs	r5, #6
  SAU->RBAR = 0;
340045a2:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340045a6:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 6;
340045aa:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RNR = 7;
340045ae:	2507      	movs	r5, #7
  SAU->RBAR = 0;
340045b0:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340045b4:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  SAU->RNR = 7;
340045b8:	f8c3 50d8 	str.w	r5, [r3, #216]	@ 0xd8
  SAU->RBAR = 0;
340045bc:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  SAU->RLAR = 0;
340045c0:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
340045c4:	f8c1 0a78 	str.w	r0, [r1, #2680]	@ 0xa78
  (void)RCC->APB4ENR2;
340045c8:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
  SYSCFG->INITSVTORCR = SCB->VTOR;
340045cc:	689a      	ldr	r2, [r3, #8]
340045ce:	6132      	str	r2, [r6, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
340045d0:	4a22      	ldr	r2, [pc, #136]	@ (3400465c <SystemInit+0x124>)
340045d2:	6bd5      	ldr	r5, [r2, #60]	@ 0x3c
340045d4:	f445 5580 	orr.w	r5, r5, #4096	@ 0x1000
340045d8:	63d5      	str	r5, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
340045da:	6bd5      	ldr	r5, [r2, #60]	@ 0x3c
340045dc:	f045 0510 	orr.w	r5, r5, #16
340045e0:	63d5      	str	r5, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
340045e2:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
340045e4:	f8d1 2274 	ldr.w	r2, [r1, #628]	@ 0x274
340045e8:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
340045ec:	f8c1 2274 	str.w	r2, [r1, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
340045f0:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
340045f4:	f042 0210 	orr.w	r2, r2, #16
340045f8:	f8c1 2278 	str.w	r2, [r1, #632]	@ 0x278
  (void) RCC->APB4ENR2;
340045fc:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34004600:	f8d1 2278 	ldr.w	r2, [r1, #632]	@ 0x278
34004604:	f022 0210 	bic.w	r2, r2, #16
34004608:	f8c1 2278 	str.w	r2, [r1, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
3400460c:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34004610:	f8c1 2a20 	str.w	r2, [r1, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34004614:	f8c4 2220 	str.w	r2, [r4, #544]	@ 0x220
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34004618:	2240      	movs	r2, #64	@ 0x40
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
3400461a:	f8c1 0a24 	str.w	r0, [r1, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
3400461e:	f8c4 0224 	str.w	r0, [r4, #548]	@ 0x224
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34004622:	f8c4 0264 	str.w	r0, [r4, #612]	@ 0x264
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34004626:	f8c4 225c 	str.w	r2, [r4, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
3400462a:	6932      	ldr	r2, [r6, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
3400462c:	f8c4 0278 	str.w	r0, [r4, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34004630:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34004634:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
34004638:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
3400463c:	4a08      	ldr	r2, [pc, #32]	@ (34004660 <SystemInit+0x128>)
3400463e:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
34004642:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34004646:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
3400464a:	bd70      	pop	{r4, r5, r6, pc}
3400464c:	e000ed00 	.word	0xe000ed00
34004650:	34000400 	.word	0x34000400
34004654:	56028000 	.word	0x56028000
34004658:	56008000 	.word	0x56008000
3400465c:	56024800 	.word	0x56024800
34004660:	e002ed00 	.word	0xe002ed00

34004664 <SystemCoreClockUpdate>:
  uint32_t pllp2 = 0;
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004664:	4b6e      	ldr	r3, [pc, #440]	@ (34004820 <SystemCoreClockUpdate+0x1bc>)
{
34004666:	b5f0      	push	{r4, r5, r6, r7, lr}
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004668:	6a1a      	ldr	r2, [r3, #32]
3400466a:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
3400466e:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
34004672:	f000 80b8 	beq.w	340047e6 <SystemCoreClockUpdate+0x182>
34004676:	d806      	bhi.n	34004686 <SystemCoreClockUpdate+0x22>
34004678:	b962      	cbnz	r2, 34004694 <SystemCoreClockUpdate+0x30>
  {
  case 0:  /* HSI used as system clock source (default after reset) */
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3400467a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400467c:	4b69      	ldr	r3, [pc, #420]	@ (34004824 <SystemCoreClockUpdate+0x1c0>)
3400467e:	f3c2 12c1 	ubfx	r2, r2, #7, #2
34004682:	40d3      	lsrs	r3, r2
    break;
34004684:	e003      	b.n	3400468e <SystemCoreClockUpdate+0x2a>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34004686:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
3400468a:	d00b      	beq.n	340046a4 <SystemCoreClockUpdate+0x40>
  uint32_t sysclk = 0;
3400468c:	2300      	movs	r3, #0
    /* Nothing to do, should not occur */
    break;
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
3400468e:	4a66      	ldr	r2, [pc, #408]	@ (34004828 <SystemCoreClockUpdate+0x1c4>)
34004690:	6013      	str	r3, [r2, #0]
}
34004692:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34004694:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
      sysclk = MSI_VALUE;
34004696:	4a65      	ldr	r2, [pc, #404]	@ (3400482c <SystemCoreClockUpdate+0x1c8>)
34004698:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400469c:	4b64      	ldr	r3, [pc, #400]	@ (34004830 <SystemCoreClockUpdate+0x1cc>)
3400469e:	bf08      	it	eq
340046a0:	4613      	moveq	r3, r2
340046a2:	e7f4      	b.n	3400468e <SystemCoreClockUpdate+0x2a>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
340046a4:	f8d3 20c4 	ldr.w	r2, [r3, #196]	@ 0xc4
340046a8:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
340046ac:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
340046b0:	d02a      	beq.n	34004708 <SystemCoreClockUpdate+0xa4>
340046b2:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
340046b6:	d036      	beq.n	34004726 <SystemCoreClockUpdate+0xc2>
340046b8:	2a00      	cmp	r2, #0
340046ba:	d143      	bne.n	34004744 <SystemCoreClockUpdate+0xe0>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
340046bc:	f8d3 7080 	ldr.w	r7, [r3, #128]	@ 0x80
      if (pllbypass == 0U)
340046c0:	013d      	lsls	r5, r7, #4
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
340046c2:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
340046c6:	f100 8096 	bmi.w	340047f6 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
340046ca:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
340046ce:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
340046d2:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
340046d6:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
340046da:	460e      	mov	r6, r1
    switch (pllsource)
340046dc:	f1b6 5f00 	cmp.w	r6, #536870912	@ 0x20000000
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
340046e0:	f3c2 65c2 	ubfx	r5, r2, #27, #3
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
340046e4:	f3c7 5105 	ubfx	r1, r7, #20, #6
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
340046e8:	f3c2 6202 	ubfx	r2, r2, #24, #3
    switch (pllsource)
340046ec:	d04f      	beq.n	3400478e <SystemCoreClockUpdate+0x12a>
340046ee:	d87c      	bhi.n	340047ea <SystemCoreClockUpdate+0x186>
340046f0:	2e00      	cmp	r6, #0
340046f2:	d03c      	beq.n	3400476e <SystemCoreClockUpdate+0x10a>
340046f4:	2600      	movs	r6, #0
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
340046f6:	4b4a      	ldr	r3, [pc, #296]	@ (34004820 <SystemCoreClockUpdate+0x1bc>)
        sysclk = MSI_VALUE;
340046f8:	4f4c      	ldr	r7, [pc, #304]	@ (3400482c <SystemCoreClockUpdate+0x1c8>)
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
340046fa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        sysclk = MSI_VALUE;
340046fc:	f413 7f00 	tst.w	r3, #512	@ 0x200
34004700:	4b4b      	ldr	r3, [pc, #300]	@ (34004830 <SystemCoreClockUpdate+0x1cc>)
34004702:	bf08      	it	eq
34004704:	463b      	moveq	r3, r7
34004706:	e038      	b.n	3400477a <SystemCoreClockUpdate+0x116>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34004708:	f8d3 7090 	ldr.w	r7, [r3, #144]	@ 0x90
      if (pllbypass == 0U)
3400470c:	013c      	lsls	r4, r7, #4
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
3400470e:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34004712:	d470      	bmi.n	340047f6 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34004714:	f8d3 0094 	ldr.w	r0, [r3, #148]	@ 0x94
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34004718:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
3400471c:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34004720:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34004724:	e7d9      	b.n	340046da <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34004726:	f8d3 70a0 	ldr.w	r7, [r3, #160]	@ 0xa0
      if (pllbypass == 0U)
3400472a:	0138      	lsls	r0, r7, #4
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
3400472c:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
34004730:	d461      	bmi.n	340047f6 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34004732:	f8d3 00a4 	ldr.w	r0, [r3, #164]	@ 0xa4
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34004736:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
3400473a:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
3400473e:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34004742:	e7ca      	b.n	340046da <SystemCoreClockUpdate+0x76>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34004744:	f8d3 70b0 	ldr.w	r7, [r3, #176]	@ 0xb0
      if (pllbypass == 0U)
34004748:	013a      	lsls	r2, r7, #4
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
3400474a:	f007 41e0 	and.w	r1, r7, #1879048192	@ 0x70000000
      if (pllbypass == 0U)
3400474e:	d452      	bmi.n	340047f6 <SystemCoreClockUpdate+0x192>
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34004750:	f8d3 00b4 	ldr.w	r0, [r3, #180]	@ 0xb4
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34004754:	f3c7 240b 	ubfx	r4, r7, #8, #12
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34004758:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
3400475c:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34004760:	e7bb      	b.n	340046da <SystemCoreClockUpdate+0x76>
    switch (pllsource)
34004762:	460a      	mov	r2, r1
34004764:	460d      	mov	r5, r1
34004766:	4608      	mov	r0, r1
34004768:	460c      	mov	r4, r1
3400476a:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3400476e:	4b2c      	ldr	r3, [pc, #176]	@ (34004820 <SystemCoreClockUpdate+0x1bc>)
34004770:	6c9f      	ldr	r7, [r3, #72]	@ 0x48
34004772:	4b2c      	ldr	r3, [pc, #176]	@ (34004824 <SystemCoreClockUpdate+0x1c0>)
34004774:	f3c7 17c1 	ubfx	r7, r7, #7, #2
34004778:	40fb      	lsrs	r3, r7
    if (pllbypass == 0U)
3400477a:	b14e      	cbz	r6, 34004790 <SystemCoreClockUpdate+0x12c>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
3400477c:	4a28      	ldr	r2, [pc, #160]	@ (34004820 <SystemCoreClockUpdate+0x1bc>)
3400477e:	f8d2 20c4 	ldr.w	r2, [r2, #196]	@ 0xc4
34004782:	f3c2 4207 	ubfx	r2, r2, #16, #8
34004786:	3201      	adds	r2, #1
    sysclk = sysclk / ic_divider;
34004788:	fbb3 f3f2 	udiv	r3, r3, r2
    break;
3400478c:	e77f      	b.n	3400468e <SystemCoreClockUpdate+0x2a>
      sysclk = HSE_VALUE;
3400478e:	4b29      	ldr	r3, [pc, #164]	@ (34004834 <SystemCoreClockUpdate+0x1d0>)
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34004790:	ee07 0a10 	vmov	s14, r0
34004794:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
34004798:	ee07 4a10 	vmov	s14, r4
3400479c:	ee07 3a90 	vmov	s15, r3
340047a0:	eddf 6a25 	vldr	s13, [pc, #148]	@ 34004838 <SystemCoreClockUpdate+0x1d4>
340047a4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
340047a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340047ac:	eea6 7a26 	vfma.f32	s14, s12, s13
340047b0:	ee67 7a87 	vmul.f32	s15, s15, s14
340047b4:	ee07 1a10 	vmov	s14, r1
340047b8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
340047bc:	eec7 6a87 	vdiv.f32	s13, s15, s14
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
340047c0:	ee07 5a90 	vmov	s15, r5
340047c4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
340047c8:	ee07 2a90 	vmov	s15, r2
340047cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340047d0:	ee27 7a27 	vmul.f32	s14, s14, s15
340047d4:	eec6 7a87 	vdiv.f32	s15, s13, s14
340047d8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
340047dc:	ee17 3a90 	vmov	r3, s15
340047e0:	e7cc      	b.n	3400477c <SystemCoreClockUpdate+0x118>
      sysclk = HSE_VALUE;
340047e2:	4b14      	ldr	r3, [pc, #80]	@ (34004834 <SystemCoreClockUpdate+0x1d0>)
340047e4:	e7ca      	b.n	3400477c <SystemCoreClockUpdate+0x118>
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
340047e6:	4b13      	ldr	r3, [pc, #76]	@ (34004834 <SystemCoreClockUpdate+0x1d0>)
340047e8:	e751      	b.n	3400468e <SystemCoreClockUpdate+0x2a>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
340047ea:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
340047ee:	4b13      	ldr	r3, [pc, #76]	@ (3400483c <SystemCoreClockUpdate+0x1d8>)
340047f0:	bf18      	it	ne
340047f2:	2300      	movne	r3, #0
340047f4:	e7cc      	b.n	34004790 <SystemCoreClockUpdate+0x12c>
    switch (pllsource)
340047f6:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
340047fa:	d0f2      	beq.n	340047e2 <SystemCoreClockUpdate+0x17e>
340047fc:	d809      	bhi.n	34004812 <SystemCoreClockUpdate+0x1ae>
340047fe:	2900      	cmp	r1, #0
34004800:	d0af      	beq.n	34004762 <SystemCoreClockUpdate+0xfe>
34004802:	2200      	movs	r2, #0
34004804:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
34004808:	4615      	mov	r5, r2
3400480a:	4610      	mov	r0, r2
3400480c:	4614      	mov	r4, r2
3400480e:	4611      	mov	r1, r2
34004810:	e771      	b.n	340046f6 <SystemCoreClockUpdate+0x92>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34004812:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34004816:	4b09      	ldr	r3, [pc, #36]	@ (3400483c <SystemCoreClockUpdate+0x1d8>)
34004818:	bf18      	it	ne
3400481a:	2300      	movne	r3, #0
3400481c:	e7ae      	b.n	3400477c <SystemCoreClockUpdate+0x118>
3400481e:	bf00      	nop
34004820:	56028000 	.word	0x56028000
34004824:	03d09000 	.word	0x03d09000
34004828:	3403edcc 	.word	0x3403edcc
3400482c:	003d0900 	.word	0x003d0900
34004830:	00f42400 	.word	0x00f42400
34004834:	02dc6c00 	.word	0x02dc6c00
34004838:	33800000 	.word	0x33800000
3400483c:	00bb8000 	.word	0x00bb8000

34004840 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34004840:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34004844:	b500      	push	{lr}
  SystemCoreClockUpdate();
34004846:	f7ff ff0d 	bl	34004664 <SystemCoreClockUpdate>

  return SystemCoreClock;
}
3400484a:	4b05      	ldr	r3, [pc, #20]	@ (34004860 <__acle_se_SECURE_SystemCoreClockUpdate+0x20>)
3400484c:	f85d eb04 	ldr.w	lr, [sp], #4
34004850:	6818      	ldr	r0, [r3, #0]
34004852:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34004856:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
3400485a:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
3400485e:	4774      	bxns	lr
34004860:	3403edcc 	.word	0x3403edcc

34004864 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
34004864:	4770      	bx	lr
	...

34004868 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34004868:	b538      	push	{r3, r4, r5, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
3400486a:	4b0f      	ldr	r3, [pc, #60]	@ (340048a8 <HAL_InitTick+0x40>)
{
3400486c:	4605      	mov	r5, r0
  if ((uint32_t)uwTickFreq == 0UL)
3400486e:	781a      	ldrb	r2, [r3, #0]
34004870:	b90a      	cbnz	r2, 34004876 <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
34004872:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
34004874:	bd38      	pop	{r3, r4, r5, pc}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34004876:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
3400487a:	fbb3 f3f2 	udiv	r3, r3, r2
3400487e:	4a0b      	ldr	r2, [pc, #44]	@ (340048ac <HAL_InitTick+0x44>)
34004880:	6810      	ldr	r0, [r2, #0]
34004882:	fbb0 f0f3 	udiv	r0, r0, r3
34004886:	f000 f9f1 	bl	34004c6c <HAL_SYSTICK_Config>
3400488a:	4604      	mov	r4, r0
3400488c:	2800      	cmp	r0, #0
3400488e:	d1f0      	bne.n	34004872 <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34004890:	2d0f      	cmp	r5, #15
34004892:	d8ee      	bhi.n	34004872 <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
34004894:	4602      	mov	r2, r0
34004896:	4629      	mov	r1, r5
34004898:	f04f 30ff 	mov.w	r0, #4294967295
3400489c:	f000 f974 	bl	34004b88 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
340048a0:	4b03      	ldr	r3, [pc, #12]	@ (340048b0 <HAL_InitTick+0x48>)
340048a2:	4620      	mov	r0, r4
340048a4:	601d      	str	r5, [r3, #0]
  return HAL_OK;
340048a6:	e7e5      	b.n	34004874 <HAL_InitTick+0xc>
340048a8:	3403edd0 	.word	0x3403edd0
340048ac:	3403edcc 	.word	0x3403edcc
340048b0:	3403edd4 	.word	0x3403edd4

340048b4 <HAL_Init>:
{
340048b4:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
340048b6:	2003      	movs	r0, #3
340048b8:	f000 f948 	bl	34004b4c <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
340048bc:	f7ff fed2 	bl	34004664 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
340048c0:	200f      	movs	r0, #15
340048c2:	f7ff ffd1 	bl	34004868 <HAL_InitTick>
340048c6:	4604      	mov	r4, r0
340048c8:	b918      	cbnz	r0, 340048d2 <HAL_Init+0x1e>
  HAL_MspInit();
340048ca:	f7ff ffcb 	bl	34004864 <HAL_MspInit>
}
340048ce:	4620      	mov	r0, r4
340048d0:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340048d2:	2401      	movs	r4, #1
340048d4:	e7fb      	b.n	340048ce <HAL_Init+0x1a>
	...

340048d8 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
340048d8:	4a03      	ldr	r2, [pc, #12]	@ (340048e8 <HAL_IncTick+0x10>)
340048da:	4b04      	ldr	r3, [pc, #16]	@ (340048ec <HAL_IncTick+0x14>)
340048dc:	6811      	ldr	r1, [r2, #0]
340048de:	781b      	ldrb	r3, [r3, #0]
340048e0:	440b      	add	r3, r1
340048e2:	6013      	str	r3, [r2, #0]
}
340048e4:	4770      	bx	lr
340048e6:	bf00      	nop
340048e8:	34057918 	.word	0x34057918
340048ec:	3403edd0 	.word	0x3403edd0

340048f0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
340048f0:	4b01      	ldr	r3, [pc, #4]	@ (340048f8 <HAL_GetTick+0x8>)
340048f2:	6818      	ldr	r0, [r3, #0]
}
340048f4:	4770      	bx	lr
340048f6:	bf00      	nop
340048f8:	34057918 	.word	0x34057918

340048fc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
340048fc:	b538      	push	{r3, r4, r5, lr}
340048fe:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
34004900:	f7ff fff6 	bl	340048f0 <HAL_GetTick>
34004904:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
34004906:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
34004908:	bf1e      	ittt	ne
3400490a:	4b04      	ldrne	r3, [pc, #16]	@ (3400491c <HAL_Delay+0x20>)
3400490c:	781b      	ldrbne	r3, [r3, #0]
3400490e:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
34004910:	f7ff ffee 	bl	340048f0 <HAL_GetTick>
34004914:	1b43      	subs	r3, r0, r5
34004916:	42a3      	cmp	r3, r4
34004918:	d3fa      	bcc.n	34004910 <HAL_Delay+0x14>
  {
  }
}
3400491a:	bd38      	pop	{r3, r4, r5, pc}
3400491c:	3403edd0 	.word	0x3403edd0

34004920 <HAL_BSEC_OTP_Reload>:
  * @param  FuseId  Fuse to be reload, this parameter value is between 0 and BSEC_NB_FUSES-1
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_BSEC_OTP_Reload(BSEC_HandleTypeDef *hbsec, uint32_t FuseId)
{
34004920:	b570      	push	{r4, r5, r6, lr}
34004922:	4604      	mov	r4, r0
34004924:	460d      	mov	r5, r1
  uint32_t status_reg;
  uint32_t status_bit;
  uint32_t tick_start = HAL_GetTick();
34004926:	f7ff ffe3 	bl	340048f0 <HAL_GetTick>
3400492a:	4606      	mov	r6, r0

  /* Check the handle pointer */
  if (hbsec == NULL)
3400492c:	b12c      	cbz	r4, 3400493a <HAL_BSEC_OTP_Reload+0x1a>
  {
    return HAL_ERROR;
  }

  /* Check the instance */
 if (hbsec->Instance != BSEC)
3400492e:	6822      	ldr	r2, [r4, #0]
34004930:	4b1b      	ldr	r3, [pc, #108]	@ (340049a0 <HAL_BSEC_OTP_Reload+0x80>)
34004932:	429a      	cmp	r2, r3
34004934:	d003      	beq.n	3400493e <HAL_BSEC_OTP_Reload+0x1e>
  {
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
34004936:	2301      	movs	r3, #1
34004938:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
3400493a:	2001      	movs	r0, #1
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
    return HAL_ERROR;
  }

  return HAL_OK;
}
3400493c:	bd70      	pop	{r4, r5, r6, pc}
  if (FuseId < BSEC_NB_FUSES)
3400493e:	f5b5 7fbc 	cmp.w	r5, #376	@ 0x178
34004942:	d2f8      	bcs.n	34004936 <HAL_BSEC_OTP_Reload+0x16>
    status_reg = FuseId / 32U;
34004944:	096b      	lsrs	r3, r5, #5
    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
34004946:	f503 7308 	add.w	r3, r3, #544	@ 0x220
3400494a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
3400494e:	2301      	movs	r3, #1
34004950:	f005 001f 	and.w	r0, r5, #31
34004954:	4083      	lsls	r3, r0
    if ((hbsec->Instance->SRLOCKx[status_reg] & status_bit) == 0U)
34004956:	420b      	tst	r3, r1
34004958:	d11f      	bne.n	3400499a <HAL_BSEC_OTP_Reload+0x7a>
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR), FuseId);
3400495a:	f8d2 3c04 	ldr.w	r3, [r2, #3076]	@ 0xc04
3400495e:	f423 43c3 	bic.w	r3, r3, #24960	@ 0x6180
34004962:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34004966:	432b      	orrs	r3, r5
34004968:	f8c2 3c04 	str.w	r3, [r2, #3076]	@ 0xc04
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
3400496c:	6823      	ldr	r3, [r4, #0]
3400496e:	f8d3 2e44 	ldr.w	r2, [r3, #3652]	@ 0xe44
34004972:	07d2      	lsls	r2, r2, #31
34004974:	d409      	bmi.n	3400498a <HAL_BSEC_OTP_Reload+0x6a>
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS) != 0U)
34004976:	f8d3 0e44 	ldr.w	r0, [r3, #3652]	@ 0xe44
3400497a:	f410 008c 	ands.w	r0, r0, #4587520	@ 0x460000
3400497e:	d0dd      	beq.n	3400493c <HAL_BSEC_OTP_Reload+0x1c>
        hbsec->ErrorCode = (hbsec->Instance->OTPSR & BSEC_OTPSR_RELOAD_ERRORS);
34004980:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004984:	f403 038c 	and.w	r3, r3, #4587520	@ 0x460000
34004988:	e7d6      	b.n	34004938 <HAL_BSEC_OTP_Reload+0x18>
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
3400498a:	f7ff ffb1 	bl	340048f0 <HAL_GetTick>
3400498e:	1b80      	subs	r0, r0, r6
34004990:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34004994:	d9ea      	bls.n	3400496c <HAL_BSEC_OTP_Reload+0x4c>
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
34004996:	230a      	movs	r3, #10
34004998:	e7ce      	b.n	34004938 <HAL_BSEC_OTP_Reload+0x18>
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
3400499a:	2304      	movs	r3, #4
3400499c:	e7cc      	b.n	34004938 <HAL_BSEC_OTP_Reload+0x18>
3400499e:	bf00      	nop
340049a0:	56009000 	.word	0x56009000

340049a4 <HAL_BSEC_OTP_Read>:
{
340049a4:	b570      	push	{r4, r5, r6, lr}
340049a6:	460e      	mov	r6, r1
340049a8:	4615      	mov	r5, r2
  if (hbsec == NULL)
340049aa:	4604      	mov	r4, r0
340049ac:	b130      	cbz	r0, 340049bc <HAL_BSEC_OTP_Read+0x18>
 if ((pFuseData == NULL) || (hbsec->Instance != BSEC))
340049ae:	b11a      	cbz	r2, 340049b8 <HAL_BSEC_OTP_Read+0x14>
340049b0:	6802      	ldr	r2, [r0, #0]
340049b2:	4b09      	ldr	r3, [pc, #36]	@ (340049d8 <HAL_BSEC_OTP_Read+0x34>)
340049b4:	429a      	cmp	r2, r3
340049b6:	d003      	beq.n	340049c0 <HAL_BSEC_OTP_Read+0x1c>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340049b8:	2301      	movs	r3, #1
340049ba:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
340049bc:	2001      	movs	r0, #1
}
340049be:	bd70      	pop	{r4, r5, r6, pc}
  if (FuseId < BSEC_NB_FUSES)
340049c0:	f5b1 7fbc 	cmp.w	r1, #376	@ 0x178
340049c4:	d2f8      	bcs.n	340049b8 <HAL_BSEC_OTP_Read+0x14>
    if (HAL_BSEC_OTP_Reload(hbsec, FuseId) == HAL_OK)
340049c6:	f7ff ffab 	bl	34004920 <HAL_BSEC_OTP_Reload>
340049ca:	2800      	cmp	r0, #0
340049cc:	d1f6      	bne.n	340049bc <HAL_BSEC_OTP_Read+0x18>
      *pFuseData = hbsec->Instance->FVRw[FuseId];
340049ce:	6823      	ldr	r3, [r4, #0]
340049d0:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
340049d4:	602b      	str	r3, [r5, #0]
  return HAL_OK;
340049d6:	e7f2      	b.n	340049be <HAL_BSEC_OTP_Read+0x1a>
340049d8:	56009000 	.word	0x56009000

340049dc <HAL_BSEC_OTP_Program>:
{
340049dc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
340049e0:	4604      	mov	r4, r0
340049e2:	460e      	mov	r6, r1
340049e4:	4617      	mov	r7, r2
340049e6:	4699      	mov	r9, r3
  uint32_t tick_start = HAL_GetTick();
340049e8:	f7ff ff82 	bl	340048f0 <HAL_GetTick>
340049ec:	4680      	mov	r8, r0
  if (hbsec == NULL)
340049ee:	b12c      	cbz	r4, 340049fc <HAL_BSEC_OTP_Program+0x20>
 if (hbsec->Instance != BSEC)
340049f0:	6822      	ldr	r2, [r4, #0]
340049f2:	4b28      	ldr	r3, [pc, #160]	@ (34004a94 <HAL_BSEC_OTP_Program+0xb8>)
340049f4:	429a      	cmp	r2, r3
340049f6:	d005      	beq.n	34004a04 <HAL_BSEC_OTP_Program+0x28>
    hbsec->ErrorCode = HAL_BSEC_ERROR_INVALID_PARAM;
340049f8:	2301      	movs	r3, #1
340049fa:	6063      	str	r3, [r4, #4]
    return HAL_ERROR;
340049fc:	2001      	movs	r0, #1
}
340049fe:	b003      	add	sp, #12
34004a00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_BSEC_PERMANENT_LOCK(Lock));
34004a04:	f439 4380 	bics.w	r3, r9, #16384	@ 0x4000
34004a08:	d004      	beq.n	34004a14 <HAL_BSEC_OTP_Program+0x38>
34004a0a:	f44f 71dd 	mov.w	r1, #442	@ 0x1ba
34004a0e:	4822      	ldr	r0, [pc, #136]	@ (34004a98 <HAL_BSEC_OTP_Program+0xbc>)
34004a10:	f7fd fd94 	bl	3400253c <assert_failed>
  if (FuseId < BSEC_NB_FUSES)
34004a14:	f5b6 7fbc 	cmp.w	r6, #376	@ 0x178
34004a18:	d2ee      	bcs.n	340049f8 <HAL_BSEC_OTP_Program+0x1c>
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004a1a:	6822      	ldr	r2, [r4, #0]
    status_reg = FuseId / 32U;
34004a1c:	0973      	lsrs	r3, r6, #5
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004a1e:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34004a22:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    status_bit = (uint32_t)(1UL << (FuseId % 32U));
34004a26:	2301      	movs	r3, #1
34004a28:	f006 001f 	and.w	r0, r6, #31
34004a2c:	4083      	lsls	r3, r0
    if ((hbsec->Instance->SPLOCKx[status_reg] & status_bit) == 0U)
34004a2e:	420b      	tst	r3, r1
34004a30:	d12e      	bne.n	34004a90 <HAL_BSEC_OTP_Program+0xb4>
      hbsec->Instance->WDR = FuseData;
34004a32:	f8c2 7c08 	str.w	r7, [r2, #3080]	@ 0xc08
      MODIFY_REG(hbsec->Instance->OTPCR, (BSEC_OTPCR_PPLOCK | BSEC_OTPCR_PROG | BSEC_OTPCR_ADDR),
34004a36:	f8d2 5c04 	ldr.w	r5, [r2, #3076]	@ 0xc04
34004a3a:	f425 45c3 	bic.w	r5, r5, #24960	@ 0x6180
34004a3e:	f025 057f 	bic.w	r5, r5, #127	@ 0x7f
34004a42:	4335      	orrs	r5, r6
34004a44:	ea45 0509 	orr.w	r5, r5, r9
34004a48:	f445 5500 	orr.w	r5, r5, #8192	@ 0x2000
34004a4c:	f8c2 5c04 	str.w	r5, [r2, #3076]	@ 0xc04
      while ((hbsec->Instance->OTPSR & BSEC_OTPSR_BUSY) != 0U)
34004a50:	6823      	ldr	r3, [r4, #0]
34004a52:	f8d3 2e44 	ldr.w	r2, [r3, #3652]	@ 0xe44
34004a56:	07d2      	lsls	r2, r2, #31
34004a58:	d406      	bmi.n	34004a68 <HAL_BSEC_OTP_Program+0x8c>
      if ((hbsec->Instance->OTPSR & BSEC_OTPSR_PROGFAIL) != 0U)
34004a5a:	f8d3 3e44 	ldr.w	r3, [r3, #3652]	@ 0xe44
34004a5e:	03db      	lsls	r3, r3, #15
34004a60:	d50b      	bpl.n	34004a7a <HAL_BSEC_OTP_Program+0x9e>
        hbsec->ErrorCode = HAL_BSEC_ERROR_PROGFAIL;
34004a62:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
34004a66:	e7c8      	b.n	340049fa <HAL_BSEC_OTP_Program+0x1e>
        if ((HAL_GetTick() - tick_start) > BSEC_TIMEOUT)
34004a68:	f7ff ff42 	bl	340048f0 <HAL_GetTick>
34004a6c:	eba0 0008 	sub.w	r0, r0, r8
34004a70:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34004a74:	d9ec      	bls.n	34004a50 <HAL_BSEC_OTP_Program+0x74>
          hbsec->ErrorCode = HAL_BSEC_ERROR_TIMEOUT;
34004a76:	230a      	movs	r3, #10
34004a78:	e7bf      	b.n	340049fa <HAL_BSEC_OTP_Program+0x1e>
      if (HAL_BSEC_OTP_Read(hbsec, FuseId, &read_data) == HAL_OK)
34004a7a:	4631      	mov	r1, r6
34004a7c:	4620      	mov	r0, r4
34004a7e:	aa01      	add	r2, sp, #4
34004a80:	f7ff ff90 	bl	340049a4 <HAL_BSEC_OTP_Read>
34004a84:	2800      	cmp	r0, #0
34004a86:	d1b9      	bne.n	340049fc <HAL_BSEC_OTP_Program+0x20>
        if (read_data != FuseData)
34004a88:	9b01      	ldr	r3, [sp, #4]
34004a8a:	42bb      	cmp	r3, r7
34004a8c:	d1e9      	bne.n	34004a62 <HAL_BSEC_OTP_Program+0x86>
34004a8e:	e7b6      	b.n	340049fe <HAL_BSEC_OTP_Program+0x22>
      hbsec->ErrorCode = HAL_BSEC_ERROR_LOCK;
34004a90:	2304      	movs	r3, #4
34004a92:	e7b2      	b.n	340049fa <HAL_BSEC_OTP_Program+0x1e>
34004a94:	56009000 	.word	0x56009000
34004a98:	3401c293 	.word	0x3401c293

34004a9c <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34004a9c:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
34004a9e:	4604      	mov	r4, r0
34004aa0:	b350      	cbz	r0, 34004af8 <HAL_CACHEAXI_Enable+0x5c>
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
34004aa2:	6803      	ldr	r3, [r0, #0]
34004aa4:	4a15      	ldr	r2, [pc, #84]	@ (34004afc <HAL_CACHEAXI_Enable+0x60>)
34004aa6:	4293      	cmp	r3, r2
34004aa8:	d008      	beq.n	34004abc <HAL_CACHEAXI_Enable+0x20>
34004aaa:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004aae:	4293      	cmp	r3, r2
34004ab0:	d004      	beq.n	34004abc <HAL_CACHEAXI_Enable+0x20>
34004ab2:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
34004ab6:	4812      	ldr	r0, [pc, #72]	@ (34004b00 <HAL_CACHEAXI_Enable+0x64>)
34004ab8:	f7fd fd40 	bl	3400253c <assert_failed>

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34004abc:	6823      	ldr	r3, [r4, #0]
34004abe:	685b      	ldr	r3, [r3, #4]
34004ac0:	07d9      	lsls	r1, r3, #31
34004ac2:	d407      	bmi.n	34004ad4 <HAL_CACHEAXI_Enable+0x38>
  }

  if (status == HAL_OK)
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34004ac4:	2000      	movs	r0, #0
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34004ac6:	6822      	ldr	r2, [r4, #0]
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34004ac8:	60a0      	str	r0, [r4, #8]
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34004aca:	6813      	ldr	r3, [r2, #0]
34004acc:	f043 0301 	orr.w	r3, r3, #1
34004ad0:	6013      	str	r3, [r2, #0]
  }

  return status;
}
34004ad2:	bd38      	pop	{r3, r4, r5, pc}
    tickstart = HAL_GetTick();
34004ad4:	f7ff ff0c 	bl	340048f0 <HAL_GetTick>
34004ad8:	4605      	mov	r5, r0
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34004ada:	6823      	ldr	r3, [r4, #0]
34004adc:	685b      	ldr	r3, [r3, #4]
34004ade:	07db      	lsls	r3, r3, #31
34004ae0:	d5f0      	bpl.n	34004ac4 <HAL_CACHEAXI_Enable+0x28>
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
34004ae2:	f7ff ff05 	bl	340048f0 <HAL_GetTick>
34004ae6:	1b40      	subs	r0, r0, r5
34004ae8:	2801      	cmp	r0, #1
34004aea:	d9f6      	bls.n	34004ada <HAL_CACHEAXI_Enable+0x3e>
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
34004aec:	6823      	ldr	r3, [r4, #0]
34004aee:	685b      	ldr	r3, [r3, #4]
34004af0:	07da      	lsls	r2, r3, #31
34004af2:	d4f2      	bmi.n	34004ada <HAL_CACHEAXI_Enable+0x3e>
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
34004af4:	2310      	movs	r3, #16
34004af6:	60a3      	str	r3, [r4, #8]
    return HAL_ERROR;
34004af8:	2001      	movs	r0, #1
34004afa:	e7ea      	b.n	34004ad2 <HAL_CACHEAXI_Enable+0x36>
34004afc:	580dfc00 	.word	0x580dfc00
34004b00:	3401c302 	.word	0x3401c302

34004b04 <HAL_CACHEAXI_Init>:
{
34004b04:	b510      	push	{r4, lr}
  if (hcacheaxi == NULL)
34004b06:	4604      	mov	r4, r0
34004b08:	b1c8      	cbz	r0, 34004b3e <HAL_CACHEAXI_Init+0x3a>
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
34004b0a:	6803      	ldr	r3, [r0, #0]
34004b0c:	4a0d      	ldr	r2, [pc, #52]	@ (34004b44 <HAL_CACHEAXI_Init+0x40>)
34004b0e:	4293      	cmp	r3, r2
34004b10:	d007      	beq.n	34004b22 <HAL_CACHEAXI_Init+0x1e>
34004b12:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004b16:	4293      	cmp	r3, r2
34004b18:	d003      	beq.n	34004b22 <HAL_CACHEAXI_Init+0x1e>
34004b1a:	21bc      	movs	r1, #188	@ 0xbc
34004b1c:	480a      	ldr	r0, [pc, #40]	@ (34004b48 <HAL_CACHEAXI_Init+0x44>)
34004b1e:	f7fd fd0d 	bl	3400253c <assert_failed>
  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34004b22:	7923      	ldrb	r3, [r4, #4]
34004b24:	b913      	cbnz	r3, 34004b2c <HAL_CACHEAXI_Init+0x28>
    HAL_CACHEAXI_MspInit(hcacheaxi);
34004b26:	4620      	mov	r0, r4
34004b28:	f7fd fcee 	bl	34002508 <HAL_CACHEAXI_MspInit>
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34004b2c:	2300      	movs	r3, #0
34004b2e:	60a3      	str	r3, [r4, #8]
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34004b30:	2301      	movs	r3, #1
34004b32:	7123      	strb	r3, [r4, #4]
  status = HAL_CACHEAXI_Enable(hcacheaxi);
34004b34:	4620      	mov	r0, r4
}
34004b36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  status = HAL_CACHEAXI_Enable(hcacheaxi);
34004b3a:	f7ff bfaf 	b.w	34004a9c <HAL_CACHEAXI_Enable>
}
34004b3e:	2001      	movs	r0, #1
34004b40:	bd10      	pop	{r4, pc}
34004b42:	bf00      	nop
34004b44:	580dfc00 	.word	0x580dfc00
34004b48:	3401c302 	.word	0x3401c302

34004b4c <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
34004b4c:	1ec3      	subs	r3, r0, #3
34004b4e:	2b04      	cmp	r3, #4
{
34004b50:	b510      	push	{r4, lr}
34004b52:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
34004b54:	d903      	bls.n	34004b5e <HAL_NVIC_SetPriorityGrouping+0x12>
34004b56:	21e6      	movs	r1, #230	@ 0xe6
34004b58:	4809      	ldr	r0, [pc, #36]	@ (34004b80 <HAL_NVIC_SetPriorityGrouping+0x34>)
34004b5a:	f7fd fcef 	bl	3400253c <assert_failed>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34004b5e:	4909      	ldr	r1, [pc, #36]	@ (34004b84 <HAL_NVIC_SetPriorityGrouping+0x38>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34004b60:	0223      	lsls	r3, r4, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34004b62:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34004b64:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34004b68:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
34004b6c:	0412      	lsls	r2, r2, #16
34004b6e:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34004b70:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34004b72:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34004b76:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
34004b7a:	60cb      	str	r3, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
34004b7c:	bd10      	pop	{r4, pc}
34004b7e:	bf00      	nop
34004b80:	3401c375 	.word	0x3401c375
34004b84:	e000ed00 	.word	0xe000ed00

34004b88 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34004b88:	f110 0f0c 	cmn.w	r0, #12
{
34004b8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34004b90:	4605      	mov	r5, r0
34004b92:	460c      	mov	r4, r1
34004b94:	4617      	mov	r7, r2
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));
34004b96:	db01      	blt.n	34004b9c <HAL_NVIC_SetPriority+0x14>
34004b98:	1d03      	adds	r3, r0, #4
34004b9a:	d103      	bne.n	34004ba4 <HAL_NVIC_SetPriority+0x1c>
34004b9c:	21ff      	movs	r1, #255	@ 0xff
34004b9e:	4826      	ldr	r0, [pc, #152]	@ (34004c38 <HAL_NVIC_SetPriority+0xb0>)
34004ba0:	f7fd fccc 	bl	3400253c <assert_failed>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34004ba4:	4b25      	ldr	r3, [pc, #148]	@ (34004c3c <HAL_NVIC_SetPriority+0xb4>)
34004ba6:	68de      	ldr	r6, [r3, #12]
34004ba8:	f3c6 2602 	ubfx	r6, r6, #8, #3

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
34004bac:	2e02      	cmp	r6, #2
34004bae:	d806      	bhi.n	34004bbe <HAL_NVIC_SetPriority+0x36>
34004bb0:	b157      	cbz	r7, 34004bc8 <HAL_NVIC_SetPriority+0x40>
34004bb2:	f44f 7181 	mov.w	r1, #258	@ 0x102
34004bb6:	4820      	ldr	r0, [pc, #128]	@ (34004c38 <HAL_NVIC_SetPriority+0xb0>)
34004bb8:	f7fd fcc0 	bl	3400253c <assert_failed>
34004bbc:	e004      	b.n	34004bc8 <HAL_NVIC_SetPriority+0x40>
34004bbe:	2301      	movs	r3, #1
34004bc0:	1ef2      	subs	r2, r6, #3
34004bc2:	4093      	lsls	r3, r2
34004bc4:	42bb      	cmp	r3, r7
34004bc6:	d9f4      	bls.n	34004bb2 <HAL_NVIC_SetPriority+0x2a>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));
34004bc8:	2c0f      	cmp	r4, #15
34004bca:	f1c6 0807 	rsb	r8, r6, #7
34004bce:	d804      	bhi.n	34004bda <HAL_NVIC_SetPriority+0x52>
34004bd0:	2301      	movs	r3, #1
34004bd2:	fa03 f308 	lsl.w	r3, r3, r8
34004bd6:	42a3      	cmp	r3, r4
34004bd8:	d804      	bhi.n	34004be4 <HAL_NVIC_SetPriority+0x5c>
34004bda:	f240 1103 	movw	r1, #259	@ 0x103
34004bde:	4816      	ldr	r0, [pc, #88]	@ (34004c38 <HAL_NVIC_SetPriority+0xb0>)
34004be0:	f7fd fcac 	bl	3400253c <assert_failed>
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34004be4:	f1b8 0f04 	cmp.w	r8, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34004be8:	f106 0304 	add.w	r3, r6, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34004bec:	bf28      	it	cs
34004bee:	f04f 0804 	movcs.w	r8, #4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004bf2:	f04f 32ff 	mov.w	r2, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34004bf6:	2b06      	cmp	r3, #6
34004bf8:	f1a6 0603 	sub.w	r6, r6, #3
34004bfc:	bf98      	it	ls
34004bfe:	2600      	movls	r6, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004c00:	fa02 f808 	lsl.w	r8, r2, r8
34004c04:	ea24 0308 	bic.w	r3, r4, r8
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34004c08:	40b2      	lsls	r2, r6
34004c0a:	ea27 0702 	bic.w	r7, r7, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004c0e:	40b3      	lsls	r3, r6
  if ((int32_t)(IRQn) >= 0)
34004c10:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004c12:	ea43 0307 	orr.w	r3, r3, r7
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c16:	bfac      	ite	ge
34004c18:	f105 4560 	addge.w	r5, r5, #3758096384	@ 0xe0000000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c1c:	4a08      	ldrlt	r2, [pc, #32]	@ (34004c40 <HAL_NVIC_SetPriority+0xb8>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c1e:	ea4f 1303 	mov.w	r3, r3, lsl #4
34004c22:	b2db      	uxtb	r3, r3
34004c24:	bfab      	itete	ge
34004c26:	f505 4561 	addge.w	r5, r5, #57600	@ 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c2a:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c2e:	f885 3300 	strbge.w	r3, [r5, #768]	@ 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c32:	5553      	strblt	r3, [r2, r5]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
34004c34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34004c38:	3401c375 	.word	0x3401c375
34004c3c:	e000ed00 	.word	0xe000ed00
34004c40:	e000ed14 	.word	0xe000ed14

34004c44 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
34004c44:	2800      	cmp	r0, #0
34004c46:	db08      	blt.n	34004c5a <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34004c48:	2301      	movs	r3, #1
34004c4a:	0941      	lsrs	r1, r0, #5
34004c4c:	4a05      	ldr	r2, [pc, #20]	@ (34004c64 <HAL_NVIC_EnableIRQ+0x20>)
34004c4e:	f000 001f 	and.w	r0, r0, #31
34004c52:	4083      	lsls	r3, r0
34004c54:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
34004c58:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
34004c5a:	f240 1115 	movw	r1, #277	@ 0x115
34004c5e:	4802      	ldr	r0, [pc, #8]	@ (34004c68 <HAL_NVIC_EnableIRQ+0x24>)
34004c60:	f7fd bc6c 	b.w	3400253c <assert_failed>
34004c64:	e000e100 	.word	0xe000e100
34004c68:	3401c375 	.word	0x3401c375

34004c6c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34004c6c:	3801      	subs	r0, #1
34004c6e:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
34004c72:	d20b      	bcs.n	34004c8c <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34004c74:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c78:	21f0      	movs	r1, #240	@ 0xf0
34004c7a:	4a05      	ldr	r2, [pc, #20]	@ (34004c90 <HAL_SYSTICK_Config+0x24>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34004c7c:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004c7e:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34004c82:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34004c84:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34004c86:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34004c88:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34004c8a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
34004c8c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
34004c8e:	4770      	bx	lr
34004c90:	e000ed00 	.word	0xe000ed00

34004c94 <DCMIPP_CSI_SetVCConfig>:
  * @param  hdcmipp         Pointer to DCMIPP handle
  * @param  Pipe            Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  VirtualChannel  Specifies the virtual channel, can be a value from @ref DCMIPP_Virtual_Channel
  */
static HAL_StatusTypeDef DCMIPP_CSI_SetVCConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel)
{
34004c94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34004c96:	4614      	mov	r4, r2
  uint32_t tickstart;

  /* Set Virtual Channel ID for the selected Pipe */
  if (Pipe == DCMIPP_PIPE0)
  {
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34004c98:	6803      	ldr	r3, [r0, #0]
  if (Pipe == DCMIPP_PIPE0)
34004c9a:	bb71      	cbnz	r1, 34004cfa <DCMIPP_CSI_SetVCConfig+0x66>
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
34004c9c:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34004ca0:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34004ca4:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34004ca8:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
    }
  }

  /* Enable the selected virtual channel */
  switch (VirtualChannel)
34004cac:	4b23      	ldr	r3, [pc, #140]	@ (34004d3c <DCMIPP_CSI_SetVCConfig+0xa8>)
34004cae:	2c02      	cmp	r4, #2
    case DCMIPP_VIRTUAL_CHANNEL3:
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
      break;
    default:
      /* DCMIPP_VIRTUAL_CHANNEL0: */
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34004cb0:	681a      	ldr	r2, [r3, #0]
  switch (VirtualChannel)
34004cb2:	d038      	beq.n	34004d26 <DCMIPP_CSI_SetVCConfig+0x92>
34004cb4:	2c03      	cmp	r4, #3
34004cb6:	d039      	beq.n	34004d2c <DCMIPP_CSI_SetVCConfig+0x98>
34004cb8:	2c01      	cmp	r4, #1
34004cba:	d13a      	bne.n	34004d32 <DCMIPP_CSI_SetVCConfig+0x9e>
      SET_BIT(csi_instance->CR, CSI_CR_VC1START);
34004cbc:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34004cc0:	601a      	str	r2, [r3, #0]
      break;
  }

  /* wait for the selected virtual channel active state */
  tickstart = HAL_GetTick();
34004cc2:	f7ff fe15 	bl	340048f0 <HAL_GetTick>
  {
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
    {
      return HAL_ERROR;
    }
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34004cc6:	f44f 3600 	mov.w	r6, #131072	@ 0x20000
  tickstart = HAL_GetTick();
34004cca:	4607      	mov	r7, r0
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34004ccc:	4d1b      	ldr	r5, [pc, #108]	@ (34004d3c <DCMIPP_CSI_SetVCConfig+0xa8>)
34004cce:	40a6      	lsls	r6, r4
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
34004cd0:	f7ff fe0e 	bl	340048f0 <HAL_GetTick>
34004cd4:	1bc0      	subs	r0, r0, r7
34004cd6:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
34004cda:	d82d      	bhi.n	34004d38 <DCMIPP_CSI_SetVCConfig+0xa4>
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34004cdc:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
34004ce0:	ea36 0303 	bics.w	r3, r6, r3
34004ce4:	d1f4      	bne.n	34004cd0 <DCMIPP_CSI_SetVCConfig+0x3c>

  /* Enable the SOF and EOF interrupts for the selected virtual channel */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34004ce6:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
                             (DCMIPP_CSI_IT_SOF0 << VirtualChannel));
  return HAL_OK;
34004cea:	2000      	movs	r0, #0
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34004cec:	f8d5 2080 	ldr.w	r2, [r5, #128]	@ 0x80
34004cf0:	40a3      	lsls	r3, r4
34004cf2:	4313      	orrs	r3, r2
34004cf4:	f8c5 3080 	str.w	r3, [r5, #128]	@ 0x80
}
34004cf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Pipe == DCMIPP_PIPE1)
34004cfa:	2901      	cmp	r1, #1
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
34004cfc:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  else if (Pipe == DCMIPP_PIPE1)
34004d00:	d106      	bne.n	34004d10 <DCMIPP_CSI_SetVCConfig+0x7c>
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
34004d02:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
34004d06:	ea42 42c4 	orr.w	r2, r2, r4, lsl #19
34004d0a:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
34004d0e:	e7cd      	b.n	34004cac <DCMIPP_CSI_SetVCConfig+0x18>
    if ((hdcmipp->Instance->P1FSCR & DCMIPP_P1FSCR_PIPEDIFF) == DCMIPP_P1FSCR_PIPEDIFF)
34004d10:	0352      	lsls	r2, r2, #13
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
34004d12:	bf41      	itttt	mi
34004d14:	f8d3 2c04 	ldrmi.w	r2, [r3, #3076]	@ 0xc04
34004d18:	f422 12c0 	bicmi.w	r2, r2, #1572864	@ 0x180000
34004d1c:	ea42 42c4 	orrmi.w	r2, r2, r4, lsl #19
34004d20:	f8c3 2c04 	strmi.w	r2, [r3, #3076]	@ 0xc04
34004d24:	e7c2      	b.n	34004cac <DCMIPP_CSI_SetVCConfig+0x18>
      SET_BIT(csi_instance->CR, CSI_CR_VC2START);
34004d26:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
34004d2a:	e7c9      	b.n	34004cc0 <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
34004d2c:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004d30:	e7c6      	b.n	34004cc0 <DCMIPP_CSI_SetVCConfig+0x2c>
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34004d32:	f042 0204 	orr.w	r2, r2, #4
34004d36:	e7c3      	b.n	34004cc0 <DCMIPP_CSI_SetVCConfig+0x2c>
      return HAL_ERROR;
34004d38:	2001      	movs	r0, #1
34004d3a:	e7dd      	b.n	34004cf8 <DCMIPP_CSI_SetVCConfig+0x64>
34004d3c:	58006000 	.word	0x58006000

34004d40 <DCMIPP_SetConfig.part.0>:
  else if (Pipe == DCMIPP_PIPE1)
34004d40:	2901      	cmp	r1, #1
static void DCMIPP_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t DstAddress, uint32_t CaptureMode)
34004d42:	b530      	push	{r4, r5, lr}
34004d44:	f04f 0502 	mov.w	r5, #2
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
34004d48:	6804      	ldr	r4, [r0, #0]
  else if (Pipe == DCMIPP_PIPE1)
34004d4a:	d110      	bne.n	34004d6e <DCMIPP_SetConfig.part.0+0x2e>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004d4c:	7185      	strb	r5, [r0, #6]
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
34004d4e:	f8d4 1900 	ldr.w	r1, [r4, #2304]	@ 0x900
34004d52:	430b      	orrs	r3, r1
34004d54:	f8c4 3900 	str.w	r3, [r4, #2304]	@ 0x900
    WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
34004d58:	f8c4 29c4 	str.w	r2, [r4, #2500]	@ 0x9c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME  | DCMIPP_IT_PIPE1_OVR | DCMIPP_IT_PIPE1_VSYNC |
34004d5c:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
34004d60:	f443 0306 	orr.w	r3, r3, #8781824	@ 0x860000
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
34004d64:	f043 0320 	orr.w	r3, r3, #32
34004d68:	f8c4 33f0 	str.w	r3, [r4, #1008]	@ 0x3f0
}
34004d6c:	bd30      	pop	{r4, r5, pc}
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004d6e:	4408      	add	r0, r1
34004d70:	7145      	strb	r5, [r0, #5]
    hdcmipp->Instance->P2FCTCR |= CaptureMode;
34004d72:	f8d4 1d00 	ldr.w	r1, [r4, #3328]	@ 0xd00
34004d76:	430b      	orrs	r3, r1
34004d78:	f8c4 3d00 	str.w	r3, [r4, #3328]	@ 0xd00
    WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
34004d7c:	f8c4 2dc4 	str.w	r2, [r4, #3524]	@ 0xdc4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
34004d80:	f8d4 33f0 	ldr.w	r3, [r4, #1008]	@ 0x3f0
34004d84:	f043 4306 	orr.w	r3, r3, #2248146944	@ 0x86000000
34004d88:	e7ec      	b.n	34004d64 <DCMIPP_SetConfig.part.0+0x24>

34004d8a <DCMIPP_SetConfig>:
{
34004d8a:	b470      	push	{r4, r5, r6}
34004d8c:	4615      	mov	r5, r2
34004d8e:	461e      	mov	r6, r3
  if (Pipe == DCMIPP_PIPE0)
34004d90:	b999      	cbnz	r1, 34004dba <DCMIPP_SetConfig+0x30>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004d92:	2302      	movs	r3, #2
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34004d94:	6801      	ldr	r1, [r0, #0]
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004d96:	7143      	strb	r3, [r0, #5]
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
34004d98:	f8d1 2500 	ldr.w	r2, [r1, #1280]	@ 0x500
34004d9c:	4332      	orrs	r2, r6
34004d9e:	f8c1 2500 	str.w	r2, [r1, #1280]	@ 0x500
    WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
34004da2:	f8c1 55c4 	str.w	r5, [r1, #1476]	@ 0x5c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34004da6:	f8d1 33f0 	ldr.w	r3, [r1, #1008]	@ 0x3f0
}
34004daa:	bc70      	pop	{r4, r5, r6}
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
34004dac:	f443 4306 	orr.w	r3, r3, #34304	@ 0x8600
34004db0:	f043 0320 	orr.w	r3, r3, #32
34004db4:	f8c1 33f0 	str.w	r3, [r1, #1008]	@ 0x3f0
}
34004db8:	4770      	bx	lr
34004dba:	bc70      	pop	{r4, r5, r6}
34004dbc:	f7ff bfc0 	b.w	34004d40 <DCMIPP_SetConfig.part.0>

34004dc0 <DCMIPP_EnableCapture.part.0>:
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34004dc0:	2302      	movs	r3, #2
34004dc2:	7183      	strb	r3, [r0, #6]
    SET_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEN);
34004dc4:	6803      	ldr	r3, [r0, #0]
34004dc6:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34004dca:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34004dce:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
    SET_BIT(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_CPTREQ);
34004dd2:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34004dd6:	f042 0208 	orr.w	r2, r2, #8
34004dda:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
34004dde:	4770      	bx	lr

34004de0 <DCMIPP_EnableCapture>:
  if (Pipe == DCMIPP_PIPE0)
34004de0:	b969      	cbnz	r1, 34004dfe <DCMIPP_EnableCapture+0x1e>
    SET_BIT(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_PIPEN);
34004de2:	6803      	ldr	r3, [r0, #0]
34004de4:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34004de8:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34004dec:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
    SET_BIT(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
34004df0:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34004df4:	f042 0208 	orr.w	r2, r2, #8
34004df8:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
34004dfc:	4770      	bx	lr
  else if (Pipe == DCMIPP_PIPE1)
34004dfe:	2901      	cmp	r1, #1
34004e00:	d101      	bne.n	34004e06 <DCMIPP_EnableCapture+0x26>
34004e02:	f7ff bfdd 	b.w	34004dc0 <DCMIPP_EnableCapture.part.0>
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);
34004e06:	6803      	ldr	r3, [r0, #0]
34004e08:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
34004e0c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34004e10:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
34004e14:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34004e18:	f042 0208 	orr.w	r2, r2, #8
34004e1c:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
}
34004e20:	4770      	bx	lr
	...

34004e24 <DCMIPP_CSI_WritePHYReg.constprop.0>:
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004e24:	4b18      	ldr	r3, [pc, #96]	@ (34004e88 <DCMIPP_CSI_WritePHYReg.constprop.0+0x64>)
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
34004e26:	b510      	push	{r4, lr}
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004e28:	695a      	ldr	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
34004e2a:	b2c9      	uxtb	r1, r1
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004e2c:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
34004e30:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004e32:	691a      	ldr	r2, [r3, #16]
34004e34:	f042 0201 	orr.w	r2, r2, #1
34004e38:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004e3a:	695a      	ldr	r2, [r3, #20]
34004e3c:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
34004e40:	615a      	str	r2, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
34004e42:	2200      	movs	r2, #0
34004e44:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
34004e46:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
34004e48:	695c      	ldr	r4, [r3, #20]
34004e4a:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004e4c:	691c      	ldr	r4, [r3, #16]
34004e4e:	f044 0401 	orr.w	r4, r4, #1
34004e52:	611c      	str	r4, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
34004e54:	611a      	str	r2, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34004e56:	695c      	ldr	r4, [r3, #20]
34004e58:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
34004e5c:	615c      	str	r4, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004e5e:	691c      	ldr	r4, [r3, #16]
34004e60:	f044 0401 	orr.w	r4, r4, #1
34004e64:	611c      	str	r4, [r3, #16]
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
34004e66:	695c      	ldr	r4, [r3, #20]
34004e68:	4304      	orrs	r4, r0
34004e6a:	f444 3480 	orr.w	r4, r4, #65536	@ 0x10000
34004e6e:	615c      	str	r4, [r3, #20]
  CLEAR_REG(hcsi->PTCR0);
34004e70:	611a      	str	r2, [r3, #16]
  CLEAR_REG(hcsi->PTCR1);
34004e72:	615a      	str	r2, [r3, #20]
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
34004e74:	6958      	ldr	r0, [r3, #20]
34004e76:	4301      	orrs	r1, r0
34004e78:	6159      	str	r1, [r3, #20]
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34004e7a:	6919      	ldr	r1, [r3, #16]
34004e7c:	f041 0101 	orr.w	r1, r1, #1
34004e80:	6119      	str	r1, [r3, #16]
  CLEAR_REG(hcsi->PTCR0);
34004e82:	611a      	str	r2, [r3, #16]
}
34004e84:	bd10      	pop	{r4, pc}
34004e86:	bf00      	nop
34004e88:	58007000 	.word	0x58007000

34004e8c <HAL_DCMIPP_Init>:
{
34004e8c:	b510      	push	{r4, lr}
  if (hdcmipp == NULL)
34004e8e:	4604      	mov	r4, r0
34004e90:	b1d8      	cbz	r0, 34004eca <HAL_DCMIPP_Init+0x3e>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34004e92:	6803      	ldr	r3, [r0, #0]
34004e94:	4a0e      	ldr	r2, [pc, #56]	@ (34004ed0 <HAL_DCMIPP_Init+0x44>)
34004e96:	4293      	cmp	r3, r2
34004e98:	d008      	beq.n	34004eac <HAL_DCMIPP_Init+0x20>
34004e9a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004e9e:	4293      	cmp	r3, r2
34004ea0:	d004      	beq.n	34004eac <HAL_DCMIPP_Init+0x20>
34004ea2:	f44f 71a7 	mov.w	r1, #334	@ 0x14e
34004ea6:	480b      	ldr	r0, [pc, #44]	@ (34004ed4 <HAL_DCMIPP_Init+0x48>)
34004ea8:	f7fd fb48 	bl	3400253c <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
34004eac:	7923      	ldrb	r3, [r4, #4]
34004eae:	b913      	cbnz	r3, 34004eb6 <HAL_DCMIPP_Init+0x2a>
    HAL_DCMIPP_MspInit(hdcmipp);
34004eb0:	4620      	mov	r0, r4
34004eb2:	f00b ff17 	bl	34010ce4 <HAL_DCMIPP_MspInit>
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34004eb6:	2303      	movs	r3, #3
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34004eb8:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34004eba:	7123      	strb	r3, [r4, #4]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34004ebc:	2301      	movs	r3, #1
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34004ebe:	7160      	strb	r0, [r4, #5]
34004ec0:	71a0      	strb	r0, [r4, #6]
34004ec2:	71e0      	strb	r0, [r4, #7]
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
34004ec4:	60a0      	str	r0, [r4, #8]
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34004ec6:	7123      	strb	r3, [r4, #4]
}
34004ec8:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34004eca:	2001      	movs	r0, #1
34004ecc:	e7fc      	b.n	34004ec8 <HAL_DCMIPP_Init+0x3c>
34004ece:	bf00      	nop
34004ed0:	58002000 	.word	0x58002000
34004ed4:	3401c3e6 	.word	0x3401c3e6

34004ed8 <HAL_DCMIPP_CSI_SetConfig>:
{
34004ed8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34004edc:	4605      	mov	r5, r0
34004ede:	b0fe      	sub	sp, #504	@ 0x1f8
34004ee0:	460c      	mov	r4, r1
  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
34004ee2:	f44f 72fc 	mov.w	r2, #504	@ 0x1f8
34004ee6:	4668      	mov	r0, sp
34004ee8:	4954      	ldr	r1, [pc, #336]	@ (3400503c <HAL_DCMIPP_CSI_SetConfig+0x164>)
34004eea:	f014 f952 	bl	34019192 <memcpy>
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34004eee:	b91d      	cbnz	r5, 34004ef8 <HAL_DCMIPP_CSI_SetConfig+0x20>
    return HAL_ERROR;
34004ef0:	2001      	movs	r0, #1
}
34004ef2:	b07e      	add	sp, #504	@ 0x1f8
34004ef4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34004ef8:	2c00      	cmp	r4, #0
34004efa:	d0f9      	beq.n	34004ef0 <HAL_DCMIPP_CSI_SetConfig+0x18>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34004efc:	682b      	ldr	r3, [r5, #0]
34004efe:	4a50      	ldr	r2, [pc, #320]	@ (34005040 <HAL_DCMIPP_CSI_SetConfig+0x168>)
34004f00:	4293      	cmp	r3, r2
34004f02:	d008      	beq.n	34004f16 <HAL_DCMIPP_CSI_SetConfig+0x3e>
34004f04:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34004f08:	4293      	cmp	r3, r2
34004f0a:	d004      	beq.n	34004f16 <HAL_DCMIPP_CSI_SetConfig+0x3e>
34004f0c:	f240 218b 	movw	r1, #651	@ 0x28b
34004f10:	484c      	ldr	r0, [pc, #304]	@ (34005044 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004f12:	f7fd fb13 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
34004f16:	6823      	ldr	r3, [r4, #0]
34004f18:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34004f1c:	d007      	beq.n	34004f2e <HAL_DCMIPP_CSI_SetConfig+0x56>
34004f1e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34004f22:	d004      	beq.n	34004f2e <HAL_DCMIPP_CSI_SetConfig+0x56>
34004f24:	f44f 7123 	mov.w	r1, #652	@ 0x28c
34004f28:	4846      	ldr	r0, [pc, #280]	@ (34005044 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004f2a:	f7fd fb07 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
34004f2e:	6863      	ldr	r3, [r4, #4]
34004f30:	3b01      	subs	r3, #1
34004f32:	2b01      	cmp	r3, #1
34004f34:	d904      	bls.n	34004f40 <HAL_DCMIPP_CSI_SetConfig+0x68>
34004f36:	f240 218d 	movw	r1, #653	@ 0x28d
34004f3a:	4842      	ldr	r0, [pc, #264]	@ (34005044 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004f3c:	f7fd fafe 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));
34004f40:	68a3      	ldr	r3, [r4, #8]
34004f42:	2b3e      	cmp	r3, #62	@ 0x3e
34004f44:	d904      	bls.n	34004f50 <HAL_DCMIPP_CSI_SetConfig+0x78>
34004f46:	f240 218e 	movw	r1, #654	@ 0x28e
34004f4a:	483e      	ldr	r0, [pc, #248]	@ (34005044 <HAL_DCMIPP_CSI_SetConfig+0x16c>)
34004f4c:	f7fd faf6 	bl	3400253c <assert_failed>
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
34004f50:	4b3d      	ldr	r3, [pc, #244]	@ (34005048 <HAL_DCMIPP_CSI_SetConfig+0x170>)
34004f52:	681a      	ldr	r2, [r3, #0]
34004f54:	f022 0201 	bic.w	r2, r2, #1
34004f58:	601a      	str	r2, [r3, #0]
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34004f5a:	6861      	ldr	r1, [r4, #4]
34004f5c:	2901      	cmp	r1, #1
34004f5e:	d11a      	bne.n	34004f96 <HAL_DCMIPP_CSI_SetConfig+0xbe>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
34004f60:	6822      	ldr	r2, [r4, #0]
34004f62:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34004f66:	671a      	str	r2, [r3, #112]	@ 0x70
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
34004f68:	681a      	ldr	r2, [r3, #0]
34004f6a:	f042 0201 	orr.w	r2, r2, #1
34004f6e:	601a      	str	r2, [r3, #0]
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
34004f70:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34004f74:	f042 42b0 	orr.w	r2, r2, #1476395008	@ 0x58000000
34004f78:	f442 1204 	orr.w	r2, r2, #2162688	@ 0x210000
34004f7c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34004f80:	6822      	ldr	r2, [r4, #0]
34004f82:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34004f86:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34004f8a:	d154      	bne.n	34005036 <HAL_DCMIPP_CSI_SetConfig+0x15e>
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34004f8c:	2901      	cmp	r1, #1
34004f8e:	d108      	bne.n	34004fa2 <HAL_DCMIPP_CSI_SetConfig+0xca>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004f90:	f042 021f 	orr.w	r2, r2, #31
34004f94:	e007      	b.n	34004fa6 <HAL_DCMIPP_CSI_SetConfig+0xce>
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
34004f96:	2902      	cmp	r1, #2
34004f98:	d1aa      	bne.n	34004ef0 <HAL_DCMIPP_CSI_SetConfig+0x18>
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34004f9a:	6822      	ldr	r2, [r4, #0]
34004f9c:	f442 1290 	orr.w	r2, r2, #1179648	@ 0x120000
34004fa0:	e7e1      	b.n	34004f66 <HAL_DCMIPP_CSI_SetConfig+0x8e>
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004fa2:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
  CLEAR_REG(csi_instance-> PCR);
34004fa6:	2600      	movs	r6, #0
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34004fa8:	4d28      	ldr	r5, [pc, #160]	@ (3400504c <HAL_DCMIPP_CSI_SetConfig+0x174>)
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34004faa:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34004fae:	682b      	ldr	r3, [r5, #0]
34004fb0:	4f25      	ldr	r7, [pc, #148]	@ (34005048 <HAL_DCMIPP_CSI_SetConfig+0x170>)
34004fb2:	f023 0302 	bic.w	r3, r3, #2
34004fb6:	602b      	str	r3, [r5, #0]
  CLEAR_REG(csi_instance-> PCR);
34004fb8:	607e      	str	r6, [r7, #4]
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34004fba:	692b      	ldr	r3, [r5, #16]
  HAL_Delay(1);
34004fbc:	2001      	movs	r0, #1
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34004fbe:	f043 0301 	orr.w	r3, r3, #1
34004fc2:	612b      	str	r3, [r5, #16]
  HAL_Delay(1);
34004fc4:	f7ff fc9a 	bl	340048fc <HAL_Delay>
  CLEAR_REG(csi_instance->PTCR0);
34004fc8:	612e      	str	r6, [r5, #16]
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004fca:	f8d4 8008 	ldr.w	r8, [r4, #8]
34004fce:	68ab      	ldr	r3, [r5, #8]
34004fd0:	f85d 2038 	ldr.w	r2, [sp, r8, lsl #3]
34004fd4:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
34004fd8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34004fdc:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34004fe0:	60ab      	str	r3, [r5, #8]
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34004fe2:	2138      	movs	r1, #56	@ 0x38
34004fe4:	2008      	movs	r0, #8
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34004fe6:	0216      	lsls	r6, r2, #8
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34004fe8:	f7ff ff1c 	bl	34004e24 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
34004fec:	2111      	movs	r1, #17
34004fee:	20e4      	movs	r0, #228	@ 0xe4
34004ff0:	f7ff ff18 	bl	34004e24 <DCMIPP_CSI_WritePHYReg.constprop.0>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34004ff4:	eb0d 03c8 	add.w	r3, sp, r8, lsl #3
34004ff8:	f8d3 8004 	ldr.w	r8, [r3, #4]
34004ffc:	20e3      	movs	r0, #227	@ 0xe3
34004ffe:	ea4f 2118 	mov.w	r1, r8, lsr #8
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34005002:	f446 3680 	orr.w	r6, r6, #65536	@ 0x10000
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34005006:	f7ff ff0d 	bl	34004e24 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
3400500a:	f046 0628 	orr.w	r6, r6, #40	@ 0x28
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
3400500e:	20e3      	movs	r0, #227	@ 0xe3
34005010:	fa5f f188 	uxtb.w	r1, r8
34005014:	f7ff ff06 	bl	34004e24 <DCMIPP_CSI_WritePHYReg.constprop.0>
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34005018:	60ae      	str	r6, [r5, #8]
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
3400501a:	6823      	ldr	r3, [r4, #0]
  CLEAR_REG(csi_instance->PMCR);
3400501c:	2000      	movs	r0, #0
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
3400501e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34005022:	bf0c      	ite	eq
34005024:	2307      	moveq	r3, #7
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34005026:	230f      	movne	r3, #15
34005028:	607b      	str	r3, [r7, #4]
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
3400502a:	682b      	ldr	r3, [r5, #0]
3400502c:	f043 0302 	orr.w	r3, r3, #2
34005030:	602b      	str	r3, [r5, #0]
  CLEAR_REG(csi_instance->PMCR);
34005032:	6068      	str	r0, [r5, #4]
  return HAL_OK;
34005034:	e75d      	b.n	34004ef2 <HAL_DCMIPP_CSI_SetConfig+0x1a>
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34005036:	f442 52f8 	orr.w	r2, r2, #7936	@ 0x1f00
3400503a:	e7a9      	b.n	34004f90 <HAL_DCMIPP_CSI_SetConfig+0xb8>
3400503c:	3401bc20 	.word	0x3401bc20
34005040:	58002000 	.word	0x58002000
34005044:	3401c3e6 	.word	0x3401c3e6
34005048:	58006000 	.word	0x58006000
3400504c:	58007000 	.word	0x58007000

34005050 <HAL_DCMIPP_CSI_PIPE_SetConfig>:
{
34005050:	b570      	push	{r4, r5, r6, lr}
34005052:	460d      	mov	r5, r1
34005054:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34005056:	4606      	mov	r6, r0
34005058:	b908      	cbnz	r0, 3400505e <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe>
    return HAL_ERROR;
3400505a:	2001      	movs	r0, #1
}
3400505c:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
3400505e:	2a00      	cmp	r2, #0
34005060:	d0fb      	beq.n	3400505a <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34005062:	6803      	ldr	r3, [r0, #0]
34005064:	4a50      	ldr	r2, [pc, #320]	@ (340051a8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x158>)
34005066:	4293      	cmp	r3, r2
34005068:	d008      	beq.n	3400507c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2c>
3400506a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400506e:	4293      	cmp	r3, r2
34005070:	d004      	beq.n	3400507c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2c>
34005072:	f44f 7144 	mov.w	r1, #784	@ 0x310
34005076:	484d      	ldr	r0, [pc, #308]	@ (340051ac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005078:	f7fd fa60 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400507c:	2d02      	cmp	r5, #2
3400507e:	d904      	bls.n	3400508a <HAL_DCMIPP_CSI_PIPE_SetConfig+0x3a>
34005080:	f240 3111 	movw	r1, #785	@ 0x311
34005084:	4849      	ldr	r0, [pc, #292]	@ (340051ac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005086:	f7fd fa59 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
3400508a:	6823      	ldr	r3, [r4, #0]
3400508c:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34005090:	d004      	beq.n	3400509c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x4c>
34005092:	f240 3112 	movw	r1, #786	@ 0x312
34005096:	4845      	ldr	r0, [pc, #276]	@ (340051ac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
34005098:	f7fd fa50 	bl	3400253c <assert_failed>
  if (Pipe != DCMIPP_PIPE2)
3400509c:	2d02      	cmp	r5, #2
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
3400509e:	6823      	ldr	r3, [r4, #0]
  if (Pipe != DCMIPP_PIPE2)
340050a0:	d01c      	beq.n	340050dc <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));
340050a2:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
340050a6:	d004      	beq.n	340050b2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x62>
340050a8:	f240 3116 	movw	r1, #790	@ 0x316
340050ac:	483f      	ldr	r0, [pc, #252]	@ (340051ac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
340050ae:	f7fd fa45 	bl	3400253c <assert_failed>
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
340050b2:	6823      	ldr	r3, [r4, #0]
340050b4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340050b8:	d002      	beq.n	340050c0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x70>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
340050ba:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340050be:	d10d      	bne.n	340050dc <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
      assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDB));
340050c0:	68a3      	ldr	r3, [r4, #8]
340050c2:	3b18      	subs	r3, #24
340050c4:	2b15      	cmp	r3, #21
340050c6:	d804      	bhi.n	340050d2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
340050c8:	4a39      	ldr	r2, [pc, #228]	@ (340051b0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x160>)
340050ca:	fa22 f303 	lsr.w	r3, r2, r3
340050ce:	07da      	lsls	r2, r3, #31
340050d0:	d404      	bmi.n	340050dc <HAL_DCMIPP_CSI_PIPE_SetConfig+0x8c>
340050d2:	f240 311b 	movw	r1, #795	@ 0x31b
340050d6:	4835      	ldr	r0, [pc, #212]	@ (340051ac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
340050d8:	f7fd fa30 	bl	3400253c <assert_failed>
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
340050dc:	6823      	ldr	r3, [r4, #0]
340050de:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340050e2:	d00d      	beq.n	34005100 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xb0>
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
340050e4:	6863      	ldr	r3, [r4, #4]
340050e6:	3b18      	subs	r3, #24
340050e8:	2b15      	cmp	r3, #21
340050ea:	d804      	bhi.n	340050f6 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa6>
340050ec:	4a30      	ldr	r2, [pc, #192]	@ (340051b0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x160>)
340050ee:	fa22 f303 	lsr.w	r3, r2, r3
340050f2:	07db      	lsls	r3, r3, #31
340050f4:	d404      	bmi.n	34005100 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xb0>
340050f6:	f240 3121 	movw	r1, #801	@ 0x321
340050fa:	482c      	ldr	r0, [pc, #176]	@ (340051ac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x15c>)
340050fc:	f7fd fa1e 	bl	3400253c <assert_failed>
  state = hdcmipp->State;
34005100:	7933      	ldrb	r3, [r6, #4]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
34005102:	3b01      	subs	r3, #1
34005104:	2b01      	cmp	r3, #1
34005106:	d82e      	bhi.n	34005166 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x116>
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34005108:	6822      	ldr	r2, [r4, #0]
3400510a:	f5b2 3f40 	cmp.w	r2, #196608	@ 0x30000
3400510e:	d045      	beq.n	3400519c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x14c>
34005110:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
34005114:	d12b      	bne.n	3400516e <HAL_DCMIPP_CSI_PIPE_SetConfig+0x11e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34005116:	2d00      	cmp	r5, #0
34005118:	d19f      	bne.n	3400505a <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
3400511a:	4613      	mov	r3, r2
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
3400511c:	6861      	ldr	r1, [r4, #4]
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
3400511e:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34005122:	ea43 0301 	orr.w	r3, r3, r1
    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34005126:	6831      	ldr	r1, [r6, #0]
34005128:	d002      	beq.n	34005130 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe0>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
3400512a:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
3400512e:	d104      	bne.n	3400513a <HAL_DCMIPP_CSI_PIPE_SetConfig+0xea>
      if (Pipe != DCMIPP_PIPE2)
34005130:	2d02      	cmp	r5, #2
34005132:	d02b      	beq.n	3400518c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
34005134:	68a2      	ldr	r2, [r4, #8]
34005136:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    if (Pipe == DCMIPP_PIPE0)
3400513a:	b9ed      	cbnz	r5, 34005178 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
3400513c:	6831      	ldr	r1, [r6, #0]
3400513e:	4a1d      	ldr	r2, [pc, #116]	@ (340051b4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x164>)
34005140:	f8d1 0404 	ldr.w	r0, [r1, #1028]	@ 0x404
34005144:	4002      	ands	r2, r0
34005146:	431a      	orrs	r2, r3
34005148:	f8c1 2404 	str.w	r2, [r1, #1028]	@ 0x404
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
3400514c:	6833      	ldr	r3, [r6, #0]
3400514e:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34005152:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34005156:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
3400515a:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
3400515e:	f042 0201 	orr.w	r2, r2, #1
34005162:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34005166:	2302      	movs	r3, #2
  return HAL_OK;
34005168:	2000      	movs	r0, #0
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
3400516a:	7133      	strb	r3, [r6, #4]
  return HAL_OK;
3400516c:	e776      	b.n	3400505c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc>
  uint32_t pxfscr_reg = 0;
3400516e:	2d02      	cmp	r5, #2
34005170:	bf14      	ite	ne
34005172:	4613      	movne	r3, r2
34005174:	2300      	moveq	r3, #0
34005176:	e7d1      	b.n	3400511c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xcc>
    else if (Pipe == DCMIPP_PIPE1)
34005178:	2d01      	cmp	r5, #1
3400517a:	d107      	bne.n	3400518c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
3400517c:	f8d1 0804 	ldr.w	r0, [r1, #2052]	@ 0x804
34005180:	4a0c      	ldr	r2, [pc, #48]	@ (340051b4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x164>)
34005182:	4002      	ands	r2, r0
34005184:	431a      	orrs	r2, r3
34005186:	f8c1 2804 	str.w	r2, [r1, #2052]	@ 0x804
3400518a:	e7df      	b.n	3400514c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xfc>
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
3400518c:	f8d1 2c04 	ldr.w	r2, [r1, #3076]	@ 0xc04
34005190:	f022 023f 	bic.w	r2, r2, #63	@ 0x3f
34005194:	4313      	orrs	r3, r2
34005196:	f8c1 3c04 	str.w	r3, [r1, #3076]	@ 0xc04
3400519a:	e7d7      	b.n	3400514c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xfc>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
3400519c:	2d00      	cmp	r5, #0
3400519e:	f47f af5c 	bne.w	3400505a <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa>
340051a2:	4613      	mov	r3, r2
340051a4:	e7ca      	b.n	3400513c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xec>
340051a6:	bf00      	nop
340051a8:	58002000 	.word	0x58002000
340051ac:	3401c3e6 	.word	0x3401c3e6
340051b0:	003c1fc3 	.word	0x003c1fc3
340051b4:	fffcc0c0 	.word	0xfffcc0c0

340051b8 <HAL_DCMIPP_CSI_SetVCConfig>:
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
340051b8:	2903      	cmp	r1, #3
{
340051ba:	b570      	push	{r4, r5, r6, lr}
340051bc:	4606      	mov	r6, r0
340051be:	460d      	mov	r5, r1
340051c0:	4614      	mov	r4, r2
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
340051c2:	d904      	bls.n	340051ce <HAL_DCMIPP_CSI_SetVCConfig+0x16>
340051c4:	f44f 7172 	mov.w	r1, #968	@ 0x3c8
340051c8:	4815      	ldr	r0, [pc, #84]	@ (34005220 <HAL_DCMIPP_CSI_SetVCConfig+0x68>)
340051ca:	f7fd f9b7 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));
340051ce:	2c06      	cmp	r4, #6
340051d0:	d904      	bls.n	340051dc <HAL_DCMIPP_CSI_SetVCConfig+0x24>
340051d2:	f240 31c9 	movw	r1, #969	@ 0x3c9
340051d6:	4812      	ldr	r0, [pc, #72]	@ (34005220 <HAL_DCMIPP_CSI_SetVCConfig+0x68>)
340051d8:	f7fd f9b0 	bl	3400253c <assert_failed>
  if (hdcmipp == NULL)
340051dc:	b1f6      	cbz	r6, 3400521c <HAL_DCMIPP_CSI_SetVCConfig+0x64>
  switch (VirtualChannel)
340051de:	2d03      	cmp	r5, #3
340051e0:	d808      	bhi.n	340051f4 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
340051e2:	e8df f005 	tbb	[pc, r5]
340051e6:	0902      	.short	0x0902
340051e8:	150f      	.short	0x150f
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
340051ea:	4b0e      	ldr	r3, [pc, #56]	@ (34005224 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
340051ec:	0224      	lsls	r4, r4, #8
340051ee:	f044 0401 	orr.w	r4, r4, #1
340051f2:	611c      	str	r4, [r3, #16]
  return HAL_OK;
340051f4:	2000      	movs	r0, #0
}
340051f6:	bd70      	pop	{r4, r5, r6, pc}
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
340051f8:	4b0a      	ldr	r3, [pc, #40]	@ (34005224 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
340051fa:	0224      	lsls	r4, r4, #8
340051fc:	f044 0401 	orr.w	r4, r4, #1
34005200:	621c      	str	r4, [r3, #32]
      break;
34005202:	e7f7      	b.n	340051f4 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
34005204:	4b07      	ldr	r3, [pc, #28]	@ (34005224 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005206:	0224      	lsls	r4, r4, #8
34005208:	f044 0401 	orr.w	r4, r4, #1
3400520c:	631c      	str	r4, [r3, #48]	@ 0x30
      break;
3400520e:	e7f1      	b.n	340051f4 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
34005210:	4b04      	ldr	r3, [pc, #16]	@ (34005224 <HAL_DCMIPP_CSI_SetVCConfig+0x6c>)
34005212:	0224      	lsls	r4, r4, #8
34005214:	f044 0401 	orr.w	r4, r4, #1
34005218:	641c      	str	r4, [r3, #64]	@ 0x40
      break;
3400521a:	e7eb      	b.n	340051f4 <HAL_DCMIPP_CSI_SetVCConfig+0x3c>
    return HAL_ERROR;
3400521c:	2001      	movs	r0, #1
3400521e:	e7ea      	b.n	340051f6 <HAL_DCMIPP_CSI_SetVCConfig+0x3e>
34005220:	3401c3e6 	.word	0x3401c3e6
34005224:	58006000 	.word	0x58006000

34005228 <HAL_DCMIPP_PIPE_SetConfig>:
{
34005228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400522a:	460d      	mov	r5, r1
3400522c:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
3400522e:	4606      	mov	r6, r0
34005230:	b908      	cbnz	r0, 34005236 <HAL_DCMIPP_PIPE_SetConfig+0xe>
    return HAL_ERROR;
34005232:	2001      	movs	r0, #1
}
34005234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
34005236:	2a00      	cmp	r2, #0
34005238:	d0fb      	beq.n	34005232 <HAL_DCMIPP_PIPE_SetConfig+0xa>
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
3400523a:	6803      	ldr	r3, [r0, #0]
3400523c:	4a46      	ldr	r2, [pc, #280]	@ (34005358 <HAL_DCMIPP_PIPE_SetConfig+0x130>)
3400523e:	4293      	cmp	r3, r2
34005240:	d008      	beq.n	34005254 <HAL_DCMIPP_PIPE_SetConfig+0x2c>
34005242:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34005246:	4293      	cmp	r3, r2
34005248:	d004      	beq.n	34005254 <HAL_DCMIPP_PIPE_SetConfig+0x2c>
3400524a:	f240 4102 	movw	r1, #1026	@ 0x402
3400524e:	4843      	ldr	r0, [pc, #268]	@ (3400535c <HAL_DCMIPP_PIPE_SetConfig+0x134>)
34005250:	f7fd f974 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005254:	2d02      	cmp	r5, #2
34005256:	d904      	bls.n	34005262 <HAL_DCMIPP_PIPE_SetConfig+0x3a>
34005258:	f240 4103 	movw	r1, #1027	@ 0x403
3400525c:	483f      	ldr	r0, [pc, #252]	@ (3400535c <HAL_DCMIPP_PIPE_SetConfig+0x134>)
3400525e:	f7fd f96d 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_FRAME_RATE(pPipeConfig->FrameRate));
34005262:	6823      	ldr	r3, [r4, #0]
34005264:	2b03      	cmp	r3, #3
34005266:	d904      	bls.n	34005272 <HAL_DCMIPP_PIPE_SetConfig+0x4a>
34005268:	f240 4104 	movw	r1, #1028	@ 0x404
3400526c:	483b      	ldr	r0, [pc, #236]	@ (3400535c <HAL_DCMIPP_PIPE_SetConfig+0x134>)
3400526e:	f7fd f965 	bl	3400253c <assert_failed>
  if (Pipe != DCMIPP_PIPE0)
34005272:	b9bd      	cbnz	r5, 340052a4 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  pipe_state = hdcmipp->PipeState[Pipe];
34005274:	1971      	adds	r1, r6, r5
34005276:	7948      	ldrb	r0, [r1, #5]
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005278:	7933      	ldrb	r3, [r6, #4]
  pipe_state = hdcmipp->PipeState[Pipe];
3400527a:	b2c0      	uxtb	r0, r0
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400527c:	2b02      	cmp	r3, #2
3400527e:	b2da      	uxtb	r2, r3
34005280:	d1d7      	bne.n	34005232 <HAL_DCMIPP_PIPE_SetConfig+0xa>
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
34005282:	f010 00fb 	ands.w	r0, r0, #251	@ 0xfb
34005286:	d1d4      	bne.n	34005232 <HAL_DCMIPP_PIPE_SetConfig+0xa>
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34005288:	714a      	strb	r2, [r1, #5]
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
3400528a:	6833      	ldr	r3, [r6, #0]
3400528c:	6827      	ldr	r7, [r4, #0]
  if (Pipe == DCMIPP_PIPE0)
3400528e:	bb15      	cbnz	r5, 340052d6 <HAL_DCMIPP_PIPE_SetConfig+0xae>
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34005290:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34005294:	f022 0203 	bic.w	r2, r2, #3
34005298:	433a      	orrs	r2, r7
3400529a:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
3400529e:	2301      	movs	r3, #1
340052a0:	714b      	strb	r3, [r1, #5]
  return HAL_OK;
340052a2:	e7c7      	b.n	34005234 <HAL_DCMIPP_PIPE_SetConfig+0xc>
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
340052a4:	68a3      	ldr	r3, [r4, #8]
340052a6:	2b09      	cmp	r3, #9
340052a8:	d904      	bls.n	340052b4 <HAL_DCMIPP_PIPE_SetConfig+0x8c>
340052aa:	f240 4107 	movw	r1, #1031	@ 0x407
340052ae:	482b      	ldr	r0, [pc, #172]	@ (3400535c <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340052b0:	f7fd f944 	bl	3400253c <assert_failed>
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
340052b4:	6863      	ldr	r3, [r4, #4]
340052b6:	071a      	lsls	r2, r3, #28
340052b8:	d102      	bne.n	340052c0 <HAL_DCMIPP_PIPE_SetConfig+0x98>
340052ba:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
340052be:	d304      	bcc.n	340052ca <HAL_DCMIPP_PIPE_SetConfig+0xa2>
340052c0:	f44f 6181 	mov.w	r1, #1032	@ 0x408
340052c4:	4825      	ldr	r0, [pc, #148]	@ (3400535c <HAL_DCMIPP_PIPE_SetConfig+0x134>)
340052c6:	f7fd f939 	bl	3400253c <assert_failed>
  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
340052ca:	2d02      	cmp	r5, #2
340052cc:	d1d2      	bne.n	34005274 <HAL_DCMIPP_PIPE_SetConfig+0x4c>
340052ce:	68a3      	ldr	r3, [r4, #8]
340052d0:	2b06      	cmp	r3, #6
340052d2:	d9cf      	bls.n	34005274 <HAL_DCMIPP_PIPE_SetConfig+0x4c>
340052d4:	e7ad      	b.n	34005232 <HAL_DCMIPP_PIPE_SetConfig+0xa>
  else if (Pipe == DCMIPP_PIPE1)
340052d6:	2d01      	cmp	r5, #1
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
340052d8:	e9d4 4601 	ldrd	r4, r6, [r4, #4]
  else if (Pipe == DCMIPP_PIPE1)
340052dc:	d126      	bne.n	3400532c <HAL_DCMIPP_PIPE_SetConfig+0x104>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
340052de:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
340052e2:	4d1f      	ldr	r5, [pc, #124]	@ (34005360 <HAL_DCMIPP_PIPE_SetConfig+0x138>)
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
340052e4:	f022 0203 	bic.w	r2, r2, #3
340052e8:	433a      	orrs	r2, r7
340052ea:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
340052ee:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
340052f2:	f022 020f 	bic.w	r2, r2, #15
340052f6:	4332      	orrs	r2, r6
340052f8:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
340052fc:	f8d3 29cc 	ldr.w	r2, [r3, #2508]	@ 0x9cc
34005300:	402a      	ands	r2, r5
34005302:	4322      	orrs	r2, r4
34005304:	f8c3 29cc 	str.w	r2, [r3, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34005308:	1ff2      	subs	r2, r6, #7
3400530a:	2a01      	cmp	r2, #1
3400530c:	d806      	bhi.n	3400531c <HAL_DCMIPP_PIPE_SetConfig+0xf4>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
3400530e:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
34005312:	402a      	ands	r2, r5
34005314:	4322      	orrs	r2, r4
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34005316:	f8c3 29dc 	str.w	r2, [r3, #2524]	@ 0x9dc
3400531a:	e7c0      	b.n	3400529e <HAL_DCMIPP_PIPE_SetConfig+0x76>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
3400531c:	2e09      	cmp	r6, #9
3400531e:	d1be      	bne.n	3400529e <HAL_DCMIPP_PIPE_SetConfig+0x76>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34005320:	f8d3 29dc 	ldr.w	r2, [r3, #2524]	@ 0x9dc
34005324:	402a      	ands	r2, r5
34005326:	ea42 0254 	orr.w	r2, r2, r4, lsr #1
3400532a:	e7f4      	b.n	34005316 <HAL_DCMIPP_PIPE_SetConfig+0xee>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
3400532c:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34005330:	f022 0203 	bic.w	r2, r2, #3
34005334:	433a      	orrs	r2, r7
34005336:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
3400533a:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
3400533e:	f022 020f 	bic.w	r2, r2, #15
34005342:	4332      	orrs	r2, r6
34005344:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
34005348:	f8d3 2dcc 	ldr.w	r2, [r3, #3532]	@ 0xdcc
3400534c:	f36f 020e 	bfc	r2, #0, #15
34005350:	4322      	orrs	r2, r4
34005352:	f8c3 2dcc 	str.w	r2, [r3, #3532]	@ 0xdcc
34005356:	e7a2      	b.n	3400529e <HAL_DCMIPP_PIPE_SetConfig+0x76>
34005358:	58002000 	.word	0x58002000
3400535c:	3401c3e6 	.word	0x3401c3e6
34005360:	ffff8000 	.word	0xffff8000

34005364 <HAL_DCMIPP_CSI_PIPE_Start>:
{
34005364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005368:	2902      	cmp	r1, #2
{
3400536a:	4604      	mov	r4, r0
3400536c:	460d      	mov	r5, r1
3400536e:	4616      	mov	r6, r2
34005370:	461f      	mov	r7, r3
34005372:	f8dd 8018 	ldr.w	r8, [sp, #24]
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005376:	d904      	bls.n	34005382 <HAL_DCMIPP_CSI_PIPE_Start+0x1e>
34005378:	f44f 61c2 	mov.w	r1, #1552	@ 0x610
3400537c:	481a      	ldr	r0, [pc, #104]	@ (340053e8 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
3400537e:	f7fd f8dd 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
34005382:	2e03      	cmp	r6, #3
34005384:	d904      	bls.n	34005390 <HAL_DCMIPP_CSI_PIPE_Start+0x2c>
34005386:	f240 6111 	movw	r1, #1553	@ 0x611
3400538a:	4817      	ldr	r0, [pc, #92]	@ (340053e8 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
3400538c:	f7fd f8d6 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_CAPTURE_MODE(CaptureMode));
34005390:	f038 0304 	bics.w	r3, r8, #4
34005394:	d004      	beq.n	340053a0 <HAL_DCMIPP_CSI_PIPE_Start+0x3c>
34005396:	f240 6112 	movw	r1, #1554	@ 0x612
3400539a:	4813      	ldr	r0, [pc, #76]	@ (340053e8 <HAL_DCMIPP_CSI_PIPE_Start+0x84>)
3400539c:	f7fd f8ce 	bl	3400253c <assert_failed>
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
340053a0:	b91c      	cbnz	r4, 340053aa <HAL_DCMIPP_CSI_PIPE_Start+0x46>
    return HAL_ERROR;
340053a2:	2601      	movs	r6, #1
}
340053a4:	4630      	mov	r0, r6
340053a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
340053aa:	073a      	lsls	r2, r7, #28
340053ac:	d1f9      	bne.n	340053a2 <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
340053ae:	6823      	ldr	r3, [r4, #0]
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
340053b0:	1962      	adds	r2, r4, r5
  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
340053b2:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
340053b6:	7952      	ldrb	r2, [r2, #5]
340053b8:	2a01      	cmp	r2, #1
340053ba:	d1f2      	bne.n	340053a2 <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
340053bc:	07db      	lsls	r3, r3, #31
340053be:	d5f0      	bpl.n	340053a2 <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  if (DCMIPP_CSI_SetVCConfig(hdcmipp, Pipe, VirtualChannel) != HAL_OK)
340053c0:	4632      	mov	r2, r6
340053c2:	4629      	mov	r1, r5
340053c4:	4620      	mov	r0, r4
340053c6:	f7ff fc65 	bl	34004c94 <DCMIPP_CSI_SetVCConfig>
340053ca:	4606      	mov	r6, r0
340053cc:	2800      	cmp	r0, #0
340053ce:	d1e8      	bne.n	340053a2 <HAL_DCMIPP_CSI_PIPE_Start+0x3e>
  DCMIPP_SetConfig(hdcmipp, Pipe, DstAddress, CaptureMode);
340053d0:	4629      	mov	r1, r5
340053d2:	4620      	mov	r0, r4
340053d4:	4643      	mov	r3, r8
340053d6:	463a      	mov	r2, r7
340053d8:	f7ff fcd7 	bl	34004d8a <DCMIPP_SetConfig>
  DCMIPP_EnableCapture(hdcmipp, Pipe);
340053dc:	4629      	mov	r1, r5
340053de:	4620      	mov	r0, r4
340053e0:	f7ff fcfe 	bl	34004de0 <DCMIPP_EnableCapture>
  return HAL_OK;
340053e4:	e7de      	b.n	340053a4 <HAL_DCMIPP_CSI_PIPE_Start+0x40>
340053e6:	bf00      	nop
340053e8:	3401c3e6 	.word	0x3401c3e6

340053ec <HAL_DCMIPP_PIPE_LineEventCallback>:
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
340053ec:	4770      	bx	lr

340053ee <HAL_DCMIPP_PIPE_LimitEventCallback>:
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
340053ee:	4770      	bx	lr

340053f0 <HAL_DCMIPP_PIPE_ErrorCallback>:
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
340053f0:	4770      	bx	lr

340053f2 <HAL_DCMIPP_ErrorCallback>:
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
340053f2:	4770      	bx	lr

340053f4 <HAL_DCMIPP_IRQHandler>:
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
340053f4:	6803      	ldr	r3, [r0, #0]
{
340053f6:	b570      	push	{r4, r5, r6, lr}
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
340053f8:	f8d3 63f8 	ldr.w	r6, [r3, #1016]	@ 0x3f8
{
340053fc:	4604      	mov	r4, r0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
340053fe:	0472      	lsls	r2, r6, #17
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
34005400:	f8d3 53f0 	ldr.w	r5, [r3, #1008]	@ 0x3f0
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34005404:	d512      	bpl.n	3400542c <HAL_DCMIPP_IRQHandler+0x38>
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34005406:	0469      	lsls	r1, r5, #17
34005408:	d510      	bpl.n	3400542c <HAL_DCMIPP_IRQHandler+0x38>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
3400540a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
3400540e:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34005410:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34005414:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34005418:	6882      	ldr	r2, [r0, #8]
3400541a:	f042 0204 	orr.w	r2, r2, #4
3400541e:	6082      	str	r2, [r0, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
34005420:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34005424:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34005428:	f7ff ffe1 	bl	340053ee <HAL_DCMIPP_PIPE_LimitEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
3400542c:	0572      	lsls	r2, r6, #21
3400542e:	d50a      	bpl.n	34005446 <HAL_DCMIPP_IRQHandler+0x52>
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
34005430:	056b      	lsls	r3, r5, #21
34005432:	d508      	bpl.n	34005446 <HAL_DCMIPP_IRQHandler+0x52>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34005434:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005438:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
3400543a:	2100      	movs	r1, #0
3400543c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
3400543e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34005442:	f00b fc2f 	bl	34010ca4 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34005446:	05b0      	lsls	r0, r6, #22
34005448:	d516      	bpl.n	34005478 <HAL_DCMIPP_IRQHandler+0x84>
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
3400544a:	05a9      	lsls	r1, r5, #22
3400544c:	d514      	bpl.n	34005478 <HAL_DCMIPP_IRQHandler+0x84>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400544e:	6823      	ldr	r3, [r4, #0]
34005450:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
34005454:	0752      	lsls	r2, r2, #29
34005456:	d507      	bpl.n	34005468 <HAL_DCMIPP_IRQHandler+0x74>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34005458:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400545c:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34005460:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34005464:	2201      	movs	r2, #1
34005466:	7162      	strb	r2, [r4, #5]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34005468:	f44f 7200 	mov.w	r2, #512	@ 0x200
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
3400546c:	2100      	movs	r1, #0
3400546e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34005470:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34005474:	f00b fc26 	bl	34010cc4 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34005478:	05f3      	lsls	r3, r6, #23
3400547a:	d50a      	bpl.n	34005492 <HAL_DCMIPP_IRQHandler+0x9e>
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
3400547c:	05e8      	lsls	r0, r5, #23
3400547e:	d508      	bpl.n	34005492 <HAL_DCMIPP_IRQHandler+0x9e>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34005480:	f44f 7280 	mov.w	r2, #256	@ 0x100
34005484:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34005486:	2100      	movs	r1, #0
34005488:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
3400548a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
3400548e:	f7ff ffad 	bl	340053ec <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
34005492:	0431      	lsls	r1, r6, #16
34005494:	d516      	bpl.n	340054c4 <HAL_DCMIPP_IRQHandler+0xd0>
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34005496:	042a      	lsls	r2, r5, #16
34005498:	d514      	bpl.n	340054c4 <HAL_DCMIPP_IRQHandler+0xd0>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
3400549a:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
3400549c:	2100      	movs	r1, #0
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
3400549e:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340054a2:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
340054a4:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340054a8:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
340054ac:	68a2      	ldr	r2, [r4, #8]
340054ae:	f042 0208 	orr.w	r2, r2, #8
340054b2:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
340054b4:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340054b8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
340054bc:	2304      	movs	r3, #4
340054be:	7163      	strb	r3, [r4, #5]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340054c0:	f7ff ff96 	bl	340053f0 <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340054c4:	03f3      	lsls	r3, r6, #15
340054c6:	d50a      	bpl.n	340054de <HAL_DCMIPP_IRQHandler+0xea>
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340054c8:	03e8      	lsls	r0, r5, #15
340054ca:	d508      	bpl.n	340054de <HAL_DCMIPP_IRQHandler+0xea>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
340054cc:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
340054d0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
340054d2:	2101      	movs	r1, #1
340054d4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
340054d6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
340054da:	f7ff ff87 	bl	340053ec <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
340054de:	0371      	lsls	r1, r6, #13
340054e0:	d50a      	bpl.n	340054f8 <HAL_DCMIPP_IRQHandler+0x104>
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
340054e2:	036a      	lsls	r2, r5, #13
340054e4:	d508      	bpl.n	340054f8 <HAL_DCMIPP_IRQHandler+0x104>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
340054e6:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
340054ea:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
340054ec:	2101      	movs	r1, #1
340054ee:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
340054f0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
340054f4:	f00b fbd6 	bl	34010ca4 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
340054f8:	03b3      	lsls	r3, r6, #14
340054fa:	d516      	bpl.n	3400552a <HAL_DCMIPP_IRQHandler+0x136>
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
340054fc:	03a8      	lsls	r0, r5, #14
340054fe:	d514      	bpl.n	3400552a <HAL_DCMIPP_IRQHandler+0x136>
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005500:	6823      	ldr	r3, [r4, #0]
34005502:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34005506:	0751      	lsls	r1, r2, #29
34005508:	d507      	bpl.n	3400551a <HAL_DCMIPP_IRQHandler+0x126>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
3400550a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400550e:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34005512:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34005516:	2201      	movs	r2, #1
34005518:	71a2      	strb	r2, [r4, #6]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
3400551a:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
3400551e:	2101      	movs	r1, #1
34005520:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34005522:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34005526:	f00b fbcd 	bl	34010cc4 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
3400552a:	0232      	lsls	r2, r6, #8
3400552c:	d516      	bpl.n	3400555c <HAL_DCMIPP_IRQHandler+0x168>
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
3400552e:	022b      	lsls	r3, r5, #8
34005530:	d514      	bpl.n	3400555c <HAL_DCMIPP_IRQHandler+0x168>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005532:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005534:	2101      	movs	r1, #1
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34005536:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
3400553a:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
3400553c:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34005540:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34005544:	68a2      	ldr	r2, [r4, #8]
34005546:	f042 0210 	orr.w	r2, r2, #16
3400554a:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
3400554c:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34005550:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34005554:	2304      	movs	r3, #4
34005556:	71a3      	strb	r3, [r4, #6]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34005558:	f7ff ff4a 	bl	340053f0 <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
3400555c:	01f0      	lsls	r0, r6, #7
3400555e:	d50a      	bpl.n	34005576 <HAL_DCMIPP_IRQHandler+0x182>
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34005560:	01e9      	lsls	r1, r5, #7
34005562:	d508      	bpl.n	34005576 <HAL_DCMIPP_IRQHandler+0x182>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34005564:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34005568:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
3400556a:	2102      	movs	r1, #2
3400556c:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
3400556e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34005572:	f7ff ff3b 	bl	340053ec <HAL_DCMIPP_PIPE_LineEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34005576:	0172      	lsls	r2, r6, #5
34005578:	d50a      	bpl.n	34005590 <HAL_DCMIPP_IRQHandler+0x19c>
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
3400557a:	016b      	lsls	r3, r5, #5
3400557c:	d508      	bpl.n	34005590 <HAL_DCMIPP_IRQHandler+0x19c>
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
3400557e:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34005582:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34005584:	2102      	movs	r1, #2
34005586:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34005588:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
3400558c:	f00b fb8a 	bl	34010ca4 <HAL_DCMIPP_PIPE_VsyncEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
34005590:	01b0      	lsls	r0, r6, #6
34005592:	d516      	bpl.n	340055c2 <HAL_DCMIPP_IRQHandler+0x1ce>
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34005594:	01a9      	lsls	r1, r5, #6
34005596:	d514      	bpl.n	340055c2 <HAL_DCMIPP_IRQHandler+0x1ce>
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005598:	6823      	ldr	r3, [r4, #0]
3400559a:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
3400559e:	0752      	lsls	r2, r2, #29
340055a0:	d507      	bpl.n	340055b2 <HAL_DCMIPP_IRQHandler+0x1be>
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
340055a2:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340055a6:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
340055aa:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
340055ae:	2201      	movs	r2, #1
340055b0:	71e2      	strb	r2, [r4, #7]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
340055b2:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
340055b6:	2102      	movs	r1, #2
340055b8:	4620      	mov	r0, r4
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
340055ba:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
340055be:	f00b fb81 	bl	34010cc4 <HAL_DCMIPP_PIPE_FrameEventCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
340055c2:	2e00      	cmp	r6, #0
340055c4:	da16      	bge.n	340055f4 <HAL_DCMIPP_IRQHandler+0x200>
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
340055c6:	2d00      	cmp	r5, #0
340055c8:	da14      	bge.n	340055f4 <HAL_DCMIPP_IRQHandler+0x200>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
340055ca:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
340055cc:	2102      	movs	r1, #2
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
340055ce:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
340055d2:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
340055d4:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
340055d8:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
340055dc:	68a2      	ldr	r2, [r4, #8]
340055de:	f042 0220 	orr.w	r2, r2, #32
340055e2:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
340055e4:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
340055e8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
340055ec:	2304      	movs	r3, #4
340055ee:	71e3      	strb	r3, [r4, #7]
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
340055f0:	f7ff fefe 	bl	340053f0 <HAL_DCMIPP_PIPE_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
340055f4:	0670      	lsls	r0, r6, #25
340055f6:	d514      	bpl.n	34005622 <HAL_DCMIPP_IRQHandler+0x22e>
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
340055f8:	0669      	lsls	r1, r5, #25
340055fa:	d512      	bpl.n	34005622 <HAL_DCMIPP_IRQHandler+0x22e>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
340055fc:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340055fe:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34005600:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005604:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34005608:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
3400560c:	68a2      	ldr	r2, [r4, #8]
3400560e:	f042 0202 	orr.w	r2, r2, #2
34005612:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34005614:	2240      	movs	r2, #64	@ 0x40
34005616:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
3400561a:	2304      	movs	r3, #4
3400561c:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400561e:	f7ff fee8 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34005622:	06b2      	lsls	r2, r6, #26
34005624:	d514      	bpl.n	34005650 <HAL_DCMIPP_IRQHandler+0x25c>
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34005626:	06ab      	lsls	r3, r5, #26
34005628:	d512      	bpl.n	34005650 <HAL_DCMIPP_IRQHandler+0x25c>
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
3400562a:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400562c:	4620      	mov	r0, r4
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
3400562e:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34005632:	f022 0220 	bic.w	r2, r2, #32
34005636:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
3400563a:	68a2      	ldr	r2, [r4, #8]
3400563c:	f042 0201 	orr.w	r2, r2, #1
34005640:	60a2      	str	r2, [r4, #8]
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34005642:	2220      	movs	r2, #32
34005644:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005648:	2304      	movs	r3, #4
3400564a:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
3400564c:	f7ff fed1 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
}
34005650:	bd70      	pop	{r4, r5, r6, pc}

34005652 <HAL_DCMIPP_CSI_LineErrorCallback>:
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
34005652:	4770      	bx	lr

34005654 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
34005654:	4770      	bx	lr

34005656 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
34005656:	4770      	bx	lr

34005658 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
34005658:	4770      	bx	lr

3400565a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
3400565a:	4770      	bx	lr

3400565c <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
3400565c:	4770      	bx	lr

3400565e <HAL_DCMIPP_CSI_LineByteEventCallback>:
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
3400565e:	4770      	bx	lr

34005660 <HAL_DCMIPP_CSI_IRQHandler>:
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34005660:	4bb5      	ldr	r3, [pc, #724]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
{
34005662:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34005666:	f8d3 6090 	ldr.w	r6, [r3, #144]	@ 0x90
{
3400566a:	4604      	mov	r4, r0
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
3400566c:	02b2      	lsls	r2, r6, #10
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
3400566e:	f8d3 8094 	ldr.w	r8, [r3, #148]	@ 0x94
  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
34005672:	f8d3 5080 	ldr.w	r5, [r3, #128]	@ 0x80
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34005676:	f8d3 7084 	ldr.w	r7, [r3, #132]	@ 0x84
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
3400567a:	d50d      	bpl.n	34005698 <HAL_DCMIPP_CSI_IRQHandler+0x38>
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
3400567c:	02a9      	lsls	r1, r5, #10
3400567e:	d50b      	bpl.n	34005698 <HAL_DCMIPP_CSI_IRQHandler+0x38>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34005680:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005684:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
34005688:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
3400568c:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34005690:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
34005694:	f7ff ffde 	bl	34005654 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34005698:	0732      	lsls	r2, r6, #28
3400569a:	d515      	bpl.n	340056c8 <HAL_DCMIPP_CSI_IRQHandler+0x68>
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
3400569c:	072b      	lsls	r3, r5, #28
3400569e:	d513      	bpl.n	340056c8 <HAL_DCMIPP_CSI_IRQHandler+0x68>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056a0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340056a2:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056a4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340056a8:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056aa:	f013 0f04 	tst.w	r3, #4
340056ae:	4ba2      	ldr	r3, [pc, #648]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
340056b0:	bf1e      	ittt	ne
340056b2:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340056b6:	f022 0208 	bicne.w	r2, r2, #8
340056ba:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
340056be:	2208      	movs	r2, #8
340056c0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340056c4:	f7ff ffcb 	bl	3400565e <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
340056c8:	0770      	lsls	r0, r6, #29
340056ca:	d515      	bpl.n	340056f8 <HAL_DCMIPP_CSI_IRQHandler+0x98>
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
340056cc:	0769      	lsls	r1, r5, #29
340056ce:	d513      	bpl.n	340056f8 <HAL_DCMIPP_CSI_IRQHandler+0x98>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056d0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
340056d2:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056d4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
340056d8:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340056da:	f013 0f04 	tst.w	r3, #4
340056de:	4b96      	ldr	r3, [pc, #600]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
340056e0:	bf1e      	ittt	ne
340056e2:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340056e6:	f022 0204 	bicne.w	r2, r2, #4
340056ea:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
340056ee:	2204      	movs	r2, #4
340056f0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
340056f4:	f7ff ffb3 	bl	3400565e <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
340056f8:	07b2      	lsls	r2, r6, #30
340056fa:	d515      	bpl.n	34005728 <HAL_DCMIPP_CSI_IRQHandler+0xc8>
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
340056fc:	07ab      	lsls	r3, r5, #30
340056fe:	d513      	bpl.n	34005728 <HAL_DCMIPP_CSI_IRQHandler+0xc8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005700:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005702:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005704:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005708:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400570a:	f013 0f04 	tst.w	r3, #4
3400570e:	4b8a      	ldr	r3, [pc, #552]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
34005710:	bf1e      	ittt	ne
34005712:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005716:	f022 0202 	bicne.w	r2, r2, #2
3400571a:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
3400571e:	2202      	movs	r2, #2
34005720:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34005724:	f7ff ff9b 	bl	3400565e <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34005728:	07f0      	lsls	r0, r6, #31
3400572a:	d515      	bpl.n	34005758 <HAL_DCMIPP_CSI_IRQHandler+0xf8>
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
3400572c:	07e9      	lsls	r1, r5, #31
3400572e:	d513      	bpl.n	34005758 <HAL_DCMIPP_CSI_IRQHandler+0xf8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005730:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005732:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005734:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005738:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400573a:	f013 0f04 	tst.w	r3, #4
3400573e:	4b7e      	ldr	r3, [pc, #504]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34005740:	bf1e      	ittt	ne
34005742:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005746:	f022 0201 	bicne.w	r2, r2, #1
3400574a:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
3400574e:	2201      	movs	r2, #1
34005750:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34005754:	f7ff ff83 	bl	3400565e <HAL_DCMIPP_CSI_LineByteEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34005758:	0432      	lsls	r2, r6, #16
3400575a:	d516      	bpl.n	3400578a <HAL_DCMIPP_CSI_IRQHandler+0x12a>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
3400575c:	042b      	lsls	r3, r5, #16
3400575e:	d514      	bpl.n	3400578a <HAL_DCMIPP_CSI_IRQHandler+0x12a>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005760:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005762:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005764:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005768:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400576a:	f013 0f04 	tst.w	r3, #4
3400576e:	4b72      	ldr	r3, [pc, #456]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
34005770:	bf1e      	ittt	ne
34005772:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005776:	f422 4200 	bicne.w	r2, r2, #32768	@ 0x8000
3400577a:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
3400577e:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34005782:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005786:	f7ff ff67 	bl	34005658 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
3400578a:	0470      	lsls	r0, r6, #17
3400578c:	d516      	bpl.n	340057bc <HAL_DCMIPP_CSI_IRQHandler+0x15c>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
3400578e:	0469      	lsls	r1, r5, #17
34005790:	d514      	bpl.n	340057bc <HAL_DCMIPP_CSI_IRQHandler+0x15c>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005792:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005794:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005796:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
3400579a:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400579c:	f013 0f04 	tst.w	r3, #4
340057a0:	4b65      	ldr	r3, [pc, #404]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
340057a2:	bf1e      	ittt	ne
340057a4:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340057a8:	f422 4280 	bicne.w	r2, r2, #16384	@ 0x4000
340057ac:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
340057b0:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
340057b4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
340057b8:	f7ff ff4e 	bl	34005658 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
340057bc:	04b2      	lsls	r2, r6, #18
340057be:	d516      	bpl.n	340057ee <HAL_DCMIPP_CSI_IRQHandler+0x18e>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
340057c0:	04ab      	lsls	r3, r5, #18
340057c2:	d514      	bpl.n	340057ee <HAL_DCMIPP_CSI_IRQHandler+0x18e>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057c4:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340057c6:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057c8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340057cc:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057ce:	f013 0f04 	tst.w	r3, #4
340057d2:	4b59      	ldr	r3, [pc, #356]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
340057d4:	bf1e      	ittt	ne
340057d6:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340057da:	f422 5200 	bicne.w	r2, r2, #8192	@ 0x2000
340057de:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
340057e2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
340057e6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340057ea:	f7ff ff35 	bl	34005658 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
340057ee:	04f0      	lsls	r0, r6, #19
340057f0:	d516      	bpl.n	34005820 <HAL_DCMIPP_CSI_IRQHandler+0x1c0>
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
340057f2:	04e9      	lsls	r1, r5, #19
340057f4:	d514      	bpl.n	34005820 <HAL_DCMIPP_CSI_IRQHandler+0x1c0>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057f6:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340057f8:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340057fa:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340057fe:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005800:	f013 0f04 	tst.w	r3, #4
34005804:	4b4c      	ldr	r3, [pc, #304]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34005806:	bf1e      	ittt	ne
34005808:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400580c:	f422 5280 	bicne.w	r2, r2, #4096	@ 0x1000
34005810:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
34005814:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005818:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
3400581c:	f7ff ff1c 	bl	34005658 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
34005820:	0532      	lsls	r2, r6, #20
34005822:	d516      	bpl.n	34005852 <HAL_DCMIPP_CSI_IRQHandler+0x1f2>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
34005824:	052b      	lsls	r3, r5, #20
34005826:	d514      	bpl.n	34005852 <HAL_DCMIPP_CSI_IRQHandler+0x1f2>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005828:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
3400582a:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400582c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34005830:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005832:	f013 0f04 	tst.w	r3, #4
34005836:	4b40      	ldr	r3, [pc, #256]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
34005838:	bf1e      	ittt	ne
3400583a:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400583e:	f422 6200 	bicne.w	r2, r2, #2048	@ 0x800
34005842:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
34005846:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3400584a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
3400584e:	f7ff ff04 	bl	3400565a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
34005852:	0570      	lsls	r0, r6, #21
34005854:	d516      	bpl.n	34005884 <HAL_DCMIPP_CSI_IRQHandler+0x224>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
34005856:	0569      	lsls	r1, r5, #21
34005858:	d514      	bpl.n	34005884 <HAL_DCMIPP_CSI_IRQHandler+0x224>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400585a:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
3400585c:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400585e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005862:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005864:	f013 0f04 	tst.w	r3, #4
34005868:	4b33      	ldr	r3, [pc, #204]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
3400586a:	bf1e      	ittt	ne
3400586c:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005870:	f422 6280 	bicne.w	r2, r2, #1024	@ 0x400
34005874:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34005878:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400587c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34005880:	f7ff feeb 	bl	3400565a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
34005884:	05b2      	lsls	r2, r6, #22
34005886:	d516      	bpl.n	340058b6 <HAL_DCMIPP_CSI_IRQHandler+0x256>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34005888:	05ab      	lsls	r3, r5, #22
3400588a:	d514      	bpl.n	340058b6 <HAL_DCMIPP_CSI_IRQHandler+0x256>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400588c:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
3400588e:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005890:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34005894:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005896:	f013 0f04 	tst.w	r3, #4
3400589a:	4b27      	ldr	r3, [pc, #156]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
3400589c:	bf1e      	ittt	ne
3400589e:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340058a2:	f422 7200 	bicne.w	r2, r2, #512	@ 0x200
340058a6:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
340058aa:	f44f 7200 	mov.w	r2, #512	@ 0x200
340058ae:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
340058b2:	f7ff fed2 	bl	3400565a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
340058b6:	05f0      	lsls	r0, r6, #23
340058b8:	d516      	bpl.n	340058e8 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
340058ba:	05e9      	lsls	r1, r5, #23
340058bc:	d514      	bpl.n	340058e8 <HAL_DCMIPP_CSI_IRQHandler+0x288>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058be:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340058c0:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058c2:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340058c6:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058c8:	f013 0f04 	tst.w	r3, #4
340058cc:	4b1a      	ldr	r3, [pc, #104]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
340058ce:	bf1e      	ittt	ne
340058d0:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
340058d4:	f422 7280 	bicne.w	r2, r2, #256	@ 0x100
340058d8:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
340058dc:	f44f 7280 	mov.w	r2, #256	@ 0x100
340058e0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340058e4:	f7ff feb9 	bl	3400565a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
340058e8:	0632      	lsls	r2, r6, #24
340058ea:	d515      	bpl.n	34005918 <HAL_DCMIPP_CSI_IRQHandler+0x2b8>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
340058ec:	062b      	lsls	r3, r5, #24
340058ee:	d513      	bpl.n	34005918 <HAL_DCMIPP_CSI_IRQHandler+0x2b8>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058f0:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
340058f2:	2103      	movs	r1, #3
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058f4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
340058f8:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340058fa:	f013 0f04 	tst.w	r3, #4
340058fe:	4b0e      	ldr	r3, [pc, #56]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
34005900:	bf1e      	ittt	ne
34005902:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005906:	f022 0280 	bicne.w	r2, r2, #128	@ 0x80
3400590a:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
3400590e:	2280      	movs	r2, #128	@ 0x80
34005910:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34005914:	f7ff fea2 	bl	3400565c <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
34005918:	0670      	lsls	r0, r6, #25
3400591a:	d519      	bpl.n	34005950 <HAL_DCMIPP_CSI_IRQHandler+0x2f0>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
3400591c:	0669      	lsls	r1, r5, #25
3400591e:	d517      	bpl.n	34005950 <HAL_DCMIPP_CSI_IRQHandler+0x2f0>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005920:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005922:	2102      	movs	r1, #2
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005924:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34005928:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400592a:	f013 0f04 	tst.w	r3, #4
3400592e:	4b02      	ldr	r3, [pc, #8]	@ (34005938 <HAL_DCMIPP_CSI_IRQHandler+0x2d8>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
34005930:	bf18      	it	ne
34005932:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
34005936:	e001      	b.n	3400593c <HAL_DCMIPP_CSI_IRQHandler+0x2dc>
34005938:	58006000 	.word	0x58006000
3400593c:	bf1c      	itt	ne
3400593e:	f022 0240 	bicne.w	r2, r2, #64	@ 0x40
34005942:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
34005946:	2240      	movs	r2, #64	@ 0x40
34005948:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
3400594c:	f7ff fe86 	bl	3400565c <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
34005950:	06b2      	lsls	r2, r6, #26
34005952:	d515      	bpl.n	34005980 <HAL_DCMIPP_CSI_IRQHandler+0x320>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34005954:	06ab      	lsls	r3, r5, #26
34005956:	d513      	bpl.n	34005980 <HAL_DCMIPP_CSI_IRQHandler+0x320>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005958:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
3400595a:	2101      	movs	r1, #1
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400595c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34005960:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005962:	f013 0f04 	tst.w	r3, #4
34005966:	4bb9      	ldr	r3, [pc, #740]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34005968:	bf1e      	ittt	ne
3400596a:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400596e:	f022 0220 	bicne.w	r2, r2, #32
34005972:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34005976:	2220      	movs	r2, #32
34005978:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
3400597c:	f7ff fe6e 	bl	3400565c <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
34005980:	06f0      	lsls	r0, r6, #27
34005982:	d515      	bpl.n	340059b0 <HAL_DCMIPP_CSI_IRQHandler+0x350>
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
34005984:	06e9      	lsls	r1, r5, #27
34005986:	d513      	bpl.n	340059b0 <HAL_DCMIPP_CSI_IRQHandler+0x350>
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005988:	6823      	ldr	r3, [r4, #0]
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
3400598a:	2100      	movs	r1, #0
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400598c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34005990:	4620      	mov	r0, r4
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34005992:	f013 0f04 	tst.w	r3, #4
34005996:	4bad      	ldr	r3, [pc, #692]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
34005998:	bf1e      	ittt	ne
3400599a:	f8d3 2080 	ldrne.w	r2, [r3, #128]	@ 0x80
3400599e:	f022 0210 	bicne.w	r2, r2, #16
340059a2:	f8c3 2080 	strne.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
340059a6:	2210      	movs	r2, #16
340059a8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
340059ac:	f7ff fe56 	bl	3400565c <HAL_DCMIPP_CSI_TimerCounterEventCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
340059b0:	0072      	lsls	r2, r6, #1
340059b2:	d513      	bpl.n	340059dc <HAL_DCMIPP_CSI_IRQHandler+0x37c>
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
340059b4:	006b      	lsls	r3, r5, #1
340059b6:	d511      	bpl.n	340059dc <HAL_DCMIPP_CSI_IRQHandler+0x37c>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
340059b8:	4ba4      	ldr	r3, [pc, #656]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059ba:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
340059bc:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340059c0:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
340059c4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
340059c8:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
340059cc:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
340059d0:	68a3      	ldr	r3, [r4, #8]
340059d2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340059d6:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059d8:	f7ff fd0b 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
340059dc:	00b0      	lsls	r0, r6, #2
340059de:	d513      	bpl.n	34005a08 <HAL_DCMIPP_CSI_IRQHandler+0x3a8>
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
340059e0:	00a9      	lsls	r1, r5, #2
340059e2:	d511      	bpl.n	34005a08 <HAL_DCMIPP_CSI_IRQHandler+0x3a8>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
340059e4:	4b99      	ldr	r3, [pc, #612]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340059e6:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
340059e8:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
340059ec:	f022 5200 	bic.w	r2, r2, #536870912	@ 0x20000000
340059f0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
340059f4:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
340059f8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
340059fc:	68a3      	ldr	r3, [r4, #8]
340059fe:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34005a02:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a04:	f7ff fcf5 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34005a08:	00f2      	lsls	r2, r6, #3
34005a0a:	d513      	bpl.n	34005a34 <HAL_DCMIPP_CSI_IRQHandler+0x3d4>
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34005a0c:	00eb      	lsls	r3, r5, #3
34005a0e:	d511      	bpl.n	34005a34 <HAL_DCMIPP_CSI_IRQHandler+0x3d4>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34005a10:	4b8e      	ldr	r3, [pc, #568]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a12:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34005a14:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005a18:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
34005a1c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
34005a20:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34005a24:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34005a28:	68a3      	ldr	r3, [r4, #8]
34005a2a:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
34005a2e:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a30:	f7ff fcdf 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
34005a34:	0130      	lsls	r0, r6, #4
34005a36:	d513      	bpl.n	34005a60 <HAL_DCMIPP_CSI_IRQHandler+0x400>
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34005a38:	0129      	lsls	r1, r5, #4
34005a3a:	d511      	bpl.n	34005a60 <HAL_DCMIPP_CSI_IRQHandler+0x400>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
34005a3c:	4b83      	ldr	r3, [pc, #524]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a3e:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
34005a40:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005a44:	f022 6200 	bic.w	r2, r2, #134217728	@ 0x8000000
34005a48:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
34005a4c:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34005a50:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
34005a54:	68a3      	ldr	r3, [r4, #8]
34005a56:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
34005a5a:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a5c:	f7ff fcc9 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
34005a60:	0172      	lsls	r2, r6, #5
34005a62:	d513      	bpl.n	34005a8c <HAL_DCMIPP_CSI_IRQHandler+0x42c>
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
34005a64:	016b      	lsls	r3, r5, #5
34005a66:	d511      	bpl.n	34005a8c <HAL_DCMIPP_CSI_IRQHandler+0x42c>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34005a68:	4b78      	ldr	r3, [pc, #480]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a6a:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34005a6c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005a70:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
34005a74:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
34005a78:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34005a7c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
34005a80:	68a3      	ldr	r3, [r4, #8]
34005a82:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34005a86:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a88:	f7ff fcb3 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
34005a8c:	01b0      	lsls	r0, r6, #6
34005a8e:	d513      	bpl.n	34005ab8 <HAL_DCMIPP_CSI_IRQHandler+0x458>
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
34005a90:	01a9      	lsls	r1, r5, #6
34005a92:	d511      	bpl.n	34005ab8 <HAL_DCMIPP_CSI_IRQHandler+0x458>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
34005a94:	4b6d      	ldr	r3, [pc, #436]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005a96:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
34005a98:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005a9c:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
34005aa0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
34005aa4:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34005aa8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
34005aac:	68a3      	ldr	r3, [r4, #8]
34005aae:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34005ab2:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005ab4:	f7ff fc9d 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
34005ab8:	01f2      	lsls	r2, r6, #7
34005aba:	d513      	bpl.n	34005ae4 <HAL_DCMIPP_CSI_IRQHandler+0x484>
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
34005abc:	01eb      	lsls	r3, r5, #7
34005abe:	d511      	bpl.n	34005ae4 <HAL_DCMIPP_CSI_IRQHandler+0x484>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
34005ac0:	4b62      	ldr	r3, [pc, #392]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005ac2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
34005ac4:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005ac8:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
34005acc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
34005ad0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34005ad4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
34005ad8:	68a3      	ldr	r3, [r4, #8]
34005ada:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
34005ade:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34005ae0:	f7ff fc87 	bl	340053f2 <HAL_DCMIPP_ErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
34005ae4:	f018 0f01 	tst.w	r8, #1
34005ae8:	d014      	beq.n	34005b14 <HAL_DCMIPP_CSI_IRQHandler+0x4b4>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34005aea:	07f8      	lsls	r0, r7, #31
34005aec:	d512      	bpl.n	34005b14 <HAL_DCMIPP_CSI_IRQHandler+0x4b4>
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
34005aee:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
34005af0:	4b56      	ldr	r3, [pc, #344]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005af2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
34005af4:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005af8:	f022 0201 	bic.w	r2, r2, #1
34005afc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
34005b00:	f8c3 1104 	str.w	r1, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34005b04:	68a3      	ldr	r3, [r4, #8]
34005b06:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34005b0a:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005b0c:	2304      	movs	r3, #4
34005b0e:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b10:	f7ff fd9f 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
34005b14:	f018 0f02 	tst.w	r8, #2
34005b18:	d015      	beq.n	34005b46 <HAL_DCMIPP_CSI_IRQHandler+0x4e6>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
34005b1a:	07b9      	lsls	r1, r7, #30
34005b1c:	d513      	bpl.n	34005b46 <HAL_DCMIPP_CSI_IRQHandler+0x4e6>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34005b1e:	4b4b      	ldr	r3, [pc, #300]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b20:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34005b22:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b26:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34005b28:	f022 0202 	bic.w	r2, r2, #2
34005b2c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
34005b30:	2202      	movs	r2, #2
34005b32:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34005b36:	68a3      	ldr	r3, [r4, #8]
34005b38:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
34005b3c:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005b3e:	2304      	movs	r3, #4
34005b40:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b42:	f7ff fd86 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
34005b46:	f018 0f04 	tst.w	r8, #4
34005b4a:	d013      	beq.n	34005b74 <HAL_DCMIPP_CSI_IRQHandler+0x514>
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
34005b4c:	077a      	lsls	r2, r7, #29
34005b4e:	d511      	bpl.n	34005b74 <HAL_DCMIPP_CSI_IRQHandler+0x514>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005b50:	4b3e      	ldr	r3, [pc, #248]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b52:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005b54:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b58:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34005b5a:	f022 0204 	bic.w	r2, r2, #4
34005b5e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
34005b62:	2204      	movs	r2, #4
34005b64:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34005b68:	68a3      	ldr	r3, [r4, #8]
34005b6a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34005b6e:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b70:	f7ff fd6f 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34005b74:	f018 0f08 	tst.w	r8, #8
34005b78:	d013      	beq.n	34005ba2 <HAL_DCMIPP_CSI_IRQHandler+0x542>
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
34005b7a:	073b      	lsls	r3, r7, #28
34005b7c:	d511      	bpl.n	34005ba2 <HAL_DCMIPP_CSI_IRQHandler+0x542>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005b7e:	4b33      	ldr	r3, [pc, #204]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b80:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005b82:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b86:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34005b88:	f022 0208 	bic.w	r2, r2, #8
34005b8c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
34005b90:	2208      	movs	r2, #8
34005b92:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34005b96:	68a3      	ldr	r3, [r4, #8]
34005b98:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34005b9c:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005b9e:	f7ff fd58 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
34005ba2:	f018 0f10 	tst.w	r8, #16
34005ba6:	d013      	beq.n	34005bd0 <HAL_DCMIPP_CSI_IRQHandler+0x570>
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
34005ba8:	06f8      	lsls	r0, r7, #27
34005baa:	d511      	bpl.n	34005bd0 <HAL_DCMIPP_CSI_IRQHandler+0x570>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34005bac:	4b27      	ldr	r3, [pc, #156]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005bae:	2101      	movs	r1, #1
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34005bb0:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005bb4:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34005bb6:	f022 0210 	bic.w	r2, r2, #16
34005bba:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
34005bbe:	2210      	movs	r2, #16
34005bc0:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34005bc4:	68a3      	ldr	r3, [r4, #8]
34005bc6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34005bca:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34005bcc:	f7ff fd41 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
34005bd0:	f418 7f80 	tst.w	r8, #256	@ 0x100
34005bd4:	d016      	beq.n	34005c04 <HAL_DCMIPP_CSI_IRQHandler+0x5a4>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
34005bd6:	05f9      	lsls	r1, r7, #23
34005bd8:	d514      	bpl.n	34005c04 <HAL_DCMIPP_CSI_IRQHandler+0x5a4>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34005bda:	4b1c      	ldr	r3, [pc, #112]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005bdc:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34005bde:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005be2:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34005be4:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
34005be8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
34005bec:	f44f 7280 	mov.w	r2, #256	@ 0x100
34005bf0:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34005bf4:	68a3      	ldr	r3, [r4, #8]
34005bf6:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34005bfa:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005bfc:	2304      	movs	r3, #4
34005bfe:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c00:	f7ff fd27 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
34005c04:	f418 7f00 	tst.w	r8, #512	@ 0x200
34005c08:	d016      	beq.n	34005c38 <HAL_DCMIPP_CSI_IRQHandler+0x5d8>
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34005c0a:	05ba      	lsls	r2, r7, #22
34005c0c:	d514      	bpl.n	34005c38 <HAL_DCMIPP_CSI_IRQHandler+0x5d8>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34005c0e:	4b0f      	ldr	r3, [pc, #60]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c10:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34005c12:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c16:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34005c18:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
34005c1c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
34005c20:	f44f 7200 	mov.w	r2, #512	@ 0x200
34005c24:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34005c28:	68a3      	ldr	r3, [r4, #8]
34005c2a:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
34005c2e:	60a3      	str	r3, [r4, #8]
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34005c30:	2304      	movs	r3, #4
34005c32:	7123      	strb	r3, [r4, #4]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c34:	f7ff fd0d 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
34005c38:	f418 6f80 	tst.w	r8, #1024	@ 0x400
34005c3c:	d017      	beq.n	34005c6e <HAL_DCMIPP_CSI_IRQHandler+0x60e>
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
34005c3e:	057b      	lsls	r3, r7, #21
34005c40:	d515      	bpl.n	34005c6e <HAL_DCMIPP_CSI_IRQHandler+0x60e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005c42:	4b02      	ldr	r3, [pc, #8]	@ (34005c4c <HAL_DCMIPP_CSI_IRQHandler+0x5ec>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c44:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005c46:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005c4a:	e001      	b.n	34005c50 <HAL_DCMIPP_CSI_IRQHandler+0x5f0>
34005c4c:	58006000 	.word	0x58006000
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c50:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34005c52:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
34005c56:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
34005c5a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34005c5e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34005c62:	68a3      	ldr	r3, [r4, #8]
34005c64:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34005c68:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c6a:	f7ff fcf2 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
34005c6e:	f418 6f00 	tst.w	r8, #2048	@ 0x800
34005c72:	d014      	beq.n	34005c9e <HAL_DCMIPP_CSI_IRQHandler+0x63e>
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34005c74:	0538      	lsls	r0, r7, #20
34005c76:	d512      	bpl.n	34005c9e <HAL_DCMIPP_CSI_IRQHandler+0x63e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34005c78:	4b1f      	ldr	r3, [pc, #124]	@ (34005cf8 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c7a:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34005c7c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c80:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34005c82:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34005c86:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
34005c8a:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34005c8e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34005c92:	68a3      	ldr	r3, [r4, #8]
34005c94:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34005c98:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005c9a:	f7ff fcda 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34005c9e:	f418 5f80 	tst.w	r8, #4096	@ 0x1000
34005ca2:	d014      	beq.n	34005cce <HAL_DCMIPP_CSI_IRQHandler+0x66e>
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34005ca4:	04f9      	lsls	r1, r7, #19
34005ca6:	d512      	bpl.n	34005cce <HAL_DCMIPP_CSI_IRQHandler+0x66e>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005ca8:	4b13      	ldr	r3, [pc, #76]	@ (34005cf8 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005caa:	2102      	movs	r1, #2
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005cac:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005cb0:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005cb2:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34005cb6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34005cba:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005cbe:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34005cc2:	68a3      	ldr	r3, [r4, #8]
34005cc4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34005cc8:	60a3      	str	r3, [r4, #8]
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34005cca:	f7ff fcc2 	bl	34005652 <HAL_DCMIPP_CSI_LineErrorCallback>
  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
34005cce:	03f2      	lsls	r2, r6, #15
34005cd0:	d50f      	bpl.n	34005cf2 <HAL_DCMIPP_CSI_IRQHandler+0x692>
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
34005cd2:	03eb      	lsls	r3, r5, #15
34005cd4:	d50d      	bpl.n	34005cf2 <HAL_DCMIPP_CSI_IRQHandler+0x692>
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34005cd6:	4b08      	ldr	r3, [pc, #32]	@ (34005cf8 <HAL_DCMIPP_CSI_IRQHandler+0x698>)
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34005cd8:	4620      	mov	r0, r4
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34005cda:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34005cde:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
34005ce2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34005ce6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34005cea:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34005cee:	f7ff fcb2 	bl	34005656 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
}
34005cf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34005cf6:	bf00      	nop
34005cf8:	58006000 	.word	0x58006000

34005cfc <HAL_DCMIPP_PIPE_SetCropConfig>:
{
34005cfc:	b570      	push	{r4, r5, r6, lr}
34005cfe:	460e      	mov	r6, r1
34005d00:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34005d02:	4605      	mov	r5, r0
34005d04:	b908      	cbnz	r0, 34005d0a <HAL_DCMIPP_PIPE_SetCropConfig+0xe>
    return HAL_ERROR;
34005d06:	2001      	movs	r0, #1
}
34005d08:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34005d0a:	2a00      	cmp	r2, #0
34005d0c:	d0fb      	beq.n	34005d06 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005d0e:	2902      	cmp	r1, #2
34005d10:	d904      	bls.n	34005d1c <HAL_DCMIPP_PIPE_SetCropConfig+0x20>
34005d12:	f640 61ef 	movw	r1, #3823	@ 0xeef
34005d16:	484a      	ldr	r0, [pc, #296]	@ (34005e40 <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005d18:	f7fc fc10 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_AREA(pCropConfig->PipeArea));
34005d1c:	6923      	ldr	r3, [r4, #16]
34005d1e:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
34005d22:	d004      	beq.n	34005d2e <HAL_DCMIPP_PIPE_SetCropConfig+0x32>
34005d24:	f44f 616f 	mov.w	r1, #3824	@ 0xef0
34005d28:	4845      	ldr	r0, [pc, #276]	@ (34005e40 <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005d2a:	f7fc fc07 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_HSTART(pCropConfig->HStart));
34005d2e:	6863      	ldr	r3, [r4, #4]
34005d30:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34005d34:	d304      	bcc.n	34005d40 <HAL_DCMIPP_PIPE_SetCropConfig+0x44>
34005d36:	f640 61f1 	movw	r1, #3825	@ 0xef1
34005d3a:	4841      	ldr	r0, [pc, #260]	@ (34005e40 <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005d3c:	f7fc fbfe 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_HSIZE(pCropConfig->HSize));
34005d40:	f640 72fe 	movw	r2, #4094	@ 0xffe
34005d44:	68e3      	ldr	r3, [r4, #12]
34005d46:	3b01      	subs	r3, #1
34005d48:	4293      	cmp	r3, r2
34005d4a:	d904      	bls.n	34005d56 <HAL_DCMIPP_PIPE_SetCropConfig+0x5a>
34005d4c:	f640 61f2 	movw	r1, #3826	@ 0xef2
34005d50:	483b      	ldr	r0, [pc, #236]	@ (34005e40 <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005d52:	f7fc fbf3 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_VSIZE(pCropConfig->VSize));
34005d56:	f640 72fe 	movw	r2, #4094	@ 0xffe
34005d5a:	68a3      	ldr	r3, [r4, #8]
34005d5c:	3b01      	subs	r3, #1
34005d5e:	4293      	cmp	r3, r2
34005d60:	d904      	bls.n	34005d6c <HAL_DCMIPP_PIPE_SetCropConfig+0x70>
34005d62:	f640 61f3 	movw	r1, #3827	@ 0xef3
34005d66:	4836      	ldr	r0, [pc, #216]	@ (34005e40 <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005d68:	f7fc fbe8 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_CROP_VSTART(pCropConfig->VStart));
34005d6c:	6823      	ldr	r3, [r4, #0]
34005d6e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34005d72:	d304      	bcc.n	34005d7e <HAL_DCMIPP_PIPE_SetCropConfig+0x82>
34005d74:	f640 61f4 	movw	r1, #3828	@ 0xef4
34005d78:	4831      	ldr	r0, [pc, #196]	@ (34005e40 <HAL_DCMIPP_PIPE_SetCropConfig+0x144>)
34005d7a:	f7fc fbdf 	bl	3400253c <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005d7e:	792b      	ldrb	r3, [r5, #4]
34005d80:	2b02      	cmp	r3, #2
34005d82:	d1c0      	bne.n	34005d06 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
    if (Pipe == DCMIPP_PIPE0)
34005d84:	bb3e      	cbnz	r6, 34005dd6 <HAL_DCMIPP_PIPE_SetCropConfig+0xda>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005d86:	682a      	ldr	r2, [r5, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005d88:	4b2e      	ldr	r3, [pc, #184]	@ (34005e44 <HAL_DCMIPP_PIPE_SetCropConfig+0x148>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005d8a:	f8d2 1104 	ldr.w	r1, [r2, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005d8e:	400b      	ands	r3, r1
34005d90:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34005d94:	d0b7      	beq.n	34005d06 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34005d96:	e9d4 0300 	ldrd	r0, r3, [r4]
34005d9a:	f8d2 1504 	ldr.w	r1, [r2, #1284]	@ 0x504
34005d9e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005da2:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005da6:	430b      	orrs	r3, r1
34005da8:	f8c2 3504 	str.w	r3, [r2, #1284]	@ 0x504
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34005dac:	f8d2 1508 	ldr.w	r1, [r2, #1288]	@ 0x508
34005db0:	e9d4 3003 	ldrd	r3, r0, [r4, #12]
34005db4:	f021 419f 	bic.w	r1, r1, #1333788672	@ 0x4f800000
34005db8:	4303      	orrs	r3, r0
34005dba:	f421 01fe 	bic.w	r1, r1, #8323072	@ 0x7f0000
34005dbe:	68a0      	ldr	r0, [r4, #8]
34005dc0:	f421 617f 	bic.w	r1, r1, #4080	@ 0xff0
34005dc4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005dc8:	f021 010f 	bic.w	r1, r1, #15
34005dcc:	430b      	orrs	r3, r1
34005dce:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
  return HAL_OK;
34005dd2:	2000      	movs	r0, #0
34005dd4:	e798      	b.n	34005d08 <HAL_DCMIPP_PIPE_SetCropConfig+0xc>
    else if (Pipe == DCMIPP_PIPE1)
34005dd6:	2e01      	cmp	r6, #1
34005dd8:	d117      	bne.n	34005e0a <HAL_DCMIPP_PIPE_SetCropConfig+0x10e>
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
34005dda:	e9d4 0300 	ldrd	r0, r3, [r4]
34005dde:	682a      	ldr	r2, [r5, #0]
34005de0:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005de4:	f8d2 1904 	ldr.w	r1, [r2, #2308]	@ 0x904
34005de8:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005dec:	430b      	orrs	r3, r1
34005dee:	f8c2 3904 	str.w	r3, [r2, #2308]	@ 0x904
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
34005df2:	f8d2 1908 	ldr.w	r1, [r2, #2312]	@ 0x908
34005df6:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34005dfa:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005dfe:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005e02:	430b      	orrs	r3, r1
34005e04:	f8c2 3908 	str.w	r3, [r2, #2312]	@ 0x908
34005e08:	e7e3      	b.n	34005dd2 <HAL_DCMIPP_PIPE_SetCropConfig+0xd6>
    else if (Pipe == DCMIPP_PIPE2)
34005e0a:	2e02      	cmp	r6, #2
34005e0c:	f47f af7b 	bne.w	34005d06 <HAL_DCMIPP_PIPE_SetCropConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
34005e10:	e9d4 0300 	ldrd	r0, r3, [r4]
34005e14:	682a      	ldr	r2, [r5, #0]
34005e16:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005e1a:	f8d2 1d04 	ldr.w	r1, [r2, #3332]	@ 0xd04
34005e1e:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005e22:	430b      	orrs	r3, r1
34005e24:	f8c2 3d04 	str.w	r3, [r2, #3332]	@ 0xd04
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
34005e28:	f8d2 1d08 	ldr.w	r1, [r2, #3336]	@ 0xd08
34005e2c:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34005e30:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34005e34:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34005e38:	430b      	orrs	r3, r1
34005e3a:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
34005e3e:	e7c8      	b.n	34005dd2 <HAL_DCMIPP_PIPE_SetCropConfig+0xd6>
34005e40:	3401c3e6 	.word	0x3401c3e6
34005e44:	00ff4000 	.word	0x00ff4000

34005e48 <HAL_DCMIPP_PIPE_EnableCrop>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005e48:	2902      	cmp	r1, #2
{
34005e4a:	b538      	push	{r3, r4, r5, lr}
34005e4c:	4605      	mov	r5, r0
34005e4e:	460c      	mov	r4, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005e50:	d904      	bls.n	34005e5c <HAL_DCMIPP_PIPE_EnableCrop+0x14>
34005e52:	f640 713f 	movw	r1, #3903	@ 0xf3f
34005e56:	481a      	ldr	r0, [pc, #104]	@ (34005ec0 <HAL_DCMIPP_PIPE_EnableCrop+0x78>)
34005e58:	f7fc fb70 	bl	3400253c <assert_failed>
  if (hdcmipp == NULL)
34005e5c:	b36d      	cbz	r5, 34005eba <HAL_DCMIPP_PIPE_EnableCrop+0x72>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005e5e:	792b      	ldrb	r3, [r5, #4]
34005e60:	2b02      	cmp	r3, #2
34005e62:	d12a      	bne.n	34005eba <HAL_DCMIPP_PIPE_EnableCrop+0x72>
    if (Pipe == DCMIPP_PIPE0)
34005e64:	b97c      	cbnz	r4, 34005e86 <HAL_DCMIPP_PIPE_EnableCrop+0x3e>
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005e66:	682b      	ldr	r3, [r5, #0]
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005e68:	4a16      	ldr	r2, [pc, #88]	@ (34005ec4 <HAL_DCMIPP_PIPE_EnableCrop+0x7c>)
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34005e6a:	f8d3 1104 	ldr.w	r1, [r3, #260]	@ 0x104
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34005e6e:	400a      	ands	r2, r1
34005e70:	f5b2 4f80 	cmp.w	r2, #16384	@ 0x4000
34005e74:	d021      	beq.n	34005eba <HAL_DCMIPP_PIPE_EnableCrop+0x72>
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34005e76:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34005e7a:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34005e7e:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
34005e82:	2000      	movs	r0, #0
}
34005e84:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE1)
34005e86:	2c01      	cmp	r4, #1
34005e88:	d10d      	bne.n	34005ea6 <HAL_DCMIPP_PIPE_EnableCrop+0x5e>
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34005e8a:	682b      	ldr	r3, [r5, #0]
    return HAL_ERROR;
34005e8c:	4620      	mov	r0, r4
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34005e8e:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
34005e92:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
34005e96:	d0f5      	beq.n	34005e84 <HAL_DCMIPP_PIPE_EnableCrop+0x3c>
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005e98:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34005e9c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34005ea0:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34005ea4:	e7ed      	b.n	34005e82 <HAL_DCMIPP_PIPE_EnableCrop+0x3a>
    else if (Pipe == DCMIPP_PIPE2)
34005ea6:	2c02      	cmp	r4, #2
34005ea8:	d107      	bne.n	34005eba <HAL_DCMIPP_PIPE_EnableCrop+0x72>
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005eaa:	682a      	ldr	r2, [r5, #0]
34005eac:	f8d2 3d08 	ldr.w	r3, [r2, #3336]	@ 0xd08
34005eb0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34005eb4:	f8c2 3d08 	str.w	r3, [r2, #3336]	@ 0xd08
34005eb8:	e7e3      	b.n	34005e82 <HAL_DCMIPP_PIPE_EnableCrop+0x3a>
    return HAL_ERROR;
34005eba:	2001      	movs	r0, #1
34005ebc:	e7e2      	b.n	34005e84 <HAL_DCMIPP_PIPE_EnableCrop+0x3c>
34005ebe:	bf00      	nop
34005ec0:	3401c3e6 	.word	0x3401c3e6
34005ec4:	00ff4000 	.word	0x00ff4000

34005ec8 <HAL_DCMIPP_PIPE_DisableCrop>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005ec8:	2902      	cmp	r1, #2
{
34005eca:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005ecc:	d906      	bls.n	34005edc <HAL_DCMIPP_PIPE_DisableCrop+0x14>
34005ece:	f640 717e 	movw	r1, #3966	@ 0xf7e
34005ed2:	4810      	ldr	r0, [pc, #64]	@ (34005f14 <HAL_DCMIPP_PIPE_DisableCrop+0x4c>)
34005ed4:	f7fc fb32 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34005ed8:	2001      	movs	r0, #1
34005eda:	e00a      	b.n	34005ef2 <HAL_DCMIPP_PIPE_DisableCrop+0x2a>
  if (hdcmipp == NULL)
34005edc:	2800      	cmp	r0, #0
34005ede:	d0fb      	beq.n	34005ed8 <HAL_DCMIPP_PIPE_DisableCrop+0x10>
  if (Pipe == DCMIPP_PIPE0)
34005ee0:	6803      	ldr	r3, [r0, #0]
34005ee2:	b939      	cbnz	r1, 34005ef4 <HAL_DCMIPP_PIPE_DisableCrop+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34005ee4:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34005ee8:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34005eec:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
  return HAL_OK;
34005ef0:	2000      	movs	r0, #0
}
34005ef2:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE1)
34005ef4:	2901      	cmp	r1, #1
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005ef6:	bf0b      	itete	eq
34005ef8:	f8d3 2908 	ldreq.w	r2, [r3, #2312]	@ 0x908
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005efc:	f8d3 2d08 	ldrne.w	r2, [r3, #3336]	@ 0xd08
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005f00:	f022 4200 	biceq.w	r2, r2, #2147483648	@ 0x80000000
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005f04:	f022 4200 	bicne.w	r2, r2, #2147483648	@ 0x80000000
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34005f08:	bf0c      	ite	eq
34005f0a:	f8c3 2908 	streq.w	r2, [r3, #2312]	@ 0x908
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34005f0e:	f8c3 2d08 	strne.w	r2, [r3, #3336]	@ 0xd08
34005f12:	e7ed      	b.n	34005ef0 <HAL_DCMIPP_PIPE_DisableCrop+0x28>
34005f14:	3401c3e6 	.word	0x3401c3e6

34005f18 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005f18:	2902      	cmp	r1, #2
{
34005f1a:	b570      	push	{r4, r5, r6, lr}
34005f1c:	4605      	mov	r5, r0
34005f1e:	460e      	mov	r6, r1
34005f20:	4614      	mov	r4, r2
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005f22:	d904      	bls.n	34005f2e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x16>
34005f24:	f241 0152 	movw	r1, #4178	@ 0x1052
34005f28:	4818      	ldr	r0, [pc, #96]	@ (34005f8c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
34005f2a:	f7fc fb07 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
34005f2e:	6822      	ldr	r2, [r4, #0]
34005f30:	b152      	cbz	r2, 34005f48 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x30>
34005f32:	2a18      	cmp	r2, #24
34005f34:	d803      	bhi.n	34005f3e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x26>
34005f36:	4b16      	ldr	r3, [pc, #88]	@ (34005f90 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x78>)
34005f38:	40d3      	lsrs	r3, r2
34005f3a:	07da      	lsls	r2, r3, #31
34005f3c:	d404      	bmi.n	34005f48 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x30>
34005f3e:	f241 0153 	movw	r1, #4179	@ 0x1053
34005f42:	4812      	ldr	r0, [pc, #72]	@ (34005f8c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
34005f44:	f7fc fafa 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));
34005f48:	6862      	ldr	r2, [r4, #4]
34005f4a:	b152      	cbz	r2, 34005f62 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x4a>
34005f4c:	2a06      	cmp	r2, #6
34005f4e:	d803      	bhi.n	34005f58 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x40>
34005f50:	2354      	movs	r3, #84	@ 0x54
34005f52:	40d3      	lsrs	r3, r2
34005f54:	07db      	lsls	r3, r3, #31
34005f56:	d404      	bmi.n	34005f62 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x4a>
34005f58:	f241 0154 	movw	r1, #4180	@ 0x1054
34005f5c:	480b      	ldr	r0, [pc, #44]	@ (34005f8c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x74>)
34005f5e:	f7fc faed 	bl	3400253c <assert_failed>
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
34005f62:	b18d      	cbz	r5, 34005f88 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34005f64:	792b      	ldrb	r3, [r5, #4]
34005f66:	2b02      	cmp	r3, #2
34005f68:	d10e      	bne.n	34005f88 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
    if (Pipe == DCMIPP_PIPE1)
34005f6a:	2e01      	cmp	r6, #1
34005f6c:	d10c      	bne.n	34005f88 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x70>
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34005f6e:	e9d4 3000 	ldrd	r3, r0, [r4]
34005f72:	4303      	orrs	r3, r0
  return HAL_OK;
34005f74:	2000      	movs	r0, #0
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34005f76:	6829      	ldr	r1, [r5, #0]
34005f78:	f8d1 2830 	ldr.w	r2, [r1, #2096]	@ 0x830
34005f7c:	f022 021e 	bic.w	r2, r2, #30
34005f80:	4313      	orrs	r3, r2
34005f82:	f8c1 3830 	str.w	r3, [r1, #2096]	@ 0x830
}
34005f86:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
34005f88:	2001      	movs	r0, #1
34005f8a:	e7fc      	b.n	34005f86 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x6e>
34005f8c:	3401c3e6 	.word	0x3401c3e6
34005f90:	01010100 	.word	0x01010100

34005f94 <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005f94:	2902      	cmp	r1, #2
{
34005f96:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005f98:	d906      	bls.n	34005fa8 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x14>
34005f9a:	f241 017a 	movw	r1, #4218	@ 0x107a
34005f9e:	4809      	ldr	r0, [pc, #36]	@ (34005fc4 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x30>)
34005fa0:	f7fc facc 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34005fa4:	2001      	movs	r0, #1
}
34005fa6:	bd08      	pop	{r3, pc}
  if (hdcmipp == NULL)
34005fa8:	2800      	cmp	r0, #0
34005faa:	d0fb      	beq.n	34005fa4 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x10>
  if (Pipe == DCMIPP_PIPE1)
34005fac:	2901      	cmp	r1, #1
34005fae:	d1f9      	bne.n	34005fa4 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x10>
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34005fb0:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34005fb2:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34005fb4:	f8d2 3830 	ldr.w	r3, [r2, #2096]	@ 0x830
34005fb8:	f043 0301 	orr.w	r3, r3, #1
34005fbc:	f8c2 3830 	str.w	r3, [r2, #2096]	@ 0x830
  return HAL_OK;
34005fc0:	e7f1      	b.n	34005fa6 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x12>
34005fc2:	bf00      	nop
34005fc4:	3401c3e6 	.word	0x3401c3e6

34005fc8 <HAL_DCMIPP_PIPE_SetDecimationConfig>:
{
34005fc8:	b570      	push	{r4, r5, r6, lr}
34005fca:	460e      	mov	r6, r1
34005fcc:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34005fce:	4605      	mov	r5, r0
34005fd0:	b908      	cbnz	r0, 34005fd6 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xe>
    return HAL_ERROR;
34005fd2:	2001      	movs	r0, #1
}
34005fd4:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34005fd6:	2902      	cmp	r1, #2
34005fd8:	d904      	bls.n	34005fe4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x1c>
34005fda:	f241 01bc 	movw	r1, #4284	@ 0x10bc
34005fde:	481e      	ldr	r0, [pc, #120]	@ (34006058 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34005fe0:	f7fc faac 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
34005fe4:	6822      	ldr	r2, [r4, #0]
34005fe6:	b152      	cbz	r2, 34005ffe <HAL_DCMIPP_PIPE_SetDecimationConfig+0x36>
34005fe8:	2a18      	cmp	r2, #24
34005fea:	d803      	bhi.n	34005ff4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x2c>
34005fec:	4b1b      	ldr	r3, [pc, #108]	@ (3400605c <HAL_DCMIPP_PIPE_SetDecimationConfig+0x94>)
34005fee:	40d3      	lsrs	r3, r2
34005ff0:	07da      	lsls	r2, r3, #31
34005ff2:	d404      	bmi.n	34005ffe <HAL_DCMIPP_PIPE_SetDecimationConfig+0x36>
34005ff4:	f241 01bd 	movw	r1, #4285	@ 0x10bd
34005ff8:	4817      	ldr	r0, [pc, #92]	@ (34006058 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34005ffa:	f7fc fa9f 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));
34005ffe:	6862      	ldr	r2, [r4, #4]
34006000:	b152      	cbz	r2, 34006018 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x50>
34006002:	2a06      	cmp	r2, #6
34006004:	d803      	bhi.n	3400600e <HAL_DCMIPP_PIPE_SetDecimationConfig+0x46>
34006006:	2354      	movs	r3, #84	@ 0x54
34006008:	40d3      	lsrs	r3, r2
3400600a:	07db      	lsls	r3, r3, #31
3400600c:	d404      	bmi.n	34006018 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x50>
3400600e:	f241 01be 	movw	r1, #4286	@ 0x10be
34006012:	4811      	ldr	r0, [pc, #68]	@ (34006058 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x90>)
34006014:	f7fc fa92 	bl	3400253c <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006018:	792b      	ldrb	r3, [r5, #4]
3400601a:	2b02      	cmp	r3, #2
3400601c:	d1d9      	bne.n	34005fd2 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xa>
    if (Pipe == DCMIPP_PIPE1)
3400601e:	2e01      	cmp	r6, #1
34006020:	d10c      	bne.n	3400603c <HAL_DCMIPP_PIPE_SetDecimationConfig+0x74>
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
34006022:	e9d4 3000 	ldrd	r3, r0, [r4]
34006026:	6829      	ldr	r1, [r5, #0]
34006028:	4303      	orrs	r3, r0
3400602a:	f8d1 290c 	ldr.w	r2, [r1, #2316]	@ 0x90c
3400602e:	f022 021e 	bic.w	r2, r2, #30
34006032:	4313      	orrs	r3, r2
34006034:	f8c1 390c 	str.w	r3, [r1, #2316]	@ 0x90c
  return HAL_OK;
34006038:	2000      	movs	r0, #0
3400603a:	e7cb      	b.n	34005fd4 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xc>
    else if (Pipe == DCMIPP_PIPE2)
3400603c:	2e02      	cmp	r6, #2
3400603e:	d1c8      	bne.n	34005fd2 <HAL_DCMIPP_PIPE_SetDecimationConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
34006040:	e9d4 3000 	ldrd	r3, r0, [r4]
34006044:	6829      	ldr	r1, [r5, #0]
34006046:	4303      	orrs	r3, r0
34006048:	f8d1 2d0c 	ldr.w	r2, [r1, #3340]	@ 0xd0c
3400604c:	f022 021e 	bic.w	r2, r2, #30
34006050:	4313      	orrs	r3, r2
34006052:	f8c1 3d0c 	str.w	r3, [r1, #3340]	@ 0xd0c
34006056:	e7ef      	b.n	34006038 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x70>
34006058:	3401c3e6 	.word	0x3401c3e6
3400605c:	01010100 	.word	0x01010100

34006060 <HAL_DCMIPP_PIPE_EnableDecimation>:
{
34006060:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006062:	b130      	cbz	r0, 34006072 <HAL_DCMIPP_PIPE_EnableDecimation+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006064:	2902      	cmp	r1, #2
34006066:	d906      	bls.n	34006076 <HAL_DCMIPP_PIPE_EnableDecimation+0x16>
34006068:	f241 01e9 	movw	r1, #4329	@ 0x10e9
3400606c:	480c      	ldr	r0, [pc, #48]	@ (340060a0 <HAL_DCMIPP_PIPE_EnableDecimation+0x40>)
3400606e:	f7fc fa65 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006072:	2001      	movs	r0, #1
34006074:	e009      	b.n	3400608a <HAL_DCMIPP_PIPE_EnableDecimation+0x2a>
  if (Pipe == DCMIPP_PIPE1)
34006076:	2901      	cmp	r1, #1
34006078:	d108      	bne.n	3400608c <HAL_DCMIPP_PIPE_EnableDecimation+0x2c>
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
3400607a:	6802      	ldr	r2, [r0, #0]
3400607c:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
34006080:	f043 0301 	orr.w	r3, r3, #1
34006084:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
34006088:	2000      	movs	r0, #0
}
3400608a:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
3400608c:	2902      	cmp	r1, #2
3400608e:	d1f0      	bne.n	34006072 <HAL_DCMIPP_PIPE_EnableDecimation+0x12>
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34006090:	6802      	ldr	r2, [r0, #0]
34006092:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
34006096:	f043 0301 	orr.w	r3, r3, #1
3400609a:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
3400609e:	e7f3      	b.n	34006088 <HAL_DCMIPP_PIPE_EnableDecimation+0x28>
340060a0:	3401c3e6 	.word	0x3401c3e6

340060a4 <HAL_DCMIPP_PIPE_DisableDecimation>:
{
340060a4:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340060a6:	b130      	cbz	r0, 340060b6 <HAL_DCMIPP_PIPE_DisableDecimation+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340060a8:	2902      	cmp	r1, #2
340060aa:	d906      	bls.n	340060ba <HAL_DCMIPP_PIPE_DisableDecimation+0x16>
340060ac:	f241 110a 	movw	r1, #4362	@ 0x110a
340060b0:	480c      	ldr	r0, [pc, #48]	@ (340060e4 <HAL_DCMIPP_PIPE_DisableDecimation+0x40>)
340060b2:	f7fc fa43 	bl	3400253c <assert_failed>
    return HAL_ERROR;
340060b6:	2001      	movs	r0, #1
340060b8:	e009      	b.n	340060ce <HAL_DCMIPP_PIPE_DisableDecimation+0x2a>
  if (Pipe == DCMIPP_PIPE1)
340060ba:	2901      	cmp	r1, #1
340060bc:	d108      	bne.n	340060d0 <HAL_DCMIPP_PIPE_DisableDecimation+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
340060be:	6802      	ldr	r2, [r0, #0]
340060c0:	f8d2 390c 	ldr.w	r3, [r2, #2316]	@ 0x90c
340060c4:	f023 0301 	bic.w	r3, r3, #1
340060c8:	f8c2 390c 	str.w	r3, [r2, #2316]	@ 0x90c
  return HAL_OK;
340060cc:	2000      	movs	r0, #0
}
340060ce:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
340060d0:	2902      	cmp	r1, #2
340060d2:	d1f0      	bne.n	340060b6 <HAL_DCMIPP_PIPE_DisableDecimation+0x12>
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
340060d4:	6802      	ldr	r2, [r0, #0]
340060d6:	f8d2 3d0c 	ldr.w	r3, [r2, #3340]	@ 0xd0c
340060da:	f023 0301 	bic.w	r3, r3, #1
340060de:	f8c2 3d0c 	str.w	r3, [r2, #3340]	@ 0xd0c
340060e2:	e7f3      	b.n	340060cc <HAL_DCMIPP_PIPE_DisableDecimation+0x28>
340060e4:	3401c3e6 	.word	0x3401c3e6

340060e8 <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
{
340060e8:	b570      	push	{r4, r5, r6, lr}
340060ea:	460e      	mov	r6, r1
340060ec:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
340060ee:	4605      	mov	r5, r0
340060f0:	b908      	cbnz	r0, 340060f6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xe>
    return HAL_ERROR;
340060f2:	2001      	movs	r0, #1
}
340060f4:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
340060f6:	2a00      	cmp	r2, #0
340060f8:	d0fb      	beq.n	340060f2 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340060fa:	2902      	cmp	r1, #2
340060fc:	d904      	bls.n	34006108 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x20>
340060fe:	f241 1134 	movw	r1, #4404	@ 0x1134
34006102:	483f      	ldr	r0, [pc, #252]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006104:	f7fc fa1a 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_DIV_FACTOR(pDownsizeConfig->HDivFactor));
34006108:	6963      	ldr	r3, [r4, #20]
3400610a:	3b80      	subs	r3, #128	@ 0x80
3400610c:	f5b3 7f60 	cmp.w	r3, #896	@ 0x380
34006110:	d304      	bcc.n	3400611c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x34>
34006112:	f241 1135 	movw	r1, #4405	@ 0x1135
34006116:	483a      	ldr	r0, [pc, #232]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006118:	f7fc fa10 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_DIV_FACTOR(pDownsizeConfig->VDivFactor));
3400611c:	6923      	ldr	r3, [r4, #16]
3400611e:	3b80      	subs	r3, #128	@ 0x80
34006120:	f5b3 7f60 	cmp.w	r3, #896	@ 0x380
34006124:	d304      	bcc.n	34006130 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x48>
34006126:	f241 1136 	movw	r1, #4406	@ 0x1136
3400612a:	4835      	ldr	r0, [pc, #212]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
3400612c:	f7fc fa06 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->HRatio));
34006130:	68e3      	ldr	r3, [r4, #12]
34006132:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34006136:	d304      	bcc.n	34006142 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x5a>
34006138:	f241 1137 	movw	r1, #4407	@ 0x1137
3400613c:	4830      	ldr	r0, [pc, #192]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
3400613e:	f7fc f9fd 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->VRatio));
34006142:	68a3      	ldr	r3, [r4, #8]
34006144:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34006148:	d304      	bcc.n	34006154 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x6c>
3400614a:	f241 1138 	movw	r1, #4408	@ 0x1138
3400614e:	482c      	ldr	r0, [pc, #176]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006150:	f7fc f9f4 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->HSize));
34006154:	6863      	ldr	r3, [r4, #4]
34006156:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400615a:	d304      	bcc.n	34006166 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x7e>
3400615c:	f241 1139 	movw	r1, #4409	@ 0x1139
34006160:	4827      	ldr	r0, [pc, #156]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006162:	f7fc f9eb 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->VSize));
34006166:	6823      	ldr	r3, [r4, #0]
34006168:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3400616c:	d304      	bcc.n	34006178 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x90>
3400616e:	f241 113a 	movw	r1, #4410	@ 0x113a
34006172:	4823      	ldr	r0, [pc, #140]	@ (34006200 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x118>)
34006174:	f7fc f9e2 	bl	3400253c <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006178:	792b      	ldrb	r3, [r5, #4]
3400617a:	2b02      	cmp	r3, #2
3400617c:	d1b9      	bne.n	340060f2 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
    if (Pipe == DCMIPP_PIPE1)
3400617e:	2e01      	cmp	r6, #1
34006180:	d11e      	bne.n	340061c0 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xd8>
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
34006182:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
34006186:	682b      	ldr	r3, [r5, #0]
34006188:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400618c:	f8d3 1910 	ldr.w	r1, [r3, #2320]	@ 0x910
34006190:	f001 21fc 	and.w	r1, r1, #4227922944	@ 0xfc00fc00
34006194:	430a      	orrs	r2, r1
34006196:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
3400619a:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
3400619e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340061a2:	f8c3 2914 	str.w	r2, [r3, #2324]	@ 0x914
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
340061a6:	f8d3 1918 	ldr.w	r1, [r3, #2328]	@ 0x918
340061aa:	e9d4 0200 	ldrd	r0, r2, [r4]
340061ae:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340061b2:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340061b6:	430a      	orrs	r2, r1
340061b8:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
  return HAL_OK;
340061bc:	2000      	movs	r0, #0
340061be:	e799      	b.n	340060f4 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xc>
    else if (Pipe == DCMIPP_PIPE2)
340061c0:	2e02      	cmp	r6, #2
340061c2:	d196      	bne.n	340060f2 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xa>
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
340061c4:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
340061c8:	682b      	ldr	r3, [r5, #0]
340061ca:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340061ce:	f8d3 1d10 	ldr.w	r1, [r3, #3344]	@ 0xd10
340061d2:	f001 21fc 	and.w	r1, r1, #4227922944	@ 0xfc00fc00
340061d6:	430a      	orrs	r2, r1
340061d8:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
340061dc:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
340061e0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340061e4:	f8c3 2d14 	str.w	r2, [r3, #3348]	@ 0xd14
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
340061e8:	f8d3 1d18 	ldr.w	r1, [r3, #3352]	@ 0xd18
340061ec:	e9d4 0200 	ldrd	r0, r2, [r4]
340061f0:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
340061f4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340061f8:	430a      	orrs	r2, r1
340061fa:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
340061fe:	e7dd      	b.n	340061bc <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xd4>
34006200:	3401c3e6 	.word	0x3401c3e6

34006204 <HAL_DCMIPP_PIPE_EnableDownsize>:
{
34006204:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006206:	b130      	cbz	r0, 34006216 <HAL_DCMIPP_PIPE_EnableDownsize+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006208:	2902      	cmp	r1, #2
3400620a:	d906      	bls.n	3400621a <HAL_DCMIPP_PIPE_EnableDownsize+0x16>
3400620c:	f241 117a 	movw	r1, #4474	@ 0x117a
34006210:	480c      	ldr	r0, [pc, #48]	@ (34006244 <HAL_DCMIPP_PIPE_EnableDownsize+0x40>)
34006212:	f7fc f993 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006216:	2001      	movs	r0, #1
34006218:	e009      	b.n	3400622e <HAL_DCMIPP_PIPE_EnableDownsize+0x2a>
  if (Pipe == DCMIPP_PIPE1)
3400621a:	2901      	cmp	r1, #1
3400621c:	d108      	bne.n	34006230 <HAL_DCMIPP_PIPE_EnableDownsize+0x2c>
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
3400621e:	6802      	ldr	r2, [r0, #0]
34006220:	f8d2 3910 	ldr.w	r3, [r2, #2320]	@ 0x910
34006224:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34006228:	f8c2 3910 	str.w	r3, [r2, #2320]	@ 0x910
  return HAL_OK;
3400622c:	2000      	movs	r0, #0
}
3400622e:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34006230:	2902      	cmp	r1, #2
34006232:	d1f0      	bne.n	34006216 <HAL_DCMIPP_PIPE_EnableDownsize+0x12>
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
34006234:	6802      	ldr	r2, [r0, #0]
34006236:	f8d2 3d10 	ldr.w	r3, [r2, #3344]	@ 0xd10
3400623a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
3400623e:	f8c2 3d10 	str.w	r3, [r2, #3344]	@ 0xd10
34006242:	e7f3      	b.n	3400622c <HAL_DCMIPP_PIPE_EnableDownsize+0x28>
34006244:	3401c3e6 	.word	0x3401c3e6

34006248 <HAL_DCMIPP_PIPE_EnableGammaConversion>:
{
34006248:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400624a:	b130      	cbz	r0, 3400625a <HAL_DCMIPP_PIPE_EnableGammaConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400624c:	2902      	cmp	r1, #2
3400624e:	d906      	bls.n	3400625e <HAL_DCMIPP_PIPE_EnableGammaConversion+0x16>
34006250:	f241 11bc 	movw	r1, #4540	@ 0x11bc
34006254:	480c      	ldr	r0, [pc, #48]	@ (34006288 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x40>)
34006256:	f7fc f971 	bl	3400253c <assert_failed>
    return HAL_ERROR;
3400625a:	2001      	movs	r0, #1
3400625c:	e009      	b.n	34006272 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2a>
  if (Pipe == DCMIPP_PIPE1)
3400625e:	2901      	cmp	r1, #1
34006260:	d108      	bne.n	34006274 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x2c>
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
34006262:	6802      	ldr	r2, [r0, #0]
34006264:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
34006268:	f043 0301 	orr.w	r3, r3, #1
3400626c:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
34006270:	2000      	movs	r0, #0
}
34006272:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
34006274:	2902      	cmp	r1, #2
34006276:	d1f0      	bne.n	3400625a <HAL_DCMIPP_PIPE_EnableGammaConversion+0x12>
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34006278:	6802      	ldr	r2, [r0, #0]
3400627a:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
3400627e:	f043 0301 	orr.w	r3, r3, #1
34006282:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
34006286:	e7f3      	b.n	34006270 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x28>
34006288:	3401c3e6 	.word	0x3401c3e6

3400628c <HAL_DCMIPP_PIPE_DisableGammaConversion>:
{
3400628c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400628e:	b130      	cbz	r0, 3400629e <HAL_DCMIPP_PIPE_DisableGammaConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006290:	2902      	cmp	r1, #2
34006292:	d906      	bls.n	340062a2 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x16>
34006294:	f241 11dd 	movw	r1, #4573	@ 0x11dd
34006298:	480c      	ldr	r0, [pc, #48]	@ (340062cc <HAL_DCMIPP_PIPE_DisableGammaConversion+0x40>)
3400629a:	f7fc f94f 	bl	3400253c <assert_failed>
    return HAL_ERROR;
3400629e:	2001      	movs	r0, #1
340062a0:	e009      	b.n	340062b6 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2a>
  if (Pipe == DCMIPP_PIPE1)
340062a2:	2901      	cmp	r1, #1
340062a4:	d108      	bne.n	340062b8 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x2c>
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
340062a6:	6802      	ldr	r2, [r0, #0]
340062a8:	f8d2 3970 	ldr.w	r3, [r2, #2416]	@ 0x970
340062ac:	f023 0301 	bic.w	r3, r3, #1
340062b0:	f8c2 3970 	str.w	r3, [r2, #2416]	@ 0x970
  return HAL_OK;
340062b4:	2000      	movs	r0, #0
}
340062b6:	bd08      	pop	{r3, pc}
  else if (Pipe == DCMIPP_PIPE2)
340062b8:	2902      	cmp	r1, #2
340062ba:	d1f0      	bne.n	3400629e <HAL_DCMIPP_PIPE_DisableGammaConversion+0x12>
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
340062bc:	6802      	ldr	r2, [r0, #0]
340062be:	f8d2 3d70 	ldr.w	r3, [r2, #3440]	@ 0xd70
340062c2:	f023 0301 	bic.w	r3, r3, #1
340062c6:	f8c2 3d70 	str.w	r3, [r2, #3440]	@ 0xd70
340062ca:	e7f3      	b.n	340062b4 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x28>
340062cc:	3401c3e6 	.word	0x3401c3e6

340062d0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
{
340062d0:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340062d2:	4a13      	ldr	r2, [pc, #76]	@ (34006320 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x50>)
340062d4:	6803      	ldr	r3, [r0, #0]
{
340062d6:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340062d8:	4293      	cmp	r3, r2
{
340062da:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340062dc:	d008      	beq.n	340062f0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x20>
340062de:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340062e2:	4293      	cmp	r3, r2
340062e4:	d004      	beq.n	340062f0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x20>
340062e6:	f241 11f8 	movw	r1, #4600	@ 0x11f8
340062ea:	480e      	ldr	r0, [pc, #56]	@ (34006324 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x54>)
340062ec:	f7fc f926 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340062f0:	2d02      	cmp	r5, #2
340062f2:	d906      	bls.n	34006302 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x32>
340062f4:	f241 11f9 	movw	r1, #4601	@ 0x11f9
340062f8:	480a      	ldr	r0, [pc, #40]	@ (34006324 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x54>)
340062fa:	f7fc f91f 	bl	3400253c <assert_failed>
    return 0;
340062fe:	2000      	movs	r0, #0
}
34006300:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
34006302:	2d01      	cmp	r5, #1
34006304:	d105      	bne.n	34006312 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x42>
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
34006306:	6823      	ldr	r3, [r4, #0]
34006308:	f8d3 0970 	ldr.w	r0, [r3, #2416]	@ 0x970
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
3400630c:	f000 0001 	and.w	r0, r0, #1
34006310:	e7f6      	b.n	34006300 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x30>
  else if (Pipe == DCMIPP_PIPE2)
34006312:	2d02      	cmp	r5, #2
34006314:	d1f3      	bne.n	340062fe <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
34006316:	6823      	ldr	r3, [r4, #0]
34006318:	f8d3 0d70 	ldr.w	r0, [r3, #3440]	@ 0xd70
3400631c:	e7f6      	b.n	3400630c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x3c>
3400631e:	bf00      	nop
34006320:	58002000 	.word	0x58002000
34006324:	3401c3e6 	.word	0x3401c3e6

34006328 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
{
34006328:	b570      	push	{r4, r5, r6, lr}
3400632a:	460e      	mov	r6, r1
3400632c:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
3400632e:	4605      	mov	r5, r0
34006330:	b908      	cbnz	r0, 34006336 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xe>
    return HAL_ERROR;
34006332:	2001      	movs	r0, #1
}
34006334:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
34006336:	2a00      	cmp	r2, #0
34006338:	d0fb      	beq.n	34006332 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400633a:	2902      	cmp	r1, #2
3400633c:	d904      	bls.n	34006348 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x20>
3400633e:	f241 211e 	movw	r1, #4638	@ 0x121e
34006342:	4824      	ldr	r0, [pc, #144]	@ (340063d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
34006344:	f7fc f8fa 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_RAW_TYPE(pRawBayer2RGBConfig->RawBayerType));
34006348:	68a2      	ldr	r2, [r4, #8]
3400634a:	b152      	cbz	r2, 34006362 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3a>
3400634c:	2a06      	cmp	r2, #6
3400634e:	d803      	bhi.n	34006358 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x30>
34006350:	2354      	movs	r3, #84	@ 0x54
34006352:	40d3      	lsrs	r3, r2
34006354:	07db      	lsls	r3, r3, #31
34006356:	d404      	bmi.n	34006362 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x3a>
34006358:	f241 211f 	movw	r1, #4639	@ 0x121f
3400635c:	481d      	ldr	r0, [pc, #116]	@ (340063d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400635e:	f7fc f8ed 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->PeakStrength));
34006362:	68e3      	ldr	r3, [r4, #12]
34006364:	2b07      	cmp	r3, #7
34006366:	d904      	bls.n	34006372 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x4a>
34006368:	f44f 5191 	mov.w	r1, #4640	@ 0x1220
3400636c:	4819      	ldr	r0, [pc, #100]	@ (340063d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400636e:	f7fc f8e5 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->VLineStrength));
34006372:	6823      	ldr	r3, [r4, #0]
34006374:	2b07      	cmp	r3, #7
34006376:	d904      	bls.n	34006382 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x5a>
34006378:	f241 2121 	movw	r1, #4641	@ 0x1221
3400637c:	4815      	ldr	r0, [pc, #84]	@ (340063d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400637e:	f7fc f8dd 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->HLineStrength));
34006382:	6863      	ldr	r3, [r4, #4]
34006384:	2b07      	cmp	r3, #7
34006386:	d904      	bls.n	34006392 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x6a>
34006388:	f241 2122 	movw	r1, #4642	@ 0x1222
3400638c:	4811      	ldr	r0, [pc, #68]	@ (340063d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400638e:	f7fc f8d5 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->EdgeStrength));
34006392:	6923      	ldr	r3, [r4, #16]
34006394:	2b07      	cmp	r3, #7
34006396:	d904      	bls.n	340063a2 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x7a>
34006398:	f241 2123 	movw	r1, #4643	@ 0x1223
3400639c:	480d      	ldr	r0, [pc, #52]	@ (340063d4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xac>)
3400639e:	f7fc f8cd 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
340063a2:	2e01      	cmp	r6, #1
340063a4:	d1c5      	bne.n	34006332 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xa>
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
340063a6:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
340063aa:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
340063ac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
340063b0:	68a2      	ldr	r2, [r4, #8]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340063b2:	6829      	ldr	r1, [r5, #0]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
340063b4:	4313      	orrs	r3, r2
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
340063b6:	6822      	ldr	r2, [r4, #0]
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340063b8:	f8d1 0870 	ldr.w	r0, [r1, #2160]	@ 0x870
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
340063bc:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
340063c0:	6862      	ldr	r2, [r4, #4]
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
340063c2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340063c6:	4a04      	ldr	r2, [pc, #16]	@ (340063d8 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xb0>)
340063c8:	4002      	ands	r2, r0
340063ca:	4313      	orrs	r3, r2
  return HAL_OK;
340063cc:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
340063ce:	f8c1 3870 	str.w	r3, [r1, #2160]	@ 0x870
  return HAL_OK;
340063d2:	e7af      	b.n	34006334 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0xc>
340063d4:	3401c3e6 	.word	0x3401c3e6
340063d8:	8888fff9 	.word	0x8888fff9

340063dc <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
{
340063dc:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340063de:	b130      	cbz	r0, 340063ee <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340063e0:	2902      	cmp	r1, #2
340063e2:	d906      	bls.n	340063f2 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x16>
340063e4:	f241 214a 	movw	r1, #4682	@ 0x124a
340063e8:	4807      	ldr	r0, [pc, #28]	@ (34006408 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x2c>)
340063ea:	f7fc f8a7 	bl	3400253c <assert_failed>
    return HAL_ERROR;
340063ee:	2001      	movs	r0, #1
}
340063f0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340063f2:	2901      	cmp	r1, #1
340063f4:	d1fb      	bne.n	340063ee <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x12>
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340063f6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340063f8:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
340063fa:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
340063fe:	f043 0301 	orr.w	r3, r3, #1
34006402:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
34006406:	e7f3      	b.n	340063f0 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x14>
34006408:	3401c3e6 	.word	0x3401c3e6

3400640c <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
{
3400640c:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
3400640e:	b130      	cbz	r0, 3400641e <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006410:	2902      	cmp	r1, #2
34006412:	d906      	bls.n	34006422 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x16>
34006414:	f241 2167 	movw	r1, #4711	@ 0x1267
34006418:	4807      	ldr	r0, [pc, #28]	@ (34006438 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x2c>)
3400641a:	f7fc f88f 	bl	3400253c <assert_failed>
    return HAL_ERROR;
3400641e:	2001      	movs	r0, #1
}
34006420:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006422:	2901      	cmp	r1, #1
34006424:	d1fb      	bne.n	3400641e <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34006426:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006428:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
3400642a:	f8d2 3870 	ldr.w	r3, [r2, #2160]	@ 0x870
3400642e:	f023 0301 	bic.w	r3, r3, #1
34006432:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  return HAL_OK;
34006436:	e7f3      	b.n	34006420 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x14>
34006438:	3401c3e6 	.word	0x3401c3e6

3400643c <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
{
3400643c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400643e:	460f      	mov	r7, r1
34006440:	4615      	mov	r5, r2
34006442:	461c      	mov	r4, r3
  if (hdcmipp == NULL)
34006444:	4606      	mov	r6, r0
34006446:	b908      	cbnz	r0, 3400644c <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x10>
    return HAL_ERROR;
34006448:	2001      	movs	r0, #1
}
3400644a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400644c:	2902      	cmp	r1, #2
3400644e:	d904      	bls.n	3400645a <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x1e>
34006450:	f241 2189 	movw	r1, #4745	@ 0x1289
34006454:	480f      	ldr	r0, [pc, #60]	@ (34006494 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006456:	f7fc f871 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_NB_FIRST_LINES(NbFirstLines));
3400645a:	2d07      	cmp	r5, #7
3400645c:	d904      	bls.n	34006468 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x2c>
3400645e:	f241 218a 	movw	r1, #4746	@ 0x128a
34006462:	480c      	ldr	r0, [pc, #48]	@ (34006494 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006464:	f7fc f86a 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_NB_LAST_LINES(NbLastLines));
34006468:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
3400646c:	d304      	bcc.n	34006478 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x3c>
3400646e:	f241 218b 	movw	r1, #4747	@ 0x128b
34006472:	4808      	ldr	r0, [pc, #32]	@ (34006494 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x58>)
34006474:	f7fc f862 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006478:	2f01      	cmp	r7, #1
3400647a:	d1e5      	bne.n	34006448 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0xc>
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
3400647c:	6832      	ldr	r2, [r6, #0]
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
3400647e:	ea44 3405 	orr.w	r4, r4, r5, lsl #12
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34006482:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
34006486:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34006488:	f36f 030e 	bfc	r3, #0, #15
3400648c:	431c      	orrs	r4, r3
3400648e:	f8c2 4820 	str.w	r4, [r2, #2080]	@ 0x820
  return HAL_OK;
34006492:	e7da      	b.n	3400644a <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0xe>
34006494:	3401c3e6 	.word	0x3401c3e6

34006498 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  if (hdcmipp == NULL)
34006498:	b150      	cbz	r0, 340064b0 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
3400649a:	2901      	cmp	r1, #1
3400649c:	d108      	bne.n	340064b0 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x18>
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
3400649e:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340064a0:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340064a2:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
340064a6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
340064aa:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
340064ae:	4770      	bx	lr
    return HAL_ERROR;
340064b0:	2001      	movs	r0, #1
}
340064b2:	4770      	bx	lr

340064b4 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  if (hdcmipp == NULL)
340064b4:	b150      	cbz	r0, 340064cc <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
  if (Pipe == DCMIPP_PIPE1)
340064b6:	2901      	cmp	r1, #1
340064b8:	d108      	bne.n	340064cc <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x18>
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340064ba:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340064bc:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
340064be:	f8d2 3820 	ldr.w	r3, [r2, #2080]	@ 0x820
340064c2:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
340064c6:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  return HAL_OK;
340064ca:	4770      	bx	lr
    return HAL_ERROR;
340064cc:	2001      	movs	r0, #1
}
340064ce:	4770      	bx	lr

340064d0 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
{
340064d0:	b570      	push	{r4, r5, r6, lr}
340064d2:	460e      	mov	r6, r1
340064d4:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
340064d6:	4605      	mov	r5, r0
340064d8:	b908      	cbnz	r0, 340064de <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xe>
    return HAL_ERROR;
340064da:	2001      	movs	r0, #1
}
340064dc:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
340064de:	2902      	cmp	r1, #2
340064e0:	d918      	bls.n	34006514 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x44>
340064e2:	f241 21ea 	movw	r1, #4842	@ 0x12ea
340064e6:	480d      	ldr	r0, [pc, #52]	@ (3400651c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x4c>)
340064e8:	f7fc f828 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));
340064ec:	2c07      	cmp	r4, #7
340064ee:	d9f4      	bls.n	340064da <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xa>
340064f0:	f241 21eb 	movw	r1, #4843	@ 0x12eb
340064f4:	4809      	ldr	r0, [pc, #36]	@ (3400651c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x4c>)
340064f6:	f7fc f821 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
340064fa:	2e01      	cmp	r6, #1
340064fc:	d1ed      	bne.n	340064da <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
340064fe:	6829      	ldr	r1, [r5, #0]
  return HAL_OK;
34006500:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
34006502:	f8d1 3824 	ldr.w	r3, [r1, #2084]	@ 0x824
34006506:	f023 030e 	bic.w	r3, r3, #14
3400650a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
3400650e:	f8c1 3824 	str.w	r3, [r1, #2084]	@ 0x824
  return HAL_OK;
34006512:	e7e3      	b.n	340064dc <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0xc>
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));
34006514:	2a07      	cmp	r2, #7
34006516:	d9f0      	bls.n	340064fa <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x2a>
34006518:	e7ea      	b.n	340064f0 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x20>
3400651a:	bf00      	nop
3400651c:	3401c3e6 	.word	0x3401c3e6

34006520 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
{
34006520:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006522:	b130      	cbz	r0, 34006532 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006524:	2902      	cmp	r1, #2
34006526:	d906      	bls.n	34006536 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x16>
34006528:	f241 3108 	movw	r1, #4872	@ 0x1308
3400652c:	4807      	ldr	r0, [pc, #28]	@ (3400654c <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x2c>)
3400652e:	f7fc f805 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006532:	2001      	movs	r0, #1
}
34006534:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006536:	2901      	cmp	r1, #1
34006538:	d1fb      	bne.n	34006532 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x12>
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400653a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400653c:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400653e:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
34006542:	f043 0301 	orr.w	r3, r3, #1
34006546:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
3400654a:	e7f3      	b.n	34006534 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x14>
3400654c:	3401c3e6 	.word	0x3401c3e6

34006550 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
{
34006550:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006552:	b130      	cbz	r0, 34006562 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006554:	2902      	cmp	r1, #2
34006556:	d906      	bls.n	34006566 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x16>
34006558:	f241 3125 	movw	r1, #4901	@ 0x1325
3400655c:	4807      	ldr	r0, [pc, #28]	@ (3400657c <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x2c>)
3400655e:	f7fb ffed 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006562:	2001      	movs	r0, #1
}
34006564:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006566:	2901      	cmp	r1, #1
34006568:	d1fb      	bne.n	34006562 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400656a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400656c:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
3400656e:	f8d2 3824 	ldr.w	r3, [r2, #2084]	@ 0x824
34006572:	f023 0301 	bic.w	r3, r3, #1
34006576:	f8c2 3824 	str.w	r3, [r2, #2084]	@ 0x824
  return HAL_OK;
3400657a:	e7f3      	b.n	34006564 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x14>
3400657c:	3401c3e6 	.word	0x3401c3e6

34006580 <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006580:	2902      	cmp	r1, #2
{
34006582:	b510      	push	{r4, lr}
34006584:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006586:	d904      	bls.n	34006592 <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig+0x12>
34006588:	f241 313b 	movw	r1, #4923	@ 0x133b
3400658c:	4804      	ldr	r0, [pc, #16]	@ (340065a0 <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig+0x20>)
3400658e:	f7fb ffd5 	bl	3400253c <assert_failed>
  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
34006592:	6823      	ldr	r3, [r4, #0]
34006594:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
}
34006598:	f3c0 0042 	ubfx	r0, r0, #1, #3
3400659c:	bd10      	pop	{r4, pc}
3400659e:	bf00      	nop
340065a0:	3401c3e6 	.word	0x3401c3e6

340065a4 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
{
340065a4:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340065a6:	4a10      	ldr	r2, [pc, #64]	@ (340065e8 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x44>)
340065a8:	6803      	ldr	r3, [r0, #0]
{
340065aa:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340065ac:	4293      	cmp	r3, r2
{
340065ae:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
340065b0:	d008      	beq.n	340065c4 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x20>
340065b2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340065b6:	4293      	cmp	r3, r2
340065b8:	d004      	beq.n	340065c4 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x20>
340065ba:	f241 3148 	movw	r1, #4936	@ 0x1348
340065be:	480b      	ldr	r0, [pc, #44]	@ (340065ec <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x48>)
340065c0:	f7fb ffbc 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340065c4:	2d02      	cmp	r5, #2
340065c6:	d906      	bls.n	340065d6 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x32>
340065c8:	f241 3149 	movw	r1, #4937	@ 0x1349
340065cc:	4807      	ldr	r0, [pc, #28]	@ (340065ec <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x48>)
340065ce:	f7fb ffb5 	bl	3400253c <assert_failed>
    return 0;
340065d2:	2000      	movs	r0, #0
}
340065d4:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
340065d6:	2d01      	cmp	r5, #1
340065d8:	d1fb      	bne.n	340065d2 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
340065da:	6823      	ldr	r3, [r4, #0]
340065dc:	f8d3 0824 	ldr.w	r0, [r3, #2084]	@ 0x824
340065e0:	f000 0001 	and.w	r0, r0, #1
340065e4:	e7f6      	b.n	340065d4 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x30>
340065e6:	bf00      	nop
340065e8:	58002000 	.word	0x58002000
340065ec:	3401c3e6 	.word	0x3401c3e6

340065f0 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
{
340065f0:	b538      	push	{r3, r4, r5, lr}
340065f2:	4615      	mov	r5, r2
  if ((hdcmipp == NULL) || (pCounter == NULL))
340065f4:	4604      	mov	r4, r0
340065f6:	b908      	cbnz	r0, 340065fc <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0xc>
    return HAL_ERROR;
340065f8:	2001      	movs	r0, #1
}
340065fa:	bd38      	pop	{r3, r4, r5, pc}
  if ((hdcmipp == NULL) || (pCounter == NULL))
340065fc:	2a00      	cmp	r2, #0
340065fe:	d0fb      	beq.n	340065f8 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x8>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006600:	2902      	cmp	r1, #2
34006602:	d904      	bls.n	3400660e <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1e>
34006604:	f241 3166 	movw	r1, #4966	@ 0x1366
34006608:	4806      	ldr	r0, [pc, #24]	@ (34006624 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x34>)
3400660a:	f7fb ff97 	bl	3400253c <assert_failed>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3400660e:	7923      	ldrb	r3, [r4, #4]
34006610:	2b02      	cmp	r3, #2
34006612:	d1f1      	bne.n	340065f8 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x8>
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34006614:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
34006616:	2000      	movs	r0, #0
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34006618:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
3400661c:	f3c3 030b 	ubfx	r3, r3, #0, #12
34006620:	602b      	str	r3, [r5, #0]
  return HAL_OK;
34006622:	e7ea      	b.n	340065fa <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0xa>
34006624:	3401c3e6 	.word	0x3401c3e6

34006628 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
{
34006628:	b570      	push	{r4, r5, r6, lr}
3400662a:	460e      	mov	r6, r1
3400662c:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
3400662e:	4605      	mov	r5, r0
34006630:	b908      	cbnz	r0, 34006636 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xe>
    return HAL_ERROR;
34006632:	2001      	movs	r0, #1
}
34006634:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34006636:	2a00      	cmp	r2, #0
34006638:	d0fb      	beq.n	34006632 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400663a:	2902      	cmp	r1, #2
3400663c:	d904      	bls.n	34006648 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x20>
3400663e:	f241 4125 	movw	r1, #5157	@ 0x1425
34006642:	4898      	ldr	r0, [pc, #608]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006644:	f7fb ff7a 	bl	3400253c <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(pColorConversionConfig->ClampOutputSamples));
34006648:	7823      	ldrb	r3, [r4, #0]
3400664a:	2b01      	cmp	r3, #1
3400664c:	d904      	bls.n	34006658 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x30>
3400664e:	f241 4126 	movw	r1, #5158	@ 0x1426
34006652:	4894      	ldr	r0, [pc, #592]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006654:	f7fb ff72 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_OUTPUT_SAMPLES_TYPES(pColorConversionConfig->OutputSamplesType));
34006658:	7863      	ldrb	r3, [r4, #1]
3400665a:	f013 0ffd 	tst.w	r3, #253	@ 0xfd
3400665e:	d004      	beq.n	3400666a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x42>
34006660:	f241 4127 	movw	r1, #5159	@ 0x1427
34006664:	488f      	ldr	r0, [pc, #572]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006666:	f7fb ff69 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RR));
3400666a:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
3400666e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006672:	db04      	blt.n	3400667e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x56>
34006674:	f241 4128 	movw	r1, #5160	@ 0x1428
34006678:	488a      	ldr	r0, [pc, #552]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400667a:	f7fb ff5f 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RG));
3400667e:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
34006682:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006686:	db04      	blt.n	34006692 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x6a>
34006688:	f241 4129 	movw	r1, #5161	@ 0x1429
3400668c:	4885      	ldr	r0, [pc, #532]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400668e:	f7fb ff55 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RB));
34006692:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
34006696:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400669a:	db04      	blt.n	340066a6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x7e>
3400669c:	f241 412a 	movw	r1, #5162	@ 0x142a
340066a0:	4880      	ldr	r0, [pc, #512]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340066a2:	f7fb ff4b 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->RA));
340066a6:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
340066aa:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340066ae:	db04      	blt.n	340066ba <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x92>
340066b0:	f241 412b 	movw	r1, #5163	@ 0x142b
340066b4:	487b      	ldr	r0, [pc, #492]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340066b6:	f7fb ff41 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GR));
340066ba:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
340066be:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340066c2:	db04      	blt.n	340066ce <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa6>
340066c4:	f241 412c 	movw	r1, #5164	@ 0x142c
340066c8:	4876      	ldr	r0, [pc, #472]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340066ca:	f7fb ff37 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GG));
340066ce:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
340066d2:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340066d6:	db04      	blt.n	340066e2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xba>
340066d8:	f241 412d 	movw	r1, #5165	@ 0x142d
340066dc:	4871      	ldr	r0, [pc, #452]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340066de:	f7fb ff2d 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GB));
340066e2:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
340066e6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340066ea:	db04      	blt.n	340066f6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xce>
340066ec:	f241 412e 	movw	r1, #5166	@ 0x142e
340066f0:	486c      	ldr	r0, [pc, #432]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
340066f2:	f7fb ff23 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->GA));
340066f6:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
340066fa:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340066fe:	db04      	blt.n	3400670a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xe2>
34006700:	f241 412f 	movw	r1, #5167	@ 0x142f
34006704:	4867      	ldr	r0, [pc, #412]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006706:	f7fb ff19 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BR));
3400670a:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
3400670e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006712:	db04      	blt.n	3400671e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xf6>
34006714:	f241 4130 	movw	r1, #5168	@ 0x1430
34006718:	4862      	ldr	r0, [pc, #392]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400671a:	f7fb ff0f 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BG));
3400671e:	f9b4 3014 	ldrsh.w	r3, [r4, #20]
34006722:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34006726:	db04      	blt.n	34006732 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x10a>
34006728:	f241 4131 	movw	r1, #5169	@ 0x1431
3400672c:	485d      	ldr	r0, [pc, #372]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
3400672e:	f7fb ff05 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BB));
34006732:	f9b4 3016 	ldrsh.w	r3, [r4, #22]
34006736:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400673a:	db04      	blt.n	34006746 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x11e>
3400673c:	f241 4132 	movw	r1, #5170	@ 0x1432
34006740:	4858      	ldr	r0, [pc, #352]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006742:	f7fb fefb 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BA));
34006746:	f9b4 3018 	ldrsh.w	r3, [r4, #24]
3400674a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400674e:	db04      	blt.n	3400675a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x132>
34006750:	f241 4133 	movw	r1, #5171	@ 0x1433
34006754:	4853      	ldr	r0, [pc, #332]	@ (340068a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x27c>)
34006756:	f7fb fef1 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
3400675a:	2e01      	cmp	r6, #1
3400675c:	f47f af69 	bne.w	34006632 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006760:	682b      	ldr	r3, [r5, #0]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
34006762:	7820      	ldrb	r0, [r4, #0]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006764:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
34006768:	7862      	ldrb	r2, [r4, #1]
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
3400676a:	f021 0106 	bic.w	r1, r1, #6
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
3400676e:	ea42 0280 	orr.w	r2, r2, r0, lsl #2
    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34006772:	430a      	orrs	r2, r1
34006774:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34006778:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
3400677c:	b290      	uxth	r0, r2
3400677e:	f3c2 010a 	ubfx	r1, r2, #0, #11
34006782:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
34006784:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34006788:	bfb8      	it	lt
3400678a:	4608      	movlt	r0, r1
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
3400678c:	f3c2 050a 	ubfx	r5, r2, #0, #11
34006790:	2a00      	cmp	r2, #0
34006792:	b291      	uxth	r1, r2
34006794:	bfb8      	it	lt
34006796:	4629      	movlt	r1, r5
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
34006798:	f8d3 2884 	ldr.w	r2, [r3, #2180]	@ 0x884
3400679c:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
340067a0:	4302      	orrs	r2, r0
340067a2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
340067a6:	f8c3 2884 	str.w	r2, [r3, #2180]	@ 0x884
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
340067aa:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
340067ae:	b295      	uxth	r5, r2
340067b0:	f3c2 010a 	ubfx	r1, r2, #0, #11
340067b4:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
340067b6:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
340067ba:	bfb8      	it	lt
340067bc:	460d      	movlt	r5, r1
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
340067be:	f3c2 0109 	ubfx	r1, r2, #0, #10
340067c2:	2a00      	cmp	r2, #0
340067c4:	b290      	uxth	r0, r2
340067c6:	bfb8      	it	lt
340067c8:	4608      	movlt	r0, r1
    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
340067ca:	f8d3 2888 	ldr.w	r2, [r3, #2184]	@ 0x888
340067ce:	4936      	ldr	r1, [pc, #216]	@ (340068a8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x280>)
340067d0:	400a      	ands	r2, r1
340067d2:	432a      	orrs	r2, r5
340067d4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
340067d8:	f8c3 2888 	str.w	r2, [r3, #2184]	@ 0x888
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
340067dc:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
340067e0:	b295      	uxth	r5, r2
340067e2:	f3c2 000a 	ubfx	r0, r2, #0, #11
340067e6:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
340067e8:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
340067ec:	bfb8      	it	lt
340067ee:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
340067f0:	f3c2 060a 	ubfx	r6, r2, #0, #11
340067f4:	2a00      	cmp	r2, #0
340067f6:	b290      	uxth	r0, r2
340067f8:	bfb8      	it	lt
340067fa:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
340067fc:	f8d3 288c 	ldr.w	r2, [r3, #2188]	@ 0x88c
34006800:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006804:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
34006808:	4302      	orrs	r2, r0
3400680a:	f8c3 288c 	str.w	r2, [r3, #2188]	@ 0x88c
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
3400680e:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
34006812:	b295      	uxth	r5, r2
34006814:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006818:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
3400681a:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
3400681e:	bfb8      	it	lt
34006820:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
34006822:	f3c2 0609 	ubfx	r6, r2, #0, #10
34006826:	2a00      	cmp	r2, #0
34006828:	b290      	uxth	r0, r2
3400682a:	bfb8      	it	lt
3400682c:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
3400682e:	f8d3 2890 	ldr.w	r2, [r3, #2192]	@ 0x890
34006832:	400a      	ands	r2, r1
34006834:	432a      	orrs	r2, r5
34006836:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400683a:	f8c3 2890 	str.w	r2, [r3, #2192]	@ 0x890
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
3400683e:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
34006842:	b295      	uxth	r5, r2
34006844:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006848:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
3400684a:	f9b4 2014 	ldrsh.w	r2, [r4, #20]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
3400684e:	bfb8      	it	lt
34006850:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
34006852:	f3c2 060a 	ubfx	r6, r2, #0, #11
34006856:	2a00      	cmp	r2, #0
34006858:	b290      	uxth	r0, r2
3400685a:	bfb8      	it	lt
3400685c:	4630      	movlt	r0, r6
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
3400685e:	f8d3 2894 	ldr.w	r2, [r3, #2196]	@ 0x894
34006862:	f002 22f8 	and.w	r2, r2, #4160813056	@ 0xf800f800
34006866:	432a      	orrs	r2, r5
34006868:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400686c:	f8c3 2894 	str.w	r2, [r3, #2196]	@ 0x894
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34006870:	f9b4 2016 	ldrsh.w	r2, [r4, #22]
34006874:	f3c2 000a 	ubfx	r0, r2, #0, #11
34006878:	b295      	uxth	r5, r2
3400687a:	2a00      	cmp	r2, #0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
3400687c:	f9b4 2018 	ldrsh.w	r2, [r4, #24]
    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34006880:	bfb8      	it	lt
34006882:	4605      	movlt	r5, r0
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
34006884:	f3c2 0409 	ubfx	r4, r2, #0, #10
34006888:	2a00      	cmp	r2, #0
3400688a:	b290      	uxth	r0, r2
3400688c:	bfb8      	it	lt
3400688e:	4620      	movlt	r0, r4
    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34006890:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
34006894:	400a      	ands	r2, r1
34006896:	432a      	orrs	r2, r5
34006898:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3400689c:	f8c3 2898 	str.w	r2, [r3, #2200]	@ 0x898
  return HAL_OK;
340068a0:	2000      	movs	r0, #0
340068a2:	e6c7      	b.n	34006634 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xc>
340068a4:	3401c3e6 	.word	0x3401c3e6
340068a8:	fc00f800 	.word	0xfc00f800

340068ac <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
{
340068ac:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340068ae:	b130      	cbz	r0, 340068be <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340068b0:	2902      	cmp	r1, #2
340068b2:	d906      	bls.n	340068c2 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x16>
340068b4:	f241 417b 	movw	r1, #5243	@ 0x147b
340068b8:	4807      	ldr	r0, [pc, #28]	@ (340068d8 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x2c>)
340068ba:	f7fb fe3f 	bl	3400253c <assert_failed>
    return HAL_ERROR;
340068be:	2001      	movs	r0, #1
}
340068c0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340068c2:	2901      	cmp	r1, #1
340068c4:	d1fb      	bne.n	340068be <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x12>
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340068c6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340068c8:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340068ca:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
340068ce:	f043 0301 	orr.w	r3, r3, #1
340068d2:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
340068d6:	e7f3      	b.n	340068c0 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x14>
340068d8:	3401c3e6 	.word	0x3401c3e6

340068dc <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
{
340068dc:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
340068de:	b130      	cbz	r0, 340068ee <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340068e0:	2902      	cmp	r1, #2
340068e2:	d906      	bls.n	340068f2 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x16>
340068e4:	f241 4197 	movw	r1, #5271	@ 0x1497
340068e8:	4807      	ldr	r0, [pc, #28]	@ (34006908 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x2c>)
340068ea:	f7fb fe27 	bl	3400253c <assert_failed>
    return HAL_ERROR;
340068ee:	2001      	movs	r0, #1
}
340068f0:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
340068f2:	2901      	cmp	r1, #1
340068f4:	d1fb      	bne.n	340068ee <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340068f6:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
340068f8:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340068fa:	f8d2 3880 	ldr.w	r3, [r2, #2176]	@ 0x880
340068fe:	f023 0301 	bic.w	r3, r3, #1
34006902:	f8c2 3880 	str.w	r3, [r2, #2176]	@ 0x880
  return HAL_OK;
34006906:	e7f3      	b.n	340068f0 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x14>
34006908:	3401c3e6 	.word	0x3401c3e6

3400690c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
{
3400690c:	b510      	push	{r4, lr}
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
3400690e:	b100      	cbz	r0, 34006912 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
34006910:	b90a      	cbnz	r2, 34006916 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0xa>
    return HAL_ERROR;
34006912:	2001      	movs	r0, #1
}
34006914:	bd10      	pop	{r4, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006916:	2902      	cmp	r1, #2
34006918:	d905      	bls.n	34006926 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x1a>
3400691a:	f241 515b 	movw	r1, #5467	@ 0x155b
3400691e:	480b      	ldr	r0, [pc, #44]	@ (3400694c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x40>)
34006920:	f7fb fe0c 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006924:	e7f5      	b.n	34006912 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
34006926:	2901      	cmp	r1, #1
34006928:	d1f3      	bne.n	34006912 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x6>
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
3400692a:	6800      	ldr	r0, [r0, #0]
3400692c:	7853      	ldrb	r3, [r2, #1]
3400692e:	7814      	ldrb	r4, [r2, #0]
34006930:	f8d0 1840 	ldr.w	r1, [r0, #2112]	@ 0x840
34006934:	7892      	ldrb	r2, [r2, #2]
34006936:	041b      	lsls	r3, r3, #16
34006938:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
3400693c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34006940:	b2ca      	uxtb	r2, r1
34006942:	4313      	orrs	r3, r2
34006944:	f8c0 3840 	str.w	r3, [r0, #2112]	@ 0x840
  return HAL_OK;
34006948:	2000      	movs	r0, #0
3400694a:	e7e3      	b.n	34006914 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x8>
3400694c:	3401c3e6 	.word	0x3401c3e6

34006950 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
{
34006950:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006952:	b130      	cbz	r0, 34006962 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006954:	2902      	cmp	r1, #2
34006956:	d906      	bls.n	34006966 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x16>
34006958:	f241 517a 	movw	r1, #5498	@ 0x157a
3400695c:	4807      	ldr	r0, [pc, #28]	@ (3400697c <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x2c>)
3400695e:	f7fb fded 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006962:	2001      	movs	r0, #1
}
34006964:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006966:	2901      	cmp	r1, #1
34006968:	d1fb      	bne.n	34006962 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x12>
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
3400696a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400696c:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
3400696e:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
34006972:	f043 0301 	orr.w	r3, r3, #1
34006976:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
3400697a:	e7f3      	b.n	34006964 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x14>
3400697c:	3401c3e6 	.word	0x3401c3e6

34006980 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
{
34006980:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006982:	b130      	cbz	r0, 34006992 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006984:	2902      	cmp	r1, #2
34006986:	d906      	bls.n	34006996 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x16>
34006988:	f241 5196 	movw	r1, #5526	@ 0x1596
3400698c:	4807      	ldr	r0, [pc, #28]	@ (340069ac <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x2c>)
3400698e:	f7fb fdd5 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006992:	2001      	movs	r0, #1
}
34006994:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006996:	2901      	cmp	r1, #1
34006998:	d1fb      	bne.n	34006992 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
3400699a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
3400699c:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
3400699e:	f8d2 3840 	ldr.w	r3, [r2, #2112]	@ 0x840
340069a2:	f023 0301 	bic.w	r3, r3, #1
340069a6:	f8c2 3840 	str.w	r3, [r2, #2112]	@ 0x840
  return HAL_OK;
340069aa:	e7f3      	b.n	34006994 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x14>
340069ac:	3401c3e6 	.word	0x3401c3e6

340069b0 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
{
340069b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340069b2:	460f      	mov	r7, r1
340069b4:	4615      	mov	r5, r2
340069b6:	461c      	mov	r4, r3
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
340069b8:	4606      	mov	r6, r0
340069ba:	b908      	cbnz	r0, 340069c0 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x10>
    return HAL_ERROR;
340069bc:	2001      	movs	r0, #1
}
340069be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
340069c0:	2b00      	cmp	r3, #0
340069c2:	d0fb      	beq.n	340069bc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc>
  assert_param(IS_DCMIPP_PIPE(Pipe));
340069c4:	2902      	cmp	r1, #2
340069c6:	d904      	bls.n	340069d2 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x22>
340069c8:	f241 51e9 	movw	r1, #5609	@ 0x15e9
340069cc:	482a      	ldr	r0, [pc, #168]	@ (34006a78 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
340069ce:	f7fb fdb5 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
340069d2:	1e6b      	subs	r3, r5, #1
340069d4:	2b02      	cmp	r3, #2
340069d6:	d904      	bls.n	340069e2 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x32>
340069d8:	f241 51ea 	movw	r1, #5610	@ 0x15ea
340069dc:	4826      	ldr	r0, [pc, #152]	@ (34006a78 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
340069de:	f7fb fdad 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_BINS(pStatisticExtractionConfig->Bins));
340069e2:	68a3      	ldr	r3, [r4, #8]
340069e4:	b16b      	cbz	r3, 34006a02 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
340069e6:	3b04      	subs	r3, #4
340069e8:	2b08      	cmp	r3, #8
340069ea:	d805      	bhi.n	340069f8 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x48>
340069ec:	f240 1211 	movw	r2, #273	@ 0x111
340069f0:	fa22 f303 	lsr.w	r3, r2, r3
340069f4:	07db      	lsls	r3, r3, #31
340069f6:	d404      	bmi.n	34006a02 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x52>
340069f8:	f241 51eb 	movw	r1, #5611	@ 0x15eb
340069fc:	481e      	ldr	r0, [pc, #120]	@ (34006a78 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
340069fe:	f7fb fd9d 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_SOURCE(pStatisticExtractionConfig->Source));
34006a02:	6863      	ldr	r3, [r4, #4]
34006a04:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34006a08:	d006      	beq.n	34006a18 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x68>
34006a0a:	2b40      	cmp	r3, #64	@ 0x40
34006a0c:	d004      	beq.n	34006a18 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x68>
34006a0e:	f241 51ec 	movw	r1, #5612	@ 0x15ec
34006a12:	4819      	ldr	r0, [pc, #100]	@ (34006a78 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34006a14:	f7fb fd92 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODE(pStatisticExtractionConfig->Mode));
34006a18:	6823      	ldr	r3, [r4, #0]
34006a1a:	f033 0380 	bics.w	r3, r3, #128	@ 0x80
34006a1e:	d004      	beq.n	34006a2a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x7a>
34006a20:	f241 51ed 	movw	r1, #5613	@ 0x15ed
34006a24:	4814      	ldr	r0, [pc, #80]	@ (34006a78 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc8>)
34006a26:	f7fb fd89 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006a2a:	2f01      	cmp	r7, #1
34006a2c:	d1c6      	bne.n	340069bc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xc>
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34006a2e:	e9d4 3200 	ldrd	r3, r2, [r4]
34006a32:	4313      	orrs	r3, r2
34006a34:	68a2      	ldr	r2, [r4, #8]
    switch (ModuleID)
34006a36:	2d01      	cmp	r5, #1
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34006a38:	6831      	ldr	r1, [r6, #0]
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34006a3a:	ea43 0302 	orr.w	r3, r3, r2
    switch (ModuleID)
34006a3e:	d009      	beq.n	34006a54 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xa4>
34006a40:	2d02      	cmp	r5, #2
34006a42:	d010      	beq.n	34006a66 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb6>
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
34006a44:	f8d1 2858 	ldr.w	r2, [r1, #2136]	@ 0x858
34006a48:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34006a4c:	4313      	orrs	r3, r2
34006a4e:	f8c1 3858 	str.w	r3, [r1, #2136]	@ 0x858
        break;
34006a52:	e006      	b.n	34006a62 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb2>
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34006a54:	f8d1 2850 	ldr.w	r2, [r1, #2128]	@ 0x850
34006a58:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34006a5c:	4313      	orrs	r3, r2
34006a5e:	f8c1 3850 	str.w	r3, [r1, #2128]	@ 0x850
  return HAL_OK;
34006a62:	2000      	movs	r0, #0
34006a64:	e7ab      	b.n	340069be <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xe>
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
34006a66:	f8d1 2854 	ldr.w	r2, [r1, #2132]	@ 0x854
34006a6a:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
34006a6e:	4313      	orrs	r3, r2
34006a70:	f8c1 3854 	str.w	r3, [r1, #2132]	@ 0x854
        break;
34006a74:	e7f5      	b.n	34006a62 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0xb2>
34006a76:	bf00      	nop
34006a78:	3401c3e6 	.word	0x3401c3e6

34006a7c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
{
34006a7c:	b570      	push	{r4, r5, r6, lr}
34006a7e:	460e      	mov	r6, r1
34006a80:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
34006a82:	4605      	mov	r5, r0
34006a84:	b908      	cbnz	r0, 34006a8a <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xe>
    return HAL_ERROR;
34006a86:	2001      	movs	r0, #1
}
34006a88:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
34006a8a:	2a00      	cmp	r2, #0
34006a8c:	d0fb      	beq.n	34006a86 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006a8e:	2902      	cmp	r1, #2
34006a90:	d904      	bls.n	34006a9c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x20>
34006a92:	f241 611f 	movw	r1, #5663	@ 0x161f
34006a96:	4821      	ldr	r0, [pc, #132]	@ (34006b1c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
34006a98:	f7fb fd50 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->HStart));
34006a9c:	6863      	ldr	r3, [r4, #4]
34006a9e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006aa2:	d304      	bcc.n	34006aae <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x32>
34006aa4:	f44f 51b1 	mov.w	r1, #5664	@ 0x1620
34006aa8:	481c      	ldr	r0, [pc, #112]	@ (34006b1c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
34006aaa:	f7fb fd47 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->VStart));
34006aae:	6823      	ldr	r3, [r4, #0]
34006ab0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006ab4:	d304      	bcc.n	34006ac0 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x44>
34006ab6:	f241 6121 	movw	r1, #5665	@ 0x1621
34006aba:	4818      	ldr	r0, [pc, #96]	@ (34006b1c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
34006abc:	f7fb fd3e 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->HSize));
34006ac0:	68e3      	ldr	r3, [r4, #12]
34006ac2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006ac6:	d304      	bcc.n	34006ad2 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x56>
34006ac8:	f241 6122 	movw	r1, #5666	@ 0x1622
34006acc:	4813      	ldr	r0, [pc, #76]	@ (34006b1c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
34006ace:	f7fb fd35 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->VSize));
34006ad2:	68a3      	ldr	r3, [r4, #8]
34006ad4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006ad8:	d304      	bcc.n	34006ae4 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x68>
34006ada:	f241 6123 	movw	r1, #5667	@ 0x1623
34006ade:	480f      	ldr	r0, [pc, #60]	@ (34006b1c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa0>)
34006ae0:	f7fb fd2c 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006ae4:	2e01      	cmp	r6, #1
34006ae6:	d1ce      	bne.n	34006a86 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
34006ae8:	e9d4 0300 	ldrd	r0, r3, [r4]
34006aec:	682a      	ldr	r2, [r5, #0]
34006aee:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006af2:	f8d2 185c 	ldr.w	r1, [r2, #2140]	@ 0x85c
34006af6:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006afa:	430b      	orrs	r3, r1
34006afc:	f8c2 385c 	str.w	r3, [r2, #2140]	@ 0x85c
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34006b00:	f8d2 1860 	ldr.w	r1, [r2, #2144]	@ 0x860
34006b04:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
34006b08:	f001 21f0 	and.w	r1, r1, #4026593280	@ 0xf000f000
34006b0c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34006b10:	430b      	orrs	r3, r1
  return HAL_OK;
34006b12:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34006b14:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
34006b18:	e7b6      	b.n	34006a88 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0xc>
34006b1a:	bf00      	nop
34006b1c:	3401c3e6 	.word	0x3401c3e6

34006b20 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
{
34006b20:	b570      	push	{r4, r5, r6, lr}
34006b22:	460e      	mov	r6, r1
34006b24:	4615      	mov	r5, r2
  if (hdcmipp == NULL)
34006b26:	4604      	mov	r4, r0
34006b28:	b908      	cbnz	r0, 34006b2e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xe>
    return HAL_ERROR;
34006b2a:	2001      	movs	r0, #1
}
34006b2c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b2e:	2902      	cmp	r1, #2
34006b30:	d904      	bls.n	34006b3c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x1c>
34006b32:	f241 6147 	movw	r1, #5703	@ 0x1647
34006b36:	4815      	ldr	r0, [pc, #84]	@ (34006b8c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>)
34006b38:	f7fb fd00 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
34006b3c:	1e6b      	subs	r3, r5, #1
34006b3e:	2b02      	cmp	r3, #2
34006b40:	d90e      	bls.n	34006b60 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x40>
34006b42:	f241 6148 	movw	r1, #5704	@ 0x1648
34006b46:	4811      	ldr	r0, [pc, #68]	@ (34006b8c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>)
34006b48:	f7fb fcf8 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006b4c:	2e01      	cmp	r6, #1
34006b4e:	d1ec      	bne.n	34006b2a <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xa>
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
34006b50:	6822      	ldr	r2, [r4, #0]
34006b52:	f8d2 3858 	ldr.w	r3, [r2, #2136]	@ 0x858
34006b56:	f043 0301 	orr.w	r3, r3, #1
34006b5a:	f8c2 3858 	str.w	r3, [r2, #2136]	@ 0x858
        break;
34006b5e:	e013      	b.n	34006b88 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x68>
  if (Pipe == DCMIPP_PIPE1)
34006b60:	2e01      	cmp	r6, #1
34006b62:	d1e2      	bne.n	34006b2a <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xa>
    switch (ModuleID)
34006b64:	2d01      	cmp	r5, #1
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34006b66:	6823      	ldr	r3, [r4, #0]
    switch (ModuleID)
34006b68:	d008      	beq.n	34006b7c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x5c>
34006b6a:	2d02      	cmp	r5, #2
34006b6c:	d1f0      	bne.n	34006b50 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x30>
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
34006b6e:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
34006b72:	f042 0201 	orr.w	r2, r2, #1
34006b76:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
34006b7a:	e005      	b.n	34006b88 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x68>
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34006b7c:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
34006b80:	f042 0201 	orr.w	r2, r2, #1
34006b84:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
  return HAL_OK;
34006b88:	2000      	movs	r0, #0
34006b8a:	e7cf      	b.n	34006b2c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0xc>
34006b8c:	3401c3e6 	.word	0x3401c3e6

34006b90 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
{
34006b90:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006b92:	b130      	cbz	r0, 34006ba2 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006b94:	2902      	cmp	r1, #2
34006b96:	d906      	bls.n	34006ba6 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x16>
34006b98:	f241 619f 	movw	r1, #5791	@ 0x169f
34006b9c:	4807      	ldr	r0, [pc, #28]	@ (34006bbc <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x2c>)
34006b9e:	f7fb fccd 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006ba2:	2001      	movs	r0, #1
}
34006ba4:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006ba6:	2901      	cmp	r1, #1
34006ba8:	d1fb      	bne.n	34006ba2 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x12>
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
34006baa:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006bac:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
34006bae:	f8d2 3860 	ldr.w	r3, [r2, #2144]	@ 0x860
34006bb2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
34006bb6:	f8c2 3860 	str.w	r3, [r2, #2144]	@ 0x860
  return HAL_OK;
34006bba:	e7f3      	b.n	34006ba4 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x14>
34006bbc:	3401c3e6 	.word	0x3401c3e6

34006bc0 <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
{
34006bc0:	b570      	push	{r4, r5, r6, lr}
34006bc2:	460e      	mov	r6, r1
34006bc4:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
34006bc6:	4605      	mov	r5, r0
34006bc8:	b908      	cbnz	r0, 34006bce <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xe>
    return HAL_ERROR;
34006bca:	2001      	movs	r0, #1
}
34006bcc:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
34006bce:	2a00      	cmp	r2, #0
34006bd0:	d0fb      	beq.n	34006bca <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006bd2:	2902      	cmp	r1, #2
34006bd4:	d904      	bls.n	34006be0 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x20>
34006bd6:	f241 61db 	movw	r1, #5851	@ 0x16db
34006bda:	481c      	ldr	r0, [pc, #112]	@ (34006c4c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006bdc:	f7fb fcae 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftRed));
34006be0:	7823      	ldrb	r3, [r4, #0]
34006be2:	2b07      	cmp	r3, #7
34006be4:	d904      	bls.n	34006bf0 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x30>
34006be6:	f241 61dc 	movw	r1, #5852	@ 0x16dc
34006bea:	4818      	ldr	r0, [pc, #96]	@ (34006c4c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006bec:	f7fb fca6 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftGreen));
34006bf0:	78a3      	ldrb	r3, [r4, #2]
34006bf2:	2b07      	cmp	r3, #7
34006bf4:	d904      	bls.n	34006c00 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x40>
34006bf6:	f241 61dd 	movw	r1, #5853	@ 0x16dd
34006bfa:	4814      	ldr	r0, [pc, #80]	@ (34006c4c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006bfc:	f7fb fc9e 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftBlue));
34006c00:	7923      	ldrb	r3, [r4, #4]
34006c02:	2b07      	cmp	r3, #7
34006c04:	d904      	bls.n	34006c10 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x50>
34006c06:	f241 61de 	movw	r1, #5854	@ 0x16de
34006c0a:	4810      	ldr	r0, [pc, #64]	@ (34006c4c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x8c>)
34006c0c:	f7fb fc96 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006c10:	2e01      	cmp	r6, #1
34006c12:	d1da      	bne.n	34006bca <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
34006c14:	682a      	ldr	r2, [r5, #0]
34006c16:	7863      	ldrb	r3, [r4, #1]
34006c18:	7820      	ldrb	r0, [r4, #0]
34006c1a:	f8d2 1844 	ldr.w	r1, [r2, #2116]	@ 0x844
34006c1e:	051b      	lsls	r3, r3, #20
34006c20:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
34006c24:	f36f 511e 	bfc	r1, #20, #11
34006c28:	430b      	orrs	r3, r1
34006c2a:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34006c2e:	78e3      	ldrb	r3, [r4, #3]
34006c30:	78a1      	ldrb	r1, [r4, #2]
34006c32:	051b      	lsls	r3, r3, #20
34006c34:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
34006c38:	7921      	ldrb	r1, [r4, #4]
  return HAL_OK;
34006c3a:	2000      	movs	r0, #0
    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34006c3c:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
34006c40:	7961      	ldrb	r1, [r4, #5]
34006c42:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
34006c46:	f8c2 3848 	str.w	r3, [r2, #2120]	@ 0x848
  return HAL_OK;
34006c4a:	e7bf      	b.n	34006bcc <HAL_DCMIPP_PIPE_SetISPExposureConfig+0xc>
34006c4c:	3401c3e6 	.word	0x3401c3e6

34006c50 <HAL_DCMIPP_PIPE_EnableISPExposure>:
{
34006c50:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006c52:	b130      	cbz	r0, 34006c62 <HAL_DCMIPP_PIPE_EnableISPExposure+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006c54:	2902      	cmp	r1, #2
34006c56:	d906      	bls.n	34006c66 <HAL_DCMIPP_PIPE_EnableISPExposure+0x16>
34006c58:	f241 7101 	movw	r1, #5889	@ 0x1701
34006c5c:	4807      	ldr	r0, [pc, #28]	@ (34006c7c <HAL_DCMIPP_PIPE_EnableISPExposure+0x2c>)
34006c5e:	f7fb fc6d 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006c62:	2001      	movs	r0, #1
}
34006c64:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006c66:	2901      	cmp	r1, #1
34006c68:	d1fb      	bne.n	34006c62 <HAL_DCMIPP_PIPE_EnableISPExposure+0x12>
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006c6a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006c6c:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006c6e:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34006c72:	f043 0301 	orr.w	r3, r3, #1
34006c76:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
34006c7a:	e7f3      	b.n	34006c64 <HAL_DCMIPP_PIPE_EnableISPExposure+0x14>
34006c7c:	3401c3e6 	.word	0x3401c3e6

34006c80 <HAL_DCMIPP_PIPE_DisableISPExposure>:
{
34006c80:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006c82:	b130      	cbz	r0, 34006c92 <HAL_DCMIPP_PIPE_DisableISPExposure+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006c84:	2902      	cmp	r1, #2
34006c86:	d906      	bls.n	34006c96 <HAL_DCMIPP_PIPE_DisableISPExposure+0x16>
34006c88:	f241 711d 	movw	r1, #5917	@ 0x171d
34006c8c:	4807      	ldr	r0, [pc, #28]	@ (34006cac <HAL_DCMIPP_PIPE_DisableISPExposure+0x2c>)
34006c8e:	f7fb fc55 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006c92:	2001      	movs	r0, #1
}
34006c94:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006c96:	2901      	cmp	r1, #1
34006c98:	d1fb      	bne.n	34006c92 <HAL_DCMIPP_PIPE_DisableISPExposure+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006c9a:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006c9c:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34006c9e:	f8d2 3844 	ldr.w	r3, [r2, #2116]	@ 0x844
34006ca2:	f023 0301 	bic.w	r3, r3, #1
34006ca6:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
  return HAL_OK;
34006caa:	e7f3      	b.n	34006c94 <HAL_DCMIPP_PIPE_DisableISPExposure+0x14>
34006cac:	3401c3e6 	.word	0x3401c3e6

34006cb0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
{
34006cb0:	b570      	push	{r4, r5, r6, lr}
34006cb2:	460e      	mov	r6, r1
34006cb4:	4614      	mov	r4, r2
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34006cb6:	4605      	mov	r5, r0
34006cb8:	b908      	cbnz	r0, 34006cbe <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xe>
    return HAL_ERROR;
34006cba:	2001      	movs	r0, #1
}
34006cbc:	bd70      	pop	{r4, r5, r6, pc}
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34006cbe:	2a00      	cmp	r2, #0
34006cc0:	d0fb      	beq.n	34006cba <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006cc2:	2902      	cmp	r1, #2
34006cc4:	d904      	bls.n	34006cd0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x20>
34006cc6:	f241 713b 	movw	r1, #5947	@ 0x173b
34006cca:	4839      	ldr	r0, [pc, #228]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006ccc:	f7fb fc36 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_0));
34006cd0:	7823      	ldrb	r3, [r4, #0]
34006cd2:	2b3f      	cmp	r3, #63	@ 0x3f
34006cd4:	d904      	bls.n	34006ce0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x30>
34006cd6:	f241 713c 	movw	r1, #5948	@ 0x173c
34006cda:	4835      	ldr	r0, [pc, #212]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006cdc:	f7fb fc2e 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_32));
34006ce0:	7863      	ldrb	r3, [r4, #1]
34006ce2:	2b3f      	cmp	r3, #63	@ 0x3f
34006ce4:	d904      	bls.n	34006cf0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x40>
34006ce6:	f241 713d 	movw	r1, #5949	@ 0x173d
34006cea:	4831      	ldr	r0, [pc, #196]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006cec:	f7fb fc26 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_64));
34006cf0:	78a3      	ldrb	r3, [r4, #2]
34006cf2:	2b3f      	cmp	r3, #63	@ 0x3f
34006cf4:	d904      	bls.n	34006d00 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x50>
34006cf6:	f241 713e 	movw	r1, #5950	@ 0x173e
34006cfa:	482d      	ldr	r0, [pc, #180]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006cfc:	f7fb fc1e 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_96));
34006d00:	78e3      	ldrb	r3, [r4, #3]
34006d02:	2b3f      	cmp	r3, #63	@ 0x3f
34006d04:	d904      	bls.n	34006d10 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x60>
34006d06:	f241 713f 	movw	r1, #5951	@ 0x173f
34006d0a:	4829      	ldr	r0, [pc, #164]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006d0c:	f7fb fc16 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_128));
34006d10:	7923      	ldrb	r3, [r4, #4]
34006d12:	2b3f      	cmp	r3, #63	@ 0x3f
34006d14:	d904      	bls.n	34006d20 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x70>
34006d16:	f44f 51ba 	mov.w	r1, #5952	@ 0x1740
34006d1a:	4825      	ldr	r0, [pc, #148]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006d1c:	f7fb fc0e 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_160));
34006d20:	7963      	ldrb	r3, [r4, #5]
34006d22:	2b3f      	cmp	r3, #63	@ 0x3f
34006d24:	d904      	bls.n	34006d30 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x80>
34006d26:	f241 7141 	movw	r1, #5953	@ 0x1741
34006d2a:	4821      	ldr	r0, [pc, #132]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006d2c:	f7fb fc06 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_192));
34006d30:	79a3      	ldrb	r3, [r4, #6]
34006d32:	2b3f      	cmp	r3, #63	@ 0x3f
34006d34:	d904      	bls.n	34006d40 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x90>
34006d36:	f241 7142 	movw	r1, #5954	@ 0x1742
34006d3a:	481d      	ldr	r0, [pc, #116]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006d3c:	f7fb fbfe 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_224));
34006d40:	79e3      	ldrb	r3, [r4, #7]
34006d42:	2b3f      	cmp	r3, #63	@ 0x3f
34006d44:	d904      	bls.n	34006d50 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa0>
34006d46:	f241 7143 	movw	r1, #5955	@ 0x1743
34006d4a:	4819      	ldr	r0, [pc, #100]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006d4c:	f7fb fbf6 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_256));
34006d50:	7a23      	ldrb	r3, [r4, #8]
34006d52:	2b3f      	cmp	r3, #63	@ 0x3f
34006d54:	d904      	bls.n	34006d60 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xb0>
34006d56:	f241 7144 	movw	r1, #5956	@ 0x1744
34006d5a:	4815      	ldr	r0, [pc, #84]	@ (34006db0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x100>)
34006d5c:	f7fb fbee 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006d60:	2e01      	cmp	r6, #1
34006d62:	d1aa      	bne.n	34006cba <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xa>
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34006d64:	682a      	ldr	r2, [r5, #0]
34006d66:	7821      	ldrb	r1, [r4, #0]
34006d68:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34006d6c:	2000      	movs	r0, #0
    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34006d6e:	f423 43fc 	bic.w	r3, r3, #32256	@ 0x7e00
34006d72:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
34006d76:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
34006d7a:	78a3      	ldrb	r3, [r4, #2]
34006d7c:	7861      	ldrb	r1, [r4, #1]
34006d7e:	045b      	lsls	r3, r3, #17
34006d80:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
34006d84:	78e1      	ldrb	r1, [r4, #3]
34006d86:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
34006d8a:	7921      	ldrb	r1, [r4, #4]
34006d8c:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
34006d90:	f8c2 38a4 	str.w	r3, [r2, #2212]	@ 0x8a4
    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
34006d94:	79a3      	ldrb	r3, [r4, #6]
34006d96:	7961      	ldrb	r1, [r4, #5]
34006d98:	045b      	lsls	r3, r3, #17
34006d9a:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
34006d9e:	79e1      	ldrb	r1, [r4, #7]
34006da0:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
34006da4:	7a21      	ldrb	r1, [r4, #8]
34006da6:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
34006daa:	f8c2 38a8 	str.w	r3, [r2, #2216]	@ 0x8a8
  return HAL_OK;
34006dae:	e785      	b.n	34006cbc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0xc>
34006db0:	3401c3e6 	.word	0x3401c3e6

34006db4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
{
34006db4:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006db6:	b130      	cbz	r0, 34006dc6 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006db8:	2902      	cmp	r1, #2
34006dba:	d906      	bls.n	34006dca <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x16>
34006dbc:	f241 716c 	movw	r1, #5996	@ 0x176c
34006dc0:	4807      	ldr	r0, [pc, #28]	@ (34006de0 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x2c>)
34006dc2:	f7fb fbbb 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006dc6:	2001      	movs	r0, #1
}
34006dc8:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006dca:	2901      	cmp	r1, #1
34006dcc:	d1fb      	bne.n	34006dc6 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x12>
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006dce:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006dd0:	2000      	movs	r0, #0
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006dd2:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
34006dd6:	f043 0301 	orr.w	r3, r3, #1
34006dda:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34006dde:	e7f3      	b.n	34006dc8 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x14>
34006de0:	3401c3e6 	.word	0x3401c3e6

34006de4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
{
34006de4:	b508      	push	{r3, lr}
  if (hdcmipp == NULL)
34006de6:	b130      	cbz	r0, 34006df6 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x12>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006de8:	2902      	cmp	r1, #2
34006dea:	d906      	bls.n	34006dfa <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x16>
34006dec:	f241 7188 	movw	r1, #6024	@ 0x1788
34006df0:	4807      	ldr	r0, [pc, #28]	@ (34006e10 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x2c>)
34006df2:	f7fb fba3 	bl	3400253c <assert_failed>
    return HAL_ERROR;
34006df6:	2001      	movs	r0, #1
}
34006df8:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE1)
34006dfa:	2901      	cmp	r1, #1
34006dfc:	d1fb      	bne.n	34006df6 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x12>
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006dfe:	6802      	ldr	r2, [r0, #0]
  return HAL_OK;
34006e00:	2000      	movs	r0, #0
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34006e02:	f8d2 38a0 	ldr.w	r3, [r2, #2208]	@ 0x8a0
34006e06:	f023 0301 	bic.w	r3, r3, #1
34006e0a:	f8c2 38a0 	str.w	r3, [r2, #2208]	@ 0x8a0
  return HAL_OK;
34006e0e:	e7f3      	b.n	34006df8 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x14>
34006e10:	3401c3e6 	.word	0x3401c3e6

34006e14 <HAL_DCMIPP_PIPE_SetPitch>:
{
34006e14:	b570      	push	{r4, r5, r6, lr}
34006e16:	460e      	mov	r6, r1
34006e18:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34006e1a:	4605      	mov	r5, r0
34006e1c:	b908      	cbnz	r0, 34006e22 <HAL_DCMIPP_PIPE_SetPitch+0xe>
    return HAL_ERROR;
34006e1e:	2001      	movs	r0, #1
}
34006e20:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e22:	2902      	cmp	r1, #2
34006e24:	d904      	bls.n	34006e30 <HAL_DCMIPP_PIPE_SetPitch+0x1c>
34006e26:	f241 71d2 	movw	r1, #6098	@ 0x17d2
34006e2a:	4812      	ldr	r0, [pc, #72]	@ (34006e74 <HAL_DCMIPP_PIPE_SetPitch+0x60>)
34006e2c:	f7fb fb86 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(LinePitch));
34006e30:	0723      	lsls	r3, r4, #28
34006e32:	d102      	bne.n	34006e3a <HAL_DCMIPP_PIPE_SetPitch+0x26>
34006e34:	f5b4 4f00 	cmp.w	r4, #32768	@ 0x8000
34006e38:	d304      	bcc.n	34006e44 <HAL_DCMIPP_PIPE_SetPitch+0x30>
34006e3a:	f241 71d3 	movw	r1, #6099	@ 0x17d3
34006e3e:	480d      	ldr	r0, [pc, #52]	@ (34006e74 <HAL_DCMIPP_PIPE_SetPitch+0x60>)
34006e40:	f7fb fb7c 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006e44:	2e01      	cmp	r6, #1
34006e46:	d109      	bne.n	34006e5c <HAL_DCMIPP_PIPE_SetPitch+0x48>
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
34006e48:	682a      	ldr	r2, [r5, #0]
34006e4a:	f8d2 39cc 	ldr.w	r3, [r2, #2508]	@ 0x9cc
34006e4e:	f36f 030e 	bfc	r3, #0, #15
34006e52:	4323      	orrs	r3, r4
34006e54:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
  return HAL_OK;
34006e58:	2000      	movs	r0, #0
34006e5a:	e7e1      	b.n	34006e20 <HAL_DCMIPP_PIPE_SetPitch+0xc>
  else if (Pipe == DCMIPP_PIPE2)
34006e5c:	2e02      	cmp	r6, #2
34006e5e:	d1de      	bne.n	34006e1e <HAL_DCMIPP_PIPE_SetPitch+0xa>
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34006e60:	682a      	ldr	r2, [r5, #0]
34006e62:	f8d2 3dcc 	ldr.w	r3, [r2, #3532]	@ 0xdcc
34006e66:	f36f 030e 	bfc	r3, #0, #15
34006e6a:	4323      	orrs	r3, r4
34006e6c:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
34006e70:	e7f2      	b.n	34006e58 <HAL_DCMIPP_PIPE_SetPitch+0x44>
34006e72:	bf00      	nop
34006e74:	3401c3e6 	.word	0x3401c3e6

34006e78 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
{
34006e78:	b570      	push	{r4, r5, r6, lr}
34006e7a:	460e      	mov	r6, r1
34006e7c:	4614      	mov	r4, r2
  if (hdcmipp == NULL)
34006e7e:	4605      	mov	r5, r0
34006e80:	b908      	cbnz	r0, 34006e86 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xe>
    return HAL_ERROR;
34006e82:	2001      	movs	r0, #1
}
34006e84:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006e86:	2902      	cmp	r1, #2
34006e88:	d917      	bls.n	34006eba <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x42>
34006e8a:	f241 71f6 	movw	r1, #6134	@ 0x17f6
34006e8e:	4812      	ldr	r0, [pc, #72]	@ (34006ed8 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x60>)
34006e90:	f7fb fb54 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));
34006e94:	2c09      	cmp	r4, #9
34006e96:	d9f4      	bls.n	34006e82 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xa>
34006e98:	f241 71f7 	movw	r1, #6135	@ 0x17f7
34006e9c:	480e      	ldr	r0, [pc, #56]	@ (34006ed8 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x60>)
34006e9e:	f7fb fb4d 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006ea2:	2e01      	cmp	r6, #1
34006ea4:	d10c      	bne.n	34006ec0 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x48>
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
34006ea6:	682a      	ldr	r2, [r5, #0]
34006ea8:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34006eac:	f023 030f 	bic.w	r3, r3, #15
34006eb0:	4323      	orrs	r3, r4
34006eb2:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34006eb6:	2000      	movs	r0, #0
34006eb8:	e7e4      	b.n	34006e84 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xc>
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));
34006eba:	2a09      	cmp	r2, #9
34006ebc:	d9f1      	bls.n	34006ea2 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x2a>
34006ebe:	e7eb      	b.n	34006e98 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x20>
  else if (Pipe == DCMIPP_PIPE2)
34006ec0:	2e02      	cmp	r6, #2
34006ec2:	d1de      	bne.n	34006e82 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0xa>
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
34006ec4:	682a      	ldr	r2, [r5, #0]
34006ec6:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34006eca:	f023 030f 	bic.w	r3, r3, #15
34006ece:	4323      	orrs	r3, r4
34006ed0:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34006ed4:	e7ef      	b.n	34006eb6 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x3e>
34006ed6:	bf00      	nop
34006ed8:	3401c3e6 	.word	0x3401c3e6

34006edc <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006edc:	2902      	cmp	r1, #2
{
34006ede:	b538      	push	{r3, r4, r5, lr}
34006ee0:	4604      	mov	r4, r0
34006ee2:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006ee4:	d904      	bls.n	34006ef0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x14>
34006ee6:	f641 1139 	movw	r1, #6457	@ 0x1939
34006eea:	480f      	ldr	r0, [pc, #60]	@ (34006f28 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x4c>)
34006eec:	f7fb fb26 	bl	3400253c <assert_failed>
  if (hdcmipp == NULL)
34006ef0:	b1bc      	cbz	r4, 34006f22 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x46>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006ef2:	7923      	ldrb	r3, [r4, #4]
34006ef4:	2b02      	cmp	r3, #2
34006ef6:	d108      	bne.n	34006f0a <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x2e>
    if (Pipe == DCMIPP_PIPE1)
34006ef8:	2d01      	cmp	r5, #1
34006efa:	d108      	bne.n	34006f0e <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x32>
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34006efc:	6822      	ldr	r2, [r4, #0]
34006efe:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34006f02:	f043 0310 	orr.w	r3, r3, #16
34006f06:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34006f0a:	2000      	movs	r0, #0
}
34006f0c:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE2)
34006f0e:	2d02      	cmp	r5, #2
34006f10:	d107      	bne.n	34006f22 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x46>
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34006f12:	6822      	ldr	r2, [r4, #0]
34006f14:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34006f18:	f043 0310 	orr.w	r3, r3, #16
34006f1c:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34006f20:	e7f3      	b.n	34006f0a <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x2e>
    return HAL_ERROR;
34006f22:	2001      	movs	r0, #1
34006f24:	e7f2      	b.n	34006f0c <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x30>
34006f26:	bf00      	nop
34006f28:	3401c3e6 	.word	0x3401c3e6

34006f2c <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f2c:	2902      	cmp	r1, #2
{
34006f2e:	b538      	push	{r3, r4, r5, lr}
34006f30:	4604      	mov	r4, r0
34006f32:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f34:	d904      	bls.n	34006f40 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x14>
34006f36:	f641 115b 	movw	r1, #6491	@ 0x195b
34006f3a:	480f      	ldr	r0, [pc, #60]	@ (34006f78 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x4c>)
34006f3c:	f7fb fafe 	bl	3400253c <assert_failed>
  if (hdcmipp == NULL)
34006f40:	b1bc      	cbz	r4, 34006f72 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x46>
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34006f42:	7923      	ldrb	r3, [r4, #4]
34006f44:	2b02      	cmp	r3, #2
34006f46:	d108      	bne.n	34006f5a <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x2e>
    if (Pipe == DCMIPP_PIPE1)
34006f48:	2d01      	cmp	r5, #1
34006f4a:	d108      	bne.n	34006f5e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x32>
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34006f4c:	6822      	ldr	r2, [r4, #0]
34006f4e:	f8d2 39c0 	ldr.w	r3, [r2, #2496]	@ 0x9c0
34006f52:	f023 0310 	bic.w	r3, r3, #16
34006f56:	f8c2 39c0 	str.w	r3, [r2, #2496]	@ 0x9c0
  return HAL_OK;
34006f5a:	2000      	movs	r0, #0
}
34006f5c:	bd38      	pop	{r3, r4, r5, pc}
    else if (Pipe == DCMIPP_PIPE2)
34006f5e:	2d02      	cmp	r5, #2
34006f60:	d107      	bne.n	34006f72 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x46>
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34006f62:	6822      	ldr	r2, [r4, #0]
34006f64:	f8d2 3dc0 	ldr.w	r3, [r2, #3520]	@ 0xdc0
34006f68:	f023 0310 	bic.w	r3, r3, #16
34006f6c:	f8c2 3dc0 	str.w	r3, [r2, #3520]	@ 0xdc0
34006f70:	e7f3      	b.n	34006f5a <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x2e>
    return HAL_ERROR;
34006f72:	2001      	movs	r0, #1
34006f74:	e7f2      	b.n	34006f5c <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x30>
34006f76:	bf00      	nop
34006f78:	3401c3e6 	.word	0x3401c3e6

34006f7c <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f7c:	2902      	cmp	r1, #2
{
34006f7e:	b508      	push	{r3, lr}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006f80:	d906      	bls.n	34006f90 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x14>
34006f82:	f641 217d 	movw	r1, #6781	@ 0x1a7d
34006f86:	480a      	ldr	r0, [pc, #40]	@ (34006fb0 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x34>)
34006f88:	f7fb fad8 	bl	3400253c <assert_failed>
      return HAL_ERROR;
34006f8c:	2001      	movs	r0, #1
}
34006f8e:	bd08      	pop	{r3, pc}
  if (Pipe == DCMIPP_PIPE2)
34006f90:	d1fc      	bne.n	34006f8c <HAL_DCMIPP_PIPE_CSI_EnableShare+0x10>
    tmp1 = hdcmipp->Instance->P2FSCR;
34006f92:	6803      	ldr	r3, [r0, #0]
34006f94:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
    tmp2 = hdcmipp->Instance->P1FSCR;
34006f98:	f8d3 1804 	ldr.w	r1, [r3, #2052]	@ 0x804
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
34006f9c:	430a      	orrs	r2, r1
34006f9e:	d4f5      	bmi.n	34006f8c <HAL_DCMIPP_PIPE_CSI_EnableShare+0x10>
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34006fa0:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
34006fa4:	2000      	movs	r0, #0
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34006fa6:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34006faa:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  return HAL_OK;
34006fae:	e7ee      	b.n	34006f8e <HAL_DCMIPP_PIPE_CSI_EnableShare+0x12>
34006fb0:	3401c3e6 	.word	0x3401c3e6

34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
{
34006fb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34006fb6:	460e      	mov	r6, r1
34006fb8:	4615      	mov	r5, r2
34006fba:	461c      	mov	r4, r3
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006fbc:	4607      	mov	r7, r0
34006fbe:	b908      	cbnz	r0, 34006fc4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x10>
    return HAL_ERROR;
34006fc0:	2001      	movs	r0, #1
}
34006fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hdcmipp == NULL) || (pCounter == NULL))
34006fc4:	2b00      	cmp	r3, #0
34006fc6:	d0fb      	beq.n	34006fc0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
  assert_param(IS_DCMIPP_PIPE(Pipe));
34006fc8:	2902      	cmp	r1, #2
34006fca:	d904      	bls.n	34006fd6 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x22>
34006fcc:	f44f 51e0 	mov.w	r1, #7168	@ 0x1c00
34006fd0:	4810      	ldr	r0, [pc, #64]	@ (34007014 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x60>)
34006fd2:	f7fb fab3 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
34006fd6:	1e6b      	subs	r3, r5, #1
34006fd8:	2b02      	cmp	r3, #2
34006fda:	d908      	bls.n	34006fee <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x3a>
34006fdc:	f641 4101 	movw	r1, #7169	@ 0x1c01
34006fe0:	480c      	ldr	r0, [pc, #48]	@ (34007014 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x60>)
34006fe2:	f7fb faab 	bl	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
34006fe6:	2e01      	cmp	r6, #1
34006fe8:	d1ea      	bne.n	34006fc0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
  return HAL_OK;
34006fea:	2000      	movs	r0, #0
34006fec:	e7e9      	b.n	34006fc2 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xe>
  if (Pipe == DCMIPP_PIPE1)
34006fee:	2e01      	cmp	r6, #1
34006ff0:	d1e6      	bne.n	34006fc0 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0xc>
    switch (ModuleID)
34006ff2:	2d02      	cmp	r5, #2
34006ff4:	683b      	ldr	r3, [r7, #0]
34006ff6:	d007      	beq.n	34007008 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x54>
34006ff8:	2d03      	cmp	r5, #3
34006ffa:	d008      	beq.n	3400700e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x5a>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34006ffc:	f8d3 3864 	ldr.w	r3, [r3, #2148]	@ 0x864
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34007000:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34007004:	6023      	str	r3, [r4, #0]
        break;
34007006:	e7f0      	b.n	34006fea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x36>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34007008:	f8d3 3868 	ldr.w	r3, [r3, #2152]	@ 0x868
3400700c:	e7f8      	b.n	34007000 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
3400700e:	f8d3 386c 	ldr.w	r3, [r3, #2156]	@ 0x86c
34007012:	e7f5      	b.n	34007000 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
34007014:	3401c3e6 	.word	0x3401c3e6

34007018 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007018:	2902      	cmp	r1, #2
{
3400701a:	b470      	push	{r4, r5, r6}
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400701c:	d905      	bls.n	3400702a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x12>
}
3400701e:	bc70      	pop	{r4, r5, r6}
  assert_param(IS_DCMIPP_PIPE(Pipe));
34007020:	f641 511f 	movw	r1, #7455	@ 0x1d1f
34007024:	484a      	ldr	r0, [pc, #296]	@ (34007150 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x138>)
34007026:	f7fb ba89 	b.w	3400253c <assert_failed>
  if (Pipe == DCMIPP_PIPE1)
3400702a:	2901      	cmp	r1, #1
3400702c:	f040 808d 	bne.w	3400714a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x132>
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
34007030:	6803      	ldr	r3, [r0, #0]
34007032:	f8d3 1880 	ldr.w	r1, [r3, #2176]	@ 0x880
                                                 ? ENABLE : DISABLE;
34007036:	f3c1 0080 	ubfx	r0, r1, #2, #1
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
3400703a:	f001 0102 	and.w	r1, r1, #2
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
3400703e:	7010      	strb	r0, [r2, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34007040:	7051      	strb	r1, [r2, #1]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34007042:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34007046:	4943      	ldr	r1, [pc, #268]	@ (34007154 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x13c>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34007048:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
3400704c:	ea40 0501 	orr.w	r5, r0, r1
34007050:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34007054:	bf18      	it	ne
34007056:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
34007058:	f8d3 4884 	ldr.w	r4, [r3, #2180]	@ 0x884
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
3400705c:	8090      	strh	r0, [r2, #4]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
3400705e:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34007062:	ea40 0501 	orr.w	r5, r0, r1
34007066:	f414 6f80 	tst.w	r4, #1024	@ 0x400
3400706a:	bf18      	it	ne
3400706c:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
3400706e:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34007072:	8050      	strh	r0, [r2, #2]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34007074:	4838      	ldr	r0, [pc, #224]	@ (34007158 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x140>)
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34007076:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
3400707a:	ea44 0600 	orr.w	r6, r4, r0
3400707e:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34007082:	bf18      	it	ne
34007084:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34007086:	f8d3 5888 	ldr.w	r5, [r3, #2184]	@ 0x888
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
3400708a:	8114      	strh	r4, [r2, #8]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
3400708c:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007090:	ea44 0601 	orr.w	r6, r4, r1
34007094:	f415 6f80 	tst.w	r5, #1024	@ 0x400
34007098:	bf18      	it	ne
3400709a:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
3400709c:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
340070a0:	80d4      	strh	r4, [r2, #6]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
340070a2:	f3c5 440a 	ubfx	r4, r5, #16, #11
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
340070a6:	ea44 0601 	orr.w	r6, r4, r1
340070aa:	f015 6f80 	tst.w	r5, #67108864	@ 0x4000000
340070ae:	bf18      	it	ne
340070b0:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
340070b2:	f8d3 588c 	ldr.w	r5, [r3, #2188]	@ 0x88c
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
340070b6:	8194      	strh	r4, [r2, #12]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
340070b8:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
340070bc:	ea44 0601 	orr.w	r6, r4, r1
340070c0:	f415 6f80 	tst.w	r5, #1024	@ 0x400
340070c4:	bf18      	it	ne
340070c6:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
340070c8:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
340070cc:	8154      	strh	r4, [r2, #10]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
340070ce:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
340070d2:	ea44 0600 	orr.w	r6, r4, r0
340070d6:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
340070da:	bf18      	it	ne
340070dc:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
340070de:	f8d3 5890 	ldr.w	r5, [r3, #2192]	@ 0x890
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
340070e2:	8214      	strh	r4, [r2, #16]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
340070e4:	f3c5 040a 	ubfx	r4, r5, #0, #11
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
340070e8:	ea44 0601 	orr.w	r6, r4, r1
340070ec:	f415 6f80 	tst.w	r5, #1024	@ 0x400
340070f0:	bf18      	it	ne
340070f2:	4634      	movne	r4, r6
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
340070f4:	f8d3 5898 	ldr.w	r5, [r3, #2200]	@ 0x898
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
340070f8:	81d4      	strh	r4, [r2, #14]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
340070fa:	f3c5 4409 	ubfx	r4, r5, #16, #10
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
340070fe:	4320      	orrs	r0, r4
34007100:	f015 7f00 	tst.w	r5, #33554432	@ 0x2000000
34007104:	bf18      	it	ne
34007106:	4604      	movne	r4, r0
34007108:	8314      	strh	r4, [r2, #24]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
3400710a:	f8d3 4898 	ldr.w	r4, [r3, #2200]	@ 0x898
3400710e:	f3c4 000a 	ubfx	r0, r4, #0, #11
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007112:	ea40 0501 	orr.w	r5, r0, r1
34007116:	f414 6f80 	tst.w	r4, #1024	@ 0x400
3400711a:	bf18      	it	ne
3400711c:	4628      	movne	r0, r5
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
3400711e:	f8d3 4894 	ldr.w	r4, [r3, #2196]	@ 0x894
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34007122:	82d0      	strh	r0, [r2, #22]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34007124:	f3c4 400a 	ubfx	r0, r4, #16, #11
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
34007128:	ea40 0501 	orr.w	r5, r0, r1
3400712c:	f014 6f80 	tst.w	r4, #67108864	@ 0x4000000
34007130:	bf18      	it	ne
34007132:	4628      	movne	r0, r5
34007134:	8290      	strh	r0, [r2, #20]
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
34007136:	f8d3 0894 	ldr.w	r0, [r3, #2196]	@ 0x894
3400713a:	f3c0 030a 	ubfx	r3, r0, #0, #11
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
3400713e:	4319      	orrs	r1, r3
34007140:	f410 6f80 	tst.w	r0, #1024	@ 0x400
34007144:	bf18      	it	ne
34007146:	460b      	movne	r3, r1
34007148:	8253      	strh	r3, [r2, #18]
}
3400714a:	bc70      	pop	{r4, r5, r6}
3400714c:	4770      	bx	lr
3400714e:	bf00      	nop
34007150:	3401c3e6 	.word	0x3401c3e6
34007154:	fffff800 	.word	0xfffff800
34007158:	fffffc00 	.word	0xfffffc00

3400715c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
{
3400715c:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
3400715e:	4a10      	ldr	r2, [pc, #64]	@ (340071a0 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x44>)
34007160:	6803      	ldr	r3, [r0, #0]
{
34007162:	4604      	mov	r4, r0
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34007164:	4293      	cmp	r3, r2
{
34007166:	460d      	mov	r5, r1
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
34007168:	d008      	beq.n	3400717c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x20>
3400716a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400716e:	4293      	cmp	r3, r2
34007170:	d004      	beq.n	3400717c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x20>
34007172:	f641 51c7 	movw	r1, #7623	@ 0x1dc7
34007176:	480b      	ldr	r0, [pc, #44]	@ (340071a4 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x48>)
34007178:	f7fb f9e0 	bl	3400253c <assert_failed>
  assert_param(IS_DCMIPP_PIPE(Pipe));
3400717c:	2d02      	cmp	r5, #2
3400717e:	d906      	bls.n	3400718e <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x32>
34007180:	f641 51c8 	movw	r1, #7624	@ 0x1dc8
34007184:	4807      	ldr	r0, [pc, #28]	@ (340071a4 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x48>)
34007186:	f7fb f9d9 	bl	3400253c <assert_failed>
    return 0;
3400718a:	2000      	movs	r0, #0
}
3400718c:	bd38      	pop	{r3, r4, r5, pc}
  if (Pipe == DCMIPP_PIPE1)
3400718e:	2d01      	cmp	r5, #1
34007190:	d1fb      	bne.n	3400718a <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2e>
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
34007192:	6823      	ldr	r3, [r4, #0]
34007194:	f8d3 0880 	ldr.w	r0, [r3, #2176]	@ 0x880
34007198:	f000 0001 	and.w	r0, r0, #1
3400719c:	e7f6      	b.n	3400718c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x30>
3400719e:	bf00      	nop
340071a0:	58002000 	.word	0x58002000
340071a4:	3401c3e6 	.word	0x3401c3e6

340071a8 <HAL_DCMIPP_GetState>:
  return hdcmipp->State;
340071a8:	7900      	ldrb	r0, [r0, #4]
}
340071aa:	4770      	bx	lr

340071ac <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
340071ac:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
340071ae:	6804      	ldr	r4, [r0, #0]
340071b0:	9d05      	ldr	r5, [sp, #20]
340071b2:	6c66      	ldr	r6, [r4, #68]	@ 0x44
340071b4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
340071b8:	6843      	ldr	r3, [r0, #4]
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
340071ba:	f006 4640 	and.w	r6, r6, #3221225472	@ 0xc0000000
340071be:	4335      	orrs	r5, r6
  if (hdma2d->Init.Mode == DMA2D_R2M)
340071c0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
340071c4:	6465      	str	r5, [r4, #68]	@ 0x44
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
340071c6:	63e2      	str	r2, [r4, #60]	@ 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
340071c8:	d12f      	bne.n	3400722a <DMA2D_SetConfig+0x7e>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
340071ca:	6880      	ldr	r0, [r0, #8]
340071cc:	f001 467f 	and.w	r6, r1, #4278190080	@ 0xff000000
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
340071d0:	f401 037f 	and.w	r3, r1, #16711680	@ 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
340071d4:	f401 427f 	and.w	r2, r1, #65280	@ 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
340071d8:	b2cd      	uxtb	r5, r1

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
340071da:	2803      	cmp	r0, #3
340071dc:	d81a      	bhi.n	34007214 <DMA2D_SetConfig+0x68>
340071de:	e8df f000 	tbb	[pc, r0]
340071e2:	0204      	.short	0x0204
340071e4:	0e06      	.short	0x0e06
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
    {
      tmp = (tmp3 | tmp2 | tmp4);
340071e6:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
      tmp3 = (tmp3 >> 12U);
      tmp4 = (tmp4 >> 4U);
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
340071ea:	63a1      	str	r1, [r4, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
340071ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
      tmp2 = (tmp2 >> 19U);
340071ee:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10U);
340071f0:	0a92      	lsrs	r2, r2, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
340071f2:	02c9      	lsls	r1, r1, #11
340071f4:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
340071f8:	ea41 01d5 	orr.w	r1, r1, r5, lsr #3
340071fc:	e7f5      	b.n	340071ea <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 19U);
340071fe:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11U);
34007200:	0ad2      	lsrs	r2, r2, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34007202:	029b      	lsls	r3, r3, #10
34007204:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
34007208:	ea43 03d5 	orr.w	r3, r3, r5, lsr #3
      tmp1 = (tmp1 >> 31U);
3400720c:	0ff1      	lsrs	r1, r6, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
3400720e:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
34007212:	e7ea      	b.n	340071ea <DMA2D_SetConfig+0x3e>
      tmp2 = (tmp2 >> 20U);
34007214:	0d1b      	lsrs	r3, r3, #20
      tmp3 = (tmp3 >> 12U);
34007216:	0b12      	lsrs	r2, r2, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34007218:	021b      	lsls	r3, r3, #8
3400721a:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
3400721e:	ea43 1315 	orr.w	r3, r3, r5, lsr #4
      tmp1 = (tmp1 >> 28U);
34007222:	0f36      	lsrs	r6, r6, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34007224:	ea43 3106 	orr.w	r1, r3, r6, lsl #12
34007228:	e7df      	b.n	340071ea <DMA2D_SetConfig+0x3e>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
3400722a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
3400722e:	bf0c      	ite	eq
34007230:	6161      	streq	r1, [r4, #20]
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
34007232:	60e1      	strne	r1, [r4, #12]
}
34007234:	e7da      	b.n	340071ec <DMA2D_SetConfig+0x40>

34007236 <HAL_DMA2D_MspInit>:
}
34007236:	4770      	bx	lr

34007238 <HAL_DMA2D_Init>:
{
34007238:	b510      	push	{r4, lr}
  if (hdma2d == NULL)
3400723a:	4604      	mov	r4, r0
3400723c:	2800      	cmp	r0, #0
3400723e:	d07d      	beq.n	3400733c <HAL_DMA2D_Init+0x104>
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
34007240:	6803      	ldr	r3, [r0, #0]
34007242:	4a3f      	ldr	r2, [pc, #252]	@ (34007340 <HAL_DMA2D_Init+0x108>)
34007244:	4293      	cmp	r3, r2
34007246:	d007      	beq.n	34007258 <HAL_DMA2D_Init+0x20>
34007248:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400724c:	4293      	cmp	r3, r2
3400724e:	d003      	beq.n	34007258 <HAL_DMA2D_Init+0x20>
34007250:	21f7      	movs	r1, #247	@ 0xf7
34007252:	483c      	ldr	r0, [pc, #240]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
34007254:	f7fb f972 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
34007258:	6863      	ldr	r3, [r4, #4]
3400725a:	f433 3240 	bics.w	r2, r3, #196608	@ 0x30000
3400725e:	d008      	beq.n	34007272 <HAL_DMA2D_Init+0x3a>
34007260:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34007264:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34007268:	d003      	beq.n	34007272 <HAL_DMA2D_Init+0x3a>
3400726a:	21f8      	movs	r1, #248	@ 0xf8
3400726c:	4835      	ldr	r0, [pc, #212]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
3400726e:	f7fb f965 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
34007272:	68a3      	ldr	r3, [r4, #8]
34007274:	2b04      	cmp	r3, #4
34007276:	d903      	bls.n	34007280 <HAL_DMA2D_Init+0x48>
34007278:	21f9      	movs	r1, #249	@ 0xf9
3400727a:	4832      	ldr	r0, [pc, #200]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
3400727c:	f7fb f95e 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
34007280:	68e3      	ldr	r3, [r4, #12]
34007282:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007286:	d303      	bcc.n	34007290 <HAL_DMA2D_Init+0x58>
34007288:	21fa      	movs	r1, #250	@ 0xfa
3400728a:	482e      	ldr	r0, [pc, #184]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
3400728c:	f7fb f956 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->Init.AlphaInverted));
34007290:	6923      	ldr	r3, [r4, #16]
34007292:	2b01      	cmp	r3, #1
34007294:	d903      	bls.n	3400729e <HAL_DMA2D_Init+0x66>
34007296:	21fb      	movs	r1, #251	@ 0xfb
34007298:	482a      	ldr	r0, [pc, #168]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
3400729a:	f7fb f94f 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->Init.RedBlueSwap));
3400729e:	6963      	ldr	r3, [r4, #20]
340072a0:	2b01      	cmp	r3, #1
340072a2:	d903      	bls.n	340072ac <HAL_DMA2D_Init+0x74>
340072a4:	21fc      	movs	r1, #252	@ 0xfc
340072a6:	4827      	ldr	r0, [pc, #156]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
340072a8:	f7fb f948 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_LOM_MODE(hdma2d->Init.LineOffsetMode));
340072ac:	69e3      	ldr	r3, [r4, #28]
340072ae:	f033 0340 	bics.w	r3, r3, #64	@ 0x40
340072b2:	d003      	beq.n	340072bc <HAL_DMA2D_Init+0x84>
340072b4:	21fd      	movs	r1, #253	@ 0xfd
340072b6:	4823      	ldr	r0, [pc, #140]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
340072b8:	f7fb f940 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_BYTES_SWAP(hdma2d->Init.BytesSwap));
340072bc:	69a3      	ldr	r3, [r4, #24]
340072be:	f433 7380 	bics.w	r3, r3, #256	@ 0x100
340072c2:	d003      	beq.n	340072cc <HAL_DMA2D_Init+0x94>
340072c4:	21fe      	movs	r1, #254	@ 0xfe
340072c6:	481f      	ldr	r0, [pc, #124]	@ (34007344 <HAL_DMA2D_Init+0x10c>)
340072c8:	f7fb f938 	bl	3400253c <assert_failed>
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
340072cc:	f894 3061 	ldrb.w	r3, [r4, #97]	@ 0x61
340072d0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
340072d4:	b923      	cbnz	r3, 340072e0 <HAL_DMA2D_Init+0xa8>
    HAL_DMA2D_MspInit(hdma2d);
340072d6:	4620      	mov	r0, r4
    hdma2d->Lock = HAL_UNLOCKED;
340072d8:	f884 2060 	strb.w	r2, [r4, #96]	@ 0x60
    HAL_DMA2D_MspInit(hdma2d);
340072dc:	f7ff ffab 	bl	34007236 <HAL_DMA2D_MspInit>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
340072e0:	2302      	movs	r3, #2
340072e2:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
340072e6:	6823      	ldr	r3, [r4, #0]
340072e8:	69e0      	ldr	r0, [r4, #28]
340072ea:	6819      	ldr	r1, [r3, #0]
340072ec:	6862      	ldr	r2, [r4, #4]
340072ee:	f421 21e0 	bic.w	r1, r1, #458752	@ 0x70000
340072f2:	4302      	orrs	r2, r0
340072f4:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
340072f8:	430a      	orrs	r2, r1
340072fa:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
340072fc:	6b59      	ldr	r1, [r3, #52]	@ 0x34
340072fe:	69a0      	ldr	r0, [r4, #24]
34007300:	68a2      	ldr	r2, [r4, #8]
34007302:	f421 7183 	bic.w	r1, r1, #262	@ 0x106
34007306:	4302      	orrs	r2, r0
34007308:	f021 0101 	bic.w	r1, r1, #1
3400730c:	430a      	orrs	r2, r1
3400730e:	635a      	str	r2, [r3, #52]	@ 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
34007310:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007312:	68e1      	ldr	r1, [r4, #12]
34007314:	f36f 020f 	bfc	r2, #0, #16
34007318:	430a      	orrs	r2, r1
3400731a:	641a      	str	r2, [r3, #64]	@ 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
3400731c:	6b59      	ldr	r1, [r3, #52]	@ 0x34
3400731e:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
34007322:	0552      	lsls	r2, r2, #21
34007324:	ea42 5200 	orr.w	r2, r2, r0, lsl #20
34007328:	f421 1140 	bic.w	r1, r1, #3145728	@ 0x300000
3400732c:	430a      	orrs	r2, r1
3400732e:	635a      	str	r2, [r3, #52]	@ 0x34
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34007330:	2000      	movs	r0, #0
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34007332:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34007334:	6660      	str	r0, [r4, #100]	@ 0x64
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34007336:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
}
3400733a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
3400733c:	2001      	movs	r0, #1
3400733e:	e7fc      	b.n	3400733a <HAL_DMA2D_Init+0x102>
34007340:	58021000 	.word	0x58021000
34007344:	3401c457 	.word	0x3401c457

34007348 <HAL_DMA2D_Start>:
{
34007348:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
3400734c:	f8dd 8020 	ldr.w	r8, [sp, #32]
34007350:	4604      	mov	r4, r0
  assert_param(IS_DMA2D_LINE(Height));
34007352:	f5b8 3f80 	cmp.w	r8, #65536	@ 0x10000
{
34007356:	460e      	mov	r6, r1
34007358:	4617      	mov	r7, r2
3400735a:	461d      	mov	r5, r3
  assert_param(IS_DMA2D_LINE(Height));
3400735c:	d304      	bcc.n	34007368 <HAL_DMA2D_Start+0x20>
3400735e:	f240 21a9 	movw	r1, #681	@ 0x2a9
34007362:	4813      	ldr	r0, [pc, #76]	@ (340073b0 <HAL_DMA2D_Start+0x68>)
34007364:	f7fb f8ea 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_PIXEL(Width));
34007368:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
3400736c:	d304      	bcc.n	34007378 <HAL_DMA2D_Start+0x30>
3400736e:	f240 21aa 	movw	r1, #682	@ 0x2aa
34007372:	480f      	ldr	r0, [pc, #60]	@ (340073b0 <HAL_DMA2D_Start+0x68>)
34007374:	f7fb f8e2 	bl	3400253c <assert_failed>
  __HAL_LOCK(hdma2d);
34007378:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
3400737c:	2002      	movs	r0, #2
3400737e:	2b01      	cmp	r3, #1
34007380:	d012      	beq.n	340073a8 <HAL_DMA2D_Start+0x60>
34007382:	2301      	movs	r3, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34007384:	f884 0061 	strb.w	r0, [r4, #97]	@ 0x61
  __HAL_LOCK(hdma2d);
34007388:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
3400738c:	463a      	mov	r2, r7
3400738e:	462b      	mov	r3, r5
34007390:	4620      	mov	r0, r4
34007392:	4631      	mov	r1, r6
34007394:	f8cd 8000 	str.w	r8, [sp]
34007398:	f7ff ff08 	bl	340071ac <DMA2D_SetConfig>
  return HAL_OK;
3400739c:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
3400739e:	6822      	ldr	r2, [r4, #0]
340073a0:	6813      	ldr	r3, [r2, #0]
340073a2:	f043 0301 	orr.w	r3, r3, #1
340073a6:	6013      	str	r3, [r2, #0]
}
340073a8:	b002      	add	sp, #8
340073aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
340073ae:	bf00      	nop
340073b0:	3401c457 	.word	0x3401c457

340073b4 <HAL_DMA2D_PollForTransfer>:
  __IO uint32_t isrflags = 0x0U;
340073b4:	2300      	movs	r3, #0
{
340073b6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
340073b8:	9301      	str	r3, [sp, #4]
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
340073ba:	6803      	ldr	r3, [r0, #0]
{
340073bc:	4604      	mov	r4, r0
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
340073be:	681b      	ldr	r3, [r3, #0]
{
340073c0:	460d      	mov	r5, r1
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
340073c2:	07db      	lsls	r3, r3, #31
340073c4:	d418      	bmi.n	340073f8 <HAL_DMA2D_PollForTransfer+0x44>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
340073c6:	6822      	ldr	r2, [r4, #0]
340073c8:	69d3      	ldr	r3, [r2, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
340073ca:	6a52      	ldr	r2, [r2, #36]	@ 0x24
340073cc:	4313      	orrs	r3, r2
  if (layer_start != 0U)
340073ce:	069e      	lsls	r6, r3, #26
340073d0:	d506      	bpl.n	340073e0 <HAL_DMA2D_PollForTransfer+0x2c>
    tickstart = HAL_GetTick();
340073d2:	f7fd fa8d 	bl	340048f0 <HAL_GetTick>
340073d6:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
340073d8:	6823      	ldr	r3, [r4, #0]
340073da:	685a      	ldr	r2, [r3, #4]
340073dc:	06d2      	lsls	r2, r2, #27
340073de:	d53f      	bpl.n	34007460 <HAL_DMA2D_PollForTransfer+0xac>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
340073e0:	2212      	movs	r2, #18
340073e2:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
340073e4:	2000      	movs	r0, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
340073e6:	609a      	str	r2, [r3, #8]
  hdma2d->State = HAL_DMA2D_STATE_READY;
340073e8:	2301      	movs	r3, #1
340073ea:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        __HAL_UNLOCK(hdma2d);
340073ee:	2300      	movs	r3, #0
340073f0:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
}
340073f4:	b002      	add	sp, #8
340073f6:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick();
340073f8:	f7fd fa7a 	bl	340048f0 <HAL_GetTick>
340073fc:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
340073fe:	6823      	ldr	r3, [r4, #0]
34007400:	685a      	ldr	r2, [r3, #4]
34007402:	0792      	lsls	r2, r2, #30
34007404:	d4df      	bmi.n	340073c6 <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34007406:	685a      	ldr	r2, [r3, #4]
34007408:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
3400740a:	9a01      	ldr	r2, [sp, #4]
3400740c:	f012 0f21 	tst.w	r2, #33	@ 0x21
34007410:	d014      	beq.n	3400743c <HAL_DMA2D_PollForTransfer+0x88>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34007412:	9a01      	ldr	r2, [sp, #4]
34007414:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34007416:	bf42      	ittt	mi
34007418:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
3400741a:	f042 0202 	orrmi.w	r2, r2, #2
3400741e:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34007420:	9a01      	ldr	r2, [sp, #4]
34007422:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34007424:	bf42      	ittt	mi
34007426:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007428:	f042 0201 	orrmi.w	r2, r2, #1
3400742c:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3400742e:	2221      	movs	r2, #33	@ 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34007430:	609a      	str	r2, [r3, #8]
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34007432:	2304      	movs	r3, #4
        return HAL_ERROR;
34007434:	2001      	movs	r0, #1
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34007436:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
        return HAL_ERROR;
3400743a:	e7d8      	b.n	340073ee <HAL_DMA2D_PollForTransfer+0x3a>
      if (Timeout != HAL_MAX_DELAY)
3400743c:	1c69      	adds	r1, r5, #1
3400743e:	d0df      	beq.n	34007400 <HAL_DMA2D_PollForTransfer+0x4c>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34007440:	f7fd fa56 	bl	340048f0 <HAL_GetTick>
34007444:	1b80      	subs	r0, r0, r6
34007446:	42a8      	cmp	r0, r5
34007448:	d801      	bhi.n	3400744e <HAL_DMA2D_PollForTransfer+0x9a>
3400744a:	2d00      	cmp	r5, #0
3400744c:	d1d7      	bne.n	340073fe <HAL_DMA2D_PollForTransfer+0x4a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
3400744e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
          return HAL_TIMEOUT;
34007450:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34007452:	f043 0320 	orr.w	r3, r3, #32
34007456:	6663      	str	r3, [r4, #100]	@ 0x64
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34007458:	2303      	movs	r3, #3
3400745a:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
          return HAL_TIMEOUT;
3400745e:	e7c6      	b.n	340073ee <HAL_DMA2D_PollForTransfer+0x3a>
      isrflags = READ_REG(hdma2d->Instance->ISR);
34007460:	685a      	ldr	r2, [r3, #4]
34007462:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34007464:	9a01      	ldr	r2, [sp, #4]
34007466:	f012 0f29 	tst.w	r2, #41	@ 0x29
3400746a:	d016      	beq.n	3400749a <HAL_DMA2D_PollForTransfer+0xe6>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
3400746c:	9a01      	ldr	r2, [sp, #4]
3400746e:	0716      	lsls	r6, r2, #28
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34007470:	bf42      	ittt	mi
34007472:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007474:	f042 0204 	orrmi.w	r2, r2, #4
34007478:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
3400747a:	9a01      	ldr	r2, [sp, #4]
3400747c:	0695      	lsls	r5, r2, #26
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
3400747e:	bf42      	ittt	mi
34007480:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007482:	f042 0202 	orrmi.w	r2, r2, #2
34007486:	6662      	strmi	r2, [r4, #100]	@ 0x64
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34007488:	9a01      	ldr	r2, [sp, #4]
3400748a:	07d0      	lsls	r0, r2, #31
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
3400748c:	bf42      	ittt	mi
3400748e:	6e62      	ldrmi	r2, [r4, #100]	@ 0x64
34007490:	f042 0201 	orrmi.w	r2, r2, #1
34007494:	6662      	strmi	r2, [r4, #100]	@ 0x64
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34007496:	2229      	movs	r2, #41	@ 0x29
34007498:	e7ca      	b.n	34007430 <HAL_DMA2D_PollForTransfer+0x7c>
      if (Timeout != HAL_MAX_DELAY)
3400749a:	1c69      	adds	r1, r5, #1
3400749c:	d09d      	beq.n	340073da <HAL_DMA2D_PollForTransfer+0x26>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3400749e:	f7fd fa27 	bl	340048f0 <HAL_GetTick>
340074a2:	1b80      	subs	r0, r0, r6
340074a4:	42a8      	cmp	r0, r5
340074a6:	d8d2      	bhi.n	3400744e <HAL_DMA2D_PollForTransfer+0x9a>
340074a8:	2d00      	cmp	r5, #0
340074aa:	d195      	bne.n	340073d8 <HAL_DMA2D_PollForTransfer+0x24>
340074ac:	e7cf      	b.n	3400744e <HAL_DMA2D_PollForTransfer+0x9a>
	...

340074b0 <HAL_DMA2D_ConfigLayer>:
  assert_param(IS_DMA2D_LAYER(LayerIdx));
340074b0:	2901      	cmp	r1, #1
{
340074b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
340074b4:	4604      	mov	r4, r0
340074b6:	460d      	mov	r5, r1
  assert_param(IS_DMA2D_LAYER(LayerIdx));
340074b8:	d904      	bls.n	340074c4 <HAL_DMA2D_ConfigLayer+0x14>
340074ba:	f240 61f3 	movw	r1, #1779	@ 0x6f3
340074be:	4850      	ldr	r0, [pc, #320]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
340074c0:	f7fb f83c 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
340074c4:	231c      	movs	r3, #28
340074c6:	fb03 4305 	mla	r3, r3, r5, r4
340074ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340074cc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340074d0:	d304      	bcc.n	340074dc <HAL_DMA2D_ConfigLayer+0x2c>
340074d2:	f240 61f4 	movw	r1, #1780	@ 0x6f4
340074d6:	484a      	ldr	r0, [pc, #296]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
340074d8:	f7fb f830 	bl	3400253c <assert_failed>
  if (hdma2d->Init.Mode != DMA2D_R2M)
340074dc:	6863      	ldr	r3, [r4, #4]
340074de:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340074e2:	d017      	beq.n	34007514 <HAL_DMA2D_ConfigLayer+0x64>
    assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
340074e4:	231c      	movs	r3, #28
340074e6:	fb03 4305 	mla	r3, r3, r5, r4
340074ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340074ec:	2b0b      	cmp	r3, #11
340074ee:	d904      	bls.n	340074fa <HAL_DMA2D_ConfigLayer+0x4a>
340074f0:	f240 61f7 	movw	r1, #1783	@ 0x6f7
340074f4:	4842      	ldr	r0, [pc, #264]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
340074f6:	f7fb f821 	bl	3400253c <assert_failed>
    if (hdma2d->Init.Mode != DMA2D_M2M)
340074fa:	6863      	ldr	r3, [r4, #4]
340074fc:	b153      	cbz	r3, 34007514 <HAL_DMA2D_ConfigLayer+0x64>
      assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
340074fe:	231c      	movs	r3, #28
34007500:	fb03 4305 	mla	r3, r3, r5, r4
34007504:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34007506:	2b02      	cmp	r3, #2
34007508:	d904      	bls.n	34007514 <HAL_DMA2D_ConfigLayer+0x64>
3400750a:	f240 61fa 	movw	r1, #1786	@ 0x6fa
3400750e:	483c      	ldr	r0, [pc, #240]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
34007510:	f7fb f814 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
34007514:	261c      	movs	r6, #28
34007516:	fb06 4305 	mla	r3, r6, r5, r4
3400751a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400751c:	2b01      	cmp	r3, #1
3400751e:	d904      	bls.n	3400752a <HAL_DMA2D_ConfigLayer+0x7a>
34007520:	f240 61fd 	movw	r1, #1789	@ 0x6fd
34007524:	4836      	ldr	r0, [pc, #216]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
34007526:	f7fb f809 	bl	3400253c <assert_failed>
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
3400752a:	fb06 4605 	mla	r6, r6, r5, r4
3400752e:	6bf3      	ldr	r3, [r6, #60]	@ 0x3c
34007530:	2b01      	cmp	r3, #1
34007532:	d904      	bls.n	3400753e <HAL_DMA2D_ConfigLayer+0x8e>
34007534:	f240 61fe 	movw	r1, #1790	@ 0x6fe
34007538:	4831      	ldr	r0, [pc, #196]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
3400753a:	f7fa ffff 	bl	3400253c <assert_failed>
  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
3400753e:	2d01      	cmp	r5, #1
34007540:	d10a      	bne.n	34007558 <HAL_DMA2D_ConfigLayer+0xa8>
34007542:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
34007544:	2b0b      	cmp	r3, #11
34007546:	d107      	bne.n	34007558 <HAL_DMA2D_ConfigLayer+0xa8>
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
34007548:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
3400754a:	2b02      	cmp	r3, #2
3400754c:	d904      	bls.n	34007558 <HAL_DMA2D_ConfigLayer+0xa8>
3400754e:	f240 7102 	movw	r1, #1794	@ 0x702
34007552:	482b      	ldr	r0, [pc, #172]	@ (34007600 <HAL_DMA2D_ConfigLayer+0x150>)
34007554:	f7fa fff2 	bl	3400253c <assert_failed>
  __HAL_LOCK(hdma2d);
34007558:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
3400755c:	2002      	movs	r0, #2
3400755e:	2b01      	cmp	r3, #1
34007560:	d033      	beq.n	340075ca <HAL_DMA2D_ConfigLayer+0x11a>
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007562:	211c      	movs	r1, #28
  __HAL_LOCK(hdma2d);
34007564:	2301      	movs	r3, #1
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007566:	fb01 4105 	mla	r1, r1, r5, r4
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3400756a:	f884 0061 	strb.w	r0, [r4, #97]	@ 0x61
  __HAL_LOCK(hdma2d);
3400756e:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007572:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007574:	e9d1 620b 	ldrd	r6, r2, [r1, #44]	@ 0x2c
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007578:	051b      	lsls	r3, r3, #20
3400757a:	6b4f      	ldr	r7, [r1, #52]	@ 0x34
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400757c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34007580:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34007582:	4333      	orrs	r3, r6
34007584:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34007588:	f1a6 0009 	sub.w	r0, r6, #9
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
3400758c:	f007 427f 	and.w	r2, r7, #4278190080	@ 0xff000000
34007590:	431a      	orrs	r2, r3
34007592:	2801      	cmp	r0, #1
34007594:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
34007598:	bf98      	it	ls
3400759a:	4613      	movls	r3, r2
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
3400759c:	6822      	ldr	r2, [r4, #0]
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
3400759e:	b9ad      	cbnz	r5, 340075cc <HAL_DMA2D_ConfigLayer+0x11c>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340075a0:	6a55      	ldr	r5, [r2, #36]	@ 0x24
340075a2:	4918      	ldr	r1, [pc, #96]	@ (34007604 <HAL_DMA2D_ConfigLayer+0x154>)
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340075a4:	2801      	cmp	r0, #1
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340075a6:	ea01 0105 	and.w	r1, r1, r5
340075aa:	ea41 0103 	orr.w	r1, r1, r3
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
340075ae:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
340075b0:	6251      	str	r1, [r2, #36]	@ 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
340075b2:	6193      	str	r3, [r2, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340075b4:	d803      	bhi.n	340075be <HAL_DMA2D_ConfigLayer+0x10e>
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
340075b6:	6b63      	ldr	r3, [r4, #52]	@ 0x34
340075b8:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340075bc:	6293      	str	r3, [r2, #40]	@ 0x28
  hdma2d->State = HAL_DMA2D_STATE_READY;
340075be:	2301      	movs	r3, #1
  __HAL_UNLOCK(hdma2d);
340075c0:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
340075c2:	f884 3061 	strb.w	r3, [r4, #97]	@ 0x61
  __HAL_UNLOCK(hdma2d);
340075c6:	f884 0060 	strb.w	r0, [r4, #96]	@ 0x60
}
340075ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
340075cc:	2e0b      	cmp	r6, #11
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
340075ce:	bf03      	ittte	eq
340075d0:	6c09      	ldreq	r1, [r1, #64]	@ 0x40
      regMask  |= DMA2D_FGPFCCR_CSS;
340075d2:	4e0d      	ldreq	r6, [pc, #52]	@ (34007608 <HAL_DMA2D_ConfigLayer+0x158>)
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
340075d4:	ea43 4381 	orreq.w	r3, r3, r1, lsl #18
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
340075d8:	4e0c      	ldrne	r6, [pc, #48]	@ (3400760c <HAL_DMA2D_ConfigLayer+0x15c>)
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
340075da:	69d1      	ldr	r1, [r2, #28]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
340075dc:	2801      	cmp	r0, #1
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
340075de:	ea21 0106 	bic.w	r1, r1, r6
340075e2:	ea43 0301 	orr.w	r3, r3, r1
340075e6:	61d3      	str	r3, [r2, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
340075e8:	f04f 031c 	mov.w	r3, #28
340075ec:	fb03 4505 	mla	r5, r3, r5, r4
340075f0:	6aab      	ldr	r3, [r5, #40]	@ 0x28
340075f2:	6113      	str	r3, [r2, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
340075f4:	bf9e      	ittt	ls
340075f6:	6b6b      	ldrls	r3, [r5, #52]	@ 0x34
340075f8:	f023 437f 	bicls.w	r3, r3, #4278190080	@ 0xff000000
340075fc:	6213      	strls	r3, [r2, #32]
340075fe:	e7de      	b.n	340075be <HAL_DMA2D_ConfigLayer+0x10e>
34007600:	3401c457 	.word	0x3401c457
34007604:	00ccfff0 	.word	0x00ccfff0
34007608:	ff3f000f 	.word	0xff3f000f
3400760c:	ff33000f 	.word	0xff33000f

34007610 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34007610:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t temp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007614:	4b47      	ldr	r3, [pc, #284]	@ (34007734 <HAL_GPIO_Init+0x124>)
{
34007616:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007618:	4298      	cmp	r0, r3
{
3400761a:	460e      	mov	r6, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
3400761c:	d054      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400761e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007622:	4298      	cmp	r0, r3
34007624:	d050      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007626:	4b44      	ldr	r3, [pc, #272]	@ (34007738 <HAL_GPIO_Init+0x128>)
34007628:	4298      	cmp	r0, r3
3400762a:	d04d      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400762c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007630:	4298      	cmp	r0, r3
34007632:	d049      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007634:	4b41      	ldr	r3, [pc, #260]	@ (3400773c <HAL_GPIO_Init+0x12c>)
34007636:	4298      	cmp	r0, r3
34007638:	d046      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400763a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400763e:	4298      	cmp	r0, r3
34007640:	d042      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007642:	4b3f      	ldr	r3, [pc, #252]	@ (34007740 <HAL_GPIO_Init+0x130>)
34007644:	4298      	cmp	r0, r3
34007646:	d03f      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007648:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400764c:	4298      	cmp	r0, r3
3400764e:	d03b      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007650:	4b3c      	ldr	r3, [pc, #240]	@ (34007744 <HAL_GPIO_Init+0x134>)
34007652:	4298      	cmp	r0, r3
34007654:	d038      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007656:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400765a:	4298      	cmp	r0, r3
3400765c:	d034      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400765e:	4b3a      	ldr	r3, [pc, #232]	@ (34007748 <HAL_GPIO_Init+0x138>)
34007660:	4298      	cmp	r0, r3
34007662:	d031      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007664:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007668:	4298      	cmp	r0, r3
3400766a:	d02d      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400766c:	4b37      	ldr	r3, [pc, #220]	@ (3400774c <HAL_GPIO_Init+0x13c>)
3400766e:	4298      	cmp	r0, r3
34007670:	d02a      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007672:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007676:	4298      	cmp	r0, r3
34007678:	d026      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400767a:	4b35      	ldr	r3, [pc, #212]	@ (34007750 <HAL_GPIO_Init+0x140>)
3400767c:	4298      	cmp	r0, r3
3400767e:	d023      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007680:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007684:	4298      	cmp	r0, r3
34007686:	d01f      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007688:	4b32      	ldr	r3, [pc, #200]	@ (34007754 <HAL_GPIO_Init+0x144>)
3400768a:	4298      	cmp	r0, r3
3400768c:	d01c      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400768e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007692:	4298      	cmp	r0, r3
34007694:	d018      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
34007696:	4b30      	ldr	r3, [pc, #192]	@ (34007758 <HAL_GPIO_Init+0x148>)
34007698:	4298      	cmp	r0, r3
3400769a:	d015      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
3400769c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340076a0:	4298      	cmp	r0, r3
340076a2:	d011      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
340076a4:	4b2d      	ldr	r3, [pc, #180]	@ (3400775c <HAL_GPIO_Init+0x14c>)
340076a6:	4298      	cmp	r0, r3
340076a8:	d00e      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
340076aa:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340076ae:	4298      	cmp	r0, r3
340076b0:	d00a      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
340076b2:	4b2b      	ldr	r3, [pc, #172]	@ (34007760 <HAL_GPIO_Init+0x150>)
340076b4:	4298      	cmp	r0, r3
340076b6:	d007      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
340076b8:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
340076bc:	4298      	cmp	r0, r3
340076be:	d003      	beq.n	340076c8 <HAL_GPIO_Init+0xb8>
340076c0:	21ad      	movs	r1, #173	@ 0xad
340076c2:	4828      	ldr	r0, [pc, #160]	@ (34007764 <HAL_GPIO_Init+0x154>)
340076c4:	f7fa ff3a 	bl	3400253c <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
340076c8:	6833      	ldr	r3, [r6, #0]
340076ca:	b29a      	uxth	r2, r3
340076cc:	b112      	cbz	r2, 340076d4 <HAL_GPIO_Init+0xc4>
340076ce:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340076d2:	d303      	bcc.n	340076dc <HAL_GPIO_Init+0xcc>
340076d4:	21ae      	movs	r1, #174	@ 0xae
340076d6:	4823      	ldr	r0, [pc, #140]	@ (34007764 <HAL_GPIO_Init+0x154>)
340076d8:	f7fa ff30 	bl	3400253c <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
340076dc:	6873      	ldr	r3, [r6, #4]
340076de:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
340076e2:	d011      	beq.n	34007708 <HAL_GPIO_Init+0xf8>
340076e4:	d81d      	bhi.n	34007722 <HAL_GPIO_Init+0x112>
340076e6:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
340076ea:	d00d      	beq.n	34007708 <HAL_GPIO_Init+0xf8>
340076ec:	d809      	bhi.n	34007702 <HAL_GPIO_Init+0xf2>
340076ee:	2b03      	cmp	r3, #3
340076f0:	d90a      	bls.n	34007708 <HAL_GPIO_Init+0xf8>
340076f2:	3b11      	subs	r3, #17
340076f4:	2b01      	cmp	r3, #1
340076f6:	d907      	bls.n	34007708 <HAL_GPIO_Init+0xf8>
340076f8:	21af      	movs	r1, #175	@ 0xaf
340076fa:	481a      	ldr	r0, [pc, #104]	@ (34007764 <HAL_GPIO_Init+0x154>)
340076fc:	f7fa ff1e 	bl	3400253c <assert_failed>
34007700:	e002      	b.n	34007708 <HAL_GPIO_Init+0xf8>
34007702:	f5b3 1f90 	cmp.w	r3, #1179648	@ 0x120000
34007706:	d1f7      	bne.n	340076f8 <HAL_GPIO_Init+0xe8>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = EXTI->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007708:	f04f 0900 	mov.w	r9, #0
3400770c:	464f      	mov	r7, r9
3400770e:	f8df 8024 	ldr.w	r8, [pc, #36]	@ 34007734 <HAL_GPIO_Init+0x124>
        EXTI->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34007712:	f8df a054 	ldr.w	sl, [pc, #84]	@ 34007768 <HAL_GPIO_Init+0x158>
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34007716:	6835      	ldr	r5, [r6, #0]
34007718:	fa35 f307 	lsrs.w	r3, r5, r7
3400771c:	d126      	bne.n	3400776c <HAL_GPIO_Init+0x15c>
      }
    }

    position++;
  }
}
3400771e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
34007722:	f5b3 1f44 	cmp.w	r3, #3211264	@ 0x310000
34007726:	d0ef      	beq.n	34007708 <HAL_GPIO_Init+0xf8>
34007728:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400772c:	f5b3 1f08 	cmp.w	r3, #2228224	@ 0x220000
34007730:	e7e9      	b.n	34007706 <HAL_GPIO_Init+0xf6>
34007732:	bf00      	nop
34007734:	56020000 	.word	0x56020000
34007738:	56020400 	.word	0x56020400
3400773c:	56020800 	.word	0x56020800
34007740:	56020c00 	.word	0x56020c00
34007744:	56021000 	.word	0x56021000
34007748:	56021400 	.word	0x56021400
3400774c:	56021800 	.word	0x56021800
34007750:	56021c00 	.word	0x56021c00
34007754:	56023400 	.word	0x56023400
34007758:	56023800 	.word	0x56023800
3400775c:	56023c00 	.word	0x56023c00
34007760:	56024000 	.word	0x56024000
34007764:	3401c4c7 	.word	0x3401c4c7
34007768:	56025000 	.word	0x56025000
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
3400776c:	f04f 0b01 	mov.w	fp, #1
34007770:	fa0b fb07 	lsl.w	fp, fp, r7
    if (iocurrent != 0x00u)
34007774:	ea1b 0505 	ands.w	r5, fp, r5
34007778:	f000 8130 	beq.w	340079dc <HAL_GPIO_Init+0x3cc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
3400777c:	6873      	ldr	r3, [r6, #4]
3400777e:	f003 0303 	and.w	r3, r3, #3
34007782:	3b01      	subs	r3, #1
34007784:	2b01      	cmp	r3, #1
34007786:	d81a      	bhi.n	340077be <HAL_GPIO_Init+0x1ae>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
34007788:	68f3      	ldr	r3, [r6, #12]
3400778a:	2b03      	cmp	r3, #3
3400778c:	d903      	bls.n	34007796 <HAL_GPIO_Init+0x186>
3400778e:	21be      	movs	r1, #190	@ 0xbe
34007790:	489e      	ldr	r0, [pc, #632]	@ (34007a0c <HAL_GPIO_Init+0x3fc>)
34007792:	f7fa fed3 	bl	3400253c <assert_failed>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34007796:	2303      	movs	r3, #3
        temp = GPIOx->OSPEEDR;
34007798:	68a2      	ldr	r2, [r4, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400779a:	fa03 f309 	lsl.w	r3, r3, r9
3400779e:	ea22 0203 	bic.w	r2, r2, r3
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
340077a2:	68f3      	ldr	r3, [r6, #12]
340077a4:	fa03 f309 	lsl.w	r3, r3, r9
340077a8:	4313      	orrs	r3, r2
        GPIOx->OSPEEDR = temp;
340077aa:	60a3      	str	r3, [r4, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
340077ac:	6873      	ldr	r3, [r6, #4]
        temp = GPIOx->OTYPER;
340077ae:	6862      	ldr	r2, [r4, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
340077b0:	f3c3 1300 	ubfx	r3, r3, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
340077b4:	ea22 020b 	bic.w	r2, r2, fp
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
340077b8:	40bb      	lsls	r3, r7
340077ba:	4313      	orrs	r3, r2
        GPIOx->OTYPER = temp;
340077bc:	6063      	str	r3, [r4, #4]
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
340077be:	e9d6 3201 	ldrd	r3, r2, [r6, #4]
340077c2:	f003 0303 	and.w	r3, r3, #3
340077c6:	2b03      	cmp	r3, #3
340077c8:	d102      	bne.n	340077d0 <HAL_GPIO_Init+0x1c0>
340077ca:	2a01      	cmp	r2, #1
340077cc:	f000 8082 	beq.w	340078d4 <HAL_GPIO_Init+0x2c4>
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
340077d0:	2a02      	cmp	r2, #2
340077d2:	d903      	bls.n	340077dc <HAL_GPIO_Init+0x1cc>
340077d4:	21d1      	movs	r1, #209	@ 0xd1
340077d6:	488d      	ldr	r0, [pc, #564]	@ (34007a0c <HAL_GPIO_Init+0x3fc>)
340077d8:	f7fa feb0 	bl	3400253c <assert_failed>
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340077dc:	2303      	movs	r3, #3
        temp = GPIOx->PUPDR;
340077de:	68e2      	ldr	r2, [r4, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340077e0:	fa03 f309 	lsl.w	r3, r3, r9
340077e4:	ea22 0203 	bic.w	r2, r2, r3
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
340077e8:	68b3      	ldr	r3, [r6, #8]
340077ea:	fa03 f309 	lsl.w	r3, r3, r9
340077ee:	4313      	orrs	r3, r2
        GPIOx->PUPDR = temp;
340077f0:	60e3      	str	r3, [r4, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
340077f2:	6873      	ldr	r3, [r6, #4]
340077f4:	f003 0303 	and.w	r3, r3, #3
340077f8:	2b02      	cmp	r3, #2
340077fa:	d16b      	bne.n	340078d4 <HAL_GPIO_Init+0x2c4>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
340077fc:	4544      	cmp	r4, r8
340077fe:	d053      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007800:	4b83      	ldr	r3, [pc, #524]	@ (34007a10 <HAL_GPIO_Init+0x400>)
34007802:	429c      	cmp	r4, r3
34007804:	d050      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007806:	4b83      	ldr	r3, [pc, #524]	@ (34007a14 <HAL_GPIO_Init+0x404>)
34007808:	429c      	cmp	r4, r3
3400780a:	d04d      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400780c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007810:	429c      	cmp	r4, r3
34007812:	d049      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007814:	4b80      	ldr	r3, [pc, #512]	@ (34007a18 <HAL_GPIO_Init+0x408>)
34007816:	429c      	cmp	r4, r3
34007818:	d046      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400781a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400781e:	429c      	cmp	r4, r3
34007820:	d042      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007822:	4b7e      	ldr	r3, [pc, #504]	@ (34007a1c <HAL_GPIO_Init+0x40c>)
34007824:	429c      	cmp	r4, r3
34007826:	d03f      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007828:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400782c:	429c      	cmp	r4, r3
3400782e:	d03b      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007830:	4b7b      	ldr	r3, [pc, #492]	@ (34007a20 <HAL_GPIO_Init+0x410>)
34007832:	429c      	cmp	r4, r3
34007834:	d038      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007836:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400783a:	429c      	cmp	r4, r3
3400783c:	d034      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400783e:	4b79      	ldr	r3, [pc, #484]	@ (34007a24 <HAL_GPIO_Init+0x414>)
34007840:	429c      	cmp	r4, r3
34007842:	d031      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007844:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007848:	429c      	cmp	r4, r3
3400784a:	d02d      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400784c:	4b76      	ldr	r3, [pc, #472]	@ (34007a28 <HAL_GPIO_Init+0x418>)
3400784e:	429c      	cmp	r4, r3
34007850:	d02a      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007852:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007856:	429c      	cmp	r4, r3
34007858:	d026      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400785a:	4b74      	ldr	r3, [pc, #464]	@ (34007a2c <HAL_GPIO_Init+0x41c>)
3400785c:	429c      	cmp	r4, r3
3400785e:	d023      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007860:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007864:	429c      	cmp	r4, r3
34007866:	d01f      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007868:	4b71      	ldr	r3, [pc, #452]	@ (34007a30 <HAL_GPIO_Init+0x420>)
3400786a:	429c      	cmp	r4, r3
3400786c:	d01c      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400786e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007872:	429c      	cmp	r4, r3
34007874:	d018      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007876:	4b6f      	ldr	r3, [pc, #444]	@ (34007a34 <HAL_GPIO_Init+0x424>)
34007878:	429c      	cmp	r4, r3
3400787a:	d015      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400787c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007880:	429c      	cmp	r4, r3
34007882:	d011      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007884:	4b6c      	ldr	r3, [pc, #432]	@ (34007a38 <HAL_GPIO_Init+0x428>)
34007886:	429c      	cmp	r4, r3
34007888:	d00e      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
3400788a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400788e:	429c      	cmp	r4, r3
34007890:	d00a      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007892:	4b6a      	ldr	r3, [pc, #424]	@ (34007a3c <HAL_GPIO_Init+0x42c>)
34007894:	429c      	cmp	r4, r3
34007896:	d007      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
34007898:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
3400789c:	429c      	cmp	r4, r3
3400789e:	d003      	beq.n	340078a8 <HAL_GPIO_Init+0x298>
340078a0:	21de      	movs	r1, #222	@ 0xde
340078a2:	485a      	ldr	r0, [pc, #360]	@ (34007a0c <HAL_GPIO_Init+0x3fc>)
340078a4:	f7fa fe4a 	bl	3400253c <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
340078a8:	6933      	ldr	r3, [r6, #16]
340078aa:	2b0f      	cmp	r3, #15
340078ac:	d903      	bls.n	340078b6 <HAL_GPIO_Init+0x2a6>
340078ae:	21df      	movs	r1, #223	@ 0xdf
340078b0:	4856      	ldr	r0, [pc, #344]	@ (34007a0c <HAL_GPIO_Init+0x3fc>)
340078b2:	f7fa fe43 	bl	3400253c <assert_failed>
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340078b6:	230f      	movs	r3, #15
        temp = GPIOx->AFR[position >> 3u];
340078b8:	08fa      	lsrs	r2, r7, #3
340078ba:	eb04 0282 	add.w	r2, r4, r2, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340078be:	f007 0107 	and.w	r1, r7, #7
        temp = GPIOx->AFR[position >> 3u];
340078c2:	6a10      	ldr	r0, [r2, #32]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340078c4:	0089      	lsls	r1, r1, #2
340078c6:	408b      	lsls	r3, r1
340078c8:	ea20 0003 	bic.w	r0, r0, r3
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340078cc:	6933      	ldr	r3, [r6, #16]
340078ce:	408b      	lsls	r3, r1
340078d0:	4303      	orrs	r3, r0
        GPIOx->AFR[position >> 3u] = temp;
340078d2:	6213      	str	r3, [r2, #32]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340078d4:	2303      	movs	r3, #3
      temp = GPIOx->MODER;
340078d6:	6820      	ldr	r0, [r4, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
340078d8:	fa03 f209 	lsl.w	r2, r3, r9
340078dc:	ea20 0002 	bic.w	r0, r0, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
340078e0:	6872      	ldr	r2, [r6, #4]
340078e2:	ea02 0103 	and.w	r1, r2, r3
340078e6:	fa01 f109 	lsl.w	r1, r1, r9
340078ea:	4301      	orrs	r1, r0
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
340078ec:	f412 3f40 	tst.w	r2, #196608	@ 0x30000
      GPIOx->MODER = temp;
340078f0:	6021      	str	r1, [r4, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
340078f2:	d073      	beq.n	340079dc <HAL_GPIO_Init+0x3cc>
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340078f4:	f04f 0e0f 	mov.w	lr, #15
340078f8:	f027 0103 	bic.w	r1, r7, #3
340078fc:	f101 41ac 	add.w	r1, r1, #1442840576	@ 0x56000000
34007900:	f501 3114 	add.w	r1, r1, #151552	@ 0x25000
34007904:	ea07 0003 	and.w	r0, r7, r3
        temp = EXTI->EXTICR[position >> 2u];
34007908:	f8d1 c060 	ldr.w	ip, [r1, #96]	@ 0x60
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400790c:	4098      	lsls	r0, r3
3400790e:	fa0e fe00 	lsl.w	lr, lr, r0
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007912:	4544      	cmp	r4, r8
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007914:	ea2c 0c0e 	bic.w	ip, ip, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007918:	d064      	beq.n	340079e4 <HAL_GPIO_Init+0x3d4>
3400791a:	f8df e0f8 	ldr.w	lr, [pc, #248]	@ 34007a14 <HAL_GPIO_Init+0x404>
3400791e:	4574      	cmp	r4, lr
34007920:	d062      	beq.n	340079e8 <HAL_GPIO_Init+0x3d8>
34007922:	f50e 6e80 	add.w	lr, lr, #1024	@ 0x400
34007926:	4574      	cmp	r4, lr
34007928:	d060      	beq.n	340079ec <HAL_GPIO_Init+0x3dc>
3400792a:	f50e 6e80 	add.w	lr, lr, #1024	@ 0x400
3400792e:	4574      	cmp	r4, lr
34007930:	d020      	beq.n	34007974 <HAL_GPIO_Init+0x364>
34007932:	4b3b      	ldr	r3, [pc, #236]	@ (34007a20 <HAL_GPIO_Init+0x410>)
34007934:	429c      	cmp	r4, r3
34007936:	d05b      	beq.n	340079f0 <HAL_GPIO_Init+0x3e0>
34007938:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400793c:	429c      	cmp	r4, r3
3400793e:	d059      	beq.n	340079f4 <HAL_GPIO_Init+0x3e4>
34007940:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007944:	429c      	cmp	r4, r3
34007946:	d057      	beq.n	340079f8 <HAL_GPIO_Init+0x3e8>
34007948:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400794c:	429c      	cmp	r4, r3
3400794e:	d055      	beq.n	340079fc <HAL_GPIO_Init+0x3ec>
34007950:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
34007954:	429c      	cmp	r4, r3
34007956:	d053      	beq.n	34007a00 <HAL_GPIO_Init+0x3f0>
34007958:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400795c:	429c      	cmp	r4, r3
3400795e:	d051      	beq.n	34007a04 <HAL_GPIO_Init+0x3f4>
34007960:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007964:	429c      	cmp	r4, r3
34007966:	d04f      	beq.n	34007a08 <HAL_GPIO_Init+0x3f8>
34007968:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400796c:	429c      	cmp	r4, r3
3400796e:	bf14      	ite	ne
34007970:	2310      	movne	r3, #16
34007972:	230b      	moveq	r3, #11
34007974:	4083      	lsls	r3, r0
34007976:	ea43 030c 	orr.w	r3, r3, ip
        EXTI->EXTICR[position >> 2u] = temp;
3400797a:	660b      	str	r3, [r1, #96]	@ 0x60
        temp = EXTI->IMR1;
3400797c:	f8da 3080 	ldr.w	r3, [sl, #128]	@ 0x80
        temp &= ~(iocurrent);
34007980:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
34007984:	ea23 0105 	bic.w	r1, r3, r5
34007988:	ea43 0305 	orr.w	r3, r3, r5
3400798c:	bf08      	it	eq
3400798e:	460b      	moveq	r3, r1
        EXTI->IMR1 = temp;
34007990:	f8ca 3080 	str.w	r3, [sl, #128]	@ 0x80
        temp = EXTI->EMR1;
34007994:	f8da 3084 	ldr.w	r3, [sl, #132]	@ 0x84
        temp &= ~(iocurrent);
34007998:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
3400799c:	ea23 0105 	bic.w	r1, r3, r5
340079a0:	ea43 0305 	orr.w	r3, r3, r5
340079a4:	bf08      	it	eq
340079a6:	460b      	moveq	r3, r1
        EXTI->EMR1 = temp;
340079a8:	f8ca 3084 	str.w	r3, [sl, #132]	@ 0x84
        temp = EXTI->RTSR1;
340079ac:	f8da 3000 	ldr.w	r3, [sl]
        temp &= ~(iocurrent);
340079b0:	f412 1f80 	tst.w	r2, #1048576	@ 0x100000
340079b4:	ea23 0105 	bic.w	r1, r3, r5
340079b8:	ea43 0305 	orr.w	r3, r3, r5
340079bc:	bf08      	it	eq
340079be:	460b      	moveq	r3, r1
        EXTI->RTSR1 = temp;
340079c0:	f8ca 3000 	str.w	r3, [sl]
        temp = EXTI->FTSR1;
340079c4:	f8da 3004 	ldr.w	r3, [sl, #4]
        temp &= ~(iocurrent);
340079c8:	f412 1f00 	tst.w	r2, #2097152	@ 0x200000
340079cc:	ea23 0105 	bic.w	r1, r3, r5
340079d0:	ea45 0503 	orr.w	r5, r5, r3
340079d4:	bf08      	it	eq
340079d6:	460d      	moveq	r5, r1
        EXTI->FTSR1 = temp;
340079d8:	f8ca 5004 	str.w	r5, [sl, #4]
    position++;
340079dc:	3701      	adds	r7, #1
340079de:	f109 0902 	add.w	r9, r9, #2
340079e2:	e698      	b.n	34007716 <HAL_GPIO_Init+0x106>
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340079e4:	2300      	movs	r3, #0
340079e6:	e7c5      	b.n	34007974 <HAL_GPIO_Init+0x364>
340079e8:	2301      	movs	r3, #1
340079ea:	e7c3      	b.n	34007974 <HAL_GPIO_Init+0x364>
340079ec:	2302      	movs	r3, #2
340079ee:	e7c1      	b.n	34007974 <HAL_GPIO_Init+0x364>
340079f0:	2304      	movs	r3, #4
340079f2:	e7bf      	b.n	34007974 <HAL_GPIO_Init+0x364>
340079f4:	2305      	movs	r3, #5
340079f6:	e7bd      	b.n	34007974 <HAL_GPIO_Init+0x364>
340079f8:	2306      	movs	r3, #6
340079fa:	e7bb      	b.n	34007974 <HAL_GPIO_Init+0x364>
340079fc:	2307      	movs	r3, #7
340079fe:	e7b9      	b.n	34007974 <HAL_GPIO_Init+0x364>
34007a00:	2308      	movs	r3, #8
34007a02:	e7b7      	b.n	34007974 <HAL_GPIO_Init+0x364>
34007a04:	2309      	movs	r3, #9
34007a06:	e7b5      	b.n	34007974 <HAL_GPIO_Init+0x364>
34007a08:	230a      	movs	r3, #10
34007a0a:	e7b3      	b.n	34007974 <HAL_GPIO_Init+0x364>
34007a0c:	3401c4c7 	.word	0x3401c4c7
34007a10:	46020000 	.word	0x46020000
34007a14:	56020400 	.word	0x56020400
34007a18:	56020800 	.word	0x56020800
34007a1c:	56020c00 	.word	0x56020c00
34007a20:	56021000 	.word	0x56021000
34007a24:	56021400 	.word	0x56021400
34007a28:	56021800 	.word	0x56021800
34007a2c:	56021c00 	.word	0x56021c00
34007a30:	56023400 	.word	0x56023400
34007a34:	56023800 	.word	0x56023800
34007a38:	56023c00 	.word	0x56023c00
34007a3c:	56024000 	.word	0x56024000

34007a40 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
34007a40:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007a44:	4b87      	ldr	r3, [pc, #540]	@ (34007c64 <HAL_GPIO_DeInit+0x224>)
{
34007a46:	4604      	mov	r4, r0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007a48:	4298      	cmp	r0, r3
{
34007a4a:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
34007a4c:	d055      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a4e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a52:	4298      	cmp	r0, r3
34007a54:	d051      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a56:	4b84      	ldr	r3, [pc, #528]	@ (34007c68 <HAL_GPIO_DeInit+0x228>)
34007a58:	4298      	cmp	r0, r3
34007a5a:	d04e      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a5c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a60:	4298      	cmp	r0, r3
34007a62:	d04a      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a64:	4b81      	ldr	r3, [pc, #516]	@ (34007c6c <HAL_GPIO_DeInit+0x22c>)
34007a66:	4298      	cmp	r0, r3
34007a68:	d047      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a6a:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a6e:	4298      	cmp	r0, r3
34007a70:	d043      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a72:	4b7f      	ldr	r3, [pc, #508]	@ (34007c70 <HAL_GPIO_DeInit+0x230>)
34007a74:	4298      	cmp	r0, r3
34007a76:	d040      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a78:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a7c:	4298      	cmp	r0, r3
34007a7e:	d03c      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a80:	4b7c      	ldr	r3, [pc, #496]	@ (34007c74 <HAL_GPIO_DeInit+0x234>)
34007a82:	4298      	cmp	r0, r3
34007a84:	d039      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a86:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a8a:	4298      	cmp	r0, r3
34007a8c:	d035      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a8e:	4b7a      	ldr	r3, [pc, #488]	@ (34007c78 <HAL_GPIO_DeInit+0x238>)
34007a90:	4298      	cmp	r0, r3
34007a92:	d032      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a94:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007a98:	4298      	cmp	r0, r3
34007a9a:	d02e      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007a9c:	4b77      	ldr	r3, [pc, #476]	@ (34007c7c <HAL_GPIO_DeInit+0x23c>)
34007a9e:	4298      	cmp	r0, r3
34007aa0:	d02b      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007aa2:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007aa6:	4298      	cmp	r0, r3
34007aa8:	d027      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007aaa:	4b75      	ldr	r3, [pc, #468]	@ (34007c80 <HAL_GPIO_DeInit+0x240>)
34007aac:	4298      	cmp	r0, r3
34007aae:	d024      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ab0:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ab4:	4298      	cmp	r0, r3
34007ab6:	d020      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ab8:	4b72      	ldr	r3, [pc, #456]	@ (34007c84 <HAL_GPIO_DeInit+0x244>)
34007aba:	4298      	cmp	r0, r3
34007abc:	d01d      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007abe:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ac2:	4298      	cmp	r0, r3
34007ac4:	d019      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ac6:	4b70      	ldr	r3, [pc, #448]	@ (34007c88 <HAL_GPIO_DeInit+0x248>)
34007ac8:	4298      	cmp	r0, r3
34007aca:	d016      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007acc:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ad0:	4298      	cmp	r0, r3
34007ad2:	d012      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ad4:	4b6d      	ldr	r3, [pc, #436]	@ (34007c8c <HAL_GPIO_DeInit+0x24c>)
34007ad6:	4298      	cmp	r0, r3
34007ad8:	d00f      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ada:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007ade:	4298      	cmp	r0, r3
34007ae0:	d00b      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ae2:	4b6b      	ldr	r3, [pc, #428]	@ (34007c90 <HAL_GPIO_DeInit+0x250>)
34007ae4:	4298      	cmp	r0, r3
34007ae6:	d008      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007ae8:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007aec:	4298      	cmp	r0, r3
34007aee:	d004      	beq.n	34007afa <HAL_GPIO_DeInit+0xba>
34007af0:	f240 112d 	movw	r1, #301	@ 0x12d
34007af4:	4867      	ldr	r0, [pc, #412]	@ (34007c94 <HAL_GPIO_DeInit+0x254>)
34007af6:	f7fa fd21 	bl	3400253c <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
34007afa:	b2ab      	uxth	r3, r5
34007afc:	b113      	cbz	r3, 34007b04 <HAL_GPIO_DeInit+0xc4>
34007afe:	f5b5 3f80 	cmp.w	r5, #65536	@ 0x10000
34007b02:	d304      	bcc.n	34007b0e <HAL_GPIO_DeInit+0xce>
34007b04:	f44f 7197 	mov.w	r1, #302	@ 0x12e
34007b08:	4862      	ldr	r0, [pc, #392]	@ (34007c94 <HAL_GPIO_DeInit+0x254>)
34007b0a:	f7fa fd17 	bl	3400253c <assert_failed>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34007b0e:	2200      	movs	r2, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
34007b10:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007b14:	f04f 080f 	mov.w	r8, #15
        EXTI->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34007b18:	f04f 0b03 	mov.w	fp, #3
        EXTI->IMR1 &= ~(iocurrent);
34007b1c:	485e      	ldr	r0, [pc, #376]	@ (34007c98 <HAL_GPIO_DeInit+0x258>)
  while ((GPIO_Pin >> position) != 0x00u)
34007b1e:	fa35 f302 	lsrs.w	r3, r5, r2
34007b22:	d101      	bne.n	34007b28 <HAL_GPIO_DeInit+0xe8>
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
    }

    position++;
  }
}
34007b24:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
34007b28:	fa0a fc02 	lsl.w	ip, sl, r2
    if (iocurrent != 0x00u)
34007b2c:	ea1c 0605 	ands.w	r6, ip, r5
34007b30:	d07f      	beq.n	34007c32 <HAL_GPIO_DeInit+0x1f2>
      tmp = EXTI->EXTICR[position >> 2u];
34007b32:	f022 0103 	bic.w	r1, r2, #3
34007b36:	f101 41ac 	add.w	r1, r1, #1442840576	@ 0x56000000
34007b3a:	f501 3114 	add.w	r1, r1, #151552	@ 0x25000
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007b3e:	f002 0703 	and.w	r7, r2, #3
      tmp = EXTI->EXTICR[position >> 2u];
34007b42:	6e0b      	ldr	r3, [r1, #96]	@ 0x60
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34007b44:	00ff      	lsls	r7, r7, #3
34007b46:	fa08 f907 	lsl.w	r9, r8, r7
34007b4a:	ea09 0e03 	and.w	lr, r9, r3
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34007b4e:	4b45      	ldr	r3, [pc, #276]	@ (34007c64 <HAL_GPIO_DeInit+0x224>)
34007b50:	429c      	cmp	r4, r3
34007b52:	d070      	beq.n	34007c36 <HAL_GPIO_DeInit+0x1f6>
34007b54:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b58:	429c      	cmp	r4, r3
34007b5a:	d06e      	beq.n	34007c3a <HAL_GPIO_DeInit+0x1fa>
34007b5c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b60:	429c      	cmp	r4, r3
34007b62:	d06c      	beq.n	34007c3e <HAL_GPIO_DeInit+0x1fe>
34007b64:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b68:	429c      	cmp	r4, r3
34007b6a:	d06a      	beq.n	34007c42 <HAL_GPIO_DeInit+0x202>
34007b6c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b70:	429c      	cmp	r4, r3
34007b72:	d068      	beq.n	34007c46 <HAL_GPIO_DeInit+0x206>
34007b74:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b78:	429c      	cmp	r4, r3
34007b7a:	d066      	beq.n	34007c4a <HAL_GPIO_DeInit+0x20a>
34007b7c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b80:	429c      	cmp	r4, r3
34007b82:	d064      	beq.n	34007c4e <HAL_GPIO_DeInit+0x20e>
34007b84:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b88:	429c      	cmp	r4, r3
34007b8a:	d062      	beq.n	34007c52 <HAL_GPIO_DeInit+0x212>
34007b8c:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
34007b90:	429c      	cmp	r4, r3
34007b92:	d060      	beq.n	34007c56 <HAL_GPIO_DeInit+0x216>
34007b94:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007b98:	429c      	cmp	r4, r3
34007b9a:	d05e      	beq.n	34007c5a <HAL_GPIO_DeInit+0x21a>
34007b9c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007ba0:	429c      	cmp	r4, r3
34007ba2:	d05c      	beq.n	34007c5e <HAL_GPIO_DeInit+0x21e>
34007ba4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
34007ba8:	429c      	cmp	r4, r3
34007baa:	bf14      	ite	ne
34007bac:	2310      	movne	r3, #16
34007bae:	230b      	moveq	r3, #11
34007bb0:	40bb      	lsls	r3, r7
34007bb2:	4573      	cmp	r3, lr
34007bb4:	d117      	bne.n	34007be6 <HAL_GPIO_DeInit+0x1a6>
        EXTI->IMR1 &= ~(iocurrent);
34007bb6:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
34007bba:	ea23 0306 	bic.w	r3, r3, r6
34007bbe:	f8c0 3080 	str.w	r3, [r0, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
34007bc2:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
34007bc6:	ea23 0306 	bic.w	r3, r3, r6
34007bca:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
34007bce:	6803      	ldr	r3, [r0, #0]
34007bd0:	ea23 0306 	bic.w	r3, r3, r6
34007bd4:	6003      	str	r3, [r0, #0]
        EXTI->FTSR1 &= ~(iocurrent);
34007bd6:	6843      	ldr	r3, [r0, #4]
34007bd8:	ea23 0306 	bic.w	r3, r3, r6
34007bdc:	6043      	str	r3, [r0, #4]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
34007bde:	6e0b      	ldr	r3, [r1, #96]	@ 0x60
34007be0:	ea23 0309 	bic.w	r3, r3, r9
34007be4:	660b      	str	r3, [r1, #96]	@ 0x60
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34007be6:	6823      	ldr	r3, [r4, #0]
34007be8:	0056      	lsls	r6, r2, #1
34007bea:	fa0b f606 	lsl.w	r6, fp, r6
34007bee:	4333      	orrs	r3, r6
34007bf0:	6023      	str	r3, [r4, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
34007bf2:	08d3      	lsrs	r3, r2, #3
34007bf4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
34007bf8:	f002 0107 	and.w	r1, r2, #7
34007bfc:	6a1f      	ldr	r7, [r3, #32]
34007bfe:	0089      	lsls	r1, r1, #2
34007c00:	fa08 f101 	lsl.w	r1, r8, r1
34007c04:	ea27 0701 	bic.w	r7, r7, r1
34007c08:	621f      	str	r7, [r3, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34007c0a:	68a7      	ldr	r7, [r4, #8]
34007c0c:	ea27 0706 	bic.w	r7, r7, r6
34007c10:	60a7      	str	r7, [r4, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
34007c12:	6867      	ldr	r7, [r4, #4]
34007c14:	ea27 070c 	bic.w	r7, r7, ip
34007c18:	6067      	str	r7, [r4, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34007c1a:	68e7      	ldr	r7, [r4, #12]
34007c1c:	ea27 0706 	bic.w	r7, r7, r6
34007c20:	60e7      	str	r7, [r4, #12]
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
34007c22:	6c1e      	ldr	r6, [r3, #64]	@ 0x40
34007c24:	ea26 0601 	bic.w	r6, r6, r1
34007c28:	641e      	str	r6, [r3, #64]	@ 0x40
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
34007c2a:	6c9e      	ldr	r6, [r3, #72]	@ 0x48
34007c2c:	ea26 0101 	bic.w	r1, r6, r1
34007c30:	6499      	str	r1, [r3, #72]	@ 0x48
    position++;
34007c32:	3201      	adds	r2, #1
34007c34:	e773      	b.n	34007b1e <HAL_GPIO_DeInit+0xde>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34007c36:	2300      	movs	r3, #0
34007c38:	e7ba      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c3a:	2301      	movs	r3, #1
34007c3c:	e7b8      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c3e:	2302      	movs	r3, #2
34007c40:	e7b6      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c42:	2303      	movs	r3, #3
34007c44:	e7b4      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c46:	2304      	movs	r3, #4
34007c48:	e7b2      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c4a:	2305      	movs	r3, #5
34007c4c:	e7b0      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c4e:	2306      	movs	r3, #6
34007c50:	e7ae      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c52:	2307      	movs	r3, #7
34007c54:	e7ac      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c56:	2308      	movs	r3, #8
34007c58:	e7aa      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c5a:	2309      	movs	r3, #9
34007c5c:	e7a8      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c5e:	230a      	movs	r3, #10
34007c60:	e7a6      	b.n	34007bb0 <HAL_GPIO_DeInit+0x170>
34007c62:	bf00      	nop
34007c64:	56020000 	.word	0x56020000
34007c68:	56020400 	.word	0x56020400
34007c6c:	56020800 	.word	0x56020800
34007c70:	56020c00 	.word	0x56020c00
34007c74:	56021000 	.word	0x56021000
34007c78:	56021400 	.word	0x56021400
34007c7c:	56021800 	.word	0x56021800
34007c80:	56021c00 	.word	0x56021c00
34007c84:	56023400 	.word	0x56023400
34007c88:	56023800 	.word	0x56023800
34007c8c:	56023c00 	.word	0x56023c00
34007c90:	56024000 	.word	0x56024000
34007c94:	3401c4c7 	.word	0x3401c4c7
34007c98:	56025000 	.word	0x56025000

34007c9c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34007c9c:	b570      	push	{r4, r5, r6, lr}
34007c9e:	4605      	mov	r5, r0
34007ca0:	4616      	mov	r6, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
34007ca2:	460c      	mov	r4, r1
34007ca4:	b921      	cbnz	r1, 34007cb0 <HAL_GPIO_WritePin+0x14>
34007ca6:	f44f 71d0 	mov.w	r1, #416	@ 0x1a0
34007caa:	4808      	ldr	r0, [pc, #32]	@ (34007ccc <HAL_GPIO_WritePin+0x30>)
34007cac:	f7fa fc46 	bl	3400253c <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
34007cb0:	2e01      	cmp	r6, #1
34007cb2:	d906      	bls.n	34007cc2 <HAL_GPIO_WritePin+0x26>
34007cb4:	f240 11a1 	movw	r1, #417	@ 0x1a1
34007cb8:	4804      	ldr	r0, [pc, #16]	@ (34007ccc <HAL_GPIO_WritePin+0x30>)
34007cba:	f7fa fc3f 	bl	3400253c <assert_failed>

  if (PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34007cbe:	61ac      	str	r4, [r5, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34007cc0:	bd70      	pop	{r4, r5, r6, pc}
  if (PinState != GPIO_PIN_RESET)
34007cc2:	2e00      	cmp	r6, #0
34007cc4:	d1fb      	bne.n	34007cbe <HAL_GPIO_WritePin+0x22>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34007cc6:	62ac      	str	r4, [r5, #40]	@ 0x28
}
34007cc8:	e7fa      	b.n	34007cc0 <HAL_GPIO_WritePin+0x24>
34007cca:	bf00      	nop
34007ccc:	3401c4c7 	.word	0x3401c4c7

34007cd0 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
34007cd0:	6803      	ldr	r3, [r0, #0]
34007cd2:	699a      	ldr	r2, [r3, #24]
34007cd4:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
34007cd6:	bf44      	itt	mi
34007cd8:	2200      	movmi	r2, #0
34007cda:	629a      	strmi	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
34007cdc:	699a      	ldr	r2, [r3, #24]
34007cde:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
34007ce0:	bf5e      	ittt	pl
34007ce2:	699a      	ldrpl	r2, [r3, #24]
34007ce4:	f042 0201 	orrpl.w	r2, r2, #1
34007ce8:	619a      	strpl	r2, [r3, #24]
  }
}
34007cea:	4770      	bx	lr

34007cec <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
34007cec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34007cf0:	4614      	mov	r4, r2
34007cf2:	461f      	mov	r7, r3
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007cf4:	6802      	ldr	r2, [r0, #0]
34007cf6:	4b29      	ldr	r3, [pc, #164]	@ (34007d9c <I2C_TransferConfig+0xb0>)
{
34007cf8:	4680      	mov	r8, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007cfa:	429a      	cmp	r2, r3
{
34007cfc:	460e      	mov	r6, r1
34007cfe:	9d06      	ldr	r5, [sp, #24]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007d00:	d01d      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d02:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d06:	429a      	cmp	r2, r3
34007d08:	d019      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d0a:	4b25      	ldr	r3, [pc, #148]	@ (34007da0 <I2C_TransferConfig+0xb4>)
34007d0c:	429a      	cmp	r2, r3
34007d0e:	d016      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d10:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d14:	429a      	cmp	r2, r3
34007d16:	d012      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d18:	4b22      	ldr	r3, [pc, #136]	@ (34007da4 <I2C_TransferConfig+0xb8>)
34007d1a:	429a      	cmp	r2, r3
34007d1c:	d00f      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d1e:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d22:	429a      	cmp	r2, r3
34007d24:	d00b      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d26:	4b20      	ldr	r3, [pc, #128]	@ (34007da8 <I2C_TransferConfig+0xbc>)
34007d28:	429a      	cmp	r2, r3
34007d2a:	d008      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d2c:	f103 4370 	add.w	r3, r3, #4026531840	@ 0xf0000000
34007d30:	429a      	cmp	r2, r3
34007d32:	d004      	beq.n	34007d3e <I2C_TransferConfig+0x52>
34007d34:	f641 51c9 	movw	r1, #7625	@ 0x1dc9
34007d38:	481c      	ldr	r0, [pc, #112]	@ (34007dac <I2C_TransferConfig+0xc0>)
34007d3a:	f7fa fbff 	bl	3400253c <assert_failed>
  assert_param(IS_TRANSFER_MODE(Mode));
34007d3e:	f037 7380 	bics.w	r3, r7, #16777216	@ 0x1000000
34007d42:	d007      	beq.n	34007d54 <I2C_TransferConfig+0x68>
34007d44:	f1b7 7f00 	cmp.w	r7, #33554432	@ 0x2000000
34007d48:	d004      	beq.n	34007d54 <I2C_TransferConfig+0x68>
34007d4a:	f641 51ca 	movw	r1, #7626	@ 0x1dca
34007d4e:	4817      	ldr	r0, [pc, #92]	@ (34007dac <I2C_TransferConfig+0xc0>)
34007d50:	f7fa fbf4 	bl	3400253c <assert_failed>
  assert_param(IS_TRANSFER_REQUEST(Request));
34007d54:	4b16      	ldr	r3, [pc, #88]	@ (34007db0 <I2C_TransferConfig+0xc4>)
34007d56:	429d      	cmp	r5, r3
34007d58:	d00b      	beq.n	34007d72 <I2C_TransferConfig+0x86>
34007d5a:	f425 6280 	bic.w	r2, r5, #1024	@ 0x400
34007d5e:	f5a3 5300 	sub.w	r3, r3, #8192	@ 0x2000
34007d62:	429a      	cmp	r2, r3
34007d64:	d005      	beq.n	34007d72 <I2C_TransferConfig+0x86>
34007d66:	b125      	cbz	r5, 34007d72 <I2C_TransferConfig+0x86>
34007d68:	f641 51cb 	movw	r1, #7627	@ 0x1dcb
34007d6c:	480f      	ldr	r0, [pc, #60]	@ (34007dac <I2C_TransferConfig+0xc0>)
34007d6e:	f7fa fbe5 	bl	3400253c <assert_failed>
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
34007d72:	f8d8 0000 	ldr.w	r0, [r8]
34007d76:	490f      	ldr	r1, [pc, #60]	@ (34007db4 <I2C_TransferConfig+0xc8>)
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34007d78:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
34007d7c:	6842      	ldr	r2, [r0, #4]
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34007d7e:	ea44 0307 	orr.w	r3, r4, r7
34007d82:	f3c6 0609 	ubfx	r6, r6, #0, #10
34007d86:	4333      	orrs	r3, r6
  MODIFY_REG(hi2c->Instance->CR2, \
34007d88:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34007d8c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
  MODIFY_REG(hi2c->Instance->CR2, \
34007d90:	ea22 0201 	bic.w	r2, r2, r1
34007d94:	4313      	orrs	r3, r2
34007d96:	6043      	str	r3, [r0, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
34007d98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34007d9c:	50005400 	.word	0x50005400
34007da0:	50005800 	.word	0x50005800
34007da4:	50005c00 	.word	0x50005c00
34007da8:	56001c00 	.word	0x56001c00
34007dac:	3401c536 	.word	0x3401c536
34007db0:	80004000 	.word	0x80004000
34007db4:	03ff63ff 	.word	0x03ff63ff

34007db8 <I2C_IsErrorOccurred>:
  uint32_t itflag   = hi2c->Instance->ISR;
34007db8:	6803      	ldr	r3, [r0, #0]
{
34007dba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t itflag   = hi2c->Instance->ISR;
34007dbe:	699c      	ldr	r4, [r3, #24]
{
34007dc0:	4605      	mov	r5, r0
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
34007dc2:	f014 0410 	ands.w	r4, r4, #16
{
34007dc6:	460f      	mov	r7, r1
34007dc8:	4616      	mov	r6, r2
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
34007dca:	d06f      	beq.n	34007eac <I2C_IsErrorOccurred+0xf4>
  uint32_t error_code = 0;
34007dcc:	2400      	movs	r4, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34007dce:	2210      	movs	r2, #16
  HAL_StatusTypeDef status = HAL_OK;
34007dd0:	46a0      	mov	r8, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34007dd2:	61da      	str	r2, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
34007dd4:	682b      	ldr	r3, [r5, #0]
34007dd6:	699a      	ldr	r2, [r3, #24]
34007dd8:	0690      	lsls	r0, r2, #26
34007dda:	d461      	bmi.n	34007ea0 <I2C_IsErrorOccurred+0xe8>
34007ddc:	f1b8 0f00 	cmp.w	r8, #0
34007de0:	d035      	beq.n	34007e4e <I2C_IsErrorOccurred+0x96>
    status = HAL_ERROR;
34007de2:	2001      	movs	r0, #1
    error_code |= HAL_I2C_ERROR_AF;
34007de4:	f044 0404 	orr.w	r4, r4, #4
  itflag = hi2c->Instance->ISR;
34007de8:	682e      	ldr	r6, [r5, #0]
34007dea:	69b3      	ldr	r3, [r6, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
34007dec:	05d9      	lsls	r1, r3, #23
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34007dee:	bf41      	itttt	mi
34007df0:	f44f 7280 	movmi.w	r2, #256	@ 0x100
    status = HAL_ERROR;
34007df4:	2001      	movmi	r0, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34007df6:	61f2      	strmi	r2, [r6, #28]
    error_code |= HAL_I2C_ERROR_BERR;
34007df8:	f044 0401 	orrmi.w	r4, r4, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
34007dfc:	055a      	lsls	r2, r3, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34007dfe:	bf41      	itttt	mi
34007e00:	f44f 6280 	movmi.w	r2, #1024	@ 0x400
    status = HAL_ERROR;
34007e04:	2001      	movmi	r0, #1
    error_code |= HAL_I2C_ERROR_OVR;
34007e06:	f044 0408 	orrmi.w	r4, r4, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34007e0a:	61f2      	strmi	r2, [r6, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
34007e0c:	059b      	lsls	r3, r3, #22
34007e0e:	d54f      	bpl.n	34007eb0 <I2C_IsErrorOccurred+0xf8>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34007e10:	f44f 7300 	mov.w	r3, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
34007e14:	f044 0402 	orr.w	r4, r4, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34007e18:	61f3      	str	r3, [r6, #28]
    I2C_Flush_TXDR(hi2c);
34007e1a:	4628      	mov	r0, r5
34007e1c:	f7ff ff58 	bl	34007cd0 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
34007e20:	6873      	ldr	r3, [r6, #4]
    __HAL_UNLOCK(hi2c);
34007e22:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
34007e24:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
34007e28:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
34007e2c:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
34007e30:	f023 0301 	bic.w	r3, r3, #1
34007e34:	6073      	str	r3, [r6, #4]
    hi2c->ErrorCode |= error_code;
34007e36:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
34007e38:	4323      	orrs	r3, r4
34007e3a:	646b      	str	r3, [r5, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
34007e3c:	2320      	movs	r3, #32
34007e3e:	f885 3041 	strb.w	r3, [r5, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
34007e42:	2300      	movs	r3, #0
34007e44:	f885 3042 	strb.w	r3, [r5, #66]	@ 0x42
    __HAL_UNLOCK(hi2c);
34007e48:	f885 3040 	strb.w	r3, [r5, #64]	@ 0x40
34007e4c:	e032      	b.n	34007eb4 <I2C_IsErrorOccurred+0xfc>
      if (Timeout != HAL_MAX_DELAY)
34007e4e:	1c7a      	adds	r2, r7, #1
34007e50:	d0c1      	beq.n	34007dd6 <I2C_IsErrorOccurred+0x1e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34007e52:	f7fc fd4d 	bl	340048f0 <HAL_GetTick>
34007e56:	1b80      	subs	r0, r0, r6
34007e58:	42b8      	cmp	r0, r7
34007e5a:	d801      	bhi.n	34007e60 <I2C_IsErrorOccurred+0xa8>
34007e5c:	2f00      	cmp	r7, #0
34007e5e:	d1b9      	bne.n	34007dd4 <I2C_IsErrorOccurred+0x1c>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
34007e60:	682b      	ldr	r3, [r5, #0]
34007e62:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
34007e64:	f895 2042 	ldrb.w	r2, [r5, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34007e68:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
34007e6a:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34007e6c:	0400      	lsls	r0, r0, #16
34007e6e:	d50a      	bpl.n	34007e86 <I2C_IsErrorOccurred+0xce>
34007e70:	0449      	lsls	r1, r1, #17
34007e72:	d408      	bmi.n	34007e86 <I2C_IsErrorOccurred+0xce>
              (tmp1 != I2C_CR2_STOP) && \
34007e74:	2a20      	cmp	r2, #32
34007e76:	d006      	beq.n	34007e86 <I2C_IsErrorOccurred+0xce>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
34007e78:	685a      	ldr	r2, [r3, #4]
34007e7a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34007e7e:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
34007e80:	f7fc fd36 	bl	340048f0 <HAL_GetTick>
34007e84:	4606      	mov	r6, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34007e86:	682b      	ldr	r3, [r5, #0]
34007e88:	699b      	ldr	r3, [r3, #24]
34007e8a:	069b      	lsls	r3, r3, #26
34007e8c:	d4a2      	bmi.n	34007dd4 <I2C_IsErrorOccurred+0x1c>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
34007e8e:	f7fc fd2f 	bl	340048f0 <HAL_GetTick>
34007e92:	1b80      	subs	r0, r0, r6
34007e94:	2819      	cmp	r0, #25
34007e96:	d9f6      	bls.n	34007e86 <I2C_IsErrorOccurred+0xce>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
34007e98:	2420      	movs	r4, #32
              status = HAL_ERROR;
34007e9a:	f04f 0801 	mov.w	r8, #1
34007e9e:	e799      	b.n	34007dd4 <I2C_IsErrorOccurred+0x1c>
    if (status == HAL_OK)
34007ea0:	f1b8 0f00 	cmp.w	r8, #0
34007ea4:	d19d      	bne.n	34007de2 <I2C_IsErrorOccurred+0x2a>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34007ea6:	2220      	movs	r2, #32
34007ea8:	61da      	str	r2, [r3, #28]
34007eaa:	e79a      	b.n	34007de2 <I2C_IsErrorOccurred+0x2a>
  HAL_StatusTypeDef status = HAL_OK;
34007eac:	4620      	mov	r0, r4
34007eae:	e79b      	b.n	34007de8 <I2C_IsErrorOccurred+0x30>
  if (status != HAL_OK)
34007eb0:	2800      	cmp	r0, #0
34007eb2:	d1b2      	bne.n	34007e1a <I2C_IsErrorOccurred+0x62>
}
34007eb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

34007eb8 <I2C_WaitOnTXISFlagUntilTimeout>:
{
34007eb8:	b570      	push	{r4, r5, r6, lr}
34007eba:	4604      	mov	r4, r0
34007ebc:	460d      	mov	r5, r1
34007ebe:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34007ec0:	6823      	ldr	r3, [r4, #0]
34007ec2:	699b      	ldr	r3, [r3, #24]
34007ec4:	079b      	lsls	r3, r3, #30
34007ec6:	d501      	bpl.n	34007ecc <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
34007ec8:	2000      	movs	r0, #0
34007eca:	e01f      	b.n	34007f0c <I2C_WaitOnTXISFlagUntilTimeout+0x54>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34007ecc:	4632      	mov	r2, r6
34007ece:	4629      	mov	r1, r5
34007ed0:	4620      	mov	r0, r4
34007ed2:	f7ff ff71 	bl	34007db8 <I2C_IsErrorOccurred>
34007ed6:	b9c0      	cbnz	r0, 34007f0a <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
34007ed8:	1c6a      	adds	r2, r5, #1
34007eda:	d0f1      	beq.n	34007ec0 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34007edc:	f7fc fd08 	bl	340048f0 <HAL_GetTick>
34007ee0:	1b80      	subs	r0, r0, r6
34007ee2:	42a8      	cmp	r0, r5
34007ee4:	d801      	bhi.n	34007eea <I2C_WaitOnTXISFlagUntilTimeout+0x32>
34007ee6:	2d00      	cmp	r5, #0
34007ee8:	d1ea      	bne.n	34007ec0 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34007eea:	6823      	ldr	r3, [r4, #0]
34007eec:	699b      	ldr	r3, [r3, #24]
34007eee:	f013 0302 	ands.w	r3, r3, #2
34007ef2:	d1e5      	bne.n	34007ec0 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007ef4:	6c62      	ldr	r2, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hi2c);
34007ef6:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007efa:	f042 0220 	orr.w	r2, r2, #32
34007efe:	6462      	str	r2, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34007f00:	2220      	movs	r2, #32
34007f02:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34007f06:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
34007f0a:	2001      	movs	r0, #1
}
34007f0c:	bd70      	pop	{r4, r5, r6, pc}

34007f0e <I2C_WaitOnFlagUntilTimeout>:
{
34007f0e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34007f12:	4604      	mov	r4, r0
34007f14:	460f      	mov	r7, r1
34007f16:	4616      	mov	r6, r2
34007f18:	461d      	mov	r5, r3
34007f1a:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34007f1e:	6823      	ldr	r3, [r4, #0]
34007f20:	699b      	ldr	r3, [r3, #24]
34007f22:	ea37 0303 	bics.w	r3, r7, r3
34007f26:	bf0c      	ite	eq
34007f28:	2301      	moveq	r3, #1
34007f2a:	2300      	movne	r3, #0
34007f2c:	42b3      	cmp	r3, r6
34007f2e:	d001      	beq.n	34007f34 <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
34007f30:	2000      	movs	r0, #0
34007f32:	e025      	b.n	34007f80 <I2C_WaitOnFlagUntilTimeout+0x72>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34007f34:	4642      	mov	r2, r8
34007f36:	4629      	mov	r1, r5
34007f38:	4620      	mov	r0, r4
34007f3a:	f7ff ff3d 	bl	34007db8 <I2C_IsErrorOccurred>
34007f3e:	b9f0      	cbnz	r0, 34007f7e <I2C_WaitOnFlagUntilTimeout+0x70>
    if (Timeout != HAL_MAX_DELAY)
34007f40:	1c6b      	adds	r3, r5, #1
34007f42:	d0ec      	beq.n	34007f1e <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34007f44:	f7fc fcd4 	bl	340048f0 <HAL_GetTick>
34007f48:	eba0 0008 	sub.w	r0, r0, r8
34007f4c:	42a8      	cmp	r0, r5
34007f4e:	d801      	bhi.n	34007f54 <I2C_WaitOnFlagUntilTimeout+0x46>
34007f50:	2d00      	cmp	r5, #0
34007f52:	d1e4      	bne.n	34007f1e <I2C_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34007f54:	6823      	ldr	r3, [r4, #0]
34007f56:	699b      	ldr	r3, [r3, #24]
34007f58:	ea37 0303 	bics.w	r3, r7, r3
34007f5c:	bf0c      	ite	eq
34007f5e:	2301      	moveq	r3, #1
34007f60:	2300      	movne	r3, #0
34007f62:	42b3      	cmp	r3, r6
34007f64:	d1db      	bne.n	34007f1e <I2C_WaitOnFlagUntilTimeout+0x10>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007f66:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34007f68:	f043 0320 	orr.w	r3, r3, #32
34007f6c:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34007f6e:	2320      	movs	r3, #32
34007f70:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34007f74:	2300      	movs	r3, #0
34007f76:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
34007f7a:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
34007f7e:	2001      	movs	r0, #1
}
34007f80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

34007f84 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
34007f84:	b570      	push	{r4, r5, r6, lr}
34007f86:	4604      	mov	r4, r0
34007f88:	460d      	mov	r5, r1
34007f8a:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34007f8c:	6823      	ldr	r3, [r4, #0]
34007f8e:	699b      	ldr	r3, [r3, #24]
34007f90:	069b      	lsls	r3, r3, #26
34007f92:	d501      	bpl.n	34007f98 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
34007f94:	2000      	movs	r0, #0
34007f96:	e01d      	b.n	34007fd4 <I2C_WaitOnSTOPFlagUntilTimeout+0x50>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34007f98:	4632      	mov	r2, r6
34007f9a:	4629      	mov	r1, r5
34007f9c:	4620      	mov	r0, r4
34007f9e:	f7ff ff0b 	bl	34007db8 <I2C_IsErrorOccurred>
34007fa2:	b9b0      	cbnz	r0, 34007fd2 <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34007fa4:	f7fc fca4 	bl	340048f0 <HAL_GetTick>
34007fa8:	1b80      	subs	r0, r0, r6
34007faa:	42a8      	cmp	r0, r5
34007fac:	d801      	bhi.n	34007fb2 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
34007fae:	2d00      	cmp	r5, #0
34007fb0:	d1ec      	bne.n	34007f8c <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34007fb2:	6823      	ldr	r3, [r4, #0]
34007fb4:	699b      	ldr	r3, [r3, #24]
34007fb6:	f013 0320 	ands.w	r3, r3, #32
34007fba:	d1e7      	bne.n	34007f8c <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007fbc:	6c62      	ldr	r2, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
34007fbe:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34007fc2:	f042 0220 	orr.w	r2, r2, #32
34007fc6:	6462      	str	r2, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
34007fc8:	2220      	movs	r2, #32
34007fca:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
34007fce:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
34007fd2:	2001      	movs	r0, #1
}
34007fd4:	bd70      	pop	{r4, r5, r6, pc}

34007fd6 <HAL_I2C_MspInit>:
}
34007fd6:	4770      	bx	lr

34007fd8 <HAL_I2C_Init>:
{
34007fd8:	b510      	push	{r4, lr}
  if (hi2c == NULL)
34007fda:	4604      	mov	r4, r0
34007fdc:	2800      	cmp	r0, #0
34007fde:	f000 80af 	beq.w	34008140 <HAL_I2C_Init+0x168>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34007fe2:	6803      	ldr	r3, [r0, #0]
34007fe4:	4a57      	ldr	r2, [pc, #348]	@ (34008144 <HAL_I2C_Init+0x16c>)
34007fe6:	4293      	cmp	r3, r2
34007fe8:	d01d      	beq.n	34008026 <HAL_I2C_Init+0x4e>
34007fea:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007fee:	4293      	cmp	r3, r2
34007ff0:	d019      	beq.n	34008026 <HAL_I2C_Init+0x4e>
34007ff2:	4a55      	ldr	r2, [pc, #340]	@ (34008148 <HAL_I2C_Init+0x170>)
34007ff4:	4293      	cmp	r3, r2
34007ff6:	d016      	beq.n	34008026 <HAL_I2C_Init+0x4e>
34007ff8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34007ffc:	4293      	cmp	r3, r2
34007ffe:	d012      	beq.n	34008026 <HAL_I2C_Init+0x4e>
34008000:	4a52      	ldr	r2, [pc, #328]	@ (3400814c <HAL_I2C_Init+0x174>)
34008002:	4293      	cmp	r3, r2
34008004:	d00f      	beq.n	34008026 <HAL_I2C_Init+0x4e>
34008006:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400800a:	4293      	cmp	r3, r2
3400800c:	d00b      	beq.n	34008026 <HAL_I2C_Init+0x4e>
3400800e:	4a50      	ldr	r2, [pc, #320]	@ (34008150 <HAL_I2C_Init+0x178>)
34008010:	4293      	cmp	r3, r2
34008012:	d008      	beq.n	34008026 <HAL_I2C_Init+0x4e>
34008014:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008018:	4293      	cmp	r3, r2
3400801a:	d004      	beq.n	34008026 <HAL_I2C_Init+0x4e>
3400801c:	f240 2126 	movw	r1, #550	@ 0x226
34008020:	484c      	ldr	r0, [pc, #304]	@ (34008154 <HAL_I2C_Init+0x17c>)
34008022:	f7fa fa8b 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
34008026:	68a3      	ldr	r3, [r4, #8]
34008028:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400802c:	d304      	bcc.n	34008038 <HAL_I2C_Init+0x60>
3400802e:	f240 2127 	movw	r1, #551	@ 0x227
34008032:	4848      	ldr	r0, [pc, #288]	@ (34008154 <HAL_I2C_Init+0x17c>)
34008034:	f7fa fa82 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
34008038:	68e3      	ldr	r3, [r4, #12]
3400803a:	3b01      	subs	r3, #1
3400803c:	2b01      	cmp	r3, #1
3400803e:	d904      	bls.n	3400804a <HAL_I2C_Init+0x72>
34008040:	f44f 710a 	mov.w	r1, #552	@ 0x228
34008044:	4843      	ldr	r0, [pc, #268]	@ (34008154 <HAL_I2C_Init+0x17c>)
34008046:	f7fa fa79 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
3400804a:	6923      	ldr	r3, [r4, #16]
3400804c:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
34008050:	d004      	beq.n	3400805c <HAL_I2C_Init+0x84>
34008052:	f240 2129 	movw	r1, #553	@ 0x229
34008056:	483f      	ldr	r0, [pc, #252]	@ (34008154 <HAL_I2C_Init+0x17c>)
34008058:	f7fa fa70 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
3400805c:	6963      	ldr	r3, [r4, #20]
3400805e:	2bff      	cmp	r3, #255	@ 0xff
34008060:	d904      	bls.n	3400806c <HAL_I2C_Init+0x94>
34008062:	f240 212a 	movw	r1, #554	@ 0x22a
34008066:	483b      	ldr	r0, [pc, #236]	@ (34008154 <HAL_I2C_Init+0x17c>)
34008068:	f7fa fa68 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
3400806c:	69a3      	ldr	r3, [r4, #24]
3400806e:	2b07      	cmp	r3, #7
34008070:	d904      	bls.n	3400807c <HAL_I2C_Init+0xa4>
34008072:	f240 212b 	movw	r1, #555	@ 0x22b
34008076:	4837      	ldr	r0, [pc, #220]	@ (34008154 <HAL_I2C_Init+0x17c>)
34008078:	f7fa fa60 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
3400807c:	69e3      	ldr	r3, [r4, #28]
3400807e:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
34008082:	d004      	beq.n	3400808e <HAL_I2C_Init+0xb6>
34008084:	f44f 710b 	mov.w	r1, #556	@ 0x22c
34008088:	4832      	ldr	r0, [pc, #200]	@ (34008154 <HAL_I2C_Init+0x17c>)
3400808a:	f7fa fa57 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
3400808e:	6a23      	ldr	r3, [r4, #32]
34008090:	f433 3300 	bics.w	r3, r3, #131072	@ 0x20000
34008094:	d004      	beq.n	340080a0 <HAL_I2C_Init+0xc8>
34008096:	f240 212d 	movw	r1, #557	@ 0x22d
3400809a:	482e      	ldr	r0, [pc, #184]	@ (34008154 <HAL_I2C_Init+0x17c>)
3400809c:	f7fa fa4e 	bl	3400253c <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
340080a0:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
340080a4:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
340080a8:	b923      	cbnz	r3, 340080b4 <HAL_I2C_Init+0xdc>
    HAL_I2C_MspInit(hi2c);
340080aa:	4620      	mov	r0, r4
    hi2c->Lock = HAL_UNLOCKED;
340080ac:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
340080b0:	f7ff ff91 	bl	34007fd6 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
340080b4:	2324      	movs	r3, #36	@ 0x24
340080b6:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
340080ba:	6823      	ldr	r3, [r4, #0]
340080bc:	681a      	ldr	r2, [r3, #0]
340080be:	f022 0201 	bic.w	r2, r2, #1
340080c2:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
340080c4:	6862      	ldr	r2, [r4, #4]
340080c6:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
340080ca:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
340080cc:	689a      	ldr	r2, [r3, #8]
340080ce:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340080d2:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
340080d4:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
340080d8:	2901      	cmp	r1, #1
340080da:	d106      	bne.n	340080ea <HAL_I2C_Init+0x112>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
340080dc:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
340080e0:	609a      	str	r2, [r3, #8]
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
340080e2:	685a      	ldr	r2, [r3, #4]
340080e4:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
340080e8:	e007      	b.n	340080fa <HAL_I2C_Init+0x122>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
340080ea:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
340080ee:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
340080f0:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
340080f2:	d1f6      	bne.n	340080e2 <HAL_I2C_Init+0x10a>
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
340080f4:	685a      	ldr	r2, [r3, #4]
340080f6:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
340080fa:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
340080fc:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340080fe:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
34008100:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
34008104:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34008108:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
3400810a:	68da      	ldr	r2, [r3, #12]
3400810c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34008110:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
34008112:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
34008116:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
34008118:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3400811a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
3400811e:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
34008120:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
34008124:	430a      	orrs	r2, r1
34008126:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
34008128:	681a      	ldr	r2, [r3, #0]
3400812a:	f042 0201 	orr.w	r2, r2, #1
3400812e:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
34008130:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34008132:	6460      	str	r0, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
34008134:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34008138:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3400813a:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
3400813e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
34008140:	2001      	movs	r0, #1
34008142:	e7fc      	b.n	3400813e <HAL_I2C_Init+0x166>
34008144:	50005400 	.word	0x50005400
34008148:	50005800 	.word	0x50005800
3400814c:	50005c00 	.word	0x50005c00
34008150:	56001c00 	.word	0x56001c00
34008154:	3401c536 	.word	0x3401c536

34008158 <HAL_I2C_MspDeInit>:
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
34008158:	4770      	bx	lr
	...

3400815c <HAL_I2C_DeInit>:
{
3400815c:	b510      	push	{r4, lr}
  if (hi2c == NULL)
3400815e:	4604      	mov	r4, r0
34008160:	2800      	cmp	r0, #0
34008162:	d036      	beq.n	340081d2 <HAL_I2C_DeInit+0x76>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008164:	6803      	ldr	r3, [r0, #0]
34008166:	4a1c      	ldr	r2, [pc, #112]	@ (340081d8 <HAL_I2C_DeInit+0x7c>)
34008168:	4293      	cmp	r3, r2
3400816a:	d01d      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
3400816c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008170:	4293      	cmp	r3, r2
34008172:	d019      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
34008174:	4a19      	ldr	r2, [pc, #100]	@ (340081dc <HAL_I2C_DeInit+0x80>)
34008176:	4293      	cmp	r3, r2
34008178:	d016      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
3400817a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400817e:	4293      	cmp	r3, r2
34008180:	d012      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
34008182:	4a17      	ldr	r2, [pc, #92]	@ (340081e0 <HAL_I2C_DeInit+0x84>)
34008184:	4293      	cmp	r3, r2
34008186:	d00f      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
34008188:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400818c:	4293      	cmp	r3, r2
3400818e:	d00b      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
34008190:	4a14      	ldr	r2, [pc, #80]	@ (340081e4 <HAL_I2C_DeInit+0x88>)
34008192:	4293      	cmp	r3, r2
34008194:	d008      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
34008196:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400819a:	4293      	cmp	r3, r2
3400819c:	d004      	beq.n	340081a8 <HAL_I2C_DeInit+0x4c>
3400819e:	f240 2199 	movw	r1, #665	@ 0x299
340081a2:	4811      	ldr	r0, [pc, #68]	@ (340081e8 <HAL_I2C_DeInit+0x8c>)
340081a4:	f7fa f9ca 	bl	3400253c <assert_failed>
  hi2c->State = HAL_I2C_STATE_BUSY;
340081a8:	2324      	movs	r3, #36	@ 0x24
  __HAL_I2C_DISABLE(hi2c);
340081aa:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
340081ac:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
340081b0:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
340081b2:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE(hi2c);
340081b4:	f023 0301 	bic.w	r3, r3, #1
340081b8:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
340081ba:	f7ff ffcd 	bl	34008158 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340081be:	2000      	movs	r0, #0
340081c0:	6460      	str	r0, [r4, #68]	@ 0x44
  __HAL_UNLOCK(hi2c);
340081c2:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
340081c6:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
340081ca:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
340081cc:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
340081d0:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
340081d2:	2001      	movs	r0, #1
340081d4:	e7fc      	b.n	340081d0 <HAL_I2C_DeInit+0x74>
340081d6:	bf00      	nop
340081d8:	50005400 	.word	0x50005400
340081dc:	50005800 	.word	0x50005800
340081e0:	50005c00 	.word	0x50005c00
340081e4:	56001c00 	.word	0x56001c00
340081e8:	3401c536 	.word	0x3401c536

340081ec <HAL_I2C_Mem_Write>:
{
340081ec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340081f0:	4699      	mov	r9, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
340081f2:	3b01      	subs	r3, #1
340081f4:	2b01      	cmp	r3, #1
{
340081f6:	4604      	mov	r4, r0
340081f8:	460f      	mov	r7, r1
340081fa:	4616      	mov	r6, r2
340081fc:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
34008200:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
34008204:	d904      	bls.n	34008210 <HAL_I2C_Mem_Write+0x24>
34008206:	f640 2138 	movw	r1, #2616	@ 0xa38
3400820a:	4868      	ldr	r0, [pc, #416]	@ (340083ac <HAL_I2C_Mem_Write+0x1c0>)
3400820c:	f7fa f996 	bl	3400253c <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
34008210:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
34008214:	2b20      	cmp	r3, #32
34008216:	f040 80c6 	bne.w	340083a6 <HAL_I2C_Mem_Write+0x1ba>
    if ((pData == NULL) || (Size == 0U))
3400821a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
3400821c:	b113      	cbz	r3, 34008224 <HAL_I2C_Mem_Write+0x38>
3400821e:	f1ba 0f00 	cmp.w	sl, #0
34008222:	d106      	bne.n	34008232 <HAL_I2C_Mem_Write+0x46>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34008224:	f44f 7300 	mov.w	r3, #512	@ 0x200
34008228:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
3400822a:	2001      	movs	r0, #1
}
3400822c:	b003      	add	sp, #12
3400822e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
34008232:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
34008236:	2b01      	cmp	r3, #1
34008238:	f000 80b5 	beq.w	340083a6 <HAL_I2C_Mem_Write+0x1ba>
3400823c:	f04f 0b01 	mov.w	fp, #1
34008240:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
34008244:	f7fc fb54 	bl	340048f0 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008248:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
3400824a:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3400824c:	9000      	str	r0, [sp, #0]
3400824e:	465a      	mov	r2, fp
34008250:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34008254:	4620      	mov	r0, r4
34008256:	f7ff fe5a 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
3400825a:	2800      	cmp	r0, #0
3400825c:	d1e5      	bne.n	3400822a <HAL_I2C_Mem_Write+0x3e>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
3400825e:	2321      	movs	r3, #33	@ 0x21
34008260:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
34008264:	2340      	movs	r3, #64	@ 0x40
34008266:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
3400826a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400826c:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
3400826e:	6263      	str	r3, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34008270:	4b4f      	ldr	r3, [pc, #316]	@ (340083b0 <HAL_I2C_Mem_Write+0x1c4>)
    hi2c->XferISR   = NULL;
34008272:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34008274:	4639      	mov	r1, r7
34008276:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
34008278:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
3400827c:	fa5f f289 	uxtb.w	r2, r9
34008280:	9300      	str	r3, [sp, #0]
34008282:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34008286:	f7ff fd31 	bl	34007cec <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400828a:	462a      	mov	r2, r5
3400828c:	4641      	mov	r1, r8
3400828e:	4620      	mov	r0, r4
34008290:	f7ff fe12 	bl	34007eb8 <I2C_WaitOnTXISFlagUntilTimeout>
34008294:	bb18      	cbnz	r0, 340082de <HAL_I2C_Mem_Write+0xf2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34008296:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400829a:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400829c:	d115      	bne.n	340082ca <HAL_I2C_Mem_Write+0xde>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400829e:	b2f6      	uxtb	r6, r6
340082a0:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
340082a2:	2200      	movs	r2, #0
340082a4:	4643      	mov	r3, r8
340082a6:	2180      	movs	r1, #128	@ 0x80
340082a8:	4620      	mov	r0, r4
340082aa:	9500      	str	r5, [sp, #0]
340082ac:	f7ff fe2f 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
340082b0:	b9a8      	cbnz	r0, 340082de <HAL_I2C_Mem_Write+0xf2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
340082b2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
340082b4:	b29b      	uxth	r3, r3
340082b6:	2bff      	cmp	r3, #255	@ 0xff
340082b8:	d815      	bhi.n	340082e6 <HAL_I2C_Mem_Write+0xfa>
      hi2c->XferSize = hi2c->XferCount;
340082ba:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
340082bc:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
340082c0:	b292      	uxth	r2, r2
340082c2:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
340082c4:	9000      	str	r0, [sp, #0]
340082c6:	b2d2      	uxtb	r2, r2
340082c8:	e012      	b.n	340082f0 <HAL_I2C_Mem_Write+0x104>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
340082ca:	0a32      	lsrs	r2, r6, #8
340082cc:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
340082ce:	4641      	mov	r1, r8
340082d0:	462a      	mov	r2, r5
340082d2:	4620      	mov	r0, r4
340082d4:	f7ff fdf0 	bl	34007eb8 <I2C_WaitOnTXISFlagUntilTimeout>
340082d8:	b908      	cbnz	r0, 340082de <HAL_I2C_Mem_Write+0xf2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340082da:	6823      	ldr	r3, [r4, #0]
340082dc:	e7df      	b.n	3400829e <HAL_I2C_Mem_Write+0xb2>
      __HAL_UNLOCK(hi2c);
340082de:	2300      	movs	r3, #0
340082e0:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
340082e4:	e7a1      	b.n	3400822a <HAL_I2C_Mem_Write+0x3e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
340082e6:	22ff      	movs	r2, #255	@ 0xff
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
340082e8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
340082ec:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
340082ee:	9000      	str	r0, [sp, #0]
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
340082f0:	4639      	mov	r1, r7
340082f2:	4620      	mov	r0, r4
340082f4:	f7ff fcfa 	bl	34007cec <I2C_TransferConfig>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
340082f8:	462a      	mov	r2, r5
340082fa:	4641      	mov	r1, r8
340082fc:	4620      	mov	r0, r4
340082fe:	f7ff fddb 	bl	34007eb8 <I2C_WaitOnTXISFlagUntilTimeout>
34008302:	2800      	cmp	r0, #0
34008304:	d191      	bne.n	3400822a <HAL_I2C_Mem_Write+0x3e>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34008306:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34008308:	6822      	ldr	r2, [r4, #0]
3400830a:	f813 1b01 	ldrb.w	r1, [r3], #1
3400830e:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
34008310:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
34008312:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
34008314:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
34008316:	3b01      	subs	r3, #1
34008318:	b29b      	uxth	r3, r3
3400831a:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400831c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
3400831e:	3a01      	subs	r2, #1
34008320:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008322:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
34008324:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34008326:	b1b3      	cbz	r3, 34008356 <HAL_I2C_Mem_Write+0x16a>
34008328:	b9aa      	cbnz	r2, 34008356 <HAL_I2C_Mem_Write+0x16a>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3400832a:	4643      	mov	r3, r8
3400832c:	2180      	movs	r1, #128	@ 0x80
3400832e:	4620      	mov	r0, r4
34008330:	9500      	str	r5, [sp, #0]
34008332:	f7ff fdec 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
34008336:	2800      	cmp	r0, #0
34008338:	f47f af77 	bne.w	3400822a <HAL_I2C_Mem_Write+0x3e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400833c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
3400833e:	b29b      	uxth	r3, r3
34008340:	2bff      	cmp	r3, #255	@ 0xff
34008342:	d928      	bls.n	34008396 <HAL_I2C_Mem_Write+0x1aa>
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008344:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34008346:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
3400834a:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3400834c:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400834e:	4639      	mov	r1, r7
34008350:	4620      	mov	r0, r4
34008352:	f7ff fccb 	bl	34007cec <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
34008356:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008358:	b29b      	uxth	r3, r3
3400835a:	2b00      	cmp	r3, #0
3400835c:	d1cc      	bne.n	340082f8 <HAL_I2C_Mem_Write+0x10c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3400835e:	462a      	mov	r2, r5
34008360:	4641      	mov	r1, r8
34008362:	4620      	mov	r0, r4
34008364:	f7ff fe0e 	bl	34007f84 <I2C_WaitOnSTOPFlagUntilTimeout>
34008368:	2800      	cmp	r0, #0
3400836a:	f47f af5e 	bne.w	3400822a <HAL_I2C_Mem_Write+0x3e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400836e:	2120      	movs	r1, #32
34008370:	6823      	ldr	r3, [r4, #0]
34008372:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34008374:	685a      	ldr	r2, [r3, #4]
34008376:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
3400837a:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
3400837e:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
34008382:	f022 0201 	bic.w	r2, r2, #1
34008386:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
34008388:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
3400838c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
34008390:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
34008394:	e74a      	b.n	3400822c <HAL_I2C_Mem_Write+0x40>
          hi2c->XferSize = hi2c->XferCount;
34008396:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008398:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
3400839c:	b292      	uxth	r2, r2
3400839e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340083a0:	9000      	str	r0, [sp, #0]
340083a2:	b2d2      	uxtb	r2, r2
340083a4:	e7d3      	b.n	3400834e <HAL_I2C_Mem_Write+0x162>
    __HAL_LOCK(hi2c);
340083a6:	2002      	movs	r0, #2
340083a8:	e740      	b.n	3400822c <HAL_I2C_Mem_Write+0x40>
340083aa:	bf00      	nop
340083ac:	3401c536 	.word	0x3401c536
340083b0:	80002000 	.word	0x80002000

340083b4 <HAL_I2C_Mem_Read>:
{
340083b4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340083b8:	4699      	mov	r9, r3
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
340083ba:	3b01      	subs	r3, #1
340083bc:	2b01      	cmp	r3, #1
{
340083be:	4604      	mov	r4, r0
340083c0:	460f      	mov	r7, r1
340083c2:	4616      	mov	r6, r2
340083c4:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
340083c8:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
340083cc:	d904      	bls.n	340083d8 <HAL_I2C_Mem_Read+0x24>
340083ce:	f640 21c1 	movw	r1, #2753	@ 0xac1
340083d2:	4869      	ldr	r0, [pc, #420]	@ (34008578 <HAL_I2C_Mem_Read+0x1c4>)
340083d4:	f7fa f8b2 	bl	3400253c <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_READY)
340083d8:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
340083dc:	2b20      	cmp	r3, #32
340083de:	f040 80c9 	bne.w	34008574 <HAL_I2C_Mem_Read+0x1c0>
    if ((pData == NULL) || (Size == 0U))
340083e2:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
340083e4:	b113      	cbz	r3, 340083ec <HAL_I2C_Mem_Read+0x38>
340083e6:	f1ba 0f00 	cmp.w	sl, #0
340083ea:	d106      	bne.n	340083fa <HAL_I2C_Mem_Read+0x46>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
340083ec:	f44f 7300 	mov.w	r3, #512	@ 0x200
340083f0:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
340083f2:	2001      	movs	r0, #1
}
340083f4:	b003      	add	sp, #12
340083f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
340083fa:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
340083fe:	2b01      	cmp	r3, #1
34008400:	f000 80b8 	beq.w	34008574 <HAL_I2C_Mem_Read+0x1c0>
34008404:	f04f 0b01 	mov.w	fp, #1
34008408:	f884 b040 	strb.w	fp, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
3400840c:	f7fc fa70 	bl	340048f0 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008410:	2319      	movs	r3, #25
34008412:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
34008414:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34008416:	465a      	mov	r2, fp
34008418:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400841c:	4620      	mov	r0, r4
3400841e:	f7ff fd76 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
34008422:	4603      	mov	r3, r0
34008424:	2800      	cmp	r0, #0
34008426:	d1e4      	bne.n	340083f2 <HAL_I2C_Mem_Read+0x3e>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
34008428:	2222      	movs	r2, #34	@ 0x22
3400842a:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3400842e:	2240      	movs	r2, #64	@ 0x40
34008430:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
34008434:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34008436:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->pBuffPtr  = pData;
34008438:	6262      	str	r2, [r4, #36]	@ 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
3400843a:	4a50      	ldr	r2, [pc, #320]	@ (3400857c <HAL_I2C_Mem_Read+0x1c8>)
    hi2c->XferISR   = NULL;
3400843c:	6360      	str	r0, [r4, #52]	@ 0x34
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
3400843e:	4639      	mov	r1, r7
34008440:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
34008442:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34008446:	9200      	str	r2, [sp, #0]
34008448:	fa5f f289 	uxtb.w	r2, r9
3400844c:	f7ff fc4e 	bl	34007cec <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34008450:	462a      	mov	r2, r5
34008452:	4641      	mov	r1, r8
34008454:	4620      	mov	r0, r4
34008456:	f7ff fd2f 	bl	34007eb8 <I2C_WaitOnTXISFlagUntilTimeout>
3400845a:	bb20      	cbnz	r0, 340084a6 <HAL_I2C_Mem_Read+0xf2>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400845c:	f1b9 0f01 	cmp.w	r9, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34008460:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34008462:	d116      	bne.n	34008492 <HAL_I2C_Mem_Read+0xde>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34008464:	b2f6      	uxtb	r6, r6
34008466:	629e      	str	r6, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
34008468:	2200      	movs	r2, #0
3400846a:	4643      	mov	r3, r8
3400846c:	2140      	movs	r1, #64	@ 0x40
3400846e:	4620      	mov	r0, r4
34008470:	9500      	str	r5, [sp, #0]
34008472:	f7ff fd4c 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
34008476:	b9b0      	cbnz	r0, 340084a6 <HAL_I2C_Mem_Read+0xf2>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34008478:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
3400847a:	b29b      	uxth	r3, r3
3400847c:	2bff      	cmp	r3, #255	@ 0xff
3400847e:	4b40      	ldr	r3, [pc, #256]	@ (34008580 <HAL_I2C_Mem_Read+0x1cc>)
34008480:	d815      	bhi.n	340084ae <HAL_I2C_Mem_Read+0xfa>
      hi2c->XferSize = hi2c->XferCount;
34008482:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
34008484:	b292      	uxth	r2, r2
34008486:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008488:	9300      	str	r3, [sp, #0]
3400848a:	b2d2      	uxtb	r2, r2
3400848c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34008490:	e012      	b.n	340084b8 <HAL_I2C_Mem_Read+0x104>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
34008492:	0a32      	lsrs	r2, r6, #8
34008494:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34008496:	4641      	mov	r1, r8
34008498:	462a      	mov	r2, r5
3400849a:	4620      	mov	r0, r4
3400849c:	f7ff fd0c 	bl	34007eb8 <I2C_WaitOnTXISFlagUntilTimeout>
340084a0:	b908      	cbnz	r0, 340084a6 <HAL_I2C_Mem_Read+0xf2>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
340084a2:	6823      	ldr	r3, [r4, #0]
340084a4:	e7de      	b.n	34008464 <HAL_I2C_Mem_Read+0xb0>
      __HAL_UNLOCK(hi2c);
340084a6:	2300      	movs	r3, #0
340084a8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
340084ac:	e7a1      	b.n	340083f2 <HAL_I2C_Mem_Read+0x3e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
340084ae:	22ff      	movs	r2, #255	@ 0xff
340084b0:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
340084b2:	9300      	str	r3, [sp, #0]
340084b4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
340084b8:	4639      	mov	r1, r7
340084ba:	4620      	mov	r0, r4
340084bc:	f7ff fc16 	bl	34007cec <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
340084c0:	4643      	mov	r3, r8
340084c2:	2200      	movs	r2, #0
340084c4:	2104      	movs	r1, #4
340084c6:	4620      	mov	r0, r4
340084c8:	9500      	str	r5, [sp, #0]
340084ca:	f7ff fd20 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
340084ce:	2800      	cmp	r0, #0
340084d0:	d18f      	bne.n	340083f2 <HAL_I2C_Mem_Read+0x3e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340084d2:	6823      	ldr	r3, [r4, #0]
340084d4:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340084d6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
340084d8:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
340084da:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
340084dc:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
340084de:	3301      	adds	r3, #1
340084e0:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
340084e2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340084e4:	3a01      	subs	r2, #1
      hi2c->XferCount--;
340084e6:	3b01      	subs	r3, #1
340084e8:	b29b      	uxth	r3, r3
340084ea:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340084ec:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
340084ee:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340084f0:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
340084f2:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
340084f4:	b1b3      	cbz	r3, 34008524 <HAL_I2C_Mem_Read+0x170>
340084f6:	b9aa      	cbnz	r2, 34008524 <HAL_I2C_Mem_Read+0x170>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
340084f8:	4643      	mov	r3, r8
340084fa:	2180      	movs	r1, #128	@ 0x80
340084fc:	4620      	mov	r0, r4
340084fe:	9500      	str	r5, [sp, #0]
34008500:	f7ff fd05 	bl	34007f0e <I2C_WaitOnFlagUntilTimeout>
34008504:	2800      	cmp	r0, #0
34008506:	f47f af74 	bne.w	340083f2 <HAL_I2C_Mem_Read+0x3e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400850a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
3400850c:	b29b      	uxth	r3, r3
3400850e:	2bff      	cmp	r3, #255	@ 0xff
34008510:	d928      	bls.n	34008564 <HAL_I2C_Mem_Read+0x1b0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008512:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34008514:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
34008518:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
3400851a:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400851c:	4639      	mov	r1, r7
3400851e:	4620      	mov	r0, r4
34008520:	f7ff fbe4 	bl	34007cec <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
34008524:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
34008526:	b29b      	uxth	r3, r3
34008528:	2b00      	cmp	r3, #0
3400852a:	d1c9      	bne.n	340084c0 <HAL_I2C_Mem_Read+0x10c>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3400852c:	462a      	mov	r2, r5
3400852e:	4641      	mov	r1, r8
34008530:	4620      	mov	r0, r4
34008532:	f7ff fd27 	bl	34007f84 <I2C_WaitOnSTOPFlagUntilTimeout>
34008536:	2800      	cmp	r0, #0
34008538:	f47f af5b 	bne.w	340083f2 <HAL_I2C_Mem_Read+0x3e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400853c:	2120      	movs	r1, #32
3400853e:	6823      	ldr	r3, [r4, #0]
34008540:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
34008542:	685a      	ldr	r2, [r3, #4]
34008544:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
34008548:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
3400854c:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
34008550:	f022 0201 	bic.w	r2, r2, #1
34008554:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
34008556:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
3400855a:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3400855e:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
34008562:	e747      	b.n	340083f4 <HAL_I2C_Mem_Read+0x40>
          hi2c->XferSize = hi2c->XferCount;
34008564:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34008566:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
3400856a:	b292      	uxth	r2, r2
3400856c:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400856e:	9000      	str	r0, [sp, #0]
34008570:	b2d2      	uxtb	r2, r2
34008572:	e7d3      	b.n	3400851c <HAL_I2C_Mem_Read+0x168>
    __HAL_LOCK(hi2c);
34008574:	2002      	movs	r0, #2
34008576:	e73d      	b.n	340083f4 <HAL_I2C_Mem_Read+0x40>
34008578:	3401c536 	.word	0x3401c536
3400857c:	80002000 	.word	0x80002000
34008580:	80002400 	.word	0x80002400

34008584 <HAL_I2C_GetState>:
  return hi2c->State;
34008584:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
34008588:	4770      	bx	lr

3400858a <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
3400858a:	6c40      	ldr	r0, [r0, #68]	@ 0x44
}
3400858c:	4770      	bx	lr
	...

34008590 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
34008590:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008592:	4a27      	ldr	r2, [pc, #156]	@ (34008630 <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
34008594:	6803      	ldr	r3, [r0, #0]
{
34008596:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008598:	4293      	cmp	r3, r2
{
3400859a:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
3400859c:	d01c      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
3400859e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340085a2:	4293      	cmp	r3, r2
340085a4:	d018      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085a6:	4a23      	ldr	r2, [pc, #140]	@ (34008634 <HAL_I2CEx_ConfigAnalogFilter+0xa4>)
340085a8:	4293      	cmp	r3, r2
340085aa:	d015      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085ac:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340085b0:	4293      	cmp	r3, r2
340085b2:	d011      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085b4:	4a20      	ldr	r2, [pc, #128]	@ (34008638 <HAL_I2CEx_ConfigAnalogFilter+0xa8>)
340085b6:	4293      	cmp	r3, r2
340085b8:	d00e      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085ba:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340085be:	4293      	cmp	r3, r2
340085c0:	d00a      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085c2:	4a1e      	ldr	r2, [pc, #120]	@ (3400863c <HAL_I2CEx_ConfigAnalogFilter+0xac>)
340085c4:	4293      	cmp	r3, r2
340085c6:	d007      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085c8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340085cc:	4293      	cmp	r3, r2
340085ce:	d003      	beq.n	340085d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
340085d0:	2162      	movs	r1, #98	@ 0x62
340085d2:	481b      	ldr	r0, [pc, #108]	@ (34008640 <HAL_I2CEx_ConfigAnalogFilter+0xb0>)
340085d4:	f7f9 ffb2 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
340085d8:	f435 5380 	bics.w	r3, r5, #4096	@ 0x1000
340085dc:	d003      	beq.n	340085e6 <HAL_I2CEx_ConfigAnalogFilter+0x56>
340085de:	2163      	movs	r1, #99	@ 0x63
340085e0:	4817      	ldr	r0, [pc, #92]	@ (34008640 <HAL_I2CEx_ConfigAnalogFilter+0xb0>)
340085e2:	f7f9 ffab 	bl	3400253c <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
340085e6:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
340085ea:	2b20      	cmp	r3, #32
340085ec:	b2d9      	uxtb	r1, r3
340085ee:	d11c      	bne.n	3400862a <HAL_I2CEx_ConfigAnalogFilter+0x9a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
340085f0:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
340085f4:	2b01      	cmp	r3, #1
340085f6:	d018      	beq.n	3400862a <HAL_I2CEx_ConfigAnalogFilter+0x9a>

    hi2c->State = HAL_I2C_STATE_BUSY;
340085f8:	2324      	movs	r3, #36	@ 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340085fa:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
340085fc:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    __HAL_I2C_DISABLE(hi2c);
34008600:	6823      	ldr	r3, [r4, #0]
34008602:	681a      	ldr	r2, [r3, #0]
34008604:	f022 0201 	bic.w	r2, r2, #1
34008608:	601a      	str	r2, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
3400860a:	681a      	ldr	r2, [r3, #0]
3400860c:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34008610:	601a      	str	r2, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
34008612:	681a      	ldr	r2, [r3, #0]
34008614:	432a      	orrs	r2, r5
34008616:	601a      	str	r2, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
34008618:	681a      	ldr	r2, [r3, #0]
3400861a:	f042 0201 	orr.w	r2, r2, #1
3400861e:	601a      	str	r2, [r3, #0]
    hi2c->State = HAL_I2C_STATE_READY;
34008620:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
34008624:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
34008628:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hi2c);
3400862a:	2002      	movs	r0, #2
3400862c:	e7fc      	b.n	34008628 <HAL_I2CEx_ConfigAnalogFilter+0x98>
3400862e:	bf00      	nop
34008630:	50005400 	.word	0x50005400
34008634:	50005800 	.word	0x50005800
34008638:	50005c00 	.word	0x50005c00
3400863c:	56001c00 	.word	0x56001c00
34008640:	3401c5a4 	.word	0x3401c5a4

34008644 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
34008644:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008646:	4a26      	ldr	r2, [pc, #152]	@ (340086e0 <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
34008648:	6803      	ldr	r3, [r0, #0]
{
3400864a:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
3400864c:	4293      	cmp	r3, r2
{
3400864e:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
34008650:	d01c      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008652:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008656:	4293      	cmp	r3, r2
34008658:	d018      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
3400865a:	4a22      	ldr	r2, [pc, #136]	@ (340086e4 <HAL_I2CEx_ConfigDigitalFilter+0xa0>)
3400865c:	4293      	cmp	r3, r2
3400865e:	d015      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008660:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008664:	4293      	cmp	r3, r2
34008666:	d011      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008668:	4a1f      	ldr	r2, [pc, #124]	@ (340086e8 <HAL_I2CEx_ConfigDigitalFilter+0xa4>)
3400866a:	4293      	cmp	r3, r2
3400866c:	d00e      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
3400866e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008672:	4293      	cmp	r3, r2
34008674:	d00a      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008676:	4a1d      	ldr	r2, [pc, #116]	@ (340086ec <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
34008678:	4293      	cmp	r3, r2
3400867a:	d007      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
3400867c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008680:	4293      	cmp	r3, r2
34008682:	d003      	beq.n	3400868c <HAL_I2CEx_ConfigDigitalFilter+0x48>
34008684:	2190      	movs	r1, #144	@ 0x90
34008686:	481a      	ldr	r0, [pc, #104]	@ (340086f0 <HAL_I2CEx_ConfigDigitalFilter+0xac>)
34008688:	f7f9 ff58 	bl	3400253c <assert_failed>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
3400868c:	2d0f      	cmp	r5, #15
3400868e:	d903      	bls.n	34008698 <HAL_I2CEx_ConfigDigitalFilter+0x54>
34008690:	2191      	movs	r1, #145	@ 0x91
34008692:	4817      	ldr	r0, [pc, #92]	@ (340086f0 <HAL_I2CEx_ConfigDigitalFilter+0xac>)
34008694:	f7f9 ff52 	bl	3400253c <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
34008698:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
3400869c:	2b20      	cmp	r3, #32
3400869e:	b2d8      	uxtb	r0, r3
340086a0:	d11b      	bne.n	340086da <HAL_I2CEx_ConfigDigitalFilter+0x96>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
340086a2:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
340086a6:	2b01      	cmp	r3, #1
340086a8:	d017      	beq.n	340086da <HAL_I2CEx_ConfigDigitalFilter+0x96>

    hi2c->State = HAL_I2C_STATE_BUSY;
340086aa:	2324      	movs	r3, #36	@ 0x24
340086ac:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
340086b0:	6823      	ldr	r3, [r4, #0]
340086b2:	681a      	ldr	r2, [r3, #0]
340086b4:	f022 0201 	bic.w	r2, r2, #1
340086b8:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
340086ba:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
340086bc:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
340086c0:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
340086c4:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
340086c6:	681a      	ldr	r2, [r3, #0]
340086c8:	f042 0201 	orr.w	r2, r2, #1
340086cc:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
340086ce:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340086d2:	2000      	movs	r0, #0
340086d4:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
340086d8:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hi2c);
340086da:	2002      	movs	r0, #2
340086dc:	e7fc      	b.n	340086d8 <HAL_I2CEx_ConfigDigitalFilter+0x94>
340086de:	bf00      	nop
340086e0:	50005400 	.word	0x50005400
340086e4:	50005800 	.word	0x50005800
340086e8:	50005c00 	.word	0x50005c00
340086ec:	56001c00 	.word	0x56001c00
340086f0:	3401c5a4 	.word	0x3401c5a4

340086f4 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
340086f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
340086f8:	2634      	movs	r6, #52	@ 0x34
{
340086fa:	b087      	sub	sp, #28
340086fc:	f8dd c040 	ldr.w	ip, [sp, #64]	@ 0x40
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34008700:	6804      	ldr	r4, [r0, #0]
34008702:	fb06 060c 	mla	r6, r6, ip, r0

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008706:	f8d6 e048 	ldr.w	lr, [r6, #72]	@ 0x48
{
3400870a:	e9cd 2302 	strd	r2, r3, [sp, #8]
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3400870e:	6e75      	ldr	r5, [r6, #100]	@ 0x64
34008710:	f10c 0301 	add.w	r3, ip, #1
34008714:	eb04 2303 	add.w	r3, r4, r3, lsl #8
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008718:	f1be 0f03 	cmp.w	lr, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3400871c:	63dd      	str	r5, [r3, #60]	@ 0x3c
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400871e:	d84c      	bhi.n	340087ba <LTDC_SetConfig+0xc6>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
34008720:	2604      	movs	r6, #4
      stride = 1U;
      break;
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008722:	2734      	movs	r7, #52	@ 0x34
34008724:	fb07 000c 	mla	r0, r7, ip, r0
34008728:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400872c:	f8d0 b038 	ldr.w	fp, [r0, #56]	@ 0x38
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008730:	68e7      	ldr	r7, [r4, #12]
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008732:	f8d0 803c 	ldr.w	r8, [r0, #60]	@ 0x3c
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008736:	f10b 0901 	add.w	r9, fp, #1
3400873a:	f3c7 470b 	ubfx	r7, r7, #16, #12
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3400873e:	f3cc 4c0b 	ubfx	ip, ip, #16, #12
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008742:	444f      	add	r7, r9
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34008744:	44c4      	add	ip, r8
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34008746:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400874a:	611f      	str	r7, [r3, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3400874c:	6c47      	ldr	r7, [r0, #68]	@ 0x44
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400874e:	6c02      	ldr	r2, [r0, #64]	@ 0x40
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008750:	9704      	str	r7, [sp, #16]
34008752:	68e7      	ldr	r7, [r4, #12]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008754:	68e4      	ldr	r4, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34008756:	9205      	str	r2, [sp, #20]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008758:	f3c4 0c0b 	ubfx	ip, r4, #0, #12
3400875c:	1c54      	adds	r4, r2, #1
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3400875e:	9a04      	ldr	r2, [sp, #16]
34008760:	f3c7 070b 	ubfx	r7, r7, #0, #12
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008764:	4464      	add	r4, ip
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
34008766:	4417      	add	r7, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
34008768:	ea44 4407 	orr.w	r4, r4, r7, lsl #16

  if (Mirror == LTDC_MIRROR_NONE)
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3400876c:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400876e:	615c      	str	r4, [r3, #20]
        /* Configure the auxiliary frame buffer address 1 */
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;

        /* Configure the buffer length */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008770:	eba8 040b 	sub.w	r4, r8, fp
        break;
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
34008774:	fb04 f906 	mul.w	r9, r4, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008778:	9201      	str	r2, [sp, #4]
  if (Mirror == LTDC_MIRROR_NONE)
3400877a:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400877c:	6e00      	ldr	r0, [r0, #96]	@ 0x60
  if (Mirror == LTDC_MIRROR_NONE)
3400877e:	2a03      	cmp	r2, #3
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34008780:	fb00 fc06 	mul.w	ip, r0, r6
                                            stride)  + 7U));
34008784:	f109 0a07 	add.w	sl, r9, #7
  if (Mirror == LTDC_MIRROR_NONE)
34008788:	d145      	bne.n	34008816 <LTDC_SetConfig+0x122>
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400878a:	f240 160d 	movw	r6, #269	@ 0x10d
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3400878e:	9a01      	ldr	r2, [sp, #4]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008790:	45b6      	cmp	lr, r6
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
34008792:	635a      	str	r2, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008794:	d02a      	beq.n	340087ec <LTDC_SetConfig+0xf8>
34008796:	f240 260d 	movw	r6, #525	@ 0x20d
3400879a:	45b6      	cmp	lr, r6
3400879c:	d031      	beq.n	34008802 <LTDC_SetConfig+0x10e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400879e:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
340087a2:	639a      	str	r2, [r3, #56]	@ 0x38
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
340087a4:	68da      	ldr	r2, [r3, #12]
340087a6:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
340087aa:	f022 0201 	bic.w	r2, r2, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
340087ae:	f042 0201 	orr.w	r2, r2, #1
340087b2:	60da      	str	r2, [r3, #12]
  }
}
340087b4:	b007      	add	sp, #28
340087b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340087ba:	f1ae 0704 	sub.w	r7, lr, #4
340087be:	2f09      	cmp	r7, #9
340087c0:	f04f 0601 	mov.w	r6, #1
340087c4:	d8ad      	bhi.n	34008722 <LTDC_SetConfig+0x2e>
340087c6:	f240 299b 	movw	r9, #667	@ 0x29b
340087ca:	fa06 f807 	lsl.w	r8, r6, r7
340087ce:	ea18 0f09 	tst.w	r8, r9
340087d2:	d107      	bne.n	340087e4 <LTDC_SetConfig+0xf0>
340087d4:	2f02      	cmp	r7, #2
340087d6:	d007      	beq.n	340087e8 <LTDC_SetConfig+0xf4>
340087d8:	2f08      	cmp	r7, #8
340087da:	d1a2      	bne.n	34008722 <LTDC_SetConfig+0x2e>
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
340087dc:	6f9e      	ldr	r6, [r3, #120]	@ 0x78
340087de:	f3c6 4682 	ubfx	r6, r6, #18, #3
      break;
340087e2:	e79e      	b.n	34008722 <LTDC_SetConfig+0x2e>
      stride = 2U;
340087e4:	2602      	movs	r6, #2
340087e6:	e79c      	b.n	34008722 <LTDC_SetConfig+0x2e>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340087e8:	2603      	movs	r6, #3
340087ea:	e79a      	b.n	34008722 <LTDC_SetConfig+0x2e>
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
340087ec:	f108 0207 	add.w	r2, r8, #7
340087f0:	eba2 020b 	sub.w	r2, r2, fp
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
340087f4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
340087f8:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
340087fa:	649a      	str	r2, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
340087fc:	086d      	lsrs	r5, r5, #1
340087fe:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008800:	e7cd      	b.n	3400879e <LTDC_SetConfig+0xaa>
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008802:	0864      	lsrs	r4, r4, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34008804:	9a02      	ldr	r2, [sp, #8]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008806:	0840      	lsrs	r0, r0, #1
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008808:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400880a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3400880e:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
34008810:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008812:	649c      	str	r4, [r3, #72]	@ 0x48
34008814:	e7f2      	b.n	340087fc <LTDC_SetConfig+0x108>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
34008816:	9a03      	ldr	r2, [sp, #12]
34008818:	bb3a      	cbnz	r2, 3400886a <LTDC_SetConfig+0x176>
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400881a:	9a01      	ldr	r2, [sp, #4]
3400881c:	1e57      	subs	r7, r2, #1
3400881e:	444f      	add	r7, r9
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008820:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008822:	f240 170d 	movw	r7, #269	@ 0x10d
34008826:	45be      	cmp	lr, r7
34008828:	d00a      	beq.n	34008840 <LTDC_SetConfig+0x14c>
3400882a:	f240 270d 	movw	r7, #525	@ 0x20d
3400882e:	45be      	cmp	lr, r7
34008830:	d010      	beq.n	34008854 <LTDC_SetConfig+0x160>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34008832:	ea4a 420c 	orr.w	r2, sl, ip, lsl #16
34008836:	639a      	str	r2, [r3, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34008838:	68da      	ldr	r2, [r3, #12]
3400883a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
3400883e:	e7b6      	b.n	340087ae <LTDC_SetConfig+0xba>
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34008840:	3901      	subs	r1, #1
34008842:	4449      	add	r1, r9
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008844:	6419      	str	r1, [r3, #64]	@ 0x40
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34008846:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008848:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400884c:	086d      	lsrs	r5, r5, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400884e:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008850:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008852:	e7ee      	b.n	34008832 <LTDC_SetConfig+0x13e>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008854:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34008856:	4366      	muls	r6, r4
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008858:	9a02      	ldr	r2, [sp, #8]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400885a:	3901      	subs	r1, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400885c:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400885e:	4431      	add	r1, r6
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34008860:	4432      	add	r2, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34008862:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008864:	0840      	lsrs	r0, r0, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008866:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34008868:	e7ed      	b.n	34008846 <LTDC_SetConfig+0x152>
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400886a:	e9dd 2704 	ldrd	r2, r7, [sp, #16]
3400886e:	eba2 0807 	sub.w	r8, r2, r7
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34008872:	9a03      	ldr	r2, [sp, #12]
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008874:	f5cc 4c00 	rsb	ip, ip, #32768	@ 0x8000
  else if (Mirror == LTDC_MIRROR_VERTICAL)
34008878:	2a01      	cmp	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400887a:	ea4a 4c0c 	orr.w	ip, sl, ip, lsl #16
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3400887e:	d131      	bne.n	340088e4 <LTDC_SetConfig+0x1f0>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008880:	9a01      	ldr	r2, [sp, #4]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34008882:	f108 3aff 	add.w	sl, r8, #4294967295
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34008886:	fb09 270a 	mla	r7, r9, sl, r2
3400888a:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400888c:	f240 170d 	movw	r7, #269	@ 0x10d
34008890:	45be      	cmp	lr, r7
34008892:	d006      	beq.n	340088a2 <LTDC_SetConfig+0x1ae>
34008894:	f240 270d 	movw	r7, #525	@ 0x20d
34008898:	45be      	cmp	lr, r7
3400889a:	d00d      	beq.n	340088b8 <LTDC_SetConfig+0x1c4>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400889c:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
340088a0:	e780      	b.n	340087a4 <LTDC_SetConfig+0xb0>
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340088a2:	ea4f 0258 	mov.w	r2, r8, lsr #1
340088a6:	3a01      	subs	r2, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340088a8:	fb09 1202 	mla	r2, r9, r2, r1
340088ac:	641a      	str	r2, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
340088ae:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
340088b2:	086d      	lsrs	r5, r5, #1
340088b4:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
340088b6:	e7f1      	b.n	3400889c <LTDC_SetConfig+0x1a8>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340088b8:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
340088ba:	4374      	muls	r4, r6
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340088bc:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340088c0:	0840      	lsrs	r0, r0, #1
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340088c2:	f108 38ff 	add.w	r8, r8, #4294967295
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340088c6:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340088ca:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340088ce:	4370      	muls	r0, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340088d0:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
340088d2:	3407      	adds	r4, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340088d4:	4441      	add	r1, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340088d6:	4442      	add	r2, r8
                                               stride) << 16U) |
340088d8:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340088dc:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340088de:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
340088e0:	649c      	str	r4, [r3, #72]	@ 0x48
340088e2:	e7e6      	b.n	340088b2 <LTDC_SetConfig+0x1be>
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
340088e4:	9a01      	ldr	r2, [sp, #4]
340088e6:	1e57      	subs	r7, r2, #1
340088e8:	fb09 7708 	mla	r7, r9, r8, r7
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
340088ec:	635f      	str	r7, [r3, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340088ee:	f240 170d 	movw	r7, #269	@ 0x10d
340088f2:	45be      	cmp	lr, r7
340088f4:	d006      	beq.n	34008904 <LTDC_SetConfig+0x210>
340088f6:	f240 270d 	movw	r7, #525	@ 0x20d
340088fa:	45be      	cmp	lr, r7
340088fc:	d00d      	beq.n	3400891a <LTDC_SetConfig+0x226>
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
340088fe:	f8c3 c038 	str.w	ip, [r3, #56]	@ 0x38
34008902:	e799      	b.n	34008838 <LTDC_SetConfig+0x144>
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008904:	ea4f 0858 	mov.w	r8, r8, lsr #1
34008908:	3901      	subs	r1, #1
3400890a:	fb09 1108 	mla	r1, r9, r8, r1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400890e:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34008910:	f8c3 c048 	str.w	ip, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34008914:	086d      	lsrs	r5, r5, #1
34008916:	64dd      	str	r5, [r3, #76]	@ 0x4c
        break;
34008918:	e7f1      	b.n	340088fe <LTDC_SetConfig+0x20a>
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400891a:	0864      	lsrs	r4, r4, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400891c:	4374      	muls	r4, r6
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400891e:	0840      	lsrs	r0, r0, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008920:	ea4f 0858 	mov.w	r8, r8, lsr #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008924:	f5c0 4000 	rsb	r0, r0, #32768	@ 0x8000
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34008928:	fb04 f808 	mul.w	r8, r4, r8
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400892c:	4370      	muls	r0, r6
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400892e:	9a02      	ldr	r2, [sp, #8]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008930:	3901      	subs	r1, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008932:	3a01      	subs	r2, #1
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34008934:	3407      	adds	r4, #7
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008936:	4442      	add	r2, r8
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34008938:	4441      	add	r1, r8
                                              << 16U) |
3400893a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400893e:	6419      	str	r1, [r3, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34008940:	645a      	str	r2, [r3, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34008942:	649c      	str	r4, [r3, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
34008944:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34008946:	f36f 020f 	bfc	r2, #0, #16
3400894a:	64da      	str	r2, [r3, #76]	@ 0x4c
3400894c:	e7e2      	b.n	34008914 <LTDC_SetConfig+0x220>
	...

34008950 <LTDC_SetCompositionConfig>:

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008950:	6802      	ldr	r2, [r0, #0]
34008952:	1c4b      	adds	r3, r1, #1
34008954:	eb02 2203 	add.w	r2, r2, r3, lsl #8
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
34008958:	2334      	movs	r3, #52	@ 0x34
3400895a:	fb03 0101 	mla	r1, r3, r1, r0
3400895e:	6d08      	ldr	r0, [r1, #80]	@ 0x50
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008960:	f891 3068 	ldrb.w	r3, [r1, #104]	@ 0x68
34008964:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
34008968:	f891 0069 	ldrb.w	r0, [r1, #105]	@ 0x69
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3400896c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
34008970:	f891 006a 	ldrb.w	r0, [r1, #106]	@ 0x6a
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34008974:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34008978:	6253      	str	r3, [r2, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
3400897a:	6a13      	ldr	r3, [r2, #32]
3400897c:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34008980:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
34008982:	6ccb      	ldr	r3, [r1, #76]	@ 0x4c
34008984:	6213      	str	r3, [r2, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
34008986:	6a90      	ldr	r0, [r2, #40]	@ 0x28
34008988:	4b05      	ldr	r3, [pc, #20]	@ (340089a0 <LTDC_SetCompositionConfig+0x50>)
3400898a:	4003      	ands	r3, r0
3400898c:	6293      	str	r3, [r2, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
3400898e:	6a90      	ldr	r0, [r2, #40]	@ 0x28
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34008990:	e9d1 3115 	ldrd	r3, r1, [r1, #84]	@ 0x54
34008994:	430b      	orrs	r3, r1
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
34008996:	f400 3180 	and.w	r1, r0, #65536	@ 0x10000
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3400899a:	430b      	orrs	r3, r1
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400899c:	6293      	str	r3, [r2, #40]	@ 0x28
}
3400899e:	4770      	bx	lr
340089a0:	fffef8f8 	.word	0xfffef8f8

340089a4 <LTDC_SetPredefFormat>:
  uint32_t BPOS = 0U;
  uint32_t GLEN = 0U;
  uint32_t GPOS = 0U;

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340089a4:	2334      	movs	r3, #52	@ 0x34
340089a6:	fb03 0301 	mla	r3, r3, r1, r0
340089aa:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
{
340089ac:	b5f0      	push	{r4, r5, r6, r7, lr}
340089ae:	1fd4      	subs	r4, r2, #7
340089b0:	2c04      	cmp	r4, #4
340089b2:	d823      	bhi.n	340089fc <LTDC_SetPredefFormat+0x58>
340089b4:	4a16      	ldr	r2, [pc, #88]	@ (34008a10 <LTDC_SetPredefFormat+0x6c>)
340089b6:	f8df c06c 	ldr.w	ip, [pc, #108]	@ 34008a24 <LTDC_SetPredefFormat+0x80>
340089ba:	5d16      	ldrb	r6, [r2, r4]
340089bc:	4a15      	ldr	r2, [pc, #84]	@ (34008a14 <LTDC_SetPredefFormat+0x70>)
340089be:	4b16      	ldr	r3, [pc, #88]	@ (34008a18 <LTDC_SetPredefFormat+0x74>)
340089c0:	5d17      	ldrb	r7, [r2, r4]
340089c2:	4a16      	ldr	r2, [pc, #88]	@ (34008a1c <LTDC_SetPredefFormat+0x78>)
340089c4:	5d1b      	ldrb	r3, [r3, r4]
340089c6:	5d15      	ldrb	r5, [r2, r4]
340089c8:	4a15      	ldr	r2, [pc, #84]	@ (34008a20 <LTDC_SetPredefFormat+0x7c>)
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
340089ca:	049b      	lsls	r3, r3, #18
340089cc:	5d12      	ldrb	r2, [r2, r4]
340089ce:	f81c 4004 	ldrb.w	r4, [ip, r4]
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
340089d2:	f101 0c01 	add.w	ip, r1, #1
340089d6:	6801      	ldr	r1, [r0, #0]
340089d8:	2007      	movs	r0, #7
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
340089da:	0252      	lsls	r2, r2, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
340089dc:	eb02 3285 	add.w	r2, r2, r5, lsl #14
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
340089e0:	443a      	add	r2, r7
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
340089e2:	eb03 3385 	add.w	r3, r3, r5, lsl #14
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
340089e6:	eb01 210c 	add.w	r1, r1, ip, lsl #8
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
340089ea:	eb02 1246 	add.w	r2, r2, r6, lsl #5
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
340089ee:	4423      	add	r3, r4
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
340089f0:	61c8      	str	r0, [r1, #28]
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
340089f2:	eb03 1345 	add.w	r3, r3, r5, lsl #5
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
340089f6:	674a      	str	r2, [r1, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
340089f8:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
    default:
      break;
  }
}
340089fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
340089fc:	2a06      	cmp	r2, #6
340089fe:	d8fc      	bhi.n	340089fa <LTDC_SetPredefFormat+0x56>
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34008a00:	6803      	ldr	r3, [r0, #0]
34008a02:	3101      	adds	r1, #1
34008a04:	eb03 2101 	add.w	r1, r3, r1, lsl #8
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34008a08:	2300      	movs	r3, #0
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34008a0a:	61ca      	str	r2, [r1, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34008a0c:	674b      	str	r3, [r1, #116]	@ 0x74
34008a0e:	e7f3      	b.n	340089f8 <LTDC_SetPredefFormat+0x54>
34008a10:	34034ffc 	.word	0x34034ffc
34008a14:	34034ff7 	.word	0x34034ff7
34008a18:	34035001 	.word	0x34035001
34008a1c:	34034ff2 	.word	0x34034ff2
34008a20:	34034fed 	.word	0x34034fed
34008a24:	34034fe8 	.word	0x34034fe8

34008a28 <LTDC_RetrieveUserConfig.constprop.0>:
static void LTDC_RetrieveUserConfig(LTDC_HandleTypeDef *hltdc, uint32_t *Mirror, uint32_t *Aux0Addr,
34008a28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34008a2c:	468c      	mov	ip, r1
34008a2e:	9907      	ldr	r1, [sp, #28]
  const uint32_t hmirror = ((LTDC_LAYER(hltdc, LayerIdx)->CR) & LTDC_LxCR_HMEN_Msk);
34008a30:	6805      	ldr	r5, [r0, #0]
34008a32:	1c4c      	adds	r4, r1, #1
34008a34:	eb05 2504 	add.w	r5, r5, r4, lsl #8
34008a38:	68ec      	ldr	r4, [r5, #12]
34008a3a:	f404 7e80 	and.w	lr, r4, #256	@ 0x100
  const uint32_t pitchSign = (LTDC_LAYER(hltdc, LayerIdx)->CFBLR & LTDC_LxCFBLR_CFBP) & LTDC_PITCH_SIGN_MSK;
34008a3e:	6bac      	ldr	r4, [r5, #56]	@ 0x38
34008a40:	f004 4880 	and.w	r8, r4, #1073741824	@ 0x40000000
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008a44:	2434      	movs	r4, #52	@ 0x34
34008a46:	fb04 0401 	mla	r4, r4, r1, r0
34008a4a:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
34008a4c:	2e03      	cmp	r6, #3
34008a4e:	d813      	bhi.n	34008a78 <LTDC_RetrieveUserConfig.constprop.0+0x50>
      stride = 4U;
34008a50:	2404      	movs	r4, #4
  if ((pitchSign == 0U) && (hmirror == 0U))
34008a52:	f1b8 0f00 	cmp.w	r8, #0
34008a56:	d153      	bne.n	34008b00 <LTDC_RetrieveUserConfig.constprop.0+0xd8>
34008a58:	2734      	movs	r7, #52	@ 0x34
34008a5a:	f1be 0f00 	cmp.w	lr, #0
34008a5e:	d123      	bne.n	34008aa8 <LTDC_RetrieveUserConfig.constprop.0+0x80>
    *Mirror = LTDC_MIRROR_NONE;
34008a60:	2403      	movs	r4, #3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34008a62:	fb07 0701 	mla	r7, r7, r1, r0
    *Mirror = LTDC_MIRROR_NONE;
34008a66:	f8cc 4000 	str.w	r4, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34008a6a:	6b6c      	ldr	r4, [r5, #52]	@ 0x34
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34008a6c:	6c29      	ldr	r1, [r5, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34008a6e:	65fc      	str	r4, [r7, #92]	@ 0x5c
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34008a70:	6011      	str	r1, [r2, #0]
    *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R;
34008a72:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008a74:	601a      	str	r2, [r3, #0]
}
34008a76:	e02d      	b.n	34008ad4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008a78:	3e04      	subs	r6, #4
34008a7a:	2e09      	cmp	r6, #9
34008a7c:	f04f 0401 	mov.w	r4, #1
34008a80:	d8e7      	bhi.n	34008a52 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
34008a82:	f240 299b 	movw	r9, #667	@ 0x29b
34008a86:	fa04 f706 	lsl.w	r7, r4, r6
34008a8a:	ea17 0f09 	tst.w	r7, r9
34008a8e:	d107      	bne.n	34008aa0 <LTDC_RetrieveUserConfig.constprop.0+0x78>
34008a90:	2e02      	cmp	r6, #2
34008a92:	d007      	beq.n	34008aa4 <LTDC_RetrieveUserConfig.constprop.0+0x7c>
34008a94:	2e08      	cmp	r6, #8
34008a96:	d1dc      	bne.n	34008a52 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = ((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos;
34008a98:	6fac      	ldr	r4, [r5, #120]	@ 0x78
34008a9a:	f3c4 4482 	ubfx	r4, r4, #18, #3
      break;
34008a9e:	e7d8      	b.n	34008a52 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
      stride = 2U;
34008aa0:	2402      	movs	r4, #2
34008aa2:	e7d6      	b.n	34008a52 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008aa4:	2403      	movs	r4, #3
34008aa6:	e7d4      	b.n	34008a52 <LTDC_RetrieveUserConfig.constprop.0+0x2a>
    *Mirror = LTDC_MIRROR_HORIZONTAL;
34008aa8:	f8cc 8000 	str.w	r8, [ip]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008aac:	f240 1c0d 	movw	ip, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008ab0:	fb07 0001 	mla	r0, r7, r1, r0
34008ab4:	e9d0 710e 	ldrd	r7, r1, [r0, #56]	@ 0x38
34008ab8:	1bc9      	subs	r1, r1, r7
34008aba:	fb04 f701 	mul.w	r7, r4, r1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008abe:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34008ac0:	3601      	adds	r6, #1
34008ac2:	1bf6      	subs	r6, r6, r7
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008ac4:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008ac6:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34008ac8:	4566      	cmp	r6, ip
34008aca:	d005      	beq.n	34008ad8 <LTDC_RetrieveUserConfig.constprop.0+0xb0>
34008acc:	f240 270d 	movw	r7, #525	@ 0x20d
34008ad0:	42be      	cmp	r6, r7
34008ad2:	d006      	beq.n	34008ae2 <LTDC_RetrieveUserConfig.constprop.0+0xba>
}
34008ad4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34008ad8:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34008ada:	3301      	adds	r3, #1
34008adc:	1bdb      	subs	r3, r3, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008ade:	6013      	str	r3, [r2, #0]
        break;
34008ae0:	e7f8      	b.n	34008ad4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34008ae2:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34008ae4:	0849      	lsrs	r1, r1, #1
34008ae6:	3601      	adds	r6, #1
34008ae8:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34008aec:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
34008aee:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008af0:	e9d0 010e 	ldrd	r0, r1, [r0, #56]	@ 0x38
34008af4:	1a09      	subs	r1, r1, r0
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34008af6:	3201      	adds	r2, #1
34008af8:	0849      	lsrs	r1, r1, #1
34008afa:	fb04 2211 	mls	r2, r4, r1, r2
34008afe:	e7b9      	b.n	34008a74 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
  else if ((pitchSign != 0U) && (hmirror == 0U))
34008b00:	2634      	movs	r6, #52	@ 0x34
34008b02:	f1be 0f00 	cmp.w	lr, #0
34008b06:	d138      	bne.n	34008b7a <LTDC_RetrieveUserConfig.constprop.0+0x152>
    *Mirror = LTDC_MIRROR_VERTICAL;
34008b08:	2701      	movs	r7, #1
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008b0a:	fb06 0601 	mla	r6, r6, r1, r0
    *Mirror = LTDC_MIRROR_VERTICAL;
34008b0e:	f8cc 7000 	str.w	r7, [ip]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008b12:	e9d6 100e 	ldrd	r1, r0, [r6, #56]	@ 0x38
34008b16:	1a40      	subs	r0, r0, r1
34008b18:	fb00 fc04 	mul.w	ip, r0, r4
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008b1c:	e9d6 1710 	ldrd	r1, r7, [r6, #64]	@ 0x40
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008b20:	f8d5 8034 	ldr.w	r8, [r5, #52]	@ 0x34
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008b24:	1a79      	subs	r1, r7, r1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34008b26:	f101 3eff 	add.w	lr, r1, #4294967295
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008b2a:	fb0c 871e 	mls	r7, ip, lr, r8
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008b2e:	f240 1e0d 	movw	lr, #269	@ 0x10d
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008b32:	65f7      	str	r7, [r6, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008b34:	6cb7      	ldr	r7, [r6, #72]	@ 0x48
34008b36:	4577      	cmp	r7, lr
34008b38:	d019      	beq.n	34008b6e <LTDC_RetrieveUserConfig.constprop.0+0x146>
34008b3a:	f240 2c0d 	movw	ip, #525	@ 0x20d
34008b3e:	4567      	cmp	r7, ip
34008b40:	d1c8      	bne.n	34008ad4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008b42:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008b44:	0840      	lsrs	r0, r0, #1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008b46:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008b48:	4341      	muls	r1, r0
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008b4a:	6c2f      	ldr	r7, [r5, #64]	@ 0x40
34008b4c:	fb04 7111 	mls	r1, r4, r1, r7
34008b50:	6011      	str	r1, [r2, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008b52:	e9d6 1210 	ldrd	r1, r2, [r6, #64]	@ 0x40
34008b56:	1a52      	subs	r2, r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008b58:	6c68      	ldr	r0, [r5, #68]	@ 0x44
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008b5a:	0852      	lsrs	r2, r2, #1
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008b5c:	e9d6 510e 	ldrd	r5, r1, [r6, #56]	@ 0x38
34008b60:	1b49      	subs	r1, r1, r5
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008b62:	3a01      	subs	r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008b64:	0849      	lsrs	r1, r1, #1
34008b66:	434a      	muls	r2, r1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008b68:	fb04 0212 	mls	r2, r4, r2, r0
34008b6c:	e782      	b.n	34008a74 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008b6e:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34008b70:	0849      	lsrs	r1, r1, #1
34008b72:	3901      	subs	r1, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008b74:	fb0c 3311 	mls	r3, ip, r1, r3
34008b78:	e7b1      	b.n	34008ade <LTDC_RetrieveUserConfig.constprop.0+0xb6>
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34008b7a:	2702      	movs	r7, #2
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008b7c:	fb06 0001 	mla	r0, r6, r1, r0
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
34008b80:	f8cc 7000 	str.w	r7, [ip]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008b84:	f8d5 e034 	ldr.w	lr, [r5, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008b88:	e9d0 610e 	ldrd	r6, r1, [r0, #56]	@ 0x38
34008b8c:	1b89      	subs	r1, r1, r6
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008b8e:	e9d0 7610 	ldrd	r7, r6, [r0, #64]	@ 0x40
34008b92:	1bf7      	subs	r7, r6, r7
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34008b94:	f10e 0601 	add.w	r6, lr, #1
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008b98:	f240 1e0d 	movw	lr, #269	@ 0x10d
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008b9c:	fb01 fc04 	mul.w	ip, r1, r4
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
34008ba0:	fb07 661c 	mls	r6, r7, ip, r6
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34008ba4:	65c6      	str	r6, [r0, #92]	@ 0x5c
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34008ba6:	6c86      	ldr	r6, [r0, #72]	@ 0x48
34008ba8:	4576      	cmp	r6, lr
34008baa:	d019      	beq.n	34008be0 <LTDC_RetrieveUserConfig.constprop.0+0x1b8>
34008bac:	f240 2c0d 	movw	ip, #525	@ 0x20d
34008bb0:	4566      	cmp	r6, ip
34008bb2:	d18f      	bne.n	34008ad4 <LTDC_RetrieveUserConfig.constprop.0+0xac>
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008bb4:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008bb6:	087f      	lsrs	r7, r7, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008bb8:	4379      	muls	r1, r7
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008bba:	6c2e      	ldr	r6, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008bbc:	3601      	adds	r6, #1
34008bbe:	fb04 6111 	mls	r1, r4, r1, r6
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008bc2:	6011      	str	r1, [r2, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
34008bc4:	6c69      	ldr	r1, [r5, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34008bc6:	e9d0 520e 	ldrd	r5, r2, [r0, #56]	@ 0x38
34008bca:	1b52      	subs	r2, r2, r5
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34008bcc:	e9d0 0510 	ldrd	r0, r5, [r0, #64]	@ 0x40
34008bd0:	1a28      	subs	r0, r5, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008bd2:	0852      	lsrs	r2, r2, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008bd4:	0840      	lsrs	r0, r0, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
34008bd6:	4342      	muls	r2, r0
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008bd8:	3101      	adds	r1, #1
34008bda:	fb04 1212 	mls	r2, r4, r2, r1
34008bde:	e749      	b.n	34008a74 <LTDC_RetrieveUserConfig.constprop.0+0x4c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
34008be0:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
34008be2:	087f      	lsrs	r7, r7, #1
34008be4:	3301      	adds	r3, #1
34008be6:	fb0c 3317 	mls	r3, ip, r7, r3
34008bea:	e778      	b.n	34008ade <LTDC_RetrieveUserConfig.constprop.0+0xb6>

34008bec <HAL_LTDC_MspInit>:
}
34008bec:	4770      	bx	lr
	...

34008bf0 <HAL_LTDC_Init>:
{
34008bf0:	b538      	push	{r3, r4, r5, lr}
  if (hltdc == NULL)
34008bf2:	4604      	mov	r4, r0
34008bf4:	2800      	cmp	r0, #0
34008bf6:	f000 80c6 	beq.w	34008d86 <HAL_LTDC_Init+0x196>
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
34008bfa:	6803      	ldr	r3, [r0, #0]
34008bfc:	4a63      	ldr	r2, [pc, #396]	@ (34008d8c <HAL_LTDC_Init+0x19c>)
34008bfe:	4293      	cmp	r3, r2
34008c00:	d007      	beq.n	34008c12 <HAL_LTDC_Init+0x22>
34008c02:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34008c06:	4293      	cmp	r3, r2
34008c08:	d003      	beq.n	34008c12 <HAL_LTDC_Init+0x22>
34008c0a:	21f8      	movs	r1, #248	@ 0xf8
34008c0c:	4860      	ldr	r0, [pc, #384]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c0e:	f7f9 fc95 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
34008c12:	6963      	ldr	r3, [r4, #20]
34008c14:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c18:	d303      	bcc.n	34008c22 <HAL_LTDC_Init+0x32>
34008c1a:	21f9      	movs	r1, #249	@ 0xf9
34008c1c:	485c      	ldr	r0, [pc, #368]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c1e:	f7f9 fc8d 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
34008c22:	69a3      	ldr	r3, [r4, #24]
34008c24:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c28:	d303      	bcc.n	34008c32 <HAL_LTDC_Init+0x42>
34008c2a:	21fa      	movs	r1, #250	@ 0xfa
34008c2c:	4858      	ldr	r0, [pc, #352]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c2e:	f7f9 fc85 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
34008c32:	69e3      	ldr	r3, [r4, #28]
34008c34:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c38:	d303      	bcc.n	34008c42 <HAL_LTDC_Init+0x52>
34008c3a:	21fb      	movs	r1, #251	@ 0xfb
34008c3c:	4854      	ldr	r0, [pc, #336]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c3e:	f7f9 fc7d 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
34008c42:	6a23      	ldr	r3, [r4, #32]
34008c44:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c48:	d303      	bcc.n	34008c52 <HAL_LTDC_Init+0x62>
34008c4a:	21fc      	movs	r1, #252	@ 0xfc
34008c4c:	4850      	ldr	r0, [pc, #320]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c4e:	f7f9 fc75 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
34008c52:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34008c54:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c58:	d303      	bcc.n	34008c62 <HAL_LTDC_Init+0x72>
34008c5a:	21fd      	movs	r1, #253	@ 0xfd
34008c5c:	484c      	ldr	r0, [pc, #304]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c5e:	f7f9 fc6d 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
34008c62:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34008c64:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c68:	d303      	bcc.n	34008c72 <HAL_LTDC_Init+0x82>
34008c6a:	21fe      	movs	r1, #254	@ 0xfe
34008c6c:	4848      	ldr	r0, [pc, #288]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c6e:	f7f9 fc65 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
34008c72:	6b23      	ldr	r3, [r4, #48]	@ 0x30
34008c74:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c78:	d303      	bcc.n	34008c82 <HAL_LTDC_Init+0x92>
34008c7a:	21ff      	movs	r1, #255	@ 0xff
34008c7c:	4844      	ldr	r0, [pc, #272]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c7e:	f7f9 fc5d 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
34008c82:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34008c84:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008c88:	d304      	bcc.n	34008c94 <HAL_LTDC_Init+0xa4>
34008c8a:	f44f 7180 	mov.w	r1, #256	@ 0x100
34008c8e:	4840      	ldr	r0, [pc, #256]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008c90:	f7f9 fc54 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
34008c94:	6863      	ldr	r3, [r4, #4]
34008c96:	f033 4300 	bics.w	r3, r3, #2147483648	@ 0x80000000
34008c9a:	d004      	beq.n	34008ca6 <HAL_LTDC_Init+0xb6>
34008c9c:	f240 1101 	movw	r1, #257	@ 0x101
34008ca0:	483b      	ldr	r0, [pc, #236]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008ca2:	f7f9 fc4b 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
34008ca6:	68a3      	ldr	r3, [r4, #8]
34008ca8:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
34008cac:	d004      	beq.n	34008cb8 <HAL_LTDC_Init+0xc8>
34008cae:	f44f 7181 	mov.w	r1, #258	@ 0x102
34008cb2:	4837      	ldr	r0, [pc, #220]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008cb4:	f7f9 fc42 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
34008cb8:	68e3      	ldr	r3, [r4, #12]
34008cba:	f033 5300 	bics.w	r3, r3, #536870912	@ 0x20000000
34008cbe:	d004      	beq.n	34008cca <HAL_LTDC_Init+0xda>
34008cc0:	f240 1103 	movw	r1, #259	@ 0x103
34008cc4:	4832      	ldr	r0, [pc, #200]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008cc6:	f7f9 fc39 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
34008cca:	6923      	ldr	r3, [r4, #16]
34008ccc:	f033 5380 	bics.w	r3, r3, #268435456	@ 0x10000000
34008cd0:	d004      	beq.n	34008cdc <HAL_LTDC_Init+0xec>
34008cd2:	f44f 7182 	mov.w	r1, #260	@ 0x104
34008cd6:	482e      	ldr	r0, [pc, #184]	@ (34008d90 <HAL_LTDC_Init+0x1a0>)
34008cd8:	f7f9 fc30 	bl	3400253c <assert_failed>
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34008cdc:	f894 30a1 	ldrb.w	r3, [r4, #161]	@ 0xa1
34008ce0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
34008ce4:	b923      	cbnz	r3, 34008cf0 <HAL_LTDC_Init+0x100>
    HAL_LTDC_MspInit(hltdc);
34008ce6:	4620      	mov	r0, r4
    hltdc->Lock = HAL_UNLOCKED;
34008ce8:	f884 20a0 	strb.w	r2, [r4, #160]	@ 0xa0
    HAL_LTDC_MspInit(hltdc);
34008cec:	f7ff ff7e 	bl	34008bec <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008cf0:	2302      	movs	r3, #2
34008cf2:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34008cf6:	6823      	ldr	r3, [r4, #0]
34008cf8:	699a      	ldr	r2, [r3, #24]
34008cfa:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34008cfe:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34008d00:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
34008d04:	4302      	orrs	r2, r0
34008d06:	68e0      	ldr	r0, [r4, #12]
34008d08:	6999      	ldr	r1, [r3, #24]
34008d0a:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34008d0c:	6920      	ldr	r0, [r4, #16]
34008d0e:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34008d10:	430a      	orrs	r2, r1
34008d12:	619a      	str	r2, [r3, #24]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34008d14:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
34008d18:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008d1c:	609a      	str	r2, [r3, #8]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34008d1e:	e9d4 1207 	ldrd	r1, r2, [r4, #28]
34008d22:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008d26:	60da      	str	r2, [r3, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34008d28:	e9d4 1209 	ldrd	r1, r2, [r4, #36]	@ 0x24
34008d2c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008d30:	611a      	str	r2, [r3, #16]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34008d32:	e9d4 120b 	ldrd	r1, r2, [r4, #44]	@ 0x2c
34008d36:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008d3a:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34008d3c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34008d3e:	f894 0035 	ldrb.w	r0, [r4, #53]	@ 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34008d42:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34008d46:	f894 1036 	ldrb.w	r1, [r4, #54]	@ 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34008d4a:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34008d4c:	6add      	ldr	r5, [r3, #44]	@ 0x2c
34008d4e:	f894 2034 	ldrb.w	r2, [r4, #52]	@ 0x34
34008d52:	432a      	orrs	r2, r5
34008d54:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
34008d58:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
34008d5c:	62da      	str	r2, [r3, #44]	@ 0x2c
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34008d5e:	2204      	movs	r2, #4
34008d60:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34008d64:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34008d68:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34008d6a:	2000      	movs	r0, #0
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34008d6c:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34008d70:	665a      	str	r2, [r3, #100]	@ 0x64
  __HAL_LTDC_ENABLE(hltdc);
34008d72:	699a      	ldr	r2, [r3, #24]
34008d74:	f042 0201 	orr.w	r2, r2, #1
34008d78:	619a      	str	r2, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
34008d7a:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34008d7c:	f8c4 00a4 	str.w	r0, [r4, #164]	@ 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
34008d80:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
34008d84:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
34008d86:	2001      	movs	r0, #1
34008d88:	e7fc      	b.n	34008d84 <HAL_LTDC_Init+0x194>
34008d8a:	bf00      	nop
34008d8c:	58001000 	.word	0x58001000
34008d90:	3401c615 	.word	0x3401c615

34008d94 <HAL_LTDC_ConfigLayer>:
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008d94:	2a01      	cmp	r2, #1
{
34008d96:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34008d98:	4606      	mov	r6, r0
34008d9a:	460c      	mov	r4, r1
34008d9c:	4617      	mov	r7, r2
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008d9e:	d904      	bls.n	34008daa <HAL_LTDC_ConfigLayer+0x16>
34008da0:	f240 4104 	movw	r1, #1028	@ 0x404
34008da4:	484d      	ldr	r0, [pc, #308]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008da6:	f7f9 fbc9 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
34008daa:	6823      	ldr	r3, [r4, #0]
34008dac:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008db0:	d304      	bcc.n	34008dbc <HAL_LTDC_ConfigLayer+0x28>
34008db2:	f240 4105 	movw	r1, #1029	@ 0x405
34008db6:	4849      	ldr	r0, [pc, #292]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008db8:	f7f9 fbc0 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
34008dbc:	6863      	ldr	r3, [r4, #4]
34008dbe:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008dc2:	d304      	bcc.n	34008dce <HAL_LTDC_ConfigLayer+0x3a>
34008dc4:	f240 4106 	movw	r1, #1030	@ 0x406
34008dc8:	4844      	ldr	r0, [pc, #272]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008dca:	f7f9 fbb7 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
34008dce:	68a3      	ldr	r3, [r4, #8]
34008dd0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008dd4:	d304      	bcc.n	34008de0 <HAL_LTDC_ConfigLayer+0x4c>
34008dd6:	f240 4107 	movw	r1, #1031	@ 0x407
34008dda:	4840      	ldr	r0, [pc, #256]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008ddc:	f7f9 fbae 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
34008de0:	68e3      	ldr	r3, [r4, #12]
34008de2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008de6:	d304      	bcc.n	34008df2 <HAL_LTDC_ConfigLayer+0x5e>
34008de8:	f44f 6181 	mov.w	r1, #1032	@ 0x408
34008dec:	483b      	ldr	r0, [pc, #236]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008dee:	f7f9 fba5 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
34008df2:	6923      	ldr	r3, [r4, #16]
34008df4:	2b0b      	cmp	r3, #11
34008df6:	d904      	bls.n	34008e02 <HAL_LTDC_ConfigLayer+0x6e>
34008df8:	f240 4109 	movw	r1, #1033	@ 0x409
34008dfc:	4837      	ldr	r0, [pc, #220]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008dfe:	f7f9 fb9d 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha));
34008e02:	6963      	ldr	r3, [r4, #20]
34008e04:	2bff      	cmp	r3, #255	@ 0xff
34008e06:	d904      	bls.n	34008e12 <HAL_LTDC_ConfigLayer+0x7e>
34008e08:	f240 410a 	movw	r1, #1034	@ 0x40a
34008e0c:	4833      	ldr	r0, [pc, #204]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008e0e:	f7f9 fb95 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
34008e12:	69a3      	ldr	r3, [r4, #24]
34008e14:	2bff      	cmp	r3, #255	@ 0xff
34008e16:	d904      	bls.n	34008e22 <HAL_LTDC_ConfigLayer+0x8e>
34008e18:	f240 410b 	movw	r1, #1035	@ 0x40b
34008e1c:	482f      	ldr	r0, [pc, #188]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008e1e:	f7f9 fb8d 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
34008e22:	69e3      	ldr	r3, [r4, #28]
34008e24:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
34008e28:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34008e2c:	d004      	beq.n	34008e38 <HAL_LTDC_ConfigLayer+0xa4>
34008e2e:	f240 410c 	movw	r1, #1036	@ 0x40c
34008e32:	482a      	ldr	r0, [pc, #168]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008e34:	f7f9 fb82 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
34008e38:	6a23      	ldr	r3, [r4, #32]
34008e3a:	f023 0302 	bic.w	r3, r3, #2
34008e3e:	2b05      	cmp	r3, #5
34008e40:	d004      	beq.n	34008e4c <HAL_LTDC_ConfigLayer+0xb8>
34008e42:	f240 410d 	movw	r1, #1037	@ 0x40d
34008e46:	4825      	ldr	r0, [pc, #148]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008e48:	f7f9 fb78 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
34008e4c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34008e4e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34008e52:	d304      	bcc.n	34008e5e <HAL_LTDC_ConfigLayer+0xca>
34008e54:	f240 410e 	movw	r1, #1038	@ 0x40e
34008e58:	4820      	ldr	r0, [pc, #128]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008e5a:	f7f9 fb6f 	bl	3400253c <assert_failed>
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
34008e5e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34008e60:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008e64:	d304      	bcc.n	34008e70 <HAL_LTDC_ConfigLayer+0xdc>
34008e66:	f240 410f 	movw	r1, #1039	@ 0x40f
34008e6a:	481c      	ldr	r0, [pc, #112]	@ (34008edc <HAL_LTDC_ConfigLayer+0x148>)
34008e6c:	f7f9 fb66 	bl	3400253c <assert_failed>
  __HAL_LOCK(hltdc);
34008e70:	f896 30a0 	ldrb.w	r3, [r6, #160]	@ 0xa0
34008e74:	2002      	movs	r0, #2
34008e76:	2b01      	cmp	r3, #1
34008e78:	d02d      	beq.n	34008ed6 <HAL_LTDC_ConfigLayer+0x142>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34008e7a:	2534      	movs	r5, #52	@ 0x34
34008e7c:	fb05 6507 	mla	r5, r5, r7, r6
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008e80:	f886 00a1 	strb.w	r0, [r6, #161]	@ 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34008e84:	3538      	adds	r5, #56	@ 0x38
34008e86:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34008e88:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34008e8a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34008e8c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34008e8e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34008e90:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34008e92:	6823      	ldr	r3, [r4, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34008e94:	4639      	mov	r1, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34008e96:	602b      	str	r3, [r5, #0]
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34008e98:	4630      	mov	r0, r6
34008e9a:	f7ff fd83 	bl	340089a4 <LTDC_SetPredefFormat>
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34008e9e:	4639      	mov	r1, r7
34008ea0:	4630      	mov	r0, r6
34008ea2:	f7ff fd55 	bl	34008950 <LTDC_SetCompositionConfig>
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008ea6:	2200      	movs	r2, #0
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34008ea8:	6834      	ldr	r4, [r6, #0]
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008eaa:	4630      	mov	r0, r6
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34008eac:	f504 7480 	add.w	r4, r4, #256	@ 0x100
34008eb0:	eb04 2407 	add.w	r4, r4, r7, lsl #8
34008eb4:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008eb6:	4611      	mov	r1, r2
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34008eb8:	f023 0308 	bic.w	r3, r3, #8
34008ebc:	6323      	str	r3, [r4, #48]	@ 0x30
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34008ebe:	2303      	movs	r3, #3
34008ec0:	9700      	str	r7, [sp, #0]
34008ec2:	f7ff fc17 	bl	340086f4 <LTDC_SetConfig>
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34008ec6:	2305      	movs	r3, #5
  __HAL_UNLOCK(hltdc);
34008ec8:	2000      	movs	r0, #0
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34008eca:	60a3      	str	r3, [r4, #8]
  hltdc->State  = HAL_LTDC_STATE_READY;
34008ecc:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34008ece:	f886 00a0 	strb.w	r0, [r6, #160]	@ 0xa0
  hltdc->State  = HAL_LTDC_STATE_READY;
34008ed2:	f886 30a1 	strb.w	r3, [r6, #161]	@ 0xa1
}
34008ed6:	b003      	add	sp, #12
34008ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
34008eda:	bf00      	nop
34008edc:	3401c615 	.word	0x3401c615

34008ee0 <HAL_LTDC_ReloadLayer>:
  assert_param(IS_LTDC_RELOAD(ReloadType));
34008ee0:	1e4b      	subs	r3, r1, #1
34008ee2:	2b01      	cmp	r3, #1
{
34008ee4:	b570      	push	{r4, r5, r6, lr}
34008ee6:	4604      	mov	r4, r0
34008ee8:	460d      	mov	r5, r1
34008eea:	4616      	mov	r6, r2
  assert_param(IS_LTDC_RELOAD(ReloadType));
34008eec:	d904      	bls.n	34008ef8 <HAL_LTDC_ReloadLayer+0x18>
34008eee:	f640 0119 	movw	r1, #2073	@ 0x819
34008ef2:	480e      	ldr	r0, [pc, #56]	@ (34008f2c <HAL_LTDC_ReloadLayer+0x4c>)
34008ef4:	f7f9 fb22 	bl	3400253c <assert_failed>
  __HAL_LOCK(hltdc);
34008ef8:	f894 30a0 	ldrb.w	r3, [r4, #160]	@ 0xa0
34008efc:	2002      	movs	r0, #2
34008efe:	2b01      	cmp	r3, #1
34008f00:	d012      	beq.n	34008f28 <HAL_LTDC_ReloadLayer+0x48>
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34008f02:	6823      	ldr	r3, [r4, #0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008f04:	f884 00a1 	strb.w	r0, [r4, #161]	@ 0xa1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34008f08:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
34008f0a:	3601      	adds	r6, #1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
34008f0c:	f042 0208 	orr.w	r2, r2, #8
34008f10:	665a      	str	r2, [r3, #100]	@ 0x64
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
34008f12:	f045 0504 	orr.w	r5, r5, #4
34008f16:	eb03 2306 	add.w	r3, r3, r6, lsl #8
34008f1a:	609d      	str	r5, [r3, #8]
  __HAL_UNLOCK(hltdc);
34008f1c:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
34008f1e:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34008f20:	f884 00a0 	strb.w	r0, [r4, #160]	@ 0xa0
  hltdc->State = HAL_LTDC_STATE_READY;
34008f24:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
}
34008f28:	bd70      	pop	{r4, r5, r6, pc}
34008f2a:	bf00      	nop
34008f2c:	3401c615 	.word	0x3401c615

34008f30 <HAL_LTDC_SetAddress_NoReload>:
  uint32_t aux0Addr = 0U;
34008f30:	2300      	movs	r3, #0
{
34008f32:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008f34:	2a01      	cmp	r2, #1
{
34008f36:	b086      	sub	sp, #24
34008f38:	4604      	mov	r4, r0
34008f3a:	460e      	mov	r6, r1
34008f3c:	4615      	mov	r5, r2
  uint32_t aux1Addr = 0U;
34008f3e:	e9cd 3303 	strd	r3, r3, [sp, #12]
  uint32_t mirror = 0U;
34008f42:	9305      	str	r3, [sp, #20]
  assert_param(IS_LTDC_LAYER(LayerIdx));
34008f44:	d904      	bls.n	34008f50 <HAL_LTDC_SetAddress_NoReload+0x20>
34008f46:	f640 1165 	movw	r1, #2405	@ 0x965
34008f4a:	4812      	ldr	r0, [pc, #72]	@ (34008f94 <HAL_LTDC_SetAddress_NoReload+0x64>)
34008f4c:	f7f9 faf6 	bl	3400253c <assert_failed>
  __HAL_LOCK(hltdc);
34008f50:	f894 30a0 	ldrb.w	r3, [r4, #160]	@ 0xa0
34008f54:	2002      	movs	r0, #2
34008f56:	2b01      	cmp	r3, #1
34008f58:	d019      	beq.n	34008f8e <HAL_LTDC_SetAddress_NoReload+0x5e>
  hltdc->State = HAL_LTDC_STATE_BUSY;
34008f5a:	f884 00a1 	strb.w	r0, [r4, #161]	@ 0xa1
  LTDC_RetrieveUserConfig(hltdc, &mirror, &aux0Addr, &aux1Addr, LayerIdx);
34008f5e:	ab04      	add	r3, sp, #16
34008f60:	4620      	mov	r0, r4
34008f62:	aa03      	add	r2, sp, #12
34008f64:	a905      	add	r1, sp, #20
34008f66:	9500      	str	r5, [sp, #0]
34008f68:	f7ff fd5e 	bl	34008a28 <LTDC_RetrieveUserConfig.constprop.0>
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34008f6c:	2334      	movs	r3, #52	@ 0x34
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34008f6e:	2200      	movs	r2, #0
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34008f70:	fb03 4305 	mla	r3, r3, r5, r4
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34008f74:	4620      	mov	r0, r4
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34008f76:	65de      	str	r6, [r3, #92]	@ 0x5c
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
34008f78:	4611      	mov	r1, r2
34008f7a:	9b05      	ldr	r3, [sp, #20]
34008f7c:	9500      	str	r5, [sp, #0]
34008f7e:	f7ff fbb9 	bl	340086f4 <LTDC_SetConfig>
  hltdc->State = HAL_LTDC_STATE_READY;
34008f82:	2301      	movs	r3, #1
  __HAL_UNLOCK(hltdc);
34008f84:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
34008f86:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
34008f8a:	f884 00a0 	strb.w	r0, [r4, #160]	@ 0xa0
}
34008f8e:	b006      	add	sp, #24
34008f90:	bd70      	pop	{r4, r5, r6, pc}
34008f92:	bf00      	nop
34008f94:	3401c615 	.word	0x3401c615

34008f98 <HAL_PWREx_ConfigVddIORange>:
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
34008f98:	2804      	cmp	r0, #4
{
34008f9a:	b538      	push	{r3, r4, r5, lr}
34008f9c:	4605      	mov	r5, r0
34008f9e:	460c      	mov	r4, r1
  assert_param(IS_PWR_VDDIO(VddIOPort));
34008fa0:	d912      	bls.n	34008fc8 <HAL_PWREx_ConfigVddIORange+0x30>
34008fa2:	f240 316a 	movw	r1, #874	@ 0x36a
34008fa6:	481d      	ldr	r0, [pc, #116]	@ (3400901c <HAL_PWREx_ConfigVddIORange+0x84>)
34008fa8:	f7f9 fac8 	bl	3400253c <assert_failed>
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
34008fac:	2c01      	cmp	r4, #1
34008fae:	d915      	bls.n	34008fdc <HAL_PWREx_ConfigVddIORange+0x44>
34008fb0:	f240 316b 	movw	r1, #875	@ 0x36b
34008fb4:	4819      	ldr	r0, [pc, #100]	@ (3400901c <HAL_PWREx_ConfigVddIORange+0x84>)
34008fb6:	f7f9 fac1 	bl	3400253c <assert_failed>

  switch (VddIOPort)
34008fba:	2d04      	cmp	r5, #4
34008fbc:	d80e      	bhi.n	34008fdc <HAL_PWREx_ConfigVddIORange+0x44>
34008fbe:	e8df f005 	tbb	[pc, r5]
34008fc2:	0e06      	.short	0x0e06
34008fc4:	1c15      	.short	0x1c15
34008fc6:	24          	.byte	0x24
34008fc7:	00          	.byte	0x00
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));
34008fc8:	2901      	cmp	r1, #1
34008fca:	d9f6      	bls.n	34008fba <HAL_PWREx_ConfigVddIORange+0x22>
34008fcc:	e7f0      	b.n	34008fb0 <HAL_PWREx_ConfigVddIORange+0x18>
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
34008fce:	4a14      	ldr	r2, [pc, #80]	@ (34009020 <HAL_PWREx_ConfigVddIORange+0x88>)
34008fd0:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008fd2:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34008fd6:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
      break;

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
34008fda:	63d3      	str	r3, [r2, #60]	@ 0x3c
      break;

    default:
      break;
  }
}
34008fdc:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
34008fde:	4a10      	ldr	r2, [pc, #64]	@ (34009020 <HAL_PWREx_ConfigVddIORange+0x88>)
34008fe0:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008fe2:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
34008fe6:	ea43 6344 	orr.w	r3, r3, r4, lsl #25
34008fea:	e7f6      	b.n	34008fda <HAL_PWREx_ConfigVddIORange+0x42>
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
34008fec:	4a0c      	ldr	r2, [pc, #48]	@ (34009020 <HAL_PWREx_ConfigVddIORange+0x88>)
34008fee:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34008ff0:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
34008ff4:	ea43 6384 	orr.w	r3, r3, r4, lsl #26
34008ff8:	e7ef      	b.n	34008fda <HAL_PWREx_ConfigVddIORange+0x42>
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
34008ffa:	4a09      	ldr	r2, [pc, #36]	@ (34009020 <HAL_PWREx_ConfigVddIORange+0x88>)
34008ffc:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34008ffe:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34009002:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34009006:	6353      	str	r3, [r2, #52]	@ 0x34
      break;
34009008:	e7e8      	b.n	34008fdc <HAL_PWREx_ConfigVddIORange+0x44>
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3400900a:	4a05      	ldr	r2, [pc, #20]	@ (34009020 <HAL_PWREx_ConfigVddIORange+0x88>)
3400900c:	6b93      	ldr	r3, [r2, #56]	@ 0x38
3400900e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34009012:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
34009016:	6393      	str	r3, [r2, #56]	@ 0x38
}
34009018:	e7e0      	b.n	34008fdc <HAL_PWREx_ConfigVddIORange+0x44>
3400901a:	bf00      	nop
3400901c:	3401c684 	.word	0x3401c684
34009020:	56024800 	.word	0x56024800

34009024 <HAL_PWREx_EnableVddIO2>:
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34009024:	4a02      	ldr	r2, [pc, #8]	@ (34009030 <HAL_PWREx_EnableVddIO2+0xc>)
34009026:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34009028:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400902c:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400902e:	4770      	bx	lr
34009030:	56024800 	.word	0x56024800

34009034 <HAL_PWREx_EnableVddIO3>:
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34009034:	4a02      	ldr	r2, [pc, #8]	@ (34009040 <HAL_PWREx_EnableVddIO3+0xc>)
34009036:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
34009038:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400903c:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400903e:	4770      	bx	lr
34009040:	56024800 	.word	0x56024800

34009044 <HAL_PWREx_EnableVddIO4>:
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
34009044:	4a02      	ldr	r2, [pc, #8]	@ (34009050 <HAL_PWREx_EnableVddIO4+0xc>)
34009046:	6b53      	ldr	r3, [r2, #52]	@ 0x34
34009048:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400904c:	6353      	str	r3, [r2, #52]	@ 0x34
}
3400904e:	4770      	bx	lr
34009050:	56024800 	.word	0x56024800

34009054 <HAL_RAMCFG_EnableAXISRAM>:
  * @retval None.
  */
void HAL_RAMCFG_EnableAXISRAM(const RAMCFG_HandleTypeDef *hramcfg)
{
  /* Check the parameters */
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
34009054:	6803      	ldr	r3, [r0, #0]
34009056:	4a1c      	ldr	r2, [pc, #112]	@ (340090c8 <HAL_RAMCFG_EnableAXISRAM+0x74>)
{
34009058:	b510      	push	{r4, lr}
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
3400905a:	4293      	cmp	r3, r2
{
3400905c:	4604      	mov	r4, r0
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));
3400905e:	d02c      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
34009060:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009064:	4293      	cmp	r3, r2
34009066:	d028      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
34009068:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
3400906c:	3280      	adds	r2, #128	@ 0x80
3400906e:	4293      	cmp	r3, r2
34009070:	d023      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
34009072:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009076:	4293      	cmp	r3, r2
34009078:	d01f      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
3400907a:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
3400907e:	3280      	adds	r2, #128	@ 0x80
34009080:	4293      	cmp	r3, r2
34009082:	d01a      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
34009084:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
34009088:	4293      	cmp	r3, r2
3400908a:	d016      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
3400908c:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
34009090:	3280      	adds	r2, #128	@ 0x80
34009092:	4293      	cmp	r3, r2
34009094:	d011      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
34009096:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400909a:	4293      	cmp	r3, r2
3400909c:	d00d      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
3400909e:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
340090a2:	3280      	adds	r2, #128	@ 0x80
340090a4:	4293      	cmp	r3, r2
340090a6:	d008      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
340090a8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
340090ac:	4293      	cmp	r3, r2
340090ae:	d004      	beq.n	340090ba <HAL_RAMCFG_EnableAXISRAM+0x66>
340090b0:	f240 4107 	movw	r1, #1031	@ 0x407
340090b4:	4805      	ldr	r0, [pc, #20]	@ (340090cc <HAL_RAMCFG_EnableAXISRAM+0x78>)
340090b6:	f7f9 fa41 	bl	3400253c <assert_failed>

  /* AXISRAMi power on */
  CLEAR_BIT(hramcfg->Instance->CR, RAMCFG_AXISRAM_POWERDOWN);
340090ba:	6822      	ldr	r2, [r4, #0]
340090bc:	6813      	ldr	r3, [r2, #0]
340090be:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
340090c2:	6013      	str	r3, [r2, #0]
}
340090c4:	bd10      	pop	{r4, pc}
340090c6:	bf00      	nop
340090c8:	52023080 	.word	0x52023080
340090cc:	3401c6f5 	.word	0x3401c6f5

340090d0 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
340090d0:	4b02      	ldr	r3, [pc, #8]	@ (340090dc <LL_RCC_HSI_IsReady+0xc>)
340090d2:	6858      	ldr	r0, [r3, #4]
}
340090d4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
340090d8:	4770      	bx	lr
340090da:	bf00      	nop
340090dc:	56028000 	.word	0x56028000

340090e0 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
340090e0:	4b02      	ldr	r3, [pc, #8]	@ (340090ec <LL_RCC_MSI_IsReady+0xc>)
340090e2:	6858      	ldr	r0, [r3, #4]
}
340090e4:	f3c0 0080 	ubfx	r0, r0, #2, #1
340090e8:	4770      	bx	lr
340090ea:	bf00      	nop
340090ec:	56028000 	.word	0x56028000

340090f0 <LL_RCC_PLL1_IsReady>:
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
340090f0:	4b02      	ldr	r3, [pc, #8]	@ (340090fc <LL_RCC_PLL1_IsReady+0xc>)
340090f2:	6858      	ldr	r0, [r3, #4]
}
340090f4:	f3c0 2000 	ubfx	r0, r0, #8, #1
340090f8:	4770      	bx	lr
340090fa:	bf00      	nop
340090fc:	56028000 	.word	0x56028000

34009100 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
34009100:	b570      	push	{r4, r5, r6, lr}
  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
34009102:	690b      	ldr	r3, [r1, #16]
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009104:	4d1b      	ldr	r5, [pc, #108]	@ (34009174 <RCC_PLL_IsNewConfig+0x74>)
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
34009106:	688e      	ldr	r6, [r1, #8]
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
34009108:	0104      	lsls	r4, r0, #4
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400910a:	5962      	ldr	r2, [r4, r5]
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3400910c:	021b      	lsls	r3, r3, #8
3400910e:	ea43 5306 	orr.w	r3, r3, r6, lsl #20
34009112:	684e      	ldr	r6, [r1, #4]
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
34009114:	f022 420c 	bic.w	r2, r2, #2348810240	@ 0x8c000000
34009118:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3400911c:	4333      	orrs	r3, r6
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400911e:	429a      	cmp	r2, r3
34009120:	d126      	bne.n	34009170 <RCC_PLL_IsNewConfig+0x70>
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34009122:	4b15      	ldr	r3, [pc, #84]	@ (34009178 <RCC_PLL_IsNewConfig+0x78>)
  {
    ret = 1U; /* New PLL configuration */
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
34009124:	68ca      	ldr	r2, [r1, #12]
34009126:	58e3      	ldr	r3, [r4, r3]
34009128:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400912c:	4293      	cmp	r3, r2
3400912e:	d11f      	bne.n	34009170 <RCC_PLL_IsNewConfig+0x70>
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
34009130:	4b12      	ldr	r3, [pc, #72]	@ (3400917c <RCC_PLL_IsNewConfig+0x7c>)
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
  {
    ret = 1U; /* New PLL configuration */
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
34009132:	58e2      	ldr	r2, [r4, r3]
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
34009134:	e9d1 6305 	ldrd	r6, r3, [r1, #20]
34009138:	061b      	lsls	r3, r3, #24
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400913a:	f002 527c 	and.w	r2, r2, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3400913e:	ea43 63c6 	orr.w	r3, r3, r6, lsl #27
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
34009142:	429a      	cmp	r2, r3
34009144:	d114      	bne.n	34009170 <RCC_PLL_IsNewConfig+0x70>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009146:	4b0e      	ldr	r3, [pc, #56]	@ (34009180 <RCC_PLL_IsNewConfig+0x80>)
34009148:	685a      	ldr	r2, [r3, #4]
3400914a:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400914e:	fa03 f000 	lsl.w	r0, r3, r0
34009152:	4390      	bics	r0, r2
34009154:	d00a      	beq.n	3400916c <RCC_PLL_IsNewConfig+0x6c>
    {
      pllState = RCC_PLL_ON;
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
34009156:	5963      	ldr	r3, [r4, r5]
      {
        pllState = RCC_PLL_BYPASS;
34009158:	f013 6f00 	tst.w	r3, #134217728	@ 0x8000000
3400915c:	bf0c      	ite	eq
3400915e:	2301      	moveq	r3, #1
34009160:	2303      	movne	r3, #3
        pllState = RCC_PLL_OFF;
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
34009162:	6808      	ldr	r0, [r1, #0]
34009164:	1ac0      	subs	r0, r0, r3
34009166:	bf18      	it	ne
34009168:	2001      	movne	r0, #1
      ret = 1U; /* New PLL configuration */
    }
  }

  return ret;
}
3400916a:	bd70      	pop	{r4, r5, r6, pc}
      pllState = RCC_PLL_ON;
3400916c:	2302      	movs	r3, #2
3400916e:	e7f8      	b.n	34009162 <RCC_PLL_IsNewConfig+0x62>
    ret = 1U; /* New PLL configuration */
34009170:	2001      	movs	r0, #1
  return ret;
34009172:	e7fa      	b.n	3400916a <RCC_PLL_IsNewConfig+0x6a>
34009174:	56028080 	.word	0x56028080
34009178:	56028084 	.word	0x56028084
3400917c:	56028088 	.word	0x56028088
34009180:	56028000 	.word	0x56028000

34009184 <RCC_PLL_Enable>:
{
34009184:	b570      	push	{r4, r5, r6, lr}
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
34009186:	f44f 7480 	mov.w	r4, #256	@ 0x100
3400918a:	4e09      	ldr	r6, [pc, #36]	@ (340091b0 <RCC_PLL_Enable+0x2c>)
3400918c:	4084      	lsls	r4, r0
3400918e:	f8c6 4800 	str.w	r4, [r6, #2048]	@ 0x800
  tickstart = HAL_GetTick();
34009192:	f7fb fbad 	bl	340048f0 <HAL_GetTick>
34009196:	4605      	mov	r5, r0
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
34009198:	6873      	ldr	r3, [r6, #4]
3400919a:	421c      	tst	r4, r3
3400919c:	d001      	beq.n	340091a2 <RCC_PLL_Enable+0x1e>
  return ret;
3400919e:	2000      	movs	r0, #0
}
340091a0:	bd70      	pop	{r4, r5, r6, pc}
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340091a2:	f7fb fba5 	bl	340048f0 <HAL_GetTick>
340091a6:	1b40      	subs	r0, r0, r5
340091a8:	2801      	cmp	r0, #1
340091aa:	d9f5      	bls.n	34009198 <RCC_PLL_Enable+0x14>
      return HAL_TIMEOUT;
340091ac:	2003      	movs	r0, #3
340091ae:	e7f7      	b.n	340091a0 <RCC_PLL_Enable+0x1c>
340091b0:	56028000 	.word	0x56028000

340091b4 <RCC_PLL_Config>:
  if (pPLLInit->PLLState == RCC_PLL_ON)
340091b4:	680b      	ldr	r3, [r1, #0]
{
340091b6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (pPLLInit->PLLState == RCC_PLL_ON)
340091ba:	2b02      	cmp	r3, #2
{
340091bc:	4681      	mov	r9, r0
340091be:	460d      	mov	r5, r1
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
340091c0:	4f83      	ldr	r7, [pc, #524]	@ (340093d0 <RCC_PLL_Config+0x21c>)
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
340091c2:	4e84      	ldr	r6, [pc, #528]	@ (340093d4 <RCC_PLL_Config+0x220>)
  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
340091c4:	ea4f 1400 	mov.w	r4, r0, lsl #4
  if (pPLLInit->PLLState == RCC_PLL_ON)
340091c8:	f040 8099 	bne.w	340092fe <RCC_PLL_Config+0x14a>
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
340091cc:	684b      	ldr	r3, [r1, #4]
340091ce:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
340091d2:	d004      	beq.n	340091de <RCC_PLL_Config+0x2a>
340091d4:	f44f 61ff 	mov.w	r1, #2040	@ 0x7f8
340091d8:	487f      	ldr	r0, [pc, #508]	@ (340093d8 <RCC_PLL_Config+0x224>)
340091da:	f7f9 f9af 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_PLLFRACN_VALUE(pPLLInit->PLLFractional));
340091de:	68eb      	ldr	r3, [r5, #12]
340091e0:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340091e4:	d304      	bcc.n	340091f0 <RCC_PLL_Config+0x3c>
340091e6:	f240 71f9 	movw	r1, #2041	@ 0x7f9
340091ea:	487b      	ldr	r0, [pc, #492]	@ (340093d8 <RCC_PLL_Config+0x224>)
340091ec:	f7f9 f9a6 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_PLLM_VALUE(pPLLInit->PLLM));
340091f0:	68ab      	ldr	r3, [r5, #8]
340091f2:	3b01      	subs	r3, #1
340091f4:	2b3e      	cmp	r3, #62	@ 0x3e
340091f6:	d904      	bls.n	34009202 <RCC_PLL_Config+0x4e>
340091f8:	f240 71fa 	movw	r1, #2042	@ 0x7fa
340091fc:	4876      	ldr	r0, [pc, #472]	@ (340093d8 <RCC_PLL_Config+0x224>)
340091fe:	f7f9 f99d 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
34009202:	f640 12ba 	movw	r2, #2490	@ 0x9ba
34009206:	692b      	ldr	r3, [r5, #16]
34009208:	3b0a      	subs	r3, #10
3400920a:	4293      	cmp	r3, r2
3400920c:	d904      	bls.n	34009218 <RCC_PLL_Config+0x64>
3400920e:	f240 71fb 	movw	r1, #2043	@ 0x7fb
34009212:	4871      	ldr	r0, [pc, #452]	@ (340093d8 <RCC_PLL_Config+0x224>)
34009214:	f7f9 f992 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
34009218:	696b      	ldr	r3, [r5, #20]
3400921a:	3b01      	subs	r3, #1
3400921c:	2b06      	cmp	r3, #6
3400921e:	d904      	bls.n	3400922a <RCC_PLL_Config+0x76>
34009220:	f240 71fc 	movw	r1, #2044	@ 0x7fc
34009224:	486c      	ldr	r0, [pc, #432]	@ (340093d8 <RCC_PLL_Config+0x224>)
34009226:	f7f9 f989 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));
3400922a:	69ab      	ldr	r3, [r5, #24]
3400922c:	3b01      	subs	r3, #1
3400922e:	2b06      	cmp	r3, #6
34009230:	d904      	bls.n	3400923c <RCC_PLL_Config+0x88>
34009232:	f240 71fd 	movw	r1, #2045	@ 0x7fd
34009236:	4868      	ldr	r0, [pc, #416]	@ (340093d8 <RCC_PLL_Config+0x224>)
34009238:	f7f9 f980 	bl	3400253c <assert_failed>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400923c:	f44f 7880 	mov.w	r8, #256	@ 0x100
34009240:	4b66      	ldr	r3, [pc, #408]	@ (340093dc <RCC_PLL_Config+0x228>)
34009242:	fa08 f809 	lsl.w	r8, r8, r9
34009246:	f8c3 8000 	str.w	r8, [r3]
    tickstart = HAL_GetTick();
3400924a:	f7fb fb51 	bl	340048f0 <HAL_GetTick>
3400924e:	4681      	mov	r9, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009250:	f8df a194 	ldr.w	sl, [pc, #404]	@ 340093e8 <RCC_PLL_Config+0x234>
34009254:	f8da 3004 	ldr.w	r3, [sl, #4]
34009258:	ea38 0303 	bics.w	r3, r8, r3
3400925c:	d040      	beq.n	340092e0 <RCC_PLL_Config+0x12c>
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3400925e:	59a3      	ldr	r3, [r4, r6]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
34009260:	495f      	ldr	r1, [pc, #380]	@ (340093e0 <RCC_PLL_Config+0x22c>)
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
34009262:	f043 0304 	orr.w	r3, r3, #4
34009266:	51a3      	str	r3, [r4, r6]
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
34009268:	59e3      	ldr	r3, [r4, r7]
3400926a:	f023 6300 	bic.w	r3, r3, #134217728	@ 0x8000000
3400926e:	51e3      	str	r3, [r4, r7]
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
34009270:	692b      	ldr	r3, [r5, #16]
34009272:	68aa      	ldr	r2, [r5, #8]
34009274:	021b      	lsls	r3, r3, #8
34009276:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
3400927a:	686a      	ldr	r2, [r5, #4]
3400927c:	59e0      	ldr	r0, [r4, r7]
3400927e:	4313      	orrs	r3, r2
34009280:	4a58      	ldr	r2, [pc, #352]	@ (340093e4 <RCC_PLL_Config+0x230>)
34009282:	4002      	ands	r2, r0
34009284:	4313      	orrs	r3, r2
34009286:	51e3      	str	r3, [r4, r7]
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
34009288:	59a2      	ldr	r2, [r4, r6]
3400928a:	e9d5 0305 	ldrd	r0, r3, [r5, #20]
3400928e:	061b      	lsls	r3, r3, #24
34009290:	f022 527c 	bic.w	r2, r2, #1056964608	@ 0x3f000000
34009294:	ea43 63c0 	orr.w	r3, r3, r0, lsl #27
34009298:	4313      	orrs	r3, r2
3400929a:	51a3      	str	r3, [r4, r6]
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3400929c:	5863      	ldr	r3, [r4, r1]
3400929e:	68ea      	ldr	r2, [r5, #12]
340092a0:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
340092a4:	4313      	orrs	r3, r2
340092a6:	5063      	str	r3, [r4, r1]
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
340092a8:	59a3      	ldr	r3, [r4, r6]
340092aa:	f023 0308 	bic.w	r3, r3, #8
340092ae:	51a3      	str	r3, [r4, r6]
    if (pPLLInit->PLLFractional != 0U)
340092b0:	68eb      	ldr	r3, [r5, #12]
340092b2:	b11b      	cbz	r3, 340092bc <RCC_PLL_Config+0x108>
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
340092b4:	59a3      	ldr	r3, [r4, r6]
340092b6:	f043 030a 	orr.w	r3, r3, #10
340092ba:	51a3      	str	r3, [r4, r6]
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
340092bc:	59a3      	ldr	r3, [r4, r6]
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
340092be:	4d4a      	ldr	r5, [pc, #296]	@ (340093e8 <RCC_PLL_Config+0x234>)
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
340092c0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
340092c4:	f043 0301 	orr.w	r3, r3, #1
340092c8:	51a3      	str	r3, [r4, r6]
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
340092ca:	f8c5 8800 	str.w	r8, [r5, #2048]	@ 0x800
    tickstart = HAL_GetTick();
340092ce:	f7fb fb0f 	bl	340048f0 <HAL_GetTick>
340092d2:	4604      	mov	r4, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
340092d4:	686b      	ldr	r3, [r5, #4]
340092d6:	ea18 0f03 	tst.w	r8, r3
340092da:	d00a      	beq.n	340092f2 <RCC_PLL_Config+0x13e>
  HAL_StatusTypeDef ret = HAL_OK;
340092dc:	2000      	movs	r0, #0
340092de:	e006      	b.n	340092ee <RCC_PLL_Config+0x13a>
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340092e0:	f7fb fb06 	bl	340048f0 <HAL_GetTick>
340092e4:	eba0 0009 	sub.w	r0, r0, r9
340092e8:	2801      	cmp	r0, #1
340092ea:	d9b3      	bls.n	34009254 <RCC_PLL_Config+0xa0>
        return HAL_TIMEOUT;
340092ec:	2003      	movs	r0, #3
}
340092ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340092f2:	f7fb fafd 	bl	340048f0 <HAL_GetTick>
340092f6:	1b00      	subs	r0, r0, r4
340092f8:	2801      	cmp	r0, #1
340092fa:	d9eb      	bls.n	340092d4 <RCC_PLL_Config+0x120>
340092fc:	e7f6      	b.n	340092ec <RCC_PLL_Config+0x138>
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
340092fe:	2b03      	cmp	r3, #3
34009300:	d146      	bne.n	34009390 <RCC_PLL_Config+0x1dc>
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));
34009302:	684b      	ldr	r3, [r1, #4]
34009304:	b37b      	cbz	r3, 34009366 <RCC_PLL_Config+0x1b2>
34009306:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400930a:	d032      	beq.n	34009372 <RCC_PLL_Config+0x1be>
3400930c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009310:	d032      	beq.n	34009378 <RCC_PLL_Config+0x1c4>
34009312:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009316:	d00d      	beq.n	34009334 <RCC_PLL_Config+0x180>
34009318:	f640 013d 	movw	r1, #2109	@ 0x83d
3400931c:	482e      	ldr	r0, [pc, #184]	@ (340093d8 <RCC_PLL_Config+0x224>)
3400931e:	f7f9 f90d 	bl	3400253c <assert_failed>
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
34009322:	686b      	ldr	r3, [r5, #4]
{
  uint32_t ret = 1U;

  /* No assert since done in calling function */

  switch (PLLSource)
34009324:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009328:	d026      	beq.n	34009378 <RCC_PLL_Config+0x1c4>
3400932a:	d803      	bhi.n	34009334 <RCC_PLL_Config+0x180>
3400932c:	b1db      	cbz	r3, 34009366 <RCC_PLL_Config+0x1b2>
3400932e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009332:	d01e      	beq.n	34009372 <RCC_PLL_Config+0x1be>
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009334:	f44f 7680 	mov.w	r6, #256	@ 0x100
34009338:	4b28      	ldr	r3, [pc, #160]	@ (340093dc <RCC_PLL_Config+0x228>)
3400933a:	fa06 f609 	lsl.w	r6, r6, r9
3400933e:	601e      	str	r6, [r3, #0]
      tickstart = HAL_GetTick();
34009340:	f7fb fad6 	bl	340048f0 <HAL_GetTick>
34009344:	4680      	mov	r8, r0
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
34009346:	f8df 90a0 	ldr.w	r9, [pc, #160]	@ 340093e8 <RCC_PLL_Config+0x234>
3400934a:	f8d9 3004 	ldr.w	r3, [r9, #4]
3400934e:	ea36 0303 	bics.w	r3, r6, r3
34009352:	d016      	beq.n	34009382 <RCC_PLL_Config+0x1ce>
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
34009354:	59e3      	ldr	r3, [r4, r7]
34009356:	686a      	ldr	r2, [r5, #4]
34009358:	f023 43f0 	bic.w	r3, r3, #2013265920	@ 0x78000000
3400935c:	4313      	orrs	r3, r2
3400935e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34009362:	51e3      	str	r3, [r4, r7]
34009364:	e7ba      	b.n	340092dc <RCC_PLL_Config+0x128>
  {
    case RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() == 0U)
34009366:	f7ff feb3 	bl	340090d0 <LL_RCC_HSI_IsReady>
3400936a:	2800      	cmp	r0, #0
3400936c:	d1e2      	bne.n	34009334 <RCC_PLL_Config+0x180>
      ret = HAL_ERROR;
3400936e:	2001      	movs	r0, #1
34009370:	e7bd      	b.n	340092ee <RCC_PLL_Config+0x13a>
      {
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() == 0U)
34009372:	f7ff feb5 	bl	340090e0 <LL_RCC_MSI_IsReady>
34009376:	e7f8      	b.n	3400936a <RCC_PLL_Config+0x1b6>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009378:	4b1b      	ldr	r3, [pc, #108]	@ (340093e8 <RCC_PLL_Config+0x234>)
3400937a:	685b      	ldr	r3, [r3, #4]
3400937c:	06db      	lsls	r3, r3, #27
3400937e:	d5f6      	bpl.n	3400936e <RCC_PLL_Config+0x1ba>
34009380:	e7d8      	b.n	34009334 <RCC_PLL_Config+0x180>
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
34009382:	f7fb fab5 	bl	340048f0 <HAL_GetTick>
34009386:	eba0 0008 	sub.w	r0, r0, r8
3400938a:	2801      	cmp	r0, #1
3400938c:	d9dd      	bls.n	3400934a <RCC_PLL_Config+0x196>
3400938e:	e7ad      	b.n	340092ec <RCC_PLL_Config+0x138>
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
34009390:	2b01      	cmp	r3, #1
34009392:	d1a3      	bne.n	340092dc <RCC_PLL_Config+0x128>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
34009394:	f44f 7580 	mov.w	r5, #256	@ 0x100
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
34009398:	59a3      	ldr	r3, [r4, r6]
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400939a:	4085      	lsls	r5, r0
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
3400939c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
340093a0:	51a3      	str	r3, [r4, r6]
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340093a2:	4b0e      	ldr	r3, [pc, #56]	@ (340093dc <RCC_PLL_Config+0x228>)
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340093a4:	f8df 8040 	ldr.w	r8, [pc, #64]	@ 340093e8 <RCC_PLL_Config+0x234>
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
340093a8:	601d      	str	r5, [r3, #0]
    tickstart = HAL_GetTick();
340093aa:	f7fb faa1 	bl	340048f0 <HAL_GetTick>
340093ae:	4606      	mov	r6, r0
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
340093b0:	f8d8 3004 	ldr.w	r3, [r8, #4]
340093b4:	ea35 0303 	bics.w	r3, r5, r3
340093b8:	d003      	beq.n	340093c2 <RCC_PLL_Config+0x20e>
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
340093ba:	59e3      	ldr	r3, [r4, r7]
340093bc:	f023 6300 	bic.w	r3, r3, #134217728	@ 0x8000000
340093c0:	e7cf      	b.n	34009362 <RCC_PLL_Config+0x1ae>
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
340093c2:	f7fb fa95 	bl	340048f0 <HAL_GetTick>
340093c6:	1b80      	subs	r0, r0, r6
340093c8:	2801      	cmp	r0, #1
340093ca:	d9f1      	bls.n	340093b0 <RCC_PLL_Config+0x1fc>
340093cc:	e78e      	b.n	340092ec <RCC_PLL_Config+0x138>
340093ce:	bf00      	nop
340093d0:	56028080 	.word	0x56028080
340093d4:	56028088 	.word	0x56028088
340093d8:	3401c766 	.word	0x3401c766
340093dc:	56029000 	.word	0x56029000
340093e0:	56028084 	.word	0x56028084
340093e4:	8c0000ff 	.word	0x8c0000ff
340093e8:	56028000 	.word	0x56028000

340093ec <RCC_IC_CheckPLLSources>:
  uint32_t ret = 1U;

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
340093ec:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
340093f0:	b508      	push	{r3, lr}
  switch (PLLSource1)
340093f2:	d021      	beq.n	34009438 <RCC_IC_CheckPLLSources+0x4c>
340093f4:	d805      	bhi.n	34009402 <RCC_IC_CheckPLLSources+0x16>
340093f6:	b9c0      	cbnz	r0, 3400942a <RCC_IC_CheckPLLSources+0x3e>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
340093f8:	f7ff fe7a 	bl	340090f0 <LL_RCC_PLL1_IsReady>
340093fc:	b178      	cbz	r0, 3400941e <RCC_IC_CheckPLLSources+0x32>
  uint32_t ret = 1U;
340093fe:	2201      	movs	r2, #1
34009400:	e003      	b.n	3400940a <RCC_IC_CheckPLLSources+0x1e>
  switch (PLLSource1)
34009402:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
34009406:	d01e      	beq.n	34009446 <RCC_IC_CheckPLLSources+0x5a>
34009408:	2200      	movs	r2, #0
      ret = 0U;
      break;
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3400940a:	f1b1 5f00 	cmp.w	r1, #536870912	@ 0x20000000
3400940e:	d03c      	beq.n	3400948a <RCC_IC_CheckPLLSources+0x9e>
34009410:	d820      	bhi.n	34009454 <RCC_IC_CheckPLLSources+0x68>
34009412:	b349      	cbz	r1, 34009468 <RCC_IC_CheckPLLSources+0x7c>
34009414:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
34009418:	d030      	beq.n	3400947c <RCC_IC_CheckPLLSources+0x90>
        }
      }
      break;
    default:
      /* Unexpected */
      ret = 0U;
3400941a:	2200      	movs	r2, #0
3400941c:	e02c      	b.n	34009478 <RCC_IC_CheckPLLSources+0x8c>
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400941e:	4b1e      	ldr	r3, [pc, #120]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
34009420:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009424:	f3c2 62c0 	ubfx	r2, r2, #27, #1
34009428:	e7ef      	b.n	3400940a <RCC_IC_CheckPLLSources+0x1e>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400942a:	4b1b      	ldr	r3, [pc, #108]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
3400942c:	685a      	ldr	r2, [r3, #4]
3400942e:	0592      	lsls	r2, r2, #22
34009430:	d4e5      	bmi.n	340093fe <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34009432:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34009436:	e7f5      	b.n	34009424 <RCC_IC_CheckPLLSources+0x38>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34009438:	4b17      	ldr	r3, [pc, #92]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
3400943a:	685a      	ldr	r2, [r3, #4]
3400943c:	0550      	lsls	r0, r2, #21
3400943e:	d4de      	bmi.n	340093fe <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34009440:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34009444:	e7ee      	b.n	34009424 <RCC_IC_CheckPLLSources+0x38>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009446:	4b14      	ldr	r3, [pc, #80]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
34009448:	685a      	ldr	r2, [r3, #4]
3400944a:	0512      	lsls	r2, r2, #20
3400944c:	d4d7      	bmi.n	340093fe <RCC_IC_CheckPLLSources+0x12>
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400944e:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34009452:	e7e7      	b.n	34009424 <RCC_IC_CheckPLLSources+0x38>
  switch (PLLSource2)
34009454:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
34009458:	d1df      	bne.n	3400941a <RCC_IC_CheckPLLSources+0x2e>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400945a:	4b0f      	ldr	r3, [pc, #60]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
3400945c:	6859      	ldr	r1, [r3, #4]
3400945e:	0509      	lsls	r1, r1, #20
34009460:	d40a      	bmi.n	34009478 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34009462:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34009466:	e005      	b.n	34009474 <RCC_IC_CheckPLLSources+0x88>
      if (LL_RCC_PLL1_IsReady() == 0U)
34009468:	f7ff fe42 	bl	340090f0 <LL_RCC_PLL1_IsReady>
3400946c:	b920      	cbnz	r0, 34009478 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400946e:	4b0a      	ldr	r3, [pc, #40]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
34009470:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34009474:	0118      	lsls	r0, r3, #4
34009476:	d5d0      	bpl.n	3400941a <RCC_IC_CheckPLLSources+0x2e>
      break;
  }

  return ret;
}
34009478:	4610      	mov	r0, r2
3400947a:	bd08      	pop	{r3, pc}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400947c:	4b06      	ldr	r3, [pc, #24]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
3400947e:	6859      	ldr	r1, [r3, #4]
34009480:	0589      	lsls	r1, r1, #22
34009482:	d4f9      	bmi.n	34009478 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34009484:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34009488:	e7f4      	b.n	34009474 <RCC_IC_CheckPLLSources+0x88>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400948a:	4b03      	ldr	r3, [pc, #12]	@ (34009498 <RCC_IC_CheckPLLSources+0xac>)
3400948c:	6859      	ldr	r1, [r3, #4]
3400948e:	0548      	lsls	r0, r1, #21
34009490:	d4f2      	bmi.n	34009478 <RCC_IC_CheckPLLSources+0x8c>
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34009492:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34009496:	e7ed      	b.n	34009474 <RCC_IC_CheckPLLSources+0x88>
34009498:	56028000 	.word	0x56028000

3400949c <HAL_RCC_OscConfig>:
{
3400949c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (pRCC_OscInitStruct == NULL)
340094a0:	4604      	mov	r4, r0
340094a2:	b918      	cbnz	r0, 340094ac <HAL_RCC_OscConfig+0x10>
    return HAL_ERROR;
340094a4:	2001      	movs	r0, #1
}
340094a6:	b003      	add	sp, #12
340094a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));
340094ac:	6803      	ldr	r3, [r0, #0]
340094ae:	b133      	cbz	r3, 340094be <HAL_RCC_OscConfig+0x22>
340094b0:	06dd      	lsls	r5, r3, #27
340094b2:	d104      	bne.n	340094be <HAL_RCC_OscConfig+0x22>
340094b4:	f44f 71b8 	mov.w	r1, #368	@ 0x170
340094b8:	4893      	ldr	r0, [pc, #588]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
340094ba:	f7f9 f83f 	bl	3400253c <assert_failed>
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
340094be:	4b93      	ldr	r3, [pc, #588]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
340094c0:	6a1e      	ldr	r6, [r3, #32]
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
340094c2:	6a1d      	ldr	r5, [r3, #32]
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
340094c4:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
340094c8:	f406 1640 	and.w	r6, r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
340094cc:	f002 4be0 	and.w	fp, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
340094d0:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
340094d4:	f005 5540 	and.w	r5, r5, #805306368	@ 0x30000000
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
340094d8:	f002 4ae0 	and.w	sl, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
340094dc:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
340094e0:	f002 49e0 	and.w	r9, r2, #1879048192	@ 0x70000000
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
340094e4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
  rccsr = RCC->SR;
340094e8:	685f      	ldr	r7, [r3, #4]
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
340094ea:	6823      	ldr	r3, [r4, #0]
340094ec:	f002 48e0 	and.w	r8, r2, #1879048192	@ 0x70000000
340094f0:	07d8      	lsls	r0, r3, #31
340094f2:	d463      	bmi.n	340095bc <HAL_RCC_OscConfig+0x120>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
340094f4:	6823      	ldr	r3, [r4, #0]
340094f6:	0799      	lsls	r1, r3, #30
340094f8:	f100 80d4 	bmi.w	340096a4 <HAL_RCC_OscConfig+0x208>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
340094fc:	6823      	ldr	r3, [r4, #0]
340094fe:	06d8      	lsls	r0, r3, #27
34009500:	d522      	bpl.n	34009548 <HAL_RCC_OscConfig+0xac>
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));
34009502:	69e3      	ldr	r3, [r4, #28]
34009504:	2b00      	cmp	r3, #0
34009506:	f000 8347 	beq.w	34009b98 <HAL_RCC_OscConfig+0x6fc>
3400950a:	2b04      	cmp	r3, #4
3400950c:	f000 834d 	beq.w	34009baa <HAL_RCC_OscConfig+0x70e>
34009510:	f240 2103 	movw	r1, #515	@ 0x203
34009514:	487c      	ldr	r0, [pc, #496]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
34009516:	f7f9 f811 	bl	3400253c <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3400951a:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
3400951e:	f040 8148 	bne.w	340097b2 <HAL_RCC_OscConfig+0x316>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
34009522:	69e3      	ldr	r3, [r4, #28]
34009524:	2b00      	cmp	r3, #0
34009526:	d0bd      	beq.n	340094a4 <HAL_RCC_OscConfig+0x8>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34009528:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400952a:	2b1f      	cmp	r3, #31
3400952c:	d904      	bls.n	34009538 <HAL_RCC_OscConfig+0x9c>
3400952e:	f240 2116 	movw	r1, #534	@ 0x216
34009532:	4875      	ldr	r0, [pc, #468]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
34009534:	f7f9 f802 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
34009538:	4a74      	ldr	r2, [pc, #464]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
3400953a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400953c:	6c53      	ldr	r3, [r2, #68]	@ 0x44
3400953e:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
34009542:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34009546:	6453      	str	r3, [r2, #68]	@ 0x44
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
34009548:	6823      	ldr	r3, [r4, #0]
3400954a:	0718      	lsls	r0, r3, #28
3400954c:	f100 8189 	bmi.w	34009862 <HAL_RCC_OscConfig+0x3c6>
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
34009550:	6823      	ldr	r3, [r4, #0]
34009552:	0759      	lsls	r1, r3, #29
34009554:	f100 81b4 	bmi.w	340098c0 <HAL_RCC_OscConfig+0x424>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));
34009558:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400955a:	2b03      	cmp	r3, #3
3400955c:	d904      	bls.n	34009568 <HAL_RCC_OscConfig+0xcc>
3400955e:	f240 21a3 	movw	r1, #675	@ 0x2a3
34009562:	4869      	ldr	r0, [pc, #420]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
34009564:	f7f8 ffea 	bl	3400253c <assert_failed>
  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
34009568:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3400956a:	2f00      	cmp	r7, #0
3400956c:	f040 8210 	bne.w	34009990 <HAL_RCC_OscConfig+0x4f4>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));
34009570:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34009572:	2b03      	cmp	r3, #3
34009574:	d904      	bls.n	34009580 <HAL_RCC_OscConfig+0xe4>
34009576:	f240 21d1 	movw	r1, #721	@ 0x2d1
3400957a:	4863      	ldr	r0, [pc, #396]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
3400957c:	f7f8 ffde 	bl	3400253c <assert_failed>
  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
34009580:	6c67      	ldr	r7, [r4, #68]	@ 0x44
34009582:	2f00      	cmp	r7, #0
34009584:	f040 8246 	bne.w	34009a14 <HAL_RCC_OscConfig+0x578>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));
34009588:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400958a:	2b03      	cmp	r3, #3
3400958c:	d904      	bls.n	34009598 <HAL_RCC_OscConfig+0xfc>
3400958e:	f240 21ff 	movw	r1, #767	@ 0x2ff
34009592:	485d      	ldr	r0, [pc, #372]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
34009594:	f7f8 ffd2 	bl	3400253c <assert_failed>
  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
34009598:	6e27      	ldr	r7, [r4, #96]	@ 0x60
3400959a:	2f00      	cmp	r7, #0
3400959c:	f040 827a 	bne.w	34009a94 <HAL_RCC_OscConfig+0x5f8>
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));
340095a0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
340095a2:	2b03      	cmp	r3, #3
340095a4:	d904      	bls.n	340095b0 <HAL_RCC_OscConfig+0x114>
340095a6:	f44f 714b 	mov.w	r1, #812	@ 0x32c
340095aa:	4857      	ldr	r0, [pc, #348]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
340095ac:	f7f8 ffc6 	bl	3400253c <assert_failed>
  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
340095b0:	6fe7      	ldr	r7, [r4, #124]	@ 0x7c
340095b2:	2f00      	cmp	r7, #0
340095b4:	f040 82b0 	bne.w	34009b18 <HAL_RCC_OscConfig+0x67c>
  return HAL_OK;
340095b8:	2000      	movs	r0, #0
340095ba:	e774      	b.n	340094a6 <HAL_RCC_OscConfig+0xa>
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));
340095bc:	6863      	ldr	r3, [r4, #4]
340095be:	2b00      	cmp	r3, #0
340095c0:	f000 8313 	beq.w	34009bea <HAL_RCC_OscConfig+0x74e>
340095c4:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
340095c8:	2a10      	cmp	r2, #16
340095ca:	f000 8305 	beq.w	34009bd8 <HAL_RCC_OscConfig+0x73c>
340095ce:	4a50      	ldr	r2, [pc, #320]	@ (34009710 <HAL_RCC_OscConfig+0x274>)
340095d0:	4293      	cmp	r3, r2
340095d2:	f000 8301 	beq.w	34009bd8 <HAL_RCC_OscConfig+0x73c>
340095d6:	f44f 71bf 	mov.w	r1, #382	@ 0x17e
340095da:	484b      	ldr	r0, [pc, #300]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
340095dc:	f7f8 ffae 	bl	3400253c <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
340095e0:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
340095e4:	d103      	bne.n	340095ee <HAL_RCC_OscConfig+0x152>
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
340095e6:	6863      	ldr	r3, [r4, #4]
340095e8:	2b00      	cmp	r3, #0
340095ea:	d183      	bne.n	340094f4 <HAL_RCC_OscConfig+0x58>
340095ec:	e75a      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
340095ee:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
340095f2:	d0f8      	beq.n	340095e6 <HAL_RCC_OscConfig+0x14a>
340095f4:	f1bb 5f00 	cmp.w	fp, #536870912	@ 0x20000000
340095f8:	d101      	bne.n	340095fe <HAL_RCC_OscConfig+0x162>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
340095fa:	05fa      	lsls	r2, r7, #23
340095fc:	d4f3      	bmi.n	340095e6 <HAL_RCC_OscConfig+0x14a>
340095fe:	f1ba 5f00 	cmp.w	sl, #536870912	@ 0x20000000
34009602:	d101      	bne.n	34009608 <HAL_RCC_OscConfig+0x16c>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34009604:	05bb      	lsls	r3, r7, #22
34009606:	d4ee      	bmi.n	340095e6 <HAL_RCC_OscConfig+0x14a>
34009608:	f1b9 5f00 	cmp.w	r9, #536870912	@ 0x20000000
3400960c:	d101      	bne.n	34009612 <HAL_RCC_OscConfig+0x176>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400960e:	0578      	lsls	r0, r7, #21
34009610:	d4e9      	bmi.n	340095e6 <HAL_RCC_OscConfig+0x14a>
34009612:	f1b8 5f00 	cmp.w	r8, #536870912	@ 0x20000000
34009616:	d101      	bne.n	3400961c <HAL_RCC_OscConfig+0x180>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009618:	0539      	lsls	r1, r7, #20
3400961a:	d4e4      	bmi.n	340095e6 <HAL_RCC_OscConfig+0x14a>
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3400961c:	6862      	ldr	r2, [r4, #4]
3400961e:	4b3b      	ldr	r3, [pc, #236]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
34009620:	2a10      	cmp	r2, #16
34009622:	d114      	bne.n	3400964e <HAL_RCC_OscConfig+0x1b2>
34009624:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009628:	f7fb f962 	bl	340048f0 <HAL_GetTick>
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3400962c:	6863      	ldr	r3, [r4, #4]
      tickstart = HAL_GetTick();
3400962e:	9001      	str	r0, [sp, #4]
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34009630:	b35b      	cbz	r3, 3400968a <HAL_RCC_OscConfig+0x1ee>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34009632:	4b36      	ldr	r3, [pc, #216]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
34009634:	685a      	ldr	r2, [r3, #4]
34009636:	06d2      	lsls	r2, r2, #27
34009638:	f53f af5c 	bmi.w	340094f4 <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3400963c:	f7fb f958 	bl	340048f0 <HAL_GetTick>
34009640:	9b01      	ldr	r3, [sp, #4]
34009642:	1ac0      	subs	r0, r0, r3
34009644:	2864      	cmp	r0, #100	@ 0x64
34009646:	4b31      	ldr	r3, [pc, #196]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
34009648:	d9f4      	bls.n	34009634 <HAL_RCC_OscConfig+0x198>
            return HAL_TIMEOUT;
3400964a:	2003      	movs	r0, #3
3400964c:	e72b      	b.n	340094a6 <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3400964e:	b93a      	cbnz	r2, 34009660 <HAL_RCC_OscConfig+0x1c4>
34009650:	2110      	movs	r1, #16
34009652:	4a30      	ldr	r2, [pc, #192]	@ (34009714 <HAL_RCC_OscConfig+0x278>)
34009654:	6011      	str	r1, [r2, #0]
34009656:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009658:	f422 32c0 	bic.w	r2, r2, #98304	@ 0x18000
3400965c:	655a      	str	r2, [r3, #84]	@ 0x54
3400965e:	e7e3      	b.n	34009628 <HAL_RCC_OscConfig+0x18c>
34009660:	f248 0110 	movw	r1, #32784	@ 0x8010
34009664:	428a      	cmp	r2, r1
34009666:	d109      	bne.n	3400967c <HAL_RCC_OscConfig+0x1e0>
34009668:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
3400966a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
3400966e:	655a      	str	r2, [r3, #84]	@ 0x54
34009670:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009672:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
34009676:	655a      	str	r2, [r3, #84]	@ 0x54
34009678:	2210      	movs	r2, #16
3400967a:	e7d3      	b.n	34009624 <HAL_RCC_OscConfig+0x188>
3400967c:	4924      	ldr	r1, [pc, #144]	@ (34009710 <HAL_RCC_OscConfig+0x274>)
3400967e:	428a      	cmp	r2, r1
34009680:	d1e6      	bne.n	34009650 <HAL_RCC_OscConfig+0x1b4>
34009682:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
34009684:	f442 32c0 	orr.w	r2, r2, #98304	@ 0x18000
34009688:	e7f5      	b.n	34009676 <HAL_RCC_OscConfig+0x1da>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
3400968a:	4b20      	ldr	r3, [pc, #128]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
3400968c:	685a      	ldr	r2, [r3, #4]
3400968e:	06d3      	lsls	r3, r2, #27
34009690:	f57f af30 	bpl.w	340094f4 <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34009694:	f7fb f92c 	bl	340048f0 <HAL_GetTick>
34009698:	9b01      	ldr	r3, [sp, #4]
3400969a:	1ac0      	subs	r0, r0, r3
3400969c:	2864      	cmp	r0, #100	@ 0x64
3400969e:	4b1b      	ldr	r3, [pc, #108]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
340096a0:	d9f4      	bls.n	3400968c <HAL_RCC_OscConfig+0x1f0>
340096a2:	e7d2      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
340096a4:	68e3      	ldr	r3, [r4, #12]
340096a6:	2b00      	cmp	r3, #0
340096a8:	f000 8288 	beq.w	34009bbc <HAL_RCC_OscConfig+0x720>
340096ac:	2b08      	cmp	r3, #8
340096ae:	f000 828c 	beq.w	34009bca <HAL_RCC_OscConfig+0x72e>
340096b2:	f240 11b3 	movw	r1, #435	@ 0x1b3
340096b6:	4814      	ldr	r0, [pc, #80]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
340096b8:	f7f8 ff40 	bl	3400253c <assert_failed>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
340096bc:	bb66      	cbnz	r6, 34009718 <HAL_RCC_OscConfig+0x27c>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
340096be:	68e3      	ldr	r3, [r4, #12]
340096c0:	2b00      	cmp	r3, #0
340096c2:	f43f aeef 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
340096c6:	6923      	ldr	r3, [r4, #16]
340096c8:	f433 73c0 	bics.w	r3, r3, #384	@ 0x180
340096cc:	d004      	beq.n	340096d8 <HAL_RCC_OscConfig+0x23c>
340096ce:	f240 11c5 	movw	r1, #453	@ 0x1c5
340096d2:	480d      	ldr	r0, [pc, #52]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
340096d4:	f7f8 ff32 	bl	3400253c <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
340096d8:	6963      	ldr	r3, [r4, #20]
340096da:	2b7f      	cmp	r3, #127	@ 0x7f
340096dc:	d904      	bls.n	340096e8 <HAL_RCC_OscConfig+0x24c>
340096de:	f44f 71e3 	mov.w	r1, #454	@ 0x1c6
340096e2:	4809      	ldr	r0, [pc, #36]	@ (34009708 <HAL_RCC_OscConfig+0x26c>)
340096e4:	f7f8 ff2a 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
340096e8:	4a08      	ldr	r2, [pc, #32]	@ (3400970c <HAL_RCC_OscConfig+0x270>)
340096ea:	6921      	ldr	r1, [r4, #16]
340096ec:	6c93      	ldr	r3, [r2, #72]	@ 0x48
340096ee:	f423 73c0 	bic.w	r3, r3, #384	@ 0x180
340096f2:	430b      	orrs	r3, r1
340096f4:	6493      	str	r3, [r2, #72]	@ 0x48
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
340096f6:	6c93      	ldr	r3, [r2, #72]	@ 0x48
340096f8:	6961      	ldr	r1, [r4, #20]
340096fa:	f423 03fe 	bic.w	r3, r3, #8323072	@ 0x7f0000
340096fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34009702:	6493      	str	r3, [r2, #72]	@ 0x48
}
34009704:	e6fa      	b.n	340094fc <HAL_RCC_OscConfig+0x60>
34009706:	bf00      	nop
34009708:	3401c766 	.word	0x3401c766
3400970c:	56028000 	.word	0x56028000
34009710:	00018010 	.word	0x00018010
34009714:	56029000 	.word	0x56029000
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34009718:	2d00      	cmp	r5, #0
3400971a:	d0d0      	beq.n	340096be <HAL_RCC_OscConfig+0x222>
3400971c:	f1bb 0f00 	cmp.w	fp, #0
34009720:	d101      	bne.n	34009726 <HAL_RCC_OscConfig+0x28a>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34009722:	05f8      	lsls	r0, r7, #23
34009724:	d4cb      	bmi.n	340096be <HAL_RCC_OscConfig+0x222>
34009726:	f1ba 0f00 	cmp.w	sl, #0
3400972a:	d101      	bne.n	34009730 <HAL_RCC_OscConfig+0x294>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400972c:	05b9      	lsls	r1, r7, #22
3400972e:	d4c6      	bmi.n	340096be <HAL_RCC_OscConfig+0x222>
34009730:	f1b9 0f00 	cmp.w	r9, #0
34009734:	d101      	bne.n	3400973a <HAL_RCC_OscConfig+0x29e>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34009736:	057a      	lsls	r2, r7, #21
34009738:	d4c1      	bmi.n	340096be <HAL_RCC_OscConfig+0x222>
3400973a:	f1b8 0f00 	cmp.w	r8, #0
3400973e:	d101      	bne.n	34009744 <HAL_RCC_OscConfig+0x2a8>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34009740:	053b      	lsls	r3, r7, #20
34009742:	d4bc      	bmi.n	340096be <HAL_RCC_OscConfig+0x222>
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
34009744:	68e3      	ldr	r3, [r4, #12]
34009746:	b313      	cbz	r3, 3400978e <HAL_RCC_OscConfig+0x2f2>
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
34009748:	6923      	ldr	r3, [r4, #16]
3400974a:	f433 73c0 	bics.w	r3, r3, #384	@ 0x180
3400974e:	d004      	beq.n	3400975a <HAL_RCC_OscConfig+0x2be>
34009750:	f44f 71ea 	mov.w	r1, #468	@ 0x1d4
34009754:	48ab      	ldr	r0, [pc, #684]	@ (34009a04 <HAL_RCC_OscConfig+0x568>)
34009756:	f7f8 fef1 	bl	3400253c <assert_failed>
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));
3400975a:	6963      	ldr	r3, [r4, #20]
3400975c:	2b7f      	cmp	r3, #127	@ 0x7f
3400975e:	d904      	bls.n	3400976a <HAL_RCC_OscConfig+0x2ce>
34009760:	f240 11d5 	movw	r1, #469	@ 0x1d5
34009764:	48a7      	ldr	r0, [pc, #668]	@ (34009a04 <HAL_RCC_OscConfig+0x568>)
34009766:	f7f8 fee9 	bl	3400253c <assert_failed>
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3400976a:	2208      	movs	r2, #8
3400976c:	4ba6      	ldr	r3, [pc, #664]	@ (34009a08 <HAL_RCC_OscConfig+0x56c>)
3400976e:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
        tickstart = HAL_GetTick();
34009772:	f7fb f8bd 	bl	340048f0 <HAL_GetTick>
34009776:	9001      	str	r0, [sp, #4]
        while (LL_RCC_HSI_IsReady() == 0U)
34009778:	f7ff fcaa 	bl	340090d0 <LL_RCC_HSI_IsReady>
3400977c:	2800      	cmp	r0, #0
3400977e:	d1b3      	bne.n	340096e8 <HAL_RCC_OscConfig+0x24c>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
34009780:	f7fb f8b6 	bl	340048f0 <HAL_GetTick>
34009784:	9b01      	ldr	r3, [sp, #4]
34009786:	1ac0      	subs	r0, r0, r3
34009788:	2801      	cmp	r0, #1
3400978a:	d9f5      	bls.n	34009778 <HAL_RCC_OscConfig+0x2dc>
3400978c:	e75d      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
3400978e:	2208      	movs	r2, #8
34009790:	4b9e      	ldr	r3, [pc, #632]	@ (34009a0c <HAL_RCC_OscConfig+0x570>)
34009792:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
34009794:	f7fb f8ac 	bl	340048f0 <HAL_GetTick>
34009798:	9001      	str	r0, [sp, #4]
        while (LL_RCC_HSI_IsReady() != 0U)
3400979a:	f7ff fc99 	bl	340090d0 <LL_RCC_HSI_IsReady>
3400979e:	2800      	cmp	r0, #0
340097a0:	f43f aeac 	beq.w	340094fc <HAL_RCC_OscConfig+0x60>
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
340097a4:	f7fb f8a4 	bl	340048f0 <HAL_GetTick>
340097a8:	9b01      	ldr	r3, [sp, #4]
340097aa:	1ac0      	subs	r0, r0, r3
340097ac:	2801      	cmp	r0, #1
340097ae:	d9f4      	bls.n	3400979a <HAL_RCC_OscConfig+0x2fe>
340097b0:	e74b      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
340097b2:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
340097b6:	f43f aeb4 	beq.w	34009522 <HAL_RCC_OscConfig+0x86>
340097ba:	f1bb 5f80 	cmp.w	fp, #268435456	@ 0x10000000
340097be:	d102      	bne.n	340097c6 <HAL_RCC_OscConfig+0x32a>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
340097c0:	05f9      	lsls	r1, r7, #23
340097c2:	f53f aeae 	bmi.w	34009522 <HAL_RCC_OscConfig+0x86>
340097c6:	f1ba 5f80 	cmp.w	sl, #268435456	@ 0x10000000
340097ca:	d102      	bne.n	340097d2 <HAL_RCC_OscConfig+0x336>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
340097cc:	05ba      	lsls	r2, r7, #22
340097ce:	f53f aea8 	bmi.w	34009522 <HAL_RCC_OscConfig+0x86>
340097d2:	f1b9 5f80 	cmp.w	r9, #268435456	@ 0x10000000
340097d6:	d102      	bne.n	340097de <HAL_RCC_OscConfig+0x342>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
340097d8:	057b      	lsls	r3, r7, #21
340097da:	f53f aea2 	bmi.w	34009522 <HAL_RCC_OscConfig+0x86>
340097de:	f1b8 5f80 	cmp.w	r8, #268435456	@ 0x10000000
340097e2:	d102      	bne.n	340097ea <HAL_RCC_OscConfig+0x34e>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
340097e4:	053f      	lsls	r7, r7, #20
340097e6:	f53f ae9c 	bmi.w	34009522 <HAL_RCC_OscConfig+0x86>
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
340097ea:	69e3      	ldr	r3, [r4, #28]
340097ec:	b343      	cbz	r3, 34009840 <HAL_RCC_OscConfig+0x3a4>
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
340097ee:	6a23      	ldr	r3, [r4, #32]
340097f0:	f433 7300 	bics.w	r3, r3, #512	@ 0x200
340097f4:	d004      	beq.n	34009800 <HAL_RCC_OscConfig+0x364>
340097f6:	f240 2122 	movw	r1, #546	@ 0x222
340097fa:	4882      	ldr	r0, [pc, #520]	@ (34009a04 <HAL_RCC_OscConfig+0x568>)
340097fc:	f7f8 fe9e 	bl	3400253c <assert_failed>
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
34009800:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009802:	2b1f      	cmp	r3, #31
34009804:	d904      	bls.n	34009810 <HAL_RCC_OscConfig+0x374>
34009806:	f240 2123 	movw	r1, #547	@ 0x223
3400980a:	487e      	ldr	r0, [pc, #504]	@ (34009a04 <HAL_RCC_OscConfig+0x568>)
3400980c:	f7f8 fe96 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
34009810:	4a7d      	ldr	r2, [pc, #500]	@ (34009a08 <HAL_RCC_OscConfig+0x56c>)
34009812:	6a21      	ldr	r1, [r4, #32]
34009814:	6c53      	ldr	r3, [r2, #68]	@ 0x44
34009816:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
3400981a:	430b      	orrs	r3, r1
3400981c:	6453      	str	r3, [r2, #68]	@ 0x44
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3400981e:	2304      	movs	r3, #4
34009820:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800
        tickstart = HAL_GetTick();
34009824:	f7fb f864 	bl	340048f0 <HAL_GetTick>
34009828:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
3400982a:	f7ff fc59 	bl	340090e0 <LL_RCC_MSI_IsReady>
3400982e:	2800      	cmp	r0, #0
34009830:	f47f ae82 	bne.w	34009538 <HAL_RCC_OscConfig+0x9c>
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34009834:	f7fb f85c 	bl	340048f0 <HAL_GetTick>
34009838:	1bc0      	subs	r0, r0, r7
3400983a:	2801      	cmp	r0, #1
3400983c:	d9f5      	bls.n	3400982a <HAL_RCC_OscConfig+0x38e>
3400983e:	e704      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34009840:	2204      	movs	r2, #4
34009842:	4b72      	ldr	r3, [pc, #456]	@ (34009a0c <HAL_RCC_OscConfig+0x570>)
34009844:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
34009846:	f7fb f853 	bl	340048f0 <HAL_GetTick>
3400984a:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
3400984c:	f7ff fc48 	bl	340090e0 <LL_RCC_MSI_IsReady>
34009850:	2800      	cmp	r0, #0
34009852:	f43f ae79 	beq.w	34009548 <HAL_RCC_OscConfig+0xac>
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
34009856:	f7fb f84b 	bl	340048f0 <HAL_GetTick>
3400985a:	1bc0      	subs	r0, r0, r7
3400985c:	2801      	cmp	r0, #1
3400985e:	d9f5      	bls.n	3400984c <HAL_RCC_OscConfig+0x3b0>
34009860:	e6f3      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));
34009862:	69a3      	ldr	r3, [r4, #24]
34009864:	2b01      	cmp	r3, #1
34009866:	d904      	bls.n	34009872 <HAL_RCC_OscConfig+0x3d6>
34009868:	f240 2153 	movw	r1, #595	@ 0x253
3400986c:	4865      	ldr	r0, [pc, #404]	@ (34009a04 <HAL_RCC_OscConfig+0x568>)
3400986e:	f7f8 fe65 	bl	3400253c <assert_failed>
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
34009872:	69a2      	ldr	r2, [r4, #24]
34009874:	2301      	movs	r3, #1
34009876:	b18a      	cbz	r2, 3400989c <HAL_RCC_OscConfig+0x400>
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
34009878:	f8df 818c 	ldr.w	r8, [pc, #396]	@ 34009a08 <HAL_RCC_OscConfig+0x56c>
3400987c:	f8c8 3800 	str.w	r3, [r8, #2048]	@ 0x800
      tickstart = HAL_GetTick();
34009880:	f7fb f836 	bl	340048f0 <HAL_GetTick>
34009884:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34009886:	f8d8 3004 	ldr.w	r3, [r8, #4]
      while (LL_RCC_LSI_IsReady() == 0U)
3400988a:	07da      	lsls	r2, r3, #31
3400988c:	f53f ae60 	bmi.w	34009550 <HAL_RCC_OscConfig+0xb4>
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
34009890:	f7fb f82e 	bl	340048f0 <HAL_GetTick>
34009894:	1bc0      	subs	r0, r0, r7
34009896:	2801      	cmp	r0, #1
34009898:	d9f5      	bls.n	34009886 <HAL_RCC_OscConfig+0x3ea>
3400989a:	e6d6      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
3400989c:	4a5b      	ldr	r2, [pc, #364]	@ (34009a0c <HAL_RCC_OscConfig+0x570>)
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400989e:	f8df 8168 	ldr.w	r8, [pc, #360]	@ 34009a08 <HAL_RCC_OscConfig+0x56c>
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
340098a2:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
340098a4:	f7fb f824 	bl	340048f0 <HAL_GetTick>
340098a8:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
340098aa:	f8d8 3004 	ldr.w	r3, [r8, #4]
      while (LL_RCC_LSI_IsReady() != 0U)
340098ae:	07db      	lsls	r3, r3, #31
340098b0:	f57f ae4e 	bpl.w	34009550 <HAL_RCC_OscConfig+0xb4>
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
340098b4:	f7fb f81c 	bl	340048f0 <HAL_GetTick>
340098b8:	1bc0      	subs	r0, r0, r7
340098ba:	2801      	cmp	r0, #1
340098bc:	d9f5      	bls.n	340098aa <HAL_RCC_OscConfig+0x40e>
340098be:	e6c4      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));
340098c0:	68a3      	ldr	r3, [r4, #8]
340098c2:	f033 0202 	bics.w	r2, r3, #2
340098c6:	d00a      	beq.n	340098de <HAL_RCC_OscConfig+0x442>
340098c8:	f248 0202 	movw	r2, #32770	@ 0x8002
340098cc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
340098d0:	4293      	cmp	r3, r2
340098d2:	d004      	beq.n	340098de <HAL_RCC_OscConfig+0x442>
340098d4:	f240 217e 	movw	r1, #638	@ 0x27e
340098d8:	484a      	ldr	r0, [pc, #296]	@ (34009a04 <HAL_RCC_OscConfig+0x568>)
340098da:	f7f8 fe2f 	bl	3400253c <assert_failed>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
340098de:	68a3      	ldr	r3, [r4, #8]
340098e0:	4f49      	ldr	r7, [pc, #292]	@ (34009a08 <HAL_RCC_OscConfig+0x56c>)
340098e2:	2b02      	cmp	r3, #2
340098e4:	d113      	bne.n	3400990e <HAL_RCC_OscConfig+0x472>
340098e6:	f8c7 3800 	str.w	r3, [r7, #2048]	@ 0x800
      tickstart = HAL_GetTick();
340098ea:	f7fb f801 	bl	340048f0 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
340098ee:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
340098f2:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
340098f4:	f8df 9110 	ldr.w	r9, [pc, #272]	@ 34009a08 <HAL_RCC_OscConfig+0x56c>
340098f8:	f8d9 3004 	ldr.w	r3, [r9, #4]
340098fc:	0798      	lsls	r0, r3, #30
340098fe:	f53f ae2b 	bmi.w	34009558 <HAL_RCC_OscConfig+0xbc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34009902:	f7fa fff5 	bl	340048f0 <HAL_GetTick>
34009906:	1bc3      	subs	r3, r0, r7
34009908:	4543      	cmp	r3, r8
3400990a:	d9f5      	bls.n	340098f8 <HAL_RCC_OscConfig+0x45c>
3400990c:	e69d      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400990e:	b9d3      	cbnz	r3, 34009946 <HAL_RCC_OscConfig+0x4aa>
34009910:	2202      	movs	r2, #2
34009912:	4b3e      	ldr	r3, [pc, #248]	@ (34009a0c <HAL_RCC_OscConfig+0x570>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34009914:	f241 3988 	movw	r9, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
34009918:	601a      	str	r2, [r3, #0]
3400991a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400991c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34009920:	643b      	str	r3, [r7, #64]	@ 0x40
34009922:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009924:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34009928:	643b      	str	r3, [r7, #64]	@ 0x40
      tickstart = HAL_GetTick();
3400992a:	f7fa ffe1 	bl	340048f0 <HAL_GetTick>
3400992e:	4680      	mov	r8, r0
34009930:	687b      	ldr	r3, [r7, #4]
34009932:	0799      	lsls	r1, r3, #30
34009934:	f57f ae10 	bpl.w	34009558 <HAL_RCC_OscConfig+0xbc>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34009938:	f7fa ffda 	bl	340048f0 <HAL_GetTick>
3400993c:	eba0 0308 	sub.w	r3, r0, r8
34009940:	454b      	cmp	r3, r9
34009942:	d9f5      	bls.n	34009930 <HAL_RCC_OscConfig+0x494>
34009944:	e681      	b.n	3400964a <HAL_RCC_OscConfig+0x1ae>
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
34009946:	f248 0202 	movw	r2, #32770	@ 0x8002
3400994a:	4293      	cmp	r3, r2
3400994c:	d109      	bne.n	34009962 <HAL_RCC_OscConfig+0x4c6>
3400994e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009950:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34009954:	643b      	str	r3, [r7, #64]	@ 0x40
34009956:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009958:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400995c:	643b      	str	r3, [r7, #64]	@ 0x40
3400995e:	2302      	movs	r3, #2
34009960:	e7c1      	b.n	340098e6 <HAL_RCC_OscConfig+0x44a>
34009962:	4a2b      	ldr	r2, [pc, #172]	@ (34009a10 <HAL_RCC_OscConfig+0x574>)
34009964:	4293      	cmp	r3, r2
34009966:	d107      	bne.n	34009978 <HAL_RCC_OscConfig+0x4dc>
34009968:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400996a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400996e:	643b      	str	r3, [r7, #64]	@ 0x40
34009970:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009972:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34009976:	e7f1      	b.n	3400995c <HAL_RCC_OscConfig+0x4c0>
34009978:	2202      	movs	r2, #2
3400997a:	4b24      	ldr	r3, [pc, #144]	@ (34009a0c <HAL_RCC_OscConfig+0x570>)
3400997c:	601a      	str	r2, [r3, #0]
3400997e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009980:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
34009984:	643b      	str	r3, [r7, #64]	@ 0x40
34009986:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34009988:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400998c:	643b      	str	r3, [r7, #64]	@ 0x40
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3400998e:	e7ac      	b.n	340098ea <HAL_RCC_OscConfig+0x44e>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
34009990:	2000      	movs	r0, #0
34009992:	f104 0128 	add.w	r1, r4, #40	@ 0x28
34009996:	f7ff fbb3 	bl	34009100 <RCC_PLL_IsNewConfig>
3400999a:	4602      	mov	r2, r0
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3400999c:	f7ff fba8 	bl	340090f0 <LL_RCC_PLL1_IsReady>
    if (new_pll_config == 1U)
340099a0:	2a01      	cmp	r2, #1
340099a2:	d125      	bne.n	340099f0 <HAL_RCC_OscConfig+0x554>
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
340099a4:	4b18      	ldr	r3, [pc, #96]	@ (34009a08 <HAL_RCC_OscConfig+0x56c>)
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
340099a6:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
340099aa:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
340099ae:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
340099b2:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
340099b6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
340099ba:	d103      	bne.n	340099c4 <HAL_RCC_OscConfig+0x528>
340099bc:	f017 5f40 	tst.w	r7, #805306368	@ 0x30000000
340099c0:	f43f ad70 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
340099c4:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
340099c8:	d10b      	bne.n	340099e2 <HAL_RCC_OscConfig+0x546>
340099ca:	f010 5f40 	tst.w	r0, #805306368	@ 0x30000000
340099ce:	f43f ad69 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
340099d2:	f012 5f40 	tst.w	r2, #805306368	@ 0x30000000
340099d6:	f43f ad65 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
340099da:	f013 5f40 	tst.w	r3, #805306368	@ 0x30000000
340099de:	f43f ad61 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
340099e2:	2000      	movs	r0, #0
340099e4:	f7ff fbe6 	bl	340091b4 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
340099e8:	2800      	cmp	r0, #0
340099ea:	f43f adc1 	beq.w	34009570 <HAL_RCC_OscConfig+0xd4>
340099ee:	e559      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
340099f0:	2f02      	cmp	r7, #2
340099f2:	f47f adbd 	bne.w	34009570 <HAL_RCC_OscConfig+0xd4>
340099f6:	2800      	cmp	r0, #0
340099f8:	f47f adba 	bne.w	34009570 <HAL_RCC_OscConfig+0xd4>
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
340099fc:	f7ff fbc2 	bl	34009184 <RCC_PLL_Enable>
34009a00:	e7f2      	b.n	340099e8 <HAL_RCC_OscConfig+0x54c>
34009a02:	bf00      	nop
34009a04:	3401c766 	.word	0x3401c766
34009a08:	56028000 	.word	0x56028000
34009a0c:	56029000 	.word	0x56029000
34009a10:	00018002 	.word	0x00018002
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
34009a14:	2001      	movs	r0, #1
34009a16:	f104 0144 	add.w	r1, r4, #68	@ 0x44
34009a1a:	f7ff fb71 	bl	34009100 <RCC_PLL_IsNewConfig>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34009a1e:	4b77      	ldr	r3, [pc, #476]	@ (34009bfc <HAL_RCC_OscConfig+0x760>)
    if (new_pll_config == 1U)
34009a20:	2801      	cmp	r0, #1
34009a22:	685a      	ldr	r2, [r3, #4]
34009a24:	d12c      	bne.n	34009a80 <HAL_RCC_OscConfig+0x5e4>
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
34009a26:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009a2a:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009a2e:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009a32:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009a36:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34009a3a:	d105      	bne.n	34009a48 <HAL_RCC_OscConfig+0x5ac>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009a3c:	f007 5740 	and.w	r7, r7, #805306368	@ 0x30000000
34009a40:	f1b7 5f80 	cmp.w	r7, #268435456	@ 0x10000000
34009a44:	f43f ad2e 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
34009a48:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
34009a4c:	d111      	bne.n	34009a72 <HAL_RCC_OscConfig+0x5d6>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009a4e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009a52:	f1b0 5f80 	cmp.w	r0, #268435456	@ 0x10000000
34009a56:	f43f ad25 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009a5a:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
34009a5e:	f1b2 5f80 	cmp.w	r2, #268435456	@ 0x10000000
34009a62:	f43f ad1f 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009a66:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
34009a6a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009a6e:	f43f ad19 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
34009a72:	2001      	movs	r0, #1
34009a74:	f7ff fb9e 	bl	340091b4 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
34009a78:	2800      	cmp	r0, #0
34009a7a:	f43f ad85 	beq.w	34009588 <HAL_RCC_OscConfig+0xec>
34009a7e:	e511      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
34009a80:	2f02      	cmp	r7, #2
34009a82:	f47f ad81 	bne.w	34009588 <HAL_RCC_OscConfig+0xec>
34009a86:	0592      	lsls	r2, r2, #22
34009a88:	f53f ad7e 	bmi.w	34009588 <HAL_RCC_OscConfig+0xec>
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
34009a8c:	2001      	movs	r0, #1
34009a8e:	f7ff fb79 	bl	34009184 <RCC_PLL_Enable>
34009a92:	e7f1      	b.n	34009a78 <HAL_RCC_OscConfig+0x5dc>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
34009a94:	2002      	movs	r0, #2
34009a96:	f104 0160 	add.w	r1, r4, #96	@ 0x60
34009a9a:	f7ff fb31 	bl	34009100 <RCC_PLL_IsNewConfig>
34009a9e:	4602      	mov	r2, r0
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
34009aa0:	f7ff fb26 	bl	340090f0 <LL_RCC_PLL1_IsReady>
    if (new_pll_config == 1U)
34009aa4:	2a01      	cmp	r2, #1
34009aa6:	d12d      	bne.n	34009b04 <HAL_RCC_OscConfig+0x668>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009aa8:	4b54      	ldr	r3, [pc, #336]	@ (34009bfc <HAL_RCC_OscConfig+0x760>)
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
34009aaa:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
34009aae:	f8d3 70c4 	ldr.w	r7, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009ab2:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009ab6:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009aba:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34009abe:	d105      	bne.n	34009acc <HAL_RCC_OscConfig+0x630>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009ac0:	f007 5740 	and.w	r7, r7, #805306368	@ 0x30000000
34009ac4:	f1b7 5f00 	cmp.w	r7, #536870912	@ 0x20000000
34009ac8:	f43f acec 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
34009acc:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
34009ad0:	d111      	bne.n	34009af6 <HAL_RCC_OscConfig+0x65a>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009ad2:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009ad6:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
34009ada:	f43f ace3 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009ade:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
34009ae2:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
34009ae6:	f43f acdd 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009aea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
34009aee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009af2:	f43f acd7 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
34009af6:	2002      	movs	r0, #2
34009af8:	f7ff fb5c 	bl	340091b4 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34009afc:	2800      	cmp	r0, #0
34009afe:	f43f ad4f 	beq.w	340095a0 <HAL_RCC_OscConfig+0x104>
34009b02:	e4cf      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
34009b04:	2f02      	cmp	r7, #2
34009b06:	f47f ad4b 	bne.w	340095a0 <HAL_RCC_OscConfig+0x104>
34009b0a:	2800      	cmp	r0, #0
34009b0c:	f47f ad48 	bne.w	340095a0 <HAL_RCC_OscConfig+0x104>
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
34009b10:	4638      	mov	r0, r7
34009b12:	f7ff fb37 	bl	34009184 <RCC_PLL_Enable>
34009b16:	e7f1      	b.n	34009afc <HAL_RCC_OscConfig+0x660>
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
34009b18:	2003      	movs	r0, #3
34009b1a:	f104 017c 	add.w	r1, r4, #124	@ 0x7c
34009b1e:	f7ff faef 	bl	34009100 <RCC_PLL_IsNewConfig>
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34009b22:	4b36      	ldr	r3, [pc, #216]	@ (34009bfc <HAL_RCC_OscConfig+0x760>)
    if (new_pll_config == 1U)
34009b24:	2801      	cmp	r0, #1
34009b26:	685a      	ldr	r2, [r3, #4]
34009b28:	d12c      	bne.n	34009b84 <HAL_RCC_OscConfig+0x6e8>
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
34009b2a:	f5b6 1f40 	cmp.w	r6, #3145728	@ 0x300000
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009b2e:	f8d3 40c4 	ldr.w	r4, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009b32:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009b36:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009b3a:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34009b3e:	d105      	bne.n	34009b4c <HAL_RCC_OscConfig+0x6b0>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009b40:	f004 5640 	and.w	r6, r4, #805306368	@ 0x30000000
34009b44:	f1b6 5f40 	cmp.w	r6, #805306368	@ 0x30000000
34009b48:	f43f acac 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
34009b4c:	f1b5 5f40 	cmp.w	r5, #805306368	@ 0x30000000
34009b50:	d111      	bne.n	34009b76 <HAL_RCC_OscConfig+0x6da>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34009b52:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009b56:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
34009b5a:	f43f aca3 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34009b5e:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
34009b62:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
34009b66:	f43f ac9d 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34009b6a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
34009b6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009b72:	f43f ac97 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
34009b76:	2003      	movs	r0, #3
34009b78:	f7ff fb1c 	bl	340091b4 <RCC_PLL_Config>
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34009b7c:	3800      	subs	r0, #0
34009b7e:	bf18      	it	ne
34009b80:	2001      	movne	r0, #1
34009b82:	e490      	b.n	340094a6 <HAL_RCC_OscConfig+0xa>
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
34009b84:	2f02      	cmp	r7, #2
34009b86:	f47f ad17 	bne.w	340095b8 <HAL_RCC_OscConfig+0x11c>
34009b8a:	0513      	lsls	r3, r2, #20
34009b8c:	f53f ad14 	bmi.w	340095b8 <HAL_RCC_OscConfig+0x11c>
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
34009b90:	2003      	movs	r0, #3
34009b92:	f7ff faf7 	bl	34009184 <RCC_PLL_Enable>
34009b96:	e7f1      	b.n	34009b7c <HAL_RCC_OscConfig+0x6e0>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
34009b98:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
34009b9c:	f43f ac82 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
34009ba0:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
34009ba4:	f47f ae09 	bne.w	340097ba <HAL_RCC_OscConfig+0x31e>
34009ba8:	e47c      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
34009baa:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
34009bae:	f43f acbb 	beq.w	34009528 <HAL_RCC_OscConfig+0x8c>
34009bb2:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
34009bb6:	f47f ae00 	bne.w	340097ba <HAL_RCC_OscConfig+0x31e>
34009bba:	e4b5      	b.n	34009528 <HAL_RCC_OscConfig+0x8c>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34009bbc:	2e00      	cmp	r6, #0
34009bbe:	f43f ac71 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
34009bc2:	2d00      	cmp	r5, #0
34009bc4:	f47f adaa 	bne.w	3400971c <HAL_RCC_OscConfig+0x280>
34009bc8:	e46c      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
34009bca:	2e00      	cmp	r6, #0
34009bcc:	f43f ad7b 	beq.w	340096c6 <HAL_RCC_OscConfig+0x22a>
34009bd0:	2d00      	cmp	r5, #0
34009bd2:	f43f ad78 	beq.w	340096c6 <HAL_RCC_OscConfig+0x22a>
34009bd6:	e5a1      	b.n	3400971c <HAL_RCC_OscConfig+0x280>
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34009bd8:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
34009bdc:	f43f ac8a 	beq.w	340094f4 <HAL_RCC_OscConfig+0x58>
34009be0:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
34009be4:	f47f ad06 	bne.w	340095f4 <HAL_RCC_OscConfig+0x158>
34009be8:	e484      	b.n	340094f4 <HAL_RCC_OscConfig+0x58>
34009bea:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
34009bee:	f43f ac59 	beq.w	340094a4 <HAL_RCC_OscConfig+0x8>
34009bf2:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
34009bf6:	f47f acfd 	bne.w	340095f4 <HAL_RCC_OscConfig+0x158>
34009bfa:	e453      	b.n	340094a4 <HAL_RCC_OscConfig+0x8>
34009bfc:	56028000 	.word	0x56028000

34009c00 <HAL_RCC_GetCpuClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34009c00:	4b1f      	ldr	r3, [pc, #124]	@ (34009c80 <HAL_RCC_GetCpuClockFreq+0x80>)
{
34009c02:	b510      	push	{r4, lr}
34009c04:	6a1a      	ldr	r2, [r3, #32]
34009c06:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
  switch (LL_RCC_GetCpuClkSource())
34009c0a:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
34009c0e:	d034      	beq.n	34009c7a <HAL_RCC_GetCpuClockFreq+0x7a>
34009c10:	d806      	bhi.n	34009c20 <HAL_RCC_GetCpuClockFreq+0x20>
34009c12:	b952      	cbnz	r2, 34009c2a <HAL_RCC_GetCpuClockFreq+0x2a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
34009c14:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009c16:	481b      	ldr	r0, [pc, #108]	@ (34009c84 <HAL_RCC_GetCpuClockFreq+0x84>)
34009c18:	f3c3 13c1 	ubfx	r3, r3, #7, #2
34009c1c:	40d8      	lsrs	r0, r3
}
34009c1e:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetCpuClkSource())
34009c20:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
34009c24:	d009      	beq.n	34009c3a <HAL_RCC_GetCpuClockFreq+0x3a>
      switch (LL_RCC_IC1_GetSource())
34009c26:	2000      	movs	r0, #0
34009c28:	e7f9      	b.n	34009c1e <HAL_RCC_GetCpuClockFreq+0x1e>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
34009c2a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        frequency = MSI_VALUE;
34009c2c:	4816      	ldr	r0, [pc, #88]	@ (34009c88 <HAL_RCC_GetCpuClockFreq+0x88>)
34009c2e:	f413 7f00 	tst.w	r3, #512	@ 0x200
34009c32:	4b16      	ldr	r3, [pc, #88]	@ (34009c8c <HAL_RCC_GetCpuClockFreq+0x8c>)
34009c34:	bf08      	it	eq
34009c36:	4618      	moveq	r0, r3
34009c38:	e7f1      	b.n	34009c1e <HAL_RCC_GetCpuClockFreq+0x1e>
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34009c3a:	f8d3 00c4 	ldr.w	r0, [r3, #196]	@ 0xc4
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009c3e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34009c42:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009c46:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
      switch (LL_RCC_IC1_GetSource())
34009c4a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34009c4e:	f100 0401 	add.w	r4, r0, #1
34009c52:	d00f      	beq.n	34009c74 <HAL_RCC_GetCpuClockFreq+0x74>
34009c54:	d805      	bhi.n	34009c62 <HAL_RCC_GetCpuClockFreq+0x62>
34009c56:	b953      	cbnz	r3, 34009c6e <HAL_RCC_GetCpuClockFreq+0x6e>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009c58:	f003 fbba 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / ic_divider;
34009c5c:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
34009c60:	e7dd      	b.n	34009c1e <HAL_RCC_GetCpuClockFreq+0x1e>
      switch (LL_RCC_IC1_GetSource())
34009c62:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009c66:	d1de      	bne.n	34009c26 <HAL_RCC_GetCpuClockFreq+0x26>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009c68:	f003 fc72 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
34009c6c:	e7f6      	b.n	34009c5c <HAL_RCC_GetCpuClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009c6e:	f003 fbef 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
34009c72:	e7f3      	b.n	34009c5c <HAL_RCC_GetCpuClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009c74:	f003 fc2c 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
34009c78:	e7f0      	b.n	34009c5c <HAL_RCC_GetCpuClockFreq+0x5c>
  switch (LL_RCC_GetCpuClkSource())
34009c7a:	4805      	ldr	r0, [pc, #20]	@ (34009c90 <HAL_RCC_GetCpuClockFreq+0x90>)
34009c7c:	e7cf      	b.n	34009c1e <HAL_RCC_GetCpuClockFreq+0x1e>
34009c7e:	bf00      	nop
34009c80:	56028000 	.word	0x56028000
34009c84:	03d09000 	.word	0x03d09000
34009c88:	00f42400 	.word	0x00f42400
34009c8c:	003d0900 	.word	0x003d0900
34009c90:	02dc6c00 	.word	0x02dc6c00

34009c94 <HAL_RCC_ClockConfig>:
{
34009c94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (pRCC_ClkInitStruct == NULL)
34009c98:	4604      	mov	r4, r0
34009c9a:	b910      	cbnz	r0, 34009ca2 <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
34009c9c:	2001      	movs	r0, #1
}
34009c9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));
34009ca2:	6803      	ldr	r3, [r0, #0]
34009ca4:	2b7f      	cmp	r3, #127	@ 0x7f
34009ca6:	d904      	bls.n	34009cb2 <HAL_RCC_ClockConfig+0x1e>
34009ca8:	f44f 715f 	mov.w	r1, #892	@ 0x37c
34009cac:	4893      	ldr	r0, [pc, #588]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009cae:	f7f8 fc45 	bl	3400253c <assert_failed>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34009cb2:	6823      	ldr	r3, [r4, #0]
34009cb4:	071f      	lsls	r7, r3, #28
34009cb6:	d513      	bpl.n	34009ce0 <HAL_RCC_ClockConfig+0x4c>
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
34009cb8:	6923      	ldr	r3, [r4, #16]
34009cba:	2b07      	cmp	r3, #7
34009cbc:	d904      	bls.n	34009cc8 <HAL_RCC_ClockConfig+0x34>
34009cbe:	f240 3183 	movw	r1, #899	@ 0x383
34009cc2:	488e      	ldr	r0, [pc, #568]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009cc4:	f7f8 fc3a 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34009cc8:	4a8d      	ldr	r2, [pc, #564]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009cca:	6921      	ldr	r1, [r4, #16]
34009ccc:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009cce:	f003 0307 	and.w	r3, r3, #7
34009cd2:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34009cd4:	bf81      	itttt	hi
34009cd6:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009cd8:	f023 0307 	bichi.w	r3, r3, #7
34009cdc:	430b      	orrhi	r3, r1
34009cde:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34009ce0:	6823      	ldr	r3, [r4, #0]
34009ce2:	06de      	lsls	r6, r3, #27
34009ce4:	d516      	bpl.n	34009d14 <HAL_RCC_ClockConfig+0x80>
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
34009ce6:	6963      	ldr	r3, [r4, #20]
34009ce8:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34009cec:	d006      	beq.n	34009cfc <HAL_RCC_ClockConfig+0x68>
34009cee:	2b40      	cmp	r3, #64	@ 0x40
34009cf0:	d004      	beq.n	34009cfc <HAL_RCC_ClockConfig+0x68>
34009cf2:	f240 318d 	movw	r1, #909	@ 0x38d
34009cf6:	4881      	ldr	r0, [pc, #516]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009cf8:	f7f8 fc20 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34009cfc:	4a80      	ldr	r2, [pc, #512]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009cfe:	6961      	ldr	r1, [r4, #20]
34009d00:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009d02:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34009d06:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34009d08:	bf81      	itttt	hi
34009d0a:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009d0c:	f023 0370 	bichi.w	r3, r3, #112	@ 0x70
34009d10:	430b      	orrhi	r3, r1
34009d12:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34009d14:	6823      	ldr	r3, [r4, #0]
34009d16:	069d      	lsls	r5, r3, #26
34009d18:	d517      	bpl.n	34009d4a <HAL_RCC_ClockConfig+0xb6>
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
34009d1a:	69a3      	ldr	r3, [r4, #24]
34009d1c:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
34009d20:	d007      	beq.n	34009d32 <HAL_RCC_ClockConfig+0x9e>
34009d22:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34009d26:	d004      	beq.n	34009d32 <HAL_RCC_ClockConfig+0x9e>
34009d28:	f240 3197 	movw	r1, #919	@ 0x397
34009d2c:	4873      	ldr	r0, [pc, #460]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009d2e:	f7f8 fc05 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34009d32:	4a73      	ldr	r2, [pc, #460]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009d34:	69a1      	ldr	r1, [r4, #24]
34009d36:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009d38:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34009d3c:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34009d3e:	bf81      	itttt	hi
34009d40:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009d42:	f423 43e0 	bichi.w	r3, r3, #28672	@ 0x7000
34009d46:	430b      	orrhi	r3, r1
34009d48:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34009d4a:	6823      	ldr	r3, [r4, #0]
34009d4c:	0658      	lsls	r0, r3, #25
34009d4e:	d517      	bpl.n	34009d80 <HAL_RCC_ClockConfig+0xec>
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
34009d50:	69e3      	ldr	r3, [r4, #28]
34009d52:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34009d56:	d007      	beq.n	34009d68 <HAL_RCC_ClockConfig+0xd4>
34009d58:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009d5c:	d004      	beq.n	34009d68 <HAL_RCC_ClockConfig+0xd4>
34009d5e:	f240 31a1 	movw	r1, #929	@ 0x3a1
34009d62:	4866      	ldr	r0, [pc, #408]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009d64:	f7f8 fbea 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34009d68:	4a65      	ldr	r2, [pc, #404]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009d6a:	69e1      	ldr	r1, [r4, #28]
34009d6c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009d6e:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34009d72:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34009d74:	bf81      	itttt	hi
34009d76:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009d78:	f423 23e0 	bichi.w	r3, r3, #458752	@ 0x70000
34009d7c:	430b      	orrhi	r3, r1
34009d7e:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34009d80:	6823      	ldr	r3, [r4, #0]
34009d82:	0759      	lsls	r1, r3, #29
34009d84:	d517      	bpl.n	34009db6 <HAL_RCC_ClockConfig+0x122>
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
34009d86:	68e3      	ldr	r3, [r4, #12]
34009d88:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
34009d8c:	d007      	beq.n	34009d9e <HAL_RCC_ClockConfig+0x10a>
34009d8e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34009d92:	d004      	beq.n	34009d9e <HAL_RCC_ClockConfig+0x10a>
34009d94:	f240 31ab 	movw	r1, #939	@ 0x3ab
34009d98:	4858      	ldr	r0, [pc, #352]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009d9a:	f7f8 fbcf 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
34009d9e:	4a58      	ldr	r2, [pc, #352]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009da0:	68e1      	ldr	r1, [r4, #12]
34009da2:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009da4:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
34009da8:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
34009daa:	bf81      	itttt	hi
34009dac:	6a53      	ldrhi	r3, [r2, #36]	@ 0x24
34009dae:	f423 03e0 	bichi.w	r3, r3, #7340032	@ 0x700000
34009db2:	430b      	orrhi	r3, r1
34009db4:	6253      	strhi	r3, [r2, #36]	@ 0x24
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
34009db6:	6823      	ldr	r3, [r4, #0]
34009db8:	07da      	lsls	r2, r3, #31
34009dba:	d52a      	bpl.n	34009e12 <HAL_RCC_ClockConfig+0x17e>
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));
34009dbc:	6863      	ldr	r3, [r4, #4]
34009dbe:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34009dc2:	d004      	beq.n	34009dce <HAL_RCC_ClockConfig+0x13a>
34009dc4:	f240 31b6 	movw	r1, #950	@ 0x3b6
34009dc8:	484c      	ldr	r0, [pc, #304]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009dca:	f7f8 fbb7 	bl	3400253c <assert_failed>
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
34009dce:	6863      	ldr	r3, [r4, #4]
34009dd0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34009dd4:	f040 809a 	bne.w	34009f0c <HAL_RCC_ClockConfig+0x278>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009dd8:	4b49      	ldr	r3, [pc, #292]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009dda:	685b      	ldr	r3, [r3, #4]
34009ddc:	06db      	lsls	r3, r3, #27
34009dde:	f57f af5d 	bpl.w	34009c9c <HAL_RCC_ClockConfig+0x8>
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34009de2:	4d47      	ldr	r5, [pc, #284]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009de4:	6862      	ldr	r2, [r4, #4]
34009de6:	6a2b      	ldr	r3, [r5, #32]
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009de8:	f241 3788 	movw	r7, #5000	@ 0x1388
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
34009dec:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
34009df0:	4313      	orrs	r3, r2
34009df2:	622b      	str	r3, [r5, #32]
    tickstart = HAL_GetTick();
34009df4:	f7fa fd7c 	bl	340048f0 <HAL_GetTick>
34009df8:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34009dfa:	6a2b      	ldr	r3, [r5, #32]
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
34009dfc:	6862      	ldr	r2, [r4, #4]
34009dfe:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34009e02:	ebb3 1f02 	cmp.w	r3, r2, lsl #4
34009e06:	f040 80b7 	bne.w	34009f78 <HAL_RCC_ClockConfig+0x2e4>
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
34009e0a:	f7ff fef9 	bl	34009c00 <HAL_RCC_GetCpuClockFreq>
34009e0e:	4b3d      	ldr	r3, [pc, #244]	@ (34009f04 <HAL_RCC_ClockConfig+0x270>)
34009e10:	6018      	str	r0, [r3, #0]
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
34009e12:	6823      	ldr	r3, [r4, #0]
34009e14:	079f      	lsls	r7, r3, #30
34009e16:	f100 80b7 	bmi.w	34009f88 <HAL_RCC_ClockConfig+0x2f4>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
34009e1a:	6823      	ldr	r3, [r4, #0]
34009e1c:	075e      	lsls	r6, r3, #29
34009e1e:	f100 815c 	bmi.w	3400a0da <HAL_RCC_ClockConfig+0x446>
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
34009e22:	6823      	ldr	r3, [r4, #0]
34009e24:	0718      	lsls	r0, r3, #28
34009e26:	d513      	bpl.n	34009e50 <HAL_RCC_ClockConfig+0x1bc>
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
34009e28:	6923      	ldr	r3, [r4, #16]
34009e2a:	2b07      	cmp	r3, #7
34009e2c:	d904      	bls.n	34009e38 <HAL_RCC_ClockConfig+0x1a4>
34009e2e:	f240 4161 	movw	r1, #1121	@ 0x461
34009e32:	4832      	ldr	r0, [pc, #200]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009e34:	f7f8 fb82 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
34009e38:	4a31      	ldr	r2, [pc, #196]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009e3a:	6921      	ldr	r1, [r4, #16]
34009e3c:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009e3e:	f003 0307 	and.w	r3, r3, #7
34009e42:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
34009e44:	bf3f      	itttt	cc
34009e46:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009e48:	f023 0307 	biccc.w	r3, r3, #7
34009e4c:	430b      	orrcc	r3, r1
34009e4e:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
34009e50:	6823      	ldr	r3, [r4, #0]
34009e52:	06d9      	lsls	r1, r3, #27
34009e54:	d516      	bpl.n	34009e84 <HAL_RCC_ClockConfig+0x1f0>
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
34009e56:	6963      	ldr	r3, [r4, #20]
34009e58:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34009e5c:	d006      	beq.n	34009e6c <HAL_RCC_ClockConfig+0x1d8>
34009e5e:	2b40      	cmp	r3, #64	@ 0x40
34009e60:	d004      	beq.n	34009e6c <HAL_RCC_ClockConfig+0x1d8>
34009e62:	f240 416b 	movw	r1, #1131	@ 0x46b
34009e66:	4825      	ldr	r0, [pc, #148]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009e68:	f7f8 fb68 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
34009e6c:	4a24      	ldr	r2, [pc, #144]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009e6e:	6961      	ldr	r1, [r4, #20]
34009e70:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009e72:	f003 0370 	and.w	r3, r3, #112	@ 0x70
34009e76:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
34009e78:	bf3f      	itttt	cc
34009e7a:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009e7c:	f023 0370 	biccc.w	r3, r3, #112	@ 0x70
34009e80:	430b      	orrcc	r3, r1
34009e82:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
34009e84:	6823      	ldr	r3, [r4, #0]
34009e86:	069a      	lsls	r2, r3, #26
34009e88:	d517      	bpl.n	34009eba <HAL_RCC_ClockConfig+0x226>
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
34009e8a:	69a3      	ldr	r3, [r4, #24]
34009e8c:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
34009e90:	d007      	beq.n	34009ea2 <HAL_RCC_ClockConfig+0x20e>
34009e92:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34009e96:	d004      	beq.n	34009ea2 <HAL_RCC_ClockConfig+0x20e>
34009e98:	f240 4175 	movw	r1, #1141	@ 0x475
34009e9c:	4817      	ldr	r0, [pc, #92]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009e9e:	f7f8 fb4d 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
34009ea2:	4a17      	ldr	r2, [pc, #92]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009ea4:	69a1      	ldr	r1, [r4, #24]
34009ea6:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009ea8:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
34009eac:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
34009eae:	bf3f      	itttt	cc
34009eb0:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009eb2:	f423 43e0 	biccc.w	r3, r3, #28672	@ 0x7000
34009eb6:	430b      	orrcc	r3, r1
34009eb8:	6253      	strcc	r3, [r2, #36]	@ 0x24
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
34009eba:	6823      	ldr	r3, [r4, #0]
34009ebc:	065b      	lsls	r3, r3, #25
34009ebe:	d517      	bpl.n	34009ef0 <HAL_RCC_ClockConfig+0x25c>
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
34009ec0:	69e3      	ldr	r3, [r4, #28]
34009ec2:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
34009ec6:	d007      	beq.n	34009ed8 <HAL_RCC_ClockConfig+0x244>
34009ec8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009ecc:	d004      	beq.n	34009ed8 <HAL_RCC_ClockConfig+0x244>
34009ece:	f240 417f 	movw	r1, #1151	@ 0x47f
34009ed2:	480a      	ldr	r0, [pc, #40]	@ (34009efc <HAL_RCC_ClockConfig+0x268>)
34009ed4:	f7f8 fb32 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
34009ed8:	4a09      	ldr	r2, [pc, #36]	@ (34009f00 <HAL_RCC_ClockConfig+0x26c>)
34009eda:	69e1      	ldr	r1, [r4, #28]
34009edc:	6a53      	ldr	r3, [r2, #36]	@ 0x24
34009ede:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
34009ee2:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
34009ee4:	bf3f      	itttt	cc
34009ee6:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
34009ee8:	f423 23e0 	biccc.w	r3, r3, #458752	@ 0x70000
34009eec:	430b      	orrcc	r3, r1
34009eee:	6253      	strcc	r3, [r2, #36]	@ 0x24
  return HAL_InitTick(uwTickPrio);
34009ef0:	4b05      	ldr	r3, [pc, #20]	@ (34009f08 <HAL_RCC_ClockConfig+0x274>)
}
34009ef2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
34009ef6:	6818      	ldr	r0, [r3, #0]
34009ef8:	f7fa bcb6 	b.w	34004868 <HAL_InitTick>
34009efc:	3401c766 	.word	0x3401c766
34009f00:	56028000 	.word	0x56028000
34009f04:	3403edcc 	.word	0x3403edcc
34009f08:	3403edd4 	.word	0x3403edd4
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
34009f0c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34009f10:	d126      	bne.n	34009f60 <HAL_RCC_ClockConfig+0x2cc>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
34009f12:	6a23      	ldr	r3, [r4, #32]
34009f14:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009f18:	d004      	beq.n	34009f24 <HAL_RCC_ClockConfig+0x290>
34009f1a:	f240 31c5 	movw	r1, #965	@ 0x3c5
34009f1e:	487b      	ldr	r0, [pc, #492]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
34009f20:	f7f8 fb0c 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));
34009f24:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009f26:	3b01      	subs	r3, #1
34009f28:	2bff      	cmp	r3, #255	@ 0xff
34009f2a:	d904      	bls.n	34009f36 <HAL_RCC_ClockConfig+0x2a2>
34009f2c:	f240 31c6 	movw	r1, #966	@ 0x3c6
34009f30:	4876      	ldr	r0, [pc, #472]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
34009f32:	f7f8 fb03 	bl	3400253c <assert_failed>
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34009f36:	4e76      	ldr	r6, [pc, #472]	@ (3400a110 <HAL_RCC_ClockConfig+0x47c>)
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
34009f38:	6a25      	ldr	r5, [r4, #32]
34009f3a:	f8d6 00c4 	ldr.w	r0, [r6, #196]	@ 0xc4
34009f3e:	4629      	mov	r1, r5
34009f40:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
34009f44:	f7ff fa52 	bl	340093ec <RCC_IC_CheckPLLSources>
34009f48:	2801      	cmp	r0, #1
34009f4a:	f47f aea7 	bne.w	34009c9c <HAL_RCC_ClockConfig+0x8>
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
34009f4e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34009f50:	3b01      	subs	r3, #1
34009f52:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
34009f56:	f8c6 50c4 	str.w	r5, [r6, #196]	@ 0xc4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34009f5a:	f8c6 0a40 	str.w	r0, [r6, #2624]	@ 0xa40
}
34009f5e:	e740      	b.n	34009de2 <HAL_RCC_ClockConfig+0x14e>
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
34009f60:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34009f64:	d105      	bne.n	34009f72 <HAL_RCC_ClockConfig+0x2de>
      if (LL_RCC_MSI_IsReady() == 0U)
34009f66:	f7ff f8bb 	bl	340090e0 <LL_RCC_MSI_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
34009f6a:	2800      	cmp	r0, #0
34009f6c:	f47f af39 	bne.w	34009de2 <HAL_RCC_ClockConfig+0x14e>
34009f70:	e694      	b.n	34009c9c <HAL_RCC_ClockConfig+0x8>
34009f72:	f7ff f8ad 	bl	340090d0 <LL_RCC_HSI_IsReady>
34009f76:	e7f8      	b.n	34009f6a <HAL_RCC_ClockConfig+0x2d6>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009f78:	f7fa fcba 	bl	340048f0 <HAL_GetTick>
34009f7c:	1b80      	subs	r0, r0, r6
34009f7e:	42b8      	cmp	r0, r7
34009f80:	f67f af3b 	bls.w	34009dfa <HAL_RCC_ClockConfig+0x166>
        return HAL_TIMEOUT;
34009f84:	2003      	movs	r0, #3
34009f86:	e68a      	b.n	34009c9e <HAL_RCC_ClockConfig+0xa>
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
34009f88:	68a3      	ldr	r3, [r4, #8]
34009f8a:	f033 7340 	bics.w	r3, r3, #50331648	@ 0x3000000
34009f8e:	d004      	beq.n	34009f9a <HAL_RCC_ClockConfig+0x306>
34009f90:	f240 31ff 	movw	r1, #1023	@ 0x3ff
34009f94:	485d      	ldr	r0, [pc, #372]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
34009f96:	f7f8 fad1 	bl	3400253c <assert_failed>
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
34009f9a:	68a3      	ldr	r3, [r4, #8]
34009f9c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34009fa0:	d11e      	bne.n	34009fe0 <HAL_RCC_ClockConfig+0x34c>
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34009fa2:	4b5b      	ldr	r3, [pc, #364]	@ (3400a110 <HAL_RCC_ClockConfig+0x47c>)
34009fa4:	685b      	ldr	r3, [r3, #4]
34009fa6:	06dd      	lsls	r5, r3, #27
34009fa8:	f57f ae78 	bpl.w	34009c9c <HAL_RCC_ClockConfig+0x8>
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34009fac:	4d58      	ldr	r5, [pc, #352]	@ (3400a110 <HAL_RCC_ClockConfig+0x47c>)
34009fae:	68a2      	ldr	r2, [r4, #8]
34009fb0:	6a2b      	ldr	r3, [r5, #32]
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009fb2:	f241 3788 	movw	r7, #5000	@ 0x1388
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
34009fb6:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
34009fba:	4313      	orrs	r3, r2
34009fbc:	622b      	str	r3, [r5, #32]
    tickstart = HAL_GetTick();
34009fbe:	f7fa fc97 	bl	340048f0 <HAL_GetTick>
34009fc2:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34009fc4:	6a2b      	ldr	r3, [r5, #32]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
34009fc6:	68a2      	ldr	r2, [r4, #8]
34009fc8:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34009fcc:	ebb3 1f02 	cmp.w	r3, r2, lsl #4
34009fd0:	f43f af23 	beq.w	34009e1a <HAL_RCC_ClockConfig+0x186>
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
34009fd4:	f7fa fc8c 	bl	340048f0 <HAL_GetTick>
34009fd8:	1b80      	subs	r0, r0, r6
34009fda:	42b8      	cmp	r0, r7
34009fdc:	d9f2      	bls.n	34009fc4 <HAL_RCC_ClockConfig+0x330>
34009fde:	e7d1      	b.n	34009f84 <HAL_RCC_ClockConfig+0x2f0>
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
34009fe0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34009fe4:	d16f      	bne.n	3400a0c6 <HAL_RCC_ClockConfig+0x432>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC2Selection.ClockSelection));
34009fe6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34009fe8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
34009fec:	d004      	beq.n	34009ff8 <HAL_RCC_ClockConfig+0x364>
34009fee:	f240 410e 	movw	r1, #1038	@ 0x40e
34009ff2:	4846      	ldr	r0, [pc, #280]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
34009ff4:	f7f8 faa2 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC2Selection.ClockDivider));
34009ff8:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34009ffa:	3b01      	subs	r3, #1
34009ffc:	2bff      	cmp	r3, #255	@ 0xff
34009ffe:	d904      	bls.n	3400a00a <HAL_RCC_ClockConfig+0x376>
3400a000:	f240 410f 	movw	r1, #1039	@ 0x40f
3400a004:	4841      	ldr	r0, [pc, #260]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
3400a006:	f7f8 fa99 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC6Selection.ClockSelection));
3400a00a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400a00c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a010:	d004      	beq.n	3400a01c <HAL_RCC_ClockConfig+0x388>
3400a012:	f44f 6182 	mov.w	r1, #1040	@ 0x410
3400a016:	483d      	ldr	r0, [pc, #244]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
3400a018:	f7f8 fa90 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC6Selection.ClockDivider));
3400a01c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400a01e:	3b01      	subs	r3, #1
3400a020:	2bff      	cmp	r3, #255	@ 0xff
3400a022:	d904      	bls.n	3400a02e <HAL_RCC_ClockConfig+0x39a>
3400a024:	f240 4111 	movw	r1, #1041	@ 0x411
3400a028:	4838      	ldr	r0, [pc, #224]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
3400a02a:	f7f8 fa87 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
3400a02e:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400a030:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a034:	d004      	beq.n	3400a040 <HAL_RCC_ClockConfig+0x3ac>
3400a036:	f240 4112 	movw	r1, #1042	@ 0x412
3400a03a:	4834      	ldr	r0, [pc, #208]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
3400a03c:	f7f8 fa7e 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));
3400a040:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a042:	3b01      	subs	r3, #1
3400a044:	2bff      	cmp	r3, #255	@ 0xff
3400a046:	d904      	bls.n	3400a052 <HAL_RCC_ClockConfig+0x3be>
3400a048:	f240 4113 	movw	r1, #1043	@ 0x413
3400a04c:	482f      	ldr	r0, [pc, #188]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
3400a04e:	f7f8 fa75 	bl	3400253c <assert_failed>
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a052:	4d2f      	ldr	r5, [pc, #188]	@ (3400a110 <HAL_RCC_ClockConfig+0x47c>)
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3400a054:	f8d4 8028 	ldr.w	r8, [r4, #40]	@ 0x28
3400a058:	f8d5 00c8 	ldr.w	r0, [r5, #200]	@ 0xc8
3400a05c:	4641      	mov	r1, r8
3400a05e:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a062:	f7ff f9c3 	bl	340093ec <RCC_IC_CheckPLLSources>
3400a066:	2801      	cmp	r0, #1
3400a068:	f47f ae18 	bne.w	34009c9c <HAL_RCC_ClockConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400a06c:	f8d5 00d8 	ldr.w	r0, [r5, #216]	@ 0xd8
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3400a070:	6b27      	ldr	r7, [r4, #48]	@ 0x30
3400a072:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a076:	4639      	mov	r1, r7
3400a078:	f7ff f9b8 	bl	340093ec <RCC_IC_CheckPLLSources>
3400a07c:	2801      	cmp	r0, #1
3400a07e:	f47f ae0d 	bne.w	34009c9c <HAL_RCC_ClockConfig+0x8>
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400a082:	f8d5 00ec 	ldr.w	r0, [r5, #236]	@ 0xec
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3400a086:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
3400a088:	f000 5040 	and.w	r0, r0, #805306368	@ 0x30000000
3400a08c:	4631      	mov	r1, r6
3400a08e:	f7ff f9ad 	bl	340093ec <RCC_IC_CheckPLLSources>
3400a092:	2801      	cmp	r0, #1
3400a094:	f47f ae02 	bne.w	34009c9c <HAL_RCC_ClockConfig+0x8>
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3400a098:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400a09a:	3b01      	subs	r3, #1
3400a09c:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
3400a0a0:	f8c5 30c8 	str.w	r3, [r5, #200]	@ 0xc8
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3400a0a4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400a0a6:	3b01      	subs	r3, #1
3400a0a8:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
3400a0ac:	f8c5 70d8 	str.w	r7, [r5, #216]	@ 0xd8
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3400a0b0:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a0b2:	3b01      	subs	r3, #1
3400a0b4:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3400a0b8:	f240 4322 	movw	r3, #1058	@ 0x422
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3400a0bc:	f8c5 60ec 	str.w	r6, [r5, #236]	@ 0xec
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3400a0c0:	f8c5 3a40 	str.w	r3, [r5, #2624]	@ 0xa40
3400a0c4:	e772      	b.n	34009fac <HAL_RCC_ClockConfig+0x318>
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3400a0c6:	b92b      	cbnz	r3, 3400a0d4 <HAL_RCC_ClockConfig+0x440>
      if (LL_RCC_HSI_IsReady() == 0U)
3400a0c8:	f7ff f802 	bl	340090d0 <LL_RCC_HSI_IsReady>
      if (LL_RCC_MSI_IsReady() == 0U)
3400a0cc:	2800      	cmp	r0, #0
3400a0ce:	f47f af6d 	bne.w	34009fac <HAL_RCC_ClockConfig+0x318>
3400a0d2:	e5e3      	b.n	34009c9c <HAL_RCC_ClockConfig+0x8>
3400a0d4:	f7ff f804 	bl	340090e0 <LL_RCC_MSI_IsReady>
3400a0d8:	e7f8      	b.n	3400a0cc <HAL_RCC_ClockConfig+0x438>
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
3400a0da:	68e3      	ldr	r3, [r4, #12]
3400a0dc:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400a0e0:	d007      	beq.n	3400a0f2 <HAL_RCC_ClockConfig+0x45e>
3400a0e2:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
3400a0e6:	d004      	beq.n	3400a0f2 <HAL_RCC_ClockConfig+0x45e>
3400a0e8:	f240 4156 	movw	r1, #1110	@ 0x456
3400a0ec:	4807      	ldr	r0, [pc, #28]	@ (3400a10c <HAL_RCC_ClockConfig+0x478>)
3400a0ee:	f7f8 fa25 	bl	3400253c <assert_failed>
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400a0f2:	4a07      	ldr	r2, [pc, #28]	@ (3400a110 <HAL_RCC_ClockConfig+0x47c>)
3400a0f4:	68e1      	ldr	r1, [r4, #12]
3400a0f6:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400a0f8:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400a0fc:	4299      	cmp	r1, r3
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400a0fe:	bf3f      	itttt	cc
3400a100:	6a53      	ldrcc	r3, [r2, #36]	@ 0x24
3400a102:	f423 03e0 	biccc.w	r3, r3, #7340032	@ 0x700000
3400a106:	430b      	orrcc	r3, r1
3400a108:	6253      	strcc	r3, [r2, #36]	@ 0x24
3400a10a:	e68a      	b.n	34009e22 <HAL_RCC_ClockConfig+0x18e>
3400a10c:	3401c766 	.word	0x3401c766
3400a110:	56028000 	.word	0x56028000

3400a114 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3400a114:	4b1f      	ldr	r3, [pc, #124]	@ (3400a194 <HAL_RCC_GetSysClockFreq+0x80>)
{
3400a116:	b510      	push	{r4, lr}
3400a118:	6a1a      	ldr	r2, [r3, #32]
3400a11a:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
  switch (LL_RCC_GetSysClkSource())
3400a11e:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
3400a122:	d034      	beq.n	3400a18e <HAL_RCC_GetSysClockFreq+0x7a>
3400a124:	d806      	bhi.n	3400a134 <HAL_RCC_GetSysClockFreq+0x20>
3400a126:	b952      	cbnz	r2, 3400a13e <HAL_RCC_GetSysClockFreq+0x2a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400a128:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a12a:	481b      	ldr	r0, [pc, #108]	@ (3400a198 <HAL_RCC_GetSysClockFreq+0x84>)
3400a12c:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400a130:	40d8      	lsrs	r0, r3
}
3400a132:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSysClkSource())
3400a134:	f1b2 5f40 	cmp.w	r2, #805306368	@ 0x30000000
3400a138:	d009      	beq.n	3400a14e <HAL_RCC_GetSysClockFreq+0x3a>
      switch (LL_RCC_IC2_GetSource())
3400a13a:	2000      	movs	r0, #0
3400a13c:	e7f9      	b.n	3400a132 <HAL_RCC_GetSysClockFreq+0x1e>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400a13e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        frequency = MSI_VALUE;
3400a140:	4816      	ldr	r0, [pc, #88]	@ (3400a19c <HAL_RCC_GetSysClockFreq+0x88>)
3400a142:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400a146:	4b16      	ldr	r3, [pc, #88]	@ (3400a1a0 <HAL_RCC_GetSysClockFreq+0x8c>)
3400a148:	bf08      	it	eq
3400a14a:	4618      	moveq	r0, r3
3400a14c:	e7f1      	b.n	3400a132 <HAL_RCC_GetSysClockFreq+0x1e>
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a14e:	f8d3 00c8 	ldr.w	r0, [r3, #200]	@ 0xc8
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a152:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a156:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400a15a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
      switch (LL_RCC_IC2_GetSource())
3400a15e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400a162:	f100 0401 	add.w	r4, r0, #1
3400a166:	d00f      	beq.n	3400a188 <HAL_RCC_GetSysClockFreq+0x74>
3400a168:	d805      	bhi.n	3400a176 <HAL_RCC_GetSysClockFreq+0x62>
3400a16a:	b953      	cbnz	r3, 3400a182 <HAL_RCC_GetSysClockFreq+0x6e>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a16c:	f003 f930 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
          frequency = frequency / ic_divider;
3400a170:	fbb0 f0f4 	udiv	r0, r0, r4
          break;
3400a174:	e7dd      	b.n	3400a132 <HAL_RCC_GetSysClockFreq+0x1e>
      switch (LL_RCC_IC2_GetSource())
3400a176:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a17a:	d1de      	bne.n	3400a13a <HAL_RCC_GetSysClockFreq+0x26>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a17c:	f003 f9e8 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400a180:	e7f6      	b.n	3400a170 <HAL_RCC_GetSysClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a182:	f003 f965 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400a186:	e7f3      	b.n	3400a170 <HAL_RCC_GetSysClockFreq+0x5c>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a188:	f003 f9a2 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400a18c:	e7f0      	b.n	3400a170 <HAL_RCC_GetSysClockFreq+0x5c>
  switch (LL_RCC_GetSysClkSource())
3400a18e:	4805      	ldr	r0, [pc, #20]	@ (3400a1a4 <HAL_RCC_GetSysClockFreq+0x90>)
3400a190:	e7cf      	b.n	3400a132 <HAL_RCC_GetSysClockFreq+0x1e>
3400a192:	bf00      	nop
3400a194:	56028000 	.word	0x56028000
3400a198:	03d09000 	.word	0x03d09000
3400a19c:	00f42400 	.word	0x00f42400
3400a1a0:	003d0900 	.word	0x003d0900
3400a1a4:	02dc6c00 	.word	0x02dc6c00

3400a1a8 <HAL_RCC_GetPCLK1Freq>:
{
3400a1a8:	b508      	push	{r3, lr}
  return LL_RCC_CALC_PCLK1_FREQ(LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()),
3400a1aa:	f7ff ffb3 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400a1ae:	4b05      	ldr	r3, [pc, #20]	@ (3400a1c4 <HAL_RCC_GetPCLK1Freq+0x1c>)
3400a1b0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400a1b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400a1b4:	f3c2 5202 	ubfx	r2, r2, #20, #3
3400a1b8:	40d0      	lsrs	r0, r2
3400a1ba:	f003 0307 	and.w	r3, r3, #7
}
3400a1be:	40d8      	lsrs	r0, r3
3400a1c0:	bd08      	pop	{r3, pc}
3400a1c2:	bf00      	nop
3400a1c4:	56028000 	.word	0x56028000

3400a1c8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400a1c8:	4a02      	ldr	r2, [pc, #8]	@ (3400a1d4 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0xc>)
3400a1ca:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3400a1cc:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400a1d0:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400a1d2:	4770      	bx	lr
3400a1d4:	56028000 	.word	0x56028000

3400a1d8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400a1d8:	4a02      	ldr	r2, [pc, #8]	@ (3400a1e4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0xc>)
3400a1da:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3400a1dc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400a1e0:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400a1e2:	4770      	bx	lr
3400a1e4:	56028000 	.word	0x56028000

3400a1e8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400a1e8:	4b02      	ldr	r3, [pc, #8]	@ (3400a1f4 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0xc>)
3400a1ea:	6d58      	ldr	r0, [r3, #84]	@ 0x54
}
3400a1ec:	f3c0 1080 	ubfx	r0, r0, #6, #1
3400a1f0:	4770      	bx	lr
3400a1f2:	bf00      	nop
3400a1f4:	56028000 	.word	0x56028000

3400a1f8 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400a1f8:	4b02      	ldr	r3, [pc, #8]	@ (3400a204 <LL_RCC_HSE_IsReady+0xc>)
3400a1fa:	6858      	ldr	r0, [r3, #4]
}
3400a1fc:	f3c0 1000 	ubfx	r0, r0, #4, #1
3400a200:	4770      	bx	lr
3400a202:	bf00      	nop
3400a204:	56028000 	.word	0x56028000

3400a208 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400a208:	4b02      	ldr	r3, [pc, #8]	@ (3400a214 <LL_RCC_HSI_IsReady+0xc>)
3400a20a:	6858      	ldr	r0, [r3, #4]
}
3400a20c:	f3c0 00c0 	ubfx	r0, r0, #3, #1
3400a210:	4770      	bx	lr
3400a212:	bf00      	nop
3400a214:	56028000 	.word	0x56028000

3400a218 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400a218:	4b02      	ldr	r3, [pc, #8]	@ (3400a224 <LL_RCC_MSI_IsReady+0xc>)
3400a21a:	6858      	ldr	r0, [r3, #4]
}
3400a21c:	f3c0 0080 	ubfx	r0, r0, #2, #1
3400a220:	4770      	bx	lr
3400a222:	bf00      	nop
3400a224:	56028000 	.word	0x56028000

3400a228 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400a228:	4b02      	ldr	r3, [pc, #8]	@ (3400a234 <LL_RCC_LSE_IsReady+0xc>)
3400a22a:	6858      	ldr	r0, [r3, #4]
}
3400a22c:	f3c0 0040 	ubfx	r0, r0, #1, #1
3400a230:	4770      	bx	lr
3400a232:	bf00      	nop
3400a234:	56028000 	.word	0x56028000

3400a238 <LL_RCC_SetClockSource>:
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400a238:	4907      	ldr	r1, [pc, #28]	@ (3400a258 <LL_RCC_SetClockSource+0x20>)
{
3400a23a:	b530      	push	{r4, r5, lr}
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400a23c:	b2c4      	uxtb	r4, r0
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3400a23e:	f3c0 2504 	ubfx	r5, r0, #8, #5
3400a242:	5863      	ldr	r3, [r4, r1]
3400a244:	0e02      	lsrs	r2, r0, #24
3400a246:	40aa      	lsls	r2, r5
3400a248:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400a24c:	ea23 0302 	bic.w	r3, r3, r2
3400a250:	40a8      	lsls	r0, r5
3400a252:	4303      	orrs	r3, r0
3400a254:	5063      	str	r3, [r4, r1]
}
3400a256:	bd30      	pop	{r4, r5, pc}
3400a258:	56028144 	.word	0x56028144

3400a25c <LL_RCC_GetClockSource>:
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3400a25c:	4b05      	ldr	r3, [pc, #20]	@ (3400a274 <LL_RCC_GetClockSource+0x18>)
3400a25e:	b2c2      	uxtb	r2, r0
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3400a260:	58d1      	ldr	r1, [r2, r3]
3400a262:	f3c0 2204 	ubfx	r2, r0, #8, #5
3400a266:	0e03      	lsrs	r3, r0, #24
3400a268:	4093      	lsls	r3, r2
3400a26a:	400b      	ands	r3, r1
3400a26c:	40d3      	lsrs	r3, r2
}
3400a26e:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
3400a272:	4770      	bx	lr
3400a274:	56028144 	.word	0x56028144

3400a278 <LL_RCC_IC7_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3400a278:	4b02      	ldr	r3, [pc, #8]	@ (3400a284 <LL_RCC_IC7_IsEnabled+0xc>)
3400a27a:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a27e:	f3c0 1080 	ubfx	r0, r0, #6, #1
3400a282:	4770      	bx	lr
3400a284:	56028000 	.word	0x56028000

3400a288 <LL_RCC_IC7_GetDivider>:
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3400a288:	4b03      	ldr	r3, [pc, #12]	@ (3400a298 <LL_RCC_IC7_GetDivider+0x10>)
3400a28a:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3400a28e:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a292:	3001      	adds	r0, #1
3400a294:	4770      	bx	lr
3400a296:	bf00      	nop
3400a298:	56028000 	.word	0x56028000

3400a29c <LL_RCC_IC8_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3400a29c:	4b02      	ldr	r3, [pc, #8]	@ (3400a2a8 <LL_RCC_IC8_IsEnabled+0xc>)
3400a29e:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a2a2:	f3c0 10c0 	ubfx	r0, r0, #7, #1
3400a2a6:	4770      	bx	lr
3400a2a8:	56028000 	.word	0x56028000

3400a2ac <LL_RCC_IC8_GetDivider>:
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3400a2ac:	4b03      	ldr	r3, [pc, #12]	@ (3400a2bc <LL_RCC_IC8_GetDivider+0x10>)
3400a2ae:	f8d3 00e0 	ldr.w	r0, [r3, #224]	@ 0xe0
3400a2b2:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a2b6:	3001      	adds	r0, #1
3400a2b8:	4770      	bx	lr
3400a2ba:	bf00      	nop
3400a2bc:	56028000 	.word	0x56028000

3400a2c0 <LL_RCC_IC9_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3400a2c0:	4b02      	ldr	r3, [pc, #8]	@ (3400a2cc <LL_RCC_IC9_IsEnabled+0xc>)
3400a2c2:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a2c6:	f3c0 2000 	ubfx	r0, r0, #8, #1
3400a2ca:	4770      	bx	lr
3400a2cc:	56028000 	.word	0x56028000

3400a2d0 <LL_RCC_IC9_GetDivider>:
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3400a2d0:	4b03      	ldr	r3, [pc, #12]	@ (3400a2e0 <LL_RCC_IC9_GetDivider+0x10>)
3400a2d2:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
3400a2d6:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a2da:	3001      	adds	r0, #1
3400a2dc:	4770      	bx	lr
3400a2de:	bf00      	nop
3400a2e0:	56028000 	.word	0x56028000

3400a2e4 <LL_RCC_IC14_IsEnabled>:
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3400a2e4:	4b02      	ldr	r3, [pc, #8]	@ (3400a2f0 <LL_RCC_IC14_IsEnabled+0xc>)
3400a2e6:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a2ea:	f3c0 3040 	ubfx	r0, r0, #13, #1
3400a2ee:	4770      	bx	lr
3400a2f0:	56028000 	.word	0x56028000

3400a2f4 <LL_RCC_IC14_GetDivider>:
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3400a2f4:	4b03      	ldr	r3, [pc, #12]	@ (3400a304 <LL_RCC_IC14_GetDivider+0x10>)
3400a2f6:	f8d3 00f8 	ldr.w	r0, [r3, #248]	@ 0xf8
3400a2fa:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a2fe:	3001      	adds	r0, #1
3400a300:	4770      	bx	lr
3400a302:	bf00      	nop
3400a304:	56028000 	.word	0x56028000

3400a308 <LL_RCC_IC15_IsEnabled>:
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3400a308:	4b02      	ldr	r3, [pc, #8]	@ (3400a314 <LL_RCC_IC15_IsEnabled+0xc>)
3400a30a:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3400a30e:	f3c0 3080 	ubfx	r0, r0, #14, #1
3400a312:	4770      	bx	lr
3400a314:	56028000 	.word	0x56028000

3400a318 <LL_RCC_IC15_GetDivider>:
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3400a318:	4b03      	ldr	r3, [pc, #12]	@ (3400a328 <LL_RCC_IC15_GetDivider+0x10>)
3400a31a:	f8d3 00fc 	ldr.w	r0, [r3, #252]	@ 0xfc
3400a31e:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3400a322:	3001      	adds	r0, #1
3400a324:	4770      	bx	lr
3400a326:	bf00      	nop
3400a328:	56028000 	.word	0x56028000

3400a32c <RCCEx_GetHCLKFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400a32c:	4b02      	ldr	r3, [pc, #8]	@ (3400a338 <RCCEx_GetHCLKFreq+0xc>)
3400a32e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
3400a330:	f3c3 5302 	ubfx	r3, r3, #20, #3
}
3400a334:	40d8      	lsrs	r0, r3
3400a336:	4770      	bx	lr
3400a338:	56028000 	.word	0x56028000

3400a33c <RCCEx_GetPLLSourceFreq>:
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;

  switch (PLLsource)
3400a33c:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
3400a340:	b508      	push	{r3, lr}
  switch (PLLsource)
3400a342:	d01d      	beq.n	3400a380 <RCCEx_GetPLLSourceFreq+0x44>
3400a344:	d80a      	bhi.n	3400a35c <RCCEx_GetPLLSourceFreq+0x20>
3400a346:	b970      	cbnz	r0, 3400a366 <RCCEx_GetPLLSourceFreq+0x2a>
  {
    case LL_RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400a348:	f7ff ff5e 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400a34c:	b148      	cbz	r0, 3400a362 <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400a34e:	4b10      	ldr	r3, [pc, #64]	@ (3400a390 <RCCEx_GetPLLSourceFreq+0x54>)
      {
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a350:	4810      	ldr	r0, [pc, #64]	@ (3400a394 <RCCEx_GetPLLSourceFreq+0x58>)
3400a352:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400a354:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400a358:	40d8      	lsrs	r0, r3
3400a35a:	e003      	b.n	3400a364 <RCCEx_GetPLLSourceFreq+0x28>
  switch (PLLsource)
3400a35c:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400a360:	d014      	beq.n	3400a38c <RCCEx_GetPLLSourceFreq+0x50>
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
3400a362:	2000      	movs	r0, #0
      /* unexpected case */
      break;
  }

  return pllinputfreq;
}
3400a364:	bd08      	pop	{r3, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400a366:	f7ff ff57 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400a36a:	2800      	cmp	r0, #0
3400a36c:	d0f9      	beq.n	3400a362 <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400a36e:	4b08      	ldr	r3, [pc, #32]	@ (3400a390 <RCCEx_GetPLLSourceFreq+0x54>)
          pllinputfreq = MSI_VALUE;
3400a370:	4809      	ldr	r0, [pc, #36]	@ (3400a398 <RCCEx_GetPLLSourceFreq+0x5c>)
3400a372:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400a374:	f413 7f00 	tst.w	r3, #512	@ 0x200
3400a378:	4b08      	ldr	r3, [pc, #32]	@ (3400a39c <RCCEx_GetPLLSourceFreq+0x60>)
3400a37a:	bf08      	it	eq
3400a37c:	4618      	moveq	r0, r3
3400a37e:	e7f1      	b.n	3400a364 <RCCEx_GetPLLSourceFreq+0x28>
      if (LL_RCC_HSE_IsReady() != 0U)
3400a380:	f7ff ff3a 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400a384:	2800      	cmp	r0, #0
3400a386:	d0ec      	beq.n	3400a362 <RCCEx_GetPLLSourceFreq+0x26>
        pllinputfreq = HSE_VALUE;
3400a388:	4805      	ldr	r0, [pc, #20]	@ (3400a3a0 <RCCEx_GetPLLSourceFreq+0x64>)
3400a38a:	e7eb      	b.n	3400a364 <RCCEx_GetPLLSourceFreq+0x28>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
3400a38c:	4805      	ldr	r0, [pc, #20]	@ (3400a3a4 <RCCEx_GetPLLSourceFreq+0x68>)
3400a38e:	e7e9      	b.n	3400a364 <RCCEx_GetPLLSourceFreq+0x28>
3400a390:	56028000 	.word	0x56028000
3400a394:	03d09000 	.word	0x03d09000
3400a398:	00f42400 	.word	0x00f42400
3400a39c:	003d0900 	.word	0x003d0900
3400a3a0:	02dc6c00 	.word	0x02dc6c00
3400a3a4:	00bb8000 	.word	0x00bb8000

3400a3a8 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
3400a3a8:	ee07 2a10 	vmov	s14, r2
3400a3ac:	ee06 3a10 	vmov	s12, r3
3400a3b0:	ee07 0a90 	vmov	s15, r0
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3400a3b4:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
3400a3b8:	eddf 5a10 	vldr	s11, [pc, #64]	@ 3400a3fc <RCCEx_CalcPLLFreq+0x54>
3400a3bc:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
3400a3c0:	ee06 1a90 	vmov	s13, r1
  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3400a3c4:	eea6 7a25 	vfma.f32	s14, s12, s11
3400a3c8:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400a3cc:	ee67 7a87 	vmul.f32	s15, s15, s14
3400a3d0:	eeb8 7a66 	vcvt.f32.u32	s14, s13
3400a3d4:	ee87 6a87 	vdiv.f32	s12, s15, s14

  freq = freq / (float_t)P1;
3400a3d8:	eddd 7a00 	vldr	s15, [sp]
3400a3dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400a3e0:	eec6 6a27 	vdiv.f32	s13, s12, s15
  freq = freq / (float_t)P2;
3400a3e4:	eddd 7a01 	vldr	s15, [sp, #4]
3400a3e8:	eef8 7a67 	vcvt.f32.u32	s15, s15
3400a3ec:	ee86 7aa7 	vdiv.f32	s14, s13, s15

  return (uint32_t)freq;
}
3400a3f0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
3400a3f4:	ee17 0a90 	vmov	r0, s15
3400a3f8:	4770      	bx	lr
3400a3fa:	bf00      	nop
3400a3fc:	33800000 	.word	0x33800000

3400a400 <HAL_RCCEx_PeriphCLKConfig>:
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400a400:	e9d0 2300 	ldrd	r2, r3, [r0]
3400a404:	f023 437e 	bic.w	r3, r3, #4261412864	@ 0xfe000000
3400a408:	431a      	orrs	r2, r3
{
3400a40a:	b570      	push	{r4, r5, r6, lr}
3400a40c:	4604      	mov	r4, r0
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
3400a40e:	d103      	bne.n	3400a418 <HAL_RCCEx_PeriphCLKConfig+0x18>
3400a410:	2193      	movs	r1, #147	@ 0x93
3400a412:	4861      	ldr	r0, [pc, #388]	@ (3400a598 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400a414:	f7f8 f892 	bl	3400253c <assert_failed>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3400a418:	6823      	ldr	r3, [r4, #0]
3400a41a:	011a      	lsls	r2, r3, #4
3400a41c:	f140 808e 	bpl.w	3400a53c <HAL_RCCEx_PeriphCLKConfig+0x13c>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
3400a420:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400a424:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400a428:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3400a42c:	d05a      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a42e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400a432:	d057      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a434:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
3400a438:	f5b2 5f98 	cmp.w	r2, #4864	@ 0x1300
3400a43c:	d052      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a43e:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
3400a442:	f5b2 5f0c 	cmp.w	r2, #8960	@ 0x2300
3400a446:	d04d      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a448:	f423 4210 	bic.w	r2, r3, #36864	@ 0x9000
3400a44c:	f5b2 4f86 	cmp.w	r2, #17152	@ 0x4300
3400a450:	d048      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a452:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
3400a456:	f5b2 4fe6 	cmp.w	r2, #29440	@ 0x7300
3400a45a:	d043      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a45c:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3400a460:	f5b2 4f03 	cmp.w	r2, #33536	@ 0x8300
3400a464:	d03e      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a466:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400a46a:	f5b1 4f63 	cmp.w	r1, #58112	@ 0xe300
3400a46e:	d039      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a470:	494a      	ldr	r1, [pc, #296]	@ (3400a59c <HAL_RCCEx_PeriphCLKConfig+0x19c>)
3400a472:	428a      	cmp	r2, r1
3400a474:	d036      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a476:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a47a:	428a      	cmp	r2, r1
3400a47c:	d032      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a47e:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a482:	428a      	cmp	r2, r1
3400a484:	d02e      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a486:	f423 3004 	bic.w	r0, r3, #135168	@ 0x21000
3400a48a:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a48e:	4288      	cmp	r0, r1
3400a490:	d028      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a492:	f423 3000 	bic.w	r0, r3, #131072	@ 0x20000
3400a496:	f501 5140 	add.w	r1, r1, #12288	@ 0x3000
3400a49a:	4288      	cmp	r0, r1
3400a49c:	d022      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a49e:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
3400a4a2:	428a      	cmp	r2, r1
3400a4a4:	d01e      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4a6:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a4aa:	428a      	cmp	r2, r1
3400a4ac:	d01a      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4ae:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a4b2:	428a      	cmp	r2, r1
3400a4b4:	d016      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4b6:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a4ba:	428a      	cmp	r2, r1
3400a4bc:	d012      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4be:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a4c2:	428a      	cmp	r2, r1
3400a4c4:	d00e      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4c6:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a4ca:	428a      	cmp	r2, r1
3400a4cc:	d00a      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4ce:	f501 4180 	add.w	r1, r1, #16384	@ 0x4000
3400a4d2:	428a      	cmp	r2, r1
3400a4d4:	d006      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4d6:	4a32      	ldr	r2, [pc, #200]	@ (3400a5a0 <HAL_RCCEx_PeriphCLKConfig+0x1a0>)
3400a4d8:	4293      	cmp	r3, r2
3400a4da:	d003      	beq.n	3400a4e4 <HAL_RCCEx_PeriphCLKConfig+0xe4>
3400a4dc:	2199      	movs	r1, #153	@ 0x99
3400a4de:	482e      	ldr	r0, [pc, #184]	@ (3400a598 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400a4e0:	f7f8 f82c 	bl	3400253c <assert_failed>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400a4e4:	4b2f      	ldr	r3, [pc, #188]	@ (3400a5a4 <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400a4e6:	f8d4 1188 	ldr.w	r1, [r4, #392]	@ 0x188
3400a4ea:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400a4ee:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
3400a4f2:	d13b      	bne.n	3400a56c <HAL_RCCEx_PeriphCLKConfig+0x16c>
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3400a4f4:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3400a4f8:	d108      	bne.n	3400a50c <HAL_RCCEx_PeriphCLKConfig+0x10c>
        tickstart = HAL_GetTick();
3400a4fa:	f7fa f9f9 	bl	340048f0 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a4fe:	f241 3688 	movw	r6, #5000	@ 0x1388
        tickstart = HAL_GetTick();
3400a502:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() == 0U)
3400a504:	f7ff fe90 	bl	3400a228 <LL_RCC_LSE_IsReady>
3400a508:	2800      	cmp	r0, #0
3400a50a:	d03d      	beq.n	3400a588 <HAL_RCCEx_PeriphCLKConfig+0x188>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3400a50c:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3400a510:	4a24      	ldr	r2, [pc, #144]	@ (3400a5a4 <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
3400a512:	f403 7040 	and.w	r0, r3, #768	@ 0x300
3400a516:	f5b0 7f40 	cmp.w	r0, #768	@ 0x300
3400a51a:	d108      	bne.n	3400a52e <HAL_RCCEx_PeriphCLKConfig+0x12e>
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3400a51c:	f8d2 115c 	ldr.w	r1, [r2, #348]	@ 0x15c
3400a520:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400a524:	f421 317c 	bic.w	r1, r1, #258048	@ 0x3f000
3400a528:	430b      	orrs	r3, r1
3400a52a:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400a52e:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400a532:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400a536:	4303      	orrs	r3, r0
3400a538:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3400a53c:	2500      	movs	r5, #0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3400a53e:	6823      	ldr	r3, [r4, #0]
3400a540:	075e      	lsls	r6, r3, #29
3400a542:	d55f      	bpl.n	3400a604 <HAL_RCCEx_PeriphCLKConfig+0x204>
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));
3400a544:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400a548:	2b07      	cmp	r3, #7
3400a54a:	d903      	bls.n	3400a554 <HAL_RCCEx_PeriphCLKConfig+0x154>
3400a54c:	21df      	movs	r1, #223	@ 0xdf
3400a54e:	4812      	ldr	r0, [pc, #72]	@ (3400a598 <HAL_RCCEx_PeriphCLKConfig+0x198>)
3400a550:	f7f7 fff4 	bl	3400253c <assert_failed>
    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3400a554:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400a558:	3b03      	subs	r3, #3
3400a55a:	2b04      	cmp	r3, #4
3400a55c:	d848      	bhi.n	3400a5f0 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
3400a55e:	e8df f013 	tbh	[pc, r3, lsl #1]
3400a562:	0f27      	.short	0x0f27
3400a564:	0ee10025 	.word	0x0ee10025
3400a568:	0f500f04 	.word	0x0f500f04
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3400a56c:	f401 7240 	and.w	r2, r1, #768	@ 0x300
3400a570:	429a      	cmp	r2, r3
3400a572:	d0bf      	beq.n	3400a4f4 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3400a574:	4b0c      	ldr	r3, [pc, #48]	@ (3400a5a8 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
3400a576:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400a578:	f042 0201 	orr.w	r2, r2, #1
3400a57c:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3400a57e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400a580:	07db      	lsls	r3, r3, #31
3400a582:	d4b7      	bmi.n	3400a4f4 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      status = ret;
3400a584:	2501      	movs	r5, #1
3400a586:	e7da      	b.n	3400a53e <HAL_RCCEx_PeriphCLKConfig+0x13e>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400a588:	f7fa f9b2 	bl	340048f0 <HAL_GetTick>
3400a58c:	1b40      	subs	r0, r0, r5
3400a58e:	42b0      	cmp	r0, r6
3400a590:	d9b8      	bls.n	3400a504 <HAL_RCCEx_PeriphCLKConfig+0x104>
        status = ret;
3400a592:	2503      	movs	r5, #3
3400a594:	e7d3      	b.n	3400a53e <HAL_RCCEx_PeriphCLKConfig+0x13e>
3400a596:	bf00      	nop
3400a598:	3401c7d4 	.word	0x3401c7d4
3400a59c:	00010300 	.word	0x00010300
3400a5a0:	0003e300 	.word	0x0003e300
3400a5a4:	56028000 	.word	0x56028000
3400a5a8:	56024800 	.word	0x56024800
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400a5ac:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400a5ae:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a5b2:	d003      	beq.n	3400a5bc <HAL_RCCEx_PeriphCLKConfig+0x1bc>
3400a5b4:	21e4      	movs	r1, #228	@ 0xe4
3400a5b6:	48bd      	ldr	r0, [pc, #756]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a5b8:	f7f7 ffc0 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400a5bc:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400a5be:	3b01      	subs	r3, #1
3400a5c0:	2bff      	cmp	r3, #255	@ 0xff
3400a5c2:	d903      	bls.n	3400a5cc <HAL_RCCEx_PeriphCLKConfig+0x1cc>
3400a5c4:	21e5      	movs	r1, #229	@ 0xe5
3400a5c6:	48b9      	ldr	r0, [pc, #740]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a5c8:	f7f7 ffb8 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400a5cc:	4ab8      	ldr	r2, [pc, #736]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a5ce:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400a5d0:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400a5d4:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400a5d6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a5da:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a5de:	3901      	subs	r1, #1
3400a5e0:	4303      	orrs	r3, r0
3400a5e2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a5e6:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400a5ea:	2310      	movs	r3, #16
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400a5ec:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3400a5f0:	4aaf      	ldr	r2, [pc, #700]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a5f2:	f8d4 10b8 	ldr.w	r1, [r4, #184]	@ 0xb8
3400a5f6:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400a5fa:	f023 0307 	bic.w	r3, r3, #7
3400a5fe:	430b      	orrs	r3, r1
3400a600:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3400a604:	6863      	ldr	r3, [r4, #4]
3400a606:	0258      	lsls	r0, r3, #9
3400a608:	d539      	bpl.n	3400a67e <HAL_RCCEx_PeriphCLKConfig+0x27e>
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));
3400a60a:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
3400a60e:	4aa9      	ldr	r2, [pc, #676]	@ (3400a8b4 <HAL_RCCEx_PeriphCLKConfig+0x4b4>)
3400a610:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a614:	4293      	cmp	r3, r2
3400a616:	d004      	beq.n	3400a622 <HAL_RCCEx_PeriphCLKConfig+0x222>
3400a618:	f240 112f 	movw	r1, #303	@ 0x12f
3400a61c:	48a3      	ldr	r0, [pc, #652]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a61e:	f7f7 ff8d 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400a622:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
3400a626:	4aa4      	ldr	r2, [pc, #656]	@ (3400a8b8 <HAL_RCCEx_PeriphCLKConfig+0x4b8>)
3400a628:	4293      	cmp	r3, r2
3400a62a:	f041 8713 	bne.w	3400c454 <HAL_RCCEx_PeriphCLKConfig+0x2054>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a62e:	69a3      	ldr	r3, [r4, #24]
3400a630:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a634:	d004      	beq.n	3400a640 <HAL_RCCEx_PeriphCLKConfig+0x240>
3400a636:	f44f 719a 	mov.w	r1, #308	@ 0x134
3400a63a:	489c      	ldr	r0, [pc, #624]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a63c:	f7f7 ff7e 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a640:	69e3      	ldr	r3, [r4, #28]
3400a642:	3b01      	subs	r3, #1
3400a644:	2bff      	cmp	r3, #255	@ 0xff
3400a646:	d904      	bls.n	3400a652 <HAL_RCCEx_PeriphCLKConfig+0x252>
3400a648:	f240 1135 	movw	r1, #309	@ 0x135
3400a64c:	4897      	ldr	r0, [pc, #604]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a64e:	f7f7 ff75 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a652:	4a97      	ldr	r2, [pc, #604]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a654:	69e1      	ldr	r1, [r4, #28]
3400a656:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a65a:	69a0      	ldr	r0, [r4, #24]
3400a65c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a660:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a664:	3901      	subs	r1, #1
3400a666:	4303      	orrs	r3, r0
3400a668:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a66c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a670:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a672:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a676:	f8d4 00ac 	ldr.w	r0, [r4, #172]	@ 0xac
3400a67a:	f7ff fddd 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3400a67e:	6863      	ldr	r3, [r4, #4]
3400a680:	0219      	lsls	r1, r3, #8
3400a682:	d539      	bpl.n	3400a6f8 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));
3400a684:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400a688:	4a8c      	ldr	r2, [pc, #560]	@ (3400a8bc <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
3400a68a:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a68e:	4293      	cmp	r3, r2
3400a690:	d004      	beq.n	3400a69c <HAL_RCCEx_PeriphCLKConfig+0x29c>
3400a692:	f44f 71ae 	mov.w	r1, #348	@ 0x15c
3400a696:	4885      	ldr	r0, [pc, #532]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a698:	f7f7 ff50 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3400a69c:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400a6a0:	4a87      	ldr	r2, [pc, #540]	@ (3400a8c0 <HAL_RCCEx_PeriphCLKConfig+0x4c0>)
3400a6a2:	4293      	cmp	r3, r2
3400a6a4:	f041 8706 	bne.w	3400c4b4 <HAL_RCCEx_PeriphCLKConfig+0x20b4>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a6a8:	69a3      	ldr	r3, [r4, #24]
3400a6aa:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a6ae:	d004      	beq.n	3400a6ba <HAL_RCCEx_PeriphCLKConfig+0x2ba>
3400a6b0:	f240 1161 	movw	r1, #353	@ 0x161
3400a6b4:	487d      	ldr	r0, [pc, #500]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a6b6:	f7f7 ff41 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a6ba:	69e3      	ldr	r3, [r4, #28]
3400a6bc:	3b01      	subs	r3, #1
3400a6be:	2bff      	cmp	r3, #255	@ 0xff
3400a6c0:	d904      	bls.n	3400a6cc <HAL_RCCEx_PeriphCLKConfig+0x2cc>
3400a6c2:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3400a6c6:	4879      	ldr	r0, [pc, #484]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a6c8:	f7f7 ff38 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a6cc:	4a78      	ldr	r2, [pc, #480]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a6ce:	69e1      	ldr	r1, [r4, #28]
3400a6d0:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a6d4:	69a0      	ldr	r0, [r4, #24]
3400a6d6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a6da:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a6de:	3901      	subs	r1, #1
3400a6e0:	4303      	orrs	r3, r0
3400a6e2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a6e6:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a6ea:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a6ec:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a6f0:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
3400a6f4:	f7ff fda0 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3400a6f8:	6863      	ldr	r3, [r4, #4]
3400a6fa:	01da      	lsls	r2, r3, #7
3400a6fc:	d539      	bpl.n	3400a772 <HAL_RCCEx_PeriphCLKConfig+0x372>
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));
3400a6fe:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
3400a702:	4a70      	ldr	r2, [pc, #448]	@ (3400a8c4 <HAL_RCCEx_PeriphCLKConfig+0x4c4>)
3400a704:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a708:	4293      	cmp	r3, r2
3400a70a:	d004      	beq.n	3400a716 <HAL_RCCEx_PeriphCLKConfig+0x316>
3400a70c:	f240 1189 	movw	r1, #393	@ 0x189
3400a710:	4866      	ldr	r0, [pc, #408]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a712:	f7f7 ff13 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3400a716:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
3400a71a:	4a6b      	ldr	r2, [pc, #428]	@ (3400a8c8 <HAL_RCCEx_PeriphCLKConfig+0x4c8>)
3400a71c:	4293      	cmp	r3, r2
3400a71e:	f041 86f9 	bne.w	3400c514 <HAL_RCCEx_PeriphCLKConfig+0x2114>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a722:	69a3      	ldr	r3, [r4, #24]
3400a724:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a728:	d004      	beq.n	3400a734 <HAL_RCCEx_PeriphCLKConfig+0x334>
3400a72a:	f44f 71c7 	mov.w	r1, #398	@ 0x18e
3400a72e:	485f      	ldr	r0, [pc, #380]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a730:	f7f7 ff04 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a734:	69e3      	ldr	r3, [r4, #28]
3400a736:	3b01      	subs	r3, #1
3400a738:	2bff      	cmp	r3, #255	@ 0xff
3400a73a:	d904      	bls.n	3400a746 <HAL_RCCEx_PeriphCLKConfig+0x346>
3400a73c:	f240 118f 	movw	r1, #399	@ 0x18f
3400a740:	485a      	ldr	r0, [pc, #360]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a742:	f7f7 fefb 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a746:	4a5a      	ldr	r2, [pc, #360]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a748:	69e1      	ldr	r1, [r4, #28]
3400a74a:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a74e:	69a0      	ldr	r0, [r4, #24]
3400a750:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a754:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a758:	3901      	subs	r1, #1
3400a75a:	4303      	orrs	r3, r0
3400a75c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a760:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a764:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a766:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a76a:	f8d4 00b4 	ldr.w	r0, [r4, #180]	@ 0xb4
3400a76e:	f7ff fd63 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3400a772:	6823      	ldr	r3, [r4, #0]
3400a774:	051b      	lsls	r3, r3, #20
3400a776:	d53c      	bpl.n	3400a7f2 <HAL_RCCEx_PeriphCLKConfig+0x3f2>
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));
3400a778:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400a77c:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400a780:	d004      	beq.n	3400a78c <HAL_RCCEx_PeriphCLKConfig+0x38c>
3400a782:	f44f 71db 	mov.w	r1, #438	@ 0x1b6
3400a786:	4849      	ldr	r0, [pc, #292]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a788:	f7f7 fed8 	bl	3400253c <assert_failed>
    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3400a78c:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400a790:	2b20      	cmp	r3, #32
3400a792:	f041 86ff 	bne.w	3400c594 <HAL_RCCEx_PeriphCLKConfig+0x2194>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
3400a796:	69a3      	ldr	r3, [r4, #24]
3400a798:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a79c:	d004      	beq.n	3400a7a8 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
3400a79e:	f240 11bb 	movw	r1, #443	@ 0x1bb
3400a7a2:	4842      	ldr	r0, [pc, #264]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a7a4:	f7f7 feca 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));
3400a7a8:	69e3      	ldr	r3, [r4, #28]
3400a7aa:	3b01      	subs	r3, #1
3400a7ac:	2bff      	cmp	r3, #255	@ 0xff
3400a7ae:	d904      	bls.n	3400a7ba <HAL_RCCEx_PeriphCLKConfig+0x3ba>
3400a7b0:	f44f 71de 	mov.w	r1, #444	@ 0x1bc
3400a7b4:	483d      	ldr	r0, [pc, #244]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a7b6:	f7f7 fec1 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400a7ba:	4a3d      	ldr	r2, [pc, #244]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a7bc:	69e1      	ldr	r1, [r4, #28]
3400a7be:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3400a7c2:	69a0      	ldr	r0, [r4, #24]
3400a7c4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a7c8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a7cc:	3901      	subs	r1, #1
3400a7ce:	4303      	orrs	r3, r0
3400a7d0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a7d4:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3400a7d8:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a7da:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3400a7de:	4a34      	ldr	r2, [pc, #208]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a7e0:	f8d4 10a8 	ldr.w	r1, [r4, #168]	@ 0xa8
3400a7e4:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3400a7e8:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400a7ec:	430b      	orrs	r3, r1
3400a7ee:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3400a7f2:	6823      	ldr	r3, [r4, #0]
3400a7f4:	005e      	lsls	r6, r3, #1
3400a7f6:	d539      	bpl.n	3400a86c <HAL_RCCEx_PeriphCLKConfig+0x46c>
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
3400a7f8:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
3400a7fc:	4a33      	ldr	r2, [pc, #204]	@ (3400a8cc <HAL_RCCEx_PeriphCLKConfig+0x4cc>)
3400a7fe:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a802:	4293      	cmp	r3, r2
3400a804:	d004      	beq.n	3400a810 <HAL_RCCEx_PeriphCLKConfig+0x410>
3400a806:	f240 11e3 	movw	r1, #483	@ 0x1e3
3400a80a:	4828      	ldr	r0, [pc, #160]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a80c:	f7f7 fe96 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3400a810:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
3400a814:	4a2e      	ldr	r2, [pc, #184]	@ (3400a8d0 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
3400a816:	4293      	cmp	r3, r2
3400a818:	f041 86ea 	bne.w	3400c5f0 <HAL_RCCEx_PeriphCLKConfig+0x21f0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400a81c:	6a23      	ldr	r3, [r4, #32]
3400a81e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a822:	d004      	beq.n	3400a82e <HAL_RCCEx_PeriphCLKConfig+0x42e>
3400a824:	f44f 71f4 	mov.w	r1, #488	@ 0x1e8
3400a828:	4820      	ldr	r0, [pc, #128]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a82a:	f7f7 fe87 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400a82e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400a830:	3b01      	subs	r3, #1
3400a832:	2bff      	cmp	r3, #255	@ 0xff
3400a834:	d904      	bls.n	3400a840 <HAL_RCCEx_PeriphCLKConfig+0x440>
3400a836:	f240 11e9 	movw	r1, #489	@ 0x1e9
3400a83a:	481c      	ldr	r0, [pc, #112]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a83c:	f7f7 fe7e 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400a840:	4a1b      	ldr	r2, [pc, #108]	@ (3400a8b0 <HAL_RCCEx_PeriphCLKConfig+0x4b0>)
3400a842:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400a844:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400a848:	6a20      	ldr	r0, [r4, #32]
3400a84a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a84e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a852:	3901      	subs	r1, #1
3400a854:	4303      	orrs	r3, r0
3400a856:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a85a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a85e:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400a860:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a864:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
3400a868:	f7ff fce6 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3400a86c:	6823      	ldr	r3, [r4, #0]
3400a86e:	2b00      	cmp	r3, #0
3400a870:	da53      	bge.n	3400a91a <HAL_RCCEx_PeriphCLKConfig+0x51a>
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));
3400a872:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
3400a876:	4a17      	ldr	r2, [pc, #92]	@ (3400a8d4 <HAL_RCCEx_PeriphCLKConfig+0x4d4>)
3400a878:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400a87c:	4293      	cmp	r3, r2
3400a87e:	d004      	beq.n	3400a88a <HAL_RCCEx_PeriphCLKConfig+0x48a>
3400a880:	f44f 7104 	mov.w	r1, #528	@ 0x210
3400a884:	4809      	ldr	r0, [pc, #36]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a886:	f7f7 fe59 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3400a88a:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
3400a88e:	4a12      	ldr	r2, [pc, #72]	@ (3400a8d8 <HAL_RCCEx_PeriphCLKConfig+0x4d8>)
3400a890:	4293      	cmp	r3, r2
3400a892:	f041 86dd 	bne.w	3400c650 <HAL_RCCEx_PeriphCLKConfig+0x2250>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400a896:	6a23      	ldr	r3, [r4, #32]
3400a898:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a89c:	d01e      	beq.n	3400a8dc <HAL_RCCEx_PeriphCLKConfig+0x4dc>
3400a89e:	f240 2115 	movw	r1, #533	@ 0x215
3400a8a2:	4802      	ldr	r0, [pc, #8]	@ (3400a8ac <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
3400a8a4:	f7f7 fe4a 	bl	3400253c <assert_failed>
3400a8a8:	e018      	b.n	3400a8dc <HAL_RCCEx_PeriphCLKConfig+0x4dc>
3400a8aa:	bf00      	nop
3400a8ac:	3401c7d4 	.word	0x3401c7d4
3400a8b0:	56028000 	.word	0x56028000
3400a8b4:	03000014 	.word	0x03000014
3400a8b8:	03020014 	.word	0x03020014
3400a8bc:	03000414 	.word	0x03000414
3400a8c0:	03020414 	.word	0x03020414
3400a8c4:	03000814 	.word	0x03000814
3400a8c8:	03020814 	.word	0x03020814
3400a8cc:	0300001c 	.word	0x0300001c
3400a8d0:	0302001c 	.word	0x0302001c
3400a8d4:	0300041c 	.word	0x0300041c
3400a8d8:	0302041c 	.word	0x0302041c
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400a8dc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400a8de:	3b01      	subs	r3, #1
3400a8e0:	2bff      	cmp	r3, #255	@ 0xff
3400a8e2:	d904      	bls.n	3400a8ee <HAL_RCCEx_PeriphCLKConfig+0x4ee>
3400a8e4:	f240 2116 	movw	r1, #534	@ 0x216
3400a8e8:	48c4      	ldr	r0, [pc, #784]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a8ea:	f7f7 fe27 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400a8ee:	4ac4      	ldr	r2, [pc, #784]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a8f0:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400a8f2:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400a8f6:	6a20      	ldr	r0, [r4, #32]
3400a8f8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a8fc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a900:	3901      	subs	r1, #1
3400a902:	4303      	orrs	r3, r0
3400a904:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a908:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400a90c:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400a90e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400a912:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
3400a916:	f7ff fc8f 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
3400a91a:	6823      	ldr	r3, [r4, #0]
3400a91c:	07d8      	lsls	r0, r3, #31
3400a91e:	d54f      	bpl.n	3400a9c0 <HAL_RCCEx_PeriphCLKConfig+0x5c0>
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
3400a920:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
3400a924:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400a928:	d006      	beq.n	3400a938 <HAL_RCCEx_PeriphCLKConfig+0x538>
3400a92a:	2b40      	cmp	r3, #64	@ 0x40
3400a92c:	d004      	beq.n	3400a938 <HAL_RCCEx_PeriphCLKConfig+0x538>
3400a92e:	f240 213d 	movw	r1, #573	@ 0x23d
3400a932:	48b2      	ldr	r0, [pc, #712]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a934:	f7f7 fe02 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));
3400a938:	f8d4 30c0 	ldr.w	r3, [r4, #192]	@ 0xc0
3400a93c:	3b01      	subs	r3, #1
3400a93e:	2bff      	cmp	r3, #255	@ 0xff
3400a940:	d904      	bls.n	3400a94c <HAL_RCCEx_PeriphCLKConfig+0x54c>
3400a942:	f240 213e 	movw	r1, #574	@ 0x23e
3400a946:	48ad      	ldr	r0, [pc, #692]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a948:	f7f7 fdf8 	bl	3400253c <assert_failed>
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3400a94c:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
3400a950:	2b20      	cmp	r3, #32
3400a952:	f041 86ad 	bne.w	3400c6b0 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400a956:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400a958:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a95c:	d004      	beq.n	3400a968 <HAL_RCCEx_PeriphCLKConfig+0x568>
3400a95e:	f240 2143 	movw	r1, #579	@ 0x243
3400a962:	48a6      	ldr	r0, [pc, #664]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a964:	f7f7 fdea 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400a968:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a96a:	3b01      	subs	r3, #1
3400a96c:	2bff      	cmp	r3, #255	@ 0xff
3400a96e:	d904      	bls.n	3400a97a <HAL_RCCEx_PeriphCLKConfig+0x57a>
3400a970:	f44f 7111 	mov.w	r1, #580	@ 0x244
3400a974:	48a1      	ldr	r0, [pc, #644]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a976:	f7f7 fde1 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400a97a:	4aa1      	ldr	r2, [pc, #644]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a97c:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400a97e:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400a982:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400a984:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400a988:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400a98c:	3901      	subs	r1, #1
3400a98e:	4303      	orrs	r3, r0
3400a990:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400a994:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400a998:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400a99a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3400a99e:	4998      	ldr	r1, [pc, #608]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400a9a0:	f8d4 20c0 	ldr.w	r2, [r4, #192]	@ 0xc0
3400a9a4:	f8d1 3144 	ldr.w	r3, [r1, #324]	@ 0x144
3400a9a8:	f8d4 00bc 	ldr.w	r0, [r4, #188]	@ 0xbc
3400a9ac:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
3400a9b0:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
3400a9b4:	3a01      	subs	r2, #1
3400a9b6:	4303      	orrs	r3, r0
3400a9b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
3400a9bc:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3400a9c0:	6823      	ldr	r3, [r4, #0]
3400a9c2:	0799      	lsls	r1, r3, #30
3400a9c4:	d53b      	bpl.n	3400aa3e <HAL_RCCEx_PeriphCLKConfig+0x63e>
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));
3400a9c6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
3400a9ca:	2b07      	cmp	r3, #7
3400a9cc:	d904      	bls.n	3400a9d8 <HAL_RCCEx_PeriphCLKConfig+0x5d8>
3400a9ce:	f44f 711b 	mov.w	r1, #620	@ 0x26c
3400a9d2:	488a      	ldr	r0, [pc, #552]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a9d4:	f7f7 fdb2 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3400a9d8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
3400a9dc:	2b02      	cmp	r3, #2
3400a9de:	f041 8695 	bne.w	3400c70c <HAL_RCCEx_PeriphCLKConfig+0x230c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400a9e2:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400a9e4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400a9e8:	d004      	beq.n	3400a9f4 <HAL_RCCEx_PeriphCLKConfig+0x5f4>
3400a9ea:	f240 2171 	movw	r1, #625	@ 0x271
3400a9ee:	4883      	ldr	r0, [pc, #524]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400a9f0:	f7f7 fda4 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400a9f4:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400a9f6:	3b01      	subs	r3, #1
3400a9f8:	2bff      	cmp	r3, #255	@ 0xff
3400a9fa:	d904      	bls.n	3400aa06 <HAL_RCCEx_PeriphCLKConfig+0x606>
3400a9fc:	f240 2172 	movw	r1, #626	@ 0x272
3400aa00:	487e      	ldr	r0, [pc, #504]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aa02:	f7f7 fd9b 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400aa06:	4a7e      	ldr	r2, [pc, #504]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aa08:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400aa0a:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400aa0e:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400aa10:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aa14:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aa18:	3901      	subs	r1, #1
3400aa1a:	4303      	orrs	r3, r0
3400aa1c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aa20:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400aa24:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400aa26:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3400aa2a:	4a75      	ldr	r2, [pc, #468]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aa2c:	f8d4 10c4 	ldr.w	r1, [r4, #196]	@ 0xc4
3400aa30:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3400aa34:	f023 0307 	bic.w	r3, r3, #7
3400aa38:	430b      	orrs	r3, r1
3400aa3a:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3400aa3e:	6823      	ldr	r3, [r4, #0]
3400aa40:	071a      	lsls	r2, r3, #28
3400aa42:	d528      	bpl.n	3400aa96 <HAL_RCCEx_PeriphCLKConfig+0x696>
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
3400aa44:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3400aa48:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400aa4c:	d004      	beq.n	3400aa58 <HAL_RCCEx_PeriphCLKConfig+0x658>
3400aa4e:	f240 2199 	movw	r1, #665	@ 0x299
3400aa52:	486a      	ldr	r0, [pc, #424]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aa54:	f7f7 fd72 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));
3400aa58:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
3400aa5c:	3b01      	subs	r3, #1
3400aa5e:	2bff      	cmp	r3, #255	@ 0xff
3400aa60:	d904      	bls.n	3400aa6c <HAL_RCCEx_PeriphCLKConfig+0x66c>
3400aa62:	f240 219a 	movw	r1, #666	@ 0x29a
3400aa66:	4865      	ldr	r0, [pc, #404]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aa68:	f7f7 fd68 	bl	3400253c <assert_failed>
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3400aa6c:	4a64      	ldr	r2, [pc, #400]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aa6e:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
3400aa72:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
3400aa76:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
3400aa7a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aa7e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aa82:	3901      	subs	r1, #1
3400aa84:	4303      	orrs	r3, r0
3400aa86:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aa8a:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3400aa8e:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3400aa92:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3400aa96:	6823      	ldr	r3, [r4, #0]
3400aa98:	06db      	lsls	r3, r3, #27
3400aa9a:	d542      	bpl.n	3400ab22 <HAL_RCCEx_PeriphCLKConfig+0x722>
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));
3400aa9c:	f8d4 30c8 	ldr.w	r3, [r4, #200]	@ 0xc8
3400aaa0:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
3400aaa4:	d004      	beq.n	3400aab0 <HAL_RCCEx_PeriphCLKConfig+0x6b0>
3400aaa6:	f44f 712a 	mov.w	r1, #680	@ 0x2a8
3400aaaa:	4854      	ldr	r0, [pc, #336]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aaac:	f7f7 fd46 	bl	3400253c <assert_failed>
    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3400aab0:	f8d4 30c8 	ldr.w	r3, [r4, #200]	@ 0xc8
3400aab4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400aab8:	f041 8656 	bne.w	3400c768 <HAL_RCCEx_PeriphCLKConfig+0x2368>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
3400aabc:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400aac0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400aac4:	d004      	beq.n	3400aad0 <HAL_RCCEx_PeriphCLKConfig+0x6d0>
3400aac6:	f240 21ad 	movw	r1, #685	@ 0x2ad
3400aaca:	484c      	ldr	r0, [pc, #304]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aacc:	f7f7 fd36 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));
3400aad0:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
3400aad4:	3b01      	subs	r3, #1
3400aad6:	2bff      	cmp	r3, #255	@ 0xff
3400aad8:	d904      	bls.n	3400aae4 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
3400aada:	f240 21ae 	movw	r1, #686	@ 0x2ae
3400aade:	4847      	ldr	r0, [pc, #284]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400aae0:	f7f7 fd2c 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3400aae4:	4a46      	ldr	r2, [pc, #280]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400aae6:	f8d4 108c 	ldr.w	r1, [r4, #140]	@ 0x8c
3400aaea:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
3400aaee:	f8d4 0088 	ldr.w	r0, [r4, #136]	@ 0x88
3400aaf2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aaf6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aafa:	3901      	subs	r1, #1
3400aafc:	4303      	orrs	r3, r0
3400aafe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ab02:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3400ab06:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3400ab0a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3400ab0e:	4a3c      	ldr	r2, [pc, #240]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400ab10:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
3400ab14:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3400ab18:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
3400ab1c:	430b      	orrs	r3, r1
3400ab1e:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3400ab22:	6823      	ldr	r3, [r4, #0]
3400ab24:	069e      	lsls	r6, r3, #26
3400ab26:	d53e      	bpl.n	3400aba6 <HAL_RCCEx_PeriphCLKConfig+0x7a6>
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));
3400ab28:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
3400ab2c:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400ab30:	d004      	beq.n	3400ab3c <HAL_RCCEx_PeriphCLKConfig+0x73c>
3400ab32:	f44f 7132 	mov.w	r1, #712	@ 0x2c8
3400ab36:	4831      	ldr	r0, [pc, #196]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400ab38:	f7f7 fd00 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3400ab3c:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
3400ab40:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400ab44:	f041 8619 	bne.w	3400c77a <HAL_RCCEx_PeriphCLKConfig+0x237a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
3400ab48:	6e23      	ldr	r3, [r4, #96]	@ 0x60
3400ab4a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ab4e:	d004      	beq.n	3400ab5a <HAL_RCCEx_PeriphCLKConfig+0x75a>
3400ab50:	f240 21cd 	movw	r1, #717	@ 0x2cd
3400ab54:	4829      	ldr	r0, [pc, #164]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400ab56:	f7f7 fcf1 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));
3400ab5a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3400ab5c:	3b01      	subs	r3, #1
3400ab5e:	2bff      	cmp	r3, #255	@ 0xff
3400ab60:	d904      	bls.n	3400ab6c <HAL_RCCEx_PeriphCLKConfig+0x76c>
3400ab62:	f240 21ce 	movw	r1, #718	@ 0x2ce
3400ab66:	4825      	ldr	r0, [pc, #148]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400ab68:	f7f7 fce8 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3400ab6c:	4a24      	ldr	r2, [pc, #144]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400ab6e:	6e61      	ldr	r1, [r4, #100]	@ 0x64
3400ab70:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
3400ab74:	6e20      	ldr	r0, [r4, #96]	@ 0x60
3400ab76:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ab7a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ab7e:	3901      	subs	r1, #1
3400ab80:	4303      	orrs	r3, r0
3400ab82:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ab86:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3400ab8a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400ab8e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3400ab92:	4a1b      	ldr	r2, [pc, #108]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400ab94:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
3400ab98:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ab9c:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3400aba0:	430b      	orrs	r3, r1
3400aba2:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
3400aba6:	6823      	ldr	r3, [r4, #0]
3400aba8:	0658      	lsls	r0, r3, #25
3400abaa:	d516      	bpl.n	3400abda <HAL_RCCEx_PeriphCLKConfig+0x7da>
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));
3400abac:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
3400abb0:	f433 3280 	bics.w	r2, r3, #65536	@ 0x10000
3400abb4:	d007      	beq.n	3400abc6 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
3400abb6:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400abba:	d004      	beq.n	3400abc6 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
3400abbc:	f44f 713a 	mov.w	r1, #744	@ 0x2e8
3400abc0:	480e      	ldr	r0, [pc, #56]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400abc2:	f7f7 fcbb 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3400abc6:	4a0e      	ldr	r2, [pc, #56]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400abc8:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
3400abcc:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400abd0:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400abd4:	430b      	orrs	r3, r1
3400abd6:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
3400abda:	6823      	ldr	r3, [r4, #0]
3400abdc:	0619      	lsls	r1, r3, #24
3400abde:	d518      	bpl.n	3400ac12 <HAL_RCCEx_PeriphCLKConfig+0x812>
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));
3400abe0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	@ 0xd4
3400abe4:	f433 1380 	bics.w	r3, r3, #1048576	@ 0x100000
3400abe8:	d004      	beq.n	3400abf4 <HAL_RCCEx_PeriphCLKConfig+0x7f4>
3400abea:	f240 21f2 	movw	r1, #754	@ 0x2f2
3400abee:	4803      	ldr	r0, [pc, #12]	@ (3400abfc <HAL_RCCEx_PeriphCLKConfig+0x7fc>)
3400abf0:	f7f7 fca4 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400abf4:	4a02      	ldr	r2, [pc, #8]	@ (3400ac00 <HAL_RCCEx_PeriphCLKConfig+0x800>)
3400abf6:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
3400abfa:	e003      	b.n	3400ac04 <HAL_RCCEx_PeriphCLKConfig+0x804>
3400abfc:	3401c7d4 	.word	0x3401c7d4
3400ac00:	56028000 	.word	0x56028000
3400ac04:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ac08:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400ac0c:	430b      	orrs	r3, r1
3400ac0e:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
3400ac12:	6823      	ldr	r3, [r4, #0]
3400ac14:	05da      	lsls	r2, r3, #23
3400ac16:	d513      	bpl.n	3400ac40 <HAL_RCCEx_PeriphCLKConfig+0x840>
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));
3400ac18:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
3400ac1c:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
3400ac20:	d004      	beq.n	3400ac2c <HAL_RCCEx_PeriphCLKConfig+0x82c>
3400ac22:	f44f 713f 	mov.w	r1, #764	@ 0x2fc
3400ac26:	48c1      	ldr	r0, [pc, #772]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac28:	f7f7 fc88 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3400ac2c:	4ac0      	ldr	r2, [pc, #768]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ac2e:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
3400ac32:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ac36:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3400ac3a:	430b      	orrs	r3, r1
3400ac3c:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
3400ac40:	6823      	ldr	r3, [r4, #0]
3400ac42:	059b      	lsls	r3, r3, #22
3400ac44:	d54b      	bpl.n	3400acde <HAL_RCCEx_PeriphCLKConfig+0x8de>
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
3400ac46:	f8d4 30dc 	ldr.w	r3, [r4, #220]	@ 0xdc
3400ac4a:	2b03      	cmp	r3, #3
3400ac4c:	d904      	bls.n	3400ac58 <HAL_RCCEx_PeriphCLKConfig+0x858>
3400ac4e:	f240 3106 	movw	r1, #774	@ 0x306
3400ac52:	48b6      	ldr	r0, [pc, #728]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac54:	f7f7 fc72 	bl	3400253c <assert_failed>
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));
3400ac58:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
3400ac5c:	3b01      	subs	r3, #1
3400ac5e:	2b0f      	cmp	r3, #15
3400ac60:	d904      	bls.n	3400ac6c <HAL_RCCEx_PeriphCLKConfig+0x86c>
3400ac62:	f240 3107 	movw	r1, #775	@ 0x307
3400ac66:	48b1      	ldr	r0, [pc, #708]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac68:	f7f7 fc68 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3400ac6c:	f8d4 30dc 	ldr.w	r3, [r4, #220]	@ 0xdc
3400ac70:	2b02      	cmp	r3, #2
3400ac72:	f041 858b 	bne.w	3400c78c <HAL_RCCEx_PeriphCLKConfig+0x238c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
3400ac76:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
3400ac78:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ac7c:	d004      	beq.n	3400ac88 <HAL_RCCEx_PeriphCLKConfig+0x888>
3400ac7e:	f44f 7143 	mov.w	r1, #780	@ 0x30c
3400ac82:	48aa      	ldr	r0, [pc, #680]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac84:	f7f7 fc5a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));
3400ac88:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
3400ac8a:	3b01      	subs	r3, #1
3400ac8c:	2bff      	cmp	r3, #255	@ 0xff
3400ac8e:	d904      	bls.n	3400ac9a <HAL_RCCEx_PeriphCLKConfig+0x89a>
3400ac90:	f240 310d 	movw	r1, #781	@ 0x30d
3400ac94:	48a5      	ldr	r0, [pc, #660]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ac96:	f7f7 fc51 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3400ac9a:	4aa5      	ldr	r2, [pc, #660]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ac9c:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
3400ac9e:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
3400aca2:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
3400aca4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aca8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400acac:	3901      	subs	r1, #1
3400acae:	4303      	orrs	r3, r0
3400acb0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400acb4:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3400acb8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3400acbc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
3400acc0:	499b      	ldr	r1, [pc, #620]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400acc2:	f8d4 20e0 	ldr.w	r2, [r4, #224]	@ 0xe0
3400acc6:	f8d1 3148 	ldr.w	r3, [r1, #328]	@ 0x148
3400acca:	f8d4 00dc 	ldr.w	r0, [r4, #220]	@ 0xdc
3400acce:	f023 03f3 	bic.w	r3, r3, #243	@ 0xf3
3400acd2:	3a01      	subs	r2, #1
3400acd4:	4303      	orrs	r3, r0
3400acd6:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
3400acda:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
3400acde:	6823      	ldr	r3, [r4, #0]
3400ace0:	055e      	lsls	r6, r3, #21
3400ace2:	d540      	bpl.n	3400ad66 <HAL_RCCEx_PeriphCLKConfig+0x966>
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));
3400ace4:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
3400ace8:	2b03      	cmp	r3, #3
3400acea:	d904      	bls.n	3400acf6 <HAL_RCCEx_PeriphCLKConfig+0x8f6>
3400acec:	f44f 714a 	mov.w	r1, #808	@ 0x328
3400acf0:	488e      	ldr	r0, [pc, #568]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400acf2:	f7f7 fc23 	bl	3400253c <assert_failed>
    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3400acf6:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
3400acfa:	2b02      	cmp	r3, #2
3400acfc:	f041 854e 	bne.w	3400c79c <HAL_RCCEx_PeriphCLKConfig+0x239c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400ad00:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400ad04:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ad08:	d004      	beq.n	3400ad14 <HAL_RCCEx_PeriphCLKConfig+0x914>
3400ad0a:	f240 312d 	movw	r1, #813	@ 0x32d
3400ad0e:	4887      	ldr	r0, [pc, #540]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ad10:	f7f7 fc14 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400ad14:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
3400ad18:	3b01      	subs	r3, #1
3400ad1a:	2bff      	cmp	r3, #255	@ 0xff
3400ad1c:	d904      	bls.n	3400ad28 <HAL_RCCEx_PeriphCLKConfig+0x928>
3400ad1e:	f240 312e 	movw	r1, #814	@ 0x32e
3400ad22:	4882      	ldr	r0, [pc, #520]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ad24:	f7f7 fc0a 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400ad28:	4a81      	ldr	r2, [pc, #516]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ad2a:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
3400ad2e:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3400ad32:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
3400ad36:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ad3a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ad3e:	3901      	subs	r1, #1
3400ad40:	4303      	orrs	r3, r0
3400ad42:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ad46:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400ad4a:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3400ad4e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3400ad52:	4a77      	ldr	r2, [pc, #476]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ad54:	f8d4 10e4 	ldr.w	r1, [r4, #228]	@ 0xe4
3400ad58:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3400ad5c:	f023 0303 	bic.w	r3, r3, #3
3400ad60:	430b      	orrs	r3, r1
3400ad62:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3400ad66:	6823      	ldr	r3, [r4, #0]
3400ad68:	04d8      	lsls	r0, r3, #19
3400ad6a:	d540      	bpl.n	3400adee <HAL_RCCEx_PeriphCLKConfig+0x9ee>
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
3400ad6c:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
3400ad70:	4a70      	ldr	r2, [pc, #448]	@ (3400af34 <HAL_RCCEx_PeriphCLKConfig+0xb34>)
3400ad72:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ad76:	4291      	cmp	r1, r2
3400ad78:	d00a      	beq.n	3400ad90 <HAL_RCCEx_PeriphCLKConfig+0x990>
3400ad7a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400ad7e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ad82:	4293      	cmp	r3, r2
3400ad84:	d004      	beq.n	3400ad90 <HAL_RCCEx_PeriphCLKConfig+0x990>
3400ad86:	f44f 7152 	mov.w	r1, #840	@ 0x348
3400ad8a:	4868      	ldr	r0, [pc, #416]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ad8c:	f7f7 fbd6 	bl	3400253c <assert_failed>
    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3400ad90:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
3400ad94:	4a68      	ldr	r2, [pc, #416]	@ (3400af38 <HAL_RCCEx_PeriphCLKConfig+0xb38>)
3400ad96:	4293      	cmp	r3, r2
3400ad98:	f041 8508 	bne.w	3400c7ac <HAL_RCCEx_PeriphCLKConfig+0x23ac>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400ad9c:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400ad9e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ada2:	d004      	beq.n	3400adae <HAL_RCCEx_PeriphCLKConfig+0x9ae>
3400ada4:	f240 314d 	movw	r1, #845	@ 0x34d
3400ada8:	4860      	ldr	r0, [pc, #384]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400adaa:	f7f7 fbc7 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400adae:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400adb0:	3b01      	subs	r3, #1
3400adb2:	2bff      	cmp	r3, #255	@ 0xff
3400adb4:	d904      	bls.n	3400adc0 <HAL_RCCEx_PeriphCLKConfig+0x9c0>
3400adb6:	f240 314e 	movw	r1, #846	@ 0x34e
3400adba:	485c      	ldr	r0, [pc, #368]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400adbc:	f7f7 fbbe 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400adc0:	4a5b      	ldr	r2, [pc, #364]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400adc2:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400adc4:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400adc8:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400adca:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400adce:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400add2:	3901      	subs	r1, #1
3400add4:	4303      	orrs	r3, r0
3400add6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400adda:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400adde:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ade2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ade6:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
3400adea:	f7ff fa25 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3400adee:	6823      	ldr	r3, [r4, #0]
3400adf0:	0499      	lsls	r1, r3, #18
3400adf2:	d540      	bpl.n	3400ae76 <HAL_RCCEx_PeriphCLKConfig+0xa76>
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
3400adf4:	f8d4 30ec 	ldr.w	r3, [r4, #236]	@ 0xec
3400adf8:	4a50      	ldr	r2, [pc, #320]	@ (3400af3c <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
3400adfa:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400adfe:	4291      	cmp	r1, r2
3400ae00:	d00a      	beq.n	3400ae18 <HAL_RCCEx_PeriphCLKConfig+0xa18>
3400ae02:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400ae06:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ae0a:	4293      	cmp	r3, r2
3400ae0c:	d004      	beq.n	3400ae18 <HAL_RCCEx_PeriphCLKConfig+0xa18>
3400ae0e:	f240 3175 	movw	r1, #885	@ 0x375
3400ae12:	4846      	ldr	r0, [pc, #280]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ae14:	f7f7 fb92 	bl	3400253c <assert_failed>
    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3400ae18:	f8d4 30ec 	ldr.w	r3, [r4, #236]	@ 0xec
3400ae1c:	4a48      	ldr	r2, [pc, #288]	@ (3400af40 <HAL_RCCEx_PeriphCLKConfig+0xb40>)
3400ae1e:	4293      	cmp	r3, r2
3400ae20:	f041 84f5 	bne.w	3400c80e <HAL_RCCEx_PeriphCLKConfig+0x240e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400ae24:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400ae26:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ae2a:	d004      	beq.n	3400ae36 <HAL_RCCEx_PeriphCLKConfig+0xa36>
3400ae2c:	f240 317a 	movw	r1, #890	@ 0x37a
3400ae30:	483e      	ldr	r0, [pc, #248]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ae32:	f7f7 fb83 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400ae36:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400ae38:	3b01      	subs	r3, #1
3400ae3a:	2bff      	cmp	r3, #255	@ 0xff
3400ae3c:	d904      	bls.n	3400ae48 <HAL_RCCEx_PeriphCLKConfig+0xa48>
3400ae3e:	f240 317b 	movw	r1, #891	@ 0x37b
3400ae42:	483a      	ldr	r0, [pc, #232]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ae44:	f7f7 fb7a 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400ae48:	4a39      	ldr	r2, [pc, #228]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400ae4a:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400ae4c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400ae50:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400ae52:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ae56:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ae5a:	3901      	subs	r1, #1
3400ae5c:	4303      	orrs	r3, r0
3400ae5e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ae62:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400ae66:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ae6a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ae6e:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
3400ae72:	f7ff f9e1 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3400ae76:	6823      	ldr	r3, [r4, #0]
3400ae78:	045a      	lsls	r2, r3, #17
3400ae7a:	d540      	bpl.n	3400aefe <HAL_RCCEx_PeriphCLKConfig+0xafe>
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
3400ae7c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400ae80:	4a30      	ldr	r2, [pc, #192]	@ (3400af44 <HAL_RCCEx_PeriphCLKConfig+0xb44>)
3400ae82:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ae86:	4291      	cmp	r1, r2
3400ae88:	d00a      	beq.n	3400aea0 <HAL_RCCEx_PeriphCLKConfig+0xaa0>
3400ae8a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400ae8e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ae92:	4293      	cmp	r3, r2
3400ae94:	d004      	beq.n	3400aea0 <HAL_RCCEx_PeriphCLKConfig+0xaa0>
3400ae96:	f240 31a2 	movw	r1, #930	@ 0x3a2
3400ae9a:	4824      	ldr	r0, [pc, #144]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400ae9c:	f7f7 fb4e 	bl	3400253c <assert_failed>
    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3400aea0:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3400aea4:	4a28      	ldr	r2, [pc, #160]	@ (3400af48 <HAL_RCCEx_PeriphCLKConfig+0xb48>)
3400aea6:	4293      	cmp	r3, r2
3400aea8:	f041 84f6 	bne.w	3400c898 <HAL_RCCEx_PeriphCLKConfig+0x2498>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400aeac:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400aeae:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400aeb2:	d004      	beq.n	3400aebe <HAL_RCCEx_PeriphCLKConfig+0xabe>
3400aeb4:	f240 31a7 	movw	r1, #935	@ 0x3a7
3400aeb8:	481c      	ldr	r0, [pc, #112]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400aeba:	f7f7 fb3f 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400aebe:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400aec0:	3b01      	subs	r3, #1
3400aec2:	2bff      	cmp	r3, #255	@ 0xff
3400aec4:	d904      	bls.n	3400aed0 <HAL_RCCEx_PeriphCLKConfig+0xad0>
3400aec6:	f44f 716a 	mov.w	r1, #936	@ 0x3a8
3400aeca:	4818      	ldr	r0, [pc, #96]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400aecc:	f7f7 fb36 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400aed0:	4a17      	ldr	r2, [pc, #92]	@ (3400af30 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
3400aed2:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400aed4:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400aed8:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400aeda:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aede:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aee2:	3901      	subs	r1, #1
3400aee4:	4303      	orrs	r3, r0
3400aee6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400aeea:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400aeee:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400aef2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400aef6:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
3400aefa:	f7ff f99d 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
3400aefe:	6823      	ldr	r3, [r4, #0]
3400af00:	041b      	lsls	r3, r3, #16
3400af02:	d554      	bpl.n	3400afae <HAL_RCCEx_PeriphCLKConfig+0xbae>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
3400af04:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400af08:	4a10      	ldr	r2, [pc, #64]	@ (3400af4c <HAL_RCCEx_PeriphCLKConfig+0xb4c>)
3400af0a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400af0e:	4291      	cmp	r1, r2
3400af10:	d01e      	beq.n	3400af50 <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400af12:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400af16:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400af1a:	4293      	cmp	r3, r2
3400af1c:	d018      	beq.n	3400af50 <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400af1e:	f240 31cf 	movw	r1, #975	@ 0x3cf
3400af22:	4802      	ldr	r0, [pc, #8]	@ (3400af2c <HAL_RCCEx_PeriphCLKConfig+0xb2c>)
3400af24:	f7f7 fb0a 	bl	3400253c <assert_failed>
3400af28:	e012      	b.n	3400af50 <HAL_RCCEx_PeriphCLKConfig+0xb50>
3400af2a:	bf00      	nop
3400af2c:	3401c7d4 	.word	0x3401c7d4
3400af30:	56028000 	.word	0x56028000
3400af34:	0700000c 	.word	0x0700000c
3400af38:	0702000c 	.word	0x0702000c
3400af3c:	0700040c 	.word	0x0700040c
3400af40:	0702040c 	.word	0x0702040c
3400af44:	0700080c 	.word	0x0700080c
3400af48:	0702080c 	.word	0x0702080c
3400af4c:	07000c0c 	.word	0x07000c0c
    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3400af50:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
3400af54:	4abd      	ldr	r2, [pc, #756]	@ (3400b24c <HAL_RCCEx_PeriphCLKConfig+0xe4c>)
3400af56:	4293      	cmp	r3, r2
3400af58:	f041 84cf 	bne.w	3400c8fa <HAL_RCCEx_PeriphCLKConfig+0x24fa>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400af5c:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400af5e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400af62:	d004      	beq.n	3400af6e <HAL_RCCEx_PeriphCLKConfig+0xb6e>
3400af64:	f44f 7175 	mov.w	r1, #980	@ 0x3d4
3400af68:	48b9      	ldr	r0, [pc, #740]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400af6a:	f7f7 fae7 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400af6e:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400af70:	3b01      	subs	r3, #1
3400af72:	2bff      	cmp	r3, #255	@ 0xff
3400af74:	d904      	bls.n	3400af80 <HAL_RCCEx_PeriphCLKConfig+0xb80>
3400af76:	f240 31d5 	movw	r1, #981	@ 0x3d5
3400af7a:	48b5      	ldr	r0, [pc, #724]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400af7c:	f7f7 fade 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400af80:	4ab4      	ldr	r2, [pc, #720]	@ (3400b254 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400af82:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400af84:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400af88:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400af8a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400af8e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400af92:	3901      	subs	r1, #1
3400af94:	4303      	orrs	r3, r0
3400af96:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400af9a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400af9e:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400afa2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400afa6:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
3400afaa:	f7ff f945 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3400afae:	6823      	ldr	r3, [r4, #0]
3400afb0:	03de      	lsls	r6, r3, #15
3400afb2:	d540      	bpl.n	3400b036 <HAL_RCCEx_PeriphCLKConfig+0xc36>
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));
3400afb4:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400afb8:	4aa7      	ldr	r2, [pc, #668]	@ (3400b258 <HAL_RCCEx_PeriphCLKConfig+0xe58>)
3400afba:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400afbe:	4291      	cmp	r1, r2
3400afc0:	d00a      	beq.n	3400afd8 <HAL_RCCEx_PeriphCLKConfig+0xbd8>
3400afc2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400afc6:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400afca:	4293      	cmp	r3, r2
3400afcc:	d004      	beq.n	3400afd8 <HAL_RCCEx_PeriphCLKConfig+0xbd8>
3400afce:	f44f 717f 	mov.w	r1, #1020	@ 0x3fc
3400afd2:	489f      	ldr	r0, [pc, #636]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400afd4:	f7f7 fab2 	bl	3400253c <assert_failed>
    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
3400afd8:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
3400afdc:	4a9f      	ldr	r2, [pc, #636]	@ (3400b25c <HAL_RCCEx_PeriphCLKConfig+0xe5c>)
3400afde:	4293      	cmp	r3, r2
3400afe0:	f041 84bc 	bne.w	3400c95c <HAL_RCCEx_PeriphCLKConfig+0x255c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400afe4:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400afe6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400afea:	d004      	beq.n	3400aff6 <HAL_RCCEx_PeriphCLKConfig+0xbf6>
3400afec:	f240 4101 	movw	r1, #1025	@ 0x401
3400aff0:	4897      	ldr	r0, [pc, #604]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400aff2:	f7f7 faa3 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400aff6:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400aff8:	3b01      	subs	r3, #1
3400affa:	2bff      	cmp	r3, #255	@ 0xff
3400affc:	d904      	bls.n	3400b008 <HAL_RCCEx_PeriphCLKConfig+0xc08>
3400affe:	f240 4102 	movw	r1, #1026	@ 0x402
3400b002:	4893      	ldr	r0, [pc, #588]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b004:	f7f7 fa9a 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b008:	4a92      	ldr	r2, [pc, #584]	@ (3400b254 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b00a:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b00c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b010:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b012:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b016:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b01a:	3901      	subs	r1, #1
3400b01c:	4303      	orrs	r3, r0
3400b01e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b022:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b026:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b02a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b02e:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
3400b032:	f7ff f901 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3400b036:	6823      	ldr	r3, [r4, #0]
3400b038:	0398      	lsls	r0, r3, #14
3400b03a:	d540      	bpl.n	3400b0be <HAL_RCCEx_PeriphCLKConfig+0xcbe>
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));
3400b03c:	f8d4 30fc 	ldr.w	r3, [r4, #252]	@ 0xfc
3400b040:	4a87      	ldr	r2, [pc, #540]	@ (3400b260 <HAL_RCCEx_PeriphCLKConfig+0xe60>)
3400b042:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b046:	4291      	cmp	r1, r2
3400b048:	d00a      	beq.n	3400b060 <HAL_RCCEx_PeriphCLKConfig+0xc60>
3400b04a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b04e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b052:	4293      	cmp	r3, r2
3400b054:	d004      	beq.n	3400b060 <HAL_RCCEx_PeriphCLKConfig+0xc60>
3400b056:	f240 4129 	movw	r1, #1065	@ 0x429
3400b05a:	487d      	ldr	r0, [pc, #500]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b05c:	f7f7 fa6e 	bl	3400253c <assert_failed>
    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3400b060:	f8d4 30fc 	ldr.w	r3, [r4, #252]	@ 0xfc
3400b064:	4a7f      	ldr	r2, [pc, #508]	@ (3400b264 <HAL_RCCEx_PeriphCLKConfig+0xe64>)
3400b066:	4293      	cmp	r3, r2
3400b068:	f041 84a9 	bne.w	3400c9be <HAL_RCCEx_PeriphCLKConfig+0x25be>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400b06c:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400b06e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b072:	d004      	beq.n	3400b07e <HAL_RCCEx_PeriphCLKConfig+0xc7e>
3400b074:	f240 412e 	movw	r1, #1070	@ 0x42e
3400b078:	4875      	ldr	r0, [pc, #468]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b07a:	f7f7 fa5f 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400b07e:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400b080:	3b01      	subs	r3, #1
3400b082:	2bff      	cmp	r3, #255	@ 0xff
3400b084:	d904      	bls.n	3400b090 <HAL_RCCEx_PeriphCLKConfig+0xc90>
3400b086:	f240 412f 	movw	r1, #1071	@ 0x42f
3400b08a:	4871      	ldr	r0, [pc, #452]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b08c:	f7f7 fa56 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400b090:	4a70      	ldr	r2, [pc, #448]	@ (3400b254 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b092:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400b094:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400b098:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400b09a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b09e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b0a2:	3901      	subs	r1, #1
3400b0a4:	4303      	orrs	r3, r0
3400b0a6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b0aa:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400b0ae:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b0b2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b0b6:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3400b0ba:	f7ff f8bd 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3400b0be:	6823      	ldr	r3, [r4, #0]
3400b0c0:	0359      	lsls	r1, r3, #13
3400b0c2:	d540      	bpl.n	3400b146 <HAL_RCCEx_PeriphCLKConfig+0xd46>
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));
3400b0c4:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400b0c8:	4a67      	ldr	r2, [pc, #412]	@ (3400b268 <HAL_RCCEx_PeriphCLKConfig+0xe68>)
3400b0ca:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b0ce:	4291      	cmp	r1, r2
3400b0d0:	d00a      	beq.n	3400b0e8 <HAL_RCCEx_PeriphCLKConfig+0xce8>
3400b0d2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b0d6:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b0da:	4293      	cmp	r3, r2
3400b0dc:	d004      	beq.n	3400b0e8 <HAL_RCCEx_PeriphCLKConfig+0xce8>
3400b0de:	f240 4156 	movw	r1, #1110	@ 0x456
3400b0e2:	485b      	ldr	r0, [pc, #364]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b0e4:	f7f7 fa2a 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3400b0e8:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
3400b0ec:	4a5f      	ldr	r2, [pc, #380]	@ (3400b26c <HAL_RCCEx_PeriphCLKConfig+0xe6c>)
3400b0ee:	4293      	cmp	r3, r2
3400b0f0:	f041 8496 	bne.w	3400ca20 <HAL_RCCEx_PeriphCLKConfig+0x2620>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b0f4:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b0f6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b0fa:	d004      	beq.n	3400b106 <HAL_RCCEx_PeriphCLKConfig+0xd06>
3400b0fc:	f240 415b 	movw	r1, #1115	@ 0x45b
3400b100:	4853      	ldr	r0, [pc, #332]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b102:	f7f7 fa1b 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b106:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b108:	3b01      	subs	r3, #1
3400b10a:	2bff      	cmp	r3, #255	@ 0xff
3400b10c:	d904      	bls.n	3400b118 <HAL_RCCEx_PeriphCLKConfig+0xd18>
3400b10e:	f240 415c 	movw	r1, #1116	@ 0x45c
3400b112:	484f      	ldr	r0, [pc, #316]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b114:	f7f7 fa12 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b118:	4a4e      	ldr	r2, [pc, #312]	@ (3400b254 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b11a:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b11c:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b120:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b122:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b126:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b12a:	3901      	subs	r1, #1
3400b12c:	4303      	orrs	r3, r0
3400b12e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b132:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b136:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b13a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b13e:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
3400b142:	f7ff f879 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
3400b146:	6823      	ldr	r3, [r4, #0]
3400b148:	031a      	lsls	r2, r3, #12
3400b14a:	d540      	bpl.n	3400b1ce <HAL_RCCEx_PeriphCLKConfig+0xdce>
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));
3400b14c:	f8d4 3104 	ldr.w	r3, [r4, #260]	@ 0x104
3400b150:	4a47      	ldr	r2, [pc, #284]	@ (3400b270 <HAL_RCCEx_PeriphCLKConfig+0xe70>)
3400b152:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b156:	4291      	cmp	r1, r2
3400b158:	d00a      	beq.n	3400b170 <HAL_RCCEx_PeriphCLKConfig+0xd70>
3400b15a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b15e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b162:	4293      	cmp	r3, r2
3400b164:	d004      	beq.n	3400b170 <HAL_RCCEx_PeriphCLKConfig+0xd70>
3400b166:	f240 4176 	movw	r1, #1142	@ 0x476
3400b16a:	4839      	ldr	r0, [pc, #228]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b16c:	f7f7 f9e6 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3400b170:	f8d4 3104 	ldr.w	r3, [r4, #260]	@ 0x104
3400b174:	4a3f      	ldr	r2, [pc, #252]	@ (3400b274 <HAL_RCCEx_PeriphCLKConfig+0xe74>)
3400b176:	4293      	cmp	r3, r2
3400b178:	f041 845b 	bne.w	3400ca32 <HAL_RCCEx_PeriphCLKConfig+0x2632>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b17c:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b17e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b182:	d004      	beq.n	3400b18e <HAL_RCCEx_PeriphCLKConfig+0xd8e>
3400b184:	f240 417b 	movw	r1, #1147	@ 0x47b
3400b188:	4831      	ldr	r0, [pc, #196]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b18a:	f7f7 f9d7 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b18e:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b190:	3b01      	subs	r3, #1
3400b192:	2bff      	cmp	r3, #255	@ 0xff
3400b194:	d904      	bls.n	3400b1a0 <HAL_RCCEx_PeriphCLKConfig+0xda0>
3400b196:	f240 417c 	movw	r1, #1148	@ 0x47c
3400b19a:	482d      	ldr	r0, [pc, #180]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b19c:	f7f7 f9ce 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b1a0:	4a2c      	ldr	r2, [pc, #176]	@ (3400b254 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b1a2:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b1a4:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b1a8:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b1aa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b1ae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b1b2:	3901      	subs	r1, #1
3400b1b4:	4303      	orrs	r3, r0
3400b1b6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b1ba:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b1be:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b1c2:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b1c6:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
3400b1ca:	f7ff f835 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
3400b1ce:	6823      	ldr	r3, [r4, #0]
3400b1d0:	02db      	lsls	r3, r3, #11
3400b1d2:	d55b      	bpl.n	3400b28c <HAL_RCCEx_PeriphCLKConfig+0xe8c>
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));
3400b1d4:	f8d4 3108 	ldr.w	r3, [r4, #264]	@ 0x108
3400b1d8:	4a27      	ldr	r2, [pc, #156]	@ (3400b278 <HAL_RCCEx_PeriphCLKConfig+0xe78>)
3400b1da:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b1de:	4291      	cmp	r1, r2
3400b1e0:	d00a      	beq.n	3400b1f8 <HAL_RCCEx_PeriphCLKConfig+0xdf8>
3400b1e2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b1e6:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b1ea:	4293      	cmp	r3, r2
3400b1ec:	d004      	beq.n	3400b1f8 <HAL_RCCEx_PeriphCLKConfig+0xdf8>
3400b1ee:	f240 4196 	movw	r1, #1174	@ 0x496
3400b1f2:	4817      	ldr	r0, [pc, #92]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b1f4:	f7f7 f9a2 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3400b1f8:	f8d4 3108 	ldr.w	r3, [r4, #264]	@ 0x108
3400b1fc:	4a1f      	ldr	r2, [pc, #124]	@ (3400b27c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
3400b1fe:	4293      	cmp	r3, r2
3400b200:	f041 8420 	bne.w	3400ca44 <HAL_RCCEx_PeriphCLKConfig+0x2644>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b204:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b206:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b20a:	d004      	beq.n	3400b216 <HAL_RCCEx_PeriphCLKConfig+0xe16>
3400b20c:	f240 419b 	movw	r1, #1179	@ 0x49b
3400b210:	480f      	ldr	r0, [pc, #60]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b212:	f7f7 f993 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b216:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b218:	3b01      	subs	r3, #1
3400b21a:	2bff      	cmp	r3, #255	@ 0xff
3400b21c:	d904      	bls.n	3400b228 <HAL_RCCEx_PeriphCLKConfig+0xe28>
3400b21e:	f240 419c 	movw	r1, #1180	@ 0x49c
3400b222:	480b      	ldr	r0, [pc, #44]	@ (3400b250 <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3400b224:	f7f7 f98a 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b228:	4a0a      	ldr	r2, [pc, #40]	@ (3400b254 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3400b22a:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b22c:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b230:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b232:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b236:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b23a:	3901      	subs	r1, #1
3400b23c:	4303      	orrs	r3, r0
3400b23e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b242:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b246:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b24a:	e019      	b.n	3400b280 <HAL_RCCEx_PeriphCLKConfig+0xe80>
3400b24c:	07020c0c 	.word	0x07020c0c
3400b250:	3401c7d4 	.word	0x3401c7d4
3400b254:	56028000 	.word	0x56028000
3400b258:	0700100c 	.word	0x0700100c
3400b25c:	0702100c 	.word	0x0702100c
3400b260:	0700140c 	.word	0x0700140c
3400b264:	0702140c 	.word	0x0702140c
3400b268:	0700082c 	.word	0x0700082c
3400b26c:	0702082c 	.word	0x0702082c
3400b270:	07000c2c 	.word	0x07000c2c
3400b274:	07020c2c 	.word	0x07020c2c
3400b278:	0700102c 	.word	0x0700102c
3400b27c:	0702102c 	.word	0x0702102c
3400b280:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b284:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
3400b288:	f7fe ffd6 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3400b28c:	6823      	ldr	r3, [r4, #0]
3400b28e:	029e      	lsls	r6, r3, #10
3400b290:	d540      	bpl.n	3400b314 <HAL_RCCEx_PeriphCLKConfig+0xf14>
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));
3400b292:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
3400b296:	4ac2      	ldr	r2, [pc, #776]	@ (3400b5a0 <HAL_RCCEx_PeriphCLKConfig+0x11a0>)
3400b298:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b29c:	4291      	cmp	r1, r2
3400b29e:	d00a      	beq.n	3400b2b6 <HAL_RCCEx_PeriphCLKConfig+0xeb6>
3400b2a0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b2a4:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b2a8:	4293      	cmp	r3, r2
3400b2aa:	d004      	beq.n	3400b2b6 <HAL_RCCEx_PeriphCLKConfig+0xeb6>
3400b2ac:	f240 41b6 	movw	r1, #1206	@ 0x4b6
3400b2b0:	48bc      	ldr	r0, [pc, #752]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b2b2:	f7f7 f943 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3400b2b6:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
3400b2ba:	4abb      	ldr	r2, [pc, #748]	@ (3400b5a8 <HAL_RCCEx_PeriphCLKConfig+0x11a8>)
3400b2bc:	4293      	cmp	r3, r2
3400b2be:	f041 83ca 	bne.w	3400ca56 <HAL_RCCEx_PeriphCLKConfig+0x2656>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b2c2:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b2c4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b2c8:	d004      	beq.n	3400b2d4 <HAL_RCCEx_PeriphCLKConfig+0xed4>
3400b2ca:	f240 41bb 	movw	r1, #1211	@ 0x4bb
3400b2ce:	48b5      	ldr	r0, [pc, #724]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b2d0:	f7f7 f934 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b2d4:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b2d6:	3b01      	subs	r3, #1
3400b2d8:	2bff      	cmp	r3, #255	@ 0xff
3400b2da:	d904      	bls.n	3400b2e6 <HAL_RCCEx_PeriphCLKConfig+0xee6>
3400b2dc:	f240 41bc 	movw	r1, #1212	@ 0x4bc
3400b2e0:	48b0      	ldr	r0, [pc, #704]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b2e2:	f7f7 f92b 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b2e6:	4ab1      	ldr	r2, [pc, #708]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b2e8:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b2ea:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b2ee:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b2f0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b2f4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b2f8:	3901      	subs	r1, #1
3400b2fa:	4303      	orrs	r3, r0
3400b2fc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b300:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b304:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b308:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b30c:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
3400b310:	f7fe ff92 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3400b314:	6823      	ldr	r3, [r4, #0]
3400b316:	0258      	lsls	r0, r3, #9
3400b318:	d540      	bpl.n	3400b39c <HAL_RCCEx_PeriphCLKConfig+0xf9c>
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));
3400b31a:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
3400b31e:	4aa4      	ldr	r2, [pc, #656]	@ (3400b5b0 <HAL_RCCEx_PeriphCLKConfig+0x11b0>)
3400b320:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b324:	4291      	cmp	r1, r2
3400b326:	d00a      	beq.n	3400b33e <HAL_RCCEx_PeriphCLKConfig+0xf3e>
3400b328:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400b32c:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b330:	4293      	cmp	r3, r2
3400b332:	d004      	beq.n	3400b33e <HAL_RCCEx_PeriphCLKConfig+0xf3e>
3400b334:	f240 41d6 	movw	r1, #1238	@ 0x4d6
3400b338:	489a      	ldr	r0, [pc, #616]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b33a:	f7f7 f8ff 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3400b33e:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
3400b342:	4a9c      	ldr	r2, [pc, #624]	@ (3400b5b4 <HAL_RCCEx_PeriphCLKConfig+0x11b4>)
3400b344:	4293      	cmp	r3, r2
3400b346:	f041 838f 	bne.w	3400ca68 <HAL_RCCEx_PeriphCLKConfig+0x2668>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400b34a:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400b34c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b350:	d004      	beq.n	3400b35c <HAL_RCCEx_PeriphCLKConfig+0xf5c>
3400b352:	f240 41db 	movw	r1, #1243	@ 0x4db
3400b356:	4893      	ldr	r0, [pc, #588]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b358:	f7f7 f8f0 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400b35c:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400b35e:	3b01      	subs	r3, #1
3400b360:	2bff      	cmp	r3, #255	@ 0xff
3400b362:	d904      	bls.n	3400b36e <HAL_RCCEx_PeriphCLKConfig+0xf6e>
3400b364:	f240 41dc 	movw	r1, #1244	@ 0x4dc
3400b368:	488e      	ldr	r0, [pc, #568]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b36a:	f7f7 f8e7 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400b36e:	4a8f      	ldr	r2, [pc, #572]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b370:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400b372:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400b376:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400b378:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b37c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b380:	3901      	subs	r1, #1
3400b382:	4303      	orrs	r3, r0
3400b384:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b388:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400b38c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b390:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b394:	f8d4 0110 	ldr.w	r0, [r4, #272]	@ 0x110
3400b398:	f7fe ff4e 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3400b39c:	6823      	ldr	r3, [r4, #0]
3400b39e:	0219      	lsls	r1, r3, #8
3400b3a0:	d546      	bpl.n	3400b430 <HAL_RCCEx_PeriphCLKConfig+0x1030>
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
3400b3a2:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
3400b3a6:	f433 7240 	bics.w	r2, r3, #768	@ 0x300
3400b3aa:	d00c      	beq.n	3400b3c6 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400b3ac:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
3400b3b0:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
3400b3b4:	d007      	beq.n	3400b3c6 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400b3b6:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400b3ba:	d004      	beq.n	3400b3c6 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
3400b3bc:	f240 41f6 	movw	r1, #1270	@ 0x4f6
3400b3c0:	4878      	ldr	r0, [pc, #480]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b3c2:	f7f7 f8bb 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
3400b3c6:	f8d4 3114 	ldr.w	r3, [r4, #276]	@ 0x114
3400b3ca:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400b3ce:	f041 8354 	bne.w	3400ca7a <HAL_RCCEx_PeriphCLKConfig+0x267a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400b3d2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400b3d4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b3d8:	d004      	beq.n	3400b3e4 <HAL_RCCEx_PeriphCLKConfig+0xfe4>
3400b3da:	f240 41fb 	movw	r1, #1275	@ 0x4fb
3400b3de:	4871      	ldr	r0, [pc, #452]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b3e0:	f7f7 f8ac 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400b3e4:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400b3e6:	3b01      	subs	r3, #1
3400b3e8:	2bff      	cmp	r3, #255	@ 0xff
3400b3ea:	d904      	bls.n	3400b3f6 <HAL_RCCEx_PeriphCLKConfig+0xff6>
3400b3ec:	f240 41fc 	movw	r1, #1276	@ 0x4fc
3400b3f0:	486c      	ldr	r0, [pc, #432]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b3f2:	f7f7 f8a3 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400b3f6:	4a6d      	ldr	r2, [pc, #436]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b3f8:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400b3fa:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400b3fe:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400b400:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b404:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b408:	3901      	subs	r1, #1
3400b40a:	4303      	orrs	r3, r0
3400b40c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b410:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b414:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400b418:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3400b41c:	4a63      	ldr	r2, [pc, #396]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b41e:	f8d4 1114 	ldr.w	r1, [r4, #276]	@ 0x114
3400b422:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400b426:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
3400b42a:	430b      	orrs	r3, r1
3400b42c:	f8c2 3178 	str.w	r3, [r2, #376]	@ 0x178
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
3400b430:	6823      	ldr	r3, [r4, #0]
3400b432:	01da      	lsls	r2, r3, #7
3400b434:	d542      	bpl.n	3400b4bc <HAL_RCCEx_PeriphCLKConfig+0x10bc>
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));
3400b436:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
3400b43a:	f033 7340 	bics.w	r3, r3, #50331648	@ 0x3000000
3400b43e:	d004      	beq.n	3400b44a <HAL_RCCEx_PeriphCLKConfig+0x104a>
3400b440:	f240 5123 	movw	r1, #1315	@ 0x523
3400b444:	4857      	ldr	r0, [pc, #348]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b446:	f7f7 f879 	bl	3400253c <assert_failed>
    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
3400b44a:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
3400b44e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400b452:	f041 8343 	bne.w	3400cadc <HAL_RCCEx_PeriphCLKConfig+0x26dc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
3400b456:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3400b45a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b45e:	d004      	beq.n	3400b46a <HAL_RCCEx_PeriphCLKConfig+0x106a>
3400b460:	f44f 61a5 	mov.w	r1, #1320	@ 0x528
3400b464:	484f      	ldr	r0, [pc, #316]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b466:	f7f7 f869 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));
3400b46a:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
3400b46e:	3b01      	subs	r3, #1
3400b470:	2bff      	cmp	r3, #255	@ 0xff
3400b472:	d904      	bls.n	3400b47e <HAL_RCCEx_PeriphCLKConfig+0x107e>
3400b474:	f240 5129 	movw	r1, #1321	@ 0x529
3400b478:	484a      	ldr	r0, [pc, #296]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b47a:	f7f7 f85f 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
3400b47e:	4a4b      	ldr	r2, [pc, #300]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b480:	f8d4 1084 	ldr.w	r1, [r4, #132]	@ 0x84
3400b484:	f8d2 3100 	ldr.w	r3, [r2, #256]	@ 0x100
3400b488:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
3400b48c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b490:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b494:	3901      	subs	r1, #1
3400b496:	4303      	orrs	r3, r0
3400b498:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b49c:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3400b4a0:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400b4a4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3400b4a8:	4a40      	ldr	r2, [pc, #256]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b4aa:	f8d4 1118 	ldr.w	r1, [r4, #280]	@ 0x118
3400b4ae:	f8d2 3150 	ldr.w	r3, [r2, #336]	@ 0x150
3400b4b2:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400b4b6:	430b      	orrs	r3, r1
3400b4b8:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3400b4bc:	6823      	ldr	r3, [r4, #0]
3400b4be:	019b      	lsls	r3, r3, #6
3400b4c0:	d540      	bpl.n	3400b544 <HAL_RCCEx_PeriphCLKConfig+0x1144>
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));
3400b4c2:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
3400b4c6:	f433 3340 	bics.w	r3, r3, #196608	@ 0x30000
3400b4ca:	d007      	beq.n	3400b4dc <HAL_RCCEx_PeriphCLKConfig+0x10dc>
3400b4cc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400b4d0:	d004      	beq.n	3400b4dc <HAL_RCCEx_PeriphCLKConfig+0x10dc>
3400b4d2:	f240 5143 	movw	r1, #1347	@ 0x543
3400b4d6:	4833      	ldr	r0, [pc, #204]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b4d8:	f7f7 f830 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3400b4dc:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
3400b4e0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400b4e4:	f041 8303 	bne.w	3400caee <HAL_RCCEx_PeriphCLKConfig+0x26ee>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b4e8:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b4ea:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b4ee:	d004      	beq.n	3400b4fa <HAL_RCCEx_PeriphCLKConfig+0x10fa>
3400b4f0:	f44f 61a9 	mov.w	r1, #1352	@ 0x548
3400b4f4:	482b      	ldr	r0, [pc, #172]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b4f6:	f7f7 f821 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b4fa:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b4fc:	3b01      	subs	r3, #1
3400b4fe:	2bff      	cmp	r3, #255	@ 0xff
3400b500:	d904      	bls.n	3400b50c <HAL_RCCEx_PeriphCLKConfig+0x110c>
3400b502:	f240 5149 	movw	r1, #1353	@ 0x549
3400b506:	4827      	ldr	r0, [pc, #156]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b508:	f7f7 f818 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b50c:	4a27      	ldr	r2, [pc, #156]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b50e:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b510:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b514:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b516:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b51a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b51e:	3901      	subs	r1, #1
3400b520:	4303      	orrs	r3, r0
3400b522:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b526:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b52a:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b52c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3400b530:	4a1e      	ldr	r2, [pc, #120]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b532:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
3400b536:	f8d2 3154 	ldr.w	r3, [r2, #340]	@ 0x154
3400b53a:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400b53e:	430b      	orrs	r3, r1
3400b540:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3400b544:	6823      	ldr	r3, [r4, #0]
3400b546:	015e      	lsls	r6, r3, #5
3400b548:	d54e      	bpl.n	3400b5e8 <HAL_RCCEx_PeriphCLKConfig+0x11e8>
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));
3400b54a:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
3400b54e:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
3400b552:	d004      	beq.n	3400b55e <HAL_RCCEx_PeriphCLKConfig+0x115e>
3400b554:	f44f 61ae 	mov.w	r1, #1392	@ 0x570
3400b558:	4812      	ldr	r0, [pc, #72]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b55a:	f7f6 ffef 	bl	3400253c <assert_failed>
    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3400b55e:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
3400b562:	2b20      	cmp	r3, #32
3400b564:	f041 82f3 	bne.w	3400cb4e <HAL_RCCEx_PeriphCLKConfig+0x274e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400b568:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400b56c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b570:	d004      	beq.n	3400b57c <HAL_RCCEx_PeriphCLKConfig+0x117c>
3400b572:	f240 5175 	movw	r1, #1397	@ 0x575
3400b576:	480b      	ldr	r0, [pc, #44]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b578:	f7f6 ffe0 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400b57c:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
3400b580:	3b01      	subs	r3, #1
3400b582:	2bff      	cmp	r3, #255	@ 0xff
3400b584:	d904      	bls.n	3400b590 <HAL_RCCEx_PeriphCLKConfig+0x1190>
3400b586:	f240 5176 	movw	r1, #1398	@ 0x576
3400b58a:	4806      	ldr	r0, [pc, #24]	@ (3400b5a4 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3400b58c:	f7f6 ffd6 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400b590:	4a06      	ldr	r2, [pc, #24]	@ (3400b5ac <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3400b592:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
3400b596:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3400b59a:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
3400b59e:	e00b      	b.n	3400b5b8 <HAL_RCCEx_PeriphCLKConfig+0x11b8>
3400b5a0:	0700142c 	.word	0x0700142c
3400b5a4:	3401c7d4 	.word	0x3401c7d4
3400b5a8:	0702142c 	.word	0x0702142c
3400b5ac:	56028000 	.word	0x56028000
3400b5b0:	0700182c 	.word	0x0700182c
3400b5b4:	0702182c 	.word	0x0702182c
3400b5b8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b5bc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b5c0:	3901      	subs	r1, #1
3400b5c2:	4303      	orrs	r3, r0
3400b5c4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b5c8:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400b5cc:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3400b5d0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3400b5d4:	4abc      	ldr	r2, [pc, #752]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b5d6:	f8d4 1120 	ldr.w	r1, [r4, #288]	@ 0x120
3400b5da:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400b5de:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3400b5e2:	430b      	orrs	r3, r1
3400b5e4:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3400b5e8:	6823      	ldr	r3, [r4, #0]
3400b5ea:	00d8      	lsls	r0, r3, #3
3400b5ec:	d53d      	bpl.n	3400b66a <HAL_RCCEx_PeriphCLKConfig+0x126a>
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
3400b5ee:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
3400b5f2:	4ab6      	ldr	r2, [pc, #728]	@ (3400b8cc <HAL_RCCEx_PeriphCLKConfig+0x14cc>)
3400b5f4:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400b5f8:	4293      	cmp	r3, r2
3400b5fa:	d008      	beq.n	3400b60e <HAL_RCCEx_PeriphCLKConfig+0x120e>
3400b5fc:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b600:	4293      	cmp	r3, r2
3400b602:	d004      	beq.n	3400b60e <HAL_RCCEx_PeriphCLKConfig+0x120e>
3400b604:	f44f 61b2 	mov.w	r1, #1424	@ 0x590
3400b608:	48b1      	ldr	r0, [pc, #708]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b60a:	f7f6 ff97 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3400b60e:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
3400b612:	4ab0      	ldr	r2, [pc, #704]	@ (3400b8d4 <HAL_RCCEx_PeriphCLKConfig+0x14d4>)
3400b614:	4293      	cmp	r3, r2
3400b616:	f041 82c1 	bne.w	3400cb9c <HAL_RCCEx_PeriphCLKConfig+0x279c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b61a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b61c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b620:	d004      	beq.n	3400b62c <HAL_RCCEx_PeriphCLKConfig+0x122c>
3400b622:	f240 5195 	movw	r1, #1429	@ 0x595
3400b626:	48aa      	ldr	r0, [pc, #680]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b628:	f7f6 ff88 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b62c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b62e:	3b01      	subs	r3, #1
3400b630:	2bff      	cmp	r3, #255	@ 0xff
3400b632:	d904      	bls.n	3400b63e <HAL_RCCEx_PeriphCLKConfig+0x123e>
3400b634:	f240 5196 	movw	r1, #1430	@ 0x596
3400b638:	48a5      	ldr	r0, [pc, #660]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b63a:	f7f6 ff7f 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b63e:	4aa2      	ldr	r2, [pc, #648]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b640:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b642:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b646:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b648:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b64c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b650:	3901      	subs	r1, #1
3400b652:	4303      	orrs	r3, r0
3400b654:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b658:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b65c:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b65e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b662:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
3400b666:	f7fe fde7 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
3400b66a:	6823      	ldr	r3, [r4, #0]
3400b66c:	0099      	lsls	r1, r3, #2
3400b66e:	d53d      	bpl.n	3400b6ec <HAL_RCCEx_PeriphCLKConfig+0x12ec>
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
3400b670:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
3400b674:	4a98      	ldr	r2, [pc, #608]	@ (3400b8d8 <HAL_RCCEx_PeriphCLKConfig+0x14d8>)
3400b676:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
3400b67a:	4293      	cmp	r3, r2
3400b67c:	d008      	beq.n	3400b690 <HAL_RCCEx_PeriphCLKConfig+0x1290>
3400b67e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b682:	4293      	cmp	r3, r2
3400b684:	d004      	beq.n	3400b690 <HAL_RCCEx_PeriphCLKConfig+0x1290>
3400b686:	f240 51bd 	movw	r1, #1469	@ 0x5bd
3400b68a:	4891      	ldr	r0, [pc, #580]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b68c:	f7f6 ff56 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3400b690:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
3400b694:	4a91      	ldr	r2, [pc, #580]	@ (3400b8dc <HAL_RCCEx_PeriphCLKConfig+0x14dc>)
3400b696:	4293      	cmp	r3, r2
3400b698:	f041 82b0 	bne.w	3400cbfc <HAL_RCCEx_PeriphCLKConfig+0x27fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b69c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b69e:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b6a2:	d004      	beq.n	3400b6ae <HAL_RCCEx_PeriphCLKConfig+0x12ae>
3400b6a4:	f240 51c2 	movw	r1, #1474	@ 0x5c2
3400b6a8:	4889      	ldr	r0, [pc, #548]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b6aa:	f7f6 ff47 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b6ae:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b6b0:	3b01      	subs	r3, #1
3400b6b2:	2bff      	cmp	r3, #255	@ 0xff
3400b6b4:	d904      	bls.n	3400b6c0 <HAL_RCCEx_PeriphCLKConfig+0x12c0>
3400b6b6:	f240 51c3 	movw	r1, #1475	@ 0x5c3
3400b6ba:	4885      	ldr	r0, [pc, #532]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b6bc:	f7f6 ff3e 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b6c0:	4a81      	ldr	r2, [pc, #516]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b6c2:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b6c4:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b6c8:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b6ca:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b6ce:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b6d2:	3901      	subs	r1, #1
3400b6d4:	4303      	orrs	r3, r0
3400b6d6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b6da:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b6de:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b6e0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b6e4:	f8d4 0128 	ldr.w	r0, [r4, #296]	@ 0x128
3400b6e8:	f7fe fda6 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3400b6ec:	6863      	ldr	r3, [r4, #4]
3400b6ee:	07da      	lsls	r2, r3, #31
3400b6f0:	d53b      	bpl.n	3400b76a <HAL_RCCEx_PeriphCLKConfig+0x136a>
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));
3400b6f2:	f8d4 314c 	ldr.w	r3, [r4, #332]	@ 0x14c
3400b6f6:	2b06      	cmp	r3, #6
3400b6f8:	d904      	bls.n	3400b704 <HAL_RCCEx_PeriphCLKConfig+0x1304>
3400b6fa:	f240 51ea 	movw	r1, #1514	@ 0x5ea
3400b6fe:	4874      	ldr	r0, [pc, #464]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b700:	f7f6 ff1c 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
3400b704:	f8d4 314c 	ldr.w	r3, [r4, #332]	@ 0x14c
3400b708:	2b02      	cmp	r3, #2
3400b70a:	f041 82a7 	bne.w	3400cc5c <HAL_RCCEx_PeriphCLKConfig+0x285c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
3400b70e:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400b710:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b714:	d004      	beq.n	3400b720 <HAL_RCCEx_PeriphCLKConfig+0x1320>
3400b716:	f240 51ef 	movw	r1, #1519	@ 0x5ef
3400b71a:	486d      	ldr	r0, [pc, #436]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b71c:	f7f6 ff0e 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));
3400b720:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400b722:	3b01      	subs	r3, #1
3400b724:	2bff      	cmp	r3, #255	@ 0xff
3400b726:	d904      	bls.n	3400b732 <HAL_RCCEx_PeriphCLKConfig+0x1332>
3400b728:	f44f 61be 	mov.w	r1, #1520	@ 0x5f0
3400b72c:	4868      	ldr	r0, [pc, #416]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b72e:	f7f6 ff05 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400b732:	4a65      	ldr	r2, [pc, #404]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b734:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400b736:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3400b73a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
3400b73c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b740:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b744:	3901      	subs	r1, #1
3400b746:	4303      	orrs	r3, r0
3400b748:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b74c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400b750:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b752:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3400b756:	4a5c      	ldr	r2, [pc, #368]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b758:	f8d4 114c 	ldr.w	r1, [r4, #332]	@ 0x14c
3400b75c:	f8d2 3164 	ldr.w	r3, [r2, #356]	@ 0x164
3400b760:	f023 0307 	bic.w	r3, r3, #7
3400b764:	430b      	orrs	r3, r1
3400b766:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
3400b76a:	6863      	ldr	r3, [r4, #4]
3400b76c:	079b      	lsls	r3, r3, #30
3400b76e:	d543      	bpl.n	3400b7f8 <HAL_RCCEx_PeriphCLKConfig+0x13f8>
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));
3400b770:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
3400b774:	4a5a      	ldr	r2, [pc, #360]	@ (3400b8e0 <HAL_RCCEx_PeriphCLKConfig+0x14e0>)
3400b776:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b77a:	4291      	cmp	r1, r2
3400b77c:	d00e      	beq.n	3400b79c <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400b77e:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b782:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b786:	4291      	cmp	r1, r2
3400b788:	d008      	beq.n	3400b79c <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400b78a:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b78e:	4293      	cmp	r3, r2
3400b790:	d004      	beq.n	3400b79c <HAL_RCCEx_PeriphCLKConfig+0x139c>
3400b792:	f240 6117 	movw	r1, #1559	@ 0x617
3400b796:	484e      	ldr	r0, [pc, #312]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b798:	f7f6 fed0 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
3400b79c:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
3400b7a0:	4a50      	ldr	r2, [pc, #320]	@ (3400b8e4 <HAL_RCCEx_PeriphCLKConfig+0x14e4>)
3400b7a2:	4293      	cmp	r3, r2
3400b7a4:	f041 8288 	bne.w	3400ccb8 <HAL_RCCEx_PeriphCLKConfig+0x28b8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b7a8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b7aa:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b7ae:	d004      	beq.n	3400b7ba <HAL_RCCEx_PeriphCLKConfig+0x13ba>
3400b7b0:	f240 611c 	movw	r1, #1564	@ 0x61c
3400b7b4:	4846      	ldr	r0, [pc, #280]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b7b6:	f7f6 fec1 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b7ba:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b7bc:	3b01      	subs	r3, #1
3400b7be:	2bff      	cmp	r3, #255	@ 0xff
3400b7c0:	d904      	bls.n	3400b7cc <HAL_RCCEx_PeriphCLKConfig+0x13cc>
3400b7c2:	f240 611d 	movw	r1, #1565	@ 0x61d
3400b7c6:	4842      	ldr	r0, [pc, #264]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b7c8:	f7f6 feb8 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b7cc:	4a3e      	ldr	r2, [pc, #248]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b7ce:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b7d0:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b7d4:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b7d6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b7da:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b7de:	3901      	subs	r1, #1
3400b7e0:	4303      	orrs	r3, r0
3400b7e2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b7e6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b7ea:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b7ec:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b7f0:	f8d4 0134 	ldr.w	r0, [r4, #308]	@ 0x134
3400b7f4:	f7fe fd20 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3400b7f8:	6863      	ldr	r3, [r4, #4]
3400b7fa:	075e      	lsls	r6, r3, #29
3400b7fc:	d543      	bpl.n	3400b886 <HAL_RCCEx_PeriphCLKConfig+0x1486>
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));
3400b7fe:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
3400b802:	4a39      	ldr	r2, [pc, #228]	@ (3400b8e8 <HAL_RCCEx_PeriphCLKConfig+0x14e8>)
3400b804:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b808:	4291      	cmp	r1, r2
3400b80a:	d00e      	beq.n	3400b82a <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400b80c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b810:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b814:	4291      	cmp	r1, r2
3400b816:	d008      	beq.n	3400b82a <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400b818:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b81c:	4293      	cmp	r3, r2
3400b81e:	d004      	beq.n	3400b82a <HAL_RCCEx_PeriphCLKConfig+0x142a>
3400b820:	f240 6144 	movw	r1, #1604	@ 0x644
3400b824:	482a      	ldr	r0, [pc, #168]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b826:	f7f6 fe89 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3400b82a:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
3400b82e:	4a2f      	ldr	r2, [pc, #188]	@ (3400b8ec <HAL_RCCEx_PeriphCLKConfig+0x14ec>)
3400b830:	4293      	cmp	r3, r2
3400b832:	f041 8272 	bne.w	3400cd1a <HAL_RCCEx_PeriphCLKConfig+0x291a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b836:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b838:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b83c:	d004      	beq.n	3400b848 <HAL_RCCEx_PeriphCLKConfig+0x1448>
3400b83e:	f240 6149 	movw	r1, #1609	@ 0x649
3400b842:	4823      	ldr	r0, [pc, #140]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b844:	f7f6 fe7a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b848:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b84a:	3b01      	subs	r3, #1
3400b84c:	2bff      	cmp	r3, #255	@ 0xff
3400b84e:	d904      	bls.n	3400b85a <HAL_RCCEx_PeriphCLKConfig+0x145a>
3400b850:	f240 614a 	movw	r1, #1610	@ 0x64a
3400b854:	481e      	ldr	r0, [pc, #120]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b856:	f7f6 fe71 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b85a:	4a1b      	ldr	r2, [pc, #108]	@ (3400b8c8 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3400b85c:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b85e:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b862:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b864:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b868:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b86c:	3901      	subs	r1, #1
3400b86e:	4303      	orrs	r3, r0
3400b870:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b874:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b878:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b87a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b87e:	f8d4 0138 	ldr.w	r0, [r4, #312]	@ 0x138
3400b882:	f7fe fcd9 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3400b886:	6863      	ldr	r3, [r4, #4]
3400b888:	0718      	lsls	r0, r3, #28
3400b88a:	d55d      	bpl.n	3400b948 <HAL_RCCEx_PeriphCLKConfig+0x1548>
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));
3400b88c:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
3400b890:	4a17      	ldr	r2, [pc, #92]	@ (3400b8f0 <HAL_RCCEx_PeriphCLKConfig+0x14f0>)
3400b892:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b896:	4291      	cmp	r1, r2
3400b898:	d00e      	beq.n	3400b8b8 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400b89a:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b89e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b8a2:	4291      	cmp	r1, r2
3400b8a4:	d008      	beq.n	3400b8b8 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400b8a6:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b8aa:	4293      	cmp	r3, r2
3400b8ac:	d004      	beq.n	3400b8b8 <HAL_RCCEx_PeriphCLKConfig+0x14b8>
3400b8ae:	f240 6171 	movw	r1, #1649	@ 0x671
3400b8b2:	4807      	ldr	r0, [pc, #28]	@ (3400b8d0 <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3400b8b4:	f7f6 fe42 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3400b8b8:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
3400b8bc:	4a0d      	ldr	r2, [pc, #52]	@ (3400b8f4 <HAL_RCCEx_PeriphCLKConfig+0x14f4>)
3400b8be:	4293      	cmp	r3, r2
3400b8c0:	f041 825c 	bne.w	3400cd7c <HAL_RCCEx_PeriphCLKConfig+0x297c>
3400b8c4:	e018      	b.n	3400b8f8 <HAL_RCCEx_PeriphCLKConfig+0x14f8>
3400b8c6:	bf00      	nop
3400b8c8:	56028000 	.word	0x56028000
3400b8cc:	07001418 	.word	0x07001418
3400b8d0:	3401c7d4 	.word	0x3401c7d4
3400b8d4:	07021418 	.word	0x07021418
3400b8d8:	07001818 	.word	0x07001818
3400b8dc:	07021818 	.word	0x07021818
3400b8e0:	07000420 	.word	0x07000420
3400b8e4:	07020420 	.word	0x07020420
3400b8e8:	07000820 	.word	0x07000820
3400b8ec:	07020820 	.word	0x07020820
3400b8f0:	07000c20 	.word	0x07000c20
3400b8f4:	07020c20 	.word	0x07020c20
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400b8f8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400b8fa:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b8fe:	d004      	beq.n	3400b90a <HAL_RCCEx_PeriphCLKConfig+0x150a>
3400b900:	f240 6176 	movw	r1, #1654	@ 0x676
3400b904:	48bb      	ldr	r0, [pc, #748]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b906:	f7f6 fe19 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400b90a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400b90c:	3b01      	subs	r3, #1
3400b90e:	2bff      	cmp	r3, #255	@ 0xff
3400b910:	d904      	bls.n	3400b91c <HAL_RCCEx_PeriphCLKConfig+0x151c>
3400b912:	f240 6177 	movw	r1, #1655	@ 0x677
3400b916:	48b7      	ldr	r0, [pc, #732]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b918:	f7f6 fe10 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400b91c:	4ab6      	ldr	r2, [pc, #728]	@ (3400bbf8 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400b91e:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400b920:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400b924:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400b926:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b92a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b92e:	3901      	subs	r1, #1
3400b930:	4303      	orrs	r3, r0
3400b932:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b936:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400b93a:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b93c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b940:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
3400b944:	f7fe fc78 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3400b948:	6863      	ldr	r3, [r4, #4]
3400b94a:	06d9      	lsls	r1, r3, #27
3400b94c:	d544      	bpl.n	3400b9d8 <HAL_RCCEx_PeriphCLKConfig+0x15d8>
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));
3400b94e:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
3400b952:	4aaa      	ldr	r2, [pc, #680]	@ (3400bbfc <HAL_RCCEx_PeriphCLKConfig+0x17fc>)
3400b954:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b958:	4291      	cmp	r1, r2
3400b95a:	d00e      	beq.n	3400b97a <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b95c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b960:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b964:	4291      	cmp	r1, r2
3400b966:	d008      	beq.n	3400b97a <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b968:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b96c:	4293      	cmp	r3, r2
3400b96e:	d004      	beq.n	3400b97a <HAL_RCCEx_PeriphCLKConfig+0x157a>
3400b970:	f240 619e 	movw	r1, #1694	@ 0x69e
3400b974:	489f      	ldr	r0, [pc, #636]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b976:	f7f6 fde1 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3400b97a:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
3400b97e:	4aa0      	ldr	r2, [pc, #640]	@ (3400bc00 <HAL_RCCEx_PeriphCLKConfig+0x1800>)
3400b980:	4293      	cmp	r3, r2
3400b982:	f041 822c 	bne.w	3400cdde <HAL_RCCEx_PeriphCLKConfig+0x29de>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400b986:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400b988:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400b98c:	d004      	beq.n	3400b998 <HAL_RCCEx_PeriphCLKConfig+0x1598>
3400b98e:	f240 61a3 	movw	r1, #1699	@ 0x6a3
3400b992:	4898      	ldr	r0, [pc, #608]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b994:	f7f6 fdd2 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400b998:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400b99a:	3b01      	subs	r3, #1
3400b99c:	2bff      	cmp	r3, #255	@ 0xff
3400b99e:	d904      	bls.n	3400b9aa <HAL_RCCEx_PeriphCLKConfig+0x15aa>
3400b9a0:	f240 61a4 	movw	r1, #1700	@ 0x6a4
3400b9a4:	4893      	ldr	r0, [pc, #588]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400b9a6:	f7f6 fdc9 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400b9aa:	4a93      	ldr	r2, [pc, #588]	@ (3400bbf8 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400b9ac:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400b9ae:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400b9b2:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400b9b4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400b9b8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400b9bc:	3901      	subs	r1, #1
3400b9be:	4303      	orrs	r3, r0
3400b9c0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400b9c4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400b9c8:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400b9cc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400b9d0:	f8d4 0140 	ldr.w	r0, [r4, #320]	@ 0x140
3400b9d4:	f7fe fc30 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3400b9d8:	6863      	ldr	r3, [r4, #4]
3400b9da:	069a      	lsls	r2, r3, #26
3400b9dc:	d544      	bpl.n	3400ba68 <HAL_RCCEx_PeriphCLKConfig+0x1668>
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));
3400b9de:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
3400b9e2:	4a88      	ldr	r2, [pc, #544]	@ (3400bc04 <HAL_RCCEx_PeriphCLKConfig+0x1804>)
3400b9e4:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400b9e8:	4291      	cmp	r1, r2
3400b9ea:	d00e      	beq.n	3400ba0a <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400b9ec:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400b9f0:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400b9f4:	4291      	cmp	r1, r2
3400b9f6:	d008      	beq.n	3400ba0a <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400b9f8:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400b9fc:	4293      	cmp	r3, r2
3400b9fe:	d004      	beq.n	3400ba0a <HAL_RCCEx_PeriphCLKConfig+0x160a>
3400ba00:	f240 61cb 	movw	r1, #1739	@ 0x6cb
3400ba04:	487b      	ldr	r0, [pc, #492]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba06:	f7f6 fd99 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3400ba0a:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
3400ba0e:	4a7e      	ldr	r2, [pc, #504]	@ (3400bc08 <HAL_RCCEx_PeriphCLKConfig+0x1808>)
3400ba10:	4293      	cmp	r3, r2
3400ba12:	f041 8231 	bne.w	3400ce78 <HAL_RCCEx_PeriphCLKConfig+0x2a78>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ba16:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400ba18:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ba1c:	d004      	beq.n	3400ba28 <HAL_RCCEx_PeriphCLKConfig+0x1628>
3400ba1e:	f44f 61da 	mov.w	r1, #1744	@ 0x6d0
3400ba22:	4874      	ldr	r0, [pc, #464]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba24:	f7f6 fd8a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ba28:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400ba2a:	3b01      	subs	r3, #1
3400ba2c:	2bff      	cmp	r3, #255	@ 0xff
3400ba2e:	d904      	bls.n	3400ba3a <HAL_RCCEx_PeriphCLKConfig+0x163a>
3400ba30:	f240 61d1 	movw	r1, #1745	@ 0x6d1
3400ba34:	486f      	ldr	r0, [pc, #444]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba36:	f7f6 fd81 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400ba3a:	4a6f      	ldr	r2, [pc, #444]	@ (3400bbf8 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400ba3c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400ba3e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400ba42:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400ba44:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ba48:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ba4c:	3901      	subs	r1, #1
3400ba4e:	4303      	orrs	r3, r0
3400ba50:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ba54:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400ba58:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400ba5c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400ba60:	f8d4 0144 	ldr.w	r0, [r4, #324]	@ 0x144
3400ba64:	f7fe fbe8 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3400ba68:	6863      	ldr	r3, [r4, #4]
3400ba6a:	065b      	lsls	r3, r3, #25
3400ba6c:	d543      	bpl.n	3400baf6 <HAL_RCCEx_PeriphCLKConfig+0x16f6>
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));
3400ba6e:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
3400ba72:	4a66      	ldr	r2, [pc, #408]	@ (3400bc0c <HAL_RCCEx_PeriphCLKConfig+0x180c>)
3400ba74:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400ba78:	4291      	cmp	r1, r2
3400ba7a:	d00e      	beq.n	3400ba9a <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400ba7c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400ba80:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400ba84:	4291      	cmp	r1, r2
3400ba86:	d008      	beq.n	3400ba9a <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400ba88:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400ba8c:	4293      	cmp	r3, r2
3400ba8e:	d004      	beq.n	3400ba9a <HAL_RCCEx_PeriphCLKConfig+0x169a>
3400ba90:	f44f 61df 	mov.w	r1, #1784	@ 0x6f8
3400ba94:	4857      	ldr	r0, [pc, #348]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400ba96:	f7f6 fd51 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3400ba9a:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
3400ba9e:	4a5c      	ldr	r2, [pc, #368]	@ (3400bc10 <HAL_RCCEx_PeriphCLKConfig+0x1810>)
3400baa0:	4293      	cmp	r3, r2
3400baa2:	f041 821a 	bne.w	3400ceda <HAL_RCCEx_PeriphCLKConfig+0x2ada>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400baa6:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400baa8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400baac:	d004      	beq.n	3400bab8 <HAL_RCCEx_PeriphCLKConfig+0x16b8>
3400baae:	f240 61fd 	movw	r1, #1789	@ 0x6fd
3400bab2:	4850      	ldr	r0, [pc, #320]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bab4:	f7f6 fd42 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400bab8:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400baba:	3b01      	subs	r3, #1
3400babc:	2bff      	cmp	r3, #255	@ 0xff
3400babe:	d904      	bls.n	3400baca <HAL_RCCEx_PeriphCLKConfig+0x16ca>
3400bac0:	f240 61fe 	movw	r1, #1790	@ 0x6fe
3400bac4:	484b      	ldr	r0, [pc, #300]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bac6:	f7f6 fd39 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400baca:	4a4b      	ldr	r2, [pc, #300]	@ (3400bbf8 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400bacc:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400bace:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400bad2:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400bad4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bad8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400badc:	3901      	subs	r1, #1
3400bade:	4303      	orrs	r3, r0
3400bae0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bae4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400bae8:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400baea:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400baee:	f8d4 0148 	ldr.w	r0, [r4, #328]	@ 0x148
3400baf2:	f7fe fba1 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3400baf6:	6863      	ldr	r3, [r4, #4]
3400baf8:	05de      	lsls	r6, r3, #23
3400bafa:	d544      	bpl.n	3400bb86 <HAL_RCCEx_PeriphCLKConfig+0x1786>
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
3400bafc:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
3400bb00:	4a44      	ldr	r2, [pc, #272]	@ (3400bc14 <HAL_RCCEx_PeriphCLKConfig+0x1814>)
3400bb02:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bb06:	4291      	cmp	r1, r2
3400bb08:	d00e      	beq.n	3400bb28 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400bb0a:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bb0e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bb12:	4291      	cmp	r1, r2
3400bb14:	d008      	beq.n	3400bb28 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400bb16:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bb1a:	4293      	cmp	r3, r2
3400bb1c:	d004      	beq.n	3400bb28 <HAL_RCCEx_PeriphCLKConfig+0x1728>
3400bb1e:	f240 7125 	movw	r1, #1829	@ 0x725
3400bb22:	4834      	ldr	r0, [pc, #208]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bb24:	f7f6 fd0a 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3400bb28:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
3400bb2c:	4a3a      	ldr	r2, [pc, #232]	@ (3400bc18 <HAL_RCCEx_PeriphCLKConfig+0x1818>)
3400bb2e:	4293      	cmp	r3, r2
3400bb30:	f041 8204 	bne.w	3400cf3c <HAL_RCCEx_PeriphCLKConfig+0x2b3c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bb34:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bb36:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bb3a:	d004      	beq.n	3400bb46 <HAL_RCCEx_PeriphCLKConfig+0x1746>
3400bb3c:	f240 712a 	movw	r1, #1834	@ 0x72a
3400bb40:	482c      	ldr	r0, [pc, #176]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bb42:	f7f6 fcfb 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bb46:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bb48:	3b01      	subs	r3, #1
3400bb4a:	2bff      	cmp	r3, #255	@ 0xff
3400bb4c:	d904      	bls.n	3400bb58 <HAL_RCCEx_PeriphCLKConfig+0x1758>
3400bb4e:	f240 712b 	movw	r1, #1835	@ 0x72b
3400bb52:	4828      	ldr	r0, [pc, #160]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bb54:	f7f6 fcf2 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bb58:	4a27      	ldr	r2, [pc, #156]	@ (3400bbf8 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400bb5a:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bb5c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bb60:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bb62:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bb66:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bb6a:	3901      	subs	r1, #1
3400bb6c:	4303      	orrs	r3, r0
3400bb6e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bb72:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bb76:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bb7a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bb7e:	f8d4 0150 	ldr.w	r0, [r4, #336]	@ 0x150
3400bb82:	f7fe fb59 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3400bb86:	6863      	ldr	r3, [r4, #4]
3400bb88:	0598      	lsls	r0, r3, #22
3400bb8a:	d55d      	bpl.n	3400bc48 <HAL_RCCEx_PeriphCLKConfig+0x1848>
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
3400bb8c:	f8d4 3154 	ldr.w	r3, [r4, #340]	@ 0x154
3400bb90:	4a22      	ldr	r2, [pc, #136]	@ (3400bc1c <HAL_RCCEx_PeriphCLKConfig+0x181c>)
3400bb92:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bb96:	4291      	cmp	r1, r2
3400bb98:	d00e      	beq.n	3400bbb8 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400bb9a:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bb9e:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bba2:	4291      	cmp	r1, r2
3400bba4:	d008      	beq.n	3400bbb8 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400bba6:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bbaa:	4293      	cmp	r3, r2
3400bbac:	d004      	beq.n	3400bbb8 <HAL_RCCEx_PeriphCLKConfig+0x17b8>
3400bbae:	f240 7152 	movw	r1, #1874	@ 0x752
3400bbb2:	4810      	ldr	r0, [pc, #64]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bbb4:	f7f6 fcc2 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3400bbb8:	f8d4 3154 	ldr.w	r3, [r4, #340]	@ 0x154
3400bbbc:	4a18      	ldr	r2, [pc, #96]	@ (3400bc20 <HAL_RCCEx_PeriphCLKConfig+0x1820>)
3400bbbe:	4293      	cmp	r3, r2
3400bbc0:	f041 81ed 	bne.w	3400cf9e <HAL_RCCEx_PeriphCLKConfig+0x2b9e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bbc4:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bbc6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bbca:	d004      	beq.n	3400bbd6 <HAL_RCCEx_PeriphCLKConfig+0x17d6>
3400bbcc:	f240 7157 	movw	r1, #1879	@ 0x757
3400bbd0:	4808      	ldr	r0, [pc, #32]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bbd2:	f7f6 fcb3 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bbd6:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bbd8:	3b01      	subs	r3, #1
3400bbda:	2bff      	cmp	r3, #255	@ 0xff
3400bbdc:	d904      	bls.n	3400bbe8 <HAL_RCCEx_PeriphCLKConfig+0x17e8>
3400bbde:	f44f 61eb 	mov.w	r1, #1880	@ 0x758
3400bbe2:	4804      	ldr	r0, [pc, #16]	@ (3400bbf4 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3400bbe4:	f7f6 fcaa 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bbe8:	4a03      	ldr	r2, [pc, #12]	@ (3400bbf8 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3400bbea:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bbec:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bbf0:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bbf2:	e017      	b.n	3400bc24 <HAL_RCCEx_PeriphCLKConfig+0x1824>
3400bbf4:	3401c7d4 	.word	0x3401c7d4
3400bbf8:	56028000 	.word	0x56028000
3400bbfc:	07001020 	.word	0x07001020
3400bc00:	07021020 	.word	0x07021020
3400bc04:	07001420 	.word	0x07001420
3400bc08:	07021420 	.word	0x07021420
3400bc0c:	07001820 	.word	0x07001820
3400bc10:	07021820 	.word	0x07021820
3400bc14:	07000030 	.word	0x07000030
3400bc18:	07020030 	.word	0x07020030
3400bc1c:	07000430 	.word	0x07000430
3400bc20:	07020430 	.word	0x07020430
3400bc24:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bc28:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bc2c:	3901      	subs	r1, #1
3400bc2e:	4303      	orrs	r3, r0
3400bc30:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bc34:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bc38:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bc3c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bc40:	f8d4 0154 	ldr.w	r0, [r4, #340]	@ 0x154
3400bc44:	f7fe faf8 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3400bc48:	6863      	ldr	r3, [r4, #4]
3400bc4a:	0559      	lsls	r1, r3, #21
3400bc4c:	d544      	bpl.n	3400bcd8 <HAL_RCCEx_PeriphCLKConfig+0x18d8>
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
3400bc4e:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
3400bc52:	4abc      	ldr	r2, [pc, #752]	@ (3400bf44 <HAL_RCCEx_PeriphCLKConfig+0x1b44>)
3400bc54:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bc58:	4291      	cmp	r1, r2
3400bc5a:	d00e      	beq.n	3400bc7a <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400bc5c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bc60:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bc64:	4291      	cmp	r1, r2
3400bc66:	d008      	beq.n	3400bc7a <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400bc68:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bc6c:	4293      	cmp	r3, r2
3400bc6e:	d004      	beq.n	3400bc7a <HAL_RCCEx_PeriphCLKConfig+0x187a>
3400bc70:	f240 717f 	movw	r1, #1919	@ 0x77f
3400bc74:	48b4      	ldr	r0, [pc, #720]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bc76:	f7f6 fc61 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
3400bc7a:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
3400bc7e:	4ab3      	ldr	r2, [pc, #716]	@ (3400bf4c <HAL_RCCEx_PeriphCLKConfig+0x1b4c>)
3400bc80:	4293      	cmp	r3, r2
3400bc82:	f041 81bd 	bne.w	3400d000 <HAL_RCCEx_PeriphCLKConfig+0x2c00>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bc86:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bc88:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bc8c:	d004      	beq.n	3400bc98 <HAL_RCCEx_PeriphCLKConfig+0x1898>
3400bc8e:	f240 7184 	movw	r1, #1924	@ 0x784
3400bc92:	48ad      	ldr	r0, [pc, #692]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bc94:	f7f6 fc52 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bc98:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bc9a:	3b01      	subs	r3, #1
3400bc9c:	2bff      	cmp	r3, #255	@ 0xff
3400bc9e:	d904      	bls.n	3400bcaa <HAL_RCCEx_PeriphCLKConfig+0x18aa>
3400bca0:	f240 7185 	movw	r1, #1925	@ 0x785
3400bca4:	48a8      	ldr	r0, [pc, #672]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bca6:	f7f6 fc49 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bcaa:	4aa9      	ldr	r2, [pc, #676]	@ (3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bcac:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bcae:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bcb2:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bcb4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bcb8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bcbc:	3901      	subs	r1, #1
3400bcbe:	4303      	orrs	r3, r0
3400bcc0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bcc4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bcc8:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bccc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bcd0:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
3400bcd4:	f7fe fab0 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
3400bcd8:	6863      	ldr	r3, [r4, #4]
3400bcda:	051a      	lsls	r2, r3, #20
3400bcdc:	d544      	bpl.n	3400bd68 <HAL_RCCEx_PeriphCLKConfig+0x1968>
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
3400bcde:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400bce2:	4a9c      	ldr	r2, [pc, #624]	@ (3400bf54 <HAL_RCCEx_PeriphCLKConfig+0x1b54>)
3400bce4:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bce8:	4291      	cmp	r1, r2
3400bcea:	d00e      	beq.n	3400bd0a <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400bcec:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bcf0:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bcf4:	4291      	cmp	r1, r2
3400bcf6:	d008      	beq.n	3400bd0a <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400bcf8:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bcfc:	4293      	cmp	r3, r2
3400bcfe:	d004      	beq.n	3400bd0a <HAL_RCCEx_PeriphCLKConfig+0x190a>
3400bd00:	f240 71ac 	movw	r1, #1964	@ 0x7ac
3400bd04:	4890      	ldr	r0, [pc, #576]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd06:	f7f6 fc19 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3400bd0a:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
3400bd0e:	4a92      	ldr	r2, [pc, #584]	@ (3400bf58 <HAL_RCCEx_PeriphCLKConfig+0x1b58>)
3400bd10:	4293      	cmp	r3, r2
3400bd12:	f041 81a6 	bne.w	3400d062 <HAL_RCCEx_PeriphCLKConfig+0x2c62>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bd16:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bd18:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bd1c:	d004      	beq.n	3400bd28 <HAL_RCCEx_PeriphCLKConfig+0x1928>
3400bd1e:	f240 71b1 	movw	r1, #1969	@ 0x7b1
3400bd22:	4889      	ldr	r0, [pc, #548]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd24:	f7f6 fc0a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bd28:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bd2a:	3b01      	subs	r3, #1
3400bd2c:	2bff      	cmp	r3, #255	@ 0xff
3400bd2e:	d904      	bls.n	3400bd3a <HAL_RCCEx_PeriphCLKConfig+0x193a>
3400bd30:	f240 71b2 	movw	r1, #1970	@ 0x7b2
3400bd34:	4884      	ldr	r0, [pc, #528]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd36:	f7f6 fc01 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bd3a:	4a85      	ldr	r2, [pc, #532]	@ (3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bd3c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bd3e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bd42:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bd44:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bd48:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bd4c:	3901      	subs	r1, #1
3400bd4e:	4303      	orrs	r3, r0
3400bd50:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bd54:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bd58:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bd5c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bd60:	f8d4 015c 	ldr.w	r0, [r4, #348]	@ 0x15c
3400bd64:	f7fe fa68 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3400bd68:	6863      	ldr	r3, [r4, #4]
3400bd6a:	04db      	lsls	r3, r3, #19
3400bd6c:	d544      	bpl.n	3400bdf8 <HAL_RCCEx_PeriphCLKConfig+0x19f8>
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
3400bd6e:	f8d4 3160 	ldr.w	r3, [r4, #352]	@ 0x160
3400bd72:	4a7a      	ldr	r2, [pc, #488]	@ (3400bf5c <HAL_RCCEx_PeriphCLKConfig+0x1b5c>)
3400bd74:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bd78:	4291      	cmp	r1, r2
3400bd7a:	d00e      	beq.n	3400bd9a <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400bd7c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bd80:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bd84:	4291      	cmp	r1, r2
3400bd86:	d008      	beq.n	3400bd9a <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400bd88:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bd8c:	4293      	cmp	r3, r2
3400bd8e:	d004      	beq.n	3400bd9a <HAL_RCCEx_PeriphCLKConfig+0x199a>
3400bd90:	f240 71d9 	movw	r1, #2009	@ 0x7d9
3400bd94:	486c      	ldr	r0, [pc, #432]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bd96:	f7f6 fbd1 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3400bd9a:	f8d4 3160 	ldr.w	r3, [r4, #352]	@ 0x160
3400bd9e:	4a70      	ldr	r2, [pc, #448]	@ (3400bf60 <HAL_RCCEx_PeriphCLKConfig+0x1b60>)
3400bda0:	4293      	cmp	r3, r2
3400bda2:	f041 818f 	bne.w	3400d0c4 <HAL_RCCEx_PeriphCLKConfig+0x2cc4>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bda6:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bda8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bdac:	d004      	beq.n	3400bdb8 <HAL_RCCEx_PeriphCLKConfig+0x19b8>
3400bdae:	f240 71de 	movw	r1, #2014	@ 0x7de
3400bdb2:	4865      	ldr	r0, [pc, #404]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bdb4:	f7f6 fbc2 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bdb8:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bdba:	3b01      	subs	r3, #1
3400bdbc:	2bff      	cmp	r3, #255	@ 0xff
3400bdbe:	d904      	bls.n	3400bdca <HAL_RCCEx_PeriphCLKConfig+0x19ca>
3400bdc0:	f240 71df 	movw	r1, #2015	@ 0x7df
3400bdc4:	4860      	ldr	r0, [pc, #384]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bdc6:	f7f6 fbb9 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bdca:	4a61      	ldr	r2, [pc, #388]	@ (3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400bdcc:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bdce:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bdd2:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bdd4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bdd8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bddc:	3901      	subs	r1, #1
3400bdde:	4303      	orrs	r3, r0
3400bde0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bde4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bde8:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bdec:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bdf0:	f8d4 0160 	ldr.w	r0, [r4, #352]	@ 0x160
3400bdf4:	f7fe fa20 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3400bdf8:	6863      	ldr	r3, [r4, #4]
3400bdfa:	049e      	lsls	r6, r3, #18
3400bdfc:	d544      	bpl.n	3400be88 <HAL_RCCEx_PeriphCLKConfig+0x1a88>
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
3400bdfe:	f8d4 3164 	ldr.w	r3, [r4, #356]	@ 0x164
3400be02:	4a58      	ldr	r2, [pc, #352]	@ (3400bf64 <HAL_RCCEx_PeriphCLKConfig+0x1b64>)
3400be04:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400be08:	4291      	cmp	r1, r2
3400be0a:	d00e      	beq.n	3400be2a <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400be0c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400be10:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400be14:	4291      	cmp	r1, r2
3400be16:	d008      	beq.n	3400be2a <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400be18:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400be1c:	4293      	cmp	r3, r2
3400be1e:	d004      	beq.n	3400be2a <HAL_RCCEx_PeriphCLKConfig+0x1a2a>
3400be20:	f640 0106 	movw	r1, #2054	@ 0x806
3400be24:	4848      	ldr	r0, [pc, #288]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400be26:	f7f6 fb89 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3400be2a:	f8d4 3164 	ldr.w	r3, [r4, #356]	@ 0x164
3400be2e:	4a4e      	ldr	r2, [pc, #312]	@ (3400bf68 <HAL_RCCEx_PeriphCLKConfig+0x1b68>)
3400be30:	4293      	cmp	r3, r2
3400be32:	f041 8199 	bne.w	3400d168 <HAL_RCCEx_PeriphCLKConfig+0x2d68>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400be36:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400be38:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400be3c:	d004      	beq.n	3400be48 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
3400be3e:	f640 010b 	movw	r1, #2059	@ 0x80b
3400be42:	4841      	ldr	r0, [pc, #260]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400be44:	f7f6 fb7a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400be48:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400be4a:	3b01      	subs	r3, #1
3400be4c:	2bff      	cmp	r3, #255	@ 0xff
3400be4e:	d904      	bls.n	3400be5a <HAL_RCCEx_PeriphCLKConfig+0x1a5a>
3400be50:	f640 010c 	movw	r1, #2060	@ 0x80c
3400be54:	483c      	ldr	r0, [pc, #240]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400be56:	f7f6 fb71 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400be5a:	4a3d      	ldr	r2, [pc, #244]	@ (3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400be5c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400be5e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400be62:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400be64:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400be68:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400be6c:	3901      	subs	r1, #1
3400be6e:	4303      	orrs	r3, r0
3400be70:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400be74:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400be78:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400be7c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400be80:	f8d4 0164 	ldr.w	r0, [r4, #356]	@ 0x164
3400be84:	f7fe f9d8 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3400be88:	6863      	ldr	r3, [r4, #4]
3400be8a:	0458      	lsls	r0, r3, #17
3400be8c:	d544      	bpl.n	3400bf18 <HAL_RCCEx_PeriphCLKConfig+0x1b18>
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
3400be8e:	f8d4 3168 	ldr.w	r3, [r4, #360]	@ 0x168
3400be92:	4a36      	ldr	r2, [pc, #216]	@ (3400bf6c <HAL_RCCEx_PeriphCLKConfig+0x1b6c>)
3400be94:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400be98:	4291      	cmp	r1, r2
3400be9a:	d00e      	beq.n	3400beba <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400be9c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bea0:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bea4:	4291      	cmp	r1, r2
3400bea6:	d008      	beq.n	3400beba <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400bea8:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400beac:	4293      	cmp	r3, r2
3400beae:	d004      	beq.n	3400beba <HAL_RCCEx_PeriphCLKConfig+0x1aba>
3400beb0:	f640 0133 	movw	r1, #2099	@ 0x833
3400beb4:	4824      	ldr	r0, [pc, #144]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400beb6:	f7f6 fb41 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3400beba:	f8d4 3168 	ldr.w	r3, [r4, #360]	@ 0x168
3400bebe:	4a2c      	ldr	r2, [pc, #176]	@ (3400bf70 <HAL_RCCEx_PeriphCLKConfig+0x1b70>)
3400bec0:	4293      	cmp	r3, r2
3400bec2:	f041 8182 	bne.w	3400d1ca <HAL_RCCEx_PeriphCLKConfig+0x2dca>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bec6:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bec8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400becc:	d004      	beq.n	3400bed8 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>
3400bece:	f640 0138 	movw	r1, #2104	@ 0x838
3400bed2:	481d      	ldr	r0, [pc, #116]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bed4:	f7f6 fb32 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bed8:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400beda:	3b01      	subs	r3, #1
3400bedc:	2bff      	cmp	r3, #255	@ 0xff
3400bede:	d904      	bls.n	3400beea <HAL_RCCEx_PeriphCLKConfig+0x1aea>
3400bee0:	f640 0139 	movw	r1, #2105	@ 0x839
3400bee4:	4818      	ldr	r0, [pc, #96]	@ (3400bf48 <HAL_RCCEx_PeriphCLKConfig+0x1b48>)
3400bee6:	f7f6 fb29 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400beea:	4a19      	ldr	r2, [pc, #100]	@ (3400bf50 <HAL_RCCEx_PeriphCLKConfig+0x1b50>)
3400beec:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400beee:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bef2:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bef4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bef8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400befc:	3901      	subs	r1, #1
3400befe:	4303      	orrs	r3, r0
3400bf00:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bf04:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bf08:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bf0c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bf10:	f8d4 0168 	ldr.w	r0, [r4, #360]	@ 0x168
3400bf14:	f7fe f990 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
3400bf18:	6863      	ldr	r3, [r4, #4]
3400bf1a:	0419      	lsls	r1, r3, #16
3400bf1c:	d560      	bpl.n	3400bfe0 <HAL_RCCEx_PeriphCLKConfig+0x1be0>
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
3400bf1e:	f8d4 316c 	ldr.w	r3, [r4, #364]	@ 0x16c
3400bf22:	4a14      	ldr	r2, [pc, #80]	@ (3400bf74 <HAL_RCCEx_PeriphCLKConfig+0x1b74>)
3400bf24:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bf28:	4291      	cmp	r1, r2
3400bf2a:	d02a      	beq.n	3400bf82 <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400bf2c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bf30:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bf34:	4291      	cmp	r1, r2
3400bf36:	d024      	beq.n	3400bf82 <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400bf38:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400bf3c:	4293      	cmp	r3, r2
3400bf3e:	d020      	beq.n	3400bf82 <HAL_RCCEx_PeriphCLKConfig+0x1b82>
3400bf40:	e01a      	b.n	3400bf78 <HAL_RCCEx_PeriphCLKConfig+0x1b78>
3400bf42:	bf00      	nop
3400bf44:	07000830 	.word	0x07000830
3400bf48:	3401c7d4 	.word	0x3401c7d4
3400bf4c:	07020830 	.word	0x07020830
3400bf50:	56028000 	.word	0x56028000
3400bf54:	07000c30 	.word	0x07000c30
3400bf58:	07020c30 	.word	0x07020c30
3400bf5c:	07001030 	.word	0x07001030
3400bf60:	07021030 	.word	0x07021030
3400bf64:	07001430 	.word	0x07001430
3400bf68:	07021430 	.word	0x07021430
3400bf6c:	07001830 	.word	0x07001830
3400bf70:	07021830 	.word	0x07021830
3400bf74:	07001c30 	.word	0x07001c30
3400bf78:	f44f 6106 	mov.w	r1, #2144	@ 0x860
3400bf7c:	48bb      	ldr	r0, [pc, #748]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bf7e:	f7f6 fadd 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
3400bf82:	f8d4 316c 	ldr.w	r3, [r4, #364]	@ 0x16c
3400bf86:	4aba      	ldr	r2, [pc, #744]	@ (3400c270 <HAL_RCCEx_PeriphCLKConfig+0x1e70>)
3400bf88:	4293      	cmp	r3, r2
3400bf8a:	f041 814f 	bne.w	3400d22c <HAL_RCCEx_PeriphCLKConfig+0x2e2c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400bf8e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400bf90:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400bf94:	d004      	beq.n	3400bfa0 <HAL_RCCEx_PeriphCLKConfig+0x1ba0>
3400bf96:	f640 0165 	movw	r1, #2149	@ 0x865
3400bf9a:	48b4      	ldr	r0, [pc, #720]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bf9c:	f7f6 face 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400bfa0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400bfa2:	3b01      	subs	r3, #1
3400bfa4:	2bff      	cmp	r3, #255	@ 0xff
3400bfa6:	d904      	bls.n	3400bfb2 <HAL_RCCEx_PeriphCLKConfig+0x1bb2>
3400bfa8:	f640 0166 	movw	r1, #2150	@ 0x866
3400bfac:	48af      	ldr	r0, [pc, #700]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400bfae:	f7f6 fac5 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400bfb2:	4ab0      	ldr	r2, [pc, #704]	@ (3400c274 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400bfb4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400bfb6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400bfba:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400bfbc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400bfc0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400bfc4:	3901      	subs	r1, #1
3400bfc6:	4303      	orrs	r3, r0
3400bfc8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400bfcc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400bfd0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400bfd4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400bfd8:	f8d4 016c 	ldr.w	r0, [r4, #364]	@ 0x16c
3400bfdc:	f7fe f92c 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3400bfe0:	6863      	ldr	r3, [r4, #4]
3400bfe2:	03da      	lsls	r2, r3, #15
3400bfe4:	d544      	bpl.n	3400c070 <HAL_RCCEx_PeriphCLKConfig+0x1c70>
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));
3400bfe6:	f8d4 3170 	ldr.w	r3, [r4, #368]	@ 0x170
3400bfea:	4aa3      	ldr	r2, [pc, #652]	@ (3400c278 <HAL_RCCEx_PeriphCLKConfig+0x1e78>)
3400bfec:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400bff0:	4291      	cmp	r1, r2
3400bff2:	d00e      	beq.n	3400c012 <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400bff4:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bff8:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400bffc:	4291      	cmp	r1, r2
3400bffe:	d008      	beq.n	3400c012 <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400c000:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c004:	4293      	cmp	r3, r2
3400c006:	d004      	beq.n	3400c012 <HAL_RCCEx_PeriphCLKConfig+0x1c12>
3400c008:	f640 018d 	movw	r1, #2189	@ 0x88d
3400c00c:	4897      	ldr	r0, [pc, #604]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c00e:	f7f6 fa95 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3400c012:	f8d4 3170 	ldr.w	r3, [r4, #368]	@ 0x170
3400c016:	4a99      	ldr	r2, [pc, #612]	@ (3400c27c <HAL_RCCEx_PeriphCLKConfig+0x1e7c>)
3400c018:	4293      	cmp	r3, r2
3400c01a:	f041 8138 	bne.w	3400d28e <HAL_RCCEx_PeriphCLKConfig+0x2e8e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c01e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c020:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c024:	d004      	beq.n	3400c030 <HAL_RCCEx_PeriphCLKConfig+0x1c30>
3400c026:	f640 0192 	movw	r1, #2194	@ 0x892
3400c02a:	4890      	ldr	r0, [pc, #576]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c02c:	f7f6 fa86 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c030:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c032:	3b01      	subs	r3, #1
3400c034:	2bff      	cmp	r3, #255	@ 0xff
3400c036:	d904      	bls.n	3400c042 <HAL_RCCEx_PeriphCLKConfig+0x1c42>
3400c038:	f640 0193 	movw	r1, #2195	@ 0x893
3400c03c:	488b      	ldr	r0, [pc, #556]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c03e:	f7f6 fa7d 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c042:	4a8c      	ldr	r2, [pc, #560]	@ (3400c274 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c044:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c046:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c04a:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c04c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c050:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c054:	3901      	subs	r1, #1
3400c056:	4303      	orrs	r3, r0
3400c058:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c05c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c060:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c064:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c068:	f8d4 0170 	ldr.w	r0, [r4, #368]	@ 0x170
3400c06c:	f7fe f8e4 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
3400c070:	6863      	ldr	r3, [r4, #4]
3400c072:	039b      	lsls	r3, r3, #14
3400c074:	d544      	bpl.n	3400c100 <HAL_RCCEx_PeriphCLKConfig+0x1d00>
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));
3400c076:	f8d4 3174 	ldr.w	r3, [r4, #372]	@ 0x174
3400c07a:	4a81      	ldr	r2, [pc, #516]	@ (3400c280 <HAL_RCCEx_PeriphCLKConfig+0x1e80>)
3400c07c:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c080:	4291      	cmp	r1, r2
3400c082:	d00e      	beq.n	3400c0a2 <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400c084:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c088:	f502 2280 	add.w	r2, r2, #262144	@ 0x40000
3400c08c:	4291      	cmp	r1, r2
3400c08e:	d008      	beq.n	3400c0a2 <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400c090:	f502 3200 	add.w	r2, r2, #131072	@ 0x20000
3400c094:	4293      	cmp	r3, r2
3400c096:	d004      	beq.n	3400c0a2 <HAL_RCCEx_PeriphCLKConfig+0x1ca2>
3400c098:	f640 01ba 	movw	r1, #2234	@ 0x8ba
3400c09c:	4873      	ldr	r0, [pc, #460]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c09e:	f7f6 fa4d 	bl	3400253c <assert_failed>
    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3400c0a2:	f8d4 3174 	ldr.w	r3, [r4, #372]	@ 0x174
3400c0a6:	4a77      	ldr	r2, [pc, #476]	@ (3400c284 <HAL_RCCEx_PeriphCLKConfig+0x1e84>)
3400c0a8:	4293      	cmp	r3, r2
3400c0aa:	f041 8121 	bne.w	3400d2f0 <HAL_RCCEx_PeriphCLKConfig+0x2ef0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400c0ae:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400c0b0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c0b4:	d004      	beq.n	3400c0c0 <HAL_RCCEx_PeriphCLKConfig+0x1cc0>
3400c0b6:	f640 01bf 	movw	r1, #2239	@ 0x8bf
3400c0ba:	486c      	ldr	r0, [pc, #432]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c0bc:	f7f6 fa3e 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400c0c0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400c0c2:	3b01      	subs	r3, #1
3400c0c4:	2bff      	cmp	r3, #255	@ 0xff
3400c0c6:	d904      	bls.n	3400c0d2 <HAL_RCCEx_PeriphCLKConfig+0x1cd2>
3400c0c8:	f44f 610c 	mov.w	r1, #2240	@ 0x8c0
3400c0cc:	4867      	ldr	r0, [pc, #412]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c0ce:	f7f6 fa35 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400c0d2:	4a68      	ldr	r2, [pc, #416]	@ (3400c274 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c0d4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400c0d6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400c0da:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400c0dc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c0e0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c0e4:	3901      	subs	r1, #1
3400c0e6:	4303      	orrs	r3, r0
3400c0e8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c0ec:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400c0f0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400c0f4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3400c0f8:	f8d4 0174 	ldr.w	r0, [r4, #372]	@ 0x174
3400c0fc:	f7fe f89c 	bl	3400a238 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3400c100:	6863      	ldr	r3, [r4, #4]
3400c102:	035e      	lsls	r6, r3, #13
3400c104:	d51e      	bpl.n	3400c144 <HAL_RCCEx_PeriphCLKConfig+0x1d44>
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));
3400c106:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3400c10a:	4a5f      	ldr	r2, [pc, #380]	@ (3400c288 <HAL_RCCEx_PeriphCLKConfig+0x1e88>)
3400c10c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c110:	4291      	cmp	r1, r2
3400c112:	d00a      	beq.n	3400c12a <HAL_RCCEx_PeriphCLKConfig+0x1d2a>
3400c114:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c118:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
3400c11c:	4293      	cmp	r3, r2
3400c11e:	d004      	beq.n	3400c12a <HAL_RCCEx_PeriphCLKConfig+0x1d2a>
3400c120:	f640 01e7 	movw	r1, #2279	@ 0x8e7
3400c124:	4851      	ldr	r0, [pc, #324]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c126:	f7f6 fa09 	bl	3400253c <assert_failed>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400c12a:	f8d4 0178 	ldr.w	r0, [r4, #376]	@ 0x178
  LL_RCC_SetClockSource(ClkSource);
3400c12e:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c132:	f7fe f881 	bl	3400a238 <LL_RCC_SetClockSource>
3400c136:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3400c13a:	2b00      	cmp	r3, #0
3400c13c:	f281 8109 	bge.w	3400d352 <HAL_RCCEx_PeriphCLKConfig+0x2f52>
3400c140:	f7fe f84a 	bl	3400a1d8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3400c144:	6863      	ldr	r3, [r4, #4]
3400c146:	02d8      	lsls	r0, r3, #11
3400c148:	d51e      	bpl.n	3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));
3400c14a:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3400c14e:	4a4f      	ldr	r2, [pc, #316]	@ (3400c28c <HAL_RCCEx_PeriphCLKConfig+0x1e8c>)
3400c150:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400c154:	4291      	cmp	r1, r2
3400c156:	d00a      	beq.n	3400c16e <HAL_RCCEx_PeriphCLKConfig+0x1d6e>
3400c158:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c15c:	f502 3280 	add.w	r2, r2, #65536	@ 0x10000
3400c160:	4293      	cmp	r3, r2
3400c162:	d004      	beq.n	3400c16e <HAL_RCCEx_PeriphCLKConfig+0x1d6e>
3400c164:	f640 01f1 	movw	r1, #2289	@ 0x8f1
3400c168:	4840      	ldr	r0, [pc, #256]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c16a:	f7f6 f9e7 	bl	3400253c <assert_failed>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400c16e:	f8d4 0180 	ldr.w	r0, [r4, #384]	@ 0x180
3400c172:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c176:	f7fe f85f 	bl	3400a238 <LL_RCC_SetClockSource>
3400c17a:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3400c17e:	2b00      	cmp	r3, #0
3400c180:	f281 80eb 	bge.w	3400d35a <HAL_RCCEx_PeriphCLKConfig+0x2f5a>
3400c184:	f7fe f828 	bl	3400a1d8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3400c188:	6863      	ldr	r3, [r4, #4]
3400c18a:	0319      	lsls	r1, r3, #12
3400c18c:	d549      	bpl.n	3400c222 <HAL_RCCEx_PeriphCLKConfig+0x1e22>
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));
3400c18e:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c192:	4a3f      	ldr	r2, [pc, #252]	@ (3400c290 <HAL_RCCEx_PeriphCLKConfig+0x1e90>)
3400c194:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c198:	4291      	cmp	r1, r2
3400c19a:	d00a      	beq.n	3400c1b2 <HAL_RCCEx_PeriphCLKConfig+0x1db2>
3400c19c:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c1a0:	f502 3240 	add.w	r2, r2, #196608	@ 0x30000
3400c1a4:	4293      	cmp	r3, r2
3400c1a6:	d004      	beq.n	3400c1b2 <HAL_RCCEx_PeriphCLKConfig+0x1db2>
3400c1a8:	f640 01fb 	movw	r1, #2299	@ 0x8fb
3400c1ac:	482f      	ldr	r0, [pc, #188]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c1ae:	f7f6 f9c5 	bl	3400253c <assert_failed>
    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3400c1b2:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c1b6:	4a37      	ldr	r2, [pc, #220]	@ (3400c294 <HAL_RCCEx_PeriphCLKConfig+0x1e94>)
3400c1b8:	4293      	cmp	r3, r2
3400c1ba:	f041 80d2 	bne.w	3400d362 <HAL_RCCEx_PeriphCLKConfig+0x2f62>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c1be:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c1c0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c1c4:	d004      	beq.n	3400c1d0 <HAL_RCCEx_PeriphCLKConfig+0x1dd0>
3400c1c6:	f44f 6110 	mov.w	r1, #2304	@ 0x900
3400c1ca:	4828      	ldr	r0, [pc, #160]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c1cc:	f7f6 f9b6 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c1d0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c1d2:	3b01      	subs	r3, #1
3400c1d4:	2bff      	cmp	r3, #255	@ 0xff
3400c1d6:	d904      	bls.n	3400c1e2 <HAL_RCCEx_PeriphCLKConfig+0x1de2>
3400c1d8:	f640 1101 	movw	r1, #2305	@ 0x901
3400c1dc:	4823      	ldr	r0, [pc, #140]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c1de:	f7f6 f9ad 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c1e2:	4a24      	ldr	r2, [pc, #144]	@ (3400c274 <HAL_RCCEx_PeriphCLKConfig+0x1e74>)
3400c1e4:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c1e6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c1ea:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c1ec:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c1f0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c1f4:	3901      	subs	r1, #1
3400c1f6:	4303      	orrs	r3, r0
3400c1f8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c1fc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c200:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c204:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400c208:	f8d4 017c 	ldr.w	r0, [r4, #380]	@ 0x17c
  LL_RCC_SetClockSource(ClkSource);
3400c20c:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c210:	f7fe f812 	bl	3400a238 <LL_RCC_SetClockSource>
3400c214:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3400c218:	2b00      	cmp	r3, #0
3400c21a:	f281 80ab 	bge.w	3400d374 <HAL_RCCEx_PeriphCLKConfig+0x2f74>
3400c21e:	f7fd ffdb 	bl	3400a1d8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3400c222:	6863      	ldr	r3, [r4, #4]
3400c224:	029a      	lsls	r2, r3, #10
3400c226:	d564      	bpl.n	3400c2f2 <HAL_RCCEx_PeriphCLKConfig+0x1ef2>
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));
3400c228:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c22c:	4a1a      	ldr	r2, [pc, #104]	@ (3400c298 <HAL_RCCEx_PeriphCLKConfig+0x1e98>)
3400c22e:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
3400c232:	4291      	cmp	r1, r2
3400c234:	d00a      	beq.n	3400c24c <HAL_RCCEx_PeriphCLKConfig+0x1e4c>
3400c236:	f102 4200 	add.w	r2, r2, #2147483648	@ 0x80000000
3400c23a:	f502 3240 	add.w	r2, r2, #196608	@ 0x30000
3400c23e:	4293      	cmp	r3, r2
3400c240:	d004      	beq.n	3400c24c <HAL_RCCEx_PeriphCLKConfig+0x1e4c>
3400c242:	f640 111b 	movw	r1, #2331	@ 0x91b
3400c246:	4809      	ldr	r0, [pc, #36]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c248:	f7f6 f978 	bl	3400253c <assert_failed>
    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3400c24c:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c250:	4a12      	ldr	r2, [pc, #72]	@ (3400c29c <HAL_RCCEx_PeriphCLKConfig+0x1e9c>)
3400c252:	4293      	cmp	r3, r2
3400c254:	f041 8092 	bne.w	3400d37c <HAL_RCCEx_PeriphCLKConfig+0x2f7c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c258:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c25a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c25e:	d01f      	beq.n	3400c2a0 <HAL_RCCEx_PeriphCLKConfig+0x1ea0>
3400c260:	f44f 6112 	mov.w	r1, #2336	@ 0x920
3400c264:	4801      	ldr	r0, [pc, #4]	@ (3400c26c <HAL_RCCEx_PeriphCLKConfig+0x1e6c>)
3400c266:	f7f6 f969 	bl	3400253c <assert_failed>
3400c26a:	e019      	b.n	3400c2a0 <HAL_RCCEx_PeriphCLKConfig+0x1ea0>
3400c26c:	3401c7d4 	.word	0x3401c7d4
3400c270:	07021c30 	.word	0x07021c30
3400c274:	56028000 	.word	0x56028000
3400c278:	07000034 	.word	0x07000034
3400c27c:	07020034 	.word	0x07020034
3400c280:	07000434 	.word	0x07000434
3400c284:	07020434 	.word	0x07020434
3400c288:	01001014 	.word	0x01001014
3400c28c:	01001814 	.word	0x01001814
3400c290:	03000c14 	.word	0x03000c14
3400c294:	03020c14 	.word	0x03020c14
3400c298:	03001414 	.word	0x03001414
3400c29c:	03021414 	.word	0x03021414
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c2a0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c2a2:	3b01      	subs	r3, #1
3400c2a4:	2bff      	cmp	r3, #255	@ 0xff
3400c2a6:	d904      	bls.n	3400c2b2 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
3400c2a8:	f640 1121 	movw	r1, #2337	@ 0x921
3400c2ac:	48b1      	ldr	r0, [pc, #708]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c2ae:	f7f6 f945 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c2b2:	4ab1      	ldr	r2, [pc, #708]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c2b4:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c2b6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c2ba:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c2bc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c2c0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c2c4:	3901      	subs	r1, #1
3400c2c6:	4303      	orrs	r3, r0
3400c2c8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c2cc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c2d0:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c2d4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400c2d8:	f8d4 0184 	ldr.w	r0, [r4, #388]	@ 0x184
  LL_RCC_SetClockSource(ClkSource);
3400c2dc:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3400c2e0:	f7fd ffaa 	bl	3400a238 <LL_RCC_SetClockSource>
3400c2e4:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3400c2e8:	2b00      	cmp	r3, #0
3400c2ea:	f281 8050 	bge.w	3400d38e <HAL_RCCEx_PeriphCLKConfig+0x2f8e>
3400c2ee:	f7fd ff73 	bl	3400a1d8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
3400c2f2:	6863      	ldr	r3, [r4, #4]
3400c2f4:	061b      	lsls	r3, r3, #24
3400c2f6:	d511      	bpl.n	3400c31c <HAL_RCCEx_PeriphCLKConfig+0x1f1c>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
3400c2f8:	f8d4 318c 	ldr.w	r3, [r4, #396]	@ 0x18c
3400c2fc:	2b03      	cmp	r3, #3
3400c2fe:	d904      	bls.n	3400c30a <HAL_RCCEx_PeriphCLKConfig+0x1f0a>
3400c300:	f640 113b 	movw	r1, #2363	@ 0x93b
3400c304:	489b      	ldr	r0, [pc, #620]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c306:	f7f6 f919 	bl	3400253c <assert_failed>
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400c30a:	4a9b      	ldr	r2, [pc, #620]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c30c:	f8d4 118c 	ldr.w	r1, [r4, #396]	@ 0x18c
3400c310:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3400c312:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3400c316:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
3400c31a:	6253      	str	r3, [r2, #36]	@ 0x24
}
3400c31c:	1e28      	subs	r0, r5, #0
3400c31e:	bf18      	it	ne
3400c320:	2001      	movne	r0, #1
3400c322:	bd70      	pop	{r4, r5, r6, pc}
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
3400c324:	6d23      	ldr	r3, [r4, #80]	@ 0x50
3400c326:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c32a:	d003      	beq.n	3400c334 <HAL_RCCEx_PeriphCLKConfig+0x1f34>
3400c32c:	21f1      	movs	r1, #241	@ 0xf1
3400c32e:	4891      	ldr	r0, [pc, #580]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c330:	f7f6 f904 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));
3400c334:	6d63      	ldr	r3, [r4, #84]	@ 0x54
3400c336:	3b01      	subs	r3, #1
3400c338:	2bff      	cmp	r3, #255	@ 0xff
3400c33a:	d903      	bls.n	3400c344 <HAL_RCCEx_PeriphCLKConfig+0x1f44>
3400c33c:	21f2      	movs	r1, #242	@ 0xf2
3400c33e:	488d      	ldr	r0, [pc, #564]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c340:	f7f6 f8fc 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400c344:	4a8c      	ldr	r2, [pc, #560]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c346:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3400c348:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3400c34c:	6d20      	ldr	r0, [r4, #80]	@ 0x50
3400c34e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c352:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c356:	3901      	subs	r1, #1
3400c358:	4303      	orrs	r3, r0
3400c35a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c35e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3400c362:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400c366:	f7fe b941 	b.w	3400a5ec <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c36a:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c36c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c370:	d003      	beq.n	3400c37a <HAL_RCCEx_PeriphCLKConfig+0x1f7a>
3400c372:	21fe      	movs	r1, #254	@ 0xfe
3400c374:	487f      	ldr	r0, [pc, #508]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c376:	f7f6 f8e1 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c37a:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c37c:	3b01      	subs	r3, #1
3400c37e:	2bff      	cmp	r3, #255	@ 0xff
3400c380:	d903      	bls.n	3400c38a <HAL_RCCEx_PeriphCLKConfig+0x1f8a>
3400c382:	21ff      	movs	r1, #255	@ 0xff
3400c384:	487b      	ldr	r0, [pc, #492]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c386:	f7f6 f8d9 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c38a:	4a7b      	ldr	r2, [pc, #492]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c38c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c38e:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c392:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c394:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c398:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c39c:	3901      	subs	r1, #1
3400c39e:	4303      	orrs	r3, r0
3400c3a0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c3a4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c3a8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c3ac:	f7fe b91e 	b.w	3400a5ec <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
3400c3b0:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400c3b4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c3b8:	d004      	beq.n	3400c3c4 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
3400c3ba:	f240 110b 	movw	r1, #267	@ 0x10b
3400c3be:	486d      	ldr	r0, [pc, #436]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c3c0:	f7f6 f8bc 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));
3400c3c4:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
3400c3c8:	3b01      	subs	r3, #1
3400c3ca:	2bff      	cmp	r3, #255	@ 0xff
3400c3cc:	d904      	bls.n	3400c3d8 <HAL_RCCEx_PeriphCLKConfig+0x1fd8>
3400c3ce:	f44f 7186 	mov.w	r1, #268	@ 0x10c
3400c3d2:	4868      	ldr	r0, [pc, #416]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c3d4:	f7f6 f8b2 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400c3d8:	4a67      	ldr	r2, [pc, #412]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c3da:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
3400c3de:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3400c3e2:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
3400c3e6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c3ea:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c3ee:	3901      	subs	r1, #1
3400c3f0:	4303      	orrs	r3, r0
3400c3f2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c3f6:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3400c3fa:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3400c3fe:	f7fe b8f5 	b.w	3400a5ec <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
3400c402:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400c406:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c40a:	d004      	beq.n	3400c416 <HAL_RCCEx_PeriphCLKConfig+0x2016>
3400c40c:	f44f 718c 	mov.w	r1, #280	@ 0x118
3400c410:	4858      	ldr	r0, [pc, #352]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c412:	f7f6 f893 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));
3400c416:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
3400c41a:	3b01      	subs	r3, #1
3400c41c:	2bff      	cmp	r3, #255	@ 0xff
3400c41e:	d904      	bls.n	3400c42a <HAL_RCCEx_PeriphCLKConfig+0x202a>
3400c420:	f240 1119 	movw	r1, #281	@ 0x119
3400c424:	4853      	ldr	r0, [pc, #332]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c426:	f7f6 f889 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400c42a:	4a53      	ldr	r2, [pc, #332]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c42c:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
3400c430:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3400c434:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
3400c438:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c43c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c440:	3901      	subs	r1, #1
3400c442:	4303      	orrs	r3, r0
3400c444:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c448:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400c44c:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3400c450:	f7fe b8cc 	b.w	3400a5ec <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3400c454:	4a49      	ldr	r2, [pc, #292]	@ (3400c57c <HAL_RCCEx_PeriphCLKConfig+0x217c>)
3400c456:	4293      	cmp	r3, r2
3400c458:	d123      	bne.n	3400c4a2 <HAL_RCCEx_PeriphCLKConfig+0x20a2>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c45a:	6a23      	ldr	r3, [r4, #32]
3400c45c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c460:	d004      	beq.n	3400c46c <HAL_RCCEx_PeriphCLKConfig+0x206c>
3400c462:	f240 1141 	movw	r1, #321	@ 0x141
3400c466:	4843      	ldr	r0, [pc, #268]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c468:	f7f6 f868 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c46c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c46e:	3b01      	subs	r3, #1
3400c470:	2bff      	cmp	r3, #255	@ 0xff
3400c472:	d904      	bls.n	3400c47e <HAL_RCCEx_PeriphCLKConfig+0x207e>
3400c474:	f44f 71a1 	mov.w	r1, #322	@ 0x142
3400c478:	483e      	ldr	r0, [pc, #248]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c47a:	f7f6 f85f 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c47e:	4a3e      	ldr	r2, [pc, #248]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c480:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c482:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c486:	6a20      	ldr	r0, [r4, #32]
3400c488:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c48c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c490:	3901      	subs	r1, #1
3400c492:	4303      	orrs	r3, r0
3400c494:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c498:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c49c:	2308      	movs	r3, #8
3400c49e:	f7fe b8e8 	b.w	3400a672 <HAL_RCCEx_PeriphCLKConfig+0x272>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3400c4a2:	4a37      	ldr	r2, [pc, #220]	@ (3400c580 <HAL_RCCEx_PeriphCLKConfig+0x2180>)
3400c4a4:	4293      	cmp	r3, r2
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c4a6:	bf02      	ittt	eq
3400c4a8:	2240      	moveq	r2, #64	@ 0x40
3400c4aa:	4b33      	ldreq	r3, [pc, #204]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c4ac:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c4b0:	f7fe b8e1 	b.w	3400a676 <HAL_RCCEx_PeriphCLKConfig+0x276>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3400c4b4:	4a33      	ldr	r2, [pc, #204]	@ (3400c584 <HAL_RCCEx_PeriphCLKConfig+0x2184>)
3400c4b6:	4293      	cmp	r3, r2
3400c4b8:	d123      	bne.n	3400c502 <HAL_RCCEx_PeriphCLKConfig+0x2102>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c4ba:	6a23      	ldr	r3, [r4, #32]
3400c4bc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c4c0:	d004      	beq.n	3400c4cc <HAL_RCCEx_PeriphCLKConfig+0x20cc>
3400c4c2:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3400c4c6:	482b      	ldr	r0, [pc, #172]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c4c8:	f7f6 f838 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c4cc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c4ce:	3b01      	subs	r3, #1
3400c4d0:	2bff      	cmp	r3, #255	@ 0xff
3400c4d2:	d904      	bls.n	3400c4de <HAL_RCCEx_PeriphCLKConfig+0x20de>
3400c4d4:	f240 116f 	movw	r1, #367	@ 0x16f
3400c4d8:	4826      	ldr	r0, [pc, #152]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c4da:	f7f6 f82f 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c4de:	4a26      	ldr	r2, [pc, #152]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c4e0:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c4e2:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c4e6:	6a20      	ldr	r0, [r4, #32]
3400c4e8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c4ec:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c4f0:	3901      	subs	r1, #1
3400c4f2:	4303      	orrs	r3, r0
3400c4f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c4f8:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c4fc:	2308      	movs	r3, #8
3400c4fe:	f7fe b8f5 	b.w	3400a6ec <HAL_RCCEx_PeriphCLKConfig+0x2ec>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3400c502:	4a21      	ldr	r2, [pc, #132]	@ (3400c588 <HAL_RCCEx_PeriphCLKConfig+0x2188>)
3400c504:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c506:	bf02      	ittt	eq
3400c508:	2240      	moveq	r2, #64	@ 0x40
3400c50a:	4b1b      	ldreq	r3, [pc, #108]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c50c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c510:	f7fe b8ee 	b.w	3400a6f0 <HAL_RCCEx_PeriphCLKConfig+0x2f0>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3400c514:	4a1d      	ldr	r2, [pc, #116]	@ (3400c58c <HAL_RCCEx_PeriphCLKConfig+0x218c>)
3400c516:	4293      	cmp	r3, r2
3400c518:	d123      	bne.n	3400c562 <HAL_RCCEx_PeriphCLKConfig+0x2162>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c51a:	6a23      	ldr	r3, [r4, #32]
3400c51c:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c520:	d004      	beq.n	3400c52c <HAL_RCCEx_PeriphCLKConfig+0x212c>
3400c522:	f240 119b 	movw	r1, #411	@ 0x19b
3400c526:	4813      	ldr	r0, [pc, #76]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c528:	f7f6 f808 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c52c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c52e:	3b01      	subs	r3, #1
3400c530:	2bff      	cmp	r3, #255	@ 0xff
3400c532:	d904      	bls.n	3400c53e <HAL_RCCEx_PeriphCLKConfig+0x213e>
3400c534:	f44f 71ce 	mov.w	r1, #412	@ 0x19c
3400c538:	480e      	ldr	r0, [pc, #56]	@ (3400c574 <HAL_RCCEx_PeriphCLKConfig+0x2174>)
3400c53a:	f7f5 ffff 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c53e:	4a0e      	ldr	r2, [pc, #56]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c540:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c542:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c546:	6a20      	ldr	r0, [r4, #32]
3400c548:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c54c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c550:	3901      	subs	r1, #1
3400c552:	4303      	orrs	r3, r0
3400c554:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c558:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c55c:	2308      	movs	r3, #8
3400c55e:	f7fe b902 	b.w	3400a766 <HAL_RCCEx_PeriphCLKConfig+0x366>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3400c562:	4a0b      	ldr	r2, [pc, #44]	@ (3400c590 <HAL_RCCEx_PeriphCLKConfig+0x2190>)
3400c564:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c566:	bf02      	ittt	eq
3400c568:	2240      	moveq	r2, #64	@ 0x40
3400c56a:	4b03      	ldreq	r3, [pc, #12]	@ (3400c578 <HAL_RCCEx_PeriphCLKConfig+0x2178>)
3400c56c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c570:	f7fe b8fb 	b.w	3400a76a <HAL_RCCEx_PeriphCLKConfig+0x36a>
3400c574:	3401c7d4 	.word	0x3401c7d4
3400c578:	56028000 	.word	0x56028000
3400c57c:	03030014 	.word	0x03030014
3400c580:	03010014 	.word	0x03010014
3400c584:	03030414 	.word	0x03030414
3400c588:	03010414 	.word	0x03010414
3400c58c:	03030814 	.word	0x03030814
3400c590:	03010814 	.word	0x03010814
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3400c594:	2b30      	cmp	r3, #48	@ 0x30
3400c596:	d123      	bne.n	3400c5e0 <HAL_RCCEx_PeriphCLKConfig+0x21e0>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
3400c598:	6a23      	ldr	r3, [r4, #32]
3400c59a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c59e:	d004      	beq.n	3400c5aa <HAL_RCCEx_PeriphCLKConfig+0x21aa>
3400c5a0:	f44f 71e4 	mov.w	r1, #456	@ 0x1c8
3400c5a4:	48b2      	ldr	r0, [pc, #712]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c5a6:	f7f5 ffc9 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));
3400c5aa:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400c5ac:	3b01      	subs	r3, #1
3400c5ae:	2bff      	cmp	r3, #255	@ 0xff
3400c5b0:	d904      	bls.n	3400c5bc <HAL_RCCEx_PeriphCLKConfig+0x21bc>
3400c5b2:	f240 11c9 	movw	r1, #457	@ 0x1c9
3400c5b6:	48ae      	ldr	r0, [pc, #696]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c5b8:	f7f5 ffc0 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400c5bc:	4aad      	ldr	r2, [pc, #692]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c5be:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400c5c0:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3400c5c4:	6a20      	ldr	r0, [r4, #32]
3400c5c6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c5ca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c5ce:	3901      	subs	r1, #1
3400c5d0:	4303      	orrs	r3, r0
3400c5d2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c5d6:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3400c5da:	2308      	movs	r3, #8
3400c5dc:	f7fe b8fd 	b.w	3400a7da <HAL_RCCEx_PeriphCLKConfig+0x3da>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3400c5e0:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c5e2:	bf02      	ittt	eq
3400c5e4:	2240      	moveq	r2, #64	@ 0x40
3400c5e6:	4ba3      	ldreq	r3, [pc, #652]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c5e8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c5ec:	f7fe b8f7 	b.w	3400a7de <HAL_RCCEx_PeriphCLKConfig+0x3de>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3400c5f0:	4aa1      	ldr	r2, [pc, #644]	@ (3400c878 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400c5f2:	4293      	cmp	r3, r2
3400c5f4:	d123      	bne.n	3400c63e <HAL_RCCEx_PeriphCLKConfig+0x223e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400c5f6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400c5f8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c5fc:	d004      	beq.n	3400c608 <HAL_RCCEx_PeriphCLKConfig+0x2208>
3400c5fe:	f240 11f5 	movw	r1, #501	@ 0x1f5
3400c602:	489b      	ldr	r0, [pc, #620]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c604:	f7f5 ff9a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400c608:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400c60a:	3b01      	subs	r3, #1
3400c60c:	2bff      	cmp	r3, #255	@ 0xff
3400c60e:	d904      	bls.n	3400c61a <HAL_RCCEx_PeriphCLKConfig+0x221a>
3400c610:	f44f 71fb 	mov.w	r1, #502	@ 0x1f6
3400c614:	4896      	ldr	r0, [pc, #600]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c616:	f7f5 ff91 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400c61a:	4a96      	ldr	r2, [pc, #600]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c61c:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400c61e:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400c622:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400c624:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c628:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c62c:	3901      	subs	r1, #1
3400c62e:	4303      	orrs	r3, r0
3400c630:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c634:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400c638:	2310      	movs	r3, #16
3400c63a:	f7fe b911 	b.w	3400a860 <HAL_RCCEx_PeriphCLKConfig+0x460>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3400c63e:	4a8f      	ldr	r2, [pc, #572]	@ (3400c87c <HAL_RCCEx_PeriphCLKConfig+0x247c>)
3400c640:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c642:	bf02      	ittt	eq
3400c644:	2240      	moveq	r2, #64	@ 0x40
3400c646:	4b8b      	ldreq	r3, [pc, #556]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c648:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c64c:	f7fe b90a 	b.w	3400a864 <HAL_RCCEx_PeriphCLKConfig+0x464>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3400c650:	4a8b      	ldr	r2, [pc, #556]	@ (3400c880 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400c652:	4293      	cmp	r3, r2
3400c654:	d123      	bne.n	3400c69e <HAL_RCCEx_PeriphCLKConfig+0x229e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
3400c656:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400c658:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c65c:	d004      	beq.n	3400c668 <HAL_RCCEx_PeriphCLKConfig+0x2268>
3400c65e:	f240 2122 	movw	r1, #546	@ 0x222
3400c662:	4883      	ldr	r0, [pc, #524]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c664:	f7f5 ff6a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));
3400c668:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400c66a:	3b01      	subs	r3, #1
3400c66c:	2bff      	cmp	r3, #255	@ 0xff
3400c66e:	d904      	bls.n	3400c67a <HAL_RCCEx_PeriphCLKConfig+0x227a>
3400c670:	f240 2123 	movw	r1, #547	@ 0x223
3400c674:	487e      	ldr	r0, [pc, #504]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c676:	f7f5 ff61 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400c67a:	4a7e      	ldr	r2, [pc, #504]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c67c:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400c67e:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3400c682:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
3400c684:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c688:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c68c:	3901      	subs	r1, #1
3400c68e:	4303      	orrs	r3, r0
3400c690:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c694:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400c698:	2310      	movs	r3, #16
3400c69a:	f7fe b938 	b.w	3400a90e <HAL_RCCEx_PeriphCLKConfig+0x50e>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
3400c69e:	4a79      	ldr	r2, [pc, #484]	@ (3400c884 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
3400c6a0:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c6a2:	bf02      	ittt	eq
3400c6a4:	2240      	moveq	r2, #64	@ 0x40
3400c6a6:	4b73      	ldreq	r3, [pc, #460]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c6a8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c6ac:	f7fe b931 	b.w	3400a912 <HAL_RCCEx_PeriphCLKConfig+0x512>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3400c6b0:	2b30      	cmp	r3, #48	@ 0x30
3400c6b2:	d123      	bne.n	3400c6fc <HAL_RCCEx_PeriphCLKConfig+0x22fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400c6b4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400c6b6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c6ba:	d004      	beq.n	3400c6c6 <HAL_RCCEx_PeriphCLKConfig+0x22c6>
3400c6bc:	f44f 7114 	mov.w	r1, #592	@ 0x250
3400c6c0:	486b      	ldr	r0, [pc, #428]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c6c2:	f7f5 ff3b 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400c6c6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400c6c8:	3b01      	subs	r3, #1
3400c6ca:	2bff      	cmp	r3, #255	@ 0xff
3400c6cc:	d904      	bls.n	3400c6d8 <HAL_RCCEx_PeriphCLKConfig+0x22d8>
3400c6ce:	f240 2151 	movw	r1, #593	@ 0x251
3400c6d2:	4867      	ldr	r0, [pc, #412]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c6d4:	f7f5 ff32 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400c6d8:	4a66      	ldr	r2, [pc, #408]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c6da:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400c6dc:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400c6e0:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400c6e2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c6e6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c6ea:	3901      	subs	r1, #1
3400c6ec:	4303      	orrs	r3, r0
3400c6ee:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c6f2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400c6f6:	2380      	movs	r3, #128	@ 0x80
3400c6f8:	f7fe b94f 	b.w	3400a99a <HAL_RCCEx_PeriphCLKConfig+0x59a>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3400c6fc:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c6fe:	bf02      	ittt	eq
3400c700:	2240      	moveq	r2, #64	@ 0x40
3400c702:	4b5c      	ldreq	r3, [pc, #368]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c704:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c708:	f7fe b949 	b.w	3400a99e <HAL_RCCEx_PeriphCLKConfig+0x59e>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3400c70c:	2b03      	cmp	r3, #3
3400c70e:	d123      	bne.n	3400c758 <HAL_RCCEx_PeriphCLKConfig+0x2358>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400c710:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400c712:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c716:	d004      	beq.n	3400c722 <HAL_RCCEx_PeriphCLKConfig+0x2322>
3400c718:	f240 217e 	movw	r1, #638	@ 0x27e
3400c71c:	4854      	ldr	r0, [pc, #336]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c71e:	f7f5 ff0d 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400c722:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400c724:	3b01      	subs	r3, #1
3400c726:	2bff      	cmp	r3, #255	@ 0xff
3400c728:	d904      	bls.n	3400c734 <HAL_RCCEx_PeriphCLKConfig+0x2334>
3400c72a:	f240 217f 	movw	r1, #639	@ 0x27f
3400c72e:	4850      	ldr	r0, [pc, #320]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c730:	f7f5 ff04 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400c734:	4a4f      	ldr	r2, [pc, #316]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c736:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400c738:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400c73c:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400c73e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c742:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c746:	3901      	subs	r1, #1
3400c748:	4303      	orrs	r3, r0
3400c74a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c74e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400c752:	2380      	movs	r3, #128	@ 0x80
3400c754:	f7fe b967 	b.w	3400aa26 <HAL_RCCEx_PeriphCLKConfig+0x626>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
3400c758:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c75a:	bf02      	ittt	eq
3400c75c:	2240      	moveq	r2, #64	@ 0x40
3400c75e:	4b45      	ldreq	r3, [pc, #276]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c760:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c764:	f7fe b961 	b.w	3400aa2a <HAL_RCCEx_PeriphCLKConfig+0x62a>
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3400c768:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c76c:	bf02      	ittt	eq
3400c76e:	2240      	moveq	r2, #64	@ 0x40
3400c770:	4b40      	ldreq	r3, [pc, #256]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c772:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c776:	f7fe b9ca 	b.w	3400ab0e <HAL_RCCEx_PeriphCLKConfig+0x70e>
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
3400c77a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c77e:	bf02      	ittt	eq
3400c780:	2240      	moveq	r2, #64	@ 0x40
3400c782:	4b3c      	ldreq	r3, [pc, #240]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c784:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c788:	f7fe ba03 	b.w	3400ab92 <HAL_RCCEx_PeriphCLKConfig+0x792>
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
3400c78c:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c78e:	bf02      	ittt	eq
3400c790:	2240      	moveq	r2, #64	@ 0x40
3400c792:	4b38      	ldreq	r3, [pc, #224]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c794:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c798:	f7fe ba92 	b.w	3400acc0 <HAL_RCCEx_PeriphCLKConfig+0x8c0>
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3400c79c:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c79e:	bf02      	ittt	eq
3400c7a0:	2240      	moveq	r2, #64	@ 0x40
3400c7a2:	4b34      	ldreq	r3, [pc, #208]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c7a4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c7a8:	f7fe bad3 	b.w	3400ad52 <HAL_RCCEx_PeriphCLKConfig+0x952>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3400c7ac:	4a36      	ldr	r2, [pc, #216]	@ (3400c888 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
3400c7ae:	4293      	cmp	r3, r2
3400c7b0:	d124      	bne.n	3400c7fc <HAL_RCCEx_PeriphCLKConfig+0x23fc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c7b2:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c7b4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c7b8:	d004      	beq.n	3400c7c4 <HAL_RCCEx_PeriphCLKConfig+0x23c4>
3400c7ba:	f240 315a 	movw	r1, #858	@ 0x35a
3400c7be:	482c      	ldr	r0, [pc, #176]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c7c0:	f7f5 febc 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c7c4:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c7c6:	3b01      	subs	r3, #1
3400c7c8:	2bff      	cmp	r3, #255	@ 0xff
3400c7ca:	d904      	bls.n	3400c7d6 <HAL_RCCEx_PeriphCLKConfig+0x23d6>
3400c7cc:	f240 315b 	movw	r1, #859	@ 0x35b
3400c7d0:	4827      	ldr	r0, [pc, #156]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c7d2:	f7f5 feb3 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c7d6:	4a27      	ldr	r2, [pc, #156]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c7d8:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c7da:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c7de:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c7e0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c7e4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c7e8:	3901      	subs	r1, #1
3400c7ea:	4303      	orrs	r3, r0
3400c7ec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c7f0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c7f4:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c7f8:	f7fe baf3 	b.w	3400ade2 <HAL_RCCEx_PeriphCLKConfig+0x9e2>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3400c7fc:	4a23      	ldr	r2, [pc, #140]	@ (3400c88c <HAL_RCCEx_PeriphCLKConfig+0x248c>)
3400c7fe:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c800:	bf02      	ittt	eq
3400c802:	2240      	moveq	r2, #64	@ 0x40
3400c804:	4b1b      	ldreq	r3, [pc, #108]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c806:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c80a:	f7fe baec 	b.w	3400ade6 <HAL_RCCEx_PeriphCLKConfig+0x9e6>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400c80e:	4a20      	ldr	r2, [pc, #128]	@ (3400c890 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
3400c810:	4293      	cmp	r3, r2
3400c812:	d124      	bne.n	3400c85e <HAL_RCCEx_PeriphCLKConfig+0x245e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c814:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c816:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c81a:	d004      	beq.n	3400c826 <HAL_RCCEx_PeriphCLKConfig+0x2426>
3400c81c:	f240 3187 	movw	r1, #903	@ 0x387
3400c820:	4813      	ldr	r0, [pc, #76]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c822:	f7f5 fe8b 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c826:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c828:	3b01      	subs	r3, #1
3400c82a:	2bff      	cmp	r3, #255	@ 0xff
3400c82c:	d904      	bls.n	3400c838 <HAL_RCCEx_PeriphCLKConfig+0x2438>
3400c82e:	f44f 7162 	mov.w	r1, #904	@ 0x388
3400c832:	480f      	ldr	r0, [pc, #60]	@ (3400c870 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400c834:	f7f5 fe82 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c838:	4a0e      	ldr	r2, [pc, #56]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c83a:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c83c:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c840:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c842:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c846:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c84a:	3901      	subs	r1, #1
3400c84c:	4303      	orrs	r3, r0
3400c84e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c852:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c856:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c85a:	f7fe bb06 	b.w	3400ae6a <HAL_RCCEx_PeriphCLKConfig+0xa6a>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3400c85e:	4a0d      	ldr	r2, [pc, #52]	@ (3400c894 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
3400c860:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c862:	bf02      	ittt	eq
3400c864:	2240      	moveq	r2, #64	@ 0x40
3400c866:	4b03      	ldreq	r3, [pc, #12]	@ (3400c874 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400c868:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c86c:	f7fe baff 	b.w	3400ae6e <HAL_RCCEx_PeriphCLKConfig+0xa6e>
3400c870:	3401c7d4 	.word	0x3401c7d4
3400c874:	56028000 	.word	0x56028000
3400c878:	0303001c 	.word	0x0303001c
3400c87c:	0301001c 	.word	0x0301001c
3400c880:	0303041c 	.word	0x0303041c
3400c884:	0301041c 	.word	0x0301041c
3400c888:	0703000c 	.word	0x0703000c
3400c88c:	0701000c 	.word	0x0701000c
3400c890:	0703040c 	.word	0x0703040c
3400c894:	0701040c 	.word	0x0701040c
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
3400c898:	4ab1      	ldr	r2, [pc, #708]	@ (3400cb60 <HAL_RCCEx_PeriphCLKConfig+0x2760>)
3400c89a:	4293      	cmp	r3, r2
3400c89c:	d124      	bne.n	3400c8e8 <HAL_RCCEx_PeriphCLKConfig+0x24e8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c89e:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c8a0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c8a4:	d004      	beq.n	3400c8b0 <HAL_RCCEx_PeriphCLKConfig+0x24b0>
3400c8a6:	f44f 716d 	mov.w	r1, #948	@ 0x3b4
3400c8aa:	48ae      	ldr	r0, [pc, #696]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c8ac:	f7f5 fe46 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c8b0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c8b2:	3b01      	subs	r3, #1
3400c8b4:	2bff      	cmp	r3, #255	@ 0xff
3400c8b6:	d904      	bls.n	3400c8c2 <HAL_RCCEx_PeriphCLKConfig+0x24c2>
3400c8b8:	f240 31b5 	movw	r1, #949	@ 0x3b5
3400c8bc:	48a9      	ldr	r0, [pc, #676]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c8be:	f7f5 fe3d 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c8c2:	4aa9      	ldr	r2, [pc, #676]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c8c4:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c8c6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c8ca:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c8cc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c8d0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c8d4:	3901      	subs	r1, #1
3400c8d6:	4303      	orrs	r3, r0
3400c8d8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c8dc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c8e0:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c8e4:	f7fe bb05 	b.w	3400aef2 <HAL_RCCEx_PeriphCLKConfig+0xaf2>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
3400c8e8:	4aa0      	ldr	r2, [pc, #640]	@ (3400cb6c <HAL_RCCEx_PeriphCLKConfig+0x276c>)
3400c8ea:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c8ec:	bf02      	ittt	eq
3400c8ee:	2240      	moveq	r2, #64	@ 0x40
3400c8f0:	4b9d      	ldreq	r3, [pc, #628]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c8f2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c8f6:	f7fe bafe 	b.w	3400aef6 <HAL_RCCEx_PeriphCLKConfig+0xaf6>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3400c8fa:	4a9d      	ldr	r2, [pc, #628]	@ (3400cb70 <HAL_RCCEx_PeriphCLKConfig+0x2770>)
3400c8fc:	4293      	cmp	r3, r2
3400c8fe:	d124      	bne.n	3400c94a <HAL_RCCEx_PeriphCLKConfig+0x254a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c900:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c902:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c906:	d004      	beq.n	3400c912 <HAL_RCCEx_PeriphCLKConfig+0x2512>
3400c908:	f240 31e1 	movw	r1, #993	@ 0x3e1
3400c90c:	4895      	ldr	r0, [pc, #596]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c90e:	f7f5 fe15 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c912:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c914:	3b01      	subs	r3, #1
3400c916:	2bff      	cmp	r3, #255	@ 0xff
3400c918:	d904      	bls.n	3400c924 <HAL_RCCEx_PeriphCLKConfig+0x2524>
3400c91a:	f240 31e2 	movw	r1, #994	@ 0x3e2
3400c91e:	4891      	ldr	r0, [pc, #580]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c920:	f7f5 fe0c 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c924:	4a90      	ldr	r2, [pc, #576]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c926:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c928:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c92c:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c92e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c932:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c936:	3901      	subs	r1, #1
3400c938:	4303      	orrs	r3, r0
3400c93a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c93e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c942:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c946:	f7fe bb2c 	b.w	3400afa2 <HAL_RCCEx_PeriphCLKConfig+0xba2>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3400c94a:	4a8a      	ldr	r2, [pc, #552]	@ (3400cb74 <HAL_RCCEx_PeriphCLKConfig+0x2774>)
3400c94c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c94e:	bf02      	ittt	eq
3400c950:	2240      	moveq	r2, #64	@ 0x40
3400c952:	4b85      	ldreq	r3, [pc, #532]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c954:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c958:	f7fe bb25 	b.w	3400afa6 <HAL_RCCEx_PeriphCLKConfig+0xba6>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
3400c95c:	4a86      	ldr	r2, [pc, #536]	@ (3400cb78 <HAL_RCCEx_PeriphCLKConfig+0x2778>)
3400c95e:	4293      	cmp	r3, r2
3400c960:	d124      	bne.n	3400c9ac <HAL_RCCEx_PeriphCLKConfig+0x25ac>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c962:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c964:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c968:	d004      	beq.n	3400c974 <HAL_RCCEx_PeriphCLKConfig+0x2574>
3400c96a:	f240 410e 	movw	r1, #1038	@ 0x40e
3400c96e:	487d      	ldr	r0, [pc, #500]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c970:	f7f5 fde4 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c974:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c976:	3b01      	subs	r3, #1
3400c978:	2bff      	cmp	r3, #255	@ 0xff
3400c97a:	d904      	bls.n	3400c986 <HAL_RCCEx_PeriphCLKConfig+0x2586>
3400c97c:	f240 410f 	movw	r1, #1039	@ 0x40f
3400c980:	4878      	ldr	r0, [pc, #480]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c982:	f7f5 fddb 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c986:	4a78      	ldr	r2, [pc, #480]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c988:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c98a:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c98e:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c990:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c994:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c998:	3901      	subs	r1, #1
3400c99a:	4303      	orrs	r3, r0
3400c99c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400c9a0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400c9a4:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400c9a8:	f7fe bb3f 	b.w	3400b02a <HAL_RCCEx_PeriphCLKConfig+0xc2a>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3400c9ac:	4a73      	ldr	r2, [pc, #460]	@ (3400cb7c <HAL_RCCEx_PeriphCLKConfig+0x277c>)
3400c9ae:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400c9b0:	bf02      	ittt	eq
3400c9b2:	2240      	moveq	r2, #64	@ 0x40
3400c9b4:	4b6c      	ldreq	r3, [pc, #432]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c9b6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400c9ba:	f7fe bb38 	b.w	3400b02e <HAL_RCCEx_PeriphCLKConfig+0xc2e>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3400c9be:	4a70      	ldr	r2, [pc, #448]	@ (3400cb80 <HAL_RCCEx_PeriphCLKConfig+0x2780>)
3400c9c0:	4293      	cmp	r3, r2
3400c9c2:	d124      	bne.n	3400ca0e <HAL_RCCEx_PeriphCLKConfig+0x260e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
3400c9c4:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
3400c9c6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400c9ca:	d004      	beq.n	3400c9d6 <HAL_RCCEx_PeriphCLKConfig+0x25d6>
3400c9cc:	f240 413b 	movw	r1, #1083	@ 0x43b
3400c9d0:	4864      	ldr	r0, [pc, #400]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c9d2:	f7f5 fdb3 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));
3400c9d6:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
3400c9d8:	3b01      	subs	r3, #1
3400c9da:	2bff      	cmp	r3, #255	@ 0xff
3400c9dc:	d904      	bls.n	3400c9e8 <HAL_RCCEx_PeriphCLKConfig+0x25e8>
3400c9de:	f240 413c 	movw	r1, #1084	@ 0x43c
3400c9e2:	4860      	ldr	r0, [pc, #384]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400c9e4:	f7f5 fdaa 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400c9e8:	4a5f      	ldr	r2, [pc, #380]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400c9ea:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3400c9ec:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3400c9f0:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
3400c9f2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400c9f6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400c9fa:	3901      	subs	r1, #1
3400c9fc:	4303      	orrs	r3, r0
3400c9fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ca02:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400ca06:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400ca0a:	f7fe bb52 	b.w	3400b0b2 <HAL_RCCEx_PeriphCLKConfig+0xcb2>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3400ca0e:	4a5d      	ldr	r2, [pc, #372]	@ (3400cb84 <HAL_RCCEx_PeriphCLKConfig+0x2784>)
3400ca10:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca12:	bf02      	ittt	eq
3400ca14:	2240      	moveq	r2, #64	@ 0x40
3400ca16:	4b54      	ldreq	r3, [pc, #336]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca18:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca1c:	f7fe bb4b 	b.w	3400b0b6 <HAL_RCCEx_PeriphCLKConfig+0xcb6>
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3400ca20:	4a59      	ldr	r2, [pc, #356]	@ (3400cb88 <HAL_RCCEx_PeriphCLKConfig+0x2788>)
3400ca22:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca24:	bf02      	ittt	eq
3400ca26:	2240      	moveq	r2, #64	@ 0x40
3400ca28:	4b4f      	ldreq	r3, [pc, #316]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca2a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca2e:	f7fe bb86 	b.w	3400b13e <HAL_RCCEx_PeriphCLKConfig+0xd3e>
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3400ca32:	4a56      	ldr	r2, [pc, #344]	@ (3400cb8c <HAL_RCCEx_PeriphCLKConfig+0x278c>)
3400ca34:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca36:	bf02      	ittt	eq
3400ca38:	2240      	moveq	r2, #64	@ 0x40
3400ca3a:	4b4b      	ldreq	r3, [pc, #300]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca3c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca40:	f7fe bbc1 	b.w	3400b1c6 <HAL_RCCEx_PeriphCLKConfig+0xdc6>
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3400ca44:	4a52      	ldr	r2, [pc, #328]	@ (3400cb90 <HAL_RCCEx_PeriphCLKConfig+0x2790>)
3400ca46:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca48:	bf02      	ittt	eq
3400ca4a:	2240      	moveq	r2, #64	@ 0x40
3400ca4c:	4b46      	ldreq	r3, [pc, #280]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca4e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca52:	f7fe bc17 	b.w	3400b284 <HAL_RCCEx_PeriphCLKConfig+0xe84>
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
3400ca56:	4a4f      	ldr	r2, [pc, #316]	@ (3400cb94 <HAL_RCCEx_PeriphCLKConfig+0x2794>)
3400ca58:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca5a:	bf02      	ittt	eq
3400ca5c:	2240      	moveq	r2, #64	@ 0x40
3400ca5e:	4b42      	ldreq	r3, [pc, #264]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca60:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca64:	f7fe bc52 	b.w	3400b30c <HAL_RCCEx_PeriphCLKConfig+0xf0c>
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3400ca68:	4a4b      	ldr	r2, [pc, #300]	@ (3400cb98 <HAL_RCCEx_PeriphCLKConfig+0x2798>)
3400ca6a:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ca6c:	bf02      	ittt	eq
3400ca6e:	2240      	moveq	r2, #64	@ 0x40
3400ca70:	4b3d      	ldreq	r3, [pc, #244]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400ca72:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ca76:	f7fe bc8d 	b.w	3400b394 <HAL_RCCEx_PeriphCLKConfig+0xf94>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3400ca7a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400ca7e:	d124      	bne.n	3400caca <HAL_RCCEx_PeriphCLKConfig+0x26ca>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400ca80:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400ca82:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ca86:	d004      	beq.n	3400ca92 <HAL_RCCEx_PeriphCLKConfig+0x2692>
3400ca88:	f44f 61a1 	mov.w	r1, #1288	@ 0x508
3400ca8c:	4835      	ldr	r0, [pc, #212]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400ca8e:	f7f5 fd55 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400ca92:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400ca94:	3b01      	subs	r3, #1
3400ca96:	2bff      	cmp	r3, #255	@ 0xff
3400ca98:	d904      	bls.n	3400caa4 <HAL_RCCEx_PeriphCLKConfig+0x26a4>
3400ca9a:	f240 5109 	movw	r1, #1289	@ 0x509
3400ca9e:	4831      	ldr	r0, [pc, #196]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400caa0:	f7f5 fd4c 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400caa4:	4a30      	ldr	r2, [pc, #192]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400caa6:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400caa8:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400caac:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400caae:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cab2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cab6:	3901      	subs	r1, #1
3400cab8:	4303      	orrs	r3, r0
3400caba:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cabe:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cac2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cac6:	f7fe bca7 	b.w	3400b418 <HAL_RCCEx_PeriphCLKConfig+0x1018>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
3400caca:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cace:	bf02      	ittt	eq
3400cad0:	2240      	moveq	r2, #64	@ 0x40
3400cad2:	4b25      	ldreq	r3, [pc, #148]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cad4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cad8:	f7fe bca0 	b.w	3400b41c <HAL_RCCEx_PeriphCLKConfig+0x101c>
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3400cadc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cae0:	bf02      	ittt	eq
3400cae2:	2240      	moveq	r2, #64	@ 0x40
3400cae4:	4b20      	ldreq	r3, [pc, #128]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cae6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400caea:	f7fe bcdd 	b.w	3400b4a8 <HAL_RCCEx_PeriphCLKConfig+0x10a8>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
3400caee:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400caf2:	d123      	bne.n	3400cb3c <HAL_RCCEx_PeriphCLKConfig+0x273c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400caf4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400caf6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cafa:	d004      	beq.n	3400cb06 <HAL_RCCEx_PeriphCLKConfig+0x2706>
3400cafc:	f240 5155 	movw	r1, #1365	@ 0x555
3400cb00:	4818      	ldr	r0, [pc, #96]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400cb02:	f7f5 fd1b 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cb06:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cb08:	3b01      	subs	r3, #1
3400cb0a:	2bff      	cmp	r3, #255	@ 0xff
3400cb0c:	d904      	bls.n	3400cb18 <HAL_RCCEx_PeriphCLKConfig+0x2718>
3400cb0e:	f240 5156 	movw	r1, #1366	@ 0x556
3400cb12:	4814      	ldr	r0, [pc, #80]	@ (3400cb64 <HAL_RCCEx_PeriphCLKConfig+0x2764>)
3400cb14:	f7f5 fd12 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cb18:	4a13      	ldr	r2, [pc, #76]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cb1a:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cb1c:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cb20:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cb22:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cb26:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cb2a:	3901      	subs	r1, #1
3400cb2c:	4303      	orrs	r3, r0
3400cb2e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cb32:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cb36:	2380      	movs	r3, #128	@ 0x80
3400cb38:	f7fe bcf8 	b.w	3400b52c <HAL_RCCEx_PeriphCLKConfig+0x112c>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3400cb3c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cb40:	bf02      	ittt	eq
3400cb42:	2240      	moveq	r2, #64	@ 0x40
3400cb44:	4b08      	ldreq	r3, [pc, #32]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cb46:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cb4a:	f7fe bcf1 	b.w	3400b530 <HAL_RCCEx_PeriphCLKConfig+0x1130>
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3400cb4e:	2b10      	cmp	r3, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cb50:	bf02      	ittt	eq
3400cb52:	2240      	moveq	r2, #64	@ 0x40
3400cb54:	4b04      	ldreq	r3, [pc, #16]	@ (3400cb68 <HAL_RCCEx_PeriphCLKConfig+0x2768>)
3400cb56:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cb5a:	f7fe bd3b 	b.w	3400b5d4 <HAL_RCCEx_PeriphCLKConfig+0x11d4>
3400cb5e:	bf00      	nop
3400cb60:	0703080c 	.word	0x0703080c
3400cb64:	3401c7d4 	.word	0x3401c7d4
3400cb68:	56028000 	.word	0x56028000
3400cb6c:	0701080c 	.word	0x0701080c
3400cb70:	07030c0c 	.word	0x07030c0c
3400cb74:	07010c0c 	.word	0x07010c0c
3400cb78:	0703100c 	.word	0x0703100c
3400cb7c:	0701100c 	.word	0x0701100c
3400cb80:	0703140c 	.word	0x0703140c
3400cb84:	0701140c 	.word	0x0701140c
3400cb88:	0701082c 	.word	0x0701082c
3400cb8c:	07010c2c 	.word	0x07010c2c
3400cb90:	0701102c 	.word	0x0701102c
3400cb94:	0701142c 	.word	0x0701142c
3400cb98:	0701182c 	.word	0x0701182c
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3400cb9c:	4aa8      	ldr	r2, [pc, #672]	@ (3400ce40 <HAL_RCCEx_PeriphCLKConfig+0x2a40>)
3400cb9e:	4293      	cmp	r3, r2
3400cba0:	d123      	bne.n	3400cbea <HAL_RCCEx_PeriphCLKConfig+0x27ea>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cba2:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cba4:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cba8:	d004      	beq.n	3400cbb4 <HAL_RCCEx_PeriphCLKConfig+0x27b4>
3400cbaa:	f240 51a2 	movw	r1, #1442	@ 0x5a2
3400cbae:	48a5      	ldr	r0, [pc, #660]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cbb0:	f7f5 fcc4 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cbb4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cbb6:	3b01      	subs	r3, #1
3400cbb8:	2bff      	cmp	r3, #255	@ 0xff
3400cbba:	d904      	bls.n	3400cbc6 <HAL_RCCEx_PeriphCLKConfig+0x27c6>
3400cbbc:	f240 51a3 	movw	r1, #1443	@ 0x5a3
3400cbc0:	48a0      	ldr	r0, [pc, #640]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cbc2:	f7f5 fcbb 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cbc6:	4aa0      	ldr	r2, [pc, #640]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cbc8:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cbca:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cbce:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cbd0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cbd4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cbd8:	3901      	subs	r1, #1
3400cbda:	4303      	orrs	r3, r0
3400cbdc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cbe0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cbe4:	2380      	movs	r3, #128	@ 0x80
3400cbe6:	f7fe bd3a 	b.w	3400b65e <HAL_RCCEx_PeriphCLKConfig+0x125e>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
3400cbea:	4a98      	ldr	r2, [pc, #608]	@ (3400ce4c <HAL_RCCEx_PeriphCLKConfig+0x2a4c>)
3400cbec:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cbee:	bf02      	ittt	eq
3400cbf0:	2240      	moveq	r2, #64	@ 0x40
3400cbf2:	4b95      	ldreq	r3, [pc, #596]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cbf4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cbf8:	f7fe bd33 	b.w	3400b662 <HAL_RCCEx_PeriphCLKConfig+0x1262>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
3400cbfc:	4a94      	ldr	r2, [pc, #592]	@ (3400ce50 <HAL_RCCEx_PeriphCLKConfig+0x2a50>)
3400cbfe:	4293      	cmp	r3, r2
3400cc00:	d123      	bne.n	3400cc4a <HAL_RCCEx_PeriphCLKConfig+0x284a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cc02:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cc04:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cc08:	d004      	beq.n	3400cc14 <HAL_RCCEx_PeriphCLKConfig+0x2814>
3400cc0a:	f240 51cf 	movw	r1, #1487	@ 0x5cf
3400cc0e:	488d      	ldr	r0, [pc, #564]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cc10:	f7f5 fc94 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cc14:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cc16:	3b01      	subs	r3, #1
3400cc18:	2bff      	cmp	r3, #255	@ 0xff
3400cc1a:	d904      	bls.n	3400cc26 <HAL_RCCEx_PeriphCLKConfig+0x2826>
3400cc1c:	f44f 61ba 	mov.w	r1, #1488	@ 0x5d0
3400cc20:	4888      	ldr	r0, [pc, #544]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cc22:	f7f5 fc8b 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cc26:	4a88      	ldr	r2, [pc, #544]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc28:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cc2a:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cc2e:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cc30:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cc34:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cc38:	3901      	subs	r1, #1
3400cc3a:	4303      	orrs	r3, r0
3400cc3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cc40:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cc44:	2380      	movs	r3, #128	@ 0x80
3400cc46:	f7fe bd4b 	b.w	3400b6e0 <HAL_RCCEx_PeriphCLKConfig+0x12e0>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3400cc4a:	4a82      	ldr	r2, [pc, #520]	@ (3400ce54 <HAL_RCCEx_PeriphCLKConfig+0x2a54>)
3400cc4c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cc4e:	bf02      	ittt	eq
3400cc50:	2240      	moveq	r2, #64	@ 0x40
3400cc52:	4b7d      	ldreq	r3, [pc, #500]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc54:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cc58:	f7fe bd44 	b.w	3400b6e4 <HAL_RCCEx_PeriphCLKConfig+0x12e4>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3400cc5c:	2b03      	cmp	r3, #3
3400cc5e:	d123      	bne.n	3400cca8 <HAL_RCCEx_PeriphCLKConfig+0x28a8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
3400cc60:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400cc62:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cc66:	d004      	beq.n	3400cc72 <HAL_RCCEx_PeriphCLKConfig+0x2872>
3400cc68:	f240 51fc 	movw	r1, #1532	@ 0x5fc
3400cc6c:	4875      	ldr	r0, [pc, #468]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cc6e:	f7f5 fc65 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));
3400cc72:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400cc74:	3b01      	subs	r3, #1
3400cc76:	2bff      	cmp	r3, #255	@ 0xff
3400cc78:	d904      	bls.n	3400cc84 <HAL_RCCEx_PeriphCLKConfig+0x2884>
3400cc7a:	f240 51fd 	movw	r1, #1533	@ 0x5fd
3400cc7e:	4871      	ldr	r0, [pc, #452]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cc80:	f7f5 fc5c 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400cc84:	4a70      	ldr	r2, [pc, #448]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cc86:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3400cc88:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3400cc8c:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400cc8e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cc92:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cc96:	3901      	subs	r1, #1
3400cc98:	4303      	orrs	r3, r0
3400cc9a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cc9e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3400cca2:	2380      	movs	r3, #128	@ 0x80
3400cca4:	f7fe bd55 	b.w	3400b752 <HAL_RCCEx_PeriphCLKConfig+0x1352>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
3400cca8:	2b01      	cmp	r3, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ccaa:	bf02      	ittt	eq
3400ccac:	2240      	moveq	r2, #64	@ 0x40
3400ccae:	4b66      	ldreq	r3, [pc, #408]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400ccb0:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ccb4:	f7fe bd4f 	b.w	3400b756 <HAL_RCCEx_PeriphCLKConfig+0x1356>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3400ccb8:	4a67      	ldr	r2, [pc, #412]	@ (3400ce58 <HAL_RCCEx_PeriphCLKConfig+0x2a58>)
3400ccba:	4293      	cmp	r3, r2
3400ccbc:	d124      	bne.n	3400cd08 <HAL_RCCEx_PeriphCLKConfig+0x2908>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400ccbe:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400ccc0:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ccc4:	d004      	beq.n	3400ccd0 <HAL_RCCEx_PeriphCLKConfig+0x28d0>
3400ccc6:	f240 6129 	movw	r1, #1577	@ 0x629
3400ccca:	485e      	ldr	r0, [pc, #376]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cccc:	f7f5 fc36 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400ccd0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400ccd2:	3b01      	subs	r3, #1
3400ccd4:	2bff      	cmp	r3, #255	@ 0xff
3400ccd6:	d904      	bls.n	3400cce2 <HAL_RCCEx_PeriphCLKConfig+0x28e2>
3400ccd8:	f240 612a 	movw	r1, #1578	@ 0x62a
3400ccdc:	4859      	ldr	r0, [pc, #356]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400ccde:	f7f5 fc2d 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400cce2:	4a59      	ldr	r2, [pc, #356]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cce4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400cce6:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400ccea:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400ccec:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ccf0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ccf4:	3901      	subs	r1, #1
3400ccf6:	4303      	orrs	r3, r0
3400ccf8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ccfc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cd00:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cd04:	f7fe bd72 	b.w	3400b7ec <HAL_RCCEx_PeriphCLKConfig+0x13ec>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3400cd08:	4a54      	ldr	r2, [pc, #336]	@ (3400ce5c <HAL_RCCEx_PeriphCLKConfig+0x2a5c>)
3400cd0a:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cd0c:	bf02      	ittt	eq
3400cd0e:	2240      	moveq	r2, #64	@ 0x40
3400cd10:	4b4d      	ldreq	r3, [pc, #308]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cd12:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cd16:	f7fe bd6b 	b.w	3400b7f0 <HAL_RCCEx_PeriphCLKConfig+0x13f0>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3400cd1a:	4a51      	ldr	r2, [pc, #324]	@ (3400ce60 <HAL_RCCEx_PeriphCLKConfig+0x2a60>)
3400cd1c:	4293      	cmp	r3, r2
3400cd1e:	d124      	bne.n	3400cd6a <HAL_RCCEx_PeriphCLKConfig+0x296a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cd20:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cd22:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cd26:	d004      	beq.n	3400cd32 <HAL_RCCEx_PeriphCLKConfig+0x2932>
3400cd28:	f240 6156 	movw	r1, #1622	@ 0x656
3400cd2c:	4845      	ldr	r0, [pc, #276]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cd2e:	f7f5 fc05 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400cd32:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400cd34:	3b01      	subs	r3, #1
3400cd36:	2bff      	cmp	r3, #255	@ 0xff
3400cd38:	d904      	bls.n	3400cd44 <HAL_RCCEx_PeriphCLKConfig+0x2944>
3400cd3a:	f240 6157 	movw	r1, #1623	@ 0x657
3400cd3e:	4841      	ldr	r0, [pc, #260]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cd40:	f7f5 fbfc 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400cd44:	4a40      	ldr	r2, [pc, #256]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cd46:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400cd48:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400cd4c:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400cd4e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cd52:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cd56:	3901      	subs	r1, #1
3400cd58:	4303      	orrs	r3, r0
3400cd5a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cd5e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cd62:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cd66:	f7fe bd88 	b.w	3400b87a <HAL_RCCEx_PeriphCLKConfig+0x147a>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3400cd6a:	4a3e      	ldr	r2, [pc, #248]	@ (3400ce64 <HAL_RCCEx_PeriphCLKConfig+0x2a64>)
3400cd6c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cd6e:	bf02      	ittt	eq
3400cd70:	2240      	moveq	r2, #64	@ 0x40
3400cd72:	4b35      	ldreq	r3, [pc, #212]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cd74:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cd78:	f7fe bd81 	b.w	3400b87e <HAL_RCCEx_PeriphCLKConfig+0x147e>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3400cd7c:	4a3a      	ldr	r2, [pc, #232]	@ (3400ce68 <HAL_RCCEx_PeriphCLKConfig+0x2a68>)
3400cd7e:	4293      	cmp	r3, r2
3400cd80:	d124      	bne.n	3400cdcc <HAL_RCCEx_PeriphCLKConfig+0x29cc>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cd82:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cd84:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cd88:	d004      	beq.n	3400cd94 <HAL_RCCEx_PeriphCLKConfig+0x2994>
3400cd8a:	f240 6183 	movw	r1, #1667	@ 0x683
3400cd8e:	482d      	ldr	r0, [pc, #180]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cd90:	f7f5 fbd4 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400cd94:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400cd96:	3b01      	subs	r3, #1
3400cd98:	2bff      	cmp	r3, #255	@ 0xff
3400cd9a:	d904      	bls.n	3400cda6 <HAL_RCCEx_PeriphCLKConfig+0x29a6>
3400cd9c:	f240 6184 	movw	r1, #1668	@ 0x684
3400cda0:	4828      	ldr	r0, [pc, #160]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cda2:	f7f5 fbcb 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400cda6:	4a28      	ldr	r2, [pc, #160]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cda8:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400cdaa:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400cdae:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400cdb0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cdb4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cdb8:	3901      	subs	r1, #1
3400cdba:	4303      	orrs	r3, r0
3400cdbc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cdc0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cdc4:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cdc8:	f7fe bdb8 	b.w	3400b93c <HAL_RCCEx_PeriphCLKConfig+0x153c>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3400cdcc:	4a27      	ldr	r2, [pc, #156]	@ (3400ce6c <HAL_RCCEx_PeriphCLKConfig+0x2a6c>)
3400cdce:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cdd0:	bf02      	ittt	eq
3400cdd2:	2240      	moveq	r2, #64	@ 0x40
3400cdd4:	4b1c      	ldreq	r3, [pc, #112]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400cdd6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cdda:	f7fe bdb1 	b.w	3400b940 <HAL_RCCEx_PeriphCLKConfig+0x1540>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3400cdde:	4a24      	ldr	r2, [pc, #144]	@ (3400ce70 <HAL_RCCEx_PeriphCLKConfig+0x2a70>)
3400cde0:	4293      	cmp	r3, r2
3400cde2:	d124      	bne.n	3400ce2e <HAL_RCCEx_PeriphCLKConfig+0x2a2e>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cde4:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cde6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cdea:	d004      	beq.n	3400cdf6 <HAL_RCCEx_PeriphCLKConfig+0x29f6>
3400cdec:	f44f 61d6 	mov.w	r1, #1712	@ 0x6b0
3400cdf0:	4814      	ldr	r0, [pc, #80]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400cdf2:	f7f5 fba3 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cdf6:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cdf8:	3b01      	subs	r3, #1
3400cdfa:	2bff      	cmp	r3, #255	@ 0xff
3400cdfc:	d904      	bls.n	3400ce08 <HAL_RCCEx_PeriphCLKConfig+0x2a08>
3400cdfe:	f240 61b1 	movw	r1, #1713	@ 0x6b1
3400ce02:	4810      	ldr	r0, [pc, #64]	@ (3400ce44 <HAL_RCCEx_PeriphCLKConfig+0x2a44>)
3400ce04:	f7f5 fb9a 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400ce08:	4a0f      	ldr	r2, [pc, #60]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400ce0a:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400ce0c:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400ce10:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400ce12:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ce16:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ce1a:	3901      	subs	r1, #1
3400ce1c:	4303      	orrs	r3, r0
3400ce1e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400ce22:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400ce26:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400ce2a:	f7fe bdcf 	b.w	3400b9cc <HAL_RCCEx_PeriphCLKConfig+0x15cc>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3400ce2e:	4a11      	ldr	r2, [pc, #68]	@ (3400ce74 <HAL_RCCEx_PeriphCLKConfig+0x2a74>)
3400ce30:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400ce32:	bf02      	ittt	eq
3400ce34:	2240      	moveq	r2, #64	@ 0x40
3400ce36:	4b04      	ldreq	r3, [pc, #16]	@ (3400ce48 <HAL_RCCEx_PeriphCLKConfig+0x2a48>)
3400ce38:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ce3c:	f7fe bdc8 	b.w	3400b9d0 <HAL_RCCEx_PeriphCLKConfig+0x15d0>
3400ce40:	07031418 	.word	0x07031418
3400ce44:	3401c7d4 	.word	0x3401c7d4
3400ce48:	56028000 	.word	0x56028000
3400ce4c:	07011418 	.word	0x07011418
3400ce50:	07031818 	.word	0x07031818
3400ce54:	07011818 	.word	0x07011818
3400ce58:	07030420 	.word	0x07030420
3400ce5c:	07010420 	.word	0x07010420
3400ce60:	07030820 	.word	0x07030820
3400ce64:	07010820 	.word	0x07010820
3400ce68:	07030c20 	.word	0x07030c20
3400ce6c:	07010c20 	.word	0x07010c20
3400ce70:	07031020 	.word	0x07031020
3400ce74:	07011020 	.word	0x07011020
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3400ce78:	4aab      	ldr	r2, [pc, #684]	@ (3400d128 <HAL_RCCEx_PeriphCLKConfig+0x2d28>)
3400ce7a:	4293      	cmp	r3, r2
3400ce7c:	d124      	bne.n	3400cec8 <HAL_RCCEx_PeriphCLKConfig+0x2ac8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400ce7e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400ce80:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400ce84:	d004      	beq.n	3400ce90 <HAL_RCCEx_PeriphCLKConfig+0x2a90>
3400ce86:	f240 61dd 	movw	r1, #1757	@ 0x6dd
3400ce8a:	48a8      	ldr	r0, [pc, #672]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ce8c:	f7f5 fb56 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400ce90:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400ce92:	3b01      	subs	r3, #1
3400ce94:	2bff      	cmp	r3, #255	@ 0xff
3400ce96:	d904      	bls.n	3400cea2 <HAL_RCCEx_PeriphCLKConfig+0x2aa2>
3400ce98:	f240 61de 	movw	r1, #1758	@ 0x6de
3400ce9c:	48a3      	ldr	r0, [pc, #652]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ce9e:	f7f5 fb4d 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cea2:	4aa3      	ldr	r2, [pc, #652]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cea4:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cea6:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400ceaa:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400ceac:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ceb0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ceb4:	3901      	subs	r1, #1
3400ceb6:	4303      	orrs	r3, r0
3400ceb8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cebc:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cec0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cec4:	f7fe bdca 	b.w	3400ba5c <HAL_RCCEx_PeriphCLKConfig+0x165c>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3400cec8:	4a9a      	ldr	r2, [pc, #616]	@ (3400d134 <HAL_RCCEx_PeriphCLKConfig+0x2d34>)
3400ceca:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cecc:	bf02      	ittt	eq
3400cece:	2240      	moveq	r2, #64	@ 0x40
3400ced0:	4b97      	ldreq	r3, [pc, #604]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400ced2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400ced6:	f7fe bdc3 	b.w	3400ba60 <HAL_RCCEx_PeriphCLKConfig+0x1660>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
3400ceda:	4a97      	ldr	r2, [pc, #604]	@ (3400d138 <HAL_RCCEx_PeriphCLKConfig+0x2d38>)
3400cedc:	4293      	cmp	r3, r2
3400cede:	d124      	bne.n	3400cf2a <HAL_RCCEx_PeriphCLKConfig+0x2b2a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
3400cee0:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400cee2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cee6:	d004      	beq.n	3400cef2 <HAL_RCCEx_PeriphCLKConfig+0x2af2>
3400cee8:	f240 710a 	movw	r1, #1802	@ 0x70a
3400ceec:	488f      	ldr	r0, [pc, #572]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400ceee:	f7f5 fb25 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));
3400cef2:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400cef4:	3b01      	subs	r3, #1
3400cef6:	2bff      	cmp	r3, #255	@ 0xff
3400cef8:	d904      	bls.n	3400cf04 <HAL_RCCEx_PeriphCLKConfig+0x2b04>
3400cefa:	f240 710b 	movw	r1, #1803	@ 0x70b
3400cefe:	488b      	ldr	r0, [pc, #556]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cf00:	f7f5 fb1c 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400cf04:	4a8a      	ldr	r2, [pc, #552]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf06:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400cf08:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3400cf0c:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
3400cf0e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cf12:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cf16:	3901      	subs	r1, #1
3400cf18:	4303      	orrs	r3, r0
3400cf1a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cf1e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3400cf22:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400cf26:	f7fe bde0 	b.w	3400baea <HAL_RCCEx_PeriphCLKConfig+0x16ea>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3400cf2a:	4a84      	ldr	r2, [pc, #528]	@ (3400d13c <HAL_RCCEx_PeriphCLKConfig+0x2d3c>)
3400cf2c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cf2e:	bf02      	ittt	eq
3400cf30:	2240      	moveq	r2, #64	@ 0x40
3400cf32:	4b7f      	ldreq	r3, [pc, #508]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf34:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cf38:	f7fe bdd9 	b.w	3400baee <HAL_RCCEx_PeriphCLKConfig+0x16ee>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
3400cf3c:	4a80      	ldr	r2, [pc, #512]	@ (3400d140 <HAL_RCCEx_PeriphCLKConfig+0x2d40>)
3400cf3e:	4293      	cmp	r3, r2
3400cf40:	d124      	bne.n	3400cf8c <HAL_RCCEx_PeriphCLKConfig+0x2b8c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cf42:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cf44:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cf48:	d004      	beq.n	3400cf54 <HAL_RCCEx_PeriphCLKConfig+0x2b54>
3400cf4a:	f240 7137 	movw	r1, #1847	@ 0x737
3400cf4e:	4877      	ldr	r0, [pc, #476]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cf50:	f7f5 faf4 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cf54:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cf56:	3b01      	subs	r3, #1
3400cf58:	2bff      	cmp	r3, #255	@ 0xff
3400cf5a:	d904      	bls.n	3400cf66 <HAL_RCCEx_PeriphCLKConfig+0x2b66>
3400cf5c:	f44f 61e7 	mov.w	r1, #1848	@ 0x738
3400cf60:	4872      	ldr	r0, [pc, #456]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cf62:	f7f5 faeb 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cf66:	4a72      	ldr	r2, [pc, #456]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf68:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cf6a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400cf6e:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400cf70:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cf74:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cf78:	3901      	subs	r1, #1
3400cf7a:	4303      	orrs	r3, r0
3400cf7c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cf80:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cf84:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cf88:	f7fe bdf7 	b.w	3400bb7a <HAL_RCCEx_PeriphCLKConfig+0x177a>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
3400cf8c:	4a6d      	ldr	r2, [pc, #436]	@ (3400d144 <HAL_RCCEx_PeriphCLKConfig+0x2d44>)
3400cf8e:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cf90:	bf02      	ittt	eq
3400cf92:	2240      	moveq	r2, #64	@ 0x40
3400cf94:	4b66      	ldreq	r3, [pc, #408]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cf96:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cf9a:	f7fe bdf0 	b.w	3400bb7e <HAL_RCCEx_PeriphCLKConfig+0x177e>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3400cf9e:	4a6a      	ldr	r2, [pc, #424]	@ (3400d148 <HAL_RCCEx_PeriphCLKConfig+0x2d48>)
3400cfa0:	4293      	cmp	r3, r2
3400cfa2:	d124      	bne.n	3400cfee <HAL_RCCEx_PeriphCLKConfig+0x2bee>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400cfa4:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400cfa6:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400cfaa:	d004      	beq.n	3400cfb6 <HAL_RCCEx_PeriphCLKConfig+0x2bb6>
3400cfac:	f240 7164 	movw	r1, #1892	@ 0x764
3400cfb0:	485e      	ldr	r0, [pc, #376]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cfb2:	f7f5 fac3 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400cfb6:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400cfb8:	3b01      	subs	r3, #1
3400cfba:	2bff      	cmp	r3, #255	@ 0xff
3400cfbc:	d904      	bls.n	3400cfc8 <HAL_RCCEx_PeriphCLKConfig+0x2bc8>
3400cfbe:	f240 7165 	movw	r1, #1893	@ 0x765
3400cfc2:	485a      	ldr	r0, [pc, #360]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400cfc4:	f7f5 faba 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400cfc8:	4a59      	ldr	r2, [pc, #356]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cfca:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400cfcc:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400cfd0:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400cfd2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400cfd6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400cfda:	3901      	subs	r1, #1
3400cfdc:	4303      	orrs	r3, r0
3400cfde:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400cfe2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400cfe6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400cfea:	f7fe be27 	b.w	3400bc3c <HAL_RCCEx_PeriphCLKConfig+0x183c>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3400cfee:	4a57      	ldr	r2, [pc, #348]	@ (3400d14c <HAL_RCCEx_PeriphCLKConfig+0x2d4c>)
3400cff0:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400cff2:	bf02      	ittt	eq
3400cff4:	2240      	moveq	r2, #64	@ 0x40
3400cff6:	4b4e      	ldreq	r3, [pc, #312]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400cff8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400cffc:	f7fe be20 	b.w	3400bc40 <HAL_RCCEx_PeriphCLKConfig+0x1840>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3400d000:	4a53      	ldr	r2, [pc, #332]	@ (3400d150 <HAL_RCCEx_PeriphCLKConfig+0x2d50>)
3400d002:	4293      	cmp	r3, r2
3400d004:	d124      	bne.n	3400d050 <HAL_RCCEx_PeriphCLKConfig+0x2c50>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d006:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d008:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d00c:	d004      	beq.n	3400d018 <HAL_RCCEx_PeriphCLKConfig+0x2c18>
3400d00e:	f240 7191 	movw	r1, #1937	@ 0x791
3400d012:	4846      	ldr	r0, [pc, #280]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d014:	f7f5 fa92 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d018:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d01a:	3b01      	subs	r3, #1
3400d01c:	2bff      	cmp	r3, #255	@ 0xff
3400d01e:	d904      	bls.n	3400d02a <HAL_RCCEx_PeriphCLKConfig+0x2c2a>
3400d020:	f240 7192 	movw	r1, #1938	@ 0x792
3400d024:	4841      	ldr	r0, [pc, #260]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d026:	f7f5 fa89 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d02a:	4a41      	ldr	r2, [pc, #260]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d02c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d02e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d032:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d034:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d038:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d03c:	3901      	subs	r1, #1
3400d03e:	4303      	orrs	r3, r0
3400d040:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d044:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d048:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d04c:	f7fe be3e 	b.w	3400bccc <HAL_RCCEx_PeriphCLKConfig+0x18cc>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
3400d050:	4a40      	ldr	r2, [pc, #256]	@ (3400d154 <HAL_RCCEx_PeriphCLKConfig+0x2d54>)
3400d052:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d054:	bf02      	ittt	eq
3400d056:	2240      	moveq	r2, #64	@ 0x40
3400d058:	4b35      	ldreq	r3, [pc, #212]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d05a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d05e:	f7fe be37 	b.w	3400bcd0 <HAL_RCCEx_PeriphCLKConfig+0x18d0>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3400d062:	4a3d      	ldr	r2, [pc, #244]	@ (3400d158 <HAL_RCCEx_PeriphCLKConfig+0x2d58>)
3400d064:	4293      	cmp	r3, r2
3400d066:	d124      	bne.n	3400d0b2 <HAL_RCCEx_PeriphCLKConfig+0x2cb2>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d068:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d06a:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d06e:	d004      	beq.n	3400d07a <HAL_RCCEx_PeriphCLKConfig+0x2c7a>
3400d070:	f240 71be 	movw	r1, #1982	@ 0x7be
3400d074:	482d      	ldr	r0, [pc, #180]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d076:	f7f5 fa61 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d07a:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d07c:	3b01      	subs	r3, #1
3400d07e:	2bff      	cmp	r3, #255	@ 0xff
3400d080:	d904      	bls.n	3400d08c <HAL_RCCEx_PeriphCLKConfig+0x2c8c>
3400d082:	f240 71bf 	movw	r1, #1983	@ 0x7bf
3400d086:	4829      	ldr	r0, [pc, #164]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d088:	f7f5 fa58 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d08c:	4a28      	ldr	r2, [pc, #160]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d08e:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d090:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d094:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d096:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d09a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d09e:	3901      	subs	r1, #1
3400d0a0:	4303      	orrs	r3, r0
3400d0a2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d0a6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d0aa:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d0ae:	f7fe be55 	b.w	3400bd5c <HAL_RCCEx_PeriphCLKConfig+0x195c>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3400d0b2:	4a2a      	ldr	r2, [pc, #168]	@ (3400d15c <HAL_RCCEx_PeriphCLKConfig+0x2d5c>)
3400d0b4:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d0b6:	bf02      	ittt	eq
3400d0b8:	2240      	moveq	r2, #64	@ 0x40
3400d0ba:	4b1d      	ldreq	r3, [pc, #116]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d0bc:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d0c0:	f7fe be4e 	b.w	3400bd60 <HAL_RCCEx_PeriphCLKConfig+0x1960>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3400d0c4:	4a26      	ldr	r2, [pc, #152]	@ (3400d160 <HAL_RCCEx_PeriphCLKConfig+0x2d60>)
3400d0c6:	4293      	cmp	r3, r2
3400d0c8:	d124      	bne.n	3400d114 <HAL_RCCEx_PeriphCLKConfig+0x2d14>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d0ca:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d0cc:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d0d0:	d004      	beq.n	3400d0dc <HAL_RCCEx_PeriphCLKConfig+0x2cdc>
3400d0d2:	f240 71eb 	movw	r1, #2027	@ 0x7eb
3400d0d6:	4815      	ldr	r0, [pc, #84]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d0d8:	f7f5 fa30 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d0dc:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d0de:	3b01      	subs	r3, #1
3400d0e0:	2bff      	cmp	r3, #255	@ 0xff
3400d0e2:	d904      	bls.n	3400d0ee <HAL_RCCEx_PeriphCLKConfig+0x2cee>
3400d0e4:	f240 71ec 	movw	r1, #2028	@ 0x7ec
3400d0e8:	4810      	ldr	r0, [pc, #64]	@ (3400d12c <HAL_RCCEx_PeriphCLKConfig+0x2d2c>)
3400d0ea:	f7f5 fa27 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d0ee:	4a10      	ldr	r2, [pc, #64]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d0f0:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d0f2:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d0f6:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d0f8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d0fc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d100:	3901      	subs	r1, #1
3400d102:	4303      	orrs	r3, r0
3400d104:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d108:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d10c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d110:	f7fe be6c 	b.w	3400bdec <HAL_RCCEx_PeriphCLKConfig+0x19ec>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
3400d114:	4a13      	ldr	r2, [pc, #76]	@ (3400d164 <HAL_RCCEx_PeriphCLKConfig+0x2d64>)
3400d116:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d118:	bf02      	ittt	eq
3400d11a:	2240      	moveq	r2, #64	@ 0x40
3400d11c:	4b04      	ldreq	r3, [pc, #16]	@ (3400d130 <HAL_RCCEx_PeriphCLKConfig+0x2d30>)
3400d11e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d122:	f7fe be65 	b.w	3400bdf0 <HAL_RCCEx_PeriphCLKConfig+0x19f0>
3400d126:	bf00      	nop
3400d128:	07031420 	.word	0x07031420
3400d12c:	3401c7d4 	.word	0x3401c7d4
3400d130:	56028000 	.word	0x56028000
3400d134:	07011420 	.word	0x07011420
3400d138:	07031820 	.word	0x07031820
3400d13c:	07011820 	.word	0x07011820
3400d140:	07030030 	.word	0x07030030
3400d144:	07010030 	.word	0x07010030
3400d148:	07030430 	.word	0x07030430
3400d14c:	07010430 	.word	0x07010430
3400d150:	07030830 	.word	0x07030830
3400d154:	07010830 	.word	0x07010830
3400d158:	07030c30 	.word	0x07030c30
3400d15c:	07010c30 	.word	0x07010c30
3400d160:	07031030 	.word	0x07031030
3400d164:	07011030 	.word	0x07011030
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3400d168:	4a8b      	ldr	r2, [pc, #556]	@ (3400d398 <HAL_RCCEx_PeriphCLKConfig+0x2f98>)
3400d16a:	4293      	cmp	r3, r2
3400d16c:	d124      	bne.n	3400d1b8 <HAL_RCCEx_PeriphCLKConfig+0x2db8>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d16e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d170:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d174:	d004      	beq.n	3400d180 <HAL_RCCEx_PeriphCLKConfig+0x2d80>
3400d176:	f640 0118 	movw	r1, #2072	@ 0x818
3400d17a:	4888      	ldr	r0, [pc, #544]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d17c:	f7f5 f9de 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d180:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d182:	3b01      	subs	r3, #1
3400d184:	2bff      	cmp	r3, #255	@ 0xff
3400d186:	d904      	bls.n	3400d192 <HAL_RCCEx_PeriphCLKConfig+0x2d92>
3400d188:	f640 0119 	movw	r1, #2073	@ 0x819
3400d18c:	4883      	ldr	r0, [pc, #524]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d18e:	f7f5 f9d5 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d192:	4a83      	ldr	r2, [pc, #524]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d194:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d196:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d19a:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d19c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d1a0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d1a4:	3901      	subs	r1, #1
3400d1a6:	4303      	orrs	r3, r0
3400d1a8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d1ac:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d1b0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d1b4:	f7fe be62 	b.w	3400be7c <HAL_RCCEx_PeriphCLKConfig+0x1a7c>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3400d1b8:	4a7a      	ldr	r2, [pc, #488]	@ (3400d3a4 <HAL_RCCEx_PeriphCLKConfig+0x2fa4>)
3400d1ba:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d1bc:	bf02      	ittt	eq
3400d1be:	2240      	moveq	r2, #64	@ 0x40
3400d1c0:	4b77      	ldreq	r3, [pc, #476]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d1c2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d1c6:	f7fe be5b 	b.w	3400be80 <HAL_RCCEx_PeriphCLKConfig+0x1a80>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3400d1ca:	4a77      	ldr	r2, [pc, #476]	@ (3400d3a8 <HAL_RCCEx_PeriphCLKConfig+0x2fa8>)
3400d1cc:	4293      	cmp	r3, r2
3400d1ce:	d124      	bne.n	3400d21a <HAL_RCCEx_PeriphCLKConfig+0x2e1a>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d1d0:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d1d2:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d1d6:	d004      	beq.n	3400d1e2 <HAL_RCCEx_PeriphCLKConfig+0x2de2>
3400d1d8:	f640 0145 	movw	r1, #2117	@ 0x845
3400d1dc:	486f      	ldr	r0, [pc, #444]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d1de:	f7f5 f9ad 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d1e2:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d1e4:	3b01      	subs	r3, #1
3400d1e6:	2bff      	cmp	r3, #255	@ 0xff
3400d1e8:	d904      	bls.n	3400d1f4 <HAL_RCCEx_PeriphCLKConfig+0x2df4>
3400d1ea:	f640 0146 	movw	r1, #2118	@ 0x846
3400d1ee:	486b      	ldr	r0, [pc, #428]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d1f0:	f7f5 f9a4 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d1f4:	4a6a      	ldr	r2, [pc, #424]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d1f6:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d1f8:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d1fc:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d1fe:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d202:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d206:	3901      	subs	r1, #1
3400d208:	4303      	orrs	r3, r0
3400d20a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d20e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d212:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d216:	f7fe be79 	b.w	3400bf0c <HAL_RCCEx_PeriphCLKConfig+0x1b0c>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3400d21a:	4a64      	ldr	r2, [pc, #400]	@ (3400d3ac <HAL_RCCEx_PeriphCLKConfig+0x2fac>)
3400d21c:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d21e:	bf02      	ittt	eq
3400d220:	2240      	moveq	r2, #64	@ 0x40
3400d222:	4b5f      	ldreq	r3, [pc, #380]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d224:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d228:	f7fe be72 	b.w	3400bf10 <HAL_RCCEx_PeriphCLKConfig+0x1b10>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3400d22c:	4a60      	ldr	r2, [pc, #384]	@ (3400d3b0 <HAL_RCCEx_PeriphCLKConfig+0x2fb0>)
3400d22e:	4293      	cmp	r3, r2
3400d230:	d124      	bne.n	3400d27c <HAL_RCCEx_PeriphCLKConfig+0x2e7c>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d232:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d234:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d238:	d004      	beq.n	3400d244 <HAL_RCCEx_PeriphCLKConfig+0x2e44>
3400d23a:	f640 0172 	movw	r1, #2162	@ 0x872
3400d23e:	4857      	ldr	r0, [pc, #348]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d240:	f7f5 f97c 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d244:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d246:	3b01      	subs	r3, #1
3400d248:	2bff      	cmp	r3, #255	@ 0xff
3400d24a:	d904      	bls.n	3400d256 <HAL_RCCEx_PeriphCLKConfig+0x2e56>
3400d24c:	f640 0173 	movw	r1, #2163	@ 0x873
3400d250:	4852      	ldr	r0, [pc, #328]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d252:	f7f5 f973 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d256:	4a52      	ldr	r2, [pc, #328]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d258:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d25a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d25e:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d260:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d264:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d268:	3901      	subs	r1, #1
3400d26a:	4303      	orrs	r3, r0
3400d26c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d270:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d274:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d278:	f7fe beac 	b.w	3400bfd4 <HAL_RCCEx_PeriphCLKConfig+0x1bd4>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3400d27c:	4a4d      	ldr	r2, [pc, #308]	@ (3400d3b4 <HAL_RCCEx_PeriphCLKConfig+0x2fb4>)
3400d27e:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d280:	bf02      	ittt	eq
3400d282:	2240      	moveq	r2, #64	@ 0x40
3400d284:	4b46      	ldreq	r3, [pc, #280]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d286:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d28a:	f7fe bea5 	b.w	3400bfd8 <HAL_RCCEx_PeriphCLKConfig+0x1bd8>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
3400d28e:	4a4a      	ldr	r2, [pc, #296]	@ (3400d3b8 <HAL_RCCEx_PeriphCLKConfig+0x2fb8>)
3400d290:	4293      	cmp	r3, r2
3400d292:	d124      	bne.n	3400d2de <HAL_RCCEx_PeriphCLKConfig+0x2ede>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d294:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d296:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d29a:	d004      	beq.n	3400d2a6 <HAL_RCCEx_PeriphCLKConfig+0x2ea6>
3400d29c:	f640 019f 	movw	r1, #2207	@ 0x89f
3400d2a0:	483e      	ldr	r0, [pc, #248]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d2a2:	f7f5 f94b 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d2a6:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d2a8:	3b01      	subs	r3, #1
3400d2aa:	2bff      	cmp	r3, #255	@ 0xff
3400d2ac:	d904      	bls.n	3400d2b8 <HAL_RCCEx_PeriphCLKConfig+0x2eb8>
3400d2ae:	f44f 610a 	mov.w	r1, #2208	@ 0x8a0
3400d2b2:	483a      	ldr	r0, [pc, #232]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d2b4:	f7f5 f942 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d2b8:	4a39      	ldr	r2, [pc, #228]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d2ba:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d2bc:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d2c0:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d2c2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d2c6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d2ca:	3901      	subs	r1, #1
3400d2cc:	4303      	orrs	r3, r0
3400d2ce:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d2d2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d2d6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d2da:	f7fe bec3 	b.w	3400c064 <HAL_RCCEx_PeriphCLKConfig+0x1c64>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
3400d2de:	4a37      	ldr	r2, [pc, #220]	@ (3400d3bc <HAL_RCCEx_PeriphCLKConfig+0x2fbc>)
3400d2e0:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d2e2:	bf02      	ittt	eq
3400d2e4:	2240      	moveq	r2, #64	@ 0x40
3400d2e6:	4b2e      	ldreq	r3, [pc, #184]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d2e8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d2ec:	f7fe bebc 	b.w	3400c068 <HAL_RCCEx_PeriphCLKConfig+0x1c68>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3400d2f0:	4a33      	ldr	r2, [pc, #204]	@ (3400d3c0 <HAL_RCCEx_PeriphCLKConfig+0x2fc0>)
3400d2f2:	4293      	cmp	r3, r2
3400d2f4:	d124      	bne.n	3400d340 <HAL_RCCEx_PeriphCLKConfig+0x2f40>
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
3400d2f6:	6f23      	ldr	r3, [r4, #112]	@ 0x70
3400d2f8:	f033 5340 	bics.w	r3, r3, #805306368	@ 0x30000000
3400d2fc:	d004      	beq.n	3400d308 <HAL_RCCEx_PeriphCLKConfig+0x2f08>
3400d2fe:	f640 01cc 	movw	r1, #2252	@ 0x8cc
3400d302:	4826      	ldr	r0, [pc, #152]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d304:	f7f5 f91a 	bl	3400253c <assert_failed>
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));
3400d308:	6f63      	ldr	r3, [r4, #116]	@ 0x74
3400d30a:	3b01      	subs	r3, #1
3400d30c:	2bff      	cmp	r3, #255	@ 0xff
3400d30e:	d904      	bls.n	3400d31a <HAL_RCCEx_PeriphCLKConfig+0x2f1a>
3400d310:	f640 01cd 	movw	r1, #2253	@ 0x8cd
3400d314:	4821      	ldr	r0, [pc, #132]	@ (3400d39c <HAL_RCCEx_PeriphCLKConfig+0x2f9c>)
3400d316:	f7f5 f911 	bl	3400253c <assert_failed>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400d31a:	4a21      	ldr	r2, [pc, #132]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d31c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3400d31e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400d322:	6f20      	ldr	r0, [r4, #112]	@ 0x70
3400d324:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400d328:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400d32c:	3901      	subs	r1, #1
3400d32e:	4303      	orrs	r3, r0
3400d330:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3400d334:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3400d338:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400d33c:	f7fe beda 	b.w	3400c0f4 <HAL_RCCEx_PeriphCLKConfig+0x1cf4>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3400d340:	4a20      	ldr	r2, [pc, #128]	@ (3400d3c4 <HAL_RCCEx_PeriphCLKConfig+0x2fc4>)
3400d342:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d344:	bf02      	ittt	eq
3400d346:	2240      	moveq	r2, #64	@ 0x40
3400d348:	4b15      	ldreq	r3, [pc, #84]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d34a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d34e:	f7fe bed3 	b.w	3400c0f8 <HAL_RCCEx_PeriphCLKConfig+0x1cf8>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400d352:	f7fc ff39 	bl	3400a1c8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d356:	f7fe bef5 	b.w	3400c144 <HAL_RCCEx_PeriphCLKConfig+0x1d44>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400d35a:	f7fc ff35 	bl	3400a1c8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d35e:	f7fe bf13 	b.w	3400c188 <HAL_RCCEx_PeriphCLKConfig+0x1d88>
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
3400d362:	4a19      	ldr	r2, [pc, #100]	@ (3400d3c8 <HAL_RCCEx_PeriphCLKConfig+0x2fc8>)
3400d364:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d366:	bf02      	ittt	eq
3400d368:	2240      	moveq	r2, #64	@ 0x40
3400d36a:	4b0d      	ldreq	r3, [pc, #52]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d36c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d370:	f7fe bf4a 	b.w	3400c208 <HAL_RCCEx_PeriphCLKConfig+0x1e08>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400d374:	f7fc ff28 	bl	3400a1c8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d378:	f7fe bf53 	b.w	3400c222 <HAL_RCCEx_PeriphCLKConfig+0x1e22>
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3400d37c:	4a13      	ldr	r2, [pc, #76]	@ (3400d3cc <HAL_RCCEx_PeriphCLKConfig+0x2fcc>)
3400d37e:	4293      	cmp	r3, r2
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3400d380:	bf02      	ittt	eq
3400d382:	2240      	moveq	r2, #64	@ 0x40
3400d384:	4b06      	ldreq	r3, [pc, #24]	@ (3400d3a0 <HAL_RCCEx_PeriphCLKConfig+0x2fa0>)
3400d386:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3400d38a:	f7fe bfa5 	b.w	3400c2d8 <HAL_RCCEx_PeriphCLKConfig+0x1ed8>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400d38e:	f7fc ff1b 	bl	3400a1c8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3400d392:	f7fe bfae 	b.w	3400c2f2 <HAL_RCCEx_PeriphCLKConfig+0x1ef2>
3400d396:	bf00      	nop
3400d398:	07031430 	.word	0x07031430
3400d39c:	3401c7d4 	.word	0x3401c7d4
3400d3a0:	56028000 	.word	0x56028000
3400d3a4:	07011430 	.word	0x07011430
3400d3a8:	07031830 	.word	0x07031830
3400d3ac:	07011830 	.word	0x07011830
3400d3b0:	07031c30 	.word	0x07031c30
3400d3b4:	07011c30 	.word	0x07011c30
3400d3b8:	07030034 	.word	0x07030034
3400d3bc:	07010034 	.word	0x07010034
3400d3c0:	07030434 	.word	0x07030434
3400d3c4:	07010434 	.word	0x07010434
3400d3c8:	03010c14 	.word	0x03010c14
3400d3cc:	03011414 	.word	0x03011414

3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>:
{
3400d3d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400d3d2:	4c1e      	ldr	r4, [pc, #120]	@ (3400d44c <HAL_RCCEx_GetPLL1CLKFreq+0x7c>)
3400d3d4:	6863      	ldr	r3, [r4, #4]
3400d3d6:	05d9      	lsls	r1, r3, #23
3400d3d8:	d506      	bpl.n	3400d3e8 <HAL_RCCEx_GetPLL1CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3400d3da:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400d3de:	005a      	lsls	r2, r3, #1
3400d3e0:	d40f      	bmi.n	3400d402 <HAL_RCCEx_GetPLL1CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d3e2:	2000      	movs	r0, #0
}
3400d3e4:	b003      	add	sp, #12
3400d3e6:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400d3e8:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3400d3ec:	011b      	lsls	r3, r3, #4
3400d3ee:	d5f8      	bpl.n	3400d3e2 <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400d3f0:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400d3f4:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d3f8:	b003      	add	sp, #12
3400d3fa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400d3fe:	f7fc bf9d 	b.w	3400a33c <RCCEx_GetPLLSourceFreq>
3400d402:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3400d406:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d40a:	f7fc ff97 	bl	3400a33c <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d40e:	2800      	cmp	r0, #0
3400d410:	d0e7      	beq.n	3400d3e2 <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3400d412:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
        if (divm != 0U)
3400d416:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d41a:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d41e:	d0e0      	beq.n	3400d3e2 <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3400d420:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3400d424:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400d428:	f8d4 5088 	ldr.w	r5, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400d42c:	f8d4 4088 	ldr.w	r4, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400d430:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400d434:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
3400d438:	9401      	str	r4, [sp, #4]
3400d43a:	9500      	str	r5, [sp, #0]
3400d43c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d440:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d444:	f7fc ffb0 	bl	3400a3a8 <RCCEx_CalcPLLFreq>
3400d448:	e7cc      	b.n	3400d3e4 <HAL_RCCEx_GetPLL1CLKFreq+0x14>
3400d44a:	bf00      	nop
3400d44c:	56028000 	.word	0x56028000

3400d450 <HAL_RCCEx_GetPLL2CLKFreq>:
{
3400d450:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400d452:	4c1e      	ldr	r4, [pc, #120]	@ (3400d4cc <HAL_RCCEx_GetPLL2CLKFreq+0x7c>)
3400d454:	6863      	ldr	r3, [r4, #4]
3400d456:	0599      	lsls	r1, r3, #22
3400d458:	d506      	bpl.n	3400d468 <HAL_RCCEx_GetPLL2CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3400d45a:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3400d45e:	005a      	lsls	r2, r3, #1
3400d460:	d40f      	bmi.n	3400d482 <HAL_RCCEx_GetPLL2CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d462:	2000      	movs	r0, #0
}
3400d464:	b003      	add	sp, #12
3400d466:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400d468:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3400d46c:	011b      	lsls	r3, r3, #4
3400d46e:	d5f8      	bpl.n	3400d462 <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400d470:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400d474:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d478:	b003      	add	sp, #12
3400d47a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400d47e:	f7fc bf5d 	b.w	3400a33c <RCCEx_GetPLLSourceFreq>
3400d482:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3400d486:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d48a:	f7fc ff57 	bl	3400a33c <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d48e:	2800      	cmp	r0, #0
3400d490:	d0e7      	beq.n	3400d462 <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3400d492:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
        if (divm != 0U)
3400d496:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d49a:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d49e:	d0e0      	beq.n	3400d462 <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3400d4a0:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3400d4a4:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400d4a8:	f8d4 5098 	ldr.w	r5, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400d4ac:	f8d4 4098 	ldr.w	r4, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400d4b0:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400d4b4:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3400d4b8:	9401      	str	r4, [sp, #4]
3400d4ba:	9500      	str	r5, [sp, #0]
3400d4bc:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d4c0:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d4c4:	f7fc ff70 	bl	3400a3a8 <RCCEx_CalcPLLFreq>
3400d4c8:	e7cc      	b.n	3400d464 <HAL_RCCEx_GetPLL2CLKFreq+0x14>
3400d4ca:	bf00      	nop
3400d4cc:	56028000 	.word	0x56028000

3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>:
{
3400d4d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400d4d2:	4c1e      	ldr	r4, [pc, #120]	@ (3400d54c <HAL_RCCEx_GetPLL3CLKFreq+0x7c>)
3400d4d4:	6863      	ldr	r3, [r4, #4]
3400d4d6:	0559      	lsls	r1, r3, #21
3400d4d8:	d506      	bpl.n	3400d4e8 <HAL_RCCEx_GetPLL3CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3400d4da:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3400d4de:	005a      	lsls	r2, r3, #1
3400d4e0:	d40f      	bmi.n	3400d502 <HAL_RCCEx_GetPLL3CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d4e2:	2000      	movs	r0, #0
}
3400d4e4:	b003      	add	sp, #12
3400d4e6:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400d4e8:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3400d4ec:	011b      	lsls	r3, r3, #4
3400d4ee:	d5f8      	bpl.n	3400d4e2 <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400d4f0:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400d4f4:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d4f8:	b003      	add	sp, #12
3400d4fa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400d4fe:	f7fc bf1d 	b.w	3400a33c <RCCEx_GetPLLSourceFreq>
3400d502:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3400d506:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d50a:	f7fc ff17 	bl	3400a33c <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d50e:	2800      	cmp	r0, #0
3400d510:	d0e7      	beq.n	3400d4e2 <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3400d512:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
        if (divm != 0U)
3400d516:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d51a:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d51e:	d0e0      	beq.n	3400d4e2 <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3400d520:	f8d4 20a0 	ldr.w	r2, [r4, #160]	@ 0xa0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3400d524:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400d528:	f8d4 50a8 	ldr.w	r5, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400d52c:	f8d4 40a8 	ldr.w	r4, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400d530:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400d534:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
3400d538:	9401      	str	r4, [sp, #4]
3400d53a:	9500      	str	r5, [sp, #0]
3400d53c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d540:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d544:	f7fc ff30 	bl	3400a3a8 <RCCEx_CalcPLLFreq>
3400d548:	e7cc      	b.n	3400d4e4 <HAL_RCCEx_GetPLL3CLKFreq+0x14>
3400d54a:	bf00      	nop
3400d54c:	56028000 	.word	0x56028000

3400d550 <HAL_RCCEx_GetPLL4CLKFreq>:
{
3400d550:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400d552:	4c1e      	ldr	r4, [pc, #120]	@ (3400d5cc <HAL_RCCEx_GetPLL4CLKFreq+0x7c>)
3400d554:	6863      	ldr	r3, [r4, #4]
3400d556:	0519      	lsls	r1, r3, #20
3400d558:	d506      	bpl.n	3400d568 <HAL_RCCEx_GetPLL4CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3400d55a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3400d55e:	005a      	lsls	r2, r3, #1
3400d560:	d40f      	bmi.n	3400d582 <HAL_RCCEx_GetPLL4CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3400d562:	2000      	movs	r0, #0
}
3400d564:	b003      	add	sp, #12
3400d566:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400d568:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3400d56c:	011b      	lsls	r3, r3, #4
3400d56e:	d5f8      	bpl.n	3400d562 <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3400d570:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400d574:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3400d578:	b003      	add	sp, #12
3400d57a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400d57e:	f7fc bedd 	b.w	3400a33c <RCCEx_GetPLLSourceFreq>
3400d582:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3400d586:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3400d58a:	f7fc fed7 	bl	3400a33c <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3400d58e:	2800      	cmp	r0, #0
3400d590:	d0e7      	beq.n	3400d562 <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3400d592:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
        if (divm != 0U)
3400d596:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3400d59a:	f3c3 5105 	ubfx	r1, r3, #20, #6
3400d59e:	d0e0      	beq.n	3400d562 <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3400d5a0:	f8d4 20b0 	ldr.w	r2, [r4, #176]	@ 0xb0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3400d5a4:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400d5a8:	f8d4 50b8 	ldr.w	r5, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400d5ac:	f8d4 40b8 	ldr.w	r4, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3400d5b0:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3400d5b4:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
3400d5b8:	9401      	str	r4, [sp, #4]
3400d5ba:	9500      	str	r5, [sp, #0]
3400d5bc:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400d5c0:	f3c2 220b 	ubfx	r2, r2, #8, #12
3400d5c4:	f7fc fef0 	bl	3400a3a8 <RCCEx_CalcPLLFreq>
3400d5c8:	e7cc      	b.n	3400d564 <HAL_RCCEx_GetPLL4CLKFreq+0x14>
3400d5ca:	bf00      	nop
3400d5cc:	56028000 	.word	0x56028000

3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>:
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3400d5d0:	4b3e      	ldr	r3, [pc, #248]	@ (3400d6cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
  * @param  CLKPxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
3400d5d2:	b510      	push	{r4, lr}
3400d5d4:	f8d3 2248 	ldr.w	r2, [r3, #584]	@ 0x248
3400d5d8:	0652      	lsls	r2, r2, #25
3400d5da:	d56b      	bpl.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3400d5dc:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400d5e0:	f002 0207 	and.w	r2, r2, #7
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
3400d5e4:	3a01      	subs	r2, #1
3400d5e6:	2a06      	cmp	r2, #6
3400d5e8:	d805      	bhi.n	3400d5f6 <RCCEx_GetCLKPCLKFreq.constprop.0+0x26>
3400d5ea:	e8df f002 	tbb	[pc, r2]
3400d5ee:	150f      	.short	0x150f
3400d5f0:	3e321b48 	.word	0x3e321b48
3400d5f4:	54          	.byte	0x54
3400d5f5:	00          	.byte	0x00
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
3400d5f6:	f7fc fe07 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400d5fa:	2800      	cmp	r0, #0
3400d5fc:	d05a      	beq.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400d5fe:	4b33      	ldr	r3, [pc, #204]	@ (3400d6cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400d600:	4833      	ldr	r0, [pc, #204]	@ (3400d6d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0x100>)
3400d602:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400d604:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400d608:	40d8      	lsrs	r0, r3
3400d60a:	e054      	b.n	3400d6b6 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
3400d60c:	f7fc fe04 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400d610:	2800      	cmp	r0, #0
3400d612:	d04f      	beq.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = MSI_VALUE;
3400d614:	482f      	ldr	r0, [pc, #188]	@ (3400d6d4 <RCCEx_GetCLKPCLKFreq.constprop.0+0x104>)
3400d616:	e04e      	b.n	3400d6b6 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
3400d618:	f7fc fdee 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400d61c:	2800      	cmp	r0, #0
3400d61e:	d049      	beq.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = HSE_VALUE;
3400d620:	482d      	ldr	r0, [pc, #180]	@ (3400d6d8 <RCCEx_GetCLKPCLKFreq.constprop.0+0x108>)
        /* Unexpected case */
        break;
    }
  }

  return clkp_frequency;
3400d622:	e048      	b.n	3400d6b6 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400d624:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d628:	06d4      	lsls	r4, r2, #27
3400d62a:	d543      	bpl.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400d62c:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400d630:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400d634:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d638:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400d63a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
          switch (LL_RCC_IC20_GetSource())
3400d63e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d642:	d03c      	beq.n	3400d6be <RCCEx_GetCLKPCLKFreq.constprop.0+0xee>
3400d644:	d833      	bhi.n	3400d6ae <RCCEx_GetCLKPCLKFreq.constprop.0+0xde>
3400d646:	bbbb      	cbnz	r3, 3400d6b8 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe8>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d648:	f7ff fec2 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
              clkp_frequency = clkp_frequency / ic_divider;
3400d64c:	fbb0 f0f4 	udiv	r0, r0, r4
              break;
3400d650:	e031      	b.n	3400d6b6 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400d652:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d656:	0590      	lsls	r0, r2, #22
3400d658:	d52c      	bpl.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400d65a:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400d65e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400d662:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d666:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400d668:	e7e7      	b.n	3400d63a <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
        if (LL_RCC_IC15_IsEnabled() != 0U)
3400d66a:	f7fc fe4d 	bl	3400a308 <LL_RCC_IC15_IsEnabled>
3400d66e:	b308      	cbz	r0, 3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
          ic_divider = LL_RCC_IC15_GetDivider();
3400d670:	f7fc fe52 	bl	3400a318 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400d674:	4b15      	ldr	r3, [pc, #84]	@ (3400d6cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
3400d676:	4604      	mov	r4, r0
3400d678:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d67c:	e7dd      	b.n	3400d63a <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400d67e:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d682:	0351      	lsls	r1, r2, #13
3400d684:	d516      	bpl.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400d686:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400d68a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400d68e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d692:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400d694:	e7d1      	b.n	3400d63a <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400d696:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400d69a:	0312      	lsls	r2, r2, #12
3400d69c:	d50a      	bpl.n	3400d6b4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400d69e:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400d6a2:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400d6a6:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d6aa:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400d6ac:	e7c5      	b.n	3400d63a <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
          switch (LL_RCC_IC20_GetSource())
3400d6ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d6b2:	d007      	beq.n	3400d6c4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xf4>
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d6b4:	2000      	movs	r0, #0
}
3400d6b6:	bd10      	pop	{r4, pc}
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d6b8:	f7ff feca 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400d6bc:	e7c6      	b.n	3400d64c <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d6be:	f7ff ff07 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400d6c2:	e7c3      	b.n	3400d64c <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d6c4:	f7ff ff44 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400d6c8:	e7c0      	b.n	3400d64c <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
3400d6ca:	bf00      	nop
3400d6cc:	56028000 	.word	0x56028000
3400d6d0:	03d09000 	.word	0x03d09000
3400d6d4:	003d0900 	.word	0x003d0900
3400d6d8:	02dc6c00 	.word	0x02dc6c00

3400d6dc <RCCEx_GetSPDIFRXCLKFreq.constprop.0>:
  * @param  SPDIFRXxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
3400d6dc:	b538      	push	{r3, r4, r5, lr}
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3400d6de:	4d2b      	ldr	r5, [pc, #172]	@ (3400d78c <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb0>)
3400d6e0:	f8d5 3164 	ldr.w	r3, [r5, #356]	@ 0x164
3400d6e4:	f003 0307 	and.w	r3, r3, #7
{
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400d6e8:	2b06      	cmp	r3, #6
3400d6ea:	d835      	bhi.n	3400d758 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
3400d6ec:	e8df f003 	tbb	[pc, r3]
3400d6f0:	28110d04 	.word	0x28110d04
3400d6f4:	3c45      	.short	0x3c45
3400d6f6:	4b          	.byte	0x4b
3400d6f7:	00          	.byte	0x00
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400d6f8:	f7fc fd0c 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400d6fc:	f7fc fe16 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400d700:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400d702:	f003 0307 	and.w	r3, r3, #7
      break;

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400d706:	40d8      	lsrs	r0, r3
3400d708:	e027      	b.n	3400d75a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      /* Unexpected case */
      break;
  }

  return spdifrx_frequency;
}
3400d70a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d70e:	f7ff bf5f 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400d712:	f7fc fdb1 	bl	3400a278 <LL_RCC_IC7_IsEnabled>
3400d716:	b1f8      	cbz	r0, 3400d758 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC7_GetDivider();
3400d718:	f7fc fdb6 	bl	3400a288 <LL_RCC_IC7_GetDivider>
3400d71c:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400d71e:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400d722:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400d726:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d72a:	d017      	beq.n	3400d75c <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x80>
3400d72c:	d811      	bhi.n	3400d752 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x76>
3400d72e:	b913      	cbnz	r3, 3400d736 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5a>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d730:	f7ff fe4e 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
3400d734:	e001      	b.n	3400d73a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d736:	f7ff fe8b 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400d73a:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400d73e:	e00c      	b.n	3400d75a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400d740:	f7fc fdac 	bl	3400a29c <LL_RCC_IC8_IsEnabled>
3400d744:	b140      	cbz	r0, 3400d758 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC8_GetDivider();
3400d746:	f7fc fdb1 	bl	3400a2ac <LL_RCC_IC8_GetDivider>
3400d74a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400d74e:	4604      	mov	r4, r0
3400d750:	e7e7      	b.n	3400d722 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x46>
        switch (LL_RCC_IC8_GetSource())
3400d752:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d756:	d004      	beq.n	3400d762 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x86>
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d758:	2000      	movs	r0, #0
}
3400d75a:	bd38      	pop	{r3, r4, r5, pc}
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d75c:	f7ff feb8 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400d760:	e7eb      	b.n	3400d73a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d762:	f7ff fef5 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400d766:	e7e8      	b.n	3400d73a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
      if (LL_RCC_HSI_IsReady() != 0U)
3400d768:	f7fc fd4e 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400d76c:	2800      	cmp	r0, #0
3400d76e:	d0f3      	beq.n	3400d758 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400d770:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400d772:	4807      	ldr	r0, [pc, #28]	@ (3400d790 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb4>)
3400d774:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400d778:	e7c5      	b.n	3400d706 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x2a>
      if (LL_RCC_MSI_IsReady() != 0U)
3400d77a:	f7fc fd4d 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400d77e:	2800      	cmp	r0, #0
3400d780:	d0ea      	beq.n	3400d758 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        spdifrx_frequency = MSI_VALUE;
3400d782:	4804      	ldr	r0, [pc, #16]	@ (3400d794 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb8>)
3400d784:	e7e9      	b.n	3400d75a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400d786:	4804      	ldr	r0, [pc, #16]	@ (3400d798 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xbc>)
  return spdifrx_frequency;
3400d788:	e7e7      	b.n	3400d75a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
3400d78a:	bf00      	nop
3400d78c:	56028000 	.word	0x56028000
3400d790:	03d09000 	.word	0x03d09000
3400d794:	003d0900 	.word	0x003d0900
3400d798:	00bb8000 	.word	0x00bb8000

3400d79c <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3400d79c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400d79e:	f7fc fd5d 	bl	3400a25c <LL_RCC_GetClockSource>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d7a2:	4b36      	ldr	r3, [pc, #216]	@ (3400d87c <RCCEx_GetXSPICLKFreq+0xe0>)
3400d7a4:	4298      	cmp	r0, r3
3400d7a6:	d028      	beq.n	3400d7fa <RCCEx_GetXSPICLKFreq+0x5e>
3400d7a8:	d81b      	bhi.n	3400d7e2 <RCCEx_GetXSPICLKFreq+0x46>
3400d7aa:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d7ae:	4298      	cmp	r0, r3
3400d7b0:	d013      	beq.n	3400d7da <RCCEx_GetXSPICLKFreq+0x3e>
3400d7b2:	d80b      	bhi.n	3400d7cc <RCCEx_GetXSPICLKFreq+0x30>
3400d7b4:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400d7b8:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d7bc:	429a      	cmp	r2, r3
3400d7be:	d04a      	beq.n	3400d856 <RCCEx_GetXSPICLKFreq+0xba>
3400d7c0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400d7c4:	4298      	cmp	r0, r3
3400d7c6:	d046      	beq.n	3400d856 <RCCEx_GetXSPICLKFreq+0xba>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d7c8:	2000      	movs	r0, #0
      /* Nothing to do */
      break;
  }

  return xspi_frequency;
}
3400d7ca:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d7cc:	4b2c      	ldr	r3, [pc, #176]	@ (3400d880 <RCCEx_GetXSPICLKFreq+0xe4>)
3400d7ce:	4298      	cmp	r0, r3
3400d7d0:	d003      	beq.n	3400d7da <RCCEx_GetXSPICLKFreq+0x3e>
3400d7d2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d7d6:	4298      	cmp	r0, r3
3400d7d8:	d1f6      	bne.n	3400d7c8 <RCCEx_GetXSPICLKFreq+0x2c>
}
3400d7da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d7de:	f7ff bef7 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d7e2:	4b28      	ldr	r3, [pc, #160]	@ (3400d884 <RCCEx_GetXSPICLKFreq+0xe8>)
3400d7e4:	4298      	cmp	r0, r3
3400d7e6:	d028      	beq.n	3400d83a <RCCEx_GetXSPICLKFreq+0x9e>
3400d7e8:	d820      	bhi.n	3400d82c <RCCEx_GetXSPICLKFreq+0x90>
3400d7ea:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400d7ee:	4298      	cmp	r0, r3
3400d7f0:	d003      	beq.n	3400d7fa <RCCEx_GetXSPICLKFreq+0x5e>
3400d7f2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d7f6:	4298      	cmp	r0, r3
3400d7f8:	d1e6      	bne.n	3400d7c8 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400d7fa:	4b23      	ldr	r3, [pc, #140]	@ (3400d888 <RCCEx_GetXSPICLKFreq+0xec>)
3400d7fc:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400d800:	f010 0004 	ands.w	r0, r0, #4
3400d804:	d0e1      	beq.n	3400d7ca <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400d806:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400d80a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400d80e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d812:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400d814:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC4_GetSource())
3400d818:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d81c:	d02a      	beq.n	3400d874 <RCCEx_GetXSPICLKFreq+0xd8>
3400d81e:	d820      	bhi.n	3400d862 <RCCEx_GetXSPICLKFreq+0xc6>
3400d820:	bb2b      	cbnz	r3, 3400d86e <RCCEx_GetXSPICLKFreq+0xd2>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d822:	f7ff fdd5 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            xspi_frequency = xspi_frequency / ic_divider;
3400d826:	fbb0 f0f4 	udiv	r0, r0, r4
  return xspi_frequency;
3400d82a:	e7ce      	b.n	3400d7ca <RCCEx_GetXSPICLKFreq+0x2e>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400d82c:	4b17      	ldr	r3, [pc, #92]	@ (3400d88c <RCCEx_GetXSPICLKFreq+0xf0>)
3400d82e:	4298      	cmp	r0, r3
3400d830:	d003      	beq.n	3400d83a <RCCEx_GetXSPICLKFreq+0x9e>
3400d832:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d836:	4298      	cmp	r0, r3
3400d838:	d1c6      	bne.n	3400d7c8 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400d83a:	4b13      	ldr	r3, [pc, #76]	@ (3400d888 <RCCEx_GetXSPICLKFreq+0xec>)
3400d83c:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400d840:	f010 0008 	ands.w	r0, r0, #8
3400d844:	d0c1      	beq.n	3400d7ca <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400d846:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400d84a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400d84e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400d852:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400d854:	e7de      	b.n	3400d814 <RCCEx_GetXSPICLKFreq+0x78>
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400d856:	f7fc fc5d 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
}
3400d85a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400d85e:	f7fc bd65 	b.w	3400a32c <RCCEx_GetHCLKFreq>
        switch (LL_RCC_IC4_GetSource())
3400d862:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d866:	d1af      	bne.n	3400d7c8 <RCCEx_GetXSPICLKFreq+0x2c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d868:	f7ff fe72 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400d86c:	e7db      	b.n	3400d826 <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d86e:	f7ff fdef 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400d872:	e7d8      	b.n	3400d826 <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d874:	f7ff fe2c 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400d878:	e7d5      	b.n	3400d826 <RCCEx_GetXSPICLKFreq+0x8a>
3400d87a:	bf00      	nop
3400d87c:	03020014 	.word	0x03020014
3400d880:	03010414 	.word	0x03010414
3400d884:	03030014 	.word	0x03030014
3400d888:	56028000 	.word	0x56028000
3400d88c:	03030414 	.word	0x03030414

3400d890 <RCCEx_GetOTGPHYCLKFreq>:
{
3400d890:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400d892:	f7fc fce3 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400d896:	4b2b      	ldr	r3, [pc, #172]	@ (3400d944 <RCCEx_GetOTGPHYCLKFreq+0xb4>)
3400d898:	4298      	cmp	r0, r3
3400d89a:	d021      	beq.n	3400d8e0 <RCCEx_GetOTGPHYCLKFreq+0x50>
3400d89c:	d815      	bhi.n	3400d8ca <RCCEx_GetOTGPHYCLKFreq+0x3a>
3400d89e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d8a2:	4298      	cmp	r0, r3
3400d8a4:	d00d      	beq.n	3400d8c2 <RCCEx_GetOTGPHYCLKFreq+0x32>
3400d8a6:	d809      	bhi.n	3400d8bc <RCCEx_GetOTGPHYCLKFreq+0x2c>
3400d8a8:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d8ac:	4298      	cmp	r0, r3
3400d8ae:	d02d      	beq.n	3400d90c <RCCEx_GetOTGPHYCLKFreq+0x7c>
3400d8b0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400d8b4:	4298      	cmp	r0, r3
3400d8b6:	d029      	beq.n	3400d90c <RCCEx_GetOTGPHYCLKFreq+0x7c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d8b8:	2000      	movs	r0, #0
}
3400d8ba:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400d8bc:	4b22      	ldr	r3, [pc, #136]	@ (3400d948 <RCCEx_GetOTGPHYCLKFreq+0xb8>)
3400d8be:	4298      	cmp	r0, r3
3400d8c0:	d1fa      	bne.n	3400d8b8 <RCCEx_GetOTGPHYCLKFreq+0x28>
}
3400d8c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400d8c6:	f7ff be83 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400d8ca:	4b20      	ldr	r3, [pc, #128]	@ (3400d94c <RCCEx_GetOTGPHYCLKFreq+0xbc>)
3400d8cc:	4298      	cmp	r0, r3
3400d8ce:	d023      	beq.n	3400d918 <RCCEx_GetOTGPHYCLKFreq+0x88>
3400d8d0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400d8d4:	4298      	cmp	r0, r3
3400d8d6:	d01f      	beq.n	3400d918 <RCCEx_GetOTGPHYCLKFreq+0x88>
3400d8d8:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400d8dc:	4298      	cmp	r0, r3
3400d8de:	d1eb      	bne.n	3400d8b8 <RCCEx_GetOTGPHYCLKFreq+0x28>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400d8e0:	f7fc fd12 	bl	3400a308 <LL_RCC_IC15_IsEnabled>
3400d8e4:	2800      	cmp	r0, #0
3400d8e6:	d0e7      	beq.n	3400d8b8 <RCCEx_GetOTGPHYCLKFreq+0x28>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
3400d8e8:	f7fc fd16 	bl	3400a318 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400d8ec:	4b18      	ldr	r3, [pc, #96]	@ (3400d950 <RCCEx_GetOTGPHYCLKFreq+0xc0>)
3400d8ee:	4604      	mov	r4, r0
3400d8f0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400d8f4:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400d8f8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400d8fc:	d01f      	beq.n	3400d93e <RCCEx_GetOTGPHYCLKFreq+0xae>
3400d8fe:	d815      	bhi.n	3400d92c <RCCEx_GetOTGPHYCLKFreq+0x9c>
3400d900:	b9d3      	cbnz	r3, 3400d938 <RCCEx_GetOTGPHYCLKFreq+0xa8>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400d902:	f7ff fd65 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            usb_frequency = usb_frequency / ic_divider;
3400d906:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400d90a:	e7d6      	b.n	3400d8ba <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400d90c:	f7fc fc74 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400d910:	2800      	cmp	r0, #0
3400d912:	d0d1      	beq.n	3400d8b8 <RCCEx_GetOTGPHYCLKFreq+0x28>
        usb_frequency = HSE_VALUE / 2U;
3400d914:	480f      	ldr	r0, [pc, #60]	@ (3400d954 <RCCEx_GetOTGPHYCLKFreq+0xc4>)
3400d916:	e7d0      	b.n	3400d8ba <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400d918:	f7fc fc6e 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400d91c:	2800      	cmp	r0, #0
3400d91e:	d0cb      	beq.n	3400d8b8 <RCCEx_GetOTGPHYCLKFreq+0x28>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400d920:	f7fc fc62 	bl	3400a1e8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3400d924:	2800      	cmp	r0, #0
3400d926:	d1f5      	bne.n	3400d914 <RCCEx_GetOTGPHYCLKFreq+0x84>
          usb_frequency = HSE_VALUE;
3400d928:	480b      	ldr	r0, [pc, #44]	@ (3400d958 <RCCEx_GetOTGPHYCLKFreq+0xc8>)
  return usb_frequency;
3400d92a:	e7c6      	b.n	3400d8ba <RCCEx_GetOTGPHYCLKFreq+0x2a>
        switch (LL_RCC_IC15_GetSource())
3400d92c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400d930:	d1c2      	bne.n	3400d8b8 <RCCEx_GetOTGPHYCLKFreq+0x28>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400d932:	f7ff fe0d 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400d936:	e7e6      	b.n	3400d906 <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400d938:	f7ff fd8a 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400d93c:	e7e3      	b.n	3400d906 <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400d93e:	f7ff fdc7 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400d942:	e7e0      	b.n	3400d906 <RCCEx_GetOTGPHYCLKFreq+0x76>
3400d944:	03020c14 	.word	0x03020c14
3400d948:	03011414 	.word	0x03011414
3400d94c:	03030c14 	.word	0x03030c14
3400d950:	56028000 	.word	0x56028000
3400d954:	016e3600 	.word	0x016e3600
3400d958:	02dc6c00 	.word	0x02dc6c00

3400d95c <RCCEx_GetOTGPHYCKREFCLKFreq>:
{
3400d95c:	b508      	push	{r3, lr}
  return LL_RCC_GetClockSource(Periph);
3400d95e:	f7fc fc7d 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400d962:	4b11      	ldr	r3, [pc, #68]	@ (3400d9a8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x4c>)
3400d964:	4298      	cmp	r0, r3
3400d966:	d01c      	beq.n	3400d9a2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x46>
3400d968:	d805      	bhi.n	3400d976 <RCCEx_GetOTGPHYCKREFCLKFreq+0x1a>
3400d96a:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400d96e:	4298      	cmp	r0, r3
3400d970:	d012      	beq.n	3400d998 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d972:	2000      	movs	r0, #0
}
3400d974:	bd08      	pop	{r3, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400d976:	4b0d      	ldr	r3, [pc, #52]	@ (3400d9ac <RCCEx_GetOTGPHYCKREFCLKFreq+0x50>)
3400d978:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3400d97c:	4298      	cmp	r0, r3
3400d97e:	d1f8      	bne.n	3400d972 <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
      if (LL_RCC_HSE_IsReady() != 0U)
3400d980:	f7fc fc3a 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400d984:	2800      	cmp	r0, #0
3400d986:	d0f4      	beq.n	3400d972 <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400d988:	f7fc fc2e 	bl	3400a1e8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
          usb_frequency = HSE_VALUE;
3400d98c:	4b08      	ldr	r3, [pc, #32]	@ (3400d9b0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>)
3400d98e:	2800      	cmp	r0, #0
3400d990:	4808      	ldr	r0, [pc, #32]	@ (3400d9b4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x58>)
3400d992:	bf08      	it	eq
3400d994:	4618      	moveq	r0, r3
3400d996:	e7ed      	b.n	3400d974 <RCCEx_GetOTGPHYCKREFCLKFreq+0x18>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400d998:	4807      	ldr	r0, [pc, #28]	@ (3400d9b8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5c>)
}
3400d99a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400d99e:	f7ff bf77 	b.w	3400d890 <RCCEx_GetOTGPHYCLKFreq>
3400d9a2:	4806      	ldr	r0, [pc, #24]	@ (3400d9bc <RCCEx_GetOTGPHYCKREFCLKFreq+0x60>)
3400d9a4:	e7f9      	b.n	3400d99a <RCCEx_GetOTGPHYCKREFCLKFreq+0x3e>
3400d9a6:	bf00      	nop
3400d9a8:	01001814 	.word	0x01001814
3400d9ac:	01011014 	.word	0x01011014
3400d9b0:	02dc6c00 	.word	0x02dc6c00
3400d9b4:	016e3600 	.word	0x016e3600
3400d9b8:	03000c14 	.word	0x03000c14
3400d9bc:	03001414 	.word	0x03001414

3400d9c0 <RCCEx_GetUSARTCLKFreq>:
{
3400d9c0:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400d9c2:	f7fc fc4b 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d9c6:	4b6f      	ldr	r3, [pc, #444]	@ (3400db84 <RCCEx_GetUSARTCLKFreq+0x1c4>)
3400d9c8:	4298      	cmp	r0, r3
3400d9ca:	d039      	beq.n	3400da40 <RCCEx_GetUSARTCLKFreq+0x80>
3400d9cc:	d852      	bhi.n	3400da74 <RCCEx_GetUSARTCLKFreq+0xb4>
3400d9ce:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400d9d2:	4298      	cmp	r0, r3
3400d9d4:	f000 80b5 	beq.w	3400db42 <RCCEx_GetUSARTCLKFreq+0x182>
3400d9d8:	d813      	bhi.n	3400da02 <RCCEx_GetUSARTCLKFreq+0x42>
3400d9da:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400d9de:	4298      	cmp	r0, r3
3400d9e0:	f000 80af 	beq.w	3400db42 <RCCEx_GetUSARTCLKFreq+0x182>
3400d9e4:	d80b      	bhi.n	3400d9fe <RCCEx_GetUSARTCLKFreq+0x3e>
3400d9e6:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400d9ea:	4298      	cmp	r0, r3
3400d9ec:	f000 80a9 	beq.w	3400db42 <RCCEx_GetUSARTCLKFreq+0x182>
3400d9f0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400d9f4:	4298      	cmp	r0, r3
3400d9f6:	f000 80ae 	beq.w	3400db56 <RCCEx_GetUSARTCLKFreq+0x196>
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400d9fa:	2000      	movs	r0, #0
}
3400d9fc:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400d9fe:	4b62      	ldr	r3, [pc, #392]	@ (3400db88 <RCCEx_GetUSARTCLKFreq+0x1c8>)
3400da00:	e7f8      	b.n	3400d9f4 <RCCEx_GetUSARTCLKFreq+0x34>
3400da02:	4b62      	ldr	r3, [pc, #392]	@ (3400db8c <RCCEx_GetUSARTCLKFreq+0x1cc>)
3400da04:	4298      	cmp	r0, r3
3400da06:	d00c      	beq.n	3400da22 <RCCEx_GetUSARTCLKFreq+0x62>
3400da08:	d80f      	bhi.n	3400da2a <RCCEx_GetUSARTCLKFreq+0x6a>
3400da0a:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400da0e:	4298      	cmp	r0, r3
3400da10:	d007      	beq.n	3400da22 <RCCEx_GetUSARTCLKFreq+0x62>
3400da12:	bf8e      	itee	hi
3400da14:	4b5e      	ldrhi	r3, [pc, #376]	@ (3400db90 <RCCEx_GetUSARTCLKFreq+0x1d0>)
3400da16:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400da1a:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400da1e:	4298      	cmp	r0, r3
3400da20:	d1eb      	bne.n	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
}
3400da22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400da26:	f7ff bdd3 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400da2a:	4b5a      	ldr	r3, [pc, #360]	@ (3400db94 <RCCEx_GetUSARTCLKFreq+0x1d4>)
3400da2c:	4298      	cmp	r0, r3
3400da2e:	d007      	beq.n	3400da40 <RCCEx_GetUSARTCLKFreq+0x80>
3400da30:	bf8e      	itee	hi
3400da32:	4b59      	ldrhi	r3, [pc, #356]	@ (3400db98 <RCCEx_GetUSARTCLKFreq+0x1d8>)
3400da34:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3400da38:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3400da3c:	4298      	cmp	r0, r3
3400da3e:	d1dc      	bne.n	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400da40:	f7fc fc3e 	bl	3400a2c0 <LL_RCC_IC9_IsEnabled>
3400da44:	2800      	cmp	r0, #0
3400da46:	d0d8      	beq.n	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC9_GetDivider();
3400da48:	f7fc fc42 	bl	3400a2d0 <LL_RCC_IC9_GetDivider>
3400da4c:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400da4e:	4b53      	ldr	r3, [pc, #332]	@ (3400db9c <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400da50:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400da54:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400da58:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400da5c:	f000 808e 	beq.w	3400db7c <RCCEx_GetUSARTCLKFreq+0x1bc>
3400da60:	f200 8082 	bhi.w	3400db68 <RCCEx_GetUSARTCLKFreq+0x1a8>
3400da64:	2b00      	cmp	r3, #0
3400da66:	f040 8086 	bne.w	3400db76 <RCCEx_GetUSARTCLKFreq+0x1b6>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400da6a:	f7ff fcb1 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            usart_frequency = usart_frequency / ic_divider;
3400da6e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400da72:	e7c3      	b.n	3400d9fc <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400da74:	4b4a      	ldr	r3, [pc, #296]	@ (3400dba0 <RCCEx_GetUSARTCLKFreq+0x1e0>)
3400da76:	4298      	cmp	r0, r3
3400da78:	d045      	beq.n	3400db06 <RCCEx_GetUSARTCLKFreq+0x146>
3400da7a:	d833      	bhi.n	3400dae4 <RCCEx_GetUSARTCLKFreq+0x124>
3400da7c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400da80:	4298      	cmp	r0, r3
3400da82:	d028      	beq.n	3400dad6 <RCCEx_GetUSARTCLKFreq+0x116>
3400da84:	d81c      	bhi.n	3400dac0 <RCCEx_GetUSARTCLKFreq+0x100>
3400da86:	f5a3 437b 	sub.w	r3, r3, #64256	@ 0xfb00
3400da8a:	3bfc      	subs	r3, #252	@ 0xfc
3400da8c:	4298      	cmp	r0, r3
3400da8e:	d006      	beq.n	3400da9e <RCCEx_GetUSARTCLKFreq+0xde>
3400da90:	d810      	bhi.n	3400dab4 <RCCEx_GetUSARTCLKFreq+0xf4>
3400da92:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400da96:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3400da9a:	4298      	cmp	r0, r3
3400da9c:	d1ad      	bne.n	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400da9e:	f7fc fc21 	bl	3400a2e4 <LL_RCC_IC14_IsEnabled>
3400daa2:	2800      	cmp	r0, #0
3400daa4:	d0a9      	beq.n	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC14_GetDivider();
3400daa6:	f7fc fc25 	bl	3400a2f4 <LL_RCC_IC14_GetDivider>
3400daaa:	4b3c      	ldr	r3, [pc, #240]	@ (3400db9c <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400daac:	4604      	mov	r4, r0
3400daae:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400dab2:	e7cf      	b.n	3400da54 <RCCEx_GetUSARTCLKFreq+0x94>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400dab4:	4b3b      	ldr	r3, [pc, #236]	@ (3400dba4 <RCCEx_GetUSARTCLKFreq+0x1e4>)
3400dab6:	4298      	cmp	r0, r3
3400dab8:	d0f1      	beq.n	3400da9e <RCCEx_GetUSARTCLKFreq+0xde>
3400daba:	f503 6340 	add.w	r3, r3, #3072	@ 0xc00
3400dabe:	e7ec      	b.n	3400da9a <RCCEx_GetUSARTCLKFreq+0xda>
3400dac0:	4b39      	ldr	r3, [pc, #228]	@ (3400dba8 <RCCEx_GetUSARTCLKFreq+0x1e8>)
3400dac2:	4298      	cmp	r0, r3
3400dac4:	d007      	beq.n	3400dad6 <RCCEx_GetUSARTCLKFreq+0x116>
3400dac6:	bf8e      	itee	hi
3400dac8:	4b38      	ldrhi	r3, [pc, #224]	@ (3400dbac <RCCEx_GetUSARTCLKFreq+0x1ec>)
3400daca:	f020 0004 	bicls.w	r0, r0, #4
3400dace:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400dad2:	4298      	cmp	r0, r3
3400dad4:	d191      	bne.n	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_LSE_IsReady() != 0U)
3400dad6:	f7fc fba7 	bl	3400a228 <LL_RCC_LSE_IsReady>
3400dada:	3800      	subs	r0, #0
3400dadc:	bf18      	it	ne
3400dade:	2001      	movne	r0, #1
3400dae0:	03c0      	lsls	r0, r0, #15
3400dae2:	e78b      	b.n	3400d9fc <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400dae4:	4b32      	ldr	r3, [pc, #200]	@ (3400dbb0 <RCCEx_GetUSARTCLKFreq+0x1f0>)
3400dae6:	4298      	cmp	r0, r3
3400dae8:	d020      	beq.n	3400db2c <RCCEx_GetUSARTCLKFreq+0x16c>
3400daea:	d813      	bhi.n	3400db14 <RCCEx_GetUSARTCLKFreq+0x154>
3400daec:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400daf0:	4298      	cmp	r0, r3
3400daf2:	d008      	beq.n	3400db06 <RCCEx_GetUSARTCLKFreq+0x146>
3400daf4:	bf8e      	itee	hi
3400daf6:	4b2f      	ldrhi	r3, [pc, #188]	@ (3400dbb4 <RCCEx_GetUSARTCLKFreq+0x1f4>)
3400daf8:	f020 0004 	bicls.w	r0, r0, #4
3400dafc:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400db00:	4298      	cmp	r0, r3
3400db02:	f47f af7a 	bne.w	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_MSI_IsReady() != 0U)
3400db06:	f7fc fb87 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400db0a:	2800      	cmp	r0, #0
3400db0c:	f43f af75 	beq.w	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
        usart_frequency = MSI_VALUE;
3400db10:	4829      	ldr	r0, [pc, #164]	@ (3400dbb8 <RCCEx_GetUSARTCLKFreq+0x1f8>)
  return usart_frequency;
3400db12:	e773      	b.n	3400d9fc <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400db14:	4b29      	ldr	r3, [pc, #164]	@ (3400dbbc <RCCEx_GetUSARTCLKFreq+0x1fc>)
3400db16:	4298      	cmp	r0, r3
3400db18:	d008      	beq.n	3400db2c <RCCEx_GetUSARTCLKFreq+0x16c>
3400db1a:	bf8e      	itee	hi
3400db1c:	4b28      	ldrhi	r3, [pc, #160]	@ (3400dbc0 <RCCEx_GetUSARTCLKFreq+0x200>)
3400db1e:	f020 0004 	bicls.w	r0, r0, #4
3400db22:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3400db26:	4298      	cmp	r0, r3
3400db28:	f47f af67 	bne.w	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_HSI_IsReady() != 0U)
3400db2c:	f7fc fb6c 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400db30:	2800      	cmp	r0, #0
3400db32:	f43f af62 	beq.w	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400db36:	4b19      	ldr	r3, [pc, #100]	@ (3400db9c <RCCEx_GetUSARTCLKFreq+0x1dc>)
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400db38:	4822      	ldr	r0, [pc, #136]	@ (3400dbc4 <RCCEx_GetUSARTCLKFreq+0x204>)
3400db3a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400db3c:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400db40:	e007      	b.n	3400db52 <RCCEx_GetUSARTCLKFreq+0x192>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400db42:	f7fc fae7 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400db46:	f7fc fbf1 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400db4a:	4b14      	ldr	r3, [pc, #80]	@ (3400db9c <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400db4c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400db4e:	f3c3 1302 	ubfx	r3, r3, #4, #3
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400db52:	40d8      	lsrs	r0, r3
3400db54:	e752      	b.n	3400d9fc <RCCEx_GetUSARTCLKFreq+0x3c>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400db56:	f7fc fadd 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400db5a:	f7fc fbe7 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400db5e:	4b0f      	ldr	r3, [pc, #60]	@ (3400db9c <RCCEx_GetUSARTCLKFreq+0x1dc>)
3400db60:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400db62:	f003 0307 	and.w	r3, r3, #7
3400db66:	e7f4      	b.n	3400db52 <RCCEx_GetUSARTCLKFreq+0x192>
        switch (LL_RCC_IC14_GetSource())
3400db68:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400db6c:	f47f af45 	bne.w	3400d9fa <RCCEx_GetUSARTCLKFreq+0x3a>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400db70:	f7ff fcee 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400db74:	e77b      	b.n	3400da6e <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400db76:	f7ff fc6b 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400db7a:	e778      	b.n	3400da6e <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400db7c:	f7ff fca8 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400db80:	e775      	b.n	3400da6e <RCCEx_GetUSARTCLKFreq+0xae>
3400db82:	bf00      	nop
3400db84:	07021430 	.word	0x07021430
3400db88:	07000830 	.word	0x07000830
3400db8c:	07011430 	.word	0x07011430
3400db90:	07010830 	.word	0x07010830
3400db94:	07020434 	.word	0x07020434
3400db98:	07020830 	.word	0x07020830
3400db9c:	56028000 	.word	0x56028000
3400dba0:	07050030 	.word	0x07050030
3400dba4:	07030830 	.word	0x07030830
3400dba8:	07040830 	.word	0x07040830
3400dbac:	07041430 	.word	0x07041430
3400dbb0:	07060030 	.word	0x07060030
3400dbb4:	07051430 	.word	0x07051430
3400dbb8:	003d0900 	.word	0x003d0900
3400dbbc:	07060830 	.word	0x07060830
3400dbc0:	07061430 	.word	0x07061430
3400dbc4:	03d09000 	.word	0x03d09000

3400dbc8 <RCCEx_GetUARTCLKFreq>:
{
3400dbc8:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400dbca:	f7fc fb47 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dbce:	4b77      	ldr	r3, [pc, #476]	@ (3400ddac <RCCEx_GetUARTCLKFreq+0x1e4>)
3400dbd0:	4298      	cmp	r0, r3
3400dbd2:	d03e      	beq.n	3400dc52 <RCCEx_GetUARTCLKFreq+0x8a>
3400dbd4:	d859      	bhi.n	3400dc8a <RCCEx_GetUARTCLKFreq+0xc2>
3400dbd6:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400dbda:	4298      	cmp	r0, r3
3400dbdc:	f000 80c6 	beq.w	3400dd6c <RCCEx_GetUARTCLKFreq+0x1a4>
3400dbe0:	d814      	bhi.n	3400dc0c <RCCEx_GetUARTCLKFreq+0x44>
3400dbe2:	4b73      	ldr	r3, [pc, #460]	@ (3400ddb0 <RCCEx_GetUARTCLKFreq+0x1e8>)
3400dbe4:	4298      	cmp	r0, r3
3400dbe6:	f000 80cb 	beq.w	3400dd80 <RCCEx_GetUARTCLKFreq+0x1b8>
3400dbea:	3b01      	subs	r3, #1
3400dbec:	4298      	cmp	r0, r3
3400dbee:	d90b      	bls.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
3400dbf0:	f420 6200 	bic.w	r2, r0, #2048	@ 0x800
3400dbf4:	f603 73fd 	addw	r3, r3, #4093	@ 0xffd
3400dbf8:	429a      	cmp	r2, r3
3400dbfa:	f000 80b7 	beq.w	3400dd6c <RCCEx_GetUARTCLKFreq+0x1a4>
3400dbfe:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400dc02:	4298      	cmp	r0, r3
3400dc04:	f000 80b2 	beq.w	3400dd6c <RCCEx_GetUARTCLKFreq+0x1a4>
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400dc08:	2000      	movs	r0, #0
}
3400dc0a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dc0c:	4b69      	ldr	r3, [pc, #420]	@ (3400ddb4 <RCCEx_GetUARTCLKFreq+0x1ec>)
3400dc0e:	4298      	cmp	r0, r3
3400dc10:	d00d      	beq.n	3400dc2e <RCCEx_GetUARTCLKFreq+0x66>
3400dc12:	d812      	bhi.n	3400dc3a <RCCEx_GetUARTCLKFreq+0x72>
3400dc14:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dc18:	4298      	cmp	r0, r3
3400dc1a:	d008      	beq.n	3400dc2e <RCCEx_GetUARTCLKFreq+0x66>
3400dc1c:	d80b      	bhi.n	3400dc36 <RCCEx_GetUARTCLKFreq+0x6e>
3400dc1e:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400dc22:	4298      	cmp	r0, r3
3400dc24:	d003      	beq.n	3400dc2e <RCCEx_GetUARTCLKFreq+0x66>
3400dc26:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400dc2a:	4298      	cmp	r0, r3
3400dc2c:	d1ec      	bne.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
}
3400dc2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400dc32:	f7ff bccd 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dc36:	4b60      	ldr	r3, [pc, #384]	@ (3400ddb8 <RCCEx_GetUARTCLKFreq+0x1f0>)
3400dc38:	e7f7      	b.n	3400dc2a <RCCEx_GetUARTCLKFreq+0x62>
3400dc3a:	4b60      	ldr	r3, [pc, #384]	@ (3400ddbc <RCCEx_GetUARTCLKFreq+0x1f4>)
3400dc3c:	4298      	cmp	r0, r3
3400dc3e:	d008      	beq.n	3400dc52 <RCCEx_GetUARTCLKFreq+0x8a>
3400dc40:	d821      	bhi.n	3400dc86 <RCCEx_GetUARTCLKFreq+0xbe>
3400dc42:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400dc46:	4298      	cmp	r0, r3
3400dc48:	d003      	beq.n	3400dc52 <RCCEx_GetUARTCLKFreq+0x8a>
3400dc4a:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400dc4e:	4298      	cmp	r0, r3
3400dc50:	d1da      	bne.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400dc52:	f7fc fb35 	bl	3400a2c0 <LL_RCC_IC9_IsEnabled>
3400dc56:	2800      	cmp	r0, #0
3400dc58:	d0d6      	beq.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC9_GetDivider();
3400dc5a:	f7fc fb39 	bl	3400a2d0 <LL_RCC_IC9_GetDivider>
3400dc5e:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400dc60:	4b57      	ldr	r3, [pc, #348]	@ (3400ddc0 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dc62:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400dc66:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400dc6a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dc6e:	f000 809a 	beq.w	3400dda6 <RCCEx_GetUARTCLKFreq+0x1de>
3400dc72:	f200 808e 	bhi.w	3400dd92 <RCCEx_GetUARTCLKFreq+0x1ca>
3400dc76:	2b00      	cmp	r3, #0
3400dc78:	f040 8092 	bne.w	3400dda0 <RCCEx_GetUARTCLKFreq+0x1d8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400dc7c:	f7ff fba8 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            uart_frequency = uart_frequency / ic_divider;
3400dc80:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400dc84:	e7c1      	b.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dc86:	4b4f      	ldr	r3, [pc, #316]	@ (3400ddc4 <RCCEx_GetUARTCLKFreq+0x1fc>)
3400dc88:	e7e1      	b.n	3400dc4e <RCCEx_GetUARTCLKFreq+0x86>
3400dc8a:	4b4f      	ldr	r3, [pc, #316]	@ (3400ddc8 <RCCEx_GetUARTCLKFreq+0x200>)
3400dc8c:	4298      	cmp	r0, r3
3400dc8e:	d04a      	beq.n	3400dd26 <RCCEx_GetUARTCLKFreq+0x15e>
3400dc90:	d836      	bhi.n	3400dd00 <RCCEx_GetUARTCLKFreq+0x138>
3400dc92:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400dc96:	4298      	cmp	r0, r3
3400dc98:	d029      	beq.n	3400dcee <RCCEx_GetUARTCLKFreq+0x126>
3400dc9a:	d81c      	bhi.n	3400dcd6 <RCCEx_GetUARTCLKFreq+0x10e>
3400dc9c:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400dca0:	3b04      	subs	r3, #4
3400dca2:	4298      	cmp	r0, r3
3400dca4:	d008      	beq.n	3400dcb8 <RCCEx_GetUARTCLKFreq+0xf0>
3400dca6:	d812      	bhi.n	3400dcce <RCCEx_GetUARTCLKFreq+0x106>
3400dca8:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3400dcac:	4298      	cmp	r0, r3
3400dcae:	d003      	beq.n	3400dcb8 <RCCEx_GetUARTCLKFreq+0xf0>
3400dcb0:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3400dcb4:	4298      	cmp	r0, r3
3400dcb6:	d1a7      	bne.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400dcb8:	f7fc fb14 	bl	3400a2e4 <LL_RCC_IC14_IsEnabled>
3400dcbc:	2800      	cmp	r0, #0
3400dcbe:	d0a3      	beq.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC14_GetDivider();
3400dcc0:	f7fc fb18 	bl	3400a2f4 <LL_RCC_IC14_GetDivider>
3400dcc4:	4b3e      	ldr	r3, [pc, #248]	@ (3400ddc0 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dcc6:	4604      	mov	r4, r0
3400dcc8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400dccc:	e7cb      	b.n	3400dc66 <RCCEx_GetUARTCLKFreq+0x9e>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dcce:	4b3f      	ldr	r3, [pc, #252]	@ (3400ddcc <RCCEx_GetUARTCLKFreq+0x204>)
3400dcd0:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400dcd4:	e7ee      	b.n	3400dcb4 <RCCEx_GetUARTCLKFreq+0xec>
3400dcd6:	4b3e      	ldr	r3, [pc, #248]	@ (3400ddd0 <RCCEx_GetUARTCLKFreq+0x208>)
3400dcd8:	4298      	cmp	r0, r3
3400dcda:	d008      	beq.n	3400dcee <RCCEx_GetUARTCLKFreq+0x126>
3400dcdc:	d80e      	bhi.n	3400dcfc <RCCEx_GetUARTCLKFreq+0x134>
3400dcde:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dce2:	4298      	cmp	r0, r3
3400dce4:	d003      	beq.n	3400dcee <RCCEx_GetUARTCLKFreq+0x126>
3400dce6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dcea:	4298      	cmp	r0, r3
3400dcec:	d18c      	bne.n	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_LSE_IsReady() != 0U)
3400dcee:	f7fc fa9b 	bl	3400a228 <LL_RCC_LSE_IsReady>
3400dcf2:	3800      	subs	r0, #0
3400dcf4:	bf18      	it	ne
3400dcf6:	2001      	movne	r0, #1
3400dcf8:	03c0      	lsls	r0, r0, #15
3400dcfa:	e786      	b.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dcfc:	4b35      	ldr	r3, [pc, #212]	@ (3400ddd4 <RCCEx_GetUARTCLKFreq+0x20c>)
3400dcfe:	e7f4      	b.n	3400dcea <RCCEx_GetUARTCLKFreq+0x122>
3400dd00:	4b35      	ldr	r3, [pc, #212]	@ (3400ddd8 <RCCEx_GetUARTCLKFreq+0x210>)
3400dd02:	4298      	cmp	r0, r3
3400dd04:	d025      	beq.n	3400dd52 <RCCEx_GetUARTCLKFreq+0x18a>
3400dd06:	d817      	bhi.n	3400dd38 <RCCEx_GetUARTCLKFreq+0x170>
3400dd08:	f5a3 4368 	sub.w	r3, r3, #59392	@ 0xe800
3400dd0c:	3b04      	subs	r3, #4
3400dd0e:	4298      	cmp	r0, r3
3400dd10:	d009      	beq.n	3400dd26 <RCCEx_GetUARTCLKFreq+0x15e>
3400dd12:	d80f      	bhi.n	3400dd34 <RCCEx_GetUARTCLKFreq+0x16c>
3400dd14:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dd18:	4298      	cmp	r0, r3
3400dd1a:	d004      	beq.n	3400dd26 <RCCEx_GetUARTCLKFreq+0x15e>
3400dd1c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dd20:	4298      	cmp	r0, r3
3400dd22:	f47f af71 	bne.w	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_MSI_IsReady() != 0U)
3400dd26:	f7fc fa77 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400dd2a:	2800      	cmp	r0, #0
3400dd2c:	f43f af6c 	beq.w	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
        uart_frequency = MSI_VALUE;
3400dd30:	482a      	ldr	r0, [pc, #168]	@ (3400dddc <RCCEx_GetUARTCLKFreq+0x214>)
  return uart_frequency;
3400dd32:	e76a      	b.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dd34:	4b2a      	ldr	r3, [pc, #168]	@ (3400dde0 <RCCEx_GetUARTCLKFreq+0x218>)
3400dd36:	e7f3      	b.n	3400dd20 <RCCEx_GetUARTCLKFreq+0x158>
3400dd38:	4b2a      	ldr	r3, [pc, #168]	@ (3400dde4 <RCCEx_GetUARTCLKFreq+0x21c>)
3400dd3a:	4298      	cmp	r0, r3
3400dd3c:	d009      	beq.n	3400dd52 <RCCEx_GetUARTCLKFreq+0x18a>
3400dd3e:	d813      	bhi.n	3400dd68 <RCCEx_GetUARTCLKFreq+0x1a0>
3400dd40:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400dd44:	4298      	cmp	r0, r3
3400dd46:	d004      	beq.n	3400dd52 <RCCEx_GetUARTCLKFreq+0x18a>
3400dd48:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dd4c:	4298      	cmp	r0, r3
3400dd4e:	f47f af5b 	bne.w	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_HSI_IsReady() != 0U)
3400dd52:	f7fc fa59 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400dd56:	2800      	cmp	r0, #0
3400dd58:	f43f af56 	beq.w	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400dd5c:	4b18      	ldr	r3, [pc, #96]	@ (3400ddc0 <RCCEx_GetUARTCLKFreq+0x1f8>)
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400dd5e:	4822      	ldr	r0, [pc, #136]	@ (3400dde8 <RCCEx_GetUARTCLKFreq+0x220>)
3400dd60:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400dd62:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400dd66:	e009      	b.n	3400dd7c <RCCEx_GetUARTCLKFreq+0x1b4>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400dd68:	4b20      	ldr	r3, [pc, #128]	@ (3400ddec <RCCEx_GetUARTCLKFreq+0x224>)
3400dd6a:	e7ef      	b.n	3400dd4c <RCCEx_GetUARTCLKFreq+0x184>
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dd6c:	f7fc f9d2 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400dd70:	f7fc fadc 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400dd74:	4b12      	ldr	r3, [pc, #72]	@ (3400ddc0 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dd76:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400dd78:	f003 0307 	and.w	r3, r3, #7
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400dd7c:	40d8      	lsrs	r0, r3
3400dd7e:	e744      	b.n	3400dc0a <RCCEx_GetUARTCLKFreq+0x42>
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400dd80:	f7fc f9c8 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400dd84:	f7fc fad2 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400dd88:	4b0d      	ldr	r3, [pc, #52]	@ (3400ddc0 <RCCEx_GetUARTCLKFreq+0x1f8>)
3400dd8a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400dd8c:	f3c3 1302 	ubfx	r3, r3, #4, #3
3400dd90:	e7f4      	b.n	3400dd7c <RCCEx_GetUARTCLKFreq+0x1b4>
        switch (LL_RCC_IC14_GetSource())
3400dd92:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dd96:	f47f af37 	bne.w	3400dc08 <RCCEx_GetUARTCLKFreq+0x40>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400dd9a:	f7ff fbd9 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400dd9e:	e76f      	b.n	3400dc80 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400dda0:	f7ff fb56 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400dda4:	e76c      	b.n	3400dc80 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400dda6:	f7ff fb93 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400ddaa:	e769      	b.n	3400dc80 <RCCEx_GetUARTCLKFreq+0xb8>
3400ddac:	07021c30 	.word	0x07021c30
3400ddb0:	07000034 	.word	0x07000034
3400ddb4:	07011c30 	.word	0x07011c30
3400ddb8:	07011830 	.word	0x07011830
3400ddbc:	07021030 	.word	0x07021030
3400ddc0:	56028000 	.word	0x56028000
3400ddc4:	07021830 	.word	0x07021830
3400ddc8:	07050034 	.word	0x07050034
3400ddcc:	07031830 	.word	0x07031830
3400ddd0:	07041830 	.word	0x07041830
3400ddd4:	07041c30 	.word	0x07041c30
3400ddd8:	07060034 	.word	0x07060034
3400dddc:	003d0900 	.word	0x003d0900
3400dde0:	07051c30 	.word	0x07051c30
3400dde4:	07061830 	.word	0x07061830
3400dde8:	03d09000 	.word	0x03d09000
3400ddec:	07061c30 	.word	0x07061c30

3400ddf0 <RCCEx_GetSPICLKFreq>:
{
3400ddf0:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400ddf2:	f7fc fa33 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400ddf6:	4b89      	ldr	r3, [pc, #548]	@ (3400e01c <RCCEx_GetSPICLKFreq+0x22c>)
3400ddf8:	4298      	cmp	r0, r3
3400ddfa:	d055      	beq.n	3400dea8 <RCCEx_GetSPICLKFreq+0xb8>
3400ddfc:	d865      	bhi.n	3400deca <RCCEx_GetSPICLKFreq+0xda>
3400ddfe:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
3400de02:	4298      	cmp	r0, r3
3400de04:	f000 80ca 	beq.w	3400df9c <RCCEx_GetSPICLKFreq+0x1ac>
3400de08:	d81e      	bhi.n	3400de48 <RCCEx_GetSPICLKFreq+0x58>
3400de0a:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400de0e:	4298      	cmp	r0, r3
3400de10:	f000 80ba 	beq.w	3400df88 <RCCEx_GetSPICLKFreq+0x198>
3400de14:	d80a      	bhi.n	3400de2c <RCCEx_GetSPICLKFreq+0x3c>
3400de16:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400de1a:	4298      	cmp	r0, r3
3400de1c:	d00b      	beq.n	3400de36 <RCCEx_GetSPICLKFreq+0x46>
3400de1e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400de22:	4298      	cmp	r0, r3
3400de24:	f000 80b0 	beq.w	3400df88 <RCCEx_GetSPICLKFreq+0x198>
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400de28:	2000      	movs	r0, #0
}
3400de2a:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400de2c:	4b7c      	ldr	r3, [pc, #496]	@ (3400e020 <RCCEx_GetSPICLKFreq+0x230>)
3400de2e:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400de32:	4298      	cmp	r0, r3
3400de34:	d1f8      	bne.n	3400de28 <RCCEx_GetSPICLKFreq+0x38>
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400de36:	f7fc f96d 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400de3a:	f7fc fa77 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400de3e:	4b79      	ldr	r3, [pc, #484]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
3400de40:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400de42:	f3c3 1302 	ubfx	r3, r3, #4, #3
3400de46:	e0a7      	b.n	3400df98 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400de48:	4b77      	ldr	r3, [pc, #476]	@ (3400e028 <RCCEx_GetSPICLKFreq+0x238>)
3400de4a:	4298      	cmp	r0, r3
3400de4c:	f000 80af 	beq.w	3400dfae <RCCEx_GetSPICLKFreq+0x1be>
3400de50:	d81d      	bhi.n	3400de8e <RCCEx_GetSPICLKFreq+0x9e>
3400de52:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400de56:	4298      	cmp	r0, r3
3400de58:	d00a      	beq.n	3400de70 <RCCEx_GetSPICLKFreq+0x80>
3400de5a:	d80d      	bhi.n	3400de78 <RCCEx_GetSPICLKFreq+0x88>
3400de5c:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400de60:	4298      	cmp	r0, r3
3400de62:	d005      	beq.n	3400de70 <RCCEx_GetSPICLKFreq+0x80>
3400de64:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3400de68:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400de6c:	4298      	cmp	r0, r3
3400de6e:	d1db      	bne.n	3400de28 <RCCEx_GetSPICLKFreq+0x38>
}
3400de70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400de74:	f7ff bbac 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400de78:	4b6c      	ldr	r3, [pc, #432]	@ (3400e02c <RCCEx_GetSPICLKFreq+0x23c>)
3400de7a:	4298      	cmp	r0, r3
3400de7c:	d0f8      	beq.n	3400de70 <RCCEx_GetSPICLKFreq+0x80>
3400de7e:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3400de82:	4298      	cmp	r0, r3
3400de84:	f000 8093 	beq.w	3400dfae <RCCEx_GetSPICLKFreq+0x1be>
3400de88:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400de8c:	e7ee      	b.n	3400de6c <RCCEx_GetSPICLKFreq+0x7c>
3400de8e:	4b68      	ldr	r3, [pc, #416]	@ (3400e030 <RCCEx_GetSPICLKFreq+0x240>)
3400de90:	4298      	cmp	r0, r3
3400de92:	d009      	beq.n	3400dea8 <RCCEx_GetSPICLKFreq+0xb8>
3400de94:	d813      	bhi.n	3400debe <RCCEx_GetSPICLKFreq+0xce>
3400de96:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400de9a:	4298      	cmp	r0, r3
3400de9c:	f000 8087 	beq.w	3400dfae <RCCEx_GetSPICLKFreq+0x1be>
3400dea0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400dea4:	4298      	cmp	r0, r3
3400dea6:	d1bf      	bne.n	3400de28 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400dea8:	f7fc fa0a 	bl	3400a2c0 <LL_RCC_IC9_IsEnabled>
3400deac:	2800      	cmp	r0, #0
3400deae:	d0bb      	beq.n	3400de28 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC9_GetDivider();
3400deb0:	f7fc fa0e 	bl	3400a2d0 <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400deb4:	4b5b      	ldr	r3, [pc, #364]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
3400deb6:	4604      	mov	r4, r0
3400deb8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400debc:	e082      	b.n	3400dfc4 <RCCEx_GetSPICLKFreq+0x1d4>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400debe:	4b5d      	ldr	r3, [pc, #372]	@ (3400e034 <RCCEx_GetSPICLKFreq+0x244>)
3400dec0:	4298      	cmp	r0, r3
3400dec2:	d074      	beq.n	3400dfae <RCCEx_GetSPICLKFreq+0x1be>
3400dec4:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3400dec8:	e7ec      	b.n	3400dea4 <RCCEx_GetSPICLKFreq+0xb4>
3400deca:	4b5b      	ldr	r3, [pc, #364]	@ (3400e038 <RCCEx_GetSPICLKFreq+0x248>)
3400decc:	4298      	cmp	r0, r3
3400dece:	d043      	beq.n	3400df58 <RCCEx_GetSPICLKFreq+0x168>
3400ded0:	d830      	bhi.n	3400df34 <RCCEx_GetSPICLKFreq+0x144>
3400ded2:	f5a3 33fa 	sub.w	r3, r3, #128000	@ 0x1f400
3400ded6:	4298      	cmp	r0, r3
3400ded8:	d0e6      	beq.n	3400dea8 <RCCEx_GetSPICLKFreq+0xb8>
3400deda:	d808      	bhi.n	3400deee <RCCEx_GetSPICLKFreq+0xfe>
3400dedc:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400dee0:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400dee4:	429a      	cmp	r2, r3
3400dee6:	d079      	beq.n	3400dfdc <RCCEx_GetSPICLKFreq+0x1ec>
3400dee8:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3400deec:	e7da      	b.n	3400dea4 <RCCEx_GetSPICLKFreq+0xb4>
3400deee:	4b53      	ldr	r3, [pc, #332]	@ (3400e03c <RCCEx_GetSPICLKFreq+0x24c>)
3400def0:	4298      	cmp	r0, r3
3400def2:	d00d      	beq.n	3400df10 <RCCEx_GetSPICLKFreq+0x120>
3400def4:	d814      	bhi.n	3400df20 <RCCEx_GetSPICLKFreq+0x130>
3400def6:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400defa:	4298      	cmp	r0, r3
3400defc:	d008      	beq.n	3400df10 <RCCEx_GetSPICLKFreq+0x120>
3400defe:	d80d      	bhi.n	3400df1c <RCCEx_GetSPICLKFreq+0x12c>
3400df00:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400df04:	4298      	cmp	r0, r3
3400df06:	d003      	beq.n	3400df10 <RCCEx_GetSPICLKFreq+0x120>
3400df08:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400df0c:	4298      	cmp	r0, r3
3400df0e:	d18b      	bne.n	3400de28 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_MSI_IsReady() != 0U)
3400df10:	f7fc f982 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400df14:	2800      	cmp	r0, #0
3400df16:	d087      	beq.n	3400de28 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = MSI_VALUE;
3400df18:	4849      	ldr	r0, [pc, #292]	@ (3400e040 <RCCEx_GetSPICLKFreq+0x250>)
  return spi_frequency;
3400df1a:	e786      	b.n	3400de2a <RCCEx_GetSPICLKFreq+0x3a>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400df1c:	4b49      	ldr	r3, [pc, #292]	@ (3400e044 <RCCEx_GetSPICLKFreq+0x254>)
3400df1e:	e7f5      	b.n	3400df0c <RCCEx_GetSPICLKFreq+0x11c>
3400df20:	4b49      	ldr	r3, [pc, #292]	@ (3400e048 <RCCEx_GetSPICLKFreq+0x258>)
3400df22:	4298      	cmp	r0, r3
3400df24:	d018      	beq.n	3400df58 <RCCEx_GetSPICLKFreq+0x168>
3400df26:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400df2a:	4298      	cmp	r0, r3
3400df2c:	d014      	beq.n	3400df58 <RCCEx_GetSPICLKFreq+0x168>
3400df2e:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400df32:	e7eb      	b.n	3400df0c <RCCEx_GetSPICLKFreq+0x11c>
3400df34:	4b45      	ldr	r3, [pc, #276]	@ (3400e04c <RCCEx_GetSPICLKFreq+0x25c>)
3400df36:	4298      	cmp	r0, r3
3400df38:	d069      	beq.n	3400e00e <RCCEx_GetSPICLKFreq+0x21e>
3400df3a:	d81e      	bhi.n	3400df7a <RCCEx_GetSPICLKFreq+0x18a>
3400df3c:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400df40:	4298      	cmp	r0, r3
3400df42:	d018      	beq.n	3400df76 <RCCEx_GetSPICLKFreq+0x186>
3400df44:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3400df48:	d811      	bhi.n	3400df6e <RCCEx_GetSPICLKFreq+0x17e>
3400df4a:	4a41      	ldr	r2, [pc, #260]	@ (3400e050 <RCCEx_GetSPICLKFreq+0x260>)
3400df4c:	4293      	cmp	r3, r2
3400df4e:	d003      	beq.n	3400df58 <RCCEx_GetSPICLKFreq+0x168>
3400df50:	4b40      	ldr	r3, [pc, #256]	@ (3400e054 <RCCEx_GetSPICLKFreq+0x264>)
3400df52:	4298      	cmp	r0, r3
3400df54:	f47f af68 	bne.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_HSI_IsReady() != 0U)
3400df58:	f7fc f956 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400df5c:	2800      	cmp	r0, #0
3400df5e:	f43f af63 	beq.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400df62:	4b30      	ldr	r3, [pc, #192]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400df64:	483c      	ldr	r0, [pc, #240]	@ (3400e058 <RCCEx_GetSPICLKFreq+0x268>)
3400df66:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400df68:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400df6c:	e014      	b.n	3400df98 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400df6e:	4a3b      	ldr	r2, [pc, #236]	@ (3400e05c <RCCEx_GetSPICLKFreq+0x26c>)
3400df70:	4293      	cmp	r3, r2
3400df72:	f47f af59 	bne.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
3400df76:	483a      	ldr	r0, [pc, #232]	@ (3400e060 <RCCEx_GetSPICLKFreq+0x270>)
3400df78:	e757      	b.n	3400de2a <RCCEx_GetSPICLKFreq+0x3a>
3400df7a:	4b3a      	ldr	r3, [pc, #232]	@ (3400e064 <RCCEx_GetSPICLKFreq+0x274>)
3400df7c:	4298      	cmp	r0, r3
3400df7e:	d046      	beq.n	3400e00e <RCCEx_GetSPICLKFreq+0x21e>
3400df80:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400df84:	4298      	cmp	r0, r3
3400df86:	e7f4      	b.n	3400df72 <RCCEx_GetSPICLKFreq+0x182>
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400df88:	f7fc f8c4 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400df8c:	f7fc f9ce 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400df90:	4b24      	ldr	r3, [pc, #144]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
3400df92:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400df94:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400df98:	40d8      	lsrs	r0, r3
      break;
3400df9a:	e746      	b.n	3400de2a <RCCEx_GetSPICLKFreq+0x3a>
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400df9c:	f7fc f8ba 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400dfa0:	f7fc f9c4 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400dfa4:	4b1f      	ldr	r3, [pc, #124]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
3400dfa6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400dfa8:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400dfac:	e7f4      	b.n	3400df98 <RCCEx_GetSPICLKFreq+0x1a8>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400dfae:	f7fc f975 	bl	3400a29c <LL_RCC_IC8_IsEnabled>
3400dfb2:	2800      	cmp	r0, #0
3400dfb4:	f43f af38 	beq.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC8_GetDivider();
3400dfb8:	f7fc f978 	bl	3400a2ac <LL_RCC_IC8_GetDivider>
3400dfbc:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400dfbe:	4b19      	ldr	r3, [pc, #100]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
3400dfc0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400dfc4:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3400dfc8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400dfcc:	d01c      	beq.n	3400e008 <RCCEx_GetSPICLKFreq+0x218>
3400dfce:	d811      	bhi.n	3400dff4 <RCCEx_GetSPICLKFreq+0x204>
3400dfd0:	b9bb      	cbnz	r3, 3400e002 <RCCEx_GetSPICLKFreq+0x212>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400dfd2:	f7ff f9fd 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            spi_frequency = spi_frequency / ic_divider;
3400dfd6:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400dfda:	e726      	b.n	3400de2a <RCCEx_GetSPICLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400dfdc:	f7fc f982 	bl	3400a2e4 <LL_RCC_IC14_IsEnabled>
3400dfe0:	2800      	cmp	r0, #0
3400dfe2:	f43f af21 	beq.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC14_GetDivider();
3400dfe6:	f7fc f985 	bl	3400a2f4 <LL_RCC_IC14_GetDivider>
3400dfea:	4b0e      	ldr	r3, [pc, #56]	@ (3400e024 <RCCEx_GetSPICLKFreq+0x234>)
3400dfec:	4604      	mov	r4, r0
3400dfee:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400dff2:	e7e7      	b.n	3400dfc4 <RCCEx_GetSPICLKFreq+0x1d4>
        switch (LL_RCC_IC14_GetSource())
3400dff4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400dff8:	f47f af16 	bne.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400dffc:	f7ff faa8 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400e000:	e7e9      	b.n	3400dfd6 <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e002:	f7ff fa25 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400e006:	e7e6      	b.n	3400dfd6 <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e008:	f7ff fa62 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400e00c:	e7e3      	b.n	3400dfd6 <RCCEx_GetSPICLKFreq+0x1e6>
      if (LL_RCC_HSE_IsReady() != 0U)
3400e00e:	f7fc f8f3 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400e012:	2800      	cmp	r0, #0
3400e014:	f43f af08 	beq.w	3400de28 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = HSE_VALUE;
3400e018:	4813      	ldr	r0, [pc, #76]	@ (3400e068 <RCCEx_GetSPICLKFreq+0x278>)
3400e01a:	e706      	b.n	3400de2a <RCCEx_GetSPICLKFreq+0x3a>
3400e01c:	07030820 	.word	0x07030820
3400e020:	07001020 	.word	0x07001020
3400e024:	56028000 	.word	0x56028000
3400e028:	07020820 	.word	0x07020820
3400e02c:	07011820 	.word	0x07011820
3400e030:	07021420 	.word	0x07021420
3400e034:	07021820 	.word	0x07021820
3400e038:	07050c20 	.word	0x07050c20
3400e03c:	07041420 	.word	0x07041420
3400e040:	003d0900 	.word	0x003d0900
3400e044:	07041020 	.word	0x07041020
3400e048:	07050420 	.word	0x07050420
3400e04c:	07061020 	.word	0x07061020
3400e050:	07051020 	.word	0x07051020
3400e054:	07051820 	.word	0x07051820
3400e058:	03d09000 	.word	0x03d09000
3400e05c:	07060820 	.word	0x07060820
3400e060:	00bb8000 	.word	0x00bb8000
3400e064:	07061420 	.word	0x07061420
3400e068:	02dc6c00 	.word	0x02dc6c00

3400e06c <RCCEx_GetSAICLKFreq>:
{
3400e06c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e06e:	f7fc f8f5 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e072:	4b49      	ldr	r3, [pc, #292]	@ (3400e198 <RCCEx_GetSAICLKFreq+0x12c>)
3400e074:	4298      	cmp	r0, r3
3400e076:	d04a      	beq.n	3400e10e <RCCEx_GetSAICLKFreq+0xa2>
3400e078:	d839      	bhi.n	3400e0ee <RCCEx_GetSAICLKFreq+0x82>
3400e07a:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3400e07e:	4298      	cmp	r0, r3
3400e080:	d021      	beq.n	3400e0c6 <RCCEx_GetSAICLKFreq+0x5a>
3400e082:	d815      	bhi.n	3400e0b0 <RCCEx_GetSAICLKFreq+0x44>
3400e084:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e088:	4298      	cmp	r0, r3
3400e08a:	d00d      	beq.n	3400e0a8 <RCCEx_GetSAICLKFreq+0x3c>
3400e08c:	d809      	bhi.n	3400e0a2 <RCCEx_GetSAICLKFreq+0x36>
3400e08e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e092:	4298      	cmp	r0, r3
3400e094:	d04e      	beq.n	3400e134 <RCCEx_GetSAICLKFreq+0xc8>
3400e096:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e09a:	4298      	cmp	r0, r3
3400e09c:	d04a      	beq.n	3400e134 <RCCEx_GetSAICLKFreq+0xc8>
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e09e:	2000      	movs	r0, #0
}
3400e0a0:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e0a2:	4b3e      	ldr	r3, [pc, #248]	@ (3400e19c <RCCEx_GetSAICLKFreq+0x130>)
3400e0a4:	4298      	cmp	r0, r3
3400e0a6:	d1fa      	bne.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
}
3400e0a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e0ac:	f7ff ba90 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e0b0:	4b3b      	ldr	r3, [pc, #236]	@ (3400e1a0 <RCCEx_GetSAICLKFreq+0x134>)
3400e0b2:	4298      	cmp	r0, r3
3400e0b4:	d04d      	beq.n	3400e152 <RCCEx_GetSAICLKFreq+0xe6>
3400e0b6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e0ba:	4298      	cmp	r0, r3
3400e0bc:	d049      	beq.n	3400e152 <RCCEx_GetSAICLKFreq+0xe6>
3400e0be:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e0c2:	4298      	cmp	r0, r3
3400e0c4:	d1eb      	bne.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400e0c6:	f7fc f8d7 	bl	3400a278 <LL_RCC_IC7_IsEnabled>
3400e0ca:	2800      	cmp	r0, #0
3400e0cc:	d0e7      	beq.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC7_GetDivider();
3400e0ce:	f7fc f8db 	bl	3400a288 <LL_RCC_IC7_GetDivider>
3400e0d2:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400e0d4:	4b33      	ldr	r3, [pc, #204]	@ (3400e1a4 <RCCEx_GetSAICLKFreq+0x138>)
3400e0d6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e0da:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400e0de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e0e2:	d047      	beq.n	3400e174 <RCCEx_GetSAICLKFreq+0x108>
3400e0e4:	d840      	bhi.n	3400e168 <RCCEx_GetSAICLKFreq+0xfc>
3400e0e6:	bb7b      	cbnz	r3, 3400e148 <RCCEx_GetSAICLKFreq+0xdc>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e0e8:	f7ff f972 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
3400e0ec:	e02e      	b.n	3400e14c <RCCEx_GetSAICLKFreq+0xe0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e0ee:	4b2e      	ldr	r3, [pc, #184]	@ (3400e1a8 <RCCEx_GetSAICLKFreq+0x13c>)
3400e0f0:	4298      	cmp	r0, r3
3400e0f2:	d01d      	beq.n	3400e130 <RCCEx_GetSAICLKFreq+0xc4>
3400e0f4:	d811      	bhi.n	3400e11a <RCCEx_GetSAICLKFreq+0xae>
3400e0f6:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e0fa:	4298      	cmp	r0, r3
3400e0fc:	d03d      	beq.n	3400e17a <RCCEx_GetSAICLKFreq+0x10e>
3400e0fe:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e102:	4298      	cmp	r0, r3
3400e104:	d039      	beq.n	3400e17a <RCCEx_GetSAICLKFreq+0x10e>
3400e106:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e10a:	4298      	cmp	r0, r3
3400e10c:	d1c7      	bne.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e10e:	f7fc f883 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400e112:	2800      	cmp	r0, #0
3400e114:	d0c3      	beq.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
        sai_frequency = MSI_VALUE;
3400e116:	4825      	ldr	r0, [pc, #148]	@ (3400e1ac <RCCEx_GetSAICLKFreq+0x140>)
  return sai_frequency;
3400e118:	e7c2      	b.n	3400e0a0 <RCCEx_GetSAICLKFreq+0x34>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3400e11a:	4b25      	ldr	r3, [pc, #148]	@ (3400e1b0 <RCCEx_GetSAICLKFreq+0x144>)
3400e11c:	4298      	cmp	r0, r3
3400e11e:	d036      	beq.n	3400e18e <RCCEx_GetSAICLKFreq+0x122>
3400e120:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e124:	4298      	cmp	r0, r3
3400e126:	d032      	beq.n	3400e18e <RCCEx_GetSAICLKFreq+0x122>
3400e128:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e12c:	4298      	cmp	r0, r3
3400e12e:	d1b6      	bne.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
3400e130:	4820      	ldr	r0, [pc, #128]	@ (3400e1b4 <RCCEx_GetSAICLKFreq+0x148>)
3400e132:	e7b5      	b.n	3400e0a0 <RCCEx_GetSAICLKFreq+0x34>
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e134:	f7fb ffee 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400e138:	f7fc f8f8 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400e13c:	4b19      	ldr	r3, [pc, #100]	@ (3400e1a4 <RCCEx_GetSAICLKFreq+0x138>)
3400e13e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3400e140:	f3c3 1302 	ubfx	r3, r3, #4, #3
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e144:	40d8      	lsrs	r0, r3
3400e146:	e7ab      	b.n	3400e0a0 <RCCEx_GetSAICLKFreq+0x34>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e148:	f7ff f982 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
            sai_frequency = sai_frequency / ic_divider;
3400e14c:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e150:	e7a6      	b.n	3400e0a0 <RCCEx_GetSAICLKFreq+0x34>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400e152:	f7fc f8a3 	bl	3400a29c <LL_RCC_IC8_IsEnabled>
3400e156:	2800      	cmp	r0, #0
3400e158:	d0a1      	beq.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC8_GetDivider();
3400e15a:	f7fc f8a7 	bl	3400a2ac <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e15e:	4b11      	ldr	r3, [pc, #68]	@ (3400e1a4 <RCCEx_GetSAICLKFreq+0x138>)
3400e160:	4604      	mov	r4, r0
3400e162:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400e166:	e7b8      	b.n	3400e0da <RCCEx_GetSAICLKFreq+0x6e>
        switch (LL_RCC_IC8_GetSource())
3400e168:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e16c:	d197      	bne.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e16e:	f7ff f9ef 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400e172:	e7eb      	b.n	3400e14c <RCCEx_GetSAICLKFreq+0xe0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e174:	f7ff f9ac 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400e178:	e7e8      	b.n	3400e14c <RCCEx_GetSAICLKFreq+0xe0>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e17a:	f7fc f845 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400e17e:	2800      	cmp	r0, #0
3400e180:	d08d      	beq.n	3400e09e <RCCEx_GetSAICLKFreq+0x32>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e182:	4b08      	ldr	r3, [pc, #32]	@ (3400e1a4 <RCCEx_GetSAICLKFreq+0x138>)
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e184:	480c      	ldr	r0, [pc, #48]	@ (3400e1b8 <RCCEx_GetSAICLKFreq+0x14c>)
3400e186:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e188:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e18c:	e7da      	b.n	3400e144 <RCCEx_GetSAICLKFreq+0xd8>
}
3400e18e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400e192:	f7ff baa3 	b.w	3400d6dc <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
3400e196:	bf00      	nop
3400e198:	07041418 	.word	0x07041418
3400e19c:	07011818 	.word	0x07011818
3400e1a0:	07031418 	.word	0x07031418
3400e1a4:	56028000 	.word	0x56028000
3400e1a8:	07061418 	.word	0x07061418
3400e1ac:	003d0900 	.word	0x003d0900
3400e1b0:	07071418 	.word	0x07071418
3400e1b4:	00bb8000 	.word	0x00bb8000
3400e1b8:	03d09000 	.word	0x03d09000

3400e1bc <RCCEx_GetI3CCLKFreq>:
{
3400e1bc:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e1be:	f7fc f84d 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e1c2:	4b3d      	ldr	r3, [pc, #244]	@ (3400e2b8 <RCCEx_GetI3CCLKFreq+0xfc>)
3400e1c4:	4298      	cmp	r0, r3
3400e1c6:	d060      	beq.n	3400e28a <RCCEx_GetI3CCLKFreq+0xce>
3400e1c8:	d830      	bhi.n	3400e22c <RCCEx_GetI3CCLKFreq+0x70>
3400e1ca:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3400e1ce:	4298      	cmp	r0, r3
3400e1d0:	d057      	beq.n	3400e282 <RCCEx_GetI3CCLKFreq+0xc6>
3400e1d2:	d80d      	bhi.n	3400e1f0 <RCCEx_GetI3CCLKFreq+0x34>
3400e1d4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e1d8:	4298      	cmp	r0, r3
3400e1da:	d048      	beq.n	3400e26e <RCCEx_GetI3CCLKFreq+0xb2>
3400e1dc:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3400e1e0:	4298      	cmp	r0, r3
3400e1e2:	d04e      	beq.n	3400e282 <RCCEx_GetI3CCLKFreq+0xc6>
3400e1e4:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e1e8:	4298      	cmp	r0, r3
3400e1ea:	d040      	beq.n	3400e26e <RCCEx_GetI3CCLKFreq+0xb2>
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e1ec:	2000      	movs	r0, #0
}
3400e1ee:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e1f0:	4b32      	ldr	r3, [pc, #200]	@ (3400e2bc <RCCEx_GetI3CCLKFreq+0x100>)
3400e1f2:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e1f6:	4298      	cmp	r0, r3
3400e1f8:	d1f8      	bne.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400e1fa:	4b31      	ldr	r3, [pc, #196]	@ (3400e2c0 <RCCEx_GetI3CCLKFreq+0x104>)
3400e1fc:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400e200:	0592      	lsls	r2, r2, #22
3400e202:	d5f3      	bpl.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e204:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400e208:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e20c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e210:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e212:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e216:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e21a:	d04a      	beq.n	3400e2b2 <RCCEx_GetI3CCLKFreq+0xf6>
3400e21c:	d840      	bhi.n	3400e2a0 <RCCEx_GetI3CCLKFreq+0xe4>
3400e21e:	2b00      	cmp	r3, #0
3400e220:	d144      	bne.n	3400e2ac <RCCEx_GetI3CCLKFreq+0xf0>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e222:	f7ff f8d5 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            i3c_frequency = i3c_frequency / ic_divider;
3400e226:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e22a:	e7e0      	b.n	3400e1ee <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e22c:	4b25      	ldr	r3, [pc, #148]	@ (3400e2c4 <RCCEx_GetI3CCLKFreq+0x108>)
3400e22e:	4298      	cmp	r0, r3
3400e230:	d008      	beq.n	3400e244 <RCCEx_GetI3CCLKFreq+0x88>
3400e232:	d80d      	bhi.n	3400e250 <RCCEx_GetI3CCLKFreq+0x94>
3400e234:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e238:	4298      	cmp	r0, r3
3400e23a:	d026      	beq.n	3400e28a <RCCEx_GetI3CCLKFreq+0xce>
3400e23c:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3400e240:	4298      	cmp	r0, r3
3400e242:	d1d3      	bne.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e244:	f7fb ffe8 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400e248:	2800      	cmp	r0, #0
3400e24a:	d0cf      	beq.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
        i3c_frequency = MSI_VALUE;
3400e24c:	481e      	ldr	r0, [pc, #120]	@ (3400e2c8 <RCCEx_GetI3CCLKFreq+0x10c>)
  return i3c_frequency;
3400e24e:	e7ce      	b.n	3400e1ee <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3400e250:	4b1e      	ldr	r3, [pc, #120]	@ (3400e2cc <RCCEx_GetI3CCLKFreq+0x110>)
3400e252:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e256:	4298      	cmp	r0, r3
3400e258:	d1c8      	bne.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e25a:	f7fb ffd5 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400e25e:	2800      	cmp	r0, #0
3400e260:	d0c4      	beq.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e262:	4b17      	ldr	r3, [pc, #92]	@ (3400e2c0 <RCCEx_GetI3CCLKFreq+0x104>)
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e264:	481a      	ldr	r0, [pc, #104]	@ (3400e2d0 <RCCEx_GetI3CCLKFreq+0x114>)
3400e266:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e268:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e26c:	e007      	b.n	3400e27e <RCCEx_GetI3CCLKFreq+0xc2>
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e26e:	f7fb ff51 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400e272:	f7fc f85b 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e276:	4b12      	ldr	r3, [pc, #72]	@ (3400e2c0 <RCCEx_GetI3CCLKFreq+0x104>)
3400e278:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e27a:	f003 0307 	and.w	r3, r3, #7
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e27e:	40d8      	lsrs	r0, r3
3400e280:	e7b5      	b.n	3400e1ee <RCCEx_GetI3CCLKFreq+0x32>
}
3400e282:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e286:	f7ff b9a3 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e28a:	f7fc f83d 	bl	3400a308 <LL_RCC_IC15_IsEnabled>
3400e28e:	2800      	cmp	r0, #0
3400e290:	d0ac      	beq.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e292:	f7fc f841 	bl	3400a318 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e296:	4b0a      	ldr	r3, [pc, #40]	@ (3400e2c0 <RCCEx_GetI3CCLKFreq+0x104>)
3400e298:	4604      	mov	r4, r0
3400e29a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e29e:	e7b8      	b.n	3400e212 <RCCEx_GetI3CCLKFreq+0x56>
        switch (LL_RCC_IC15_GetSource())
3400e2a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e2a4:	d1a2      	bne.n	3400e1ec <RCCEx_GetI3CCLKFreq+0x30>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e2a6:	f7ff f953 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400e2aa:	e7bc      	b.n	3400e226 <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e2ac:	f7ff f8d0 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400e2b0:	e7b9      	b.n	3400e226 <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e2b2:	f7ff f90d 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400e2b6:	e7b6      	b.n	3400e226 <RCCEx_GetI3CCLKFreq+0x6a>
3400e2b8:	0703100c 	.word	0x0703100c
3400e2bc:	0702100c 	.word	0x0702100c
3400e2c0:	56028000 	.word	0x56028000
3400e2c4:	0704140c 	.word	0x0704140c
3400e2c8:	003d0900 	.word	0x003d0900
3400e2cc:	0705100c 	.word	0x0705100c
3400e2d0:	03d09000 	.word	0x03d09000

3400e2d4 <RCCEx_GetSDMMCCLKFreq>:
{
3400e2d4:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e2d6:	f7fb ffc1 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e2da:	4b2d      	ldr	r3, [pc, #180]	@ (3400e390 <RCCEx_GetSDMMCCLKFreq+0xbc>)
3400e2dc:	4298      	cmp	r0, r3
3400e2de:	d01d      	beq.n	3400e31c <RCCEx_GetSDMMCCLKFreq+0x48>
3400e2e0:	d813      	bhi.n	3400e30a <RCCEx_GetSDMMCCLKFreq+0x36>
3400e2e2:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e2e6:	4298      	cmp	r0, r3
3400e2e8:	d00b      	beq.n	3400e302 <RCCEx_GetSDMMCCLKFreq+0x2e>
3400e2ea:	d807      	bhi.n	3400e2fc <RCCEx_GetSDMMCCLKFreq+0x28>
3400e2ec:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e2f0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3400e2f4:	4298      	cmp	r0, r3
3400e2f6:	d02a      	beq.n	3400e34e <RCCEx_GetSDMMCCLKFreq+0x7a>
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e2f8:	2000      	movs	r0, #0
}
3400e2fa:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e2fc:	4b25      	ldr	r3, [pc, #148]	@ (3400e394 <RCCEx_GetSDMMCCLKFreq+0xc0>)
3400e2fe:	4298      	cmp	r0, r3
3400e300:	d1fa      	bne.n	3400e2f8 <RCCEx_GetSDMMCCLKFreq+0x24>
}
3400e302:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e306:	f7ff b963 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400e30a:	4b23      	ldr	r3, [pc, #140]	@ (3400e398 <RCCEx_GetSDMMCCLKFreq+0xc4>)
3400e30c:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e310:	429a      	cmp	r2, r3
3400e312:	d022      	beq.n	3400e35a <RCCEx_GetSDMMCCLKFreq+0x86>
3400e314:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e318:	4298      	cmp	r0, r3
3400e31a:	d1ed      	bne.n	3400e2f8 <RCCEx_GetSDMMCCLKFreq+0x24>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400e31c:	4b1f      	ldr	r3, [pc, #124]	@ (3400e39c <RCCEx_GetSDMMCCLKFreq+0xc8>)
3400e31e:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400e322:	f010 0008 	ands.w	r0, r0, #8
3400e326:	d0e8      	beq.n	3400e2fa <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e328:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400e32c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400e330:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e334:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e336:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC5_GetSource())
3400e33a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e33e:	d023      	beq.n	3400e388 <RCCEx_GetSDMMCCLKFreq+0xb4>
3400e340:	d819      	bhi.n	3400e376 <RCCEx_GetSDMMCCLKFreq+0xa2>
3400e342:	b9f3      	cbnz	r3, 3400e382 <RCCEx_GetSDMMCCLKFreq+0xae>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e344:	f7ff f844 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400e348:	fbb0 f0f4 	udiv	r0, r0, r4
  return sdmmc_frequency;
3400e34c:	e7d5      	b.n	3400e2fa <RCCEx_GetSDMMCCLKFreq+0x26>
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e34e:	f7fb fee1 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
}
3400e352:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400e356:	f7fb bfe9 	b.w	3400a32c <RCCEx_GetHCLKFreq>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3400e35a:	4b10      	ldr	r3, [pc, #64]	@ (3400e39c <RCCEx_GetSDMMCCLKFreq+0xc8>)
3400e35c:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3400e360:	f010 0010 	ands.w	r0, r0, #16
3400e364:	d0c9      	beq.n	3400e2fa <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400e366:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e36a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3400e36e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e372:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3400e374:	e7df      	b.n	3400e336 <RCCEx_GetSDMMCCLKFreq+0x62>
        switch (LL_RCC_IC5_GetSource())
3400e376:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e37a:	d1bd      	bne.n	3400e2f8 <RCCEx_GetSDMMCCLKFreq+0x24>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e37c:	f7ff f8e8 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400e380:	e7e2      	b.n	3400e348 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e382:	f7ff f865 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400e386:	e7df      	b.n	3400e348 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e388:	f7ff f8a2 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400e38c:	e7dc      	b.n	3400e348 <RCCEx_GetSDMMCCLKFreq+0x74>
3400e38e:	bf00      	nop
3400e390:	0302001c 	.word	0x0302001c
3400e394:	0301041c 	.word	0x0301041c
3400e398:	0303001c 	.word	0x0303001c
3400e39c:	56028000 	.word	0x56028000

3400e3a0 <RCCEx_GetI2CCLKFreq>:
{
3400e3a0:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e3a2:	f7fb ff5b 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e3a6:	4b50      	ldr	r3, [pc, #320]	@ (3400e4e8 <RCCEx_GetI2CCLKFreq+0x148>)
3400e3a8:	4298      	cmp	r0, r3
3400e3aa:	f000 8085 	beq.w	3400e4b8 <RCCEx_GetI2CCLKFreq+0x118>
3400e3ae:	d84b      	bhi.n	3400e448 <RCCEx_GetI2CCLKFreq+0xa8>
3400e3b0:	f5a3 33fc 	sub.w	r3, r3, #129024	@ 0x1f800
3400e3b4:	4298      	cmp	r0, r3
3400e3b6:	d01a      	beq.n	3400e3ee <RCCEx_GetI2CCLKFreq+0x4e>
3400e3b8:	d81d      	bhi.n	3400e3f6 <RCCEx_GetI2CCLKFreq+0x56>
3400e3ba:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e3be:	4298      	cmp	r0, r3
3400e3c0:	d008      	beq.n	3400e3d4 <RCCEx_GetI2CCLKFreq+0x34>
3400e3c2:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3400e3c6:	d80f      	bhi.n	3400e3e8 <RCCEx_GetI2CCLKFreq+0x48>
3400e3c8:	4a48      	ldr	r2, [pc, #288]	@ (3400e4ec <RCCEx_GetI2CCLKFreq+0x14c>)
3400e3ca:	4293      	cmp	r3, r2
3400e3cc:	d002      	beq.n	3400e3d4 <RCCEx_GetI2CCLKFreq+0x34>
3400e3ce:	4b48      	ldr	r3, [pc, #288]	@ (3400e4f0 <RCCEx_GetI2CCLKFreq+0x150>)
3400e3d0:	4298      	cmp	r0, r3
3400e3d2:	d14a      	bne.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e3d4:	f7fb fe9e 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400e3d8:	f7fb ffa8 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e3dc:	4b45      	ldr	r3, [pc, #276]	@ (3400e4f4 <RCCEx_GetI2CCLKFreq+0x154>)
3400e3de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e3e0:	f003 0307 	and.w	r3, r3, #7
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e3e4:	40d8      	lsrs	r0, r3
3400e3e6:	e041      	b.n	3400e46c <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e3e8:	4a43      	ldr	r2, [pc, #268]	@ (3400e4f8 <RCCEx_GetI2CCLKFreq+0x158>)
3400e3ea:	4293      	cmp	r3, r2
3400e3ec:	d13d      	bne.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
}
3400e3ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e3f2:	f7ff b8ed 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e3f6:	4b41      	ldr	r3, [pc, #260]	@ (3400e4fc <RCCEx_GetI2CCLKFreq+0x15c>)
3400e3f8:	4298      	cmp	r0, r3
3400e3fa:	d008      	beq.n	3400e40e <RCCEx_GetI2CCLKFreq+0x6e>
3400e3fc:	d820      	bhi.n	3400e440 <RCCEx_GetI2CCLKFreq+0xa0>
3400e3fe:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400e402:	4298      	cmp	r0, r3
3400e404:	d0f3      	beq.n	3400e3ee <RCCEx_GetI2CCLKFreq+0x4e>
3400e406:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3400e40a:	4298      	cmp	r0, r3
3400e40c:	d12d      	bne.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3400e40e:	4b39      	ldr	r3, [pc, #228]	@ (3400e4f4 <RCCEx_GetI2CCLKFreq+0x154>)
3400e410:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400e414:	0592      	lsls	r2, r2, #22
3400e416:	d528      	bpl.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e418:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3400e41c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3400e420:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400e424:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e426:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e42a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e42e:	d057      	beq.n	3400e4e0 <RCCEx_GetI2CCLKFreq+0x140>
3400e430:	d84d      	bhi.n	3400e4ce <RCCEx_GetI2CCLKFreq+0x12e>
3400e432:	2b00      	cmp	r3, #0
3400e434:	d151      	bne.n	3400e4da <RCCEx_GetI2CCLKFreq+0x13a>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e436:	f7fe ffcb 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            i2c_frequency = i2c_frequency / ic_divider;
3400e43a:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e43e:	e015      	b.n	3400e46c <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e440:	4b2f      	ldr	r3, [pc, #188]	@ (3400e500 <RCCEx_GetI2CCLKFreq+0x160>)
3400e442:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e446:	e7e0      	b.n	3400e40a <RCCEx_GetI2CCLKFreq+0x6a>
3400e448:	4b2e      	ldr	r3, [pc, #184]	@ (3400e504 <RCCEx_GetI2CCLKFreq+0x164>)
3400e44a:	4298      	cmp	r0, r3
3400e44c:	d014      	beq.n	3400e478 <RCCEx_GetI2CCLKFreq+0xd8>
3400e44e:	d819      	bhi.n	3400e484 <RCCEx_GetI2CCLKFreq+0xe4>
3400e450:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e454:	4298      	cmp	r0, r3
3400e456:	d02f      	beq.n	3400e4b8 <RCCEx_GetI2CCLKFreq+0x118>
3400e458:	d809      	bhi.n	3400e46e <RCCEx_GetI2CCLKFreq+0xce>
3400e45a:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e45e:	4298      	cmp	r0, r3
3400e460:	d02a      	beq.n	3400e4b8 <RCCEx_GetI2CCLKFreq+0x118>
3400e462:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e466:	4298      	cmp	r0, r3
3400e468:	d026      	beq.n	3400e4b8 <RCCEx_GetI2CCLKFreq+0x118>
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e46a:	2000      	movs	r0, #0
}
3400e46c:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e46e:	4b26      	ldr	r3, [pc, #152]	@ (3400e508 <RCCEx_GetI2CCLKFreq+0x168>)
3400e470:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e474:	4298      	cmp	r0, r3
3400e476:	d1f8      	bne.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_MSI_IsReady() != 0U)
3400e478:	f7fb fece 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400e47c:	2800      	cmp	r0, #0
3400e47e:	d0f4      	beq.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
        i2c_frequency = MSI_VALUE;
3400e480:	4822      	ldr	r0, [pc, #136]	@ (3400e50c <RCCEx_GetI2CCLKFreq+0x16c>)
  return i2c_frequency;
3400e482:	e7f3      	b.n	3400e46c <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e484:	4b22      	ldr	r3, [pc, #136]	@ (3400e510 <RCCEx_GetI2CCLKFreq+0x170>)
3400e486:	4298      	cmp	r0, r3
3400e488:	d008      	beq.n	3400e49c <RCCEx_GetI2CCLKFreq+0xfc>
3400e48a:	d811      	bhi.n	3400e4b0 <RCCEx_GetI2CCLKFreq+0x110>
3400e48c:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3400e490:	4298      	cmp	r0, r3
3400e492:	d0f1      	beq.n	3400e478 <RCCEx_GetI2CCLKFreq+0xd8>
3400e494:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3400e498:	4298      	cmp	r0, r3
3400e49a:	d1e6      	bne.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_HSI_IsReady() != 0U)
3400e49c:	f7fb feb4 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400e4a0:	2800      	cmp	r0, #0
3400e4a2:	d0e2      	beq.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400e4a4:	4b13      	ldr	r3, [pc, #76]	@ (3400e4f4 <RCCEx_GetI2CCLKFreq+0x154>)
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e4a6:	481b      	ldr	r0, [pc, #108]	@ (3400e514 <RCCEx_GetI2CCLKFreq+0x174>)
3400e4a8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400e4aa:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400e4ae:	e799      	b.n	3400e3e4 <RCCEx_GetI2CCLKFreq+0x44>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3400e4b0:	4b19      	ldr	r3, [pc, #100]	@ (3400e518 <RCCEx_GetI2CCLKFreq+0x178>)
3400e4b2:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e4b6:	e7ef      	b.n	3400e498 <RCCEx_GetI2CCLKFreq+0xf8>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e4b8:	f7fb ff26 	bl	3400a308 <LL_RCC_IC15_IsEnabled>
3400e4bc:	2800      	cmp	r0, #0
3400e4be:	d0d4      	beq.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e4c0:	f7fb ff2a 	bl	3400a318 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e4c4:	4b0b      	ldr	r3, [pc, #44]	@ (3400e4f4 <RCCEx_GetI2CCLKFreq+0x154>)
3400e4c6:	4604      	mov	r4, r0
3400e4c8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e4cc:	e7ab      	b.n	3400e426 <RCCEx_GetI2CCLKFreq+0x86>
        switch (LL_RCC_IC15_GetSource())
3400e4ce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e4d2:	d1ca      	bne.n	3400e46a <RCCEx_GetI2CCLKFreq+0xca>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e4d4:	f7ff f83c 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400e4d8:	e7af      	b.n	3400e43a <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e4da:	f7fe ffb9 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400e4de:	e7ac      	b.n	3400e43a <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e4e0:	f7fe fff6 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400e4e4:	e7a9      	b.n	3400e43a <RCCEx_GetI2CCLKFreq+0x9a>
3400e4e6:	bf00      	nop
3400e4e8:	0703000c 	.word	0x0703000c
3400e4ec:	0700000c 	.word	0x0700000c
3400e4f0:	0700080c 	.word	0x0700080c
3400e4f4:	56028000 	.word	0x56028000
3400e4f8:	0701000c 	.word	0x0701000c
3400e4fc:	0702040c 	.word	0x0702040c
3400e500:	0702080c 	.word	0x0702080c
3400e504:	0704080c 	.word	0x0704080c
3400e508:	0704000c 	.word	0x0704000c
3400e50c:	003d0900 	.word	0x003d0900
3400e510:	0705040c 	.word	0x0705040c
3400e514:	03d09000 	.word	0x03d09000
3400e518:	0705080c 	.word	0x0705080c

3400e51c <RCCEx_GetLPTIMCLKFreq>:
{
3400e51c:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3400e51e:	f7fb fe9d 	bl	3400a25c <LL_RCC_GetClockSource>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e522:	4b63      	ldr	r3, [pc, #396]	@ (3400e6b0 <RCCEx_GetLPTIMCLKFreq+0x194>)
3400e524:	4298      	cmp	r0, r3
3400e526:	d03a      	beq.n	3400e59e <RCCEx_GetLPTIMCLKFreq+0x82>
3400e528:	d850      	bhi.n	3400e5cc <RCCEx_GetLPTIMCLKFreq+0xb0>
3400e52a:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3400e52e:	4298      	cmp	r0, r3
3400e530:	f000 80a7 	beq.w	3400e682 <RCCEx_GetLPTIMCLKFreq+0x166>
3400e534:	d813      	bhi.n	3400e55e <RCCEx_GetLPTIMCLKFreq+0x42>
3400e536:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3400e53a:	4298      	cmp	r0, r3
3400e53c:	f000 8097 	beq.w	3400e66e <RCCEx_GetLPTIMCLKFreq+0x152>
3400e540:	3b01      	subs	r3, #1
3400e542:	4298      	cmp	r0, r3
3400e544:	d909      	bls.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
3400e546:	f203 4301 	addw	r3, r3, #1025	@ 0x401
3400e54a:	4298      	cmp	r0, r3
3400e54c:	f000 8099 	beq.w	3400e682 <RCCEx_GetLPTIMCLKFreq+0x166>
3400e550:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e554:	4298      	cmp	r0, r3
3400e556:	f000 8094 	beq.w	3400e682 <RCCEx_GetLPTIMCLKFreq+0x166>
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e55a:	2000      	movs	r0, #0
}
3400e55c:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e55e:	4b55      	ldr	r3, [pc, #340]	@ (3400e6b4 <RCCEx_GetLPTIMCLKFreq+0x198>)
3400e560:	4298      	cmp	r0, r3
3400e562:	d015      	beq.n	3400e590 <RCCEx_GetLPTIMCLKFreq+0x74>
3400e564:	d808      	bhi.n	3400e578 <RCCEx_GetLPTIMCLKFreq+0x5c>
3400e566:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e56a:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e56e:	429a      	cmp	r2, r3
3400e570:	d00e      	beq.n	3400e590 <RCCEx_GetLPTIMCLKFreq+0x74>
3400e572:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3400e576:	e7ed      	b.n	3400e554 <RCCEx_GetLPTIMCLKFreq+0x38>
3400e578:	4b4f      	ldr	r3, [pc, #316]	@ (3400e6b8 <RCCEx_GetLPTIMCLKFreq+0x19c>)
3400e57a:	4298      	cmp	r0, r3
3400e57c:	d00f      	beq.n	3400e59e <RCCEx_GetLPTIMCLKFreq+0x82>
3400e57e:	d80b      	bhi.n	3400e598 <RCCEx_GetLPTIMCLKFreq+0x7c>
3400e580:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e584:	4298      	cmp	r0, r3
3400e586:	d003      	beq.n	3400e590 <RCCEx_GetLPTIMCLKFreq+0x74>
3400e588:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e58c:	4298      	cmp	r0, r3
3400e58e:	d1e4      	bne.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
}
3400e590:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400e594:	f7ff b81c 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e598:	4b48      	ldr	r3, [pc, #288]	@ (3400e6bc <RCCEx_GetLPTIMCLKFreq+0x1a0>)
3400e59a:	4298      	cmp	r0, r3
3400e59c:	d1dd      	bne.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400e59e:	f7fb feb3 	bl	3400a308 <LL_RCC_IC15_IsEnabled>
3400e5a2:	2800      	cmp	r0, #0
3400e5a4:	d0d9      	beq.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
        ic_divider = LL_RCC_IC15_GetDivider();
3400e5a6:	f7fb feb7 	bl	3400a318 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3400e5aa:	4b45      	ldr	r3, [pc, #276]	@ (3400e6c0 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e5ac:	4604      	mov	r4, r0
3400e5ae:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400e5b2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3400e5b6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e5ba:	d075      	beq.n	3400e6a8 <RCCEx_GetLPTIMCLKFreq+0x18c>
3400e5bc:	d86a      	bhi.n	3400e694 <RCCEx_GetLPTIMCLKFreq+0x178>
3400e5be:	2b00      	cmp	r3, #0
3400e5c0:	d16f      	bne.n	3400e6a2 <RCCEx_GetLPTIMCLKFreq+0x186>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400e5c2:	f7fe ff05 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            lptim_frequency = lptim_frequency / ic_divider;
3400e5c6:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400e5ca:	e7c7      	b.n	3400e55c <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e5cc:	4b3d      	ldr	r3, [pc, #244]	@ (3400e6c4 <RCCEx_GetLPTIMCLKFreq+0x1a8>)
3400e5ce:	4298      	cmp	r0, r3
3400e5d0:	d034      	beq.n	3400e63c <RCCEx_GetLPTIMCLKFreq+0x120>
3400e5d2:	d824      	bhi.n	3400e61e <RCCEx_GetLPTIMCLKFreq+0x102>
3400e5d4:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3400e5d8:	4298      	cmp	r0, r3
3400e5da:	d00f      	beq.n	3400e5fc <RCCEx_GetLPTIMCLKFreq+0xe0>
3400e5dc:	d815      	bhi.n	3400e60a <RCCEx_GetLPTIMCLKFreq+0xee>
3400e5de:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e5e2:	4298      	cmp	r0, r3
3400e5e4:	d00a      	beq.n	3400e5fc <RCCEx_GetLPTIMCLKFreq+0xe0>
3400e5e6:	d806      	bhi.n	3400e5f6 <RCCEx_GetLPTIMCLKFreq+0xda>
3400e5e8:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e5ec:	4298      	cmp	r0, r3
3400e5ee:	d0d6      	beq.n	3400e59e <RCCEx_GetLPTIMCLKFreq+0x82>
3400e5f0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3400e5f4:	e7d1      	b.n	3400e59a <RCCEx_GetLPTIMCLKFreq+0x7e>
3400e5f6:	4b34      	ldr	r3, [pc, #208]	@ (3400e6c8 <RCCEx_GetLPTIMCLKFreq+0x1ac>)
3400e5f8:	4298      	cmp	r0, r3
3400e5fa:	d1ae      	bne.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_LSE_IsReady() != 0U)
3400e5fc:	f7fb fe14 	bl	3400a228 <LL_RCC_LSE_IsReady>
3400e600:	3800      	subs	r0, #0
3400e602:	bf18      	it	ne
3400e604:	2001      	movne	r0, #1
3400e606:	03c0      	lsls	r0, r0, #15
3400e608:	e7a8      	b.n	3400e55c <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e60a:	4b30      	ldr	r3, [pc, #192]	@ (3400e6cc <RCCEx_GetLPTIMCLKFreq+0x1b0>)
3400e60c:	4298      	cmp	r0, r3
3400e60e:	d0f5      	beq.n	3400e5fc <RCCEx_GetLPTIMCLKFreq+0xe0>
3400e610:	f503 4370 	add.w	r3, r3, #61440	@ 0xf000
3400e614:	4298      	cmp	r0, r3
3400e616:	d011      	beq.n	3400e63c <RCCEx_GetLPTIMCLKFreq+0x120>
3400e618:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e61c:	e7ec      	b.n	3400e5f8 <RCCEx_GetLPTIMCLKFreq+0xdc>
3400e61e:	4b2c      	ldr	r3, [pc, #176]	@ (3400e6d0 <RCCEx_GetLPTIMCLKFreq+0x1b4>)
3400e620:	4298      	cmp	r0, r3
3400e622:	d015      	beq.n	3400e650 <RCCEx_GetLPTIMCLKFreq+0x134>
3400e624:	d81b      	bhi.n	3400e65e <RCCEx_GetLPTIMCLKFreq+0x142>
3400e626:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3400e62a:	4298      	cmp	r0, r3
3400e62c:	d006      	beq.n	3400e63c <RCCEx_GetLPTIMCLKFreq+0x120>
3400e62e:	d80c      	bhi.n	3400e64a <RCCEx_GetLPTIMCLKFreq+0x12e>
3400e630:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3400e634:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3400e638:	4298      	cmp	r0, r3
3400e63a:	d18e      	bne.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400e63c:	4b20      	ldr	r3, [pc, #128]	@ (3400e6c0 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e63e:	685b      	ldr	r3, [r3, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3400e640:	07db      	lsls	r3, r3, #31
3400e642:	d58a      	bpl.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
        lptim_frequency = LSI_VALUE;
3400e644:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return lptim_frequency;
3400e648:	e788      	b.n	3400e55c <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e64a:	4b22      	ldr	r3, [pc, #136]	@ (3400e6d4 <RCCEx_GetLPTIMCLKFreq+0x1b8>)
3400e64c:	4298      	cmp	r0, r3
3400e64e:	d184      	bne.n	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400e650:	f7fb fd60 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400e654:	4b1a      	ldr	r3, [pc, #104]	@ (3400e6c0 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e656:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e658:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400e65c:	e00f      	b.n	3400e67e <RCCEx_GetLPTIMCLKFreq+0x162>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3400e65e:	4b1e      	ldr	r3, [pc, #120]	@ (3400e6d8 <RCCEx_GetLPTIMCLKFreq+0x1bc>)
3400e660:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3400e664:	429a      	cmp	r2, r3
3400e666:	d0f3      	beq.n	3400e650 <RCCEx_GetLPTIMCLKFreq+0x134>
3400e668:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3400e66c:	e7ee      	b.n	3400e64c <RCCEx_GetLPTIMCLKFreq+0x130>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e66e:	f7fb fd51 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400e672:	f7fb fe5b 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e676:	4b12      	ldr	r3, [pc, #72]	@ (3400e6c0 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e678:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e67a:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400e67e:	40d8      	lsrs	r0, r3
      break;
3400e680:	e76c      	b.n	3400e55c <RCCEx_GetLPTIMCLKFreq+0x40>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e682:	f7fb fd47 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400e686:	f7fb fe51 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400e68a:	4b0d      	ldr	r3, [pc, #52]	@ (3400e6c0 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3400e68c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400e68e:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400e692:	e7f4      	b.n	3400e67e <RCCEx_GetLPTIMCLKFreq+0x162>
        switch (LL_RCC_IC15_GetSource())
3400e694:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e698:	f47f af5f 	bne.w	3400e55a <RCCEx_GetLPTIMCLKFreq+0x3e>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400e69c:	f7fe ff58 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400e6a0:	e791      	b.n	3400e5c6 <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400e6a2:	f7fe fed5 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400e6a6:	e78e      	b.n	3400e5c6 <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400e6a8:	f7fe ff12 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400e6ac:	e78b      	b.n	3400e5c6 <RCCEx_GetLPTIMCLKFreq+0xaa>
3400e6ae:	bf00      	nop
3400e6b0:	0702102c 	.word	0x0702102c
3400e6b4:	0701102c 	.word	0x0701102c
3400e6b8:	0702082c 	.word	0x0702082c
3400e6bc:	07020c2c 	.word	0x07020c2c
3400e6c0:	56028000 	.word	0x56028000
3400e6c4:	07040c2c 	.word	0x07040c2c
3400e6c8:	07030c2c 	.word	0x07030c2c
3400e6cc:	0703182c 	.word	0x0703182c
3400e6d0:	07050c2c 	.word	0x07050c2c
3400e6d4:	0705082c 	.word	0x0705082c
3400e6d8:	0705102c 	.word	0x0705102c

3400e6dc <HAL_RCCEx_GetPeriphCLKFreq>:
{
3400e6dc:	b538      	push	{r3, r4, r5, lr}
  switch (PeriphClk)
3400e6de:	f100 4360 	add.w	r3, r0, #3758096384	@ 0xe0000000
3400e6e2:	430b      	orrs	r3, r1
3400e6e4:	f000 8447 	beq.w	3400ef76 <HAL_RCCEx_GetPeriphCLKFreq+0x89a>
3400e6e8:	4bbf      	ldr	r3, [pc, #764]	@ (3400e9e8 <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
3400e6ea:	4298      	cmp	r0, r3
3400e6ec:	f171 0300 	sbcs.w	r3, r1, #0
3400e6f0:	f080 80e6 	bcs.w	3400e8c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1e4>
3400e6f4:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
3400e6f8:	430b      	orrs	r3, r1
3400e6fa:	f000 835b 	beq.w	3400edb4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3400e6fe:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
3400e702:	f171 0300 	sbcs.w	r3, r1, #0
3400e706:	d26a      	bcs.n	3400e7de <HAL_RCCEx_GetPeriphCLKFreq+0x102>
3400e708:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
3400e70c:	430b      	orrs	r3, r1
3400e70e:	f000 82b9 	beq.w	3400ec84 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
3400e712:	f240 2301 	movw	r3, #513	@ 0x201
3400e716:	4298      	cmp	r0, r3
3400e718:	f171 0300 	sbcs.w	r3, r1, #0
3400e71c:	d224      	bcs.n	3400e768 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
3400e71e:	2809      	cmp	r0, #9
3400e720:	f171 0300 	sbcs.w	r3, r1, #0
3400e724:	d215      	bcs.n	3400e752 <HAL_RCCEx_GetPeriphCLKFreq+0x76>
3400e726:	ea50 0301 	orrs.w	r3, r0, r1
3400e72a:	d01b      	beq.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400e72c:	3801      	subs	r0, #1
3400e72e:	f141 31ff 	adc.w	r1, r1, #4294967295
3400e732:	2808      	cmp	r0, #8
3400e734:	f171 0100 	sbcs.w	r1, r1, #0
3400e738:	d214      	bcs.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400e73a:	2807      	cmp	r0, #7
3400e73c:	d812      	bhi.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3400e73e:	e8df f010 	tbh	[pc, r0, lsl #1]
3400e742:	01a6      	.short	0x01a6
3400e744:	0011020f 	.word	0x0011020f
3400e748:	00110285 	.word	0x00110285
3400e74c:	00110011 	.word	0x00110011
3400e750:	0235      	.short	0x0235
3400e752:	f1a0 0310 	sub.w	r3, r0, #16
3400e756:	430b      	orrs	r3, r1
3400e758:	f000 8242 	beq.w	3400ebe0 <HAL_RCCEx_GetPeriphCLKFreq+0x504>
3400e75c:	3820      	subs	r0, #32
3400e75e:	4308      	orrs	r0, r1
3400e760:	f000 8268 	beq.w	3400ec34 <HAL_RCCEx_GetPeriphCLKFreq+0x558>
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
3400e764:	2000      	movs	r0, #0
3400e766:	e219      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3400e768:	f5a0 5300 	sub.w	r3, r0, #8192	@ 0x2000
3400e76c:	430b      	orrs	r3, r1
3400e76e:	f000 831d 	beq.w	3400edac <HAL_RCCEx_GetPeriphCLKFreq+0x6d0>
3400e772:	f242 0301 	movw	r3, #8193	@ 0x2001
3400e776:	4298      	cmp	r0, r3
3400e778:	f171 0300 	sbcs.w	r3, r1, #0
3400e77c:	d224      	bcs.n	3400e7c8 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
3400e77e:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
3400e782:	430b      	orrs	r3, r1
3400e784:	f000 82df 	beq.w	3400ed46 <HAL_RCCEx_GetPeriphCLKFreq+0x66a>
3400e788:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
3400e78c:	430b      	orrs	r3, r1
3400e78e:	f000 8308 	beq.w	3400eda2 <HAL_RCCEx_GetPeriphCLKFreq+0x6c6>
3400e792:	f5a0 6080 	sub.w	r0, r0, #1024	@ 0x400
3400e796:	4308      	orrs	r0, r1
3400e798:	d1e4      	bne.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3400e79a:	4d94      	ldr	r5, [pc, #592]	@ (3400e9ec <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400e79c:	f8d5 314c 	ldr.w	r3, [r5, #332]	@ 0x14c
3400e7a0:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
3400e7a4:	2b02      	cmp	r3, #2
3400e7a6:	f000 82c1 	beq.w	3400ed2c <HAL_RCCEx_GetPeriphCLKFreq+0x650>
3400e7aa:	2b03      	cmp	r3, #3
3400e7ac:	f000 8256 	beq.w	3400ec5c <HAL_RCCEx_GetPeriphCLKFreq+0x580>
3400e7b0:	2b01      	cmp	r3, #1
3400e7b2:	f000 824b 	beq.w	3400ec4c <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400e7b6:	f7fb fcad 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400e7ba:	f7fb fdb7 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400e7be:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400e7c0:	f003 0307 	and.w	r3, r3, #7
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400e7c4:	40d8      	lsrs	r0, r3
3400e7c6:	e1e9      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3400e7c8:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
3400e7cc:	430b      	orrs	r3, r1
3400e7ce:	f000 82ef 	beq.w	3400edb0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
3400e7d2:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
3400e7d6:	4308      	orrs	r0, r1
3400e7d8:	d1c4      	bne.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3400e7da:	4885      	ldr	r0, [pc, #532]	@ (3400e9f0 <HAL_RCCEx_GetPeriphCLKFreq+0x314>)
3400e7dc:	e2e2      	b.n	3400eda4 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
  switch (PeriphClk)
3400e7de:	f5a0 0300 	sub.w	r3, r0, #8388608	@ 0x800000
3400e7e2:	430b      	orrs	r3, r1
3400e7e4:	f000 82f6 	beq.w	3400edd4 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
3400e7e8:	4b82      	ldr	r3, [pc, #520]	@ (3400e9f4 <HAL_RCCEx_GetPeriphCLKFreq+0x318>)
3400e7ea:	4298      	cmp	r0, r3
3400e7ec:	f171 0300 	sbcs.w	r3, r1, #0
3400e7f0:	d224      	bcs.n	3400e83c <HAL_RCCEx_GetPeriphCLKFreq+0x160>
3400e7f2:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
3400e7f6:	430b      	orrs	r3, r1
3400e7f8:	f000 82e8 	beq.w	3400edcc <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
3400e7fc:	4b7e      	ldr	r3, [pc, #504]	@ (3400e9f8 <HAL_RCCEx_GetPeriphCLKFreq+0x31c>)
3400e7fe:	4298      	cmp	r0, r3
3400e800:	f171 0300 	sbcs.w	r3, r1, #0
3400e804:	d20f      	bcs.n	3400e826 <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
3400e806:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
3400e80a:	430b      	orrs	r3, r1
3400e80c:	f000 82d7 	beq.w	3400edbe <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
3400e810:	f5a0 2300 	sub.w	r3, r0, #524288	@ 0x80000
3400e814:	430b      	orrs	r3, r1
3400e816:	f000 82d7 	beq.w	3400edc8 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3400e81a:	f5a0 3000 	sub.w	r0, r0, #131072	@ 0x20000
3400e81e:	4308      	orrs	r0, r1
3400e820:	d1a0      	bne.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400e822:	4876      	ldr	r0, [pc, #472]	@ (3400e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
3400e824:	e2c7      	b.n	3400edb6 <HAL_RCCEx_GetPeriphCLKFreq+0x6da>
  switch (PeriphClk)
3400e826:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
3400e82a:	430b      	orrs	r3, r1
3400e82c:	f000 82d0 	beq.w	3400edd0 <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
3400e830:	f5a0 0080 	sub.w	r0, r0, #4194304	@ 0x400000
3400e834:	4308      	orrs	r0, r1
3400e836:	d195      	bne.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
3400e838:	4871      	ldr	r0, [pc, #452]	@ (3400ea00 <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
3400e83a:	e2c1      	b.n	3400edc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  switch (PeriphClk)
3400e83c:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
3400e840:	430b      	orrs	r3, r1
3400e842:	f000 834d 	beq.w	3400eee0 <HAL_RCCEx_GetPeriphCLKFreq+0x804>
3400e846:	4b6f      	ldr	r3, [pc, #444]	@ (3400ea04 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
3400e848:	4298      	cmp	r0, r3
3400e84a:	f171 0300 	sbcs.w	r3, r1, #0
3400e84e:	d228      	bcs.n	3400e8a2 <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
3400e850:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
3400e854:	430b      	orrs	r3, r1
3400e856:	f000 8302 	beq.w	3400ee5e <HAL_RCCEx_GetPeriphCLKFreq+0x782>
3400e85a:	f100 407e 	add.w	r0, r0, #4261412864	@ 0xfe000000
3400e85e:	4308      	orrs	r0, r1
3400e860:	d180      	bne.n	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3400e862:	4d62      	ldr	r5, [pc, #392]	@ (3400e9ec <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3400e864:	f8d5 3154 	ldr.w	r3, [r5, #340]	@ 0x154
3400e868:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400e86c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400e870:	f000 8195 	beq.w	3400eb9e <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3400e874:	f200 8319 	bhi.w	3400eeaa <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
3400e878:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400e87c:	f000 831f 	beq.w	3400eebe <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
3400e880:	f240 81e1 	bls.w	3400ec46 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3400e884:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400e888:	f47f af6c 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400e88c:	f7fb fd06 	bl	3400a29c <LL_RCC_IC8_IsEnabled>
3400e890:	2800      	cmp	r0, #0
3400e892:	f43f af67 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC8_GetDivider();
3400e896:	f7fb fd09 	bl	3400a2ac <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400e89a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400e89e:	4604      	mov	r4, r0
3400e8a0:	e191      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (PeriphClk)
3400e8a2:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
3400e8a6:	430b      	orrs	r3, r1
3400e8a8:	f000 8344 	beq.w	3400ef34 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
3400e8ac:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
3400e8b0:	4308      	orrs	r0, r1
3400e8b2:	f47f af57 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
3400e8b6:	4854      	ldr	r0, [pc, #336]	@ (3400ea08 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
}
3400e8b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400e8bc:	f7ff bbd6 	b.w	3400e06c <RCCEx_GetSAICLKFreq>
  switch (PeriphClk)
3400e8c0:	2300      	movs	r3, #0
3400e8c2:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400e8c6:	4291      	cmp	r1, r2
3400e8c8:	bf08      	it	eq
3400e8ca:	4298      	cmpeq	r0, r3
3400e8cc:	f000 836f 	beq.w	3400efae <HAL_RCCEx_GetPeriphCLKFreq+0x8d2>
3400e8d0:	4283      	cmp	r3, r0
3400e8d2:	418a      	sbcs	r2, r1
3400e8d4:	d35f      	bcc.n	3400e996 <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
3400e8d6:	2210      	movs	r2, #16
3400e8d8:	4291      	cmp	r1, r2
3400e8da:	bf08      	it	eq
3400e8dc:	4298      	cmpeq	r0, r3
3400e8de:	f000 8359 	beq.w	3400ef94 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
3400e8e2:	4283      	cmp	r3, r0
3400e8e4:	418a      	sbcs	r2, r1
3400e8e6:	d329      	bcc.n	3400e93c <HAL_RCCEx_GetPeriphCLKFreq+0x260>
3400e8e8:	2202      	movs	r2, #2
3400e8ea:	4291      	cmp	r1, r2
3400e8ec:	bf08      	it	eq
3400e8ee:	4298      	cmpeq	r0, r3
3400e8f0:	f000 8349 	beq.w	3400ef86 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
3400e8f4:	4283      	cmp	r3, r0
3400e8f6:	418a      	sbcs	r2, r1
3400e8f8:	d314      	bcc.n	3400e924 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
3400e8fa:	4299      	cmp	r1, r3
3400e8fc:	bf08      	it	eq
3400e8fe:	f1b0 4f00 	cmpeq.w	r0, #2147483648	@ 0x80000000
3400e902:	f000 833a 	beq.w	3400ef7a <HAL_RCCEx_GetPeriphCLKFreq+0x89e>
3400e906:	2901      	cmp	r1, #1
3400e908:	bf08      	it	eq
3400e90a:	4298      	cmpeq	r0, r3
3400e90c:	f000 8337 	beq.w	3400ef7e <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
3400e910:	f100 4040 	add.w	r0, r0, #3221225472	@ 0xc0000000
3400e914:	4308      	orrs	r0, r1
3400e916:	f47f af25 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
3400e91a:	483c      	ldr	r0, [pc, #240]	@ (3400ea0c <HAL_RCCEx_GetPeriphCLKFreq+0x330>)
}
3400e91c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3400e920:	f7ff bcd8 	b.w	3400e2d4 <RCCEx_GetSDMMCCLKFreq>
  switch (PeriphClk)
3400e924:	2904      	cmp	r1, #4
3400e926:	bf08      	it	eq
3400e928:	4298      	cmpeq	r0, r3
3400e92a:	f000 8331 	beq.w	3400ef90 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>
3400e92e:	2908      	cmp	r1, #8
3400e930:	bf08      	it	eq
3400e932:	4298      	cmpeq	r0, r3
3400e934:	f47f af16 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
3400e938:	4835      	ldr	r0, [pc, #212]	@ (3400ea10 <HAL_RCCEx_GetPeriphCLKFreq+0x334>)
3400e93a:	e325      	b.n	3400ef88 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3400e93c:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400e940:	4291      	cmp	r1, r2
3400e942:	bf08      	it	eq
3400e944:	4298      	cmpeq	r0, r3
3400e946:	f000 832e 	beq.w	3400efa6 <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
3400e94a:	4283      	cmp	r3, r0
3400e94c:	418a      	sbcs	r2, r1
3400e94e:	d311      	bcc.n	3400e974 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
3400e950:	2940      	cmp	r1, #64	@ 0x40
3400e952:	bf08      	it	eq
3400e954:	4298      	cmpeq	r0, r3
3400e956:	f000 831f 	beq.w	3400ef98 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>
3400e95a:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3400e95e:	bf08      	it	eq
3400e960:	4298      	cmpeq	r0, r3
3400e962:	f000 831b 	beq.w	3400ef9c <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>
3400e966:	2920      	cmp	r1, #32
3400e968:	bf08      	it	eq
3400e96a:	2800      	cmpeq	r0, #0
3400e96c:	f47f aefa 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3400e970:	4828      	ldr	r0, [pc, #160]	@ (3400ea14 <HAL_RCCEx_GetPeriphCLKFreq+0x338>)
3400e972:	e309      	b.n	3400ef88 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3400e974:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
3400e978:	bf08      	it	eq
3400e97a:	4298      	cmpeq	r0, r3
3400e97c:	f000 8315 	beq.w	3400efaa <HAL_RCCEx_GetPeriphCLKFreq+0x8ce>
3400e980:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
3400e984:	bf08      	it	eq
3400e986:	4298      	cmpeq	r0, r3
3400e988:	f47f aeec 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
3400e98c:	4822      	ldr	r0, [pc, #136]	@ (3400ea18 <HAL_RCCEx_GetPeriphCLKFreq+0x33c>)
}
3400e98e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400e992:	f7ff b919 	b.w	3400dbc8 <RCCEx_GetUARTCLKFreq>
  switch (PeriphClk)
3400e996:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3400e99a:	4291      	cmp	r1, r2
3400e99c:	bf08      	it	eq
3400e99e:	4298      	cmpeq	r0, r3
3400e9a0:	f000 830f 	beq.w	3400efc2 <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
3400e9a4:	4283      	cmp	r3, r0
3400e9a6:	418a      	sbcs	r2, r1
3400e9a8:	d34b      	bcc.n	3400ea42 <HAL_RCCEx_GetPeriphCLKFreq+0x366>
3400e9aa:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400e9ae:	4291      	cmp	r1, r2
3400e9b0:	bf08      	it	eq
3400e9b2:	4298      	cmpeq	r0, r3
3400e9b4:	f000 8301 	beq.w	3400efba <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
3400e9b8:	4283      	cmp	r3, r0
3400e9ba:	418a      	sbcs	r2, r1
3400e9bc:	d330      	bcc.n	3400ea20 <HAL_RCCEx_GetPeriphCLKFreq+0x344>
3400e9be:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
3400e9c2:	bf08      	it	eq
3400e9c4:	4298      	cmpeq	r0, r3
3400e9c6:	f000 82f4 	beq.w	3400efb2 <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
3400e9ca:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
3400e9ce:	bf08      	it	eq
3400e9d0:	4298      	cmpeq	r0, r3
3400e9d2:	f000 82f0 	beq.w	3400efb6 <HAL_RCCEx_GetPeriphCLKFreq+0x8da>
3400e9d6:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
3400e9da:	bf08      	it	eq
3400e9dc:	2800      	cmpeq	r0, #0
3400e9de:	f47f aec1 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
3400e9e2:	480e      	ldr	r0, [pc, #56]	@ (3400ea1c <HAL_RCCEx_GetPeriphCLKFreq+0x340>)
3400e9e4:	e2db      	b.n	3400ef9e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
3400e9e6:	bf00      	nop
3400e9e8:	20000001 	.word	0x20000001
3400e9ec:	56028000 	.word	0x56028000
3400e9f0:	07000c0c 	.word	0x07000c0c
3400e9f4:	00800001 	.word	0x00800001
3400e9f8:	00100001 	.word	0x00100001
3400e9fc:	0700140c 	.word	0x0700140c
3400ea00:	0700182c 	.word	0x0700182c
3400ea04:	04000001 	.word	0x04000001
3400ea08:	07001418 	.word	0x07001418
3400ea0c:	0300001c 	.word	0x0300001c
3400ea10:	07000c20 	.word	0x07000c20
3400ea14:	07001420 	.word	0x07001420
3400ea18:	07000c30 	.word	0x07000c30
3400ea1c:	07001430 	.word	0x07001430
  switch (PeriphClk)
3400ea20:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
3400ea24:	bf08      	it	eq
3400ea26:	4298      	cmpeq	r0, r3
3400ea28:	f000 82c9 	beq.w	3400efbe <HAL_RCCEx_GetPeriphCLKFreq+0x8e2>
3400ea2c:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
3400ea30:	bf08      	it	eq
3400ea32:	4298      	cmpeq	r0, r3
3400ea34:	f47f ae96 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
3400ea38:	48b4      	ldr	r0, [pc, #720]	@ (3400ed0c <HAL_RCCEx_GetPeriphCLKFreq+0x630>)
}
3400ea3a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400ea3e:	f7fe bf8d 	b.w	3400d95c <RCCEx_GetOTGPHYCKREFCLKFreq>
  switch (PeriphClk)
3400ea42:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
3400ea46:	4291      	cmp	r1, r2
3400ea48:	bf08      	it	eq
3400ea4a:	4298      	cmpeq	r0, r3
3400ea4c:	f000 82c0 	beq.w	3400efd0 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
3400ea50:	4283      	cmp	r3, r0
3400ea52:	418a      	sbcs	r2, r1
3400ea54:	d30d      	bcc.n	3400ea72 <HAL_RCCEx_GetPeriphCLKFreq+0x396>
3400ea56:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
3400ea5a:	bf08      	it	eq
3400ea5c:	4298      	cmpeq	r0, r3
3400ea5e:	f000 82b5 	beq.w	3400efcc <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
3400ea62:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
3400ea66:	bf08      	it	eq
3400ea68:	4298      	cmpeq	r0, r3
3400ea6a:	f47f ae7b 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400ea6e:	48a8      	ldr	r0, [pc, #672]	@ (3400ed10 <HAL_RCCEx_GetPeriphCLKFreq+0x634>)
3400ea70:	e2a8      	b.n	3400efc4 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
  switch (PeriphClk)
3400ea72:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3400ea76:	bf08      	it	eq
3400ea78:	4298      	cmpeq	r0, r3
3400ea7a:	f000 82ae 	beq.w	3400efda <HAL_RCCEx_GetPeriphCLKFreq+0x8fe>
3400ea7e:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
3400ea82:	bf08      	it	eq
3400ea84:	4298      	cmpeq	r0, r3
3400ea86:	f47f ae6d 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3400ea8a:	48a2      	ldr	r0, [pc, #648]	@ (3400ed14 <HAL_RCCEx_GetPeriphCLKFreq+0x638>)
3400ea8c:	e2a1      	b.n	3400efd2 <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3400ea8e:	4da2      	ldr	r5, [pc, #648]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ea90:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400ea94:	f003 0370 	and.w	r3, r3, #112	@ 0x70
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400ea98:	2b40      	cmp	r3, #64	@ 0x40
3400ea9a:	d053      	beq.n	3400eb44 <HAL_RCCEx_GetPeriphCLKFreq+0x468>
3400ea9c:	d814      	bhi.n	3400eac8 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
3400ea9e:	2b20      	cmp	r3, #32
3400eaa0:	d025      	beq.n	3400eaee <HAL_RCCEx_GetPeriphCLKFreq+0x412>
3400eaa2:	d805      	bhi.n	3400eab0 <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
3400eaa4:	bb03      	cbnz	r3, 3400eae8 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400eaa6:	f7fb fb35 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400eaaa:	f7fb fc3f 	bl	3400a32c <RCCEx_GetHCLKFreq>
      break;
3400eaae:	e002      	b.n	3400eab6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400eab0:	2b30      	cmp	r3, #48	@ 0x30
3400eab2:	d034      	beq.n	3400eb1e <HAL_RCCEx_GetPeriphCLKFreq+0x442>
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400eab4:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3400eab6:	4b98      	ldr	r3, [pc, #608]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eab8:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400eabc:	f3c3 2307 	ubfx	r3, r3, #8, #8
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3400eac0:	3301      	adds	r3, #1
3400eac2:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
3400eac6:	e069      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400eac8:	2b60      	cmp	r3, #96	@ 0x60
3400eaca:	d047      	beq.n	3400eb5c <HAL_RCCEx_GetPeriphCLKFreq+0x480>
3400eacc:	2b70      	cmp	r3, #112	@ 0x70
3400eace:	d03f      	beq.n	3400eb50 <HAL_RCCEx_GetPeriphCLKFreq+0x474>
3400ead0:	2b50      	cmp	r3, #80	@ 0x50
3400ead2:	d1ef      	bne.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
      if (LL_RCC_HSI_IsReady() != 0U)
3400ead4:	f7fb fb98 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400ead8:	2800      	cmp	r0, #0
3400eada:	d0eb      	beq.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400eadc:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400eade:	488f      	ldr	r0, [pc, #572]	@ (3400ed1c <HAL_RCCEx_GetPeriphCLKFreq+0x640>)
3400eae0:	f3c3 13c1 	ubfx	r3, r3, #7, #2
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400eae4:	40d8      	lsrs	r0, r3
      break;
3400eae6:	e7e6      	b.n	3400eab6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400eae8:	f7fe fd72 	bl	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400eaec:	e7e3      	b.n	3400eab6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400eaee:	f7fb fbc3 	bl	3400a278 <LL_RCC_IC7_IsEnabled>
3400eaf2:	2800      	cmp	r0, #0
3400eaf4:	d0de      	beq.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC7_GetDivider();
3400eaf6:	f7fb fbc7 	bl	3400a288 <LL_RCC_IC7_GetDivider>
3400eafa:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400eafc:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3400eb00:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3400eb04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eb08:	d019      	beq.n	3400eb3e <HAL_RCCEx_GetPeriphCLKFreq+0x462>
3400eb0a:	d812      	bhi.n	3400eb32 <HAL_RCCEx_GetPeriphCLKFreq+0x456>
3400eb0c:	b913      	cbnz	r3, 3400eb14 <HAL_RCCEx_GetPeriphCLKFreq+0x438>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400eb0e:	f7fe fc5f 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
3400eb12:	e001      	b.n	3400eb18 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400eb14:	f7fe fc9c 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
            adc_frequency = adc_frequency / ic_divider;
3400eb18:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400eb1c:	e7cb      	b.n	3400eab6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400eb1e:	f7fb fbbd 	bl	3400a29c <LL_RCC_IC8_IsEnabled>
3400eb22:	2800      	cmp	r0, #0
3400eb24:	d0c6      	beq.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC8_GetDivider();
3400eb26:	f7fb fbc1 	bl	3400a2ac <LL_RCC_IC8_GetDivider>
3400eb2a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3400eb2e:	4604      	mov	r4, r0
3400eb30:	e7e6      	b.n	3400eb00 <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        switch (LL_RCC_IC8_GetSource())
3400eb32:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eb36:	d1bd      	bne.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400eb38:	f7fe fd0a 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400eb3c:	e7ec      	b.n	3400eb18 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400eb3e:	f7fe fcc7 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400eb42:	e7e9      	b.n	3400eb18 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
      if (LL_RCC_MSI_IsReady() != 0U)
3400eb44:	f7fb fb68 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400eb48:	2800      	cmp	r0, #0
3400eb4a:	d0b3      	beq.n	3400eab4 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        adc_frequency = MSI_VALUE;
3400eb4c:	4874      	ldr	r0, [pc, #464]	@ (3400ed20 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400eb4e:	e7b2      	b.n	3400eab6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400eb50:	f7fb fae0 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400eb54:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400eb56:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400eb5a:	e7c3      	b.n	3400eae4 <HAL_RCCEx_GetPeriphCLKFreq+0x408>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400eb5c:	4871      	ldr	r0, [pc, #452]	@ (3400ed24 <HAL_RCCEx_GetPeriphCLKFreq+0x648>)
3400eb5e:	e7aa      	b.n	3400eab6 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3400eb60:	4d6d      	ldr	r5, [pc, #436]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eb62:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400eb66:	f003 0307 	and.w	r3, r3, #7
  switch (LL_RCC_GetADFClockSource(ADFxSource))
3400eb6a:	3b01      	subs	r3, #1
3400eb6c:	2b06      	cmp	r3, #6
3400eb6e:	f200 80f5 	bhi.w	3400ed5c <HAL_RCCEx_GetPeriphCLKFreq+0x680>
3400eb72:	a201      	add	r2, pc, #4	@ (adr r2, 3400eb78 <HAL_RCCEx_GetPeriphCLKFreq+0x49c>)
3400eb74:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400eb78:	3400ec4d 	.word	0x3400ec4d
3400eb7c:	3400eebf 	.word	0x3400eebf
3400eb80:	3400e88d 	.word	0x3400e88d
3400eb84:	3400eb9f 	.word	0x3400eb9f
3400eb88:	3400ec0d 	.word	0x3400ec0d
3400eb8c:	3400efdf 	.word	0x3400efdf
3400eb90:	3400eed5 	.word	0x3400eed5
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400eb94:	f7fe fc5c 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
            adf_frequency = adf_frequency / ic_divider;
3400eb98:	fbb0 f0f4 	udiv	r0, r0, r4
}
3400eb9c:	bd38      	pop	{r3, r4, r5, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3400eb9e:	f7fb fb3b 	bl	3400a218 <LL_RCC_MSI_IsReady>
3400eba2:	2800      	cmp	r0, #0
3400eba4:	f43f adde 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        adf_frequency = MSI_VALUE;
3400eba8:	485d      	ldr	r0, [pc, #372]	@ (3400ed20 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3400ebaa:	e7f7      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3400ebac:	4b5a      	ldr	r3, [pc, #360]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ebae:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400ebb2:	0395      	lsls	r5, r2, #14
3400ebb4:	f57f add6 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400ebb8:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3400ebbc:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3400ebc0:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ebc4:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400ebc6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC20_GetSource())
3400ebca:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ebce:	f000 81ae 	beq.w	3400ef2e <HAL_RCCEx_GetPeriphCLKFreq+0x852>
3400ebd2:	f200 81a5 	bhi.w	3400ef20 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
3400ebd6:	2b00      	cmp	r3, #0
3400ebd8:	d1dc      	bne.n	3400eb94 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ebda:	f7fe fbf9 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
3400ebde:	e7db      	b.n	3400eb98 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3400ebe0:	4d4d      	ldr	r5, [pc, #308]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ebe2:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3400ebe6:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400ebea:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400ebee:	d014      	beq.n	3400ec1a <HAL_RCCEx_GetPeriphCLKFreq+0x53e>
3400ebf0:	d808      	bhi.n	3400ec04 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3400ebf2:	bb5b      	cbnz	r3, 3400ec4c <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400ebf4:	f7fb fa8e 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400ebf8:	f7fb fb98 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3400ebfc:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
3400ebfe:	f3c3 4302 	ubfx	r3, r3, #16, #3
3400ec02:	e5df      	b.n	3400e7c4 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400ec04:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400ec08:	f47f adac 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400ec0c:	f7fb fafc 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400ec10:	2800      	cmp	r0, #0
3400ec12:	f43f ada7 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400ec16:	6cab      	ldr	r3, [r5, #72]	@ 0x48
3400ec18:	e136      	b.n	3400ee88 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3400ec1a:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400ec1e:	03dc      	lsls	r4, r3, #15
3400ec20:	f57f ada0 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400ec24:	f8d5 0104 	ldr.w	r0, [r5, #260]	@ 0x104
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400ec28:	f8d5 3104 	ldr.w	r3, [r5, #260]	@ 0x104
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3400ec2c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ec30:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3400ec32:	e7c8      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3400ec34:	4a38      	ldr	r2, [pc, #224]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ec36:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ec3a:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3400ec3e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3400ec42:	d012      	beq.n	3400ec6a <HAL_RCCEx_GetPeriphCLKFreq+0x58e>
3400ec44:	d806      	bhi.n	3400ec54 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400ec46:	2b00      	cmp	r3, #0
3400ec48:	f000 8088 	beq.w	3400ed5c <HAL_RCCEx_GetPeriphCLKFreq+0x680>
}
3400ec4c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400ec50:	f7fe bcbe 	b.w	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3400ec54:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3400ec58:	f47f ad84 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSE_IsReady() != 0U)
3400ec5c:	f7fb facc 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400ec60:	2800      	cmp	r0, #0
3400ec62:	f43f ad7f 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        eth1_frequency = HSE_VALUE;
3400ec66:	4830      	ldr	r0, [pc, #192]	@ (3400ed28 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400ec68:	e798      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3400ec6a:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400ec6e:	0518      	lsls	r0, r3, #20
3400ec70:	f57f ad78 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400ec74:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400ec78:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3400ec7c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ec80:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3400ec82:	e7a0      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3400ec84:	4a24      	ldr	r2, [pc, #144]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400ec86:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3400ec8a:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
3400ec8e:	2b02      	cmp	r3, #2
3400ec90:	d010      	beq.n	3400ecb4 <HAL_RCCEx_GetPeriphCLKFreq+0x5d8>
3400ec92:	2b03      	cmp	r3, #3
3400ec94:	d034      	beq.n	3400ed00 <HAL_RCCEx_GetPeriphCLKFreq+0x624>
3400ec96:	2b01      	cmp	r3, #1
3400ec98:	d009      	beq.n	3400ecae <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400ec9a:	f7fb fa3b 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400ec9e:	f7fb fb45 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3400eca2:	4b1d      	ldr	r3, [pc, #116]	@ (3400ed18 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3400eca4:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3400eca8:	f3c3 1303 	ubfx	r3, r3, #4, #4
3400ecac:	e708      	b.n	3400eac0 <HAL_RCCEx_GetPeriphCLKFreq+0x3e4>
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400ecae:	f7fe fc8f 	bl	3400d5d0 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3400ecb2:	e7f6      	b.n	3400eca2 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3400ecb4:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400ecb8:	04d9      	lsls	r1, r3, #19
3400ecba:	d516      	bpl.n	3400ecea <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400ecbc:	f8d2 00f4 	ldr.w	r0, [r2, #244]	@ 0xf4
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400ecc0:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400ecc4:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3400ecc8:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC13_GetSource())
3400eccc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3400ecd0:	f100 0401 	add.w	r4, r0, #1
3400ecd4:	d00e      	beq.n	3400ecf4 <HAL_RCCEx_GetPeriphCLKFreq+0x618>
3400ecd6:	d805      	bhi.n	3400ece4 <HAL_RCCEx_GetPeriphCLKFreq+0x608>
3400ecd8:	b94b      	cbnz	r3, 3400ecee <HAL_RCCEx_GetPeriphCLKFreq+0x612>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ecda:	f7fe fb79 	bl	3400d3d0 <HAL_RCCEx_GetPLL1CLKFreq>
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3400ecde:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3400ece2:	e7de      	b.n	3400eca2 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        switch (LL_RCC_IC13_GetSource())
3400ece4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ece8:	d007      	beq.n	3400ecfa <HAL_RCCEx_GetPeriphCLKFreq+0x61e>
        eth1ptp_frequency = HSE_VALUE;
3400ecea:	2000      	movs	r0, #0
3400ecec:	e7d9      	b.n	3400eca2 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ecee:	f7fe fbaf 	bl	3400d450 <HAL_RCCEx_GetPLL2CLKFreq>
3400ecf2:	e7f4      	b.n	3400ecde <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ecf4:	f7fe fbec 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400ecf8:	e7f1      	b.n	3400ecde <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ecfa:	f7fe fc29 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400ecfe:	e7ee      	b.n	3400ecde <HAL_RCCEx_GetPeriphCLKFreq+0x602>
      if (LL_RCC_HSE_IsReady() != 0U)
3400ed00:	f7fb fa7a 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400ed04:	2800      	cmp	r0, #0
3400ed06:	d0f0      	beq.n	3400ecea <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        eth1ptp_frequency = HSE_VALUE;
3400ed08:	4807      	ldr	r0, [pc, #28]	@ (3400ed28 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3400ed0a:	e7ca      	b.n	3400eca2 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
3400ed0c:	01001014 	.word	0x01001014
3400ed10:	03001414 	.word	0x03001414
3400ed14:	03000814 	.word	0x03000814
3400ed18:	56028000 	.word	0x56028000
3400ed1c:	03d09000 	.word	0x03d09000
3400ed20:	003d0900 	.word	0x003d0900
3400ed24:	00bb8000 	.word	0x00bb8000
3400ed28:	02dc6c00 	.word	0x02dc6c00
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3400ed2c:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400ed30:	035b      	lsls	r3, r3, #13
3400ed32:	f57f ad17 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400ed36:	f8d5 010c 	ldr.w	r0, [r5, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400ed3a:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3400ed3e:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ed42:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3400ed44:	e73f      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3400ed46:	4ba7      	ldr	r3, [pc, #668]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ed48:	f8d3 214c 	ldr.w	r2, [r3, #332]	@ 0x14c
3400ed4c:	f002 0230 	and.w	r2, r2, #48	@ 0x30
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3400ed50:	2a20      	cmp	r2, #32
3400ed52:	d019      	beq.n	3400ed88 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
3400ed54:	d808      	bhi.n	3400ed68 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>
3400ed56:	2a00      	cmp	r2, #0
3400ed58:	f47f af78 	bne.w	3400ec4c <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400ed5c:	f7fb f9da 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
}
3400ed60:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400ed64:	f7fb bae2 	b.w	3400a32c <RCCEx_GetHCLKFreq>
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3400ed68:	2a30      	cmp	r2, #48	@ 0x30
3400ed6a:	f47f acfb 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3400ed6e:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400ed72:	0714      	lsls	r4, r2, #28
3400ed74:	f57f acf6 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400ed78:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400ed7c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3400ed80:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ed84:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3400ed86:	e71e      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3400ed88:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3400ed8c:	0755      	lsls	r5, r2, #29
3400ed8e:	f57f ace9 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400ed92:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400ed96:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3400ed9a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ed9e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3400eda0:	e711      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
3400eda2:	4891      	ldr	r0, [pc, #580]	@ (3400efe8 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
}
3400eda4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3400eda8:	f7ff bafa 	b.w	3400e3a0 <RCCEx_GetI2CCLKFreq>
3400edac:	488f      	ldr	r0, [pc, #572]	@ (3400efec <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3400edae:	e7f9      	b.n	3400eda4 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
3400edb0:	488f      	ldr	r0, [pc, #572]	@ (3400eff0 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
3400edb2:	e7f7      	b.n	3400eda4 <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
3400edb4:	488f      	ldr	r0, [pc, #572]	@ (3400eff4 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
}
3400edb6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3400edba:	f7ff b9ff 	b.w	3400e1bc <RCCEx_GetI3CCLKFreq>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3400edbe:	488e      	ldr	r0, [pc, #568]	@ (3400eff8 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
}
3400edc0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
3400edc4:	f7ff bbaa 	b.w	3400e51c <RCCEx_GetLPTIMCLKFreq>
3400edc8:	488c      	ldr	r0, [pc, #560]	@ (3400effc <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
3400edca:	e7f9      	b.n	3400edc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
3400edcc:	488c      	ldr	r0, [pc, #560]	@ (3400f000 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3400edce:	e7f7      	b.n	3400edc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
3400edd0:	488c      	ldr	r0, [pc, #560]	@ (3400f004 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
3400edd2:	e7f5      	b.n	3400edc0 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3400edd4:	4a83      	ldr	r2, [pc, #524]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400edd6:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3400edda:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400edde:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400ede2:	d031      	beq.n	3400ee48 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
3400ede4:	d812      	bhi.n	3400ee0c <HAL_RCCEx_GetPeriphCLKFreq+0x730>
3400ede6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400edea:	f43f af2f 	beq.w	3400ec4c <HAL_RCCEx_GetPeriphCLKFreq+0x570>
3400edee:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400edf2:	d01d      	beq.n	3400ee30 <HAL_RCCEx_GetPeriphCLKFreq+0x754>
3400edf4:	2b00      	cmp	r3, #0
3400edf6:	f47f acb5 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400edfa:	f7fb f98b 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
3400edfe:	f7fb fa95 	bl	3400a32c <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400ee02:	4b78      	ldr	r3, [pc, #480]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ee04:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3400ee06:	f3c3 3302 	ubfx	r3, r3, #12, #3
3400ee0a:	e4db      	b.n	3400e7c4 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3400ee0c:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3400ee10:	f43f aec5 	beq.w	3400eb9e <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3400ee14:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400ee18:	d02f      	beq.n	3400ee7a <HAL_RCCEx_GetPeriphCLKFreq+0x79e>
3400ee1a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
  switch (LL_RCC_GetRTCClockSource())
3400ee1e:	f47f aca1 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_LSE_IsReady() != 0U)
3400ee22:	f7fb fa01 	bl	3400a228 <LL_RCC_LSE_IsReady>
3400ee26:	3800      	subs	r0, #0
3400ee28:	bf18      	it	ne
3400ee2a:	2001      	movne	r0, #1
3400ee2c:	03c0      	lsls	r0, r0, #15
3400ee2e:	e6b5      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400ee30:	f7fb fa46 	bl	3400a2c0 <LL_RCC_IC9_IsEnabled>
3400ee34:	2800      	cmp	r0, #0
3400ee36:	f43f ac95 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC9_GetDivider();
3400ee3a:	f7fb fa49 	bl	3400a2d0 <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3400ee3e:	4b69      	ldr	r3, [pc, #420]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ee40:	4604      	mov	r4, r0
3400ee42:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400ee46:	e6be      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400ee48:	f7fb fa4c 	bl	3400a2e4 <LL_RCC_IC14_IsEnabled>
3400ee4c:	2800      	cmp	r0, #0
3400ee4e:	f43f ac89 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC14_GetDivider();
3400ee52:	f7fb fa4f 	bl	3400a2f4 <LL_RCC_IC14_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3400ee56:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3400ee5a:	4604      	mov	r4, r0
3400ee5c:	e6b3      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3400ee5e:	4d61      	ldr	r5, [pc, #388]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ee60:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
3400ee64:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3400ee68:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400ee6c:	d010      	beq.n	3400ee90 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>
3400ee6e:	f67f aec0 	bls.w	3400ebf2 <HAL_RCCEx_GetPeriphCLKFreq+0x516>
3400ee72:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400ee76:	f47f ac75 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400ee7a:	f7fb f9c5 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400ee7e:	2800      	cmp	r0, #0
3400ee80:	f43f ac70 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400ee84:	4b57      	ldr	r3, [pc, #348]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ee86:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400ee88:	485f      	ldr	r0, [pc, #380]	@ (3400f008 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
3400ee8a:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3400ee8e:	e499      	b.n	3400e7c4 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3400ee90:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3400ee94:	0418      	lsls	r0, r3, #16
3400ee96:	f57f ac65 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400ee9a:	f8d5 0100 	ldr.w	r0, [r5, #256]	@ 0x100
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400ee9e:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3400eea2:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400eea6:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3400eea8:	e68d      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400eeaa:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3400eeae:	f000 8096 	beq.w	3400efde <HAL_RCCEx_GetPeriphCLKFreq+0x902>
3400eeb2:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3400eeb6:	d00d      	beq.n	3400eed4 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
3400eeb8:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3400eebc:	e6a4      	b.n	3400ec08 <HAL_RCCEx_GetPeriphCLKFreq+0x52c>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400eebe:	f7fb f9db 	bl	3400a278 <LL_RCC_IC7_IsEnabled>
3400eec2:	2800      	cmp	r0, #0
3400eec4:	f43f ac4e 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC7_GetDivider();
3400eec8:	f7fb f9de 	bl	3400a288 <LL_RCC_IC7_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3400eecc:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
3400eed0:	4604      	mov	r4, r0
3400eed2:	e678      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3400eed4:	f7fb f91e 	bl	3400a114 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400eed8:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3400eeda:	f3c3 6301 	ubfx	r3, r3, #24, #2
3400eede:	e471      	b.n	3400e7c4 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3400eee0:	4a40      	ldr	r2, [pc, #256]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400eee2:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400eee6:	f003 0330 	and.w	r3, r3, #48	@ 0x30
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3400eeea:	2b20      	cmp	r3, #32
3400eeec:	d00b      	beq.n	3400ef06 <HAL_RCCEx_GetPeriphCLKFreq+0x82a>
3400eeee:	f67f aeaa 	bls.w	3400ec46 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3400eef2:	2b30      	cmp	r3, #48	@ 0x30
3400eef4:	f47f ac36 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3400eef8:	f7fb f986 	bl	3400a208 <LL_RCC_HSI_IsReady>
3400eefc:	2800      	cmp	r0, #0
3400eefe:	f43f ac31 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400ef02:	6c93      	ldr	r3, [r2, #72]	@ 0x48
3400ef04:	e7c0      	b.n	3400ee88 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3400ef06:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3400ef0a:	0319      	lsls	r1, r3, #12
3400ef0c:	f57f ac2a 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400ef10:	f8d2 0110 	ldr.w	r0, [r2, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400ef14:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3400ef18:	f3c0 4007 	ubfx	r0, r0, #16, #8
3400ef1c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3400ef1e:	e652      	b.n	3400ebc6 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        switch (LL_RCC_IC20_GetSource())
3400ef20:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ef24:	f47f ac1e 	bne.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ef28:	f7fe fb12 	bl	3400d550 <HAL_RCCEx_GetPLL4CLKFreq>
3400ef2c:	e634      	b.n	3400eb98 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ef2e:	f7fe facf 	bl	3400d4d0 <HAL_RCCEx_GetPLL3CLKFreq>
3400ef32:	e631      	b.n	3400eb98 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400ef34:	4a2b      	ldr	r2, [pc, #172]	@ (3400efe4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3400ef36:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3400ef3a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
  switch (LL_RCC_GetRTCClockSource())
3400ef3e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400ef42:	d005      	beq.n	3400ef50 <HAL_RCCEx_GetPeriphCLKFreq+0x874>
3400ef44:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400ef48:	d009      	beq.n	3400ef5e <HAL_RCCEx_GetPeriphCLKFreq+0x882>
3400ef4a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400ef4e:	e766      	b.n	3400ee1e <HAL_RCCEx_GetPeriphCLKFreq+0x742>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400ef50:	6853      	ldr	r3, [r2, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3400ef52:	07db      	lsls	r3, r3, #31
3400ef54:	f57f ac06 	bpl.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        rtc_frequency = LSI_VALUE;
3400ef58:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return frequency;
3400ef5c:	e61e      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_HSE_IsReady() != 0U)
3400ef5e:	f7fb f94b 	bl	3400a1f8 <LL_RCC_HSE_IsReady>
3400ef62:	2800      	cmp	r0, #0
3400ef64:	f43f abfe 	beq.w	3400e764 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3400ef68:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
        rtc_frequency = HSE_VALUE / prescaler;
3400ef6c:	4827      	ldr	r0, [pc, #156]	@ (3400f00c <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3400ef6e:	f3c3 3305 	ubfx	r3, r3, #12, #6
3400ef72:	3301      	adds	r3, #1
3400ef74:	e5a5      	b.n	3400eac2 <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3400ef76:	4826      	ldr	r0, [pc, #152]	@ (3400f010 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
3400ef78:	e49e      	b.n	3400e8b8 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3400ef7a:	4826      	ldr	r0, [pc, #152]	@ (3400f014 <HAL_RCCEx_GetPeriphCLKFreq+0x938>)
3400ef7c:	e4ce      	b.n	3400e91c <HAL_RCCEx_GetPeriphCLKFreq+0x240>
}
3400ef7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400ef82:	f7fe bbab 	b.w	3400d6dc <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
3400ef86:	4824      	ldr	r0, [pc, #144]	@ (3400f018 <HAL_RCCEx_GetPeriphCLKFreq+0x93c>)
}
3400ef88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3400ef8c:	f7fe bf30 	b.w	3400ddf0 <RCCEx_GetSPICLKFreq>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
3400ef90:	4822      	ldr	r0, [pc, #136]	@ (3400f01c <HAL_RCCEx_GetPeriphCLKFreq+0x940>)
3400ef92:	e7f9      	b.n	3400ef88 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
3400ef94:	4822      	ldr	r0, [pc, #136]	@ (3400f020 <HAL_RCCEx_GetPeriphCLKFreq+0x944>)
3400ef96:	e7f7      	b.n	3400ef88 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3400ef98:	4822      	ldr	r0, [pc, #136]	@ (3400f024 <HAL_RCCEx_GetPeriphCLKFreq+0x948>)
3400ef9a:	e7f5      	b.n	3400ef88 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
3400ef9c:	4822      	ldr	r0, [pc, #136]	@ (3400f028 <HAL_RCCEx_GetPeriphCLKFreq+0x94c>)
}
3400ef9e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400efa2:	f7fe bd0d 	b.w	3400d9c0 <RCCEx_GetUSARTCLKFreq>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3400efa6:	4821      	ldr	r0, [pc, #132]	@ (3400f02c <HAL_RCCEx_GetPeriphCLKFreq+0x950>)
3400efa8:	e7f9      	b.n	3400ef9e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
3400efaa:	4821      	ldr	r0, [pc, #132]	@ (3400f030 <HAL_RCCEx_GetPeriphCLKFreq+0x954>)
3400efac:	e7f7      	b.n	3400ef9e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3400efae:	4821      	ldr	r0, [pc, #132]	@ (3400f034 <HAL_RCCEx_GetPeriphCLKFreq+0x958>)
3400efb0:	e4ed      	b.n	3400e98e <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
3400efb2:	4821      	ldr	r0, [pc, #132]	@ (3400f038 <HAL_RCCEx_GetPeriphCLKFreq+0x95c>)
3400efb4:	e4eb      	b.n	3400e98e <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
3400efb6:	4821      	ldr	r0, [pc, #132]	@ (3400f03c <HAL_RCCEx_GetPeriphCLKFreq+0x960>)
3400efb8:	e4e9      	b.n	3400e98e <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3400efba:	4821      	ldr	r0, [pc, #132]	@ (3400f040 <HAL_RCCEx_GetPeriphCLKFreq+0x964>)
3400efbc:	e4e7      	b.n	3400e98e <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3400efbe:	4821      	ldr	r0, [pc, #132]	@ (3400f044 <HAL_RCCEx_GetPeriphCLKFreq+0x968>)
3400efc0:	e7ed      	b.n	3400ef9e <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400efc2:	4821      	ldr	r0, [pc, #132]	@ (3400f048 <HAL_RCCEx_GetPeriphCLKFreq+0x96c>)
}
3400efc4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400efc8:	f7fe bc62 	b.w	3400d890 <RCCEx_GetOTGPHYCLKFreq>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3400efcc:	481f      	ldr	r0, [pc, #124]	@ (3400f04c <HAL_RCCEx_GetPeriphCLKFreq+0x970>)
3400efce:	e534      	b.n	3400ea3a <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
3400efd0:	481f      	ldr	r0, [pc, #124]	@ (3400f050 <HAL_RCCEx_GetPeriphCLKFreq+0x974>)
}
3400efd2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3400efd6:	f7fe bbe1 	b.w	3400d79c <RCCEx_GetXSPICLKFreq>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
3400efda:	481e      	ldr	r0, [pc, #120]	@ (3400f054 <HAL_RCCEx_GetPeriphCLKFreq+0x978>)
3400efdc:	e7f9      	b.n	3400efd2 <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3400efde:	481e      	ldr	r0, [pc, #120]	@ (3400f058 <HAL_RCCEx_GetPeriphCLKFreq+0x97c>)
3400efe0:	e5dc      	b.n	3400eb9c <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
3400efe2:	bf00      	nop
3400efe4:	56028000 	.word	0x56028000
3400efe8:	0700000c 	.word	0x0700000c
3400efec:	0700040c 	.word	0x0700040c
3400eff0:	0700080c 	.word	0x0700080c
3400eff4:	0700100c 	.word	0x0700100c
3400eff8:	0700082c 	.word	0x0700082c
3400effc:	07000c2c 	.word	0x07000c2c
3400f000:	0700102c 	.word	0x0700102c
3400f004:	0700142c 	.word	0x0700142c
3400f008:	03d09000 	.word	0x03d09000
3400f00c:	02dc6c00 	.word	0x02dc6c00
3400f010:	07001818 	.word	0x07001818
3400f014:	0300041c 	.word	0x0300041c
3400f018:	07000420 	.word	0x07000420
3400f01c:	07000820 	.word	0x07000820
3400f020:	07001020 	.word	0x07001020
3400f024:	07001820 	.word	0x07001820
3400f028:	07000030 	.word	0x07000030
3400f02c:	07000430 	.word	0x07000430
3400f030:	07000830 	.word	0x07000830
3400f034:	07001030 	.word	0x07001030
3400f038:	07001830 	.word	0x07001830
3400f03c:	07001c30 	.word	0x07001c30
3400f040:	07000034 	.word	0x07000034
3400f044:	07000434 	.word	0x07000434
3400f048:	03000c14 	.word	0x03000c14
3400f04c:	01001814 	.word	0x01001814
3400f050:	03000014 	.word	0x03000014
3400f054:	03000414 	.word	0x03000414
3400f058:	00bb8000 	.word	0x00bb8000

3400f05c <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
3400f05c:	b538      	push	{r3, r4, r5, lr}
3400f05e:	4604      	mov	r4, r0
  uint32_t master_cid;
  uint32_t rimc_attr_val;

  /* Check the parameter */
  assert_param(pConfig != (void *)NULL);
3400f060:	460d      	mov	r5, r1
3400f062:	b921      	cbnz	r1, 3400f06e <HAL_RIF_RIMC_ConfigMasterAttributes+0x12>
3400f064:	f240 1111 	movw	r1, #273	@ 0x111
3400f068:	4825      	ldr	r0, [pc, #148]	@ (3400f100 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f06a:	f7f3 fa67 	bl	3400253c <assert_failed>
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
3400f06e:	2c0c      	cmp	r4, #12
3400f070:	d904      	bls.n	3400f07c <HAL_RIF_RIMC_ConfigMasterAttributes+0x20>
3400f072:	f44f 7189 	mov.w	r1, #274	@ 0x112
3400f076:	4822      	ldr	r0, [pc, #136]	@ (3400f100 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f078:	f7f3 fa60 	bl	3400253c <assert_failed>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
3400f07c:	682b      	ldr	r3, [r5, #0]
3400f07e:	2b20      	cmp	r3, #32
3400f080:	d838      	bhi.n	3400f0f4 <HAL_RIF_RIMC_ConfigMasterAttributes+0x98>
3400f082:	2b03      	cmp	r3, #3
3400f084:	d82a      	bhi.n	3400f0dc <HAL_RIF_RIMC_ConfigMasterAttributes+0x80>
3400f086:	3b01      	subs	r3, #1
3400f088:	2b01      	cmp	r3, #1
3400f08a:	d82d      	bhi.n	3400f0e8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x8c>
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
3400f08c:	682b      	ldr	r3, [r5, #0]
3400f08e:	2b80      	cmp	r3, #128	@ 0x80
3400f090:	d001      	beq.n	3400f096 <HAL_RIF_RIMC_ConfigMasterAttributes+0x3a>
3400f092:	2bff      	cmp	r3, #255	@ 0xff
3400f094:	d904      	bls.n	3400f0a0 <HAL_RIF_RIMC_ConfigMasterAttributes+0x44>
3400f096:	f44f 718a 	mov.w	r1, #276	@ 0x114
3400f09a:	4819      	ldr	r0, [pc, #100]	@ (3400f100 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f09c:	f7f3 fa4e 	bl	3400253c <assert_failed>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));
3400f0a0:	686b      	ldr	r3, [r5, #4]
3400f0a2:	2b03      	cmp	r3, #3
3400f0a4:	d904      	bls.n	3400f0b0 <HAL_RIF_RIMC_ConfigMasterAttributes+0x54>
3400f0a6:	f240 1115 	movw	r1, #277	@ 0x115
3400f0aa:	4815      	ldr	r0, [pc, #84]	@ (3400f100 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f0ac:	f7f3 fa46 	bl	3400253c <assert_failed>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
3400f0b0:	682b      	ldr	r3, [r5, #0]
3400f0b2:	fa93 f3a3 	rbit	r3, r3
  return __builtin_clz(value);
3400f0b6:	fab3 f283 	clz	r2, r3

  master_cid = POSITION_VAL(pConfig->MasterCID);
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
3400f0ba:	00a0      	lsls	r0, r4, #2
3400f0bc:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
3400f0c0:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
3400f0c4:	f8d0 3c10 	ldr.w	r3, [r0, #3088]	@ 0xc10
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3400f0c8:	6869      	ldr	r1, [r5, #4]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
3400f0ca:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
3400f0ce:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3400f0d2:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
3400f0d6:	f8c0 3c10 	str.w	r3, [r0, #3088]	@ 0xc10
}
3400f0da:	bd38      	pop	{r3, r4, r5, pc}
3400f0dc:	4a09      	ldr	r2, [pc, #36]	@ (3400f104 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa8>)
3400f0de:	3b04      	subs	r3, #4
3400f0e0:	fa22 f303 	lsr.w	r3, r2, r3
3400f0e4:	07db      	lsls	r3, r3, #31
3400f0e6:	d4d1      	bmi.n	3400f08c <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
3400f0e8:	f240 1113 	movw	r1, #275	@ 0x113
3400f0ec:	4804      	ldr	r0, [pc, #16]	@ (3400f100 <HAL_RIF_RIMC_ConfigMasterAttributes+0xa4>)
3400f0ee:	f7f3 fa25 	bl	3400253c <assert_failed>
3400f0f2:	e7cb      	b.n	3400f08c <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f0f4:	2b40      	cmp	r3, #64	@ 0x40
3400f0f6:	d0c9      	beq.n	3400f08c <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f0f8:	2b80      	cmp	r3, #128	@ 0x80
3400f0fa:	d1f5      	bne.n	3400f0e8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x8c>
3400f0fc:	e7c6      	b.n	3400f08c <HAL_RIF_RIMC_ConfigMasterAttributes+0x30>
3400f0fe:	bf00      	nop
3400f100:	3401c845 	.word	0x3401c845
3400f104:	10001011 	.word	0x10001011

3400f108 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
3400f108:	4b38      	ldr	r3, [pc, #224]	@ (3400f1ec <HAL_RIF_RISC_SetSlaveSecureAttributes+0xe4>)
{
3400f10a:	b537      	push	{r0, r1, r2, r4, r5, lr}
3400f10c:	4298      	cmp	r0, r3
3400f10e:	4604      	mov	r4, r0
3400f110:	460d      	mov	r5, r1
3400f112:	d85c      	bhi.n	3400f1ce <HAL_RIF_RISC_SetSlaveSecureAttributes+0xc6>
3400f114:	3b1e      	subs	r3, #30
3400f116:	4298      	cmp	r0, r3
3400f118:	d83b      	bhi.n	3400f192 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x8a>
3400f11a:	4b35      	ldr	r3, [pc, #212]	@ (3400f1f0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xe8>)
3400f11c:	4298      	cmp	r0, r3
3400f11e:	d84b      	bhi.n	3400f1b8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xb0>
3400f120:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
3400f124:	d23a      	bcs.n	3400f19c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x94>
3400f126:	4b33      	ldr	r3, [pc, #204]	@ (3400f1f4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xec>)
3400f128:	4298      	cmp	r0, r3
3400f12a:	d840      	bhi.n	3400f1ae <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa6>
3400f12c:	1fc2      	subs	r2, r0, #7
3400f12e:	3b22      	subs	r3, #34	@ 0x22
3400f130:	429a      	cmp	r2, r3
3400f132:	d937      	bls.n	3400f1a4 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x9c>
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));
3400f134:	2d03      	cmp	r5, #3
3400f136:	d904      	bls.n	3400f142 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x3a>
3400f138:	f44f 71b9 	mov.w	r1, #370	@ 0x172
3400f13c:	482e      	ldr	r0, [pc, #184]	@ (3400f1f8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf0>)
3400f13e:	f7f3 f9fd 	bl	3400253c <assert_failed>

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f142:	2201      	movs	r2, #1
  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f144:	0f20      	lsrs	r0, r4, #28
3400f146:	0080      	lsls	r0, r0, #2
3400f148:	f100 40a8 	add.w	r0, r0, #1409286144	@ 0x54000000
3400f14c:	f500 3010 	add.w	r0, r0, #147456	@ 0x24000
3400f150:	6903      	ldr	r3, [r0, #16]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f152:	f004 041f 	and.w	r4, r4, #31
  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f156:	9301      	str	r3, [sp, #4]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f158:	9b01      	ldr	r3, [sp, #4]
3400f15a:	40a2      	lsls	r2, r4
3400f15c:	ea23 0302 	bic.w	r3, r3, r2
3400f160:	9301      	str	r3, [sp, #4]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f162:	9901      	ldr	r1, [sp, #4]
3400f164:	f005 0301 	and.w	r3, r5, #1
3400f168:	40a3      	lsls	r3, r4
3400f16a:	430b      	orrs	r3, r1
3400f16c:	9301      	str	r3, [sp, #4]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f16e:	9b01      	ldr	r3, [sp, #4]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f170:	f3c5 0140 	ubfx	r1, r5, #1, #1
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f174:	6103      	str	r3, [r0, #16]
  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f176:	6b03      	ldr	r3, [r0, #48]	@ 0x30
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f178:	40a1      	lsls	r1, r4
  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3400f17a:	9301      	str	r3, [sp, #4]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3400f17c:	9b01      	ldr	r3, [sp, #4]
3400f17e:	ea23 0302 	bic.w	r3, r3, r2
3400f182:	9301      	str	r3, [sp, #4]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3400f184:	9b01      	ldr	r3, [sp, #4]
3400f186:	4319      	orrs	r1, r3
3400f188:	9101      	str	r1, [sp, #4]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3400f18a:	9b01      	ldr	r3, [sp, #4]
3400f18c:	6303      	str	r3, [r0, #48]	@ 0x30
}
3400f18e:	b003      	add	sp, #12
3400f190:	bd30      	pop	{r4, r5, pc}
3400f192:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
3400f196:	4b19      	ldr	r3, [pc, #100]	@ (3400f1fc <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf4>)
3400f198:	3a02      	subs	r2, #2
3400f19a:	e01d      	b.n	3400f1d8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd0>
3400f19c:	4b18      	ldr	r3, [pc, #96]	@ (3400f200 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf8>)
3400f19e:	f100 4260 	add.w	r2, r0, #3758096384	@ 0xe0000000
3400f1a2:	e019      	b.n	3400f1d8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd0>
3400f1a4:	f1a0 0308 	sub.w	r3, r0, #8
3400f1a8:	2b17      	cmp	r3, #23
3400f1aa:	d9c3      	bls.n	3400f134 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f1ac:	e017      	b.n	3400f1de <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f1ae:	f100 4370 	add.w	r3, r0, #4026531840	@ 0xf0000000
3400f1b2:	3b1c      	subs	r3, #28
3400f1b4:	2b02      	cmp	r3, #2
3400f1b6:	e7f8      	b.n	3400f1aa <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa2>
3400f1b8:	4b12      	ldr	r3, [pc, #72]	@ (3400f204 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xfc>)
3400f1ba:	4298      	cmp	r0, r3
3400f1bc:	d803      	bhi.n	3400f1c6 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xbe>
3400f1be:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3400f1c2:	d2b7      	bcs.n	3400f134 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f1c4:	e00b      	b.n	3400f1de <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f1c6:	4b10      	ldr	r3, [pc, #64]	@ (3400f208 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x100>)
3400f1c8:	4298      	cmp	r0, r3
3400f1ca:	d0b3      	beq.n	3400f134 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f1cc:	e007      	b.n	3400f1de <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f1ce:	f100 4230 	add.w	r2, r0, #2952790016	@ 0xb0000000
3400f1d2:	2a1e      	cmp	r2, #30
3400f1d4:	d803      	bhi.n	3400f1de <HAL_RIF_RISC_SetSlaveSecureAttributes+0xd6>
3400f1d6:	4b0d      	ldr	r3, [pc, #52]	@ (3400f20c <HAL_RIF_RISC_SetSlaveSecureAttributes+0x104>)
3400f1d8:	40d3      	lsrs	r3, r2
3400f1da:	07db      	lsls	r3, r3, #31
3400f1dc:	d4aa      	bmi.n	3400f134 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
3400f1de:	f240 1171 	movw	r1, #369	@ 0x171
3400f1e2:	4805      	ldr	r0, [pc, #20]	@ (3400f1f8 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xf0>)
3400f1e4:	f7f3 f9aa 	bl	3400253c <assert_failed>
3400f1e8:	e7a4      	b.n	3400f134 <HAL_RIF_RISC_SetSlaveSecureAttributes+0x2c>
3400f1ea:	bf00      	nop
3400f1ec:	4000001f 	.word	0x4000001f
3400f1f0:	2000001e 	.word	0x2000001e
3400f1f4:	1000001a 	.word	0x1000001a
3400f1f8:	3401c845 	.word	0x3401c845
3400f1fc:	2e838c0b 	.word	0x2e838c0b
3400f200:	77dff03b 	.word	0x77dff03b
3400f204:	30000008 	.word	0x30000008
3400f208:	3000000a 	.word	0x3000000a
3400f20c:	49deef7f 	.word	0x49deef7f

3400f210 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
3400f210:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3400f212:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f214:	e852 3f00 	ldrex	r3, [r2]
3400f218:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f21c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
3400f220:	6802      	ldr	r2, [r0, #0]
3400f222:	2900      	cmp	r1, #0
3400f224:	d1f5      	bne.n	3400f212 <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
3400f226:	4c0f      	ldr	r4, [pc, #60]	@ (3400f264 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f228:	f102 0308 	add.w	r3, r2, #8
3400f22c:	e853 3f00 	ldrex	r3, [r3]
3400f230:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f232:	f102 0c08 	add.w	ip, r2, #8
3400f236:	e84c 3100 	strex	r1, r3, [ip]
3400f23a:	2900      	cmp	r1, #0
3400f23c:	d1f4      	bne.n	3400f228 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
3400f23e:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
3400f240:	2b01      	cmp	r3, #1
3400f242:	d107      	bne.n	3400f254 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f244:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
3400f248:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f24c:	e842 3100 	strex	r1, r3, [r2]
3400f250:	2900      	cmp	r1, #0
3400f252:	d1f7      	bne.n	3400f244 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
3400f254:	2320      	movs	r3, #32
3400f256:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400f25a:	2300      	movs	r3, #0
3400f25c:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
3400f25e:	6743      	str	r3, [r0, #116]	@ 0x74
}
3400f260:	bd10      	pop	{r4, pc}
3400f262:	bf00      	nop
3400f264:	effffffe 	.word	0xeffffffe

3400f268 <HAL_UART_MspInit>:
}
3400f268:	4770      	bx	lr
	...

3400f26c <UART_SetConfig>:
{
3400f26c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
3400f26e:	6842      	ldr	r2, [r0, #4]
3400f270:	4bb0      	ldr	r3, [pc, #704]	@ (3400f534 <UART_SetConfig+0x2c8>)
{
3400f272:	4604      	mov	r4, r0
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
3400f274:	429a      	cmp	r2, r3
3400f276:	d904      	bls.n	3400f282 <UART_SetConfig+0x16>
3400f278:	f640 414c 	movw	r1, #3148	@ 0xc4c
3400f27c:	48ae      	ldr	r0, [pc, #696]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f27e:	f7f3 f95d 	bl	3400253c <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
3400f282:	68a3      	ldr	r3, [r4, #8]
3400f284:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f288:	d007      	beq.n	3400f29a <UART_SetConfig+0x2e>
3400f28a:	f433 5380 	bics.w	r3, r3, #4096	@ 0x1000
3400f28e:	d004      	beq.n	3400f29a <UART_SetConfig+0x2e>
3400f290:	f640 414d 	movw	r1, #3149	@ 0xc4d
3400f294:	48a8      	ldr	r0, [pc, #672]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f296:	f7f3 f951 	bl	3400253c <assert_failed>
  if (UART_INSTANCE_LOWPOWER(huart))
3400f29a:	6822      	ldr	r2, [r4, #0]
3400f29c:	49a7      	ldr	r1, [pc, #668]	@ (3400f53c <UART_SetConfig+0x2d0>)
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
3400f29e:	68e3      	ldr	r3, [r4, #12]
  if (UART_INSTANCE_LOWPOWER(huart))
3400f2a0:	428a      	cmp	r2, r1
3400f2a2:	d004      	beq.n	3400f2ae <UART_SetConfig+0x42>
3400f2a4:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
3400f2a8:	428a      	cmp	r2, r1
3400f2aa:	f040 80af 	bne.w	3400f40c <UART_SetConfig+0x1a0>
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
3400f2ae:	f433 5300 	bics.w	r3, r3, #8192	@ 0x2000
3400f2b2:	d004      	beq.n	3400f2be <UART_SetConfig+0x52>
3400f2b4:	f44f 6145 	mov.w	r1, #3152	@ 0xc50
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
3400f2b8:	489f      	ldr	r0, [pc, #636]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f2ba:	f7f3 f93f 	bl	3400253c <assert_failed>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
3400f2be:	6923      	ldr	r3, [r4, #16]
3400f2c0:	f433 6280 	bics.w	r2, r3, #1024	@ 0x400
3400f2c4:	d007      	beq.n	3400f2d6 <UART_SetConfig+0x6a>
3400f2c6:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3400f2ca:	d004      	beq.n	3400f2d6 <UART_SetConfig+0x6a>
3400f2cc:	f640 4158 	movw	r1, #3160	@ 0xc58
3400f2d0:	4899      	ldr	r0, [pc, #612]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f2d2:	f7f3 f933 	bl	3400253c <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
3400f2d6:	6963      	ldr	r3, [r4, #20]
3400f2d8:	f033 020c 	bics.w	r2, r3, #12
3400f2dc:	d100      	bne.n	3400f2e0 <UART_SetConfig+0x74>
3400f2de:	b923      	cbnz	r3, 3400f2ea <UART_SetConfig+0x7e>
3400f2e0:	f640 4159 	movw	r1, #3161	@ 0xc59
3400f2e4:	4894      	ldr	r0, [pc, #592]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f2e6:	f7f3 f929 	bl	3400253c <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
3400f2ea:	69a3      	ldr	r3, [r4, #24]
3400f2ec:	f433 7340 	bics.w	r3, r3, #768	@ 0x300
3400f2f0:	d004      	beq.n	3400f2fc <UART_SetConfig+0x90>
3400f2f2:	f640 415a 	movw	r1, #3162	@ 0xc5a
3400f2f6:	4890      	ldr	r0, [pc, #576]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f2f8:	f7f3 f920 	bl	3400253c <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
3400f2fc:	69e3      	ldr	r3, [r4, #28]
3400f2fe:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
3400f302:	d004      	beq.n	3400f30e <UART_SetConfig+0xa2>
3400f304:	f640 415b 	movw	r1, #3163	@ 0xc5b
3400f308:	488b      	ldr	r0, [pc, #556]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f30a:	f7f3 f917 	bl	3400253c <assert_failed>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
3400f30e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400f310:	2b0b      	cmp	r3, #11
3400f312:	d904      	bls.n	3400f31e <UART_SetConfig+0xb2>
3400f314:	f640 415c 	movw	r1, #3164	@ 0xc5c
3400f318:	4887      	ldr	r0, [pc, #540]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f31a:	f7f3 f90f 	bl	3400253c <assert_failed>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f31e:	6921      	ldr	r1, [r4, #16]
3400f320:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f322:	6823      	ldr	r3, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f324:	430a      	orrs	r2, r1
3400f326:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f328:	6818      	ldr	r0, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f32a:	69e5      	ldr	r5, [r4, #28]
3400f32c:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f32e:	4984      	ldr	r1, [pc, #528]	@ (3400f540 <UART_SetConfig+0x2d4>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400f330:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400f332:	4001      	ands	r1, r0
3400f334:	430a      	orrs	r2, r1
3400f336:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
3400f338:	685a      	ldr	r2, [r3, #4]
3400f33a:	68e1      	ldr	r1, [r4, #12]
3400f33c:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
3400f340:	430a      	orrs	r2, r1
3400f342:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
3400f344:	4a7d      	ldr	r2, [pc, #500]	@ (3400f53c <UART_SetConfig+0x2d0>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
3400f346:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
3400f348:	4293      	cmp	r3, r2
3400f34a:	d005      	beq.n	3400f358 <UART_SetConfig+0xec>
3400f34c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f350:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
3400f352:	bf1c      	itt	ne
3400f354:	6a22      	ldrne	r2, [r4, #32]
3400f356:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
3400f358:	689a      	ldr	r2, [r3, #8]
3400f35a:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
3400f35e:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
3400f362:	430a      	orrs	r2, r1
3400f364:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
3400f366:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400f368:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f36a:	f022 020f 	bic.w	r2, r2, #15
3400f36e:	430a      	orrs	r2, r1
3400f370:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f372:	4a74      	ldr	r2, [pc, #464]	@ (3400f544 <UART_SetConfig+0x2d8>)
3400f374:	4293      	cmp	r3, r2
3400f376:	d07a      	beq.n	3400f46e <UART_SetConfig+0x202>
3400f378:	4a73      	ldr	r2, [pc, #460]	@ (3400f548 <UART_SetConfig+0x2dc>)
3400f37a:	4293      	cmp	r3, r2
3400f37c:	f000 809c 	beq.w	3400f4b8 <UART_SetConfig+0x24c>
3400f380:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f384:	4293      	cmp	r3, r2
3400f386:	f000 809b 	beq.w	3400f4c0 <UART_SetConfig+0x254>
3400f38a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f38e:	4293      	cmp	r3, r2
3400f390:	f000 809a 	beq.w	3400f4c8 <UART_SetConfig+0x25c>
3400f394:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f398:	f000 809a 	beq.w	3400f4d0 <UART_SetConfig+0x264>
3400f39c:	4a6b      	ldr	r2, [pc, #428]	@ (3400f54c <UART_SetConfig+0x2e0>)
3400f39e:	4293      	cmp	r3, r2
3400f3a0:	f000 809a 	beq.w	3400f4d8 <UART_SetConfig+0x26c>
3400f3a4:	4a6a      	ldr	r2, [pc, #424]	@ (3400f550 <UART_SetConfig+0x2e4>)
3400f3a6:	4293      	cmp	r3, r2
3400f3a8:	f000 809a 	beq.w	3400f4e0 <UART_SetConfig+0x274>
3400f3ac:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f3b0:	4293      	cmp	r3, r2
3400f3b2:	f000 8099 	beq.w	3400f4e8 <UART_SetConfig+0x27c>
3400f3b6:	4a67      	ldr	r2, [pc, #412]	@ (3400f554 <UART_SetConfig+0x2e8>)
3400f3b8:	4293      	cmp	r3, r2
3400f3ba:	f000 8099 	beq.w	3400f4f0 <UART_SetConfig+0x284>
3400f3be:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f3c2:	4293      	cmp	r3, r2
3400f3c4:	f000 8098 	beq.w	3400f4f8 <UART_SetConfig+0x28c>
3400f3c8:	4a5c      	ldr	r2, [pc, #368]	@ (3400f53c <UART_SetConfig+0x2d0>)
3400f3ca:	4293      	cmp	r3, r2
3400f3cc:	d02e      	beq.n	3400f42c <UART_SetConfig+0x1c0>
  if (UART_INSTANCE_LOWPOWER(huart))
3400f3ce:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f3d2:	4293      	cmp	r3, r2
3400f3d4:	f04f 0000 	mov.w	r0, #0
3400f3d8:	f04f 0100 	mov.w	r1, #0
3400f3dc:	d14a      	bne.n	3400f474 <UART_SetConfig+0x208>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400f3de:	f7ff f97d 	bl	3400e6dc <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
3400f3e2:	2800      	cmp	r0, #0
3400f3e4:	d041      	beq.n	3400f46a <UART_SetConfig+0x1fe>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400f3e6:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f3e8:	4a5b      	ldr	r2, [pc, #364]	@ (3400f558 <UART_SetConfig+0x2ec>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f3ea:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400f3ec:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f3f0:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400f3f4:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f3f8:	4299      	cmp	r1, r3
3400f3fa:	d91b      	bls.n	3400f434 <UART_SetConfig+0x1c8>
        ret = HAL_ERROR;
3400f3fc:	2001      	movs	r0, #1
  huart->NbRxDataToProcess = 1;
3400f3fe:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
3400f402:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
3400f404:	2300      	movs	r3, #0
  huart->TxISR = NULL;
3400f406:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
3400f40a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
3400f40c:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
3400f410:	d004      	beq.n	3400f41c <UART_SetConfig+0x1b0>
3400f412:	f640 4154 	movw	r1, #3156	@ 0xc54
3400f416:	4848      	ldr	r0, [pc, #288]	@ (3400f538 <UART_SetConfig+0x2cc>)
3400f418:	f7f3 f890 	bl	3400253c <assert_failed>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
3400f41c:	6a23      	ldr	r3, [r4, #32]
3400f41e:	f433 6300 	bics.w	r3, r3, #2048	@ 0x800
3400f422:	f43f af4c 	beq.w	3400f2be <UART_SetConfig+0x52>
3400f426:	f640 4155 	movw	r1, #3157	@ 0xc55
3400f42a:	e745      	b.n	3400f2b8 <UART_SetConfig+0x4c>
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f42c:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
3400f430:	2100      	movs	r1, #0
3400f432:	e7d4      	b.n	3400f3de <UART_SetConfig+0x172>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400f434:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
3400f438:	d8e0      	bhi.n	3400f3fc <UART_SetConfig+0x190>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400f43a:	2300      	movs	r3, #0
3400f43c:	4619      	mov	r1, r3
3400f43e:	f7f2 f8cd 	bl	340015dc <__aeabi_uldivmod>
3400f442:	4606      	mov	r6, r0
3400f444:	460f      	mov	r7, r1
3400f446:	ea56 270f 	orrs.w	r7, r6, pc, lsl #8
3400f44a:	0868      	lsrs	r0, r5, #1
3400f44c:	1830      	adds	r0, r6, r0
3400f44e:	462a      	mov	r2, r5
3400f450:	f04f 0300 	mov.w	r3, #0
3400f454:	f147 0100 	adc.w	r1, r7, #0
3400f458:	f7f2 f8c0 	bl	340015dc <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
3400f45c:	4b3f      	ldr	r3, [pc, #252]	@ (3400f55c <UART_SetConfig+0x2f0>)
3400f45e:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
3400f462:	429a      	cmp	r2, r3
3400f464:	d8ca      	bhi.n	3400f3fc <UART_SetConfig+0x190>
          huart->Instance->BRR = usartdiv;
3400f466:	6823      	ldr	r3, [r4, #0]
3400f468:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
3400f46a:	2000      	movs	r0, #0
3400f46c:	e7c7      	b.n	3400f3fe <UART_SetConfig+0x192>
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f46e:	2000      	movs	r0, #0
3400f470:	f44f 7180 	mov.w	r1, #256	@ 0x100
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
3400f474:	f5b5 4f00 	cmp.w	r5, #32768	@ 0x8000
3400f478:	d142      	bne.n	3400f500 <UART_SetConfig+0x294>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400f47a:	f7ff f92f 	bl	3400e6dc <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
3400f47e:	2800      	cmp	r0, #0
3400f480:	d0f3      	beq.n	3400f46a <UART_SetConfig+0x1fe>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400f482:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f484:	4b34      	ldr	r3, [pc, #208]	@ (3400f558 <UART_SetConfig+0x2ec>)
3400f486:	6862      	ldr	r2, [r4, #4]
3400f488:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
3400f48c:	fbb0 f0f3 	udiv	r0, r0, r3
3400f490:	0853      	lsrs	r3, r2, #1
3400f492:	eb03 0340 	add.w	r3, r3, r0, lsl #1
3400f496:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3400f49a:	f64f 72ef 	movw	r2, #65519	@ 0xffef
3400f49e:	f1a3 0110 	sub.w	r1, r3, #16
3400f4a2:	4291      	cmp	r1, r2
3400f4a4:	d8aa      	bhi.n	3400f3fc <UART_SetConfig+0x190>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3400f4a6:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
3400f4aa:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3400f4ac:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
3400f4ae:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
3400f4b2:	4313      	orrs	r3, r2
3400f4b4:	60cb      	str	r3, [r1, #12]
3400f4b6:	e7d8      	b.n	3400f46a <UART_SetConfig+0x1fe>
  UART_GETCLOCKSOURCE(huart, clocksource);
3400f4b8:	2000      	movs	r0, #0
3400f4ba:	f44f 7100 	mov.w	r1, #512	@ 0x200
3400f4be:	e7d9      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4c0:	2000      	movs	r0, #0
3400f4c2:	f44f 6180 	mov.w	r1, #1024	@ 0x400
3400f4c6:	e7d5      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4c8:	2000      	movs	r0, #0
3400f4ca:	f44f 6100 	mov.w	r1, #2048	@ 0x800
3400f4ce:	e7d1      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4d0:	2000      	movs	r0, #0
3400f4d2:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
3400f4d6:	e7cd      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4d8:	2000      	movs	r0, #0
3400f4da:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
3400f4de:	e7c9      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4e0:	2000      	movs	r0, #0
3400f4e2:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
3400f4e6:	e7c5      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4e8:	2000      	movs	r0, #0
3400f4ea:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400f4ee:	e7c1      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4f0:	2000      	movs	r0, #0
3400f4f2:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
3400f4f6:	e7bd      	b.n	3400f474 <UART_SetConfig+0x208>
3400f4f8:	2000      	movs	r0, #0
3400f4fa:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
3400f4fe:	e7b9      	b.n	3400f474 <UART_SetConfig+0x208>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400f500:	f7ff f8ec 	bl	3400e6dc <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
3400f504:	2800      	cmp	r0, #0
3400f506:	d0b0      	beq.n	3400f46a <UART_SetConfig+0x1fe>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400f508:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400f50a:	4b13      	ldr	r3, [pc, #76]	@ (3400f558 <UART_SetConfig+0x2ec>)
3400f50c:	6862      	ldr	r2, [r4, #4]
3400f50e:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
3400f512:	fbb0 f3f3 	udiv	r3, r0, r3
3400f516:	eb03 0352 	add.w	r3, r3, r2, lsr #1
3400f51a:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3400f51e:	f64f 72ef 	movw	r2, #65519	@ 0xffef
3400f522:	f1a3 0110 	sub.w	r1, r3, #16
3400f526:	4291      	cmp	r1, r2
3400f528:	f63f af68 	bhi.w	3400f3fc <UART_SetConfig+0x190>
        huart->Instance->BRR = (uint16_t)usartdiv;
3400f52c:	6822      	ldr	r2, [r4, #0]
3400f52e:	60d3      	str	r3, [r2, #12]
3400f530:	e79b      	b.n	3400f46a <UART_SetConfig+0x1fe>
3400f532:	bf00      	nop
3400f534:	00bebc1f 	.word	0x00bebc1f
3400f538:	3401c8b3 	.word	0x3401c8b3
3400f53c:	56000c00 	.word	0x56000c00
3400f540:	cfff69f3 	.word	0xcfff69f3
3400f544:	52001000 	.word	0x52001000
3400f548:	50004400 	.word	0x50004400
3400f54c:	52001400 	.word	0x52001400
3400f550:	50007800 	.word	0x50007800
3400f554:	52001800 	.word	0x52001800
3400f558:	34035006 	.word	0x34035006
3400f55c:	000ffcff 	.word	0x000ffcff

3400f560 <UART_AdvFeatureConfig>:
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3400f560:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
3400f562:	b510      	push	{r4, lr}
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3400f564:	2bff      	cmp	r3, #255	@ 0xff
{
3400f566:	4604      	mov	r4, r0
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
3400f568:	d904      	bls.n	3400f574 <UART_AdvFeatureConfig+0x14>
3400f56a:	f640 41e1 	movw	r1, #3297	@ 0xce1
3400f56e:	487e      	ldr	r0, [pc, #504]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f570:	f7f2 ffe4 	bl	3400253c <assert_failed>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
3400f574:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f576:	0718      	lsls	r0, r3, #28
3400f578:	d50f      	bpl.n	3400f59a <UART_AdvFeatureConfig+0x3a>
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
3400f57a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3400f57c:	f433 4300 	bics.w	r3, r3, #32768	@ 0x8000
3400f580:	d004      	beq.n	3400f58c <UART_AdvFeatureConfig+0x2c>
3400f582:	f640 41e6 	movw	r1, #3302	@ 0xce6
3400f586:	4878      	ldr	r0, [pc, #480]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f588:	f7f2 ffd8 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
3400f58c:	6822      	ldr	r2, [r4, #0]
3400f58e:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
3400f590:	6853      	ldr	r3, [r2, #4]
3400f592:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400f596:	430b      	orrs	r3, r1
3400f598:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
3400f59a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f59c:	07d9      	lsls	r1, r3, #31
3400f59e:	d50f      	bpl.n	3400f5c0 <UART_AdvFeatureConfig+0x60>
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
3400f5a0:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400f5a2:	f433 3300 	bics.w	r3, r3, #131072	@ 0x20000
3400f5a6:	d004      	beq.n	3400f5b2 <UART_AdvFeatureConfig+0x52>
3400f5a8:	f640 41ed 	movw	r1, #3309	@ 0xced
3400f5ac:	486e      	ldr	r0, [pc, #440]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f5ae:	f7f2 ffc5 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
3400f5b2:	6822      	ldr	r2, [r4, #0]
3400f5b4:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3400f5b6:	6853      	ldr	r3, [r2, #4]
3400f5b8:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
3400f5bc:	430b      	orrs	r3, r1
3400f5be:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
3400f5c0:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f5c2:	079a      	lsls	r2, r3, #30
3400f5c4:	d50f      	bpl.n	3400f5e6 <UART_AdvFeatureConfig+0x86>
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
3400f5c6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400f5c8:	f433 3380 	bics.w	r3, r3, #65536	@ 0x10000
3400f5cc:	d004      	beq.n	3400f5d8 <UART_AdvFeatureConfig+0x78>
3400f5ce:	f640 41f4 	movw	r1, #3316	@ 0xcf4
3400f5d2:	4865      	ldr	r0, [pc, #404]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f5d4:	f7f2 ffb2 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
3400f5d8:	6822      	ldr	r2, [r4, #0]
3400f5da:	6b21      	ldr	r1, [r4, #48]	@ 0x30
3400f5dc:	6853      	ldr	r3, [r2, #4]
3400f5de:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400f5e2:	430b      	orrs	r3, r1
3400f5e4:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
3400f5e6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f5e8:	075b      	lsls	r3, r3, #29
3400f5ea:	d50f      	bpl.n	3400f60c <UART_AdvFeatureConfig+0xac>
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
3400f5ec:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400f5ee:	f433 2380 	bics.w	r3, r3, #262144	@ 0x40000
3400f5f2:	d004      	beq.n	3400f5fe <UART_AdvFeatureConfig+0x9e>
3400f5f4:	f640 41fb 	movw	r1, #3323	@ 0xcfb
3400f5f8:	485b      	ldr	r0, [pc, #364]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f5fa:	f7f2 ff9f 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
3400f5fe:	6822      	ldr	r2, [r4, #0]
3400f600:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3400f602:	6853      	ldr	r3, [r2, #4]
3400f604:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
3400f608:	430b      	orrs	r3, r1
3400f60a:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
3400f60c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f60e:	06d8      	lsls	r0, r3, #27
3400f610:	d50f      	bpl.n	3400f632 <UART_AdvFeatureConfig+0xd2>
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
3400f612:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400f614:	f433 5380 	bics.w	r3, r3, #4096	@ 0x1000
3400f618:	d004      	beq.n	3400f624 <UART_AdvFeatureConfig+0xc4>
3400f61a:	f640 5102 	movw	r1, #3330	@ 0xd02
3400f61e:	4852      	ldr	r0, [pc, #328]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f620:	f7f2 ff8c 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
3400f624:	6822      	ldr	r2, [r4, #0]
3400f626:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3400f628:	6893      	ldr	r3, [r2, #8]
3400f62a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
3400f62e:	430b      	orrs	r3, r1
3400f630:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
3400f632:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f634:	0699      	lsls	r1, r3, #26
3400f636:	d50f      	bpl.n	3400f658 <UART_AdvFeatureConfig+0xf8>
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
3400f638:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400f63a:	f433 5300 	bics.w	r3, r3, #8192	@ 0x2000
3400f63e:	d004      	beq.n	3400f64a <UART_AdvFeatureConfig+0xea>
3400f640:	f640 510a 	movw	r1, #3338	@ 0xd0a
3400f644:	4848      	ldr	r0, [pc, #288]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f646:	f7f2 ff79 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
3400f64a:	6822      	ldr	r2, [r4, #0]
3400f64c:	6c21      	ldr	r1, [r4, #64]	@ 0x40
3400f64e:	6893      	ldr	r3, [r2, #8]
3400f650:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
3400f654:	430b      	orrs	r3, r1
3400f656:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
3400f658:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f65a:	065a      	lsls	r2, r3, #25
3400f65c:	d56f      	bpl.n	3400f73e <UART_AdvFeatureConfig+0x1de>
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
3400f65e:	6823      	ldr	r3, [r4, #0]
3400f660:	4a42      	ldr	r2, [pc, #264]	@ (3400f76c <UART_AdvFeatureConfig+0x20c>)
3400f662:	4293      	cmp	r3, r2
3400f664:	d047      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f666:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f66a:	4293      	cmp	r3, r2
3400f66c:	d043      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f66e:	4a40      	ldr	r2, [pc, #256]	@ (3400f770 <UART_AdvFeatureConfig+0x210>)
3400f670:	4293      	cmp	r3, r2
3400f672:	d040      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f674:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f678:	4293      	cmp	r3, r2
3400f67a:	d03c      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f67c:	4a3d      	ldr	r2, [pc, #244]	@ (3400f774 <UART_AdvFeatureConfig+0x214>)
3400f67e:	4293      	cmp	r3, r2
3400f680:	d039      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f682:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f686:	4293      	cmp	r3, r2
3400f688:	d035      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f68a:	4a3b      	ldr	r2, [pc, #236]	@ (3400f778 <UART_AdvFeatureConfig+0x218>)
3400f68c:	4293      	cmp	r3, r2
3400f68e:	d032      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f690:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f694:	4293      	cmp	r3, r2
3400f696:	d02e      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f698:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f69c:	d02b      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f69e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f6a2:	4293      	cmp	r3, r2
3400f6a4:	d027      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6a6:	4a35      	ldr	r2, [pc, #212]	@ (3400f77c <UART_AdvFeatureConfig+0x21c>)
3400f6a8:	4293      	cmp	r3, r2
3400f6aa:	d024      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6ac:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f6b0:	4293      	cmp	r3, r2
3400f6b2:	d020      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6b4:	4a32      	ldr	r2, [pc, #200]	@ (3400f780 <UART_AdvFeatureConfig+0x220>)
3400f6b6:	4293      	cmp	r3, r2
3400f6b8:	d01d      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6ba:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f6be:	4293      	cmp	r3, r2
3400f6c0:	d019      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6c2:	4a30      	ldr	r2, [pc, #192]	@ (3400f784 <UART_AdvFeatureConfig+0x224>)
3400f6c4:	4293      	cmp	r3, r2
3400f6c6:	d016      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6c8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f6cc:	4293      	cmp	r3, r2
3400f6ce:	d012      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6d0:	4a2d      	ldr	r2, [pc, #180]	@ (3400f788 <UART_AdvFeatureConfig+0x228>)
3400f6d2:	4293      	cmp	r3, r2
3400f6d4:	d00f      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6d6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f6da:	4293      	cmp	r3, r2
3400f6dc:	d00b      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6de:	4a2b      	ldr	r2, [pc, #172]	@ (3400f78c <UART_AdvFeatureConfig+0x22c>)
3400f6e0:	4293      	cmp	r3, r2
3400f6e2:	d008      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6e4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f6e8:	4293      	cmp	r3, r2
3400f6ea:	d004      	beq.n	3400f6f6 <UART_AdvFeatureConfig+0x196>
3400f6ec:	f640 5112 	movw	r1, #3346	@ 0xd12
3400f6f0:	481d      	ldr	r0, [pc, #116]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f6f2:	f7f2 ff23 	bl	3400253c <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
3400f6f6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
3400f6f8:	f433 1380 	bics.w	r3, r3, #1048576	@ 0x100000
3400f6fc:	d004      	beq.n	3400f708 <UART_AdvFeatureConfig+0x1a8>
3400f6fe:	f640 5113 	movw	r1, #3347	@ 0xd13
3400f702:	4819      	ldr	r0, [pc, #100]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f704:	f7f2 ff1a 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
3400f708:	6821      	ldr	r1, [r4, #0]
3400f70a:	6c62      	ldr	r2, [r4, #68]	@ 0x44
3400f70c:	684b      	ldr	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3400f70e:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
3400f712:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3400f716:	ea43 0302 	orr.w	r3, r3, r2
3400f71a:	604b      	str	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3400f71c:	d10f      	bne.n	3400f73e <UART_AdvFeatureConfig+0x1de>
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
3400f71e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
3400f720:	f433 03c0 	bics.w	r3, r3, #6291456	@ 0x600000
3400f724:	d004      	beq.n	3400f730 <UART_AdvFeatureConfig+0x1d0>
3400f726:	f640 5118 	movw	r1, #3352	@ 0xd18
3400f72a:	480f      	ldr	r0, [pc, #60]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f72c:	f7f2 ff06 	bl	3400253c <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
3400f730:	6822      	ldr	r2, [r4, #0]
3400f732:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
3400f734:	6853      	ldr	r3, [r2, #4]
3400f736:	f423 03c0 	bic.w	r3, r3, #6291456	@ 0x600000
3400f73a:	430b      	orrs	r3, r1
3400f73c:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
3400f73e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400f740:	061b      	lsls	r3, r3, #24
3400f742:	d50f      	bpl.n	3400f764 <UART_AdvFeatureConfig+0x204>
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
3400f744:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3400f746:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
3400f74a:	d004      	beq.n	3400f756 <UART_AdvFeatureConfig+0x1f6>
3400f74c:	f44f 6152 	mov.w	r1, #3360	@ 0xd20
3400f750:	4805      	ldr	r0, [pc, #20]	@ (3400f768 <UART_AdvFeatureConfig+0x208>)
3400f752:	f7f2 fef3 	bl	3400253c <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
3400f756:	6822      	ldr	r2, [r4, #0]
3400f758:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3400f75a:	6853      	ldr	r3, [r2, #4]
3400f75c:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
3400f760:	430b      	orrs	r3, r1
3400f762:	6053      	str	r3, [r2, #4]
}
3400f764:	bd10      	pop	{r4, pc}
3400f766:	bf00      	nop
3400f768:	3401c8b3 	.word	0x3401c8b3
3400f76c:	52001000 	.word	0x52001000
3400f770:	50004400 	.word	0x50004400
3400f774:	50004800 	.word	0x50004800
3400f778:	50004c00 	.word	0x50004c00
3400f77c:	52001400 	.word	0x52001400
3400f780:	50007800 	.word	0x50007800
3400f784:	50007c00 	.word	0x50007c00
3400f788:	52001800 	.word	0x52001800
3400f78c:	52001c00 	.word	0x52001c00

3400f790 <UART_WaitOnFlagUntilTimeout>:
{
3400f790:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3400f794:	4604      	mov	r4, r0
3400f796:	460d      	mov	r5, r1
3400f798:	4617      	mov	r7, r2
3400f79a:	4698      	mov	r8, r3
3400f79c:	f8dd 9020 	ldr.w	r9, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
3400f7a0:	6822      	ldr	r2, [r4, #0]
3400f7a2:	69d3      	ldr	r3, [r2, #28]
3400f7a4:	ea35 0303 	bics.w	r3, r5, r3
3400f7a8:	bf0c      	ite	eq
3400f7aa:	2301      	moveq	r3, #1
3400f7ac:	2300      	movne	r3, #0
3400f7ae:	42bb      	cmp	r3, r7
3400f7b0:	d001      	beq.n	3400f7b6 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
3400f7b2:	2000      	movs	r0, #0
3400f7b4:	e022      	b.n	3400f7fc <UART_WaitOnFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
3400f7b6:	f1b9 3fff 	cmp.w	r9, #4294967295
3400f7ba:	d0f2      	beq.n	3400f7a2 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400f7bc:	f7f5 f898 	bl	340048f0 <HAL_GetTick>
3400f7c0:	eba0 0008 	sub.w	r0, r0, r8
3400f7c4:	4548      	cmp	r0, r9
3400f7c6:	d829      	bhi.n	3400f81c <UART_WaitOnFlagUntilTimeout+0x8c>
3400f7c8:	f1b9 0f00 	cmp.w	r9, #0
3400f7cc:	d026      	beq.n	3400f81c <UART_WaitOnFlagUntilTimeout+0x8c>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
3400f7ce:	6821      	ldr	r1, [r4, #0]
3400f7d0:	680b      	ldr	r3, [r1, #0]
3400f7d2:	075a      	lsls	r2, r3, #29
3400f7d4:	d5e4      	bpl.n	3400f7a0 <UART_WaitOnFlagUntilTimeout+0x10>
3400f7d6:	2d80      	cmp	r5, #128	@ 0x80
3400f7d8:	d0e2      	beq.n	3400f7a0 <UART_WaitOnFlagUntilTimeout+0x10>
3400f7da:	2d40      	cmp	r5, #64	@ 0x40
3400f7dc:	d0e0      	beq.n	3400f7a0 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
3400f7de:	69ce      	ldr	r6, [r1, #28]
3400f7e0:	f016 0608 	ands.w	r6, r6, #8
3400f7e4:	d00c      	beq.n	3400f800 <UART_WaitOnFlagUntilTimeout+0x70>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
3400f7e6:	2508      	movs	r5, #8
          UART_EndRxTransfer(huart);
3400f7e8:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
3400f7ea:	620d      	str	r5, [r1, #32]
          UART_EndRxTransfer(huart);
3400f7ec:	f7ff fd10 	bl	3400f210 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
3400f7f0:	2300      	movs	r3, #0
          return HAL_ERROR;
3400f7f2:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
3400f7f4:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
3400f7f8:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
3400f7fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
3400f800:	69cb      	ldr	r3, [r1, #28]
3400f802:	051b      	lsls	r3, r3, #20
3400f804:	d5cc      	bpl.n	3400f7a0 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
3400f806:	f44f 6300 	mov.w	r3, #2048	@ 0x800
          UART_EndRxTransfer(huart);
3400f80a:	4620      	mov	r0, r4
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
3400f80c:	620b      	str	r3, [r1, #32]
          UART_EndRxTransfer(huart);
3400f80e:	f7ff fcff 	bl	3400f210 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
3400f812:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
3400f814:	f884 6084 	strb.w	r6, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
3400f818:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
3400f81c:	2003      	movs	r0, #3
3400f81e:	e7ed      	b.n	3400f7fc <UART_WaitOnFlagUntilTimeout+0x6c>

3400f820 <HAL_UART_Transmit>:
{
3400f820:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
3400f824:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
3400f826:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
3400f82a:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
3400f82c:	2b20      	cmp	r3, #32
{
3400f82e:	460d      	mov	r5, r1
3400f830:	4616      	mov	r6, r2
  if (huart->gState == HAL_UART_STATE_READY)
3400f832:	d148      	bne.n	3400f8c6 <HAL_UART_Transmit+0xa6>
    if ((pData == NULL) || (Size == 0U))
3400f834:	2900      	cmp	r1, #0
3400f836:	d048      	beq.n	3400f8ca <HAL_UART_Transmit+0xaa>
3400f838:	2a00      	cmp	r2, #0
3400f83a:	d046      	beq.n	3400f8ca <HAL_UART_Transmit+0xaa>
    huart->gState = HAL_UART_STATE_BUSY_TX;
3400f83c:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
3400f83e:	f04f 0900 	mov.w	r9, #0
3400f842:	f8c0 9090 	str.w	r9, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
3400f846:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
3400f84a:	f7f5 f851 	bl	340048f0 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3400f84e:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
3400f850:	f8a4 6054 	strh.w	r6, [r4, #84]	@ 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3400f854:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
3400f858:	f8a4 6056 	strh.w	r6, [r4, #86]	@ 0x56
    tickstart = HAL_GetTick();
3400f85c:	4607      	mov	r7, r0
      pdata16bits = NULL;
3400f85e:	464e      	mov	r6, r9
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
3400f860:	d103      	bne.n	3400f86a <HAL_UART_Transmit+0x4a>
3400f862:	6923      	ldr	r3, [r4, #16]
3400f864:	b90b      	cbnz	r3, 3400f86a <HAL_UART_Transmit+0x4a>
      pdata16bits = (const uint16_t *) pData;
3400f866:	462e      	mov	r6, r5
      pdata8bits  = NULL;
3400f868:	461d      	mov	r5, r3
    while (huart->TxXferCount > 0U)
3400f86a:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3400f86e:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
3400f870:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3400f872:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
3400f876:	b942      	cbnz	r2, 3400f88a <HAL_UART_Transmit+0x6a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
3400f878:	2140      	movs	r1, #64	@ 0x40
3400f87a:	4620      	mov	r0, r4
3400f87c:	f7ff ff88 	bl	3400f790 <UART_WaitOnFlagUntilTimeout>
3400f880:	2320      	movs	r3, #32
3400f882:	b948      	cbnz	r0, 3400f898 <HAL_UART_Transmit+0x78>
    huart->gState = HAL_UART_STATE_READY;
3400f884:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
3400f888:	e009      	b.n	3400f89e <HAL_UART_Transmit+0x7e>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
3400f88a:	2200      	movs	r2, #0
3400f88c:	2180      	movs	r1, #128	@ 0x80
3400f88e:	4620      	mov	r0, r4
3400f890:	f7ff ff7e 	bl	3400f790 <UART_WaitOnFlagUntilTimeout>
3400f894:	b130      	cbz	r0, 3400f8a4 <HAL_UART_Transmit+0x84>
        huart->gState = HAL_UART_STATE_READY;
3400f896:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
3400f898:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
3400f89a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
3400f89e:	b003      	add	sp, #12
3400f8a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
3400f8a4:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
3400f8a6:	b95d      	cbnz	r5, 3400f8c0 <HAL_UART_Transmit+0xa0>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
3400f8a8:	f836 3b02 	ldrh.w	r3, [r6], #2
3400f8ac:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
3400f8b0:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
3400f8b2:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
3400f8b6:	3a01      	subs	r2, #1
3400f8b8:	b292      	uxth	r2, r2
3400f8ba:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
3400f8be:	e7d4      	b.n	3400f86a <HAL_UART_Transmit+0x4a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
3400f8c0:	f815 3b01 	ldrb.w	r3, [r5], #1
3400f8c4:	e7f4      	b.n	3400f8b0 <HAL_UART_Transmit+0x90>
    return HAL_BUSY;
3400f8c6:	2002      	movs	r0, #2
3400f8c8:	e7e9      	b.n	3400f89e <HAL_UART_Transmit+0x7e>
      return  HAL_ERROR;
3400f8ca:	2001      	movs	r0, #1
3400f8cc:	e7e7      	b.n	3400f89e <HAL_UART_Transmit+0x7e>

3400f8ce <UART_CheckIdleState>:
{
3400f8ce:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
3400f8d0:	2600      	movs	r6, #0
{
3400f8d2:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
3400f8d4:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
3400f8d8:	f7f5 f80a 	bl	340048f0 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
3400f8dc:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
3400f8de:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
3400f8e0:	681b      	ldr	r3, [r3, #0]
3400f8e2:	071a      	lsls	r2, r3, #28
3400f8e4:	d51c      	bpl.n	3400f920 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3400f8e6:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3400f8ea:	4632      	mov	r2, r6
3400f8ec:	9300      	str	r3, [sp, #0]
3400f8ee:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
3400f8f2:	4603      	mov	r3, r0
3400f8f4:	4620      	mov	r0, r4
3400f8f6:	f7ff ff4b 	bl	3400f790 <UART_WaitOnFlagUntilTimeout>
3400f8fa:	b188      	cbz	r0, 3400f920 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
3400f8fc:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f8fe:	e852 3f00 	ldrex	r3, [r2]
3400f902:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f906:	e842 3100 	strex	r1, r3, [r2]
3400f90a:	2900      	cmp	r1, #0
3400f90c:	d1f6      	bne.n	3400f8fc <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
3400f90e:	2320      	movs	r3, #32
3400f910:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
3400f914:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
3400f916:	2300      	movs	r3, #0
3400f918:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
3400f91c:	b002      	add	sp, #8
3400f91e:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
3400f920:	6823      	ldr	r3, [r4, #0]
3400f922:	681b      	ldr	r3, [r3, #0]
3400f924:	075b      	lsls	r3, r3, #29
3400f926:	d524      	bpl.n	3400f972 <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3400f928:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3400f92c:	2200      	movs	r2, #0
3400f92e:	9300      	str	r3, [sp, #0]
3400f930:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
3400f934:	462b      	mov	r3, r5
3400f936:	4620      	mov	r0, r4
3400f938:	f7ff ff2a 	bl	3400f790 <UART_WaitOnFlagUntilTimeout>
3400f93c:	b1c8      	cbz	r0, 3400f972 <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3400f93e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f940:	e852 3f00 	ldrex	r3, [r2]
3400f944:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f948:	e842 3100 	strex	r1, r3, [r2]
   return(result);
3400f94c:	6822      	ldr	r2, [r4, #0]
3400f94e:	2900      	cmp	r1, #0
3400f950:	d1f5      	bne.n	3400f93e <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400f952:	f102 0308 	add.w	r3, r2, #8
3400f956:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
3400f95a:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400f95e:	f102 0008 	add.w	r0, r2, #8
3400f962:	e840 3100 	strex	r1, r3, [r0]
3400f966:	2900      	cmp	r1, #0
3400f968:	d1f3      	bne.n	3400f952 <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
3400f96a:	2320      	movs	r3, #32
3400f96c:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
3400f970:	e7d0      	b.n	3400f914 <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
3400f972:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400f974:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
3400f976:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
3400f97a:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400f97e:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
3400f980:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
3400f982:	e7c8      	b.n	3400f916 <UART_CheckIdleState+0x48>

3400f984 <HAL_UART_Init>:
{
3400f984:	b510      	push	{r4, lr}
  if (huart == NULL)
3400f986:	4604      	mov	r4, r0
3400f988:	2800      	cmp	r0, #0
3400f98a:	f000 80d0 	beq.w	3400fb2e <HAL_UART_Init+0x1aa>
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
3400f98e:	6981      	ldr	r1, [r0, #24]
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
3400f990:	6803      	ldr	r3, [r0, #0]
3400f992:	4a68      	ldr	r2, [pc, #416]	@ (3400fb34 <HAL_UART_Init+0x1b0>)
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
3400f994:	2900      	cmp	r1, #0
3400f996:	d07c      	beq.n	3400fa92 <HAL_UART_Init+0x10e>
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
3400f998:	4293      	cmp	r3, r2
3400f99a:	d04e      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f99c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9a0:	4293      	cmp	r3, r2
3400f9a2:	d04a      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9a4:	4a64      	ldr	r2, [pc, #400]	@ (3400fb38 <HAL_UART_Init+0x1b4>)
3400f9a6:	4293      	cmp	r3, r2
3400f9a8:	d047      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9aa:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9ae:	4293      	cmp	r3, r2
3400f9b0:	d043      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9b2:	4a62      	ldr	r2, [pc, #392]	@ (3400fb3c <HAL_UART_Init+0x1b8>)
3400f9b4:	4293      	cmp	r3, r2
3400f9b6:	d040      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9b8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9bc:	4293      	cmp	r3, r2
3400f9be:	d03c      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9c0:	4a5f      	ldr	r2, [pc, #380]	@ (3400fb40 <HAL_UART_Init+0x1bc>)
3400f9c2:	4293      	cmp	r3, r2
3400f9c4:	d039      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9c6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9ca:	4293      	cmp	r3, r2
3400f9cc:	d035      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9ce:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400f9d2:	d032      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9d4:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400f9d8:	4293      	cmp	r3, r2
3400f9da:	d02e      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9dc:	4a59      	ldr	r2, [pc, #356]	@ (3400fb44 <HAL_UART_Init+0x1c0>)
3400f9de:	4293      	cmp	r3, r2
3400f9e0:	d02b      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9e2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9e6:	4293      	cmp	r3, r2
3400f9e8:	d027      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9ea:	4a57      	ldr	r2, [pc, #348]	@ (3400fb48 <HAL_UART_Init+0x1c4>)
3400f9ec:	4293      	cmp	r3, r2
3400f9ee:	d024      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9f0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400f9f4:	4293      	cmp	r3, r2
3400f9f6:	d020      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9f8:	4a54      	ldr	r2, [pc, #336]	@ (3400fb4c <HAL_UART_Init+0x1c8>)
3400f9fa:	4293      	cmp	r3, r2
3400f9fc:	d01d      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400f9fe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa02:	4293      	cmp	r3, r2
3400fa04:	d019      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa06:	4a52      	ldr	r2, [pc, #328]	@ (3400fb50 <HAL_UART_Init+0x1cc>)
3400fa08:	4293      	cmp	r3, r2
3400fa0a:	d016      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa0c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa10:	4293      	cmp	r3, r2
3400fa12:	d012      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa14:	4a4f      	ldr	r2, [pc, #316]	@ (3400fb54 <HAL_UART_Init+0x1d0>)
3400fa16:	4293      	cmp	r3, r2
3400fa18:	d00f      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa1a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa1e:	4293      	cmp	r3, r2
3400fa20:	d00b      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa22:	4a4d      	ldr	r2, [pc, #308]	@ (3400fb58 <HAL_UART_Init+0x1d4>)
3400fa24:	4293      	cmp	r3, r2
3400fa26:	d008      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa28:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fa2c:	4293      	cmp	r3, r2
3400fa2e:	d004      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa30:	f44f 71a0 	mov.w	r1, #320	@ 0x140
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
3400fa34:	4849      	ldr	r0, [pc, #292]	@ (3400fb5c <HAL_UART_Init+0x1d8>)
3400fa36:	f7f2 fd81 	bl	3400253c <assert_failed>
  if (huart->gState == HAL_UART_STATE_RESET)
3400fa3a:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3400fa3e:	b923      	cbnz	r3, 3400fa4a <HAL_UART_Init+0xc6>
    HAL_UART_MspInit(huart);
3400fa40:	4620      	mov	r0, r4
    huart->Lock = HAL_UNLOCKED;
3400fa42:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
    HAL_UART_MspInit(huart);
3400fa46:	f7ff fc0f 	bl	3400f268 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
3400fa4a:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
3400fa4c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
3400fa4e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
3400fa52:	6813      	ldr	r3, [r2, #0]
3400fa54:	f023 0301 	bic.w	r3, r3, #1
3400fa58:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
3400fa5a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400fa5c:	b113      	cbz	r3, 3400fa64 <HAL_UART_Init+0xe0>
    UART_AdvFeatureConfig(huart);
3400fa5e:	4620      	mov	r0, r4
3400fa60:	f7ff fd7e 	bl	3400f560 <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
3400fa64:	4620      	mov	r0, r4
3400fa66:	f7ff fc01 	bl	3400f26c <UART_SetConfig>
3400fa6a:	2801      	cmp	r0, #1
3400fa6c:	d05f      	beq.n	3400fb2e <HAL_UART_Init+0x1aa>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
3400fa6e:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
3400fa70:	4620      	mov	r0, r4
}
3400fa72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
3400fa76:	685a      	ldr	r2, [r3, #4]
3400fa78:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
3400fa7c:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
3400fa7e:	689a      	ldr	r2, [r3, #8]
3400fa80:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
3400fa84:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
3400fa86:	681a      	ldr	r2, [r3, #0]
3400fa88:	f042 0201 	orr.w	r2, r2, #1
3400fa8c:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
3400fa8e:	f7ff bf1e 	b.w	3400f8ce <UART_CheckIdleState>
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
3400fa92:	4293      	cmp	r3, r2
3400fa94:	d0d1      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa96:	4a32      	ldr	r2, [pc, #200]	@ (3400fb60 <HAL_UART_Init+0x1dc>)
3400fa98:	4293      	cmp	r3, r2
3400fa9a:	d0ce      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fa9c:	4a26      	ldr	r2, [pc, #152]	@ (3400fb38 <HAL_UART_Init+0x1b4>)
3400fa9e:	4293      	cmp	r3, r2
3400faa0:	d0cb      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400faa2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400faa6:	4293      	cmp	r3, r2
3400faa8:	d0c7      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400faaa:	4a24      	ldr	r2, [pc, #144]	@ (3400fb3c <HAL_UART_Init+0x1b8>)
3400faac:	4293      	cmp	r3, r2
3400faae:	d0c4      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fab0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fab4:	4293      	cmp	r3, r2
3400fab6:	d0c0      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fab8:	4a21      	ldr	r2, [pc, #132]	@ (3400fb40 <HAL_UART_Init+0x1bc>)
3400faba:	4293      	cmp	r3, r2
3400fabc:	d0bd      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fabe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fac2:	4293      	cmp	r3, r2
3400fac4:	d0b9      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fac6:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400faca:	d0b6      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400facc:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
3400fad0:	4293      	cmp	r3, r2
3400fad2:	d0b2      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fad4:	4a1b      	ldr	r2, [pc, #108]	@ (3400fb44 <HAL_UART_Init+0x1c0>)
3400fad6:	4293      	cmp	r3, r2
3400fad8:	d0af      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fada:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fade:	4293      	cmp	r3, r2
3400fae0:	d0ab      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fae2:	4a19      	ldr	r2, [pc, #100]	@ (3400fb48 <HAL_UART_Init+0x1c4>)
3400fae4:	4293      	cmp	r3, r2
3400fae6:	d0a8      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fae8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400faec:	4293      	cmp	r3, r2
3400faee:	d0a4      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400faf0:	4a16      	ldr	r2, [pc, #88]	@ (3400fb4c <HAL_UART_Init+0x1c8>)
3400faf2:	4293      	cmp	r3, r2
3400faf4:	d0a1      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400faf6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fafa:	4293      	cmp	r3, r2
3400fafc:	d09d      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fafe:	4a14      	ldr	r2, [pc, #80]	@ (3400fb50 <HAL_UART_Init+0x1cc>)
3400fb00:	4293      	cmp	r3, r2
3400fb02:	d09a      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fb04:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fb08:	4293      	cmp	r3, r2
3400fb0a:	d096      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fb0c:	4a11      	ldr	r2, [pc, #68]	@ (3400fb54 <HAL_UART_Init+0x1d0>)
3400fb0e:	4293      	cmp	r3, r2
3400fb10:	d093      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fb12:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fb16:	4293      	cmp	r3, r2
3400fb18:	d08f      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fb1a:	4a0f      	ldr	r2, [pc, #60]	@ (3400fb58 <HAL_UART_Init+0x1d4>)
3400fb1c:	4293      	cmp	r3, r2
3400fb1e:	d08c      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fb20:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400fb24:	4293      	cmp	r3, r2
3400fb26:	d088      	beq.n	3400fa3a <HAL_UART_Init+0xb6>
3400fb28:	f240 1145 	movw	r1, #325	@ 0x145
3400fb2c:	e782      	b.n	3400fa34 <HAL_UART_Init+0xb0>
}
3400fb2e:	2001      	movs	r0, #1
3400fb30:	bd10      	pop	{r4, pc}
3400fb32:	bf00      	nop
3400fb34:	52001000 	.word	0x52001000
3400fb38:	50004400 	.word	0x50004400
3400fb3c:	50004800 	.word	0x50004800
3400fb40:	50004c00 	.word	0x50004c00
3400fb44:	52001400 	.word	0x52001400
3400fb48:	50007800 	.word	0x50007800
3400fb4c:	50007c00 	.word	0x50007c00
3400fb50:	52001800 	.word	0x52001800
3400fb54:	52001c00 	.word	0x52001c00
3400fb58:	56000c00 	.word	0x56000c00
3400fb5c:	3401c8b3 	.word	0x3401c8b3
3400fb60:	42001000 	.word	0x42001000

3400fb64 <XSPI_ConfigCmd>:
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400fb64:	6802      	ldr	r2, [r0, #0]
{
3400fb66:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400fb6a:	6813      	ldr	r3, [r2, #0]
{
3400fb6c:	4606      	mov	r6, r0
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
3400fb6e:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3400fb72:	6013      	str	r3, [r2, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400fb74:	6883      	ldr	r3, [r0, #8]
{
3400fb76:	460c      	mov	r4, r1
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
3400fb78:	b97b      	cbnz	r3, 3400fb9a <XSPI_ConfigCmd+0x36>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
3400fb7a:	684b      	ldr	r3, [r1, #4]
3400fb7c:	f033 4340 	bics.w	r3, r3, #3221225472	@ 0xc0000000
3400fb80:	d004      	beq.n	3400fb8c <XSPI_ConfigCmd+0x28>
3400fb82:	f640 41a3 	movw	r1, #3235	@ 0xca3
3400fb86:	4876      	ldr	r0, [pc, #472]	@ (3400fd60 <XSPI_ConfigCmd+0x1fc>)
3400fb88:	f7f2 fcd8 	bl	3400253c <assert_failed>
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
3400fb8c:	6832      	ldr	r2, [r6, #0]
3400fb8e:	6861      	ldr	r1, [r4, #4]
3400fb90:	6813      	ldr	r3, [r2, #0]
3400fb92:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
3400fb96:	430b      	orrs	r3, r1
3400fb98:	6013      	str	r3, [r2, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400fb9a:	6823      	ldr	r3, [r4, #0]
  {
    ccr_reg = &(hxspi->Instance->WCCR);
3400fb9c:	6831      	ldr	r1, [r6, #0]
  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3400fb9e:	2b02      	cmp	r3, #2
3400fba0:	d158      	bne.n	3400fc54 <XSPI_ConfigCmd+0xf0>
    ccr_reg = &(hxspi->Instance->WCCR);
3400fba2:	f501 72c0 	add.w	r2, r1, #384	@ 0x180
    tcr_reg = &(hxspi->Instance->WTCR);
3400fba6:	f501 70c4 	add.w	r0, r1, #392	@ 0x188
    ir_reg  = &(hxspi->Instance->WIR);
3400fbaa:	f501 75c8 	add.w	r5, r1, #400	@ 0x190
    abr_reg = &(hxspi->Instance->WABR);
3400fbae:	f501 73d0 	add.w	r3, r1, #416	@ 0x1a0
    ir_reg  = &(hxspi->Instance->IR);
    abr_reg = &(hxspi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
3400fbb2:	6ca7      	ldr	r7, [r4, #72]	@ 0x48
3400fbb4:	6017      	str	r7, [r2, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3400fbb6:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
3400fbb8:	b167      	cbz	r7, 3400fbd4 <XSPI_ConfigCmd+0x70>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
3400fbba:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3400fbbc:	601f      	str	r7, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
3400fbbe:	6b67      	ldr	r7, [r4, #52]	@ 0x34
3400fbc0:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400fbc2:	f8d2 c000 	ldr.w	ip, [r2]
3400fbc6:	433b      	orrs	r3, r7
3400fbc8:	6b27      	ldr	r7, [r4, #48]	@ 0x30
3400fbca:	433b      	orrs	r3, r7
3400fbcc:	f42c 177c 	bic.w	r7, ip, #4128768	@ 0x3f0000
3400fbd0:	433b      	orrs	r3, r7
3400fbd2:	6013      	str	r3, [r2, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
3400fbd4:	6803      	ldr	r3, [r0, #0]
3400fbd6:	6c67      	ldr	r7, [r4, #68]	@ 0x44
3400fbd8:	f023 031f 	bic.w	r3, r3, #31
3400fbdc:	433b      	orrs	r3, r7
3400fbde:	6003      	str	r3, [r0, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fbe0:	f8d4 e038 	ldr.w	lr, [r4, #56]	@ 0x38
3400fbe4:	f1be 0f00 	cmp.w	lr, #0
3400fbe8:	d00e      	beq.n	3400fc08 <XSPI_ConfigCmd+0xa4>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3400fbea:	6823      	ldr	r3, [r4, #0]
3400fbec:	b913      	cbnz	r3, 3400fbf4 <XSPI_ConfigCmd+0x90>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
3400fbee:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400fbf0:	3b01      	subs	r3, #1
3400fbf2:	640b      	str	r3, [r1, #64]	@ 0x40
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
3400fbf4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400fbf6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400fbfa:	d13f      	bne.n	3400fc7c <XSPI_ConfigCmd+0x118>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400fbfc:	f8d1 3108 	ldr.w	r3, [r1, #264]	@ 0x108
3400fc00:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400fc04:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400fc08:	68e3      	ldr	r3, [r4, #12]
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fc0a:	f8d4 901c 	ldr.w	r9, [r4, #28]
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3400fc0e:	2b00      	cmp	r3, #0
3400fc10:	f000 8083 	beq.w	3400fd1a <XSPI_ConfigCmd+0x1b6>
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fc14:	e9d4 c804 	ldrd	ip, r8, [r4, #16]
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fc18:	f1b9 0f00 	cmp.w	r9, #0
3400fc1c:	d053      	beq.n	3400fcc6 <XSPI_ConfigCmd+0x162>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fc1e:	e9d4 0708 	ldrd	r0, r7, [r4, #32]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fc22:	f1be 0f00 	cmp.w	lr, #0
3400fc26:	d032      	beq.n	3400fc8e <XSPI_ConfigCmd+0x12a>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fc28:	ea4e 0303 	orr.w	r3, lr, r3
3400fc2c:	ea43 0309 	orr.w	r3, r3, r9
3400fc30:	ea43 0308 	orr.w	r3, r3, r8
3400fc34:	ea43 030c 	orr.w	r3, r3, ip
3400fc38:	433b      	orrs	r3, r7
3400fc3a:	4303      	orrs	r3, r0
3400fc3c:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400fc3e:	6816      	ldr	r6, [r2, #0]
3400fc40:	4303      	orrs	r3, r0
3400fc42:	4848      	ldr	r0, [pc, #288]	@ (3400fd64 <XSPI_ConfigCmd+0x200>)
3400fc44:	4030      	ands	r0, r6
3400fc46:	4303      	orrs	r3, r0

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fc48:	6013      	str	r3, [r2, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
3400fc4a:	68a3      	ldr	r3, [r4, #8]
3400fc4c:	602b      	str	r3, [r5, #0]
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
3400fc4e:	69a3      	ldr	r3, [r4, #24]
3400fc50:	648b      	str	r3, [r1, #72]	@ 0x48
3400fc52:	e04c      	b.n	3400fcee <XSPI_ConfigCmd+0x18a>
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
3400fc54:	2b03      	cmp	r3, #3
    ccr_reg = &(hxspi->Instance->WPCCR);
3400fc56:	bf01      	itttt	eq
3400fc58:	f501 72a0 	addeq.w	r2, r1, #320	@ 0x140
    tcr_reg = &(hxspi->Instance->WPTCR);
3400fc5c:	f501 70a4 	addeq.w	r0, r1, #328	@ 0x148
    ir_reg  = &(hxspi->Instance->WPIR);
3400fc60:	f501 75a8 	addeq.w	r5, r1, #336	@ 0x150
    abr_reg = &(hxspi->Instance->WPABR);
3400fc64:	f501 73b0 	addeq.w	r3, r1, #352	@ 0x160
    ccr_reg = &(hxspi->Instance->CCR);
3400fc68:	bf1f      	itttt	ne
3400fc6a:	f501 7280 	addne.w	r2, r1, #256	@ 0x100
    tcr_reg = &(hxspi->Instance->TCR);
3400fc6e:	f501 7084 	addne.w	r0, r1, #264	@ 0x108
    ir_reg  = &(hxspi->Instance->IR);
3400fc72:	f501 7588 	addne.w	r5, r1, #272	@ 0x110
    abr_reg = &(hxspi->Instance->ABR);
3400fc76:	f501 7390 	addne.w	r3, r1, #288	@ 0x120
3400fc7a:	e79a      	b.n	3400fbb2 <XSPI_ConfigCmd+0x4e>
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
3400fc7c:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
3400fc7e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400fc82:	d1c1      	bne.n	3400fc08 <XSPI_ConfigCmd+0xa4>
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3400fc84:	f8d1 3108 	ldr.w	r3, [r1, #264]	@ 0x108
3400fc88:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3400fc8c:	e7ba      	b.n	3400fc04 <XSPI_ConfigCmd+0xa0>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fc8e:	ea43 0309 	orr.w	r3, r3, r9
3400fc92:	f8d2 e000 	ldr.w	lr, [r2]
3400fc96:	ea43 0308 	orr.w	r3, r3, r8
3400fc9a:	ea43 030c 	orr.w	r3, r3, ip
3400fc9e:	433b      	orrs	r3, r7
3400fca0:	f42e 5e7c 	bic.w	lr, lr, #16128	@ 0x3f00
3400fca4:	4303      	orrs	r3, r0
3400fca6:	f02e 0e3f 	bic.w	lr, lr, #63	@ 0x3f
3400fcaa:	ea43 030e 	orr.w	r3, r3, lr
3400fcae:	6013      	str	r3, [r2, #0]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3400fcb0:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
3400fcb2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fcb6:	d1c8      	bne.n	3400fc4a <XSPI_ConfigCmd+0xe6>
3400fcb8:	6963      	ldr	r3, [r4, #20]
3400fcba:	2b08      	cmp	r3, #8
3400fcbc:	d1c5      	bne.n	3400fc4a <XSPI_ConfigCmd+0xe6>
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fcbe:	6813      	ldr	r3, [r2, #0]
3400fcc0:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400fcc4:	e7c0      	b.n	3400fc48 <XSPI_ConfigCmd+0xe4>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3400fcc6:	6811      	ldr	r1, [r2, #0]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fcc8:	f1be 0f00 	cmp.w	lr, #0
3400fccc:	d012      	beq.n	3400fcf4 <XSPI_ConfigCmd+0x190>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
3400fcce:	ea4e 0303 	orr.w	r3, lr, r3
3400fcd2:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400fcd4:	ea43 0308 	orr.w	r3, r3, r8
3400fcd8:	ea43 030c 	orr.w	r3, r3, ip
3400fcdc:	f021 6170 	bic.w	r1, r1, #251658240	@ 0xf000000
3400fce0:	4303      	orrs	r3, r0
3400fce2:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
3400fce6:	430b      	orrs	r3, r1
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fce8:	6013      	str	r3, [r2, #0]
      *ir_reg = pCmd->Instruction;
3400fcea:	68a3      	ldr	r3, [r4, #8]
3400fcec:	602b      	str	r3, [r5, #0]
  HAL_StatusTypeDef status = HAL_OK;
3400fcee:	2000      	movs	r0, #0
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
    }
  }

  return status;
}
3400fcf0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
3400fcf4:	ea43 0308 	orr.w	r3, r3, r8
3400fcf8:	ea43 030c 	orr.w	r3, r3, ip
3400fcfc:	f021 013f 	bic.w	r1, r1, #63	@ 0x3f
3400fd00:	430b      	orrs	r3, r1
3400fd02:	6013      	str	r3, [r2, #0]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
3400fd04:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
3400fd06:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400fd0a:	d1ee      	bne.n	3400fcea <XSPI_ConfigCmd+0x186>
3400fd0c:	6963      	ldr	r3, [r4, #20]
3400fd0e:	2b08      	cmp	r3, #8
3400fd10:	d1eb      	bne.n	3400fcea <XSPI_ConfigCmd+0x186>
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
3400fd12:	6813      	ldr	r3, [r2, #0]
3400fd14:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
3400fd18:	e7e6      	b.n	3400fce8 <XSPI_ConfigCmd+0x184>
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
3400fd1a:	f1b9 0f00 	cmp.w	r9, #0
3400fd1e:	d01b      	beq.n	3400fd58 <XSPI_ConfigCmd+0x1f4>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
3400fd20:	e9d4 6008 	ldrd	r6, r0, [r4, #32]
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3400fd24:	f1be 0f00 	cmp.w	lr, #0
3400fd28:	d00d      	beq.n	3400fd46 <XSPI_ConfigCmd+0x1e2>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
3400fd2a:	ea4e 0309 	orr.w	r3, lr, r9
3400fd2e:	6815      	ldr	r5, [r2, #0]
3400fd30:	4303      	orrs	r3, r0
3400fd32:	6c20      	ldr	r0, [r4, #64]	@ 0x40
3400fd34:	4333      	orrs	r3, r6
3400fd36:	4303      	orrs	r3, r0
3400fd38:	f025 6070 	bic.w	r0, r5, #251658240	@ 0xf000000
3400fd3c:	f420 507c 	bic.w	r0, r0, #16128	@ 0x3f00
3400fd40:	4303      	orrs	r3, r0
3400fd42:	6013      	str	r3, [r2, #0]
3400fd44:	e783      	b.n	3400fc4e <XSPI_ConfigCmd+0xea>
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
3400fd46:	6813      	ldr	r3, [r2, #0]
3400fd48:	ea40 0009 	orr.w	r0, r0, r9
3400fd4c:	4330      	orrs	r0, r6
3400fd4e:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400fd52:	4318      	orrs	r0, r3
3400fd54:	6010      	str	r0, [r2, #0]
3400fd56:	e77a      	b.n	3400fc4e <XSPI_ConfigCmd+0xea>
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400fd58:	2308      	movs	r3, #8
      status = HAL_ERROR;
3400fd5a:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3400fd5c:	65f3      	str	r3, [r6, #92]	@ 0x5c
3400fd5e:	e7c7      	b.n	3400fcf0 <XSPI_ConfigCmd+0x18c>
3400fd60:	3401c922 	.word	0x3401c922
3400fd64:	f0ffc0c0 	.word	0xf0ffc0c0

3400fd68 <XSPI_WaitFlagStateUntilTimeout>:
{
3400fd68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3400fd6c:	4604      	mov	r4, r0
3400fd6e:	460e      	mov	r6, r1
3400fd70:	4615      	mov	r5, r2
3400fd72:	461f      	mov	r7, r3
3400fd74:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3400fd78:	6822      	ldr	r2, [r4, #0]
3400fd7a:	6a13      	ldr	r3, [r2, #32]
3400fd7c:	4233      	tst	r3, r6
3400fd7e:	bf14      	ite	ne
3400fd80:	2301      	movne	r3, #1
3400fd82:	2300      	moveq	r3, #0
3400fd84:	42ab      	cmp	r3, r5
3400fd86:	d101      	bne.n	3400fd8c <XSPI_WaitFlagStateUntilTimeout+0x24>
  return HAL_OK;
3400fd88:	2000      	movs	r0, #0
3400fd8a:	e00e      	b.n	3400fdaa <XSPI_WaitFlagStateUntilTimeout+0x42>
    if (Timeout != HAL_MAX_DELAY)
3400fd8c:	f1b8 3fff 	cmp.w	r8, #4294967295
3400fd90:	d0f3      	beq.n	3400fd7a <XSPI_WaitFlagStateUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400fd92:	f7f4 fdad 	bl	340048f0 <HAL_GetTick>
3400fd96:	1bc0      	subs	r0, r0, r7
3400fd98:	4540      	cmp	r0, r8
3400fd9a:	d908      	bls.n	3400fdae <XSPI_WaitFlagStateUntilTimeout+0x46>
        hxspi->State     = HAL_XSPI_STATE_READY;
3400fd9c:	2302      	movs	r3, #2
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400fd9e:	2003      	movs	r0, #3
        hxspi->State     = HAL_XSPI_STATE_READY;
3400fda0:	65a3      	str	r3, [r4, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400fda2:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
3400fda4:	f043 0301 	orr.w	r3, r3, #1
3400fda8:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
3400fdaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400fdae:	f1b8 0f00 	cmp.w	r8, #0
3400fdb2:	d1e1      	bne.n	3400fd78 <XSPI_WaitFlagStateUntilTimeout+0x10>
3400fdb4:	e7f2      	b.n	3400fd9c <XSPI_WaitFlagStateUntilTimeout+0x34>

3400fdb6 <HAL_XSPI_MspInit>:
}
3400fdb6:	4770      	bx	lr

3400fdb8 <HAL_XSPI_Init>:
{
3400fdb8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3400fdba:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
3400fdbc:	f7f4 fd98 	bl	340048f0 <HAL_GetTick>
3400fdc0:	4606      	mov	r6, r0
  if (hxspi == NULL)
3400fdc2:	2c00      	cmp	r4, #0
3400fdc4:	f000 812a 	beq.w	3401001c <HAL_XSPI_Init+0x264>
    assert_param(IS_XSPI_MEMORY_MODE(hxspi->Init.MemoryMode));
3400fdc8:	68a3      	ldr	r3, [r4, #8]
3400fdca:	f033 0340 	bics.w	r3, r3, #64	@ 0x40
3400fdce:	d004      	beq.n	3400fdda <HAL_XSPI_Init+0x22>
3400fdd0:	f240 1161 	movw	r1, #353	@ 0x161
3400fdd4:	4892      	ldr	r0, [pc, #584]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fdd6:	f7f2 fbb1 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_MEMORY_TYPE(hxspi->Init.MemoryType));
3400fdda:	68e3      	ldr	r3, [r4, #12]
3400fddc:	f033 7240 	bics.w	r2, r3, #50331648	@ 0x3000000
3400fde0:	d009      	beq.n	3400fdf6 <HAL_XSPI_Init+0x3e>
3400fde2:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
3400fde6:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3400fdea:	d004      	beq.n	3400fdf6 <HAL_XSPI_Init+0x3e>
3400fdec:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3400fdf0:	488b      	ldr	r0, [pc, #556]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fdf2:	f7f2 fba3 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_MEMORY_SIZE(hxspi->Init.MemorySize));
3400fdf6:	6923      	ldr	r3, [r4, #16]
3400fdf8:	2b1f      	cmp	r3, #31
3400fdfa:	d904      	bls.n	3400fe06 <HAL_XSPI_Init+0x4e>
3400fdfc:	f240 1163 	movw	r1, #355	@ 0x163
3400fe00:	4887      	ldr	r0, [pc, #540]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe02:	f7f2 fb9b 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_CS_HIGH_TIME_CYCLE(hxspi->Init.ChipSelectHighTimeCycle));
3400fe06:	6963      	ldr	r3, [r4, #20]
3400fe08:	3b01      	subs	r3, #1
3400fe0a:	2b3f      	cmp	r3, #63	@ 0x3f
3400fe0c:	d904      	bls.n	3400fe18 <HAL_XSPI_Init+0x60>
3400fe0e:	f44f 71b2 	mov.w	r1, #356	@ 0x164
3400fe12:	4883      	ldr	r0, [pc, #524]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe14:	f7f2 fb92 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_FREE_RUN_CLK(hxspi->Init.FreeRunningClock));
3400fe18:	69a3      	ldr	r3, [r4, #24]
3400fe1a:	f033 0302 	bics.w	r3, r3, #2
3400fe1e:	d004      	beq.n	3400fe2a <HAL_XSPI_Init+0x72>
3400fe20:	f240 1165 	movw	r1, #357	@ 0x165
3400fe24:	487e      	ldr	r0, [pc, #504]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe26:	f7f2 fb89 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_CLOCK_MODE(hxspi->Init.ClockMode));
3400fe2a:	69e3      	ldr	r3, [r4, #28]
3400fe2c:	2b01      	cmp	r3, #1
3400fe2e:	d904      	bls.n	3400fe3a <HAL_XSPI_Init+0x82>
3400fe30:	f44f 71b3 	mov.w	r1, #358	@ 0x166
3400fe34:	487a      	ldr	r0, [pc, #488]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe36:	f7f2 fb81 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_WRAP_SIZE(hxspi->Init.WrapSize));
3400fe3a:	6a23      	ldr	r3, [r4, #32]
3400fe3c:	f433 3200 	bics.w	r2, r3, #131072	@ 0x20000
3400fe40:	d00c      	beq.n	3400fe5c <HAL_XSPI_Init+0xa4>
3400fe42:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400fe46:	d009      	beq.n	3400fe5c <HAL_XSPI_Init+0xa4>
3400fe48:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400fe4c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400fe50:	d004      	beq.n	3400fe5c <HAL_XSPI_Init+0xa4>
3400fe52:	f240 1167 	movw	r1, #359	@ 0x167
3400fe56:	4872      	ldr	r0, [pc, #456]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe58:	f7f2 fb70 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_CLK_PRESCALER(hxspi->Init.ClockPrescaler));
3400fe5c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
3400fe5e:	2bff      	cmp	r3, #255	@ 0xff
3400fe60:	d904      	bls.n	3400fe6c <HAL_XSPI_Init+0xb4>
3400fe62:	f44f 71b4 	mov.w	r1, #360	@ 0x168
3400fe66:	486e      	ldr	r0, [pc, #440]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe68:	f7f2 fb68 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_SAMPLE_SHIFTING(hxspi->Init.SampleShifting));
3400fe6c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
3400fe6e:	f033 4380 	bics.w	r3, r3, #1073741824	@ 0x40000000
3400fe72:	d004      	beq.n	3400fe7e <HAL_XSPI_Init+0xc6>
3400fe74:	f240 1169 	movw	r1, #361	@ 0x169
3400fe78:	4869      	ldr	r0, [pc, #420]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe7a:	f7f2 fb5f 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_DHQC(hxspi->Init.DelayHoldQuarterCycle));
3400fe7e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
3400fe80:	f033 5380 	bics.w	r3, r3, #268435456	@ 0x10000000
3400fe84:	d004      	beq.n	3400fe90 <HAL_XSPI_Init+0xd8>
3400fe86:	f44f 71b5 	mov.w	r1, #362	@ 0x16a
3400fe8a:	4865      	ldr	r0, [pc, #404]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe8c:	f7f2 fb56 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_CS_BOUND(hxspi->Init.ChipSelectBoundary));
3400fe90:	6b23      	ldr	r3, [r4, #48]	@ 0x30
3400fe92:	2b1f      	cmp	r3, #31
3400fe94:	d904      	bls.n	3400fea0 <HAL_XSPI_Init+0xe8>
3400fe96:	f240 116b 	movw	r1, #363	@ 0x16b
3400fe9a:	4861      	ldr	r0, [pc, #388]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fe9c:	f7f2 fb4e 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
3400fea0:	6863      	ldr	r3, [r4, #4]
3400fea2:	3b01      	subs	r3, #1
3400fea4:	2b3f      	cmp	r3, #63	@ 0x3f
3400fea6:	d904      	bls.n	3400feb2 <HAL_XSPI_Init+0xfa>
3400fea8:	f44f 71b6 	mov.w	r1, #364	@ 0x16c
3400feac:	485c      	ldr	r0, [pc, #368]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400feae:	f7f2 fb45 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
3400feb2:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3400feb4:	2bff      	cmp	r3, #255	@ 0xff
3400feb6:	d904      	bls.n	3400fec2 <HAL_XSPI_Init+0x10a>
3400feb8:	f240 116d 	movw	r1, #365	@ 0x16d
3400febc:	4858      	ldr	r0, [pc, #352]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400febe:	f7f2 fb3d 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
3400fec2:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
3400fec4:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
3400fec8:	d004      	beq.n	3400fed4 <HAL_XSPI_Init+0x11c>
3400feca:	f44f 71b7 	mov.w	r1, #366	@ 0x16e
3400fece:	4854      	ldr	r0, [pc, #336]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fed0:	f7f2 fb34 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
3400fed4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3400fed6:	f433 1300 	bics.w	r3, r3, #2097152	@ 0x200000
3400feda:	d004      	beq.n	3400fee6 <HAL_XSPI_Init+0x12e>
3400fedc:	f240 116f 	movw	r1, #367	@ 0x16f
3400fee0:	484f      	ldr	r0, [pc, #316]	@ (34010020 <HAL_XSPI_Init+0x268>)
3400fee2:	f7f2 fb2b 	bl	3400253c <assert_failed>
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3400fee6:	2300      	movs	r3, #0
3400fee8:	65e3      	str	r3, [r4, #92]	@ 0x5c
    if (hxspi->State == HAL_XSPI_STATE_RESET)
3400feea:	6da7      	ldr	r7, [r4, #88]	@ 0x58
3400feec:	2f00      	cmp	r7, #0
3400feee:	f040 8087 	bne.w	34010000 <HAL_XSPI_Init+0x248>
      HAL_XSPI_MspInit(hxspi);
3400fef2:	4620      	mov	r0, r4
3400fef4:	f7ff ff5f 	bl	3400fdb6 <HAL_XSPI_MspInit>
  hxspi->Timeout = Timeout;
3400fef8:	f241 3288 	movw	r2, #5000	@ 0x1388
      MODIFY_REG(hxspi->Instance->DCR1,
3400fefc:	69e3      	ldr	r3, [r4, #28]
3400fefe:	68e5      	ldr	r5, [r4, #12]
3400ff00:	6821      	ldr	r1, [r4, #0]
3400ff02:	431d      	orrs	r5, r3
3400ff04:	6923      	ldr	r3, [r4, #16]
3400ff06:	6888      	ldr	r0, [r1, #8]
3400ff08:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
3400ff0c:	4b45      	ldr	r3, [pc, #276]	@ (34010024 <HAL_XSPI_Init+0x26c>)
  hxspi->Timeout = Timeout;
3400ff0e:	6622      	str	r2, [r4, #96]	@ 0x60
      MODIFY_REG(hxspi->Instance->DCR1,
3400ff10:	4003      	ands	r3, r0
3400ff12:	431d      	orrs	r5, r3
3400ff14:	6963      	ldr	r3, [r4, #20]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400ff16:	6a20      	ldr	r0, [r4, #32]
      MODIFY_REG(hxspi->Instance->DCR1,
3400ff18:	3b01      	subs	r3, #1
3400ff1a:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
3400ff1e:	608d      	str	r5, [r1, #8]
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400ff20:	68cb      	ldr	r3, [r1, #12]
3400ff22:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400ff26:	4303      	orrs	r3, r0
3400ff28:	60cb      	str	r3, [r1, #12]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3400ff2a:	690b      	ldr	r3, [r1, #16]
3400ff2c:	6b20      	ldr	r0, [r4, #48]	@ 0x30
3400ff2e:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
3400ff32:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3400ff36:	610b      	str	r3, [r1, #16]
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3400ff38:	690b      	ldr	r3, [r1, #16]
3400ff3a:	6b60      	ldr	r0, [r4, #52]	@ 0x34
3400ff3c:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400ff40:	4303      	orrs	r3, r0
3400ff42:	610b      	str	r3, [r1, #16]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400ff44:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400ff46:	6860      	ldr	r0, [r4, #4]
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400ff48:	614b      	str	r3, [r1, #20]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400ff4a:	680b      	ldr	r3, [r1, #0]
3400ff4c:	3801      	subs	r0, #1
3400ff4e:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3400ff52:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
3400ff56:	600b      	str	r3, [r1, #0]
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400ff58:	4620      	mov	r0, r4
3400ff5a:	9200      	str	r2, [sp, #0]
3400ff5c:	4633      	mov	r3, r6
3400ff5e:	463a      	mov	r2, r7
3400ff60:	2120      	movs	r1, #32
3400ff62:	f7ff ff01 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
3400ff66:	2800      	cmp	r0, #0
3400ff68:	d156      	bne.n	34010018 <HAL_XSPI_Init+0x260>
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3400ff6a:	6823      	ldr	r3, [r4, #0]
3400ff6c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3400ff6e:	68da      	ldr	r2, [r3, #12]
3400ff70:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
3400ff74:	430a      	orrs	r2, r1
3400ff76:	60da      	str	r2, [r3, #12]
        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3400ff78:	4a2b      	ldr	r2, [pc, #172]	@ (34010028 <HAL_XSPI_Init+0x270>)
3400ff7a:	4293      	cmp	r3, r2
3400ff7c:	d042      	beq.n	34010004 <HAL_XSPI_Init+0x24c>
3400ff7e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400ff82:	4293      	cmp	r3, r2
3400ff84:	d03e      	beq.n	34010004 <HAL_XSPI_Init+0x24c>
3400ff86:	4a29      	ldr	r2, [pc, #164]	@ (3401002c <HAL_XSPI_Init+0x274>)
3400ff88:	4293      	cmp	r3, r2
3400ff8a:	d03b      	beq.n	34010004 <HAL_XSPI_Init+0x24c>
3400ff8c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400ff90:	4293      	cmp	r3, r2
3400ff92:	d037      	beq.n	34010004 <HAL_XSPI_Init+0x24c>
3400ff94:	4a26      	ldr	r2, [pc, #152]	@ (34010030 <HAL_XSPI_Init+0x278>)
3400ff96:	4293      	cmp	r3, r2
3400ff98:	d034      	beq.n	34010004 <HAL_XSPI_Init+0x24c>
3400ff9a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
3400ff9e:	4293      	cmp	r3, r2
3400ffa0:	d030      	beq.n	34010004 <HAL_XSPI_Init+0x24c>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
3400ffa2:	6823      	ldr	r3, [r4, #0]
3400ffa4:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3400ffa6:	6819      	ldr	r1, [r3, #0]
3400ffa8:	68a2      	ldr	r2, [r4, #8]
3400ffaa:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
3400ffae:	4302      	orrs	r2, r0
3400ffb0:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
3400ffb4:	430a      	orrs	r2, r1
3400ffb6:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT | XSPI_TCR_DHQC),
3400ffb8:	f8d3 1108 	ldr.w	r1, [r3, #264]	@ 0x108
3400ffbc:	e9d4 200a 	ldrd	r2, r0, [r4, #40]	@ 0x28
3400ffc0:	f021 41a0 	bic.w	r1, r1, #1342177280	@ 0x50000000
3400ffc4:	4302      	orrs	r2, r0
3400ffc6:	430a      	orrs	r2, r1
3400ffc8:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
        HAL_XSPI_ENABLE(hxspi);
3400ffcc:	681a      	ldr	r2, [r3, #0]
3400ffce:	f042 0201 	orr.w	r2, r2, #1
3400ffd2:	601a      	str	r2, [r3, #0]
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
3400ffd4:	69a2      	ldr	r2, [r4, #24]
3400ffd6:	2a02      	cmp	r2, #2
3400ffd8:	d103      	bne.n	3400ffe2 <HAL_XSPI_Init+0x22a>
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3400ffda:	689a      	ldr	r2, [r3, #8]
3400ffdc:	f042 0202 	orr.w	r2, r2, #2
3400ffe0:	609a      	str	r2, [r3, #8]
        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3400ffe2:	6c22      	ldr	r2, [r4, #64]	@ 0x40
3400ffe4:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
3400ffe8:	bf02      	ittt	eq
3400ffea:	689a      	ldreq	r2, [r3, #8]
3400ffec:	f442 1200 	orreq.w	r2, r2, #2097152	@ 0x200000
3400fff0:	609a      	streq	r2, [r3, #8]
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3400fff2:	68e3      	ldr	r3, [r4, #12]
3400fff4:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3400fff8:	bf0c      	ite	eq
3400fffa:	2301      	moveq	r3, #1
          hxspi->State = HAL_XSPI_STATE_READY;
3400fffc:	2302      	movne	r3, #2
3400fffe:	65a3      	str	r3, [r4, #88]	@ 0x58
  HAL_StatusTypeDef status = HAL_OK;
34010000:	2000      	movs	r0, #0
34010002:	e009      	b.n	34010018 <HAL_XSPI_Init+0x260>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34010004:	6e23      	ldr	r3, [r4, #96]	@ 0x60
34010006:	2200      	movs	r2, #0
34010008:	9300      	str	r3, [sp, #0]
3401000a:	2120      	movs	r1, #32
3401000c:	4633      	mov	r3, r6
3401000e:	4620      	mov	r0, r4
34010010:	f7ff feaa 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
          if (status != HAL_OK)
34010014:	2800      	cmp	r0, #0
34010016:	d0c4      	beq.n	3400ffa2 <HAL_XSPI_Init+0x1ea>
}
34010018:	b003      	add	sp, #12
3401001a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_ERROR;
3401001c:	2001      	movs	r0, #1
3401001e:	e7fb      	b.n	34010018 <HAL_XSPI_Init+0x260>
34010020:	3401c922 	.word	0x3401c922
34010024:	f8e0c0fc 	.word	0xf8e0c0fc
34010028:	58025000 	.word	0x58025000
3401002c:	5802a000 	.word	0x5802a000
34010030:	5802d000 	.word	0x5802d000

34010034 <HAL_XSPI_Command>:
{
34010034:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34010036:	460c      	mov	r4, r1
34010038:	4605      	mov	r5, r0
3401003a:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
3401003c:	f7f4 fc58 	bl	340048f0 <HAL_GetTick>
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
34010040:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
34010042:	4606      	mov	r6, r0
  assert_param(IS_XSPI_OPERATION_TYPE(pCmd->OperationType));
34010044:	2b03      	cmp	r3, #3
34010046:	d904      	bls.n	34010052 <HAL_XSPI_Command+0x1e>
34010048:	f240 313e 	movw	r1, #830	@ 0x33e
3401004c:	4884      	ldr	r0, [pc, #528]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401004e:	f7f2 fa75 	bl	3400253c <assert_failed>
  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
34010052:	68ab      	ldr	r3, [r5, #8]
34010054:	b943      	cbnz	r3, 34010068 <HAL_XSPI_Command+0x34>
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
34010056:	6863      	ldr	r3, [r4, #4]
34010058:	f033 4340 	bics.w	r3, r3, #3221225472	@ 0xc0000000
3401005c:	d004      	beq.n	34010068 <HAL_XSPI_Command+0x34>
3401005e:	f240 3141 	movw	r1, #833	@ 0x341
34010062:	487f      	ldr	r0, [pc, #508]	@ (34010260 <HAL_XSPI_Command+0x22c>)
34010064:	f7f2 fa6a 	bl	3400253c <assert_failed>
  assert_param(IS_XSPI_INSTRUCTION_MODE(pCmd->InstructionMode));
34010068:	68e3      	ldr	r3, [r4, #12]
3401006a:	2b04      	cmp	r3, #4
3401006c:	d904      	bls.n	34010078 <HAL_XSPI_Command+0x44>
3401006e:	f44f 7151 	mov.w	r1, #836	@ 0x344
34010072:	487b      	ldr	r0, [pc, #492]	@ (34010260 <HAL_XSPI_Command+0x22c>)
34010074:	f7f2 fa62 	bl	3400253c <assert_failed>
  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
34010078:	68e3      	ldr	r3, [r4, #12]
3401007a:	b18b      	cbz	r3, 340100a0 <HAL_XSPI_Command+0x6c>
    assert_param(IS_XSPI_INSTRUCTION_WIDTH(pCmd->InstructionWidth));
3401007c:	6923      	ldr	r3, [r4, #16]
3401007e:	f033 0330 	bics.w	r3, r3, #48	@ 0x30
34010082:	d004      	beq.n	3401008e <HAL_XSPI_Command+0x5a>
34010084:	f240 3147 	movw	r1, #839	@ 0x347
34010088:	4875      	ldr	r0, [pc, #468]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401008a:	f7f2 fa57 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_INSTRUCTION_DTR_MODE(pCmd->InstructionDTRMode));
3401008e:	6963      	ldr	r3, [r4, #20]
34010090:	f033 0308 	bics.w	r3, r3, #8
34010094:	d004      	beq.n	340100a0 <HAL_XSPI_Command+0x6c>
34010096:	f44f 7152 	mov.w	r1, #840	@ 0x348
3401009a:	4871      	ldr	r0, [pc, #452]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401009c:	f7f2 fa4e 	bl	3400253c <assert_failed>
  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
340100a0:	69e3      	ldr	r3, [r4, #28]
340100a2:	b303      	cbz	r3, 340100e6 <HAL_XSPI_Command+0xb2>
340100a4:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
340100a8:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
340100ac:	d10d      	bne.n	340100ca <HAL_XSPI_Command+0x96>
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
340100ae:	6a23      	ldr	r3, [r4, #32]
340100b0:	f433 5340 	bics.w	r3, r3, #12288	@ 0x3000
340100b4:	d12c      	bne.n	34010110 <HAL_XSPI_Command+0xdc>
    assert_param(IS_XSPI_ADDRESS_DTR_MODE(pCmd->AddressDTRMode));
340100b6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
340100b8:	f433 6300 	bics.w	r3, r3, #2048	@ 0x800
340100bc:	d013      	beq.n	340100e6 <HAL_XSPI_Command+0xb2>
340100be:	f240 314f 	movw	r1, #847	@ 0x34f
340100c2:	4867      	ldr	r0, [pc, #412]	@ (34010260 <HAL_XSPI_Command+0x22c>)
340100c4:	f7f2 fa3a 	bl	3400253c <assert_failed>
340100c8:	e00d      	b.n	340100e6 <HAL_XSPI_Command+0xb2>
  assert_param(IS_XSPI_ADDRESS_MODE(pCmd->AddressMode));
340100ca:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340100ce:	d0ee      	beq.n	340100ae <HAL_XSPI_Command+0x7a>
340100d0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340100d4:	d0eb      	beq.n	340100ae <HAL_XSPI_Command+0x7a>
340100d6:	f240 314b 	movw	r1, #843	@ 0x34b
340100da:	4861      	ldr	r0, [pc, #388]	@ (34010260 <HAL_XSPI_Command+0x22c>)
340100dc:	f7f2 fa2e 	bl	3400253c <assert_failed>
  if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
340100e0:	69e3      	ldr	r3, [r4, #28]
340100e2:	2b00      	cmp	r3, #0
340100e4:	d1e3      	bne.n	340100ae <HAL_XSPI_Command+0x7a>
  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
340100e6:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
340100e8:	b333      	cbz	r3, 34010138 <HAL_XSPI_Command+0x104>
340100ea:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
340100ee:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
340100f2:	d113      	bne.n	3401011c <HAL_XSPI_Command+0xe8>
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
340100f4:	6b23      	ldr	r3, [r4, #48]	@ 0x30
340100f6:	f433 1340 	bics.w	r3, r3, #3145728	@ 0x300000
340100fa:	d13d      	bne.n	34010178 <HAL_XSPI_Command+0x144>
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
340100fc:	6b63      	ldr	r3, [r4, #52]	@ 0x34
340100fe:	f433 2300 	bics.w	r3, r3, #524288	@ 0x80000
34010102:	d019      	beq.n	34010138 <HAL_XSPI_Command+0x104>
34010104:	f240 3156 	movw	r1, #854	@ 0x356
34010108:	4855      	ldr	r0, [pc, #340]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401010a:	f7f2 fa17 	bl	3400253c <assert_failed>
3401010e:	e013      	b.n	34010138 <HAL_XSPI_Command+0x104>
    assert_param(IS_XSPI_ADDRESS_WIDTH(pCmd->AddressWidth));
34010110:	f240 314e 	movw	r1, #846	@ 0x34e
34010114:	4852      	ldr	r0, [pc, #328]	@ (34010260 <HAL_XSPI_Command+0x22c>)
34010116:	f7f2 fa11 	bl	3400253c <assert_failed>
3401011a:	e7cc      	b.n	340100b6 <HAL_XSPI_Command+0x82>
  assert_param(IS_XSPI_ALT_BYTES_MODE(pCmd->AlternateBytesMode));
3401011c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34010120:	d0e8      	beq.n	340100f4 <HAL_XSPI_Command+0xc0>
34010122:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34010126:	d0e5      	beq.n	340100f4 <HAL_XSPI_Command+0xc0>
34010128:	f240 3152 	movw	r1, #850	@ 0x352
3401012c:	484c      	ldr	r0, [pc, #304]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401012e:	f7f2 fa05 	bl	3400253c <assert_failed>
  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
34010132:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34010134:	2b00      	cmp	r3, #0
34010136:	d1dd      	bne.n	340100f4 <HAL_XSPI_Command+0xc0>
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
34010138:	68eb      	ldr	r3, [r5, #12]
3401013a:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
3401013c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34010140:	d120      	bne.n	34010184 <HAL_XSPI_Command+0x150>
34010142:	b389      	cbz	r1, 340101a8 <HAL_XSPI_Command+0x174>
34010144:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
34010148:	f1b1 6f80 	cmp.w	r1, #67108864	@ 0x4000000
3401014c:	d124      	bne.n	34010198 <HAL_XSPI_Command+0x164>
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
3401014e:	6823      	ldr	r3, [r4, #0]
34010150:	2b00      	cmp	r3, #0
34010152:	d03d      	beq.n	340101d0 <HAL_XSPI_Command+0x19c>
    assert_param(IS_XSPI_DATA_DTR_MODE(pCmd->DataDTRMode));
34010154:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34010156:	f033 6300 	bics.w	r3, r3, #134217728	@ 0x8000000
3401015a:	d004      	beq.n	34010166 <HAL_XSPI_Command+0x132>
3401015c:	f240 3161 	movw	r1, #865	@ 0x361
34010160:	483f      	ldr	r0, [pc, #252]	@ (34010260 <HAL_XSPI_Command+0x22c>)
34010162:	f7f2 f9eb 	bl	3400253c <assert_failed>
    assert_param(IS_XSPI_DUMMY_CYCLES(pCmd->DummyCycles));
34010166:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010168:	2b1f      	cmp	r3, #31
3401016a:	d91d      	bls.n	340101a8 <HAL_XSPI_Command+0x174>
3401016c:	f240 3162 	movw	r1, #866	@ 0x362
34010170:	483b      	ldr	r0, [pc, #236]	@ (34010260 <HAL_XSPI_Command+0x22c>)
34010172:	f7f2 f9e3 	bl	3400253c <assert_failed>
34010176:	e017      	b.n	340101a8 <HAL_XSPI_Command+0x174>
    assert_param(IS_XSPI_ALT_BYTES_WIDTH(pCmd->AlternateBytesWidth));
34010178:	f240 3155 	movw	r1, #853	@ 0x355
3401017c:	4838      	ldr	r0, [pc, #224]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401017e:	f7f2 f9dd 	bl	3400253c <assert_failed>
34010182:	e7bb      	b.n	340100fc <HAL_XSPI_Command+0xc8>
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));
34010184:	b181      	cbz	r1, 340101a8 <HAL_XSPI_Command+0x174>
34010186:	f021 7300 	bic.w	r3, r1, #33554432	@ 0x2000000
3401018a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401018e:	d0de      	beq.n	3401014e <HAL_XSPI_Command+0x11a>
34010190:	f1b1 7f00 	cmp.w	r1, #33554432	@ 0x2000000
34010194:	d1d6      	bne.n	34010144 <HAL_XSPI_Command+0x110>
34010196:	e7da      	b.n	3401014e <HAL_XSPI_Command+0x11a>
34010198:	f240 3159 	movw	r1, #857	@ 0x359
3401019c:	4830      	ldr	r0, [pc, #192]	@ (34010260 <HAL_XSPI_Command+0x22c>)
3401019e:	f7f2 f9cd 	bl	3400253c <assert_failed>
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
340101a2:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
340101a4:	2b00      	cmp	r3, #0
340101a6:	d1d2      	bne.n	3401014e <HAL_XSPI_Command+0x11a>
  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));
340101a8:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
340101aa:	f033 5300 	bics.w	r3, r3, #536870912	@ 0x20000000
340101ae:	d004      	beq.n	340101ba <HAL_XSPI_Command+0x186>
340101b0:	f240 3165 	movw	r1, #869	@ 0x365
340101b4:	482a      	ldr	r0, [pc, #168]	@ (34010260 <HAL_XSPI_Command+0x22c>)
340101b6:	f7f2 f9c1 	bl	3400253c <assert_failed>
  state = hxspi->State;
340101ba:	6dab      	ldr	r3, [r5, #88]	@ 0x58
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
340101bc:	2b02      	cmp	r3, #2
340101be:	d110      	bne.n	340101e2 <HAL_XSPI_Command+0x1ae>
340101c0:	68eb      	ldr	r3, [r5, #12]
340101c2:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
340101c6:	d112      	bne.n	340101ee <HAL_XSPI_Command+0x1ba>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340101c8:	2310      	movs	r3, #16
    status = HAL_ERROR;
340101ca:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340101cc:	65eb      	str	r3, [r5, #92]	@ 0x5c
340101ce:	e028      	b.n	34010222 <HAL_XSPI_Command+0x1ee>
      assert_param(IS_XSPI_DATA_LENGTH(pCmd->DataLength));
340101d0:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
340101d2:	2b00      	cmp	r3, #0
340101d4:	d1be      	bne.n	34010154 <HAL_XSPI_Command+0x120>
340101d6:	f240 315f 	movw	r1, #863	@ 0x35f
340101da:	4821      	ldr	r0, [pc, #132]	@ (34010260 <HAL_XSPI_Command+0x22c>)
340101dc:	f7f2 f9ae 	bl	3400253c <assert_failed>
340101e0:	e7b8      	b.n	34010154 <HAL_XSPI_Command+0x120>
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
340101e2:	2b14      	cmp	r3, #20
340101e4:	d11f      	bne.n	34010226 <HAL_XSPI_Command+0x1f2>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
340101e6:	6823      	ldr	r3, [r4, #0]
340101e8:	3b02      	subs	r3, #2
340101ea:	2b01      	cmp	r3, #1
340101ec:	d8ec      	bhi.n	340101c8 <HAL_XSPI_Command+0x194>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
340101ee:	4633      	mov	r3, r6
340101f0:	2200      	movs	r2, #0
340101f2:	2120      	movs	r1, #32
340101f4:	4628      	mov	r0, r5
340101f6:	9700      	str	r7, [sp, #0]
340101f8:	f7ff fdb6 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
340101fc:	bb70      	cbnz	r0, 3401025c <HAL_XSPI_Command+0x228>
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
340101fe:	65e8      	str	r0, [r5, #92]	@ 0x5c
      status = XSPI_ConfigCmd(hxspi, pCmd);
34010200:	4621      	mov	r1, r4
34010202:	4628      	mov	r0, r5
34010204:	f7ff fcae 	bl	3400fb64 <XSPI_ConfigCmd>
      if (status == HAL_OK)
34010208:	b958      	cbnz	r0, 34010222 <HAL_XSPI_Command+0x1ee>
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
3401020a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
3401020c:	b99b      	cbnz	r3, 34010236 <HAL_XSPI_Command+0x202>
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3401020e:	4633      	mov	r3, r6
34010210:	2201      	movs	r2, #1
34010212:	2102      	movs	r1, #2
34010214:	4628      	mov	r0, r5
34010216:	9700      	str	r7, [sp, #0]
34010218:	f7ff fda6 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3401021c:	2202      	movs	r2, #2
3401021e:	682b      	ldr	r3, [r5, #0]
34010220:	625a      	str	r2, [r3, #36]	@ 0x24
}
34010222:	b003      	add	sp, #12
34010224:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34010226:	2b24      	cmp	r3, #36	@ 0x24
34010228:	d1ce      	bne.n	340101c8 <HAL_XSPI_Command+0x194>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
3401022a:	6823      	ldr	r3, [r4, #0]
3401022c:	f023 0302 	bic.w	r3, r3, #2
34010230:	2b01      	cmp	r3, #1
34010232:	d1c9      	bne.n	340101c8 <HAL_XSPI_Command+0x194>
34010234:	e7db      	b.n	340101ee <HAL_XSPI_Command+0x1ba>
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34010236:	6823      	ldr	r3, [r4, #0]
34010238:	b90b      	cbnz	r3, 3401023e <HAL_XSPI_Command+0x20a>
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3401023a:	2304      	movs	r3, #4
3401023c:	e005      	b.n	3401024a <HAL_XSPI_Command+0x216>
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
3401023e:	2b01      	cmp	r3, #1
34010240:	d105      	bne.n	3401024e <HAL_XSPI_Command+0x21a>
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
34010242:	6dab      	ldr	r3, [r5, #88]	@ 0x58
34010244:	2b24      	cmp	r3, #36	@ 0x24
34010246:	d0f8      	beq.n	3401023a <HAL_XSPI_Command+0x206>
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
34010248:	2314      	movs	r3, #20
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3401024a:	65ab      	str	r3, [r5, #88]	@ 0x58
3401024c:	e7e9      	b.n	34010222 <HAL_XSPI_Command+0x1ee>
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
3401024e:	2b02      	cmp	r3, #2
34010250:	d1e7      	bne.n	34010222 <HAL_XSPI_Command+0x1ee>
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
34010252:	6dab      	ldr	r3, [r5, #88]	@ 0x58
34010254:	2b14      	cmp	r3, #20
34010256:	d0f0      	beq.n	3401023a <HAL_XSPI_Command+0x206>
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
34010258:	2324      	movs	r3, #36	@ 0x24
3401025a:	e7f6      	b.n	3401024a <HAL_XSPI_Command+0x216>
      status = HAL_BUSY;
3401025c:	2002      	movs	r0, #2
3401025e:	e7e0      	b.n	34010222 <HAL_XSPI_Command+0x1ee>
34010260:	3401c922 	.word	0x3401c922

34010264 <HAL_XSPI_Transmit>:
{
34010264:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
34010268:	4604      	mov	r4, r0
3401026a:	4688      	mov	r8, r1
3401026c:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
3401026e:	f7f4 fb3f 	bl	340048f0 <HAL_GetTick>
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
34010272:	6827      	ldr	r7, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
34010274:	4605      	mov	r5, r0
  if (pData == NULL)
34010276:	f1b8 0f00 	cmp.w	r8, #0
3401027a:	d103      	bne.n	34010284 <HAL_XSPI_Transmit+0x20>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401027c:	2308      	movs	r3, #8
    status = HAL_ERROR;
3401027e:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010280:	65e3      	str	r3, [r4, #92]	@ 0x5c
34010282:	e02e      	b.n	340102e2 <HAL_XSPI_Transmit+0x7e>
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34010284:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34010286:	2b04      	cmp	r3, #4
34010288:	d12e      	bne.n	340102e8 <HAL_XSPI_Transmit+0x84>
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401028a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
      hxspi->pBuffPtr  = (uint8_t *)pData;
3401028c:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34010290:	3301      	adds	r3, #1
34010292:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
34010294:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010296:	64a3      	str	r3, [r4, #72]	@ 0x48
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
34010298:	683b      	ldr	r3, [r7, #0]
3401029a:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3401029e:	603b      	str	r3, [r7, #0]
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
340102a0:	462b      	mov	r3, r5
340102a2:	2201      	movs	r2, #1
340102a4:	2104      	movs	r1, #4
340102a6:	4620      	mov	r0, r4
340102a8:	9600      	str	r6, [sp, #0]
340102aa:	f7ff fd5d 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
340102ae:	b9c0      	cbnz	r0, 340102e2 <HAL_XSPI_Transmit+0x7e>
        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
340102b0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340102b2:	781b      	ldrb	r3, [r3, #0]
340102b4:	f887 3050 	strb.w	r3, [r7, #80]	@ 0x50
        hxspi->pBuffPtr++;
340102b8:	6c63      	ldr	r3, [r4, #68]	@ 0x44
340102ba:	3301      	adds	r3, #1
340102bc:	6463      	str	r3, [r4, #68]	@ 0x44
        hxspi->XferCount--;
340102be:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340102c0:	3b01      	subs	r3, #1
340102c2:	64e3      	str	r3, [r4, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
340102c4:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
340102c6:	2b00      	cmp	r3, #0
340102c8:	d1ea      	bne.n	340102a0 <HAL_XSPI_Transmit+0x3c>
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
340102ca:	462b      	mov	r3, r5
340102cc:	2201      	movs	r2, #1
340102ce:	2102      	movs	r1, #2
340102d0:	4620      	mov	r0, r4
340102d2:	9600      	str	r6, [sp, #0]
340102d4:	f7ff fd48 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
340102d8:	b918      	cbnz	r0, 340102e2 <HAL_XSPI_Transmit+0x7e>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
340102da:	2302      	movs	r3, #2
340102dc:	6822      	ldr	r2, [r4, #0]
340102de:	6253      	str	r3, [r2, #36]	@ 0x24
          hxspi->State = HAL_XSPI_STATE_READY;
340102e0:	65a3      	str	r3, [r4, #88]	@ 0x58
}
340102e2:	b002      	add	sp, #8
340102e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340102e8:	2310      	movs	r3, #16
340102ea:	e7c8      	b.n	3401027e <HAL_XSPI_Transmit+0x1a>

340102ec <HAL_XSPI_Receive>:
{
340102ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
340102f0:	4604      	mov	r4, r0
340102f2:	4616      	mov	r6, r2
340102f4:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
340102f6:	f7f4 fafb 	bl	340048f0 <HAL_GetTick>
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
340102fa:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
340102fc:	4607      	mov	r7, r0
  uint32_t addr_reg = hxspi->Instance->AR;
340102fe:	6caa      	ldr	r2, [r5, #72]	@ 0x48
  uint32_t ir_reg = hxspi->Instance->IR;
34010300:	f8d5 0110 	ldr.w	r0, [r5, #272]	@ 0x110
  if (pData == NULL)
34010304:	f1b8 0f00 	cmp.w	r8, #0
34010308:	d103      	bne.n	34010312 <HAL_XSPI_Receive+0x26>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
3401030a:	2308      	movs	r3, #8
    status = HAL_ERROR;
3401030c:	2001      	movs	r0, #1
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401030e:	65e3      	str	r3, [r4, #92]	@ 0x5c
34010310:	e035      	b.n	3401037e <HAL_XSPI_Receive+0x92>
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34010312:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34010314:	2b04      	cmp	r3, #4
34010316:	d13d      	bne.n	34010394 <HAL_XSPI_Receive+0xa8>
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34010318:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
      hxspi->pBuffPtr  = pData;
3401031a:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
3401031e:	3301      	adds	r3, #1
34010320:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
34010322:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010324:	64a3      	str	r3, [r4, #72]	@ 0x48
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34010326:	6829      	ldr	r1, [r5, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010328:	68e3      	ldr	r3, [r4, #12]
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
3401032a:	f021 5140 	bic.w	r1, r1, #805306368	@ 0x30000000
3401032e:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010332:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
34010336:	6029      	str	r1, [r5, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010338:	d124      	bne.n	34010384 <HAL_XSPI_Receive+0x98>
          WRITE_REG(hxspi->Instance->AR, addr_reg);
3401033a:	64aa      	str	r2, [r5, #72]	@ 0x48
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
3401033c:	463b      	mov	r3, r7
3401033e:	2201      	movs	r2, #1
34010340:	2106      	movs	r1, #6
34010342:	4620      	mov	r0, r4
34010344:	9600      	str	r6, [sp, #0]
34010346:	f7ff fd0f 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
3401034a:	b9c0      	cbnz	r0, 3401037e <HAL_XSPI_Receive+0x92>
        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
3401034c:	f895 2050 	ldrb.w	r2, [r5, #80]	@ 0x50
34010350:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010352:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34010354:	6c63      	ldr	r3, [r4, #68]	@ 0x44
34010356:	3301      	adds	r3, #1
34010358:	6463      	str	r3, [r4, #68]	@ 0x44
        hxspi->XferCount--;
3401035a:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
3401035c:	3b01      	subs	r3, #1
3401035e:	64e3      	str	r3, [r4, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
34010360:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
34010362:	2b00      	cmp	r3, #0
34010364:	d1ea      	bne.n	3401033c <HAL_XSPI_Receive+0x50>
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
34010366:	463b      	mov	r3, r7
34010368:	2201      	movs	r2, #1
3401036a:	2102      	movs	r1, #2
3401036c:	4620      	mov	r0, r4
3401036e:	9600      	str	r6, [sp, #0]
34010370:	f7ff fcfa 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
34010374:	b918      	cbnz	r0, 3401037e <HAL_XSPI_Receive+0x92>
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34010376:	2302      	movs	r3, #2
34010378:	6822      	ldr	r2, [r4, #0]
3401037a:	6253      	str	r3, [r2, #36]	@ 0x24
          hxspi->State = HAL_XSPI_STATE_READY;
3401037c:	65a3      	str	r3, [r4, #88]	@ 0x58
}
3401037e:	b002      	add	sp, #8
34010380:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34010384:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
34010388:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
3401038c:	d1d5      	bne.n	3401033a <HAL_XSPI_Receive+0x4e>
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401038e:	f8c5 0110 	str.w	r0, [r5, #272]	@ 0x110
34010392:	e7d3      	b.n	3401033c <HAL_XSPI_Receive+0x50>
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010394:	2310      	movs	r3, #16
34010396:	e7b9      	b.n	3401030c <HAL_XSPI_Receive+0x20>

34010398 <HAL_XSPI_AutoPolling>:
{
34010398:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
3401039c:	4604      	mov	r4, r0
3401039e:	460d      	mov	r5, r1
340103a0:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
340103a2:	f7f4 faa5 	bl	340048f0 <HAL_GetTick>
  uint32_t addr_reg = hxspi->Instance->AR;
340103a6:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
340103a8:	4606      	mov	r6, r0
  uint32_t addr_reg = hxspi->Instance->AR;
340103aa:	f8d3 8048 	ldr.w	r8, [r3, #72]	@ 0x48
  uint32_t ir_reg = hxspi->Instance->IR;
340103ae:	f8d3 9110 	ldr.w	r9, [r3, #272]	@ 0x110
  uint32_t dlr_reg = hxspi->Instance->DLR;
340103b2:	f8d3 a040 	ldr.w	sl, [r3, #64]	@ 0x40
  assert_param(IS_XSPI_MATCH_MODE(pCfg->MatchMode));
340103b6:	68ab      	ldr	r3, [r5, #8]
340103b8:	f433 0300 	bics.w	r3, r3, #8388608	@ 0x800000
340103bc:	d004      	beq.n	340103c8 <HAL_XSPI_AutoPolling+0x30>
340103be:	f240 7133 	movw	r1, #1843	@ 0x733
340103c2:	4832      	ldr	r0, [pc, #200]	@ (3401048c <HAL_XSPI_AutoPolling+0xf4>)
340103c4:	f7f2 f8ba 	bl	3400253c <assert_failed>
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
340103c8:	68eb      	ldr	r3, [r5, #12]
340103ca:	f433 0380 	bics.w	r3, r3, #4194304	@ 0x400000
340103ce:	d004      	beq.n	340103da <HAL_XSPI_AutoPolling+0x42>
340103d0:	f240 7134 	movw	r1, #1844	@ 0x734
340103d4:	482d      	ldr	r0, [pc, #180]	@ (3401048c <HAL_XSPI_AutoPolling+0xf4>)
340103d6:	f7f2 f8b1 	bl	3400253c <assert_failed>
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
340103da:	692b      	ldr	r3, [r5, #16]
340103dc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340103e0:	d304      	bcc.n	340103ec <HAL_XSPI_AutoPolling+0x54>
340103e2:	f240 7135 	movw	r1, #1845	@ 0x735
340103e6:	4829      	ldr	r0, [pc, #164]	@ (3401048c <HAL_XSPI_AutoPolling+0xf4>)
340103e8:	f7f2 f8a8 	bl	3400253c <assert_failed>
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));
340103ec:	f1ba 0f03 	cmp.w	sl, #3
340103f0:	d904      	bls.n	340103fc <HAL_XSPI_AutoPolling+0x64>
340103f2:	f240 7136 	movw	r1, #1846	@ 0x736
340103f6:	4825      	ldr	r0, [pc, #148]	@ (3401048c <HAL_XSPI_AutoPolling+0xf4>)
340103f8:	f7f2 f8a0 	bl	3400253c <assert_failed>
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
340103fc:	6da3      	ldr	r3, [r4, #88]	@ 0x58
340103fe:	2b04      	cmp	r3, #4
34010400:	d13e      	bne.n	34010480 <HAL_XSPI_AutoPolling+0xe8>
34010402:	68eb      	ldr	r3, [r5, #12]
34010404:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34010408:	d13a      	bne.n	34010480 <HAL_XSPI_AutoPolling+0xe8>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3401040a:	4633      	mov	r3, r6
3401040c:	2200      	movs	r2, #0
3401040e:	2120      	movs	r1, #32
34010410:	4620      	mov	r0, r4
34010412:	9700      	str	r7, [sp, #0]
34010414:	f7ff fca8 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
34010418:	2800      	cmp	r0, #0
3401041a:	d135      	bne.n	34010488 <HAL_XSPI_AutoPolling+0xf0>
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
3401041c:	682b      	ldr	r3, [r5, #0]
3401041e:	6821      	ldr	r1, [r4, #0]
34010420:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
34010424:	686b      	ldr	r3, [r5, #4]
34010426:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
3401042a:	692b      	ldr	r3, [r5, #16]
3401042c:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34010430:	680a      	ldr	r2, [r1, #0]
34010432:	e9d5 3502 	ldrd	r3, r5, [r5, #8]
34010436:	431d      	orrs	r5, r3
34010438:	f022 5343 	bic.w	r3, r2, #817889280	@ 0x30c00000
3401043c:	431d      	orrs	r5, r3
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401043e:	68e3      	ldr	r3, [r4, #12]
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34010440:	f045 5500 	orr.w	r5, r5, #536870912	@ 0x20000000
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34010444:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34010448:	600d      	str	r5, [r1, #0]
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3401044a:	d111      	bne.n	34010470 <HAL_XSPI_AutoPolling+0xd8>
          WRITE_REG(hxspi->Instance->AR, addr_reg);
3401044c:	f8c1 8048 	str.w	r8, [r1, #72]	@ 0x48
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
34010450:	4633      	mov	r3, r6
34010452:	2201      	movs	r2, #1
34010454:	2108      	movs	r1, #8
34010456:	4620      	mov	r0, r4
34010458:	9700      	str	r7, [sp, #0]
3401045a:	f7ff fc85 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
3401045e:	b920      	cbnz	r0, 3401046a <HAL_XSPI_AutoPolling+0xd2>
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
34010460:	2208      	movs	r2, #8
34010462:	6823      	ldr	r3, [r4, #0]
34010464:	625a      	str	r2, [r3, #36]	@ 0x24
        hxspi->State = HAL_XSPI_STATE_READY;
34010466:	2302      	movs	r3, #2
34010468:	65a3      	str	r3, [r4, #88]	@ 0x58
}
3401046a:	b002      	add	sp, #8
3401046c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34010470:	f8d1 3100 	ldr.w	r3, [r1, #256]	@ 0x100
34010474:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
34010478:	d1e8      	bne.n	3401044c <HAL_XSPI_AutoPolling+0xb4>
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401047a:	f8c1 9110 	str.w	r9, [r1, #272]	@ 0x110
3401047e:	e7e7      	b.n	34010450 <HAL_XSPI_AutoPolling+0xb8>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010480:	2310      	movs	r3, #16
    status = HAL_ERROR;
34010482:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010484:	65e3      	str	r3, [r4, #92]	@ 0x5c
34010486:	e7f0      	b.n	3401046a <HAL_XSPI_AutoPolling+0xd2>
      status = HAL_BUSY;
34010488:	2002      	movs	r0, #2
3401048a:	e7ee      	b.n	3401046a <HAL_XSPI_AutoPolling+0xd2>
3401048c:	3401c922 	.word	0x3401c922

34010490 <HAL_XSPI_MemoryMapped>:
{
34010490:	b573      	push	{r0, r1, r4, r5, r6, lr}
34010492:	460c      	mov	r4, r1
34010494:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
34010496:	f7f4 fa2b 	bl	340048f0 <HAL_GetTick>
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
3401049a:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
3401049c:	4606      	mov	r6, r0
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
3401049e:	f033 0308 	bics.w	r3, r3, #8
340104a2:	d004      	beq.n	340104ae <HAL_XSPI_MemoryMapped+0x1e>
340104a4:	f240 71c7 	movw	r1, #1991	@ 0x7c7
340104a8:	482f      	ldr	r0, [pc, #188]	@ (34010568 <HAL_XSPI_MemoryMapped+0xd8>)
340104aa:	f7f2 f847 	bl	3400253c <assert_failed>
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));
340104ae:	68a3      	ldr	r3, [r4, #8]
340104b0:	f033 7300 	bics.w	r3, r3, #33554432	@ 0x2000000
340104b4:	d004      	beq.n	340104c0 <HAL_XSPI_MemoryMapped+0x30>
340104b6:	f44f 61f9 	mov.w	r1, #1992	@ 0x7c8
340104ba:	482b      	ldr	r0, [pc, #172]	@ (34010568 <HAL_XSPI_MemoryMapped+0xd8>)
340104bc:	f7f2 f83e 	bl	3400253c <assert_failed>
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
340104c0:	6dab      	ldr	r3, [r5, #88]	@ 0x58
340104c2:	2b04      	cmp	r3, #4
340104c4:	d14b      	bne.n	3401055e <HAL_XSPI_MemoryMapped+0xce>
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
340104c6:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
340104c8:	2200      	movs	r2, #0
340104ca:	9300      	str	r3, [sp, #0]
340104cc:	2120      	movs	r1, #32
340104ce:	4633      	mov	r3, r6
340104d0:	4628      	mov	r0, r5
340104d2:	f7ff fc49 	bl	3400fd68 <XSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
340104d6:	4606      	mov	r6, r0
340104d8:	bb58      	cbnz	r0, 34010532 <HAL_XSPI_MemoryMapped+0xa2>
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
340104da:	2388      	movs	r3, #136	@ 0x88
340104dc:	65ab      	str	r3, [r5, #88]	@ 0x58
      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
340104de:	68a3      	ldr	r3, [r4, #8]
340104e0:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340104e4:	d128      	bne.n	34010538 <HAL_XSPI_MemoryMapped+0xa8>
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
340104e6:	682a      	ldr	r2, [r5, #0]
340104e8:	6813      	ldr	r3, [r2, #0]
340104ea:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
340104ee:	6013      	str	r3, [r2, #0]
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
340104f0:	6823      	ldr	r3, [r4, #0]
340104f2:	2b08      	cmp	r3, #8
340104f4:	d112      	bne.n	3401051c <HAL_XSPI_MemoryMapped+0x8c>
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));
340104f6:	6863      	ldr	r3, [r4, #4]
340104f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340104fc:	d304      	bcc.n	34010508 <HAL_XSPI_MemoryMapped+0x78>
340104fe:	f240 71e4 	movw	r1, #2020	@ 0x7e4
34010502:	4819      	ldr	r0, [pc, #100]	@ (34010568 <HAL_XSPI_MemoryMapped+0xd8>)
34010504:	f7f2 f81a 	bl	3400253c <assert_failed>
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34010508:	682b      	ldr	r3, [r5, #0]
3401050a:	6862      	ldr	r2, [r4, #4]
3401050c:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
34010510:	2210      	movs	r2, #16
34010512:	625a      	str	r2, [r3, #36]	@ 0x24
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34010514:	681a      	ldr	r2, [r3, #0]
34010516:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
3401051a:	601a      	str	r2, [r3, #0]
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
3401051c:	682a      	ldr	r2, [r5, #0]
3401051e:	6821      	ldr	r1, [r4, #0]
34010520:	6813      	ldr	r3, [r2, #0]
34010522:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
34010526:	f023 0308 	bic.w	r3, r3, #8
3401052a:	430b      	orrs	r3, r1
3401052c:	f043 5340 	orr.w	r3, r3, #805306368	@ 0x30000000
34010530:	6013      	str	r3, [r2, #0]
}
34010532:	4630      	mov	r0, r6
34010534:	b002      	add	sp, #8
34010536:	bd70      	pop	{r4, r5, r6, pc}
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));
34010538:	68e3      	ldr	r3, [r4, #12]
3401053a:	f033 6380 	bics.w	r3, r3, #67108864	@ 0x4000000
3401053e:	d004      	beq.n	3401054a <HAL_XSPI_MemoryMapped+0xba>
34010540:	f240 71dc 	movw	r1, #2012	@ 0x7dc
34010544:	4808      	ldr	r0, [pc, #32]	@ (34010568 <HAL_XSPI_MemoryMapped+0xd8>)
34010546:	f7f1 fff9 	bl	3400253c <assert_failed>
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
3401054a:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
3401054e:	6829      	ldr	r1, [r5, #0]
34010550:	4303      	orrs	r3, r0
34010552:	680a      	ldr	r2, [r1, #0]
34010554:	f022 62c0 	bic.w	r2, r2, #100663296	@ 0x6000000
34010558:	4313      	orrs	r3, r2
3401055a:	600b      	str	r3, [r1, #0]
3401055c:	e7c8      	b.n	340104f0 <HAL_XSPI_MemoryMapped+0x60>
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401055e:	2310      	movs	r3, #16
    status = HAL_ERROR;
34010560:	2601      	movs	r6, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010562:	65eb      	str	r3, [r5, #92]	@ 0x5c
34010564:	e7e5      	b.n	34010532 <HAL_XSPI_MemoryMapped+0xa2>
34010566:	bf00      	nop
34010568:	3401c922 	.word	0x3401c922

3401056c <HAL_XSPI_SetClockPrescaler>:
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
3401056c:	29ff      	cmp	r1, #255	@ 0xff
{
3401056e:	b538      	push	{r3, r4, r5, lr}
34010570:	4604      	mov	r4, r0
34010572:	460d      	mov	r5, r1
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));
34010574:	d904      	bls.n	34010580 <HAL_XSPI_SetClockPrescaler+0x14>
34010576:	f640 2192 	movw	r1, #2706	@ 0xa92
3401057a:	4809      	ldr	r0, [pc, #36]	@ (340105a0 <HAL_XSPI_SetClockPrescaler+0x34>)
3401057c:	f7f1 ffde 	bl	3400253c <assert_failed>
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
34010580:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34010582:	f010 0008 	ands.w	r0, r0, #8
34010586:	d107      	bne.n	34010598 <HAL_XSPI_SetClockPrescaler+0x2c>
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
34010588:	6822      	ldr	r2, [r4, #0]
    hxspi->Init.ClockPrescaler = Prescaler;
3401058a:	6265      	str	r5, [r4, #36]	@ 0x24
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3401058c:	68d3      	ldr	r3, [r2, #12]
3401058e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34010592:	432b      	orrs	r3, r5
34010594:	60d3      	str	r3, [r2, #12]
}
34010596:	bd38      	pop	{r3, r4, r5, pc}
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34010598:	2310      	movs	r3, #16
    status = HAL_ERROR;
3401059a:	2001      	movs	r0, #1
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401059c:	65e3      	str	r3, [r4, #92]	@ 0x5c
3401059e:	e7fa      	b.n	34010596 <HAL_XSPI_SetClockPrescaler+0x2a>
340105a0:	3401c922 	.word	0x3401c922

340105a4 <CB_ISP_GetSensorGain>:
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
  *Gain = Camera_Ctx.Gain;
340105a4:	4b02      	ldr	r3, [pc, #8]	@ (340105b0 <CB_ISP_GetSensorGain+0xc>)
{
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
    return ISP_ERR_SENSORGAIN;

  return ISP_OK;
}
340105a6:	2000      	movs	r0, #0
  *Gain = Camera_Ctx.Gain;
340105a8:	6a1b      	ldr	r3, [r3, #32]
340105aa:	600b      	str	r3, [r1, #0]
}
340105ac:	4770      	bx	lr
340105ae:	bf00      	nop
340105b0:	34057ad8 	.word	0x34057ad8

340105b4 <CB_ISP_GetSensorExposure>:
  *exposure = Camera_Ctx.Exposure;
340105b4:	4b02      	ldr	r3, [pc, #8]	@ (340105c0 <CB_ISP_GetSensorExposure+0xc>)
{
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
    return ISP_ERR_SENSOREXPOSURE;

  return ISP_OK;
}
340105b6:	2000      	movs	r0, #0
  *exposure = Camera_Ctx.Exposure;
340105b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340105ba:	600b      	str	r3, [r1, #0]
}
340105bc:	4770      	bx	lr
340105be:	bf00      	nop
340105c0:	34057ad8 	.word	0x34057ad8

340105c4 <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
340105c4:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo != NULL)
340105c6:	4b05      	ldr	r3, [pc, #20]	@ (340105dc <CB_ISP_GetSensorInfo+0x18>)
340105c8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340105ca:	b113      	cbz	r3, 340105d2 <CB_ISP_GetSensorInfo+0xe>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
340105cc:	4804      	ldr	r0, [pc, #16]	@ (340105e0 <CB_ISP_GetSensorInfo+0x1c>)
340105ce:	4798      	blx	r3
340105d0:	b908      	cbnz	r0, 340105d6 <CB_ISP_GetSensorInfo+0x12>
      return ISP_ERR_SENSOREXPOSURE;
  }
  return ISP_OK;
340105d2:	2000      	movs	r0, #0
}
340105d4:	bd08      	pop	{r3, pc}
      return ISP_ERR_SENSOREXPOSURE;
340105d6:	2083      	movs	r0, #131	@ 0x83
340105d8:	e7fc      	b.n	340105d4 <CB_ISP_GetSensorInfo+0x10>
340105da:	bf00      	nop
340105dc:	34057a6c 	.word	0x34057a6c
340105e0:	34057928 	.word	0x34057928

340105e4 <CMW_CAMERA_EnablePin>:
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
340105e4:	1e02      	subs	r2, r0, #0
340105e6:	bf18      	it	ne
340105e8:	2201      	movne	r2, #1
340105ea:	2104      	movs	r1, #4
340105ec:	4801      	ldr	r0, [pc, #4]	@ (340105f4 <CMW_CAMERA_EnablePin+0x10>)
340105ee:	f7f7 bb55 	b.w	34007c9c <HAL_GPIO_WritePin>
340105f2:	bf00      	nop
340105f4:	56020c00 	.word	0x56020c00

340105f8 <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
340105f8:	1e02      	subs	r2, r0, #0
340105fa:	bf18      	it	ne
340105fc:	2201      	movne	r2, #1
340105fe:	f44f 7180 	mov.w	r1, #256	@ 0x100
34010602:	4801      	ldr	r0, [pc, #4]	@ (34010608 <CMW_CAMERA_ShutdownPin+0x10>)
34010604:	f7f7 bb4a 	b.w	34007c9c <HAL_GPIO_WritePin>
34010608:	56020800 	.word	0x56020800

3401060c <CMW_CAMERA_Probe_Sensor.constprop.0>:

#if defined(USE_VD55G1_SENSOR)
static int32_t CMW_CAMERA_VD55G1_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401060c:	2100      	movs	r1, #0
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
3401060e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010612:	4ca0      	ldr	r4, [pc, #640]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
34010614:	b099      	sub	sp, #100	@ 0x64
34010616:	4605      	mov	r5, r0
  memset(&camera_bsp, 0, sizeof(camera_bsp));
34010618:	f44f 72a2 	mov.w	r2, #324	@ 0x144
3401061c:	4620      	mov	r0, r4
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401061e:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
34010622:	e9cd 1105 	strd	r1, r1, [sp, #20]
34010626:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
3401062a:	f008 fb1b 	bl	34018c64 <memset>
  camera_bsp.vd55g1_bsp.Address     = CAMERA_VD55G1_ADDRESS;
3401062e:	2320      	movs	r3, #32
34010630:	8023      	strh	r3, [r4, #0]
  camera_bsp.vd55g1_bsp.ClockInHz   = CAMERA_VD55G1_FREQ_IN_HZ;
34010632:	4b99      	ldr	r3, [pc, #612]	@ (34010898 <CMW_CAMERA_Probe_Sensor.constprop.0+0x28c>)
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
34010634:	f8df b294 	ldr.w	fp, [pc, #660]	@ 340108cc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2c0>
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
34010638:	f8df a294 	ldr.w	sl, [pc, #660]	@ 340108d0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2c4>
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3401063c:	f8df 8294 	ldr.w	r8, [pc, #660]	@ 340108d4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2c8>
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
34010640:	f8df 9294 	ldr.w	r9, [pc, #660]	@ 340108d8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2cc>
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
34010644:	4f95      	ldr	r7, [pc, #596]	@ (3401089c <CMW_CAMERA_Probe_Sensor.constprop.0+0x290>)
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
34010646:	4e96      	ldr	r6, [pc, #600]	@ (340108a0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x294>)
  camera_bsp.vd55g1_bsp.ClockInHz   = CAMERA_VD55G1_FREQ_IN_HZ;
34010648:	6063      	str	r3, [r4, #4]
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3401064a:	4b96      	ldr	r3, [pc, #600]	@ (340108a4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x298>)

  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
3401064c:	4620      	mov	r0, r4
3401064e:	4996      	ldr	r1, [pc, #600]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
34010650:	f8c4 b074 	str.w	fp, [r4, #116]	@ 0x74
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
34010654:	f8c4 a078 	str.w	sl, [r4, #120]	@ 0x78
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
34010658:	f8c4 807c 	str.w	r8, [r4, #124]	@ 0x7c
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
3401065c:	f8c4 9080 	str.w	r9, [r4, #128]	@ 0x80
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
34010660:	f8c4 7088 	str.w	r7, [r4, #136]	@ 0x88
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
34010664:	f8c4 608c 	str.w	r6, [r4, #140]	@ 0x8c
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010668:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
3401066c:	f000 fee4 	bl	34011438 <CMW_VD55G1_Probe>
  if (ret != CMW_ERROR_NONE)
34010670:	2800      	cmp	r0, #0
34010672:	d135      	bne.n	340106e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
34010674:	682b      	ldr	r3, [r5, #0]
34010676:	4a8c      	ldr	r2, [pc, #560]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
34010678:	b10b      	cbz	r3, 3401067e <CMW_CAMERA_Probe_Sensor.constprop.0+0x72>
3401067a:	686b      	ldr	r3, [r5, #4]
3401067c:	b943      	cbnz	r3, 34010690 <CMW_CAMERA_Probe_Sensor.constprop.0+0x84>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3401067e:	6d93      	ldr	r3, [r2, #88]	@ 0x58
34010680:	4884      	ldr	r0, [pc, #528]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010682:	a909      	add	r1, sp, #36	@ 0x24
34010684:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
34010686:	9b12      	ldr	r3, [sp, #72]	@ 0x48
    initSensors_params->height = sensor_info.height;
34010688:	4a87      	ldr	r2, [pc, #540]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
    initSensors_params->width = sensor_info.width;
3401068a:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
3401068c:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
3401068e:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
34010690:	4629      	mov	r1, r5
34010692:	6813      	ldr	r3, [r2, #0]
34010694:	487f      	ldr	r0, [pc, #508]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010696:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010698:	bb10      	cbnz	r0, 340106e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3401069a:	f44f 7080 	mov.w	r0, #256	@ 0x100
3401069e:	2301      	movs	r3, #1
340106a0:	e9cd 0303 	strd	r0, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
340106a4:	231c      	movs	r3, #28
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
340106a6:	a903      	add	r1, sp, #12
340106a8:	4880      	ldr	r0, [pc, #512]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
340106aa:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
340106ac:	f7f4 fc14 	bl	34004ed8 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
340106b0:	4601      	mov	r1, r0
340106b2:	b9a8      	cbnz	r0, 340106e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
340106b4:	2202      	movs	r2, #2
340106b6:	487d      	ldr	r0, [pc, #500]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
340106b8:	f7f4 fd7e 	bl	340051b8 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
340106bc:	4601      	mov	r1, r0
340106be:	b978      	cbnz	r0, 340106e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
340106c0:	232a      	movs	r3, #42	@ 0x2a
  csi_pipe_conf.DataTypeIDB = 0;
340106c2:	e9cd 3007 	strd	r3, r0, [sp, #28]
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
340106c6:	9006      	str	r0, [sp, #24]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
340106c8:	4878      	ldr	r0, [pc, #480]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
340106ca:	aa06      	add	r2, sp, #24
340106cc:	9101      	str	r1, [sp, #4]
340106ce:	f7f4 fcbf 	bl	34005050 <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
340106d2:	b928      	cbnz	r0, 340106e0 <CMW_CAMERA_Probe_Sensor.constprop.0+0xd4>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
340106d4:	9901      	ldr	r1, [sp, #4]
340106d6:	3101      	adds	r1, #1
340106d8:	2903      	cmp	r1, #3
340106da:	d1f5      	bne.n	340106c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0xbc>
    return ret;
340106dc:	2002      	movs	r0, #2
340106de:	e064      	b.n	340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x19e>

#if defined(USE_VD66GY_SENSOR)
static int32_t CMW_CAMERA_VD66GY_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340106e0:	2100      	movs	r1, #0
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
340106e2:	f44f 72a2 	mov.w	r2, #324	@ 0x144
340106e6:	486b      	ldr	r0, [pc, #428]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340106e8:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
340106ec:	e9cd 1105 	strd	r1, r1, [sp, #20]
340106f0:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
340106f4:	f008 fab6 	bl	34018c64 <memset>
  camera_bsp.vd66gy_bsp.Address     = CAMERA_VD66GY_ADDRESS;
340106f8:	2320      	movs	r3, #32
340106fa:	8023      	strh	r3, [r4, #0]
  camera_bsp.vd66gy_bsp.ClockInHz   = CAMERA_VD66GY_FREQ_IN_HZ;
340106fc:	4b66      	ldr	r3, [pc, #408]	@ (34010898 <CMW_CAMERA_Probe_Sensor.constprop.0+0x28c>)
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
340106fe:	496a      	ldr	r1, [pc, #424]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
  camera_bsp.vd66gy_bsp.ClockInHz   = CAMERA_VD66GY_FREQ_IN_HZ;
34010700:	6063      	str	r3, [r4, #4]
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010702:	4b68      	ldr	r3, [pc, #416]	@ (340108a4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x298>)
  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
34010704:	4863      	ldr	r0, [pc, #396]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
34010706:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
3401070a:	4b68      	ldr	r3, [pc, #416]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  camera_bsp.vd66gy_bsp.DeInit      = CMW_I2C_DEINIT;
3401070c:	e9c4 ba49 	strd	fp, sl, [r4, #292]	@ 0x124
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
34010710:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
34010714:	4b66      	ldr	r3, [pc, #408]	@ (340108b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a4>)
  camera_bsp.vd66gy_bsp.WriteReg    = CMW_I2C_WRITEREG16;
34010716:	e9c4 894b 	strd	r8, r9, [r4, #300]	@ 0x12c
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3401071a:	f8c4 3108 	str.w	r3, [r4, #264]	@ 0x108
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3401071e:	4b65      	ldr	r3, [pc, #404]	@ (340108b4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a8>)
  camera_bsp.vd66gy_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
34010720:	e9c4 764e 	strd	r7, r6, [r4, #312]	@ 0x138
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
34010724:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
34010728:	4b63      	ldr	r3, [pc, #396]	@ (340108b8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ac>)
3401072a:	f8c4 3110 	str.w	r3, [r4, #272]	@ 0x110
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3401072e:	4b63      	ldr	r3, [pc, #396]	@ (340108bc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b0>)
34010730:	f8c4 3114 	str.w	r3, [r4, #276]	@ 0x114
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
34010734:	4b62      	ldr	r3, [pc, #392]	@ (340108c0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b4>)
34010736:	f8c4 3104 	str.w	r3, [r4, #260]	@ 0x104
  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
3401073a:	f001 fa0b 	bl	34011b54 <CMW_VD66GY_Probe>
  if (ret != CMW_ERROR_NONE)
3401073e:	2800      	cmp	r0, #0
34010740:	d139      	bne.n	340107b6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
34010742:	682b      	ldr	r3, [r5, #0]
34010744:	b10b      	cbz	r3, 3401074a <CMW_CAMERA_Probe_Sensor.constprop.0+0x13e>
34010746:	686b      	ldr	r3, [r5, #4]
34010748:	b943      	cbnz	r3, 3401075c <CMW_CAMERA_Probe_Sensor.constprop.0+0x150>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3401074a:	4b57      	ldr	r3, [pc, #348]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
3401074c:	4851      	ldr	r0, [pc, #324]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
3401074e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34010750:	a909      	add	r1, sp, #36	@ 0x24
34010752:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
34010754:	9b12      	ldr	r3, [sp, #72]	@ 0x48
34010756:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
34010758:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
3401075a:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3401075c:	4b52      	ldr	r3, [pc, #328]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
3401075e:	4629      	mov	r1, r5
34010760:	681b      	ldr	r3, [r3, #0]
34010762:	484c      	ldr	r0, [pc, #304]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010764:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010766:	bb30      	cbnz	r0, 340107b6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34010768:	f44f 7100 	mov.w	r1, #512	@ 0x200
3401076c:	2301      	movs	r3, #1
3401076e:	e9cd 1303 	strd	r1, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
34010772:	231c      	movs	r3, #28
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010774:	a903      	add	r1, sp, #12
34010776:	484d      	ldr	r0, [pc, #308]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
34010778:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3401077a:	f7f4 fbad 	bl	34004ed8 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
3401077e:	4601      	mov	r1, r0
34010780:	b9c8      	cbnz	r0, 340107b6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
34010782:	2202      	movs	r2, #2
34010784:	4849      	ldr	r0, [pc, #292]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
34010786:	f7f4 fd17 	bl	340051b8 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
3401078a:	4601      	mov	r1, r0
3401078c:	b998      	cbnz	r0, 340107b6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
3401078e:	232a      	movs	r3, #42	@ 0x2a
  csi_pipe_conf.DataTypeIDB = 0;
34010790:	e9cd 3007 	strd	r3, r0, [sp, #28]
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34010794:	9006      	str	r0, [sp, #24]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010796:	4845      	ldr	r0, [pc, #276]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
34010798:	aa06      	add	r2, sp, #24
3401079a:	9101      	str	r1, [sp, #4]
3401079c:	f7f4 fc58 	bl	34005050 <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
340107a0:	b948      	cbnz	r0, 340107b6 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1aa>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
340107a2:	9901      	ldr	r1, [sp, #4]
340107a4:	3101      	adds	r1, #1
340107a6:	2903      	cmp	r1, #3
340107a8:	d1f5      	bne.n	34010796 <CMW_CAMERA_Probe_Sensor.constprop.0+0x18a>
    *sensorName = CMW_VD66GY_Sensor;
340107aa:	4b46      	ldr	r3, [pc, #280]	@ (340108c4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b8>)
340107ac:	7018      	strb	r0, [r3, #0]
    return ret;
340107ae:	2000      	movs	r0, #0
}
340107b0:	b019      	add	sp, #100	@ 0x64
340107b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init( CMW_Sensor_Init_t *initSensors_params)
{
  int32_t ret = CMW_ERROR_NONE;
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340107b6:	2100      	movs	r1, #0
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };

  memset(&camera_bsp, 0, sizeof(camera_bsp));
340107b8:	f44f 72a2 	mov.w	r2, #324	@ 0x144
340107bc:	4835      	ldr	r0, [pc, #212]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
340107be:	e9cd 1103 	strd	r1, r1, [sp, #12]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
340107c2:	e9cd 1105 	strd	r1, r1, [sp, #20]
340107c6:	e9cd 1107 	strd	r1, r1, [sp, #28]
  memset(&camera_bsp, 0, sizeof(camera_bsp));
340107ca:	f008 fa4b 	bl	34018c64 <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
340107ce:	2334      	movs	r3, #52	@ 0x34
340107d0:	8023      	strh	r3, [r4, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
340107d2:	4b3d      	ldr	r3, [pc, #244]	@ (340108c8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2bc>)
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
340107d4:	4934      	ldr	r1, [pc, #208]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
340107d6:	e9c4 373d 	strd	r3, r7, [r4, #244]	@ 0xf4
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
340107da:	4b32      	ldr	r3, [pc, #200]	@ (340108a4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x298>)
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
340107dc:	482d      	ldr	r0, [pc, #180]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
340107de:	f8c4 3100 	str.w	r3, [r4, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
340107e2:	4b32      	ldr	r3, [pc, #200]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
340107e4:	e9c4 ba39 	strd	fp, sl, [r4, #228]	@ 0xe4
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
340107e8:	f8c4 30dc 	str.w	r3, [r4, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
340107ec:	4b30      	ldr	r3, [pc, #192]	@ (340108b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a4>)
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
340107ee:	e9c4 893b 	strd	r8, r9, [r4, #236]	@ 0xec
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
340107f2:	f8c4 30c8 	str.w	r3, [r4, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
340107f6:	4b2f      	ldr	r3, [pc, #188]	@ (340108b4 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a8>)
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
340107f8:	f8c4 60fc 	str.w	r6, [r4, #252]	@ 0xfc
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
340107fc:	f8c4 30cc 	str.w	r3, [r4, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
34010800:	4b2d      	ldr	r3, [pc, #180]	@ (340108b8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2ac>)
34010802:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
34010806:	4b2d      	ldr	r3, [pc, #180]	@ (340108bc <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b0>)
34010808:	f8c4 30d4 	str.w	r3, [r4, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3401080c:	4b2c      	ldr	r3, [pc, #176]	@ (340108c0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x2b4>)
3401080e:	f8c4 30c4 	str.w	r3, [r4, #196]	@ 0xc4
  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
34010812:	f000 fc71 	bl	340110f8 <CMW_IMX335_Probe>
  if (ret != CMW_ERROR_NONE)
34010816:	2800      	cmp	r0, #0
34010818:	d139      	bne.n	3401088e <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3401081a:	682b      	ldr	r3, [r5, #0]
3401081c:	4c22      	ldr	r4, [pc, #136]	@ (340108a8 <CMW_CAMERA_Probe_Sensor.constprop.0+0x29c>)
3401081e:	b10b      	cbz	r3, 34010824 <CMW_CAMERA_Probe_Sensor.constprop.0+0x218>
34010820:	686b      	ldr	r3, [r5, #4]
34010822:	b93b      	cbnz	r3, 34010834 <CMW_CAMERA_Probe_Sensor.constprop.0+0x228>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
34010824:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34010826:	481b      	ldr	r0, [pc, #108]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010828:	a909      	add	r1, sp, #36	@ 0x24
3401082a:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3401082c:	9b12      	ldr	r3, [sp, #72]	@ 0x48
3401082e:	602b      	str	r3, [r5, #0]
    initSensors_params->height = sensor_info.height;
34010830:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
34010832:	606b      	str	r3, [r5, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
34010834:	4629      	mov	r1, r5
34010836:	6823      	ldr	r3, [r4, #0]
34010838:	4816      	ldr	r0, [pc, #88]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
3401083a:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
3401083c:	bb38      	cbnz	r0, 3401088e <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_24MHZ);
3401083e:	2102      	movs	r1, #2
34010840:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34010842:	4814      	ldr	r0, [pc, #80]	@ (34010894 <CMW_CAMERA_Probe_Sensor.constprop.0+0x288>)
34010844:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010846:	bb10      	cbnz	r0, 3401088e <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34010848:	f44f 7200 	mov.w	r2, #512	@ 0x200
3401084c:	2301      	movs	r3, #1
3401084e:	e9cd 2303 	strd	r2, r3, [sp, #12]
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
34010852:	232c      	movs	r3, #44	@ 0x2c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
34010854:	a903      	add	r1, sp, #12
34010856:	4815      	ldr	r0, [pc, #84]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
34010858:	9305      	str	r3, [sp, #20]
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3401085a:	f7f4 fb3d 	bl	34004ed8 <HAL_DCMIPP_CSI_SetConfig>
  if (ret != HAL_OK)
3401085e:	4601      	mov	r1, r0
34010860:	b9a8      	cbnz	r0, 3401088e <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
34010862:	2203      	movs	r2, #3
34010864:	4811      	ldr	r0, [pc, #68]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
34010866:	f7f4 fca7 	bl	340051b8 <HAL_DCMIPP_CSI_SetVCConfig>
  if (ret != HAL_OK)
3401086a:	4604      	mov	r4, r0
3401086c:	b978      	cbnz	r0, 3401088e <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  {
    return CMW_ERROR_PERIPH_FAILURE;
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
3401086e:	232b      	movs	r3, #43	@ 0x2b
  csi_pipe_conf.DataTypeIDB = 0;
34010870:	e9cd 3007 	strd	r3, r0, [sp, #28]
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010874:	4d0d      	ldr	r5, [pc, #52]	@ (340108ac <CMW_CAMERA_Probe_Sensor.constprop.0+0x2a0>)
  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34010876:	9006      	str	r0, [sp, #24]
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
34010878:	4621      	mov	r1, r4
3401087a:	4628      	mov	r0, r5
3401087c:	aa06      	add	r2, sp, #24
3401087e:	f7f4 fbe7 	bl	34005050 <HAL_DCMIPP_CSI_PIPE_SetConfig>
    if (ret != HAL_OK)
34010882:	b920      	cbnz	r0, 3401088e <CMW_CAMERA_Probe_Sensor.constprop.0+0x282>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
34010884:	3401      	adds	r4, #1
34010886:	2c03      	cmp	r4, #3
34010888:	d1f6      	bne.n	34010878 <CMW_CAMERA_Probe_Sensor.constprop.0+0x26c>
    return ret;
3401088a:	2001      	movs	r0, #1
3401088c:	e78d      	b.n	340107aa <CMW_CAMERA_Probe_Sensor.constprop.0+0x19e>
    return CMW_ERROR_UNKNOWN_COMPONENT;
3401088e:	f06f 0006 	mvn.w	r0, #6
34010892:	e78d      	b.n	340107b0 <CMW_CAMERA_Probe_Sensor.constprop.0+0x1a4>
34010894:	34057928 	.word	0x34057928
34010898:	00b71b00 	.word	0x00b71b00
3401089c:	340048fd 	.word	0x340048fd
340108a0:	340105f9 	.word	0x340105f9
340108a4:	340105e5 	.word	0x340105e5
340108a8:	34057a6c 	.word	0x34057a6c
340108ac:	34057acc 	.word	0x34057acc
340108b0:	34010b5d 	.word	0x34010b5d
340108b4:	340105a5 	.word	0x340105a5
340108b8:	34010ba1 	.word	0x34010ba1
340108bc:	340105b5 	.word	0x340105b5
340108c0:	340105c5 	.word	0x340105c5
340108c4:	34057b18 	.word	0x34057b18
340108c8:	340035b9 	.word	0x340035b9
340108cc:	34003489 	.word	0x34003489
340108d0:	340033f9 	.word	0x340033f9
340108d4:	34003549 	.word	0x34003549
340108d8:	34003581 	.word	0x34003581

340108dc <CMW_CAMERA_EnableGPIOs>:
{
340108dc:	b570      	push	{r4, r5, r6, lr}
340108de:	b088      	sub	sp, #32
  GPIO_InitTypeDef gpio_init_structure = {0};
340108e0:	2214      	movs	r2, #20
340108e2:	2100      	movs	r1, #0
340108e4:	a803      	add	r0, sp, #12
340108e6:	f008 f9bd 	bl	34018c64 <memset>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340108ea:	2308      	movs	r3, #8
340108ec:	4c13      	ldr	r4, [pc, #76]	@ (3401093c <CMW_CAMERA_EnableGPIOs+0x60>)
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340108ee:	2501      	movs	r5, #1
340108f0:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
340108f4:	f8d4 325c 	ldr.w	r3, [r4, #604]	@ 0x25c
340108f8:	2600      	movs	r6, #0
340108fa:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
340108fc:	9b02      	ldr	r3, [sp, #8]
  NRST_CAM_GPIO_ENABLE_VDDIO();
340108fe:	f7f8 fba1 	bl	34009044 <HAL_PWREx_EnableVddIO4>
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34010902:	2304      	movs	r3, #4
34010904:	f8c4 3a5c 	str.w	r3, [r4, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34010908:	f8d4 225c 	ldr.w	r2, [r4, #604]	@ 0x25c
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3401090c:	2403      	movs	r4, #3
3401090e:	9201      	str	r2, [sp, #4]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
34010910:	a903      	add	r1, sp, #12
34010912:	480b      	ldr	r0, [pc, #44]	@ (34010940 <CMW_CAMERA_EnableGPIOs+0x64>)
  (void)tmpreg;
34010914:	9a01      	ldr	r2, [sp, #4]
  gpio_init_structure.Pin       = EN_CAM_PIN;
34010916:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34010918:	e9cd 5604 	strd	r5, r6, [sp, #16]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3401091c:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3401091e:	f7f6 fe77 	bl	34007610 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = NRST_CAM_PIN;
34010922:	f44f 7380 	mov.w	r3, #256	@ 0x100
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
34010926:	4807      	ldr	r0, [pc, #28]	@ (34010944 <CMW_CAMERA_EnableGPIOs+0x68>)
34010928:	a903      	add	r1, sp, #12
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3401092a:	e9cd 5604 	strd	r5, r6, [sp, #16]
  gpio_init_structure.Pin       = NRST_CAM_PIN;
3401092e:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34010930:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
34010932:	f7f6 fe6d 	bl	34007610 <HAL_GPIO_Init>
}
34010936:	b008      	add	sp, #32
34010938:	bd70      	pop	{r4, r5, r6, pc}
3401093a:	bf00      	nop
3401093c:	56028000 	.word	0x56028000
34010940:	56020c00 	.word	0x56020c00
34010944:	56020800 	.word	0x56020800

34010948 <CMW_CAMERA_GetDCMIPPHandle>:
}
34010948:	4800      	ldr	r0, [pc, #0]	@ (3401094c <CMW_CAMERA_GetDCMIPPHandle+0x4>)
3401094a:	4770      	bx	lr
3401094c:	34057acc 	.word	0x34057acc

34010950 <CMW_CAMERA_SetPipeConfig>:
{
34010950:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
}
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010954:	2600      	movs	r6, #0
{
34010956:	4604      	mov	r4, r0
34010958:	b093      	sub	sp, #76	@ 0x4c
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3401095a:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
{
3401095e:	460d      	mov	r5, r1
34010960:	4617      	mov	r7, r2
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
34010962:	4631      	mov	r1, r6
34010964:	2218      	movs	r2, #24
34010966:	4640      	mov	r0, r8
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
34010968:	e9cd 6604 	strd	r6, r6, [sp, #16]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3401096c:	9602      	str	r6, [sp, #8]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3401096e:	9606      	str	r6, [sp, #24]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
34010970:	9603      	str	r6, [sp, #12]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
34010972:	f008 f977 	bl	34018c64 <memset>
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
34010976:	2214      	movs	r2, #20
34010978:	4631      	mov	r1, r6
3401097a:	a807      	add	r0, sp, #28
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3401097c:	f10d 0908 	add.w	r9, sp, #8
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
34010980:	f008 f970 	bl	34018c64 <memset>
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
34010984:	b95c      	cbnz	r4, 3401099e <CMW_CAMERA_SetPipeConfig+0x4e>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
34010986:	4621      	mov	r1, r4
34010988:	484f      	ldr	r0, [pc, #316]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
3401098a:	aa04      	add	r2, sp, #16
3401098c:	f7f4 fc4c 	bl	34005228 <HAL_DCMIPP_PIPE_SetConfig>
    if (ret != HAL_OK)
34010990:	2800      	cmp	r0, #0
34010992:	d07c      	beq.n	34010a8e <CMW_CAMERA_SetPipeConfig+0x13e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
34010994:	f06f 0004 	mvn.w	r0, #4
}
34010998:	b013      	add	sp, #76	@ 0x4c
3401099a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }

    return HAL_OK;
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
3401099e:	e9cd 9800 	strd	r9, r8, [sp]
340109a2:	484a      	ldr	r0, [pc, #296]	@ (34010acc <CMW_CAMERA_SetPipeConfig+0x17c>)
340109a4:	462a      	mov	r2, r5
340109a6:	e9d0 0100 	ldrd	r0, r1, [r0]
340109aa:	ab07      	add	r3, sp, #28
340109ac:	f000 fa10 	bl	34010dd0 <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
340109b0:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	@ 0x24
340109b4:	4313      	orrs	r3, r2
340109b6:	d015      	beq.n	340109e4 <CMW_CAMERA_SetPipeConfig+0x94>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
340109b8:	4621      	mov	r1, r4
340109ba:	4843      	ldr	r0, [pc, #268]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
340109bc:	aa07      	add	r2, sp, #28
340109be:	f7f5 f99d 	bl	34005cfc <HAL_DCMIPP_PIPE_SetCropConfig>
    if (ret != HAL_OK)
340109c2:	2800      	cmp	r0, #0
340109c4:	d1e6      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
340109c6:	4621      	mov	r1, r4
340109c8:	483f      	ldr	r0, [pc, #252]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
340109ca:	f7f5 fa3d 	bl	34005e48 <HAL_DCMIPP_PIPE_EnableCrop>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
    if (ret != HAL_OK)
340109ce:	2800      	cmp	r0, #0
340109d0:	d1e0      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
340109d2:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
340109d6:	4313      	orrs	r3, r2
340109d8:	d109      	bne.n	340109ee <CMW_CAMERA_SetPipeConfig+0x9e>
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
340109da:	4621      	mov	r1, r4
340109dc:	483a      	ldr	r0, [pc, #232]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
340109de:	f7f5 fb61 	bl	340060a4 <HAL_DCMIPP_PIPE_DisableDecimation>
340109e2:	e00f      	b.n	34010a04 <CMW_CAMERA_SetPipeConfig+0xb4>
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
340109e4:	4621      	mov	r1, r4
340109e6:	4838      	ldr	r0, [pc, #224]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
340109e8:	f7f5 fa6e 	bl	34005ec8 <HAL_DCMIPP_PIPE_DisableCrop>
340109ec:	e7ef      	b.n	340109ce <CMW_CAMERA_SetPipeConfig+0x7e>
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
340109ee:	464a      	mov	r2, r9
340109f0:	4621      	mov	r1, r4
340109f2:	4835      	ldr	r0, [pc, #212]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
340109f4:	f7f5 fae8 	bl	34005fc8 <HAL_DCMIPP_PIPE_SetDecimationConfig>
    if (ret != HAL_OK)
340109f8:	2800      	cmp	r0, #0
340109fa:	d1cb      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
340109fc:	4621      	mov	r1, r4
340109fe:	4832      	ldr	r0, [pc, #200]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010a00:	f7f5 fb2e 	bl	34006060 <HAL_DCMIPP_PIPE_EnableDecimation>
    if (ret != HAL_OK)
34010a04:	2800      	cmp	r0, #0
34010a06:	d1c5      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
34010a08:	4642      	mov	r2, r8
34010a0a:	4621      	mov	r1, r4
34010a0c:	482e      	ldr	r0, [pc, #184]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010a0e:	f7f5 fb6b 	bl	340060e8 <HAL_DCMIPP_PIPE_SetDownsizeConfig>
  if (ret != HAL_OK)
34010a12:	4e2d      	ldr	r6, [pc, #180]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010a14:	2800      	cmp	r0, #0
34010a16:	d1bd      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
34010a18:	4621      	mov	r1, r4
34010a1a:	4630      	mov	r0, r6
34010a1c:	f7f5 fbf2 	bl	34006204 <HAL_DCMIPP_PIPE_EnableDownsize>
  if (ret != HAL_OK)
34010a20:	2800      	cmp	r0, #0
34010a22:	d1b7      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  if (p_conf->enable_swap)
34010a24:	692b      	ldr	r3, [r5, #16]
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
34010a26:	4621      	mov	r1, r4
34010a28:	4630      	mov	r0, r6
  if (p_conf->enable_swap)
34010a2a:	2b00      	cmp	r3, #0
34010a2c:	d031      	beq.n	34010a92 <CMW_CAMERA_SetPipeConfig+0x142>
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
34010a2e:	f7f6 fa55 	bl	34006edc <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
    if (ret != HAL_OK)
34010a32:	2800      	cmp	r0, #0
34010a34:	d1ae      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
34010a36:	696b      	ldr	r3, [r5, #20]
34010a38:	2b00      	cmp	r3, #0
34010a3a:	da2d      	bge.n	34010a98 <CMW_CAMERA_SetPipeConfig+0x148>
        return CMW_ERROR_COMPONENT_FAILURE;
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
34010a3c:	2c02      	cmp	r4, #2
34010a3e:	d10f      	bne.n	34010a60 <CMW_CAMERA_SetPipeConfig+0x110>
  {
    if (!is_pipe1_2_shared)
34010a40:	f8df 808c 	ldr.w	r8, [pc, #140]	@ 34010ad0 <CMW_CAMERA_SetPipeConfig+0x180>
34010a44:	f8d8 3000 	ldr.w	r3, [r8]
34010a48:	b953      	cbnz	r3, 34010a60 <CMW_CAMERA_SetPipeConfig+0x110>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
34010a4a:	4621      	mov	r1, r4
34010a4c:	481e      	ldr	r0, [pc, #120]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010a4e:	f7f6 fa95 	bl	34006f7c <HAL_DCMIPP_PIPE_CSI_EnableShare>
      if (ret != HAL_OK)
34010a52:	2800      	cmp	r0, #0
34010a54:	d19e      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
      }
      is_pipe1_2_shared++;
34010a56:	f8d8 3000 	ldr.w	r3, [r8]
34010a5a:	3301      	adds	r3, #1
34010a5c:	f8c8 3000 	str.w	r3, [r8]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
34010a60:	2300      	movs	r3, #0
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
34010a62:	68ea      	ldr	r2, [r5, #12]
  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
34010a64:	9304      	str	r3, [sp, #16]
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
34010a66:	682b      	ldr	r3, [r5, #0]
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
  pipe_conf.PixelPackerFormat = p_conf->output_format;
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010a68:	4426      	add	r6, r4
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
34010a6a:	4353      	muls	r3, r2
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
34010a6c:	330f      	adds	r3, #15
34010a6e:	f023 030f 	bic.w	r3, r3, #15
  pipe_conf.PixelPackerFormat = p_conf->output_format;
34010a72:	68aa      	ldr	r2, [r5, #8]
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
34010a74:	9305      	str	r3, [sp, #20]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010a76:	7973      	ldrb	r3, [r6, #5]
  pipe_conf.PixelPackerFormat = p_conf->output_format;
34010a78:	9206      	str	r2, [sp, #24]
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
34010a7a:	b9c3      	cbnz	r3, 34010aae <CMW_CAMERA_SetPipeConfig+0x15e>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
34010a7c:	4621      	mov	r1, r4
34010a7e:	4812      	ldr	r0, [pc, #72]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010a80:	aa04      	add	r2, sp, #16
34010a82:	f7f4 fbd1 	bl	34005228 <HAL_DCMIPP_PIPE_SetConfig>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
    {
      return CMW_ERROR_COMPONENT_FAILURE;
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
34010a86:	2800      	cmp	r0, #0
34010a88:	d184      	bne.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
34010a8a:	9b05      	ldr	r3, [sp, #20]
34010a8c:	603b      	str	r3, [r7, #0]
    return HAL_OK;
34010a8e:	2000      	movs	r0, #0
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
34010a90:	e782      	b.n	34010998 <CMW_CAMERA_SetPipeConfig+0x48>
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
34010a92:	f7f6 fa4b 	bl	34006f2c <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
34010a96:	e7cc      	b.n	34010a32 <CMW_CAMERA_SetPipeConfig+0xe2>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
34010a98:	4621      	mov	r1, r4
34010a9a:	480b      	ldr	r0, [pc, #44]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
    if (p_conf->enable_gamma_conversion)
34010a9c:	d004      	beq.n	34010aa8 <CMW_CAMERA_SetPipeConfig+0x158>
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
34010a9e:	f7f5 fbd3 	bl	34006248 <HAL_DCMIPP_PIPE_EnableGammaConversion>
      if (ret != HAL_OK)
34010aa2:	2800      	cmp	r0, #0
34010aa4:	d0ca      	beq.n	34010a3c <CMW_CAMERA_SetPipeConfig+0xec>
34010aa6:	e775      	b.n	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
34010aa8:	f7f5 fbf0 	bl	3400628c <HAL_DCMIPP_PIPE_DisableGammaConversion>
34010aac:	e7f9      	b.n	34010aa2 <CMW_CAMERA_SetPipeConfig+0x152>
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
34010aae:	4621      	mov	r1, r4
34010ab0:	4805      	ldr	r0, [pc, #20]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010ab2:	f7f6 f9e1 	bl	34006e78 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
34010ab6:	2800      	cmp	r0, #0
34010ab8:	f47f af6c 	bne.w	34010994 <CMW_CAMERA_SetPipeConfig+0x44>
    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
34010abc:	4621      	mov	r1, r4
34010abe:	9a05      	ldr	r2, [sp, #20]
34010ac0:	4801      	ldr	r0, [pc, #4]	@ (34010ac8 <CMW_CAMERA_SetPipeConfig+0x178>)
34010ac2:	f7f6 f9a7 	bl	34006e14 <HAL_DCMIPP_PIPE_SetPitch>
34010ac6:	e7de      	b.n	34010a86 <CMW_CAMERA_SetPipeConfig+0x136>
34010ac8:	34057acc 	.word	0x34057acc
34010acc:	34057b1c 	.word	0x34057b1c
34010ad0:	3405791c 	.word	0x3405791c

34010ad4 <CMW_CAMERA_Start>:
  if (pipe >= DCMIPP_NUM_OF_PIPES)
34010ad4:	2802      	cmp	r0, #2
{
34010ad6:	460b      	mov	r3, r1
34010ad8:	b513      	push	{r0, r1, r4, lr}
  if (pipe >= DCMIPP_NUM_OF_PIPES)
34010ada:	d815      	bhi.n	34010b08 <CMW_CAMERA_Start+0x34>
  ret = HAL_DCMIPP_CSI_PIPE_Start(&hcamera_dcmipp, pipe, DCMIPP_VIRTUAL_CHANNEL0, (uint32_t)pbuff, mode);
34010adc:	4601      	mov	r1, r0
34010ade:	9200      	str	r2, [sp, #0]
34010ae0:	480e      	ldr	r0, [pc, #56]	@ (34010b1c <CMW_CAMERA_Start+0x48>)
34010ae2:	2200      	movs	r2, #0
34010ae4:	f7f4 fc3e 	bl	34005364 <HAL_DCMIPP_CSI_PIPE_Start>
  if (ret != HAL_OK)
34010ae8:	b988      	cbnz	r0, 34010b0e <CMW_CAMERA_Start+0x3a>
  if (!is_camera_started)
34010aea:	4c0d      	ldr	r4, [pc, #52]	@ (34010b20 <CMW_CAMERA_Start+0x4c>)
34010aec:	6823      	ldr	r3, [r4, #0]
34010aee:	b113      	cbz	r3, 34010af6 <CMW_CAMERA_Start+0x22>
  return ret;
34010af0:	2000      	movs	r0, #0
}
34010af2:	b002      	add	sp, #8
34010af4:	bd10      	pop	{r4, pc}
    ret = Camera_Drv.Start(&camera_bsp);
34010af6:	4b0b      	ldr	r3, [pc, #44]	@ (34010b24 <CMW_CAMERA_Start+0x50>)
34010af8:	480b      	ldr	r0, [pc, #44]	@ (34010b28 <CMW_CAMERA_Start+0x54>)
34010afa:	689b      	ldr	r3, [r3, #8]
34010afc:	4798      	blx	r3
    if (ret != CMW_ERROR_NONE)
34010afe:	b948      	cbnz	r0, 34010b14 <CMW_CAMERA_Start+0x40>
    is_camera_started++;
34010b00:	6823      	ldr	r3, [r4, #0]
34010b02:	3301      	adds	r3, #1
34010b04:	6023      	str	r3, [r4, #0]
34010b06:	e7f3      	b.n	34010af0 <CMW_CAMERA_Start+0x1c>
    return CMW_ERROR_WRONG_PARAM;
34010b08:	f06f 0001 	mvn.w	r0, #1
34010b0c:	e7f1      	b.n	34010af2 <CMW_CAMERA_Start+0x1e>
    return CMW_ERROR_PERIPH_FAILURE;
34010b0e:	f06f 0003 	mvn.w	r0, #3
34010b12:	e7ee      	b.n	34010af2 <CMW_CAMERA_Start+0x1e>
      return CMW_ERROR_COMPONENT_FAILURE;
34010b14:	f06f 0004 	mvn.w	r0, #4
34010b18:	e7eb      	b.n	34010af2 <CMW_CAMERA_Start+0x1e>
34010b1a:	bf00      	nop
34010b1c:	34057acc 	.word	0x34057acc
34010b20:	34057920 	.word	0x34057920
34010b24:	34057a6c 	.word	0x34057a6c
34010b28:	34057928 	.word	0x34057928

34010b2c <CMW_CAMERA_SetGain>:
  if(Camera_Drv.SetGain == NULL)
34010b2c:	4b08      	ldr	r3, [pc, #32]	@ (34010b50 <CMW_CAMERA_SetGain+0x24>)
{
34010b2e:	b510      	push	{r4, lr}
  if(Camera_Drv.SetGain == NULL)
34010b30:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
{
34010b32:	4604      	mov	r4, r0
  if(Camera_Drv.SetGain == NULL)
34010b34:	b133      	cbz	r3, 34010b44 <CMW_CAMERA_SetGain+0x18>
  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
34010b36:	4601      	mov	r1, r0
34010b38:	4806      	ldr	r0, [pc, #24]	@ (34010b54 <CMW_CAMERA_SetGain+0x28>)
34010b3a:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010b3c:	b928      	cbnz	r0, 34010b4a <CMW_CAMERA_SetGain+0x1e>
  Camera_Ctx.Gain = Gain;
34010b3e:	4b06      	ldr	r3, [pc, #24]	@ (34010b58 <CMW_CAMERA_SetGain+0x2c>)
34010b40:	621c      	str	r4, [r3, #32]
}
34010b42:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010b44:	f06f 000a 	mvn.w	r0, #10
34010b48:	e7fb      	b.n	34010b42 <CMW_CAMERA_SetGain+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
34010b4a:	f06f 0004 	mvn.w	r0, #4
34010b4e:	e7f8      	b.n	34010b42 <CMW_CAMERA_SetGain+0x16>
34010b50:	34057a6c 	.word	0x34057a6c
34010b54:	34057928 	.word	0x34057928
34010b58:	34057ad8 	.word	0x34057ad8

34010b5c <CB_ISP_SetSensorGain>:
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
34010b5c:	4608      	mov	r0, r1
{
34010b5e:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
34010b60:	f7ff ffe4 	bl	34010b2c <CMW_CAMERA_SetGain>
  return ISP_OK;
34010b64:	2800      	cmp	r0, #0
}
34010b66:	bf14      	ite	ne
34010b68:	2079      	movne	r0, #121	@ 0x79
34010b6a:	2000      	moveq	r0, #0
34010b6c:	bd08      	pop	{r3, pc}
	...

34010b70 <CMW_CAMERA_SetExposure>:
  if(Camera_Drv.SetExposure == NULL)
34010b70:	4b08      	ldr	r3, [pc, #32]	@ (34010b94 <CMW_CAMERA_SetExposure+0x24>)
{
34010b72:	b510      	push	{r4, lr}
  if(Camera_Drv.SetExposure == NULL)
34010b74:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
{
34010b76:	4604      	mov	r4, r0
  if(Camera_Drv.SetExposure == NULL)
34010b78:	b133      	cbz	r3, 34010b88 <CMW_CAMERA_SetExposure+0x18>
  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
34010b7a:	4601      	mov	r1, r0
34010b7c:	4806      	ldr	r0, [pc, #24]	@ (34010b98 <CMW_CAMERA_SetExposure+0x28>)
34010b7e:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34010b80:	b928      	cbnz	r0, 34010b8e <CMW_CAMERA_SetExposure+0x1e>
  Camera_Ctx.Exposure = exposure;
34010b82:	4b06      	ldr	r3, [pc, #24]	@ (34010b9c <CMW_CAMERA_SetExposure+0x2c>)
34010b84:	625c      	str	r4, [r3, #36]	@ 0x24
}
34010b86:	bd10      	pop	{r4, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010b88:	f06f 000a 	mvn.w	r0, #10
34010b8c:	e7fb      	b.n	34010b86 <CMW_CAMERA_SetExposure+0x16>
    return CMW_ERROR_COMPONENT_FAILURE;
34010b8e:	f06f 0004 	mvn.w	r0, #4
34010b92:	e7f8      	b.n	34010b86 <CMW_CAMERA_SetExposure+0x16>
34010b94:	34057a6c 	.word	0x34057a6c
34010b98:	34057928 	.word	0x34057928
34010b9c:	34057ad8 	.word	0x34057ad8

34010ba0 <CB_ISP_SetSensorExposure>:
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
34010ba0:	4608      	mov	r0, r1
{
34010ba2:	b508      	push	{r3, lr}
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
34010ba4:	f7ff ffe4 	bl	34010b70 <CMW_CAMERA_SetExposure>
  return ISP_OK;
34010ba8:	2800      	cmp	r0, #0
}
34010baa:	bf14      	ite	ne
34010bac:	2083      	movne	r0, #131	@ 0x83
34010bae:	2000      	moveq	r0, #0
34010bb0:	bd08      	pop	{r3, pc}
	...

34010bb4 <CMW_CAMERA_GetSensorInfo>:
{
34010bb4:	b508      	push	{r3, lr}
  if(Camera_Drv.GetSensorInfo == NULL)
34010bb6:	4b07      	ldr	r3, [pc, #28]	@ (34010bd4 <CMW_CAMERA_GetSensorInfo+0x20>)
{
34010bb8:	4601      	mov	r1, r0
  if(Camera_Drv.GetSensorInfo == NULL)
34010bba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34010bbc:	b133      	cbz	r3, 34010bcc <CMW_CAMERA_GetSensorInfo+0x18>
  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
34010bbe:	4806      	ldr	r0, [pc, #24]	@ (34010bd8 <CMW_CAMERA_GetSensorInfo+0x24>)
34010bc0:	4798      	blx	r3
    return CMW_ERROR_COMPONENT_FAILURE;
34010bc2:	2800      	cmp	r0, #0
34010bc4:	bf18      	it	ne
34010bc6:	f06f 0004 	mvnne.w	r0, #4
}
34010bca:	bd08      	pop	{r3, pc}
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
34010bcc:	f06f 000a 	mvn.w	r0, #10
34010bd0:	e7fb      	b.n	34010bca <CMW_CAMERA_GetSensorInfo+0x16>
34010bd2:	bf00      	nop
34010bd4:	34057a6c 	.word	0x34057a6c
34010bd8:	34057928 	.word	0x34057928

34010bdc <CMW_CAMERA_Init>:
{
34010bdc:	b570      	push	{r4, r5, r6, lr}
34010bde:	4604      	mov	r4, r0
34010be0:	b094      	sub	sp, #80	@ 0x50
  ISP_SensorInfoTypeDef info = {0};
34010be2:	223c      	movs	r2, #60	@ 0x3c
34010be4:	2100      	movs	r1, #0
34010be6:	a805      	add	r0, sp, #20
34010be8:	f008 f83c 	bl	34018c64 <memset>
  initValues.width = initConf->width;
34010bec:	6823      	ldr	r3, [r4, #0]
  if (is_camera_init != 0)
34010bee:	4e22      	ldr	r6, [pc, #136]	@ (34010c78 <CMW_CAMERA_Init+0x9c>)
  initValues.width = initConf->width;
34010bf0:	9300      	str	r3, [sp, #0]
  initValues.height = initConf->height;
34010bf2:	6863      	ldr	r3, [r4, #4]
34010bf4:	9301      	str	r3, [sp, #4]
  initValues.fps = initConf->fps;
34010bf6:	68a3      	ldr	r3, [r4, #8]
34010bf8:	9302      	str	r3, [sp, #8]
  initValues.pixel_format = initConf->pixel_format;
34010bfa:	68e3      	ldr	r3, [r4, #12]
34010bfc:	9303      	str	r3, [sp, #12]
  initValues.mirrorFlip = initConf->mirror_flip;
34010bfe:	6963      	ldr	r3, [r4, #20]
34010c00:	9304      	str	r3, [sp, #16]
  if (is_camera_init != 0)
34010c02:	6833      	ldr	r3, [r6, #0]
34010c04:	2b00      	cmp	r3, #0
34010c06:	d135      	bne.n	34010c74 <CMW_CAMERA_Init+0x98>
  hcamera_dcmipp.Instance = DCMIPP;
34010c08:	4d1c      	ldr	r5, [pc, #112]	@ (34010c7c <CMW_CAMERA_Init+0xa0>)
34010c0a:	4b1d      	ldr	r3, [pc, #116]	@ (34010c80 <CMW_CAMERA_Init+0xa4>)
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
34010c0c:	4628      	mov	r0, r5
  hcamera_dcmipp.Instance = DCMIPP;
34010c0e:	602b      	str	r3, [r5, #0]
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
34010c10:	f7f1 fc55 	bl	340024be <MX_DCMIPP_ClockConfig>
  if (ret != HAL_OK)
34010c14:	b118      	cbz	r0, 34010c1e <CMW_CAMERA_Init+0x42>
    return CMW_ERROR_PERIPH_FAILURE;
34010c16:	f06f 0003 	mvn.w	r0, #3
}
34010c1a:	b014      	add	sp, #80	@ 0x50
34010c1c:	bd70      	pop	{r4, r5, r6, pc}
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
34010c1e:	4628      	mov	r0, r5
34010c20:	f7f4 f934 	bl	34004e8c <HAL_DCMIPP_Init>
  if (ret != HAL_OK)
34010c24:	2800      	cmp	r0, #0
34010c26:	d1f6      	bne.n	34010c16 <CMW_CAMERA_Init+0x3a>
  CMW_CAMERA_EnableGPIOs();
34010c28:	f7ff fe58 	bl	340108dc <CMW_CAMERA_EnableGPIOs>
  ret = CMW_CAMERA_Probe_Sensor(&initValues, &detected_sensor);
34010c2c:	4668      	mov	r0, sp
34010c2e:	f7ff fced 	bl	3401060c <CMW_CAMERA_Probe_Sensor.constprop.0>
  if (ret != CMW_ERROR_NONE)
34010c32:	b110      	cbz	r0, 34010c3a <CMW_CAMERA_Init+0x5e>
    return CMW_ERROR_UNKNOWN_COMPONENT;
34010c34:	f06f 0006 	mvn.w	r0, #6
34010c38:	e7ef      	b.n	34010c1a <CMW_CAMERA_Init+0x3e>
  ret = CMW_CAMERA_GetSensorInfo(&info);
34010c3a:	a805      	add	r0, sp, #20
34010c3c:	f7ff ffba 	bl	34010bb4 <CMW_CAMERA_GetSensorInfo>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010c40:	3005      	adds	r0, #5
34010c42:	d0f7      	beq.n	34010c34 <CMW_CAMERA_Init+0x58>
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
34010c44:	9812      	ldr	r0, [sp, #72]	@ 0x48
34010c46:	f7ff ff93 	bl	34010b70 <CMW_CAMERA_SetExposure>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010c4a:	3005      	adds	r0, #5
34010c4c:	d0f2      	beq.n	34010c34 <CMW_CAMERA_Init+0x58>
  ret = CMW_CAMERA_SetGain(info.gain_min);
34010c4e:	9810      	ldr	r0, [sp, #64]	@ 0x40
34010c50:	f7ff ff6c 	bl	34010b2c <CMW_CAMERA_SetGain>
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
34010c54:	3005      	adds	r0, #5
34010c56:	d0ed      	beq.n	34010c34 <CMW_CAMERA_Init+0x58>
  initConf->width = initValues.width;
34010c58:	9b00      	ldr	r3, [sp, #0]
  camera_conf = *initConf;
34010c5a:	4d0a      	ldr	r5, [pc, #40]	@ (34010c84 <CMW_CAMERA_Init+0xa8>)
  initConf->width = initValues.width;
34010c5c:	6023      	str	r3, [r4, #0]
  initConf->height = initValues.height ;
34010c5e:	9b01      	ldr	r3, [sp, #4]
34010c60:	6063      	str	r3, [r4, #4]
  camera_conf = *initConf;
34010c62:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34010c64:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  is_camera_init++;
34010c66:	6833      	ldr	r3, [r6, #0]
  camera_conf = *initConf;
34010c68:	e894 0003 	ldmia.w	r4, {r0, r1}
34010c6c:	e885 0003 	stmia.w	r5, {r0, r1}
  is_camera_init++;
34010c70:	3301      	adds	r3, #1
34010c72:	6033      	str	r3, [r6, #0]
    return CMW_ERROR_NONE;
34010c74:	2000      	movs	r0, #0
34010c76:	e7d0      	b.n	34010c1a <CMW_CAMERA_Init+0x3e>
34010c78:	34057924 	.word	0x34057924
34010c7c:	34057acc 	.word	0x34057acc
34010c80:	58002000 	.word	0x58002000
34010c84:	34057b1c 	.word	0x34057b1c

34010c88 <CMW_CAMERA_Run>:
  if(Camera_Drv.Run != NULL)
34010c88:	4b03      	ldr	r3, [pc, #12]	@ (34010c98 <CMW_CAMERA_Run+0x10>)
34010c8a:	68db      	ldr	r3, [r3, #12]
34010c8c:	b10b      	cbz	r3, 34010c92 <CMW_CAMERA_Run+0xa>
      return Camera_Drv.Run(&camera_bsp);
34010c8e:	4803      	ldr	r0, [pc, #12]	@ (34010c9c <CMW_CAMERA_Run+0x14>)
34010c90:	4718      	bx	r3
}
34010c92:	4618      	mov	r0, r3
34010c94:	4770      	bx	lr
34010c96:	bf00      	nop
34010c98:	34057a6c 	.word	0x34057a6c
34010c9c:	34057928 	.word	0x34057928

34010ca0 <CMW_CAMERA_PIPE_VsyncEventCallback>:
__weak int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
34010ca0:	2000      	movs	r0, #0
34010ca2:	4770      	bx	lr

34010ca4 <HAL_DCMIPP_PIPE_VsyncEventCallback>:
  if(Camera_Drv.VsyncEventCallback != NULL)
34010ca4:	4b05      	ldr	r3, [pc, #20]	@ (34010cbc <HAL_DCMIPP_PIPE_VsyncEventCallback+0x18>)
{
34010ca6:	b510      	push	{r4, lr}
  if(Camera_Drv.VsyncEventCallback != NULL)
34010ca8:	691b      	ldr	r3, [r3, #16]
{
34010caa:	460c      	mov	r4, r1
  if(Camera_Drv.VsyncEventCallback != NULL)
34010cac:	b10b      	cbz	r3, 34010cb2 <HAL_DCMIPP_PIPE_VsyncEventCallback+0xe>
      Camera_Drv.VsyncEventCallback(&camera_bsp, Pipe);
34010cae:	4804      	ldr	r0, [pc, #16]	@ (34010cc0 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>)
34010cb0:	4798      	blx	r3
  CMW_CAMERA_PIPE_VsyncEventCallback(Pipe);
34010cb2:	4620      	mov	r0, r4
34010cb4:	f7ff fff4 	bl	34010ca0 <CMW_CAMERA_PIPE_VsyncEventCallback>
}
34010cb8:	bd10      	pop	{r4, pc}
34010cba:	bf00      	nop
34010cbc:	34057a6c 	.word	0x34057a6c
34010cc0:	34057928 	.word	0x34057928

34010cc4 <HAL_DCMIPP_PIPE_FrameEventCallback>:
  if(Camera_Drv.FrameEventCallback != NULL)
34010cc4:	4b05      	ldr	r3, [pc, #20]	@ (34010cdc <HAL_DCMIPP_PIPE_FrameEventCallback+0x18>)
{
34010cc6:	b510      	push	{r4, lr}
  if(Camera_Drv.FrameEventCallback != NULL)
34010cc8:	695b      	ldr	r3, [r3, #20]
{
34010cca:	460c      	mov	r4, r1
  if(Camera_Drv.FrameEventCallback != NULL)
34010ccc:	b10b      	cbz	r3, 34010cd2 <HAL_DCMIPP_PIPE_FrameEventCallback+0xe>
      Camera_Drv.FrameEventCallback(&camera_bsp, Pipe);
34010cce:	4804      	ldr	r0, [pc, #16]	@ (34010ce0 <HAL_DCMIPP_PIPE_FrameEventCallback+0x1c>)
34010cd0:	4798      	blx	r3
  CMW_CAMERA_PIPE_FrameEventCallback(Pipe);
34010cd2:	4620      	mov	r0, r4
34010cd4:	f7f0 fece 	bl	34001a74 <CMW_CAMERA_PIPE_FrameEventCallback>
}
34010cd8:	bd10      	pop	{r4, pc}
34010cda:	bf00      	nop
34010cdc:	34057a6c 	.word	0x34057a6c
34010ce0:	34057928 	.word	0x34057928

34010ce4 <HAL_DCMIPP_MspInit>:
  WRITE_REG(RCC->APB5ENSR, Periphs);
34010ce4:	2304      	movs	r3, #4
{
34010ce6:	b530      	push	{r4, r5, lr}
34010ce8:	4c1b      	ldr	r4, [pc, #108]	@ (34010d58 <HAL_DCMIPP_MspInit+0x74>)
34010cea:	b085      	sub	sp, #20
34010cec:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34010cf0:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010cf4:	f504 5580 	add.w	r5, r4, #4096	@ 0x1000
  tmpreg = READ_REG(RCC->APB5ENR);
34010cf8:	9203      	str	r2, [sp, #12]
  (void)tmpreg;
34010cfa:	9a03      	ldr	r2, [sp, #12]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34010cfc:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34010d00:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
  HAL_NVIC_SetPriority(DCMIPP_IRQn, 0x07, 0);
34010d04:	2107      	movs	r1, #7
34010d06:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
34010d08:	9a02      	ldr	r2, [sp, #8]
34010d0a:	2030      	movs	r0, #48	@ 0x30
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34010d0c:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
34010d10:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010d12:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
34010d16:	f7f3 ff37 	bl	34004b88 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
34010d1a:	2030      	movs	r0, #48	@ 0x30
34010d1c:	f7f3 ff92 	bl	34004c44 <HAL_NVIC_EnableIRQ>
  WRITE_REG(RCC->APB5ENSR, Periphs);
34010d20:	2340      	movs	r3, #64	@ 0x40
34010d22:	f8c4 3a7c 	str.w	r3, [r4, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34010d26:	f8d4 227c 	ldr.w	r2, [r4, #636]	@ 0x27c
  HAL_NVIC_SetPriority(CSI_IRQn, 0x07, 0);
34010d2a:	2107      	movs	r1, #7
34010d2c:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
34010d2e:	9a01      	ldr	r2, [sp, #4]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34010d30:	f8c4 3abc 	str.w	r3, [r4, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
34010d34:	f8d4 22bc 	ldr.w	r2, [r4, #700]	@ 0x2bc
34010d38:	202f      	movs	r0, #47	@ 0x2f
34010d3a:	9200      	str	r2, [sp, #0]
  (void)tmpreg;
34010d3c:	9a00      	ldr	r2, [sp, #0]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34010d3e:	f8c4 3a3c 	str.w	r3, [r4, #2620]	@ 0xa3c
34010d42:	2200      	movs	r2, #0
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34010d44:	f8c5 323c 	str.w	r3, [r5, #572]	@ 0x23c
34010d48:	f7f3 ff1e 	bl	34004b88 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CSI_IRQn);
34010d4c:	202f      	movs	r0, #47	@ 0x2f
}
34010d4e:	b005      	add	sp, #20
34010d50:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  HAL_NVIC_EnableIRQ(CSI_IRQn);
34010d54:	f7f3 bf76 	b.w	34004c44 <HAL_NVIC_EnableIRQ>
34010d58:	56028000 	.word	0x56028000

34010d5c <CMW_UTILS_get_dec_ratio_and_update>:

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
34010d5c:	b508      	push	{r3, lr}
  int dec_ratio = 1;

  while (*ratio >= 8) {
34010d5e:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
  int dec_ratio = 1;
34010d62:	2301      	movs	r3, #1
    dec_ratio *= 2;
    *ratio /= 2;
34010d64:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
  while (*ratio >= 8) {
34010d68:	edd0 7a00 	vldr	s15, [r0]
34010d6c:	eef4 7ac7 	vcmpe.f32	s15, s14
34010d70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010d74:	da08      	bge.n	34010d88 <CMW_UTILS_get_dec_ratio_and_update+0x2c>
  switch (dec_ratio) {
34010d76:	3b01      	subs	r3, #1
34010d78:	2b07      	cmp	r3, #7
34010d7a:	d81a      	bhi.n	34010db2 <CMW_UTILS_get_dec_ratio_and_update+0x56>
34010d7c:	e8df f003 	tbb	[pc, r3]
34010d80:	0f190a1f 	.word	0x0f190a1f
34010d84:	14191919 	.word	0x14191919
    *ratio /= 2;
34010d88:	ee67 7aa6 	vmul.f32	s15, s15, s13
    dec_ratio *= 2;
34010d8c:	005b      	lsls	r3, r3, #1
    *ratio /= 2;
34010d8e:	edc0 7a00 	vstr	s15, [r0]
34010d92:	e7e9      	b.n	34010d68 <CMW_UTILS_get_dec_ratio_and_update+0xc>
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
34010d94:	2900      	cmp	r1, #0
34010d96:	bf0c      	ite	eq
34010d98:	2002      	moveq	r0, #2
34010d9a:	2008      	movne	r0, #8
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
}
34010d9c:	bd08      	pop	{r3, pc}
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
34010d9e:	2900      	cmp	r1, #0
34010da0:	bf0c      	ite	eq
34010da2:	2004      	moveq	r0, #4
34010da4:	2010      	movne	r0, #16
34010da6:	e7f9      	b.n	34010d9c <CMW_UTILS_get_dec_ratio_and_update+0x40>
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
34010da8:	2900      	cmp	r1, #0
34010daa:	bf0c      	ite	eq
34010dac:	2006      	moveq	r0, #6
34010dae:	2018      	movne	r0, #24
34010db0:	e7f4      	b.n	34010d9c <CMW_UTILS_get_dec_ratio_and_update+0x40>
    assert(0);
34010db2:	2177      	movs	r1, #119	@ 0x77
34010db4:	4b03      	ldr	r3, [pc, #12]	@ (34010dc4 <CMW_UTILS_get_dec_ratio_and_update+0x68>)
34010db6:	4a04      	ldr	r2, [pc, #16]	@ (34010dc8 <CMW_UTILS_get_dec_ratio_and_update+0x6c>)
34010db8:	4804      	ldr	r0, [pc, #16]	@ (34010dcc <CMW_UTILS_get_dec_ratio_and_update+0x70>)
34010dba:	f006 fdf1 	bl	340179a0 <__assert_func>
  switch (dec_ratio) {
34010dbe:	2000      	movs	r0, #0
34010dc0:	e7ec      	b.n	34010d9c <CMW_UTILS_get_dec_ratio_and_update+0x40>
34010dc2:	bf00      	nop
34010dc4:	3401d306 	.word	0x3401d306
34010dc8:	3403501e 	.word	0x3403501e
34010dcc:	3401c991 	.word	0x3401c991

34010dd0 <CMW_UTILS_GetPipeConfig>:
{
34010dd0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34010dd2:	4614      	mov	r4, r2
34010dd4:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
34010dd8:	6867      	ldr	r7, [r4, #4]
  if (p_conf->mode == CMW_Aspect_ratio_crop)
34010dda:	6992      	ldr	r2, [r2, #24]
  const float ratio_height = (float)cam_height / pipe_height;
34010ddc:	ee06 7a90 	vmov	s13, r7
{
34010de0:	ee07 0a10 	vmov	s14, r0
34010de4:	ee07 1a90 	vmov	s15, r1
  const float ratio_height = (float)cam_height / pipe_height;
34010de8:	eeb8 5a66 	vcvt.f32.u32	s10, s13
  if (p_conf->mode == CMW_Aspect_ratio_crop)
34010dec:	2a00      	cmp	r2, #0
34010dee:	f040 808e 	bne.w	34010f0e <CMW_UTILS_GetPipeConfig+0x13e>
  const float ratio_width = (float)cam_width / pipe_width ;
34010df2:	edd4 6a00 	vldr	s13, [r4]
34010df6:	eeb8 6a47 	vcvt.f32.u32	s12, s14
34010dfa:	eef8 4a66 	vcvt.f32.u32	s9, s13
  const float ratio_height = (float)cam_height / pipe_height;
34010dfe:	eef8 6a67 	vcvt.f32.u32	s13, s15
  const float ratio_width = (float)cam_width / pipe_width ;
34010e02:	ee86 4a24 	vdiv.f32	s8, s12, s9
  const float ratio_height = (float)cam_height / pipe_height;
34010e06:	eec6 5a85 	vdiv.f32	s11, s13, s10
  const float ratio = MIN(ratio_width, ratio_height);
34010e0a:	eeb4 4a65 	vcmp.f32	s8, s11
34010e0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010e12:	bf48      	it	mi
34010e14:	eef0 5a44 	vmovmi.f32	s11, s8
  assert(ratio >= 1);
34010e18:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
34010e1c:	eef4 5ac4 	vcmpe.f32	s11, s8
34010e20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010e24:	da05      	bge.n	34010e32 <CMW_UTILS_GetPipeConfig+0x62>
34010e26:	214f      	movs	r1, #79	@ 0x4f
34010e28:	4b4f      	ldr	r3, [pc, #316]	@ (34010f68 <CMW_UTILS_GetPipeConfig+0x198>)
34010e2a:	4a50      	ldr	r2, [pc, #320]	@ (34010f6c <CMW_UTILS_GetPipeConfig+0x19c>)
  assert(ratio < 64);
34010e2c:	4850      	ldr	r0, [pc, #320]	@ (34010f70 <CMW_UTILS_GetPipeConfig+0x1a0>)
34010e2e:	f006 fdb7 	bl	340179a0 <__assert_func>
34010e32:	ed9f 4a50 	vldr	s8, [pc, #320]	@ 34010f74 <CMW_UTILS_GetPipeConfig+0x1a4>
34010e36:	eef4 5ac4 	vcmpe.f32	s11, s8
34010e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34010e3e:	d403      	bmi.n	34010e48 <CMW_UTILS_GetPipeConfig+0x78>
34010e40:	2150      	movs	r1, #80	@ 0x50
34010e42:	4b4d      	ldr	r3, [pc, #308]	@ (34010f78 <CMW_UTILS_GetPipeConfig+0x1a8>)
34010e44:	4a49      	ldr	r2, [pc, #292]	@ (34010f6c <CMW_UTILS_GetPipeConfig+0x19c>)
34010e46:	e7f1      	b.n	34010e2c <CMW_UTILS_GetPipeConfig+0x5c>
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010e48:	ee24 4aa5 	vmul.f32	s8, s9, s11
34010e4c:	eeb4 6ac4 	vcmpe.f32	s12, s8
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010e50:	ee65 5a25 	vmul.f32	s11, s10, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010e54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010e58:	eef4 6ae5 	vcmpe.f32	s13, s11
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010e5c:	bfcc      	ite	gt
34010e5e:	eebc 6ac4 	vcvtgt.u32.f32	s12, s8
34010e62:	eebc 6ac6 	vcvtle.u32.f32	s12, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010e66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
34010e6a:	4601      	mov	r1, r0
34010e6c:	ee16 2a10 	vmov	r2, s12
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010e70:	bfcc      	ite	gt
34010e72:	eefc 6ae5 	vcvtgt.u32.f32	s13, s11
34010e76:	eefc 6ae6 	vcvtle.u32.f32	s13, s13
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
34010e7a:	3101      	adds	r1, #1
34010e7c:	1a89      	subs	r1, r1, r2
34010e7e:	0849      	lsrs	r1, r1, #1
34010e80:	6059      	str	r1, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010e82:	ee17 1a90 	vmov	r1, s15
34010e86:	ee16 2a90 	vmov	r2, s13
  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
34010e8a:	ed83 6a03 	vstr	s12, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
34010e8e:	edc3 6a02 	vstr	s13, [r3, #8]
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010e92:	eeb8 6a46 	vcvt.f32.u32	s12, s12
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010e96:	eef8 6a66 	vcvt.f32.u32	s13, s13
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010e9a:	3101      	adds	r1, #1
34010e9c:	1a89      	subs	r1, r1, r2
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
34010e9e:	2200      	movs	r2, #0
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010ea0:	eec6 5a24 	vdiv.f32	s11, s12, s9
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010ea4:	ee86 7a85 	vdiv.f32	s14, s13, s10
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
34010ea8:	0849      	lsrs	r1, r1, #1
34010eaa:	6019      	str	r1, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
34010eac:	611a      	str	r2, [r3, #16]

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
34010eae:	2100      	movs	r1, #0
34010eb0:	4668      	mov	r0, sp
34010eb2:	ed8d 7a01 	vstr	s14, [sp, #4]
34010eb6:	edcd 5a00 	vstr	s11, [sp]
34010eba:	f7ff ff4f 	bl	34010d5c <CMW_UTILS_get_dec_ratio_and_update>
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010ebe:	2101      	movs	r1, #1
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
34010ec0:	6068      	str	r0, [r5, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010ec2:	a801      	add	r0, sp, #4
34010ec4:	f7ff ff4a 	bl	34010d5c <CMW_UTILS_get_dec_ratio_and_update>
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010ec8:	ed9f 7a2c 	vldr	s14, [pc, #176]	@ 34010f7c <CMW_UTILS_GetPipeConfig+0x1ac>
34010ecc:	eddd 7a00 	vldr	s15, [sp]
34010ed0:	ee67 7a87 	vmul.f32	s15, s15, s14
34010ed4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
34010ed8:	6028      	str	r0, [r5, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010eda:	ee17 3a90 	vmov	r3, s15
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
34010ede:	6820      	ldr	r0, [r4, #0]
  down->HRatio = (uint32_t) (8192 * ratio_width);
34010ee0:	edc6 7a03 	vstr	s15, [r6, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
34010ee4:	eddd 7a01 	vldr	s15, [sp, #4]
34010ee8:	ee67 7a87 	vmul.f32	s15, s15, s14
34010eec:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34010ef0:	ee17 2a90 	vmov	r2, s15
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010ef4:	4922      	ldr	r1, [pc, #136]	@ (34010f80 <CMW_UTILS_GetPipeConfig+0x1b0>)
  down->VRatio = (uint32_t) (8192 * ratio_height);
34010ef6:	edc6 7a02 	vstr	s15, [r6, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010efa:	fbb1 f3f3 	udiv	r3, r1, r3
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
34010efe:	fbb1 f1f2 	udiv	r1, r1, r2
  down->VSize = height;
34010f02:	e9c6 7000 	strd	r7, r0, [r6]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
34010f06:	6173      	str	r3, [r6, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
34010f08:	6131      	str	r1, [r6, #16]
}
34010f0a:	b003      	add	sp, #12
34010f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
34010f0e:	2a01      	cmp	r2, #1
34010f10:	d10c      	bne.n	34010f2c <CMW_UTILS_GetPipeConfig+0x15c>
    ratio_width = (float)cam_width / p_conf->output_width;
34010f12:	edd4 6a00 	vldr	s13, [r4]
34010f16:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34010f1a:	eef8 6a66 	vcvt.f32.u32	s13, s13
34010f1e:	eec7 5a26 	vdiv.f32	s11, s14, s13
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010f22:	eef8 7a67 	vcvt.f32.u32	s15, s15
34010f26:	ee87 7a85 	vdiv.f32	s14, s15, s10
34010f2a:	e7c0      	b.n	34010eae <CMW_UTILS_GetPipeConfig+0xde>
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
34010f2c:	2a02      	cmp	r2, #2
34010f2e:	d106      	bne.n	34010f3e <CMW_UTILS_GetPipeConfig+0x16e>
    ratio_height = (float) cam_height / p_conf->output_height;
34010f30:	eef8 7a67 	vcvt.f32.u32	s15, s15
34010f34:	ee87 7a85 	vdiv.f32	s14, s15, s10
    ratio_width = (float) ratio_height;
34010f38:	eef0 5a47 	vmov.f32	s11, s14
34010f3c:	e7b7      	b.n	34010eae <CMW_UTILS_GetPipeConfig+0xde>
  crop->HSize = roi->width;
34010f3e:	69e1      	ldr	r1, [r4, #28]
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010f40:	ed94 7a00 	vldr	s14, [r4]
34010f44:	ee07 1a90 	vmov	s15, r1
34010f48:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34010f4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
  crop->HStart = roi->offset_x;
34010f50:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  crop->VSize = roi->height;
34010f52:	6a22      	ldr	r2, [r4, #32]
  crop->HStart = roi->offset_x;
34010f54:	6058      	str	r0, [r3, #4]
  crop->VStart = roi->offset_y;
34010f56:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
    ratio_width = (float)crop->HSize / p_conf->output_width;
34010f58:	eec7 5a87 	vdiv.f32	s11, s15, s14
  crop->HSize = roi->width;
34010f5c:	60d9      	str	r1, [r3, #12]
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010f5e:	ee07 2a90 	vmov	s15, r2
  crop->VSize = roi->height;
34010f62:	609a      	str	r2, [r3, #8]
  crop->VStart = roi->offset_y;
34010f64:	6018      	str	r0, [r3, #0]
    ratio_height = (float)crop->VSize / p_conf->output_height;
34010f66:	e7dc      	b.n	34010f22 <CMW_UTILS_GetPipeConfig+0x152>
34010f68:	3401c9e4 	.word	0x3401c9e4
34010f6c:	34035049 	.word	0x34035049
34010f70:	3401c991 	.word	0x3401c991
34010f74:	42800000 	.word	0x42800000
34010f78:	3401c9ef 	.word	0x3401c9ef
34010f7c:	46000000 	.word	0x46000000
34010f80:	007fffff 	.word	0x007fffff

34010f84 <CMW_IMX335_FrameEventCallback>:
#endif
}

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
34010f84:	4770      	bx	lr

34010f86 <CMW_IMX335_ReadID>:
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
34010f86:	3008      	adds	r0, #8
34010f88:	f000 bef4 	b.w	34011d74 <IMX335_ReadID>

34010f8c <CMW_IMX335_SetTestPattern>:
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
34010f8c:	3008      	adds	r0, #8
34010f8e:	f000 bffd 	b.w	34011f8c <IMX335_SetTestPattern>
	...

34010f94 <CMW_IMX335_GetSensorInfo>:
{
34010f94:	b508      	push	{r3, lr}
34010f96:	460b      	mov	r3, r1
  if ((io_ctx ==  NULL) || (info == NULL))
34010f98:	b1b8      	cbz	r0, 34010fca <CMW_IMX335_GetSensorInfo+0x36>
34010f9a:	b1b1      	cbz	r1, 34010fca <CMW_IMX335_GetSensorInfo+0x36>
    strcpy(info->name, IMX335_NAME);
34010f9c:	4618      	mov	r0, r3
34010f9e:	490c      	ldr	r1, [pc, #48]	@ (34010fd0 <CMW_IMX335_GetSensorInfo+0x3c>)
34010fa0:	f008 f8e1 	bl	34019166 <strcpy>
  info->bayer_pattern = IMX335_BAYER_PATTERN;
34010fa4:	f44f 6220 	mov.w	r2, #2560	@ 0xa00
  info->height = IMX335_HEIGHT;
34010fa8:	f44f 6122 	mov.w	r1, #2592	@ 0xa20
  info->bayer_pattern = IMX335_BAYER_PATTERN;
34010fac:	8402      	strh	r2, [r0, #32]
  info->height = IMX335_HEIGHT;
34010fae:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
    strcpy(info->name, IMX335_NAME);
34010fb2:	4603      	mov	r3, r0
  info->height = IMX335_HEIGHT;
34010fb4:	e9c0 1209 	strd	r1, r2, [r0, #36]	@ 0x24
  info->gain_max = IMX335_GAIN_MAX;
34010fb8:	2000      	movs	r0, #0
34010fba:	4a06      	ldr	r2, [pc, #24]	@ (34010fd4 <CMW_IMX335_GetSensorInfo+0x40>)
  info->exposure_min = IMX335_EXPOSURE_MIN;
34010fbc:	6358      	str	r0, [r3, #52]	@ 0x34
  info->gain_max = IMX335_GAIN_MAX;
34010fbe:	e9c3 020b 	strd	r0, r2, [r3, #44]	@ 0x2c
  info->exposure_max = IMX335_EXPOSURE_MAX;
34010fc2:	f248 12f2 	movw	r2, #33266	@ 0x81f2
34010fc6:	639a      	str	r2, [r3, #56]	@ 0x38
}
34010fc8:	bd08      	pop	{r3, pc}
    return CMW_ERROR_WRONG_PARAM;
34010fca:	f06f 0001 	mvn.w	r0, #1
34010fce:	e7fb      	b.n	34010fc8 <CMW_IMX335_GetSensorInfo+0x34>
34010fd0:	3401c9fa 	.word	0x3401c9fa
34010fd4:	00011940 	.word	0x00011940

34010fd8 <CMW_IMX335_SetMirrorFlip>:
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
34010fd8:	2903      	cmp	r1, #3
34010fda:	bf28      	it	cs
34010fdc:	2103      	movcs	r1, #3
34010fde:	3008      	adds	r0, #8
34010fe0:	f000 bfba 	b.w	34011f58 <IMX335_MirrorFlipConfig>

34010fe4 <CMW_IMX335_SetFramerate>:
  return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
34010fe4:	3008      	adds	r0, #8
34010fe6:	f000 bf8b 	b.w	34011f00 <IMX335_SetFramerate>

34010fea <CMW_IMX335_SetFrequency>:
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
34010fea:	3008      	adds	r0, #8
34010fec:	f000 bf64 	b.w	34011eb8 <IMX335_SetFrequency>

34010ff0 <CMW_IMX335_SetExposure>:
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
34010ff0:	3008      	adds	r0, #8
34010ff2:	f000 bf0f 	b.w	34011e14 <IMX335_SetExposure>

34010ff6 <CMW_IMX335_SetGain>:
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
34010ff6:	3008      	adds	r0, #8
34010ff8:	f000 bed4 	b.w	34011da4 <IMX335_SetGain>

34010ffc <CMW_IMX335_Run>:
{
34010ffc:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
34010ffe:	3030      	adds	r0, #48	@ 0x30
34011000:	f003 fa22 	bl	34014448 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
34011004:	2800      	cmp	r0, #0
}
34011006:	bf14      	ite	ne
34011008:	f06f 0003 	mvnne.w	r0, #3
3401100c:	2000      	moveq	r0, #0
3401100e:	bd08      	pop	{r3, pc}

34011010 <CMW_IMX335_DeInit>:
{
34011010:	b510      	push	{r4, lr}
34011012:	4604      	mov	r4, r0
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
34011014:	3030      	adds	r0, #48	@ 0x30
34011016:	f003 f95d 	bl	340142d4 <ISP_DeInit>
  if (ret)
3401101a:	b110      	cbz	r0, 34011022 <CMW_IMX335_DeInit+0x12>
    return CMW_ERROR_COMPONENT_FAILURE;
3401101c:	f06f 0004 	mvn.w	r0, #4
}
34011020:	bd10      	pop	{r4, pc}
  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34011022:	f104 0008 	add.w	r0, r4, #8
34011026:	f000 fe9c 	bl	34011d62 <IMX335_DeInit>
  if (ret)
3401102a:	2800      	cmp	r0, #0
3401102c:	d0f8      	beq.n	34011020 <CMW_IMX335_DeInit+0x10>
3401102e:	e7f5      	b.n	3401101c <CMW_IMX335_DeInit+0xc>

34011030 <CMW_IMX335_Start>:
{
34011030:	b530      	push	{r4, r5, lr}
34011032:	b087      	sub	sp, #28
  ISP_StatAreaTypeDef isp_stat_area = {0};
34011034:	ab02      	add	r3, sp, #8
{
34011036:	4604      	mov	r4, r0
  ISP_StatAreaTypeDef isp_stat_area = {0};
34011038:	2210      	movs	r2, #16
3401103a:	2100      	movs	r1, #0
3401103c:	4618      	mov	r0, r3
3401103e:	f007 fe11 	bl	34018c64 <memset>
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &isp_stat_area, &ISP_IQParamCacheInit_IMX335);
34011042:	4a0f      	ldr	r2, [pc, #60]	@ (34011080 <CMW_IMX335_Start+0x50>)
34011044:	f104 0530 	add.w	r5, r4, #48	@ 0x30
34011048:	e9cd 0200 	strd	r0, r2, [sp]
3401104c:	f104 03b8 	add.w	r3, r4, #184	@ 0xb8
34011050:	2200      	movs	r2, #0
34011052:	4628      	mov	r0, r5
34011054:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
34011058:	f003 f8b2 	bl	340141c0 <ISP_Init>
  if (ret != ISP_OK)
3401105c:	b948      	cbnz	r0, 34011072 <CMW_IMX335_Start+0x42>
  ret = ISP_Start(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401105e:	4628      	mov	r0, r5
34011060:	f003 f94a 	bl	340142f8 <ISP_Start>
  if (ret != ISP_OK)
34011064:	b940      	cbnz	r0, 34011078 <CMW_IMX335_Start+0x48>
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
34011066:	f104 0008 	add.w	r0, r4, #8
3401106a:	f000 fe5d 	bl	34011d28 <IMX335_Start>
}
3401106e:	b007      	add	sp, #28
34011070:	bd30      	pop	{r4, r5, pc}
    return CMW_ERROR_COMPONENT_FAILURE;
34011072:	f06f 0004 	mvn.w	r0, #4
34011076:	e7fa      	b.n	3401106e <CMW_IMX335_Start+0x3e>
      return CMW_ERROR_PERIPH_FAILURE;
34011078:	f06f 0003 	mvn.w	r0, #3
3401107c:	e7f7      	b.n	3401106e <CMW_IMX335_Start+0x3e>
3401107e:	bf00      	nop
34011080:	34035064 	.word	0x34035064

34011084 <CMW_IMX335_Init>:
{
34011084:	b538      	push	{r3, r4, r5, lr}
  if (width == 2592 && height == 1944)
34011086:	e9d1 2300 	ldrd	r2, r3, [r1]
3401108a:	f5b2 6f22 	cmp.w	r2, #2592	@ 0xa20
{
3401108e:	4605      	mov	r5, r0
34011090:	460c      	mov	r4, r1
  if (width == 2592 && height == 1944)
34011092:	d002      	beq.n	3401109a <CMW_IMX335_Init+0x16>
    return CMW_ERROR_WRONG_PARAM;
34011094:	f06f 0001 	mvn.w	r0, #1
}
34011098:	bd38      	pop	{r3, r4, r5, pc}
  if (width == 2592 && height == 1944)
3401109a:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
3401109e:	d1f9      	bne.n	34011094 <CMW_IMX335_Init+0x10>
  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
340110a0:	6909      	ldr	r1, [r1, #16]
340110a2:	f7ff ff99 	bl	34010fd8 <CMW_IMX335_SetMirrorFlip>
  if (ret)
340110a6:	2800      	cmp	r0, #0
340110a8:	d1f4      	bne.n	34011094 <CMW_IMX335_Init+0x10>
  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
340110aa:	2106      	movs	r1, #6
340110ac:	68e2      	ldr	r2, [r4, #12]
340110ae:	f105 0008 	add.w	r0, r5, #8
340110b2:	f000 fe19 	bl	34011ce8 <IMX335_Init>
    return CMW_ERROR_COMPONENT_FAILURE;
340110b6:	2800      	cmp	r0, #0
340110b8:	bf18      	it	ne
340110ba:	f06f 0004 	mvnne.w	r0, #4
340110be:	e7eb      	b.n	34011098 <CMW_IMX335_Init+0x14>

340110c0 <CMW_IMX335_VsyncEventCallback>:
  switch (pipe)
340110c0:	2901      	cmp	r1, #1
{
340110c2:	b510      	push	{r4, lr}
  switch (pipe)
340110c4:	d007      	beq.n	340110d6 <CMW_IMX335_VsyncEventCallback+0x16>
340110c6:	2902      	cmp	r1, #2
340110c8:	d00f      	beq.n	340110ea <CMW_IMX335_VsyncEventCallback+0x2a>
340110ca:	b999      	cbnz	r1, 340110f4 <CMW_IMX335_VsyncEventCallback+0x34>
}
340110cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
340110d0:	3030      	adds	r0, #48	@ 0x30
340110d2:	f003 b9cf 	b.w	34014474 <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
340110d6:	f100 0430 	add.w	r4, r0, #48	@ 0x30
340110da:	4620      	mov	r0, r4
340110dc:	f003 f9c6 	bl	3401446c <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
340110e0:	4620      	mov	r0, r4
}
340110e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
340110e6:	f003 b9bf 	b.w	34014468 <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
340110ea:	3030      	adds	r0, #48	@ 0x30
}
340110ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
340110f0:	f003 b9be 	b.w	34014470 <ISP_IncAncillaryFrameId>
}
340110f4:	bd10      	pop	{r4, pc}
	...

340110f8 <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
340110f8:	b573      	push	{r0, r1, r4, r5, r6, lr}
340110fa:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
340110fc:	8803      	ldrh	r3, [r0, #0]
{
340110fe:	460d      	mov	r5, r1
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
34011100:	8203      	strh	r3, [r0, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
34011102:	f8d0 30e4 	ldr.w	r3, [r0, #228]	@ 0xe4
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;

  CMW_IMX335_PowerOn(io_ctx);

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
34011106:	3408      	adds	r4, #8
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
34011108:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
3401110a:	f8d0 30e8 	ldr.w	r3, [r0, #232]	@ 0xe8
3401110e:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
34011110:	f8d0 30f4 	ldr.w	r3, [r0, #244]	@ 0xf4
34011114:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
34011116:	f8d0 30f0 	ldr.w	r3, [r0, #240]	@ 0xf0
3401111a:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
3401111c:	f8d0 30ec 	ldr.w	r3, [r0, #236]	@ 0xec
34011120:	6143      	str	r3, [r0, #20]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34011122:	f8d0 30fc 	ldr.w	r3, [r0, #252]	@ 0xfc
34011126:	2000      	movs	r0, #0
34011128:	4798      	blx	r3
  io_ctx->Delay(100);
3401112a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401112e:	2064      	movs	r0, #100	@ 0x64
34011130:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
34011132:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
34011136:	2000      	movs	r0, #0
34011138:	4798      	blx	r3
  io_ctx->Delay(100);
3401113a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401113e:	2064      	movs	r0, #100	@ 0x64
34011140:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34011142:	f8d4 30f4 	ldr.w	r3, [r4, #244]	@ 0xf4
34011146:	2001      	movs	r0, #1
34011148:	4798      	blx	r3
  io_ctx->Delay(100);
3401114a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401114e:	2064      	movs	r0, #100	@ 0x64
34011150:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
34011152:	f8d4 30f8 	ldr.w	r3, [r4, #248]	@ 0xf8
34011156:	2001      	movs	r0, #1
34011158:	4798      	blx	r3
  io_ctx->Delay(100);
3401115a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	@ 0xf0
3401115e:	2064      	movs	r0, #100	@ 0x64
34011160:	4798      	blx	r3
  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
34011162:	4621      	mov	r1, r4
34011164:	4620      	mov	r0, r4
34011166:	f000 fda3 	bl	34011cb0 <IMX335_RegisterBusIO>
  if (ret != IMX335_OK)
3401116a:	4606      	mov	r6, r0
3401116c:	b120      	cbz	r0, 34011178 <CMW_IMX335_Probe+0x80>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401116e:	f06f 0404 	mvn.w	r4, #4
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
  return ret;
}
34011172:	4620      	mov	r0, r4
34011174:	b002      	add	sp, #8
34011176:	bd70      	pop	{r4, r5, r6, pc}
  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
34011178:	4620      	mov	r0, r4
3401117a:	a901      	add	r1, sp, #4
3401117c:	f000 fdfa 	bl	34011d74 <IMX335_ReadID>
  if (ret != IMX335_OK)
34011180:	4604      	mov	r4, r0
34011182:	2800      	cmp	r0, #0
34011184:	d1f3      	bne.n	3401116e <CMW_IMX335_Probe+0x76>
  if (id != IMX335_CHIP_ID)
34011186:	9b01      	ldr	r3, [sp, #4]
  memset(imx335_if, 0, sizeof(*imx335_if));
34011188:	2248      	movs	r2, #72	@ 0x48
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
3401118a:	2b00      	cmp	r3, #0
3401118c:	bf08      	it	eq
3401118e:	4604      	moveq	r4, r0
  memset(imx335_if, 0, sizeof(*imx335_if));
34011190:	4631      	mov	r1, r6
34011192:	f105 0018 	add.w	r0, r5, #24
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
34011196:	bf18      	it	ne
34011198:	f06f 0406 	mvnne.w	r4, #6
  memset(imx335_if, 0, sizeof(*imx335_if));
3401119c:	f007 fd62 	bl	34018c64 <memset>
  imx335_if->Init = CMW_IMX335_Init;
340111a0:	4b0e      	ldr	r3, [pc, #56]	@ (340111dc <CMW_IMX335_Probe+0xe4>)
340111a2:	602b      	str	r3, [r5, #0]
  imx335_if->Start = CMW_IMX335_Start;
340111a4:	4b0e      	ldr	r3, [pc, #56]	@ (340111e0 <CMW_IMX335_Probe+0xe8>)
340111a6:	60ab      	str	r3, [r5, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
340111a8:	4b0e      	ldr	r3, [pc, #56]	@ (340111e4 <CMW_IMX335_Probe+0xec>)
340111aa:	606b      	str	r3, [r5, #4]
  imx335_if->Run = CMW_IMX335_Run;
340111ac:	4b0e      	ldr	r3, [pc, #56]	@ (340111e8 <CMW_IMX335_Probe+0xf0>)
340111ae:	60eb      	str	r3, [r5, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
340111b0:	4b0e      	ldr	r3, [pc, #56]	@ (340111ec <CMW_IMX335_Probe+0xf4>)
340111b2:	612b      	str	r3, [r5, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
340111b4:	4b0e      	ldr	r3, [pc, #56]	@ (340111f0 <CMW_IMX335_Probe+0xf8>)
340111b6:	616b      	str	r3, [r5, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
340111b8:	4b0e      	ldr	r3, [pc, #56]	@ (340111f4 <CMW_IMX335_Probe+0xfc>)
340111ba:	61eb      	str	r3, [r5, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
340111bc:	4b0e      	ldr	r3, [pc, #56]	@ (340111f8 <CMW_IMX335_Probe+0x100>)
340111be:	64ab      	str	r3, [r5, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
340111c0:	4b0e      	ldr	r3, [pc, #56]	@ (340111fc <CMW_IMX335_Probe+0x104>)
340111c2:	64eb      	str	r3, [r5, #76]	@ 0x4c
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
340111c4:	4b0e      	ldr	r3, [pc, #56]	@ (34011200 <CMW_IMX335_Probe+0x108>)
340111c6:	642b      	str	r3, [r5, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
340111c8:	4b0e      	ldr	r3, [pc, #56]	@ (34011204 <CMW_IMX335_Probe+0x10c>)
340111ca:	646b      	str	r3, [r5, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
340111cc:	4b0e      	ldr	r3, [pc, #56]	@ (34011208 <CMW_IMX335_Probe+0x110>)
340111ce:	62eb      	str	r3, [r5, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
340111d0:	4b0e      	ldr	r3, [pc, #56]	@ (3401120c <CMW_IMX335_Probe+0x114>)
340111d2:	65ab      	str	r3, [r5, #88]	@ 0x58
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
340111d4:	4b0e      	ldr	r3, [pc, #56]	@ (34011210 <CMW_IMX335_Probe+0x118>)
340111d6:	65eb      	str	r3, [r5, #92]	@ 0x5c
  return ret;
340111d8:	e7cb      	b.n	34011172 <CMW_IMX335_Probe+0x7a>
340111da:	bf00      	nop
340111dc:	34011085 	.word	0x34011085
340111e0:	34011031 	.word	0x34011031
340111e4:	34011011 	.word	0x34011011
340111e8:	34010ffd 	.word	0x34010ffd
340111ec:	340110c1 	.word	0x340110c1
340111f0:	34010f85 	.word	0x34010f85
340111f4:	34010f87 	.word	0x34010f87
340111f8:	34010ff7 	.word	0x34010ff7
340111fc:	34010ff1 	.word	0x34010ff1
34011200:	34010feb 	.word	0x34010feb
34011204:	34010fe5 	.word	0x34010fe5
34011208:	34010fd9 	.word	0x34010fd9
3401120c:	34010f95 	.word	0x34010f95
34011210:	34010f8d 	.word	0x34010f8d

34011214 <CMW_VD55G1_Read32>:
static int CMW_VD55G1_Read32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t *value)
{
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011214:	2304      	movs	r3, #4
{
34011216:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011218:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3401121a:	f8d0 5080 	ldr.w	r5, [r0, #128]	@ 0x80
3401121e:	eb0d 0203 	add.w	r2, sp, r3
34011222:	8800      	ldrh	r0, [r0, #0]
34011224:	47a8      	blx	r5
  if (ret)
34011226:	b908      	cbnz	r0, 3401122c <CMW_VD55G1_Read32+0x18>
    return ret;

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
34011228:	9b01      	ldr	r3, [sp, #4]
3401122a:	6023      	str	r3, [r4, #0]

  return 0;
}
3401122c:	b003      	add	sp, #12
3401122e:	bd30      	pop	{r4, r5, pc}

34011230 <VD55G1_ShutdownPin>:

static void VD55G1_ShutdownPin(struct VD55G1_Ctx *ctx, int value)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  p_ctx->ShutdownPin(value);
34011230:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
34011234:	4608      	mov	r0, r1
34011236:	4718      	bx	r3

34011238 <VD55G1_Read8>:
}

static int VD55G1_Read8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *value)
{
34011238:	b410      	push	{r4}
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3401123a:	6f84      	ldr	r4, [r0, #120]	@ 0x78
3401123c:	2301      	movs	r3, #1
3401123e:	46a4      	mov	ip, r4
34011240:	f830 0c08 	ldrh.w	r0, [r0, #-8]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read8(p_ctx, addr, value);
}
34011244:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011248:	4760      	bx	ip

3401124a <VD55G1_Read16>:

static int VD55G1_Read16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t *value)
{
3401124a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401124c:	2302      	movs	r3, #2
{
3401124e:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
34011250:	6f85      	ldr	r5, [r0, #120]	@ 0x78
34011252:	aa01      	add	r2, sp, #4
34011254:	f830 0c08 	ldrh.w	r0, [r0, #-8]
34011258:	47a8      	blx	r5
  if (ret)
3401125a:	b910      	cbnz	r0, 34011262 <VD55G1_Read16+0x18>
  *value = (data[1] << 8) | data[0];
3401125c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
34011260:	8023      	strh	r3, [r4, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read16(p_ctx, addr, value);
}
34011262:	b003      	add	sp, #12
34011264:	bd30      	pop	{r4, r5, pc}

34011266 <VD55G1_Read32>:

static int VD55G1_Read32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t *value)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Read32(p_ctx, addr, value);
34011266:	3808      	subs	r0, #8
34011268:	f7ff bfd4 	b.w	34011214 <CMW_VD55G1_Read32>

3401126c <VD55G1_Write8>:
}

static int VD55G1_Write8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t value)
{
3401126c:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3401126e:	2301      	movs	r3, #1
34011270:	6f44      	ldr	r4, [r0, #116]	@ 0x74
34011272:	f88d 2007 	strb.w	r2, [sp, #7]
34011276:	f830 0c08 	ldrh.w	r0, [r0, #-8]
3401127a:	f10d 0207 	add.w	r2, sp, #7
3401127e:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write8(p_ctx, addr, value);
}
34011280:	b002      	add	sp, #8
34011282:	bd10      	pop	{r4, pc}

34011284 <VD55G1_Write16>:

static int VD55G1_Write16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t value)
{
34011284:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
34011286:	2302      	movs	r3, #2
34011288:	6f44      	ldr	r4, [r0, #116]	@ 0x74
3401128a:	f8ad 2006 	strh.w	r2, [sp, #6]
3401128e:	f830 0c08 	ldrh.w	r0, [r0, #-8]
34011292:	f10d 0206 	add.w	r2, sp, #6
34011296:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write16(p_ctx, addr, value);
}
34011298:	b002      	add	sp, #8
3401129a:	bd10      	pop	{r4, pc}

3401129c <VD55G1_Write32>:
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
3401129c:	2304      	movs	r3, #4

static int VD55G1_Write32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t value)
{
3401129e:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340112a0:	6f44      	ldr	r4, [r0, #116]	@ 0x74
340112a2:	9201      	str	r2, [sp, #4]
340112a4:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340112a8:	eb0d 0203 	add.w	r2, sp, r3
340112ac:	47a0      	blx	r4
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  return CMW_VD55G1_Write32(p_ctx, addr, value);
}
340112ae:	b002      	add	sp, #8
340112b0:	bd10      	pop	{r4, pc}

340112b2 <VD55G1_WriteArray>:

static int VD55G1_WriteArray(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
340112b2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340112b6:	4680      	mov	r8, r0
340112b8:	460d      	mov	r5, r1
340112ba:	4616      	mov	r6, r2
340112bc:	461c      	mov	r4, r3
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
  const unsigned int chunk_size = 128;
  uint16_t sz;
  int ret;

  while (data_len) {
340112be:	b914      	cbnz	r4, 340112c6 <VD55G1_WriteArray+0x14>
    data_len -= sz;
    addr += sz;
    data += sz;
  }

  return 0;
340112c0:	4620      	mov	r0, r4
}
340112c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sz = MIN(data_len, chunk_size);
340112c6:	2c80      	cmp	r4, #128	@ 0x80
340112c8:	46a1      	mov	r9, r4
340112ca:	bf28      	it	cs
340112cc:	f04f 0980 	movcs.w	r9, #128	@ 0x80
340112d0:	fa1f fa89 	uxth.w	sl, r9
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
340112d4:	4653      	mov	r3, sl
340112d6:	4632      	mov	r2, r6
340112d8:	4629      	mov	r1, r5
340112da:	f8d8 7074 	ldr.w	r7, [r8, #116]	@ 0x74
340112de:	f838 0c08 	ldrh.w	r0, [r8, #-8]
340112e2:	47b8      	blx	r7
    if (ret)
340112e4:	2800      	cmp	r0, #0
340112e6:	d1ec      	bne.n	340112c2 <VD55G1_WriteArray+0x10>
    addr += sz;
340112e8:	44aa      	add	sl, r5
    data_len -= sz;
340112ea:	eba4 0409 	sub.w	r4, r4, r9
    addr += sz;
340112ee:	fa1f f58a 	uxth.w	r5, sl
    data += sz;
340112f2:	444e      	add	r6, r9
340112f4:	e7e3      	b.n	340112be <VD55G1_WriteArray+0xc>

340112f6 <VD55G1_Delay>:

static void VD55G1_Delay(struct VD55G1_Ctx *ctx, uint32_t delay_in_ms)
{
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);

  p_ctx->Delay(delay_in_ms);
340112f6:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
340112fa:	4608      	mov	r0, r1
340112fc:	4718      	bx	r3

340112fe <VD55G1_Log>:
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
340112fe:	4770      	bx	lr

34011300 <CMW_VD55G1_GetSensorInfo>:
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
static int32_t CMW_VD55G1_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
  if ((io_ctx ==  NULL) || (info == NULL))
34011300:	b140      	cbz	r0, 34011314 <CMW_VD55G1_GetSensorInfo+0x14>
34011302:	b139      	cbz	r1, 34011314 <CMW_VD55G1_GetSensorInfo+0x14>
    return CMW_ERROR_WRONG_PARAM;
  }

  /* Return the default full resolution */
  info->width = VD55G1_MAX_WIDTH;
  info->height = VD55G1_MAX_HEIGHT;
34011304:	f44f 7249 	mov.w	r2, #804	@ 0x324
34011308:	f44f 7330 	mov.w	r3, #704	@ 0x2c0

  return CMW_ERROR_NONE;
3401130c:	2000      	movs	r0, #0
  info->height = VD55G1_MAX_HEIGHT;
3401130e:	e9c1 2309 	strd	r2, r3, [r1, #36]	@ 0x24
  return CMW_ERROR_NONE;
34011312:	4770      	bx	lr
    return CMW_ERROR_WRONG_PARAM;
34011314:	f06f 0001 	mvn.w	r0, #1
}
34011318:	4770      	bx	lr

3401131a <CMW_VD55G1_MirrorFlipConfig>:

static int32_t CMW_VD55G1_MirrorFlipConfig(void *io_ctx, uint32_t Config)
{
  int32_t ret = CMW_ERROR_NONE;

  switch (Config) {
3401131a:	2903      	cmp	r1, #3
3401131c:	d80d      	bhi.n	3401133a <CMW_VD55G1_MirrorFlipConfig+0x20>
3401131e:	e8df f001 	tbb	[pc, r1]
34011322:	0602      	.short	0x0602
34011324:	0a08      	.short	0x0a08
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP_NONE);
34011326:	2100      	movs	r1, #0
      break;
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
      break;
    case CMW_MIRRORFLIP_FLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
34011328:	3008      	adds	r0, #8
3401132a:	f001 bbd4 	b.w	34012ad6 <VD55G1_SetFlipMirrorMode>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_FLIP);
3401132e:	2101      	movs	r1, #1
34011330:	e7fa      	b.n	34011328 <CMW_VD55G1_MirrorFlipConfig+0xe>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
34011332:	2102      	movs	r1, #2
34011334:	e7f8      	b.n	34011328 <CMW_VD55G1_MirrorFlipConfig+0xe>
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
34011336:	2103      	movs	r1, #3
34011338:	e7f6      	b.n	34011328 <CMW_VD55G1_MirrorFlipConfig+0xe>
    default:
      ret = CMW_ERROR_PERIPH_FAILURE;
  }

  return ret;
}
3401133a:	f06f 0003 	mvn.w	r0, #3
3401133e:	4770      	bx	lr

34011340 <CMW_VD55G1_Stop>:
{
34011340:	b508      	push	{r3, lr}
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011342:	3008      	adds	r0, #8
34011344:	f001 fbc0 	bl	34012ac8 <VD55G1_Stop>
    return CMW_ERROR_PERIPH_FAILURE;
34011348:	2800      	cmp	r0, #0
}
3401134a:	bf18      	it	ne
3401134c:	f06f 0003 	mvnne.w	r0, #3
34011350:	bd08      	pop	{r3, pc}

34011352 <CMW_VD55G1_Start>:
{
34011352:	b510      	push	{r4, lr}
  ret = VD55G1_Start(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011354:	f100 0408 	add.w	r4, r0, #8
34011358:	4620      	mov	r0, r4
3401135a:	f001 f929 	bl	340125b0 <VD55G1_Start>
  if (ret) {
3401135e:	b120      	cbz	r0, 3401136a <CMW_VD55G1_Start+0x18>
    VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011360:	4620      	mov	r0, r4
34011362:	f001 f911 	bl	34012588 <VD55G1_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
34011366:	f06f 0003 	mvn.w	r0, #3
}
3401136a:	bd10      	pop	{r4, pc}

3401136c <CMW_VD55G1_DeInit>:
{
3401136c:	b538      	push	{r3, r4, r5, lr}
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3401136e:	f100 0508 	add.w	r5, r0, #8
{
34011372:	4604      	mov	r4, r0
  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011374:	4628      	mov	r0, r5
34011376:	f001 fba7 	bl	34012ac8 <VD55G1_Stop>
  if (ret)
3401137a:	b110      	cbz	r0, 34011382 <CMW_VD55G1_DeInit+0x16>
    return CMW_ERROR_PERIPH_FAILURE;
3401137c:	f06f 0003 	mvn.w	r0, #3
}
34011380:	bd38      	pop	{r3, r4, r5, pc}
  ret = VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
34011382:	4628      	mov	r0, r5
34011384:	f001 f900 	bl	34012588 <VD55G1_DeInit>
  if (ret)
34011388:	2800      	cmp	r0, #0
3401138a:	d1f7      	bne.n	3401137c <CMW_VD55G1_DeInit+0x10>
  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 0;
3401138c:	f884 0070 	strb.w	r0, [r4, #112]	@ 0x70
  return CMW_ERROR_NONE;
34011390:	e7f6      	b.n	34011380 <CMW_VD55G1_DeInit+0x14>
	...

34011394 <CMW_VD55G1_Init>:
{
34011394:	b530      	push	{r4, r5, lr}
34011396:	4604      	mov	r4, r0
34011398:	b08f      	sub	sp, #60	@ 0x3c
3401139a:	460d      	mov	r5, r1
  VD55G1_Config_t config = { 0 };
3401139c:	2234      	movs	r2, #52	@ 0x34
3401139e:	2100      	movs	r1, #0
340113a0:	a801      	add	r0, sp, #4
340113a2:	f007 fc5f 	bl	34018c64 <memset>
  if (((CMW_VD55G1_t *)io_ctx)->IsInitialized)
340113a6:	f894 3070 	ldrb.w	r3, [r4, #112]	@ 0x70
340113aa:	bb63      	cbnz	r3, 34011406 <CMW_VD55G1_Init+0x72>
  config.frame_rate = initSensor->fps;
340113ac:	68ab      	ldr	r3, [r5, #8]
340113ae:	9303      	str	r3, [sp, #12]
  ret = CMW_VD55G1_GetResType(initSensor->width, initSensor->height, &config.resolution);
340113b0:	e9d5 2300 	ldrd	r2, r3, [r5]
  if (width == 320 && height == 240)
340113b4:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
340113b8:	d104      	bne.n	340113c4 <CMW_VD55G1_Init+0x30>
340113ba:	2bf0      	cmp	r3, #240	@ 0xf0
340113bc:	d00b      	beq.n	340113d6 <CMW_VD55G1_Init+0x42>
    return CMW_ERROR_WRONG_PARAM;
340113be:	f06f 0001 	mvn.w	r0, #1
340113c2:	e021      	b.n	34011408 <CMW_VD55G1_Init+0x74>
  else if (width == 640 && height == 480)
340113c4:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
340113c8:	d120      	bne.n	3401140c <CMW_VD55G1_Init+0x78>
340113ca:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
340113ce:	d1f6      	bne.n	340113be <CMW_VD55G1_Init+0x2a>
    *res = VD55G1_RES_VGA_640_480;
340113d0:	2301      	movs	r3, #1
      *res = VD55G1_RES_FULL_804_704;
340113d2:	f88d 3008 	strb.w	r3, [sp, #8]
  config.ext_clock_freq_in_hz = ((CMW_VD55G1_t *)io_ctx)->ClockInHz;
340113d6:	6863      	ldr	r3, [r4, #4]
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
340113d8:	a901      	add	r1, sp, #4
  config.ext_clock_freq_in_hz = ((CMW_VD55G1_t *)io_ctx)->ClockInHz;
340113da:	9301      	str	r3, [sp, #4]
  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
340113dc:	692b      	ldr	r3, [r5, #16]
  config.out_itf.clock_lane_swap_enable = 1;
340113de:	2501      	movs	r5, #1
  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
340113e0:	2b03      	cmp	r3, #3
340113e2:	bf28      	it	cs
340113e4:	2303      	movcs	r3, #3
340113e6:	f88d 3010 	strb.w	r3, [sp, #16]
  config.out_itf.clock_lane_swap_enable = 1;
340113ea:	4b12      	ldr	r3, [pc, #72]	@ (34011434 <CMW_VD55G1_Init+0xa0>)
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
340113ec:	f104 0008 	add.w	r0, r4, #8
  config.out_itf.clock_lane_swap_enable = 1;
340113f0:	e9cd 3505 	strd	r3, r5, [sp, #20]
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
340113f4:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
  config.out_itf.data_lane_swap_enable = 1;
340113f8:	9507      	str	r5, [sp, #28]
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
340113fa:	930d      	str	r3, [sp, #52]	@ 0x34
  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
340113fc:	f000 ffc0 	bl	34012380 <VD55G1_Init>
  if (ret)
34011400:	b9a0      	cbnz	r0, 3401142c <CMW_VD55G1_Init+0x98>
  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 1;
34011402:	f884 5070 	strb.w	r5, [r4, #112]	@ 0x70
    return CMW_ERROR_NONE;
34011406:	2000      	movs	r0, #0
}
34011408:	b00f      	add	sp, #60	@ 0x3c
3401140a:	bd30      	pop	{r4, r5, pc}
  else if (width == 800 && height == 600)
3401140c:	f5b2 7f48 	cmp.w	r2, #800	@ 0x320
34011410:	d104      	bne.n	3401141c <CMW_VD55G1_Init+0x88>
34011412:	f5b3 7f16 	cmp.w	r3, #600	@ 0x258
34011416:	d1d2      	bne.n	340113be <CMW_VD55G1_Init+0x2a>
    *res = VD55G1_RES_SXGA_800_600;
34011418:	2302      	movs	r3, #2
3401141a:	e7da      	b.n	340113d2 <CMW_VD55G1_Init+0x3e>
  else if (width == 804 && height == 704)
3401141c:	f5b2 7f49 	cmp.w	r2, #804	@ 0x324
34011420:	d1cd      	bne.n	340113be <CMW_VD55G1_Init+0x2a>
34011422:	f5b3 7f30 	cmp.w	r3, #704	@ 0x2c0
34011426:	d1ca      	bne.n	340113be <CMW_VD55G1_Init+0x2a>
      *res = VD55G1_RES_FULL_804_704;
34011428:	2303      	movs	r3, #3
3401142a:	e7d2      	b.n	340113d2 <CMW_VD55G1_Init+0x3e>
    return CMW_ERROR_PERIPH_FAILURE;
3401142c:	f06f 0003 	mvn.w	r0, #3
34011430:	e7ea      	b.n	34011408 <CMW_VD55G1_Init+0x74>
34011432:	bf00      	nop
34011434:	2fec1100 	.word	0x2fec1100

34011438 <CMW_VD55G1_Probe>:
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
}

int CMW_VD55G1_Probe(CMW_VD55G1_t *io_ctx, CMW_Sensor_if_t *vd55g1_if)
{
34011438:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401143a:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
3401143c:	4b26      	ldr	r3, [pc, #152]	@ (340114d8 <CMW_VD55G1_Probe+0xa0>)
{
3401143e:	460d      	mov	r5, r1
  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
34011440:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.read8 = VD55G1_Read8;
34011442:	4b26      	ldr	r3, [pc, #152]	@ (340114dc <CMW_VD55G1_Probe+0xa4>)
34011444:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.read16 = VD55G1_Read16;
34011446:	4b26      	ldr	r3, [pc, #152]	@ (340114e0 <CMW_VD55G1_Probe+0xa8>)
34011448:	6103      	str	r3, [r0, #16]
  io_ctx->ctx_driver.read32 = VD55G1_Read32;
3401144a:	4b26      	ldr	r3, [pc, #152]	@ (340114e4 <CMW_VD55G1_Probe+0xac>)
3401144c:	6143      	str	r3, [r0, #20]
  io_ctx->ctx_driver.write8 = VD55G1_Write8;
3401144e:	4b26      	ldr	r3, [pc, #152]	@ (340114e8 <CMW_VD55G1_Probe+0xb0>)
34011450:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.write16 = VD55G1_Write16;
34011452:	4b26      	ldr	r3, [pc, #152]	@ (340114ec <CMW_VD55G1_Probe+0xb4>)
34011454:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.write32 = VD55G1_Write32;
34011456:	4b26      	ldr	r3, [pc, #152]	@ (340114f0 <CMW_VD55G1_Probe+0xb8>)
34011458:	6203      	str	r3, [r0, #32]
  io_ctx->ctx_driver.write_array = VD55G1_WriteArray;
3401145a:	4b26      	ldr	r3, [pc, #152]	@ (340114f4 <CMW_VD55G1_Probe+0xbc>)
3401145c:	6243      	str	r3, [r0, #36]	@ 0x24
  io_ctx->ctx_driver.delay = VD55G1_Delay;
3401145e:	4b26      	ldr	r3, [pc, #152]	@ (340114f8 <CMW_VD55G1_Probe+0xc0>)
34011460:	6283      	str	r3, [r0, #40]	@ 0x28
  io_ctx->ctx_driver.log = VD55G1_Log;
34011462:	4b26      	ldr	r3, [pc, #152]	@ (340114fc <CMW_VD55G1_Probe+0xc4>)
34011464:	62c3      	str	r3, [r0, #44]	@ 0x2c
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34011466:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
3401146a:	2000      	movs	r0, #0
3401146c:	4798      	blx	r3
  io_ctx->Delay(200); /* NRST signals asserted during 200ms */
3401146e:	20c8      	movs	r0, #200	@ 0xc8
34011470:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
34011474:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34011476:	2001      	movs	r0, #1
34011478:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
3401147c:	4798      	blx	r3
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
3401147e:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
34011482:	2014      	movs	r0, #20
34011484:	4798      	blx	r3
  if (!io_ctx->Init)
34011486:	6f63      	ldr	r3, [r4, #116]	@ 0x74
34011488:	b923      	cbnz	r3, 34011494 <CMW_VD55G1_Probe+0x5c>
  CMW_VD55G1_PowerOn(io_ctx);

  ret = VD55G1_RegisterBusIO(io_ctx);
  if (ret != CMW_ERROR_NONE)
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401148a:	f06f 0404 	mvn.w	r4, #4
  vd55g1_if->Start = CMW_VD55G1_Start;
  vd55g1_if->Stop = CMW_VD55G1_Stop;
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
  return ret;
}
3401148e:	4620      	mov	r0, r4
34011490:	b003      	add	sp, #12
34011492:	bd30      	pop	{r4, r5, pc}
  ret = io_ctx->Init();
34011494:	4798      	blx	r3
  if (ret != CMW_ERROR_NONE)
34011496:	4601      	mov	r1, r0
34011498:	2800      	cmp	r0, #0
3401149a:	d1f6      	bne.n	3401148a <CMW_VD55G1_Probe+0x52>
  ret = CMW_VD55G1_Read32(io_ctx, VD55G1_REG_MODEL_ID, &reg32);
3401149c:	4620      	mov	r0, r4
3401149e:	aa01      	add	r2, sp, #4
340114a0:	f7ff feb8 	bl	34011214 <CMW_VD55G1_Read32>
  if (ret)
340114a4:	4604      	mov	r4, r0
340114a6:	2800      	cmp	r0, #0
340114a8:	d1ef      	bne.n	3401148a <CMW_VD55G1_Probe+0x52>
  if (id != VD55G1_CHIP_ID)
340114aa:	9a01      	ldr	r2, [sp, #4]
340114ac:	4b14      	ldr	r3, [pc, #80]	@ (34011500 <CMW_VD55G1_Probe+0xc8>)
340114ae:	429a      	cmp	r2, r3
340114b0:	d1eb      	bne.n	3401148a <CMW_VD55G1_Probe+0x52>
  memset(vd55g1_if, 0, sizeof(*vd55g1_if));
340114b2:	4601      	mov	r1, r0
340114b4:	2254      	movs	r2, #84	@ 0x54
340114b6:	f105 000c 	add.w	r0, r5, #12
340114ba:	f007 fbd3 	bl	34018c64 <memset>
  vd55g1_if->Init = CMW_VD55G1_Init;
340114be:	4b11      	ldr	r3, [pc, #68]	@ (34011504 <CMW_VD55G1_Probe+0xcc>)
340114c0:	602b      	str	r3, [r5, #0]
  vd55g1_if->DeInit = CMW_VD55G1_DeInit;
340114c2:	4b11      	ldr	r3, [pc, #68]	@ (34011508 <CMW_VD55G1_Probe+0xd0>)
340114c4:	606b      	str	r3, [r5, #4]
  vd55g1_if->Start = CMW_VD55G1_Start;
340114c6:	4b11      	ldr	r3, [pc, #68]	@ (3401150c <CMW_VD55G1_Probe+0xd4>)
340114c8:	60ab      	str	r3, [r5, #8]
  vd55g1_if->Stop = CMW_VD55G1_Stop;
340114ca:	4b11      	ldr	r3, [pc, #68]	@ (34011510 <CMW_VD55G1_Probe+0xd8>)
340114cc:	61ab      	str	r3, [r5, #24]
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
340114ce:	4b11      	ldr	r3, [pc, #68]	@ (34011514 <CMW_VD55G1_Probe+0xdc>)
340114d0:	62eb      	str	r3, [r5, #44]	@ 0x2c
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
340114d2:	4b11      	ldr	r3, [pc, #68]	@ (34011518 <CMW_VD55G1_Probe+0xe0>)
340114d4:	65ab      	str	r3, [r5, #88]	@ 0x58
  return ret;
340114d6:	e7da      	b.n	3401148e <CMW_VD55G1_Probe+0x56>
340114d8:	34011231 	.word	0x34011231
340114dc:	34011239 	.word	0x34011239
340114e0:	3401124b 	.word	0x3401124b
340114e4:	34011267 	.word	0x34011267
340114e8:	3401126d 	.word	0x3401126d
340114ec:	34011285 	.word	0x34011285
340114f0:	3401129d 	.word	0x3401129d
340114f4:	340112b3 	.word	0x340112b3
340114f8:	340112f7 	.word	0x340112f7
340114fc:	340112ff 	.word	0x340112ff
34011500:	53354731 	.word	0x53354731
34011504:	34011395 	.word	0x34011395
34011508:	3401136d 	.word	0x3401136d
3401150c:	34011353 	.word	0x34011353
34011510:	34011341 	.word	0x34011341
34011514:	3401131b 	.word	0x3401131b
34011518:	34011301 	.word	0x34011301

3401151c <CMW_VD66GY_Read16>:
{
  return pObj->ReadReg(pObj->Address, addr, value, 1);
}

static int CMW_VD66GY_Read16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t *value)
{
3401151c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3401151e:	2302      	movs	r3, #2
{
34011520:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
34011522:	f8d0 5130 	ldr.w	r5, [r0, #304]	@ 0x130
34011526:	aa01      	add	r2, sp, #4
34011528:	8800      	ldrh	r0, [r0, #0]
3401152a:	47a8      	blx	r5
  if (ret)
3401152c:	b910      	cbnz	r0, 34011534 <CMW_VD66GY_Read16+0x18>
    return ret;

  *value = (data[1] << 8) | data[0];
3401152e:	f8bd 3004 	ldrh.w	r3, [sp, #4]
34011532:	8023      	strh	r3, [r4, #0]

  return CMW_ERROR_NONE;
}
34011534:	b003      	add	sp, #12
34011536:	bd30      	pop	{r4, r5, pc}

34011538 <VD6G_ShutdownPin>:

static void VD6G_ShutdownPin(struct VD6G_Ctx *ctx, int value)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  p_ctx->ShutdownPin(value);
34011538:	f8d0 3134 	ldr.w	r3, [r0, #308]	@ 0x134
3401153c:	4608      	mov	r0, r1
3401153e:	4718      	bx	r3

34011540 <VD6G_Read8>:
}

static int VD6G_Read8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *value)
{
34011540:	b410      	push	{r4}
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011542:	f8d0 4128 	ldr.w	r4, [r0, #296]	@ 0x128
34011546:	2301      	movs	r3, #1
34011548:	46a4      	mov	ip, r4
3401154a:	f830 0c08 	ldrh.w	r0, [r0, #-8]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read8(p_ctx, addr, value);
}
3401154e:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->ReadReg(pObj->Address, addr, value, 1);
34011552:	4760      	bx	ip

34011554 <VD6G_Read16>:

static int VD6G_Read16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t *value)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read16(p_ctx, addr, value);
34011554:	3808      	subs	r0, #8
34011556:	f7ff bfe1 	b.w	3401151c <CMW_VD66GY_Read16>

3401155a <VD6G_Read32>:
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3401155a:	2304      	movs	r3, #4
}

static int VD6G_Read32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t *value)
{
3401155c:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401155e:	4614      	mov	r4, r2
  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
34011560:	f8d0 5128 	ldr.w	r5, [r0, #296]	@ 0x128
34011564:	eb0d 0203 	add.w	r2, sp, r3
34011568:	f830 0c08 	ldrh.w	r0, [r0, #-8]
3401156c:	47a8      	blx	r5
  if (ret)
3401156e:	b908      	cbnz	r0, 34011574 <VD6G_Read32+0x1a>
  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
34011570:	9b01      	ldr	r3, [sp, #4]
34011572:	6023      	str	r3, [r4, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Read32(p_ctx, addr, value);
}
34011574:	b003      	add	sp, #12
34011576:	bd30      	pop	{r4, r5, pc}

34011578 <VD6G_Write8>:

static int VD6G_Write8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t value)
{
34011578:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3401157a:	2301      	movs	r3, #1
3401157c:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
34011580:	f88d 2007 	strb.w	r2, [sp, #7]
34011584:	f830 0c08 	ldrh.w	r0, [r0, #-8]
34011588:	f10d 0207 	add.w	r2, sp, #7
3401158c:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write8(p_ctx, addr, value);
}
3401158e:	b002      	add	sp, #8
34011590:	bd10      	pop	{r4, pc}

34011592 <VD6G_Write16>:

static int VD6G_Write16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t value)
{
34011592:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
34011594:	2302      	movs	r3, #2
34011596:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
3401159a:	f8ad 2006 	strh.w	r2, [sp, #6]
3401159e:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340115a2:	f10d 0206 	add.w	r2, sp, #6
340115a6:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write16(p_ctx, addr, value);
}
340115a8:	b002      	add	sp, #8
340115aa:	bd10      	pop	{r4, pc}

340115ac <VD6G_Write32>:
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340115ac:	2304      	movs	r3, #4

static int VD6G_Write32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t value)
{
340115ae:	b513      	push	{r0, r1, r4, lr}
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
340115b0:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
340115b4:	9201      	str	r2, [sp, #4]
340115b6:	f830 0c08 	ldrh.w	r0, [r0, #-8]
340115ba:	eb0d 0203 	add.w	r2, sp, r3
340115be:	47a0      	blx	r4
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  return CMW_VD66GY_Write32(p_ctx, addr, value);
}
340115c0:	b002      	add	sp, #8
340115c2:	bd10      	pop	{r4, pc}

340115c4 <VD6G_WriteArray>:

static int VD6G_WriteArray(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
340115c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340115c8:	4680      	mov	r8, r0
340115ca:	460d      	mov	r5, r1
340115cc:	4616      	mov	r6, r2
340115ce:	461c      	mov	r4, r3
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
  const unsigned int chunk_size = 128;
  uint16_t sz;
  int ret;

  while (data_len) {
340115d0:	b914      	cbnz	r4, 340115d8 <VD6G_WriteArray+0x14>
    data_len -= sz;
    addr += sz;
    data += sz;
  }

  return 0;
340115d2:	4620      	mov	r0, r4
}
340115d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    sz = MIN(data_len, chunk_size);
340115d8:	2c80      	cmp	r4, #128	@ 0x80
340115da:	46a1      	mov	r9, r4
340115dc:	bf28      	it	cs
340115de:	f04f 0980 	movcs.w	r9, #128	@ 0x80
340115e2:	fa1f fa89 	uxth.w	sl, r9
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
340115e6:	4653      	mov	r3, sl
340115e8:	4632      	mov	r2, r6
340115ea:	4629      	mov	r1, r5
340115ec:	f8d8 7124 	ldr.w	r7, [r8, #292]	@ 0x124
340115f0:	f838 0c08 	ldrh.w	r0, [r8, #-8]
340115f4:	47b8      	blx	r7
    if (ret)
340115f6:	2800      	cmp	r0, #0
340115f8:	d1ec      	bne.n	340115d4 <VD6G_WriteArray+0x10>
    addr += sz;
340115fa:	44aa      	add	sl, r5
    data_len -= sz;
340115fc:	eba4 0409 	sub.w	r4, r4, r9
    addr += sz;
34011600:	fa1f f58a 	uxth.w	r5, sl
    data += sz;
34011604:	444e      	add	r6, r9
34011606:	e7e3      	b.n	340115d0 <VD6G_WriteArray+0xc>

34011608 <VD6G_Delay>:

static void VD6G_Delay(struct VD6G_Ctx *ctx, uint32_t delay_in_ms)
{
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);

  p_ctx->Delay(delay_in_ms);
34011608:	f8d0 3130 	ldr.w	r3, [r0, #304]	@ 0x130
3401160c:	4608      	mov	r0, r1
3401160e:	4718      	bx	r3

34011610 <VD6G_Log>:
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
34011610:	4770      	bx	lr

34011612 <CMW_VD66GY_FrameEventCallback>:
#endif
}

static void CMW_VD66GY_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
}
34011612:	4770      	bx	lr
34011614:	0000      	movs	r0, r0
	...

34011618 <CMW_VD66GY_SetGain>:
{
34011618:	b5f0      	push	{r4, r5, r6, r7, lr}
3401161a:	ed2d 8b08 	vpush	{d8-d11}
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3401161e:	f100 0608 	add.w	r6, r0, #8
{
34011622:	b085      	sub	sp, #20
34011624:	460d      	mov	r5, r1
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
34011626:	4630      	mov	r0, r6
34011628:	f10d 020b 	add.w	r2, sp, #11
3401162c:	f10d 010a 	add.w	r1, sp, #10
34011630:	f002 f858 	bl	340136e4 <VD6G_GetAnalogGainRegRange>
  if (ret)
34011634:	2800      	cmp	r0, #0
34011636:	f040 80bc 	bne.w	340117b2 <CMW_VD66GY_SetGain+0x19a>
  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
3401163a:	4630      	mov	r0, r6
3401163c:	f10d 020e 	add.w	r2, sp, #14
34011640:	a903      	add	r1, sp, #12
34011642:	f002 f8bb 	bl	340137bc <VD6G_GetDigitalGainRegRange>
  if (ret)
34011646:	2800      	cmp	r0, #0
34011648:	f040 80b3 	bne.w	340117b2 <CMW_VD66GY_SetGain+0x19a>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401164c:	2420      	movs	r4, #32
3401164e:	f89d 300a 	ldrb.w	r3, [sp, #10]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011652:	eeb3 ab04 	vmov.f64	d10, #52	@ 0x41a00000  20.0
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011656:	f1c3 0320 	rsb	r3, r3, #32
3401165a:	fb94 f3f3 	sdiv	r3, r4, r3
3401165e:	ee00 3a10 	vmov	s0, r3
34011662:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
34011666:	f009 fbab 	bl	3401adc0 <log10>
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401166a:	f89d 300b 	ldrb.w	r3, [sp, #11]
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3401166e:	eeb0 8b40 	vmov.f64	d8, d0
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
34011672:	1ae3      	subs	r3, r4, r3
34011674:	fb94 f3f3 	sdiv	r3, r4, r3
34011678:	ee00 3a10 	vmov	s0, r3
3401167c:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
34011680:	f009 fb9e 	bl	3401adc0 <log10>
34011684:	ed9f bb58 	vldr	d11, [pc, #352]	@ 340117e8 <CMW_VD66GY_SetGain+0x1d0>
34011688:	ee20 0b0a 	vmul.f64	d0, d0, d10
3401168c:	ee20 0b0b 	vmul.f64	d0, d0, d11
34011690:	eefc 7bc0 	vcvt.u32.f64	s15, d0
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011694:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34011698:	f89d 200c 	ldrb.w	r2, [sp, #12]
3401169c:	0a1b      	lsrs	r3, r3, #8
3401169e:	ee00 3a10 	vmov	s0, r3
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340116a2:	ee17 7a90 	vmov	r7, s15
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340116a6:	ee07 2a90 	vmov	s15, r2
340116aa:	ed9f 9a55 	vldr	s18, [pc, #340]	@ 34011800 <CMW_VD66GY_SetGain+0x1e8>
340116ae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340116b2:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
340116b6:	eea7 0a89 	vfma.f32	s0, s15, s18
340116ba:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340116be:	f009 fb7f 	bl	3401adc0 <log10>
340116c2:	ee20 0b0a 	vmul.f64	d0, d0, d10
340116c6:	ee20 0b0b 	vmul.f64	d0, d0, d11
340116ca:	eefc 7bc0 	vcvt.u32.f64	s15, d0
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340116ce:	f8bd 300e 	ldrh.w	r3, [sp, #14]
340116d2:	f89d 200e 	ldrb.w	r2, [sp, #14]
340116d6:	0a1b      	lsrs	r3, r3, #8
340116d8:	ee00 3a10 	vmov	s0, r3
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340116dc:	ee17 4a90 	vmov	r4, s15
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340116e0:	ee07 2a90 	vmov	s15, r2
340116e4:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
340116e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340116ec:	eea7 0a89 	vfma.f32	s0, s15, s18
340116f0:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340116f4:	f009 fb64 	bl	3401adc0 <log10>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340116f8:	ee28 8b0a 	vmul.f64	d8, d8, d10
340116fc:	ee28 8b0b 	vmul.f64	d8, d8, d11
34011700:	eebc 8bc8 	vcvt.u32.f64	s16, d8
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011704:	ee20 0b0a 	vmul.f64	d0, d0, d10
  if ((gain < dgain_min_mdB + again_min_mdB)
34011708:	ee18 3a10 	vmov	r3, s16
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3401170c:	ee20 0b0b 	vmul.f64	d0, d0, d11
  if ((gain < dgain_min_mdB + again_min_mdB)
34011710:	4423      	add	r3, r4
34011712:	42ab      	cmp	r3, r5
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011714:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  if ((gain < dgain_min_mdB + again_min_mdB)
34011718:	d861      	bhi.n	340117de <CMW_VD66GY_SetGain+0x1c6>
      || (gain > dgain_max_mdB + again_max_mdB))
3401171a:	ee10 3a10 	vmov	r3, s0
3401171e:	443b      	add	r3, r7
34011720:	429d      	cmp	r5, r3
34011722:	d85c      	bhi.n	340117de <CMW_VD66GY_SetGain+0x1c6>
  if (gain <= again_max_mdB)
34011724:	42bd      	cmp	r5, r7
34011726:	d848      	bhi.n	340117ba <CMW_VD66GY_SetGain+0x1a2>
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
34011728:	1b2d      	subs	r5, r5, r4
3401172a:	ee07 5a90 	vmov	s15, r5
3401172e:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34011732:	ee87 1b0b 	vdiv.f64	d1, d7, d11
34011736:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3401173a:	ee81 1b0a 	vdiv.f64	d1, d1, d10
3401173e:	f009 fc47 	bl	3401afd0 <pow>
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)dgain_min_mdB);
34011742:	ee07 4a90 	vmov	s15, r4
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
34011746:	eeb0 9b40 	vmov.f64	d9, d0
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
3401174a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401174e:	ee87 1b0b 	vdiv.f64	d1, d7, d11
34011752:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
34011756:	ee81 1b0a 	vdiv.f64	d1, d1, d10
3401175a:	f009 fc39 	bl	3401afd0 <pow>
  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
3401175e:	ed9f 7b24 	vldr	d7, [pc, #144]	@ 340117f0 <CMW_VD66GY_SetGain+0x1d8>
34011762:	ee87 6b09 	vdiv.f64	d6, d7, d9
34011766:	ee37 7b46 	vsub.f64	d7, d7, d6
3401176a:	eefd 7bc7 	vcvt.s32.f64	s15, d7
3401176e:	4630      	mov	r0, r6
34011770:	ee17 1a90 	vmov	r1, s15
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
34011774:	eeb0 8b40 	vmov.f64	d8, d0
  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
34011778:	f001 fff0 	bl	3401375c <VD6G_SetAnalogGain>
  if (ret)
3401177c:	b9c8      	cbnz	r0, 340117b2 <CMW_VD66GY_SetGain+0x19a>
  ret = VD6G_SetDigitalGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, FLOAT_TO_FP58(digital_linear_gain));
3401177e:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34011782:	ee17 3a90 	vmov	r3, s15
34011786:	b299      	uxth	r1, r3
34011788:	ee07 1a90 	vmov	s15, r1
3401178c:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34011790:	ee38 8b47 	vsub.f64	d8, d8, d7
34011794:	ed9f 7b18 	vldr	d7, [pc, #96]	@ 340117f8 <CMW_VD66GY_SetGain+0x1e0>
34011798:	ee28 8b07 	vmul.f64	d8, d8, d7
3401179c:	eefc 7bc8 	vcvt.u32.f64	s15, d8
340117a0:	edcd 7a01 	vstr	s15, [sp, #4]
340117a4:	f89d 3004 	ldrb.w	r3, [sp, #4]
340117a8:	4630      	mov	r0, r6
340117aa:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
340117ae:	f002 f833 	bl	34013818 <VD6G_SetDigitalGain>
}
340117b2:	b005      	add	sp, #20
340117b4:	ecbd 8b08 	vpop	{d8-d11}
340117b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
340117ba:	ee07 7a90 	vmov	s15, r7
340117be:	eeb8 7b67 	vcvt.f64.u32	d7, s15
340117c2:	ee87 1b0b 	vdiv.f64	d1, d7, d11
340117c6:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
340117ca:	ee81 1b0a 	vdiv.f64	d1, d1, d10
340117ce:	f009 fbff 	bl	3401afd0 <pow>
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
340117d2:	1bed      	subs	r5, r5, r7
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
340117d4:	eeb0 9b40 	vmov.f64	d9, d0
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
340117d8:	ee07 5a90 	vmov	s15, r5
340117dc:	e7b5      	b.n	3401174a <CMW_VD66GY_SetGain+0x132>
    return -1;
340117de:	f04f 30ff 	mov.w	r0, #4294967295
340117e2:	e7e6      	b.n	340117b2 <CMW_VD66GY_SetGain+0x19a>
340117e4:	f3af 8000 	nop.w
340117e8:	00000000 	.word	0x00000000
340117ec:	408f4000 	.word	0x408f4000
340117f0:	00000000 	.word	0x00000000
340117f4:	40400000 	.word	0x40400000
340117f8:	00000000 	.word	0x00000000
340117fc:	40700000 	.word	0x40700000
34011800:	3b800000 	.word	0x3b800000

34011804 <CMW_VD66GY_SetExposure>:
  return VD6G_SetExposureTime(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, exposure);
34011804:	3008      	adds	r0, #8
34011806:	f002 b8a9 	b.w	3401395c <VD6G_SetExposureTime>

3401180a <CMW_VD66GY_SetExposureMode>:
  switch (mode)
3401180a:	2901      	cmp	r1, #1
{
3401180c:	b508      	push	{r3, lr}
3401180e:	f100 0008 	add.w	r0, r0, #8
  switch (mode)
34011812:	d002      	beq.n	3401181a <CMW_VD66GY_SetExposureMode+0x10>
34011814:	2902      	cmp	r1, #2
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_AUTO);
34011816:	bf18      	it	ne
34011818:	2100      	movne	r1, #0
3401181a:	f001 ff59 	bl	340136d0 <VD6G_SetExposureMode>
  return (ret == 0) ? CMW_ERROR_NONE : CMW_ERROR_UNKNOWN_FAILURE;
3401181e:	2800      	cmp	r0, #0
}
34011820:	bf18      	it	ne
34011822:	f06f 0005 	mvnne.w	r0, #5
34011826:	bd08      	pop	{r3, pc}

34011828 <CMW_VD66GY_GetSensorInfo>:
{
34011828:	b570      	push	{r4, r5, r6, lr}
3401182a:	ed2d 8b08 	vpush	{d8-d11}
3401182e:	460c      	mov	r4, r1
  if ((!io_ctx) || (info == NULL))
34011830:	4605      	mov	r5, r0
{
34011832:	b082      	sub	sp, #8
  if ((!io_ctx) || (info == NULL))
34011834:	2800      	cmp	r0, #0
34011836:	f000 80a0 	beq.w	3401197a <CMW_VD66GY_GetSensorInfo+0x152>
3401183a:	2900      	cmp	r1, #0
3401183c:	f000 809d 	beq.w	3401197a <CMW_VD66GY_GetSensorInfo+0x152>
    strcpy(info->name, VD66GY_NAME);
34011840:	4951      	ldr	r1, [pc, #324]	@ (34011988 <CMW_VD66GY_GetSensorInfo+0x160>)
34011842:	4620      	mov	r0, r4
34011844:	f007 fc8f 	bl	34019166 <strcpy>
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
34011848:	f895 3030 	ldrb.w	r3, [r5, #48]	@ 0x30
  info->height = VD6G_MAX_HEIGHT;
3401184c:	f44f 628c 	mov.w	r2, #1120	@ 0x460
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
34011850:	3b01      	subs	r3, #1
34011852:	f884 3020 	strb.w	r3, [r4, #32]
  info->color_depth = VD6G_COLOR_DEPTH_RAW8;
34011856:	2308      	movs	r3, #8
34011858:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  info->height = VD6G_MAX_HEIGHT;
3401185c:	f240 5354 	movw	r3, #1364	@ 0x554
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
34011860:	3508      	adds	r5, #8
  info->height = VD6G_MAX_HEIGHT;
34011862:	e9c4 2309 	strd	r2, r3, [r4, #36]	@ 0x24
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
34011866:	4628      	mov	r0, r5
34011868:	f10d 0203 	add.w	r2, sp, #3
3401186c:	f10d 0102 	add.w	r1, sp, #2
34011870:	f001 ff38 	bl	340136e4 <VD6G_GetAnalogGainRegRange>
  if (ret)
34011874:	2800      	cmp	r0, #0
34011876:	d17c      	bne.n	34011972 <CMW_VD66GY_GetSensorInfo+0x14a>
  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
34011878:	4628      	mov	r0, r5
3401187a:	f10d 0206 	add.w	r2, sp, #6
3401187e:	a901      	add	r1, sp, #4
34011880:	f001 ff9c 	bl	340137bc <VD6G_GetDigitalGainRegRange>
  if (ret)
34011884:	2800      	cmp	r0, #0
34011886:	d174      	bne.n	34011972 <CMW_VD66GY_GetSensorInfo+0x14a>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011888:	2620      	movs	r6, #32
3401188a:	f89d 3002 	ldrb.w	r3, [sp, #2]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3401188e:	ed9f ba3f 	vldr	s22, [pc, #252]	@ 3401198c <CMW_VD66GY_GetSensorInfo+0x164>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011892:	f1c3 0320 	rsb	r3, r3, #32
34011896:	fb96 f3f3 	sdiv	r3, r6, r3
3401189a:	ee00 3a10 	vmov	s0, r3
3401189e:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
340118a2:	f009 fa8d 	bl	3401adc0 <log10>
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340118a6:	f89d 3003 	ldrb.w	r3, [sp, #3]
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
340118aa:	eeb0 9b40 	vmov.f64	d9, d0
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340118ae:	1af3      	subs	r3, r6, r3
340118b0:	fb96 f3f3 	sdiv	r3, r6, r3
340118b4:	ee00 3a10 	vmov	s0, r3
340118b8:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
340118bc:	f009 fa80 	bl	3401adc0 <log10>
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340118c0:	f8bd 3004 	ldrh.w	r3, [sp, #4]
340118c4:	f89d 2004 	ldrb.w	r2, [sp, #4]
340118c8:	0a1b      	lsrs	r3, r3, #8
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
340118ca:	eeb0 8b40 	vmov.f64	d8, d0
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340118ce:	ee07 2a90 	vmov	s15, r2
340118d2:	ee00 3a10 	vmov	s0, r3
340118d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340118da:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
340118de:	eea7 0a8b 	vfma.f32	s0, s15, s22
340118e2:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
340118e6:	f009 fa6b 	bl	3401adc0 <log10>
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340118ea:	f8bd 3006 	ldrh.w	r3, [sp, #6]
340118ee:	f89d 2006 	ldrb.w	r2, [sp, #6]
340118f2:	0a1b      	lsrs	r3, r3, #8
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
340118f4:	eeb0 ab40 	vmov.f64	d10, d0
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
340118f8:	ee07 2a90 	vmov	s15, r2
340118fc:	ee00 3a10 	vmov	s0, r3
34011900:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34011904:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
34011908:	eea7 0a8b 	vfma.f32	s0, s15, s22
3401190c:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34011910:	f009 fa56 	bl	3401adc0 <log10>
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011914:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
34011918:	ed9f 6b19 	vldr	d6, [pc, #100]	@ 34011980 <CMW_VD66GY_GetSensorInfo+0x158>
3401191c:	ee29 9b07 	vmul.f64	d9, d9, d7
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011920:	ee2a ab07 	vmul.f64	d10, d10, d7
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011924:	ee29 9b06 	vmul.f64	d9, d9, d6
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011928:	ee2a ab06 	vmul.f64	d10, d10, d6
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401192c:	ee28 8b07 	vmul.f64	d8, d8, d7
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011930:	ee20 0b07 	vmul.f64	d0, d0, d7
  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
34011934:	eebc 9bc9 	vcvt.u32.f64	s18, d9
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
34011938:	eebc abca 	vcvt.u32.f64	s20, d10
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401193c:	ee28 8b06 	vmul.f64	d8, d8, d6
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011940:	ee20 0b06 	vmul.f64	d0, d0, d6
  info->gain_min = again_min_mdB + dgain_min_mdB;
34011944:	ee1a 2a10 	vmov	r2, s20
34011948:	ee19 3a10 	vmov	r3, s18
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3401194c:	eebc 8bc8 	vcvt.u32.f64	s16, d8
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
34011950:	eebc 0bc0 	vcvt.u32.f64	s0, d0
  info->gain_min = again_min_mdB + dgain_min_mdB;
34011954:	4413      	add	r3, r2
34011956:	62e3      	str	r3, [r4, #44]	@ 0x2c
  info->gain_max = again_max_mdB + dgain_max_mdB;
34011958:	ee10 2a10 	vmov	r2, s0
3401195c:	ee18 3a10 	vmov	r3, s16
34011960:	4413      	add	r3, r2
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
34011962:	4628      	mov	r0, r5
  info->gain_max = again_max_mdB + dgain_max_mdB;
34011964:	6323      	str	r3, [r4, #48]	@ 0x30
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
34011966:	f104 0238 	add.w	r2, r4, #56	@ 0x38
3401196a:	f104 0134 	add.w	r1, r4, #52	@ 0x34
3401196e:	f001 ffa9 	bl	340138c4 <VD6G_GetExposureRegRange>
}
34011972:	b002      	add	sp, #8
34011974:	ecbd 8b08 	vpop	{d8-d11}
34011978:	bd70      	pop	{r4, r5, r6, pc}
    return CMW_ERROR_WRONG_PARAM;
3401197a:	f06f 0001 	mvn.w	r0, #1
3401197e:	e7f8      	b.n	34011972 <CMW_VD66GY_GetSensorInfo+0x14a>
34011980:	00000000 	.word	0x00000000
34011984:	408f4000 	.word	0x408f4000
34011988:	3401ca01 	.word	0x3401ca01
3401198c:	3b800000 	.word	0x3b800000

34011990 <CMW_VD66GY_Stop>:
{
34011990:	b508      	push	{r3, lr}
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011992:	3008      	adds	r0, #8
34011994:	f001 fe6a 	bl	3401366c <VD6G_Stop>
    return CMW_ERROR_PERIPH_FAILURE;
34011998:	2800      	cmp	r0, #0
}
3401199a:	bf18      	it	ne
3401199c:	f06f 0003 	mvnne.w	r0, #3
340119a0:	bd08      	pop	{r3, pc}
	...

340119a4 <CMW_VD66GY_Start>:
{
340119a4:	b530      	push	{r4, r5, lr}
340119a6:	b087      	sub	sp, #28
  ISP_StatAreaTypeDef isp_stat_area = {0};
340119a8:	ab02      	add	r3, sp, #8
{
340119aa:	4604      	mov	r4, r0
  ISP_StatAreaTypeDef isp_stat_area = {0};
340119ac:	2210      	movs	r2, #16
340119ae:	2100      	movs	r1, #0
340119b0:	4618      	mov	r0, r3
340119b2:	f007 f957 	bl	34018c64 <memset>
  ret = ISP_Init(&((CMW_VD66GY_t *)io_ctx)->hIsp, ((CMW_VD66GY_t *)io_ctx)->hdcmipp, 0, &((CMW_VD66GY_t *)io_ctx)->appliHelpers, &isp_stat_area, &ISP_IQParamCacheInit_VD66GY);
340119b6:	4a10      	ldr	r2, [pc, #64]	@ (340119f8 <CMW_VD66GY_Start+0x54>)
340119b8:	f104 0570 	add.w	r5, r4, #112	@ 0x70
340119bc:	e9cd 0200 	strd	r0, r2, [sp]
340119c0:	f104 03f8 	add.w	r3, r4, #248	@ 0xf8
340119c4:	2200      	movs	r2, #0
340119c6:	4628      	mov	r0, r5
340119c8:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
340119cc:	f002 fbf8 	bl	340141c0 <ISP_Init>
  if (ret != ISP_OK)
340119d0:	b978      	cbnz	r0, 340119f2 <CMW_VD66GY_Start+0x4e>
  ret = ISP_Start(&((CMW_VD66GY_t *)io_ctx)->hIsp);
340119d2:	4628      	mov	r0, r5
340119d4:	f002 fc90 	bl	340142f8 <ISP_Start>
  if (ret != ISP_OK)
340119d8:	b938      	cbnz	r0, 340119ea <CMW_VD66GY_Start+0x46>
  ret = VD6G_Start(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340119da:	3408      	adds	r4, #8
340119dc:	4620      	mov	r0, r4
340119de:	f001 fd01 	bl	340133e4 <VD6G_Start>
  if (ret) {
340119e2:	b120      	cbz	r0, 340119ee <CMW_VD66GY_Start+0x4a>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340119e4:	4620      	mov	r0, r4
340119e6:	f001 fced 	bl	340133c4 <VD6G_DeInit>
      return CMW_ERROR_PERIPH_FAILURE;
340119ea:	f06f 0003 	mvn.w	r0, #3
}
340119ee:	b007      	add	sp, #28
340119f0:	bd30      	pop	{r4, r5, pc}
    return CMW_ERROR_COMPONENT_FAILURE;
340119f2:	f06f 0004 	mvn.w	r0, #4
340119f6:	e7fa      	b.n	340119ee <CMW_VD66GY_Start+0x4a>
340119f8:	340352b8 	.word	0x340352b8

340119fc <CMW_VD66GY_DeInit>:
{
340119fc:	b538      	push	{r3, r4, r5, lr}
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
340119fe:	f100 0508 	add.w	r5, r0, #8
{
34011a02:	4604      	mov	r4, r0
  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011a04:	4628      	mov	r0, r5
34011a06:	f001 fe31 	bl	3401366c <VD6G_Stop>
  if (ret)
34011a0a:	b110      	cbz	r0, 34011a12 <CMW_VD66GY_DeInit+0x16>
    return CMW_ERROR_PERIPH_FAILURE;
34011a0c:	f06f 0003 	mvn.w	r0, #3
}
34011a10:	bd38      	pop	{r3, r4, r5, pc}
  ret = VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011a12:	4628      	mov	r0, r5
34011a14:	f001 fcd6 	bl	340133c4 <VD6G_DeInit>
  if (ret)
34011a18:	2800      	cmp	r0, #0
34011a1a:	d1f7      	bne.n	34011a0c <CMW_VD66GY_DeInit+0x10>
  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 0;
34011a1c:	f884 0120 	strb.w	r0, [r4, #288]	@ 0x120
  return CMW_ERROR_NONE;
34011a20:	e7f6      	b.n	34011a10 <CMW_VD66GY_DeInit+0x14>

34011a22 <CMW_VD66GY_Run>:
{
34011a22:	b508      	push	{r3, lr}
  ret = ISP_BackgroundProcess(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011a24:	3070      	adds	r0, #112	@ 0x70
34011a26:	f002 fd0f 	bl	34014448 <ISP_BackgroundProcess>
  return CMW_ERROR_NONE;
34011a2a:	2800      	cmp	r0, #0
}
34011a2c:	bf14      	ite	ne
34011a2e:	f06f 0003 	mvnne.w	r0, #3
34011a32:	2000      	moveq	r0, #0
34011a34:	bd08      	pop	{r3, pc}

34011a36 <CMW_VD66GY_Init>:
{
34011a36:	b570      	push	{r4, r5, r6, lr}
34011a38:	4604      	mov	r4, r0
34011a3a:	b08e      	sub	sp, #56	@ 0x38
34011a3c:	460d      	mov	r5, r1
  VD6G_Config_t config = { 0 };
34011a3e:	2238      	movs	r2, #56	@ 0x38
34011a40:	2100      	movs	r1, #0
34011a42:	4668      	mov	r0, sp
34011a44:	f007 f90e 	bl	34018c64 <memset>
  if (((CMW_VD66GY_t *)io_ctx)->IsInitialized)
34011a48:	f894 3120 	ldrb.w	r3, [r4, #288]	@ 0x120
34011a4c:	2b00      	cmp	r3, #0
34011a4e:	d14f      	bne.n	34011af0 <CMW_VD66GY_Init+0xba>
  config.frame_rate = initSensor->fps;
34011a50:	68ab      	ldr	r3, [r5, #8]
34011a52:	9302      	str	r3, [sp, #8]
  ret = CMW_VD66GY_GetResType(initSensor->width, initSensor->height, &config.resolution);
34011a54:	e9d5 2300 	ldrd	r2, r3, [r5]
  if (width == 320 && height == 240)
34011a58:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
34011a5c:	d104      	bne.n	34011a68 <CMW_VD66GY_Init+0x32>
34011a5e:	2bf0      	cmp	r3, #240	@ 0xf0
34011a60:	d00b      	beq.n	34011a7a <CMW_VD66GY_Init+0x44>
    return CMW_ERROR_WRONG_PARAM;
34011a62:	f06f 0001 	mvn.w	r0, #1
34011a66:	e029      	b.n	34011abc <CMW_VD66GY_Init+0x86>
  else if (width == 640 && height == 480)
34011a68:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
34011a6c:	d128      	bne.n	34011ac0 <CMW_VD66GY_Init+0x8a>
34011a6e:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34011a72:	d1f6      	bne.n	34011a62 <CMW_VD66GY_Init+0x2c>
    *res = VD6G_RES_VGA_640_480;
34011a74:	2301      	movs	r3, #1
    *res = VD6G_RES_FULL_1120_1364;
34011a76:	f88d 3004 	strb.w	r3, [sp, #4]
  config.ext_clock_freq_in_hz = ((CMW_VD66GY_t *)io_ctx)->ClockInHz;
34011a7a:	6863      	ldr	r3, [r4, #4]
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
34011a7c:	f104 0608 	add.w	r6, r4, #8
  config.ext_clock_freq_in_hz = ((CMW_VD66GY_t *)io_ctx)->ClockInHz;
34011a80:	9300      	str	r3, [sp, #0]
  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
34011a82:	692b      	ldr	r3, [r5, #16]
  config.out_itf.clock_lane_swap_enable = 1;
34011a84:	2501      	movs	r5, #1
  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
34011a86:	2b03      	cmp	r3, #3
34011a88:	bf28      	it	cs
34011a8a:	2303      	movcs	r3, #3
34011a8c:	f88d 300c 	strb.w	r3, [sp, #12]
  config.out_itf.clock_lane_swap_enable = 1;
34011a90:	2302      	movs	r3, #2
34011a92:	e9cd 3506 	strd	r3, r5, [sp, #24]
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
34011a96:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
34011a9a:	4669      	mov	r1, sp
34011a9c:	4630      	mov	r0, r6
  config.out_itf.data_lane1_swap_enable = 1;
34011a9e:	e9cd 5508 	strd	r5, r5, [sp, #32]
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
34011aa2:	e9cd 330b 	strd	r3, r3, [sp, #44]	@ 0x2c
  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
34011aa6:	f001 f97d 	bl	34012da4 <VD6G_Init>
  if (ret)
34011aaa:	b928      	cbnz	r0, 34011ab8 <CMW_VD66GY_Init+0x82>
  if (((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer == VD6G_BAYER_NONE)
34011aac:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
34011ab0:	b9e3      	cbnz	r3, 34011aec <CMW_VD66GY_Init+0xb6>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
34011ab2:	4630      	mov	r0, r6
34011ab4:	f001 fc86 	bl	340133c4 <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
34011ab8:	f06f 0003 	mvn.w	r0, #3
}
34011abc:	b00e      	add	sp, #56	@ 0x38
34011abe:	bd70      	pop	{r4, r5, r6, pc}
  else if (width == 1024 && height == 768)
34011ac0:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
34011ac4:	d104      	bne.n	34011ad0 <CMW_VD66GY_Init+0x9a>
34011ac6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34011aca:	d1ca      	bne.n	34011a62 <CMW_VD66GY_Init+0x2c>
    *res = VD6G_RES_XGA_1024_768;
34011acc:	2303      	movs	r3, #3
34011ace:	e7d2      	b.n	34011a76 <CMW_VD66GY_Init+0x40>
  else if (width == 1120 && height == 720)
34011ad0:	f5b2 6f8c 	cmp.w	r2, #1120	@ 0x460
34011ad4:	d1c5      	bne.n	34011a62 <CMW_VD66GY_Init+0x2c>
34011ad6:	f5b3 7f34 	cmp.w	r3, #720	@ 0x2d0
34011ada:	d101      	bne.n	34011ae0 <CMW_VD66GY_Init+0xaa>
    *res = VD6G_RES_PORTRAIT_1120_720;
34011adc:	2307      	movs	r3, #7
34011ade:	e7ca      	b.n	34011a76 <CMW_VD66GY_Init+0x40>
  else if (width == 1120 && height == 1364)
34011ae0:	f240 5254 	movw	r2, #1364	@ 0x554
34011ae4:	4293      	cmp	r3, r2
34011ae6:	d1bc      	bne.n	34011a62 <CMW_VD66GY_Init+0x2c>
    *res = VD6G_RES_FULL_1120_1364;
34011ae8:	2308      	movs	r3, #8
34011aea:	e7c4      	b.n	34011a76 <CMW_VD66GY_Init+0x40>
  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 1;
34011aec:	f884 5120 	strb.w	r5, [r4, #288]	@ 0x120
    return CMW_ERROR_NONE;
34011af0:	2000      	movs	r0, #0
34011af2:	e7e3      	b.n	34011abc <CMW_VD66GY_Init+0x86>

34011af4 <CMW_VD66GY_VsyncEventCallback>:
  switch (pipe)
34011af4:	2901      	cmp	r1, #1
{
34011af6:	b510      	push	{r4, lr}
  switch (pipe)
34011af8:	d007      	beq.n	34011b0a <CMW_VD66GY_VsyncEventCallback+0x16>
34011afa:	2902      	cmp	r1, #2
34011afc:	d00f      	beq.n	34011b1e <CMW_VD66GY_VsyncEventCallback+0x2a>
34011afe:	b999      	cbnz	r1, 34011b28 <CMW_VD66GY_VsyncEventCallback+0x34>
}
34011b00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncDumpFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011b04:	3070      	adds	r0, #112	@ 0x70
34011b06:	f002 bcb5 	b.w	34014474 <ISP_IncDumpFrameId>
      ISP_IncMainFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011b0a:	f100 0470 	add.w	r4, r0, #112	@ 0x70
34011b0e:	4620      	mov	r0, r4
34011b10:	f002 fcac 	bl	3401446c <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011b14:	4620      	mov	r0, r4
}
34011b16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011b1a:	f002 bca5 	b.w	34014468 <ISP_GatherStatistics>
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011b1e:	3070      	adds	r0, #112	@ 0x70
}
34011b20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
34011b24:	f002 bca4 	b.w	34014470 <ISP_IncAncillaryFrameId>
}
34011b28:	bd10      	pop	{r4, pc}

34011b2a <VD66GY_RegisterBusIO>:

int32_t VD66GY_RegisterBusIO(CMW_VD66GY_t *io_ctx)
{
  int ret;

  if (!io_ctx)
34011b2a:	b118      	cbz	r0, 34011b34 <VD66GY_RegisterBusIO+0xa>
    return CMW_ERROR_COMPONENT_FAILURE;

  if (!io_ctx->Init)
34011b2c:	f8d0 3124 	ldr.w	r3, [r0, #292]	@ 0x124
34011b30:	b103      	cbz	r3, 34011b34 <VD66GY_RegisterBusIO+0xa>
    return CMW_ERROR_COMPONENT_FAILURE;

  ret = io_ctx->Init();
34011b32:	4718      	bx	r3

  return ret;
}
34011b34:	f06f 0004 	mvn.w	r0, #4
34011b38:	4770      	bx	lr

34011b3a <VD66GY_ReadID>:

int32_t VD66GY_ReadID(CMW_VD66GY_t *io_ctx, uint32_t *Id)
{
34011b3a:	b513      	push	{r0, r1, r4, lr}
34011b3c:	460c      	mov	r4, r1
  uint16_t reg16;
  int32_t ret;

  ret = CMW_VD66GY_Read16(io_ctx, VD66GY_REG_MODEL_ID, &reg16);
34011b3e:	f10d 0206 	add.w	r2, sp, #6
34011b42:	2100      	movs	r1, #0
34011b44:	f7ff fcea 	bl	3401151c <CMW_VD66GY_Read16>
  if (ret)
34011b48:	b910      	cbnz	r0, 34011b50 <VD66GY_ReadID+0x16>
    return ret;

  *Id = reg16;
34011b4a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
34011b4e:	6023      	str	r3, [r4, #0]

  return CMW_ERROR_NONE;
}
34011b50:	b002      	add	sp, #8
34011b52:	bd10      	pop	{r4, pc}

34011b54 <CMW_VD66GY_Probe>:
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
}

int CMW_VD66GY_Probe(CMW_VD66GY_t *io_ctx, CMW_Sensor_if_t *vd6g_if)
{
34011b54:	b537      	push	{r0, r1, r2, r4, r5, lr}
34011b56:	4604      	mov	r4, r0
  int ret = CMW_ERROR_NONE;
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
34011b58:	4b2c      	ldr	r3, [pc, #176]	@ (34011c0c <CMW_VD66GY_Probe+0xb8>)
{
34011b5a:	460d      	mov	r5, r1
  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
34011b5c:	6083      	str	r3, [r0, #8]
  io_ctx->ctx_driver.read8 = VD6G_Read8;
34011b5e:	4b2c      	ldr	r3, [pc, #176]	@ (34011c10 <CMW_VD66GY_Probe+0xbc>)
34011b60:	60c3      	str	r3, [r0, #12]
  io_ctx->ctx_driver.read16 =VD6G_Read16;
34011b62:	4b2c      	ldr	r3, [pc, #176]	@ (34011c14 <CMW_VD66GY_Probe+0xc0>)
34011b64:	6103      	str	r3, [r0, #16]
  io_ctx->ctx_driver.read32 = VD6G_Read32;
34011b66:	4b2c      	ldr	r3, [pc, #176]	@ (34011c18 <CMW_VD66GY_Probe+0xc4>)
34011b68:	6143      	str	r3, [r0, #20]
  io_ctx->ctx_driver.write8 = VD6G_Write8;
34011b6a:	4b2c      	ldr	r3, [pc, #176]	@ (34011c1c <CMW_VD66GY_Probe+0xc8>)
34011b6c:	6183      	str	r3, [r0, #24]
  io_ctx->ctx_driver.write16 = VD6G_Write16;
34011b6e:	4b2c      	ldr	r3, [pc, #176]	@ (34011c20 <CMW_VD66GY_Probe+0xcc>)
34011b70:	61c3      	str	r3, [r0, #28]
  io_ctx->ctx_driver.write32 = VD6G_Write32;
34011b72:	4b2c      	ldr	r3, [pc, #176]	@ (34011c24 <CMW_VD66GY_Probe+0xd0>)
34011b74:	6203      	str	r3, [r0, #32]
  io_ctx->ctx_driver.write_array = VD6G_WriteArray;
34011b76:	4b2c      	ldr	r3, [pc, #176]	@ (34011c28 <CMW_VD66GY_Probe+0xd4>)
34011b78:	6243      	str	r3, [r0, #36]	@ 0x24
  io_ctx->ctx_driver.delay = VD6G_Delay;
34011b7a:	4b2c      	ldr	r3, [pc, #176]	@ (34011c2c <CMW_VD66GY_Probe+0xd8>)
34011b7c:	6283      	str	r3, [r0, #40]	@ 0x28
  io_ctx->ctx_driver.log = VD6G_Log;
34011b7e:	4b2c      	ldr	r3, [pc, #176]	@ (34011c30 <CMW_VD66GY_Probe+0xdc>)
34011b80:	62c3      	str	r3, [r0, #44]	@ 0x2c
  io_ctx->EnablePin(1);
34011b82:	f8d0 3140 	ldr.w	r3, [r0, #320]	@ 0x140
34011b86:	2001      	movs	r0, #1
34011b88:	4798      	blx	r3
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
34011b8a:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
34011b8e:	2000      	movs	r0, #0
34011b90:	4798      	blx	r3
  HAL_Delay(200);   /* NRST signals asserted during 200ms */
34011b92:	20c8      	movs	r0, #200	@ 0xc8
34011b94:	f7f2 feb2 	bl	340048fc <HAL_Delay>
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
34011b98:	2001      	movs	r0, #1
34011b9a:	f8d4 313c 	ldr.w	r3, [r4, #316]	@ 0x13c
34011b9e:	4798      	blx	r3
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
34011ba0:	2014      	movs	r0, #20
34011ba2:	f7f2 feab 	bl	340048fc <HAL_Delay>

  CMW_VD66GY_PowerOn(io_ctx);

  ret = VD66GY_RegisterBusIO(io_ctx);
34011ba6:	4620      	mov	r0, r4
34011ba8:	f7ff ffbf 	bl	34011b2a <VD66GY_RegisterBusIO>
  if (ret != CMW_ERROR_NONE)
34011bac:	b120      	cbz	r0, 34011bb8 <CMW_VD66GY_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
34011bae:	f06f 0404 	mvn.w	r4, #4
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
  return ret;
}
34011bb2:	4620      	mov	r0, r4
34011bb4:	b003      	add	sp, #12
34011bb6:	bd30      	pop	{r4, r5, pc}
  ret = VD66GY_ReadID(io_ctx, &id);
34011bb8:	4620      	mov	r0, r4
34011bba:	a901      	add	r1, sp, #4
34011bbc:	f7ff ffbd 	bl	34011b3a <VD66GY_ReadID>
  if (ret != CMW_ERROR_NONE)
34011bc0:	4604      	mov	r4, r0
34011bc2:	2800      	cmp	r0, #0
34011bc4:	d1f3      	bne.n	34011bae <CMW_VD66GY_Probe+0x5a>
  if (id != VD66GY_CHIP_ID)
34011bc6:	f245 6303 	movw	r3, #22019	@ 0x5603
34011bca:	9a01      	ldr	r2, [sp, #4]
34011bcc:	429a      	cmp	r2, r3
34011bce:	d1ee      	bne.n	34011bae <CMW_VD66GY_Probe+0x5a>
  memset(vd6g_if, 0, sizeof(*vd6g_if));
34011bd0:	4601      	mov	r1, r0
34011bd2:	2244      	movs	r2, #68	@ 0x44
34011bd4:	f105 001c 	add.w	r0, r5, #28
34011bd8:	f007 f844 	bl	34018c64 <memset>
  vd6g_if->Init = CMW_VD66GY_Init;
34011bdc:	4b15      	ldr	r3, [pc, #84]	@ (34011c34 <CMW_VD66GY_Probe+0xe0>)
34011bde:	602b      	str	r3, [r5, #0]
  vd6g_if->DeInit = CMW_VD66GY_DeInit;
34011be0:	4b15      	ldr	r3, [pc, #84]	@ (34011c38 <CMW_VD66GY_Probe+0xe4>)
34011be2:	606b      	str	r3, [r5, #4]
  vd6g_if->Run = CMW_VD66GY_Run;
34011be4:	4b15      	ldr	r3, [pc, #84]	@ (34011c3c <CMW_VD66GY_Probe+0xe8>)
34011be6:	60eb      	str	r3, [r5, #12]
  vd6g_if->VsyncEventCallback = CMW_VD66GY_VsyncEventCallback;
34011be8:	4b15      	ldr	r3, [pc, #84]	@ (34011c40 <CMW_VD66GY_Probe+0xec>)
34011bea:	612b      	str	r3, [r5, #16]
  vd6g_if->FrameEventCallback = CMW_VD66GY_FrameEventCallback;
34011bec:	4b15      	ldr	r3, [pc, #84]	@ (34011c44 <CMW_VD66GY_Probe+0xf0>)
34011bee:	616b      	str	r3, [r5, #20]
  vd6g_if->Start = CMW_VD66GY_Start;
34011bf0:	4b15      	ldr	r3, [pc, #84]	@ (34011c48 <CMW_VD66GY_Probe+0xf4>)
34011bf2:	60ab      	str	r3, [r5, #8]
  vd6g_if->Stop = CMW_VD66GY_Stop;
34011bf4:	4b15      	ldr	r3, [pc, #84]	@ (34011c4c <CMW_VD66GY_Probe+0xf8>)
34011bf6:	61ab      	str	r3, [r5, #24]
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
34011bf8:	4b15      	ldr	r3, [pc, #84]	@ (34011c50 <CMW_VD66GY_Probe+0xfc>)
34011bfa:	64ab      	str	r3, [r5, #72]	@ 0x48
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
34011bfc:	4b15      	ldr	r3, [pc, #84]	@ (34011c54 <CMW_VD66GY_Probe+0x100>)
34011bfe:	64eb      	str	r3, [r5, #76]	@ 0x4c
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
34011c00:	4b15      	ldr	r3, [pc, #84]	@ (34011c58 <CMW_VD66GY_Probe+0x104>)
34011c02:	652b      	str	r3, [r5, #80]	@ 0x50
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
34011c04:	4b15      	ldr	r3, [pc, #84]	@ (34011c5c <CMW_VD66GY_Probe+0x108>)
34011c06:	65ab      	str	r3, [r5, #88]	@ 0x58
  return ret;
34011c08:	e7d3      	b.n	34011bb2 <CMW_VD66GY_Probe+0x5e>
34011c0a:	bf00      	nop
34011c0c:	34011539 	.word	0x34011539
34011c10:	34011541 	.word	0x34011541
34011c14:	34011555 	.word	0x34011555
34011c18:	3401155b 	.word	0x3401155b
34011c1c:	34011579 	.word	0x34011579
34011c20:	34011593 	.word	0x34011593
34011c24:	340115ad 	.word	0x340115ad
34011c28:	340115c5 	.word	0x340115c5
34011c2c:	34011609 	.word	0x34011609
34011c30:	34011611 	.word	0x34011611
34011c34:	34011a37 	.word	0x34011a37
34011c38:	340119fd 	.word	0x340119fd
34011c3c:	34011a23 	.word	0x34011a23
34011c40:	34011af5 	.word	0x34011af5
34011c44:	34011613 	.word	0x34011613
34011c48:	340119a5 	.word	0x340119a5
34011c4c:	34011991 	.word	0x34011991
34011c50:	34011619 	.word	0x34011619
34011c54:	34011805 	.word	0x34011805
34011c58:	3401180b 	.word	0x3401180b
34011c5c:	34011829 	.word	0x34011829

34011c60 <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
34011c60:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
34011c62:	6904      	ldr	r4, [r0, #16]
34011c64:	8900      	ldrh	r0, [r0, #8]
34011c66:	46a4      	mov	ip, r4
}
34011c68:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
34011c6c:	4760      	bx	ip

34011c6e <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
34011c6e:	b410      	push	{r4}
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
34011c70:	68c4      	ldr	r4, [r0, #12]
34011c72:	8900      	ldrh	r0, [r0, #8]
34011c74:	46a4      	mov	ip, r4
}
34011c76:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
34011c7a:	4760      	bx	ip

34011c7c <IMX335_WriteTable>:
{
34011c7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int32_t ret = IMX335_OK;
34011c7e:	2500      	movs	r5, #0
34011c80:	1c8c      	adds	r4, r1, #2
34011c82:	eb04 0682 	add.w	r6, r4, r2, lsl #2
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
34011c86:	f100 0718 	add.w	r7, r0, #24
    if(ret != IMX335_ERROR)
34011c8a:	b135      	cbz	r5, 34011c9a <IMX335_WriteTable+0x1e>
  int32_t ret = IMX335_OK;
34011c8c:	f04f 35ff 	mov.w	r5, #4294967295
  for(index=0; index<size ; index++)
34011c90:	3404      	adds	r4, #4
34011c92:	42b4      	cmp	r4, r6
34011c94:	d1f9      	bne.n	34011c8a <IMX335_WriteTable+0xe>
}
34011c96:	4628      	mov	r0, r5
34011c98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
34011c9a:	2301      	movs	r3, #1
34011c9c:	4622      	mov	r2, r4
34011c9e:	4638      	mov	r0, r7
34011ca0:	f834 1c02 	ldrh.w	r1, [r4, #-2]
34011ca4:	f000 f99d 	bl	34011fe2 <imx335_write_reg>
34011ca8:	2800      	cmp	r0, #0
34011caa:	d1ef      	bne.n	34011c8c <IMX335_WriteTable+0x10>
34011cac:	e7f0      	b.n	34011c90 <IMX335_WriteTable+0x14>
	...

34011cb0 <IMX335_RegisterBusIO>:
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
  int32_t ret;

  if (pObj == NULL)
34011cb0:	b190      	cbz	r0, 34011cd8 <IMX335_RegisterBusIO+0x28>
    ret = IMX335_ERROR;
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
    pObj->IO.DeInit    = pIO->DeInit;
34011cb2:	684a      	ldr	r2, [r1, #4]
    pObj->IO.Init      = pIO->Init;
34011cb4:	680b      	ldr	r3, [r1, #0]
    pObj->IO.DeInit    = pIO->DeInit;
34011cb6:	6042      	str	r2, [r0, #4]
    pObj->IO.Address   = pIO->Address;
34011cb8:	890a      	ldrh	r2, [r1, #8]
    pObj->IO.Init      = pIO->Init;
34011cba:	6003      	str	r3, [r0, #0]
    pObj->IO.Address   = pIO->Address;
34011cbc:	8102      	strh	r2, [r0, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
34011cbe:	68ca      	ldr	r2, [r1, #12]
34011cc0:	60c2      	str	r2, [r0, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
34011cc2:	690a      	ldr	r2, [r1, #16]
34011cc4:	6102      	str	r2, [r0, #16]
    pObj->IO.GetTick   = pIO->GetTick;
34011cc6:	694a      	ldr	r2, [r1, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
    pObj->Ctx.handle   = pObj;
34011cc8:	6200      	str	r0, [r0, #32]
    pObj->IO.GetTick   = pIO->GetTick;
34011cca:	6142      	str	r2, [r0, #20]
    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
34011ccc:	4a04      	ldr	r2, [pc, #16]	@ (34011ce0 <IMX335_RegisterBusIO+0x30>)
34011cce:	61c2      	str	r2, [r0, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
34011cd0:	4a04      	ldr	r2, [pc, #16]	@ (34011ce4 <IMX335_RegisterBusIO+0x34>)
34011cd2:	6182      	str	r2, [r0, #24]

    if(pObj->IO.Init != NULL)
34011cd4:	b103      	cbz	r3, 34011cd8 <IMX335_RegisterBusIO+0x28>
    {
      ret = pObj->IO.Init();
34011cd6:	4718      	bx	r3
      ret = IMX335_ERROR;
    }
  }

  return ret;
}
34011cd8:	f04f 30ff 	mov.w	r0, #4294967295
34011cdc:	4770      	bx	lr
34011cde:	bf00      	nop
34011ce0:	34011c61 	.word	0x34011c61
34011ce4:	34011c6f 	.word	0x34011c6f

34011ce8 <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
34011ce8:	b510      	push	{r4, lr}
  int32_t ret = IMX335_OK;

  if(pObj->IsInitialized == 0U)
34011cea:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
{
34011cee:	4604      	mov	r4, r0
  if(pObj->IsInitialized == 0U)
34011cf0:	b9a3      	cbnz	r3, 34011d1c <IMX335_Init+0x34>
  {
    switch (Resolution)
34011cf2:	2906      	cmp	r1, #6
34011cf4:	d002      	beq.n	34011cfc <IMX335_Init+0x14>
        }
        break;
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
34011cf6:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
34011cfa:	bd10      	pop	{r4, pc}
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
34011cfc:	2254      	movs	r2, #84	@ 0x54
34011cfe:	4908      	ldr	r1, [pc, #32]	@ (34011d20 <IMX335_Init+0x38>)
34011d00:	f7ff ffbc 	bl	34011c7c <IMX335_WriteTable>
34011d04:	2800      	cmp	r0, #0
34011d06:	d1f6      	bne.n	34011cf6 <IMX335_Init+0xe>
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
34011d08:	2205      	movs	r2, #5
34011d0a:	4620      	mov	r0, r4
34011d0c:	4905      	ldr	r1, [pc, #20]	@ (34011d24 <IMX335_Init+0x3c>)
34011d0e:	f7ff ffb5 	bl	34011c7c <IMX335_WriteTable>
34011d12:	2800      	cmp	r0, #0
34011d14:	d1ef      	bne.n	34011cf6 <IMX335_Init+0xe>
        pObj->IsInitialized = 1U;
34011d16:	2301      	movs	r3, #1
34011d18:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
  int32_t ret = IMX335_OK;
34011d1c:	2000      	movs	r0, #0
  return ret;
34011d1e:	e7ec      	b.n	34011cfa <IMX335_Init+0x12>
34011d20:	340356ac 	.word	0x340356ac
34011d24:	34035698 	.word	0x34035698

34011d28 <IMX335_Start>:
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
  uint8_t tmp;
  int32_t ret = IMX335_OK;
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
34011d28:	2300      	movs	r3, #0
{
34011d2a:	b573      	push	{r0, r1, r4, r5, r6, lr}
34011d2c:	4605      	mov	r5, r0
  tmp = IMX335_MODE_STREAMING;
34011d2e:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
34011d32:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
34011d36:	2301      	movs	r3, #1
34011d38:	f10d 0207 	add.w	r2, sp, #7
34011d3c:	3018      	adds	r0, #24
34011d3e:	f000 f950 	bl	34011fe2 <imx335_write_reg>
  if (ret != IMX335_OK)
34011d42:	4604      	mov	r4, r0
34011d44:	b950      	cbnz	r0, 34011d5c <IMX335_Start+0x34>
  tickstart = pObj->IO.GetTick();
34011d46:	696b      	ldr	r3, [r5, #20]
34011d48:	4798      	blx	r3
34011d4a:	4606      	mov	r6, r0
  while((pObj->IO.GetTick() - tickstart) < Delay)
34011d4c:	696b      	ldr	r3, [r5, #20]
34011d4e:	4798      	blx	r3
34011d50:	1b83      	subs	r3, r0, r6
34011d52:	2b13      	cmp	r3, #19
34011d54:	d9fa      	bls.n	34011d4c <IMX335_Start+0x24>
  {
    return IMX335_ERROR;
  }
  IMX335_Delay(pObj, 20);
  return ret;
}
34011d56:	4620      	mov	r0, r4
34011d58:	b002      	add	sp, #8
34011d5a:	bd70      	pop	{r4, r5, r6, pc}
    return IMX335_ERROR;
34011d5c:	f04f 34ff 	mov.w	r4, #4294967295
34011d60:	e7f9      	b.n	34011d56 <IMX335_Start+0x2e>

34011d62 <IMX335_DeInit>:
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
  if(pObj->IsInitialized == 1U)
34011d62:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
34011d66:	2b01      	cmp	r3, #1
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
34011d68:	bf04      	itt	eq
34011d6a:	2300      	moveq	r3, #0
34011d6c:	f880 3024 	strbeq.w	r3, [r0, #36]	@ 0x24
  }

  return IMX335_OK;
}
34011d70:	2000      	movs	r0, #0
34011d72:	4770      	bx	lr

34011d74 <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
34011d74:	b537      	push	{r0, r1, r2, r4, r5, lr}
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
34011d76:	4604      	mov	r4, r0
34011d78:	f854 3b18 	ldr.w	r3, [r4], #24
{
34011d7c:	460d      	mov	r5, r1
  pObj->IO.Init();
34011d7e:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
34011d80:	2301      	movs	r3, #1
34011d82:	f643 1112 	movw	r1, #14610	@ 0x3912
34011d86:	4620      	mov	r0, r4
34011d88:	f10d 0207 	add.w	r2, sp, #7
34011d8c:	f000 f922 	bl	34011fd4 <imx335_read_reg>
34011d90:	b920      	cbnz	r0, 34011d9c <IMX335_ReadID+0x28>
  {
    ret = IMX335_ERROR;
  }
  else
  {
    *Id = tmp;
34011d92:	f89d 3007 	ldrb.w	r3, [sp, #7]
34011d96:	602b      	str	r3, [r5, #0]
    ret = IMX335_OK;
  }

  /* Component status */
  return ret;
}
34011d98:	b003      	add	sp, #12
34011d9a:	bd30      	pop	{r4, r5, pc}
    ret = IMX335_ERROR;
34011d9c:	f04f 30ff 	mov.w	r0, #4294967295
  return ret;
34011da0:	e7fa      	b.n	34011d98 <IMX335_ReadID+0x24>
	...

34011da4 <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
34011da4:	b530      	push	{r4, r5, lr}
  int32_t ret = IMX335_OK;
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
34011da6:	4b1a      	ldr	r3, [pc, #104]	@ (34011e10 <IMX335_SetGain+0x6c>)
{
34011da8:	b085      	sub	sp, #20
  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
34011daa:	4299      	cmp	r1, r3
34011dac:	d903      	bls.n	34011db6 <IMX335_SetGain+0x12>
  {
    ret = IMX335_ERROR;
34011dae:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

return ret;
}
34011db2:	b005      	add	sp, #20
34011db4:	bd30      	pop	{r4, r5, pc}
    gain /= IMX335_GAIN_UNIT_MDB;
34011db6:	f44f 7396 	mov.w	r3, #300	@ 0x12c
    hold = 1;
34011dba:	2501      	movs	r5, #1
    gain /= IMX335_GAIN_UNIT_MDB;
34011dbc:	fb91 f1f3 	sdiv	r1, r1, r3
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011dc0:	f100 0418 	add.w	r4, r0, #24
    gain /= IMX335_GAIN_UNIT_MDB;
34011dc4:	9101      	str	r1, [sp, #4]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011dc6:	462b      	mov	r3, r5
34011dc8:	f243 0101 	movw	r1, #12289	@ 0x3001
34011dcc:	4620      	mov	r0, r4
34011dce:	f10d 020f 	add.w	r2, sp, #15
    hold = 1;
34011dd2:	f88d 500f 	strb.w	r5, [sp, #15]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011dd6:	f000 f904 	bl	34011fe2 <imx335_write_reg>
34011dda:	2800      	cmp	r0, #0
34011ddc:	d1e7      	bne.n	34011dae <IMX335_SetGain+0xa>
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
34011dde:	2302      	movs	r3, #2
34011de0:	f243 01e8 	movw	r1, #12520	@ 0x30e8
34011de4:	4620      	mov	r0, r4
34011de6:	aa01      	add	r2, sp, #4
34011de8:	f000 f8fb 	bl	34011fe2 <imx335_write_reg>
34011dec:	2800      	cmp	r0, #0
34011dee:	d1de      	bne.n	34011dae <IMX335_SetGain+0xa>
        hold = 0;
34011df0:	f88d 000f 	strb.w	r0, [sp, #15]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011df4:	462b      	mov	r3, r5
34011df6:	f243 0101 	movw	r1, #12289	@ 0x3001
34011dfa:	4620      	mov	r0, r4
34011dfc:	f10d 020f 	add.w	r2, sp, #15
34011e00:	f000 f8ef 	bl	34011fe2 <imx335_write_reg>
34011e04:	3800      	subs	r0, #0
34011e06:	bf18      	it	ne
34011e08:	2001      	movne	r0, #1
34011e0a:	4240      	negs	r0, r0
return ret;
34011e0c:	e7d1      	b.n	34011db2 <IMX335_SetGain+0xe>
34011e0e:	bf00      	nop
34011e10:	00011940 	.word	0x00011940

34011e14 <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
34011e14:	b530      	push	{r4, r5, lr}
34011e16:	ed2d 8b02 	vpush	{d8}
  int32_t ret = IMX335_OK;
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
34011e1a:	f100 0418 	add.w	r4, r0, #24
{
34011e1e:	b085      	sub	sp, #20
34011e20:	ee08 1a10 	vmov	s16, r1
  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
34011e24:	2304      	movs	r3, #4
34011e26:	f243 0130 	movw	r1, #12336	@ 0x3030
34011e2a:	4620      	mov	r0, r4
34011e2c:	aa02      	add	r2, sp, #8
34011e2e:	f000 f8d1 	bl	34011fd4 <imx335_read_reg>
34011e32:	b128      	cbz	r0, 34011e40 <IMX335_SetExposure+0x2c>
  {
    ret = IMX335_ERROR;
34011e34:	f04f 30ff 	mov.w	r0, #4294967295
      }
    }
  }

  return ret;
}
34011e38:	b005      	add	sp, #20
34011e3a:	ecbd 8b02 	vpop	{d8}
34011e3e:	bd30      	pop	{r4, r5, pc}
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
34011e40:	eddd 7a02 	vldr	s15, [sp, #8]
34011e44:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
34011e48:	eddf 6a1a 	vldr	s13, [pc, #104]	@ 34011eb4 <IMX335_SetExposure+0xa0>
34011e4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
34011e50:	ee88 7a26 	vdiv.f32	s14, s16, s13
34011e54:	ee77 7ac7 	vsub.f32	s15, s15, s14
34011e58:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34011e5c:	ee17 3a90 	vmov	r3, s15
    if (shutter < IMX335_SHUTTER_MIN)
34011e60:	2b08      	cmp	r3, #8
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
34011e62:	edcd 7a03 	vstr	s15, [sp, #12]
    if (shutter < IMX335_SHUTTER_MIN)
34011e66:	d9e5      	bls.n	34011e34 <IMX335_SetExposure+0x20>
      hold = 1;
34011e68:	2501      	movs	r5, #1
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011e6a:	f243 0101 	movw	r1, #12289	@ 0x3001
34011e6e:	462b      	mov	r3, r5
34011e70:	4620      	mov	r0, r4
34011e72:	f10d 0207 	add.w	r2, sp, #7
      hold = 1;
34011e76:	f88d 5007 	strb.w	r5, [sp, #7]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011e7a:	f000 f8b2 	bl	34011fe2 <imx335_write_reg>
34011e7e:	2800      	cmp	r0, #0
34011e80:	d1d8      	bne.n	34011e34 <IMX335_SetExposure+0x20>
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
34011e82:	2303      	movs	r3, #3
34011e84:	f243 0158 	movw	r1, #12376	@ 0x3058
34011e88:	4620      	mov	r0, r4
34011e8a:	aa03      	add	r2, sp, #12
34011e8c:	f000 f8a9 	bl	34011fe2 <imx335_write_reg>
34011e90:	2800      	cmp	r0, #0
34011e92:	d1cf      	bne.n	34011e34 <IMX335_SetExposure+0x20>
          hold = 0;
34011e94:	f88d 0007 	strb.w	r0, [sp, #7]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
34011e98:	462b      	mov	r3, r5
34011e9a:	f243 0101 	movw	r1, #12289	@ 0x3001
34011e9e:	4620      	mov	r0, r4
34011ea0:	f10d 0207 	add.w	r2, sp, #7
34011ea4:	f000 f89d 	bl	34011fe2 <imx335_write_reg>
34011ea8:	3800      	subs	r0, #0
34011eaa:	bf18      	it	ne
34011eac:	2001      	movne	r0, #1
34011eae:	4240      	negs	r0, r0
  return ret;
34011eb0:	e7c2      	b.n	34011e38 <IMX335_SetExposure+0x24>
34011eb2:	bf00      	nop
34011eb4:	40ed097c 	.word	0x40ed097c

34011eb8 <IMX335_SetFrequency>:
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
  uint32_t ret = IMX335_OK;

  switch (frequency)
34011eb8:	3901      	subs	r1, #1
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011eba:	2207      	movs	r2, #7
{
34011ebc:	b508      	push	{r3, lr}
  switch (frequency)
34011ebe:	2903      	cmp	r1, #3
34011ec0:	d811      	bhi.n	34011ee6 <IMX335_SetFrequency+0x2e>
34011ec2:	e8df f001 	tbb	[pc, r1]
34011ec6:	0c0e      	.short	0x0c0e
34011ec8:	020a      	.short	0x020a
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
34011eca:	4908      	ldr	r1, [pc, #32]	@ (34011eec <IMX335_SetFrequency+0x34>)
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011ecc:	f7ff fed6 	bl	34011c7c <IMX335_WriteTable>
34011ed0:	3800      	subs	r0, #0
34011ed2:	bf18      	it	ne
34011ed4:	2001      	movne	r0, #1
34011ed6:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
34011ed8:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
34011eda:	4905      	ldr	r1, [pc, #20]	@ (34011ef0 <IMX335_SetFrequency+0x38>)
34011edc:	e7f6      	b.n	34011ecc <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
34011ede:	4905      	ldr	r1, [pc, #20]	@ (34011ef4 <IMX335_SetFrequency+0x3c>)
34011ee0:	e7f4      	b.n	34011ecc <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
34011ee2:	4905      	ldr	r1, [pc, #20]	@ (34011ef8 <IMX335_SetFrequency+0x40>)
34011ee4:	e7f2      	b.n	34011ecc <IMX335_SetFrequency+0x14>
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
34011ee6:	4905      	ldr	r1, [pc, #20]	@ (34011efc <IMX335_SetFrequency+0x44>)
34011ee8:	e7f0      	b.n	34011ecc <IMX335_SetFrequency+0x14>
34011eea:	bf00      	nop
34011eec:	3403567c 	.word	0x3403567c
34011ef0:	34035660 	.word	0x34035660
34011ef4:	34035644 	.word	0x34035644
34011ef8:	34035628 	.word	0x34035628
34011efc:	3403560c 	.word	0x3403560c

34011f00 <IMX335_SetFramerate>:
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
  uint32_t ret = IMX335_OK;
  switch (framerate)
34011f00:	2914      	cmp	r1, #20
{
34011f02:	b508      	push	{r3, lr}
34011f04:	4603      	mov	r3, r0
  switch (framerate)
34011f06:	d019      	beq.n	34011f3c <IMX335_SetFramerate+0x3c>
34011f08:	dc07      	bgt.n	34011f1a <IMX335_SetFramerate+0x1a>
34011f0a:	290a      	cmp	r1, #10
34011f0c:	d00a      	beq.n	34011f24 <IMX335_SetFramerate+0x24>
34011f0e:	290f      	cmp	r1, #15
34011f10:	d011      	beq.n	34011f36 <IMX335_SetFramerate+0x36>
        ret = IMX335_ERROR;
      }
      break;
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
34011f12:	2202      	movs	r2, #2
34011f14:	4618      	mov	r0, r3
34011f16:	490b      	ldr	r1, [pc, #44]	@ (34011f44 <IMX335_SetFramerate+0x44>)
34011f18:	e006      	b.n	34011f28 <IMX335_SetFramerate+0x28>
  switch (framerate)
34011f1a:	2919      	cmp	r1, #25
34011f1c:	d1f9      	bne.n	34011f12 <IMX335_SetFramerate+0x12>
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
34011f1e:	2202      	movs	r2, #2
34011f20:	4909      	ldr	r1, [pc, #36]	@ (34011f48 <IMX335_SetFramerate+0x48>)
34011f22:	e001      	b.n	34011f28 <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
34011f24:	2202      	movs	r2, #2
34011f26:	4909      	ldr	r1, [pc, #36]	@ (34011f4c <IMX335_SetFramerate+0x4c>)
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
34011f28:	f7ff fea8 	bl	34011c7c <IMX335_WriteTable>
34011f2c:	3800      	subs	r0, #0
34011f2e:	bf18      	it	ne
34011f30:	2001      	movne	r0, #1
34011f32:	4240      	negs	r0, r0
      }
      break;
  };

  return ret;
}
34011f34:	bd08      	pop	{r3, pc}
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
34011f36:	2202      	movs	r2, #2
34011f38:	4905      	ldr	r1, [pc, #20]	@ (34011f50 <IMX335_SetFramerate+0x50>)
34011f3a:	e7f5      	b.n	34011f28 <IMX335_SetFramerate+0x28>
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
34011f3c:	2202      	movs	r2, #2
34011f3e:	4905      	ldr	r1, [pc, #20]	@ (34011f54 <IMX335_SetFramerate+0x54>)
34011f40:	e7f2      	b.n	34011f28 <IMX335_SetFramerate+0x28>
34011f42:	bf00      	nop
34011f44:	340355e4 	.word	0x340355e4
34011f48:	340355ec 	.word	0x340355ec
34011f4c:	34035604 	.word	0x34035604
34011f50:	340355fc 	.word	0x340355fc
34011f54:	340355f4 	.word	0x340355f4

34011f58 <IMX335_MirrorFlipConfig>:
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
  int32_t ret = IMX335_OK;

  switch (Config)
34011f58:	2902      	cmp	r1, #2
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
      break;
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011f5a:	f04f 020a 	mov.w	r2, #10
  switch (Config)
34011f5e:	d006      	beq.n	34011f6e <IMX335_MirrorFlipConfig+0x16>
34011f60:	2903      	cmp	r1, #3
34011f62:	d006      	beq.n	34011f72 <IMX335_MirrorFlipConfig+0x1a>
34011f64:	2901      	cmp	r1, #1
34011f66:	d106      	bne.n	34011f76 <IMX335_MirrorFlipConfig+0x1e>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
34011f68:	4904      	ldr	r1, [pc, #16]	@ (34011f7c <IMX335_MirrorFlipConfig+0x24>)
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011f6a:	f7ff be87 	b.w	34011c7c <IMX335_WriteTable>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
34011f6e:	4904      	ldr	r1, [pc, #16]	@ (34011f80 <IMX335_MirrorFlipConfig+0x28>)
34011f70:	e7fb      	b.n	34011f6a <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
34011f72:	4904      	ldr	r1, [pc, #16]	@ (34011f84 <IMX335_MirrorFlipConfig+0x2c>)
34011f74:	e7f9      	b.n	34011f6a <IMX335_MirrorFlipConfig+0x12>
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
34011f76:	4904      	ldr	r1, [pc, #16]	@ (34011f88 <IMX335_MirrorFlipConfig+0x30>)
34011f78:	e7f7      	b.n	34011f6a <IMX335_MirrorFlipConfig+0x12>
34011f7a:	bf00      	nop
34011f7c:	3403556c 	.word	0x3403556c
34011f80:	34035594 	.word	0x34035594
34011f84:	340355bc 	.word	0x340355bc
34011f88:	34035544 	.word	0x34035544

34011f8c <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
34011f8c:	b513      	push	{r0, r1, r4, lr}
  int32_t ret = IMX335_OK;
  uint8_t val;

  if (mode >= 0)
34011f8e:	2900      	cmp	r1, #0
{
34011f90:	4604      	mov	r4, r0
  if (mode >= 0)
34011f92:	db15      	blt.n	34011fc0 <IMX335_SetTestPattern+0x34>
  {
    /* Enable Test Pattern #mode */
    val = mode;
34011f94:	f88d 1007 	strb.w	r1, [sp, #7]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
34011f98:	2301      	movs	r3, #1
34011f9a:	f243 219e 	movw	r1, #12958	@ 0x329e
34011f9e:	f10d 0207 	add.w	r2, sp, #7
34011fa2:	3018      	adds	r0, #24
34011fa4:	f000 f81d 	bl	34011fe2 <imx335_write_reg>
34011fa8:	b968      	cbnz	r0, 34011fc6 <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
34011faa:	2207      	movs	r2, #7
34011fac:	4620      	mov	r0, r4
34011fae:	4907      	ldr	r1, [pc, #28]	@ (34011fcc <IMX335_SetTestPattern+0x40>)
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
34011fb0:	f7ff fe64 	bl	34011c7c <IMX335_WriteTable>
34011fb4:	3800      	subs	r0, #0
34011fb6:	bf18      	it	ne
34011fb8:	2001      	movne	r0, #1
34011fba:	4240      	negs	r0, r0
      return IMX335_ERROR;
    }
  }

  return ret;
}
34011fbc:	b002      	add	sp, #8
34011fbe:	bd10      	pop	{r4, pc}
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
34011fc0:	2207      	movs	r2, #7
34011fc2:	4903      	ldr	r1, [pc, #12]	@ (34011fd0 <IMX335_SetTestPattern+0x44>)
34011fc4:	e7f4      	b.n	34011fb0 <IMX335_SetTestPattern+0x24>
      return IMX335_ERROR;
34011fc6:	f04f 30ff 	mov.w	r0, #4294967295
34011fca:	e7f7      	b.n	34011fbc <IMX335_SetTestPattern+0x30>
34011fcc:	34035528 	.word	0x34035528
34011fd0:	3403550c 	.word	0x3403550c

34011fd4 <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
34011fd4:	b410      	push	{r4}
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
34011fd6:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
34011fda:	46a4      	mov	ip, r4
}
34011fdc:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
34011fe0:	4760      	bx	ip

34011fe2 <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
34011fe2:	b410      	push	{r4}
  return ctx->WriteReg(ctx->handle, reg, data, length);
34011fe4:	6804      	ldr	r4, [r0, #0]
34011fe6:	6880      	ldr	r0, [r0, #8]
34011fe8:	46a4      	mov	ip, r4
}
34011fea:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->WriteReg(ctx->handle, reg, data, length);
34011fee:	4760      	bx	ip

34011ff0 <VD55G1_log_impl>:
    return NULL;
  }
}

static void VD55G1_log_impl(VD55G1_Ctx_t *ctx, int lvl, const char *format, ...)
{
34011ff0:	b40c      	push	{r2, r3}
34011ff2:	b513      	push	{r0, r1, r4, lr}
  va_list ap;

  if (!ctx->log)
34011ff4:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34011ff6:	b11c      	cbz	r4, 34012000 <VD55G1_log_impl+0x10>
    return ;

  va_start(ap, format);
34011ff8:	ab05      	add	r3, sp, #20
  ctx->log(ctx, lvl, format, ap);
34011ffa:	9a04      	ldr	r2, [sp, #16]
  va_start(ap, format);
34011ffc:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, lvl, format, ap);
34011ffe:	47a0      	blx	r4
  va_end(ap);
}
34012000:	b002      	add	sp, #8
34012002:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012006:	b002      	add	sp, #8
34012008:	4770      	bx	lr
	...

3401200c <VD55G1_PollReg8>:

  return 0;
}

static int VD55G1_PollReg8(VD55G1_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
3401200c:	b5f0      	push	{r4, r5, r6, r7, lr}
3401200e:	4604      	mov	r4, r0
34012010:	460e      	mov	r6, r1
34012012:	4617      	mov	r7, r2
34012014:	2531      	movs	r5, #49	@ 0x31
34012016:	b085      	sub	sp, #20
  int loop_nb = timeout_ms / loop_delay_ms;
  uint8_t val;
  int ret;

  while (--loop_nb) {
    ret = ctx->read8(ctx, addr, &val);
34012018:	4631      	mov	r1, r6
3401201a:	4620      	mov	r0, r4
3401201c:	6863      	ldr	r3, [r4, #4]
3401201e:	f10d 020f 	add.w	r2, sp, #15
34012022:	4798      	blx	r3
    if (ret < 0)
34012024:	2800      	cmp	r0, #0
34012026:	db17      	blt.n	34012058 <VD55G1_PollReg8+0x4c>
      return ret;
    if (val == poll_val)
34012028:	f89d 300f 	ldrb.w	r3, [sp, #15]
3401202c:	42bb      	cmp	r3, r7
3401202e:	d015      	beq.n	3401205c <VD55G1_PollReg8+0x50>
      return 0;
    ctx->delay(ctx, loop_delay_ms);
34012030:	210a      	movs	r1, #10
34012032:	4620      	mov	r0, r4
34012034:	6a23      	ldr	r3, [r4, #32]
34012036:	4798      	blx	r3
  while (--loop_nb) {
34012038:	3d01      	subs	r5, #1
3401203a:	d1ed      	bne.n	34012018 <VD55G1_PollReg8+0xc>
  }

  VD55G1_dbg(ctx, 0, "current state %d\n", val);
3401203c:	f89d 300f 	ldrb.w	r3, [sp, #15]
34012040:	4620      	mov	r0, r4
34012042:	9301      	str	r3, [sp, #4]
34012044:	f240 132b 	movw	r3, #299	@ 0x12b
34012048:	2103      	movs	r1, #3
3401204a:	9300      	str	r3, [sp, #0]
3401204c:	4a04      	ldr	r2, [pc, #16]	@ (34012060 <VD55G1_PollReg8+0x54>)
3401204e:	462b      	mov	r3, r5
34012050:	f7ff ffce 	bl	34011ff0 <VD55G1_log_impl>

  return -1;
34012054:	f04f 30ff 	mov.w	r0, #4294967295
}
34012058:	b005      	add	sp, #20
3401205a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return 0;
3401205c:	2000      	movs	r0, #0
3401205e:	e7fb      	b.n	34012058 <VD55G1_PollReg8+0x4c>
34012060:	3401ca08 	.word	0x3401ca08

34012064 <VD55G1_WaitState>:

  return state == VD55G1_SYSTEM_FSM_STREAMING;
}

static int VD55G1_WaitState(VD55G1_Ctx_t *ctx, int state)
{
34012064:	b573      	push	{r0, r1, r4, r5, r6, lr}
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
34012066:	b2ca      	uxtb	r2, r1
{
34012068:	460d      	mov	r5, r1
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
3401206a:	211c      	movs	r1, #28
{
3401206c:	4606      	mov	r6, r0
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
3401206e:	f7ff ffcd 	bl	3401200c <VD55G1_PollReg8>

  if (ret)
34012072:	4604      	mov	r4, r0
34012074:	b150      	cbz	r0, 3401208c <VD55G1_WaitState+0x28>
    VD55G1_warn(ctx, "Unable to reach state %d\n", state);
34012076:	f240 1341 	movw	r3, #321	@ 0x141
3401207a:	2101      	movs	r1, #1
3401207c:	4630      	mov	r0, r6
3401207e:	4a09      	ldr	r2, [pc, #36]	@ (340120a4 <VD55G1_WaitState+0x40>)
34012080:	9500      	str	r5, [sp, #0]
34012082:	f7ff ffb5 	bl	34011ff0 <VD55G1_log_impl>
  else
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);

  return ret;
}
34012086:	4620      	mov	r0, r4
34012088:	b002      	add	sp, #8
3401208a:	bd70      	pop	{r4, r5, r6, pc}
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);
3401208c:	f240 1343 	movw	r3, #323	@ 0x143
34012090:	2103      	movs	r1, #3
34012092:	9300      	str	r3, [sp, #0]
34012094:	4a04      	ldr	r2, [pc, #16]	@ (340120a8 <VD55G1_WaitState+0x44>)
34012096:	4603      	mov	r3, r0
34012098:	9501      	str	r5, [sp, #4]
3401209a:	4630      	mov	r0, r6
3401209c:	f7ff ffa8 	bl	34011ff0 <VD55G1_log_impl>
  return ret;
340120a0:	e7f1      	b.n	34012086 <VD55G1_WaitState+0x22>
340120a2:	bf00      	nop
340120a4:	3401ca2b 	.word	0x3401ca2b
340120a8:	3401ca55 	.word	0x3401ca55

340120ac <display_error>:
{
340120ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
340120ae:	2110      	movs	r1, #16
340120b0:	6883      	ldr	r3, [r0, #8]
340120b2:	f10d 020e 	add.w	r2, sp, #14
{
340120b6:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
340120b8:	4798      	blx	r3
  assert(ret == 0);
340120ba:	4601      	mov	r1, r0
340120bc:	b128      	cbz	r0, 340120ca <display_error+0x1e>
340120be:	21fc      	movs	r1, #252	@ 0xfc
340120c0:	4b07      	ldr	r3, [pc, #28]	@ (340120e0 <display_error+0x34>)
340120c2:	4a08      	ldr	r2, [pc, #32]	@ (340120e4 <display_error+0x38>)
340120c4:	4808      	ldr	r0, [pc, #32]	@ (340120e8 <display_error+0x3c>)
340120c6:	f005 fc6b 	bl	340179a0 <__assert_func>
  VD55G1_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
340120ca:	f8bd 300e 	ldrh.w	r3, [sp, #14]
340120ce:	4620      	mov	r0, r4
340120d0:	9300      	str	r3, [sp, #0]
340120d2:	4a06      	ldr	r2, [pc, #24]	@ (340120ec <display_error+0x40>)
340120d4:	23fd      	movs	r3, #253	@ 0xfd
340120d6:	f7ff ff8b 	bl	34011ff0 <VD55G1_log_impl>
}
340120da:	b004      	add	sp, #16
340120dc:	bd10      	pop	{r4, pc}
340120de:	bf00      	nop
340120e0:	3401bf23 	.word	0x3401bf23
340120e4:	34035957 	.word	0x34035957
340120e8:	3401ca76 	.word	0x3401ca76
340120ec:	3401cad5 	.word	0x3401cad5

340120f0 <VD55G1_ApplyPatchCommon>:
  return 0;
}

static int VD55G1_ApplyPatchCommon(VD55G1_Ctx_t *ctx, uint8_t *patch_array, int patch_len, uint8_t patch_major,
                                   uint8_t patch_minor)
{
340120f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t reg16;
  int ret;

  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
340120f2:	69c4      	ldr	r4, [r0, #28]
{
340120f4:	b087      	sub	sp, #28
340120f6:	461e      	mov	r6, r3
  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
340120f8:	4613      	mov	r3, r2
340120fa:	460a      	mov	r2, r1
340120fc:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
{
34012100:	4605      	mov	r5, r0
34012102:	f89d 7030 	ldrb.w	r7, [sp, #48]	@ 0x30
  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
34012106:	47a0      	blx	r4
  VD55G1_TraceError(ctx, ret);
34012108:	4604      	mov	r4, r0
3401210a:	b958      	cbnz	r0, 34012124 <VD55G1_ApplyPatchCommon+0x34>

  ret = ctx->write8(ctx, VD55G1_REG_BOOT, VD55G1_BOOT_PATCH_AND_BOOT);
3401210c:	2202      	movs	r2, #2
3401210e:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012112:	4628      	mov	r0, r5
34012114:	692b      	ldr	r3, [r5, #16]
34012116:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012118:	4604      	mov	r4, r0
3401211a:	b190      	cbz	r0, 34012142 <VD55G1_ApplyPatchCommon+0x52>
3401211c:	f240 1377 	movw	r3, #375	@ 0x177
34012120:	9002      	str	r0, [sp, #8]
34012122:	e002      	b.n	3401212a <VD55G1_ApplyPatchCommon+0x3a>
  VD55G1_TraceError(ctx, ret);
34012124:	f44f 73ba 	mov.w	r3, #372	@ 0x174
34012128:	9002      	str	r0, [sp, #8]
    return -1;
  }
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
  VD55G1_TraceError(ctx, ret);
3401212a:	4a32      	ldr	r2, [pc, #200]	@ (340121f4 <VD55G1_ApplyPatchCommon+0x104>)
3401212c:	4628      	mov	r0, r5
3401212e:	9200      	str	r2, [sp, #0]
34012130:	2100      	movs	r1, #0
34012132:	4a31      	ldr	r2, [pc, #196]	@ (340121f8 <VD55G1_ApplyPatchCommon+0x108>)
34012134:	9301      	str	r3, [sp, #4]
34012136:	f7ff ff5b 	bl	34011ff0 <VD55G1_log_impl>
3401213a:	4628      	mov	r0, r5
3401213c:	f7ff ffb6 	bl	340120ac <display_error>
34012140:	e039      	b.n	340121b6 <VD55G1_ApplyPatchCommon+0xc6>
  ret = VD55G1_PollReg8(ctx, VD55G1_REG_BOOT, VD55G1_CMD_ACK);
34012142:	4602      	mov	r2, r0
34012144:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012148:	4628      	mov	r0, r5
3401214a:	f7ff ff5f 	bl	3401200c <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
3401214e:	4604      	mov	r4, r0
34012150:	b118      	cbz	r0, 3401215a <VD55G1_ApplyPatchCommon+0x6a>
34012152:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
34012156:	9002      	str	r0, [sp, #8]
34012158:	e7e7      	b.n	3401212a <VD55G1_ApplyPatchCommon+0x3a>
  ret = ctx->read16(ctx, VD55G1_REG_FWPATCH_REVISION, &reg16);
3401215a:	2112      	movs	r1, #18
3401215c:	4628      	mov	r0, r5
3401215e:	68ab      	ldr	r3, [r5, #8]
34012160:	f10d 0216 	add.w	r2, sp, #22
34012164:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012166:	4604      	mov	r4, r0
34012168:	b118      	cbz	r0, 34012172 <VD55G1_ApplyPatchCommon+0x82>
3401216a:	f240 137d 	movw	r3, #381	@ 0x17d
3401216e:	9002      	str	r0, [sp, #8]
34012170:	e7db      	b.n	3401212a <VD55G1_ApplyPatchCommon+0x3a>
  VD55G1_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
34012172:	f8bd 3016 	ldrh.w	r3, [sp, #22]
34012176:	4a21      	ldr	r2, [pc, #132]	@ (340121fc <VD55G1_ApplyPatchCommon+0x10c>)
34012178:	9301      	str	r3, [sp, #4]
3401217a:	f44f 73bf 	mov.w	r3, #382	@ 0x17e
3401217e:	2103      	movs	r1, #3
34012180:	9300      	str	r3, [sp, #0]
34012182:	4603      	mov	r3, r0
34012184:	4628      	mov	r0, r5
34012186:	f7ff ff33 	bl	34011ff0 <VD55G1_log_impl>
  if (reg16 != (patch_major << 8) + patch_minor) {
3401218a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
3401218e:	eb07 2306 	add.w	r3, r7, r6, lsl #8
34012192:	429a      	cmp	r2, r3
34012194:	b2d3      	uxtb	r3, r2
34012196:	ea4f 2212 	mov.w	r2, r2, lsr #8
3401219a:	d00f      	beq.n	340121bc <VD55G1_ApplyPatchCommon+0xcc>
    VD55G1_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor, reg16 >> 8, reg16 & 0xff);
3401219c:	e9cd 2302 	strd	r2, r3, [sp, #8]
340121a0:	4621      	mov	r1, r4
340121a2:	f240 1381 	movw	r3, #385	@ 0x181
340121a6:	4628      	mov	r0, r5
340121a8:	e9cd 6700 	strd	r6, r7, [sp]
340121ac:	4a14      	ldr	r2, [pc, #80]	@ (34012200 <VD55G1_ApplyPatchCommon+0x110>)
340121ae:	f7ff ff1f 	bl	34011ff0 <VD55G1_log_impl>
    return -1;
340121b2:	f04f 34ff 	mov.w	r4, #4294967295

  VD55G1_notice(ctx, "sensor boot successfully\n");

  return 0;
}
340121b6:	4620      	mov	r0, r4
340121b8:	b007      	add	sp, #28
340121ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
340121bc:	e9cd 2300 	strd	r2, r3, [sp]
340121c0:	2102      	movs	r1, #2
340121c2:	f44f 73c2 	mov.w	r3, #388	@ 0x184
340121c6:	4628      	mov	r0, r5
340121c8:	4a0e      	ldr	r2, [pc, #56]	@ (34012204 <VD55G1_ApplyPatchCommon+0x114>)
340121ca:	f7ff ff11 	bl	34011ff0 <VD55G1_log_impl>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
340121ce:	2102      	movs	r1, #2
340121d0:	4628      	mov	r0, r5
340121d2:	f7ff ff47 	bl	34012064 <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
340121d6:	4604      	mov	r4, r0
340121d8:	b938      	cbnz	r0, 340121ea <VD55G1_ApplyPatchCommon+0xfa>
  VD55G1_notice(ctx, "sensor boot successfully\n");
340121da:	f240 1389 	movw	r3, #393	@ 0x189
340121de:	2102      	movs	r1, #2
340121e0:	4628      	mov	r0, r5
340121e2:	4a09      	ldr	r2, [pc, #36]	@ (34012208 <VD55G1_ApplyPatchCommon+0x118>)
340121e4:	f7ff ff04 	bl	34011ff0 <VD55G1_log_impl>
  return 0;
340121e8:	e7e5      	b.n	340121b6 <VD55G1_ApplyPatchCommon+0xc6>
  VD55G1_TraceError(ctx, ret);
340121ea:	f240 1387 	movw	r3, #391	@ 0x187
340121ee:	9002      	str	r0, [sp, #8]
340121f0:	e79b      	b.n	3401212a <VD55G1_ApplyPatchCommon+0x3a>
340121f2:	bf00      	nop
340121f4:	3403592d 	.word	0x3403592d
340121f8:	3401cafa 	.word	0x3401cafa
340121fc:	3401cb1f 	.word	0x3401cb1f
34012200:	3401cb40 	.word	0x3401cb40
34012204:	3401cb7c 	.word	0x3401cb7c
34012208:	3401cba1 	.word	0x3401cba1

3401220c <VD55G1_ComputeFrameLength>:

  return 0;
}

static int VD55G1_ComputeFrameLength(VD55G1_Ctx_t *ctx, int fps, uint16_t *frame_length)
{
3401220c:	b5f0      	push	{r4, r5, r6, r7, lr}
3401220e:	b089      	sub	sp, #36	@ 0x24
34012210:	460e      	mov	r6, r1
34012212:	4617      	mov	r7, r2
  int req_frame_length;
  uint16_t line_length;
  uint16_t height;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
34012214:	f44f 7140 	mov.w	r1, #768	@ 0x300
34012218:	6883      	ldr	r3, [r0, #8]
3401221a:	aa07      	add	r2, sp, #28
{
3401221c:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
3401221e:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012220:	4605      	mov	r5, r0
34012222:	b960      	cbnz	r0, 3401223e <VD55G1_ComputeFrameLength+0x32>

  ret = ctx->read16(ctx, VD55G1_REG_Y_HEIGHT, &height);
34012224:	f240 5112 	movw	r1, #1298	@ 0x512
34012228:	4620      	mov	r0, r4
3401222a:	68a3      	ldr	r3, [r4, #8]
3401222c:	f10d 021e 	add.w	r2, sp, #30
34012230:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012232:	4605      	mov	r5, r0
34012234:	b190      	cbz	r0, 3401225c <VD55G1_ComputeFrameLength+0x50>
34012236:	f44f 7316 	mov.w	r3, #600	@ 0x258
3401223a:	9002      	str	r0, [sp, #8]
3401223c:	e002      	b.n	34012244 <VD55G1_ComputeFrameLength+0x38>
  VD55G1_TraceError(ctx, ret);
3401223e:	f240 2355 	movw	r3, #597	@ 0x255
34012242:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012244:	4a17      	ldr	r2, [pc, #92]	@ (340122a4 <VD55G1_ComputeFrameLength+0x98>)
34012246:	4620      	mov	r0, r4
34012248:	9200      	str	r2, [sp, #0]
3401224a:	2100      	movs	r1, #0
3401224c:	4a16      	ldr	r2, [pc, #88]	@ (340122a8 <VD55G1_ComputeFrameLength+0x9c>)
3401224e:	9301      	str	r3, [sp, #4]
34012250:	f7ff fece 	bl	34011ff0 <VD55G1_log_impl>
34012254:	4620      	mov	r0, r4
34012256:	f7ff ff29 	bl	340120ac <display_error>
3401225a:	e01f      	b.n	3401229c <VD55G1_ComputeFrameLength+0x90>

  min_frame_length = height + VD55G1_MIN_VBLANK;
  req_frame_length = drv_ctx->pclk / (line_length * fps);
3401225c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
34012260:	6b20      	ldr	r0, [r4, #48]	@ 0x30
34012262:	4372      	muls	r2, r6
34012264:	fbb0 f0f2 	udiv	r0, r0, r2
  min_frame_length = height + VD55G1_MIN_VBLANK;
34012268:	f8bd 301e 	ldrh.w	r3, [sp, #30]
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
3401226c:	f64f 71ff 	movw	r1, #65535	@ 0xffff
  min_frame_length = height + VD55G1_MIN_VBLANK;
34012270:	3356      	adds	r3, #86	@ 0x56
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
34012272:	4283      	cmp	r3, r0
34012274:	461a      	mov	r2, r3
34012276:	bfb8      	it	lt
34012278:	4602      	movlt	r2, r0
3401227a:	428a      	cmp	r2, r1
3401227c:	bfa8      	it	ge
3401227e:	460a      	movge	r2, r1
34012280:	803a      	strh	r2, [r7, #0]

  VD55G1_dbg(ctx, 1, "frame_length to MAX(%d, %d) = %d to reach %d fps\n", min_frame_length, req_frame_length,
34012282:	e9cd 3001 	strd	r3, r0, [sp, #4]
34012286:	f240 235e 	movw	r3, #606	@ 0x25e
3401228a:	e9cd 2603 	strd	r2, r6, [sp, #12]
3401228e:	9300      	str	r3, [sp, #0]
34012290:	2104      	movs	r1, #4
34012292:	2301      	movs	r3, #1
34012294:	4620      	mov	r0, r4
34012296:	4a05      	ldr	r2, [pc, #20]	@ (340122ac <VD55G1_ComputeFrameLength+0xa0>)
34012298:	f7ff feaa 	bl	34011ff0 <VD55G1_log_impl>
             *frame_length, fps);

  return 0;
}
3401229c:	4628      	mov	r0, r5
3401229e:	b009      	add	sp, #36	@ 0x24
340122a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
340122a2:	bf00      	nop
340122a4:	34035898 	.word	0x34035898
340122a8:	3401cafa 	.word	0x3401cafa
340122ac:	3401cbcb 	.word	0x3401cbcb

340122b0 <VD55G1_SetFlicker>:

  return 0;
}

static int VD55G1_SetFlicker(VD55G1_Ctx_t *ctx, VD55G1_Flicker_t flicker)
{
340122b0:	b530      	push	{r4, r5, lr}
340122b2:	2902      	cmp	r1, #2
340122b4:	4605      	mov	r5, r0
340122b6:	b085      	sub	sp, #20
340122b8:	d818      	bhi.n	340122ec <VD55G1_SetFlicker+0x3c>
    break;
  default:
    return -1;
  }

  ret = ctx->write16(ctx, VD55G1_REG_EXPOSURE_COMPILER_CONTROL_A, mode);
340122ba:	4a0e      	ldr	r2, [pc, #56]	@ (340122f4 <VD55G1_SetFlicker+0x44>)
340122bc:	6943      	ldr	r3, [r0, #20]
340122be:	5c52      	ldrb	r2, [r2, r1]
340122c0:	f240 4182 	movw	r1, #1154	@ 0x482
340122c4:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340122c6:	4604      	mov	r4, r0
340122c8:	b168      	cbz	r0, 340122e6 <VD55G1_SetFlicker+0x36>
340122ca:	f240 23ed 	movw	r3, #749	@ 0x2ed
340122ce:	4a0a      	ldr	r2, [pc, #40]	@ (340122f8 <VD55G1_SetFlicker+0x48>)
340122d0:	9002      	str	r0, [sp, #8]
340122d2:	9200      	str	r2, [sp, #0]
340122d4:	4628      	mov	r0, r5
340122d6:	2100      	movs	r1, #0
340122d8:	4a08      	ldr	r2, [pc, #32]	@ (340122fc <VD55G1_SetFlicker+0x4c>)
340122da:	9301      	str	r3, [sp, #4]
340122dc:	f7ff fe88 	bl	34011ff0 <VD55G1_log_impl>
340122e0:	4628      	mov	r0, r5
340122e2:	f7ff fee3 	bl	340120ac <display_error>

  return 0;
}
340122e6:	4620      	mov	r0, r4
340122e8:	b005      	add	sp, #20
340122ea:	bd30      	pop	{r4, r5, pc}
    return -1;
340122ec:	f04f 34ff 	mov.w	r4, #4294967295
340122f0:	e7f9      	b.n	340122e6 <VD55G1_SetFlicker+0x36>
340122f2:	bf00      	nop
340122f4:	340357fc 	.word	0x340357fc
340122f8:	34035847 	.word	0x34035847
340122fc:	3401cafa 	.word	0x3401cafa

34012300 <VD55G1_StopStreaming>:

  return 0;
}

static int VD55G1_StopStreaming(VD55G1_Ctx_t *ctx)
{
34012300:	b530      	push	{r4, r5, lr}
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
34012302:	2201      	movs	r2, #1
34012304:	f240 2102 	movw	r1, #514	@ 0x202
34012308:	6903      	ldr	r3, [r0, #16]
{
3401230a:	b085      	sub	sp, #20
3401230c:	4605      	mov	r5, r0
  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
3401230e:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012310:	4604      	mov	r4, r0
34012312:	b958      	cbnz	r0, 3401232c <VD55G1_StopStreaming+0x2c>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STREAMING, VD55G1_CMD_ACK);
34012314:	4602      	mov	r2, r0
34012316:	f240 2102 	movw	r1, #514	@ 0x202
3401231a:	4628      	mov	r0, r5
3401231c:	f7ff fe76 	bl	3401200c <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012320:	4604      	mov	r4, r0
34012322:	b190      	cbz	r0, 3401234a <VD55G1_StopStreaming+0x4a>
34012324:	f240 3332 	movw	r3, #818	@ 0x332
34012328:	9002      	str	r0, [sp, #8]
3401232a:	e002      	b.n	34012332 <VD55G1_StopStreaming+0x32>
  VD55G1_TraceError(ctx, ret);
3401232c:	f240 332f 	movw	r3, #815	@ 0x32f
34012330:	9002      	str	r0, [sp, #8]

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
  VD55G1_TraceError(ctx, ret);
34012332:	4a10      	ldr	r2, [pc, #64]	@ (34012374 <VD55G1_StopStreaming+0x74>)
34012334:	4628      	mov	r0, r5
34012336:	9200      	str	r2, [sp, #0]
34012338:	2100      	movs	r1, #0
3401233a:	4a0f      	ldr	r2, [pc, #60]	@ (34012378 <VD55G1_StopStreaming+0x78>)
3401233c:	9301      	str	r3, [sp, #4]
3401233e:	f7ff fe57 	bl	34011ff0 <VD55G1_log_impl>
34012342:	4628      	mov	r0, r5
34012344:	f7ff feb2 	bl	340120ac <display_error>
34012348:	e010      	b.n	3401236c <VD55G1_StopStreaming+0x6c>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
3401234a:	2102      	movs	r1, #2
3401234c:	4628      	mov	r0, r5
3401234e:	f7ff fe89 	bl	34012064 <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
34012352:	4604      	mov	r4, r0
34012354:	b118      	cbz	r0, 3401235e <VD55G1_StopStreaming+0x5e>
34012356:	f240 3335 	movw	r3, #821	@ 0x335
3401235a:	9002      	str	r0, [sp, #8]
3401235c:	e7e9      	b.n	34012332 <VD55G1_StopStreaming+0x32>

  VD55G1_notice(ctx, "Streaming is off\n");
3401235e:	f240 3337 	movw	r3, #823	@ 0x337
34012362:	2102      	movs	r1, #2
34012364:	4628      	mov	r0, r5
34012366:	4a05      	ldr	r2, [pc, #20]	@ (3401237c <VD55G1_StopStreaming+0x7c>)
34012368:	f7ff fe42 	bl	34011ff0 <VD55G1_log_impl>

  return 0;
}
3401236c:	4620      	mov	r0, r4
3401236e:	b005      	add	sp, #20
34012370:	bd30      	pop	{r4, r5, pc}
34012372:	bf00      	nop
34012374:	3403581c 	.word	0x3403581c
34012378:	3401cafa 	.word	0x3401cafa
3401237c:	3401cc0e 	.word	0x3401cc0e

34012380 <VD55G1_Init>:

  return VD55G1_StartAWU(ctx);
}

int VD55G1_Init(VD55G1_Ctx_t *ctx, VD55G1_Config_t *config)
{
34012380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  VD55G1_AWUConfig_t *awu = &config->awu;
  struct drv_ctx *drv_ctx = &ctx->ctx;
  int ret;

  if (config->frame_rate < VD55G1_MIN_FPS)
34012384:	688b      	ldr	r3, [r1, #8]
{
34012386:	4605      	mov	r5, r0
  if (config->frame_rate < VD55G1_MIN_FPS)
34012388:	3b02      	subs	r3, #2
3401238a:	2ba6      	cmp	r3, #166	@ 0xa6
{
3401238c:	460c      	mov	r4, r1
3401238e:	b086      	sub	sp, #24
  if (config->frame_rate < VD55G1_MIN_FPS)
34012390:	d802      	bhi.n	34012398 <VD55G1_Init+0x18>
    return -1;
  if (config->frame_rate > VD55G1_MAX_FPS)
    return -1;

  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
34012392:	790b      	ldrb	r3, [r1, #4]
34012394:	2b03      	cmp	r3, #3
34012396:	d905      	bls.n	340123a4 <VD55G1_Init+0x24>
    return -1;
34012398:	f04f 34ff 	mov.w	r4, #4294967295
    return ret;

  drv_ctx->state = VD55G1_ST_IDLE;

  return 0;
}
3401239c:	4620      	mov	r0, r4
3401239e:	b006      	add	sp, #24
340123a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (awu->is_enable && awu->threshold != VD55G1_AWU_THRESHOLD_DEFAULT) {
340123a4:	69cb      	ldr	r3, [r1, #28]
340123a6:	b123      	cbz	r3, 340123b2 <VD55G1_Init+0x32>
340123a8:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
340123aa:	b113      	cbz	r3, 340123b2 <VD55G1_Init+0x32>
    if (awu->threshold < VD55G1_AWU_THRESHOLD_MIN)
340123ac:	3b02      	subs	r3, #2
340123ae:	2b7e      	cmp	r3, #126	@ 0x7e
340123b0:	d8f2      	bhi.n	34012398 <VD55G1_Init+0x18>
  drv_ctx->config_save = *config;
340123b2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340123b4:	f105 0634 	add.w	r6, r5, #52	@ 0x34
340123b8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340123ba:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340123bc:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340123be:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340123c0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340123c2:	6823      	ldr	r3, [r4, #0]
  ctx->shutdown_pin(ctx, 0);
340123c4:	2100      	movs	r1, #0
340123c6:	4628      	mov	r0, r5
  drv_ctx->config_save = *config;
340123c8:	6033      	str	r3, [r6, #0]
  ctx->shutdown_pin(ctx, 0);
340123ca:	682b      	ldr	r3, [r5, #0]
340123cc:	4798      	blx	r3
  ctx->delay(ctx, 10);
340123ce:	210a      	movs	r1, #10
340123d0:	4628      	mov	r0, r5
340123d2:	6a2b      	ldr	r3, [r5, #32]
340123d4:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
340123d6:	2101      	movs	r1, #1
340123d8:	4628      	mov	r0, r5
340123da:	682b      	ldr	r3, [r5, #0]
340123dc:	4798      	blx	r3
  ctx->delay(ctx, 10);
340123de:	210a      	movs	r1, #10
340123e0:	4628      	mov	r0, r5
340123e2:	6a2b      	ldr	r3, [r5, #32]
340123e4:	4798      	blx	r3
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_READY_TO_BOOT);
340123e6:	2101      	movs	r1, #1
340123e8:	4628      	mov	r0, r5
340123ea:	f7ff fe3b 	bl	34012064 <VD55G1_WaitState>
  if (ret)
340123ee:	4604      	mov	r4, r0
340123f0:	2800      	cmp	r0, #0
340123f2:	d1d3      	bne.n	3401239c <VD55G1_Init+0x1c>
  ret = ctx->read32(ctx, VD55G1_REG_MODEL_ID, &reg32);
340123f4:	4601      	mov	r1, r0
340123f6:	68eb      	ldr	r3, [r5, #12]
340123f8:	4628      	mov	r0, r5
340123fa:	aa05      	add	r2, sp, #20
340123fc:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340123fe:	4604      	mov	r4, r0
34012400:	b9c0      	cbnz	r0, 34012434 <VD55G1_Init+0xb4>
  VD55G1_dbg(ctx, 0, "model_id = 0x%04x\n", reg32);
34012402:	9b05      	ldr	r3, [sp, #20]
34012404:	4a52      	ldr	r2, [pc, #328]	@ (34012550 <VD55G1_Init+0x1d0>)
34012406:	9301      	str	r3, [sp, #4]
34012408:	f240 1351 	movw	r3, #337	@ 0x151
3401240c:	2103      	movs	r1, #3
3401240e:	9300      	str	r3, [sp, #0]
34012410:	4603      	mov	r3, r0
34012412:	4628      	mov	r0, r5
34012414:	f7ff fdec 	bl	34011ff0 <VD55G1_log_impl>
  if (reg32 != VD55G1_MODEL_ID) {
34012418:	9a05      	ldr	r2, [sp, #20]
3401241a:	4b4e      	ldr	r3, [pc, #312]	@ (34012554 <VD55G1_Init+0x1d4>)
3401241c:	429a      	cmp	r2, r3
3401241e:	d018      	beq.n	34012452 <VD55G1_Init+0xd2>
    VD55G1_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD55G1_MODEL_ID, reg32);
34012420:	e9cd 3200 	strd	r3, r2, [sp]
34012424:	4621      	mov	r1, r4
34012426:	f240 1353 	movw	r3, #339	@ 0x153
3401242a:	4628      	mov	r0, r5
3401242c:	4a4a      	ldr	r2, [pc, #296]	@ (34012558 <VD55G1_Init+0x1d8>)
3401242e:	f7ff fddf 	bl	34011ff0 <VD55G1_log_impl>
  if (ret)
34012432:	e7b1      	b.n	34012398 <VD55G1_Init+0x18>
  VD55G1_TraceError(ctx, ret);
34012434:	f44f 73a8 	mov.w	r3, #336	@ 0x150
34012438:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401243a:	4a48      	ldr	r2, [pc, #288]	@ (3401255c <VD55G1_Init+0x1dc>)
3401243c:	9301      	str	r3, [sp, #4]
    VD55G1_TraceError(ctx, ret);
3401243e:	4628      	mov	r0, r5
34012440:	9200      	str	r2, [sp, #0]
34012442:	2100      	movs	r1, #0
34012444:	4a46      	ldr	r2, [pc, #280]	@ (34012560 <VD55G1_Init+0x1e0>)
34012446:	f7ff fdd3 	bl	34011ff0 <VD55G1_log_impl>
3401244a:	4628      	mov	r0, r5
3401244c:	f7ff fe2e 	bl	340120ac <display_error>
  if (ret)
34012450:	e7a4      	b.n	3401239c <VD55G1_Init+0x1c>
  ret = ctx->read16(ctx, VD55G1_REG_REVISION, &reg16);
34012452:	2104      	movs	r1, #4
34012454:	4628      	mov	r0, r5
34012456:	68ab      	ldr	r3, [r5, #8]
34012458:	f10d 0212 	add.w	r2, sp, #18
3401245c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401245e:	4604      	mov	r4, r0
34012460:	b9f0      	cbnz	r0, 340124a0 <VD55G1_Init+0x120>
  VD55G1_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
34012462:	f8bd 3012 	ldrh.w	r3, [sp, #18]
34012466:	4a3f      	ldr	r2, [pc, #252]	@ (34012564 <VD55G1_Init+0x1e4>)
34012468:	9301      	str	r3, [sp, #4]
3401246a:	f240 1359 	movw	r3, #345	@ 0x159
3401246e:	2103      	movs	r1, #3
34012470:	9300      	str	r3, [sp, #0]
34012472:	4603      	mov	r3, r0
34012474:	4628      	mov	r0, r5
34012476:	f7ff fdbb 	bl	34011ff0 <VD55G1_log_impl>
  switch (reg16) {
3401247a:	f241 0210 	movw	r2, #4112	@ 0x1010
3401247e:	f8bd 3012 	ldrh.w	r3, [sp, #18]
34012482:	4293      	cmp	r3, r2
34012484:	d010      	beq.n	340124a8 <VD55G1_Init+0x128>
34012486:	f242 0220 	movw	r2, #8224	@ 0x2020
3401248a:	4293      	cmp	r3, r2
3401248c:	d00c      	beq.n	340124a8 <VD55G1_Init+0x128>
    VD55G1_error(ctx, "Unsupported revision0x%04x\n", reg16);
3401248e:	9300      	str	r3, [sp, #0]
34012490:	4621      	mov	r1, r4
34012492:	f44f 73b1 	mov.w	r3, #354	@ 0x162
34012496:	4628      	mov	r0, r5
34012498:	4a33      	ldr	r2, [pc, #204]	@ (34012568 <VD55G1_Init+0x1e8>)
3401249a:	f7ff fda9 	bl	34011ff0 <VD55G1_log_impl>
  if (ret)
3401249e:	e77b      	b.n	34012398 <VD55G1_Init+0x18>
  VD55G1_TraceError(ctx, ret);
340124a0:	f44f 73ac 	mov.w	r3, #344	@ 0x158
340124a4:	9002      	str	r0, [sp, #8]
340124a6:	e7c8      	b.n	3401243a <VD55G1_Init+0xba>
    drv_ctx->cut_version = VD55G1_REVISION_CUT_1;
340124a8:	62eb      	str	r3, [r5, #44]	@ 0x2c
  ret = ctx->read32(ctx, VD55G1_REG_ROM_REVISION, &reg32);
340124aa:	2108      	movs	r1, #8
340124ac:	4628      	mov	r0, r5
340124ae:	68eb      	ldr	r3, [r5, #12]
340124b0:	aa05      	add	r2, sp, #20
340124b2:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340124b4:	4604      	mov	r4, r0
340124b6:	b9d0      	cbnz	r0, 340124ee <VD55G1_Init+0x16e>
  VD55G1_dbg(ctx, 0, "rom = 0x%04x\n", reg32);
340124b8:	9b05      	ldr	r3, [sp, #20]
340124ba:	4a2c      	ldr	r2, [pc, #176]	@ (3401256c <VD55G1_Init+0x1ec>)
340124bc:	9301      	str	r3, [sp, #4]
340124be:	f44f 73b4 	mov.w	r3, #360	@ 0x168
340124c2:	2103      	movs	r1, #3
340124c4:	9300      	str	r3, [sp, #0]
340124c6:	4603      	mov	r3, r0
340124c8:	4628      	mov	r0, r5
340124ca:	f7ff fd91 	bl	34011ff0 <VD55G1_log_impl>
  switch (drv_ctx->cut_version) {
340124ce:	f241 0210 	movw	r2, #4112	@ 0x1010
340124d2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
340124d4:	4293      	cmp	r3, r2
340124d6:	d00e      	beq.n	340124f6 <VD55G1_Init+0x176>
340124d8:	f242 0220 	movw	r2, #8224	@ 0x2020
340124dc:	4293      	cmp	r3, r2
340124de:	d02b      	beq.n	34012538 <VD55G1_Init+0x1b8>
    assert(0);
340124e0:	f44f 71cd 	mov.w	r1, #410	@ 0x19a
340124e4:	4b22      	ldr	r3, [pc, #136]	@ (34012570 <VD55G1_Init+0x1f0>)
340124e6:	4a23      	ldr	r2, [pc, #140]	@ (34012574 <VD55G1_Init+0x1f4>)
340124e8:	4823      	ldr	r0, [pc, #140]	@ (34012578 <VD55G1_Init+0x1f8>)
340124ea:	f005 fa59 	bl	340179a0 <__assert_func>
  VD55G1_TraceError(ctx, ret);
340124ee:	f240 1367 	movw	r3, #359	@ 0x167
340124f2:	9002      	str	r0, [sp, #8]
340124f4:	e7a1      	b.n	3401243a <VD55G1_Init+0xba>
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_1, sizeof(patch_array_cut_1),
340124f6:	2316      	movs	r3, #22
340124f8:	f241 22e4 	movw	r2, #4836	@ 0x12e4
340124fc:	9300      	str	r3, [sp, #0]
340124fe:	2301      	movs	r3, #1
34012500:	491e      	ldr	r1, [pc, #120]	@ (3401257c <VD55G1_Init+0x1fc>)
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
34012502:	4628      	mov	r0, r5
34012504:	f7ff fdf4 	bl	340120f0 <VD55G1_ApplyPatchCommon>
34012508:	4604      	mov	r4, r0
  if (ret)
3401250a:	2800      	cmp	r0, #0
3401250c:	f47f af46 	bne.w	3401239c <VD55G1_Init+0x1c>
34012510:	f240 561d 	movw	r6, #1309	@ 0x51d
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
34012514:	f240 5821 	movw	r8, #1313	@ 0x521
34012518:	f105 0763 	add.w	r7, r5, #99	@ 0x63
    ret = ctx->write8(ctx, VD55G1_REG_GPIO_x(i), drv_ctx->config_save.gpio_ctrl[i]);
3401251c:	4631      	mov	r1, r6
3401251e:	4628      	mov	r0, r5
34012520:	692b      	ldr	r3, [r5, #16]
34012522:	f817 2f01 	ldrb.w	r2, [r7, #1]!
34012526:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
34012528:	4604      	mov	r4, r0
3401252a:	b158      	cbz	r0, 34012544 <VD55G1_Init+0x1c4>
3401252c:	f240 13a9 	movw	r3, #425	@ 0x1a9
34012530:	4a13      	ldr	r2, [pc, #76]	@ (34012580 <VD55G1_Init+0x200>)
34012532:	9002      	str	r0, [sp, #8]
34012534:	9301      	str	r3, [sp, #4]
34012536:	e782      	b.n	3401243e <VD55G1_Init+0xbe>
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
34012538:	2302      	movs	r3, #2
3401253a:	f44f 7272 	mov.w	r2, #968	@ 0x3c8
3401253e:	4911      	ldr	r1, [pc, #68]	@ (34012584 <VD55G1_Init+0x204>)
34012540:	9300      	str	r3, [sp, #0]
34012542:	e7de      	b.n	34012502 <VD55G1_Init+0x182>
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
34012544:	3601      	adds	r6, #1
34012546:	b2b6      	uxth	r6, r6
34012548:	4546      	cmp	r6, r8
3401254a:	d1e7      	bne.n	3401251c <VD55G1_Init+0x19c>
  drv_ctx->state = VD55G1_ST_IDLE;
3401254c:	62a8      	str	r0, [r5, #40]	@ 0x28
  return 0;
3401254e:	e725      	b.n	3401239c <VD55G1_Init+0x1c>
34012550:	3401cc30 	.word	0x3401cc30
34012554:	53354731 	.word	0x53354731
34012558:	3401cc54 	.word	0x3401cc54
3401255c:	34035965 	.word	0x34035965
34012560:	3401cafa 	.word	0x3401cafa
34012564:	3401cc8f 	.word	0x3401cc8f
34012568:	3401ccb3 	.word	0x3401ccb3
3401256c:	3401ccdf 	.word	0x3401ccdf
34012570:	3401d306 	.word	0x3401d306
34012574:	34035945 	.word	0x34035945
34012578:	3401ca76 	.word	0x3401ca76
3401257c:	34035db4 	.word	0x34035db4
34012580:	34035920 	.word	0x34035920
34012584:	340359ec 	.word	0x340359ec

34012588 <VD55G1_DeInit>:

int VD55G1_DeInit(VD55G1_Ctx_t *ctx)
{
  struct drv_ctx *drv_ctx = &ctx->ctx;

  if (drv_ctx->state == VD55G1_ST_STREAMING)
34012588:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
3401258a:	b510      	push	{r4, lr}
  if (drv_ctx->state == VD55G1_ST_STREAMING)
3401258c:	2b01      	cmp	r3, #1
{
3401258e:	4604      	mov	r4, r0
  if (drv_ctx->state == VD55G1_ST_STREAMING)
34012590:	d008      	beq.n	340125a4 <VD55G1_DeInit+0x1c>
    return -1;

  ctx->shutdown_pin(ctx, 0);
34012592:	6803      	ldr	r3, [r0, #0]
34012594:	2100      	movs	r1, #0
34012596:	4798      	blx	r3
  ctx->delay(ctx, 10);
34012598:	4620      	mov	r0, r4
3401259a:	210a      	movs	r1, #10
3401259c:	6a23      	ldr	r3, [r4, #32]
3401259e:	4798      	blx	r3

  return 0;
340125a0:	2000      	movs	r0, #0
}
340125a2:	bd10      	pop	{r4, pc}
    return -1;
340125a4:	f04f 30ff 	mov.w	r0, #4294967295
340125a8:	e7fb      	b.n	340125a2 <VD55G1_DeInit+0x1a>
340125aa:	0000      	movs	r0, r0
340125ac:	0000      	movs	r0, r0
	...

340125b0 <VD55G1_Start>:

int VD55G1_Start(VD55G1_Ctx_t *ctx)
{
340125b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
340125b2:	6c43      	ldr	r3, [r0, #68]	@ 0x44
340125b4:	4e8a      	ldr	r6, [pc, #552]	@ (340127e0 <VD55G1_Start+0x230>)
340125b6:	4a8b      	ldr	r2, [pc, #556]	@ (340127e4 <VD55G1_Start+0x234>)
340125b8:	4433      	add	r3, r6
340125ba:	4293      	cmp	r3, r2
{
340125bc:	4605      	mov	r5, r0
340125be:	b087      	sub	sp, #28
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
340125c0:	d87e      	bhi.n	340126c0 <VD55G1_Start+0x110>
  ret = ctx->write32(ctx, VD55G1_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
340125c2:	f44f 7108 	mov.w	r1, #544	@ 0x220
340125c6:	6983      	ldr	r3, [r0, #24]
340125c8:	6b42      	ldr	r2, [r0, #52]	@ 0x34
340125ca:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340125cc:	4604      	mov	r4, r0
340125ce:	b958      	cbnz	r0, 340125e8 <VD55G1_Start+0x38>
  ret = ctx->write32(ctx, VD55G1_REG_MIPI_DATA_RATE, drv_ctx->config_save.out_itf.data_rate_in_mps);
340125d0:	f44f 7109 	mov.w	r1, #548	@ 0x224
340125d4:	4628      	mov	r0, r5
340125d6:	69ab      	ldr	r3, [r5, #24]
340125d8:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
340125da:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340125dc:	4604      	mov	r4, r0
340125de:	b300      	cbz	r0, 34012622 <VD55G1_Start+0x72>
340125e0:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
340125e4:	9002      	str	r0, [sp, #8]
340125e6:	e002      	b.n	340125ee <VD55G1_Start+0x3e>
  VD55G1_TraceError(ctx, ret);
340125e8:	f240 13f5 	movw	r3, #501	@ 0x1f5
340125ec:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340125ee:	4a7e      	ldr	r2, [pc, #504]	@ (340127e8 <VD55G1_Start+0x238>)
340125f0:	4628      	mov	r0, r5
340125f2:	9200      	str	r2, [sp, #0]
340125f4:	2100      	movs	r1, #0
340125f6:	4a7d      	ldr	r2, [pc, #500]	@ (340127ec <VD55G1_Start+0x23c>)
340125f8:	9301      	str	r3, [sp, #4]
340125fa:	f7ff fcf9 	bl	34011ff0 <VD55G1_log_impl>
340125fe:	4628      	mov	r0, r5
34012600:	f7ff fd54 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
34012604:	f240 23fe 	movw	r3, #766	@ 0x2fe
34012608:	9402      	str	r4, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401260a:	4a79      	ldr	r2, [pc, #484]	@ (340127f0 <VD55G1_Start+0x240>)
3401260c:	9301      	str	r3, [sp, #4]
  VD55G1_TraceError(ctx, ret);
3401260e:	4628      	mov	r0, r5
34012610:	9200      	str	r2, [sp, #0]
34012612:	2100      	movs	r1, #0
34012614:	4a75      	ldr	r2, [pc, #468]	@ (340127ec <VD55G1_Start+0x23c>)
34012616:	f7ff fceb 	bl	34011ff0 <VD55G1_log_impl>
3401261a:	4628      	mov	r0, r5
3401261c:	f7ff fd46 	bl	340120ac <display_error>
  ret = VD55G1_Setup(ctx);
  if (ret)
    return ret;

  ret = VD55G1_StartStreaming(ctx);
  if (ret)
34012620:	e233      	b.n	34012a8a <VD55G1_Start+0x4da>
  ret = ctx->read32(ctx, VD55G1_REG_MIPI_DATA_RATE, &mipi_data_rate);
34012622:	f44f 7109 	mov.w	r1, #548	@ 0x224
34012626:	4628      	mov	r0, r5
34012628:	68eb      	ldr	r3, [r5, #12]
3401262a:	aa05      	add	r2, sp, #20
3401262c:	4798      	blx	r3
  if (ret)
3401262e:	2800      	cmp	r0, #0
34012630:	d144      	bne.n	340126bc <VD55G1_Start+0x10c>
  if (mipi_data_rate <= 1200000000 && mipi_data_rate > 600000000)
34012632:	9b05      	ldr	r3, [sp, #20]
34012634:	4a6f      	ldr	r2, [pc, #444]	@ (340127f4 <VD55G1_Start+0x244>)
34012636:	4970      	ldr	r1, [pc, #448]	@ (340127f8 <VD55G1_Start+0x248>)
34012638:	441a      	add	r2, r3
3401263a:	428a      	cmp	r2, r1
3401263c:	496f      	ldr	r1, [pc, #444]	@ (340127fc <VD55G1_Start+0x24c>)
3401263e:	d904      	bls.n	3401264a <VD55G1_Start+0x9a>
  else if (mipi_data_rate <= 600000000 && mipi_data_rate > 300000000)
34012640:	4a6f      	ldr	r2, [pc, #444]	@ (34012800 <VD55G1_Start+0x250>)
34012642:	441a      	add	r2, r3
34012644:	428a      	cmp	r2, r1
34012646:	d80e      	bhi.n	34012666 <VD55G1_Start+0xb6>
    return mipi_data_rate * 2;
34012648:	005b      	lsls	r3, r3, #1
  if (system_clk <= 1200000000 && system_clk > 900000000)
3401264a:	4a6e      	ldr	r2, [pc, #440]	@ (34012804 <VD55G1_Start+0x254>)
3401264c:	441a      	add	r2, r3
3401264e:	428a      	cmp	r2, r1
34012650:	d90e      	bls.n	34012670 <VD55G1_Start+0xc0>
  else if (system_clk <= 900000000 && system_clk > 780000000)
34012652:	4a6d      	ldr	r2, [pc, #436]	@ (34012808 <VD55G1_Start+0x258>)
34012654:	496d      	ldr	r1, [pc, #436]	@ (3401280c <VD55G1_Start+0x25c>)
34012656:	441a      	add	r2, r3
34012658:	428a      	cmp	r2, r1
    return system_clk / 6;
3401265a:	bf94      	ite	ls
3401265c:	2206      	movls	r2, #6
    return system_clk / 5;
3401265e:	2205      	movhi	r2, #5
34012660:	fbb3 f3f2 	udiv	r3, r3, r2
  if (!drv_ctx->pclk)
34012664:	e005      	b.n	34012672 <VD55G1_Start+0xc2>
  else if (mipi_data_rate <= 300000000 && mipi_data_rate >= 250000000)
34012666:	4a6a      	ldr	r2, [pc, #424]	@ (34012810 <VD55G1_Start+0x260>)
34012668:	441e      	add	r6, r3
3401266a:	4296      	cmp	r6, r2
3401266c:	d826      	bhi.n	340126bc <VD55G1_Start+0x10c>
    return mipi_data_rate * 4;
3401266e:	009b      	lsls	r3, r3, #2
    return system_clk / 8;
34012670:	08db      	lsrs	r3, r3, #3
  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
34012672:	632b      	str	r3, [r5, #48]	@ 0x30
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34012674:	6cab      	ldr	r3, [r5, #72]	@ 0x48
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
34012676:	2208      	movs	r2, #8
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
34012678:	3b00      	subs	r3, #0
3401267a:	bf18      	it	ne
3401267c:	2301      	movne	r3, #1
3401267e:	64ab      	str	r3, [r5, #72]	@ 0x48
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
34012680:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
34012682:	f240 310a 	movw	r1, #778	@ 0x30a
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
34012686:	3b00      	subs	r3, #0
34012688:	bf18      	it	ne
3401268a:	2301      	movne	r3, #1
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
3401268c:	4628      	mov	r0, r5
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
3401268e:	64eb      	str	r3, [r5, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
34012690:	692b      	ldr	r3, [r5, #16]
34012692:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012694:	4604      	mov	r4, r0
34012696:	b1b0      	cbz	r0, 340126c6 <VD55G1_Start+0x116>
34012698:	f240 230d 	movw	r3, #525	@ 0x20d
3401269c:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401269e:	4a5d      	ldr	r2, [pc, #372]	@ (34012814 <VD55G1_Start+0x264>)
340126a0:	9301      	str	r3, [sp, #4]
340126a2:	2100      	movs	r1, #0
340126a4:	4628      	mov	r0, r5
340126a6:	9200      	str	r2, [sp, #0]
340126a8:	4a50      	ldr	r2, [pc, #320]	@ (340127ec <VD55G1_Start+0x23c>)
340126aa:	f7ff fca1 	bl	34011ff0 <VD55G1_log_impl>
340126ae:	4628      	mov	r0, r5
340126b0:	f7ff fcfc 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
340126b4:	f240 3301 	movw	r3, #769	@ 0x301
340126b8:	9402      	str	r4, [sp, #8]
340126ba:	e7a6      	b.n	3401260a <VD55G1_Start+0x5a>
  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
340126bc:	2300      	movs	r3, #0
340126be:	632b      	str	r3, [r5, #48]	@ 0x30
    return -1;
340126c0:	f04f 34ff 	mov.w	r4, #4294967295
340126c4:	e79e      	b.n	34012604 <VD55G1_Start+0x54>
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
340126c6:	e9d5 2312 	ldrd	r2, r3, [r5, #72]	@ 0x48
340126ca:	00d2      	lsls	r2, r2, #3
340126cc:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
  ret = ctx->write16(ctx, VD55G1_REG_OIF_CTRL, oif_ctrl);
340126d0:	f44f 7143 	mov.w	r1, #780	@ 0x30c
340126d4:	4628      	mov	r0, r5
340126d6:	696b      	ldr	r3, [r5, #20]
340126d8:	b292      	uxth	r2, r2
340126da:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340126dc:	4604      	mov	r4, r0
340126de:	b958      	cbnz	r0, 340126f8 <VD55G1_Start+0x148>
  ret = ctx->write8(ctx, VD55G1_REG_OIF_IMG_CTRL, 0x2a);
340126e0:	222a      	movs	r2, #42	@ 0x2a
340126e2:	f240 310f 	movw	r1, #783	@ 0x30f
340126e6:	4628      	mov	r0, r5
340126e8:	692b      	ldr	r3, [r5, #16]
340126ea:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340126ec:	4604      	mov	r4, r0
340126ee:	b138      	cbz	r0, 34012700 <VD55G1_Start+0x150>
340126f0:	f240 2317 	movw	r3, #535	@ 0x217
340126f4:	9002      	str	r0, [sp, #8]
340126f6:	e7d2      	b.n	3401269e <VD55G1_Start+0xee>
  VD55G1_TraceError(ctx, ret);
340126f8:	f240 2313 	movw	r3, #531	@ 0x213
340126fc:	9002      	str	r0, [sp, #8]
340126fe:	e7ce      	b.n	3401269e <VD55G1_Start+0xee>
  mode = VD55G1_Resolution2Mode(drv_ctx->config_save.resolution);
34012700:	f895 3038 	ldrb.w	r3, [r5, #56]	@ 0x38
  switch (resolution) {
34012704:	2b03      	cmp	r3, #3
34012706:	f200 8102 	bhi.w	3401290e <VD55G1_Start+0x35e>
3401270a:	4a43      	ldr	r2, [pc, #268]	@ (34012818 <VD55G1_Start+0x268>)
3401270c:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
  if (!mode)
34012710:	2e00      	cmp	r6, #0
34012712:	f000 80fc 	beq.w	3401290e <VD55G1_Start+0x35e>
  ret = ctx->write8(ctx, VD55G1_REG_READOUT_CTRL, mode->bin_mode);
34012716:	f240 512e 	movw	r1, #1326	@ 0x52e
3401271a:	4628      	mov	r0, r5
3401271c:	692b      	ldr	r3, [r5, #16]
3401271e:	7a32      	ldrb	r2, [r6, #8]
34012720:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012722:	4604      	mov	r4, r0
34012724:	b188      	cbz	r0, 3401274a <VD55G1_Start+0x19a>
34012726:	f240 2327 	movw	r3, #551	@ 0x227
3401272a:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
3401272c:	4a3b      	ldr	r2, [pc, #236]	@ (3401281c <VD55G1_Start+0x26c>)
3401272e:	4628      	mov	r0, r5
34012730:	9200      	str	r2, [sp, #0]
34012732:	2100      	movs	r1, #0
34012734:	4a2d      	ldr	r2, [pc, #180]	@ (340127ec <VD55G1_Start+0x23c>)
34012736:	9301      	str	r3, [sp, #4]
34012738:	f7ff fc5a 	bl	34011ff0 <VD55G1_log_impl>
3401273c:	4628      	mov	r0, r5
3401273e:	f7ff fcb5 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
34012742:	f44f 7341 	mov.w	r3, #772	@ 0x304
34012746:	9402      	str	r4, [sp, #8]
34012748:	e75f      	b.n	3401260a <VD55G1_Start+0x5a>
  ret = ctx->write16(ctx, VD55G1_REG_X_START, mode->crop.left);
3401274a:	f240 5114 	movw	r1, #1300	@ 0x514
3401274e:	4628      	mov	r0, r5
34012750:	696b      	ldr	r3, [r5, #20]
34012752:	89b2      	ldrh	r2, [r6, #12]
34012754:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012756:	4604      	mov	r4, r0
34012758:	b958      	cbnz	r0, 34012772 <VD55G1_Start+0x1c2>
  ret = ctx->write16(ctx, VD55G1_REG_X_WIDTH, mode->crop.width);
3401275a:	f240 5116 	movw	r1, #1302	@ 0x516
3401275e:	4628      	mov	r0, r5
34012760:	696b      	ldr	r3, [r5, #20]
34012762:	8ab2      	ldrh	r2, [r6, #20]
34012764:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012766:	4604      	mov	r4, r0
34012768:	b138      	cbz	r0, 3401277a <VD55G1_Start+0x1ca>
3401276a:	f44f 730b 	mov.w	r3, #556	@ 0x22c
3401276e:	9002      	str	r0, [sp, #8]
34012770:	e7dc      	b.n	3401272c <VD55G1_Start+0x17c>
  VD55G1_TraceError(ctx, ret);
34012772:	f240 232a 	movw	r3, #554	@ 0x22a
34012776:	9002      	str	r0, [sp, #8]
34012778:	e7d8      	b.n	3401272c <VD55G1_Start+0x17c>
  ret = ctx->write16(ctx, VD55G1_REG_Y_START, mode->crop.top);
3401277a:	f44f 61a2 	mov.w	r1, #1296	@ 0x510
3401277e:	4628      	mov	r0, r5
34012780:	696b      	ldr	r3, [r5, #20]
34012782:	8a32      	ldrh	r2, [r6, #16]
34012784:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012786:	4604      	mov	r4, r0
34012788:	b118      	cbz	r0, 34012792 <VD55G1_Start+0x1e2>
3401278a:	f240 232e 	movw	r3, #558	@ 0x22e
3401278e:	9002      	str	r0, [sp, #8]
34012790:	e7cc      	b.n	3401272c <VD55G1_Start+0x17c>
  ret = ctx->write16(ctx, VD55G1_REG_Y_HEIGHT, mode->crop.height);
34012792:	f240 5112 	movw	r1, #1298	@ 0x512
34012796:	4628      	mov	r0, r5
34012798:	696b      	ldr	r3, [r5, #20]
3401279a:	8b32      	ldrh	r2, [r6, #24]
3401279c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
3401279e:	4604      	mov	r4, r0
340127a0:	b118      	cbz	r0, 340127aa <VD55G1_Start+0x1fa>
340127a2:	f44f 730c 	mov.w	r3, #560	@ 0x230
340127a6:	9002      	str	r0, [sp, #8]
340127a8:	e7c0      	b.n	3401272c <VD55G1_Start+0x17c>
  ret = ctx->read16(ctx, VD55G1_REG_X_WIDTH, &width);
340127aa:	f240 5116 	movw	r1, #1302	@ 0x516
340127ae:	4628      	mov	r0, r5
340127b0:	68ab      	ldr	r3, [r5, #8]
340127b2:	aa05      	add	r2, sp, #20
340127b4:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340127b6:	4604      	mov	r4, r0
340127b8:	b3a0      	cbz	r0, 34012824 <VD55G1_Start+0x274>
340127ba:	f240 233e 	movw	r3, #574	@ 0x23e
340127be:	9002      	str	r0, [sp, #8]
340127c0:	4a17      	ldr	r2, [pc, #92]	@ (34012820 <VD55G1_Start+0x270>)
340127c2:	9301      	str	r3, [sp, #4]
340127c4:	4628      	mov	r0, r5
340127c6:	9200      	str	r2, [sp, #0]
340127c8:	2100      	movs	r1, #0
340127ca:	4a08      	ldr	r2, [pc, #32]	@ (340127ec <VD55G1_Start+0x23c>)
340127cc:	f7ff fc10 	bl	34011ff0 <VD55G1_log_impl>
340127d0:	4628      	mov	r0, r5
340127d2:	f7ff fc6b 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
340127d6:	f240 3307 	movw	r3, #775	@ 0x307
340127da:	9402      	str	r4, [sp, #8]
340127dc:	e715      	b.n	3401260a <VD55G1_Start+0x5a>
340127de:	bf00      	nop
340127e0:	f1194d80 	.word	0xf1194d80
340127e4:	389fd980 	.word	0x389fd980
340127e8:	34035900 	.word	0x34035900
340127ec:	3401cafa 	.word	0x3401cafa
340127f0:	34035913 	.word	0x34035913
340127f4:	dc3cb9ff 	.word	0xdc3cb9ff
340127f8:	23c345ff 	.word	0x23c345ff
340127fc:	11e1a2ff 	.word	0x11e1a2ff
34012800:	ee1e5cff 	.word	0xee1e5cff
34012804:	ca5b16ff 	.word	0xca5b16ff
34012808:	d18224ff 	.word	0xd18224ff
3401280c:	07270dff 	.word	0x07270dff
34012810:	02faf080 	.word	0x02faf080
34012814:	340358ed 	.word	0x340358ed
34012818:	3403580c 	.word	0x3403580c
3401281c:	340358dc 	.word	0x340358dc
34012820:	340358b2 	.word	0x340358b2
  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
34012824:	f8bd 1014 	ldrh.w	r1, [sp, #20]
34012828:	6b28      	ldr	r0, [r5, #48]	@ 0x30
3401282a:	00c9      	lsls	r1, r1, #3
3401282c:	f501 7161 	add.w	r1, r1, #900	@ 0x384
                      / VD55G1_MIPI_DATA_RATE_HZ;
34012830:	a3a3      	add	r3, pc, #652	@ (adr r3, 34012ac0 <VD55G1_Start+0x510>)
34012832:	e9d3 2300 	ldrd	r2, r3, [r3]
34012836:	fba1 0100 	umull	r0, r1, r1, r0
3401283a:	f7ee fecf 	bl	340015dc <__aeabi_uldivmod>
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
3401283e:	f5b0 6f8d 	cmp.w	r0, #1128	@ 0x468
34012842:	bfb8      	it	lt
34012844:	f44f 608d 	movlt.w	r0, #1128	@ 0x468
  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
34012848:	f44f 7140 	mov.w	r1, #768	@ 0x300
3401284c:	b282      	uxth	r2, r0
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
3401284e:	4606      	mov	r6, r0
  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
34012850:	696b      	ldr	r3, [r5, #20]
34012852:	4628      	mov	r0, r5
34012854:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012856:	4604      	mov	r4, r0
34012858:	2800      	cmp	r0, #0
3401285a:	d14e      	bne.n	340128fa <VD55G1_Start+0x34a>
  VD55G1_dbg(ctx, 1, "line_length = %d\n", line_len);
3401285c:	f240 2346 	movw	r3, #582	@ 0x246
34012860:	b2b6      	uxth	r6, r6
34012862:	2104      	movs	r1, #4
34012864:	4628      	mov	r0, r5
34012866:	4a8a      	ldr	r2, [pc, #552]	@ (34012a90 <VD55G1_Start+0x4e0>)
34012868:	9300      	str	r3, [sp, #0]
3401286a:	9601      	str	r6, [sp, #4]
3401286c:	2301      	movs	r3, #1
3401286e:	f7ff fbbf 	bl	34011ff0 <VD55G1_log_impl>
  ret = VD55G1_ComputeFrameLength(ctx, drv_ctx->config_save.frame_rate, &frame_length);
34012872:	4628      	mov	r0, r5
34012874:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
34012876:	aa05      	add	r2, sp, #20
34012878:	f7ff fcc8 	bl	3401220c <VD55G1_ComputeFrameLength>
  if (ret)
3401287c:	4604      	mov	r4, r0
3401287e:	2800      	cmp	r0, #0
34012880:	d1a9      	bne.n	340127d6 <VD55G1_Start+0x226>
  VD55G1_dbg(ctx, 1, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
34012882:	f8bd 4014 	ldrh.w	r4, [sp, #20]
34012886:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
34012888:	2104      	movs	r1, #4
3401288a:	e9cd 4301 	strd	r4, r3, [sp, #4]
3401288e:	f240 2372 	movw	r3, #626	@ 0x272
34012892:	4628      	mov	r0, r5
34012894:	4a7f      	ldr	r2, [pc, #508]	@ (34012a94 <VD55G1_Start+0x4e4>)
34012896:	9300      	str	r3, [sp, #0]
34012898:	2301      	movs	r3, #1
3401289a:	f7ff fba9 	bl	34011ff0 <VD55G1_log_impl>
  ret = ctx->write16(ctx, VD55G1_REG_FRAME_LENGTH, frame_length);
3401289e:	4622      	mov	r2, r4
340128a0:	f240 510c 	movw	r1, #1292	@ 0x50c
340128a4:	4628      	mov	r0, r5
340128a6:	696b      	ldr	r3, [r5, #20]
340128a8:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340128aa:	4604      	mov	r4, r0
340128ac:	bb48      	cbnz	r0, 34012902 <VD55G1_Start+0x352>
  if (awu->is_enable)
340128ae:	6d2b      	ldr	r3, [r5, #80]	@ 0x50
  max_fps = drv_ctx->config_save.frame_rate;
340128b0:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
  if (awu->is_enable)
340128b2:	bb7b      	cbnz	r3, 34012914 <VD55G1_Start+0x364>
  ret = VD55G1_ComputeFrameLength(ctx, max_fps, &frame_length);
340128b4:	4628      	mov	r0, r5
340128b6:	aa05      	add	r2, sp, #20
340128b8:	f7ff fca8 	bl	3401220c <VD55G1_ComputeFrameLength>
  if (ret)
340128bc:	4604      	mov	r4, r0
340128be:	b9c0      	cbnz	r0, 340128f2 <VD55G1_Start+0x342>
  ret = ctx->write16(ctx, VD55G1_REG_MAX_COARSE_INTEGRATION_LINES, frame_length - 10);
340128c0:	f8bd 6014 	ldrh.w	r6, [sp, #20]
340128c4:	f240 3172 	movw	r1, #882	@ 0x372
340128c8:	3e0a      	subs	r6, #10
340128ca:	4628      	mov	r0, r5
340128cc:	696b      	ldr	r3, [r5, #20]
340128ce:	b2b2      	uxth	r2, r6
340128d0:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
340128d2:	4604      	mov	r4, r0
340128d4:	b338      	cbz	r0, 34012926 <VD55G1_Start+0x376>
340128d6:	f240 238f 	movw	r3, #655	@ 0x28f
340128da:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340128dc:	4a6e      	ldr	r2, [pc, #440]	@ (34012a98 <VD55G1_Start+0x4e8>)
340128de:	4628      	mov	r0, r5
340128e0:	9200      	str	r2, [sp, #0]
340128e2:	2100      	movs	r1, #0
340128e4:	4a6d      	ldr	r2, [pc, #436]	@ (34012a9c <VD55G1_Start+0x4ec>)
340128e6:	9301      	str	r3, [sp, #4]
340128e8:	f7ff fb82 	bl	34011ff0 <VD55G1_log_impl>
340128ec:	4628      	mov	r0, r5
340128ee:	f7ff fbdd 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
340128f2:	f240 330a 	movw	r3, #778	@ 0x30a
340128f6:	9402      	str	r4, [sp, #8]
340128f8:	e687      	b.n	3401260a <VD55G1_Start+0x5a>
  VD55G1_TraceError(ctx, ret);
340128fa:	f240 2345 	movw	r3, #581	@ 0x245
340128fe:	9002      	str	r0, [sp, #8]
34012900:	e75e      	b.n	340127c0 <VD55G1_Start+0x210>
  VD55G1_TraceError(ctx, ret);
34012902:	f44f 731d 	mov.w	r3, #628	@ 0x274
34012906:	4a66      	ldr	r2, [pc, #408]	@ (34012aa0 <VD55G1_Start+0x4f0>)
34012908:	9002      	str	r0, [sp, #8]
3401290a:	9301      	str	r3, [sp, #4]
3401290c:	e75a      	b.n	340127c4 <VD55G1_Start+0x214>
3401290e:	f04f 34ff 	mov.w	r4, #4294967295
34012912:	e716      	b.n	34012742 <VD55G1_Start+0x192>
    max_fps = MAX(max_fps, awu->convergence_frame_rate);
34012914:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
34012916:	4299      	cmp	r1, r3
34012918:	bfb8      	it	lt
3401291a:	4619      	movlt	r1, r3
    max_fps = MAX(max_fps, awu->awu_frame_rate);
3401291c:	6dab      	ldr	r3, [r5, #88]	@ 0x58
3401291e:	4299      	cmp	r1, r3
34012920:	bfb8      	it	lt
34012922:	4619      	movlt	r1, r3
34012924:	e7c6      	b.n	340128b4 <VD55G1_Start+0x304>
  VD55G1_dbg(ctx, 1, "Max coarse lines = %d\n", frame_length - 10);
34012926:	f44f 7324 	mov.w	r3, #656	@ 0x290
3401292a:	2104      	movs	r1, #4
3401292c:	4628      	mov	r0, r5
3401292e:	4a5d      	ldr	r2, [pc, #372]	@ (34012aa4 <VD55G1_Start+0x4f4>)
34012930:	9300      	str	r3, [sp, #0]
34012932:	9601      	str	r6, [sp, #4]
34012934:	2301      	movs	r3, #1
34012936:	f7ff fb5b 	bl	34011ff0 <VD55G1_log_impl>
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
3401293a:	f895 2041 	ldrb.w	r2, [r5, #65]	@ 0x41
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
3401293e:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
34012942:	3a00      	subs	r2, #0
34012944:	bf18      	it	ne
34012946:	2201      	movne	r2, #1
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
34012948:	4628      	mov	r0, r5
3401294a:	692b      	ldr	r3, [r5, #16]
3401294c:	0052      	lsls	r2, r2, #1
3401294e:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012950:	4604      	mov	r4, r0
34012952:	b118      	cbz	r0, 3401295c <VD55G1_Start+0x3ac>
34012954:	f240 2395 	movw	r3, #661	@ 0x295
34012958:	9002      	str	r0, [sp, #8]
3401295a:	e7bf      	b.n	340128dc <VD55G1_Start+0x32c>
  switch (drv_ctx->config_save.flip_mirror_mode) {
3401295c:	f895 3040 	ldrb.w	r3, [r5, #64]	@ 0x40
34012960:	2b03      	cmp	r3, #3
34012962:	d905      	bls.n	34012970 <VD55G1_Start+0x3c0>
    return -1;
34012964:	f04f 34ff 	mov.w	r4, #4294967295
  VD55G1_TraceError(ctx, ret);
34012968:	f240 330d 	movw	r3, #781	@ 0x30d
3401296c:	9402      	str	r4, [sp, #8]
3401296e:	e64c      	b.n	3401260a <VD55G1_Start+0x5a>
  ret = ctx->write8(ctx, VD55G1_REG_ORIENTATION, mode);
34012970:	4a4d      	ldr	r2, [pc, #308]	@ (34012aa8 <VD55G1_Start+0x4f8>)
34012972:	692c      	ldr	r4, [r5, #16]
34012974:	f240 3102 	movw	r1, #770	@ 0x302
34012978:	4628      	mov	r0, r5
3401297a:	5cd2      	ldrb	r2, [r2, r3]
3401297c:	47a0      	blx	r4
  VD55G1_TraceError(ctx, ret);
3401297e:	4604      	mov	r4, r0
34012980:	b948      	cbnz	r0, 34012996 <VD55G1_Start+0x3e6>
  switch (drv_ctx->config_save.patgen) {
34012982:	f895 3041 	ldrb.w	r3, [r5, #65]	@ 0x41
34012986:	2b02      	cmp	r3, #2
34012988:	d914      	bls.n	340129b4 <VD55G1_Start+0x404>
    return -1;
3401298a:	f04f 34ff 	mov.w	r4, #4294967295
  VD55G1_TraceError(ctx, ret);
3401298e:	f44f 7344 	mov.w	r3, #784	@ 0x310
34012992:	9402      	str	r4, [sp, #8]
34012994:	e639      	b.n	3401260a <VD55G1_Start+0x5a>
  VD55G1_TraceError(ctx, ret);
34012996:	f240 23b2 	movw	r3, #690	@ 0x2b2
3401299a:	4a44      	ldr	r2, [pc, #272]	@ (34012aac <VD55G1_Start+0x4fc>)
3401299c:	9002      	str	r0, [sp, #8]
3401299e:	9200      	str	r2, [sp, #0]
340129a0:	4628      	mov	r0, r5
340129a2:	2100      	movs	r1, #0
340129a4:	4a3d      	ldr	r2, [pc, #244]	@ (34012a9c <VD55G1_Start+0x4ec>)
340129a6:	9301      	str	r3, [sp, #4]
340129a8:	f7ff fb22 	bl	34011ff0 <VD55G1_log_impl>
340129ac:	4628      	mov	r0, r5
340129ae:	f7ff fb7d 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
340129b2:	e7d9      	b.n	34012968 <VD55G1_Start+0x3b8>
340129b4:	4a3e      	ldr	r2, [pc, #248]	@ (34012ab0 <VD55G1_Start+0x500>)
340129b6:	f832 6013 	ldrh.w	r6, [r2, r3, lsl #1]
  if (drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE)
340129ba:	b313      	cbz	r3, 34012a02 <VD55G1_Start+0x452>
    ret = ctx->write8(ctx, VD55G1_REG_DUSTER_CTRL, VD55G1_DUSTER_DISABLE);
340129bc:	4602      	mov	r2, r0
340129be:	f240 31ae 	movw	r1, #942	@ 0x3ae
340129c2:	4628      	mov	r0, r5
340129c4:	692b      	ldr	r3, [r5, #16]
340129c6:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
340129c8:	4604      	mov	r4, r0
340129ca:	b170      	cbz	r0, 340129ea <VD55G1_Start+0x43a>
340129cc:	f240 23ce 	movw	r3, #718	@ 0x2ce
340129d0:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
340129d2:	4a38      	ldr	r2, [pc, #224]	@ (34012ab4 <VD55G1_Start+0x504>)
340129d4:	4628      	mov	r0, r5
340129d6:	9200      	str	r2, [sp, #0]
340129d8:	2100      	movs	r1, #0
340129da:	4a30      	ldr	r2, [pc, #192]	@ (34012a9c <VD55G1_Start+0x4ec>)
340129dc:	9301      	str	r3, [sp, #4]
340129de:	f7ff fb07 	bl	34011ff0 <VD55G1_log_impl>
340129e2:	4628      	mov	r0, r5
340129e4:	f7ff fb62 	bl	340120ac <display_error>
  VD55G1_TraceError(ctx, ret);
340129e8:	e7d1      	b.n	3401298e <VD55G1_Start+0x3de>
    ret = ctx->write8(ctx, VD55G1_REG_DARKCAL_CTRL, VD55G1_DARKCAL_BYPASS_DARKAVG);
340129ea:	2202      	movs	r2, #2
340129ec:	f240 312a 	movw	r1, #810	@ 0x32a
340129f0:	4628      	mov	r0, r5
340129f2:	692b      	ldr	r3, [r5, #16]
340129f4:	4798      	blx	r3
    VD55G1_TraceError(ctx, ret);
340129f6:	4604      	mov	r4, r0
340129f8:	b118      	cbz	r0, 34012a02 <VD55G1_Start+0x452>
340129fa:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
340129fe:	9002      	str	r0, [sp, #8]
34012a00:	e7e7      	b.n	340129d2 <VD55G1_Start+0x422>
  ret = ctx->write16(ctx, VD55G1_REG_PATGEN_CTRL, value);
34012a02:	4632      	mov	r2, r6
34012a04:	f44f 7141 	mov.w	r1, #772	@ 0x304
34012a08:	4628      	mov	r0, r5
34012a0a:	696b      	ldr	r3, [r5, #20]
34012a0c:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012a0e:	4604      	mov	r4, r0
34012a10:	b118      	cbz	r0, 34012a1a <VD55G1_Start+0x46a>
34012a12:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
34012a16:	9002      	str	r0, [sp, #8]
34012a18:	e7db      	b.n	340129d2 <VD55G1_Start+0x422>
  return VD55G1_SetFlicker(ctx, drv_ctx->config_save.flicker);
34012a1a:	4628      	mov	r0, r5
34012a1c:	f895 1042 	ldrb.w	r1, [r5, #66]	@ 0x42
34012a20:	f7ff fc46 	bl	340122b0 <VD55G1_SetFlicker>
  VD55G1_TraceError(ctx, ret);
34012a24:	4604      	mov	r4, r0
34012a26:	b118      	cbz	r0, 34012a30 <VD55G1_Start+0x480>
34012a28:	f240 3313 	movw	r3, #787	@ 0x313
34012a2c:	9002      	str	r0, [sp, #8]
34012a2e:	e5ec      	b.n	3401260a <VD55G1_Start+0x5a>
  ret = ctx->write8(ctx, VD55G1_REG_STBY, VD55G1_STBY_START_STREAM);
34012a30:	2201      	movs	r2, #1
34012a32:	f240 2101 	movw	r1, #513	@ 0x201
34012a36:	4628      	mov	r0, r5
34012a38:	692b      	ldr	r3, [r5, #16]
34012a3a:	4798      	blx	r3
  VD55G1_TraceError(ctx, ret);
34012a3c:	4604      	mov	r4, r0
34012a3e:	b128      	cbz	r0, 34012a4c <VD55G1_Start+0x49c>
34012a40:	f240 331d 	movw	r3, #797	@ 0x31d
34012a44:	9002      	str	r0, [sp, #8]
  VD55G1_TraceError(ctx, ret);
34012a46:	4a1c      	ldr	r2, [pc, #112]	@ (34012ab8 <VD55G1_Start+0x508>)
34012a48:	9301      	str	r3, [sp, #4]
34012a4a:	e5e0      	b.n	3401260e <VD55G1_Start+0x5e>
  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STBY, VD55G1_CMD_ACK);
34012a4c:	4602      	mov	r2, r0
34012a4e:	f240 2101 	movw	r1, #513	@ 0x201
34012a52:	4628      	mov	r0, r5
34012a54:	f7ff fada 	bl	3401200c <VD55G1_PollReg8>
  VD55G1_TraceError(ctx, ret);
34012a58:	4604      	mov	r4, r0
34012a5a:	b948      	cbnz	r0, 34012a70 <VD55G1_Start+0x4c0>
  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_STREAMING);
34012a5c:	2103      	movs	r1, #3
34012a5e:	4628      	mov	r0, r5
34012a60:	f7ff fb00 	bl	34012064 <VD55G1_WaitState>
  VD55G1_TraceError(ctx, ret);
34012a64:	4604      	mov	r4, r0
34012a66:	b138      	cbz	r0, 34012a78 <VD55G1_Start+0x4c8>
34012a68:	f240 3323 	movw	r3, #803	@ 0x323
34012a6c:	9002      	str	r0, [sp, #8]
34012a6e:	e7ea      	b.n	34012a46 <VD55G1_Start+0x496>
  VD55G1_TraceError(ctx, ret);
34012a70:	f44f 7348 	mov.w	r3, #800	@ 0x320
34012a74:	9002      	str	r0, [sp, #8]
34012a76:	e7e6      	b.n	34012a46 <VD55G1_Start+0x496>
  VD55G1_notice(ctx, "Streaming is on\n");
34012a78:	f240 3325 	movw	r3, #805	@ 0x325
34012a7c:	2102      	movs	r1, #2
34012a7e:	4628      	mov	r0, r5
34012a80:	4a0e      	ldr	r2, [pc, #56]	@ (34012abc <VD55G1_Start+0x50c>)
34012a82:	f7ff fab5 	bl	34011ff0 <VD55G1_log_impl>
    return ret;
  drv_ctx->state = VD55G1_ST_STREAMING;
34012a86:	2301      	movs	r3, #1
34012a88:	62ab      	str	r3, [r5, #40]	@ 0x28

  return 0;
}
34012a8a:	4620      	mov	r0, r4
34012a8c:	b007      	add	sp, #28
34012a8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
34012a90:	3401ccfe 	.word	0x3401ccfe
34012a94:	3401cd21 	.word	0x3401cd21
34012a98:	34035883 	.word	0x34035883
34012a9c:	3401cafa 	.word	0x3401cafa
34012aa0:	340358c6 	.word	0x340358c6
34012aa4:	3401cd5a 	.word	0x3401cd5a
34012aa8:	34035806 	.word	0x34035806
34012aac:	3403586c 	.word	0x3403586c
34012ab0:	34035800 	.word	0x34035800
34012ab4:	34035859 	.word	0x34035859
34012ab8:	34035831 	.word	0x34035831
34012abc:	3401cd82 	.word	0x3401cd82
34012ac0:	2fec1100 	.word	0x2fec1100
34012ac4:	00000000 	.word	0x00000000

34012ac8 <VD55G1_Stop>:

int VD55G1_Stop(VD55G1_Ctx_t *ctx)
{
34012ac8:	b510      	push	{r4, lr}
34012aca:	4604      	mov	r4, r0
  struct drv_ctx *drv_ctx = &ctx->ctx;
  int ret;

  ret = VD55G1_StopStreaming(ctx);
34012acc:	f7ff fc18 	bl	34012300 <VD55G1_StopStreaming>
  if (ret)
34012ad0:	b900      	cbnz	r0, 34012ad4 <VD55G1_Stop+0xc>
    return ret;
  drv_ctx->state = VD55G1_ST_IDLE;
34012ad2:	62a0      	str	r0, [r4, #40]	@ 0x28

  return 0;
}
34012ad4:	bd10      	pop	{r4, pc}

34012ad6 <VD55G1_SetFlipMirrorMode>:

  return 0;
}

int VD55G1_SetFlipMirrorMode(VD55G1_Ctx_t *ctx, VD55G1_MirrorFlip_t mode)
{
34012ad6:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
34012ad8:	6843      	ldr	r3, [r0, #4]
{
34012ada:	460d      	mov	r5, r1
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
34012adc:	f10d 0207 	add.w	r2, sp, #7
34012ae0:	211c      	movs	r1, #28
{
34012ae2:	4604      	mov	r4, r0
  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
34012ae4:	4798      	blx	r3
  if (ret)
34012ae6:	2800      	cmp	r0, #0
34012ae8:	d10f      	bne.n	34012b0a <VD55G1_SetFlipMirrorMode+0x34>
  return state == VD55G1_SYSTEM_FSM_STREAMING;
34012aea:	f89d 3007 	ldrb.w	r3, [sp, #7]

  is_streaming = VD55G1_IsStreaming(ctx);
  if (is_streaming < 0)
    return is_streaming;

  if (is_streaming) {
34012aee:	2b03      	cmp	r3, #3
34012af0:	d10e      	bne.n	34012b10 <VD55G1_SetFlipMirrorMode+0x3a>
    ret = VD55G1_Stop(ctx);
34012af2:	4620      	mov	r0, r4
34012af4:	f7ff ffe8 	bl	34012ac8 <VD55G1_Stop>
    if (ret)
34012af8:	b940      	cbnz	r0, 34012b0c <VD55G1_SetFlipMirrorMode+0x36>
  }

  drv_ctx->config_save.flip_mirror_mode = mode;

  if (is_streaming) {
    ret = VD55G1_Start(ctx);
34012afa:	4620      	mov	r0, r4
  drv_ctx->config_save.flip_mirror_mode = mode;
34012afc:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    if (ret)
      return ret;
  }

  return 0;
}
34012b00:	b003      	add	sp, #12
34012b02:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    ret = VD55G1_Start(ctx);
34012b06:	f7ff bd53 	b.w	340125b0 <VD55G1_Start>
  if (is_streaming < 0)
34012b0a:	daf2      	bge.n	34012af2 <VD55G1_SetFlipMirrorMode+0x1c>
}
34012b0c:	b003      	add	sp, #12
34012b0e:	bd30      	pop	{r4, r5, pc}
  drv_ctx->config_save.flip_mirror_mode = mode;
34012b10:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
  if (is_streaming) {
34012b14:	e7fa      	b.n	34012b0c <VD55G1_SetFlipMirrorMode+0x36>

34012b16 <VD6G_error>:
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
  va_end(ap);
}

static void VD6G_error(VD6G_Ctx_t *ctx, const char *format, ...)
{
34012b16:	b40e      	push	{r1, r2, r3}
34012b18:	b517      	push	{r0, r1, r2, r4, lr}
  va_list ap;

  if (!ctx->log)
34012b1a:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012b1c:	b124      	cbz	r4, 34012b28 <VD6G_error+0x12>
    return ;

  va_start(ap, format);
34012b1e:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
34012b20:	2100      	movs	r1, #0
34012b22:	9a05      	ldr	r2, [sp, #20]
  va_start(ap, format);
34012b24:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
34012b26:	47a0      	blx	r4
  va_end(ap);
}
34012b28:	b003      	add	sp, #12
34012b2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012b2e:	b003      	add	sp, #12
34012b30:	4770      	bx	lr

34012b32 <VD6G_notice>:
{
34012b32:	b40e      	push	{r1, r2, r3}
34012b34:	b517      	push	{r0, r1, r2, r4, lr}
  if (!ctx->log)
34012b36:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012b38:	b124      	cbz	r4, 34012b44 <VD6G_notice+0x12>
  va_start(ap, format);
34012b3a:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
34012b3c:	2102      	movs	r1, #2
34012b3e:	9a05      	ldr	r2, [sp, #20]
  va_start(ap, format);
34012b40:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
34012b42:	47a0      	blx	r4
}
34012b44:	b003      	add	sp, #12
34012b46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012b4a:	b003      	add	sp, #12
34012b4c:	4770      	bx	lr
	...

34012b50 <display_error>:

static void display_error(VD6G_Ctx_t *ctx)
{
34012b50:	b513      	push	{r0, r1, r4, lr}
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
34012b52:	6883      	ldr	r3, [r0, #8]
34012b54:	211c      	movs	r1, #28
34012b56:	f10d 0206 	add.w	r2, sp, #6
{
34012b5a:	4604      	mov	r4, r0
  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
34012b5c:	4798      	blx	r3
  assert(ret == 0);
34012b5e:	b130      	cbz	r0, 34012b6e <display_error+0x1e>
34012b60:	f240 1131 	movw	r1, #305	@ 0x131
34012b64:	4b06      	ldr	r3, [pc, #24]	@ (34012b80 <display_error+0x30>)
34012b66:	4a07      	ldr	r2, [pc, #28]	@ (34012b84 <display_error+0x34>)
34012b68:	4807      	ldr	r0, [pc, #28]	@ (34012b88 <display_error+0x38>)
34012b6a:	f004 ff19 	bl	340179a0 <__assert_func>
  VD6G_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
34012b6e:	4620      	mov	r0, r4
34012b70:	f8bd 2006 	ldrh.w	r2, [sp, #6]
34012b74:	4905      	ldr	r1, [pc, #20]	@ (34012b8c <display_error+0x3c>)
34012b76:	f7ff ffce 	bl	34012b16 <VD6G_error>
}
34012b7a:	b002      	add	sp, #8
34012b7c:	bd10      	pop	{r4, pc}
34012b7e:	bf00      	nop
34012b80:	3401bf23 	.word	0x3401bf23
34012b84:	340372d3 	.word	0x340372d3
34012b88:	3401cda3 	.word	0x3401cda3
34012b8c:	3401cae5 	.word	0x3401cae5

34012b90 <VD6G_PollReg8>:

static int VD6G_PollReg8(VD6G_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
34012b90:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
34012b94:	4604      	mov	r4, r0
34012b96:	460f      	mov	r7, r1
34012b98:	4690      	mov	r8, r2
34012b9a:	2631      	movs	r6, #49	@ 0x31
  int loop_nb = timeout_ms / loop_delay_ms;
  uint8_t val;
  int ret;

  while (--loop_nb) {
    ret = ctx->read8(ctx, addr, &val);
34012b9c:	4639      	mov	r1, r7
34012b9e:	4620      	mov	r0, r4
34012ba0:	6863      	ldr	r3, [r4, #4]
34012ba2:	f10d 020f 	add.w	r2, sp, #15
34012ba6:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34012ba8:	4605      	mov	r5, r0
34012baa:	b938      	cbnz	r0, 34012bbc <VD6G_PollReg8+0x2c>
    if (val == poll_val)
34012bac:	f89d 300f 	ldrb.w	r3, [sp, #15]
34012bb0:	4543      	cmp	r3, r8
34012bb2:	d10f      	bne.n	34012bd4 <VD6G_PollReg8+0x44>
      return 0;
    ctx->delay(ctx, loop_delay_ms);
  }

  return -1;
}
34012bb4:	4628      	mov	r0, r5
34012bb6:	b004      	add	sp, #16
34012bb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    VD6G_TraceError(ctx, ret);
34012bbc:	9000      	str	r0, [sp, #0]
34012bbe:	f240 133f 	movw	r3, #319	@ 0x13f
34012bc2:	4620      	mov	r0, r4
34012bc4:	4a08      	ldr	r2, [pc, #32]	@ (34012be8 <VD6G_PollReg8+0x58>)
34012bc6:	4909      	ldr	r1, [pc, #36]	@ (34012bec <VD6G_PollReg8+0x5c>)
34012bc8:	f7ff ffa5 	bl	34012b16 <VD6G_error>
34012bcc:	4620      	mov	r0, r4
34012bce:	f7ff ffbf 	bl	34012b50 <display_error>
34012bd2:	e7ef      	b.n	34012bb4 <VD6G_PollReg8+0x24>
    ctx->delay(ctx, loop_delay_ms);
34012bd4:	210a      	movs	r1, #10
34012bd6:	4620      	mov	r0, r4
34012bd8:	6a23      	ldr	r3, [r4, #32]
34012bda:	4798      	blx	r3
  while (--loop_nb) {
34012bdc:	3e01      	subs	r6, #1
34012bde:	d1dd      	bne.n	34012b9c <VD6G_PollReg8+0xc>
  return -1;
34012be0:	f04f 35ff 	mov.w	r5, #4294967295
34012be4:	e7e6      	b.n	34012bb4 <VD6G_PollReg8+0x24>
34012be6:	bf00      	nop
34012be8:	340372e1 	.word	0x340372e1
34012bec:	3401cb0a 	.word	0x3401cb0a

34012bf0 <VD6G_SetExposureModeInternal>:

static int VD6G_SetExposureModeInternal(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
  int ret;

  if ((mode != VD6G_EXPOSURE_AUTO) &&
34012bf0:	2902      	cmp	r1, #2
{
34012bf2:	b537      	push	{r0, r1, r2, r4, r5, lr}
34012bf4:	4605      	mov	r5, r0
34012bf6:	460a      	mov	r2, r1
  if ((mode != VD6G_EXPOSURE_AUTO) &&
34012bf8:	d813      	bhi.n	34012c22 <VD6G_SetExposureModeInternal+0x32>
      (mode != VD6G_EXPOSURE_FREEZE_AEALGO) &&
      (mode != VD6G_EXPOSURE_MANUAL)) {
    return -1;
  }

  ret = ctx->write8(ctx, VD6G_REG_EXP_MODE, mode);
34012bfa:	f240 414c 	movw	r1, #1100	@ 0x44c
34012bfe:	6903      	ldr	r3, [r0, #16]
34012c00:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012c02:	4604      	mov	r4, r0
34012c04:	b150      	cbz	r0, 34012c1c <VD6G_SetExposureModeInternal+0x2c>
34012c06:	9000      	str	r0, [sp, #0]
34012c08:	f240 2367 	movw	r3, #615	@ 0x267
34012c0c:	4628      	mov	r0, r5
34012c0e:	4a06      	ldr	r2, [pc, #24]	@ (34012c28 <VD6G_SetExposureModeInternal+0x38>)
34012c10:	4906      	ldr	r1, [pc, #24]	@ (34012c2c <VD6G_SetExposureModeInternal+0x3c>)
34012c12:	f7ff ff80 	bl	34012b16 <VD6G_error>
34012c16:	4628      	mov	r0, r5
34012c18:	f7ff ff9a 	bl	34012b50 <display_error>

  return 0;
}
34012c1c:	4620      	mov	r0, r4
34012c1e:	b003      	add	sp, #12
34012c20:	bd30      	pop	{r4, r5, pc}
    return -1;
34012c22:	f04f 34ff 	mov.w	r4, #4294967295
34012c26:	e7f9      	b.n	34012c1c <VD6G_SetExposureModeInternal+0x2c>
34012c28:	340371d2 	.word	0x340371d2
34012c2c:	3401cb0a 	.word	0x3401cb0a

34012c30 <VD6G_SetFlicker>:
static int VD6G_SetFlicker(VD6G_Ctx_t *ctx, VD6G_Flicker_t flicker)
{
  uint16_t mode;
  int ret;

  switch (flicker) {
34012c30:	2902      	cmp	r1, #2
{
34012c32:	b537      	push	{r0, r1, r2, r4, r5, lr}
34012c34:	4605      	mov	r5, r0
34012c36:	d815      	bhi.n	34012c64 <VD6G_SetFlicker+0x34>
    break;
  default:
    return -1;
  }

  ret = ctx->write16(ctx, VD6G_REG_AE_COMPILER_CONTROL, mode);
34012c38:	4a0c      	ldr	r2, [pc, #48]	@ (34012c6c <VD6G_SetFlicker+0x3c>)
34012c3a:	6943      	ldr	r3, [r0, #20]
34012c3c:	5c52      	ldrb	r2, [r2, r1]
34012c3e:	f44f 6186 	mov.w	r1, #1072	@ 0x430
34012c42:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012c44:	4604      	mov	r4, r0
34012c46:	b150      	cbz	r0, 34012c5e <VD6G_SetFlicker+0x2e>
34012c48:	9000      	str	r0, [sp, #0]
34012c4a:	f240 33b1 	movw	r3, #945	@ 0x3b1
34012c4e:	4628      	mov	r0, r5
34012c50:	4a07      	ldr	r2, [pc, #28]	@ (34012c70 <VD6G_SetFlicker+0x40>)
34012c52:	4908      	ldr	r1, [pc, #32]	@ (34012c74 <VD6G_SetFlicker+0x44>)
34012c54:	f7ff ff5f 	bl	34012b16 <VD6G_error>
34012c58:	4628      	mov	r0, r5
34012c5a:	f7ff ff79 	bl	34012b50 <display_error>

  return 0;
}
34012c5e:	4620      	mov	r0, r4
34012c60:	b003      	add	sp, #12
34012c62:	bd30      	pop	{r4, r5, pc}
    return -1;
34012c64:	f04f 34ff 	mov.w	r4, #4294967295
34012c68:	e7f9      	b.n	34012c5e <VD6G_SetFlicker+0x2e>
34012c6a:	bf00      	nop
34012c6c:	34037098 	.word	0x34037098
34012c70:	3403719c 	.word	0x3403719c
34012c74:	3401cb0a 	.word	0x3401cb0a

34012c78 <VD6G_GetLineTimeInUs>:
{
34012c78:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34012c7a:	460e      	mov	r6, r1
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
34012c7c:	6883      	ldr	r3, [r0, #8]
34012c7e:	f44f 7140 	mov.w	r1, #768	@ 0x300
34012c82:	f10d 020e 	add.w	r2, sp, #14
{
34012c86:	4605      	mov	r5, r0
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
34012c88:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012c8a:	4604      	mov	r4, r0
34012c8c:	b968      	cbnz	r0, 34012caa <VD6G_GetLineTimeInUs+0x32>
  *line_time_in_us = ((uint64_t)line_len * 1000000) / VD6G_PIXEL_CLOCK;
34012c8e:	a311      	add	r3, pc, #68	@ (adr r3, 34012cd4 <VD6G_GetLineTimeInUs+0x5c>)
34012c90:	e9d3 2300 	ldrd	r2, r3, [r3]
34012c94:	f8bd 000e 	ldrh.w	r0, [sp, #14]
34012c98:	490b      	ldr	r1, [pc, #44]	@ (34012cc8 <VD6G_GetLineTimeInUs+0x50>)
34012c9a:	fba0 0101 	umull	r0, r1, r0, r1
34012c9e:	f7ee fc9d 	bl	340015dc <__aeabi_uldivmod>
34012ca2:	6030      	str	r0, [r6, #0]
}
34012ca4:	4620      	mov	r0, r4
34012ca6:	b004      	add	sp, #16
34012ca8:	bd70      	pop	{r4, r5, r6, pc}
  VD6G_TraceError(ctx, ret);
34012caa:	9000      	str	r0, [sp, #0]
34012cac:	f44f 73a7 	mov.w	r3, #334	@ 0x14e
34012cb0:	4628      	mov	r0, r5
34012cb2:	4a06      	ldr	r2, [pc, #24]	@ (34012ccc <VD6G_GetLineTimeInUs+0x54>)
34012cb4:	4906      	ldr	r1, [pc, #24]	@ (34012cd0 <VD6G_GetLineTimeInUs+0x58>)
34012cb6:	f7ff ff2e 	bl	34012b16 <VD6G_error>
34012cba:	4628      	mov	r0, r5
34012cbc:	f7ff ff48 	bl	34012b50 <display_error>
34012cc0:	e7f0      	b.n	34012ca4 <VD6G_GetLineTimeInUs+0x2c>
34012cc2:	bf00      	nop
34012cc4:	f3af 8000 	nop.w
34012cc8:	000f4240 	.word	0x000f4240
34012ccc:	340370e9 	.word	0x340370e9
34012cd0:	3401cb0a 	.word	0x3401cb0a
34012cd4:	09959d00 	.word	0x09959d00
34012cd8:	00000000 	.word	0x00000000

34012cdc <VD6G_warn.constprop.0>:
static void VD6G_warn(VD6G_Ctx_t *ctx, const char *format, ...)
34012cdc:	b40e      	push	{r1, r2, r3}
34012cde:	b517      	push	{r0, r1, r2, r4, lr}
  if (!ctx->log)
34012ce0:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012ce2:	b124      	cbz	r4, 34012cee <VD6G_warn.constprop.0+0x12>
  va_start(ap, format);
34012ce4:	ab06      	add	r3, sp, #24
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
34012ce6:	2101      	movs	r1, #1
34012ce8:	4a03      	ldr	r2, [pc, #12]	@ (34012cf8 <VD6G_warn.constprop.0+0x1c>)
  va_start(ap, format);
34012cea:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
34012cec:	47a0      	blx	r4
}
34012cee:	b003      	add	sp, #12
34012cf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012cf4:	b003      	add	sp, #12
34012cf6:	4770      	bx	lr
34012cf8:	3401ca3b 	.word	0x3401ca3b

34012cfc <VD6G_dbg.constprop.0>:
static void VD6G_dbg(VD6G_Ctx_t *ctx, int lvl, const char *format, ...)
34012cfc:	b40c      	push	{r2, r3}
34012cfe:	b513      	push	{r0, r1, r4, lr}
  if (!ctx->log)
34012d00:	6a44      	ldr	r4, [r0, #36]	@ 0x24
34012d02:	b124      	cbz	r4, 34012d0e <VD6G_dbg.constprop.0+0x12>
  va_start(ap, format);
34012d04:	ab05      	add	r3, sp, #20
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
34012d06:	2103      	movs	r1, #3
34012d08:	9a04      	ldr	r2, [sp, #16]
  va_start(ap, format);
34012d0a:	9301      	str	r3, [sp, #4]
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
34012d0c:	47a0      	blx	r4
}
34012d0e:	b002      	add	sp, #8
34012d10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34012d14:	b002      	add	sp, #8
34012d16:	4770      	bx	lr

34012d18 <VD6G_GetTopDie>:
{
34012d18:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34012d1a:	460e      	mov	r6, r1
  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
34012d1c:	6883      	ldr	r3, [r0, #8]
34012d1e:	2102      	movs	r1, #2
34012d20:	f10d 020e 	add.w	r2, sp, #14
{
34012d24:	4605      	mov	r5, r0
  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
34012d26:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012d28:	4604      	mov	r4, r0
34012d2a:	b968      	cbnz	r0, 34012d48 <VD6G_GetTopDie+0x30>
  VD6G_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
34012d2c:	4601      	mov	r1, r0
34012d2e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34012d32:	4628      	mov	r0, r5
34012d34:	4a0a      	ldr	r2, [pc, #40]	@ (34012d60 <VD6G_GetTopDie+0x48>)
34012d36:	f7ff ffe1 	bl	34012cfc <VD6G_dbg.constprop.0>
  *top_die = reg16 >> 8;
34012d3a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34012d3e:	0a1b      	lsrs	r3, r3, #8
34012d40:	7033      	strb	r3, [r6, #0]
}
34012d42:	4620      	mov	r0, r4
34012d44:	b004      	add	sp, #16
34012d46:	bd70      	pop	{r4, r5, r6, pc}
  VD6G_TraceError(ctx, ret);
34012d48:	9000      	str	r0, [sp, #0]
34012d4a:	f240 1373 	movw	r3, #371	@ 0x173
34012d4e:	4628      	mov	r0, r5
34012d50:	4a04      	ldr	r2, [pc, #16]	@ (34012d64 <VD6G_GetTopDie+0x4c>)
34012d52:	4905      	ldr	r1, [pc, #20]	@ (34012d68 <VD6G_GetTopDie+0x50>)
34012d54:	f7ff fedf 	bl	34012b16 <VD6G_error>
34012d58:	4628      	mov	r0, r5
34012d5a:	f7ff fef9 	bl	34012b50 <display_error>
34012d5e:	e7f0      	b.n	34012d42 <VD6G_GetTopDie+0x2a>
34012d60:	3401cca0 	.word	0x3401cca0
34012d64:	340372b2 	.word	0x340372b2
34012d68:	3401cb0a 	.word	0x3401cb0a

34012d6c <VD6G_WaitState>:
{
34012d6c:	b570      	push	{r4, r5, r6, lr}
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012d6e:	b2ca      	uxtb	r2, r1
{
34012d70:	460d      	mov	r5, r1
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012d72:	2128      	movs	r1, #40	@ 0x28
{
34012d74:	4606      	mov	r6, r0
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
34012d76:	f7ff ff0b 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
34012d7a:	4604      	mov	r4, r0
34012d7c:	b130      	cbz	r0, 34012d8c <VD6G_WaitState+0x20>
    VD6G_warn(ctx, "Unable to reach state %d\n", state);
34012d7e:	462a      	mov	r2, r5
34012d80:	4630      	mov	r0, r6
34012d82:	4906      	ldr	r1, [pc, #24]	@ (34012d9c <VD6G_WaitState+0x30>)
34012d84:	f7ff ffaa 	bl	34012cdc <VD6G_warn.constprop.0>
}
34012d88:	4620      	mov	r0, r4
34012d8a:	bd70      	pop	{r4, r5, r6, pc}
    VD6G_dbg(ctx, 0, "reach state %d\n", state);
34012d8c:	4601      	mov	r1, r0
34012d8e:	462b      	mov	r3, r5
34012d90:	4630      	mov	r0, r6
34012d92:	4a03      	ldr	r2, [pc, #12]	@ (34012da0 <VD6G_WaitState+0x34>)
34012d94:	f7ff ffb2 	bl	34012cfc <VD6G_dbg.constprop.0>
  return ret;
34012d98:	e7f6      	b.n	34012d88 <VD6G_WaitState+0x1c>
34012d9a:	bf00      	nop
34012d9c:	3401ca3b 	.word	0x3401ca3b
34012da0:	3401ca66 	.word	0x3401ca66

34012da4 <VD6G_Init>:

  return 0;
}

int VD6G_Init(VD6G_Ctx_t *ctx, VD6G_Config_t *config)
{
34012da4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
  int ret;

  if (config->frame_rate < VD6G_MIN_FPS)
34012da8:	688b      	ldr	r3, [r1, #8]
{
34012daa:	4605      	mov	r5, r0
  if (config->frame_rate < VD6G_MIN_FPS)
34012dac:	3b01      	subs	r3, #1
34012dae:	2b57      	cmp	r3, #87	@ 0x57
{
34012db0:	460c      	mov	r4, r1
34012db2:	b087      	sub	sp, #28
  if (config->frame_rate < VD6G_MIN_FPS)
34012db4:	d802      	bhi.n	34012dbc <VD6G_Init+0x18>
    return -1;
  if (config->frame_rate > VD6G_MAX_FPS)
    return -1;

  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
34012db6:	790b      	ldrb	r3, [r1, #4]
34012db8:	2b08      	cmp	r3, #8
34012dba:	d905      	bls.n	34012dc8 <VD6G_Init+0x24>
    return -1;
34012dbc:	f04f 34ff 	mov.w	r4, #4294967295
  ret = VD6G_SetupEarly(ctx);
  if (ret)
    return ret;

  return 0;
}
34012dc0:	4620      	mov	r0, r4
34012dc2:	b007      	add	sp, #28
34012dc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
34012dc8:	7b0b      	ldrb	r3, [r1, #12]
34012dca:	2b03      	cmp	r3, #3
34012dcc:	d8f6      	bhi.n	34012dbc <VD6G_Init+0x18>
  ctx->shutdown_pin(ctx, 0);
34012dce:	6803      	ldr	r3, [r0, #0]
34012dd0:	2100      	movs	r1, #0
34012dd2:	4798      	blx	r3
  ctx->delay(ctx, 10);
34012dd4:	210a      	movs	r1, #10
34012dd6:	4628      	mov	r0, r5
34012dd8:	6a2b      	ldr	r3, [r5, #32]
34012dda:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
34012ddc:	2101      	movs	r1, #1
34012dde:	4628      	mov	r0, r5
34012de0:	682b      	ldr	r3, [r5, #0]
34012de2:	4798      	blx	r3
  drv_ctx->config_save = *config;
34012de4:	f105 0630 	add.w	r6, r5, #48	@ 0x30
  ctx->delay(ctx, 10);
34012de8:	210a      	movs	r1, #10
34012dea:	4628      	mov	r0, r5
34012dec:	6a2b      	ldr	r3, [r5, #32]
34012dee:	4798      	blx	r3
  drv_ctx->config_save = *config;
34012df0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012df2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34012df4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012df6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34012df8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
34012dfa:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  drv_ctx->is_streaming = 0;
34012dfc:	2300      	movs	r3, #0
  drv_ctx->config_save = *config;
34012dfe:	e894 0003 	ldmia.w	r4, {r0, r1}
34012e02:	e886 0003 	stmia.w	r6, {r0, r1}
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
34012e06:	2101      	movs	r1, #1
34012e08:	4628      	mov	r0, r5
  drv_ctx->is_streaming = 0;
34012e0a:	62eb      	str	r3, [r5, #44]	@ 0x2c
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
34012e0c:	f7ff ffae 	bl	34012d6c <VD6G_WaitState>
  if (ret)
34012e10:	4604      	mov	r4, r0
34012e12:	2800      	cmp	r0, #0
34012e14:	d1d4      	bne.n	34012dc0 <VD6G_Init+0x1c>
  ret = ctx->read16(ctx, VD6G_REG_MODEL_ID, &reg16);
34012e16:	ae03      	add	r6, sp, #12
34012e18:	4601      	mov	r1, r0
34012e1a:	4632      	mov	r2, r6
34012e1c:	4628      	mov	r0, r5
34012e1e:	68ab      	ldr	r3, [r5, #8]
34012e20:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e22:	4604      	mov	r4, r0
34012e24:	b988      	cbnz	r0, 34012e4a <VD6G_Init+0xa6>
  VD6G_dbg(ctx, 0, "model_id = 0x%04x\n", reg16);
34012e26:	4601      	mov	r1, r0
34012e28:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e2c:	4aaf      	ldr	r2, [pc, #700]	@ (340130ec <VD6G_Init+0x348>)
34012e2e:	4628      	mov	r0, r5
34012e30:	f7ff ff64 	bl	34012cfc <VD6G_dbg.constprop.0>
  if (reg16 != VD6G_MODEL_ID) {
34012e34:	f245 6203 	movw	r2, #22019	@ 0x5603
34012e38:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e3c:	4293      	cmp	r3, r2
34012e3e:	d010      	beq.n	34012e62 <VD6G_Init+0xbe>
    VD6G_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD6G_MODEL_ID, reg16);
34012e40:	4628      	mov	r0, r5
34012e42:	49ab      	ldr	r1, [pc, #684]	@ (340130f0 <VD6G_Init+0x34c>)
34012e44:	f7ff fe67 	bl	34012b16 <VD6G_error>
  if (ret)
34012e48:	e7b8      	b.n	34012dbc <VD6G_Init+0x18>
  VD6G_TraceError(ctx, ret);
34012e4a:	f240 1381 	movw	r3, #385	@ 0x181
34012e4e:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012e50:	4aa8      	ldr	r2, [pc, #672]	@ (340130f4 <VD6G_Init+0x350>)
  VD6G_TraceError(ctx, ret);
34012e52:	4628      	mov	r0, r5
34012e54:	49a8      	ldr	r1, [pc, #672]	@ (340130f8 <VD6G_Init+0x354>)
34012e56:	f7ff fe5e 	bl	34012b16 <VD6G_error>
34012e5a:	4628      	mov	r0, r5
34012e5c:	f7ff fe78 	bl	34012b50 <display_error>
34012e60:	e7ae      	b.n	34012dc0 <VD6G_Init+0x1c>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012e62:	4628      	mov	r0, r5
34012e64:	f10d 010b 	add.w	r1, sp, #11
34012e68:	f7ff ff56 	bl	34012d18 <VD6G_GetTopDie>
  if (ret)
34012e6c:	4604      	mov	r4, r0
34012e6e:	2800      	cmp	r0, #0
34012e70:	d1a6      	bne.n	34012dc0 <VD6G_Init+0x1c>
  if (top_die != VD6G_TOP_DIE_SLOW_BOOT && top_die != VD6G_TOP_DIE_FAST_BOOT) {
34012e72:	f89d 300b 	ldrb.w	r3, [sp, #11]
34012e76:	2b20      	cmp	r3, #32
34012e78:	d006      	beq.n	34012e88 <VD6G_Init+0xe4>
34012e7a:	2b31      	cmp	r3, #49	@ 0x31
34012e7c:	d004      	beq.n	34012e88 <VD6G_Init+0xe4>
    VD6G_error(ctx, "Unsupported revision\n");
34012e7e:	499f      	ldr	r1, [pc, #636]	@ (340130fc <VD6G_Init+0x358>)
    VD6G_error(ctx, "External clock out of rangen\n");
34012e80:	4628      	mov	r0, r5
34012e82:	f7ff fe48 	bl	34012b16 <VD6G_error>
  if (ret)
34012e86:	e799      	b.n	34012dbc <VD6G_Init+0x18>
  ret = ctx->read16(ctx, VD6G_REG_ROM_REVISION, &reg16);
34012e88:	4632      	mov	r2, r6
34012e8a:	2114      	movs	r1, #20
34012e8c:	4628      	mov	r0, r5
34012e8e:	68ab      	ldr	r3, [r5, #8]
34012e90:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012e92:	4604      	mov	r4, r0
34012e94:	b9d8      	cbnz	r0, 34012ece <VD6G_Init+0x12a>
  VD6G_dbg(ctx, 0, "rom = 0x%04x\n", reg16);
34012e96:	4601      	mov	r1, r0
34012e98:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012e9c:	4628      	mov	r0, r5
34012e9e:	4a98      	ldr	r2, [pc, #608]	@ (34013100 <VD6G_Init+0x35c>)
34012ea0:	f7ff ff2c 	bl	34012cfc <VD6G_dbg.constprop.0>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012ea4:	4628      	mov	r0, r5
34012ea6:	f10d 010b 	add.w	r1, sp, #11
34012eaa:	f7ff ff35 	bl	34012d18 <VD6G_GetTopDie>
  if (ret)
34012eae:	4604      	mov	r4, r0
34012eb0:	2800      	cmp	r0, #0
34012eb2:	d185      	bne.n	34012dc0 <VD6G_Init+0x1c>
  switch (top_die) {
34012eb4:	f89d 300b 	ldrb.w	r3, [sp, #11]
34012eb8:	2b20      	cmp	r3, #32
34012eba:	d00c      	beq.n	34012ed6 <VD6G_Init+0x132>
34012ebc:	2b31      	cmp	r3, #49	@ 0x31
34012ebe:	d057      	beq.n	34012f70 <VD6G_Init+0x1cc>
    assert(0);
34012ec0:	f44f 71e5 	mov.w	r1, #458	@ 0x1ca
34012ec4:	4b8f      	ldr	r3, [pc, #572]	@ (34013104 <VD6G_Init+0x360>)
34012ec6:	4a90      	ldr	r2, [pc, #576]	@ (34013108 <VD6G_Init+0x364>)
    assert(0);
34012ec8:	4890      	ldr	r0, [pc, #576]	@ (3401310c <VD6G_Init+0x368>)
34012eca:	f004 fd69 	bl	340179a0 <__assert_func>
  VD6G_TraceError(ctx, ret);
34012ece:	f240 1391 	movw	r3, #401	@ 0x191
34012ed2:	9000      	str	r0, [sp, #0]
34012ed4:	e7bc      	b.n	34012e50 <VD6G_Init+0xac>
  ret = ctx->write_array(ctx, 0x2000, (uint8_t *) patch_cut2, sizeof(patch_cut2));
34012ed6:	69ec      	ldr	r4, [r5, #28]
34012ed8:	f642 23f8 	movw	r3, #11000	@ 0x2af8
34012edc:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34012ee0:	4628      	mov	r0, r5
34012ee2:	4a8b      	ldr	r2, [pc, #556]	@ (34013110 <VD6G_Init+0x36c>)
34012ee4:	47a0      	blx	r4
  VD6G_TraceError(ctx, ret);
34012ee6:	4604      	mov	r4, r0
34012ee8:	b120      	cbz	r0, 34012ef4 <VD6G_Init+0x150>
34012eea:	f44f 73d1 	mov.w	r3, #418	@ 0x1a2
34012eee:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012ef0:	4a88      	ldr	r2, [pc, #544]	@ (34013114 <VD6G_Init+0x370>)
34012ef2:	e7ae      	b.n	34012e52 <VD6G_Init+0xae>
  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_PATCH_SETUP);
34012ef4:	2202      	movs	r2, #2
34012ef6:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012efa:	4628      	mov	r0, r5
34012efc:	692b      	ldr	r3, [r5, #16]
34012efe:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f00:	4604      	mov	r4, r0
34012f02:	bb38      	cbnz	r0, 34012f54 <VD6G_Init+0x1b0>
  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
34012f04:	4602      	mov	r2, r0
34012f06:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012f0a:	4628      	mov	r0, r5
34012f0c:	f7ff fe40 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
34012f10:	4604      	mov	r4, r0
34012f12:	2800      	cmp	r0, #0
34012f14:	f47f af54 	bne.w	34012dc0 <VD6G_Init+0x1c>
  ret = ctx->read16(ctx, VD6G_REG_FWPATCH_REVISION, &reg16);
34012f18:	4632      	mov	r2, r6
34012f1a:	211e      	movs	r1, #30
34012f1c:	4628      	mov	r0, r5
34012f1e:	68ab      	ldr	r3, [r5, #8]
34012f20:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f22:	4604      	mov	r4, r0
34012f24:	b9d0      	cbnz	r0, 34012f5c <VD6G_Init+0x1b8>
  VD6G_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
34012f26:	4601      	mov	r1, r0
34012f28:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012f2c:	4628      	mov	r0, r5
34012f2e:	4a7a      	ldr	r2, [pc, #488]	@ (34013118 <VD6G_Init+0x374>)
34012f30:	f7ff fee4 	bl	34012cfc <VD6G_dbg.constprop.0>
  if (reg16 != (patch_major << 8) + patch_minor) {
34012f34:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34012f38:	f5b3 7f07 	cmp.w	r3, #540	@ 0x21c
34012f3c:	d012      	beq.n	34012f64 <VD6G_Init+0x1c0>
    VD6G_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor,
34012f3e:	b2da      	uxtb	r2, r3
34012f40:	0a1b      	lsrs	r3, r3, #8
34012f42:	9201      	str	r2, [sp, #4]
34012f44:	9300      	str	r3, [sp, #0]
34012f46:	2202      	movs	r2, #2
34012f48:	231c      	movs	r3, #28
34012f4a:	4974      	ldr	r1, [pc, #464]	@ (3401311c <VD6G_Init+0x378>)
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
34012f4c:	4628      	mov	r0, r5
34012f4e:	f7ff fde2 	bl	34012b16 <VD6G_error>
  if (ret)
34012f52:	e733      	b.n	34012dbc <VD6G_Init+0x18>
  VD6G_TraceError(ctx, ret);
34012f54:	f240 13a5 	movw	r3, #421	@ 0x1a5
34012f58:	9000      	str	r0, [sp, #0]
34012f5a:	e7c9      	b.n	34012ef0 <VD6G_Init+0x14c>
  VD6G_TraceError(ctx, ret);
34012f5c:	f44f 73d6 	mov.w	r3, #428	@ 0x1ac
34012f60:	9000      	str	r0, [sp, #0]
34012f62:	e7c5      	b.n	34012ef0 <VD6G_Init+0x14c>
  VD6G_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
34012f64:	231c      	movs	r3, #28
34012f66:	2202      	movs	r2, #2
34012f68:	4628      	mov	r0, r5
34012f6a:	496d      	ldr	r1, [pc, #436]	@ (34013120 <VD6G_Init+0x37c>)
34012f6c:	f7ff fde1 	bl	34012b32 <VD6G_notice>
  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_BOOT);
34012f70:	2201      	movs	r2, #1
34012f72:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012f76:	4628      	mov	r0, r5
34012f78:	692b      	ldr	r3, [r5, #16]
34012f7a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012f7c:	4604      	mov	r4, r0
34012f7e:	b120      	cbz	r0, 34012f8a <VD6G_Init+0x1e6>
34012f80:	f240 13d5 	movw	r3, #469	@ 0x1d5
34012f84:	4a67      	ldr	r2, [pc, #412]	@ (34013124 <VD6G_Init+0x380>)
34012f86:	9000      	str	r0, [sp, #0]
34012f88:	e763      	b.n	34012e52 <VD6G_Init+0xae>
  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
34012f8a:	4602      	mov	r2, r0
34012f8c:	f44f 7100 	mov.w	r1, #512	@ 0x200
34012f90:	4628      	mov	r0, r5
34012f92:	f7ff fdfd 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
34012f96:	4604      	mov	r4, r0
34012f98:	2800      	cmp	r0, #0
34012f9a:	f47f af11 	bne.w	34012dc0 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34012f9e:	2102      	movs	r1, #2
34012fa0:	4628      	mov	r0, r5
34012fa2:	f7ff fee3 	bl	34012d6c <VD6G_WaitState>
  if (ret)
34012fa6:	4604      	mov	r4, r0
34012fa8:	2800      	cmp	r0, #0
34012faa:	f47f af09 	bne.w	34012dc0 <VD6G_Init+0x1c>
  VD6G_notice(ctx, "sensor boot successfully\n");
34012fae:	4628      	mov	r0, r5
34012fb0:	495d      	ldr	r1, [pc, #372]	@ (34013128 <VD6G_Init+0x384>)
34012fb2:	f7ff fdbe 	bl	34012b32 <VD6G_notice>
  ret = VD6G_GetTopDie(ctx, &top_die);
34012fb6:	4628      	mov	r0, r5
34012fb8:	f10d 0109 	add.w	r1, sp, #9
34012fbc:	f7ff feac 	bl	34012d18 <VD6G_GetTopDie>
  if (ret)
34012fc0:	4604      	mov	r4, r0
34012fc2:	2800      	cmp	r0, #0
34012fc4:	f47f aefc 	bne.w	34012dc0 <VD6G_Init+0x1c>
  switch (top_die) {
34012fc8:	f89d 3009 	ldrb.w	r3, [sp, #9]
34012fcc:	2b20      	cmp	r3, #32
34012fce:	d007      	beq.n	34012fe0 <VD6G_Init+0x23c>
34012fd0:	2b31      	cmp	r3, #49	@ 0x31
34012fd2:	f000 80ff 	beq.w	340131d4 <VD6G_Init+0x430>
    assert(0);
34012fd6:	f44f 710d 	mov.w	r1, #564	@ 0x234
34012fda:	4b4a      	ldr	r3, [pc, #296]	@ (34013104 <VD6G_Init+0x360>)
34012fdc:	4a53      	ldr	r2, [pc, #332]	@ (3401312c <VD6G_Init+0x388>)
34012fde:	e773      	b.n	34012ec8 <VD6G_Init+0x124>
  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_START_VTRAM_UPDATE);
34012fe0:	2201      	movs	r2, #1
34012fe2:	f240 2103 	movw	r1, #515	@ 0x203
34012fe6:	4628      	mov	r0, r5
34012fe8:	692b      	ldr	r3, [r5, #16]
34012fea:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34012fec:	4604      	mov	r4, r0
34012fee:	b120      	cbz	r0, 34012ffa <VD6G_Init+0x256>
34012ff0:	f44f 73f6 	mov.w	r3, #492	@ 0x1ec
34012ff4:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34012ff6:	4a4e      	ldr	r2, [pc, #312]	@ (34013130 <VD6G_Init+0x38c>)
34012ff8:	e72b      	b.n	34012e52 <VD6G_Init+0xae>
  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
34012ffa:	4602      	mov	r2, r0
34012ffc:	f240 2103 	movw	r1, #515	@ 0x203
34013000:	4628      	mov	r0, r5
34013002:	f7ff fdc5 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
34013006:	4604      	mov	r4, r0
34013008:	2800      	cmp	r0, #0
3401300a:	f47f aed9 	bne.w	34012dc0 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3401300e:	2102      	movs	r1, #2
34013010:	4628      	mov	r0, r5
34013012:	f7ff feab 	bl	34012d6c <VD6G_WaitState>
  if (ret)
34013016:	4604      	mov	r4, r0
34013018:	2800      	cmp	r0, #0
3401301a:	f47f aed1 	bne.w	34012dc0 <VD6G_Init+0x1c>
  for (i = 0; i < vtpatch_area_nb; i++) {
3401301e:	4681      	mov	r9, r0
34013020:	f8df 8110 	ldr.w	r8, [pc, #272]	@ 34013134 <VD6G_Init+0x390>
34013024:	f8df a110 	ldr.w	sl, [pc, #272]	@ 34013138 <VD6G_Init+0x394>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
34013028:	f8df b110 	ldr.w	fp, [pc, #272]	@ 3401313c <VD6G_Init+0x398>
  for (i = 0; i < vtpatch_area_nb; i++) {
3401302c:	f8da 3000 	ldr.w	r3, [sl]
34013030:	4599      	cmp	r9, r3
34013032:	db13      	blt.n	3401305c <VD6G_Init+0x2b8>
  ret = ctx->write8(ctx, 0xd9f8, VT_REVISION);
34013034:	2211      	movs	r2, #17
34013036:	f64d 11f8 	movw	r1, #55800	@ 0xd9f8
3401303a:	4628      	mov	r0, r5
3401303c:	692b      	ldr	r3, [r5, #16]
3401303e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013040:	4604      	mov	r4, r0
34013042:	bb58      	cbnz	r0, 3401309c <VD6G_Init+0x2f8>
  ret = ctx->write8(ctx, 0xaffc, VT_REVISION);
34013044:	2211      	movs	r2, #17
34013046:	f64a 71fc 	movw	r1, #45052	@ 0xaffc
3401304a:	4628      	mov	r0, r5
3401304c:	692b      	ldr	r3, [r5, #16]
3401304e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013050:	4604      	mov	r4, r0
34013052:	b338      	cbz	r0, 340130a4 <VD6G_Init+0x300>
34013054:	f240 13ff 	movw	r3, #511	@ 0x1ff
34013058:	9000      	str	r0, [sp, #0]
3401305a:	e7cc      	b.n	34012ff6 <VD6G_Init+0x252>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
3401305c:	69ef      	ldr	r7, [r5, #28]
3401305e:	f8d8 3004 	ldr.w	r3, [r8, #4]
34013062:	f8b8 1000 	ldrh.w	r1, [r8]
34013066:	4628      	mov	r0, r5
34013068:	eb0b 0204 	add.w	r2, fp, r4
3401306c:	47b8      	blx	r7
    VD6G_TraceError(ctx, ret);
3401306e:	f108 0808 	add.w	r8, r8, #8
34013072:	4607      	mov	r7, r0
34013074:	b928      	cbnz	r0, 34013082 <VD6G_Init+0x2de>
    vtpatch_offset += vtpatch_desc[i].size;
34013076:	f858 3c04 	ldr.w	r3, [r8, #-4]
  for (i = 0; i < vtpatch_area_nb; i++) {
3401307a:	f109 0901 	add.w	r9, r9, #1
    vtpatch_offset += vtpatch_desc[i].size;
3401307e:	441c      	add	r4, r3
  for (i = 0; i < vtpatch_area_nb; i++) {
34013080:	e7d4      	b.n	3401302c <VD6G_Init+0x288>
    VD6G_TraceError(ctx, ret);
34013082:	f240 13f9 	movw	r3, #505	@ 0x1f9
34013086:	4a2a      	ldr	r2, [pc, #168]	@ (34013130 <VD6G_Init+0x38c>)
34013088:	491b      	ldr	r1, [pc, #108]	@ (340130f8 <VD6G_Init+0x354>)
3401308a:	9000      	str	r0, [sp, #0]
3401308c:	4628      	mov	r0, r5
3401308e:	f7ff fd42 	bl	34012b16 <VD6G_error>
34013092:	4628      	mov	r0, r5
34013094:	f7ff fd5c 	bl	34012b50 <display_error>
    return ret;
34013098:	463c      	mov	r4, r7
3401309a:	e691      	b.n	34012dc0 <VD6G_Init+0x1c>
  VD6G_TraceError(ctx, ret);
3401309c:	f240 13fd 	movw	r3, #509	@ 0x1fd
340130a0:	9000      	str	r0, [sp, #0]
340130a2:	e7a8      	b.n	34012ff6 <VD6G_Init+0x252>
  ret = ctx->write8(ctx, 0xbbb4, VT_REVISION);
340130a4:	2211      	movs	r2, #17
340130a6:	f64b 31b4 	movw	r1, #48052	@ 0xbbb4
340130aa:	4628      	mov	r0, r5
340130ac:	692b      	ldr	r3, [r5, #16]
340130ae:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340130b0:	4604      	mov	r4, r0
340130b2:	b118      	cbz	r0, 340130bc <VD6G_Init+0x318>
340130b4:	f240 2301 	movw	r3, #513	@ 0x201
340130b8:	9000      	str	r0, [sp, #0]
340130ba:	e79c      	b.n	34012ff6 <VD6G_Init+0x252>
  ret = ctx->write8(ctx, 0xb898, VT_REVISION);
340130bc:	2211      	movs	r2, #17
340130be:	f64b 0198 	movw	r1, #47256	@ 0xb898
340130c2:	4628      	mov	r0, r5
340130c4:	692b      	ldr	r3, [r5, #16]
340130c6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340130c8:	4604      	mov	r4, r0
340130ca:	b118      	cbz	r0, 340130d4 <VD6G_Init+0x330>
340130cc:	f240 2303 	movw	r3, #515	@ 0x203
340130d0:	9000      	str	r0, [sp, #0]
340130d2:	e790      	b.n	34012ff6 <VD6G_Init+0x252>
  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_END_VTRAM_UPDATE);
340130d4:	2202      	movs	r2, #2
340130d6:	f240 2103 	movw	r1, #515	@ 0x203
340130da:	4628      	mov	r0, r5
340130dc:	692b      	ldr	r3, [r5, #16]
340130de:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340130e0:	4604      	mov	r4, r0
340130e2:	b368      	cbz	r0, 34013140 <VD6G_Init+0x39c>
340130e4:	f240 2306 	movw	r3, #518	@ 0x206
340130e8:	9000      	str	r0, [sp, #0]
340130ea:	e784      	b.n	34012ff6 <VD6G_Init+0x252>
340130ec:	3401cc41 	.word	0x3401cc41
340130f0:	3401cc64 	.word	0x3401cc64
340130f4:	340372c1 	.word	0x340372c1
340130f8:	3401cb0a 	.word	0x3401cb0a
340130fc:	3401cdfe 	.word	0x3401cdfe
34013100:	3401ccf0 	.word	0x3401ccf0
34013104:	3401d306 	.word	0x3401d306
34013108:	340372a2 	.word	0x340372a2
3401310c:	3401cda3 	.word	0x3401cda3
34013110:	34038bb4 	.word	0x34038bb4
34013114:	3403728a 	.word	0x3403728a
34013118:	3401cb30 	.word	0x3401cb30
3401311c:	3401cb50 	.word	0x3401cb50
34013120:	3401cb8c 	.word	0x3401cb8c
34013124:	3403727d 	.word	0x3403727d
34013128:	3401cbb1 	.word	0x3401cbb1
3401312c:	3403726b 	.word	0x3403726b
34013130:	34037251 	.word	0x34037251
34013134:	3403eddc 	.word	0x3403eddc
34013138:	3403edd8 	.word	0x3403edd8
3401313c:	340373ec 	.word	0x340373ec
  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
34013140:	4602      	mov	r2, r0
34013142:	f240 2103 	movw	r1, #515	@ 0x203
34013146:	4628      	mov	r0, r5
34013148:	f7ff fd22 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
3401314c:	4604      	mov	r4, r0
3401314e:	2800      	cmp	r0, #0
34013150:	f47f ae36 	bne.w	34012dc0 <VD6G_Init+0x1c>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
34013154:	2102      	movs	r1, #2
34013156:	4628      	mov	r0, r5
34013158:	f7ff fe08 	bl	34012d6c <VD6G_WaitState>
  if (ret)
3401315c:	4604      	mov	r4, r0
3401315e:	2800      	cmp	r0, #0
34013160:	f47f ae2e 	bne.w	34012dc0 <VD6G_Init+0x1c>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_RD_REVISION, &cur_vtpatch_rd_rev);
34013164:	2120      	movs	r1, #32
34013166:	4628      	mov	r0, r5
34013168:	686b      	ldr	r3, [r5, #4]
3401316a:	f10d 020a 	add.w	r2, sp, #10
3401316e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013170:	4604      	mov	r4, r0
34013172:	b958      	cbnz	r0, 3401318c <VD6G_Init+0x3e8>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GR_REVISION, &cur_vtpatch_gr_rev);
34013174:	2124      	movs	r1, #36	@ 0x24
34013176:	4628      	mov	r0, r5
34013178:	686b      	ldr	r3, [r5, #4]
3401317a:	f10d 020b 	add.w	r2, sp, #11
3401317e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013180:	4604      	mov	r4, r0
34013182:	b138      	cbz	r0, 34013194 <VD6G_Init+0x3f0>
34013184:	f240 2313 	movw	r3, #531	@ 0x213
34013188:	9000      	str	r0, [sp, #0]
3401318a:	e734      	b.n	34012ff6 <VD6G_Init+0x252>
  VD6G_TraceError(ctx, ret);
3401318c:	f240 2311 	movw	r3, #529	@ 0x211
34013190:	9000      	str	r0, [sp, #0]
34013192:	e730      	b.n	34012ff6 <VD6G_Init+0x252>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GT_REVISION, &cur_vtpatch_gt_rev);
34013194:	4632      	mov	r2, r6
34013196:	2126      	movs	r1, #38	@ 0x26
34013198:	4628      	mov	r0, r5
3401319a:	686b      	ldr	r3, [r5, #4]
3401319c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401319e:	4604      	mov	r4, r0
340131a0:	b118      	cbz	r0, 340131aa <VD6G_Init+0x406>
340131a2:	f240 2315 	movw	r3, #533	@ 0x215
340131a6:	9000      	str	r0, [sp, #0]
340131a8:	e725      	b.n	34012ff6 <VD6G_Init+0x252>
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340131aa:	f89d 300a 	ldrb.w	r3, [sp, #10]
      cur_vtpatch_gr_rev != VT_REVISION ||
340131ae:	f89d 100b 	ldrb.w	r1, [sp, #11]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340131b2:	2b11      	cmp	r3, #17
      cur_vtpatch_gt_rev != VT_REVISION) {
340131b4:	f89d 200c 	ldrb.w	r2, [sp, #12]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340131b8:	d004      	beq.n	340131c4 <VD6G_Init+0x420>
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
340131ba:	e9cd 1200 	strd	r1, r2, [sp]
340131be:	2211      	movs	r2, #17
340131c0:	496e      	ldr	r1, [pc, #440]	@ (3401337c <VD6G_Init+0x5d8>)
340131c2:	e6c3      	b.n	34012f4c <VD6G_Init+0x1a8>
  if (cur_vtpatch_rd_rev != VT_REVISION ||
340131c4:	2911      	cmp	r1, #17
340131c6:	d1f8      	bne.n	340131ba <VD6G_Init+0x416>
      cur_vtpatch_gr_rev != VT_REVISION ||
340131c8:	2a11      	cmp	r2, #17
340131ca:	d1f6      	bne.n	340131ba <VD6G_Init+0x416>
  VD6G_notice(ctx, "VT patch %d applied\n", VT_REVISION);
340131cc:	4628      	mov	r0, r5
340131ce:	496c      	ldr	r1, [pc, #432]	@ (34013380 <VD6G_Init+0x5dc>)
340131d0:	f7ff fcaf 	bl	34012b32 <VD6G_notice>
  ret = ctx->read8(ctx, VD6G_REG_OPTICAL_REVISION, &reg8);
340131d4:	4632      	mov	r2, r6
340131d6:	211a      	movs	r1, #26
340131d8:	4628      	mov	r0, r5
340131da:	686b      	ldr	r3, [r5, #4]
340131dc:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340131de:	4604      	mov	r4, r0
340131e0:	b120      	cbz	r0, 340131ec <VD6G_Init+0x448>
340131e2:	f240 2341 	movw	r3, #577	@ 0x241
340131e6:	4a67      	ldr	r2, [pc, #412]	@ (34013384 <VD6G_Init+0x5e0>)
340131e8:	9000      	str	r0, [sp, #0]
340131ea:	e632      	b.n	34012e52 <VD6G_Init+0xae>
  if (!(reg8 & 1)) {
340131ec:	f89d 300c 	ldrb.w	r3, [sp, #12]
340131f0:	f013 0301 	ands.w	r3, r3, #1
340131f4:	d008      	beq.n	34013208 <VD6G_Init+0x464>
  switch (drv_ctx->config_save.flip_mirror_mode) {
340131f6:	f895 203c 	ldrb.w	r2, [r5, #60]	@ 0x3c
340131fa:	2a03      	cmp	r2, #3
340131fc:	d81b      	bhi.n	34013236 <VD6G_Init+0x492>
340131fe:	e8df f002 	tbb	[pc, r2]
34013202:	021f      	.short	0x021f
34013204:	1803      	.short	0x1803
34013206:	2304      	movs	r3, #4
34013208:	f240 4767 	movw	r7, #1127	@ 0x467
  for (i = 0; i < VD6G_GPIO_NB; i++) {
3401320c:	f240 496f 	movw	r9, #1135	@ 0x46f
    ctx->bayer = VD6G_BAYER_RGGB;
34013210:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
34013214:	f105 085b 	add.w	r8, r5, #91	@ 0x5b
    ret = ctx->write8(ctx, VD6G_REG_GPIO_x_CTRL(i), drv_ctx->config_save.gpio_ctrl[i]);
34013218:	4639      	mov	r1, r7
3401321a:	4628      	mov	r0, r5
3401321c:	692b      	ldr	r3, [r5, #16]
3401321e:	f818 2f01 	ldrb.w	r2, [r8, #1]!
34013222:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34013224:	4604      	mov	r4, r0
34013226:	b168      	cbz	r0, 34013244 <VD6G_Init+0x4a0>
34013228:	f44f 731d 	mov.w	r3, #628	@ 0x274
3401322c:	4a56      	ldr	r2, [pc, #344]	@ (34013388 <VD6G_Init+0x5e4>)
3401322e:	9000      	str	r0, [sp, #0]
34013230:	e60f      	b.n	34012e52 <VD6G_Init+0xae>
  case VD6G_MIRROR_FLIP:
34013232:	4613      	mov	r3, r2
34013234:	e7e8      	b.n	34013208 <VD6G_Init+0x464>
    assert(0);
34013236:	f240 2156 	movw	r1, #598	@ 0x256
3401323a:	4b54      	ldr	r3, [pc, #336]	@ (3401338c <VD6G_Init+0x5e8>)
3401323c:	4a51      	ldr	r2, [pc, #324]	@ (34013384 <VD6G_Init+0x5e0>)
3401323e:	e643      	b.n	34012ec8 <VD6G_Init+0x124>
  switch (drv_ctx->config_save.flip_mirror_mode) {
34013240:	2302      	movs	r3, #2
34013242:	e7e1      	b.n	34013208 <VD6G_Init+0x464>
  for (i = 0; i < VD6G_GPIO_NB; i++) {
34013244:	3701      	adds	r7, #1
34013246:	b2bf      	uxth	r7, r7
34013248:	454f      	cmp	r7, r9
3401324a:	d1e5      	bne.n	34013218 <VD6G_Init+0x474>
  ret = VD6G_ComputeClocks(ctx, drv_ctx->config_save.ext_clock_freq_in_hz, &pll_prediv, &pll_mult);
3401324c:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
  const unsigned int predivs[] = { 1, 2, 4 };
3401324e:	4a50      	ldr	r2, [pc, #320]	@ (34013390 <VD6G_Init+0x5ec>)
34013250:	ca07      	ldmia	r2, {r0, r1, r2}
34013252:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  if (ext_clock < 6 * M_HZ ||
34013256:	484f      	ldr	r0, [pc, #316]	@ (34013394 <VD6G_Init+0x5f0>)
34013258:	f5a3 02b7 	sub.w	r2, r3, #5996544	@ 0x5b8000
3401325c:	f5a2 6258 	sub.w	r2, r2, #3456	@ 0xd80
34013260:	4282      	cmp	r2, r0
34013262:	4631      	mov	r1, r6
34013264:	d830      	bhi.n	340132c8 <VD6G_Init+0x524>
    if (ext_clock / *pll_prediv < 12 * M_HZ)
34013266:	4a4c      	ldr	r2, [pc, #304]	@ (34013398 <VD6G_Init+0x5f4>)
    *pll_prediv = predivs[i];
34013268:	f851 0b04 	ldr.w	r0, [r1], #4
    if (ext_clock / *pll_prediv < 12 * M_HZ)
3401326c:	fa5f f880 	uxtb.w	r8, r0
34013270:	fbb3 f0f8 	udiv	r0, r3, r8
34013274:	4290      	cmp	r0, r2
34013276:	d302      	bcc.n	3401327e <VD6G_Init+0x4da>
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
34013278:	3401      	adds	r4, #1
3401327a:	2c03      	cmp	r4, #3
3401327c:	d1f4      	bne.n	34013268 <VD6G_Init+0x4c4>
  *pll_mult = (VD6G_TARGET_PLL * *pll_prediv + ext_clock / 2) / ext_clock;
3401327e:	4a47      	ldr	r2, [pc, #284]	@ (3401339c <VD6G_Init+0x5f8>)
34013280:	085f      	lsrs	r7, r3, #1
34013282:	fb02 7708 	mla	r7, r2, r8, r7
34013286:	fbb7 f7f3 	udiv	r7, r7, r3
  VD6G_dbg(ctx, 0, "Ext Clock = %d Hz\n", ext_clock);
3401328a:	2100      	movs	r1, #0
3401328c:	4628      	mov	r0, r5
3401328e:	4a44      	ldr	r2, [pc, #272]	@ (340133a0 <VD6G_Init+0x5fc>)
34013290:	f7ff fd34 	bl	34012cfc <VD6G_dbg.constprop.0>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
34013294:	b2ff      	uxtb	r7, r7
  VD6G_dbg(ctx, 0, "PLL prediv = %d\n", *pll_prediv);
34013296:	4643      	mov	r3, r8
34013298:	2100      	movs	r1, #0
3401329a:	4628      	mov	r0, r5
3401329c:	4a41      	ldr	r2, [pc, #260]	@ (340133a4 <VD6G_Init+0x600>)
3401329e:	f7ff fd2d 	bl	34012cfc <VD6G_dbg.constprop.0>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
340132a2:	463b      	mov	r3, r7
340132a4:	2100      	movs	r1, #0
340132a6:	4628      	mov	r0, r5
340132a8:	4a3f      	ldr	r2, [pc, #252]	@ (340133a8 <VD6G_Init+0x604>)
340132aa:	f7ff fd27 	bl	34012cfc <VD6G_dbg.constprop.0>
  ret = ctx->write32(ctx, VD6G_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
340132ae:	f44f 7108 	mov.w	r1, #544	@ 0x220
340132b2:	4628      	mov	r0, r5
340132b4:	69ab      	ldr	r3, [r5, #24]
340132b6:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
340132b8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340132ba:	4604      	mov	r4, r0
340132bc:	b130      	cbz	r0, 340132cc <VD6G_Init+0x528>
340132be:	f44f 7331 	mov.w	r3, #708	@ 0x2c4
340132c2:	9000      	str	r0, [sp, #0]
    VD6G_TraceError(ctx, ret);
340132c4:	4a39      	ldr	r2, [pc, #228]	@ (340133ac <VD6G_Init+0x608>)
340132c6:	e5c4      	b.n	34012e52 <VD6G_Init+0xae>
    VD6G_error(ctx, "External clock out of rangen\n");
340132c8:	4939      	ldr	r1, [pc, #228]	@ (340133b0 <VD6G_Init+0x60c>)
340132ca:	e5d9      	b.n	34012e80 <VD6G_Init+0xdc>
  ret = ctx->write8(ctx, VD6G_REG_CLK_PLL_PREDIV, pll_prediv);
340132cc:	4642      	mov	r2, r8
340132ce:	f44f 7109 	mov.w	r1, #548	@ 0x224
340132d2:	4628      	mov	r0, r5
340132d4:	692b      	ldr	r3, [r5, #16]
340132d6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340132d8:	4604      	mov	r4, r0
340132da:	b958      	cbnz	r0, 340132f4 <VD6G_Init+0x550>
  ret = ctx->write8(ctx, VD6G_REG_CLK_SYS_PLL_MULT, pll_mult);
340132dc:	463a      	mov	r2, r7
340132de:	f240 2126 	movw	r1, #550	@ 0x226
340132e2:	4628      	mov	r0, r5
340132e4:	692b      	ldr	r3, [r5, #16]
340132e6:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340132e8:	4604      	mov	r4, r0
340132ea:	b138      	cbz	r0, 340132fc <VD6G_Init+0x558>
340132ec:	f240 23ca 	movw	r3, #714	@ 0x2ca
340132f0:	9000      	str	r0, [sp, #0]
340132f2:	e7e7      	b.n	340132c4 <VD6G_Init+0x520>
  VD6G_TraceError(ctx, ret);
340132f4:	f240 23c7 	movw	r3, #711	@ 0x2c7
340132f8:	9000      	str	r0, [sp, #0]
340132fa:	e7e3      	b.n	340132c4 <VD6G_Init+0x520>
  if (drv_ctx->config_save.line_len) {
340132fc:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
340132fe:	b962      	cbnz	r2, 3401331a <VD6G_Init+0x576>
  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_length);
34013300:	4632      	mov	r2, r6
34013302:	f44f 7140 	mov.w	r1, #768	@ 0x300
34013306:	4628      	mov	r0, r5
34013308:	68ab      	ldr	r3, [r5, #8]
3401330a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401330c:	4604      	mov	r4, r0
3401330e:	b188      	cbz	r0, 34013334 <VD6G_Init+0x590>
34013310:	f44f 7350 	mov.w	r3, #832	@ 0x340
34013314:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013316:	4a27      	ldr	r2, [pc, #156]	@ (340133b4 <VD6G_Init+0x610>)
34013318:	e59b      	b.n	34012e52 <VD6G_Init+0xae>
    ret = ctx->write16(ctx, VD6G_LINE_LENGTH, drv_ctx->config_save.line_len);
3401331a:	f44f 7140 	mov.w	r1, #768	@ 0x300
3401331e:	4628      	mov	r0, r5
34013320:	696b      	ldr	r3, [r5, #20]
34013322:	b292      	uxth	r2, r2
34013324:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
34013326:	4604      	mov	r4, r0
34013328:	2800      	cmp	r0, #0
3401332a:	d0e9      	beq.n	34013300 <VD6G_Init+0x55c>
3401332c:	f240 23ce 	movw	r3, #718	@ 0x2ce
34013330:	9000      	str	r0, [sp, #0]
34013332:	e7c7      	b.n	340132c4 <VD6G_Init+0x520>
  VD6G_dbg(ctx, 0, "Line len = %d\n", line_length);
34013334:	4601      	mov	r1, r0
34013336:	f8bd 300c 	ldrh.w	r3, [sp, #12]
3401333a:	4628      	mov	r0, r5
3401333c:	4a1e      	ldr	r2, [pc, #120]	@ (340133b8 <VD6G_Init+0x614>)
3401333e:	f7ff fcdd 	bl	34012cfc <VD6G_dbg.constprop.0>
  frame_length = VD6G_PIXEL_CLOCK / (line_length * drv_ctx->config_save.frame_rate);
34013342:	6baa      	ldr	r2, [r5, #56]	@ 0x38
34013344:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013348:	4e1c      	ldr	r6, [pc, #112]	@ (340133bc <VD6G_Init+0x618>)
3401334a:	4353      	muls	r3, r2
3401334c:	fb96 f6f3 	sdiv	r6, r6, r3
  VD6G_dbg(ctx, 0, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
34013350:	4621      	mov	r1, r4
34013352:	4628      	mov	r0, r5
34013354:	9200      	str	r2, [sp, #0]
34013356:	b2b3      	uxth	r3, r6
34013358:	4a19      	ldr	r2, [pc, #100]	@ (340133c0 <VD6G_Init+0x61c>)
3401335a:	f7ff fccf 	bl	34012cfc <VD6G_dbg.constprop.0>
  ret = ctx->write16(ctx, VD6G_FRAME_LENGTH, frame_length);
3401335e:	f44f 618b 	mov.w	r1, #1112	@ 0x458
34013362:	4628      	mov	r0, r5
34013364:	696b      	ldr	r3, [r5, #20]
34013366:	b2b2      	uxth	r2, r6
34013368:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401336a:	4604      	mov	r4, r0
3401336c:	2800      	cmp	r0, #0
3401336e:	f43f ad27 	beq.w	34012dc0 <VD6G_Init+0x1c>
34013372:	f240 3346 	movw	r3, #838	@ 0x346
34013376:	9000      	str	r0, [sp, #0]
34013378:	e7cd      	b.n	34013316 <VD6G_Init+0x572>
3401337a:	bf00      	nop
3401337c:	3401ce14 	.word	0x3401ce14
34013380:	3401ce4d 	.word	0x3401ce4d
34013384:	3403723f 	.word	0x3403723f
34013388:	34037234 	.word	0x34037234
3401338c:	3401d306 	.word	0x3401d306
34013390:	3401be18 	.word	0x3401be18
34013394:	01406f40 	.word	0x01406f40
34013398:	00b71b00 	.word	0x00b71b00
3401339c:	2fec1100 	.word	0x2fec1100
340133a0:	3401ce80 	.word	0x3401ce80
340133a4:	3401ce93 	.word	0x3401ce93
340133a8:	3401cea4 	.word	0x3401cea4
340133ac:	34037223 	.word	0x34037223
340133b0:	3401ce62 	.word	0x3401ce62
340133b4:	3403720f 	.word	0x3403720f
340133b8:	3401ceb3 	.word	0x3401ceb3
340133bc:	09959d00 	.word	0x09959d00
340133c0:	3401cd32 	.word	0x3401cd32

340133c4 <VD6G_DeInit>:

int VD6G_DeInit(VD6G_Ctx_t *ctx)
{
340133c4:	b538      	push	{r3, r4, r5, lr}
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;

  if (drv_ctx->is_streaming)
340133c6:	6ac5      	ldr	r5, [r0, #44]	@ 0x2c
{
340133c8:	4604      	mov	r4, r0
  if (drv_ctx->is_streaming)
340133ca:	b945      	cbnz	r5, 340133de <VD6G_DeInit+0x1a>
    return -1;

  ctx->shutdown_pin(ctx, 0);
340133cc:	6803      	ldr	r3, [r0, #0]
340133ce:	4629      	mov	r1, r5
340133d0:	4798      	blx	r3
  ctx->delay(ctx, 10);
340133d2:	210a      	movs	r1, #10
340133d4:	4620      	mov	r0, r4
340133d6:	6a23      	ldr	r3, [r4, #32]
340133d8:	4798      	blx	r3

  return 0;
}
340133da:	4628      	mov	r0, r5
340133dc:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
340133de:	f04f 35ff 	mov.w	r5, #4294967295
340133e2:	e7fa      	b.n	340133da <VD6G_DeInit+0x16>

340133e4 <VD6G_Start>:
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340133e4:	6c83      	ldr	r3, [r0, #72]	@ 0x48

int VD6G_Start(VD6G_Ctx_t *ctx)
{
340133e6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340133e8:	3b01      	subs	r3, #1
340133ea:	2b01      	cmp	r3, #1
{
340133ec:	4605      	mov	r5, r0
  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
340133ee:	d904      	bls.n	340133fa <VD6G_Start+0x16>
    return ret;
340133f0:	f04f 34ff 	mov.w	r4, #4294967295
  if (ret)
    return ret;
  drv_ctx->is_streaming = 1;

  return 0;
}
340133f4:	4620      	mov	r0, r4
340133f6:	b002      	add	sp, #8
340133f8:	bd70      	pop	{r4, r5, r6, pc}
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
340133fa:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
340133fc:	2208      	movs	r2, #8
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
340133fe:	3b00      	subs	r3, #0
34013400:	bf18      	it	ne
34013402:	2301      	movne	r3, #1
34013404:	64c3      	str	r3, [r0, #76]	@ 0x4c
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
34013406:	6d03      	ldr	r3, [r0, #80]	@ 0x50
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013408:	f240 310a 	movw	r1, #778	@ 0x30a
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
3401340c:	3b00      	subs	r3, #0
3401340e:	bf18      	it	ne
34013410:	2301      	movne	r3, #1
34013412:	6503      	str	r3, [r0, #80]	@ 0x50
  out_itf->data_lane1_swap_enable = !!out_itf->data_lane1_swap_enable;
34013414:	6d43      	ldr	r3, [r0, #84]	@ 0x54
34013416:	3b00      	subs	r3, #0
34013418:	bf18      	it	ne
3401341a:	2301      	movne	r3, #1
3401341c:	6543      	str	r3, [r0, #84]	@ 0x54
  out_itf->data_lanes_mapping_swap_enable = !!out_itf->data_lanes_mapping_swap_enable;
3401341e:	6d83      	ldr	r3, [r0, #88]	@ 0x58
34013420:	3b00      	subs	r3, #0
34013422:	bf18      	it	ne
34013424:	2301      	movne	r3, #1
34013426:	6583      	str	r3, [r0, #88]	@ 0x58
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
34013428:	6903      	ldr	r3, [r0, #16]
3401342a:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401342c:	4604      	mov	r4, r0
3401342e:	b9e8      	cbnz	r0, 3401346c <VD6G_Start+0x88>
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
34013430:	e9d5 0315 	ldrd	r0, r3, [r5, #84]	@ 0x54
             !out_itf->data_lanes_mapping_swap_enable << 7 |
34013434:	6d2a      	ldr	r2, [r5, #80]	@ 0x50
             out_itf->clock_lane_swap_enable << 3 |
34013436:	6ca9      	ldr	r1, [r5, #72]	@ 0x48
             !out_itf->data_lanes_mapping_swap_enable << 7 |
34013438:	0192      	lsls	r2, r2, #6
             out_itf->clock_lane_swap_enable << 3 |
3401343a:	ea42 2240 	orr.w	r2, r2, r0, lsl #9
3401343e:	430a      	orrs	r2, r1
34013440:	ea42 1203 	orr.w	r2, r2, r3, lsl #4
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
34013444:	fab3 f383 	clz	r3, r3
             out_itf->data_lanes_mapping_swap_enable << 4 |
34013448:	6ce9      	ldr	r1, [r5, #76]	@ 0x4c
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
3401344a:	095b      	lsrs	r3, r3, #5
             out_itf->clock_lane_swap_enable << 3 |
3401344c:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
34013450:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
  ret = ctx->write16(ctx, VD6G_REG_OIF_CTRL, oif_ctrl);
34013454:	f44f 7143 	mov.w	r1, #780	@ 0x30c
34013458:	4628      	mov	r0, r5
3401345a:	696b      	ldr	r3, [r5, #20]
3401345c:	b292      	uxth	r2, r2
3401345e:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013460:	4604      	mov	r4, r0
34013462:	b178      	cbz	r0, 34013484 <VD6G_Start+0xa0>
34013464:	f240 23ee 	movw	r3, #750	@ 0x2ee
34013468:	9000      	str	r0, [sp, #0]
3401346a:	e002      	b.n	34013472 <VD6G_Start+0x8e>
  VD6G_TraceError(ctx, ret);
3401346c:	f44f 7339 	mov.w	r3, #740	@ 0x2e4
34013470:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013472:	4a74      	ldr	r2, [pc, #464]	@ (34013644 <VD6G_Start+0x260>)
34013474:	4628      	mov	r0, r5
34013476:	4974      	ldr	r1, [pc, #464]	@ (34013648 <VD6G_Start+0x264>)
34013478:	f7ff fb4d 	bl	34012b16 <VD6G_error>
3401347c:	4628      	mov	r0, r5
3401347e:	f7ff fb67 	bl	34012b50 <display_error>
  if (ret)
34013482:	e7b7      	b.n	340133f4 <VD6G_Start+0x10>
  ret = ctx->write16(ctx, VD6G_REG_OIF_CSI_BITRATE, 804);
34013484:	f44f 7249 	mov.w	r2, #804	@ 0x324
34013488:	f240 3112 	movw	r1, #786	@ 0x312
3401348c:	4628      	mov	r0, r5
3401348e:	696b      	ldr	r3, [r5, #20]
34013490:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013492:	4604      	mov	r4, r0
34013494:	b118      	cbz	r0, 3401349e <VD6G_Start+0xba>
34013496:	f240 23f2 	movw	r3, #754	@ 0x2f2
3401349a:	9000      	str	r0, [sp, #0]
3401349c:	e7e9      	b.n	34013472 <VD6G_Start+0x8e>
  ret = ctx->write8(ctx, VD6G_REG_OIF_IMG_CTRL, 0x2a);
3401349e:	222a      	movs	r2, #42	@ 0x2a
340134a0:	f240 310f 	movw	r1, #783	@ 0x30f
340134a4:	4628      	mov	r0, r5
340134a6:	692b      	ldr	r3, [r5, #16]
340134a8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340134aa:	4604      	mov	r4, r0
340134ac:	b118      	cbz	r0, 340134b6 <VD6G_Start+0xd2>
340134ae:	f240 23f6 	movw	r3, #758	@ 0x2f6
340134b2:	9000      	str	r0, [sp, #0]
340134b4:	e7dd      	b.n	34013472 <VD6G_Start+0x8e>
  mode = VD6G_Resolution2Mode(drv_ctx->config_save.resolution);
340134b6:	f895 3034 	ldrb.w	r3, [r5, #52]	@ 0x34
  switch (resolution) {
340134ba:	2b08      	cmp	r3, #8
340134bc:	d898      	bhi.n	340133f0 <VD6G_Start+0xc>
340134be:	4a63      	ldr	r2, [pc, #396]	@ (3401364c <VD6G_Start+0x268>)
340134c0:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
  if (!mode)
340134c4:	2e00      	cmp	r6, #0
340134c6:	d093      	beq.n	340133f0 <VD6G_Start+0xc>
  ret = ctx->write8(ctx, VD6G_REG_READOUT_CTRL, mode->bin_mode);
340134c8:	f240 417e 	movw	r1, #1150	@ 0x47e
340134cc:	4628      	mov	r0, r5
340134ce:	692b      	ldr	r3, [r5, #16]
340134d0:	7a32      	ldrb	r2, [r6, #8]
340134d2:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340134d4:	4604      	mov	r4, r0
340134d6:	b120      	cbz	r0, 340134e2 <VD6G_Start+0xfe>
340134d8:	f240 3329 	movw	r3, #809	@ 0x329
340134dc:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340134de:	4a5c      	ldr	r2, [pc, #368]	@ (34013650 <VD6G_Start+0x26c>)
340134e0:	e7c8      	b.n	34013474 <VD6G_Start+0x90>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_START, mode->crop.left);
340134e2:	f240 415e 	movw	r1, #1118	@ 0x45e
340134e6:	4628      	mov	r0, r5
340134e8:	696b      	ldr	r3, [r5, #20]
340134ea:	89b2      	ldrh	r2, [r6, #12]
340134ec:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340134ee:	4604      	mov	r4, r0
340134f0:	b978      	cbnz	r0, 34013512 <VD6G_Start+0x12e>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_END, mode->crop.left + mode->crop.width - 1);
340134f2:	6973      	ldr	r3, [r6, #20]
340134f4:	68f2      	ldr	r2, [r6, #12]
340134f6:	f44f 618c 	mov.w	r1, #1120	@ 0x460
340134fa:	441a      	add	r2, r3
340134fc:	3a01      	subs	r2, #1
340134fe:	4628      	mov	r0, r5
34013500:	696b      	ldr	r3, [r5, #20]
34013502:	b292      	uxth	r2, r2
34013504:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013506:	4604      	mov	r4, r0
34013508:	b138      	cbz	r0, 3401351a <VD6G_Start+0x136>
3401350a:	f240 332e 	movw	r3, #814	@ 0x32e
3401350e:	9000      	str	r0, [sp, #0]
34013510:	e7e5      	b.n	340134de <VD6G_Start+0xfa>
  VD6G_TraceError(ctx, ret);
34013512:	f44f 734b 	mov.w	r3, #812	@ 0x32c
34013516:	9000      	str	r0, [sp, #0]
34013518:	e7e1      	b.n	340134de <VD6G_Start+0xfa>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_START, mode->crop.top);
3401351a:	f240 4162 	movw	r1, #1122	@ 0x462
3401351e:	4628      	mov	r0, r5
34013520:	696b      	ldr	r3, [r5, #20]
34013522:	8a32      	ldrh	r2, [r6, #16]
34013524:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013526:	4604      	mov	r4, r0
34013528:	b118      	cbz	r0, 34013532 <VD6G_Start+0x14e>
3401352a:	f240 3331 	movw	r3, #817	@ 0x331
3401352e:	9000      	str	r0, [sp, #0]
34013530:	e7d5      	b.n	340134de <VD6G_Start+0xfa>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_END, mode->crop.top + mode->crop.height - 1);
34013532:	69b3      	ldr	r3, [r6, #24]
34013534:	6932      	ldr	r2, [r6, #16]
34013536:	f240 4164 	movw	r1, #1124	@ 0x464
3401353a:	441a      	add	r2, r3
3401353c:	3a01      	subs	r2, #1
3401353e:	4628      	mov	r0, r5
34013540:	696b      	ldr	r3, [r5, #20]
34013542:	b292      	uxth	r2, r2
34013544:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013546:	4604      	mov	r4, r0
34013548:	b118      	cbz	r0, 34013552 <VD6G_Start+0x16e>
3401354a:	f240 3333 	movw	r3, #819	@ 0x333
3401354e:	9000      	str	r0, [sp, #0]
34013550:	e7c5      	b.n	340134de <VD6G_Start+0xfa>
  return VD6G_SetExposureModeInternal(ctx, drv_ctx->config_save.exposure_mode);
34013552:	4628      	mov	r0, r5
34013554:	f895 1064 	ldrb.w	r1, [r5, #100]	@ 0x64
34013558:	f7ff fb4a 	bl	34012bf0 <VD6G_SetExposureModeInternal>
  if (ret)
3401355c:	4604      	mov	r4, r0
3401355e:	2800      	cmp	r0, #0
34013560:	f47f af48 	bne.w	340133f4 <VD6G_Start+0x10>
  switch (drv_ctx->config_save.flip_mirror_mode) {
34013564:	f895 303c 	ldrb.w	r3, [r5, #60]	@ 0x3c
34013568:	2b03      	cmp	r3, #3
3401356a:	f63f af41 	bhi.w	340133f0 <VD6G_Start+0xc>
  ret = ctx->write8(ctx, VD6G_REG_ORIENTATION, mode);
3401356e:	4a39      	ldr	r2, [pc, #228]	@ (34013654 <VD6G_Start+0x270>)
34013570:	692c      	ldr	r4, [r5, #16]
34013572:	f240 3102 	movw	r1, #770	@ 0x302
34013576:	4628      	mov	r0, r5
34013578:	5cd2      	ldrb	r2, [r2, r3]
3401357a:	47a0      	blx	r4
  VD6G_TraceError(ctx, ret);
3401357c:	4604      	mov	r4, r0
3401357e:	b9a8      	cbnz	r0, 340135ac <VD6G_Start+0x1c8>
  switch (drv_ctx->config_save.patgen) {
34013580:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
34013584:	2b06      	cmp	r3, #6
34013586:	f63f af33 	bhi.w	340133f0 <VD6G_Start+0xc>
3401358a:	4a33      	ldr	r2, [pc, #204]	@ (34013658 <VD6G_Start+0x274>)
3401358c:	f832 6013 	ldrh.w	r6, [r2, r3, lsl #1]
  if (drv_ctx->config_save.patgen != VD6G_PATGEN_DISABLE)
34013590:	b1eb      	cbz	r3, 340135ce <VD6G_Start+0x1ea>
    ret = ctx->write8(ctx, VD6G_REG_DUSTER_CTRL, VD6G_DUSTER_CTRL_DISABLE);
34013592:	4602      	mov	r2, r0
34013594:	f44f 7146 	mov.w	r1, #792	@ 0x318
34013598:	4628      	mov	r0, r5
3401359a:	692b      	ldr	r3, [r5, #16]
3401359c:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
3401359e:	4604      	mov	r4, r0
340135a0:	b148      	cbz	r0, 340135b6 <VD6G_Start+0x1d2>
340135a2:	f240 3392 	movw	r3, #914	@ 0x392
340135a6:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340135a8:	4a2c      	ldr	r2, [pc, #176]	@ (3401365c <VD6G_Start+0x278>)
340135aa:	e763      	b.n	34013474 <VD6G_Start+0x90>
  VD6G_TraceError(ctx, ret);
340135ac:	f240 336a 	movw	r3, #874	@ 0x36a
340135b0:	4a2b      	ldr	r2, [pc, #172]	@ (34013660 <VD6G_Start+0x27c>)
340135b2:	9000      	str	r0, [sp, #0]
340135b4:	e75e      	b.n	34013474 <VD6G_Start+0x90>
    ret = ctx->write8(ctx, VD6G_REG_DARKCAL_CTRL, VD6G_DARKCAL_CTRL_DISABLE_DARKAVG);
340135b6:	2202      	movs	r2, #2
340135b8:	f44f 7150 	mov.w	r1, #832	@ 0x340
340135bc:	4628      	mov	r0, r5
340135be:	692b      	ldr	r3, [r5, #16]
340135c0:	4798      	blx	r3
    VD6G_TraceError(ctx, ret);
340135c2:	4604      	mov	r4, r0
340135c4:	b118      	cbz	r0, 340135ce <VD6G_Start+0x1ea>
340135c6:	f44f 7365 	mov.w	r3, #916	@ 0x394
340135ca:	9000      	str	r0, [sp, #0]
340135cc:	e7ec      	b.n	340135a8 <VD6G_Start+0x1c4>
  ret = ctx->write16(ctx, VD6G_REG_PATGEN_CTRL, value);
340135ce:	4632      	mov	r2, r6
340135d0:	f44f 6180 	mov.w	r1, #1024	@ 0x400
340135d4:	4628      	mov	r0, r5
340135d6:	696b      	ldr	r3, [r5, #20]
340135d8:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340135da:	4604      	mov	r4, r0
340135dc:	b118      	cbz	r0, 340135e6 <VD6G_Start+0x202>
340135de:	f44f 7366 	mov.w	r3, #920	@ 0x398
340135e2:	9000      	str	r0, [sp, #0]
340135e4:	e7e0      	b.n	340135a8 <VD6G_Start+0x1c4>
  return VD6G_SetFlicker(ctx, drv_ctx->config_save.flicker);
340135e6:	4628      	mov	r0, r5
340135e8:	f895 1045 	ldrb.w	r1, [r5, #69]	@ 0x45
340135ec:	f7ff fb20 	bl	34012c30 <VD6G_SetFlicker>
  if (ret)
340135f0:	4604      	mov	r4, r0
340135f2:	2800      	cmp	r0, #0
340135f4:	f47f aefe 	bne.w	340133f4 <VD6G_Start+0x10>
  ret = ctx->write8(ctx, VD6G_REG_STBY, VD6G_CMD_START_STREAM);
340135f8:	2201      	movs	r2, #1
340135fa:	f240 2101 	movw	r1, #513	@ 0x201
340135fe:	4628      	mov	r0, r5
34013600:	692b      	ldr	r3, [r5, #16]
34013602:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013604:	4604      	mov	r4, r0
34013606:	b120      	cbz	r0, 34013612 <VD6G_Start+0x22e>
34013608:	f44f 737c 	mov.w	r3, #1008	@ 0x3f0
3401360c:	4a15      	ldr	r2, [pc, #84]	@ (34013664 <VD6G_Start+0x280>)
3401360e:	9000      	str	r0, [sp, #0]
34013610:	e730      	b.n	34013474 <VD6G_Start+0x90>
  ret = VD6G_PollReg8(ctx, VD6G_REG_STBY, VD6G_CMD_ACK);
34013612:	4602      	mov	r2, r0
34013614:	f240 2101 	movw	r1, #513	@ 0x201
34013618:	4628      	mov	r0, r5
3401361a:	f7ff fab9 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
3401361e:	4604      	mov	r4, r0
34013620:	2800      	cmp	r0, #0
34013622:	f47f aee7 	bne.w	340133f4 <VD6G_Start+0x10>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_STREAMING);
34013626:	2103      	movs	r1, #3
34013628:	4628      	mov	r0, r5
3401362a:	f7ff fb9f 	bl	34012d6c <VD6G_WaitState>
  if (ret)
3401362e:	4604      	mov	r4, r0
34013630:	2800      	cmp	r0, #0
34013632:	f47f aedf 	bne.w	340133f4 <VD6G_Start+0x10>
  VD6G_notice(ctx, "Streaming is on\n");
34013636:	4628      	mov	r0, r5
34013638:	490b      	ldr	r1, [pc, #44]	@ (34013668 <VD6G_Start+0x284>)
3401363a:	f7ff fa7a 	bl	34012b32 <VD6G_notice>
  drv_ctx->is_streaming = 1;
3401363e:	2301      	movs	r3, #1
34013640:	62eb      	str	r3, [r5, #44]	@ 0x2c
  return 0;
34013642:	e6d7      	b.n	340133f4 <VD6G_Start+0x10>
34013644:	340371fe 	.word	0x340371fe
34013648:	3401cb0a 	.word	0x3401cb0a
3401364c:	340370b0 	.word	0x340370b0
34013650:	340371ef 	.word	0x340371ef
34013654:	340370aa 	.word	0x340370aa
34013658:	3403709c 	.word	0x3403709c
3401365c:	340371ac 	.word	0x340371ac
34013660:	340371bd 	.word	0x340371bd
34013664:	34037188 	.word	0x34037188
34013668:	3401cd92 	.word	0x3401cd92

3401366c <VD6G_Stop>:

int VD6G_Stop(VD6G_Ctx_t *ctx)
{
3401366c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
3401366e:	6903      	ldr	r3, [r0, #16]
34013670:	2201      	movs	r2, #1
34013672:	f240 2102 	movw	r1, #514	@ 0x202
{
34013676:	4605      	mov	r5, r0
  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
34013678:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401367a:	4604      	mov	r4, r0
3401367c:	b998      	cbnz	r0, 340136a6 <VD6G_Stop+0x3a>
  ret = VD6G_PollReg8(ctx, VD6G_REG_STREAMING, VD6G_CMD_ACK);
3401367e:	4602      	mov	r2, r0
34013680:	f240 2102 	movw	r1, #514	@ 0x202
34013684:	4628      	mov	r0, r5
34013686:	f7ff fa83 	bl	34012b90 <VD6G_PollReg8>
  if (ret)
3401368a:	4604      	mov	r4, r0
3401368c:	b9b0      	cbnz	r0, 340136bc <VD6G_Stop+0x50>
  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3401368e:	2102      	movs	r1, #2
34013690:	4628      	mov	r0, r5
34013692:	f7ff fb6b 	bl	34012d6c <VD6G_WaitState>
  if (ret)
34013696:	4604      	mov	r4, r0
34013698:	b980      	cbnz	r0, 340136bc <VD6G_Stop+0x50>
  VD6G_notice(ctx, "Streaming is off\n");
3401369a:	4628      	mov	r0, r5
3401369c:	4909      	ldr	r1, [pc, #36]	@ (340136c4 <VD6G_Stop+0x58>)
3401369e:	f7ff fa48 	bl	34012b32 <VD6G_notice>
  int ret;

  ret = VD6G_StopStreaming(ctx);
  if (ret)
    return ret;
  drv_ctx->is_streaming = 0;
340136a2:	62ec      	str	r4, [r5, #44]	@ 0x2c

  return 0;
340136a4:	e00a      	b.n	340136bc <VD6G_Stop+0x50>
  VD6G_TraceError(ctx, ret);
340136a6:	9000      	str	r0, [sp, #0]
340136a8:	f240 4304 	movw	r3, #1028	@ 0x404
340136ac:	4628      	mov	r0, r5
340136ae:	4a06      	ldr	r2, [pc, #24]	@ (340136c8 <VD6G_Stop+0x5c>)
340136b0:	4906      	ldr	r1, [pc, #24]	@ (340136cc <VD6G_Stop+0x60>)
340136b2:	f7ff fa30 	bl	34012b16 <VD6G_error>
340136b6:	4628      	mov	r0, r5
340136b8:	f7ff fa4a 	bl	34012b50 <display_error>
}
340136bc:	4620      	mov	r0, r4
340136be:	b003      	add	sp, #12
340136c0:	bd30      	pop	{r4, r5, pc}
340136c2:	bf00      	nop
340136c4:	3401cc1e 	.word	0x3401cc1e
340136c8:	34037175 	.word	0x34037175
340136cc:	3401cb0a 	.word	0x3401cb0a

340136d0 <VD6G_SetExposureMode>:

  return 0;
}

int VD6G_SetExposureMode(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
340136d0:	b538      	push	{r3, r4, r5, lr}
340136d2:	4604      	mov	r4, r0
340136d4:	460d      	mov	r5, r1
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
  int ret;

  ret = VD6G_SetExposureModeInternal(ctx, mode);
340136d6:	f7ff fa8b 	bl	34012bf0 <VD6G_SetExposureModeInternal>
  if (ret)
340136da:	b908      	cbnz	r0, 340136e0 <VD6G_SetExposureMode+0x10>
    return ret;

  drv_ctx->config_save.exposure_mode = mode;
340136dc:	f884 5064 	strb.w	r5, [r4, #100]	@ 0x64

  return 0;
}
340136e0:	bd38      	pop	{r3, r4, r5, pc}
	...

340136e4 <VD6G_GetAnalogGainRegRange>:

int VD6G_GetAnalogGainRegRange(VD6G_Ctx_t *ctx, uint8_t *AGmin, uint8_t *AGmax)
{
340136e4:	b5f0      	push	{r4, r5, r6, r7, lr}
340136e6:	4605      	mov	r5, r0
340136e8:	4616      	mov	r6, r2
  int ret;
  uint8_t value;

  if ((AGmin == NULL) || (AGmax == NULL))
340136ea:	460f      	mov	r7, r1
{
340136ec:	b085      	sub	sp, #20
  if ((AGmin == NULL) || (AGmax == NULL))
340136ee:	b371      	cbz	r1, 3401374e <VD6G_GetAnalogGainRegRange+0x6a>
340136f0:	b36a      	cbz	r2, 3401374e <VD6G_GetAnalogGainRegRange+0x6a>
    return -1;

  ret = ctx->read8(ctx, VD6G_REG_MIN_AG_CODED, &value);
340136f2:	f640 117e 	movw	r1, #2430	@ 0x97e
340136f6:	6843      	ldr	r3, [r0, #4]
340136f8:	f10d 020f 	add.w	r2, sp, #15
340136fc:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340136fe:	4604      	mov	r4, r0
34013700:	b988      	cbnz	r0, 34013726 <VD6G_GetAnalogGainRegRange+0x42>
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
34013702:	f89d 300f 	ldrb.w	r3, [sp, #15]

  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
34013706:	f44f 6116 	mov.w	r1, #2400	@ 0x960
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
3401370a:	f003 031f 	and.w	r3, r3, #31
3401370e:	703b      	strb	r3, [r7, #0]
  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
34013710:	4628      	mov	r0, r5
34013712:	686b      	ldr	r3, [r5, #4]
34013714:	f10d 020f 	add.w	r2, sp, #15
34013718:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401371a:	4604      	mov	r4, r0
3401371c:	b178      	cbz	r0, 3401373e <VD6G_GetAnalogGainRegRange+0x5a>
3401371e:	f240 43cc 	movw	r3, #1228	@ 0x4cc
34013722:	9000      	str	r0, [sp, #0]
34013724:	e002      	b.n	3401372c <VD6G_GetAnalogGainRegRange+0x48>
  VD6G_TraceError(ctx, ret);
34013726:	f44f 6399 	mov.w	r3, #1224	@ 0x4c8
3401372a:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
3401372c:	4628      	mov	r0, r5
3401372e:	4a09      	ldr	r2, [pc, #36]	@ (34013754 <VD6G_GetAnalogGainRegRange+0x70>)
34013730:	4909      	ldr	r1, [pc, #36]	@ (34013758 <VD6G_GetAnalogGainRegRange+0x74>)
34013732:	f7ff f9f0 	bl	34012b16 <VD6G_error>
34013736:	4628      	mov	r0, r5
34013738:	f7ff fa0a 	bl	34012b50 <display_error>
3401373c:	e004      	b.n	34013748 <VD6G_GetAnalogGainRegRange+0x64>
  *AGmax = value & VD6G_REG_MAX_AG_CODED_MASK;
3401373e:	f89d 300f 	ldrb.w	r3, [sp, #15]
34013742:	f003 031f 	and.w	r3, r3, #31
34013746:	7033      	strb	r3, [r6, #0]

  return 0;
}
34013748:	4620      	mov	r0, r4
3401374a:	b005      	add	sp, #20
3401374c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1;
3401374e:	f04f 34ff 	mov.w	r4, #4294967295
34013752:	e7f9      	b.n	34013748 <VD6G_GetAnalogGainRegRange+0x64>
34013754:	3403715a 	.word	0x3403715a
34013758:	3401cb0a 	.word	0x3401cb0a

3401375c <VD6G_SetAnalogGain>:

int VD6G_SetAnalogGain(VD6G_Ctx_t *ctx, int gain)
{
3401375c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
3401375e:	460e      	mov	r6, r1
  int ret;
  uint8_t again_regmin, again_regmax;

  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
34013760:	f10d 020f 	add.w	r2, sp, #15
34013764:	f10d 010e 	add.w	r1, sp, #14
{
34013768:	4605      	mov	r5, r0
  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
3401376a:	f7ff ffbb 	bl	340136e4 <VD6G_GetAnalogGainRegRange>
  if (ret)
3401376e:	4604      	mov	r4, r0
34013770:	b9d0      	cbnz	r0, 340137a8 <VD6G_SetAnalogGain+0x4c>
    return ret;

  ret = CHECK_RANGE(gain, again_regmin, again_regmax);
34013772:	f89d 300e 	ldrb.w	r3, [sp, #14]
34013776:	42b3      	cmp	r3, r6
34013778:	dc19      	bgt.n	340137ae <VD6G_SetAnalogGain+0x52>
3401377a:	f89d 300f 	ldrb.w	r3, [sp, #15]
3401377e:	42b3      	cmp	r3, r6
34013780:	db15      	blt.n	340137ae <VD6G_SetAnalogGain+0x52>
  if (ret)
    return ret;

  ret = ctx->write8(ctx, VD6G_REG_MANUAL_ANALOG_GAIN, gain);
34013782:	f240 414d 	movw	r1, #1101	@ 0x44d
34013786:	4628      	mov	r0, r5
34013788:	692b      	ldr	r3, [r5, #16]
3401378a:	b2f2      	uxtb	r2, r6
3401378c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401378e:	4604      	mov	r4, r0
34013790:	b150      	cbz	r0, 340137a8 <VD6G_SetAnalogGain+0x4c>
34013792:	9000      	str	r0, [sp, #0]
34013794:	f44f 639c 	mov.w	r3, #1248	@ 0x4e0
34013798:	4628      	mov	r0, r5
3401379a:	4a06      	ldr	r2, [pc, #24]	@ (340137b4 <VD6G_SetAnalogGain+0x58>)
3401379c:	4906      	ldr	r1, [pc, #24]	@ (340137b8 <VD6G_SetAnalogGain+0x5c>)
3401379e:	f7ff f9ba 	bl	34012b16 <VD6G_error>
340137a2:	4628      	mov	r0, r5
340137a4:	f7ff f9d4 	bl	34012b50 <display_error>

  return 0;
}
340137a8:	4620      	mov	r0, r4
340137aa:	b004      	add	sp, #16
340137ac:	bd70      	pop	{r4, r5, r6, pc}
    return ret;
340137ae:	f04f 34ff 	mov.w	r4, #4294967295
340137b2:	e7f9      	b.n	340137a8 <VD6G_SetAnalogGain+0x4c>
340137b4:	34037147 	.word	0x34037147
340137b8:	3401cb0a 	.word	0x3401cb0a

340137bc <VD6G_GetDigitalGainRegRange>:

int VD6G_GetDigitalGainRegRange(VD6G_Ctx_t *ctx, uint16_t *DGmin, uint16_t *DGmax)
{
340137bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
340137be:	4616      	mov	r6, r2
340137c0:	4605      	mov	r5, r0
  int ret;

  if ((DGmin == NULL) && (DGmax == NULL))
340137c2:	460a      	mov	r2, r1
340137c4:	b901      	cbnz	r1, 340137c8 <VD6G_GetDigitalGainRegRange+0xc>
340137c6:	b306      	cbz	r6, 3401380a <VD6G_GetDigitalGainRegRange+0x4e>
    return -1;

  ret = ctx->read16(ctx, VD6G_REG_MIN_DG, DGmin);
340137c8:	f640 117c 	movw	r1, #2428	@ 0x97c
340137cc:	4628      	mov	r0, r5
340137ce:	68ab      	ldr	r3, [r5, #8]
340137d0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340137d2:	4604      	mov	r4, r0
340137d4:	b958      	cbnz	r0, 340137ee <VD6G_GetDigitalGainRegRange+0x32>

  ret = ctx->read16(ctx, VD6G_REG_MAX_DG, DGmax);
340137d6:	4632      	mov	r2, r6
340137d8:	f640 115e 	movw	r1, #2398	@ 0x95e
340137dc:	4628      	mov	r0, r5
340137de:	68ab      	ldr	r3, [r5, #8]
340137e0:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340137e2:	4604      	mov	r4, r0
340137e4:	b170      	cbz	r0, 34013804 <VD6G_GetDigitalGainRegRange+0x48>
340137e6:	f44f 639e 	mov.w	r3, #1264	@ 0x4f0
340137ea:	9000      	str	r0, [sp, #0]
340137ec:	e002      	b.n	340137f4 <VD6G_GetDigitalGainRegRange+0x38>
  VD6G_TraceError(ctx, ret);
340137ee:	f240 43ed 	movw	r3, #1261	@ 0x4ed
340137f2:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
340137f4:	4628      	mov	r0, r5
340137f6:	4a06      	ldr	r2, [pc, #24]	@ (34013810 <VD6G_GetDigitalGainRegRange+0x54>)
340137f8:	4906      	ldr	r1, [pc, #24]	@ (34013814 <VD6G_GetDigitalGainRegRange+0x58>)
340137fa:	f7ff f98c 	bl	34012b16 <VD6G_error>
340137fe:	4628      	mov	r0, r5
34013800:	f7ff f9a6 	bl	34012b50 <display_error>

  return 0;
}
34013804:	4620      	mov	r0, r4
34013806:	b002      	add	sp, #8
34013808:	bd70      	pop	{r4, r5, r6, pc}
    return -1;
3401380a:	f04f 34ff 	mov.w	r4, #4294967295
3401380e:	e7f9      	b.n	34013804 <VD6G_GetDigitalGainRegRange+0x48>
34013810:	3403712b 	.word	0x3403712b
34013814:	3401cb0a 	.word	0x3401cb0a

34013818 <VD6G_SetDigitalGain>:

int VD6G_SetDigitalGain(VD6G_Ctx_t *ctx, int gain)
{
34013818:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
3401381a:	460e      	mov	r6, r1
  int ret;
  uint16_t dgain_regmin, dgain_regmax;

  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
3401381c:	f10d 020e 	add.w	r2, sp, #14
34013820:	a903      	add	r1, sp, #12
{
34013822:	4605      	mov	r5, r0
  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
34013824:	f7ff ffca 	bl	340137bc <VD6G_GetDigitalGainRegRange>
  if (ret)
34013828:	4604      	mov	r4, r0
3401382a:	bb38      	cbnz	r0, 3401387c <VD6G_SetDigitalGain+0x64>
    return ret;

  ret = CHECK_RANGE(gain, dgain_regmin, dgain_regmax);
3401382c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
34013830:	42b3      	cmp	r3, r6
34013832:	dc3f      	bgt.n	340138b4 <VD6G_SetDigitalGain+0x9c>
34013834:	f8bd 300e 	ldrh.w	r3, [sp, #14]
34013838:	42b3      	cmp	r3, r6
3401383a:	db3b      	blt.n	340138b4 <VD6G_SetDigitalGain+0x9c>
  if (ret)
    return ret;

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH0_DIGITAL_GAIN, gain);
3401383c:	b2b6      	uxth	r6, r6
3401383e:	4632      	mov	r2, r6
34013840:	f44f 618a 	mov.w	r1, #1104	@ 0x450
34013844:	4628      	mov	r0, r5
34013846:	696b      	ldr	r3, [r5, #20]
34013848:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401384a:	4604      	mov	r4, r0
3401384c:	b958      	cbnz	r0, 34013866 <VD6G_SetDigitalGain+0x4e>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH1_DIGITAL_GAIN, gain);
3401384e:	4632      	mov	r2, r6
34013850:	f240 4152 	movw	r1, #1106	@ 0x452
34013854:	4628      	mov	r0, r5
34013856:	696b      	ldr	r3, [r5, #20]
34013858:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401385a:	4604      	mov	r4, r0
3401385c:	b188      	cbz	r0, 34013882 <VD6G_SetDigitalGain+0x6a>
3401385e:	f240 5306 	movw	r3, #1286	@ 0x506
34013862:	9000      	str	r0, [sp, #0]
34013864:	e002      	b.n	3401386c <VD6G_SetDigitalGain+0x54>
  VD6G_TraceError(ctx, ret);
34013866:	f240 5303 	movw	r3, #1283	@ 0x503
3401386a:	9000      	str	r0, [sp, #0]

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
  VD6G_TraceError(ctx, ret);

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
  VD6G_TraceError(ctx, ret);
3401386c:	4628      	mov	r0, r5
3401386e:	4a13      	ldr	r2, [pc, #76]	@ (340138bc <VD6G_SetDigitalGain+0xa4>)
34013870:	4913      	ldr	r1, [pc, #76]	@ (340138c0 <VD6G_SetDigitalGain+0xa8>)
34013872:	f7ff f950 	bl	34012b16 <VD6G_error>
34013876:	4628      	mov	r0, r5
34013878:	f7ff f96a 	bl	34012b50 <display_error>

  return 0;
}
3401387c:	4620      	mov	r0, r4
3401387e:	b004      	add	sp, #16
34013880:	bd70      	pop	{r4, r5, r6, pc}
  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
34013882:	4632      	mov	r2, r6
34013884:	f240 4154 	movw	r1, #1108	@ 0x454
34013888:	4628      	mov	r0, r5
3401388a:	696b      	ldr	r3, [r5, #20]
3401388c:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401388e:	4604      	mov	r4, r0
34013890:	b118      	cbz	r0, 3401389a <VD6G_SetDigitalGain+0x82>
34013892:	f240 5309 	movw	r3, #1289	@ 0x509
34013896:	9000      	str	r0, [sp, #0]
34013898:	e7e8      	b.n	3401386c <VD6G_SetDigitalGain+0x54>
  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
3401389a:	4632      	mov	r2, r6
3401389c:	f240 4156 	movw	r1, #1110	@ 0x456
340138a0:	4628      	mov	r0, r5
340138a2:	696b      	ldr	r3, [r5, #20]
340138a4:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
340138a6:	4604      	mov	r4, r0
340138a8:	2800      	cmp	r0, #0
340138aa:	d0e7      	beq.n	3401387c <VD6G_SetDigitalGain+0x64>
340138ac:	f240 530c 	movw	r3, #1292	@ 0x50c
340138b0:	9000      	str	r0, [sp, #0]
340138b2:	e7db      	b.n	3401386c <VD6G_SetDigitalGain+0x54>
    return ret;
340138b4:	f04f 34ff 	mov.w	r4, #4294967295
340138b8:	e7e0      	b.n	3401387c <VD6G_SetDigitalGain+0x64>
340138ba:	bf00      	nop
340138bc:	34037117 	.word	0x34037117
340138c0:	3401cb0a 	.word	0x3401cb0a

340138c4 <VD6G_GetExposureRegRange>:

int VD6G_GetExposureRegRange(VD6G_Ctx_t *ctx, uint32_t *min_us, uint32_t *max_us)
{
340138c4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
340138c8:	4605      	mov	r5, r0
340138ca:	4616      	mov	r6, r2
  uint16_t exp_coarse_intg_margin;
  uint32_t line_time_in_us;
  uint16_t frame_length;
  int ret;

  if ((min_us == NULL) || (max_us == NULL))
340138cc:	460f      	mov	r7, r1
340138ce:	b929      	cbnz	r1, 340138dc <VD6G_GetExposureRegRange+0x18>
    return -1;
340138d0:	f04f 34ff 	mov.w	r4, #4294967295
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
  else
    return -1;

  return 0;
}
340138d4:	4620      	mov	r0, r4
340138d6:	b004      	add	sp, #16
340138d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((min_us == NULL) || (max_us == NULL))
340138dc:	2a00      	cmp	r2, #0
340138de:	d0f7      	beq.n	340138d0 <VD6G_GetExposureRegRange+0xc>
  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
340138e0:	a903      	add	r1, sp, #12
340138e2:	f7ff f9c9 	bl	34012c78 <VD6G_GetLineTimeInUs>
  if (ret)
340138e6:	4604      	mov	r4, r0
340138e8:	2800      	cmp	r0, #0
340138ea:	d1f3      	bne.n	340138d4 <VD6G_GetExposureRegRange+0x10>
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
340138ec:	2315      	movs	r3, #21
340138ee:	f8dd 800c 	ldr.w	r8, [sp, #12]
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
340138f2:	f44f 618b 	mov.w	r1, #1112	@ 0x458
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
340138f6:	fb03 f308 	mul.w	r3, r3, r8
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
340138fa:	4628      	mov	r0, r5
  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
340138fc:	603b      	str	r3, [r7, #0]
  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
340138fe:	f10d 020a 	add.w	r2, sp, #10
34013902:	68ab      	ldr	r3, [r5, #8]
34013904:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013906:	4604      	mov	r4, r0
34013908:	b958      	cbnz	r0, 34013922 <VD6G_GetExposureRegRange+0x5e>
  ret = ctx->read16(ctx, VD6G_REG_EXP_COARSE_INTG_MARGIN, &exp_coarse_intg_margin);
3401390a:	f640 1146 	movw	r1, #2374	@ 0x946
3401390e:	4628      	mov	r0, r5
34013910:	68ab      	ldr	r3, [r5, #8]
34013912:	aa02      	add	r2, sp, #8
34013914:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
34013916:	4604      	mov	r4, r0
34013918:	b178      	cbz	r0, 3401393a <VD6G_GetExposureRegRange+0x76>
3401391a:	f240 5325 	movw	r3, #1317	@ 0x525
3401391e:	9000      	str	r0, [sp, #0]
34013920:	e002      	b.n	34013928 <VD6G_GetExposureRegRange+0x64>
  VD6G_TraceError(ctx, ret);
34013922:	f240 5322 	movw	r3, #1314	@ 0x522
34013926:	9000      	str	r0, [sp, #0]
  VD6G_TraceError(ctx, ret);
34013928:	4628      	mov	r0, r5
3401392a:	4a0a      	ldr	r2, [pc, #40]	@ (34013954 <VD6G_GetExposureRegRange+0x90>)
3401392c:	490a      	ldr	r1, [pc, #40]	@ (34013958 <VD6G_GetExposureRegRange+0x94>)
3401392e:	f7ff f8f2 	bl	34012b16 <VD6G_error>
34013932:	4628      	mov	r0, r5
34013934:	f7ff f90c 	bl	34012b50 <display_error>
34013938:	e7cc      	b.n	340138d4 <VD6G_GetExposureRegRange+0x10>
  if (exp_coarse_intg_margin >= VD6G_MIN_EXP_COARSE_INTG_MARGIN)
3401393a:	f8bd 2008 	ldrh.w	r2, [sp, #8]
3401393e:	2a43      	cmp	r2, #67	@ 0x43
34013940:	d9c6      	bls.n	340138d0 <VD6G_GetExposureRegRange+0xc>
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
34013942:	f8bd 300a 	ldrh.w	r3, [sp, #10]
34013946:	1a9b      	subs	r3, r3, r2
34013948:	3b07      	subs	r3, #7
3401394a:	fb08 f303 	mul.w	r3, r8, r3
3401394e:	6033      	str	r3, [r6, #0]
  return 0;
34013950:	e7c0      	b.n	340138d4 <VD6G_GetExposureRegRange+0x10>
34013952:	bf00      	nop
34013954:	340370fe 	.word	0x340370fe
34013958:	3401cb0a 	.word	0x3401cb0a

3401395c <VD6G_SetExposureTime>:

int VD6G_SetExposureTime(VD6G_Ctx_t *ctx, int exposure_us)
{
3401395c:	b570      	push	{r4, r5, r6, lr}
3401395e:	b086      	sub	sp, #24
34013960:	460e      	mov	r6, r1
  int32_t ret;
  uint32_t exp_min, exp_max;
  uint32_t line_time_in_us;

  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
34013962:	aa04      	add	r2, sp, #16
34013964:	a903      	add	r1, sp, #12
{
34013966:	4605      	mov	r5, r0
  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
34013968:	f7ff ffac 	bl	340138c4 <VD6G_GetExposureRegRange>
  if (ret)
3401396c:	4604      	mov	r4, r0
3401396e:	bb08      	cbnz	r0, 340139b4 <VD6G_SetExposureTime+0x58>
    return ret;

  ret = CHECK_RANGE(exposure_us, exp_min, exp_max);
34013970:	9b03      	ldr	r3, [sp, #12]
34013972:	429e      	cmp	r6, r3
34013974:	d321      	bcc.n	340139ba <VD6G_SetExposureTime+0x5e>
34013976:	9b04      	ldr	r3, [sp, #16]
34013978:	429e      	cmp	r6, r3
3401397a:	d81e      	bhi.n	340139ba <VD6G_SetExposureTime+0x5e>
  if (ret)
    return ret;

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
3401397c:	4628      	mov	r0, r5
3401397e:	a905      	add	r1, sp, #20
34013980:	f7ff f97a 	bl	34012c78 <VD6G_GetLineTimeInUs>
  if (ret)
34013984:	4604      	mov	r4, r0
34013986:	b9a8      	cbnz	r0, 340139b4 <VD6G_SetExposureTime+0x58>
    return ret;

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_COARSE_EXP, CEIL(exposure_us / line_time_in_us));
34013988:	9b05      	ldr	r3, [sp, #20]
3401398a:	f240 414e 	movw	r1, #1102	@ 0x44e
3401398e:	fbb6 f2f3 	udiv	r2, r6, r3
34013992:	4628      	mov	r0, r5
34013994:	696b      	ldr	r3, [r5, #20]
34013996:	b292      	uxth	r2, r2
34013998:	4798      	blx	r3
  VD6G_TraceError(ctx, ret);
3401399a:	4604      	mov	r4, r0
3401399c:	b150      	cbz	r0, 340139b4 <VD6G_SetExposureTime+0x58>
3401399e:	9000      	str	r0, [sp, #0]
340139a0:	f240 5342 	movw	r3, #1346	@ 0x542
340139a4:	4628      	mov	r0, r5
340139a6:	4a06      	ldr	r2, [pc, #24]	@ (340139c0 <VD6G_SetExposureTime+0x64>)
340139a8:	4906      	ldr	r1, [pc, #24]	@ (340139c4 <VD6G_SetExposureTime+0x68>)
340139aa:	f7ff f8b4 	bl	34012b16 <VD6G_error>
340139ae:	4628      	mov	r0, r5
340139b0:	f7ff f8ce 	bl	34012b50 <display_error>

  return 0;
}
340139b4:	4620      	mov	r0, r4
340139b6:	b006      	add	sp, #24
340139b8:	bd70      	pop	{r4, r5, r6, pc}
    return ret;
340139ba:	f04f 34ff 	mov.w	r4, #4294967295
340139be:	e7f9      	b.n	340139b4 <VD6G_SetExposureTime+0x58>
340139c0:	340370d4 	.word	0x340370d4
340139c4:	3401cb0a 	.word	0x3401cb0a

340139c8 <ISP_Algo_BadPixel_Init>:
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
340139c8:	2000      	movs	r0, #0
340139ca:	7048      	strb	r0, [r1, #1]

  return ISP_OK;
}
340139cc:	4770      	bx	lr

340139ce <ISP_Algo_BadPixel_DeInit>:
{
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
}
340139ce:	2000      	movs	r0, #0
340139d0:	4770      	bx	lr

340139d2 <ISP_Algo_AEC_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
340139d2:	2303      	movs	r3, #3
340139d4:	7043      	strb	r3, [r0, #1]

  return ISP_OK;
}
340139d6:	2000      	movs	r0, #0
340139d8:	4770      	bx	lr

340139da <ISP_Algo_AWB_StatCb>:
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
340139da:	7843      	ldrb	r3, [r0, #1]
340139dc:	b10b      	cbz	r3, 340139e2 <ISP_Algo_AWB_StatCb+0x8>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
340139de:	2303      	movs	r3, #3
340139e0:	7043      	strb	r3, [r0, #1]
  }

  return ISP_OK;
}
340139e2:	2000      	movs	r0, #0
340139e4:	4770      	bx	lr
	...

340139e8 <ISP_Algo_BadPixel_Process>:
{
340139e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
340139ea:	4604      	mov	r4, r0
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340139ec:	f001 f96e 	bl	34014ccc <ISP_SVC_IQParam_Get>
  if (IQParamConfig->badPixelAlgo.enable == false)
340139f0:	f890 3054 	ldrb.w	r3, [r0, #84]	@ 0x54
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
340139f4:	4607      	mov	r7, r0
  if (IQParamConfig->badPixelAlgo.enable == false)
340139f6:	b913      	cbnz	r3, 340139fe <ISP_Algo_BadPixel_Process+0x16>
    return ISP_OK;
340139f8:	2000      	movs	r0, #0
}
340139fa:	b003      	add	sp, #12
340139fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
340139fe:	4620      	mov	r0, r4
34013a00:	f001 f91c 	bl	34014c3c <ISP_SVC_Misc_GetMainFrameId>
  if (CurrentFrameId == LastFrameId)
34013a04:	4b1e      	ldr	r3, [pc, #120]	@ (34013a80 <ISP_Algo_BadPixel_Process+0x98>)
34013a06:	681a      	ldr	r2, [r3, #0]
34013a08:	4282      	cmp	r2, r0
34013a0a:	d0f5      	beq.n	340139f8 <ISP_Algo_BadPixel_Process+0x10>
  if (Step++ >= 0)
34013a0c:	4d1d      	ldr	r5, [pc, #116]	@ (34013a84 <ISP_Algo_BadPixel_Process+0x9c>)
  LastFrameId = CurrentFrameId;
34013a0e:	6018      	str	r0, [r3, #0]
  if (Step++ >= 0)
34013a10:	f995 3000 	ldrsb.w	r3, [r5]
34013a14:	1c5a      	adds	r2, r3, #1
34013a16:	2b00      	cmp	r3, #0
34013a18:	702a      	strb	r2, [r5, #0]
34013a1a:	db0a      	blt.n	34013a32 <ISP_Algo_BadPixel_Process+0x4a>
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
34013a1c:	4669      	mov	r1, sp
34013a1e:	4620      	mov	r0, r4
34013a20:	f000 ff0b 	bl	3401483a <ISP_SVC_ISP_GetBadPixel>
    if (ret != ISP_OK)
34013a24:	2800      	cmp	r0, #0
34013a26:	d1e8      	bne.n	340139fa <ISP_Algo_BadPixel_Process+0x12>
    BadPixelCount += BadPixelConfig.count;
34013a28:	4a17      	ldr	r2, [pc, #92]	@ (34013a88 <ISP_Algo_BadPixel_Process+0xa0>)
34013a2a:	9b01      	ldr	r3, [sp, #4]
34013a2c:	6811      	ldr	r1, [r2, #0]
34013a2e:	440b      	add	r3, r1
34013a30:	6013      	str	r3, [r2, #0]
  if (Step == 10)
34013a32:	f995 2000 	ldrsb.w	r2, [r5]
34013a36:	2a0a      	cmp	r2, #10
34013a38:	d1de      	bne.n	340139f8 <ISP_Algo_BadPixel_Process+0x10>
    BadPixelCount /= 10;
34013a3a:	4e13      	ldr	r6, [pc, #76]	@ (34013a88 <ISP_Algo_BadPixel_Process+0xa0>)
34013a3c:	6833      	ldr	r3, [r6, #0]
34013a3e:	fbb3 f3f2 	udiv	r3, r3, r2
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
34013a42:	6dba      	ldr	r2, [r7, #88]	@ 0x58
    BadPixelCount /= 10;
34013a44:	6033      	str	r3, [r6, #0]
    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
34013a46:	4293      	cmp	r3, r2
34013a48:	d912      	bls.n	34013a70 <ISP_Algo_BadPixel_Process+0x88>
34013a4a:	f89d 3001 	ldrb.w	r3, [sp, #1]
34013a4e:	b113      	cbz	r3, 34013a56 <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength--;
34013a50:	3b01      	subs	r3, #1
      BadPixelConfig.strength++;
34013a52:	f88d 3001 	strb.w	r3, [sp, #1]
    BadPixelConfig.enable = 1;
34013a56:	2301      	movs	r3, #1
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34013a58:	4669      	mov	r1, sp
34013a5a:	4620      	mov	r0, r4
    BadPixelConfig.enable = 1;
34013a5c:	f88d 3000 	strb.w	r3, [sp]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34013a60:	f000 fed0 	bl	34014804 <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
34013a64:	2800      	cmp	r0, #0
34013a66:	d1c8      	bne.n	340139fa <ISP_Algo_BadPixel_Process+0x12>
    Step = -1;
34013a68:	23ff      	movs	r3, #255	@ 0xff
    BadPixelCount = 0;
34013a6a:	6030      	str	r0, [r6, #0]
    Step = -1;
34013a6c:	702b      	strb	r3, [r5, #0]
    BadPixelCount = 0;
34013a6e:	e7c4      	b.n	340139fa <ISP_Algo_BadPixel_Process+0x12>
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
34013a70:	d2f1      	bcs.n	34013a56 <ISP_Algo_BadPixel_Process+0x6e>
34013a72:	f89d 3001 	ldrb.w	r3, [sp, #1]
34013a76:	2b05      	cmp	r3, #5
34013a78:	d8ed      	bhi.n	34013a56 <ISP_Algo_BadPixel_Process+0x6e>
      BadPixelConfig.strength++;
34013a7a:	3301      	adds	r3, #1
34013a7c:	e7e9      	b.n	34013a52 <ISP_Algo_BadPixel_Process+0x6a>
34013a7e:	bf00      	nop
34013a80:	34057d98 	.word	0x34057d98
34013a84:	34057d94 	.word	0x34057d94
34013a88:	34057d90 	.word	0x34057d90

34013a8c <ISP_Algo_AEC_Init>:
{
34013a8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34013a8e:	460d      	mov	r5, r1
34013a90:	4604      	mov	r4, r0
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013a92:	f001 f91b 	bl	34014ccc <ISP_SVC_IQParam_Get>
34013a96:	4606      	mov	r6, r0
  pIspAEprocess = evision_api_st_ae_new(log_cb);
34013a98:	480f      	ldr	r0, [pc, #60]	@ (34013ad8 <ISP_Algo_AEC_Init+0x4c>)
34013a9a:	f7ed fbf5 	bl	34001288 <evision_api_st_ae_new>
34013a9e:	4f0f      	ldr	r7, [pc, #60]	@ (34013adc <ISP_Algo_AEC_Init+0x50>)
34013aa0:	6038      	str	r0, [r7, #0]
  if (pIspAEprocess == NULL)
34013aa2:	b130      	cbz	r0, 34013ab2 <ISP_Algo_AEC_Init+0x26>
  e_ret = evision_api_st_ae_init(pIspAEprocess);
34013aa4:	f7ed fc44 	bl	34001330 <evision_api_st_ae_init>
  if (e_ret != EVISION_RET_SUCCESS)
34013aa8:	2801      	cmp	r0, #1
34013aaa:	d004      	beq.n	34013ab6 <ISP_Algo_AEC_Init+0x2a>
    evision_api_st_ae_delete(pIspAEprocess);
34013aac:	6838      	ldr	r0, [r7, #0]
34013aae:	f7ed fc05 	bl	340012bc <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
34013ab2:	20be      	movs	r0, #190	@ 0xbe
}
34013ab4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  algo->state = ISP_ALGO_STATE_INIT;
34013ab6:	2000      	movs	r0, #0
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013ab8:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
34013aba:	683b      	ldr	r3, [r7, #0]
34013abc:	611a      	str	r2, [r3, #16]
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
34013abe:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
34013ac2:	641a      	str	r2, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
34013ac4:	f8d4 2084 	ldr.w	r2, [r4, #132]	@ 0x84
34013ac8:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
34013aca:	6fa2      	ldr	r2, [r4, #120]	@ 0x78
34013acc:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
34013ace:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
34013ad0:	64da      	str	r2, [r3, #76]	@ 0x4c
  algo->state = ISP_ALGO_STATE_INIT;
34013ad2:	7068      	strb	r0, [r5, #1]
  return ISP_OK;
34013ad4:	e7ee      	b.n	34013ab4 <ISP_Algo_AEC_Init+0x28>
34013ad6:	bf00      	nop
34013ad8:	34013af5 	.word	0x34013af5
34013adc:	34057da4 	.word	0x34057da4

34013ae0 <ISP_Algo_AEC_DeInit>:
{
34013ae0:	b508      	push	{r3, lr}
  if (pIspAEprocess != NULL)
34013ae2:	4b03      	ldr	r3, [pc, #12]	@ (34013af0 <ISP_Algo_AEC_DeInit+0x10>)
34013ae4:	6818      	ldr	r0, [r3, #0]
34013ae6:	b108      	cbz	r0, 34013aec <ISP_Algo_AEC_DeInit+0xc>
    evision_api_st_ae_delete(pIspAEprocess);
34013ae8:	f7ed fbe8 	bl	340012bc <evision_api_st_ae_delete>
}
34013aec:	2000      	movs	r0, #0
34013aee:	bd08      	pop	{r3, pc}
34013af0:	34057da4 	.word	0x34057da4

34013af4 <log_cb>:
{
34013af4:	b508      	push	{r3, lr}
  printf(msg);
34013af6:	f004 fee1 	bl	340188bc <iprintf>
}
34013afa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("\r\n");
34013afe:	4801      	ldr	r0, [pc, #4]	@ (34013b04 <log_cb+0x10>)
34013b00:	f004 bf44 	b.w	3401898c <puts>
34013b04:	3401d044 	.word	0x3401d044

34013b08 <ISP_Algo_AEC_Process>:
{
34013b08:	b5f0      	push	{r4, r5, r6, r7, lr}
34013b0a:	b087      	sub	sp, #28
34013b0c:	4605      	mov	r5, r0
34013b0e:	460c      	mov	r4, r1
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013b10:	f001 f8dc 	bl	34014ccc <ISP_SVC_IQParam_Get>
34013b14:	4603      	mov	r3, r0
  if (IQParamConfig->AECAlgo.enable == false)
34013b16:	f890 0068 	ldrb.w	r0, [r0, #104]	@ 0x68
34013b1a:	b128      	cbz	r0, 34013b28 <ISP_Algo_AEC_Process+0x20>
  switch(algo->state)
34013b1c:	7862      	ldrb	r2, [r4, #1]
34013b1e:	2a01      	cmp	r2, #1
34013b20:	d904      	bls.n	34013b2c <ISP_Algo_AEC_Process+0x24>
34013b22:	2a03      	cmp	r2, #3
34013b24:	d012      	beq.n	34013b4c <ISP_Algo_AEC_Process+0x44>
    return ISP_OK;
34013b26:	2000      	movs	r0, #0
}
34013b28:	b007      	add	sp, #28
34013b2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN, ISP_STAT_TYPE_AVG, ALGO_SENSOR_LATENCY);
34013b2c:	2301      	movs	r3, #1
34013b2e:	2104      	movs	r1, #4
34013b30:	2602      	movs	r6, #2
34013b32:	e9cd 3101 	strd	r3, r1, [sp, #4]
34013b36:	4622      	mov	r2, r4
34013b38:	4628      	mov	r0, r5
34013b3a:	4b25      	ldr	r3, [pc, #148]	@ (34013bd0 <ISP_Algo_AEC_Process+0xc8>)
34013b3c:	4925      	ldr	r1, [pc, #148]	@ (34013bd4 <ISP_Algo_AEC_Process+0xcc>)
34013b3e:	9600      	str	r6, [sp, #0]
34013b40:	f001 fb08 	bl	34015154 <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
34013b44:	2800      	cmp	r0, #0
34013b46:	d1ef      	bne.n	34013b28 <ISP_Algo_AEC_Process+0x20>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013b48:	7066      	strb	r6, [r4, #1]
    break;
34013b4a:	e7ed      	b.n	34013b28 <ISP_Algo_AEC_Process+0x20>
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013b4c:	4e22      	ldr	r6, [pc, #136]	@ (34013bd8 <ISP_Algo_AEC_Process+0xd0>)
34013b4e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34013b50:	6832      	ldr	r2, [r6, #0]
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013b52:	4628      	mov	r0, r5
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34013b54:	6113      	str	r3, [r2, #16]
    avgL = stats.down.averageL;
34013b56:	4b1e      	ldr	r3, [pc, #120]	@ (34013bd0 <ISP_Algo_AEC_Process+0xc8>)
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013b58:	a904      	add	r1, sp, #16
    avgL = stats.down.averageL;
34013b5a:	f893 7037 	ldrb.w	r7, [r3, #55]	@ 0x37
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34013b5e:	f001 f832 	bl	34014bc6 <ISP_SVC_Sensor_GetGain>
    if (ret != ISP_OK)
34013b62:	2800      	cmp	r0, #0
34013b64:	d1e0      	bne.n	34013b28 <ISP_Algo_AEC_Process+0x20>
    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
34013b66:	4628      	mov	r0, r5
34013b68:	a905      	add	r1, sp, #20
34013b6a:	f001 f849 	bl	34014c00 <ISP_SVC_Sensor_GetExposure>
    if (ret != ISP_OK)
34013b6e:	2800      	cmp	r0, #0
34013b70:	d1da      	bne.n	34013b28 <ISP_Algo_AEC_Process+0x20>
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, avgL);
34013b72:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
34013b76:	463b      	mov	r3, r7
34013b78:	6830      	ldr	r0, [r6, #0]
34013b7a:	f7ed fbe4 	bl	34001346 <evision_api_st_ae_process>
    if (e_ret == EVISION_RET_SUCCESS)
34013b7e:	2801      	cmp	r0, #1
34013b80:	d00c      	beq.n	34013b9c <ISP_Algo_AEC_Process+0x94>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats,
34013b82:	2301      	movs	r3, #1
34013b84:	2204      	movs	r2, #4
34013b86:	2602      	movs	r6, #2
34013b88:	e9cd 3201 	strd	r3, r2, [sp, #4]
34013b8c:	4628      	mov	r0, r5
34013b8e:	4622      	mov	r2, r4
34013b90:	4b0f      	ldr	r3, [pc, #60]	@ (34013bd0 <ISP_Algo_AEC_Process+0xc8>)
34013b92:	4910      	ldr	r1, [pc, #64]	@ (34013bd4 <ISP_Algo_AEC_Process+0xcc>)
34013b94:	9600      	str	r6, [sp, #0]
34013b96:	f001 fadd 	bl	34015154 <ISP_SVC_Stats_GetNext>
34013b9a:	e7d5      	b.n	34013b48 <ISP_Algo_AEC_Process+0x40>
      if (gainConfig.gain != pIspAEprocess->new_gain)
34013b9c:	6833      	ldr	r3, [r6, #0]
34013b9e:	9a04      	ldr	r2, [sp, #16]
34013ba0:	689b      	ldr	r3, [r3, #8]
34013ba2:	429a      	cmp	r2, r3
34013ba4:	d10c      	bne.n	34013bc0 <ISP_Algo_AEC_Process+0xb8>
      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
34013ba6:	6833      	ldr	r3, [r6, #0]
34013ba8:	9a05      	ldr	r2, [sp, #20]
34013baa:	685b      	ldr	r3, [r3, #4]
34013bac:	429a      	cmp	r2, r3
34013bae:	d0e8      	beq.n	34013b82 <ISP_Algo_AEC_Process+0x7a>
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34013bb0:	4628      	mov	r0, r5
34013bb2:	a905      	add	r1, sp, #20
        exposureConfig.exposure = pIspAEprocess->new_exposure;
34013bb4:	9305      	str	r3, [sp, #20]
        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34013bb6:	f001 f814 	bl	34014be2 <ISP_SVC_Sensor_SetExposure>
        if (ret != ISP_OK)
34013bba:	2800      	cmp	r0, #0
34013bbc:	d0e1      	beq.n	34013b82 <ISP_Algo_AEC_Process+0x7a>
34013bbe:	e7b3      	b.n	34013b28 <ISP_Algo_AEC_Process+0x20>
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34013bc0:	4628      	mov	r0, r5
34013bc2:	a904      	add	r1, sp, #16
        gainConfig.gain = pIspAEprocess->new_gain;
34013bc4:	9304      	str	r3, [sp, #16]
        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34013bc6:	f000 ffef 	bl	34014ba8 <ISP_SVC_Sensor_SetGain>
        if (ret != ISP_OK)
34013bca:	2800      	cmp	r0, #0
34013bcc:	d0eb      	beq.n	34013ba6 <ISP_Algo_AEC_Process+0x9e>
34013bce:	e7ab      	b.n	34013b28 <ISP_Algo_AEC_Process+0x20>
34013bd0:	34057d18 	.word	0x34057d18
34013bd4:	340139d3 	.word	0x340139d3
34013bd8:	34057da4 	.word	0x34057da4

34013bdc <ISP_Algo_AWB_Init>:
{
34013bdc:	b510      	push	{r4, lr}
  pIspAWBestimator = evision_api_awb_new(log_cb);
34013bde:	4806      	ldr	r0, [pc, #24]	@ (34013bf8 <ISP_Algo_AWB_Init+0x1c>)
{
34013be0:	460c      	mov	r4, r1
  pIspAWBestimator = evision_api_awb_new(log_cb);
34013be2:	f7ed f844 	bl	34000c6e <evision_api_awb_new>
34013be6:	4b05      	ldr	r3, [pc, #20]	@ (34013bfc <ISP_Algo_AWB_Init+0x20>)
34013be8:	6018      	str	r0, [r3, #0]
  if (pIspAWBestimator == NULL)
34013bea:	b110      	cbz	r0, 34013bf2 <ISP_Algo_AWB_Init+0x16>
  algo->state = ISP_ALGO_STATE_INIT;
34013bec:	2000      	movs	r0, #0
34013bee:	7060      	strb	r0, [r4, #1]
}
34013bf0:	bd10      	pop	{r4, pc}
    return ISP_ERR_ALGO;
34013bf2:	20be      	movs	r0, #190	@ 0xbe
34013bf4:	e7fc      	b.n	34013bf0 <ISP_Algo_AWB_Init+0x14>
34013bf6:	bf00      	nop
34013bf8:	34013af5 	.word	0x34013af5
34013bfc:	34057da0 	.word	0x34057da0

34013c00 <ISP_Algo_AWB_DeInit>:
{
34013c00:	b508      	push	{r3, lr}
  if (pIspAWBestimator != NULL)
34013c02:	4b03      	ldr	r3, [pc, #12]	@ (34013c10 <ISP_Algo_AWB_DeInit+0x10>)
34013c04:	6818      	ldr	r0, [r3, #0]
34013c06:	b108      	cbz	r0, 34013c0c <ISP_Algo_AWB_DeInit+0xc>
    evision_api_awb_delete(pIspAWBestimator);
34013c08:	f7ed f84e 	bl	34000ca8 <evision_api_awb_delete>
}
34013c0c:	2000      	movs	r0, #0
34013c0e:	bd08      	pop	{r3, pc}
34013c10:	34057da0 	.word	0x34057da0
34013c14:	00000000 	.word	0x00000000

34013c18 <ISP_Algo_ApplyGammaInverse>:
{
34013c18:	b508      	push	{r3, lr}
34013c1a:	ed2d 8b02 	vpush	{d8}
34013c1e:	ee08 1a10 	vmov	s16, r1
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
34013c22:	2101      	movs	r1, #1
34013c24:	f001 f814 	bl	34014c50 <ISP_SVC_Misc_IsGammaEnabled>
34013c28:	b190      	cbz	r0, 34013c50 <ISP_Algo_ApplyGammaInverse+0x38>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
34013c2a:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 34013c68 <ISP_Algo_ApplyGammaInverse+0x50>
34013c2e:	eeb8 8a48 	vcvt.f32.u32	s16, s16
34013c32:	ee88 0a27 	vdiv.f32	s0, s16, s15
34013c36:	ed9f 1b08 	vldr	d1, [pc, #32]	@ 34013c58 <ISP_Algo_ApplyGammaInverse+0x40>
34013c3a:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34013c3e:	f007 f9c7 	bl	3401afd0 <pow>
34013c42:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 34013c60 <ISP_Algo_ApplyGammaInverse+0x48>
34013c46:	ee20 0b07 	vmul.f64	d0, d0, d7
}
34013c4a:	ecbd 8b02 	vpop	{d8}
34013c4e:	bd08      	pop	{r3, pc}
    out = (double) comp;
34013c50:	eeb8 0b48 	vcvt.f64.u32	d0, s16
  return out;
34013c54:	e7f9      	b.n	34013c4a <ISP_Algo_ApplyGammaInverse+0x32>
34013c56:	bf00      	nop
34013c58:	d1745d17 	.word	0xd1745d17
34013c5c:	3fdd1745 	.word	0x3fdd1745
34013c60:	00000000 	.word	0x00000000
34013c64:	406fe000 	.word	0x406fe000
34013c68:	437f0000 	.word	0x437f0000
34013c6c:	00000000 	.word	0x00000000

34013c70 <ISP_Algo_ApplyCConv>:
{
34013c70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34013c74:	b08b      	sub	sp, #44	@ 0x2c
34013c76:	460e      	mov	r6, r1
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34013c78:	4669      	mov	r1, sp
{
34013c7a:	4615      	mov	r5, r2
34013c7c:	461c      	mov	r4, r3
  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34013c7e:	f000 ff3d 	bl	34014afc <ISP_SVC_ISP_GetColorConv>
34013c82:	4602      	mov	r2, r0
34013c84:	2800      	cmp	r0, #0
34013c86:	f040 8096 	bne.w	34013db6 <ISP_Algo_ApplyCConv+0x146>
34013c8a:	f89d 3000 	ldrb.w	r3, [sp]
34013c8e:	2b01      	cmp	r3, #1
34013c90:	f040 8091 	bne.w	34013db6 <ISP_Algo_ApplyCConv+0x146>
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34013c94:	9b01      	ldr	r3, [sp, #4]
34013c96:	17d9      	asrs	r1, r3, #31
34013c98:	fba3 3706 	umull	r3, r7, r3, r6
34013c9c:	fb06 7701 	mla	r7, r6, r1, r7
34013ca0:	9902      	ldr	r1, [sp, #8]
34013ca2:	ea4f 7ce1 	mov.w	ip, r1, asr #31
34013ca6:	fba1 1005 	umull	r1, r0, r1, r5
34013caa:	fb05 000c 	mla	r0, r5, ip, r0
34013cae:	185b      	adds	r3, r3, r1
34013cb0:	eb47 0700 	adc.w	r7, r7, r0
34013cb4:	9803      	ldr	r0, [sp, #12]
34013cb6:	ea4f 7ce0 	mov.w	ip, r0, asr #31
34013cba:	fba0 0104 	umull	r0, r1, r0, r4
34013cbe:	fb04 110c 	mla	r1, r4, ip, r1
34013cc2:	1818      	adds	r0, r3, r0
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34013cc4:	9b04      	ldr	r3, [sp, #16]
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34013cc6:	eb41 0107 	adc.w	r1, r1, r7
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34013cca:	17df      	asrs	r7, r3, #31
34013ccc:	fba3 8306 	umull	r8, r3, r3, r6
34013cd0:	fb06 3307 	mla	r3, r6, r7, r3
34013cd4:	9f05      	ldr	r7, [sp, #20]
34013cd6:	fba7 ce05 	umull	ip, lr, r7, r5
34013cda:	ea4f 79e7 	mov.w	r9, r7, asr #31
34013cde:	fb05 ee09 	mla	lr, r5, r9, lr
34013ce2:	eb18 070c 	adds.w	r7, r8, ip
34013ce6:	f8dd c018 	ldr.w	ip, [sp, #24]
34013cea:	eb43 030e 	adc.w	r3, r3, lr
34013cee:	ea4f 7eec 	mov.w	lr, ip, asr #31
34013cf2:	fbac c804 	umull	ip, r8, ip, r4
34013cf6:	fb04 880e 	mla	r8, r4, lr, r8
34013cfa:	eb17 070c 	adds.w	r7, r7, ip
34013cfe:	eb48 0803 	adc.w	r8, r8, r3
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34013d02:	9b07      	ldr	r3, [sp, #28]
34013d04:	ea4f 7ce3 	mov.w	ip, r3, asr #31
34013d08:	fba3 e306 	umull	lr, r3, r3, r6
34013d0c:	fb06 3c0c 	mla	ip, r6, ip, r3
34013d10:	9b08      	ldr	r3, [sp, #32]
34013d12:	ea4f 79e3 	mov.w	r9, r3, asr #31
34013d16:	fba3 3605 	umull	r3, r6, r3, r5
34013d1a:	fb05 6509 	mla	r5, r5, r9, r6
34013d1e:	eb1e 0303 	adds.w	r3, lr, r3
34013d22:	eb4c 0c05 	adc.w	ip, ip, r5
34013d26:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34013d28:	ea4f 7ee5 	mov.w	lr, r5, asr #31
34013d2c:	fba5 5604 	umull	r5, r6, r5, r4
34013d30:	fb04 660e 	mla	r6, r4, lr, r6
34013d34:	195c      	adds	r4, r3, r5
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013d36:	f04f 33ff 	mov.w	r3, #4294967295
34013d3a:	4d29      	ldr	r5, [pc, #164]	@ (34013de0 <ISP_Algo_ApplyCConv+0x170>)
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34013d3c:	eb46 060c 	adc.w	r6, r6, ip
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013d40:	42a8      	cmp	r0, r5
34013d42:	eb71 0303 	sbcs.w	r3, r1, r3
34013d46:	db3f      	blt.n	34013dc8 <ISP_Algo_ApplyCConv+0x158>
    ccR /= ISP_CCM_PRECISION_FACTOR;
34013d48:	a323      	add	r3, pc, #140	@ (adr r3, 34013dd8 <ISP_Algo_ApplyCConv+0x168>)
34013d4a:	e9d3 2300 	ldrd	r2, r3, [r3]
34013d4e:	f7ed fbf5 	bl	3400153c <__aeabi_ldivmod>
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013d52:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013d56:	f171 0100 	sbcs.w	r1, r1, #0
34013d5a:	4681      	mov	r9, r0
34013d5c:	db01      	blt.n	34013d62 <ISP_Algo_ApplyCConv+0xf2>
34013d5e:	f04f 09ff 	mov.w	r9, #255	@ 0xff
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013d62:	f04f 33ff 	mov.w	r3, #4294967295
34013d66:	42af      	cmp	r7, r5
34013d68:	eb78 0303 	sbcs.w	r3, r8, r3
34013d6c:	db2e      	blt.n	34013dcc <ISP_Algo_ApplyCConv+0x15c>
    ccG /= ISP_CCM_PRECISION_FACTOR;
34013d6e:	a31a      	add	r3, pc, #104	@ (adr r3, 34013dd8 <ISP_Algo_ApplyCConv+0x168>)
34013d70:	e9d3 2300 	ldrd	r2, r3, [r3]
34013d74:	4638      	mov	r0, r7
34013d76:	4641      	mov	r1, r8
34013d78:	f7ed fbe0 	bl	3400153c <__aeabi_ldivmod>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013d7c:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013d80:	f171 0100 	sbcs.w	r1, r1, #0
34013d84:	4607      	mov	r7, r0
34013d86:	db00      	blt.n	34013d8a <ISP_Algo_ApplyCConv+0x11a>
34013d88:	27ff      	movs	r7, #255	@ 0xff
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013d8a:	f04f 33ff 	mov.w	r3, #4294967295
34013d8e:	42ac      	cmp	r4, r5
34013d90:	eb76 0303 	sbcs.w	r3, r6, r3
34013d94:	db1c      	blt.n	34013dd0 <ISP_Algo_ApplyCConv+0x160>
    ccB /= ISP_CCM_PRECISION_FACTOR;
34013d96:	a310      	add	r3, pc, #64	@ (adr r3, 34013dd8 <ISP_Algo_ApplyCConv+0x168>)
34013d98:	e9d3 2300 	ldrd	r2, r3, [r3]
34013d9c:	4620      	mov	r0, r4
34013d9e:	4631      	mov	r1, r6
34013da0:	f7ed fbcc 	bl	3400153c <__aeabi_ldivmod>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013da4:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
34013da8:	f171 0100 	sbcs.w	r1, r1, #0
34013dac:	4604      	mov	r4, r0
34013dae:	db00      	blt.n	34013db2 <ISP_Algo_ApplyCConv+0x142>
34013db0:	24ff      	movs	r4, #255	@ 0xff
    *outR = (uint32_t) ccR;
34013db2:	464e      	mov	r6, r9
    *outG = (uint32_t) ccG;
34013db4:	463d      	mov	r5, r7
    *outR = (uint32_t) ccR;
34013db6:	9b12      	ldr	r3, [sp, #72]	@ 0x48
34013db8:	601e      	str	r6, [r3, #0]
    *outG = (uint32_t) ccG;
34013dba:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
34013dbc:	601d      	str	r5, [r3, #0]
    *outB = (uint32_t) ccB;
34013dbe:	9b14      	ldr	r3, [sp, #80]	@ 0x50
34013dc0:	601c      	str	r4, [r3, #0]
}
34013dc2:	b00b      	add	sp, #44	@ 0x2c
34013dc4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
34013dc8:	4691      	mov	r9, r2
34013dca:	e7ca      	b.n	34013d62 <ISP_Algo_ApplyCConv+0xf2>
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
34013dcc:	2700      	movs	r7, #0
34013dce:	e7dc      	b.n	34013d8a <ISP_Algo_ApplyCConv+0x11a>
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34013dd0:	2400      	movs	r4, #0
34013dd2:	e7ee      	b.n	34013db2 <ISP_Algo_ApplyCConv+0x142>
34013dd4:	f3af 8000 	nop.w
34013dd8:	05f5e100 	.word	0x05f5e100
34013ddc:	00000000 	.word	0x00000000
34013de0:	fa0a1f01 	.word	0xfa0a1f01
34013de4:	00000000 	.word	0x00000000

34013de8 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
34013de8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34013dec:	ed2d 8b02 	vpush	{d8}
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34013df0:	2400      	movs	r4, #0
{
34013df2:	b09e      	sub	sp, #120	@ 0x78
34013df4:	4606      	mov	r6, r0
34013df6:	460f      	mov	r7, r1
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34013df8:	e9cd 4407 	strd	r4, r4, [sp, #28]
34013dfc:	9409      	str	r4, [sp, #36]	@ 0x24
  double meas[3];

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013dfe:	f000 ff65 	bl	34014ccc <ISP_SVC_IQParam_Get>

  if (IQParamConfig->AWBAlgo.enable == false)
34013e02:	f890 2070 	ldrb.w	r2, [r0, #112]	@ 0x70
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34013e06:	4605      	mov	r5, r0
  if (IQParamConfig->AWBAlgo.enable == false)
34013e08:	4bc3      	ldr	r3, [pc, #780]	@ (34014118 <ISP_Algo_AWB_Process+0x330>)
34013e0a:	b932      	cbnz	r2, 34013e1a <ISP_Algo_AWB_Process+0x32>
  {
    enableCurrent = false;
34013e0c:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
34013e0e:	2000      	movs	r0, #0
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
    break;
  }

  return ret;
}
34013e10:	b01e      	add	sp, #120	@ 0x78
34013e12:	ecbd 8b02 	vpop	{d8}
34013e16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
34013e1a:	7819      	ldrb	r1, [r3, #0]
34013e1c:	b111      	cbz	r1, 34013e24 <ISP_Algo_AWB_Process+0x3c>
34013e1e:	2aff      	cmp	r2, #255	@ 0xff
34013e20:	f040 80b1 	bne.w	34013f86 <ISP_Algo_AWB_Process+0x19e>
    algo->state = ISP_ALGO_STATE_INIT;
34013e24:	2200      	movs	r2, #0
34013e26:	707a      	strb	r2, [r7, #1]
    IQParamConfig->AWBAlgo.enable = true;
34013e28:	2201      	movs	r2, #1
    reconfigureRequest = true;
34013e2a:	49bc      	ldr	r1, [pc, #752]	@ (3401411c <ISP_Algo_AWB_Process+0x334>)
    IQParamConfig->AWBAlgo.enable = true;
34013e2c:	f885 2070 	strb.w	r2, [r5, #112]	@ 0x70
    reconfigureRequest = true;
34013e30:	700a      	strb	r2, [r1, #0]
    enableCurrent = true;
34013e32:	701a      	strb	r2, [r3, #0]
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013e34:	2400      	movs	r4, #0
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e36:	ed9f 8aba 	vldr	s16, [pc, #744]	@ 34014120 <ISP_Algo_AWB_Process+0x338>
34013e3a:	f8df 92f0 	ldr.w	r9, [pc, #752]	@ 3401412c <ISP_Algo_AWB_Process+0x344>
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013e3e:	f8df a2e8 	ldr.w	sl, [pc, #744]	@ 34014128 <ISP_Algo_AWB_Process+0x340>
34013e42:	f505 7888 	add.w	r8, r5, #272	@ 0x110
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
34013e46:	f8d8 0004 	ldr.w	r0, [r8, #4]
      if (colorTemp == 0)
34013e4a:	2800      	cmp	r0, #0
34013e4c:	f000 80aa 	beq.w	34013fa4 <ISP_Algo_AWB_Process+0x1bc>
      if (profNb > 0)
34013e50:	b15c      	cbz	r4, 34013e6a <ISP_Algo_AWB_Process+0x82>
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
34013e52:	f8d8 3000 	ldr.w	r3, [r8]
34013e56:	eb03 0343 	add.w	r3, r3, r3, lsl #1
34013e5a:	4403      	add	r3, r0
34013e5c:	089b      	lsrs	r3, r3, #2
34013e5e:	ee07 3a90 	vmov	s15, r3
34013e62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013e66:	ed49 7a01 	vstr	s15, [r9, #-4]
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e6a:	edd8 7a06 	vldr	s15, [r8, #24]
34013e6e:	eef8 7a67 	vcvt.f32.u32	s15, s15
34013e72:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e76:	edd8 7a0b 	vldr	s15, [r8, #44]	@ 0x2c
34013e7a:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e7e:	ed8d 7a0e 	vstr	s14, [sp, #56]	@ 0x38
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e82:	ee87 7a88 	vdiv.f32	s14, s15, s16
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e86:	edd8 7a10 	vldr	s15, [r8, #64]	@ 0x40
34013e8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e8e:	ed8d 7a0f 	vstr	s14, [sp, #60]	@ 0x3c
      cfaGains[2] = cfaGains[1];
34013e92:	ed8d 7a10 	vstr	s14, [sp, #64]	@ 0x40
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34013e96:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013e9a:	2324      	movs	r3, #36	@ 0x24
34013e9c:	a914      	add	r1, sp, #80	@ 0x50
34013e9e:	ed8d 7a11 	vstr	s14, [sp, #68]	@ 0x44
34013ea2:	f04f 0c03 	mov.w	ip, #3
34013ea6:	460a      	mov	r2, r1
34013ea8:	fb03 5304 	mla	r3, r3, r4, r5
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34013eac:	edd3 7a59 	vldr	s15, [r3, #356]	@ 0x164
34013eb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013eb4:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013eb8:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
34013ebc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013ec0:	ed81 7a00 	vstr	s14, [r1]
34013ec4:	ee87 7a88 	vdiv.f32	s14, s15, s16
34013ec8:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
34013ecc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34013ed0:	ed81 7a01 	vstr	s14, [r1, #4]
34013ed4:	ee87 7a88 	vdiv.f32	s14, s15, s16
      for (i = 0; i < 3; i++)
34013ed8:	f1bc 0c01 	subs.w	ip, ip, #1
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34013edc:	ed81 7a02 	vstr	s14, [r1, #8]
      for (i = 0; i < 3; i++)
34013ee0:	f103 030c 	add.w	r3, r3, #12
34013ee4:	f101 010c 	add.w	r1, r1, #12
34013ee8:	d1e0      	bne.n	34013eac <ISP_Algo_AWB_Process+0xc4>
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013eea:	ee07 0a90 	vmov	s15, r0
34013eee:	2044      	movs	r0, #68	@ 0x44
34013ef0:	eeb8 0a67 	vcvt.f32.u32	s0, s15
34013ef4:	fb00 a004 	mla	r0, r0, r4, sl
34013ef8:	ab07      	add	r3, sp, #28
34013efa:	a90e      	add	r1, sp, #56	@ 0x38
      profNb++;
34013efc:	3401      	adds	r4, #1
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34013efe:	f7ec fed9 	bl	34000cb4 <evision_api_awb_set_profile>
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34013f02:	2c05      	cmp	r4, #5
34013f04:	f108 0804 	add.w	r8, r8, #4
34013f08:	f109 0904 	add.w	r9, r9, #4
34013f0c:	d19b      	bne.n	34013e46 <ISP_Algo_AWB_Process+0x5e>
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], profNb,
34013f0e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
34013f12:	ed93 1a44 	vldr	s2, [r3, #272]	@ 0x110
34013f16:	ed95 0a45 	vldr	s0, [r5, #276]	@ 0x114
34013f1a:	4d82      	ldr	r5, [pc, #520]	@ (34014124 <ISP_Algo_AWB_Process+0x33c>)
34013f1c:	eeb8 1b41 	vcvt.f64.u32	d1, s2
34013f20:	eeb8 0b40 	vcvt.f64.u32	d0, s0
34013f24:	4b80      	ldr	r3, [pc, #512]	@ (34014128 <ISP_Algo_AWB_Process+0x340>)
34013f26:	4a81      	ldr	r2, [pc, #516]	@ (3401412c <ISP_Algo_AWB_Process+0x344>)
34013f28:	6828      	ldr	r0, [r5, #0]
34013f2a:	b2a1      	uxth	r1, r4
34013f2c:	f7ec fee2 	bl	34000cf4 <evision_api_awb_init_profiles>
    if (e_ret != EVISION_RET_SUCCESS)
34013f30:	2801      	cmp	r0, #1
34013f32:	f040 80a6 	bne.w	34014082 <ISP_Algo_AWB_Process+0x29a>
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013f36:	f20f 19d0 	addw	r9, pc, #464	@ 0x1d0
34013f3a:	e9d9 8900 	ldrd	r8, r9, [r9]
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013f3e:	eeb0 7b00 	vmov.f64	d7, #0	@ 0x40000000  2.0
34013f42:	ed9f 6b73 	vldr	d6, [pc, #460]	@ 34014110 <ISP_Algo_AWB_Process+0x328>
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34013f46:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013f4a:	2c03      	cmp	r4, #3
34013f4c:	bf98      	it	ls
34013f4e:	eeb0 7b46 	vmovls.f64	d7, d6
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013f52:	682b      	ldr	r3, [r5, #0]
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34013f54:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34013f58:	4a75      	ldr	r2, [pc, #468]	@ (34014130 <ISP_Algo_AWB_Process+0x348>)
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34013f5a:	ed83 7ba8 	vstr	d7, [r3, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34013f5e:	e9c3 89a6 	strd	r8, r9, [r3, #664]	@ 0x298
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34013f62:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013f66:	2305      	movs	r3, #5
34013f68:	e9cd 0301 	strd	r0, r3, [sp, #4]
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013f6c:	2402      	movs	r4, #2
34013f6e:	463a      	mov	r2, r7
34013f70:	4630      	mov	r0, r6
34013f72:	4b70      	ldr	r3, [pc, #448]	@ (34014134 <ISP_Algo_AWB_Process+0x34c>)
34013f74:	4970      	ldr	r1, [pc, #448]	@ (34014138 <ISP_Algo_AWB_Process+0x350>)
34013f76:	9400      	str	r4, [sp, #0]
34013f78:	f001 f8ec 	bl	34015154 <ISP_SVC_Stats_GetNext>
    if (ret != ISP_OK)
34013f7c:	2800      	cmp	r0, #0
34013f7e:	f47f af47 	bne.w	34013e10 <ISP_Algo_AWB_Process+0x28>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34013f82:	707c      	strb	r4, [r7, #1]
    break;
34013f84:	e744      	b.n	34013e10 <ISP_Algo_AWB_Process+0x28>
  switch(algo->state)
34013f86:	787b      	ldrb	r3, [r7, #1]
34013f88:	2b03      	cmp	r3, #3
34013f8a:	d010      	beq.n	34013fae <ISP_Algo_AWB_Process+0x1c6>
34013f8c:	f63f af3f 	bhi.w	34013e0e <ISP_Algo_AWB_Process+0x26>
34013f90:	2b00      	cmp	r3, #0
34013f92:	f43f af4f 	beq.w	34013e34 <ISP_Algo_AWB_Process+0x4c>
34013f96:	2b01      	cmp	r3, #1
34013f98:	f47f af39 	bne.w	34013e0e <ISP_Algo_AWB_Process+0x26>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34013f9c:	2205      	movs	r2, #5
34013f9e:	e9cd 3201 	strd	r3, r2, [sp, #4]
34013fa2:	e7e3      	b.n	34013f6c <ISP_Algo_AWB_Process+0x184>
      return ISP_ERR_WB_COLORTEMP;
34013fa4:	2096      	movs	r0, #150	@ 0x96
    if (profNb == 0)
34013fa6:	2c00      	cmp	r4, #0
34013fa8:	f43f af32 	beq.w	34013e10 <ISP_Algo_AWB_Process+0x28>
34013fac:	e7af      	b.n	34013f0e <ISP_Algo_AWB_Process+0x126>
    ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
34013fae:	ab06      	add	r3, sp, #24
34013fb0:	9302      	str	r3, [sp, #8]
34013fb2:	ab05      	add	r3, sp, #20
34013fb4:	9301      	str	r3, [sp, #4]
34013fb6:	495f      	ldr	r1, [pc, #380]	@ (34014134 <ISP_Algo_AWB_Process+0x34c>)
34013fb8:	ab04      	add	r3, sp, #16
34013fba:	9300      	str	r3, [sp, #0]
34013fbc:	f891 3036 	ldrb.w	r3, [r1, #54]	@ 0x36
34013fc0:	f891 2035 	ldrb.w	r2, [r1, #53]	@ 0x35
34013fc4:	4630      	mov	r0, r6
34013fc6:	f891 1034 	ldrb.w	r1, [r1, #52]	@ 0x34
34013fca:	f7ff fe51 	bl	34013c70 <ISP_Algo_ApplyCConv>
    meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34013fce:	4630      	mov	r0, r6
34013fd0:	9904      	ldr	r1, [sp, #16]
34013fd2:	f7ff fe21 	bl	34013c18 <ISP_Algo_ApplyGammaInverse>
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34013fd6:	4630      	mov	r0, r6
34013fd8:	9905      	ldr	r1, [sp, #20]
    meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34013fda:	ed8d 0b0e 	vstr	d0, [sp, #56]	@ 0x38
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34013fde:	f7ff fe1b 	bl	34013c18 <ISP_Algo_ApplyGammaInverse>
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34013fe2:	4630      	mov	r0, r6
34013fe4:	9906      	ldr	r1, [sp, #24]
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34013fe6:	ed8d 0b10 	vstr	d0, [sp, #64]	@ 0x40
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34013fea:	f7ff fe15 	bl	34013c18 <ISP_Algo_ApplyGammaInverse>
    e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
34013fee:	f8df 8134 	ldr.w	r8, [pc, #308]	@ 34014124 <ISP_Algo_AWB_Process+0x33c>
34013ff2:	2201      	movs	r2, #1
34013ff4:	4621      	mov	r1, r4
34013ff6:	f8d8 0000 	ldr.w	r0, [r8]
34013ffa:	ab0e      	add	r3, sp, #56	@ 0x38
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34013ffc:	ed8d 0b12 	vstr	d0, [sp, #72]	@ 0x48
    e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
34014000:	f7ed f84c 	bl	3400109c <evision_api_awb_run_average>
    if (e_ret == EVISION_RET_SUCCESS)
34014004:	2801      	cmp	r0, #1
34014006:	d13a      	bne.n	3401407e <ISP_Algo_AWB_Process+0x296>
      if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
34014008:	f8df 9134 	ldr.w	r9, [pc, #308]	@ 34014140 <ISP_Algo_AWB_Process+0x358>
3401400c:	f8d8 3000 	ldr.w	r3, [r8]
34014010:	edd9 7a00 	vldr	s15, [r9]
34014014:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34014018:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401401c:	eeb4 6b47 	vcmp.f64	d6, d7
34014020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34014024:	4b3d      	ldr	r3, [pc, #244]	@ (3401411c <ISP_Algo_AWB_Process+0x334>)
34014026:	d102      	bne.n	3401402e <ISP_Algo_AWB_Process+0x246>
34014028:	781a      	ldrb	r2, [r3, #0]
3401402a:	2a01      	cmp	r2, #1
3401402c:	d116      	bne.n	3401405c <ISP_Algo_AWB_Process+0x274>
        reconfigureRequest = false;
3401402e:	f04f 0a00 	mov.w	sl, #0
34014032:	f883 a000 	strb.w	sl, [r3]
        for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34014036:	2305      	movs	r3, #5
34014038:	f505 7288 	add.w	r2, r5, #272	@ 0x110
          if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
3401403c:	ed92 7a01 	vldr	s14, [r2, #4]
34014040:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34014044:	eeb4 6b47 	vcmp.f64	d6, d7
34014048:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401404c:	f102 0204 	add.w	r2, r2, #4
34014050:	d019      	beq.n	34014086 <ISP_Algo_AWB_Process+0x29e>
        for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34014052:	3b01      	subs	r3, #1
34014054:	f10a 0a01 	add.w	sl, sl, #1
34014058:	d1f0      	bne.n	3401403c <ISP_Algo_AWB_Process+0x254>
          ret  = ISP_ERR_WB_COLORTEMP;
3401405a:	2496      	movs	r4, #150	@ 0x96
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3401405c:	2301      	movs	r3, #1
3401405e:	2205      	movs	r2, #5
34014060:	2502      	movs	r5, #2
34014062:	e9cd 3201 	strd	r3, r2, [sp, #4]
34014066:	4630      	mov	r0, r6
34014068:	463a      	mov	r2, r7
3401406a:	4b32      	ldr	r3, [pc, #200]	@ (34014134 <ISP_Algo_AWB_Process+0x34c>)
3401406c:	4932      	ldr	r1, [pc, #200]	@ (34014138 <ISP_Algo_AWB_Process+0x350>)
3401406e:	9500      	str	r5, [sp, #0]
34014070:	f001 f870 	bl	34015154 <ISP_SVC_Stats_GetNext>
    ret = (ret != ISP_OK) ? ret : ret_stat;
34014074:	2c00      	cmp	r4, #0
34014076:	bf18      	it	ne
34014078:	4620      	movne	r0, r4
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3401407a:	707d      	strb	r5, [r7, #1]
    break;
3401407c:	e6c8      	b.n	34013e10 <ISP_Algo_AWB_Process+0x28>
      ret = ISP_ERR_ALGO;
3401407e:	24be      	movs	r4, #190	@ 0xbe
34014080:	e7ec      	b.n	3401405c <ISP_Algo_AWB_Process+0x274>
      return ISP_ERR_ALGO;
34014082:	20be      	movs	r0, #190	@ 0xbe
34014084:	e6c4      	b.n	34013e10 <ISP_Algo_AWB_Process+0x28>
          ColorConvConfig.enable = 1;
34014086:	2301      	movs	r3, #1
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34014088:	f04f 0e04 	mov.w	lr, #4
          ColorConvConfig.enable = 1;
3401408c:	f88d 3050 	strb.w	r3, [sp, #80]	@ 0x50
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34014090:	2324      	movs	r3, #36	@ 0x24
34014092:	f04e e001 	dls	lr, lr
34014096:	fb03 530a 	mla	r3, r3, sl, r5
3401409a:	aa15      	add	r2, sp, #84	@ 0x54
3401409c:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
340140a0:	4614      	mov	r4, r2
340140a2:	6818      	ldr	r0, [r3, #0]
340140a4:	6859      	ldr	r1, [r3, #4]
340140a6:	3308      	adds	r3, #8
340140a8:	c403      	stmia	r4!, {r0, r1}
340140aa:	4622      	mov	r2, r4
340140ac:	f00f c009 	le	lr, 340140a0 <ISP_Algo_AWB_Process+0x2b8>
340140b0:	6818      	ldr	r0, [r3, #0]
          ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
340140b2:	a914      	add	r1, sp, #80	@ 0x50
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
340140b4:	6020      	str	r0, [r4, #0]
          ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
340140b6:	4630      	mov	r0, r6
340140b8:	f000 fc98 	bl	340149ec <ISP_SVC_ISP_SetColorConv>
          if (ret == ISP_OK)
340140bc:	4604      	mov	r4, r0
340140be:	2800      	cmp	r0, #0
340140c0:	d1cc      	bne.n	3401405c <ISP_Algo_AWB_Process+0x274>
            ISPGainConfig.enable = 1;
340140c2:	2301      	movs	r3, #1
340140c4:	eb05 058a 	add.w	r5, r5, sl, lsl #2
340140c8:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
            ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
340140cc:	f8d5 3128 	ldr.w	r3, [r5, #296]	@ 0x128
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
340140d0:	4630      	mov	r0, r6
            ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
340140d2:	930b      	str	r3, [sp, #44]	@ 0x2c
            ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
340140d4:	f8d5 313c 	ldr.w	r3, [r5, #316]	@ 0x13c
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
340140d8:	a90a      	add	r1, sp, #40	@ 0x28
            ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
340140da:	930c      	str	r3, [sp, #48]	@ 0x30
            ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
340140dc:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
340140e0:	930d      	str	r3, [sp, #52]	@ 0x34
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
340140e2:	f000 fbe9 	bl	340148b8 <ISP_SVC_ISP_SetGain>
            if (ret == ISP_OK)
340140e6:	4604      	mov	r4, r0
340140e8:	2800      	cmp	r0, #0
340140ea:	d1b7      	bne.n	3401405c <ISP_Algo_AWB_Process+0x274>
              currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
340140ec:	f8d8 3000 	ldr.w	r3, [r8]
340140f0:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
340140f4:	eebc 7bc7 	vcvt.u32.f64	s14, d7
              current_awb_profId = profId;
340140f8:	4b10      	ldr	r3, [pc, #64]	@ (3401413c <ISP_Algo_AWB_Process+0x354>)
              currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
340140fa:	ed89 7a00 	vstr	s14, [r9]
              current_awb_profId = profId;
340140fe:	f8c3 a000 	str.w	sl, [r3]
34014102:	e7ab      	b.n	3401405c <ISP_Algo_AWB_Process+0x274>
34014104:	f3af 8000 	nop.w
34014108:	9999999a 	.word	0x9999999a
3401410c:	3ff59999 	.word	0x3ff59999
34014110:	cccccccd 	.word	0xcccccccd
34014114:	3ffccccc 	.word	0x3ffccccc
34014118:	34057d15 	.word	0x34057d15
3401411c:	34057d14 	.word	0x34057d14
34014120:	4cbebc20 	.word	0x4cbebc20
34014124:	34057da0 	.word	0x34057da0
34014128:	34057bb0 	.word	0x34057bb0
3401412c:	34057d04 	.word	0x34057d04
34014130:	40400000 	.word	0x40400000
34014134:	34057b38 	.word	0x34057b38
34014138:	340139db 	.word	0x340139db
3401413c:	34057d9c 	.word	0x34057d9c
34014140:	34057b34 	.word	0x34057b34

34014144 <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
34014144:	b538      	push	{r3, r4, r5, lr}
34014146:	4604      	mov	r4, r0
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
34014148:	2500      	movs	r5, #0
3401414a:	4b09      	ldr	r3, [pc, #36]	@ (34014170 <ISP_Algo_Init+0x2c>)
3401414c:	6183      	str	r3, [r0, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
3401414e:	69a3      	ldr	r3, [r4, #24]
34014150:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Init != NULL))
34014152:	b921      	cbnz	r1, 3401415e <ISP_Algo_Init+0x1a>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34014154:	3504      	adds	r5, #4
34014156:	2d0c      	cmp	r5, #12
34014158:	d1f9      	bne.n	3401414e <ISP_Algo_Init+0xa>
        return ret;
      }
    }
  }

  return ISP_OK;
3401415a:	2000      	movs	r0, #0
}
3401415c:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Init != NULL))
3401415e:	684b      	ldr	r3, [r1, #4]
34014160:	2b00      	cmp	r3, #0
34014162:	d0f7      	beq.n	34014154 <ISP_Algo_Init+0x10>
      ret = algo->Init((void*)hIsp, (void*)algo);
34014164:	4620      	mov	r0, r4
34014166:	4798      	blx	r3
      if (ret != ISP_OK)
34014168:	2800      	cmp	r0, #0
3401416a:	d0f3      	beq.n	34014154 <ISP_Algo_Init+0x10>
3401416c:	e7f6      	b.n	3401415c <ISP_Algo_Init+0x18>
3401416e:	bf00      	nop
34014170:	3403ee14 	.word	0x3403ee14

34014174 <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
34014174:	b538      	push	{r3, r4, r5, lr}
34014176:	4604      	mov	r4, r0
34014178:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
3401417a:	69a3      	ldr	r3, [r4, #24]
3401417c:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->DeInit != NULL))
3401417e:	b921      	cbnz	r1, 3401418a <ISP_Algo_DeInit+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34014180:	3504      	adds	r5, #4
34014182:	2d0c      	cmp	r5, #12
34014184:	d1f9      	bne.n	3401417a <ISP_Algo_DeInit+0x6>
        return ret;
      }
    }
  }

  return ISP_OK;
34014186:	2000      	movs	r0, #0
}
34014188:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->DeInit != NULL))
3401418a:	688b      	ldr	r3, [r1, #8]
3401418c:	2b00      	cmp	r3, #0
3401418e:	d0f7      	beq.n	34014180 <ISP_Algo_DeInit+0xc>
      ret = algo->DeInit((void*)hIsp, (void*)algo);
34014190:	4620      	mov	r0, r4
34014192:	4798      	blx	r3
      if (ret != ISP_OK)
34014194:	2800      	cmp	r0, #0
34014196:	d0f3      	beq.n	34014180 <ISP_Algo_DeInit+0xc>
34014198:	e7f6      	b.n	34014188 <ISP_Algo_DeInit+0x14>

3401419a <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
3401419a:	b538      	push	{r3, r4, r5, lr}
3401419c:	4604      	mov	r4, r0
3401419e:	2500      	movs	r5, #0
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
  {
    algo = hIsp->algorithm[i];
340141a0:	69a3      	ldr	r3, [r4, #24]
340141a2:	5959      	ldr	r1, [r3, r5]
    if ((algo != NULL) && (algo->Process != NULL))
340141a4:	b921      	cbnz	r1, 340141b0 <ISP_Algo_Process+0x16>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
340141a6:	3504      	adds	r5, #4
340141a8:	2d0c      	cmp	r5, #12
340141aa:	d1f9      	bne.n	340141a0 <ISP_Algo_Process+0x6>
      }
#endif
    }
  }

  return ISP_OK;
340141ac:	2000      	movs	r0, #0
}
340141ae:	bd38      	pop	{r3, r4, r5, pc}
    if ((algo != NULL) && (algo->Process != NULL))
340141b0:	68cb      	ldr	r3, [r1, #12]
340141b2:	2b00      	cmp	r3, #0
340141b4:	d0f7      	beq.n	340141a6 <ISP_Algo_Process+0xc>
      ret = algo->Process((void*)hIsp, (void*)algo);
340141b6:	4620      	mov	r0, r4
340141b8:	4798      	blx	r3
      if (ret != ISP_OK)
340141ba:	2800      	cmp	r0, #0
340141bc:	d0f3      	beq.n	340141a6 <ISP_Algo_Process+0xc>
340141be:	e7f6      	b.n	340141ae <ISP_Algo_Process+0x14>

340141c0 <ISP_Init>:
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           ISP_StatAreaTypeDef *pStatArea,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
340141c0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
340141c4:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
340141c8:	460e      	mov	r6, r1
340141ca:	4691      	mov	r9, r2
340141cc:	461c      	mov	r4, r3
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
340141ce:	4605      	mov	r5, r0
340141d0:	2800      	cmp	r0, #0
340141d2:	d070      	beq.n	340142b6 <ISP_Init+0xf6>
340141d4:	2900      	cmp	r1, #0
340141d6:	d06e      	beq.n	340142b6 <ISP_Init+0xf6>
340141d8:	2b00      	cmp	r3, #0
340141da:	d06c      	beq.n	340142b6 <ISP_Init+0xf6>
  {
    return ISP_ERR_EINVAL;
  }

  memset(hIsp, 0, sizeof(*hIsp));
340141dc:	f100 0708 	add.w	r7, r0, #8
340141e0:	2280      	movs	r2, #128	@ 0x80
340141e2:	2100      	movs	r1, #0
340141e4:	4638      	mov	r0, r7
340141e6:	f004 fd3d 	bl	34018c64 <memset>
  hIsp->cameraInstance = CameraInstance;
  hIsp->MainPipe_FrameCount = 0;
  hIsp->AncillaryPipe_FrameCount = 0;
  hIsp->DumpPipe_FrameCount = 0;

  hIsp->appliHelpers = *pAppliHelpers;
340141ea:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  hIsp->cameraInstance = CameraInstance;
340141ec:	e9c5 6900 	strd	r6, r9, [r5]
  hIsp->appliHelpers = *pAppliHelpers;
340141f0:	f105 061c 	add.w	r6, r5, #28
340141f4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340141f6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
340141f8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
340141fa:	6823      	ldr	r3, [r4, #0]
340141fc:	6033      	str	r3, [r6, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
340141fe:	6aab      	ldr	r3, [r5, #40]	@ 0x28
34014200:	b93b      	cbnz	r3, 34014212 <ISP_Init+0x52>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
34014202:	482e      	ldr	r0, [pc, #184]	@ (340142bc <ISP_Init+0xfc>)
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
      return ISP_ERR_APP_HELPER_UNDEFINED;
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
34014204:	f004 fbc2 	bl	3401898c <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
34014208:	24b4      	movs	r4, #180	@ 0xb4

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);

  return ISP_OK;
}
3401420a:	4620      	mov	r0, r4
3401420c:	b003      	add	sp, #12
3401420e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (hIsp->appliHelpers.SetSensorGain == NULL)
34014212:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
34014214:	b90b      	cbnz	r3, 3401421a <ISP_Init+0x5a>
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
34014216:	482a      	ldr	r0, [pc, #168]	@ (340142c0 <ISP_Init+0x100>)
34014218:	e7f4      	b.n	34014204 <ISP_Init+0x44>
  if (hIsp->appliHelpers.GetSensorGain == NULL)
3401421a:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
3401421c:	b90b      	cbnz	r3, 34014222 <ISP_Init+0x62>
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
3401421e:	4829      	ldr	r0, [pc, #164]	@ (340142c4 <ISP_Init+0x104>)
34014220:	e7f0      	b.n	34014204 <ISP_Init+0x44>
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
34014222:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
34014224:	b90b      	cbnz	r3, 3401422a <ISP_Init+0x6a>
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
34014226:	4828      	ldr	r0, [pc, #160]	@ (340142c8 <ISP_Init+0x108>)
34014228:	e7ec      	b.n	34014204 <ISP_Init+0x44>
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
3401422a:	6bab      	ldr	r3, [r5, #56]	@ 0x38
3401422c:	b90b      	cbnz	r3, 34014232 <ISP_Init+0x72>
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
3401422e:	4827      	ldr	r0, [pc, #156]	@ (340142cc <ISP_Init+0x10c>)
34014230:	e7e8      	b.n	34014204 <ISP_Init+0x44>
  if (pStatArea != NULL)
34014232:	f1b8 0f00 	cmp.w	r8, #0
34014236:	d003      	beq.n	34014240 <ISP_Init+0x80>
    hIsp->statArea = *pStatArea;
34014238:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
3401423c:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
34014240:	4628      	mov	r0, r5
34014242:	990b      	ldr	r1, [sp, #44]	@ 0x2c
34014244:	f000 fd38 	bl	34014cb8 <ISP_SVC_IQParam_Init>
  if (ret != ISP_OK)
34014248:	4604      	mov	r4, r0
3401424a:	2800      	cmp	r0, #0
3401424c:	d1dd      	bne.n	3401420a <ISP_Init+0x4a>
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
3401424e:	4628      	mov	r0, r5
34014250:	f105 014c 	add.w	r1, r5, #76	@ 0x4c
34014254:	f000 fc9a 	bl	34014b8c <ISP_SVC_Sensor_GetInfo>
  if (ret != ISP_OK)
34014258:	4604      	mov	r4, r0
3401425a:	2800      	cmp	r0, #0
3401425c:	d1d5      	bne.n	3401420a <ISP_Init+0x4a>
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
3401425e:	6f2a      	ldr	r2, [r5, #112]	@ 0x70
34014260:	f5b2 6f28 	cmp.w	r2, #2688	@ 0xa80
34014264:	d30f      	bcc.n	34014286 <ISP_Init+0xc6>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
34014266:	f5b2 5fa8 	cmp.w	r2, #5376	@ 0x1500
3401426a:	d320      	bcc.n	340142ae <ISP_Init+0xee>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
3401426c:	f5b2 5f28 	cmp.w	r2, #10752	@ 0x2a00
34014270:	d31f      	bcc.n	340142b2 <ISP_Init+0xf2>
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
34014272:	f5b2 4fa8 	cmp.w	r2, #21504	@ 0x5400
34014276:	f04f 0308 	mov.w	r3, #8
3401427a:	d305      	bcc.n	34014288 <ISP_Init+0xc8>
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
3401427c:	4814      	ldr	r0, [pc, #80]	@ (340142d0 <ISP_Init+0x110>)
3401427e:	f004 fb85 	bl	3401898c <puts>
    return ISP_ERR_DECIMATION_EINVAL;
34014282:	241e      	movs	r4, #30
34014284:	e7c1      	b.n	3401420a <ISP_Init+0x4a>
34014286:	2301      	movs	r3, #1
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
34014288:	4628      	mov	r0, r5
3401428a:	a901      	add	r1, sp, #4
    decimation.factor = ISP_DECIM_FACTOR_1;
3401428c:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
34014290:	f000 f9c6 	bl	34014620 <ISP_SVC_ISP_SetDecimation>
  if (ret != ISP_OK)
34014294:	4604      	mov	r4, r0
34014296:	2800      	cmp	r0, #0
34014298:	d1b7      	bne.n	3401420a <ISP_Init+0x4a>
  ret = ISP_Algo_Init(hIsp);
3401429a:	4628      	mov	r0, r5
3401429c:	f7ff ff52 	bl	34014144 <ISP_Algo_Init>
  if (ret != ISP_OK)
340142a0:	4604      	mov	r4, r0
340142a2:	2800      	cmp	r0, #0
340142a4:	d1b1      	bne.n	3401420a <ISP_Init+0x4a>
  ISP_SVC_Stats_Init(hIsp);
340142a6:	4628      	mov	r0, r5
340142a8:	f000 fd14 	bl	34014cd4 <ISP_SVC_Stats_Init>
  return ISP_OK;
340142ac:	e7ad      	b.n	3401420a <ISP_Init+0x4a>
340142ae:	2302      	movs	r3, #2
340142b0:	e7ea      	b.n	34014288 <ISP_Init+0xc8>
340142b2:	2304      	movs	r3, #4
340142b4:	e7e8      	b.n	34014288 <ISP_Init+0xc8>
    return ISP_ERR_EINVAL;
340142b6:	2401      	movs	r4, #1
340142b8:	e7a7      	b.n	3401420a <ISP_Init+0x4a>
340142ba:	bf00      	nop
340142bc:	3401cec2 	.word	0x3401cec2
340142c0:	3401cefa 	.word	0x3401cefa
340142c4:	3401cf32 	.word	0x3401cf32
340142c8:	3401cf6a 	.word	0x3401cf6a
340142cc:	3401cfa6 	.word	0x3401cfa6
340142d0:	3401cfe2 	.word	0x3401cfe2

340142d4 <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
340142d4:	b538      	push	{r3, r4, r5, lr}
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
340142d6:	4605      	mov	r5, r0
340142d8:	b150      	cbz	r0, 340142f0 <ISP_DeInit+0x1c>
  {
    return ISP_ERR_EINVAL;
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
340142da:	f7ff ff4b 	bl	34014174 <ISP_Algo_DeInit>
  if (ret != ISP_OK)
340142de:	4604      	mov	r4, r0
340142e0:	b920      	cbnz	r0, 340142ec <ISP_DeInit+0x18>
  {
    return ret;
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
340142e2:	4601      	mov	r1, r0
340142e4:	2288      	movs	r2, #136	@ 0x88
340142e6:	4628      	mov	r0, r5
340142e8:	f004 fcbc 	bl	34018c64 <memset>

  return ISP_OK;
}
340142ec:	4620      	mov	r0, r4
340142ee:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
340142f0:	2401      	movs	r4, #1
340142f2:	e7fb      	b.n	340142ec <ISP_DeInit+0x18>
340142f4:	0000      	movs	r0, r0
	...

340142f8 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
340142f8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
340142fa:	4606      	mov	r6, r0
340142fc:	2800      	cmp	r0, #0
340142fe:	f000 809c 	beq.w	3401443a <ISP_Start+0x142>
  {
    return ISP_ERR_EINVAL;
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
34014302:	f000 fc8b 	bl	34014c1c <ISP_SVC_Misc_IsDCMIPPReady>
  if (ret != ISP_OK)
34014306:	2800      	cmp	r0, #0
34014308:	d171      	bne.n	340143ee <ISP_Start+0xf6>
  {
    return ret;
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401430a:	4630      	mov	r0, r6
3401430c:	f000 fcde 	bl	34014ccc <ISP_SVC_IQParam_Get>
34014310:	4605      	mov	r5, r0

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
34014312:	f100 010c 	add.w	r1, r0, #12
34014316:	4630      	mov	r0, r6
34014318:	f000 f922 	bl	34014560 <ISP_SVC_ISP_SetDemosaicing>
  if (ret != ISP_OK)
3401431c:	2800      	cmp	r0, #0
3401431e:	d166      	bne.n	340143ee <ISP_Start+0xf6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
34014320:	4629      	mov	r1, r5
34014322:	4630      	mov	r0, r6
34014324:	f000 f95b 	bl	340145de <ISP_SVC_ISP_SetStatRemoval>
  if (ret != ISP_OK)
34014328:	2800      	cmp	r0, #0
3401432a:	d160      	bne.n	340143ee <ISP_Start+0xf6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
3401432c:	4630      	mov	r0, r6
3401432e:	f105 0114 	add.w	r1, r5, #20
34014332:	f000 f9a9 	bl	34014688 <ISP_SVC_ISP_SetContrast>
  if (ret != ISP_OK)
34014336:	2800      	cmp	r0, #0
34014338:	d159      	bne.n	340143ee <ISP_Start+0xf6>
  {
    return ret;
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
3401433a:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
3401433c:	2b00      	cmp	r3, #0
3401433e:	d14b      	bne.n	340143d8 <ISP_Start+0xe0>
    {
      return ret;
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
34014340:	6d2b      	ldr	r3, [r5, #80]	@ 0x50
34014342:	2b00      	cmp	r3, #0
34014344:	d155      	bne.n	340143f2 <ISP_Start+0xfa>
    {
      return ret;
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
34014346:	f895 305c 	ldrb.w	r3, [r5, #92]	@ 0x5c
3401434a:	b133      	cbz	r3, 3401435a <ISP_Start+0x62>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
3401434c:	4630      	mov	r0, r6
3401434e:	f105 015c 	add.w	r1, r5, #92	@ 0x5c
34014352:	f000 fa57 	bl	34014804 <ISP_SVC_ISP_SetBadPixel>
    if (ret != ISP_OK)
34014356:	2800      	cmp	r0, #0
34014358:	d149      	bne.n	340143ee <ISP_Start+0xf6>
    {
      return ret;
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
3401435a:	f895 3064 	ldrb.w	r3, [r5, #100]	@ 0x64
3401435e:	b133      	cbz	r3, 3401436e <ISP_Start+0x76>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
34014360:	4630      	mov	r0, r6
34014362:	f105 0164 	add.w	r1, r5, #100	@ 0x64
34014366:	f000 fa82 	bl	3401486e <ISP_SVC_ISP_SetBlackLevel>
    if (ret != ISP_OK)
3401436a:	2800      	cmp	r0, #0
3401436c:	d13f      	bne.n	340143ee <ISP_Start+0xf6>
    {
      return ret;
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401436e:	f895 3218 	ldrb.w	r3, [r5, #536]	@ 0x218
34014372:	2b00      	cmp	r3, #0
34014374:	d149      	bne.n	3401440a <ISP_Start+0x112>
    {
      return ret;
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
34014376:	f895 3228 	ldrb.w	r3, [r5, #552]	@ 0x228
3401437a:	2b00      	cmp	r3, #0
3401437c:	d151      	bne.n	34014422 <ISP_Start+0x12a>
    }
  }

  /* Configure statistic area (defined by the application or by an optional static configuration) */
  /* Get its config from IQ params if it was not provided by the application at ISP_Init() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
3401437e:	6933      	ldr	r3, [r6, #16]
34014380:	f106 0408 	add.w	r4, r6, #8
34014384:	b10b      	cbz	r3, 3401438a <ISP_Start+0x92>
34014386:	6973      	ldr	r3, [r6, #20]
34014388:	b923      	cbnz	r3, 34014394 <ISP_Start+0x9c>
  {
    hIsp->statArea = IQParamConfig->statAreaStatic;
3401438a:	f105 033c 	add.w	r3, r5, #60	@ 0x3c
3401438e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
34014390:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  }
  ret = ISP_SVC_ISP_SetStatArea(hIsp, &hIsp->statArea);
34014394:	4621      	mov	r1, r4
34014396:	4630      	mov	r0, r6
34014398:	f000 f9f0 	bl	3401477c <ISP_SVC_ISP_SetStatArea>
  if (ret != ISP_OK)
3401439c:	bb38      	cbnz	r0, 340143ee <ISP_Start+0xf6>
  {
    return ret;
  }

  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
3401439e:	4630      	mov	r0, r6
340143a0:	f505 7114 	add.w	r1, r5, #592	@ 0x250
340143a4:	f000 fc66 	bl	34014c74 <ISP_SVC_ISP_SetGamma>
  if (ret != ISP_OK)
340143a8:	bb08      	cbnz	r0, 340143ee <ISP_Start+0xf6>
  {
    return ret;
  }

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
340143aa:	f995 3069 	ldrsb.w	r3, [r5, #105]	@ 0x69
340143ae:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
340143b2:	ee01 3a10 	vmov	s2, r3
340143b6:	eeba 1aef 	vcvt.f32.s32	s2, s2, #1
340143ba:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
340143be:	9001      	str	r0, [sp, #4]
340143c0:	f006 fe06 	bl	3401afd0 <pow>
340143c4:	ed9f 7b1e 	vldr	d7, [pc, #120]	@ 34014440 <ISP_Start+0x148>
340143c8:	ee20 0b07 	vmul.f64	d0, d0, d7
340143cc:	eebc 0bc0 	vcvt.u32.f64	s0, d0

  return ISP_OK;
340143d0:	9801      	ldr	r0, [sp, #4]
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
340143d2:	ed85 0a1b 	vstr	s0, [r5, #108]	@ 0x6c
  return ISP_OK;
340143d6:	e00a      	b.n	340143ee <ISP_Start+0xf6>
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
340143d8:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
340143dc:	2b00      	cmp	r3, #0
340143de:	d1af      	bne.n	34014340 <ISP_Start+0x48>
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
340143e0:	4630      	mov	r0, r6
340143e2:	f105 014c 	add.w	r1, r5, #76	@ 0x4c
340143e6:	f000 fbdf 	bl	34014ba8 <ISP_SVC_Sensor_SetGain>
    if (ret != ISP_OK)
340143ea:	2800      	cmp	r0, #0
340143ec:	d0a8      	beq.n	34014340 <ISP_Start+0x48>
}
340143ee:	b002      	add	sp, #8
340143f0:	bd70      	pop	{r4, r5, r6, pc}
  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
340143f2:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
340143f6:	2b00      	cmp	r3, #0
340143f8:	d1a5      	bne.n	34014346 <ISP_Start+0x4e>
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
340143fa:	4630      	mov	r0, r6
340143fc:	f105 0150 	add.w	r1, r5, #80	@ 0x50
34014400:	f000 fbef 	bl	34014be2 <ISP_SVC_Sensor_SetExposure>
    if (ret != ISP_OK)
34014404:	2800      	cmp	r0, #0
34014406:	d09e      	beq.n	34014346 <ISP_Start+0x4e>
34014408:	e7f1      	b.n	340143ee <ISP_Start+0xf6>
  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401440a:	f895 3070 	ldrb.w	r3, [r5, #112]	@ 0x70
3401440e:	2b00      	cmp	r3, #0
34014410:	d1b1      	bne.n	34014376 <ISP_Start+0x7e>
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
34014412:	4630      	mov	r0, r6
34014414:	f505 7106 	add.w	r1, r5, #536	@ 0x218
34014418:	f000 fa4e 	bl	340148b8 <ISP_SVC_ISP_SetGain>
    if (ret != ISP_OK)
3401441c:	2800      	cmp	r0, #0
3401441e:	d0aa      	beq.n	34014376 <ISP_Start+0x7e>
34014420:	e7e5      	b.n	340143ee <ISP_Start+0xf6>
  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
34014422:	f895 3070 	ldrb.w	r3, [r5, #112]	@ 0x70
34014426:	2b00      	cmp	r3, #0
34014428:	d1a9      	bne.n	3401437e <ISP_Start+0x86>
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
3401442a:	4630      	mov	r0, r6
3401442c:	f505 710a 	add.w	r1, r5, #552	@ 0x228
34014430:	f000 fadc 	bl	340149ec <ISP_SVC_ISP_SetColorConv>
    if (ret != ISP_OK)
34014434:	2800      	cmp	r0, #0
34014436:	d0a2      	beq.n	3401437e <ISP_Start+0x86>
34014438:	e7d9      	b.n	340143ee <ISP_Start+0xf6>
    return ISP_ERR_EINVAL;
3401443a:	2001      	movs	r0, #1
3401443c:	e7d7      	b.n	340143ee <ISP_Start+0xf6>
3401443e:	bf00      	nop
34014440:	00000000 	.word	0x00000000
34014444:	404c0000 	.word	0x404c0000

34014448 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
34014448:	b538      	push	{r3, r4, r5, lr}
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
3401444a:	4605      	mov	r5, r0
3401444c:	b150      	cbz	r0, 34014464 <ISP_BackgroundProcess+0x1c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
3401444e:	f000 fe43 	bl	340150d8 <ISP_SVC_Stats_ProcessCallbacks>
34014452:	4604      	mov	r4, r0

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
34014454:	4628      	mov	r0, r5
34014456:	f7ff fea0 	bl	3401419a <ISP_Algo_Process>
  else if (retAlgo != ISP_OK)
  {
    return retAlgo;
  }

  return ISP_OK;
3401445a:	2c00      	cmp	r4, #0
3401445c:	bf08      	it	eq
3401445e:	4604      	moveq	r4, r0
}
34014460:	4620      	mov	r0, r4
34014462:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_EINVAL;
34014464:	2401      	movs	r4, #1
34014466:	e7fb      	b.n	34014460 <ISP_BackgroundProcess+0x18>

34014468 <ISP_GatherStatistics>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Stats_Gather(hIsp);
34014468:	f000 bc3c 	b.w	34014ce4 <ISP_SVC_Stats_Gather>

3401446c <ISP_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncMainFrameId(hIsp);
3401446c:	f000 bbe2 	b.w	34014c34 <ISP_SVC_Misc_IncMainFrameId>

34014470 <ISP_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
34014470:	f000 bbe6 	b.w	34014c40 <ISP_SVC_Misc_IncAncillaryFrameId>

34014474 <ISP_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
34014474:	f000 bbe8 	b.w	34014c48 <ISP_SVC_Misc_IncDumpFrameId>

34014478 <GetAvgStats>:

  return (int32_t) Val;
}

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
34014478:	b510      	push	{r4, lr}
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
3401447a:	e9d0 4004 	ldrd	r4, r0, [r0, #16]
3401447e:	4360      	muls	r0, r4
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
34014480:	4c0d      	ldr	r4, [pc, #52]	@ (340144b8 <GetAvgStats+0x40>)

  if (location == ISP_STAT_LOC_DOWN)
34014482:	2902      	cmp	r1, #2
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
34014484:	7824      	ldrb	r4, [r4, #0]
34014486:	fb04 f404 	mul.w	r4, r4, r4
3401448a:	fbb0 f0f4 	udiv	r0, r0, r4
  if (location == ISP_STAT_LOC_DOWN)
3401448e:	d010      	beq.n	340144b2 <GetAvgStats+0x3a>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
34014490:	2a01      	cmp	r2, #1
34014492:	bf14      	ite	ne
34014494:	2204      	movne	r2, #4
34014496:	2202      	moveq	r2, #2

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
34014498:	4282      	cmp	r2, r0
  nb_comp_pix /= comp_divider;
3401449a:	bf9f      	itttt	ls
3401449c:	fbb0 f0f2 	udivls	r0, r0, r2
  {
    return 0;
  }

  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
340144a0:	0842      	lsrls	r2, r0, #1
340144a2:	eb02 2303 	addls.w	r3, r2, r3, lsl #8
340144a6:	fbb3 f0f0 	udivls	r0, r3, r0
    return 0;
340144aa:	bf8c      	ite	hi
340144ac:	2000      	movhi	r0, #0
  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
340144ae:	b2c0      	uxtbls	r0, r0
}
340144b0:	bd10      	pop	{r4, pc}
    comp_divider = 1;
340144b2:	2201      	movs	r2, #1
340144b4:	e7f0      	b.n	34014498 <GetAvgStats+0x20>
340144b6:	bf00      	nop
340144b8:	3403eed6 	.word	0x3403eed6

340144bc <SetStatConfig>:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
  }
}

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
340144bc:	b5f0      	push	{r4, r5, r6, r7, lr}
340144be:	460b      	mov	r3, r1
340144c0:	4606      	mov	r6, r0
  for (int i = 0; i < 3; i++)
340144c2:	2400      	movs	r4, #0
  {
    statConf[i] = *refConfig;
340144c4:	270c      	movs	r7, #12
340144c6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
340144ca:	fb07 6504 	mla	r5, r7, r4, r6
  for (int i = 0; i < 3; i++)
340144ce:	3401      	adds	r4, #1
340144d0:	2c03      	cmp	r4, #3
    statConf[i] = *refConfig;
340144d2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
340144d6:	d1f6      	bne.n	340144c6 <SetStatConfig+0xa>
  }
}
340144d8:	bdf0      	pop	{r4, r5, r6, r7, pc}

340144da <ReadStatHistogram>:
{
340144da:	b570      	push	{r4, r5, r6, lr}
340144dc:	4606      	mov	r6, r0
340144de:	460c      	mov	r4, r1
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
340144e0:	2501      	movs	r5, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
340144e2:	4623      	mov	r3, r4
340144e4:	b2ea      	uxtb	r2, r5
340144e6:	2101      	movs	r1, #1
340144e8:	6830      	ldr	r0, [r6, #0]
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
340144ea:	3501      	adds	r5, #1
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
340144ec:	f7f2 fd62 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
340144f0:	2d04      	cmp	r5, #4
340144f2:	f104 0404 	add.w	r4, r4, #4
340144f6:	d1f4      	bne.n	340144e2 <ReadStatHistogram+0x8>
}
340144f8:	bd70      	pop	{r4, r5, r6, pc}
340144fa:	0000      	movs	r0, r0
340144fc:	0000      	movs	r0, r0
	...

34014500 <LuminanceFromRGB>:
  }
  return stage;
}

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
34014500:	ee07 1a10 	vmov	s14, r1
34014504:	ee05 0a10 	vmov	s10, r0
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34014508:	ed9f 4b0f 	vldr	d4, [pc, #60]	@ 34014548 <LuminanceFromRGB+0x48>
3401450c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
{
34014510:	ee06 2a10 	vmov	s12, r2
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34014514:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
34014518:	ee27 7b04 	vmul.f64	d7, d7, d4
3401451c:	ed9f 4b0c 	vldr	d4, [pc, #48]	@ 34014550 <LuminanceFromRGB+0x50>
34014520:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
34014524:	eea5 7b04 	vfma.f64	d7, d5, d4
34014528:	ed9f 5b0b 	vldr	d5, [pc, #44]	@ 34014558 <LuminanceFromRGB+0x58>
3401452c:	eea6 7b05 	vfma.f64	d7, d6, d5
34014530:	eefc 7bc7 	vcvt.u32.f64	s15, d7
{
34014534:	b082      	sub	sp, #8
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34014536:	edcd 7a01 	vstr	s15, [sp, #4]
}
3401453a:	f89d 0004 	ldrb.w	r0, [sp, #4]
3401453e:	b002      	add	sp, #8
34014540:	4770      	bx	lr
34014542:	bf00      	nop
34014544:	f3af 8000 	nop.w
34014548:	39581062 	.word	0x39581062
3401454c:	3fe2c8b4 	.word	0x3fe2c8b4
34014550:	e5604189 	.word	0xe5604189
34014554:	3fd322d0 	.word	0x3fd322d0
34014558:	9fbe76c9 	.word	0x9fbe76c9
3401455c:	3fbd2f1a 	.word	0x3fbd2f1a

34014560 <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
34014560:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34014562:	4604      	mov	r4, r0
{
34014564:	b087      	sub	sp, #28
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014566:	2800      	cmp	r0, #0
34014568:	d037      	beq.n	340145da <ISP_SVC_ISP_SetDemosaicing+0x7a>
3401456a:	2900      	cmp	r1, #0
3401456c:	d035      	beq.n	340145da <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3401456e:	788f      	ldrb	r7, [r1, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014570:	2f07      	cmp	r7, #7
34014572:	d832      	bhi.n	340145da <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34014574:	78ce      	ldrb	r6, [r1, #3]
34014576:	2e07      	cmp	r6, #7
34014578:	d82f      	bhi.n	340145da <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
3401457a:	790d      	ldrb	r5, [r1, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3401457c:	2d07      	cmp	r5, #7
3401457e:	d82c      	bhi.n	340145da <ISP_SVC_ISP_SetDemosaicing+0x7a>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34014580:	7948      	ldrb	r0, [r1, #5]
34014582:	2807      	cmp	r0, #7
34014584:	d829      	bhi.n	340145da <ISP_SVC_ISP_SetDemosaicing+0x7a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
34014586:	780b      	ldrb	r3, [r1, #0]
34014588:	b113      	cbz	r3, 34014590 <ISP_SVC_ISP_SetDemosaicing+0x30>
3401458a:	784a      	ldrb	r2, [r1, #1]
3401458c:	2a04      	cmp	r2, #4
3401458e:	d107      	bne.n	340145a0 <ISP_SVC_ISP_SetDemosaicing+0x40>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
34014590:	2101      	movs	r1, #1
34014592:	6820      	ldr	r0, [r4, #0]
34014594:	f7f1 ff3a 	bl	3400640c <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014598:	b100      	cbz	r0, 3401459c <ISP_SVC_ISP_SetDemosaicing+0x3c>
  {
    return ISP_ERR_DEMOSAICING_HAL;
3401459a:	200b      	movs	r0, #11
  }

  return ISP_OK;
}
3401459c:	b007      	add	sp, #28
3401459e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(pConfig->type)
340145a0:	2a02      	cmp	r2, #2
340145a2:	d018      	beq.n	340145d6 <ISP_SVC_ISP_SetDemosaicing+0x76>
340145a4:	1e51      	subs	r1, r2, #1
340145a6:	424b      	negs	r3, r1
340145a8:	414b      	adcs	r3, r1
340145aa:	2a03      	cmp	r2, #3
340145ac:	ea4f 0343 	mov.w	r3, r3, lsl #1
340145b0:	bf08      	it	eq
340145b2:	2306      	moveq	r3, #6
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
340145b4:	9005      	str	r0, [sp, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
340145b6:	2101      	movs	r1, #1
340145b8:	6820      	ldr	r0, [r4, #0]
340145ba:	aa01      	add	r2, sp, #4
    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
340145bc:	e9cd 3703 	strd	r3, r7, [sp, #12]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
340145c0:	e9cd 6501 	strd	r6, r5, [sp, #4]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
340145c4:	f7f1 feb0 	bl	34006328 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
    if (halStatus == HAL_OK)
340145c8:	2800      	cmp	r0, #0
340145ca:	d1e6      	bne.n	3401459a <ISP_SVC_ISP_SetDemosaicing+0x3a>
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
340145cc:	2101      	movs	r1, #1
340145ce:	6820      	ldr	r0, [r4, #0]
340145d0:	f7f1 ff04 	bl	340063dc <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
340145d4:	e7e0      	b.n	34014598 <ISP_SVC_ISP_SetDemosaicing+0x38>
    switch(pConfig->type)
340145d6:	2304      	movs	r3, #4
340145d8:	e7ec      	b.n	340145b4 <ISP_SVC_ISP_SetDemosaicing+0x54>
    return ISP_ERR_DEMOSAICING_EINVAL;
340145da:	200a      	movs	r0, #10
340145dc:	e7de      	b.n	3401459c <ISP_SVC_ISP_SetDemosaicing+0x3c>

340145de <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
340145de:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340145e0:	4604      	mov	r4, r0
340145e2:	b1d8      	cbz	r0, 3401461c <ISP_SVC_ISP_SetStatRemoval+0x3e>
340145e4:	b1d1      	cbz	r1, 3401461c <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
340145e6:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340145e8:	2a07      	cmp	r2, #7
340145ea:	d817      	bhi.n	3401461c <ISP_SVC_ISP_SetStatRemoval+0x3e>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
340145ec:	f640 70fe 	movw	r0, #4094	@ 0xffe
340145f0:	688b      	ldr	r3, [r1, #8]
340145f2:	4283      	cmp	r3, r0
340145f4:	d812      	bhi.n	3401461c <ISP_SVC_ISP_SetStatRemoval+0x3e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
  }

  if (pConfig->enable == 0)
340145f6:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
340145f8:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enable == 0)
340145fa:	b921      	cbnz	r1, 34014606 <ISP_SVC_ISP_SetStatRemoval+0x28>
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
340145fc:	2101      	movs	r1, #1
340145fe:	f7f1 ff59 	bl	340064b4 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014602:	b128      	cbz	r0, 34014610 <ISP_SVC_ISP_SetStatRemoval+0x32>
34014604:	e003      	b.n	3401460e <ISP_SVC_ISP_SetStatRemoval+0x30>
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
34014606:	2101      	movs	r1, #1
34014608:	f7f1 ff18 	bl	3400643c <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
    if (halStatus == HAL_OK)
3401460c:	b108      	cbz	r0, 34014612 <ISP_SVC_ISP_SetStatRemoval+0x34>
  {
    return ISP_ERR_STATREMOVAL_HAL;
3401460e:	2015      	movs	r0, #21
  }

  return ISP_OK;
}
34014610:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34014612:	2101      	movs	r1, #1
34014614:	6820      	ldr	r0, [r4, #0]
34014616:	f7f1 ff3f 	bl	34006498 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
3401461a:	e7f2      	b.n	34014602 <ISP_SVC_ISP_SetStatRemoval+0x24>
    return ISP_ERR_STATREMOVAL_EINVAL;
3401461c:	2014      	movs	r0, #20
3401461e:	e7f7      	b.n	34014610 <ISP_SVC_ISP_SetStatRemoval+0x32>

34014620 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
34014620:	b537      	push	{r0, r1, r2, r4, r5, lr}
34014622:	460c      	mov	r4, r1
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014624:	4605      	mov	r5, r0
34014626:	b350      	cbz	r0, 3401467e <ISP_SVC_ISP_SetDecimation+0x5e>
34014628:	b349      	cbz	r1, 3401467e <ISP_SVC_ISP_SetDecimation+0x5e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
  }

  switch (pConfig->factor)
3401462a:	780b      	ldrb	r3, [r1, #0]
3401462c:	3b01      	subs	r3, #1
3401462e:	2b07      	cmp	r3, #7
34014630:	d825      	bhi.n	3401467e <ISP_SVC_ISP_SetDecimation+0x5e>
34014632:	e8df f003 	tbb	[pc, r3]
34014636:	0417      	.short	0x0417
34014638:	24241124 	.word	0x24241124
3401463c:	1424      	.short	0x1424
3401463e:	2308      	movs	r3, #8
34014640:	2202      	movs	r2, #2
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
34014642:	e9cd 3200 	strd	r3, r2, [sp]

  default:
    return ISP_ERR_DECIMATION_EINVAL;
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
34014646:	2101      	movs	r1, #1
34014648:	466a      	mov	r2, sp
3401464a:	6828      	ldr	r0, [r5, #0]
3401464c:	f7f1 fc64 	bl	34005f18 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
34014650:	b158      	cbz	r0, 3401466a <ISP_SVC_ISP_SetDecimation+0x4a>
  {
    return ISP_ERR_DECIMATION_HAL;
34014652:	201f      	movs	r0, #31

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;

  return ret;
}
34014654:	b003      	add	sp, #12
34014656:	bd30      	pop	{r4, r5, pc}
    break;
34014658:	2310      	movs	r3, #16
3401465a:	2204      	movs	r2, #4
3401465c:	e7f1      	b.n	34014642 <ISP_SVC_ISP_SetDecimation+0x22>
    break;
3401465e:	2318      	movs	r3, #24
34014660:	2206      	movs	r2, #6
34014662:	e7ee      	b.n	34014642 <ISP_SVC_ISP_SetDecimation+0x22>
  switch (pConfig->factor)
34014664:	2300      	movs	r3, #0
34014666:	461a      	mov	r2, r3
34014668:	e7eb      	b.n	34014642 <ISP_SVC_ISP_SetDecimation+0x22>
  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3401466a:	2101      	movs	r1, #1
3401466c:	6828      	ldr	r0, [r5, #0]
3401466e:	f7f1 fc91 	bl	34005f94 <HAL_DCMIPP_PIPE_EnableISPDecimation>
34014672:	2800      	cmp	r0, #0
34014674:	d1ed      	bne.n	34014652 <ISP_SVC_ISP_SetDecimation+0x32>
  ISP_DecimationValue.factor = pConfig->factor;
34014676:	7822      	ldrb	r2, [r4, #0]
34014678:	4b02      	ldr	r3, [pc, #8]	@ (34014684 <ISP_SVC_ISP_SetDecimation+0x64>)
3401467a:	701a      	strb	r2, [r3, #0]
  return ret;
3401467c:	e7ea      	b.n	34014654 <ISP_SVC_ISP_SetDecimation+0x34>
  switch (pConfig->factor)
3401467e:	201e      	movs	r0, #30
34014680:	e7e8      	b.n	34014654 <ISP_SVC_ISP_SetDecimation+0x34>
34014682:	bf00      	nop
34014684:	3403eed6 	.word	0x3403eed6

34014688 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
34014688:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401468c:	4605      	mov	r5, r0
{
3401468e:	b085      	sub	sp, #20
  if ((hIsp == NULL) || (pConfig == NULL) ||
34014690:	2800      	cmp	r0, #0
34014692:	d071      	beq.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
34014694:	2900      	cmp	r1, #0
34014696:	d06f      	beq.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34014698:	684b      	ldr	r3, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401469a:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401469e:	d86b      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146a0:	f8d1 9008 	ldr.w	r9, [r1, #8]
340146a4:	f5b9 7fc5 	cmp.w	r9, #394	@ 0x18a
340146a8:	d866      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146aa:	f8d1 800c 	ldr.w	r8, [r1, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146ae:	f5b8 7fc5 	cmp.w	r8, #394	@ 0x18a
340146b2:	d861      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146b4:	f8d1 e010 	ldr.w	lr, [r1, #16]
340146b8:	f5be 7fc5 	cmp.w	lr, #394	@ 0x18a
340146bc:	d85c      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146be:	f8d1 c014 	ldr.w	ip, [r1, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146c2:	f5bc 7fc5 	cmp.w	ip, #394	@ 0x18a
340146c6:	d857      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146c8:	698f      	ldr	r7, [r1, #24]
340146ca:	f5b7 7fc5 	cmp.w	r7, #394	@ 0x18a
340146ce:	d853      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146d0:	69ce      	ldr	r6, [r1, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146d2:	f5b6 7fc5 	cmp.w	r6, #394	@ 0x18a
340146d6:	d84f      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146d8:	6a0c      	ldr	r4, [r1, #32]
340146da:	f5b4 7fc5 	cmp.w	r4, #394	@ 0x18a
340146de:	d84b      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
340146e0:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
340146e2:	f5b2 7fc5 	cmp.w	r2, #394	@ 0x18a
340146e6:	d847      	bhi.n	34014778 <ISP_SVC_ISP_SetContrast+0xf0>
  {
    return ISP_ERR_CONTRAST_EINVAL;
  }

  if (pConfig->enable == 0)
340146e8:	7809      	ldrb	r1, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
340146ea:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
340146ec:	b921      	cbnz	r1, 340146f8 <ISP_SVC_ISP_SetContrast+0x70>
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
340146ee:	2101      	movs	r1, #1
340146f0:	f7f2 fb78 	bl	34006de4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
340146f4:	b3c0      	cbz	r0, 34014768 <ISP_SVC_ISP_SetContrast+0xe0>
340146f6:	e036      	b.n	34014766 <ISP_SVC_ISP_SetContrast+0xde>
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
340146f8:	0119      	lsls	r1, r3, #4
340146fa:	2364      	movs	r3, #100	@ 0x64
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
340146fc:	0112      	lsls	r2, r2, #4
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
340146fe:	fbb1 f1f3 	udiv	r1, r1, r3
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
34014702:	fbb2 f2f3 	udiv	r2, r2, r3
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
34014706:	ea4f 1909 	mov.w	r9, r9, lsl #4
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
3401470a:	ea4f 1808 	mov.w	r8, r8, lsl #4
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3401470e:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
34014712:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
34014716:	013f      	lsls	r7, r7, #4
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
34014718:	0136      	lsls	r6, r6, #4
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3401471a:	0124      	lsls	r4, r4, #4
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3401471c:	fbb9 f9f3 	udiv	r9, r9, r3
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
34014720:	fbb8 f8f3 	udiv	r8, r8, r3
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
34014724:	fbbe fef3 	udiv	lr, lr, r3
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
34014728:	fbbc fcf3 	udiv	ip, ip, r3
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3401472c:	fbb7 f7f3 	udiv	r7, r7, r3
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
34014730:	fbb6 f6f3 	udiv	r6, r6, r3
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
34014734:	fbb4 f4f3 	udiv	r4, r4, r3
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
34014738:	f88d 1004 	strb.w	r1, [sp, #4]
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
3401473c:	f88d 200c 	strb.w	r2, [sp, #12]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
34014740:	2101      	movs	r1, #1
34014742:	aa01      	add	r2, sp, #4
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
34014744:	f88d 9005 	strb.w	r9, [sp, #5]
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
34014748:	f88d 8006 	strb.w	r8, [sp, #6]
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3401474c:	f88d e007 	strb.w	lr, [sp, #7]
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
34014750:	f88d c008 	strb.w	ip, [sp, #8]
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
34014754:	f88d 7009 	strb.w	r7, [sp, #9]
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
34014758:	f88d 600a 	strb.w	r6, [sp, #10]
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3401475c:	f88d 400b 	strb.w	r4, [sp, #11]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
34014760:	f7f2 faa6 	bl	34006cb0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
    if (halStatus == HAL_OK)
34014764:	b118      	cbz	r0, 3401476e <ISP_SVC_ISP_SetContrast+0xe6>
  {
    return ISP_ERR_CONTRAST_HAL;
34014766:	2029      	movs	r0, #41	@ 0x29
  }

  return ISP_OK;
}
34014768:	b005      	add	sp, #20
3401476a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3401476e:	2101      	movs	r1, #1
34014770:	6828      	ldr	r0, [r5, #0]
34014772:	f7f2 fb1f 	bl	34006db4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
34014776:	e7bd      	b.n	340146f4 <ISP_SVC_ISP_SetContrast+0x6c>
    return ISP_ERR_CONTRAST_EINVAL;
34014778:	2028      	movs	r0, #40	@ 0x28
3401477a:	e7f5      	b.n	34014768 <ISP_SVC_ISP_SetContrast+0xe0>

3401477c <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
3401477c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401477e:	4604      	mov	r4, r0
34014780:	2800      	cmp	r0, #0
34014782:	d03a      	beq.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
34014784:	2900      	cmp	r1, #0
34014786:	d038      	beq.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
34014788:	f640 72fe 	movw	r2, #4094	@ 0xffe
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3401478c:	680d      	ldr	r5, [r1, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401478e:	4295      	cmp	r5, r2
34014790:	d833      	bhi.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
34014792:	6848      	ldr	r0, [r1, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
34014794:	4290      	cmp	r0, r2
34014796:	d830      	bhi.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
34014798:	688b      	ldr	r3, [r1, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3401479a:	4293      	cmp	r3, r2
3401479c:	d82d      	bhi.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3401479e:	68ca      	ldr	r2, [r1, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
340147a0:	f640 71fa 	movw	r1, #4090	@ 0xffa
340147a4:	1f16      	subs	r6, r2, #4
340147a6:	428e      	cmp	r6, r1
340147a8:	d827      	bhi.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
340147aa:	2b03      	cmp	r3, #3
340147ac:	d925      	bls.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
340147ae:	6f26      	ldr	r6, [r4, #112]	@ 0x70
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
340147b0:	18e9      	adds	r1, r5, r3
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
340147b2:	42b1      	cmp	r1, r6
340147b4:	d821      	bhi.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
340147b6:	6f66      	ldr	r6, [r4, #116]	@ 0x74
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
340147b8:	1881      	adds	r1, r0, r2
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
340147ba:	42b1      	cmp	r1, r6
340147bc:	d81d      	bhi.n	340147fa <ISP_SVC_ISP_SetStatArea+0x7e>
  {
    return ISP_ERR_STATAREA_EINVAL;
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
340147be:	4910      	ldr	r1, [pc, #64]	@ (34014800 <ISP_SVC_ISP_SetStatArea+0x84>)
340147c0:	7809      	ldrb	r1, [r1, #0]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
340147c2:	fbb0 f0f1 	udiv	r0, r0, r1
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
340147c6:	fbb2 f2f1 	udiv	r2, r2, r1
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
340147ca:	fbb5 f5f1 	udiv	r5, r5, r1
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
340147ce:	fbb3 f3f1 	udiv	r3, r3, r1
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
340147d2:	9000      	str	r0, [sp, #0]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
340147d4:	9202      	str	r2, [sp, #8]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
340147d6:	2101      	movs	r1, #1
340147d8:	466a      	mov	r2, sp
340147da:	6820      	ldr	r0, [r4, #0]
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
340147dc:	9501      	str	r5, [sp, #4]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
340147de:	9303      	str	r3, [sp, #12]
  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
340147e0:	f7f2 f94c 	bl	34006a7c <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
340147e4:	b110      	cbz	r0, 340147ec <ISP_SVC_ISP_SetStatArea+0x70>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
340147e6:	2033      	movs	r0, #51	@ 0x33
  {
    return ISP_ERR_STATAREA_HAL;
  }

  return ret;
}
340147e8:	b004      	add	sp, #16
340147ea:	bd70      	pop	{r4, r5, r6, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
340147ec:	2101      	movs	r1, #1
340147ee:	6820      	ldr	r0, [r4, #0]
340147f0:	f7f2 f9ce 	bl	34006b90 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
  if (halStatus != HAL_OK)
340147f4:	2800      	cmp	r0, #0
340147f6:	d0f7      	beq.n	340147e8 <ISP_SVC_ISP_SetStatArea+0x6c>
340147f8:	e7f5      	b.n	340147e6 <ISP_SVC_ISP_SetStatArea+0x6a>
    return ISP_ERR_STATAREA_EINVAL;
340147fa:	2032      	movs	r0, #50	@ 0x32
340147fc:	e7f4      	b.n	340147e8 <ISP_SVC_ISP_SetStatArea+0x6c>
340147fe:	bf00      	nop
34014800:	3403eed6 	.word	0x3403eed6

34014804 <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
34014804:	b510      	push	{r4, lr}
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
34014806:	4604      	mov	r4, r0
34014808:	b1a8      	cbz	r0, 34014836 <ISP_SVC_ISP_SetBadPixel+0x32>
3401480a:	b1a1      	cbz	r1, 34014836 <ISP_SVC_ISP_SetBadPixel+0x32>
3401480c:	784a      	ldrb	r2, [r1, #1]
3401480e:	2a07      	cmp	r2, #7
34014810:	d811      	bhi.n	34014836 <ISP_SVC_ISP_SetBadPixel+0x32>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  if (pConfig->enable == 0)
34014812:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014814:	6800      	ldr	r0, [r0, #0]
34014816:	2101      	movs	r1, #1
  if (pConfig->enable == 0)
34014818:	b91b      	cbnz	r3, 34014822 <ISP_SVC_ISP_SetBadPixel+0x1e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401481a:	f7f1 fe99 	bl	34006550 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
  }

  if (halStatus != HAL_OK)
3401481e:	b120      	cbz	r0, 3401482a <ISP_SVC_ISP_SetBadPixel+0x26>
34014820:	e002      	b.n	34014828 <ISP_SVC_ISP_SetBadPixel+0x24>
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
34014822:	f7f1 fe55 	bl	340064d0 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
    if (halStatus != HAL_OK)
34014826:	b108      	cbz	r0, 3401482c <ISP_SVC_ISP_SetBadPixel+0x28>
      return ISP_ERR_BADPIXEL_HAL;
34014828:	203d      	movs	r0, #61	@ 0x3d
  {
    return ISP_ERR_BADPIXEL_HAL;
  }

  return ISP_OK;
}
3401482a:	bd10      	pop	{r4, pc}
    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401482c:	2101      	movs	r1, #1
3401482e:	6820      	ldr	r0, [r4, #0]
34014830:	f7f1 fe76 	bl	34006520 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
34014834:	e7f3      	b.n	3401481e <ISP_SVC_ISP_SetBadPixel+0x1a>
    return ISP_ERR_BADPIXEL_EINVAL;
34014836:	203c      	movs	r0, #60	@ 0x3c
34014838:	e7f7      	b.n	3401482a <ISP_SVC_ISP_SetBadPixel+0x26>

3401483a <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3401483a:	b538      	push	{r3, r4, r5, lr}
3401483c:	460d      	mov	r5, r1
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401483e:	4604      	mov	r4, r0
34014840:	b198      	cbz	r0, 3401486a <ISP_SVC_ISP_GetBadPixel+0x30>
34014842:	b191      	cbz	r1, 3401486a <ISP_SVC_ISP_GetBadPixel+0x30>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
34014844:	2101      	movs	r1, #1
34014846:	6800      	ldr	r0, [r0, #0]
34014848:	f7f1 feac 	bl	340065a4 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
3401484c:	7028      	strb	r0, [r5, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
3401484e:	2101      	movs	r1, #1
34014850:	6820      	ldr	r0, [r4, #0]
34014852:	f7f1 fe95 	bl	34006580 <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
34014856:	7068      	strb	r0, [r5, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
34014858:	2101      	movs	r1, #1
3401485a:	6820      	ldr	r0, [r4, #0]
3401485c:	1d2a      	adds	r2, r5, #4
3401485e:	f7f1 fec7 	bl	340065f0 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>

  if (halStatus != HAL_OK)
  {
    return ISP_ERR_BADPIXEL_HAL;
34014862:	2800      	cmp	r0, #0
34014864:	bf18      	it	ne
34014866:	203d      	movne	r0, #61	@ 0x3d
  }

  return ISP_OK;
}
34014868:	bd38      	pop	{r3, r4, r5, pc}
    return ISP_ERR_BADPIXEL_EINVAL;
3401486a:	203c      	movs	r0, #60	@ 0x3c
3401486c:	e7fc      	b.n	34014868 <ISP_SVC_ISP_GetBadPixel+0x2e>

3401486e <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3401486e:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014870:	4604      	mov	r4, r0
34014872:	b1f0      	cbz	r0, 340148b2 <ISP_SVC_ISP_SetBlackLevel+0x44>
34014874:	b1e9      	cbz	r1, 340148b2 <ISP_SVC_ISP_SetBlackLevel+0x44>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
  }

  if (pConfig->enable == 0)
34014876:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
34014878:	6800      	ldr	r0, [r0, #0]
  if (pConfig->enable == 0)
3401487a:	b923      	cbnz	r3, 34014886 <ISP_SVC_ISP_SetBlackLevel+0x18>
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3401487c:	2101      	movs	r1, #1
3401487e:	f7f2 f87f 	bl	34006980 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014882:	b178      	cbz	r0, 340148a4 <ISP_SVC_ISP_SetBlackLevel+0x36>
34014884:	e00d      	b.n	340148a2 <ISP_SVC_ISP_SetBlackLevel+0x34>
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
34014886:	784b      	ldrb	r3, [r1, #1]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
34014888:	aa01      	add	r2, sp, #4
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
3401488a:	f88d 3004 	strb.w	r3, [sp, #4]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
3401488e:	788b      	ldrb	r3, [r1, #2]
34014890:	f88d 3005 	strb.w	r3, [sp, #5]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
34014894:	78cb      	ldrb	r3, [r1, #3]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
34014896:	2101      	movs	r1, #1
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
34014898:	f88d 3006 	strb.w	r3, [sp, #6]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3401489c:	f7f2 f836 	bl	3400690c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
    if (halStatus == HAL_OK)
340148a0:	b110      	cbz	r0, 340148a8 <ISP_SVC_ISP_SetBlackLevel+0x3a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
340148a2:	2047      	movs	r0, #71	@ 0x47
  }

  return ISP_OK;
}
340148a4:	b002      	add	sp, #8
340148a6:	bd10      	pop	{r4, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
340148a8:	2101      	movs	r1, #1
340148aa:	6820      	ldr	r0, [r4, #0]
340148ac:	f7f2 f850 	bl	34006950 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
340148b0:	e7e7      	b.n	34014882 <ISP_SVC_ISP_SetBlackLevel+0x14>
    return ISP_ERR_BLACKLEVEL_EINVAL;
340148b2:	2046      	movs	r0, #70	@ 0x46
340148b4:	e7f6      	b.n	340148a4 <ISP_SVC_ISP_SetBlackLevel+0x36>
	...

340148b8 <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
340148b8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
340148bc:	4605      	mov	r5, r0
340148be:	2800      	cmp	r0, #0
340148c0:	f000 808b 	beq.w	340149da <ISP_SVC_ISP_SetGain+0x122>
340148c4:	2900      	cmp	r1, #0
340148c6:	f000 8088 	beq.w	340149da <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
340148ca:	684a      	ldr	r2, [r1, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
340148cc:	4b46      	ldr	r3, [pc, #280]	@ (340149e8 <ISP_SVC_ISP_SetGain+0x130>)
340148ce:	429a      	cmp	r2, r3
340148d0:	f200 8083 	bhi.w	340149da <ISP_SVC_ISP_SetGain+0x122>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
340148d4:	f8d1 8008 	ldr.w	r8, [r1, #8]
340148d8:	4598      	cmp	r8, r3
340148da:	d87e      	bhi.n	340149da <ISP_SVC_ISP_SetGain+0x122>
340148dc:	68cf      	ldr	r7, [r1, #12]
340148de:	429f      	cmp	r7, r3
340148e0:	d87b      	bhi.n	340149da <ISP_SVC_ISP_SetGain+0x122>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
  }

  if (pConfig->enable == 0)
340148e2:	780b      	ldrb	r3, [r1, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
340148e4:	6806      	ldr	r6, [r0, #0]
  if (pConfig->enable == 0)
340148e6:	b933      	cbnz	r3, 340148f6 <ISP_SVC_ISP_SetGain+0x3e>
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
340148e8:	2101      	movs	r1, #1
340148ea:	4630      	mov	r0, r6
340148ec:	f7f2 f9c8 	bl	34006c80 <HAL_DCMIPP_PIPE_DisableISPExposure>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
340148f0:	2800      	cmp	r0, #0
340148f2:	d05b      	beq.n	340149ac <ISP_SVC_ISP_SetGain+0xf4>
340148f4:	e059      	b.n	340149aa <ISP_SVC_ISP_SetGain+0xf2>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
340148f6:	2400      	movs	r4, #0
340148f8:	4610      	mov	r0, r2
340148fa:	a339      	add	r3, pc, #228	@ (adr r3, 340149e0 <ISP_SVC_ISP_SetGain+0x128>)
340148fc:	e9d3 2300 	ldrd	r2, r3, [r3]
34014900:	4621      	mov	r1, r4
34014902:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
34014906:	f7ec fe69 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
3401490a:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401490c:	4682      	mov	sl, r0
3401490e:	468b      	mov	fp, r1
  while (Val >= 256)
34014910:	4622      	mov	r2, r4
34014912:	f5ba 7f80 	cmp.w	sl, #256	@ 0x100
34014916:	f17b 0000 	sbcs.w	r0, fp, #0
3401491a:	f103 0101 	add.w	r1, r3, #1
3401491e:	d248      	bcs.n	340149b2 <ISP_SVC_ISP_SetGain+0xfa>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014920:	2400      	movs	r4, #0
  *pShift = 0;
34014922:	2a00      	cmp	r2, #0
34014924:	bf08      	it	eq
34014926:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014928:	4640      	mov	r0, r8
3401492a:	4621      	mov	r1, r4
  *pShift = 0;
3401492c:	f88d 3000 	strb.w	r3, [sp]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014930:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
34014934:	a32a      	add	r3, pc, #168	@ (adr r3, 340149e0 <ISP_SVC_ISP_SetGain+0x128>)
34014936:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = Val;
3401493a:	f88d a001 	strb.w	sl, [sp, #1]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401493e:	f7ec fe4d 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
34014942:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014944:	4680      	mov	r8, r0
34014946:	4689      	mov	r9, r1
  while (Val >= 256)
34014948:	4622      	mov	r2, r4
3401494a:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
3401494e:	f179 0000 	sbcs.w	r0, r9, #0
34014952:	f103 0101 	add.w	r1, r3, #1
34014956:	d231      	bcs.n	340149bc <ISP_SVC_ISP_SetGain+0x104>
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014958:	2400      	movs	r4, #0
  *pShift = 0;
3401495a:	2a00      	cmp	r2, #0
3401495c:	bf08      	it	eq
3401495e:	4613      	moveq	r3, r2
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014960:	4638      	mov	r0, r7
34014962:	4621      	mov	r1, r4
  *pShift = 0;
34014964:	f88d 3002 	strb.w	r3, [sp, #2]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014968:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3401496c:	a31c      	add	r3, pc, #112	@ (adr r3, 340149e0 <ISP_SVC_ISP_SetGain+0x128>)
3401496e:	e9d3 2300 	ldrd	r2, r3, [r3]
  *pMultiplier = Val;
34014972:	f88d 8003 	strb.w	r8, [sp, #3]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34014976:	f7ec fe31 	bl	340015dc <__aeabi_uldivmod>
  while (Val >= 256)
3401497a:	4623      	mov	r3, r4
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401497c:	4680      	mov	r8, r0
3401497e:	4689      	mov	r9, r1
  while (Val >= 256)
34014980:	4622      	mov	r2, r4
34014982:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
34014986:	f179 0000 	sbcs.w	r0, r9, #0
3401498a:	f103 0101 	add.w	r1, r3, #1
3401498e:	d21a      	bcs.n	340149c6 <ISP_SVC_ISP_SetGain+0x10e>
  *pShift = 0;
34014990:	2a00      	cmp	r2, #0
34014992:	bf08      	it	eq
34014994:	4613      	moveq	r3, r2
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
34014996:	2101      	movs	r1, #1
34014998:	466a      	mov	r2, sp
3401499a:	4630      	mov	r0, r6
  *pShift = 0;
3401499c:	f88d 3004 	strb.w	r3, [sp, #4]
  *pMultiplier = Val;
340149a0:	f88d 8005 	strb.w	r8, [sp, #5]
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
340149a4:	f7f2 f90c 	bl	34006bc0 <HAL_DCMIPP_PIPE_SetISPExposureConfig>
    if (halStatus == HAL_OK)
340149a8:	b190      	cbz	r0, 340149d0 <ISP_SVC_ISP_SetGain+0x118>
  {
    return ISP_ERR_ISPGAIN_HAL;
340149aa:	2051      	movs	r0, #81	@ 0x51
  }

  return ISP_OK;
}
340149ac:	b003      	add	sp, #12
340149ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Val /= 2;
340149b2:	ea5a 0b5f 	orrs.w	fp, sl, pc, lsr #1
340149b6:	460b      	mov	r3, r1
340149b8:	2201      	movs	r2, #1
340149ba:	e7aa      	b.n	34014912 <ISP_SVC_ISP_SetGain+0x5a>
340149bc:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
340149c0:	460b      	mov	r3, r1
340149c2:	2201      	movs	r2, #1
340149c4:	e7c1      	b.n	3401494a <ISP_SVC_ISP_SetGain+0x92>
340149c6:	ea58 095f 	orrs.w	r9, r8, pc, lsr #1
340149ca:	460b      	mov	r3, r1
340149cc:	2201      	movs	r2, #1
340149ce:	e7d8      	b.n	34014982 <ISP_SVC_ISP_SetGain+0xca>
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
340149d0:	2101      	movs	r1, #1
340149d2:	6828      	ldr	r0, [r5, #0]
340149d4:	f7f2 f93c 	bl	34006c50 <HAL_DCMIPP_PIPE_EnableISPExposure>
340149d8:	e78a      	b.n	340148f0 <ISP_SVC_ISP_SetGain+0x38>
    return ISP_ERR_ISPGAIN_EINVAL;
340149da:	2050      	movs	r0, #80	@ 0x50
340149dc:	e7e6      	b.n	340149ac <ISP_SVC_ISP_SetGain+0xf4>
340149de:	bf00      	nop
340149e0:	05f5e100 	.word	0x05f5e100
340149e4:	00000000 	.word	0x00000000
340149e8:	5f5e1000 	.word	0x5f5e1000

340149ec <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
340149ec:	b570      	push	{r4, r5, r6, lr}
340149ee:	4605      	mov	r5, r0
340149f0:	b088      	sub	sp, #32
340149f2:	460c      	mov	r4, r1
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
340149f4:	221a      	movs	r2, #26
340149f6:	2100      	movs	r1, #0
340149f8:	a801      	add	r0, sp, #4
340149fa:	f004 f933 	bl	34018c64 <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
340149fe:	b16d      	cbz	r5, 34014a1c <ISP_SVC_ISP_SetColorConv+0x30>
34014a00:	b164      	cbz	r4, 34014a1c <ISP_SVC_ISP_SetColorConv+0x30>
34014a02:	4623      	mov	r3, r4

  for (i = 0; i < 3; i++)
  {
    for (j = 0; j < 3; j++)
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
34014a04:	483a      	ldr	r0, [pc, #232]	@ (34014af0 <ISP_SVC_ISP_SetColorConv+0x104>)
34014a06:	4a3b      	ldr	r2, [pc, #236]	@ (34014af4 <ISP_SVC_ISP_SetColorConv+0x108>)
34014a08:	f104 0624 	add.w	r6, r4, #36	@ 0x24
34014a0c:	6859      	ldr	r1, [r3, #4]
34014a0e:	4401      	add	r1, r0
34014a10:	4291      	cmp	r1, r2
34014a12:	d803      	bhi.n	34014a1c <ISP_SVC_ISP_SetColorConv+0x30>
34014a14:	6899      	ldr	r1, [r3, #8]
34014a16:	4401      	add	r1, r0
34014a18:	4291      	cmp	r1, r2
34014a1a:	d901      	bls.n	34014a20 <ISP_SVC_ISP_SetColorConv+0x34>
    return ISP_ERR_COLORCONV_EINVAL;
34014a1c:	205a      	movs	r0, #90	@ 0x5a
34014a1e:	e05f      	b.n	34014ae0 <ISP_SVC_ISP_SetColorConv+0xf4>
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
34014a20:	68d9      	ldr	r1, [r3, #12]
34014a22:	4401      	add	r1, r0
34014a24:	4291      	cmp	r1, r2
34014a26:	d8f9      	bhi.n	34014a1c <ISP_SVC_ISP_SetColorConv+0x30>
  for (i = 0; i < 3; i++)
34014a28:	330c      	adds	r3, #12
34014a2a:	42b3      	cmp	r3, r6
34014a2c:	d1ee      	bne.n	34014a0c <ISP_SVC_ISP_SetColorConv+0x20>
        return ISP_ERR_COLORCONV_EINVAL;
      }
    }
  }

  if (pConfig->enable == 0)
34014a2e:	7823      	ldrb	r3, [r4, #0]
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014a30:	682e      	ldr	r6, [r5, #0]
  if (pConfig->enable == 0)
34014a32:	b933      	cbnz	r3, 34014a42 <ISP_SVC_ISP_SetColorConv+0x56>
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014a34:	2101      	movs	r1, #1
34014a36:	4630      	mov	r0, r6
34014a38:	f7f1 ff50 	bl	340068dc <HAL_DCMIPP_PIPE_DisableISPColorConversion>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
    }
  }

  if (halStatus != HAL_OK)
34014a3c:	2800      	cmp	r0, #0
34014a3e:	d04f      	beq.n	34014ae0 <ISP_SVC_ISP_SetColorConv+0xf4>
34014a40:	e04d      	b.n	34014ade <ISP_SVC_ISP_SetColorConv+0xf2>
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014a42:	6860      	ldr	r0, [r4, #4]
34014a44:	2300      	movs	r3, #0
34014a46:	4a2c      	ldr	r2, [pc, #176]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014a48:	17c1      	asrs	r1, r0, #31
34014a4a:	f7ec fd77 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014a4e:	f8ad 0006 	strh.w	r0, [sp, #6]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014a52:	68a0      	ldr	r0, [r4, #8]
34014a54:	2300      	movs	r3, #0
34014a56:	4a28      	ldr	r2, [pc, #160]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014a58:	17c1      	asrs	r1, r0, #31
34014a5a:	f7ec fd6f 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014a5e:	f8ad 0008 	strh.w	r0, [sp, #8]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014a62:	68e0      	ldr	r0, [r4, #12]
34014a64:	2300      	movs	r3, #0
34014a66:	4a24      	ldr	r2, [pc, #144]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014a68:	17c1      	asrs	r1, r0, #31
34014a6a:	f7ec fd67 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014a6e:	f8ad 000a 	strh.w	r0, [sp, #10]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014a72:	6920      	ldr	r0, [r4, #16]
34014a74:	2300      	movs	r3, #0
34014a76:	4a20      	ldr	r2, [pc, #128]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014a78:	17c1      	asrs	r1, r0, #31
34014a7a:	f7ec fd5f 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014a7e:	f8ad 000e 	strh.w	r0, [sp, #14]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014a82:	6960      	ldr	r0, [r4, #20]
34014a84:	2300      	movs	r3, #0
34014a86:	4a1c      	ldr	r2, [pc, #112]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014a88:	17c1      	asrs	r1, r0, #31
34014a8a:	f7ec fd57 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014a8e:	f8ad 0010 	strh.w	r0, [sp, #16]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014a92:	69a0      	ldr	r0, [r4, #24]
34014a94:	2300      	movs	r3, #0
34014a96:	4a18      	ldr	r2, [pc, #96]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014a98:	17c1      	asrs	r1, r0, #31
34014a9a:	f7ec fd4f 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014a9e:	f8ad 0012 	strh.w	r0, [sp, #18]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014aa2:	69e0      	ldr	r0, [r4, #28]
34014aa4:	2300      	movs	r3, #0
34014aa6:	4a14      	ldr	r2, [pc, #80]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014aa8:	17c1      	asrs	r1, r0, #31
34014aaa:	f7ec fd47 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014aae:	f8ad 0016 	strh.w	r0, [sp, #22]
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014ab2:	6a20      	ldr	r0, [r4, #32]
34014ab4:	2300      	movs	r3, #0
34014ab6:	4a10      	ldr	r2, [pc, #64]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014ab8:	17c1      	asrs	r1, r0, #31
34014aba:	f7ec fd3f 	bl	3400153c <__aeabi_ldivmod>
  return (int16_t) Val;
34014abe:	f8ad 0018 	strh.w	r0, [sp, #24]
  int64_t Val = Coeff;
34014ac2:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34014ac4:	4a0c      	ldr	r2, [pc, #48]	@ (34014af8 <ISP_SVC_ISP_SetColorConv+0x10c>)
34014ac6:	2300      	movs	r3, #0
34014ac8:	17c1      	asrs	r1, r0, #31
34014aca:	f7ec fd37 	bl	3400153c <__aeabi_ldivmod>
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014ace:	2101      	movs	r1, #1
  return (int16_t) Val;
34014ad0:	f8ad 001a 	strh.w	r0, [sp, #26]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014ad4:	aa01      	add	r2, sp, #4
34014ad6:	4630      	mov	r0, r6
34014ad8:	f7f1 fda6 	bl	34006628 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
    if (halStatus == HAL_OK)
34014adc:	b110      	cbz	r0, 34014ae4 <ISP_SVC_ISP_SetColorConv+0xf8>
  {
    return ISP_ERR_COLORCONV_HAL;
34014ade:	205b      	movs	r0, #91	@ 0x5b
  }

  return ISP_OK;
}
34014ae0:	b008      	add	sp, #32
34014ae2:	bd70      	pop	{r4, r5, r6, pc}
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014ae4:	2101      	movs	r1, #1
34014ae6:	6828      	ldr	r0, [r5, #0]
34014ae8:	f7f1 fee0 	bl	340068ac <HAL_DCMIPP_PIPE_EnableISPColorConversion>
34014aec:	e7a6      	b.n	34014a3c <ISP_SVC_ISP_SetColorConv+0x50>
34014aee:	bf00      	nop
34014af0:	17c841c0 	.word	0x17c841c0
34014af4:	2f908380 	.word	0x2f908380
34014af8:	0005f5e1 	.word	0x0005f5e1

34014afc <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
34014afc:	b530      	push	{r4, r5, lr}
34014afe:	460c      	mov	r4, r1
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014b00:	4605      	mov	r5, r0
{
34014b02:	b089      	sub	sp, #36	@ 0x24
  if ((hIsp == NULL) || (pConfig == NULL))
34014b04:	2800      	cmp	r0, #0
34014b06:	d03c      	beq.n	34014b82 <ISP_SVC_ISP_GetColorConv+0x86>
34014b08:	2900      	cmp	r1, #0
34014b0a:	d03a      	beq.n	34014b82 <ISP_SVC_ISP_GetColorConv+0x86>
  {
    return ISP_ERR_COLORCONV_EINVAL;
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34014b0c:	2101      	movs	r1, #1
34014b0e:	6800      	ldr	r0, [r0, #0]
34014b10:	f7f2 fb24 	bl	3400715c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
34014b14:	7020      	strb	r0, [r4, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
34014b16:	2101      	movs	r1, #1
34014b18:	6828      	ldr	r0, [r5, #0]
34014b1a:	aa01      	add	r2, sp, #4
34014b1c:	f7f2 fa7c 	bl	34007018 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b20:	4b19      	ldr	r3, [pc, #100]	@ (34014b88 <ISP_SVC_ISP_GetColorConv+0x8c>)
  int64_t Val = Reg;
34014b22:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);

  return ISP_OK;
34014b26:	2000      	movs	r0, #0
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b28:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b2c:	6062      	str	r2, [r4, #4]
  int64_t Val = Reg;
34014b2e:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b32:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b36:	60a2      	str	r2, [r4, #8]
  int64_t Val = Reg;
34014b38:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b3c:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b40:	60e2      	str	r2, [r4, #12]
  int64_t Val = Reg;
34014b42:	f9bd 200e 	ldrsh.w	r2, [sp, #14]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b46:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b4a:	6122      	str	r2, [r4, #16]
  int64_t Val = Reg;
34014b4c:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b50:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b54:	6162      	str	r2, [r4, #20]
  int64_t Val = Reg;
34014b56:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b5a:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b5e:	61a2      	str	r2, [r4, #24]
  int64_t Val = Reg;
34014b60:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b64:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b68:	61e2      	str	r2, [r4, #28]
  int64_t Val = Reg;
34014b6a:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b6e:	fba2 2103 	umull	r2, r1, r2, r3
  return (int32_t) Val;
34014b72:	6222      	str	r2, [r4, #32]
  int64_t Val = Reg;
34014b74:	f9bd 201a 	ldrsh.w	r2, [sp, #26]
  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34014b78:	fba2 2303 	umull	r2, r3, r2, r3
  return (int32_t) Val;
34014b7c:	6262      	str	r2, [r4, #36]	@ 0x24
}
34014b7e:	b009      	add	sp, #36	@ 0x24
34014b80:	bd30      	pop	{r4, r5, pc}
    return ISP_ERR_COLORCONV_EINVAL;
34014b82:	205a      	movs	r0, #90	@ 0x5a
34014b84:	e7fb      	b.n	34014b7e <ISP_SVC_ISP_GetColorConv+0x82>
34014b86:	bf00      	nop
34014b88:	0005f5e1 	.word	0x0005f5e1

34014b8c <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
34014b8c:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014b8e:	b138      	cbz	r0, 34014ba0 <ISP_SVC_Sensor_GetInfo+0x14>
34014b90:	b131      	cbz	r1, 34014ba0 <ISP_SVC_Sensor_GetInfo+0x14>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
34014b92:	6a83      	ldr	r3, [r0, #40]	@ 0x28
34014b94:	b113      	cbz	r3, 34014b9c <ISP_SVC_Sensor_GetInfo+0x10>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
34014b96:	6840      	ldr	r0, [r0, #4]
34014b98:	4798      	blx	r3
34014b9a:	b918      	cbnz	r0, 34014ba4 <ISP_SVC_Sensor_GetInfo+0x18>
    {
      return ISP_ERR_SENSORINFO;
    }
  }

  return ISP_OK;
34014b9c:	2000      	movs	r0, #0
}
34014b9e:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORINFO_EINVAL;
34014ba0:	206e      	movs	r0, #110	@ 0x6e
34014ba2:	e7fc      	b.n	34014b9e <ISP_SVC_Sensor_GetInfo+0x12>
      return ISP_ERR_SENSORINFO;
34014ba4:	206f      	movs	r0, #111	@ 0x6f
34014ba6:	e7fa      	b.n	34014b9e <ISP_SVC_Sensor_GetInfo+0x12>

34014ba8 <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34014ba8:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014baa:	b140      	cbz	r0, 34014bbe <ISP_SVC_Sensor_SetGain+0x16>
34014bac:	b139      	cbz	r1, 34014bbe <ISP_SVC_Sensor_SetGain+0x16>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
34014bae:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
34014bb0:	b11b      	cbz	r3, 34014bba <ISP_SVC_Sensor_SetGain+0x12>
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, pConfig->gain) != 0)
34014bb2:	6809      	ldr	r1, [r1, #0]
34014bb4:	6840      	ldr	r0, [r0, #4]
34014bb6:	4798      	blx	r3
34014bb8:	b918      	cbnz	r0, 34014bc2 <ISP_SVC_Sensor_SetGain+0x1a>
    {
      return ISP_ERR_SENSORGAIN;
    }
  }

  return ISP_OK;
34014bba:	2000      	movs	r0, #0
}
34014bbc:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORGAIN_EINVAL;
34014bbe:	2078      	movs	r0, #120	@ 0x78
34014bc0:	e7fc      	b.n	34014bbc <ISP_SVC_Sensor_SetGain+0x14>
      return ISP_ERR_SENSORGAIN;
34014bc2:	2079      	movs	r0, #121	@ 0x79
34014bc4:	e7fa      	b.n	34014bbc <ISP_SVC_Sensor_SetGain+0x14>

34014bc6 <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34014bc6:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014bc8:	b138      	cbz	r0, 34014bda <ISP_SVC_Sensor_GetGain+0x14>
34014bca:	b131      	cbz	r1, 34014bda <ISP_SVC_Sensor_GetGain+0x14>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
34014bcc:	6b03      	ldr	r3, [r0, #48]	@ 0x30
34014bce:	b113      	cbz	r3, 34014bd6 <ISP_SVC_Sensor_GetGain+0x10>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
34014bd0:	6840      	ldr	r0, [r0, #4]
34014bd2:	4798      	blx	r3
34014bd4:	b918      	cbnz	r0, 34014bde <ISP_SVC_Sensor_GetGain+0x18>
    {
      return ISP_ERR_SENSORGAIN;
    }
  }

  return ISP_OK;
34014bd6:	2000      	movs	r0, #0
}
34014bd8:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSORGAIN_EINVAL;
34014bda:	2078      	movs	r0, #120	@ 0x78
34014bdc:	e7fc      	b.n	34014bd8 <ISP_SVC_Sensor_GetGain+0x12>
      return ISP_ERR_SENSORGAIN;
34014bde:	2079      	movs	r0, #121	@ 0x79
34014be0:	e7fa      	b.n	34014bd8 <ISP_SVC_Sensor_GetGain+0x12>

34014be2 <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34014be2:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014be4:	b140      	cbz	r0, 34014bf8 <ISP_SVC_Sensor_SetExposure+0x16>
34014be6:	b139      	cbz	r1, 34014bf8 <ISP_SVC_Sensor_SetExposure+0x16>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
34014be8:	6b43      	ldr	r3, [r0, #52]	@ 0x34
34014bea:	b11b      	cbz	r3, 34014bf4 <ISP_SVC_Sensor_SetExposure+0x12>
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, pConfig->exposure) != 0)
34014bec:	6809      	ldr	r1, [r1, #0]
34014bee:	6840      	ldr	r0, [r0, #4]
34014bf0:	4798      	blx	r3
34014bf2:	b918      	cbnz	r0, 34014bfc <ISP_SVC_Sensor_SetExposure+0x1a>
    {
      return ISP_ERR_SENSOREXPOSURE;
    }
  }

  return ISP_OK;
34014bf4:	2000      	movs	r0, #0
}
34014bf6:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
34014bf8:	2082      	movs	r0, #130	@ 0x82
34014bfa:	e7fc      	b.n	34014bf6 <ISP_SVC_Sensor_SetExposure+0x14>
      return ISP_ERR_SENSOREXPOSURE;
34014bfc:	2083      	movs	r0, #131	@ 0x83
34014bfe:	e7fa      	b.n	34014bf6 <ISP_SVC_Sensor_SetExposure+0x14>

34014c00 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34014c00:	b508      	push	{r3, lr}
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34014c02:	b138      	cbz	r0, 34014c14 <ISP_SVC_Sensor_GetExposure+0x14>
34014c04:	b131      	cbz	r1, 34014c14 <ISP_SVC_Sensor_GetExposure+0x14>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
34014c06:	6b83      	ldr	r3, [r0, #56]	@ 0x38
34014c08:	b113      	cbz	r3, 34014c10 <ISP_SVC_Sensor_GetExposure+0x10>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
34014c0a:	6840      	ldr	r0, [r0, #4]
34014c0c:	4798      	blx	r3
34014c0e:	b918      	cbnz	r0, 34014c18 <ISP_SVC_Sensor_GetExposure+0x18>
    {
      return ISP_ERR_SENSOREXPOSURE;
    }
  }

  return ISP_OK;
34014c10:	2000      	movs	r0, #0
}
34014c12:	bd08      	pop	{r3, pc}
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
34014c14:	2082      	movs	r0, #130	@ 0x82
34014c16:	e7fc      	b.n	34014c12 <ISP_SVC_Sensor_GetExposure+0x12>
      return ISP_ERR_SENSOREXPOSURE;
34014c18:	2083      	movs	r0, #131	@ 0x83
34014c1a:	e7fa      	b.n	34014c12 <ISP_SVC_Sensor_GetExposure+0x12>

34014c1c <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
34014c1c:	b508      	push	{r3, lr}
  /* Check handle validity */
  if (hIsp == NULL)
34014c1e:	b138      	cbz	r0, 34014c30 <ISP_SVC_Misc_IsDCMIPPReady+0x14>
  {
    return ISP_ERR_EINVAL;
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
34014c20:	6800      	ldr	r0, [r0, #0]
34014c22:	f7f2 fac1 	bl	340071a8 <HAL_DCMIPP_GetState>
  {
    return ISP_ERR_DCMIPP_STATE;
  }

  return ISP_OK;
34014c26:	2802      	cmp	r0, #2
34014c28:	bf14      	ite	ne
34014c2a:	208c      	movne	r0, #140	@ 0x8c
34014c2c:	2000      	moveq	r0, #0
}
34014c2e:	bd08      	pop	{r3, pc}
    return ISP_ERR_EINVAL;
34014c30:	2001      	movs	r0, #1
34014c32:	e7fc      	b.n	34014c2e <ISP_SVC_Misc_IsDCMIPPReady+0x12>

34014c34 <ISP_SVC_Misc_IncMainFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->MainPipe_FrameCount++;
34014c34:	6c03      	ldr	r3, [r0, #64]	@ 0x40
34014c36:	3301      	adds	r3, #1
34014c38:	6403      	str	r3, [r0, #64]	@ 0x40
}
34014c3a:	4770      	bx	lr

34014c3c <ISP_SVC_Misc_GetMainFrameId>:
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
  return hIsp->MainPipe_FrameCount;
}
34014c3c:	6c00      	ldr	r0, [r0, #64]	@ 0x40
34014c3e:	4770      	bx	lr

34014c40 <ISP_SVC_Misc_IncAncillaryFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->AncillaryPipe_FrameCount++;
34014c40:	6c43      	ldr	r3, [r0, #68]	@ 0x44
34014c42:	3301      	adds	r3, #1
34014c44:	6443      	str	r3, [r0, #68]	@ 0x44
}
34014c46:	4770      	bx	lr

34014c48 <ISP_SVC_Misc_IncDumpFrameId>:
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
  hIsp->DumpPipe_FrameCount++;
34014c48:	6c83      	ldr	r3, [r0, #72]	@ 0x48
34014c4a:	3301      	adds	r3, #1
34014c4c:	6483      	str	r3, [r0, #72]	@ 0x48
}
34014c4e:	4770      	bx	lr

34014c50 <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
34014c50:	b508      	push	{r3, lr}
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
34014c52:	b168      	cbz	r0, 34014c70 <ISP_SVC_Misc_IsGammaEnabled+0x20>
  {
    return ISP_ERR_EINVAL;
  }

  switch(Pipe)
34014c54:	2901      	cmp	r1, #1
34014c56:	d006      	beq.n	34014c66 <ISP_SVC_Misc_IsGammaEnabled+0x16>
34014c58:	2902      	cmp	r1, #2
34014c5a:	d004      	beq.n	34014c66 <ISP_SVC_Misc_IsGammaEnabled+0x16>
34014c5c:	2000      	movs	r0, #0
    break;
  default:
    ret = 0; /*  No gamma on pipe 0 */
  }

  return ret;
34014c5e:	3800      	subs	r0, #0
34014c60:	bf18      	it	ne
34014c62:	2001      	movne	r0, #1
}
34014c64:	bd08      	pop	{r3, pc}
    ret = HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
34014c66:	6800      	ldr	r0, [r0, #0]
34014c68:	f7f1 fb32 	bl	340062d0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
34014c6c:	b2c0      	uxtb	r0, r0
    break;
34014c6e:	e7f6      	b.n	34014c5e <ISP_SVC_Misc_IsGammaEnabled+0xe>
    return ISP_ERR_EINVAL;
34014c70:	2001      	movs	r0, #1
34014c72:	e7f7      	b.n	34014c64 <ISP_SVC_Misc_IsGammaEnabled+0x14>

34014c74 <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
34014c74:	b538      	push	{r3, r4, r5, lr}
34014c76:	460d      	mov	r5, r1
  if ((hIsp == NULL) || (pConfig == NULL))
34014c78:	4604      	mov	r4, r0
34014c7a:	b908      	cbnz	r0, 34014c80 <ISP_SVC_ISP_SetGamma+0xc>
  {
    return ISP_ERR_DCMIPP_GAMMA;
34014c7c:	2095      	movs	r0, #149	@ 0x95
      return ISP_ERR_DCMIPP_GAMMA;
    }
  }

  return ISP_OK;
}
34014c7e:	bd38      	pop	{r3, r4, r5, pc}
  if ((hIsp == NULL) || (pConfig == NULL))
34014c80:	2900      	cmp	r1, #0
34014c82:	d0fb      	beq.n	34014c7c <ISP_SVC_ISP_SetGamma+0x8>
  if (pConfig->enablePipe1 == 0)
34014c84:	780b      	ldrb	r3, [r1, #0]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014c86:	6800      	ldr	r0, [r0, #0]
34014c88:	2101      	movs	r1, #1
  if (pConfig->enablePipe1 == 0)
34014c8a:	b953      	cbnz	r3, 34014ca2 <ISP_SVC_ISP_SetGamma+0x2e>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014c8c:	f7f1 fafe 	bl	3400628c <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014c90:	2800      	cmp	r0, #0
34014c92:	d1f3      	bne.n	34014c7c <ISP_SVC_ISP_SetGamma+0x8>
  if (pConfig->enablePipe2 == 0)
34014c94:	786b      	ldrb	r3, [r5, #1]
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014c96:	6820      	ldr	r0, [r4, #0]
  if (pConfig->enablePipe2 == 0)
34014c98:	b133      	cbz	r3, 34014ca8 <ISP_SVC_ISP_SetGamma+0x34>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014c9a:	2102      	movs	r1, #2
34014c9c:	f7f1 fad4 	bl	34006248 <HAL_DCMIPP_PIPE_EnableGammaConversion>
34014ca0:	e005      	b.n	34014cae <ISP_SVC_ISP_SetGamma+0x3a>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34014ca2:	f7f1 fad1 	bl	34006248 <HAL_DCMIPP_PIPE_EnableGammaConversion>
34014ca6:	e7f3      	b.n	34014c90 <ISP_SVC_ISP_SetGamma+0x1c>
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014ca8:	2102      	movs	r1, #2
34014caa:	f7f1 faef 	bl	3400628c <HAL_DCMIPP_PIPE_DisableGammaConversion>
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
34014cae:	2800      	cmp	r0, #0
34014cb0:	d1e4      	bne.n	34014c7c <ISP_SVC_ISP_SetGamma+0x8>
  return ISP_OK;
34014cb2:	2000      	movs	r0, #0
34014cb4:	e7e3      	b.n	34014c7e <ISP_SVC_ISP_SetGamma+0xa>
	...

34014cb8 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
34014cb8:	b508      	push	{r3, lr}
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
34014cba:	f44f 7215 	mov.w	r2, #596	@ 0x254
34014cbe:	4802      	ldr	r0, [pc, #8]	@ (34014cc8 <ISP_SVC_IQParam_Init+0x10>)
34014cc0:	f004 fa67 	bl	34019192 <memcpy>
  return ISP_OK;
}
34014cc4:	2000      	movs	r0, #0
34014cc6:	bd08      	pop	{r3, pc}
34014cc8:	34057f08 	.word	0x34057f08

34014ccc <ISP_SVC_IQParam_Get>:
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
}
34014ccc:	4800      	ldr	r0, [pc, #0]	@ (34014cd0 <ISP_SVC_IQParam_Get+0x4>)
34014cce:	4770      	bx	lr
34014cd0:	34057f08 	.word	0x34057f08

34014cd4 <ISP_SVC_Stats_Init>:
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
34014cd4:	f44f 72b0 	mov.w	r2, #352	@ 0x160
34014cd8:	2100      	movs	r1, #0
34014cda:	4801      	ldr	r0, [pc, #4]	@ (34014ce0 <ISP_SVC_Stats_Init+0xc>)
34014cdc:	f003 bfc2 	b.w	34018c64 <memset>
34014ce0:	34057da8 	.word	0x34057da8

34014ce4 <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
34014ce4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t i, avgR, avgG, avgB, frameId;

  /* Check handle validity */
  if (hIsp == NULL)
34014ce8:	4605      	mov	r5, r0
{
34014cea:	b08d      	sub	sp, #52	@ 0x34
  if (hIsp == NULL)
34014cec:	b928      	cbnz	r0, 34014cfa <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
34014cee:	48aa      	ldr	r0, [pc, #680]	@ (34014f98 <ISP_SVC_Stats_Gather+0x2b4>)

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
  stagePrevious1 = ISP_SVC_StatEngine.stage;
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
}
34014cf0:	b00d      	add	sp, #52	@ 0x34
34014cf2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    printf("ERROR: ISP handle is NULL\r\n");
34014cf6:	f003 be49 	b.w	3401898c <puts>
  if (hIsp->hDcmipp == NULL)
34014cfa:	6800      	ldr	r0, [r0, #0]
34014cfc:	2800      	cmp	r0, #0
34014cfe:	f000 80b4 	beq.w	34014e6a <ISP_SVC_Stats_Gather+0x186>
  switch(stagePrevious2)
34014d02:	f8df 92f0 	ldr.w	r9, [pc, #752]	@ 34014ff4 <ISP_SVC_Stats_Gather+0x310>
34014d06:	4ca5      	ldr	r4, [pc, #660]	@ (34014f9c <ISP_SVC_Stats_Gather+0x2b8>)
34014d08:	f899 3000 	ldrb.w	r3, [r9]
34014d0c:	2b09      	cmp	r3, #9
34014d0e:	d836      	bhi.n	34014d7e <ISP_SVC_Stats_Gather+0x9a>
34014d10:	e8df f003 	tbb	[pc, r3]
34014d14:	46443f05 	.word	0x46443f05
34014d18:	89874a48 	.word	0x89874a48
34014d1c:	8d8b      	.short	0x8d8b
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34014d1e:	2201      	movs	r2, #1
34014d20:	466b      	mov	r3, sp
34014d22:	4611      	mov	r1, r2
34014d24:	f7f2 f946 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
34014d28:	2202      	movs	r2, #2
34014d2a:	2101      	movs	r1, #1
34014d2c:	ab01      	add	r3, sp, #4
34014d2e:	6828      	ldr	r0, [r5, #0]
34014d30:	f7f2 f940 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
34014d34:	2203      	movs	r2, #3
34014d36:	2101      	movs	r1, #1
34014d38:	ab02      	add	r3, sp, #8
34014d3a:	6828      	ldr	r0, [r5, #0]
34014d3c:	f7f2 f93a 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34014d40:	2101      	movs	r1, #1
34014d42:	2200      	movs	r2, #0
34014d44:	9b00      	ldr	r3, [sp, #0]
34014d46:	4628      	mov	r0, r5
34014d48:	f7ff fb96 	bl	34014478 <GetAvgStats>
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014d4c:	460a      	mov	r2, r1
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34014d4e:	4606      	mov	r6, r0
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014d50:	9b01      	ldr	r3, [sp, #4]
    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34014d52:	f884 007c 	strb.w	r0, [r4, #124]	@ 0x7c
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014d56:	4628      	mov	r0, r5
34014d58:	f7ff fb8e 	bl	34014478 <GetAvgStats>
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34014d5c:	2202      	movs	r2, #2
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34014d5e:	4607      	mov	r7, r0
34014d60:	f884 007d 	strb.w	r0, [r4, #125]	@ 0x7d
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34014d64:	9b02      	ldr	r3, [sp, #8]
34014d66:	4628      	mov	r0, r5
34014d68:	f7ff fb86 	bl	34014478 <GetAvgStats>
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
34014d6c:	4639      	mov	r1, r7
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34014d6e:	4602      	mov	r2, r0
34014d70:	f884 007e 	strb.w	r0, [r4, #126]	@ 0x7e
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
34014d74:	4630      	mov	r0, r6
34014d76:	f7ff fbc3 	bl	34014500 <LuminanceFromRGB>
34014d7a:	f884 007f 	strb.w	r0, [r4, #127]	@ 0x7f
  switch(ISP_SVC_StatEngine.stage)
34014d7e:	7823      	ldrb	r3, [r4, #0]
34014d80:	2b09      	cmp	r3, #9
34014d82:	d863      	bhi.n	34014e4c <ISP_SVC_Stats_Gather+0x168>
34014d84:	e8df f003 	tbb	[pc, r3]
34014d88:	86847f74 	.word	0x86847f74
34014d8c:	8c8a5588 	.word	0x8c8a5588
34014d90:	908e      	.short	0x908e
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
34014d92:	4983      	ldr	r1, [pc, #524]	@ (34014fa0 <ISP_SVC_Stats_Gather+0x2bc>)
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
34014d94:	4628      	mov	r0, r5
34014d96:	f7ff fba0 	bl	340144da <ReadStatHistogram>
    break;
34014d9a:	e7f0      	b.n	34014d7e <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
34014d9c:	4981      	ldr	r1, [pc, #516]	@ (34014fa4 <ISP_SVC_Stats_Gather+0x2c0>)
34014d9e:	e7f9      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
34014da0:	4981      	ldr	r1, [pc, #516]	@ (34014fa8 <ISP_SVC_Stats_Gather+0x2c4>)
34014da2:	e7f7      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
34014da4:	4981      	ldr	r1, [pc, #516]	@ (34014fac <ISP_SVC_Stats_Gather+0x2c8>)
34014da6:	e7f5      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34014da8:	2201      	movs	r2, #1
34014daa:	466b      	mov	r3, sp
34014dac:	4611      	mov	r1, r2
34014dae:	f7f2 f901 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
34014db2:	2202      	movs	r2, #2
34014db4:	2101      	movs	r1, #1
34014db6:	ab01      	add	r3, sp, #4
34014db8:	6828      	ldr	r0, [r5, #0]
34014dba:	f7f2 f8fb 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
34014dbe:	2203      	movs	r2, #3
34014dc0:	2101      	movs	r1, #1
34014dc2:	ab02      	add	r3, sp, #8
34014dc4:	6828      	ldr	r0, [r5, #0]
34014dc6:	f7f2 f8f5 	bl	34006fb4 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34014dca:	2102      	movs	r1, #2
34014dcc:	2200      	movs	r2, #0
34014dce:	9b00      	ldr	r3, [sp, #0]
34014dd0:	4628      	mov	r0, r5
34014dd2:	f7ff fb51 	bl	34014478 <GetAvgStats>
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34014dd6:	2201      	movs	r2, #1
34014dd8:	9b01      	ldr	r3, [sp, #4]
    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34014dda:	f884 00b0 	strb.w	r0, [r4, #176]	@ 0xb0
34014dde:	4607      	mov	r7, r0
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34014de0:	4628      	mov	r0, r5
34014de2:	f7ff fb49 	bl	34014478 <GetAvgStats>
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34014de6:	460a      	mov	r2, r1
34014de8:	9b02      	ldr	r3, [sp, #8]
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34014dea:	f884 00b1 	strb.w	r0, [r4, #177]	@ 0xb1
34014dee:	4606      	mov	r6, r0
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34014df0:	4628      	mov	r0, r5
34014df2:	f7ff fb41 	bl	34014478 <GetAvgStats>
34014df6:	f884 00b2 	strb.w	r0, [r4, #178]	@ 0xb2
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34014dfa:	f895 306c 	ldrb.w	r3, [r5, #108]	@ 0x6c
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34014dfe:	4602      	mov	r2, r0
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34014e00:	2b04      	cmp	r3, #4
34014e02:	d002      	beq.n	34014e0a <ISP_SVC_Stats_Gather+0x126>
34014e04:	4b6a      	ldr	r3, [pc, #424]	@ (34014fb0 <ISP_SVC_Stats_Gather+0x2cc>)
34014e06:	7b1b      	ldrb	r3, [r3, #12]
34014e08:	b923      	cbnz	r3, 34014e14 <ISP_SVC_Stats_Gather+0x130>
  return r + g + b;
34014e0a:	443e      	add	r6, r7
34014e0c:	4432      	add	r2, r6
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34014e0e:	f884 20b3 	strb.w	r2, [r4, #179]	@ 0xb3
34014e12:	e7b4      	b.n	34014d7e <ISP_SVC_Stats_Gather+0x9a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34014e14:	4631      	mov	r1, r6
34014e16:	4638      	mov	r0, r7
34014e18:	f7ff fb72 	bl	34014500 <LuminanceFromRGB>
34014e1c:	f884 00b3 	strb.w	r0, [r4, #179]	@ 0xb3
34014e20:	e7ad      	b.n	34014d7e <ISP_SVC_Stats_Gather+0x9a>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
34014e22:	4964      	ldr	r1, [pc, #400]	@ (34014fb4 <ISP_SVC_Stats_Gather+0x2d0>)
34014e24:	e7b6      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
34014e26:	4964      	ldr	r1, [pc, #400]	@ (34014fb8 <ISP_SVC_Stats_Gather+0x2d4>)
34014e28:	e7b4      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
34014e2a:	4964      	ldr	r1, [pc, #400]	@ (34014fbc <ISP_SVC_Stats_Gather+0x2d8>)
34014e2c:	e7b2      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
34014e2e:	4964      	ldr	r1, [pc, #400]	@ (34014fc0 <ISP_SVC_Stats_Gather+0x2dc>)
34014e30:	e7b0      	b.n	34014d94 <ISP_SVC_Stats_Gather+0xb0>
      statConf[i].Source = avgRGBDown[i];
34014e32:	2300      	movs	r3, #0
34014e34:	2240      	movs	r2, #64	@ 0x40
34014e36:	e9cd 3203 	strd	r3, r2, [sp, #12]
34014e3a:	2250      	movs	r2, #80	@ 0x50
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34014e3c:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Source = avgRGBDown[i];
34014e40:	2260      	movs	r2, #96	@ 0x60
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014e42:	e9cd 3305 	strd	r3, r3, [sp, #20]
34014e46:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34014e48:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
{
34014e4c:	f04f 0801 	mov.w	r8, #1
34014e50:	af03      	add	r7, sp, #12
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
34014e52:	fa5f f688 	uxtb.w	r6, r8
34014e56:	463b      	mov	r3, r7
34014e58:	4632      	mov	r2, r6
34014e5a:	2101      	movs	r1, #1
34014e5c:	6828      	ldr	r0, [r5, #0]
34014e5e:	f7f1 fda7 	bl	340069b0 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
34014e62:	b318      	cbz	r0, 34014eac <ISP_SVC_Stats_Gather+0x1c8>
      printf("ERROR: can't set Statistic Extraction config\r\n");
34014e64:	4857      	ldr	r0, [pc, #348]	@ (34014fc4 <ISP_SVC_Stats_Gather+0x2e0>)
      printf("ERROR: can't enable Statistic Extraction config\r\n");
34014e66:	f003 fd91 	bl	3401898c <puts>
}
34014e6a:	b00d      	add	sp, #52	@ 0x34
34014e6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014e70:	2300      	movs	r3, #0
      statConf[i].Source = avgRGBUp[i];
34014e72:	2210      	movs	r2, #16
34014e74:	e9cd 3303 	strd	r3, r3, [sp, #12]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34014e78:	e9cd 2307 	strd	r2, r3, [sp, #28]
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014e7c:	e9cd 3305 	strd	r3, r3, [sp, #20]
      statConf[i].Source = avgRGBUp[i];
34014e80:	2220      	movs	r2, #32
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34014e82:	9309      	str	r3, [sp, #36]	@ 0x24
      statConf[i].Source = avgRGBUp[i];
34014e84:	e7e0      	b.n	34014e48 <ISP_SVC_Stats_Gather+0x164>
    SetStatConfig(statConf, &statConfUpBins_0_2);
34014e86:	4950      	ldr	r1, [pc, #320]	@ (34014fc8 <ISP_SVC_Stats_Gather+0x2e4>)
    SetStatConfig(statConf, &statConfDownBins_9_11);
34014e88:	a803      	add	r0, sp, #12
34014e8a:	f7ff fb17 	bl	340144bc <SetStatConfig>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014e8e:	e7dd      	b.n	34014e4c <ISP_SVC_Stats_Gather+0x168>
    SetStatConfig(statConf, &statConfUpBins_3_5);
34014e90:	494e      	ldr	r1, [pc, #312]	@ (34014fcc <ISP_SVC_Stats_Gather+0x2e8>)
34014e92:	e7f9      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfUpBins_6_8);
34014e94:	494e      	ldr	r1, [pc, #312]	@ (34014fd0 <ISP_SVC_Stats_Gather+0x2ec>)
34014e96:	e7f7      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfUpBins_9_11);
34014e98:	494e      	ldr	r1, [pc, #312]	@ (34014fd4 <ISP_SVC_Stats_Gather+0x2f0>)
34014e9a:	e7f5      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_0_2);
34014e9c:	494e      	ldr	r1, [pc, #312]	@ (34014fd8 <ISP_SVC_Stats_Gather+0x2f4>)
34014e9e:	e7f3      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_3_5);
34014ea0:	494e      	ldr	r1, [pc, #312]	@ (34014fdc <ISP_SVC_Stats_Gather+0x2f8>)
34014ea2:	e7f1      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_6_8);
34014ea4:	494e      	ldr	r1, [pc, #312]	@ (34014fe0 <ISP_SVC_Stats_Gather+0x2fc>)
34014ea6:	e7ef      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    SetStatConfig(statConf, &statConfDownBins_9_11);
34014ea8:	494e      	ldr	r1, [pc, #312]	@ (34014fe4 <ISP_SVC_Stats_Gather+0x300>)
34014eaa:	e7ed      	b.n	34014e88 <ISP_SVC_Stats_Gather+0x1a4>
    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
34014eac:	4632      	mov	r2, r6
34014eae:	2101      	movs	r1, #1
34014eb0:	6828      	ldr	r0, [r5, #0]
34014eb2:	f7f1 fe35 	bl	34006b20 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
34014eb6:	4606      	mov	r6, r0
34014eb8:	b108      	cbz	r0, 34014ebe <ISP_SVC_Stats_Gather+0x1da>
      printf("ERROR: can't enable Statistic Extraction config\r\n");
34014eba:	484b      	ldr	r0, [pc, #300]	@ (34014fe8 <ISP_SVC_Stats_Gather+0x304>)
34014ebc:	e7d3      	b.n	34014e66 <ISP_SVC_Stats_Gather+0x182>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34014ebe:	f108 0801 	add.w	r8, r8, #1
34014ec2:	f1b8 0f04 	cmp.w	r8, #4
34014ec6:	f107 070c 	add.w	r7, r7, #12
34014eca:	d1c2      	bne.n	34014e52 <ISP_SVC_Stats_Gather+0x16e>
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34014ecc:	f894 8158 	ldrb.w	r8, [r4, #344]	@ 0x158
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34014ed0:	f899 b000 	ldrb.w	fp, [r9]
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34014ed4:	f018 0f05 	tst.w	r8, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34014ed8:	bf0c      	ite	eq
34014eda:	2301      	moveq	r3, #1
34014edc:	2300      	movne	r3, #0
  return hIsp->MainPipe_FrameCount;
34014ede:	f8d5 a040 	ldr.w	sl, [r5, #64]	@ 0x40
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34014ee2:	f894 7159 	ldrb.w	r7, [r4, #345]	@ 0x159
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34014ee6:	455b      	cmp	r3, fp
    ongoing->upFrameIdStart = frameId;
34014ee8:	bf08      	it	eq
34014eea:	f8c4 a0e4 	streq.w	sl, [r4, #228]	@ 0xe4
      stage = ISP_STAT_CFG_DOWN_AVG;
34014eee:	f017 0f05 	tst.w	r7, #5
34014ef2:	bf0c      	ite	eq
34014ef4:	2306      	moveq	r3, #6
34014ef6:	2305      	movne	r3, #5
  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
34014ef8:	459b      	cmp	fp, r3
34014efa:	d17d      	bne.n	34014ff8 <ISP_SVC_Stats_Gather+0x314>
    ongoing->downFrameIdStart = frameId;
34014efc:	f8c4 a0ec 	str.w	sl, [r4, #236]	@ 0xec
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
34014f00:	f017 0f06 	tst.w	r7, #6
34014f04:	bf0c      	ite	eq
34014f06:	2305      	moveq	r3, #5
34014f08:	2309      	movne	r3, #9
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
34014f0a:	459b      	cmp	fp, r3
34014f0c:	d11e      	bne.n	34014f4c <ISP_SVC_Stats_Gather+0x268>
34014f0e:	f8d4 e0ec 	ldr.w	lr, [r4, #236]	@ 0xec
34014f12:	f1be 0f00 	cmp.w	lr, #0
34014f16:	d019      	beq.n	34014f4c <ISP_SVC_Stats_Gather+0x268>
    ISP_SVC_StatEngine.last.down = ongoing->down;
34014f18:	4d34      	ldr	r5, [pc, #208]	@ (34014fec <ISP_SVC_Stats_Gather+0x308>)
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
34014f1a:	e9c4 ea1d 	strd	lr, sl, [r4, #116]	@ 0x74
    ISP_SVC_StatEngine.last.down = ongoing->down;
34014f1e:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
34014f22:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014f26:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014f28:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014f2c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014f2e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34014f32:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34014f34:	4628      	mov	r0, r5
34014f36:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->down, 0, sizeof(ongoing->down));
34014f3a:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.down = ongoing->down;
34014f3c:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->down, 0, sizeof(ongoing->down));
34014f40:	2100      	movs	r1, #0
34014f42:	f003 fe8f 	bl	34018c64 <memset>
    ongoing->downFrameIdStart = 0;
34014f46:	2300      	movs	r3, #0
    ongoing->downFrameIdEnd = 0;
34014f48:	e9c4 333b 	strd	r3, r3, [r4, #236]	@ 0xec
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014f4c:	ea48 0307 	orr.w	r3, r8, r7
34014f50:	075a      	lsls	r2, r3, #29
34014f52:	d50b      	bpl.n	34014f6c <ISP_SVC_Stats_Gather+0x288>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
34014f54:	f8d4 315c 	ldr.w	r3, [r4, #348]	@ 0x15c
34014f58:	4553      	cmp	r3, sl
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014f5a:	bf3f      	itttt	cc
34014f5c:	f028 0804 	biccc.w	r8, r8, #4
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014f60:	f027 0704 	biccc.w	r7, r7, #4
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014f64:	f884 8158 	strbcc.w	r8, [r4, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34014f68:	f884 7159 	strbcc.w	r7, [r4, #345]	@ 0x159
  stagePrevious2 = stagePrevious1;
34014f6c:	4b20      	ldr	r3, [pc, #128]	@ (34014ff0 <ISP_SVC_Stats_Gather+0x30c>)
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014f6e:	f894 1158 	ldrb.w	r1, [r4, #344]	@ 0x158
  stagePrevious2 = stagePrevious1;
34014f72:	781a      	ldrb	r2, [r3, #0]
34014f74:	f889 2000 	strb.w	r2, [r9]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
34014f78:	7822      	ldrb	r2, [r4, #0]
34014f7a:	701a      	strb	r2, [r3, #0]
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014f7c:	074b      	lsls	r3, r1, #29
34014f7e:	d403      	bmi.n	34014f88 <ISP_SVC_Stats_Gather+0x2a4>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34014f80:	f894 3159 	ldrb.w	r3, [r4, #345]	@ 0x159
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34014f84:	075f      	lsls	r7, r3, #29
34014f86:	d561      	bpl.n	3401504c <ISP_SVC_Stats_Gather+0x368>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
34014f88:	1c53      	adds	r3, r2, #1
34014f8a:	b2db      	uxtb	r3, r3
34014f8c:	2a09      	cmp	r2, #9
34014f8e:	bf38      	it	cc
34014f90:	461e      	movcc	r6, r3
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
34014f92:	7026      	strb	r6, [r4, #0]
34014f94:	e769      	b.n	34014e6a <ISP_SVC_Stats_Gather+0x186>
34014f96:	bf00      	nop
34014f98:	3401d02b 	.word	0x3401d02b
34014f9c:	34057da8 	.word	0x34057da8
34014fa0:	34057e28 	.word	0x34057e28
34014fa4:	34057e34 	.word	0x34057e34
34014fa8:	34057e40 	.word	0x34057e40
34014fac:	34057e4c 	.word	0x34057e4c
34014fb0:	34057f08 	.word	0x34057f08
34014fb4:	34057e5c 	.word	0x34057e5c
34014fb8:	34057e68 	.word	0x34057e68
34014fbc:	34057e74 	.word	0x34057e74
34014fc0:	34057e80 	.word	0x34057e80
34014fc4:	3401d046 	.word	0x3401d046
34014fc8:	3403b700 	.word	0x3403b700
34014fcc:	3403b6f4 	.word	0x3403b6f4
34014fd0:	3403b6e8 	.word	0x3403b6e8
34014fd4:	3403b6dc 	.word	0x3403b6dc
34014fd8:	3403b6d0 	.word	0x3403b6d0
34014fdc:	3403b6c4 	.word	0x3403b6c4
34014fe0:	3403b6b8 	.word	0x3403b6b8
34014fe4:	3403b6ac 	.word	0x3403b6ac
34014fe8:	3401d074 	.word	0x3401d074
34014fec:	34057de0 	.word	0x34057de0
34014ff0:	3403eed4 	.word	0x3403eed4
34014ff4:	3403eed5 	.word	0x3403eed5
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34014ff8:	f018 0f06 	tst.w	r8, #6
34014ffc:	bf14      	ite	ne
34014ffe:	2301      	movne	r3, #1
34015000:	2300      	moveq	r3, #0
  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
34015002:	ebbb 0f83 	cmp.w	fp, r3, lsl #2
34015006:	f47f af7b 	bne.w	34014f00 <ISP_SVC_Stats_Gather+0x21c>
3401500a:	f8d4 e0e4 	ldr.w	lr, [r4, #228]	@ 0xe4
3401500e:	f1be 0f00 	cmp.w	lr, #0
34015012:	f43f af75 	beq.w	34014f00 <ISP_SVC_Stats_Gather+0x21c>
    ISP_SVC_StatEngine.last.up = ongoing->up;
34015016:	4d2f      	ldr	r5, [pc, #188]	@ (340150d4 <ISP_SVC_Stats_Gather+0x3f0>)
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
34015018:	e9c4 ea1b 	strd	lr, sl, [r4, #108]	@ 0x6c
    ISP_SVC_StatEngine.last.up = ongoing->up;
3401501c:	f105 0c78 	add.w	ip, r5, #120	@ 0x78
34015020:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34015024:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34015026:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
3401502a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3401502c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34015030:	c50f      	stmia	r5!, {r0, r1, r2, r3}
34015032:	4628      	mov	r0, r5
34015034:	f8dc 3000 	ldr.w	r3, [ip]
    memset(&ongoing->up, 0, sizeof(ongoing->up));
34015038:	2234      	movs	r2, #52	@ 0x34
    ISP_SVC_StatEngine.last.up = ongoing->up;
3401503a:	f840 3b48 	str.w	r3, [r0], #72
    memset(&ongoing->up, 0, sizeof(ongoing->up));
3401503e:	2100      	movs	r1, #0
34015040:	f003 fe10 	bl	34018c64 <memset>
    ongoing->upFrameIdStart = 0;
34015044:	2300      	movs	r3, #0
    ongoing->upFrameIdEnd = 0;
34015046:	e9c4 3339 	strd	r3, r3, [r4, #228]	@ 0xe4
3401504a:	e759      	b.n	34014f00 <ISP_SVC_Stats_Gather+0x21c>
  switch (current)
3401504c:	2a09      	cmp	r2, #9
3401504e:	d836      	bhi.n	340150be <ISP_SVC_Stats_Gather+0x3da>
34015050:	e8df f002 	tbb	[pc, r2]
34015054:	35353505 	.word	0x35353505
34015058:	35351d11 	.word	0x35351d11
3401505c:	2a35      	.short	0x2a35
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3401505e:	078d      	lsls	r5, r1, #30
34015060:	d434      	bmi.n	340150cc <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
34015062:	07d8      	lsls	r0, r3, #31
34015064:	d434      	bmi.n	340150d0 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34015066:	f013 0602 	ands.w	r6, r3, #2
3401506a:	d12b      	bne.n	340150c4 <ISP_SVC_Stats_Gather+0x3e0>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3401506c:	f011 0f01 	tst.w	r1, #1
34015070:	bf08      	it	eq
34015072:	2609      	moveq	r6, #9
34015074:	e78d      	b.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34015076:	07da      	lsls	r2, r3, #31
34015078:	d42a      	bmi.n	340150d0 <ISP_SVC_Stats_Gather+0x3ec>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3401507a:	f013 0602 	ands.w	r6, r3, #2
3401507e:	d121      	bne.n	340150c4 <ISP_SVC_Stats_Gather+0x3e0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34015080:	07cb      	lsls	r3, r1, #31
34015082:	d486      	bmi.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34015084:	f011 0f02 	tst.w	r1, #2
34015088:	bf18      	it	ne
3401508a:	2601      	movne	r6, #1
3401508c:	e7f0      	b.n	34015070 <ISP_SVC_Stats_Gather+0x38c>
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3401508e:	f013 0602 	ands.w	r6, r3, #2
34015092:	d117      	bne.n	340150c4 <ISP_SVC_Stats_Gather+0x3e0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34015094:	07cf      	lsls	r7, r1, #31
34015096:	f53f af7c 	bmi.w	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3401509a:	078d      	lsls	r5, r1, #30
3401509c:	d416      	bmi.n	340150cc <ISP_SVC_Stats_Gather+0x3e8>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3401509e:	f013 0f01 	tst.w	r3, #1
340150a2:	bf18      	it	ne
340150a4:	4616      	movne	r6, r2
340150a6:	e7e3      	b.n	34015070 <ISP_SVC_Stats_Gather+0x38c>
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
340150a8:	07c8      	lsls	r0, r1, #31
340150aa:	d40d      	bmi.n	340150c8 <ISP_SVC_Stats_Gather+0x3e4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
340150ac:	0789      	lsls	r1, r1, #30
340150ae:	d40d      	bmi.n	340150cc <ISP_SVC_Stats_Gather+0x3e8>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
340150b0:	07da      	lsls	r2, r3, #31
340150b2:	d40d      	bmi.n	340150d0 <ISP_SVC_Stats_Gather+0x3ec>
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
340150b4:	f013 0f02 	tst.w	r3, #2
340150b8:	bf18      	it	ne
340150ba:	2606      	movne	r6, #6
340150bc:	e7d8      	b.n	34015070 <ISP_SVC_Stats_Gather+0x38c>
    next = (ISP_SVC_StatEngineStage) (current + 1);
340150be:	3201      	adds	r2, #1
340150c0:	b2d6      	uxtb	r6, r2
    break;
340150c2:	e766      	b.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
340150c4:	2606      	movs	r6, #6
340150c6:	e764      	b.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
340150c8:	2600      	movs	r6, #0
340150ca:	e762      	b.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_UP_BINS_0_2;
340150cc:	2601      	movs	r6, #1
340150ce:	e760      	b.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
      next = ISP_STAT_CFG_DOWN_AVG;
340150d0:	2605      	movs	r6, #5
340150d2:	e75e      	b.n	34014f92 <ISP_SVC_Stats_Gather+0x2ae>
340150d4:	34057dac 	.word	0x34057dac

340150d8 <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
340150d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
340150dc:	2500      	movs	r5, #0
340150de:	4c1c      	ldr	r4, [pc, #112]	@ (34015150 <ISP_SVC_Stats_ProcessCallbacks+0x78>)
{
340150e0:	2705      	movs	r7, #5
340150e2:	4626      	mov	r6, r4
      {
        ret = retcb;
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
340150e4:	46a9      	mov	r9, r5
      *(client->pStats) = *pLastStat;
340150e6:	f104 0804 	add.w	r8, r4, #4
    if (client->callback == NULL)
340150ea:	f8d4 a0f4 	ldr.w	sl, [r4, #244]	@ 0xf4
340150ee:	f1ba 0f00 	cmp.w	sl, #0
340150f2:	d016      	beq.n	34015122 <ISP_SVC_Stats_ProcessCallbacks+0x4a>
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
340150f4:	f894 3104 	ldrb.w	r3, [r4, #260]	@ 0x104
340150f8:	2b02      	cmp	r3, #2
340150fa:	d119      	bne.n	34015130 <ISP_SVC_Stats_ProcessCallbacks+0x58>
340150fc:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
34015100:	6f73      	ldr	r3, [r6, #116]	@ 0x74
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
34015102:	429a      	cmp	r2, r3
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
34015104:	d80d      	bhi.n	34015122 <ISP_SVC_Stats_ProcessCallbacks+0x4a>
      *(client->pStats) = *pLastStat;
34015106:	2278      	movs	r2, #120	@ 0x78
34015108:	4641      	mov	r1, r8
3401510a:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3401510e:	f004 f840 	bl	34019192 <memcpy>
      retcb = client->callback(client->pAlgo);
34015112:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
34015116:	47d0      	blx	sl
      if (retcb != ISP_OK)
34015118:	2800      	cmp	r0, #0
      client->callback = NULL;
3401511a:	bf18      	it	ne
3401511c:	4605      	movne	r5, r0
3401511e:	f8c4 90f4 	str.w	r9, [r4, #244]	@ 0xf4
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34015122:	3f01      	subs	r7, #1
34015124:	f104 0414 	add.w	r4, r4, #20
34015128:	d1df      	bne.n	340150ea <ISP_SVC_Stats_ProcessCallbacks+0x12>
    }
  }

  return ret;
}
3401512a:	4628      	mov	r0, r5
3401512c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
34015130:	2b01      	cmp	r3, #1
34015132:	d103      	bne.n	3401513c <ISP_SVC_Stats_ProcessCallbacks+0x64>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
34015134:	f8d4 2100 	ldr.w	r2, [r4, #256]	@ 0x100
34015138:	6ef3      	ldr	r3, [r6, #108]	@ 0x6c
3401513a:	e7e2      	b.n	34015102 <ISP_SVC_Stats_ProcessCallbacks+0x2a>
3401513c:	2b03      	cmp	r3, #3
3401513e:	d1f0      	bne.n	34015122 <ISP_SVC_Stats_ProcessCallbacks+0x4a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
34015140:	f8d4 3100 	ldr.w	r3, [r4, #256]	@ 0x100
34015144:	6ef2      	ldr	r2, [r6, #108]	@ 0x6c
34015146:	4293      	cmp	r3, r2
34015148:	d8eb      	bhi.n	34015122 <ISP_SVC_Stats_ProcessCallbacks+0x4a>
3401514a:	6f72      	ldr	r2, [r6, #116]	@ 0x74
3401514c:	4293      	cmp	r3, r2
3401514e:	e7d9      	b.n	34015104 <ISP_SVC_Stats_ProcessCallbacks+0x2c>
34015150:	34057da8 	.word	0x34057da8

34015154 <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
34015154:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34015158:	4691      	mov	r9, r2
3401515a:	f89d c01c 	ldrb.w	ip, [sp, #28]
3401515e:	f89d 5020 	ldrb.w	r5, [sp, #32]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
34015162:	b1b0      	cbz	r0, 34015192 <ISP_SVC_Stats_GetNext+0x3e>
34015164:	b1ab      	cbz	r3, 34015192 <ISP_SVC_Stats_GetNext+0x3e>
  return hIsp->MainPipe_FrameCount;
34015166:	4e1e      	ldr	r6, [pc, #120]	@ (340151e0 <ISP_SVC_Stats_GetNext+0x8c>)
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34015168:	f04f 0e00 	mov.w	lr, #0
3401516c:	4634      	mov	r4, r6
3401516e:	f04f 0805 	mov.w	r8, #5
  return hIsp->MainPipe_FrameCount;
34015172:	6c00      	ldr	r0, [r0, #64]	@ 0x40
  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
34015174:	9f09      	ldr	r7, [sp, #36]	@ 0x24
34015176:	4407      	add	r7, r0
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
34015178:	f8d6 20f4 	ldr.w	r2, [r6, #244]	@ 0xf4
3401517c:	b15a      	cbz	r2, 34015196 <ISP_SVC_Stats_GetNext+0x42>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3401517e:	f1b8 0801 	subs.w	r8, r8, #1
34015182:	f10e 0e01 	add.w	lr, lr, #1
34015186:	f106 0614 	add.w	r6, r6, #20
3401518a:	d1f5      	bne.n	34015178 <ISP_SVC_Stats_GetNext+0x24>
  }

  if (i == ISP_SVC_STAT_MAX_CB)
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
3401518c:	20ac      	movs	r0, #172	@ 0xac
  ISP_SVC_StatEngine.client[i].location = location;
  ISP_SVC_StatEngine.client[i].type = type;
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;

  return ISP_OK;
}
3401518e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return ISP_ERR_EINVAL;
34015192:	2001      	movs	r0, #1
34015194:	e7fb      	b.n	3401518e <ISP_SVC_Stats_GetNext+0x3a>
  if (location & ISP_STAT_LOC_UP)
34015196:	f01c 0f01 	tst.w	ip, #1
3401519a:	d004      	beq.n	340151a6 <ISP_SVC_Stats_GetNext+0x52>
    ISP_SVC_StatEngine.upRequest |= type;
3401519c:	f894 6158 	ldrb.w	r6, [r4, #344]	@ 0x158
340151a0:	432e      	orrs	r6, r5
340151a2:	f884 6158 	strb.w	r6, [r4, #344]	@ 0x158
  if (location & ISP_STAT_LOC_DOWN)
340151a6:	f01c 0f02 	tst.w	ip, #2
    ISP_SVC_StatEngine.downRequest |= type;
340151aa:	bf1e      	ittt	ne
340151ac:	f894 6159 	ldrbne.w	r6, [r4, #345]	@ 0x159
340151b0:	432e      	orrne	r6, r5
340151b2:	f884 6159 	strbne.w	r6, [r4, #345]	@ 0x159
  if (type == ISP_STAT_TYPE_ALL_TMP)
340151b6:	2d04      	cmp	r5, #4
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
340151b8:	bf04      	itt	eq
340151ba:	301e      	addeq	r0, #30
340151bc:	f8c4 015c 	streq.w	r0, [r4, #348]	@ 0x15c
  ISP_SVC_StatEngine.client[i].callback = callback;
340151c0:	2014      	movs	r0, #20
340151c2:	fb00 400e 	mla	r0, r0, lr, r4
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
340151c6:	e9c0 193d 	strd	r1, r9, [r0, #244]	@ 0xf4
  ISP_SVC_StatEngine.client[i].pStats = pStats;
340151ca:	f8c0 30fc 	str.w	r3, [r0, #252]	@ 0xfc
  ISP_SVC_StatEngine.client[i].location = location;
340151ce:	f880 c104 	strb.w	ip, [r0, #260]	@ 0x104
  ISP_SVC_StatEngine.client[i].type = type;
340151d2:	f880 5105 	strb.w	r5, [r0, #261]	@ 0x105
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
340151d6:	f8c0 7100 	str.w	r7, [r0, #256]	@ 0x100
  return ISP_OK;
340151da:	2000      	movs	r0, #0
340151dc:	e7d7      	b.n	3401518e <ISP_SVC_Stats_GetNext+0x3a>
340151de:	bf00      	nop
340151e0:	34057da8 	.word	0x34057da8

340151e4 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
340151e4:	b570      	push	{r4, r5, r6, lr}
  FuncDriver.GetXSize       = pDrv->GetXSize;
  FuncDriver.GetYSize       = pDrv->GetYSize;
  FuncDriver.SetLayer       = pDrv->SetLayer;
  FuncDriver.GetFormat      = pDrv->GetFormat;

  DrawProp->LcdLayer = 0;
340151e6:	2500      	movs	r5, #0
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
340151e8:	4c14      	ldr	r4, [pc, #80]	@ (3401523c <UTIL_LCD_SetFuncDriver+0x58>)
340151ea:	6803      	ldr	r3, [r0, #0]
  FuncDriver.GetYSize       = pDrv->GetYSize;
340151ec:	6a02      	ldr	r2, [r0, #32]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
340151ee:	6023      	str	r3, [r4, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
340151f0:	6843      	ldr	r3, [r0, #4]
  FuncDriver.GetYSize       = pDrv->GetYSize;
340151f2:	6222      	str	r2, [r4, #32]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
340151f4:	6063      	str	r3, [r4, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
340151f6:	6883      	ldr	r3, [r0, #8]
  FuncDriver.SetLayer       = pDrv->SetLayer;
340151f8:	6a42      	ldr	r2, [r0, #36]	@ 0x24
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
340151fa:	60a3      	str	r3, [r4, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
340151fc:	68c3      	ldr	r3, [r0, #12]
  DrawProp->LcdLayer = 0;
340151fe:	4e10      	ldr	r6, [pc, #64]	@ (34015240 <UTIL_LCD_SetFuncDriver+0x5c>)
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
34015200:	60e3      	str	r3, [r4, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
34015202:	6903      	ldr	r3, [r0, #16]
  FuncDriver.SetLayer       = pDrv->SetLayer;
34015204:	6262      	str	r2, [r4, #36]	@ 0x24
  FuncDriver.FillRect       = pDrv->FillRect;
34015206:	6123      	str	r3, [r4, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
34015208:	6943      	ldr	r3, [r0, #20]
  FuncDriver.GetFormat      = pDrv->GetFormat;
3401520a:	6a82      	ldr	r2, [r0, #40]	@ 0x28
  FuncDriver.GetPixel       = pDrv->GetPixel;
3401520c:	6163      	str	r3, [r4, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
3401520e:	6983      	ldr	r3, [r0, #24]
  DrawProp->LcdDevice = 0;
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
34015210:	f106 0114 	add.w	r1, r6, #20
  FuncDriver.SetPixel       = pDrv->SetPixel;
34015214:	61a3      	str	r3, [r4, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
34015216:	69c3      	ldr	r3, [r0, #28]
  DrawProp->LcdDevice = 0;
34015218:	e9c6 5503 	strd	r5, r5, [r6, #12]
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
3401521c:	4628      	mov	r0, r5
  FuncDriver.GetXSize       = pDrv->GetXSize;
3401521e:	61e3      	str	r3, [r4, #28]
  FuncDriver.GetFormat      = pDrv->GetFormat;
34015220:	62a2      	str	r2, [r4, #40]	@ 0x28
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
34015222:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp->LcdYsize);
34015224:	6a23      	ldr	r3, [r4, #32]
34015226:	f106 0118 	add.w	r1, r6, #24
3401522a:	4628      	mov	r0, r5
3401522c:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
3401522e:	4628      	mov	r0, r5
34015230:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
34015232:	f106 011c 	add.w	r1, r6, #28
}
34015236:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
3401523a:	4718      	bx	r3
3401523c:	3405815c 	.word	0x3405815c
34015240:	34058188 	.word	0x34058188

34015244 <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
34015244:	b570      	push	{r4, r5, r6, lr}
  if(FuncDriver.SetLayer != NULL)
34015246:	4e10      	ldr	r6, [pc, #64]	@ (34015288 <UTIL_LCD_SetLayer+0x44>)
{
34015248:	4605      	mov	r5, r0
  if(FuncDriver.SetLayer != NULL)
3401524a:	6a73      	ldr	r3, [r6, #36]	@ 0x24
3401524c:	b1db      	cbz	r3, 34015286 <UTIL_LCD_SetLayer+0x42>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
3401524e:	4c0f      	ldr	r4, [pc, #60]	@ (3401528c <UTIL_LCD_SetLayer+0x48>)
34015250:	4601      	mov	r1, r0
34015252:	6920      	ldr	r0, [r4, #16]
34015254:	4798      	blx	r3
34015256:	b9b0      	cbnz	r0, 34015286 <UTIL_LCD_SetLayer+0x42>
    {
      DrawProp->LcdLayer = Layer;
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34015258:	eb04 1145 	add.w	r1, r4, r5, lsl #5
3401525c:	69f3      	ldr	r3, [r6, #28]
3401525e:	6920      	ldr	r0, [r4, #16]
      DrawProp->LcdLayer = Layer;
34015260:	60e5      	str	r5, [r4, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34015262:	3114      	adds	r1, #20
34015264:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
34015266:	68e1      	ldr	r1, [r4, #12]
34015268:	6a33      	ldr	r3, [r6, #32]
3401526a:	eb04 1141 	add.w	r1, r4, r1, lsl #5
3401526e:	6920      	ldr	r0, [r4, #16]
34015270:	3118      	adds	r1, #24
34015272:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
34015274:	68e1      	ldr	r1, [r4, #12]
34015276:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
34015278:	eb04 1141 	add.w	r1, r4, r1, lsl #5
3401527c:	6920      	ldr	r0, [r4, #16]
3401527e:	311c      	adds	r1, #28
    }
  }
}
34015280:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
34015284:	4718      	bx	r3
}
34015286:	bd70      	pop	{r4, r5, r6, pc}
34015288:	3405815c 	.word	0x3405815c
3401528c:	34058188 	.word	0x34058188

34015290 <UTIL_LCD_SetTextColor>:
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
34015290:	4a02      	ldr	r2, [pc, #8]	@ (3401529c <UTIL_LCD_SetTextColor+0xc>)
34015292:	68d3      	ldr	r3, [r2, #12]
34015294:	015b      	lsls	r3, r3, #5
34015296:	50d0      	str	r0, [r2, r3]
}
34015298:	4770      	bx	lr
3401529a:	bf00      	nop
3401529c:	34058188 	.word	0x34058188

340152a0 <UTIL_LCD_SetBackColor>:
  * @brief  Sets the LCD background color.
  * @param  Color  Layer background color code
  */
void UTIL_LCD_SetBackColor(uint32_t Color)
{
  DrawProp[DrawProp->LcdLayer].BackColor = Color;
340152a0:	4b02      	ldr	r3, [pc, #8]	@ (340152ac <UTIL_LCD_SetBackColor+0xc>)
340152a2:	68da      	ldr	r2, [r3, #12]
340152a4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
340152a8:	6058      	str	r0, [r3, #4]
}
340152aa:	4770      	bx	lr
340152ac:	34058188 	.word	0x34058188

340152b0 <UTIL_LCD_SetFont>:
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
340152b0:	4b02      	ldr	r3, [pc, #8]	@ (340152bc <UTIL_LCD_SetFont+0xc>)
340152b2:	68da      	ldr	r2, [r3, #12]
340152b4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
340152b8:	6098      	str	r0, [r3, #8]
}
340152ba:	4770      	bx	lr
340152bc:	34058188 	.word	0x34058188

340152c0 <UTIL_LCD_GetFont>:
  * @brief  Gets the LCD text font.
  * @retval Used layer font
  */
sFONT *UTIL_LCD_GetFont(void)
{
  return DrawProp[DrawProp->LcdLayer].pFont;
340152c0:	4b02      	ldr	r3, [pc, #8]	@ (340152cc <UTIL_LCD_GetFont+0xc>)
340152c2:	68da      	ldr	r2, [r3, #12]
340152c4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
}
340152c8:	6898      	ldr	r0, [r3, #8]
340152ca:	4770      	bx	lr
340152cc:	34058188 	.word	0x34058188

340152d0 <UTIL_LCD_FillRGBRect>:
  * @param  Xpos    X position
  * @param  Ypos    Y position
  * @param  Length  Line length
  */
void UTIL_LCD_FillRGBRect(uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
340152d0:	b513      	push	{r0, r1, r4, lr}
  /* Write RGB rectangle data */
  FuncDriver.FillRGBRect(DrawProp->LcdDevice, Xpos, Ypos, pData, Width, Height);
340152d2:	9c04      	ldr	r4, [sp, #16]
340152d4:	e9cd 3400 	strd	r3, r4, [sp]
340152d8:	4b04      	ldr	r3, [pc, #16]	@ (340152ec <UTIL_LCD_FillRGBRect+0x1c>)
340152da:	685c      	ldr	r4, [r3, #4]
340152dc:	4613      	mov	r3, r2
340152de:	460a      	mov	r2, r1
340152e0:	4601      	mov	r1, r0
340152e2:	4803      	ldr	r0, [pc, #12]	@ (340152f0 <UTIL_LCD_FillRGBRect+0x20>)
340152e4:	6900      	ldr	r0, [r0, #16]
340152e6:	47a0      	blx	r4
}
340152e8:	b002      	add	sp, #8
340152ea:	bd10      	pop	{r4, pc}
340152ec:	3405815c 	.word	0x3405815c
340152f0:	34058188 	.word	0x34058188

340152f4 <UTIL_LCD_DrawHLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawHLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
340152f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340152f6:	4c19      	ldr	r4, [pc, #100]	@ (3401535c <UTIL_LCD_DrawHLine+0x68>)
{
340152f8:	4606      	mov	r6, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340152fa:	68e0      	ldr	r0, [r4, #12]
340152fc:	eb04 1040 	add.w	r0, r4, r0, lsl #5
34015300:	69c7      	ldr	r7, [r0, #28]
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015302:	4817      	ldr	r0, [pc, #92]	@ (34015360 <UTIL_LCD_DrawHLine+0x6c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015304:	2f02      	cmp	r7, #2
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015306:	6885      	ldr	r5, [r0, #8]
34015308:	6920      	ldr	r0, [r4, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401530a:	d110      	bne.n	3401532e <UTIL_LCD_DrawHLine+0x3a>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401530c:	095c      	lsrs	r4, r3, #5
3401530e:	0a1f      	lsrs	r7, r3, #8
34015310:	f404 64fc 	and.w	r4, r4, #2016	@ 0x7e0
34015314:	f407 4778 	and.w	r7, r7, #63488	@ 0xf800
34015318:	433c      	orrs	r4, r7
3401531a:	f3c3 03c4 	ubfx	r3, r3, #3, #5
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
3401531e:	431c      	orrs	r4, r3
34015320:	9400      	str	r4, [sp, #0]
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015322:	4613      	mov	r3, r2
34015324:	460a      	mov	r2, r1
34015326:	4631      	mov	r1, r6
34015328:	47a8      	blx	r5
  }
}
3401532a:	b003      	add	sp, #12
3401532c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3401532e:	69e4      	ldr	r4, [r4, #28]
34015330:	2c01      	cmp	r4, #1
34015332:	d103      	bne.n	3401533c <UTIL_LCD_DrawHLine+0x48>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
34015334:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015338:	9300      	str	r3, [sp, #0]
3401533a:	e7f2      	b.n	34015322 <UTIL_LCD_DrawHLine+0x2e>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
3401533c:	2f04      	cmp	r7, #4
3401533e:	d1fb      	bne.n	34015338 <UTIL_LCD_DrawHLine+0x44>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
34015340:	0f1f      	lsrs	r7, r3, #28
34015342:	f3c3 1403 	ubfx	r4, r3, #4, #4
34015346:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
3401534a:	0a1f      	lsrs	r7, r3, #8
3401534c:	f007 07f0 	and.w	r7, r7, #240	@ 0xf0
34015350:	0b1b      	lsrs	r3, r3, #12
34015352:	433c      	orrs	r4, r7
34015354:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34015358:	e7e1      	b.n	3401531e <UTIL_LCD_DrawHLine+0x2a>
3401535a:	bf00      	nop
3401535c:	34058188 	.word	0x34058188
34015360:	3405815c 	.word	0x3405815c

34015364 <UTIL_LCD_DrawVLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawVLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34015364:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015366:	4c19      	ldr	r4, [pc, #100]	@ (340153cc <UTIL_LCD_DrawVLine+0x68>)
{
34015368:	4606      	mov	r6, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401536a:	68e0      	ldr	r0, [r4, #12]
3401536c:	eb04 1040 	add.w	r0, r4, r0, lsl #5
34015370:	69c7      	ldr	r7, [r0, #28]
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015372:	4817      	ldr	r0, [pc, #92]	@ (340153d0 <UTIL_LCD_DrawVLine+0x6c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015374:	2f02      	cmp	r7, #2
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34015376:	68c5      	ldr	r5, [r0, #12]
34015378:	6920      	ldr	r0, [r4, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401537a:	d110      	bne.n	3401539e <UTIL_LCD_DrawVLine+0x3a>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3401537c:	095c      	lsrs	r4, r3, #5
3401537e:	0a1f      	lsrs	r7, r3, #8
34015380:	f404 64fc 	and.w	r4, r4, #2016	@ 0x7e0
34015384:	f407 4778 	and.w	r7, r7, #63488	@ 0xf800
34015388:	433c      	orrs	r4, r7
3401538a:	f3c3 03c4 	ubfx	r3, r3, #3, #5
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
  }
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
3401538e:	431c      	orrs	r4, r3
34015390:	9400      	str	r4, [sp, #0]
  }
  else /*LCD_PIXEL_FORMAT_ARGB888*/
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
34015392:	4613      	mov	r3, r2
34015394:	460a      	mov	r2, r1
34015396:	4631      	mov	r1, r6
34015398:	47a8      	blx	r5
  }
}
3401539a:	b003      	add	sp, #12
3401539c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3401539e:	69e4      	ldr	r4, [r4, #28]
340153a0:	2c01      	cmp	r4, #1
340153a2:	d103      	bne.n	340153ac <UTIL_LCD_DrawVLine+0x48>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
340153a4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
340153a8:	9300      	str	r3, [sp, #0]
340153aa:	e7f2      	b.n	34015392 <UTIL_LCD_DrawVLine+0x2e>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
340153ac:	2f04      	cmp	r7, #4
340153ae:	d1fb      	bne.n	340153a8 <UTIL_LCD_DrawVLine+0x44>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
340153b0:	0f1f      	lsrs	r7, r3, #28
340153b2:	f3c3 1403 	ubfx	r4, r3, #4, #4
340153b6:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
340153ba:	0a1f      	lsrs	r7, r3, #8
340153bc:	f007 07f0 	and.w	r7, r7, #240	@ 0xf0
340153c0:	0b1b      	lsrs	r3, r3, #12
340153c2:	433c      	orrs	r4, r7
340153c4:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340153c8:	e7e1      	b.n	3401538e <UTIL_LCD_DrawVLine+0x2a>
340153ca:	bf00      	nop
340153cc:	34058188 	.word	0x34058188
340153d0:	3405815c 	.word	0x3405815c

340153d4 <UTIL_LCD_DisplayChar>:
  * @param  Ypos Line where to display the character shape.
  * @param  Ascii Character ascii code
  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E
  */
void UTIL_LCD_DisplayChar(uint32_t Xpos, uint32_t Ypos, uint8_t Ascii)
{
340153d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
340153d8:	f8df 81e0 	ldr.w	r8, [pc, #480]	@ 340155bc <UTIL_LCD_DisplayChar+0x1e8>
{
340153dc:	b0a3      	sub	sp, #140	@ 0x8c
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
340153de:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
340153e2:	9108      	str	r1, [sp, #32]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
340153e4:	eb08 1343 	add.w	r3, r8, r3, lsl #5
340153e8:	6899      	ldr	r1, [r3, #8]
{
340153ea:	9005      	str	r0, [sp, #20]
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
340153ec:	88cb      	ldrh	r3, [r1, #6]
340153ee:	888c      	ldrh	r4, [r1, #4]
340153f0:	9307      	str	r3, [sp, #28]
  uint8_t rgb8[24*4];
  uint16_t* rgb16 = (uint16_t*)rgb8;
  uint32_t* argb32 = (uint32_t*)rgb8;
  uint16_t* argb4444 = (uint16_t*)rgb8;

  offset =  8 *((width + 7)/8) -  width ;
340153f2:	1de3      	adds	r3, r4, #7
340153f4:	f023 0007 	bic.w	r0, r3, #7
340153f8:	9003      	str	r0, [sp, #12]

  for(i = 0; i < height; i++)
  {
    pchar = ((uint8_t *)pData + (width + 7)/8 * i);
340153fa:	08d8      	lsrs	r0, r3, #3
340153fc:	9006      	str	r0, [sp, #24]
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
    {
      for (j = 0; j < width*3; j = j+ 3)
340153fe:	eb04 0044 	add.w	r0, r4, r4, lsl #1
34015402:	9009      	str	r0, [sp, #36]	@ 0x24
34015404:	9808      	ldr	r0, [sp, #32]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34015406:	3a20      	subs	r2, #32
34015408:	3001      	adds	r0, #1
3401540a:	9004      	str	r0, [sp, #16]
3401540c:	9807      	ldr	r0, [sp, #28]
3401540e:	680d      	ldr	r5, [r1, #0]
34015410:	4342      	muls	r2, r0
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
34015412:	10db      	asrs	r3, r3, #3
34015414:	fb03 5502 	mla	r5, r3, r2, r5
34015418:	9b04      	ldr	r3, [sp, #16]
  for(i = 0; i < height; i++)
3401541a:	9a08      	ldr	r2, [sp, #32]
3401541c:	1e59      	subs	r1, r3, #1
3401541e:	1a9b      	subs	r3, r3, r2
34015420:	9a07      	ldr	r2, [sp, #28]
34015422:	3b01      	subs	r3, #1
34015424:	429a      	cmp	r2, r3
34015426:	d802      	bhi.n	3401542e <UTIL_LCD_DisplayChar+0x5a>
}
34015428:	b023      	add	sp, #140	@ 0x8c
3401542a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(((width + 7)/8))
3401542e:	9806      	ldr	r0, [sp, #24]
      line =  pchar[0];
34015430:	782b      	ldrb	r3, [r5, #0]
    switch(((width + 7)/8))
34015432:	2801      	cmp	r0, #1
      line =  pchar[0];
34015434:	461a      	mov	r2, r3
    switch(((width + 7)/8))
34015436:	d004      	beq.n	34015442 <UTIL_LCD_DisplayChar+0x6e>
34015438:	2802      	cmp	r0, #2
3401543a:	d127      	bne.n	3401548c <UTIL_LCD_DisplayChar+0xb8>
      line =  (pchar[0]<< 8) | pchar[1];
3401543c:	882a      	ldrh	r2, [r5, #0]
3401543e:	ba52      	rev16	r2, r2
34015440:	b292      	uxth	r2, r2
    if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34015442:	f8d8 000c 	ldr.w	r0, [r8, #12]
34015446:	eb08 1040 	add.w	r0, r8, r0, lsl #5
3401544a:	69c7      	ldr	r7, [r0, #28]
3401544c:	2f02      	cmp	r7, #2
3401544e:	d13c      	bne.n	340154ca <UTIL_LCD_DisplayChar+0xf6>
34015450:	f04f 0c01 	mov.w	ip, #1
        if(line & (1 << (width- j + offset- 1)))
34015454:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < width; j++)
34015456:	f04f 0e00 	mov.w	lr, #0
        if(line & (1 << (width- j + offset- 1)))
3401545a:	f103 3aff 	add.w	sl, r3, #4294967295
3401545e:	4663      	mov	r3, ip
34015460:	4574      	cmp	r4, lr
34015462:	eb04 0603 	add.w	r6, r4, r3
34015466:	bf08      	it	eq
34015468:	4666      	moveq	r6, ip
3401546a:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
3401546e:	3e01      	subs	r6, #1
34015470:	d113      	bne.n	3401549a <UTIL_LCD_DisplayChar+0xc6>
        else
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&argb4444[0], width, 1);
34015472:	f8cd c000 	str.w	ip, [sp]
        else
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].BackColor;
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34015476:	4623      	mov	r3, r4
34015478:	9805      	ldr	r0, [sp, #20]
3401547a:	aa0a      	add	r2, sp, #40	@ 0x28
3401547c:	f7ff ff28 	bl	340152d0 <UTIL_LCD_FillRGBRect>
  for(i = 0; i < height; i++)
34015480:	9b04      	ldr	r3, [sp, #16]
34015482:	3301      	adds	r3, #1
34015484:	9304      	str	r3, [sp, #16]
34015486:	9b06      	ldr	r3, [sp, #24]
34015488:	441d      	add	r5, r3
3401548a:	e7c5      	b.n	34015418 <UTIL_LCD_DisplayChar+0x44>
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
3401548c:	786a      	ldrb	r2, [r5, #1]
3401548e:	041b      	lsls	r3, r3, #16
34015490:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
34015494:	78aa      	ldrb	r2, [r5, #2]
34015496:	431a      	orrs	r2, r3
      break;
34015498:	e7d3      	b.n	34015442 <UTIL_LCD_DisplayChar+0x6e>
        if(line & (1 << (width- j + offset- 1)))
3401549a:	ebaa 030e 	sub.w	r3, sl, lr
3401549e:	fa0c f303 	lsl.w	r3, ip, r3
340154a2:	4213      	tst	r3, r2
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
340154a4:	bf14      	ite	ne
340154a6:	6807      	ldrne	r7, [r0, #0]
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
340154a8:	6847      	ldreq	r7, [r0, #4]
      for (j = 0; j < width; j++)
340154aa:	f10e 0e01 	add.w	lr, lr, #1
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
340154ae:	f3c7 03c4 	ubfx	r3, r7, #3, #5
340154b2:	ea4f 4bd7 	mov.w	fp, r7, lsr #19
340154b6:	097f      	lsrs	r7, r7, #5
340154b8:	ea43 23cb 	orr.w	r3, r3, fp, lsl #11
340154bc:	f407 67fc 	and.w	r7, r7, #2016	@ 0x7e0
340154c0:	433b      	orrs	r3, r7
340154c2:	b29b      	uxth	r3, r3
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
340154c4:	f829 3b02 	strh.w	r3, [r9], #2
      for (j = 0; j < width; j++)
340154c8:	e7d1      	b.n	3401546e <UTIL_LCD_DisplayChar+0x9a>
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340154ca:	2f01      	cmp	r7, #1
340154cc:	d126      	bne.n	3401551c <UTIL_LCD_DisplayChar+0x148>
      for (j = 0; j < width*3; j = j+ 3)
340154ce:	f04f 0c00 	mov.w	ip, #0
        if(line & (1 << (width- j/3 + offset- 1)))
340154d2:	f04f 0b03 	mov.w	fp, #3
340154d6:	9b03      	ldr	r3, [sp, #12]
340154d8:	ae0a      	add	r6, sp, #40	@ 0x28
340154da:	f103 3aff 	add.w	sl, r3, #4294967295
      for (j = 0; j < width*3; j = j+ 3)
340154de:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340154e0:	459c      	cmp	ip, r3
340154e2:	d302      	bcc.n	340154ea <UTIL_LCD_DisplayChar+0x116>
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
340154e4:	2301      	movs	r3, #1
340154e6:	9300      	str	r3, [sp, #0]
340154e8:	e7c5      	b.n	34015476 <UTIL_LCD_DisplayChar+0xa2>
        if(line & (1 << (width- j/3 + offset- 1)))
340154ea:	fbbc f3fb 	udiv	r3, ip, fp
340154ee:	ebaa 0303 	sub.w	r3, sl, r3
340154f2:	fa07 f303 	lsl.w	r3, r7, r3
340154f6:	4213      	tst	r3, r2
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
340154f8:	bf14      	ite	ne
340154fa:	6803      	ldrne	r3, [r0, #0]
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
340154fc:	6843      	ldreq	r3, [r0, #4]
      for (j = 0; j < width*3; j = j+ 3)
340154fe:	f10c 0c03 	add.w	ip, ip, #3
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
34015502:	fa5f f983 	uxtb.w	r9, r3
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 8) & 0xFFU;
34015506:	f3c3 2e07 	ubfx	lr, r3, #8, #8
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 16) & 0xFFU;
3401550a:	f3c3 4307 	ubfx	r3, r3, #16, #8
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
3401550e:	f886 9000 	strb.w	r9, [r6]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 8) & 0xFFU;
34015512:	f886 e001 	strb.w	lr, [r6, #1]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 16) & 0xFFU;
34015516:	70b3      	strb	r3, [r6, #2]
      for (j = 0; j < width*3; j = j+ 3)
34015518:	3603      	adds	r6, #3
3401551a:	e7e0      	b.n	340154de <UTIL_LCD_DisplayChar+0x10a>
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
3401551c:	2f04      	cmp	r7, #4
3401551e:	d01f      	beq.n	34015560 <UTIL_LCD_DisplayChar+0x18c>
        if(line & (1 << (width- j + offset- 1)))
34015520:	f04f 0a01 	mov.w	sl, #1
      for (j = 0; j < width; j++)
34015524:	2700      	movs	r7, #0
34015526:	4656      	mov	r6, sl
        if(line & (1 << (width- j + offset- 1)))
34015528:	9b03      	ldr	r3, [sp, #12]
3401552a:	42bc      	cmp	r4, r7
3401552c:	f103 3bff 	add.w	fp, r3, #4294967295
34015530:	eb04 0306 	add.w	r3, r4, r6
34015534:	bf14      	ite	ne
34015536:	469c      	movne	ip, r3
34015538:	46d4      	moveq	ip, sl
3401553a:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
3401553e:	f1bc 0c01 	subs.w	ip, ip, #1
34015542:	d0cf      	beq.n	340154e4 <UTIL_LCD_DisplayChar+0x110>
        if(line & (1 << (width- j + offset- 1)))
34015544:	ebab 0e07 	sub.w	lr, fp, r7
34015548:	6843      	ldr	r3, [r0, #4]
3401554a:	fa0a fe0e 	lsl.w	lr, sl, lr
3401554e:	ea1e 0f02 	tst.w	lr, r2
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
34015552:	6806      	ldr	r6, [r0, #0]
        if(line & (1 << (width- j + offset- 1)))
34015554:	bf08      	it	eq
34015556:	461e      	moveq	r6, r3
      for (j = 0; j < width; j++)
34015558:	3701      	adds	r7, #1
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
3401555a:	f849 6b04 	str.w	r6, [r9], #4
      for (j = 0; j < width; j++)
3401555e:	e7ee      	b.n	3401553e <UTIL_LCD_DisplayChar+0x16a>
34015560:	f04f 0c01 	mov.w	ip, #1
        if(line & (1 << (width- j + offset- 1)))
34015564:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < width; j++)
34015566:	f04f 0e00 	mov.w	lr, #0
        if(line & (1 << (width- j + offset- 1)))
3401556a:	f103 3bff 	add.w	fp, r3, #4294967295
3401556e:	4663      	mov	r3, ip
34015570:	4574      	cmp	r4, lr
34015572:	eb04 0603 	add.w	r6, r4, r3
34015576:	bf08      	it	eq
34015578:	4666      	moveq	r6, ip
3401557a:	f10d 0a28 	add.w	sl, sp, #40	@ 0x28
      for (j = 0; j < width; j++)
3401557e:	3e01      	subs	r6, #1
34015580:	f43f af77 	beq.w	34015472 <UTIL_LCD_DisplayChar+0x9e>
        if(line & (1 << (width- j + offset- 1)))
34015584:	ebab 030e 	sub.w	r3, fp, lr
34015588:	fa0c f303 	lsl.w	r3, ip, r3
3401558c:	4213      	tst	r3, r2
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
3401558e:	bf14      	ite	ne
34015590:	6807      	ldrne	r7, [r0, #0]
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
34015592:	6847      	ldreq	r7, [r0, #4]
      for (j = 0; j < width; j++)
34015594:	f10e 0e01 	add.w	lr, lr, #1
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
34015598:	0f3b      	lsrs	r3, r7, #28
3401559a:	f3c7 1903 	ubfx	r9, r7, #4, #4
3401559e:	ea49 3903 	orr.w	r9, r9, r3, lsl #12
340155a2:	0a3b      	lsrs	r3, r7, #8
340155a4:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
340155a8:	0b3f      	lsrs	r7, r7, #12
340155aa:	ea49 0303 	orr.w	r3, r9, r3
340155ae:	f407 6770 	and.w	r7, r7, #3840	@ 0xf00
340155b2:	433b      	orrs	r3, r7
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
340155b4:	f82a 3b02 	strh.w	r3, [sl], #2
      for (j = 0; j < width; j++)
340155b8:	e7e1      	b.n	3401557e <UTIL_LCD_DisplayChar+0x1aa>
340155ba:	bf00      	nop
340155bc:	34058188 	.word	0x34058188

340155c0 <UTIL_LCD_DisplayStringAt>:
{
340155c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340155c4:	f8df 8088 	ldr.w	r8, [pc, #136]	@ 34015650 <UTIL_LCD_DisplayStringAt+0x90>
{
340155c8:	4605      	mov	r5, r0
  while (*ptr++) size ++ ;
340155ca:	4610      	mov	r0, r2
{
340155cc:	4699      	mov	r9, r3
340155ce:	4616      	mov	r6, r2
340155d0:	460f      	mov	r7, r1
  while (*ptr++) size ++ ;
340155d2:	f7eb ffab 	bl	3400152c <strlen>
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340155d6:	f8d8 300c 	ldr.w	r3, [r8, #12]
  switch (Mode)
340155da:	f1b9 0f01 	cmp.w	r9, #1
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340155de:	eb08 1343 	add.w	r3, r8, r3, lsl #5
340155e2:	689a      	ldr	r2, [r3, #8]
340155e4:	695c      	ldr	r4, [r3, #20]
340155e6:	8892      	ldrh	r2, [r2, #4]
340155e8:	fbb4 f4f2 	udiv	r4, r4, r2
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
340155ec:	eba4 0400 	sub.w	r4, r4, r0
340155f0:	fb02 f404 	mul.w	r4, r2, r4
  switch (Mode)
340155f4:	d01b      	beq.n	3401562e <UTIL_LCD_DisplayStringAt+0x6e>
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
340155f6:	1b64      	subs	r4, r4, r5
340155f8:	f1b9 0f02 	cmp.w	r9, #2
340155fc:	bf08      	it	eq
340155fe:	4625      	moveq	r5, r4
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
34015600:	f647 73fe 	movw	r3, #32766	@ 0x7ffe
34015604:	1e6a      	subs	r2, r5, #1
    refcolumn = 1;
34015606:	429a      	cmp	r2, r3
34015608:	bf88      	it	hi
3401560a:	2501      	movhi	r5, #1
3401560c:	2400      	movs	r4, #0
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
3401560e:	f8d8 300c 	ldr.w	r3, [r8, #12]
34015612:	5d32      	ldrb	r2, [r6, r4]
34015614:	eb08 1343 	add.w	r3, r8, r3, lsl #5
34015618:	6899      	ldr	r1, [r3, #8]
3401561a:	695b      	ldr	r3, [r3, #20]
3401561c:	8889      	ldrh	r1, [r1, #4]
3401561e:	fb04 3311 	mls	r3, r4, r1, r3
34015622:	b29b      	uxth	r3, r3
34015624:	4299      	cmp	r1, r3
34015626:	d800      	bhi.n	3401562a <UTIL_LCD_DisplayStringAt+0x6a>
34015628:	b922      	cbnz	r2, 34015634 <UTIL_LCD_DisplayStringAt+0x74>
}
3401562a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      refcolumn = Xpos + ((xsize - size)* DrawProp[DrawProp->LcdLayer].pFont->Width) / 2;
3401562e:	eb05 0554 	add.w	r5, r5, r4, lsr #1
      break;
34015632:	e7e5      	b.n	34015600 <UTIL_LCD_DisplayStringAt+0x40>
    UTIL_LCD_DisplayChar(refcolumn, Ypos, *Text);
34015634:	4628      	mov	r0, r5
34015636:	4639      	mov	r1, r7
34015638:	f7ff fecc 	bl	340153d4 <UTIL_LCD_DisplayChar>
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
3401563c:	f8d8 300c 	ldr.w	r3, [r8, #12]
    i++;
34015640:	3401      	adds	r4, #1
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
34015642:	eb08 1343 	add.w	r3, r8, r3, lsl #5
34015646:	689b      	ldr	r3, [r3, #8]
34015648:	889b      	ldrh	r3, [r3, #4]
3401564a:	441d      	add	r5, r3
    i++;
3401564c:	e7df      	b.n	3401560e <UTIL_LCD_DisplayStringAt+0x4e>
3401564e:	bf00      	nop
34015650:	34058188 	.word	0x34058188

34015654 <UTIL_LCD_DrawRect>:
{
34015654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34015658:	461f      	mov	r7, r3
3401565a:	460e      	mov	r6, r1
3401565c:	4605      	mov	r5, r0
3401565e:	4614      	mov	r4, r2
34015660:	f8dd 8018 	ldr.w	r8, [sp, #24]
  UTIL_LCD_DrawHLine(Xpos, Ypos, Width, Color);
34015664:	4643      	mov	r3, r8
34015666:	f7ff fe45 	bl	340152f4 <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawHLine(Xpos, (Ypos+ Height - 1U), Width, Color);
3401566a:	1e79      	subs	r1, r7, #1
3401566c:	4643      	mov	r3, r8
3401566e:	4622      	mov	r2, r4
34015670:	4628      	mov	r0, r5
34015672:	4431      	add	r1, r6
34015674:	f7ff fe3e 	bl	340152f4 <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
34015678:	3c01      	subs	r4, #1
  UTIL_LCD_DrawVLine(Xpos, Ypos, Height, Color);
3401567a:	4643      	mov	r3, r8
3401567c:	463a      	mov	r2, r7
3401567e:	4631      	mov	r1, r6
34015680:	4628      	mov	r0, r5
34015682:	f7ff fe6f 	bl	34015364 <UTIL_LCD_DrawVLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
34015686:	4643      	mov	r3, r8
34015688:	463a      	mov	r2, r7
3401568a:	4631      	mov	r1, r6
3401568c:	1960      	adds	r0, r4, r5
}
3401568e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
34015692:	f7ff be67 	b.w	34015364 <UTIL_LCD_DrawVLine>
	...

34015698 <UTIL_LCD_FillRect>:
{
34015698:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401569a:	4d1d      	ldr	r5, [pc, #116]	@ (34015710 <UTIL_LCD_FillRect+0x78>)
{
3401569c:	4607      	mov	r7, r0
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3401569e:	68e8      	ldr	r0, [r5, #12]
{
340156a0:	9c08      	ldr	r4, [sp, #32]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156a2:	eb05 1040 	add.w	r0, r5, r0, lsl #5
340156a6:	f8d0 c01c 	ldr.w	ip, [r0, #28]
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340156aa:	481a      	ldr	r0, [pc, #104]	@ (34015714 <UTIL_LCD_FillRect+0x7c>)
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156ac:	f1bc 0f02 	cmp.w	ip, #2
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340156b0:	6906      	ldr	r6, [r0, #16]
340156b2:	6928      	ldr	r0, [r5, #16]
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
340156b4:	d10c      	bne.n	340156d0 <UTIL_LCD_FillRect+0x38>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
340156b6:	0965      	lsrs	r5, r4, #5
340156b8:	ea4f 2c14 	mov.w	ip, r4, lsr #8
340156bc:	f405 65fc 	and.w	r5, r5, #2016	@ 0x7e0
340156c0:	f40c 4c78 	and.w	ip, ip, #63488	@ 0xf800
340156c4:	ea45 050c 	orr.w	r5, r5, ip
340156c8:	f3c4 04c4 	ubfx	r4, r4, #3, #5
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
340156cc:	432c      	orrs	r4, r5
340156ce:	e004      	b.n	340156da <UTIL_LCD_FillRect+0x42>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
340156d0:	69ed      	ldr	r5, [r5, #28]
340156d2:	2d01      	cmp	r5, #1
340156d4:	d109      	bne.n	340156ea <UTIL_LCD_FillRect+0x52>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
340156d6:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
340156da:	e9cd 3400 	strd	r3, r4, [sp]
340156de:	4613      	mov	r3, r2
340156e0:	460a      	mov	r2, r1
340156e2:	4639      	mov	r1, r7
340156e4:	47b0      	blx	r6
}
340156e6:	b003      	add	sp, #12
340156e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
340156ea:	f1bc 0f04 	cmp.w	ip, #4
340156ee:	d1f4      	bne.n	340156da <UTIL_LCD_FillRect+0x42>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
340156f0:	ea4f 7c14 	mov.w	ip, r4, lsr #28
340156f4:	f3c4 1503 	ubfx	r5, r4, #4, #4
340156f8:	ea45 350c 	orr.w	r5, r5, ip, lsl #12
340156fc:	ea4f 2c14 	mov.w	ip, r4, lsr #8
34015700:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
34015704:	0b24      	lsrs	r4, r4, #12
34015706:	ea45 050c 	orr.w	r5, r5, ip
3401570a:	f404 6470 	and.w	r4, r4, #3840	@ 0xf00
3401570e:	e7dd      	b.n	340156cc <UTIL_LCD_FillRect+0x34>
34015710:	34058188 	.word	0x34058188
34015714:	3405815c 	.word	0x3405815c

34015718 <UTIL_LCD_Clear>:
{
34015718:	b507      	push	{r0, r1, r2, lr}
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
3401571a:	2100      	movs	r1, #0
3401571c:	4a06      	ldr	r2, [pc, #24]	@ (34015738 <UTIL_LCD_Clear+0x20>)
3401571e:	68d3      	ldr	r3, [r2, #12]
34015720:	9000      	str	r0, [sp, #0]
34015722:	eb02 1243 	add.w	r2, r2, r3, lsl #5
34015726:	4608      	mov	r0, r1
34015728:	e9d2 2305 	ldrd	r2, r3, [r2, #20]
3401572c:	f7ff ffb4 	bl	34015698 <UTIL_LCD_FillRect>
}
34015730:	b003      	add	sp, #12
34015732:	f85d fb04 	ldr.w	pc, [sp], #4
34015736:	bf00      	nop
34015738:	34058188 	.word	0x34058188

3401573c <yolov2_nms_comparator>:
static int32_t AI_YOLOV2_PP_SORT_CLASS;


int32_t yolov2_nms_comparator(const void *pa, const void *pb)
{
    float32_t a = *((float32_t *)pa + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
3401573c:	4b0c      	ldr	r3, [pc, #48]	@ (34015770 <yolov2_nms_comparator+0x34>)
3401573e:	681b      	ldr	r3, [r3, #0]
34015740:	3305      	adds	r3, #5
34015742:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    float32_t b = *((float32_t *)pb + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
34015746:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    float32_t diff = 0;

    diff = a - b;
3401574a:	edd0 7a00 	vldr	s15, [r0]
3401574e:	ed91 7a00 	vldr	s14, [r1]
34015752:	ee77 7ac7 	vsub.f32	s15, s15, s14

    if (diff < 0) return 1;
34015756:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401575a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401575e:	d404      	bmi.n	3401576a <yolov2_nms_comparator+0x2e>
    else if (diff > 0) return -1;
34015760:	bfcc      	ite	gt
34015762:	f04f 30ff 	movgt.w	r0, #4294967295
34015766:	2000      	movle	r0, #0
34015768:	4770      	bx	lr
    if (diff < 0) return 1;
3401576a:	2001      	movs	r0, #1
    return 0;
}
3401576c:	4770      	bx	lr
3401576e:	bf00      	nop
34015770:	340581c8 	.word	0x340581c8

34015774 <yolov2_pp_nmsFiltering_centroid>:


int32_t yolov2_pp_nmsFiltering_centroid(yolov2_pp_in_t  *pInput,
                                        yolov2_pp_static_param_t *pInput_static_param)
{
34015774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int32_t i, j, k, limit_counter;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34015778:	f8d0 9000 	ldr.w	r9, [r0]
{
3401577c:	460c      	mov	r4, r1

    for (k = 0; k < pInput_static_param->nb_classes; ++k)
3401577e:	46ca      	mov	sl, r9
34015780:	2700      	movs	r7, #0
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015782:	680d      	ldr	r5, [r1, #0]
{
34015784:	b085      	sub	sp, #20
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015786:	3505      	adds	r5, #5
        limit_counter = 0;
        AI_YOLOV2_PP_SORT_CLASS = k;

        qsort(pInbuff,
              pInput_static_param->nb_detect,
              anch_stride * sizeof(float32_t),
34015788:	ea4f 0885 	mov.w	r8, r5, lsl #2
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
3401578c:	6823      	ldr	r3, [r4, #0]
3401578e:	42bb      	cmp	r3, r7
34015790:	dc03      	bgt.n	3401579a <yolov2_pp_nmsFiltering_centroid+0x26>
            }
        }
    }

    return (AI_OD_POSTPROCESS_ERROR_NO);
}
34015792:	2000      	movs	r0, #0
34015794:	b005      	add	sp, #20
34015796:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AI_YOLOV2_PP_SORT_CLASS = k;
3401579a:	4b2b      	ldr	r3, [pc, #172]	@ (34015848 <yolov2_pp_nmsFiltering_centroid+0xd4>)
        qsort(pInbuff,
3401579c:	4648      	mov	r0, r9
        AI_YOLOV2_PP_SORT_CLASS = k;
3401579e:	601f      	str	r7, [r3, #0]
        qsort(pInbuff,
340157a0:	4642      	mov	r2, r8
340157a2:	4b2a      	ldr	r3, [pc, #168]	@ (3401584c <yolov2_pp_nmsFiltering_centroid+0xd8>)
340157a4:	6a61      	ldr	r1, [r4, #36]	@ 0x24
340157a6:	f002 fa36 	bl	34017c16 <qsort>
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
340157aa:	4656      	mov	r6, sl
340157ac:	2000      	movs	r0, #0
340157ae:	6a62      	ldr	r2, [r4, #36]	@ 0x24
340157b0:	436a      	muls	r2, r5
340157b2:	4282      	cmp	r2, r0
340157b4:	dc08      	bgt.n	340157c8 <yolov2_pp_nmsFiltering_centroid+0x54>
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
340157b6:	2300      	movs	r3, #0
340157b8:	4650      	mov	r0, sl
        limit_counter = 0;
340157ba:	461e      	mov	r6, r3
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
340157bc:	429a      	cmp	r2, r3
340157be:	da30      	bge.n	34015822 <yolov2_pp_nmsFiltering_centroid+0xae>
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
340157c0:	3701      	adds	r7, #1
340157c2:	f10a 0a04 	add.w	sl, sl, #4
340157c6:	e7e1      	b.n	3401578c <yolov2_pp_nmsFiltering_centroid+0x18>
            if (pInbuff[i + AI_YOLOV2_PP_CLASSPROB + k] == 0) continue;
340157c8:	edd6 7a05 	vldr	s15, [r6, #20]
340157cc:	eef5 7a40 	vcmp.f32	s15, #0.0
340157d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340157d4:	eb05 0200 	add.w	r2, r5, r0
340157d8:	4446      	add	r6, r8
340157da:	d101      	bne.n	340157e0 <yolov2_pp_nmsFiltering_centroid+0x6c>
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
340157dc:	4610      	mov	r0, r2
340157de:	e7e6      	b.n	340157ae <yolov2_pp_nmsFiltering_centroid+0x3a>
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
340157e0:	4693      	mov	fp, r2
            float32_t *a = &(pInbuff[i + AI_YOLOV2_PP_XCENTER]);
340157e2:	4633      	mov	r3, r6
340157e4:	eb09 0080 	add.w	r0, r9, r0, lsl #2
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
340157e8:	6a61      	ldr	r1, [r4, #36]	@ 0x24
340157ea:	4369      	muls	r1, r5
340157ec:	4559      	cmp	r1, fp
340157ee:	ddf5      	ble.n	340157dc <yolov2_pp_nmsFiltering_centroid+0x68>
                if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
340157f0:	eb09 018b 	add.w	r1, r9, fp, lsl #2
340157f4:	e9cd 3202 	strd	r3, r2, [sp, #8]
340157f8:	9001      	str	r0, [sp, #4]
340157fa:	f000 fa39 	bl	34015c70 <vision_models_box_iou>
340157fe:	e9dd 0301 	ldrd	r0, r3, [sp, #4]
34015802:	edd4 7a07 	vldr	s15, [r4, #28]
34015806:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401580a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    pInbuff[j + AI_YOLOV2_PP_CLASSPROB + k] = 0;
3401580e:	bfc8      	it	gt
34015810:	eddf 7a0f 	vldrgt	s15, [pc, #60]	@ 34015850 <yolov2_pp_nmsFiltering_centroid+0xdc>
                if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
34015814:	9a03      	ldr	r2, [sp, #12]
                    pInbuff[j + AI_YOLOV2_PP_CLASSPROB + k] = 0;
34015816:	bfc8      	it	gt
34015818:	edc3 7a05 	vstrgt	s15, [r3, #20]
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
3401581c:	44ab      	add	fp, r5
3401581e:	4443      	add	r3, r8
34015820:	e7e2      	b.n	340157e8 <yolov2_pp_nmsFiltering_centroid+0x74>
            if ((limit_counter < pInput_static_param->max_boxes_limit) &&
34015822:	6961      	ldr	r1, [r4, #20]
34015824:	42b1      	cmp	r1, r6
34015826:	dd0a      	ble.n	3401583e <yolov2_pp_nmsFiltering_centroid+0xca>
34015828:	edd0 7a05 	vldr	s15, [r0, #20]
3401582c:	eef5 7a40 	vcmp.f32	s15, #0.0
34015830:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015834:	d003      	beq.n	3401583e <yolov2_pp_nmsFiltering_centroid+0xca>
                limit_counter++;
34015836:	3601      	adds	r6, #1
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
34015838:	442b      	add	r3, r5
3401583a:	4440      	add	r0, r8
3401583c:	e7be      	b.n	340157bc <yolov2_pp_nmsFiltering_centroid+0x48>
                pInbuff[y + AI_YOLOV2_PP_CLASSPROB + k] = 0;
3401583e:	eddf 7a04 	vldr	s15, [pc, #16]	@ 34015850 <yolov2_pp_nmsFiltering_centroid+0xdc>
34015842:	edc0 7a05 	vstr	s15, [r0, #20]
34015846:	e7f7      	b.n	34015838 <yolov2_pp_nmsFiltering_centroid+0xc4>
34015848:	340581c8 	.word	0x340581c8
3401584c:	3401573d 	.word	0x3401573d
34015850:	00000000 	.word	0x00000000

34015854 <yolov2_pp_scoreFiltering_centroid>:


int32_t yolov2_pp_scoreFiltering_centroid(yolov2_pp_in_t *pInput,
                                          od_pp_out_t *pOutput,
                                          yolov2_pp_static_param_t *pInput_static_param)
{
34015854:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    float32_t best_score;
    uint32_t class_index;
    int32_t det_count = 0;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);

    if (pOutput->pOutBuff == NULL)
34015858:	680b      	ldr	r3, [r1, #0]
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401585a:	6817      	ldr	r7, [r2, #0]
{
3401585c:	460d      	mov	r5, r1
3401585e:	4616      	mov	r6, r2
    {
      pOutput->pOutBuff = (od_pp_outBuffer_t *)pInput->pRaw_detections;
34015860:	6804      	ldr	r4, [r0, #0]
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015862:	3705      	adds	r7, #5
    if (pOutput->pOutBuff == NULL)
34015864:	b903      	cbnz	r3, 34015868 <yolov2_pp_scoreFiltering_centroid+0x14>
      pOutput->pOutBuff = (od_pp_outBuffer_t *)pInput->pRaw_detections;
34015866:	600c      	str	r4, [r1, #0]
    }
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;

    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
34015868:	f04f 0900 	mov.w	r9, #0
             &best_score,
             &class_index);

        if (best_score >= pInput_static_param->conf_threshold)
        {
            pOutput->pOutBuff[det_count].x_center = pInbuff[i + AI_YOLOV2_PP_XCENTER];
3401586c:	f04f 0b18 	mov.w	fp, #24
    int32_t det_count = 0;
34015870:	46c8      	mov	r8, r9
34015872:	ea4f 0a87 	mov.w	sl, r7, lsl #2
34015876:	3414      	adds	r4, #20
    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
34015878:	6a73      	ldr	r3, [r6, #36]	@ 0x24
3401587a:	437b      	muls	r3, r7
3401587c:	454b      	cmp	r3, r9
3401587e:	dc05      	bgt.n	3401588c <yolov2_pp_scoreFiltering_centroid+0x38>
        }
    }
    pOutput->nb_detect = det_count;

    return (AI_OD_POSTPROCESS_ERROR_NO);
}
34015880:	2000      	movs	r0, #0
    pOutput->nb_detect = det_count;
34015882:	f8c5 8004 	str.w	r8, [r5, #4]
}
34015886:	b003      	add	sp, #12
34015888:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        vision_models_maxi_if32ou32(&pInbuff[i + AI_YOLOV2_PP_CLASSPROB],
3401588c:	466a      	mov	r2, sp
3401588e:	4620      	mov	r0, r4
34015890:	6831      	ldr	r1, [r6, #0]
34015892:	ab01      	add	r3, sp, #4
34015894:	f000 f913 	bl	34015abe <vision_models_maxi_if32ou32>
        if (best_score >= pInput_static_param->conf_threshold)
34015898:	eddd 7a00 	vldr	s15, [sp]
3401589c:	ed96 7a06 	vldr	s14, [r6, #24]
340158a0:	eeb4 7ae7 	vcmpe.f32	s14, s15
340158a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340158a8:	d814      	bhi.n	340158d4 <yolov2_pp_scoreFiltering_centroid+0x80>
            pOutput->pOutBuff[det_count].x_center = pInbuff[i + AI_YOLOV2_PP_XCENTER];
340158aa:	682b      	ldr	r3, [r5, #0]
340158ac:	f854 2c14 	ldr.w	r2, [r4, #-20]
340158b0:	fb0b 3308 	mla	r3, fp, r8, r3
340158b4:	601a      	str	r2, [r3, #0]
            pOutput->pOutBuff[det_count].y_center = pInbuff[i + AI_YOLOV2_PP_YCENTER];
340158b6:	f854 2c10 	ldr.w	r2, [r4, #-16]
            det_count++;
340158ba:	f108 0801 	add.w	r8, r8, #1
            pOutput->pOutBuff[det_count].y_center = pInbuff[i + AI_YOLOV2_PP_YCENTER];
340158be:	605a      	str	r2, [r3, #4]
            pOutput->pOutBuff[det_count].width = pInbuff[i + AI_YOLOV2_PP_WIDTHREL];
340158c0:	f854 2c0c 	ldr.w	r2, [r4, #-12]
340158c4:	609a      	str	r2, [r3, #8]
            pOutput->pOutBuff[det_count].height = pInbuff[i + AI_YOLOV2_PP_HEIGHTREL];
340158c6:	f854 2c08 	ldr.w	r2, [r4, #-8]
            pOutput->pOutBuff[det_count].conf = best_score;
340158ca:	edc3 7a04 	vstr	s15, [r3, #16]
            pOutput->pOutBuff[det_count].height = pInbuff[i + AI_YOLOV2_PP_HEIGHTREL];
340158ce:	60da      	str	r2, [r3, #12]
            pOutput->pOutBuff[det_count].class_index = class_index;
340158d0:	9a01      	ldr	r2, [sp, #4]
340158d2:	615a      	str	r2, [r3, #20]
    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
340158d4:	44b9      	add	r9, r7
340158d6:	4454      	add	r4, sl
340158d8:	e7ce      	b.n	34015878 <yolov2_pp_scoreFiltering_centroid+0x24>

340158da <yolov2_pp_getNNBoxes_centroid>:


int32_t yolov2_pp_getNNBoxes_centroid(yolov2_pp_in_t *pInput,
                                      yolov2_pp_static_param_t *pInput_static_param)
{
340158da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340158de:	ed2d 8b04 	vpush	{d8-d9}
340158e2:	b08b      	sub	sp, #44	@ 0x2c
    float32_t best_score=0;
    uint32_t class_index;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);

    yolov2_pp_in_t *pOutput = pInput;
    float32_t grid_width_inv = 1.0f / pInput_static_param->grid_width;
340158e4:	edd1 7a02 	vldr	s15, [r1, #8]
340158e8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
340158ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340158f0:	eec7 8a27 	vdiv.f32	s17, s14, s15
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
340158f4:	edd1 7a03 	vldr	s15, [r1, #12]
    float32_t tmp_a[pInput_static_param->nb_classes];
    int32_t el_offset = 0;
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
    float32_t *pOutbuff = (float32_t *)pOutput->pRaw_detections;
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
340158f8:	2500      	movs	r5, #0
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
340158fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float32_t best_score=0;
340158fe:	2300      	movs	r3, #0
{
34015900:	460c      	mov	r4, r1
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
34015902:	ee87 9a27 	vdiv.f32	s18, s14, s15
    int32_t el_offset = 0;
34015906:	462e      	mov	r6, r5
    int32_t count = 0;
34015908:	46aa      	mov	sl, r5
{
3401590a:	af00      	add	r7, sp, #0
    float32_t best_score=0;
3401590c:	623b      	str	r3, [r7, #32]
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3401590e:	680b      	ldr	r3, [r1, #0]
34015910:	1d5a      	adds	r2, r3, #5
    float32_t tmp_a[pInput_static_param->nb_classes];
34015912:	009b      	lsls	r3, r3, #2
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34015914:	613a      	str	r2, [r7, #16]
    float32_t tmp_a[pInput_static_param->nb_classes];
34015916:	1dda      	adds	r2, r3, #7
34015918:	f022 0207 	bic.w	r2, r2, #7
3401591c:	ebad 0d02 	sub.w	sp, sp, r2
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34015920:	6802      	ldr	r2, [r0, #0]
34015922:	3314      	adds	r3, #20
    float32_t tmp_a[pInput_static_param->nb_classes];
34015924:	f8c7 d00c 	str.w	sp, [r7, #12]
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34015928:	617a      	str	r2, [r7, #20]
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
3401592a:	60bb      	str	r3, [r7, #8]
    int32_t count_detect = 0;
3401592c:	61bd      	str	r5, [r7, #24]
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
3401592e:	68a3      	ldr	r3, [r4, #8]
34015930:	42ab      	cmp	r3, r5
34015932:	f300 80a7 	bgt.w	34015a84 <yolov2_pp_getNNBoxes_centroid+0x1aa>
        }
    }

    pInput_static_param->nb_detect = count_detect;
    return (error);
}
34015936:	2000      	movs	r0, #0
    pInput_static_param->nb_detect = count_detect;
34015938:	69bb      	ldr	r3, [r7, #24]
}
3401593a:	372c      	adds	r7, #44	@ 0x2c
    pInput_static_param->nb_detect = count_detect;
3401593c:	6263      	str	r3, [r4, #36]	@ 0x24
}
3401593e:	46bd      	mov	sp, r7
34015940:	ecbd 8b04 	vpop	{d8-d9}
34015944:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] = vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS]);
34015948:	ed1b 0a01 	vldr	s0, [fp, #-4]
3401594c:	f000 f8f2 	bl	34015b34 <vision_models_sigmoid_f>
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34015950:	4659      	mov	r1, fp
34015952:	68fb      	ldr	r3, [r7, #12]
34015954:	6822      	ldr	r2, [r4, #0]
                pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] = vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS]);
34015956:	ed0b 0a01 	vstr	s0, [fp, #-4]
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3401595a:	4658      	mov	r0, fp
3401595c:	f000 f8f6 	bl	34015b4c <vision_models_softmax_f>
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
34015960:	6821      	ldr	r1, [r4, #0]
34015962:	465a      	mov	r2, fp
34015964:	2900      	cmp	r1, #0
34015966:	f101 0301 	add.w	r3, r1, #1
3401596a:	bfb8      	it	lt
3401596c:	2301      	movlt	r3, #1
3401596e:	3b01      	subs	r3, #1
34015970:	d17a      	bne.n	34015a68 <yolov2_pp_getNNBoxes_centroid+0x18e>
                vision_models_maxi_if32ou32(&pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34015972:	4658      	mov	r0, fp
34015974:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34015978:	f107 0220 	add.w	r2, r7, #32
3401597c:	f000 f89f 	bl	34015abe <vision_models_maxi_if32ou32>
                if (best_score >= pInput_static_param->conf_threshold)
34015980:	ed94 7a06 	vldr	s14, [r4, #24]
34015984:	edd7 7a08 	vldr	s15, [r7, #32]
34015988:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401598c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015990:	d851      	bhi.n	34015a36 <yolov2_pp_getNNBoxes_centroid+0x15c>
                    pOutbuff[count + AI_YOLOV2_PP_OBJECTNESS] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS];
34015992:	6979      	ldr	r1, [r7, #20]
34015994:	f10a 0304 	add.w	r3, sl, #4
34015998:	eb01 0883 	add.w	r8, r1, r3, lsl #2
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
3401599c:	6821      	ldr	r1, [r4, #0]
                    pOutbuff[count + AI_YOLOV2_PP_OBJECTNESS] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS];
3401599e:	f85b 2c04 	ldr.w	r2, [fp, #-4]
340159a2:	4643      	mov	r3, r8
340159a4:	2900      	cmp	r1, #0
340159a6:	f8c8 2000 	str.w	r2, [r8]
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
340159aa:	46dc      	mov	ip, fp
340159ac:	f101 0201 	add.w	r2, r1, #1
340159b0:	bfb8      	it	lt
340159b2:	2201      	movlt	r2, #1
340159b4:	3304      	adds	r3, #4
340159b6:	3a01      	subs	r2, #1
340159b8:	d15f      	bne.n	34015a7a <yolov2_pp_getNNBoxes_centroid+0x1a0>
                    pOutbuff[count + AI_YOLOV2_PP_XCENTER] = (col + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_XCENTER])) * grid_width_inv;
340159ba:	ed1b 0a05 	vldr	s0, [fp, #-20]	@ 0xffffffec
340159be:	f000 f8b9 	bl	34015b34 <vision_models_sigmoid_f>
340159c2:	edd7 7a07 	vldr	s15, [r7, #28]
340159c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340159ca:	ee77 7a80 	vadd.f32	s15, s15, s0
340159ce:	ee67 7aa8 	vmul.f32	s15, s15, s17
340159d2:	ed48 7a04 	vstr	s15, [r8, #-16]
                    pOutbuff[count + AI_YOLOV2_PP_YCENTER] = (row + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_YCENTER])) * grid_height_inv;
340159d6:	ed1b 0a04 	vldr	s0, [fp, #-16]
340159da:	f000 f8ab 	bl	34015b34 <vision_models_sigmoid_f>
340159de:	ee07 5a90 	vmov	s15, r5
340159e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340159e6:	ee77 7a80 	vadd.f32	s15, s15, s0
340159ea:	ee67 7a89 	vmul.f32	s15, s15, s18
340159ee:	ed48 7a03 	vstr	s15, [r8, #-12]
                    pOutbuff[count + AI_YOLOV2_PP_WIDTHREL] = (pInput_static_param->pAnchors[2 * anch] * expf(pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL])) * grid_width_inv;
340159f2:	6a23      	ldr	r3, [r4, #32]
340159f4:	ed1b 0a03 	vldr	s0, [fp, #-12]
340159f8:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
340159fc:	ed93 8a00 	vldr	s16, [r3]
34015a00:	607b      	str	r3, [r7, #4]
34015a02:	f005 fd35 	bl	3401b470 <expf>
34015a06:	ee28 8a00 	vmul.f32	s16, s16, s0
34015a0a:	ee28 8a28 	vmul.f32	s16, s16, s17
34015a0e:	ed08 8a02 	vstr	s16, [r8, #-8]
                    pOutbuff[count + AI_YOLOV2_PP_HEIGHTREL] = (pInput_static_param->pAnchors[2 * anch + 1] * expf(pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL])) * grid_height_inv;
34015a12:	687b      	ldr	r3, [r7, #4]
34015a14:	ed1b 0a02 	vldr	s0, [fp, #-8]
34015a18:	ed93 8a01 	vldr	s16, [r3, #4]
34015a1c:	f005 fd28 	bl	3401b470 <expf>
34015a20:	ee28 8a00 	vmul.f32	s16, s16, s0
34015a24:	ee28 8a09 	vmul.f32	s16, s16, s18
34015a28:	ed08 8a01 	vstr	s16, [r8, #-4]
                    count += anch_stride;
34015a2c:	693b      	ldr	r3, [r7, #16]
34015a2e:	449a      	add	sl, r3
                    count_detect++;
34015a30:	69bb      	ldr	r3, [r7, #24]
34015a32:	3301      	adds	r3, #1
34015a34:	61bb      	str	r3, [r7, #24]
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015a36:	68bb      	ldr	r3, [r7, #8]
34015a38:	f109 0901 	add.w	r9, r9, #1
34015a3c:	449b      	add	fp, r3
34015a3e:	693b      	ldr	r3, [r7, #16]
34015a40:	441e      	add	r6, r3
34015a42:	6863      	ldr	r3, [r4, #4]
34015a44:	454b      	cmp	r3, r9
34015a46:	f73f af7f 	bgt.w	34015948 <yolov2_pp_getNNBoxes_centroid+0x6e>
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
34015a4a:	69fb      	ldr	r3, [r7, #28]
34015a4c:	3e05      	subs	r6, #5
34015a4e:	3301      	adds	r3, #1
34015a50:	61fb      	str	r3, [r7, #28]
34015a52:	69fa      	ldr	r2, [r7, #28]
34015a54:	68e3      	ldr	r3, [r4, #12]
34015a56:	4293      	cmp	r3, r2
34015a58:	dd16      	ble.n	34015a88 <yolov2_pp_getNNBoxes_centroid+0x1ae>
34015a5a:	697b      	ldr	r3, [r7, #20]
34015a5c:	3605      	adds	r6, #5
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34015a5e:	f04f 0900 	mov.w	r9, #0
34015a62:	eb03 0b86 	add.w	fp, r3, r6, lsl #2
34015a66:	e7ec      	b.n	34015a42 <yolov2_pp_getNNBoxes_centroid+0x168>
                                                                       pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
34015a68:	ed92 7a00 	vldr	s14, [r2]
                    pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] *
34015a6c:	ed5b 7a01 	vldr	s15, [fp, #-4]
34015a70:	ee67 7a87 	vmul.f32	s15, s15, s14
34015a74:	ece2 7a01 	vstmia	r2!, {s15}
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
34015a78:	e779      	b.n	3401596e <yolov2_pp_getNNBoxes_centroid+0x94>
                        pOutbuff[count + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
34015a7a:	f85c 1b04 	ldr.w	r1, [ip], #4
34015a7e:	f843 1b04 	str.w	r1, [r3], #4
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
34015a82:	e798      	b.n	340159b6 <yolov2_pp_getNNBoxes_centroid+0xdc>
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
34015a84:	2300      	movs	r3, #0
34015a86:	e7e3      	b.n	34015a50 <yolov2_pp_getNNBoxes_centroid+0x176>
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
34015a88:	3501      	adds	r5, #1
34015a8a:	e750      	b.n	3401592e <yolov2_pp_getNNBoxes_centroid+0x54>

34015a8c <od_yolov2_pp_reset>:


/* ----------------------       Exported routines      ---------------------- */

int32_t od_yolov2_pp_reset(yolov2_pp_static_param_t *pInput_static_param)
{
34015a8c:	4603      	mov	r3, r0
    /* Initializations */
    pInput_static_param->nb_detect = 0;
34015a8e:	2000      	movs	r0, #0
34015a90:	6258      	str	r0, [r3, #36]	@ 0x24

	return (AI_OD_POSTPROCESS_ERROR_NO);
}
34015a92:	4770      	bx	lr

34015a94 <od_yolov2_pp_process>:


int32_t od_yolov2_pp_process(yolov2_pp_in_t *pInput,
                                    od_pp_out_t *pOutput,
                                    yolov2_pp_static_param_t *pInput_static_param)
{
34015a94:	b570      	push	{r4, r5, r6, lr}
34015a96:	460e      	mov	r6, r1
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;

    /* Call Get NN boxes first */
    error = yolov2_pp_getNNBoxes_centroid(pInput,
34015a98:	4611      	mov	r1, r2
{
34015a9a:	4605      	mov	r5, r0
34015a9c:	4614      	mov	r4, r2
    error = yolov2_pp_getNNBoxes_centroid(pInput,
34015a9e:	f7ff ff1c 	bl	340158da <yolov2_pp_getNNBoxes_centroid>
                                          pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
34015aa2:	b958      	cbnz	r0, 34015abc <od_yolov2_pp_process+0x28>

    /* Then NMS */
    error = yolov2_pp_nmsFiltering_centroid(pInput,
34015aa4:	4621      	mov	r1, r4
34015aa6:	4628      	mov	r0, r5
34015aa8:	f7ff fe64 	bl	34015774 <yolov2_pp_nmsFiltering_centroid>
                                            pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
34015aac:	b930      	cbnz	r0, 34015abc <od_yolov2_pp_process+0x28>

    /* And score re-filtering */
    error = yolov2_pp_scoreFiltering_centroid(pInput,
34015aae:	4622      	mov	r2, r4
34015ab0:	4631      	mov	r1, r6
34015ab2:	4628      	mov	r0, r5
                                              pOutput,
                                              pInput_static_param);

    return (error);
}
34015ab4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    error = yolov2_pp_scoreFiltering_centroid(pInput,
34015ab8:	f7ff becc 	b.w	34015854 <yolov2_pp_scoreFiltering_centroid>
}
34015abc:	bd70      	pop	{r4, r5, r6, pc}

34015abe <vision_models_maxi_if32ou32>:
#include "stdio.h"

/* return max value and it's index from an array */
#if defined(AI_OD_YOLOV5_PP_MVEF_OPTIM) || defined(AI_SPE_MOVENET_PP_MVEF_OPTIM)
void vision_models_maxi_if32ou32(float32_t *arr, uint32_t len_arr, float32_t *maxim, uint32_t *index)
{
34015abe:	b5f0      	push	{r4, r5, r6, r7, lr}

__extension__ extern __inline uint32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_u32 (uint32_t __a)
{
  return __builtin_mve_vdupq_n_uv4si (__a);
34015ac0:	2400      	movs	r4, #0

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_f32 (float32_t __a)
{
  return __builtin_mve_vdupq_n_fv4sf (__a);
34015ac2:	f46f 0500 	mvn.w	r5, #8388608	@ 0x800000
  return __builtin_mve_vdupq_n_uv4si (__a);
34015ac6:	eea6 4b10 	vdup.32	q3, r4
  return __builtin_mve_vidupq_n_uv4si (__a, __imm);
34015aca:	ee25 2f6e 	cdp	15, 2, cr2, cr5, cr14, {3}

    // according to p0: update with s8x16_val or keep s8x16_blk_minmax_val
    f32x4_max_val = vpselq_f32(f32x4_val, f32x4_max_val, p0);
    /* according to p0: store per-lane extrema indexes*/
    u32x4_max_idx = vpselq_u32(u32x4_idx, u32x4_max_idx, p0);
    u32x4_idx+=4;
34015ace:	1ccc      	adds	r4, r1, #3
34015ad0:	08a4      	lsrs	r4, r4, #2
34015ad2:	f111 0f04 	cmn.w	r1, #4
34015ad6:	f104 0401 	add.w	r4, r4, #1
{
34015ada:	ed2d 8b04 	vpush	{d8-d9}
  return __builtin_mve_vdupq_n_fv4sf (__a);
34015ade:	eea4 5b10 	vdup.32	q2, r5
  int32_t iter = len_arr;
34015ae2:	460f      	mov	r7, r1
    u32x4_idx+=4;
34015ae4:	ef80 8054 	vmov.i32	q4, #4	@ 0x00000004
34015ae8:	bfcc      	ite	gt
34015aea:	4626      	movgt	r6, r4
34015aec:	2601      	movle	r6, #1
  while(iter > 0)
34015aee:	3e01      	subs	r6, #1
34015af0:	d10e      	bne.n	34015b10 <vision_models_maxi_if32ou32+0x52>
  /*
   * Get min index which is thus for a max value
   */
  *index = (int32_t)vminvq_u32(len_arr, indexVec);

}
34015af2:	ecbd 8b04 	vpop	{d8-d9}

__extension__ extern __inline float32_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vmaxnmvq_f32 (float32_t __a, float32x4_t __b)
{
  return __builtin_mve_vmaxnmvq_fv4sf (__a, __b);
34015af6:	eeee 5f04 	cdp	15, 14, cr5, cr14, cr4, {0}
  return __builtin_mve_vcmpgeq_n_fv4sf (__a, __b);
34015afa:	ee35 1f45 	cdp	15, 3, cr1, cr5, cr5, {2}
  return __builtin_mve_vdupq_n_uv4si (__a);
34015afe:	eea4 1b10 	vdup.32	q2, r1
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
34015b02:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}
  return __builtin_mve_vminvq_uv4si (__a, __b);
34015b06:	feea 1f86 	cdp2	15, 14, cr1, cr10, cr6, {4}
  *maxim = vmaxnmvq_f32(F32_MIN, f32x4_max_val);
34015b0a:	6015      	str	r5, [r2, #0]
  *index = (int32_t)vminvq_u32(len_arr, indexVec);
34015b0c:	6019      	str	r1, [r3, #0]
}
34015b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return __builtin_mve_vctp32qv4bi (__a);
34015b10:	f027 e801 	bfcsel	0, 34014b16 <ISP_SVC_ISP_GetColorConv+0x1a>, 4, ls

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vldrwq_z_f32 (float32_t const * __base, mve_pred16_t __p)
{
  return __builtin_mve_vldrwq_z_fv4sf((__builtin_neon_si *) __base, __p);
34015b14:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34015b18:	ecb0 1f04 	ldc	15, cr1, [r0], #16
  return __builtin_mve_vcmpgtq_m_fv4sf (__a, __b, __p);
34015b1c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34015b20:	ee31 1f05 	cdp	15, 3, cr1, cr1, cr5, {0}
    iter-=4;
34015b24:	3f04      	subs	r7, #4
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
34015b26:	fe33 6f07 	cdp2	15, 3, cr6, cr3, cr7, {0}
  return __builtin_mve_vpselq_fv4sf (__a, __b, __p);
34015b2a:	fe31 4f05 	cdp2	15, 3, cr4, cr1, cr5, {0}
    u32x4_idx+=4;
34015b2e:	ef22 2848 	vadd.i32	q1, q1, q4
    iter-=4;
34015b32:	e7dc      	b.n	34015aee <vision_models_maxi_if32ou32+0x30>

34015b34 <vision_models_sigmoid_f>:
    }
  }
}

float32_t vision_models_sigmoid_f(float32_t x)
{
34015b34:	b508      	push	{r3, lr}
  return (1.0f / (1.0f + expf(-x)));
34015b36:	eeb1 0a40 	vneg.f32	s0, s0
34015b3a:	f005 fc99 	bl	3401b470 <expf>
34015b3e:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34015b42:	ee30 0a27 	vadd.f32	s0, s0, s15
}
34015b46:	ee87 0a80 	vdiv.f32	s0, s15, s0
34015b4a:	bd08      	pop	{r3, pc}

34015b4c <vision_models_softmax_f>:


void vision_models_softmax_f(float32_t *input_x, float32_t *output_x, int32_t len_x, float32_t *tmp_x)
{
34015b4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34015b50:	460f      	mov	r7, r1
34015b52:	ed2d 8b02 	vpush	{d8}
34015b56:	4614      	mov	r4, r2
34015b58:	461d      	mov	r5, r3
34015b5a:	4606      	mov	r6, r0
34015b5c:	4698      	mov	r8, r3
  float32_t sum = 0;

  for (int32_t i = 0; i < len_x; ++i)
34015b5e:	469a      	mov	sl, r3
34015b60:	f04f 0900 	mov.w	r9, #0
  float32_t sum = 0;
34015b64:	ed9f 8a14 	vldr	s16, [pc, #80]	@ 34015bb8 <vision_models_softmax_f+0x6c>
  for (int32_t i = 0; i < len_x; ++i)
34015b68:	45a1      	cmp	r9, r4
34015b6a:	db13      	blt.n	34015b94 <vision_models_softmax_f+0x48>
  {
    tmp_x[i] = expf(input_x[i]);
    sum = sum + tmp_x[i];
  }
  sum = 1.0f / sum;
34015b6c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34015b70:	2c00      	cmp	r4, #0
34015b72:	f104 0201 	add.w	r2, r4, #1
34015b76:	ee87 7a88 	vdiv.f32	s14, s15, s16
  for (int32_t i = 0; i < len_x; ++i)
34015b7a:	bfb8      	it	lt
34015b7c:	2201      	movlt	r2, #1
34015b7e:	3a01      	subs	r2, #1
34015b80:	d113      	bne.n	34015baa <vision_models_softmax_f+0x5e>
  {
    tmp_x[i] *= sum;
  }
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
}
34015b82:	ecbd 8b02 	vpop	{d8}
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
34015b86:	4629      	mov	r1, r5
34015b88:	4638      	mov	r0, r7
34015b8a:	00a2      	lsls	r2, r4, #2
}
34015b8c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
34015b90:	f003 baff 	b.w	34019192 <memcpy>
    tmp_x[i] = expf(input_x[i]);
34015b94:	ecb6 0a01 	vldmia	r6!, {s0}
34015b98:	f005 fc6a 	bl	3401b470 <expf>
  for (int32_t i = 0; i < len_x; ++i)
34015b9c:	f109 0901 	add.w	r9, r9, #1
    tmp_x[i] = expf(input_x[i]);
34015ba0:	ecaa 0a01 	vstmia	sl!, {s0}
    sum = sum + tmp_x[i];
34015ba4:	ee38 8a00 	vadd.f32	s16, s16, s0
  for (int32_t i = 0; i < len_x; ++i)
34015ba8:	e7de      	b.n	34015b68 <vision_models_softmax_f+0x1c>
    tmp_x[i] *= sum;
34015baa:	edd8 7a00 	vldr	s15, [r8]
34015bae:	ee67 7a87 	vmul.f32	s15, s15, s14
34015bb2:	ece8 7a01 	vstmia	r8!, {s15}
  for (int32_t i = 0; i < len_x; ++i)
34015bb6:	e7e2      	b.n	34015b7e <vision_models_softmax_f+0x32>
34015bb8:	00000000 	.word	0x00000000

34015bbc <overlap>:

//***************iou ********
//inline
float32_t overlap(float32_t x1, float32_t w1, float32_t x2, float32_t w2)
{
  float32_t l1 = x1 - w1 / 2;
34015bbc:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
34015bc0:	ee60 0aa7 	vmul.f32	s1, s1, s15
  float32_t l2 = x2 - w2 / 2;
34015bc4:	ee61 1aa7 	vmul.f32	s3, s3, s15
  float32_t l1 = x1 - w1 / 2;
34015bc8:	ee30 7a60 	vsub.f32	s14, s0, s1
  float32_t l2 = x2 - w2 / 2;
34015bcc:	ee71 7a61 	vsub.f32	s15, s2, s3
  float32_t left = l1 > l2 ? l1 : l2;
  float32_t r1 = x1 + w1 / 2;
34015bd0:	ee70 0a80 	vadd.f32	s1, s1, s0
  float32_t left = l1 > l2 ? l1 : l2;
34015bd4:	eeb4 7a67 	vcmp.f32	s14, s15
  float32_t r2 = x2 + w2 / 2;
34015bd8:	ee31 1a81 	vadd.f32	s2, s3, s2
  float32_t left = l1 > l2 ? l1 : l2;
34015bdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t right = r1 < r2 ? r1 : r2;
34015be0:	eef4 0a41 	vcmp.f32	s1, s2
  float32_t left = l1 > l2 ? l1 : l2;
34015be4:	fe77 7a27 	vselgt.f32	s15, s14, s15
  float32_t right = r1 < r2 ? r1 : r2;
34015be8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015bec:	bf48      	it	mi
34015bee:	eeb0 1a60 	vmovmi.f32	s2, s1
  return (right - left);
}
34015bf2:	ee31 0a67 	vsub.f32	s0, s2, s15
34015bf6:	4770      	bx	lr

34015bf8 <box_intersection>:

//inline
float32_t box_intersection(float32_t *a, float32_t *b)
{
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34015bf8:	edd1 1a02 	vldr	s3, [r1, #8]
34015bfc:	ed91 1a00 	vldr	s2, [r1]
34015c00:	edd0 0a02 	vldr	s1, [r0, #8]
34015c04:	ed90 0a00 	vldr	s0, [r0]
{
34015c08:	b508      	push	{r3, lr}
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34015c0a:	f7ff ffd7 	bl	34015bbc <overlap>
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
  if (w < 0 || h < 0) return 0;
34015c0e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
34015c12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34015c16:	eef0 6a40 	vmov.f32	s13, s0
  if (w < 0 || h < 0) return 0;
34015c1a:	d411      	bmi.n	34015c40 <box_intersection+0x48>
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
34015c1c:	edd1 1a03 	vldr	s3, [r1, #12]
34015c20:	ed91 1a01 	vldr	s2, [r1, #4]
34015c24:	edd0 0a03 	vldr	s1, [r0, #12]
34015c28:	ed90 0a01 	vldr	s0, [r0, #4]
34015c2c:	f7ff ffc6 	bl	34015bbc <overlap>
  if (w < 0 || h < 0) return 0;
34015c30:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
34015c34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34015c38:	d402      	bmi.n	34015c40 <box_intersection+0x48>
  float32_t area = w * h;
34015c3a:	ee26 0a80 	vmul.f32	s0, s13, s0
  return (area);
}
34015c3e:	bd08      	pop	{r3, pc}
  if (w < 0 || h < 0) return 0;
34015c40:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34015c48 <box_intersection+0x50>
34015c44:	e7fb      	b.n	34015c3e <box_intersection+0x46>
34015c46:	bf00      	nop
34015c48:	00000000 	.word	0x00000000

34015c4c <box_union>:

//inline
float32_t box_union(float32_t *a, float32_t *b)
{
34015c4c:	b510      	push	{r4, lr}
  float32_t i = box_intersection(a, b);
34015c4e:	f7ff ffd3 	bl	34015bf8 <box_intersection>
  float32_t u = a[2] * a[3] + b[2] * b[3] - i;
34015c52:	ed91 7a03 	vldr	s14, [r1, #12]
34015c56:	edd1 7a02 	vldr	s15, [r1, #8]
34015c5a:	edd0 6a02 	vldr	s13, [r0, #8]
34015c5e:	ee67 7a87 	vmul.f32	s15, s15, s14
34015c62:	ed90 7a03 	vldr	s14, [r0, #12]
34015c66:	eee6 7a87 	vfma.f32	s15, s13, s14
  return (u);
}
34015c6a:	ee37 0ac0 	vsub.f32	s0, s15, s0
34015c6e:	bd10      	pop	{r4, pc}

34015c70 <vision_models_box_iou>:


float32_t vision_models_box_iou(float32_t *a, float32_t *b)
{
34015c70:	b508      	push	{r3, lr}

  float32_t I = box_intersection(a, b);
34015c72:	f7ff ffc1 	bl	34015bf8 <box_intersection>
  float32_t U = box_union(a, b);
 if (I == 0 || U == 0)
34015c76:	eeb5 0a40 	vcmp.f32	s0, #0.0
34015c7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t I = box_intersection(a, b);
34015c7e:	eeb0 6a40 	vmov.f32	s12, s0
 if (I == 0 || U == 0)
34015c82:	d00b      	beq.n	34015c9c <vision_models_box_iou+0x2c>
  float32_t U = box_union(a, b);
34015c84:	f7ff ffe2 	bl	34015c4c <box_union>
 if (I == 0 || U == 0)
34015c88:	eeb5 0a40 	vcmp.f32	s0, #0.0
34015c8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float32_t U = box_union(a, b);
34015c90:	eef0 7a40 	vmov.f32	s15, s0
 if (I == 0 || U == 0)
34015c94:	d002      	beq.n	34015c9c <vision_models_box_iou+0x2c>
  {
    return 0;
  }
  return (I / U);
34015c96:	ee86 0a27 	vdiv.f32	s0, s12, s15
}
34015c9a:	bd08      	pop	{r3, pc}
    return 0;
34015c9c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34015ca4 <vision_models_box_iou+0x34>
34015ca0:	e7fb      	b.n	34015c9a <vision_models_box_iou+0x2a>
34015ca2:	bf00      	nop
34015ca4:	00000000 	.word	0x00000000

34015ca8 <LL_ATON_Init>:
/**
 * @brief  ATON global initialization. Initializes clocks and bus interfaces. Must be called before anything else
 * @retval Always zero
 */
int LL_ATON_Init(void)
{
34015ca8:	b510      	push	{r4, lr}
  if (done != 0)
34015caa:	4ba3      	ldr	r3, [pc, #652]	@ (34015f38 <LL_ATON_Init+0x290>)
{
34015cac:	b088      	sub	sp, #32
  if (done != 0)
34015cae:	781a      	ldrb	r2, [r3, #0]
34015cb0:	b90a      	cbnz	r2, 34015cb6 <LL_ATON_Init+0xe>
  done = 1;
34015cb2:	2201      	movs	r2, #1
34015cb4:	701a      	strb	r2, [r3, #0]
  int i;

  ll_aton_static_checks();

  /* Clear pipeline */
  t = ATON_CLKCTRL_CTRL_GET(0);
34015cb6:	4ba1      	ldr	r3, [pc, #644]	@ (34015f3c <LL_ATON_Init+0x294>)
34015cb8:	681a      	ldr	r2, [r3, #0]
  t = ATON_CLKCTRL_CTRL_SET_CLR(t, 1);
34015cba:	f042 0202 	orr.w	r2, r2, #2
  ATON_CLKCTRL_CTRL_SET(0, t);
34015cbe:	601a      	str	r2, [r3, #0]

  /* Enable all ATON clocks */
  ATON_CLKCTRL_CTRL_SET(0, 1);
34015cc0:	2201      	movs	r2, #1
34015cc2:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES0_SET(0, 0xffffffff);
34015cc4:	f04f 32ff 	mov.w	r2, #4294967295
34015cc8:	609a      	str	r2, [r3, #8]
  ATON_CLKCTRL_AGATES1_SET(0, 0xffffffff);
34015cca:	60da      	str	r2, [r3, #12]

#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ATON_CLKCTRL_BGATES_SET(0, (1 << ATON_EPOCHCTRL_CLKB_CLK(0)));
#else
  ATON_CLKCTRL_BGATES_SET(0, 0x0);
34015ccc:	2200      	movs	r2, #0
34015cce:	611a      	str	r2, [r3, #16]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0xffffffff);
#endif

  /* Check that RTL and ATON.h match. Only check first unit */
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34015cd0:	f503 43a0 	add.w	r3, r3, #20480	@ 0x5000
34015cd4:	685c      	ldr	r4, [r3, #4]
34015cd6:	2c00      	cmp	r4, #0
34015cd8:	d0fc      	beq.n	34015cd4 <LL_ATON_Init+0x2c>
34015cda:	f245 0301 	movw	r3, #20481	@ 0x5001
34015cde:	b2a2      	uxth	r2, r4
34015ce0:	429a      	cmp	r2, r3
34015ce2:	f040 8092 	bne.w	34015e0a <LL_ATON_Init+0x162>

#ifdef ATON_CONVACC_NUM
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34015ce6:	4b96      	ldr	r3, [pc, #600]	@ (34015f40 <LL_ATON_Init+0x298>)
34015ce8:	685c      	ldr	r4, [r3, #4]
34015cea:	2c00      	cmp	r4, #0
34015cec:	d0fc      	beq.n	34015ce8 <LL_ATON_Init+0x40>
34015cee:	f245 1317 	movw	r3, #20759	@ 0x5117
34015cf2:	b2a2      	uxth	r2, r4
34015cf4:	429a      	cmp	r2, r3
34015cf6:	f040 80b0 	bne.w	34015e5a <LL_ATON_Init+0x1b2>
#endif

#ifdef ATON_POOL_NUM
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
34015cfa:	4b92      	ldr	r3, [pc, #584]	@ (34015f44 <LL_ATON_Init+0x29c>)
34015cfc:	685c      	ldr	r4, [r3, #4]
34015cfe:	2c00      	cmp	r4, #0
34015d00:	d0fc      	beq.n	34015cfc <LL_ATON_Init+0x54>
34015d02:	f241 131c 	movw	r3, #4380	@ 0x111c
34015d06:	b2a2      	uxth	r2, r4
34015d08:	429a      	cmp	r2, r3
34015d0a:	f040 80cc 	bne.w	34015ea6 <LL_ATON_Init+0x1fe>
#endif

#ifdef ATON_ARITH_NUM
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
34015d0e:	4b8e      	ldr	r3, [pc, #568]	@ (34015f48 <LL_ATON_Init+0x2a0>)
34015d10:	685c      	ldr	r4, [r3, #4]
34015d12:	2c00      	cmp	r4, #0
34015d14:	d0fc      	beq.n	34015d10 <LL_ATON_Init+0x68>
34015d16:	f241 031a 	movw	r3, #4122	@ 0x101a
34015d1a:	b2a2      	uxth	r2, r4
34015d1c:	429a      	cmp	r2, r3
34015d1e:	f040 80e6 	bne.w	34015eee <LL_ATON_Init+0x246>
#endif

#ifdef ATON_ACTIV_NUM
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
34015d22:	4b8a      	ldr	r3, [pc, #552]	@ (34015f4c <LL_ATON_Init+0x2a4>)
34015d24:	685c      	ldr	r4, [r3, #4]
34015d26:	2c00      	cmp	r4, #0
34015d28:	d0fc      	beq.n	34015d24 <LL_ATON_Init+0x7c>
34015d2a:	f241 131b 	movw	r3, #4379	@ 0x111b
34015d2e:	b2a2      	uxth	r2, r4
34015d30:	429a      	cmp	r2, r3
34015d32:	f040 812d 	bne.w	34015f90 <LL_ATON_Init+0x2e8>
#endif

#ifdef ATON_DECUN_NUM
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
34015d36:	4b86      	ldr	r3, [pc, #536]	@ (34015f50 <LL_ATON_Init+0x2a8>)
34015d38:	685c      	ldr	r4, [r3, #4]
34015d3a:	2c00      	cmp	r4, #0
34015d3c:	d0fc      	beq.n	34015d38 <LL_ATON_Init+0x90>
34015d3e:	f641 2319 	movw	r3, #6681	@ 0x1a19
34015d42:	b2a2      	uxth	r2, r4
34015d44:	429a      	cmp	r2, r3
34015d46:	f040 8147 	bne.w	34015fd8 <LL_ATON_Init+0x330>
#endif

#ifdef ATON_EPOCHCTRL_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
34015d4a:	4b82      	ldr	r3, [pc, #520]	@ (34015f54 <LL_ATON_Init+0x2ac>)
34015d4c:	685c      	ldr	r4, [r3, #4]
34015d4e:	2c00      	cmp	r4, #0
34015d50:	d0fc      	beq.n	34015d4c <LL_ATON_Init+0xa4>
34015d52:	f241 1321 	movw	r3, #4385	@ 0x1121
34015d56:	b2a2      	uxth	r2, r4
34015d58:	429a      	cmp	r2, r3
34015d5a:	f040 8162 	bne.w	34016022 <LL_ATON_Init+0x37a>
#endif

#ifdef ATON_RECBUF_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
34015d5e:	4b7e      	ldr	r3, [pc, #504]	@ (34015f58 <LL_ATON_Init+0x2b0>)
34015d60:	685c      	ldr	r4, [r3, #4]
34015d62:	2c00      	cmp	r4, #0
34015d64:	d0fc      	beq.n	34015d60 <LL_ATON_Init+0xb8>
34015d66:	f243 2320 	movw	r3, #12832	@ 0x3220
34015d6a:	b2a2      	uxth	r2, r4
34015d6c:	429a      	cmp	r2, r3
34015d6e:	f040 817c 	bne.w	3401606a <LL_ATON_Init+0x3c2>

#ifdef ATON_IMC_NUM
  ASSERT_UNITS_VERS_W_MSG(IMC, t);
#endif

  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
34015d72:	4b72      	ldr	r3, [pc, #456]	@ (34015f3c <LL_ATON_Init+0x294>)
34015d74:	685c      	ldr	r4, [r3, #4]
34015d76:	2c00      	cmp	r4, #0
34015d78:	d0fc      	beq.n	34015d74 <LL_ATON_Init+0xcc>
34015d7a:	f241 231f 	movw	r3, #4639	@ 0x121f
34015d7e:	b2a2      	uxth	r2, r4
34015d80:	429a      	cmp	r2, r3
34015d82:	f040 8198 	bne.w	340160b6 <LL_ATON_Init+0x40e>

  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
34015d86:	4b75      	ldr	r3, [pc, #468]	@ (34015f5c <LL_ATON_Init+0x2b4>)
34015d88:	685c      	ldr	r4, [r3, #4]
34015d8a:	2c00      	cmp	r4, #0
34015d8c:	d0fc      	beq.n	34015d88 <LL_ATON_Init+0xe0>
34015d8e:	f241 131e 	movw	r3, #4382	@ 0x111e
34015d92:	b2a2      	uxth	r2, r4
34015d94:	429a      	cmp	r2, r3
34015d96:	f040 81b4 	bne.w	34016102 <LL_ATON_Init+0x45a>

  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
34015d9a:	4b71      	ldr	r3, [pc, #452]	@ (34015f60 <LL_ATON_Init+0x2b8>)
34015d9c:	685c      	ldr	r4, [r3, #4]
34015d9e:	2c00      	cmp	r4, #0
34015da0:	d0fc      	beq.n	34015d9c <LL_ATON_Init+0xf4>
34015da2:	b2a3      	uxth	r3, r4
34015da4:	f5b3 5fb0 	cmp.w	r3, #5632	@ 0x1600
34015da8:	f040 81cf 	bne.w	3401614a <LL_ATON_Init+0x4a2>

  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
34015dac:	4a6d      	ldr	r2, [pc, #436]	@ (34015f64 <LL_ATON_Init+0x2bc>)
34015dae:	6854      	ldr	r4, [r2, #4]
34015db0:	2c00      	cmp	r4, #0
34015db2:	d0fc      	beq.n	34015dae <LL_ATON_Init+0x106>
34015db4:	f245 031d 	movw	r3, #20509	@ 0x501d
34015db8:	b2a1      	uxth	r1, r4
34015dba:	4299      	cmp	r1, r3
34015dbc:	f000 81ec 	beq.w	34016198 <LL_ATON_Init+0x4f0>
34015dc0:	f003 f9a4 	bl	3401910c <__errno>
34015dc4:	6803      	ldr	r3, [r0, #0]
34015dc6:	2b00      	cmp	r3, #0
34015dc8:	f000 81e4 	beq.w	34016194 <LL_ATON_Init+0x4ec>
34015dcc:	f003 f99e 	bl	3401910c <__errno>
34015dd0:	6800      	ldr	r0, [r0, #0]
34015dd2:	f003 f935 	bl	34019040 <strerror>
34015dd6:	4603      	mov	r3, r0
34015dd8:	2205      	movs	r2, #5
34015dda:	2100      	movs	r1, #0
34015ddc:	e9cd 2105 	strd	r2, r1, [sp, #20]
34015de0:	221d      	movs	r2, #29
34015de2:	9204      	str	r2, [sp, #16]
34015de4:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015de8:	9203      	str	r2, [sp, #12]
34015dea:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015dee:	9202      	str	r2, [sp, #8]
34015df0:	4a5d      	ldr	r2, [pc, #372]	@ (34015f68 <LL_ATON_Init+0x2c0>)
34015df2:	b2e4      	uxtb	r4, r4
34015df4:	495d      	ldr	r1, [pc, #372]	@ (34015f6c <LL_ATON_Init+0x2c4>)
34015df6:	9200      	str	r2, [sp, #0]
34015df8:	485d      	ldr	r0, [pc, #372]	@ (34015f70 <LL_ATON_Init+0x2c8>)
34015dfa:	22fd      	movs	r2, #253	@ 0xfd
34015dfc:	9401      	str	r4, [sp, #4]
34015dfe:	f002 fd5d 	bl	340188bc <iprintf>
34015e02:	21fd      	movs	r1, #253	@ 0xfd
34015e04:	4b5b      	ldr	r3, [pc, #364]	@ (34015f74 <LL_ATON_Init+0x2cc>)
34015e06:	4a5c      	ldr	r2, [pc, #368]	@ (34015f78 <LL_ATON_Init+0x2d0>)
34015e08:	e022      	b.n	34015e50 <LL_ATON_Init+0x1a8>
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34015e0a:	f003 f97f 	bl	3401910c <__errno>
34015e0e:	6803      	ldr	r3, [r0, #0]
34015e10:	b30b      	cbz	r3, 34015e56 <LL_ATON_Init+0x1ae>
34015e12:	f003 f97b 	bl	3401910c <__errno>
34015e16:	6800      	ldr	r0, [r0, #0]
34015e18:	f003 f912 	bl	34019040 <strerror>
34015e1c:	4603      	mov	r3, r0
34015e1e:	2205      	movs	r2, #5
34015e20:	f04f 0e00 	mov.w	lr, #0
34015e24:	e9cd 2e05 	strd	r2, lr, [sp, #20]
34015e28:	2201      	movs	r2, #1
34015e2a:	9204      	str	r2, [sp, #16]
34015e2c:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015e30:	9203      	str	r2, [sp, #12]
34015e32:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015e36:	9202      	str	r2, [sp, #8]
34015e38:	4a50      	ldr	r2, [pc, #320]	@ (34015f7c <LL_ATON_Init+0x2d4>)
34015e3a:	b2e4      	uxtb	r4, r4
34015e3c:	494b      	ldr	r1, [pc, #300]	@ (34015f6c <LL_ATON_Init+0x2c4>)
34015e3e:	9200      	str	r2, [sp, #0]
34015e40:	484b      	ldr	r0, [pc, #300]	@ (34015f70 <LL_ATON_Init+0x2c8>)
34015e42:	22c9      	movs	r2, #201	@ 0xc9
34015e44:	9401      	str	r4, [sp, #4]
34015e46:	f002 fd39 	bl	340188bc <iprintf>
34015e4a:	21c9      	movs	r1, #201	@ 0xc9
34015e4c:	4b49      	ldr	r3, [pc, #292]	@ (34015f74 <LL_ATON_Init+0x2cc>)
34015e4e:	4a4a      	ldr	r2, [pc, #296]	@ (34015f78 <LL_ATON_Init+0x2d0>)
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34015e50:	4846      	ldr	r0, [pc, #280]	@ (34015f6c <LL_ATON_Init+0x2c4>)
34015e52:	f001 fda5 	bl	340179a0 <__assert_func>
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
34015e56:	4b4a      	ldr	r3, [pc, #296]	@ (34015f80 <LL_ATON_Init+0x2d8>)
34015e58:	e7e1      	b.n	34015e1e <LL_ATON_Init+0x176>
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34015e5a:	f003 f957 	bl	3401910c <__errno>
34015e5e:	6803      	ldr	r3, [r0, #0]
34015e60:	b1fb      	cbz	r3, 34015ea2 <LL_ATON_Init+0x1fa>
34015e62:	f003 f953 	bl	3401910c <__errno>
34015e66:	6800      	ldr	r0, [r0, #0]
34015e68:	f003 f8ea 	bl	34019040 <strerror>
34015e6c:	4603      	mov	r3, r0
34015e6e:	2205      	movs	r2, #5
34015e70:	f04f 0c01 	mov.w	ip, #1
34015e74:	e9cd 2c05 	strd	r2, ip, [sp, #20]
34015e78:	2217      	movs	r2, #23
34015e7a:	9204      	str	r2, [sp, #16]
34015e7c:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015e80:	9203      	str	r2, [sp, #12]
34015e82:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015e86:	9202      	str	r2, [sp, #8]
34015e88:	4a3e      	ldr	r2, [pc, #248]	@ (34015f84 <LL_ATON_Init+0x2dc>)
34015e8a:	b2e4      	uxtb	r4, r4
34015e8c:	4937      	ldr	r1, [pc, #220]	@ (34015f6c <LL_ATON_Init+0x2c4>)
34015e8e:	9200      	str	r2, [sp, #0]
34015e90:	4837      	ldr	r0, [pc, #220]	@ (34015f70 <LL_ATON_Init+0x2c8>)
34015e92:	22cc      	movs	r2, #204	@ 0xcc
34015e94:	9401      	str	r4, [sp, #4]
34015e96:	f002 fd11 	bl	340188bc <iprintf>
34015e9a:	21cc      	movs	r1, #204	@ 0xcc
34015e9c:	4b35      	ldr	r3, [pc, #212]	@ (34015f74 <LL_ATON_Init+0x2cc>)
34015e9e:	4a36      	ldr	r2, [pc, #216]	@ (34015f78 <LL_ATON_Init+0x2d0>)
34015ea0:	e7d6      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34015ea2:	4b37      	ldr	r3, [pc, #220]	@ (34015f80 <LL_ATON_Init+0x2d8>)
34015ea4:	e7e3      	b.n	34015e6e <LL_ATON_Init+0x1c6>
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
34015ea6:	f003 f931 	bl	3401910c <__errno>
34015eaa:	6803      	ldr	r3, [r0, #0]
34015eac:	b1eb      	cbz	r3, 34015eea <LL_ATON_Init+0x242>
34015eae:	f003 f92d 	bl	3401910c <__errno>
34015eb2:	6800      	ldr	r0, [r0, #0]
34015eb4:	f003 f8c4 	bl	34019040 <strerror>
34015eb8:	4603      	mov	r3, r0
34015eba:	2201      	movs	r2, #1
34015ebc:	e9cd 2205 	strd	r2, r2, [sp, #20]
34015ec0:	221c      	movs	r2, #28
34015ec2:	9204      	str	r2, [sp, #16]
34015ec4:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015ec8:	9203      	str	r2, [sp, #12]
34015eca:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015ece:	9202      	str	r2, [sp, #8]
34015ed0:	4a2d      	ldr	r2, [pc, #180]	@ (34015f88 <LL_ATON_Init+0x2e0>)
34015ed2:	b2e4      	uxtb	r4, r4
34015ed4:	4925      	ldr	r1, [pc, #148]	@ (34015f6c <LL_ATON_Init+0x2c4>)
34015ed6:	9200      	str	r2, [sp, #0]
34015ed8:	4825      	ldr	r0, [pc, #148]	@ (34015f70 <LL_ATON_Init+0x2c8>)
34015eda:	22d0      	movs	r2, #208	@ 0xd0
34015edc:	9401      	str	r4, [sp, #4]
34015ede:	f002 fced 	bl	340188bc <iprintf>
34015ee2:	21d0      	movs	r1, #208	@ 0xd0
34015ee4:	4b23      	ldr	r3, [pc, #140]	@ (34015f74 <LL_ATON_Init+0x2cc>)
34015ee6:	4a24      	ldr	r2, [pc, #144]	@ (34015f78 <LL_ATON_Init+0x2d0>)
34015ee8:	e7b2      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34015eea:	4b25      	ldr	r3, [pc, #148]	@ (34015f80 <LL_ATON_Init+0x2d8>)
34015eec:	e7e5      	b.n	34015eba <LL_ATON_Init+0x212>
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
34015eee:	f003 f90d 	bl	3401910c <__errno>
34015ef2:	6803      	ldr	r3, [r0, #0]
34015ef4:	b1f3      	cbz	r3, 34015f34 <LL_ATON_Init+0x28c>
34015ef6:	f003 f909 	bl	3401910c <__errno>
34015efa:	6800      	ldr	r0, [r0, #0]
34015efc:	f003 f8a0 	bl	34019040 <strerror>
34015f00:	4603      	mov	r3, r0
34015f02:	2201      	movs	r2, #1
34015f04:	2000      	movs	r0, #0
34015f06:	e9cd 2005 	strd	r2, r0, [sp, #20]
34015f0a:	221a      	movs	r2, #26
34015f0c:	9204      	str	r2, [sp, #16]
34015f0e:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015f12:	9203      	str	r2, [sp, #12]
34015f14:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015f18:	9202      	str	r2, [sp, #8]
34015f1a:	4a1c      	ldr	r2, [pc, #112]	@ (34015f8c <LL_ATON_Init+0x2e4>)
34015f1c:	b2e4      	uxtb	r4, r4
34015f1e:	4913      	ldr	r1, [pc, #76]	@ (34015f6c <LL_ATON_Init+0x2c4>)
34015f20:	9200      	str	r2, [sp, #0]
34015f22:	4813      	ldr	r0, [pc, #76]	@ (34015f70 <LL_ATON_Init+0x2c8>)
34015f24:	22d4      	movs	r2, #212	@ 0xd4
34015f26:	9401      	str	r4, [sp, #4]
34015f28:	f002 fcc8 	bl	340188bc <iprintf>
34015f2c:	21d4      	movs	r1, #212	@ 0xd4
34015f2e:	4b11      	ldr	r3, [pc, #68]	@ (34015f74 <LL_ATON_Init+0x2cc>)
34015f30:	4a11      	ldr	r2, [pc, #68]	@ (34015f78 <LL_ATON_Init+0x2d0>)
34015f32:	e78d      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34015f34:	4b12      	ldr	r3, [pc, #72]	@ (34015f80 <LL_ATON_Init+0x2d8>)
34015f36:	e7e4      	b.n	34015f02 <LL_ATON_Init+0x25a>
34015f38:	340581cc 	.word	0x340581cc
34015f3c:	580e0000 	.word	0x580e0000
34015f40:	580ef000 	.word	0x580ef000
34015f44:	580fb000 	.word	0x580fb000
34015f48:	580f7000 	.word	0x580f7000
34015f4c:	580f5000 	.word	0x580f5000
34015f50:	580f3000 	.word	0x580f3000
34015f54:	580fe000 	.word	0x580fe000
34015f58:	580fd000 	.word	0x580fd000
34015f5c:	580e1000 	.word	0x580e1000
34015f60:	580e4000 	.word	0x580e4000
34015f64:	580e2000 	.word	0x580e2000
34015f68:	3401d1b5 	.word	0x3401d1b5
34015f6c:	3401d0aa 	.word	0x3401d0aa
34015f70:	3401d100 	.word	0x3401d100
34015f74:	3401d306 	.word	0x3401d306
34015f78:	3403c5e4 	.word	0x3403c5e4
34015f7c:	3401d164 	.word	0x3401d164
34015f80:	3401d0a5 	.word	0x3401d0a5
34015f84:	3401d16b 	.word	0x3401d16b
34015f88:	3401d173 	.word	0x3401d173
34015f8c:	3401d178 	.word	0x3401d178
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
34015f90:	f003 f8bc 	bl	3401910c <__errno>
34015f94:	6803      	ldr	r3, [r0, #0]
34015f96:	b1eb      	cbz	r3, 34015fd4 <LL_ATON_Init+0x32c>
34015f98:	f003 f8b8 	bl	3401910c <__errno>
34015f9c:	6800      	ldr	r0, [r0, #0]
34015f9e:	f003 f84f 	bl	34019040 <strerror>
34015fa2:	4603      	mov	r3, r0
34015fa4:	2201      	movs	r2, #1
34015fa6:	e9cd 2205 	strd	r2, r2, [sp, #20]
34015faa:	221b      	movs	r2, #27
34015fac:	9204      	str	r2, [sp, #16]
34015fae:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015fb2:	9203      	str	r2, [sp, #12]
34015fb4:	f3c4 3203 	ubfx	r2, r4, #12, #4
34015fb8:	9202      	str	r2, [sp, #8]
34015fba:	4a7c      	ldr	r2, [pc, #496]	@ (340161ac <LL_ATON_Init+0x504>)
34015fbc:	b2e4      	uxtb	r4, r4
34015fbe:	497c      	ldr	r1, [pc, #496]	@ (340161b0 <LL_ATON_Init+0x508>)
34015fc0:	9200      	str	r2, [sp, #0]
34015fc2:	487c      	ldr	r0, [pc, #496]	@ (340161b4 <LL_ATON_Init+0x50c>)
34015fc4:	22d8      	movs	r2, #216	@ 0xd8
34015fc6:	9401      	str	r4, [sp, #4]
34015fc8:	f002 fc78 	bl	340188bc <iprintf>
34015fcc:	21d8      	movs	r1, #216	@ 0xd8
34015fce:	4b7a      	ldr	r3, [pc, #488]	@ (340161b8 <LL_ATON_Init+0x510>)
34015fd0:	4a7a      	ldr	r2, [pc, #488]	@ (340161bc <LL_ATON_Init+0x514>)
34015fd2:	e73d      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34015fd4:	4b7a      	ldr	r3, [pc, #488]	@ (340161c0 <LL_ATON_Init+0x518>)
34015fd6:	e7e5      	b.n	34015fa4 <LL_ATON_Init+0x2fc>
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
34015fd8:	f003 f898 	bl	3401910c <__errno>
34015fdc:	6803      	ldr	r3, [r0, #0]
34015fde:	b1f3      	cbz	r3, 3401601e <LL_ATON_Init+0x376>
34015fe0:	f003 f894 	bl	3401910c <__errno>
34015fe4:	6800      	ldr	r0, [r0, #0]
34015fe6:	f003 f82b 	bl	34019040 <strerror>
34015fea:	4603      	mov	r3, r0
34015fec:	2201      	movs	r2, #1
34015fee:	210a      	movs	r1, #10
34015ff0:	e9cd 2105 	strd	r2, r1, [sp, #20]
34015ff4:	2219      	movs	r2, #25
34015ff6:	9204      	str	r2, [sp, #16]
34015ff8:	f3c4 2203 	ubfx	r2, r4, #8, #4
34015ffc:	9203      	str	r2, [sp, #12]
34015ffe:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016002:	9202      	str	r2, [sp, #8]
34016004:	4a6f      	ldr	r2, [pc, #444]	@ (340161c4 <LL_ATON_Init+0x51c>)
34016006:	b2e4      	uxtb	r4, r4
34016008:	4969      	ldr	r1, [pc, #420]	@ (340161b0 <LL_ATON_Init+0x508>)
3401600a:	9200      	str	r2, [sp, #0]
3401600c:	4869      	ldr	r0, [pc, #420]	@ (340161b4 <LL_ATON_Init+0x50c>)
3401600e:	22dc      	movs	r2, #220	@ 0xdc
34016010:	9401      	str	r4, [sp, #4]
34016012:	f002 fc53 	bl	340188bc <iprintf>
34016016:	21dc      	movs	r1, #220	@ 0xdc
34016018:	4b67      	ldr	r3, [pc, #412]	@ (340161b8 <LL_ATON_Init+0x510>)
3401601a:	4a68      	ldr	r2, [pc, #416]	@ (340161bc <LL_ATON_Init+0x514>)
3401601c:	e718      	b.n	34015e50 <LL_ATON_Init+0x1a8>
3401601e:	4b68      	ldr	r3, [pc, #416]	@ (340161c0 <LL_ATON_Init+0x518>)
34016020:	e7e4      	b.n	34015fec <LL_ATON_Init+0x344>
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
34016022:	f003 f873 	bl	3401910c <__errno>
34016026:	6803      	ldr	r3, [r0, #0]
34016028:	b1eb      	cbz	r3, 34016066 <LL_ATON_Init+0x3be>
3401602a:	f003 f86f 	bl	3401910c <__errno>
3401602e:	6800      	ldr	r0, [r0, #0]
34016030:	f003 f806 	bl	34019040 <strerror>
34016034:	4603      	mov	r3, r0
34016036:	2201      	movs	r2, #1
34016038:	e9cd 2205 	strd	r2, r2, [sp, #20]
3401603c:	2221      	movs	r2, #33	@ 0x21
3401603e:	9204      	str	r2, [sp, #16]
34016040:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016044:	9203      	str	r2, [sp, #12]
34016046:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401604a:	9202      	str	r2, [sp, #8]
3401604c:	4a5e      	ldr	r2, [pc, #376]	@ (340161c8 <LL_ATON_Init+0x520>)
3401604e:	b2e4      	uxtb	r4, r4
34016050:	4957      	ldr	r1, [pc, #348]	@ (340161b0 <LL_ATON_Init+0x508>)
34016052:	9200      	str	r2, [sp, #0]
34016054:	4857      	ldr	r0, [pc, #348]	@ (340161b4 <LL_ATON_Init+0x50c>)
34016056:	22e0      	movs	r2, #224	@ 0xe0
34016058:	9401      	str	r4, [sp, #4]
3401605a:	f002 fc2f 	bl	340188bc <iprintf>
3401605e:	21e0      	movs	r1, #224	@ 0xe0
34016060:	4b55      	ldr	r3, [pc, #340]	@ (340161b8 <LL_ATON_Init+0x510>)
34016062:	4a56      	ldr	r2, [pc, #344]	@ (340161bc <LL_ATON_Init+0x514>)
34016064:	e6f4      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34016066:	4b56      	ldr	r3, [pc, #344]	@ (340161c0 <LL_ATON_Init+0x518>)
34016068:	e7e5      	b.n	34016036 <LL_ATON_Init+0x38e>
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
3401606a:	f003 f84f 	bl	3401910c <__errno>
3401606e:	6803      	ldr	r3, [r0, #0]
34016070:	b1fb      	cbz	r3, 340160b2 <LL_ATON_Init+0x40a>
34016072:	f003 f84b 	bl	3401910c <__errno>
34016076:	6800      	ldr	r0, [r0, #0]
34016078:	f002 ffe2 	bl	34019040 <strerror>
3401607c:	4603      	mov	r3, r0
3401607e:	2203      	movs	r2, #3
34016080:	f04f 0e02 	mov.w	lr, #2
34016084:	e9cd 2e05 	strd	r2, lr, [sp, #20]
34016088:	2220      	movs	r2, #32
3401608a:	9204      	str	r2, [sp, #16]
3401608c:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016090:	9203      	str	r2, [sp, #12]
34016092:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016096:	9202      	str	r2, [sp, #8]
34016098:	4a4c      	ldr	r2, [pc, #304]	@ (340161cc <LL_ATON_Init+0x524>)
3401609a:	b2e4      	uxtb	r4, r4
3401609c:	4944      	ldr	r1, [pc, #272]	@ (340161b0 <LL_ATON_Init+0x508>)
3401609e:	9200      	str	r2, [sp, #0]
340160a0:	4844      	ldr	r0, [pc, #272]	@ (340161b4 <LL_ATON_Init+0x50c>)
340160a2:	22e4      	movs	r2, #228	@ 0xe4
340160a4:	9401      	str	r4, [sp, #4]
340160a6:	f002 fc09 	bl	340188bc <iprintf>
340160aa:	21e4      	movs	r1, #228	@ 0xe4
340160ac:	4b42      	ldr	r3, [pc, #264]	@ (340161b8 <LL_ATON_Init+0x510>)
340160ae:	4a43      	ldr	r2, [pc, #268]	@ (340161bc <LL_ATON_Init+0x514>)
340160b0:	e6ce      	b.n	34015e50 <LL_ATON_Init+0x1a8>
340160b2:	4b43      	ldr	r3, [pc, #268]	@ (340161c0 <LL_ATON_Init+0x518>)
340160b4:	e7e3      	b.n	3401607e <LL_ATON_Init+0x3d6>
  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
340160b6:	f003 f829 	bl	3401910c <__errno>
340160ba:	6803      	ldr	r3, [r0, #0]
340160bc:	b1fb      	cbz	r3, 340160fe <LL_ATON_Init+0x456>
340160be:	f003 f825 	bl	3401910c <__errno>
340160c2:	6800      	ldr	r0, [r0, #0]
340160c4:	f002 ffbc 	bl	34019040 <strerror>
340160c8:	4603      	mov	r3, r0
340160ca:	2201      	movs	r2, #1
340160cc:	f04f 0c02 	mov.w	ip, #2
340160d0:	e9cd 2c05 	strd	r2, ip, [sp, #20]
340160d4:	221f      	movs	r2, #31
340160d6:	9204      	str	r2, [sp, #16]
340160d8:	f3c4 2203 	ubfx	r2, r4, #8, #4
340160dc:	9203      	str	r2, [sp, #12]
340160de:	f3c4 3203 	ubfx	r2, r4, #12, #4
340160e2:	9202      	str	r2, [sp, #8]
340160e4:	4a3a      	ldr	r2, [pc, #232]	@ (340161d0 <LL_ATON_Init+0x528>)
340160e6:	b2e4      	uxtb	r4, r4
340160e8:	4931      	ldr	r1, [pc, #196]	@ (340161b0 <LL_ATON_Init+0x508>)
340160ea:	9200      	str	r2, [sp, #0]
340160ec:	4831      	ldr	r0, [pc, #196]	@ (340161b4 <LL_ATON_Init+0x50c>)
340160ee:	22f7      	movs	r2, #247	@ 0xf7
340160f0:	9401      	str	r4, [sp, #4]
340160f2:	f002 fbe3 	bl	340188bc <iprintf>
340160f6:	21f7      	movs	r1, #247	@ 0xf7
340160f8:	4b2f      	ldr	r3, [pc, #188]	@ (340161b8 <LL_ATON_Init+0x510>)
340160fa:	4a30      	ldr	r2, [pc, #192]	@ (340161bc <LL_ATON_Init+0x514>)
340160fc:	e6a8      	b.n	34015e50 <LL_ATON_Init+0x1a8>
340160fe:	4b30      	ldr	r3, [pc, #192]	@ (340161c0 <LL_ATON_Init+0x518>)
34016100:	e7e3      	b.n	340160ca <LL_ATON_Init+0x422>
  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
34016102:	f003 f803 	bl	3401910c <__errno>
34016106:	6803      	ldr	r3, [r0, #0]
34016108:	b1eb      	cbz	r3, 34016146 <LL_ATON_Init+0x49e>
3401610a:	f002 ffff 	bl	3401910c <__errno>
3401610e:	6800      	ldr	r0, [r0, #0]
34016110:	f002 ff96 	bl	34019040 <strerror>
34016114:	4603      	mov	r3, r0
34016116:	2201      	movs	r2, #1
34016118:	e9cd 2205 	strd	r2, r2, [sp, #20]
3401611c:	221e      	movs	r2, #30
3401611e:	9204      	str	r2, [sp, #16]
34016120:	f3c4 2203 	ubfx	r2, r4, #8, #4
34016124:	9203      	str	r2, [sp, #12]
34016126:	f3c4 3203 	ubfx	r2, r4, #12, #4
3401612a:	9202      	str	r2, [sp, #8]
3401612c:	4a29      	ldr	r2, [pc, #164]	@ (340161d4 <LL_ATON_Init+0x52c>)
3401612e:	b2e4      	uxtb	r4, r4
34016130:	491f      	ldr	r1, [pc, #124]	@ (340161b0 <LL_ATON_Init+0x508>)
34016132:	9200      	str	r2, [sp, #0]
34016134:	481f      	ldr	r0, [pc, #124]	@ (340161b4 <LL_ATON_Init+0x50c>)
34016136:	22f9      	movs	r2, #249	@ 0xf9
34016138:	9401      	str	r4, [sp, #4]
3401613a:	f002 fbbf 	bl	340188bc <iprintf>
3401613e:	21f9      	movs	r1, #249	@ 0xf9
34016140:	4b1d      	ldr	r3, [pc, #116]	@ (340161b8 <LL_ATON_Init+0x510>)
34016142:	4a1e      	ldr	r2, [pc, #120]	@ (340161bc <LL_ATON_Init+0x514>)
34016144:	e684      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34016146:	4b1e      	ldr	r3, [pc, #120]	@ (340161c0 <LL_ATON_Init+0x518>)
34016148:	e7e5      	b.n	34016116 <LL_ATON_Init+0x46e>
  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
3401614a:	f002 ffdf 	bl	3401910c <__errno>
3401614e:	6803      	ldr	r3, [r0, #0]
34016150:	b1f3      	cbz	r3, 34016190 <LL_ATON_Init+0x4e8>
34016152:	f002 ffdb 	bl	3401910c <__errno>
34016156:	6800      	ldr	r0, [r0, #0]
34016158:	f002 ff72 	bl	34019040 <strerror>
3401615c:	4603      	mov	r3, r0
3401615e:	2201      	movs	r2, #1
34016160:	2006      	movs	r0, #6
34016162:	e9cd 2005 	strd	r2, r0, [sp, #20]
34016166:	2200      	movs	r2, #0
34016168:	9204      	str	r2, [sp, #16]
3401616a:	f3c4 2203 	ubfx	r2, r4, #8, #4
3401616e:	9203      	str	r2, [sp, #12]
34016170:	f3c4 3203 	ubfx	r2, r4, #12, #4
34016174:	9202      	str	r2, [sp, #8]
34016176:	4a18      	ldr	r2, [pc, #96]	@ (340161d8 <LL_ATON_Init+0x530>)
34016178:	b2e4      	uxtb	r4, r4
3401617a:	490d      	ldr	r1, [pc, #52]	@ (340161b0 <LL_ATON_Init+0x508>)
3401617c:	9200      	str	r2, [sp, #0]
3401617e:	480d      	ldr	r0, [pc, #52]	@ (340161b4 <LL_ATON_Init+0x50c>)
34016180:	22fb      	movs	r2, #251	@ 0xfb
34016182:	9401      	str	r4, [sp, #4]
34016184:	f002 fb9a 	bl	340188bc <iprintf>
34016188:	21fb      	movs	r1, #251	@ 0xfb
3401618a:	4b0b      	ldr	r3, [pc, #44]	@ (340161b8 <LL_ATON_Init+0x510>)
3401618c:	4a0b      	ldr	r2, [pc, #44]	@ (340161bc <LL_ATON_Init+0x514>)
3401618e:	e65f      	b.n	34015e50 <LL_ATON_Init+0x1a8>
34016190:	4b0b      	ldr	r3, [pc, #44]	@ (340161c0 <LL_ATON_Init+0x518>)
34016192:	e7e4      	b.n	3401615e <LL_ATON_Init+0x4b6>
  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
34016194:	4b0a      	ldr	r3, [pc, #40]	@ (340161c0 <LL_ATON_Init+0x518>)
34016196:	e61f      	b.n	34015dd8 <LL_ATON_Init+0x130>

  /* Enable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
  {
    ATON_BUSIF_CTRL_SET(i, 1);
34016198:	2301      	movs	r3, #1

  /* Enable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 1);

  return 0;
}
3401619a:	2000      	movs	r0, #0
    ATON_BUSIF_CTRL_SET(i, 1);
3401619c:	6013      	str	r3, [r2, #0]
3401619e:	4a0f      	ldr	r2, [pc, #60]	@ (340161dc <LL_ATON_Init+0x534>)
340161a0:	6013      	str	r3, [r2, #0]
  ATON_INTCTRL_CTRL_SET(0, 1);
340161a2:	f5a2 5200 	sub.w	r2, r2, #8192	@ 0x2000
340161a6:	6013      	str	r3, [r2, #0]
}
340161a8:	b008      	add	sp, #32
340161aa:	bd10      	pop	{r4, pc}
340161ac:	3401d17e 	.word	0x3401d17e
340161b0:	3401d0aa 	.word	0x3401d0aa
340161b4:	3401d100 	.word	0x3401d100
340161b8:	3401d306 	.word	0x3401d306
340161bc:	3403c5e4 	.word	0x3403c5e4
340161c0:	3401d0a5 	.word	0x3401d0a5
340161c4:	3401d184 	.word	0x3401d184
340161c8:	3401d18a 	.word	0x3401d18a
340161cc:	3401d194 	.word	0x3401d194
340161d0:	3401d19b 	.word	0x3401d19b
340161d4:	3401d1a3 	.word	0x3401d1a3
340161d8:	3401d1ab 	.word	0x3401d1ab
340161dc:	580e3000 	.word	0x580e3000

340161e0 <LL_ATON_DeInit>:
int LL_ATON_DeInit(void)
{
  int i;

  /* Disable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 0);
340161e0:	2000      	movs	r0, #0
340161e2:	4b07      	ldr	r3, [pc, #28]	@ (34016200 <LL_ATON_DeInit+0x20>)
340161e4:	6018      	str	r0, [r3, #0]

  /* Disable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
  {
    ATON_BUSIF_CTRL_SET(i, 0);
340161e6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340161ea:	6018      	str	r0, [r3, #0]
340161ec:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340161f0:	6018      	str	r0, [r3, #0]
  }

  /* Disable all ATON clocks */
  ATON_CLKCTRL_AGATES0_SET(0, 0);
340161f2:	f5a3 5340 	sub.w	r3, r3, #12288	@ 0x3000
340161f6:	6098      	str	r0, [r3, #8]
  ATON_CLKCTRL_AGATES1_SET(0, 0);
340161f8:	60d8      	str	r0, [r3, #12]
  ATON_CLKCTRL_BGATES_SET(0, 0);
340161fa:	6118      	str	r0, [r3, #16]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0);
#endif
  ATON_CLKCTRL_CTRL_SET(0, 0);
340161fc:	6018      	str	r0, [r3, #0]

  return 0;
}
340161fe:	4770      	bx	lr
34016200:	580e1000 	.word	0x580e1000

34016204 <LL_ATON_EnableClock>:
  return bloblines * 4;
}
#endif // ATON_EPOCHCTRL_NUM

void LL_ATON_EnableClock(unsigned int clock)
{
34016204:	b530      	push	{r4, r5, lr}
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  LL_ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 1);
34016206:	2401      	movs	r4, #1
34016208:	2500      	movs	r5, #0
3401620a:	2301      	movs	r3, #1
3401620c:	ea54 050d 	orrs.w	r5, r4, sp
34016210:	4a03      	ldr	r2, [pc, #12]	@ (34016220 <LL_ATON_EnableClock+0x1c>)
34016212:	4083      	lsls	r3, r0
34016214:	6911      	ldr	r1, [r2, #16]
34016216:	404b      	eors	r3, r1
34016218:	4023      	ands	r3, r4
3401621a:	404b      	eors	r3, r1
3401621c:	6113      	str	r3, [r2, #16]
#endif
}
3401621e:	bd30      	pop	{r4, r5, pc}
34016220:	580e0000 	.word	0x580e0000

34016224 <LL_EpochCtrl_Init>:
  if (id >= ATON_EPOCHCTRL_NUM)
34016224:	2800      	cmp	r0, #0
{
34016226:	b510      	push	{r4, lr}
34016228:	460c      	mov	r4, r1
  if (id >= ATON_EPOCHCTRL_NUM)
3401622a:	dc0e      	bgt.n	3401624a <LL_EpochCtrl_Init+0x26>
  LL_ATON_EnableClock(ATON_EPOCHCTRL_CLKB_CLK(id));
3401622c:	3019      	adds	r0, #25
3401622e:	f7ff ffe9 	bl	34016204 <LL_ATON_EnableClock>
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
34016232:	7923      	ldrb	r3, [r4, #4]
  ATON_EPOCHCTRL_CTRL_SET(id, t);
34016234:	4a08      	ldr	r2, [pc, #32]	@ (34016258 <LL_EpochCtrl_Init+0x34>)
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
34016236:	f003 0301 	and.w	r3, r3, #1
3401623a:	00db      	lsls	r3, r3, #3
  ATON_EPOCHCTRL_CTRL_SET(id, t);
3401623c:	6013      	str	r3, [r2, #0]
  if (conf->blobaddr & 0x7)
3401623e:	6823      	ldr	r3, [r4, #0]
34016240:	f013 0007 	ands.w	r0, r3, #7
34016244:	d104      	bne.n	34016250 <LL_EpochCtrl_Init+0x2c>
  ATON_EPOCHCTRL_ADDR_SET(id, conf->blobaddr);
34016246:	6093      	str	r3, [r2, #8]
}
34016248:	bd10      	pop	{r4, pc}
    return LL_ATON_INVALID_ID;
3401624a:	f04f 30ff 	mov.w	r0, #4294967295
3401624e:	e7fb      	b.n	34016248 <LL_EpochCtrl_Init+0x24>
    return LL_ATON_INVALID_PARAM;
34016250:	f06f 0001 	mvn.w	r0, #1
34016254:	e7f8      	b.n	34016248 <LL_EpochCtrl_Init+0x24>
34016256:	bf00      	nop
34016258:	580fe000 	.word	0x580fe000

3401625c <LL_ATON_DisableClock>:

void LL_ATON_DisableClock(unsigned int clock)
{
3401625c:	b530      	push	{r4, r5, lr}
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  LL_ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 0);
3401625e:	2401      	movs	r4, #1
34016260:	2500      	movs	r5, #0
34016262:	ea54 050d 	orrs.w	r5, r4, sp
34016266:	4a03      	ldr	r2, [pc, #12]	@ (34016274 <LL_ATON_DisableClock+0x18>)
34016268:	6913      	ldr	r3, [r2, #16]
3401626a:	ea23 0304 	bic.w	r3, r3, r4
3401626e:	6113      	str	r3, [r2, #16]
#endif
}
34016270:	bd30      	pop	{r4, r5, pc}
34016272:	bf00      	nop
34016274:	580e0000 	.word	0x580e0000

34016278 <LL_ATON_RT_Main>:
 *                         and the network interface, or macros
 *                         `LL_ATON_DECLARE_NAMED_NN_INTERFACE()` & `LL_ATON_DECLARE_NAMED_NN_INSTANCE()` to
 *                         create/instantiate the objects separately.
 */
void LL_ATON_RT_Main(NN_Instance_TypeDef *network_instance)
{
34016278:	b510      	push	{r4, lr}

  /*** Start of user initialization code ***/

  /*** End of user initialization code ***/

  LL_ATON_ASSERT(network_instance != NULL);
3401627a:	4604      	mov	r4, r0
3401627c:	b928      	cbnz	r0, 3401628a <LL_ATON_RT_Main+0x12>
3401627e:	2130      	movs	r1, #48	@ 0x30
34016280:	4b0f      	ldr	r3, [pc, #60]	@ (340162c0 <LL_ATON_RT_Main+0x48>)
34016282:	4a10      	ldr	r2, [pc, #64]	@ (340162c4 <LL_ATON_RT_Main+0x4c>)
  LL_ATON_ASSERT(network_instance->network != NULL);
34016284:	4810      	ldr	r0, [pc, #64]	@ (340162c8 <LL_ATON_RT_Main+0x50>)
34016286:	f001 fb8b 	bl	340179a0 <__assert_func>
3401628a:	6803      	ldr	r3, [r0, #0]
3401628c:	b91b      	cbnz	r3, 34016296 <LL_ATON_RT_Main+0x1e>
3401628e:	2131      	movs	r1, #49	@ 0x31
34016290:	4b0e      	ldr	r3, [pc, #56]	@ (340162cc <LL_ATON_RT_Main+0x54>)
34016292:	4a0c      	ldr	r2, [pc, #48]	@ (340162c4 <LL_ATON_RT_Main+0x4c>)
34016294:	e7f6      	b.n	34016284 <LL_ATON_RT_Main+0xc>
  LL_ATON_RT_RuntimeInit();                  // Initialize runtime
34016296:	f000 fa05 	bl	340166a4 <LL_ATON_RT_RuntimeInit>
  LL_ATON_RT_Init_Network(network_instance); // Initialize passed network instance object
3401629a:	4620      	mov	r0, r4
3401629c:	f000 f9c0 	bl	34016620 <LL_ATON_RT_Init_Network>

  do
  {
    /* Execute first/next step of Cube.AI/ATON runtime */
    ll_aton_rt_ret = LL_ATON_RT_RunEpochBlock(network_instance);
340162a0:	4620      	mov	r0, r4
340162a2:	f000 fa79 	bl	34016798 <LL_ATON_RT_RunEpochBlock>
    /*** Start of user event handling code ***/

    /*** End of user event handling code ***/

    /* Wait for next event */
    if (ll_aton_rt_ret == LL_ATON_RT_WFE)
340162a6:	2801      	cmp	r0, #1
340162a8:	d101      	bne.n	340162ae <LL_ATON_RT_Main+0x36>
    { /*** subject to change to fit also user code requirements ***/
      LL_ATON_OSAL_WFE();
340162aa:	bf20      	wfe
    }
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE); /*** subject to change to fit also user code requirements ***/
340162ac:	e7f8      	b.n	340162a0 <LL_ATON_RT_Main+0x28>
340162ae:	2802      	cmp	r0, #2
340162b0:	d1f6      	bne.n	340162a0 <LL_ATON_RT_Main+0x28>

  LL_ATON_RT_DeInit_Network(network_instance); // De-initialize the network instance object
340162b2:	4620      	mov	r0, r4
340162b4:	f000 f9d8 	bl	34016668 <LL_ATON_RT_DeInit_Network>
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime

  /*** Start of user de-initialization code ***/

  /*** End of user de-initialization code ***/
}
340162b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime
340162bc:	f000 ba3c 	b.w	34016738 <LL_ATON_RT_RuntimeDeInit>
340162c0:	3401d1bb 	.word	0x3401d1bb
340162c4:	3403c5f1 	.word	0x3403c5f1
340162c8:	3401d1db 	.word	0x3401d1db
340162cc:	3401d239 	.word	0x3401d239

340162d0 <__LL_ATON_RT_Init_Network>:
                          // wait for
  }
}

static inline void __LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
340162d0:	b510      	push	{r4, lr}
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
340162d2:	4604      	mov	r4, r0
340162d4:	b310      	cbz	r0, 3401631c <__LL_ATON_RT_Init_Network+0x4c>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
340162d6:	6803      	ldr	r3, [r0, #0]
340162d8:	b303      	cbz	r3, 3401631c <__LL_ATON_RT_Init_Network+0x4c>
    return;
  }

  /** Initialize static variables **/
  /* set context */
  const LL_ATON_RT_EpochBlockItem_t *eb_list = nn_instance->network->epoch_block_items();
340162da:	69db      	ldr	r3, [r3, #28]
340162dc:	4798      	blx	r3
  nn_instance->exec_state.current_epoch_block = eb_list;
  nn_instance->exec_state.first_epoch_block = eb_list;
  nn_instance->exec_state.next_epoch_block = NULL;
340162de:	2300      	movs	r3, #0
  nn_instance->exec_state.current_epoch_block = eb_list;
340162e0:	6060      	str	r0, [r4, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
340162e2:	60a0      	str	r0, [r4, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
340162e4:	60e3      	str	r3, [r4, #12]

  /* set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
340162e6:	6123      	str	r3, [r4, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
340162e8:	6163      	str	r3, [r4, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
340162ea:	6863      	ldr	r3, [r4, #4]
  if (list != NULL)
340162ec:	b9a3      	cbnz	r3, 34016318 <__LL_ATON_RT_Init_Network+0x48>
  int i = 0;
340162ee:	461a      	mov	r2, r3
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
340162f0:	6262      	str	r2, [r4, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
340162f2:	2200      	movs	r2, #0
  nn_instance->exec_state.triggered_events = 0x0;
  nn_instance->exec_state.current_epoch_block_started = false;
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_Init` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340162f4:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
340162f6:	62a2      	str	r2, [r4, #40]	@ 0x28
  nn_instance->exec_state.inference_started = false;
340162f8:	7622      	strb	r2, [r4, #24]
  nn_instance->exec_state.triggered_events = 0x0;
340162fa:	61e2      	str	r2, [r4, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
340162fc:	f884 2020 	strb.w	r2, [r4, #32]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34016300:	b163      	cbz	r3, 3401631c <__LL_ATON_RT_Init_Network+0x4c>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
34016302:	4621      	mov	r1, r4
  }
}
34016304:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
34016308:	2004      	movs	r0, #4
3401630a:	4718      	bx	r3
      list++;
3401630c:	3314      	adds	r3, #20
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401630e:	3201      	adds	r2, #1
34016310:	8a19      	ldrh	r1, [r3, #16]
34016312:	0709      	lsls	r1, r1, #28
34016314:	d5fa      	bpl.n	3401630c <__LL_ATON_RT_Init_Network+0x3c>
34016316:	e7eb      	b.n	340162f0 <__LL_ATON_RT_Init_Network+0x20>
34016318:	2201      	movs	r2, #1
3401631a:	e7f9      	b.n	34016310 <__LL_ATON_RT_Init_Network+0x40>
}
3401631c:	bd10      	pop	{r4, pc}
	...

34016320 <__ll_clear_aton_owner>:

    __ll_current_aton_ip_owner = new_owner;
  }

  static inline void __ll_clear_aton_owner(NN_Instance_TypeDef *current_owner)
  {
34016320:	b508      	push	{r3, lr}
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(current_owner == __ll_current_aton_ip_owner);
34016322:	4b09      	ldr	r3, [pc, #36]	@ (34016348 <__ll_clear_aton_owner+0x28>)
34016324:	681a      	ldr	r2, [r3, #0]
34016326:	4282      	cmp	r2, r0
34016328:	d005      	beq.n	34016336 <__ll_clear_aton_owner+0x16>
3401632a:	2142      	movs	r1, #66	@ 0x42
3401632c:	4b07      	ldr	r3, [pc, #28]	@ (3401634c <__ll_clear_aton_owner+0x2c>)
3401632e:	4a08      	ldr	r2, [pc, #32]	@ (34016350 <__ll_clear_aton_owner+0x30>)

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
34016330:	4808      	ldr	r0, [pc, #32]	@ (34016354 <__ll_clear_aton_owner+0x34>)
34016332:	f001 fb35 	bl	340179a0 <__assert_func>
34016336:	4a08      	ldr	r2, [pc, #32]	@ (34016358 <__ll_clear_aton_owner+0x38>)
34016338:	6812      	ldr	r2, [r2, #0]
3401633a:	b11a      	cbz	r2, 34016344 <__ll_clear_aton_owner+0x24>
3401633c:	2146      	movs	r1, #70	@ 0x46
3401633e:	4b07      	ldr	r3, [pc, #28]	@ (3401635c <__ll_clear_aton_owner+0x3c>)
34016340:	4a03      	ldr	r2, [pc, #12]	@ (34016350 <__ll_clear_aton_owner+0x30>)
34016342:	e7f5      	b.n	34016330 <__ll_clear_aton_owner+0x10>
#endif // NDEBUG

    __ll_current_aton_ip_owner = NULL;
34016344:	601a      	str	r2, [r3, #0]
    LL_ATON_UNLOCK_ATON();
  }
34016346:	bd08      	pop	{r3, pc}
34016348:	340581d8 	.word	0x340581d8
3401634c:	3401d262 	.word	0x3401d262
34016350:	3403c74f 	.word	0x3403c74f
34016354:	3401d28e 	.word	0x3401d28e
34016358:	340581d4 	.word	0x340581d4
3401635c:	3401d2ec 	.word	0x3401d2ec

34016360 <__LL_ATON_RT_SetWaitMask>:
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
  }

  /* set wait mask(s) in interrupt controller */
  static inline void __LL_ATON_RT_SetWaitMask(uint32_t wait_mask)
  {
34016360:	b508      	push	{r3, lr}
#ifndef NDEBUG
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34016362:	4b07      	ldr	r3, [pc, #28]	@ (34016380 <__LL_ATON_RT_SetWaitMask+0x20>)
34016364:	681b      	ldr	r3, [r3, #0]
34016366:	b92b      	cbnz	r3, 34016374 <__LL_ATON_RT_SetWaitMask+0x14>
34016368:	2175      	movs	r1, #117	@ 0x75
3401636a:	4b06      	ldr	r3, [pc, #24]	@ (34016384 <__LL_ATON_RT_SetWaitMask+0x24>)
3401636c:	4a06      	ldr	r2, [pc, #24]	@ (34016388 <__LL_ATON_RT_SetWaitMask+0x28>)
3401636e:	4807      	ldr	r0, [pc, #28]	@ (3401638c <__LL_ATON_RT_SetWaitMask+0x2c>)
34016370:	f001 fb16 	bl	340179a0 <__assert_func>

    extern uint32_t volatile __ll_current_wait_mask;
    __ll_current_wait_mask = wait_mask;
34016374:	4b06      	ldr	r3, [pc, #24]	@ (34016390 <__LL_ATON_RT_SetWaitMask+0x30>)
34016376:	6018      	str	r0, [r3, #0]

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    wait_mask <<= ATON_STRENG_INT(0);
#ifndef LL_ATON_RT_USE_IRQ_OR_MASK
    /* configure interrupt controller AND mask for epoch block */
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
34016378:	43c0      	mvns	r0, r0
3401637a:	4b06      	ldr	r3, [pc, #24]	@ (34016394 <__LL_ATON_RT_SetWaitMask+0x34>)
3401637c:	6258      	str	r0, [r3, #36]	@ 0x24
                                                                // (all other events & errors are enabled)
    val &= ~wait_mask;
    ATON_INTCTRL_STD_INTORMSK_SET(val);
#endif // LL_ATON_RT_USE_IRQ_OR_MASK
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  }
3401637e:	bd08      	pop	{r3, pc}
34016380:	340581d8 	.word	0x340581d8
34016384:	3401d308 	.word	0x3401d308
34016388:	3403c6a2 	.word	0x3403c6a2
3401638c:	3401d28e 	.word	0x3401d28e
34016390:	340581d4 	.word	0x340581d4
34016394:	580e1000 	.word	0x580e1000

34016398 <EpochBlock_EpochControllerUnit>:
  {
    return ((eb->flags & EpochBlock_Flags_internal) != 0);
  }

  static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
  {
34016398:	b508      	push	{r3, lr}
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401639a:	8a03      	ldrh	r3, [r0, #16]
3401639c:	075b      	lsls	r3, r3, #29
3401639e:	d406      	bmi.n	340163ae <EpochBlock_EpochControllerUnit+0x16>
340163a0:	f240 212a 	movw	r1, #554	@ 0x22a
340163a4:	4b03      	ldr	r3, [pc, #12]	@ (340163b4 <EpochBlock_EpochControllerUnit+0x1c>)
340163a6:	4a04      	ldr	r2, [pc, #16]	@ (340163b8 <EpochBlock_EpochControllerUnit+0x20>)
340163a8:	4804      	ldr	r0, [pc, #16]	@ (340163bc <EpochBlock_EpochControllerUnit+0x24>)
340163aa:	f001 faf9 	bl	340179a0 <__assert_func>
    return eb->wait_mask;
  }
340163ae:	68c0      	ldr	r0, [r0, #12]
340163b0:	bd08      	pop	{r3, pc}
340163b2:	bf00      	nop
340163b4:	3401d332 	.word	0x3401d332
340163b8:	3403c683 	.word	0x3403c683
340163bc:	3401d34d 	.word	0x3401d34d

340163c0 <__LL_ATON_RT_ExecEndEpochBlock>:
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340163c0:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
{
340163c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
340163c6:	4605      	mov	r5, r0
340163c8:	460c      	mov	r4, r1
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340163ca:	b113      	cbz	r3, 340163d2 <__LL_ATON_RT_ExecEndEpochBlock+0x12>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_END, nn_instance, eb);
340163cc:	4602      	mov	r2, r0
340163ce:	2002      	movs	r0, #2
340163d0:	4798      	blx	r3
  if (EpochBlock_IsEpochBlob(eb))
340163d2:	8a2b      	ldrh	r3, [r5, #16]
340163d4:	0758      	lsls	r0, r3, #29
340163d6:	d518      	bpl.n	3401640a <__LL_ATON_RT_ExecEndEpochBlock+0x4a>
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
340163d8:	4628      	mov	r0, r5
340163da:	f7ff ffdd 	bl	34016398 <EpochBlock_EpochControllerUnit>
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
340163de:	b128      	cbz	r0, 340163ec <__LL_ATON_RT_ExecEndEpochBlock+0x2c>
340163e0:	21b5      	movs	r1, #181	@ 0xb5
340163e2:	4b25      	ldr	r3, [pc, #148]	@ (34016478 <__LL_ATON_RT_ExecEndEpochBlock+0xb8>)
340163e4:	4a25      	ldr	r2, [pc, #148]	@ (3401647c <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
340163e6:	4826      	ldr	r0, [pc, #152]	@ (34016480 <__LL_ATON_RT_ExecEndEpochBlock+0xc0>)
340163e8:	f001 fada 	bl	340179a0 <__assert_func>
    ATON_DISABLE_CLR_CONFCLR(EPOCHCTRL, ecId);
340163ec:	2202      	movs	r2, #2
340163ee:	4b25      	ldr	r3, [pc, #148]	@ (34016484 <__LL_ATON_RT_ExecEndEpochBlock+0xc4>)
340163f0:	601a      	str	r2, [r3, #0]
340163f2:	681a      	ldr	r2, [r3, #0]
340163f4:	0791      	lsls	r1, r2, #30
340163f6:	d4fc      	bmi.n	340163f2 <__LL_ATON_RT_ExecEndEpochBlock+0x32>
340163f8:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
340163fc:	601a      	str	r2, [r3, #0]
340163fe:	681a      	ldr	r2, [r3, #0]
34016400:	0052      	lsls	r2, r2, #1
34016402:	d4fc      	bmi.n	340163fe <__LL_ATON_RT_ExecEndEpochBlock+0x3e>
    LL_ATON_DisableClock(ATON_EPOCHCTRL_CLKB_CLK(ecId));
34016404:	2019      	movs	r0, #25
34016406:	f7ff ff29 	bl	3401625c <LL_ATON_DisableClock>
  if (eb->end_epoch_block != NULL)
3401640a:	686b      	ldr	r3, [r5, #4]
3401640c:	b10b      	cbz	r3, 34016412 <__LL_ATON_RT_ExecEndEpochBlock+0x52>
    eb->end_epoch_block((const void *)eb);
3401640e:	4628      	mov	r0, r5
34016410:	4798      	blx	r3
    return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
34016412:	8a2e      	ldrh	r6, [r5, #16]
  if (EpochBlock_IsEpochPureHW(eb) ||
34016414:	f016 0f90 	tst.w	r6, #144	@ 0x90
34016418:	f006 07c0 	and.w	r7, r6, #192	@ 0xc0
3401641c:	d108      	bne.n	34016430 <__LL_ATON_RT_ExecEndEpochBlock+0x70>
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401641e:	bb0f      	cbnz	r7, 34016464 <__LL_ATON_RT_ExecEndEpochBlock+0xa4>
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
34016420:	4b19      	ldr	r3, [pc, #100]	@ (34016488 <__LL_ATON_RT_ExecEndEpochBlock+0xc8>)
34016422:	681b      	ldr	r3, [r3, #0]
34016424:	42a3      	cmp	r3, r4
34016426:	d115      	bne.n	34016454 <__LL_ATON_RT_ExecEndEpochBlock+0x94>
34016428:	21d5      	movs	r1, #213	@ 0xd5
3401642a:	4b18      	ldr	r3, [pc, #96]	@ (3401648c <__LL_ATON_RT_ExecEndEpochBlock+0xcc>)
3401642c:	4a13      	ldr	r2, [pc, #76]	@ (3401647c <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
3401642e:	e7da      	b.n	340163e6 <__LL_ATON_RT_ExecEndEpochBlock+0x26>
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
34016430:	4b15      	ldr	r3, [pc, #84]	@ (34016488 <__LL_ATON_RT_ExecEndEpochBlock+0xc8>)
34016432:	681b      	ldr	r3, [r3, #0]
34016434:	42a3      	cmp	r3, r4
34016436:	d003      	beq.n	34016440 <__LL_ATON_RT_ExecEndEpochBlock+0x80>
34016438:	21c9      	movs	r1, #201	@ 0xc9
3401643a:	4b15      	ldr	r3, [pc, #84]	@ (34016490 <__LL_ATON_RT_ExecEndEpochBlock+0xd0>)
3401643c:	4a0f      	ldr	r2, [pc, #60]	@ (3401647c <__LL_ATON_RT_ExecEndEpochBlock+0xbc>)
3401643e:	e7d2      	b.n	340163e6 <__LL_ATON_RT_ExecEndEpochBlock+0x26>
    __LL_ATON_RT_SetWaitMask(0);
34016440:	2000      	movs	r0, #0
34016442:	f7ff ff8d 	bl	34016360 <__LL_ATON_RT_SetWaitMask>
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
34016446:	06f3      	lsls	r3, r6, #27
34016448:	d5e9      	bpl.n	3401641e <__LL_ATON_RT_ExecEndEpochBlock+0x5e>
    __ll_clear_aton_owner(nn_instance);
3401644a:	4620      	mov	r0, r4
3401644c:	f7ff ff68 	bl	34016320 <__ll_clear_aton_owner>
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
34016450:	2f00      	cmp	r7, #0
34016452:	d0e5      	beq.n	34016420 <__LL_ATON_RT_ExecEndEpochBlock+0x60>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34016454:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34016456:	b163      	cbz	r3, 34016472 <__LL_ATON_RT_ExecEndEpochBlock+0xb2>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
34016458:	462a      	mov	r2, r5
3401645a:	4621      	mov	r1, r4
}
3401645c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
34016460:	2003      	movs	r0, #3
34016462:	4718      	bx	r3
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
34016464:	6923      	ldr	r3, [r4, #16]
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
34016466:	2b00      	cmp	r3, #0
34016468:	d1f4      	bne.n	34016454 <__LL_ATON_RT_ExecEndEpochBlock+0x94>
                                       (nn_instance->exec_state.next_epoch_block ==
3401646a:	68e3      	ldr	r3, [r4, #12]
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401646c:	2b00      	cmp	r3, #0
3401646e:	d1f1      	bne.n	34016454 <__LL_ATON_RT_ExecEndEpochBlock+0x94>
34016470:	e7eb      	b.n	3401644a <__LL_ATON_RT_ExecEndEpochBlock+0x8a>
}
34016472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34016476:	bf00      	nop
34016478:	3401d3b0 	.word	0x3401d3b0
3401647c:	3403c664 	.word	0x3403c664
34016480:	3401d3b9 	.word	0x3401d3b9
34016484:	580fe000 	.word	0x580fe000
34016488:	340581d8 	.word	0x340581d8
3401648c:	3401d441 	.word	0x3401d441
34016490:	3401d417 	.word	0x3401d417

34016494 <__LL_ATON_RT_DetermineNextEpochBlock>:
{
34016494:	b508      	push	{r3, lr}
  LL_ATON_ASSERT(nn_instance != NULL);
34016496:	b928      	cbnz	r0, 340164a4 <__LL_ATON_RT_DetermineNextEpochBlock+0x10>
34016498:	21e0      	movs	r1, #224	@ 0xe0
3401649a:	4b19      	ldr	r3, [pc, #100]	@ (34016500 <__LL_ATON_RT_DetermineNextEpochBlock+0x6c>)
3401649c:	4a19      	ldr	r2, [pc, #100]	@ (34016504 <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
  LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401649e:	481a      	ldr	r0, [pc, #104]	@ (34016508 <__LL_ATON_RT_DetermineNextEpochBlock+0x74>)
340164a0:	f001 fa7e 	bl	340179a0 <__assert_func>
340164a4:	69c3      	ldr	r3, [r0, #28]
340164a6:	b11b      	cbz	r3, 340164b0 <__LL_ATON_RT_DetermineNextEpochBlock+0x1c>
340164a8:	21e2      	movs	r1, #226	@ 0xe2
340164aa:	4b18      	ldr	r3, [pc, #96]	@ (3401650c <__LL_ATON_RT_DetermineNextEpochBlock+0x78>)
340164ac:	4a15      	ldr	r2, [pc, #84]	@ (34016504 <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
340164ae:	e7f6      	b.n	3401649e <__LL_ATON_RT_DetermineNextEpochBlock+0xa>
  if ((nn_instance->exec_state.next_epoch_block != NULL))
340164b0:	68c3      	ldr	r3, [r0, #12]
340164b2:	b30b      	cbz	r3, 340164f8 <__LL_ATON_RT_DetermineNextEpochBlock+0x64>
    LL_ATON_ASSERT(nn_instance->exec_state.saved_current_epoch_block == NULL);
340164b4:	6903      	ldr	r3, [r0, #16]
340164b6:	b11b      	cbz	r3, 340164c0 <__LL_ATON_RT_DetermineNextEpochBlock+0x2c>
340164b8:	21ea      	movs	r1, #234	@ 0xea
340164ba:	4b15      	ldr	r3, [pc, #84]	@ (34016510 <__LL_ATON_RT_DetermineNextEpochBlock+0x7c>)
340164bc:	4a11      	ldr	r2, [pc, #68]	@ (34016504 <__LL_ATON_RT_DetermineNextEpochBlock+0x70>)
340164be:	e7ee      	b.n	3401649e <__LL_ATON_RT_DetermineNextEpochBlock+0xa>
    nn_instance->exec_state.saved_current_epoch_block = nn_instance->exec_state.current_epoch_block;
340164c0:	6843      	ldr	r3, [r0, #4]
340164c2:	6103      	str	r3, [r0, #16]
    nn_instance->exec_state.saved_first_epoch_block = nn_instance->exec_state.first_epoch_block;
340164c4:	6883      	ldr	r3, [r0, #8]
340164c6:	6143      	str	r3, [r0, #20]
    nn_instance->exec_state.saved_nr_of_epoch_blocks = nn_instance->exec_state.nr_of_epoch_blocks;
340164c8:	6a43      	ldr	r3, [r0, #36]	@ 0x24
340164ca:	6283      	str	r3, [r0, #40]	@ 0x28
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.next_epoch_block;
340164cc:	68c3      	ldr	r3, [r0, #12]
340164ce:	6043      	str	r3, [r0, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.next_epoch_block;
340164d0:	68c3      	ldr	r3, [r0, #12]
340164d2:	6083      	str	r3, [r0, #8]
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
340164d4:	6883      	ldr	r3, [r0, #8]
  if (list != NULL)
340164d6:	b96b      	cbnz	r3, 340164f4 <__LL_ATON_RT_DetermineNextEpochBlock+0x60>
  int i = 0;
340164d8:	461a      	mov	r2, r3
    nn_instance->exec_state.next_epoch_block = NULL;
340164da:	2300      	movs	r3, #0
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
340164dc:	6242      	str	r2, [r0, #36]	@ 0x24
    nn_instance->exec_state.next_epoch_block = NULL;
340164de:	60c3      	str	r3, [r0, #12]
  nn_instance->exec_state.current_epoch_block_started = false;
340164e0:	2300      	movs	r3, #0
340164e2:	f880 3020 	strb.w	r3, [r0, #32]
}
340164e6:	bd08      	pop	{r3, pc}
      list++;
340164e8:	3314      	adds	r3, #20
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
340164ea:	3201      	adds	r2, #1
340164ec:	8a19      	ldrh	r1, [r3, #16]
340164ee:	0709      	lsls	r1, r1, #28
340164f0:	d5fa      	bpl.n	340164e8 <__LL_ATON_RT_DetermineNextEpochBlock+0x54>
340164f2:	e7f2      	b.n	340164da <__LL_ATON_RT_DetermineNextEpochBlock+0x46>
340164f4:	2201      	movs	r2, #1
340164f6:	e7f9      	b.n	340164ec <__LL_ATON_RT_DetermineNextEpochBlock+0x58>
    nn_instance->exec_state.current_epoch_block++;
340164f8:	6843      	ldr	r3, [r0, #4]
340164fa:	3314      	adds	r3, #20
340164fc:	6043      	str	r3, [r0, #4]
340164fe:	e7ef      	b.n	340164e0 <__LL_ATON_RT_DetermineNextEpochBlock+0x4c>
34016500:	3401d4af 	.word	0x3401d4af
34016504:	3403c63f 	.word	0x3403c63f
34016508:	3401d3b9 	.word	0x3401d3b9
3401650c:	3401d4ca 	.word	0x3401d4ca
34016510:	3401d4fa 	.word	0x3401d4fa

34016514 <dump_dma_state>:
LL_ATON_WEAK void dump_dma_state(void){};
34016514:	4770      	bx	lr
	...

34016518 <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
34016518:	b538      	push	{r3, r4, r5, lr}
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
3401651a:	4604      	mov	r4, r0
3401651c:	2800      	cmp	r0, #0
3401651e:	d056      	beq.n	340165ce <__LL_ATON_RT_IrqErr+0xb6>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
34016520:	4b2b      	ldr	r3, [pc, #172]	@ (340165d0 <__LL_ATON_RT_IrqErr+0xb8>)
34016522:	4218      	tst	r0, r3
34016524:	d002      	beq.n	3401652c <__LL_ATON_RT_IrqErr+0x14>
  {
    LL_ATON_PRINTF("Streaming engine error interrupt\n");
34016526:	482b      	ldr	r0, [pc, #172]	@ (340165d4 <__LL_ATON_RT_IrqErr+0xbc>)
34016528:	f002 fa30 	bl	3401898c <puts>
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
3401652c:	f3c4 0309 	ubfx	r3, r4, #0, #10
34016530:	b113      	cbz	r3, 34016538 <__LL_ATON_RT_IrqErr+0x20>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
34016532:	4829      	ldr	r0, [pc, #164]	@ (340165d8 <__LL_ATON_RT_IrqErr+0xc0>)
34016534:	f002 fa2a 	bl	3401898c <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
34016538:	f414 0f70 	tst.w	r4, #15728640	@ 0xf00000
3401653c:	d002      	beq.n	34016544 <__LL_ATON_RT_IrqErr+0x2c>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
3401653e:	4827      	ldr	r0, [pc, #156]	@ (340165dc <__LL_ATON_RT_IrqErr+0xc4>)
34016540:	f002 fa24 	bl	3401898c <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
34016544:	01e5      	lsls	r5, r4, #7
34016546:	d502      	bpl.n	3401654e <__LL_ATON_RT_IrqErr+0x36>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
34016548:	4825      	ldr	r0, [pc, #148]	@ (340165e0 <__LL_ATON_RT_IrqErr+0xc8>)
3401654a:	f002 fa1f 	bl	3401898c <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
3401654e:	f014 6fc0 	tst.w	r4, #100663296	@ 0x6000000
34016552:	d00e      	beq.n	34016572 <__LL_ATON_RT_IrqErr+0x5a>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
34016554:	4823      	ldr	r0, [pc, #140]	@ (340165e4 <__LL_ATON_RT_IrqErr+0xcc>)
34016556:	f002 fa19 	bl	3401898c <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
3401655a:	4b23      	ldr	r3, [pc, #140]	@ (340165e8 <__LL_ATON_RT_IrqErr+0xd0>)
3401655c:	2100      	movs	r1, #0
3401655e:	691a      	ldr	r2, [r3, #16]
34016560:	4822      	ldr	r0, [pc, #136]	@ (340165ec <__LL_ATON_RT_IrqErr+0xd4>)
34016562:	f002 f9ab 	bl	340188bc <iprintf>
34016566:	4b22      	ldr	r3, [pc, #136]	@ (340165f0 <__LL_ATON_RT_IrqErr+0xd8>)
34016568:	2101      	movs	r1, #1
3401656a:	691a      	ldr	r2, [r3, #16]
3401656c:	481f      	ldr	r0, [pc, #124]	@ (340165ec <__LL_ATON_RT_IrqErr+0xd4>)
3401656e:	f002 f9a5 	bl	340188bc <iprintf>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
34016572:	0120      	lsls	r0, r4, #4
34016574:	d502      	bpl.n	3401657c <__LL_ATON_RT_IrqErr+0x64>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
34016576:	481f      	ldr	r0, [pc, #124]	@ (340165f4 <__LL_ATON_RT_IrqErr+0xdc>)
34016578:	f002 fa08 	bl	3401898c <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
3401657c:	0061      	lsls	r1, r4, #1
3401657e:	d50c      	bpl.n	3401659a <__LL_ATON_RT_IrqErr+0x82>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
34016580:	4d1d      	ldr	r5, [pc, #116]	@ (340165f8 <__LL_ATON_RT_IrqErr+0xe0>)
34016582:	481e      	ldr	r0, [pc, #120]	@ (340165fc <__LL_ATON_RT_IrqErr+0xe4>)
34016584:	68e9      	ldr	r1, [r5, #12]
34016586:	f002 f999 	bl	340188bc <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
3401658a:	6a29      	ldr	r1, [r5, #32]
3401658c:	481c      	ldr	r0, [pc, #112]	@ (34016600 <__LL_ATON_RT_IrqErr+0xe8>)
3401658e:	f002 f995 	bl	340188bc <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
34016592:	69e9      	ldr	r1, [r5, #28]
34016594:	481b      	ldr	r0, [pc, #108]	@ (34016604 <__LL_ATON_RT_IrqErr+0xec>)
34016596:	f002 f991 	bl	340188bc <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
3401659a:	00a2      	lsls	r2, r4, #2
3401659c:	d502      	bpl.n	340165a4 <__LL_ATON_RT_IrqErr+0x8c>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
3401659e:	481a      	ldr	r0, [pc, #104]	@ (34016608 <__LL_ATON_RT_IrqErr+0xf0>)
340165a0:	f002 f9f4 	bl	3401898c <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
340165a4:	00e3      	lsls	r3, r4, #3
340165a6:	d502      	bpl.n	340165ae <__LL_ATON_RT_IrqErr+0x96>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
340165a8:	4818      	ldr	r0, [pc, #96]	@ (3401660c <__LL_ATON_RT_IrqErr+0xf4>)
340165aa:	f002 f9ef 	bl	3401898c <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
340165ae:	f7ff ffb1 	bl	34016514 <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
340165b2:	4622      	mov	r2, r4
340165b4:	2300      	movs	r3, #0
340165b6:	f240 21fb 	movw	r1, #763	@ 0x2fb
340165ba:	4815      	ldr	r0, [pc, #84]	@ (34016610 <__LL_ATON_RT_IrqErr+0xf8>)
340165bc:	f002 f97e 	bl	340188bc <iprintf>
#if (LL_ATON_HAVE_FFLUSH)
  LL_ATON_FFLUSH(stdout);
#endif
  LL_ATON_ASSERT(false); // may never happen
340165c0:	f240 21ff 	movw	r1, #767	@ 0x2ff
340165c4:	4b13      	ldr	r3, [pc, #76]	@ (34016614 <__LL_ATON_RT_IrqErr+0xfc>)
340165c6:	4a14      	ldr	r2, [pc, #80]	@ (34016618 <__LL_ATON_RT_IrqErr+0x100>)
340165c8:	4814      	ldr	r0, [pc, #80]	@ (3401661c <__LL_ATON_RT_IrqErr+0x104>)
340165ca:	f001 f9e9 	bl	340179a0 <__assert_func>
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
340165ce:	bd38      	pop	{r3, r4, r5, pc}
340165d0:	000ffc00 	.word	0x000ffc00
340165d4:	3401d53b 	.word	0x3401d53b
340165d8:	3401d55c 	.word	0x3401d55c
340165dc:	3401d582 	.word	0x3401d582
340165e0:	3401d5a6 	.word	0x3401d5a6
340165e4:	3401d5c6 	.word	0x3401d5c6
340165e8:	580e2000 	.word	0x580e2000
340165ec:	3401d5de 	.word	0x3401d5de
340165f0:	580e3000 	.word	0x580e3000
340165f4:	3401d5f3 	.word	0x3401d5f3
340165f8:	580fe000 	.word	0x580fe000
340165fc:	3401d60b 	.word	0x3401d60b
34016600:	3401d63f 	.word	0x3401d63f
34016604:	3401d669 	.word	0x3401d669
34016608:	3401d68a 	.word	0x3401d68a
3401660c:	3401d6ab 	.word	0x3401d6ab
34016610:	3401d6c6 	.word	0x3401d6c6
34016614:	3401d306 	.word	0x3401d306
34016618:	3403c61b 	.word	0x3403c61b
3401661c:	3401d3b9 	.word	0x3401d3b9

34016620 <LL_ATON_RT_Init_Network>:
{
34016620:	b510      	push	{r4, lr}
  if (nn_instance == NULL)
34016622:	4604      	mov	r4, r0
34016624:	b1b0      	cbz	r0, 34016654 <LL_ATON_RT_Init_Network+0x34>
  if (nn_instance->network == NULL)
34016626:	6803      	ldr	r3, [r0, #0]
34016628:	b1a3      	cbz	r3, 34016654 <LL_ATON_RT_Init_Network+0x34>
  LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
3401662a:	685b      	ldr	r3, [r3, #4]
3401662c:	b933      	cbnz	r3, 3401663c <LL_ATON_RT_Init_Network+0x1c>
3401662e:	f44f 71bb 	mov.w	r1, #374	@ 0x176
34016632:	4b09      	ldr	r3, [pc, #36]	@ (34016658 <LL_ATON_RT_Init_Network+0x38>)
34016634:	4a09      	ldr	r2, [pc, #36]	@ (3401665c <LL_ATON_RT_Init_Network+0x3c>)
  LL_ATON_ASSERT(ret == true);
34016636:	480a      	ldr	r0, [pc, #40]	@ (34016660 <LL_ATON_RT_Init_Network+0x40>)
34016638:	f001 f9b2 	bl	340179a0 <__assert_func>
  bool ret = nn_instance->network->ec_network_init();
3401663c:	4798      	blx	r3
  LL_ATON_ASSERT(ret == true);
3401663e:	b920      	cbnz	r0, 3401664a <LL_ATON_RT_Init_Network+0x2a>
34016640:	f44f 71bc 	mov.w	r1, #376	@ 0x178
34016644:	4b07      	ldr	r3, [pc, #28]	@ (34016664 <LL_ATON_RT_Init_Network+0x44>)
34016646:	4a05      	ldr	r2, [pc, #20]	@ (3401665c <LL_ATON_RT_Init_Network+0x3c>)
34016648:	e7f5      	b.n	34016636 <LL_ATON_RT_Init_Network+0x16>
  __LL_ATON_RT_Init_Network(nn_instance);
3401664a:	4620      	mov	r0, r4
}
3401664c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __LL_ATON_RT_Init_Network(nn_instance);
34016650:	f7ff be3e 	b.w	340162d0 <__LL_ATON_RT_Init_Network>
}
34016654:	bd10      	pop	{r4, pc}
34016656:	bf00      	nop
34016658:	3401d6ed 	.word	0x3401d6ed
3401665c:	3403c765 	.word	0x3403c765
34016660:	3401d3b9 	.word	0x3401d3b9
34016664:	3401d722 	.word	0x3401d722

34016668 <LL_ATON_RT_DeInit_Network>:
{
34016668:	b510      	push	{r4, lr}
  if (nn_instance == NULL)
3401666a:	4604      	mov	r4, r0
3401666c:	b1b8      	cbz	r0, 3401669e <LL_ATON_RT_DeInit_Network+0x36>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401666e:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
34016670:	b11b      	cbz	r3, 3401667a <LL_ATON_RT_DeInit_Network+0x12>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_DeInit, nn_instance, NULL);
34016672:	4601      	mov	r1, r0
34016674:	2200      	movs	r2, #0
34016676:	2005      	movs	r0, #5
34016678:	4798      	blx	r3
  if (nn_instance == __ll_current_aton_ip_owner)
3401667a:	4b09      	ldr	r3, [pc, #36]	@ (340166a0 <LL_ATON_RT_DeInit_Network+0x38>)
3401667c:	681b      	ldr	r3, [r3, #0]
3401667e:	42a3      	cmp	r3, r4
34016680:	d102      	bne.n	34016688 <LL_ATON_RT_DeInit_Network+0x20>
    __ll_clear_aton_owner(nn_instance);
34016682:	4620      	mov	r0, r4
34016684:	f7ff fe4c 	bl	34016320 <__ll_clear_aton_owner>
  nn_instance->exec_state.current_epoch_block = eb_list;
34016688:	2300      	movs	r3, #0
3401668a:	6063      	str	r3, [r4, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401668c:	60a3      	str	r3, [r4, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401668e:	60e3      	str	r3, [r4, #12]
  nn_instance->exec_state.saved_current_epoch_block = NULL;
34016690:	6123      	str	r3, [r4, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
34016692:	6163      	str	r3, [r4, #20]
  nn_instance->exec_state.nr_of_epoch_blocks = 0;
34016694:	6263      	str	r3, [r4, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
34016696:	62a3      	str	r3, [r4, #40]	@ 0x28
  nn_instance->exec_state.triggered_events = 0x0;
34016698:	61e3      	str	r3, [r4, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401669a:	f884 3020 	strb.w	r3, [r4, #32]
}
3401669e:	bd10      	pop	{r4, pc}
340166a0:	340581d8 	.word	0x340581d8

340166a4 <LL_ATON_RT_RuntimeInit>:
{
340166a4:	b510      	push	{r4, lr}
  LL_ATON_Init();
340166a6:	f7ff faff 	bl	34015ca8 <LL_ATON_Init>
    ATON_DISABLE_CLR_CONFCLR(INTCTRL, 0);
340166aa:	2202      	movs	r2, #2
340166ac:	4b1f      	ldr	r3, [pc, #124]	@ (3401672c <LL_ATON_RT_RuntimeInit+0x88>)
340166ae:	601a      	str	r2, [r3, #0]
340166b0:	681a      	ldr	r2, [r3, #0]
340166b2:	0791      	lsls	r1, r2, #30
340166b4:	d4fc      	bmi.n	340166b0 <LL_ATON_RT_RuntimeInit+0xc>
340166b6:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
340166ba:	601a      	str	r2, [r3, #0]
340166bc:	681a      	ldr	r2, [r3, #0]
340166be:	0052      	lsls	r2, r2, #1
340166c0:	d4fc      	bmi.n	340166bc <LL_ATON_RT_RuntimeInit+0x18>
    ATON_INTCTRL_STD_INTORMSK_SET(ATON_STRENG_INT_MASK(
340166c2:	f240 32ff 	movw	r2, #1023	@ 0x3ff
340166c6:	615a      	str	r2, [r3, #20]
    ATON_INTCTRL_STD_INTANDMSK_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
340166c8:	f04f 32ff 	mov.w	r2, #4294967295
340166cc:	625a      	str	r2, [r3, #36]	@ 0x24
    ATON_ENABLE(INTCTRL, 0);
340166ce:	681a      	ldr	r2, [r3, #0]
340166d0:	f042 0201 	orr.w	r2, r2, #1
340166d4:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340166d6:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
340166da:	4b15      	ldr	r3, [pc, #84]	@ (34016730 <LL_ATON_RT_RuntimeInit+0x8c>)
340166dc:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340166e0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340166e4:	f3bf 8f6f 	isb	sy
340166e8:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
340166ec:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340166f0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
340166f4:	f3bf 8f6f 	isb	sy
340166f8:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
340166fc:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016700:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016704:	f3bf 8f6f 	isb	sy
34016708:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
3401670c:	f8c3 1084 	str.w	r1, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016710:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016714:	f3bf 8f6f 	isb	sy
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34016718:	605a      	str	r2, [r3, #4]
  if (ll_aton_init_deinit_trace)
3401671a:	4b06      	ldr	r3, [pc, #24]	@ (34016734 <LL_ATON_RT_RuntimeInit+0x90>)
3401671c:	681b      	ldr	r3, [r3, #0]
3401671e:	b11b      	cbz	r3, 34016728 <LL_ATON_RT_RuntimeInit+0x84>
}
34016720:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Init);
34016724:	2006      	movs	r0, #6
34016726:	4718      	bx	r3
}
34016728:	bd10      	pop	{r4, pc}
3401672a:	bf00      	nop
3401672c:	580e1000 	.word	0x580e1000
34016730:	e000e100 	.word	0xe000e100
34016734:	340581d0 	.word	0x340581d0

34016738 <LL_ATON_RT_RuntimeDeInit>:
{
34016738:	b508      	push	{r3, lr}
  if (ll_aton_init_deinit_trace)
3401673a:	4b15      	ldr	r3, [pc, #84]	@ (34016790 <LL_ATON_RT_RuntimeDeInit+0x58>)
3401673c:	681b      	ldr	r3, [r3, #0]
3401673e:	b10b      	cbz	r3, 34016744 <LL_ATON_RT_RuntimeDeInit+0xc>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Deinit);
34016740:	2007      	movs	r0, #7
34016742:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34016744:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34016748:	4b12      	ldr	r3, [pc, #72]	@ (34016794 <LL_ATON_RT_RuntimeDeInit+0x5c>)
3401674a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
3401674e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016752:	f3bf 8f6f 	isb	sy
34016756:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
3401675a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
3401675e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016762:	f3bf 8f6f 	isb	sy
34016766:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3401676a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
3401676e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016772:	f3bf 8f6f 	isb	sy
34016776:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3401677a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
3401677e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016782:	f3bf 8f6f 	isb	sy
}
34016786:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LL_ATON_DeInit();
3401678a:	f7ff bd29 	b.w	340161e0 <LL_ATON_DeInit>
3401678e:	bf00      	nop
34016790:	340581d0 	.word	0x340581d0
34016794:	e000e100 	.word	0xe000e100

34016798 <LL_ATON_RT_RunEpochBlock>:
{
34016798:	b573      	push	{r0, r1, r4, r5, r6, lr}
  LL_ATON_ASSERT(nn_instance != NULL);
3401679a:	4604      	mov	r4, r0
3401679c:	b930      	cbnz	r0, 340167ac <LL_ATON_RT_RunEpochBlock+0x14>
3401679e:	f240 210f 	movw	r1, #527	@ 0x20f
340167a2:	4b8c      	ldr	r3, [pc, #560]	@ (340169d4 <LL_ATON_RT_RunEpochBlock+0x23c>)
340167a4:	4a8c      	ldr	r2, [pc, #560]	@ (340169d8 <LL_ATON_RT_RunEpochBlock+0x240>)
  LL_ATON_ASSERT(nn_instance->exec_state.current_epoch_block != NULL); // should never happen
340167a6:	488d      	ldr	r0, [pc, #564]	@ (340169dc <LL_ATON_RT_RunEpochBlock+0x244>)
340167a8:	f001 f8fa 	bl	340179a0 <__assert_func>
340167ac:	6843      	ldr	r3, [r0, #4]
340167ae:	b923      	cbnz	r3, 340167ba <LL_ATON_RT_RunEpochBlock+0x22>
340167b0:	f240 2112 	movw	r1, #530	@ 0x212
340167b4:	4b8a      	ldr	r3, [pc, #552]	@ (340169e0 <LL_ATON_RT_RunEpochBlock+0x248>)
340167b6:	4a88      	ldr	r2, [pc, #544]	@ (340169d8 <LL_ATON_RT_RunEpochBlock+0x240>)
340167b8:	e7f5      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
  if (nn_instance->exec_state.inference_started == false)
340167ba:	7e03      	ldrb	r3, [r0, #24]
340167bc:	b98b      	cbnz	r3, 340167e2 <LL_ATON_RT_RunEpochBlock+0x4a>
    LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
340167be:	6803      	ldr	r3, [r0, #0]
340167c0:	b10b      	cbz	r3, 340167c6 <LL_ATON_RT_RunEpochBlock+0x2e>
340167c2:	689b      	ldr	r3, [r3, #8]
340167c4:	b923      	cbnz	r3, 340167d0 <LL_ATON_RT_RunEpochBlock+0x38>
340167c6:	f44f 7106 	mov.w	r1, #536	@ 0x218
340167ca:	4b86      	ldr	r3, [pc, #536]	@ (340169e4 <LL_ATON_RT_RunEpochBlock+0x24c>)
340167cc:	4a82      	ldr	r2, [pc, #520]	@ (340169d8 <LL_ATON_RT_RunEpochBlock+0x240>)
340167ce:	e7ea      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
    bool ret = nn_instance->network->ec_inference_init();
340167d0:	4798      	blx	r3
    LL_ATON_ASSERT(ret == true);
340167d2:	b920      	cbnz	r0, 340167de <LL_ATON_RT_RunEpochBlock+0x46>
340167d4:	f240 211a 	movw	r1, #538	@ 0x21a
340167d8:	4b83      	ldr	r3, [pc, #524]	@ (340169e8 <LL_ATON_RT_RunEpochBlock+0x250>)
340167da:	4a7f      	ldr	r2, [pc, #508]	@ (340169d8 <LL_ATON_RT_RunEpochBlock+0x240>)
340167dc:	e7e3      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
    nn_instance->exec_state.inference_started = true;
340167de:	2301      	movs	r3, #1
340167e0:	7623      	strb	r3, [r4, #24]
    uint32_t _wait_mask = __LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block);
340167e2:	6860      	ldr	r0, [r4, #4]
  if (EpochBlock_IsEpochBlob(eb))
340167e4:	8a03      	ldrh	r3, [r0, #16]
340167e6:	075a      	lsls	r2, r3, #29
340167e8:	d512      	bpl.n	34016810 <LL_ATON_RT_RunEpochBlock+0x78>
    return (1 << EpochBlock_EpochControllerUnit(eb));
340167ea:	f7ff fdd5 	bl	34016398 <EpochBlock_EpochControllerUnit>
340167ee:	2301      	movs	r3, #1
340167f0:	fa03 f000 	lsl.w	r0, r3, r0
    if (nn_instance->exec_state.current_epoch_block_started && (_wait_mask != 0))
340167f4:	f894 3020 	ldrb.w	r3, [r4, #32]
340167f8:	f003 06ff 	and.w	r6, r3, #255	@ 0xff
340167fc:	b343      	cbz	r3, 34016850 <LL_ATON_RT_RunEpochBlock+0xb8>
340167fe:	2800      	cmp	r0, #0
34016800:	d036      	beq.n	34016870 <LL_ATON_RT_RunEpochBlock+0xd8>
      if ((nn_instance->exec_state.triggered_events & _wait_mask) == _wait_mask)
34016802:	69e3      	ldr	r3, [r4, #28]
34016804:	ea30 0303 	bics.w	r3, r0, r3
34016808:	d004      	beq.n	34016814 <LL_ATON_RT_RunEpochBlock+0x7c>
        return LL_ATON_RT_WFE;
3401680a:	2001      	movs	r0, #1
}
3401680c:	b002      	add	sp, #8
3401680e:	bd70      	pop	{r4, r5, r6, pc}
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
34016810:	68c0      	ldr	r0, [r0, #12]
34016812:	e7ef      	b.n	340167f4 <LL_ATON_RT_RunEpochBlock+0x5c>
        LL_ATON_ASSERT(__ll_current_aton_ip_owner ==
34016814:	4b75      	ldr	r3, [pc, #468]	@ (340169ec <LL_ATON_RT_RunEpochBlock+0x254>)
34016816:	681b      	ldr	r3, [r3, #0]
34016818:	42a3      	cmp	r3, r4
3401681a:	d004      	beq.n	34016826 <LL_ATON_RT_RunEpochBlock+0x8e>
3401681c:	f240 2132 	movw	r1, #562	@ 0x232
34016820:	4b73      	ldr	r3, [pc, #460]	@ (340169f0 <LL_ATON_RT_RunEpochBlock+0x258>)
34016822:	4a6d      	ldr	r2, [pc, #436]	@ (340169d8 <LL_ATON_RT_RunEpochBlock+0x240>)
34016824:	e7bf      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
34016826:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
3401682a:	4a72      	ldr	r2, [pc, #456]	@ (340169f4 <LL_ATON_RT_RunEpochBlock+0x25c>)
3401682c:	f8c2 1084 	str.w	r1, [r2, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34016830:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
34016834:	f3bf 8f6f 	isb	sy
        nn_instance->exec_state.triggered_events &= ~_wait_mask;
34016838:	69e3      	ldr	r3, [r4, #28]
3401683a:	ea23 0300 	bic.w	r3, r3, r0
3401683e:	61e3      	str	r3, [r4, #28]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34016840:	6051      	str	r1, [r2, #4]
        __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
34016842:	6860      	ldr	r0, [r4, #4]
34016844:	4621      	mov	r1, r4
34016846:	f7ff fdbb 	bl	340163c0 <__LL_ATON_RT_ExecEndEpochBlock>
        __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401684a:	4620      	mov	r0, r4
3401684c:	f7ff fe22 	bl	34016494 <__LL_ATON_RT_DetermineNextEpochBlock>
    if (EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block))
34016850:	6863      	ldr	r3, [r4, #4]
34016852:	8a1b      	ldrh	r3, [r3, #16]
34016854:	071b      	lsls	r3, r3, #28
34016856:	d534      	bpl.n	340168c2 <LL_ATON_RT_RunEpochBlock+0x12a>
      if (nn_instance->exec_state.saved_current_epoch_block != NULL)
34016858:	6923      	ldr	r3, [r4, #16]
3401685a:	2b00      	cmp	r3, #0
3401685c:	f000 80b7 	beq.w	340169ce <LL_ATON_RT_RunEpochBlock+0x236>
      LL_ATON_ASSERT(nn_instance == NULL);

      nn_instance = __ll_current_aton_ip_owner;
    }

    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34016860:	4b62      	ldr	r3, [pc, #392]	@ (340169ec <LL_ATON_RT_RunEpochBlock+0x254>)
34016862:	681a      	ldr	r2, [r3, #0]
34016864:	b932      	cbnz	r2, 34016874 <LL_ATON_RT_RunEpochBlock+0xdc>
34016866:	2197      	movs	r1, #151	@ 0x97
34016868:	4b63      	ldr	r3, [pc, #396]	@ (340169f8 <LL_ATON_RT_RunEpochBlock+0x260>)
3401686a:	4a64      	ldr	r2, [pc, #400]	@ (340169fc <LL_ATON_RT_RunEpochBlock+0x264>)
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401686c:	4864      	ldr	r0, [pc, #400]	@ (34016a00 <LL_ATON_RT_RunEpochBlock+0x268>)
3401686e:	e79b      	b.n	340167a8 <LL_ATON_RT_RunEpochBlock+0x10>
  bool this_run_executed_end_epoch = false;
34016870:	4606      	mov	r6, r0
34016872:	e7ed      	b.n	34016850 <LL_ATON_RT_RunEpochBlock+0xb8>
    LL_ATON_ASSERT(unlock ? EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block)
34016874:	6862      	ldr	r2, [r4, #4]
34016876:	8a12      	ldrh	r2, [r2, #16]
34016878:	0716      	lsls	r6, r2, #28
3401687a:	d403      	bmi.n	34016884 <LL_ATON_RT_RunEpochBlock+0xec>
3401687c:	2198      	movs	r1, #152	@ 0x98
3401687e:	4b61      	ldr	r3, [pc, #388]	@ (34016a04 <LL_ATON_RT_RunEpochBlock+0x26c>)
34016880:	4a5e      	ldr	r2, [pc, #376]	@ (340169fc <LL_ATON_RT_RunEpochBlock+0x264>)
34016882:	e7f3      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>
                          : EpochBlock_IsEpochInternal(nn_instance->exec_state.current_epoch_block));
    LL_ATON_ASSERT(EpochBlock_IsEpochHybrid(nn_instance->exec_state.saved_current_epoch_block));
34016884:	6922      	ldr	r2, [r4, #16]
34016886:	8a12      	ldrh	r2, [r2, #16]
34016888:	0655      	lsls	r5, r2, #25
3401688a:	d403      	bmi.n	34016894 <LL_ATON_RT_RunEpochBlock+0xfc>
3401688c:	219a      	movs	r1, #154	@ 0x9a
3401688e:	4b5e      	ldr	r3, [pc, #376]	@ (34016a08 <LL_ATON_RT_RunEpochBlock+0x270>)
34016890:	4a5a      	ldr	r2, [pc, #360]	@ (340169fc <LL_ATON_RT_RunEpochBlock+0x264>)
34016892:	e7eb      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>

    /* Clear owner */
    if (unlock)
    {
      __ll_clear_aton_owner(__ll_current_aton_ip_owner);
34016894:	6818      	ldr	r0, [r3, #0]
34016896:	f7ff fd43 	bl	34016320 <__ll_clear_aton_owner>
    }

    /* set old context */
    LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401689a:	68e3      	ldr	r3, [r4, #12]
3401689c:	b11b      	cbz	r3, 340168a6 <LL_ATON_RT_RunEpochBlock+0x10e>
3401689e:	21a3      	movs	r1, #163	@ 0xa3
340168a0:	4b5a      	ldr	r3, [pc, #360]	@ (34016a0c <LL_ATON_RT_RunEpochBlock+0x274>)
340168a2:	4a56      	ldr	r2, [pc, #344]	@ (340169fc <LL_ATON_RT_RunEpochBlock+0x264>)
340168a4:	e7e2      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.saved_current_epoch_block;
340168a6:	6922      	ldr	r2, [r4, #16]
340168a8:	6062      	str	r2, [r4, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.saved_first_epoch_block;
340168aa:	6962      	ldr	r2, [r4, #20]
340168ac:	60a2      	str	r2, [r4, #8]

#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = nn_instance->exec_state.saved_nr_of_epoch_blocks;
340168ae:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
340168b0:	6262      	str	r2, [r4, #36]	@ 0x24
#endif

    /* reset saved context */
    nn_instance->exec_state.saved_current_epoch_block = NULL;
340168b2:	6123      	str	r3, [r4, #16]
    nn_instance->exec_state.saved_first_epoch_block = NULL;
340168b4:	6163      	str	r3, [r4, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
340168b6:	62a3      	str	r3, [r4, #40]	@ 0x28
        nn_instance->exec_state.current_epoch_block++;
340168b8:	6863      	ldr	r3, [r4, #4]
340168ba:	3314      	adds	r3, #20
340168bc:	6063      	str	r3, [r4, #4]
        return LL_ATON_RT_NO_WFE;
340168be:	2000      	movs	r0, #0
340168c0:	e7a4      	b.n	3401680c <LL_ATON_RT_RunEpochBlock+0x74>
    if (this_run_executed_end_epoch)
340168c2:	2e00      	cmp	r6, #0
340168c4:	d1fb      	bne.n	340168be <LL_ATON_RT_RunEpochBlock+0x126>
    if (!nn_instance->exec_state.current_epoch_block_started)
340168c6:	f894 3020 	ldrb.w	r3, [r4, #32]
340168ca:	2b00      	cmp	r3, #0
340168cc:	d169      	bne.n	340169a2 <LL_ATON_RT_RunEpochBlock+0x20a>
      nn_instance->exec_state.current_epoch_block_started = true;
340168ce:	2301      	movs	r3, #1
340168d0:	f884 3020 	strb.w	r3, [r4, #32]
      __LL_ATON_RT_ExecStartEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
340168d4:	6865      	ldr	r5, [r4, #4]
  LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
340168d6:	68e3      	ldr	r3, [r4, #12]
340168d8:	b11b      	cbz	r3, 340168e2 <LL_ATON_RT_RunEpochBlock+0x14a>
340168da:	215f      	movs	r1, #95	@ 0x5f
340168dc:	4b4b      	ldr	r3, [pc, #300]	@ (34016a0c <LL_ATON_RT_RunEpochBlock+0x274>)
340168de:	4a4c      	ldr	r2, [pc, #304]	@ (34016a10 <LL_ATON_RT_RunEpochBlock+0x278>)
340168e0:	e761      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
  if (nn_instance->exec_state.epoch_callback_function != NULL)
340168e2:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
340168e4:	b11b      	cbz	r3, 340168ee <LL_ATON_RT_RunEpochBlock+0x156>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_START, nn_instance, eb);
340168e6:	462a      	mov	r2, r5
340168e8:	4621      	mov	r1, r4
340168ea:	4630      	mov	r0, r6
340168ec:	4798      	blx	r3
    return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
340168ee:	8a2b      	ldrh	r3, [r5, #16]
  if (EpochBlock_IsEpochStart(eb))
340168f0:	07d8      	lsls	r0, r3, #31
340168f2:	d505      	bpl.n	34016900 <LL_ATON_RT_RunEpochBlock+0x168>
    LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
340168f4:	69e2      	ldr	r2, [r4, #28]
340168f6:	b11a      	cbz	r2, 34016900 <LL_ATON_RT_RunEpochBlock+0x168>
340168f8:	2156      	movs	r1, #86	@ 0x56
340168fa:	4b46      	ldr	r3, [pc, #280]	@ (34016a14 <LL_ATON_RT_RunEpochBlock+0x27c>)
340168fc:	4a46      	ldr	r2, [pc, #280]	@ (34016a18 <LL_ATON_RT_RunEpochBlock+0x280>)
340168fe:	e7b5      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>
  if (EpochBlock_IsEpochPureHW(eb) ||
34016900:	f013 0f50 	tst.w	r3, #80	@ 0x50
34016904:	d015      	beq.n	34016932 <LL_ATON_RT_RunEpochBlock+0x19a>
    LL_ATON_ASSERT(new_owner != __ll_current_aton_ip_owner);
34016906:	4a39      	ldr	r2, [pc, #228]	@ (340169ec <LL_ATON_RT_RunEpochBlock+0x254>)
34016908:	6811      	ldr	r1, [r2, #0]
3401690a:	428c      	cmp	r4, r1
3401690c:	d103      	bne.n	34016916 <LL_ATON_RT_RunEpochBlock+0x17e>
3401690e:	2131      	movs	r1, #49	@ 0x31
34016910:	4b42      	ldr	r3, [pc, #264]	@ (34016a1c <LL_ATON_RT_RunEpochBlock+0x284>)
34016912:	4a43      	ldr	r2, [pc, #268]	@ (34016a20 <LL_ATON_RT_RunEpochBlock+0x288>)
34016914:	e7aa      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(__ll_current_aton_ip_owner == NULL);
34016916:	6811      	ldr	r1, [r2, #0]
34016918:	b119      	cbz	r1, 34016922 <LL_ATON_RT_RunEpochBlock+0x18a>
3401691a:	2135      	movs	r1, #53	@ 0x35
3401691c:	4b41      	ldr	r3, [pc, #260]	@ (34016a24 <LL_ATON_RT_RunEpochBlock+0x28c>)
3401691e:	4a40      	ldr	r2, [pc, #256]	@ (34016a20 <LL_ATON_RT_RunEpochBlock+0x288>)
34016920:	e7a4      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
34016922:	4941      	ldr	r1, [pc, #260]	@ (34016a28 <LL_ATON_RT_RunEpochBlock+0x290>)
34016924:	6809      	ldr	r1, [r1, #0]
34016926:	b119      	cbz	r1, 34016930 <LL_ATON_RT_RunEpochBlock+0x198>
34016928:	2139      	movs	r1, #57	@ 0x39
3401692a:	4b40      	ldr	r3, [pc, #256]	@ (34016a2c <LL_ATON_RT_RunEpochBlock+0x294>)
3401692c:	4a3c      	ldr	r2, [pc, #240]	@ (34016a20 <LL_ATON_RT_RunEpochBlock+0x288>)
3401692e:	e79d      	b.n	3401686c <LL_ATON_RT_RunEpochBlock+0xd4>
    __ll_current_aton_ip_owner = new_owner;
34016930:	6014      	str	r4, [r2, #0]
  if (!EpochBlock_IsEpochBlob(eb))
34016932:	0759      	lsls	r1, r3, #29
34016934:	d41c      	bmi.n	34016970 <LL_ATON_RT_RunEpochBlock+0x1d8>
    if (EpochBlock_IsEpochPureHW(eb) || EpochBlock_IsEpochInternal(eb))
34016936:	f013 0f90 	tst.w	r3, #144	@ 0x90
3401693a:	d00a      	beq.n	34016952 <LL_ATON_RT_RunEpochBlock+0x1ba>
      LL_ATON_ASSERT(__ll_current_aton_ip_owner == nn_instance);
3401693c:	4b2b      	ldr	r3, [pc, #172]	@ (340169ec <LL_ATON_RT_RunEpochBlock+0x254>)
3401693e:	681b      	ldr	r3, [r3, #0]
34016940:	429c      	cmp	r4, r3
34016942:	d003      	beq.n	3401694c <LL_ATON_RT_RunEpochBlock+0x1b4>
34016944:	2176      	movs	r1, #118	@ 0x76
34016946:	4b2a      	ldr	r3, [pc, #168]	@ (340169f0 <LL_ATON_RT_RunEpochBlock+0x258>)
34016948:	4a31      	ldr	r2, [pc, #196]	@ (34016a10 <LL_ATON_RT_RunEpochBlock+0x278>)
3401694a:	e72c      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
      __LL_ATON_RT_SetWaitMask(eb->wait_mask);
3401694c:	68e8      	ldr	r0, [r5, #12]
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
3401694e:	f7ff fd07 	bl	34016360 <__LL_ATON_RT_SetWaitMask>
  if (eb->start_epoch_block != NULL)
34016952:	682b      	ldr	r3, [r5, #0]
34016954:	b10b      	cbz	r3, 3401695a <LL_ATON_RT_RunEpochBlock+0x1c2>
    eb->start_epoch_block((const void *)eb);
34016956:	4628      	mov	r0, r5
34016958:	4798      	blx	r3
  if (EpochBlock_IsEpochBlob(eb))
3401695a:	8a2b      	ldrh	r3, [r5, #16]
3401695c:	075a      	lsls	r2, r3, #29
3401695e:	d51a      	bpl.n	34016996 <LL_ATON_RT_RunEpochBlock+0x1fe>
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
34016960:	4628      	mov	r0, r5
34016962:	f7ff fd19 	bl	34016398 <EpochBlock_EpochControllerUnit>
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
34016966:	b130      	cbz	r0, 34016976 <LL_ATON_RT_RunEpochBlock+0x1de>
34016968:	2197      	movs	r1, #151	@ 0x97
3401696a:	4b31      	ldr	r3, [pc, #196]	@ (34016a30 <LL_ATON_RT_RunEpochBlock+0x298>)
3401696c:	4a28      	ldr	r2, [pc, #160]	@ (34016a10 <LL_ATON_RT_RunEpochBlock+0x278>)
3401696e:	e71a      	b.n	340167a6 <LL_ATON_RT_RunEpochBlock+0xe>
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
34016970:	f240 30ff 	movw	r0, #1023	@ 0x3ff
34016974:	e7eb      	b.n	3401694e <LL_ATON_RT_RunEpochBlock+0x1b6>
    conf.stepmode = 0;
34016976:	f89d 2004 	ldrb.w	r2, [sp, #4]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
3401697a:	68ab      	ldr	r3, [r5, #8]
    conf.stepmode = 0;
3401697c:	f360 0200 	bfi	r2, r0, #0, #1
    LL_EpochCtrl_Init(ecId, &conf);
34016980:	4669      	mov	r1, sp
    conf.stepmode = 0;
34016982:	f88d 2004 	strb.w	r2, [sp, #4]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
34016986:	9300      	str	r3, [sp, #0]
    LL_EpochCtrl_Init(ecId, &conf);
34016988:	f7ff fc4c 	bl	34016224 <LL_EpochCtrl_Init>
    ATON_ENABLE(EPOCHCTRL, ecId);
3401698c:	4a29      	ldr	r2, [pc, #164]	@ (34016a34 <LL_ATON_RT_RunEpochBlock+0x29c>)
3401698e:	6813      	ldr	r3, [r2, #0]
34016990:	f043 0301 	orr.w	r3, r3, #1
34016994:	6013      	str	r3, [r2, #0]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
34016996:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
34016998:	b11b      	cbz	r3, 340169a2 <LL_ATON_RT_RunEpochBlock+0x20a>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_START, nn_instance, eb);
3401699a:	462a      	mov	r2, r5
3401699c:	4621      	mov	r1, r4
3401699e:	2001      	movs	r0, #1
340169a0:	4798      	blx	r3
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
340169a2:	6860      	ldr	r0, [r4, #4]
  if (EpochBlock_IsEpochBlob(eb))
340169a4:	8a03      	ldrh	r3, [r0, #16]
340169a6:	075b      	lsls	r3, r3, #29
340169a8:	d50f      	bpl.n	340169ca <LL_ATON_RT_RunEpochBlock+0x232>
    return (1 << EpochBlock_EpochControllerUnit(eb));
340169aa:	f7ff fcf5 	bl	34016398 <EpochBlock_EpochControllerUnit>
340169ae:	2301      	movs	r3, #1
340169b0:	fa03 f000 	lsl.w	r0, r3, r0
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
340169b4:	2800      	cmp	r0, #0
340169b6:	f47f af28 	bne.w	3401680a <LL_ATON_RT_RunEpochBlock+0x72>
      __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
340169ba:	6860      	ldr	r0, [r4, #4]
340169bc:	4621      	mov	r1, r4
340169be:	f7ff fcff 	bl	340163c0 <__LL_ATON_RT_ExecEndEpochBlock>
      __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
340169c2:	4620      	mov	r0, r4
340169c4:	f7ff fd66 	bl	34016494 <__LL_ATON_RT_DetermineNextEpochBlock>
      return LL_ATON_RT_NO_WFE;
340169c8:	e779      	b.n	340168be <LL_ATON_RT_RunEpochBlock+0x126>
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
340169ca:	68c0      	ldr	r0, [r0, #12]
340169cc:	e7f2      	b.n	340169b4 <LL_ATON_RT_RunEpochBlock+0x21c>
        return LL_ATON_RT_DONE;
340169ce:	2002      	movs	r0, #2
340169d0:	e71c      	b.n	3401680c <LL_ATON_RT_RunEpochBlock+0x74>
340169d2:	bf00      	nop
340169d4:	3401d4af 	.word	0x3401d4af
340169d8:	3403c736 	.word	0x3403c736
340169dc:	3401d3b9 	.word	0x3401d3b9
340169e0:	3401d72b 	.word	0x3401d72b
340169e4:	3401d766 	.word	0x3401d766
340169e8:	3401d722 	.word	0x3401d722
340169ec:	340581d8 	.word	0x340581d8
340169f0:	3401d7c8 	.word	0x3401d7c8
340169f4:	e000e100 	.word	0xe000e100
340169f8:	3401d308 	.word	0x3401d308
340169fc:	3403c70f 	.word	0x3403c70f
34016a00:	3401d28e 	.word	0x3401d28e
34016a04:	3401d7f2 	.word	0x3401d7f2
34016a08:	3401d88e 	.word	0x3401d88e
34016a0c:	3401d8da 	.word	0x3401d8da
34016a10:	3403c6ee 	.word	0x3403c6ee
34016a14:	3401d4ca 	.word	0x3401d4ca
34016a18:	3403c6cf 	.word	0x3403c6cf
34016a1c:	3401d912 	.word	0x3401d912
34016a20:	3403c6bb 	.word	0x3403c6bb
34016a24:	3401d93a 	.word	0x3401d93a
34016a28:	340581d4 	.word	0x340581d4
34016a2c:	3401d2ec 	.word	0x3401d2ec
34016a30:	3401d3b0 	.word	0x3401d3b0
34016a34:	580fe000 	.word	0x580fe000

34016a38 <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
34016a38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
34016a3a:	4b38      	ldr	r3, [pc, #224]	@ (34016b1c <NPU0_IRQHandler+0xe4>)
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
34016a3c:	4c38      	ldr	r4, [pc, #224]	@ (34016b20 <NPU0_IRQHandler+0xe8>)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
34016a3e:	689d      	ldr	r5, [r3, #8]
  if (__ll_current_aton_ip_owner != NULL)
34016a40:	6823      	ldr	r3, [r4, #0]
34016a42:	b343      	cbz	r3, 34016a96 <NPU0_IRQHandler+0x5e>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
34016a44:	6823      	ldr	r3, [r4, #0]
34016a46:	685b      	ldr	r3, [r3, #4]
34016a48:	b933      	cbnz	r3, 34016a58 <NPU0_IRQHandler+0x20>
34016a4a:	f240 3162 	movw	r1, #866	@ 0x362
34016a4e:	4b35      	ldr	r3, [pc, #212]	@ (34016b24 <NPU0_IRQHandler+0xec>)
34016a50:	4a35      	ldr	r2, [pc, #212]	@ (34016b28 <NPU0_IRQHandler+0xf0>)
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
34016a52:	4836      	ldr	r0, [pc, #216]	@ (34016b2c <NPU0_IRQHandler+0xf4>)
34016a54:	f000 ffa4 	bl	340179a0 <__assert_func>
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
34016a58:	6823      	ldr	r3, [r4, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
34016a5a:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
34016a5c:	8a1b      	ldrh	r3, [r3, #16]
34016a5e:	075b      	lsls	r3, r3, #29
34016a60:	d40c      	bmi.n	34016a7c <NPU0_IRQHandler+0x44>
      __LL_ATON_RT_IrqErr(
34016a62:	f425 707f 	bic.w	r0, r5, #1020	@ 0x3fc
34016a66:	f020 0003 	bic.w	r0, r0, #3
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
34016a6a:	f7ff fd55 	bl	34016518 <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
34016a6e:	6823      	ldr	r3, [r4, #0]
34016a70:	b99b      	cbnz	r3, 34016a9a <NPU0_IRQHandler+0x62>
34016a72:	f240 3183 	movw	r1, #899	@ 0x383
34016a76:	4b2e      	ldr	r3, [pc, #184]	@ (34016b30 <NPU0_IRQHandler+0xf8>)
34016a78:	4a2b      	ldr	r2, [pc, #172]	@ (34016b28 <NPU0_IRQHandler+0xf0>)
34016a7a:	e7ea      	b.n	34016a52 <NPU0_IRQHandler+0x1a>
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
34016a7c:	6823      	ldr	r3, [r4, #0]
34016a7e:	6858      	ldr	r0, [r3, #4]
34016a80:	f7ff fc8a 	bl	34016398 <EpochBlock_EpochControllerUnit>
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
34016a84:	b120      	cbz	r0, 34016a90 <NPU0_IRQHandler+0x58>
34016a86:	f240 316f 	movw	r1, #879	@ 0x36f
34016a8a:	4b2a      	ldr	r3, [pc, #168]	@ (34016b34 <NPU0_IRQHandler+0xfc>)
34016a8c:	4a26      	ldr	r2, [pc, #152]	@ (34016b28 <NPU0_IRQHandler+0xf0>)
34016a8e:	e7e0      	b.n	34016a52 <NPU0_IRQHandler+0x1a>
      __LL_ATON_RT_IrqErr(
34016a90:	f025 5080 	bic.w	r0, r5, #268435456	@ 0x10000000
34016a94:	e7e9      	b.n	34016a6a <NPU0_IRQHandler+0x32>
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
34016a96:	4628      	mov	r0, r5
34016a98:	e7e7      	b.n	34016a6a <NPU0_IRQHandler+0x32>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
34016a9a:	6823      	ldr	r3, [r4, #0]
34016a9c:	685b      	ldr	r3, [r3, #4]
34016a9e:	8a1b      	ldrh	r3, [r3, #16]
34016aa0:	f013 0304 	ands.w	r3, r3, #4
34016aa4:	d123      	bne.n	34016aee <NPU0_IRQHandler+0xb6>
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
34016aa6:	6822      	ldr	r2, [r4, #0]
34016aa8:	6852      	ldr	r2, [r2, #4]
  wait_irqs =
34016aaa:	68d2      	ldr	r2, [r2, #12]
  if (wait_irqs)
34016aac:	402a      	ands	r2, r5
34016aae:	d017      	beq.n	34016ae0 <NPU0_IRQHandler+0xa8>
        _tmp_triggered_events |= (1 << i);
34016ab0:	f04f 0c01 	mov.w	ip, #1
34016ab4:	200a      	movs	r0, #10
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
34016ab6:	6821      	ldr	r1, [r4, #0]
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
34016ab8:	4e1f      	ldr	r6, [pc, #124]	@ (34016b38 <NPU0_IRQHandler+0x100>)
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
34016aba:	69c9      	ldr	r1, [r1, #28]
      if ((wait_irqs >> i) & 1)
34016abc:	fa22 f703 	lsr.w	r7, r2, r3
34016ac0:	07ff      	lsls	r7, r7, #31
34016ac2:	d507      	bpl.n	34016ad4 <NPU0_IRQHandler+0x9c>
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
34016ac4:	031f      	lsls	r7, r3, #12
34016ac6:	f857 e006 	ldr.w	lr, [r7, r6]
        ATON_STRENG_IRQ_SET(
34016aca:	f847 e006 	str.w	lr, [r7, r6]
        _tmp_triggered_events |= (1 << i);
34016ace:	fa0c f703 	lsl.w	r7, ip, r3
34016ad2:	4339      	orrs	r1, r7
    for (i = 0; i < ATON_STRENG_NUM; i++)
34016ad4:	3801      	subs	r0, #1
34016ad6:	f103 0301 	add.w	r3, r3, #1
34016ada:	d1ef      	bne.n	34016abc <NPU0_IRQHandler+0x84>
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34016adc:	6823      	ldr	r3, [r4, #0]
34016ade:	61d9      	str	r1, [r3, #28]
  __ASM volatile ("dsb 0xF":::"memory");
34016ae0:	f3bf 8f4f 	dsb	sy
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
34016ae4:	4b0d      	ldr	r3, [pc, #52]	@ (34016b1c <NPU0_IRQHandler+0xe4>)
34016ae6:	611d      	str	r5, [r3, #16]
34016ae8:	f3bf 8f4f 	dsb	sy
  LL_ATON_OSAL_SIGNAL_EVENT();

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
}
34016aec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
34016aee:	6823      	ldr	r3, [r4, #0]
34016af0:	6858      	ldr	r0, [r3, #4]
34016af2:	f7ff fc51 	bl	34016398 <EpochBlock_EpochControllerUnit>
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
34016af6:	b120      	cbz	r0, 34016b02 <NPU0_IRQHandler+0xca>
34016af8:	f240 3142 	movw	r1, #834	@ 0x342
34016afc:	4b0d      	ldr	r3, [pc, #52]	@ (34016b34 <NPU0_IRQHandler+0xfc>)
34016afe:	4a0f      	ldr	r2, [pc, #60]	@ (34016b3c <NPU0_IRQHandler+0x104>)
34016b00:	e7a7      	b.n	34016a52 <NPU0_IRQHandler+0x1a>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
34016b02:	00eb      	lsls	r3, r5, #3
34016b04:	d5ec      	bpl.n	34016ae0 <NPU0_IRQHandler+0xa8>
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
34016b06:	4b0e      	ldr	r3, [pc, #56]	@ (34016b40 <NPU0_IRQHandler+0x108>)
34016b08:	68da      	ldr	r2, [r3, #12]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
34016b0a:	60da      	str	r2, [r3, #12]
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
34016b0c:	6823      	ldr	r3, [r4, #0]
34016b0e:	69db      	ldr	r3, [r3, #28]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34016b10:	6822      	ldr	r2, [r4, #0]
    _tmp_triggered_events |= (1 << ecId);
34016b12:	f043 0301 	orr.w	r3, r3, #1
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
34016b16:	61d3      	str	r3, [r2, #28]
34016b18:	e7e2      	b.n	34016ae0 <NPU0_IRQHandler+0xa8>
34016b1a:	bf00      	nop
34016b1c:	580e1000 	.word	0x580e1000
34016b20:	340581d8 	.word	0x340581d8
34016b24:	3401d964 	.word	0x3401d964
34016b28:	3403c62f 	.word	0x3403c62f
34016b2c:	3401d3b9 	.word	0x3401d3b9
34016b30:	3401d308 	.word	0x3401d308
34016b34:	3401d3b0 	.word	0x3401d3b0
34016b38:	580e503c 	.word	0x580e503c
34016b3c:	3403c601 	.word	0x3403c601
34016b40:	580fe000 	.word	0x580fe000

34016b44 <ll_sw_forward_dequantizelinear>:
{
  Dequantizelinear_sw_info *sw_info = (Dequantizelinear_sw_info *)sw_info_struct;

  // array init
  int32_t format = sw_info->general.input.format.is_signed ? (AI_ARRAY_FORMAT_S8 | AI_FMT_FLAG_IS_IO)
                                                           : (AI_ARRAY_FORMAT_U8 | AI_FMT_FLAG_IS_IO);
34016b44:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
34016b48:	4a47      	ldr	r2, [pc, #284]	@ (34016c68 <ll_sw_forward_dequantizelinear+0x124>)
34016b4a:	2b00      	cmp	r3, #0
34016b4c:	4b47      	ldr	r3, [pc, #284]	@ (34016c6c <ll_sw_forward_dequantizelinear+0x128>)
34016b4e:	bf18      	it	ne
34016b50:	4613      	movne	r3, r2
{
34016b52:	b510      	push	{r4, lr}
34016b54:	b0c4      	sub	sp, #272	@ 0x110
  AI_ARRAY_OBJ_DECLARE(input_output_array, format, sw_info->general.input.mem.start_offset,
34016b56:	930a      	str	r3, [sp, #40]	@ 0x28
34016b58:	6943      	ldr	r3, [r0, #20]
                                  .info = (const ai_intq_info[1]){{
                                      .scale = ((float *)sw_info->is.mem.start_offset),
                                      .zeropoint = ((void *)sw_info->izp.mem.start_offset),
                                  }}};

  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016b5a:	f04f 7482 	mov.w	r4, #17039360	@ 0x1040000
  AI_ARRAY_OBJ_DECLARE(input_output_array, format, sw_info->general.input.mem.start_offset,
34016b5e:	930b      	str	r3, [sp, #44]	@ 0x2c
34016b60:	6a83      	ldr	r3, [r0, #40]	@ 0x28
34016b62:	e9cd 330c 	strd	r3, r3, [sp, #48]	@ 0x30
  AI_ARRAY_OBJ_DECLARE(dequantize_output_array, FORMAT, sw_info->general.output.mem.start_offset,
34016b66:	4b42      	ldr	r3, [pc, #264]	@ (34016c70 <ll_sw_forward_dequantizelinear+0x12c>)
34016b68:	930e      	str	r3, [sp, #56]	@ 0x38
34016b6a:	6c03      	ldr	r3, [r0, #64]	@ 0x40
34016b6c:	930f      	str	r3, [sp, #60]	@ 0x3c
34016b6e:	6d43      	ldr	r3, [r0, #84]	@ 0x54
34016b70:	e9cd 3310 	strd	r3, r3, [sp, #64]	@ 0x40
  uint16_t offset_format =
34016b74:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
34016b78:	2b00      	cmp	r3, #0
34016b7a:	bf0c      	ite	eq
34016b7c:	2202      	moveq	r2, #2
34016b7e:	2204      	movne	r2, #4
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
34016b80:	f042 0201 	orr.w	r2, r2, #1
34016b84:	f8ad 2010 	strh.w	r2, [sp, #16]
34016b88:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
34016b8a:	ab04      	add	r3, sp, #16
34016b8c:	f8ad 2012 	strh.w	r2, [sp, #18]
                                  .info = (const ai_intq_info[1]){{
34016b90:	f8d0 2080 	ldr.w	r2, [r0, #128]	@ 0x80
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016b94:	9322      	str	r3, [sp, #136]	@ 0x88
                                  .info = (const ai_intq_info[1]){{
34016b96:	9206      	str	r2, [sp, #24]
34016b98:	f8d0 20ac 	ldr.w	r2, [r0, #172]	@ 0xac
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016b9c:	6903      	ldr	r3, [r0, #16]
                                  .info = (const ai_intq_info[1]){{
34016b9e:	9207      	str	r2, [sp, #28]
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
34016ba0:	aa06      	add	r2, sp, #24
34016ba2:	9205      	str	r2, [sp, #20]
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016ba4:	f240 4201 	movw	r2, #1025	@ 0x401
34016ba8:	9312      	str	r3, [sp, #72]	@ 0x48
34016baa:	68c3      	ldr	r3, [r0, #12]
34016bac:	e9cd 4223 	strd	r4, r2, [sp, #140]	@ 0x8c
34016bb0:	9313      	str	r3, [sp, #76]	@ 0x4c
34016bb2:	6883      	ldr	r3, [r0, #8]
34016bb4:	6a41      	ldr	r1, [r0, #36]	@ 0x24
34016bb6:	9314      	str	r3, [sp, #80]	@ 0x50
34016bb8:	9116      	str	r1, [sp, #88]	@ 0x58
34016bba:	6a01      	ldr	r1, [r0, #32]
34016bbc:	6843      	ldr	r3, [r0, #4]
34016bbe:	9117      	str	r1, [sp, #92]	@ 0x5c
34016bc0:	69c1      	ldr	r1, [r0, #28]
34016bc2:	9315      	str	r3, [sp, #84]	@ 0x54
34016bc4:	ab12      	add	r3, sp, #72	@ 0x48
34016bc6:	9325      	str	r3, [sp, #148]	@ 0x94
34016bc8:	9118      	str	r1, [sp, #96]	@ 0x60
34016bca:	f240 4302 	movw	r3, #1026	@ 0x402
34016bce:	6981      	ldr	r1, [r0, #24]
                                   sw_info->general.input.dim.tensor_c, sw_info->general.input.dim.tensor_b),
                        STRIDE_INIT(sw_info->general.input.stride.h, sw_info->general.input.stride.w,
                                    sw_info->general.input.stride.c, sw_info->general.input.stride.b),
                        1, &input_output_array, &input_intq);

  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016bd0:	922b      	str	r2, [sp, #172]	@ 0xac
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016bd2:	9119      	str	r1, [sp, #100]	@ 0x64
34016bd4:	a916      	add	r1, sp, #88	@ 0x58
34016bd6:	9127      	str	r1, [sp, #156]	@ 0x9c
34016bd8:	a90a      	add	r1, sp, #40	@ 0x28
34016bda:	9128      	str	r1, [sp, #160]	@ 0xa0
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016bdc:	2100      	movs	r1, #0
34016bde:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
34016be0:	9326      	str	r3, [sp, #152]	@ 0x98
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016be2:	921a      	str	r2, [sp, #104]	@ 0x68
34016be4:	6b82      	ldr	r2, [r0, #56]	@ 0x38
34016be6:	e9cd 1429 	strd	r1, r4, [sp, #164]	@ 0xa4
34016bea:	921b      	str	r2, [sp, #108]	@ 0x6c
34016bec:	6b42      	ldr	r2, [r0, #52]	@ 0x34
34016bee:	921c      	str	r2, [sp, #112]	@ 0x70
34016bf0:	6b02      	ldr	r2, [r0, #48]	@ 0x30
34016bf2:	921d      	str	r2, [sp, #116]	@ 0x74
34016bf4:	aa1a      	add	r2, sp, #104	@ 0x68
34016bf6:	e9cd 232c 	strd	r2, r3, [sp, #176]	@ 0xb0
34016bfa:	6d03      	ldr	r3, [r0, #80]	@ 0x50
                        STRIDE_INIT(sw_info->general.output.stride.h, sw_info->general.output.stride.w,
                                    sw_info->general.output.stride.c, sw_info->general.output.stride.b),
                        1, &dequantize_output_array, NULL);

  // tensor chain initialization
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016bfc:	aa22      	add	r2, sp, #136	@ 0x88
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016bfe:	931e      	str	r3, [sp, #120]	@ 0x78
34016c00:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
34016c02:	931f      	str	r3, [sp, #124]	@ 0x7c
34016c04:	6c83      	ldr	r3, [r0, #72]	@ 0x48
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016c06:	9200      	str	r2, [sp, #0]
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016c08:	9320      	str	r3, [sp, #128]	@ 0x80
34016c0a:	6c43      	ldr	r3, [r0, #68]	@ 0x44
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016c0c:	aa29      	add	r2, sp, #164	@ 0xa4
  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
34016c0e:	9321      	str	r3, [sp, #132]	@ 0x84
34016c10:	ab1e      	add	r3, sp, #120	@ 0x78
34016c12:	932e      	str	r3, [sp, #184]	@ 0xb8
34016c14:	ab0e      	add	r3, sp, #56	@ 0x38
34016c16:	932f      	str	r3, [sp, #188]	@ 0xbc
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016c18:	2304      	movs	r3, #4
34016c1a:	9308      	str	r3, [sp, #32]
34016c1c:	2301      	movs	r3, #1
34016c1e:	e9cd 133a 	strd	r1, r3, [sp, #232]	@ 0xe8
34016c22:	9338      	str	r3, [sp, #224]	@ 0xe0
34016c24:	ab01      	add	r3, sp, #4
34016c26:	e9cd 313c 	strd	r3, r1, [sp, #240]	@ 0xf0
34016c2a:	ab02      	add	r3, sp, #8
34016c2c:	e9cd 313f 	strd	r3, r1, [sp, #252]	@ 0xfc
34016c30:	ab03      	add	r3, sp, #12
34016c32:	e9cd 3142 	strd	r3, r1, [sp, #264]	@ 0x108
34016c36:	ab38      	add	r3, sp, #224	@ 0xe0
34016c38:	9309      	str	r3, [sp, #36]	@ 0x24
                              AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&dequantize_output)),
                              AI_TENSOR_LIST_OBJ_EMPTY, AI_TENSOR_LIST_OBJ_EMPTY)

  // layer initialization
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016c3a:	4b0e      	ldr	r3, [pc, #56]	@ (34016c74 <ll_sw_forward_dequantizelinear+0x130>)
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016c3c:	9201      	str	r2, [sp, #4]
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016c3e:	a831      	add	r0, sp, #196	@ 0xc4
34016c40:	221c      	movs	r2, #28
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016c42:	913e      	str	r1, [sp, #248]	@ 0xf8
34016c44:	9102      	str	r1, [sp, #8]
34016c46:	9141      	str	r1, [sp, #260]	@ 0x104
34016c48:	9103      	str	r1, [sp, #12]
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016c4a:	9330      	str	r3, [sp, #192]	@ 0xc0
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
34016c4c:	f8cd d0e4 	str.w	sp, [sp, #228]	@ 0xe4
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016c50:	f002 f808 	bl	34018c64 <memset>
34016c54:	4b08      	ldr	r3, [pc, #32]	@ (34016c78 <ll_sw_forward_dequantizelinear+0x134>)
                       NULL, )
  dequantize_layer.forward(AI_LAYER_OBJ(&dequantize_layer));
34016c56:	a830      	add	r0, sp, #192	@ 0xc0
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
34016c58:	9335      	str	r3, [sp, #212]	@ 0xd4
34016c5a:	ab08      	add	r3, sp, #32
34016c5c:	9336      	str	r3, [sp, #216]	@ 0xd8
  dequantize_layer.forward(AI_LAYER_OBJ(&dequantize_layer));
34016c5e:	f000 f83d 	bl	34016cdc <node_convert>
}
34016c62:	b044      	add	sp, #272	@ 0x110
34016c64:	bd10      	pop	{r4, pc}
34016c66:	bf00      	nop
34016c68:	08840440 	.word	0x08840440
34016c6c:	08040440 	.word	0x08040440
34016c70:	00821040 	.word	0x00821040
34016c74:	00010107 	.word	0x00010107
34016c78:	34016cdd 	.word	0x34016cdd

34016c7c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34016c7c:	480f      	ldr	r0, [pc, #60]	@ (34016cbc <LoopForever+0x4>)
  msr   MSPLIM, r0
34016c7e:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34016c82:	480f      	ldr	r0, [pc, #60]	@ (34016cc0 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34016c84:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34016c86:	f7ed fc57 	bl	34004538 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34016c8a:	480e      	ldr	r0, [pc, #56]	@ (34016cc4 <LoopForever+0xc>)
  ldr r1, =_edata
34016c8c:	490e      	ldr	r1, [pc, #56]	@ (34016cc8 <LoopForever+0x10>)
  ldr r2, =_sidata
34016c8e:	4a0f      	ldr	r2, [pc, #60]	@ (34016ccc <LoopForever+0x14>)
  movs r3, #0
34016c90:	2300      	movs	r3, #0
  b LoopCopyDataInit
34016c92:	e002      	b.n	34016c9a <LoopCopyDataInit>

34016c94 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34016c94:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34016c96:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34016c98:	3304      	adds	r3, #4

34016c9a <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34016c9a:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34016c9c:	428c      	cmp	r4, r1
  bcc CopyDataInit
34016c9e:	d3f9      	bcc.n	34016c94 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34016ca0:	4a0b      	ldr	r2, [pc, #44]	@ (34016cd0 <LoopForever+0x18>)
  ldr r4, =_ebss
34016ca2:	4c0c      	ldr	r4, [pc, #48]	@ (34016cd4 <LoopForever+0x1c>)
  movs r3, #0
34016ca4:	2300      	movs	r3, #0
  b LoopFillZerobss
34016ca6:	e001      	b.n	34016cac <LoopFillZerobss>

34016ca8 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34016ca8:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34016caa:	3204      	adds	r2, #4

34016cac <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34016cac:	42a2      	cmp	r2, r4
  bcc FillZerobss
34016cae:	d3fb      	bcc.n	34016ca8 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34016cb0:	f002 fa32 	bl	34019118 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34016cb4:	f7eb f800 	bl	34001cb8 <main>

34016cb8 <LoopForever>:

LoopForever:
  b LoopForever
34016cb8:	e7fe      	b.n	34016cb8 <LoopForever>
34016cba:	0000      	.short	0x0000
  ldr   r0, =_sstack
34016cbc:	340fc000 	.word	0x340fc000
  ldr   r0, =_estack
34016cc0:	34100000 	.word	0x34100000
  ldr r0, =_sdata
34016cc4:	3403ed5c 	.word	0x3403ed5c
  ldr r1, =_edata
34016cc8:	3403f0a8 	.word	0x3403f0a8
  ldr r2, =_sidata
34016ccc:	3403ed5c 	.word	0x3403ed5c
  ldr r2, =_sbss
34016cd0:	3403f0a8 	.word	0x3403f0a8
  ldr r4, =_ebss
34016cd4:	3405832c 	.word	0x3405832c

34016cd8 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34016cd8:	e7fe      	b.n	34016cd8 <ADC1_2_IRQHandler>
	...

34016cdc <node_convert>:
34016cdc:	6982      	ldr	r2, [r0, #24]
34016cde:	8813      	ldrh	r3, [r2, #0]
34016ce0:	2b00      	cmp	r3, #0
34016ce2:	d048      	beq.n	34016d76 <node_convert+0x9a>
34016ce4:	6852      	ldr	r2, [r2, #4]
34016ce6:	6851      	ldr	r1, [r2, #4]
34016ce8:	b101      	cbz	r1, 34016cec <node_convert+0x10>
34016cea:	6809      	ldr	r1, [r1, #0]
34016cec:	2b01      	cmp	r3, #1
34016cee:	f000 8147 	beq.w	34016f80 <node_convert+0x2a4>
34016cf2:	b5f0      	push	{r4, r5, r6, r7, lr}
34016cf4:	6910      	ldr	r0, [r2, #16]
34016cf6:	b083      	sub	sp, #12
34016cf8:	b100      	cbz	r0, 34016cfc <node_convert+0x20>
34016cfa:	6800      	ldr	r0, [r0, #0]
34016cfc:	688b      	ldr	r3, [r1, #8]
34016cfe:	2401      	movs	r4, #1
34016d00:	0a1a      	lsrs	r2, r3, #8
34016d02:	d011      	beq.n	34016d28 <node_convert+0x4c>
34016d04:	ea4f 0e82 	mov.w	lr, r2, lsl #2
34016d08:	f1ae 0e04 	sub.w	lr, lr, #4
34016d0c:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
34016d10:	44a6      	add	lr, r4
34016d12:	f04e e001 	dls	lr, lr
34016d16:	68cb      	ldr	r3, [r1, #12]
34016d18:	eb03 0382 	add.w	r3, r3, r2, lsl #2
34016d1c:	f853 2d04 	ldr.w	r2, [r3, #-4]!
34016d20:	fb02 f404 	mul.w	r4, r2, r4
34016d24:	f00f c007 	le	lr, 34016d1c <node_convert+0x40>
34016d28:	698a      	ldr	r2, [r1, #24]
34016d2a:	6985      	ldr	r5, [r0, #24]
34016d2c:	6813      	ldr	r3, [r2, #0]
34016d2e:	f3c3 4c43 	ubfx	ip, r3, #17, #4
34016d32:	f1bc 0f01 	cmp.w	ip, #1
34016d36:	d020      	beq.n	34016d7a <node_convert+0x9e>
34016d38:	680e      	ldr	r6, [r1, #0]
34016d3a:	68ad      	ldr	r5, [r5, #8]
34016d3c:	2e00      	cmp	r6, #0
34016d3e:	d03a      	beq.n	34016db6 <node_convert+0xda>
34016d40:	6871      	ldr	r1, [r6, #4]
34016d42:	6890      	ldr	r0, [r2, #8]
34016d44:	f3c3 52c0 	ubfx	r2, r3, #23, #1
34016d48:	2900      	cmp	r1, #0
34016d4a:	f000 8099 	beq.w	34016e80 <node_convert+0x1a4>
34016d4e:	8873      	ldrh	r3, [r6, #2]
34016d50:	2b00      	cmp	r3, #0
34016d52:	f000 8082 	beq.w	34016e5a <node_convert+0x17e>
34016d56:	680b      	ldr	r3, [r1, #0]
34016d58:	ed93 0a00 	vldr	s0, [r3]
34016d5c:	684b      	ldr	r3, [r1, #4]
34016d5e:	2a00      	cmp	r2, #0
34016d60:	f000 809a 	beq.w	34016e98 <node_convert+0x1bc>
34016d64:	f993 3000 	ldrsb.w	r3, [r3]
34016d68:	4622      	mov	r2, r4
34016d6a:	4629      	mov	r1, r5
34016d6c:	b003      	add	sp, #12
34016d6e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016d72:	f000 b909 	b.w	34016f88 <forward_lite_node_convert_integer_is8of32>
34016d76:	685b      	ldr	r3, [r3, #4]
34016d78:	deff      	udf	#255	@ 0xff
34016d7a:	6806      	ldr	r6, [r0, #0]
34016d7c:	6890      	ldr	r0, [r2, #8]
34016d7e:	2e00      	cmp	r6, #0
34016d80:	f000 8092 	beq.w	34016ea8 <node_convert+0x1cc>
34016d84:	682b      	ldr	r3, [r5, #0]
34016d86:	6872      	ldr	r2, [r6, #4]
34016d88:	68a9      	ldr	r1, [r5, #8]
34016d8a:	f3c3 53c0 	ubfx	r3, r3, #23, #1
34016d8e:	2a00      	cmp	r2, #0
34016d90:	d067      	beq.n	34016e62 <node_convert+0x186>
34016d92:	8875      	ldrh	r5, [r6, #2]
34016d94:	2d00      	cmp	r5, #0
34016d96:	d069      	beq.n	34016e6c <node_convert+0x190>
34016d98:	6815      	ldr	r5, [r2, #0]
34016d9a:	ed95 0a00 	vldr	s0, [r5]
34016d9e:	2b00      	cmp	r3, #0
34016da0:	f000 80e3 	beq.w	34016f6a <node_convert+0x28e>
34016da4:	6853      	ldr	r3, [r2, #4]
34016da6:	f993 3000 	ldrsb.w	r3, [r3]
34016daa:	4622      	mov	r2, r4
34016dac:	b003      	add	sp, #12
34016dae:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016db2:	f000 b8ed 	b.w	34016f90 <forward_lite_node_convert_integer_if32os8>
34016db6:	f3c3 11c6 	ubfx	r1, r3, #7, #7
34016dba:	f003 067f 	and.w	r6, r3, #127	@ 0x7f
34016dbe:	1b8e      	subs	r6, r1, r6
34016dc0:	3640      	adds	r6, #64	@ 0x40
34016dc2:	f3c3 53c0 	ubfx	r3, r3, #23, #1
34016dc6:	2908      	cmp	r1, #8
34016dc8:	6890      	ldr	r0, [r2, #8]
34016dca:	4629      	mov	r1, r5
34016dcc:	4622      	mov	r2, r4
34016dce:	eba6 0603 	sub.w	r6, r6, r3
34016dd2:	f000 80bc 	beq.w	34016f4e <node_convert+0x272>
34016dd6:	f000 fd55 	bl	34017884 <st_int16_to_f32>
34016dda:	b3e6      	cbz	r6, 34016e56 <node_convert+0x17a>
34016ddc:	ee07 6a90 	vmov	s15, r6
34016de0:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
34016de4:	eef8 0ae7 	vcvt.f32.s32	s1, s15
34016de8:	f004 fbce 	bl	3401b588 <powf>
34016dec:	b39c      	cbz	r4, 34016e56 <node_convert+0x17a>
34016dee:	1e63      	subs	r3, r4, #1
34016df0:	2b02      	cmp	r3, #2
34016df2:	f240 80c1 	bls.w	34016f78 <node_convert+0x29c>
34016df6:	ee10 3a10 	vmov	r3, s0
34016dfa:	08a2      	lsrs	r2, r4, #2
34016dfc:	eea4 3b10 	vdup.32	q2, r3
34016e00:	f042 e001 	dls	lr, r2
34016e04:	462b      	mov	r3, r5
34016e06:	ed93 7f00 	ldc	15, cr7, [r3]
34016e0a:	461a      	mov	r2, r3
34016e0c:	ff06 6d54 	vmul.f32	q3, q3, q2
34016e10:	3310      	adds	r3, #16
34016e12:	ed82 7f00 	stc	15, cr7, [r2]
34016e16:	f00f c00b 	le	lr, 34016e06 <node_convert+0x12a>
34016e1a:	f024 0303 	bic.w	r3, r4, #3
34016e1e:	429c      	cmp	r4, r3
34016e20:	eb05 0583 	add.w	r5, r5, r3, lsl #2
34016e24:	d017      	beq.n	34016e56 <node_convert+0x17a>
34016e26:	edd5 7a00 	vldr	s15, [r5]
34016e2a:	ee67 7a80 	vmul.f32	s15, s15, s0
34016e2e:	1c5a      	adds	r2, r3, #1
34016e30:	4294      	cmp	r4, r2
34016e32:	edc5 7a00 	vstr	s15, [r5]
34016e36:	d90e      	bls.n	34016e56 <node_convert+0x17a>
34016e38:	edd5 7a01 	vldr	s15, [r5, #4]
34016e3c:	ee67 7a80 	vmul.f32	s15, s15, s0
34016e40:	3302      	adds	r3, #2
34016e42:	429c      	cmp	r4, r3
34016e44:	edc5 7a01 	vstr	s15, [r5, #4]
34016e48:	d905      	bls.n	34016e56 <node_convert+0x17a>
34016e4a:	edd5 7a02 	vldr	s15, [r5, #8]
34016e4e:	ee67 7a80 	vmul.f32	s15, s15, s0
34016e52:	edc5 7a02 	vstr	s15, [r5, #8]
34016e56:	b003      	add	sp, #12
34016e58:	bdf0      	pop	{r4, r5, r6, r7, pc}
34016e5a:	b19a      	cbz	r2, 34016e84 <node_convert+0x1a8>
34016e5c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016e60:	e782      	b.n	34016d68 <node_convert+0x8c>
34016e62:	b12b      	cbz	r3, 34016e70 <node_convert+0x194>
34016e64:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016e68:	4613      	mov	r3, r2
34016e6a:	e79e      	b.n	34016daa <node_convert+0xce>
34016e6c:	2b00      	cmp	r3, #0
34016e6e:	d17f      	bne.n	34016f70 <node_convert+0x294>
34016e70:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016e74:	4622      	mov	r2, r4
34016e76:	b003      	add	sp, #12
34016e78:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016e7c:	f000 b88a 	b.w	34016f94 <forward_lite_node_convert_integer_if32ou8>
34016e80:	2a00      	cmp	r2, #0
34016e82:	d167      	bne.n	34016f54 <node_convert+0x278>
34016e84:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016e88:	2300      	movs	r3, #0
34016e8a:	4622      	mov	r2, r4
34016e8c:	4629      	mov	r1, r5
34016e8e:	b003      	add	sp, #12
34016e90:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016e94:	f000 b87a 	b.w	34016f8c <forward_lite_node_convert_integer_iu8of32>
34016e98:	4622      	mov	r2, r4
34016e9a:	4629      	mov	r1, r5
34016e9c:	781b      	ldrb	r3, [r3, #0]
34016e9e:	b003      	add	sp, #12
34016ea0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016ea4:	f000 b872 	b.w	34016f8c <forward_lite_node_convert_integer_iu8of32>
34016ea8:	682a      	ldr	r2, [r5, #0]
34016eaa:	f3c2 17c6 	ubfx	r7, r2, #7, #7
34016eae:	f002 037f 	and.w	r3, r2, #127	@ 0x7f
34016eb2:	1afb      	subs	r3, r7, r3
34016eb4:	3340      	adds	r3, #64	@ 0x40
34016eb6:	f3c2 52c0 	ubfx	r2, r2, #23, #1
34016eba:	1a9b      	subs	r3, r3, r2
34016ebc:	d03e      	beq.n	34016f3c <node_convert+0x260>
34016ebe:	425b      	negs	r3, r3
34016ec0:	ee00 3a90 	vmov	s1, r3
34016ec4:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
34016ec8:	eef8 0ae0 	vcvt.f32.s32	s1, s1
34016ecc:	9001      	str	r0, [sp, #4]
34016ece:	f004 fb5b 	bl	3401b588 <powf>
34016ed2:	9801      	ldr	r0, [sp, #4]
34016ed4:	b394      	cbz	r4, 34016f3c <node_convert+0x260>
34016ed6:	1e63      	subs	r3, r4, #1
34016ed8:	2b02      	cmp	r3, #2
34016eda:	d94f      	bls.n	34016f7c <node_convert+0x2a0>
34016edc:	ee10 2a10 	vmov	r2, s0
34016ee0:	08a3      	lsrs	r3, r4, #2
34016ee2:	f043 e001 	dls	lr, r3
34016ee6:	eea4 2b10 	vdup.32	q2, r2
34016eea:	4603      	mov	r3, r0
34016eec:	ed93 7f00 	ldc	15, cr7, [r3]
34016ef0:	461a      	mov	r2, r3
34016ef2:	ff06 6d54 	vmul.f32	q3, q3, q2
34016ef6:	3310      	adds	r3, #16
34016ef8:	ed82 7f00 	stc	15, cr7, [r2]
34016efc:	f00f c00b 	le	lr, 34016eec <node_convert+0x210>
34016f00:	f024 0603 	bic.w	r6, r4, #3
34016f04:	42a6      	cmp	r6, r4
34016f06:	eb00 0386 	add.w	r3, r0, r6, lsl #2
34016f0a:	d017      	beq.n	34016f3c <node_convert+0x260>
34016f0c:	edd3 7a00 	vldr	s15, [r3]
34016f10:	ee67 7a80 	vmul.f32	s15, s15, s0
34016f14:	1c72      	adds	r2, r6, #1
34016f16:	42a2      	cmp	r2, r4
34016f18:	edc3 7a00 	vstr	s15, [r3]
34016f1c:	d20e      	bcs.n	34016f3c <node_convert+0x260>
34016f1e:	edd3 7a01 	vldr	s15, [r3, #4]
34016f22:	ee67 7a80 	vmul.f32	s15, s15, s0
34016f26:	3602      	adds	r6, #2
34016f28:	42b4      	cmp	r4, r6
34016f2a:	edc3 7a01 	vstr	s15, [r3, #4]
34016f2e:	d905      	bls.n	34016f3c <node_convert+0x260>
34016f30:	edd3 7a02 	vldr	s15, [r3, #8]
34016f34:	ee67 7a80 	vmul.f32	s15, s15, s0
34016f38:	edc3 7a02 	vstr	s15, [r3, #8]
34016f3c:	2f08      	cmp	r7, #8
34016f3e:	d00d      	beq.n	34016f5c <node_convert+0x280>
34016f40:	4622      	mov	r2, r4
34016f42:	68a9      	ldr	r1, [r5, #8]
34016f44:	b003      	add	sp, #12
34016f46:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016f4a:	f000 ba05 	b.w	34017358 <st_f32_to_int16>
34016f4e:	f000 fcdb 	bl	34017908 <st_int8_to_f32>
34016f52:	e742      	b.n	34016dda <node_convert+0xfe>
34016f54:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016f58:	460b      	mov	r3, r1
34016f5a:	e705      	b.n	34016d68 <node_convert+0x8c>
34016f5c:	4622      	mov	r2, r4
34016f5e:	68a9      	ldr	r1, [r5, #8]
34016f60:	b003      	add	sp, #12
34016f62:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34016f66:	f000 bacb 	b.w	34017500 <st_f32_to_int8>
34016f6a:	6853      	ldr	r3, [r2, #4]
34016f6c:	781b      	ldrb	r3, [r3, #0]
34016f6e:	e781      	b.n	34016e74 <node_convert+0x198>
34016f70:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34016f74:	462b      	mov	r3, r5
34016f76:	e718      	b.n	34016daa <node_convert+0xce>
34016f78:	2300      	movs	r3, #0
34016f7a:	e754      	b.n	34016e26 <node_convert+0x14a>
34016f7c:	4603      	mov	r3, r0
34016f7e:	e7c5      	b.n	34016f0c <node_convert+0x230>
34016f80:	2300      	movs	r3, #0
34016f82:	685b      	ldr	r3, [r3, #4]
34016f84:	deff      	udf	#255	@ 0xff
34016f86:	bf00      	nop

34016f88 <forward_lite_node_convert_integer_is8of32>:
34016f88:	f000 b806 	b.w	34016f98 <lite_convert_is8of32>

34016f8c <forward_lite_node_convert_integer_iu8of32>:
34016f8c:	f000 b83a 	b.w	34017004 <lite_convert_iu8of32>

34016f90 <forward_lite_node_convert_integer_if32os8>:
34016f90:	f000 b85e 	b.w	34017050 <lite_convert_if32os8>

34016f94 <forward_lite_node_convert_integer_if32ou8>:
34016f94:	f000 b954 	b.w	34017240 <lite_convert_if32ou8>

34016f98 <lite_convert_is8of32>:
34016f98:	2a00      	cmp	r2, #0
34016f9a:	dd31      	ble.n	34017000 <lite_convert_is8of32+0x68>
34016f9c:	b570      	push	{r4, r5, r6, lr}
34016f9e:	1885      	adds	r5, r0, r2
34016fa0:	1e50      	subs	r0, r2, #1
34016fa2:	f020 0003 	bic.w	r0, r0, #3
34016fa6:	1f16      	subs	r6, r2, #4
34016fa8:	ea4f 0c92 	mov.w	ip, r2, lsr #2
34016fac:	ee10 4a10 	vmov	r4, s0
34016fb0:	1a36      	subs	r6, r6, r0
34016fb2:	f10c 0c01 	add.w	ip, ip, #1
34016fb6:	e008      	b.n	34016fca <lite_convert_is8of32+0x32>
34016fb8:	4608      	mov	r0, r1
34016fba:	4296      	cmp	r6, r2
34016fbc:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016fc0:	ed80 7f00 	stc	15, cr7, [r0]
34016fc4:	f101 0110 	add.w	r1, r1, #16
34016fc8:	d019      	beq.n	34016ffe <lite_convert_is8of32+0x66>
34016fca:	f022 e801 	bfcsel	0, 34016fd0 <lite_convert_is8of32+0x38>, 4, hi
34016fce:	1aa8      	subs	r0, r5, r2
34016fd0:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016fd4:	ed90 6f00 	ldc	15, cr6, [r0]
34016fd8:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
34016fdc:	ffbb 6646 	vcvt.f32.s32	q3, q3
34016fe0:	f1bc 0c01 	subs.w	ip, ip, #1
34016fe4:	eefd ea10 	vmrs	lr, <impl def 0xd>
34016fe8:	ee37 6e64 	cdp	14, 3, cr6, cr7, cr4, {3}
34016fec:	f1a2 0204 	sub.w	r2, r2, #4
34016ff0:	d1e2      	bne.n	34016fb8 <lite_convert_is8of32+0x20>
34016ff2:	eeed ea10 	vmsr	<impl def 0xd>, lr
34016ff6:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34016ffa:	ed81 7f00 	stc	15, cr7, [r1]
34016ffe:	bd70      	pop	{r4, r5, r6, pc}
34017000:	4770      	bx	lr
34017002:	bf00      	nop

34017004 <lite_convert_iu8of32>:
34017004:	2a00      	cmp	r2, #0
34017006:	dd22      	ble.n	3401704e <lite_convert_iu8of32+0x4a>
34017008:	b530      	push	{r4, r5, lr}
3401700a:	f102 3eff 	add.w	lr, r2, #4294967295
3401700e:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
34017012:	f10e 0e01 	add.w	lr, lr, #1
34017016:	ee10 5a10 	vmov	r5, s0
3401701a:	f04e e001 	dls	lr, lr
3401701e:	1884      	adds	r4, r0, r2
34017020:	f022 e801 	bfcsel	0, 34017026 <lite_convert_iu8of32+0x22>, 4, hi
34017024:	1aa0      	subs	r0, r4, r2
34017026:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401702a:	fd90 6f00 	ldc2	15, cr6, [r0]
3401702e:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
34017032:	ffbb 6646 	vcvt.f32.s32	q3, q3
34017036:	4608      	mov	r0, r1
34017038:	ee37 6e65 	cdp	14, 3, cr6, cr7, cr5, {3}
3401703c:	3a04      	subs	r2, #4
3401703e:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34017042:	ed80 7f00 	stc	15, cr7, [r0]
34017046:	3110      	adds	r1, #16
34017048:	f00f c017 	le	lr, 34017020 <lite_convert_iu8of32+0x1c>
3401704c:	bd30      	pop	{r4, r5, pc}
3401704e:	4770      	bx	lr

34017050 <lite_convert_if32os8>:
34017050:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34017054:	ee07 3a10 	vmov	s14, r3
34017058:	eec7 7a80 	vdiv.f32	s15, s15, s0
3401705c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34017060:	ee17 ca90 	vmov	ip, s15
34017064:	b500      	push	{lr}
34017066:	ed2d 8b10 	vpush	{d8-d15}
3401706a:	ee17 3a10 	vmov	r3, s14
3401706e:	eea8 cb10 	vdup.32	q4, ip
34017072:	b09d      	sub	sp, #116	@ 0x74
34017074:	eea0 3b10 	vdup.32	q0, r3
34017078:	2a00      	cmp	r2, #0
3401707a:	ab10      	add	r3, sp, #64	@ 0x40
3401707c:	ed83 9f00 	stc	15, cr9, [r3]
34017080:	dd6a      	ble.n	34017158 <lite_convert_if32os8+0x108>
34017082:	2a0f      	cmp	r2, #15
34017084:	dd6d      	ble.n	34017162 <lite_convert_if32os8+0x112>
34017086:	f1a2 0c10 	sub.w	ip, r2, #16
3401708a:	ea4f 131c 	mov.w	r3, ip, lsr #4
3401708e:	3301      	adds	r3, #1
34017090:	f1bc 0f00 	cmp.w	ip, #0
34017094:	f04f 0e01 	mov.w	lr, #1
34017098:	ed9f 2b61 	vldr	d2, [pc, #388]	@ 34017220 <lite_convert_if32os8+0x1d0>
3401709c:	ed9f 3b62 	vldr	d3, [pc, #392]	@ 34017228 <lite_convert_if32os8+0x1d8>
340170a0:	bfa8      	it	ge
340170a2:	469e      	movge	lr, r3
340170a4:	ab14      	add	r3, sp, #80	@ 0x50
340170a6:	ed9f 4b62 	vldr	d4, [pc, #392]	@ 34017230 <lite_convert_if32os8+0x1e0>
340170aa:	ed9f 5b63 	vldr	d5, [pc, #396]	@ 34017238 <lite_convert_if32os8+0x1e8>
340170ae:	f04e e001 	dls	lr, lr
340170b2:	ef22 6152 	vorr	q3, q1, q1
340170b6:	ed83 9f00 	stc	15, cr9, [r3]
340170ba:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
340170be:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
340170c2:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
340170c6:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
340170ca:	466b      	mov	r3, sp
340170cc:	ec8d 8b10 	vstmia	sp, {d8-d15}
340170d0:	ed93 df00 	ldc	15, cr13, [r3]
340170d4:	ab14      	add	r3, sp, #80	@ 0x50
340170d6:	ed93 ff00 	ldc	15, cr15, [r3]
340170da:	ef20 a150 	vorr	q5, q0, q0
340170de:	ef0c ac5e 	vfma.f32	q5, q6, q7
340170e2:	ffbb a04a 	vcvta.s32.f32	q5, q5
340170e6:	ab04      	add	r3, sp, #16
340170e8:	ed93 df00 	ldc	15, cr13, [r3]
340170ec:	ee37 6e0b 	cdp	14, 3, cr6, cr7, cr11, {0}
340170f0:	ef20 a150 	vorr	q5, q0, q0
340170f4:	ef0c ac5e 	vfma.f32	q5, q6, q7
340170f8:	ffbb a04a 	vcvta.s32.f32	q5, q5
340170fc:	ab08      	add	r3, sp, #32
340170fe:	ee37 2e0b 	cdp	14, 3, cr2, cr7, cr11, {0}
34017102:	ef20 c150 	vorr	q6, q0, q0
34017106:	ed93 bf00 	ldc	15, cr11, [r3]
3401710a:	ab0c      	add	r3, sp, #48	@ 0x30
3401710c:	ef0a cc5e 	vfma.f32	q6, q5, q7
34017110:	ed93 9f00 	ldc	15, cr9, [r3]
34017114:	ef20 a150 	vorr	q5, q0, q0
34017118:	ffbb c04c 	vcvta.s32.f32	q6, q6
3401711c:	ef08 ac5e 	vfma.f32	q5, q4, q7
34017120:	ee37 7e0d 	cdp	14, 3, cr7, cr7, cr13, {0}
34017124:	ffbb a04a 	vcvta.s32.f32	q5, q5
34017128:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
3401712c:	ee37 3e0b 	cdp	14, 3, cr3, cr7, cr11, {0}
34017130:	f002 e801 	bfcsel	0, 34017136 <lite_convert_if32os8+0xe6>, 4, eq
34017134:	468c      	mov	ip, r1
34017136:	ee33 5e03 	cdp	14, 3, cr5, cr3, cr3, {0}
3401713a:	3110      	adds	r1, #16
3401713c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34017140:	ed8c 5e00 	stc	14, cr5, [ip]
34017144:	3a10      	subs	r2, #16
34017146:	f00f c049 	le	lr, 340170ba <lite_convert_if32os8+0x6a>
3401714a:	ab14      	add	r3, sp, #80	@ 0x50
3401714c:	ed83 5e00 	stc	14, cr5, [r3]
34017150:	ab18      	add	r3, sp, #96	@ 0x60
34017152:	ed83 3e80 	stc	14, cr3, [r3, #512]	@ 0x200
34017156:	b9a2      	cbnz	r2, 34017182 <lite_convert_if32os8+0x132>
34017158:	b01d      	add	sp, #116	@ 0x74
3401715a:	ecbd 8b10 	vpop	{d8-d15}
3401715e:	f85d fb04 	ldr.w	pc, [sp], #4
34017162:	ed9f 4b2f 	vldr	d4, [pc, #188]	@ 34017220 <lite_convert_if32os8+0x1d0>
34017166:	ed9f 5b30 	vldr	d5, [pc, #192]	@ 34017228 <lite_convert_if32os8+0x1d8>
3401716a:	ed9f 6b31 	vldr	d6, [pc, #196]	@ 34017230 <lite_convert_if32os8+0x1e0>
3401716e:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 34017238 <lite_convert_if32os8+0x1e8>
34017172:	ab18      	add	r3, sp, #96	@ 0x60
34017174:	ed83 5e80 	stc	14, cr5, [r3, #512]	@ 0x200
34017178:	ab14      	add	r3, sp, #80	@ 0x50
3401717a:	ed83 7e00 	stc	14, cr7, [r3]
3401717e:	ef24 6154 	vorr	q3, q2, q2
34017182:	f002 e801 	bfcsel	0, 34017188 <lite_convert_if32os8+0x138>, 4, eq
34017186:	aa10      	add	r2, sp, #64	@ 0x40
34017188:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
3401718c:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
34017190:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
34017194:	fc90 9f61 	ldc2	15, cr9, [r0], {97}	@ 0x61
34017198:	ed92 5f00 	ldc	15, cr5, [r2]
3401719c:	ef20 2150 	vorr	q1, q0, q0
340171a0:	ef08 2c54 	vfma.f32	q1, q4, q2
340171a4:	ffbb 4042 	vcvta.s32.f32	q2, q1
340171a8:	466a      	mov	r2, sp
340171aa:	ee37 6e05 	cdp	14, 3, cr6, cr7, cr5, {0}
340171ae:	ed82 7e80 	stc	14, cr7, [r2, #512]	@ 0x200
340171b2:	aa10      	add	r2, sp, #64	@ 0x40
340171b4:	ed92 5f00 	ldc	15, cr5, [r2]
340171b8:	ef20 2150 	vorr	q1, q0, q0
340171bc:	ef0a 2c54 	vfma.f32	q1, q5, q2
340171c0:	aa18      	add	r2, sp, #96	@ 0x60
340171c2:	ffbb 6042 	vcvta.s32.f32	q3, q1
340171c6:	ed92 3e80 	ldc	14, cr3, [r2, #512]	@ 0x200
340171ca:	ee37 2e07 	cdp	14, 3, cr2, cr7, cr7, {0}
340171ce:	aa10      	add	r2, sp, #64	@ 0x40
340171d0:	ef22 4152 	vorr	q2, q1, q1
340171d4:	ed92 3f00 	ldc	15, cr3, [r2]
340171d8:	ef20 6150 	vorr	q3, q0, q0
340171dc:	ef0e 0c52 	vfma.f32	q0, q7, q1
340171e0:	ef0c 6c52 	vfma.f32	q3, q6, q1
340171e4:	466a      	mov	r2, sp
340171e6:	ef20 2150 	vorr	q1, q0, q0
340171ea:	ffbb 0046 	vcvta.s32.f32	q0, q3
340171ee:	ffbb 2042 	vcvta.s32.f32	q1, q1
340171f2:	ed92 7e80 	ldc	14, cr7, [r2, #512]	@ 0x200
340171f6:	aa14      	add	r2, sp, #80	@ 0x50
340171f8:	ee37 5e03 	cdp	14, 3, cr5, cr7, cr3, {0}
340171fc:	ee37 7e01 	cdp	14, 3, cr7, cr7, cr1, {0}
34017200:	ed92 3e00 	ldc	14, cr3, [r2]
34017204:	ee33 2e07 	cdp	14, 3, cr2, cr3, cr7, {0}
34017208:	ee33 3e05 	cdp	14, 3, cr3, cr3, cr5, {0}
3401720c:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34017210:	ed81 3e00 	stc	14, cr3, [r1]
34017214:	b01d      	add	sp, #116	@ 0x74
34017216:	ecbd 8b10 	vpop	{d8-d15}
3401721a:	f85d fb04 	ldr.w	pc, [sp], #4
3401721e:	bf00      	nop
	...

34017240 <lite_convert_if32ou8>:
34017240:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34017244:	2a00      	cmp	r2, #0
34017246:	eec7 7a80 	vdiv.f32	s15, s15, s0
3401724a:	dd72      	ble.n	34017332 <lite_convert_if32ou8+0xf2>
3401724c:	ee07 3a10 	vmov	s14, r3
34017250:	eeb8 7a47 	vcvt.f32.u32	s14, s14
34017254:	ee17 ca90 	vmov	ip, s15
34017258:	b500      	push	{lr}
3401725a:	ed2d 8b10 	vpush	{d8-d15}
3401725e:	ee17 3a10 	vmov	r3, s14
34017262:	eea8 cb10 	vdup.32	q4, ip
34017266:	ed9f 6b34 	vldr	d6, [pc, #208]	@ 34017338 <lite_convert_if32ou8+0xf8>
3401726a:	ed9f 7b35 	vldr	d7, [pc, #212]	@ 34017340 <lite_convert_if32ou8+0x100>
3401726e:	f102 3eff 	add.w	lr, r2, #4294967295
34017272:	b095      	sub	sp, #84	@ 0x54
34017274:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
34017278:	eea0 3b10 	vdup.32	q0, r3
3401727c:	f10e 0e01 	add.w	lr, lr, #1
34017280:	ab10      	add	r3, sp, #64	@ 0x40
34017282:	ed9f 2b31 	vldr	d2, [pc, #196]	@ 34017348 <lite_convert_if32ou8+0x108>
34017286:	ed9f 3b32 	vldr	d3, [pc, #200]	@ 34017350 <lite_convert_if32ou8+0x110>
3401728a:	f04e e001 	dls	lr, lr
3401728e:	ef26 4156 	vorr	q2, q3, q3
34017292:	ed83 9f00 	stc	15, cr9, [r3]
34017296:	4411      	add	r1, r2
34017298:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
3401729c:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
340172a0:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
340172a4:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
340172a8:	466b      	mov	r3, sp
340172aa:	ec8d 8b10 	vstmia	sp, {d8-d15}
340172ae:	ed93 df00 	ldc	15, cr13, [r3]
340172b2:	ab10      	add	r3, sp, #64	@ 0x40
340172b4:	ed93 ff00 	ldc	15, cr15, [r3]
340172b8:	ef20 a150 	vorr	q5, q0, q0
340172bc:	ef0c ac5e 	vfma.f32	q5, q6, q7
340172c0:	ffbb a0ca 	vcvta.u32.f32	q5, q5
340172c4:	ab04      	add	r3, sp, #16
340172c6:	ed93 df00 	ldc	15, cr13, [r3]
340172ca:	fe37 4e0b 	cdp2	14, 3, cr4, cr7, cr11, {0}
340172ce:	ef20 a150 	vorr	q5, q0, q0
340172d2:	ef0c ac5e 	vfma.f32	q5, q6, q7
340172d6:	ffbb a0ca 	vcvta.u32.f32	q5, q5
340172da:	ab08      	add	r3, sp, #32
340172dc:	fe37 6e0b 	cdp2	14, 3, cr6, cr7, cr11, {0}
340172e0:	ef20 c150 	vorr	q6, q0, q0
340172e4:	ed93 bf00 	ldc	15, cr11, [r3]
340172e8:	ab0c      	add	r3, sp, #48	@ 0x30
340172ea:	ef0a cc5e 	vfma.f32	q6, q5, q7
340172ee:	ed93 9f00 	ldc	15, cr9, [r3]
340172f2:	ef20 a150 	vorr	q5, q0, q0
340172f6:	ffbb c0cc 	vcvta.u32.f32	q6, q6
340172fa:	ef08 ac5e 	vfma.f32	q5, q4, q7
340172fe:	fe37 5e0d 	cdp2	14, 3, cr5, cr7, cr13, {0}
34017302:	ffbb a0ca 	vcvta.u32.f32	q5, q5
34017306:	fe33 2e05 	cdp2	14, 3, cr2, cr3, cr5, {0}
3401730a:	fe37 7e0b 	cdp2	14, 3, cr7, cr7, cr11, {0}
3401730e:	f022 e801 	bfcsel	0, 34017314 <lite_convert_if32ou8+0xd4>, 4, hi
34017312:	fe33 3e07 	cdp2	14, 3, cr3, cr3, cr7, {0}
34017316:	eba1 0c02 	sub.w	ip, r1, r2
3401731a:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
3401731e:	ed8c 3e00 	stc	14, cr3, [ip]
34017322:	3a10      	subs	r2, #16
34017324:	f00f c049 	le	lr, 34017298 <lite_convert_if32ou8+0x58>
34017328:	b015      	add	sp, #84	@ 0x54
3401732a:	ecbd 8b10 	vpop	{d8-d15}
3401732e:	f85d fb04 	ldr.w	pc, [sp], #4
34017332:	4770      	bx	lr
34017334:	f3af 8000 	nop.w
	...

34017358 <st_f32_to_int16>:
34017358:	b570      	push	{r4, r5, r6, lr}
3401735a:	08d5      	lsrs	r5, r2, #3
3401735c:	ed2d 8b08 	vpush	{d8-d11}
34017360:	d022      	beq.n	340173a8 <st_f32_to_int16+0x50>
34017362:	460c      	mov	r4, r1
34017364:	ed9f 6b60 	vldr	d6, [pc, #384]	@ 340174e8 <st_f32_to_int16+0x190>
34017368:	ed9f 7b61 	vldr	d7, [pc, #388]	@ 340174f0 <st_f32_to_int16+0x198>
3401736c:	4684      	mov	ip, r0
3401736e:	f045 e001 	dls	lr, r5
34017372:	4b61      	ldr	r3, [pc, #388]	@ (340174f8 <st_f32_to_int16+0x1a0>)
34017374:	fc9c 9f00 	ldc2	15, cr9, [ip], {0}
34017378:	fcbc 9f20 	ldc2	15, cr9, [ip], #128	@ 0x80
3401737c:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
34017380:	ee3b 4e63 	cdp	14, 3, cr4, cr11, cr3, {3}
34017384:	ffbb 2042 	vcvta.s32.f32	q1, q1
34017388:	ffbb 4044 	vcvta.s32.f32	q2, q2
3401738c:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
34017390:	4626      	mov	r6, r4
34017392:	ee37 7e05 	cdp	14, 3, cr7, cr7, cr5, {0}
34017396:	3410      	adds	r4, #16
34017398:	ed86 7e80 	stc	14, cr7, [r6, #512]	@ 0x200
3401739c:	f00f c017 	le	lr, 34017374 <st_f32_to_int16+0x1c>
340173a0:	eb00 1045 	add.w	r0, r0, r5, lsl #5
340173a4:	eb01 1105 	add.w	r1, r1, r5, lsl #4
340173a8:	f012 0207 	ands.w	r2, r2, #7
340173ac:	f000 8097 	beq.w	340174de <st_f32_to_int16+0x186>
340173b0:	edd0 5a00 	vldr	s11, [r0]
340173b4:	ed9f 6a51 	vldr	s12, [pc, #324]	@ 340174fc <st_f32_to_int16+0x1a4>
340173b8:	ee65 5a86 	vmul.f32	s11, s11, s12
340173bc:	eef5 5ac0 	vcmpe.f32	s11, #0.0
340173c0:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
340173c4:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
340173c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340173cc:	fe77 7a26 	vselgt.f32	s15, s14, s13
340173d0:	ee77 7aa5 	vadd.f32	s15, s15, s11
340173d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340173d8:	ee17 3a90 	vmov	r3, s15
340173dc:	f303 030f 	ssat	r3, #16, r3
340173e0:	2a01      	cmp	r2, #1
340173e2:	800b      	strh	r3, [r1, #0]
340173e4:	d07b      	beq.n	340174de <st_f32_to_int16+0x186>
340173e6:	edd0 7a01 	vldr	s15, [r0, #4]
340173ea:	ee67 7a86 	vmul.f32	s15, s15, s12
340173ee:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340173f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340173f6:	fe77 5a26 	vselgt.f32	s11, s14, s13
340173fa:	ee77 7aa5 	vadd.f32	s15, s15, s11
340173fe:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017402:	ee17 3a90 	vmov	r3, s15
34017406:	f303 030f 	ssat	r3, #16, r3
3401740a:	2a02      	cmp	r2, #2
3401740c:	804b      	strh	r3, [r1, #2]
3401740e:	d066      	beq.n	340174de <st_f32_to_int16+0x186>
34017410:	edd0 7a02 	vldr	s15, [r0, #8]
34017414:	ee67 7a86 	vmul.f32	s15, s15, s12
34017418:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401741c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017420:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017424:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017428:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401742c:	ee17 3a90 	vmov	r3, s15
34017430:	f303 030f 	ssat	r3, #16, r3
34017434:	2a03      	cmp	r2, #3
34017436:	808b      	strh	r3, [r1, #4]
34017438:	d051      	beq.n	340174de <st_f32_to_int16+0x186>
3401743a:	edd0 7a03 	vldr	s15, [r0, #12]
3401743e:	ee67 7a86 	vmul.f32	s15, s15, s12
34017442:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017446:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401744a:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401744e:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017452:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017456:	ee17 3a90 	vmov	r3, s15
3401745a:	f303 030f 	ssat	r3, #16, r3
3401745e:	2a04      	cmp	r2, #4
34017460:	80cb      	strh	r3, [r1, #6]
34017462:	d03c      	beq.n	340174de <st_f32_to_int16+0x186>
34017464:	edd0 7a04 	vldr	s15, [r0, #16]
34017468:	ee67 7a86 	vmul.f32	s15, s15, s12
3401746c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017474:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017478:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401747c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017480:	ee17 3a90 	vmov	r3, s15
34017484:	f303 030f 	ssat	r3, #16, r3
34017488:	3a05      	subs	r2, #5
3401748a:	810b      	strh	r3, [r1, #8]
3401748c:	d027      	beq.n	340174de <st_f32_to_int16+0x186>
3401748e:	edd0 7a05 	vldr	s15, [r0, #20]
34017492:	ee67 7a86 	vmul.f32	s15, s15, s12
34017496:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401749a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401749e:	fe77 5a26 	vselgt.f32	s11, s14, s13
340174a2:	ee77 7aa5 	vadd.f32	s15, s15, s11
340174a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340174aa:	ee17 3a90 	vmov	r3, s15
340174ae:	f303 030f 	ssat	r3, #16, r3
340174b2:	2a01      	cmp	r2, #1
340174b4:	814b      	strh	r3, [r1, #10]
340174b6:	d012      	beq.n	340174de <st_f32_to_int16+0x186>
340174b8:	edd0 7a06 	vldr	s15, [r0, #24]
340174bc:	ee67 7a86 	vmul.f32	s15, s15, s12
340174c0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340174c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340174c8:	fe37 7a26 	vselgt.f32	s14, s14, s13
340174cc:	ee37 7a27 	vadd.f32	s14, s14, s15
340174d0:	eebd 7ac7 	vcvt.s32.f32	s14, s14
340174d4:	ee17 3a10 	vmov	r3, s14
340174d8:	f303 030f 	ssat	r3, #16, r3
340174dc:	818b      	strh	r3, [r1, #12]
340174de:	ecbd 8b08 	vpop	{d8-d11}
340174e2:	bd70      	pop	{r4, r5, r6, pc}
340174e4:	f3af 8000 	nop.w
	...
340174f8:	46fffe00 	.word	0x46fffe00
340174fc:	47000000 	.word	0x47000000

34017500 <st_f32_to_int8>:
34017500:	b570      	push	{r4, r5, r6, lr}
34017502:	0915      	lsrs	r5, r2, #4
34017504:	ed2d 8b10 	vpush	{d8-d15}
34017508:	f000 81a5 	beq.w	34017856 <st_f32_to_int8+0x356>
3401750c:	ed9f 0bd4 	vldr	d0, [pc, #848]	@ 34017860 <st_f32_to_int8+0x360>
34017510:	ed9f 1bd5 	vldr	d1, [pc, #852]	@ 34017868 <st_f32_to_int8+0x368>
34017514:	ea4f 1e05 	mov.w	lr, r5, lsl #4
34017518:	f1ae 0e10 	sub.w	lr, lr, #16
3401751c:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
34017520:	f10e 0e01 	add.w	lr, lr, #1
34017524:	ed9f 4bd2 	vldr	d4, [pc, #840]	@ 34017870 <st_f32_to_int8+0x370>
34017528:	ed9f 5bd3 	vldr	d5, [pc, #844]	@ 34017878 <st_f32_to_int8+0x378>
3401752c:	f04f 4386 	mov.w	r3, #1124073472	@ 0x43000000
34017530:	f04e e001 	dls	lr, lr
34017534:	4684      	mov	ip, r0
34017536:	ef20 6150 	vorr	q3, q0, q0
3401753a:	eb01 1405 	add.w	r4, r1, r5, lsl #4
3401753e:	fc9c 9f01 	ldc2	15, cr9, [ip], {1}
34017542:	fc9c 9f21 	ldc2	15, cr9, [ip], {33}	@ 0x21
34017546:	fc9c 9f41 	ldc2	15, cr9, [ip], {65}	@ 0x41
3401754a:	fcbc 9f61 	ldc2	15, cr9, [ip], #388	@ 0x184
3401754e:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
34017552:	ffbb 2042 	vcvta.s32.f32	q1, q1
34017556:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
3401755a:	ee3b 2e63 	cdp	14, 3, cr2, cr11, cr3, {3}
3401755e:	ffbb 2042 	vcvta.s32.f32	q1, q1
34017562:	ee37 0e03 	cdp	14, 3, cr0, cr7, cr3, {0}
34017566:	ee3d 2e63 	cdp	14, 3, cr2, cr13, cr3, {3}
3401756a:	ee3f 8e63 	cdp	14, 3, cr8, cr15, cr3, {3}
3401756e:	ffbb 2042 	vcvta.s32.f32	q1, q1
34017572:	ffbb 8048 	vcvta.s32.f32	q4, q4
34017576:	ee37 7e03 	cdp	14, 3, cr7, cr7, cr3, {0}
3401757a:	ee37 1e09 	cdp	14, 3, cr1, cr7, cr9, {0}
3401757e:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
34017582:	460e      	mov	r6, r1
34017584:	ee33 5e01 	cdp	14, 3, cr5, cr3, cr1, {0}
34017588:	3110      	adds	r1, #16
3401758a:	ed86 5e00 	stc	14, cr5, [r6]
3401758e:	f00f c02b 	le	lr, 3401753e <st_f32_to_int8+0x3e>
34017592:	eb00 1085 	add.w	r0, r0, r5, lsl #6
34017596:	f012 030f 	ands.w	r3, r2, #15
3401759a:	f000 8159 	beq.w	34017850 <st_f32_to_int8+0x350>
3401759e:	edd0 5a00 	vldr	s11, [r0]
340175a2:	ed9f 6ab7 	vldr	s12, [pc, #732]	@ 34017880 <st_f32_to_int8+0x380>
340175a6:	ee65 5a86 	vmul.f32	s11, s11, s12
340175aa:	eef5 5ac0 	vcmpe.f32	s11, #0.0
340175ae:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
340175b2:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
340175b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340175ba:	fe77 7a26 	vselgt.f32	s15, s14, s13
340175be:	ee77 7aa5 	vadd.f32	s15, s15, s11
340175c2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340175c6:	ee17 2a90 	vmov	r2, s15
340175ca:	b212      	sxth	r2, r2
340175cc:	f302 0207 	ssat	r2, #8, r2
340175d0:	2b01      	cmp	r3, #1
340175d2:	7022      	strb	r2, [r4, #0]
340175d4:	f000 813c 	beq.w	34017850 <st_f32_to_int8+0x350>
340175d8:	edd0 7a01 	vldr	s15, [r0, #4]
340175dc:	ee67 7a86 	vmul.f32	s15, s15, s12
340175e0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340175e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340175e8:	fe77 5a26 	vselgt.f32	s11, s14, s13
340175ec:	ee77 7aa5 	vadd.f32	s15, s15, s11
340175f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340175f4:	ee17 2a90 	vmov	r2, s15
340175f8:	b212      	sxth	r2, r2
340175fa:	f302 0207 	ssat	r2, #8, r2
340175fe:	2b02      	cmp	r3, #2
34017600:	7062      	strb	r2, [r4, #1]
34017602:	f000 8125 	beq.w	34017850 <st_f32_to_int8+0x350>
34017606:	edd0 7a02 	vldr	s15, [r0, #8]
3401760a:	ee67 7a86 	vmul.f32	s15, s15, s12
3401760e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017612:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017616:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401761a:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401761e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017622:	ee17 2a90 	vmov	r2, s15
34017626:	b212      	sxth	r2, r2
34017628:	f302 0207 	ssat	r2, #8, r2
3401762c:	2b03      	cmp	r3, #3
3401762e:	70a2      	strb	r2, [r4, #2]
34017630:	f000 810e 	beq.w	34017850 <st_f32_to_int8+0x350>
34017634:	edd0 7a03 	vldr	s15, [r0, #12]
34017638:	ee67 7a86 	vmul.f32	s15, s15, s12
3401763c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017644:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017648:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401764c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017650:	ee17 2a90 	vmov	r2, s15
34017654:	b212      	sxth	r2, r2
34017656:	f302 0207 	ssat	r2, #8, r2
3401765a:	2b04      	cmp	r3, #4
3401765c:	70e2      	strb	r2, [r4, #3]
3401765e:	f000 80f7 	beq.w	34017850 <st_f32_to_int8+0x350>
34017662:	edd0 7a04 	vldr	s15, [r0, #16]
34017666:	ee67 7a86 	vmul.f32	s15, s15, s12
3401766a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401766e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017672:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017676:	ee77 7aa5 	vadd.f32	s15, s15, s11
3401767a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3401767e:	ee17 2a90 	vmov	r2, s15
34017682:	b212      	sxth	r2, r2
34017684:	f302 0207 	ssat	r2, #8, r2
34017688:	2b05      	cmp	r3, #5
3401768a:	7122      	strb	r2, [r4, #4]
3401768c:	f000 80e0 	beq.w	34017850 <st_f32_to_int8+0x350>
34017690:	edd0 7a05 	vldr	s15, [r0, #20]
34017694:	ee67 7a86 	vmul.f32	s15, s15, s12
34017698:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3401769c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340176a0:	fe77 5a26 	vselgt.f32	s11, s14, s13
340176a4:	ee77 7aa5 	vadd.f32	s15, s15, s11
340176a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340176ac:	ee17 2a90 	vmov	r2, s15
340176b0:	b212      	sxth	r2, r2
340176b2:	f302 0207 	ssat	r2, #8, r2
340176b6:	2b06      	cmp	r3, #6
340176b8:	7162      	strb	r2, [r4, #5]
340176ba:	f000 80c9 	beq.w	34017850 <st_f32_to_int8+0x350>
340176be:	edd0 7a06 	vldr	s15, [r0, #24]
340176c2:	ee67 7a86 	vmul.f32	s15, s15, s12
340176c6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340176ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340176ce:	fe77 5a26 	vselgt.f32	s11, s14, s13
340176d2:	ee77 7aa5 	vadd.f32	s15, s15, s11
340176d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340176da:	ee17 2a90 	vmov	r2, s15
340176de:	b212      	sxth	r2, r2
340176e0:	f302 0207 	ssat	r2, #8, r2
340176e4:	2b07      	cmp	r3, #7
340176e6:	71a2      	strb	r2, [r4, #6]
340176e8:	f000 80b2 	beq.w	34017850 <st_f32_to_int8+0x350>
340176ec:	edd0 7a07 	vldr	s15, [r0, #28]
340176f0:	ee67 7a86 	vmul.f32	s15, s15, s12
340176f4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340176f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340176fc:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017700:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017704:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017708:	ee17 2a90 	vmov	r2, s15
3401770c:	b212      	sxth	r2, r2
3401770e:	f302 0207 	ssat	r2, #8, r2
34017712:	2b08      	cmp	r3, #8
34017714:	71e2      	strb	r2, [r4, #7]
34017716:	f000 809b 	beq.w	34017850 <st_f32_to_int8+0x350>
3401771a:	edd0 7a08 	vldr	s15, [r0, #32]
3401771e:	ee67 7a86 	vmul.f32	s15, s15, s12
34017722:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017726:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401772a:	fe37 7a26 	vselgt.f32	s14, s14, s13
3401772e:	ee77 7a87 	vadd.f32	s15, s15, s14
34017732:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017736:	ee17 2a90 	vmov	r2, s15
3401773a:	b212      	sxth	r2, r2
3401773c:	f302 0207 	ssat	r2, #8, r2
34017740:	2b09      	cmp	r3, #9
34017742:	7222      	strb	r2, [r4, #8]
34017744:	f000 8084 	beq.w	34017850 <st_f32_to_int8+0x350>
34017748:	edd0 7a09 	vldr	s15, [r0, #36]	@ 0x24
3401774c:	ee67 7a86 	vmul.f32	s15, s15, s12
34017750:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017754:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34017758:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401775c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017760:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017764:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017768:	ee17 2a90 	vmov	r2, s15
3401776c:	b212      	sxth	r2, r2
3401776e:	f302 0207 	ssat	r2, #8, r2
34017772:	2b0a      	cmp	r3, #10
34017774:	7262      	strb	r2, [r4, #9]
34017776:	d06b      	beq.n	34017850 <st_f32_to_int8+0x350>
34017778:	edd0 7a0a 	vldr	s15, [r0, #40]	@ 0x28
3401777c:	ee67 7a86 	vmul.f32	s15, s15, s12
34017780:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017784:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017788:	fe77 5a26 	vselgt.f32	s11, s14, s13
3401778c:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017790:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017794:	ee17 2a90 	vmov	r2, s15
34017798:	b212      	sxth	r2, r2
3401779a:	f302 0207 	ssat	r2, #8, r2
3401779e:	2b0b      	cmp	r3, #11
340177a0:	72a2      	strb	r2, [r4, #10]
340177a2:	d055      	beq.n	34017850 <st_f32_to_int8+0x350>
340177a4:	edd0 7a0b 	vldr	s15, [r0, #44]	@ 0x2c
340177a8:	ee67 7a86 	vmul.f32	s15, s15, s12
340177ac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340177b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340177b4:	fe77 5a26 	vselgt.f32	s11, s14, s13
340177b8:	ee77 7aa5 	vadd.f32	s15, s15, s11
340177bc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340177c0:	ee17 2a90 	vmov	r2, s15
340177c4:	b212      	sxth	r2, r2
340177c6:	f302 0207 	ssat	r2, #8, r2
340177ca:	2b0c      	cmp	r3, #12
340177cc:	72e2      	strb	r2, [r4, #11]
340177ce:	d03f      	beq.n	34017850 <st_f32_to_int8+0x350>
340177d0:	edd0 7a0c 	vldr	s15, [r0, #48]	@ 0x30
340177d4:	ee67 7a86 	vmul.f32	s15, s15, s12
340177d8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340177dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340177e0:	fe77 5a26 	vselgt.f32	s11, s14, s13
340177e4:	ee77 7aa5 	vadd.f32	s15, s15, s11
340177e8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340177ec:	ee17 2a90 	vmov	r2, s15
340177f0:	b212      	sxth	r2, r2
340177f2:	f302 0207 	ssat	r2, #8, r2
340177f6:	3b0d      	subs	r3, #13
340177f8:	7322      	strb	r2, [r4, #12]
340177fa:	d029      	beq.n	34017850 <st_f32_to_int8+0x350>
340177fc:	edd0 7a0d 	vldr	s15, [r0, #52]	@ 0x34
34017800:	ee67 7a86 	vmul.f32	s15, s15, s12
34017804:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34017808:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401780c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34017810:	ee77 7aa5 	vadd.f32	s15, s15, s11
34017814:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017818:	ee17 2a90 	vmov	r2, s15
3401781c:	b212      	sxth	r2, r2
3401781e:	f302 0207 	ssat	r2, #8, r2
34017822:	2b01      	cmp	r3, #1
34017824:	7362      	strb	r2, [r4, #13]
34017826:	d013      	beq.n	34017850 <st_f32_to_int8+0x350>
34017828:	edd0 7a0e 	vldr	s15, [r0, #56]	@ 0x38
3401782c:	ee27 6a86 	vmul.f32	s12, s15, s12
34017830:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
34017834:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017838:	fe77 7a26 	vselgt.f32	s15, s14, s13
3401783c:	ee77 7a86 	vadd.f32	s15, s15, s12
34017840:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34017844:	ee17 3a90 	vmov	r3, s15
34017848:	b21b      	sxth	r3, r3
3401784a:	f303 0307 	ssat	r3, #8, r3
3401784e:	73a3      	strb	r3, [r4, #14]
34017850:	ecbd 8b10 	vpop	{d8-d15}
34017854:	bd70      	pop	{r4, r5, r6, pc}
34017856:	460c      	mov	r4, r1
34017858:	e69d      	b.n	34017596 <st_f32_to_int8+0x96>
3401785a:	bf00      	nop
3401785c:	f3af 8000 	nop.w
	...
34017880:	43000000 	.word	0x43000000

34017884 <st_int16_to_f32>:
34017884:	ea5f 0c92 	movs.w	ip, r2, lsr #2
34017888:	b530      	push	{r4, r5, lr}
3401788a:	d013      	beq.n	340178b4 <st_int16_to_f32+0x30>
3401788c:	4604      	mov	r4, r0
3401788e:	460b      	mov	r3, r1
34017890:	f04c e001 	dls	lr, ip
34017894:	4625      	mov	r5, r4
34017896:	ed9d 6f00 	ldc	15, cr6, [sp]
3401789a:	461d      	mov	r5, r3
3401789c:	efb1 6e56 	vcvt.f32.s32	q3, q3, #15
340178a0:	3408      	adds	r4, #8
340178a2:	ed85 7f00 	stc	15, cr7, [r5]
340178a6:	3310      	adds	r3, #16
340178a8:	f00f c00d 	le	lr, 34017894 <st_int16_to_f32+0x10>
340178ac:	eb01 110c 	add.w	r1, r1, ip, lsl #4
340178b0:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
340178b4:	f012 0203 	ands.w	r2, r2, #3
340178b8:	d023      	beq.n	34017902 <st_int16_to_f32+0x7e>
340178ba:	f9b0 3000 	ldrsh.w	r3, [r0]
340178be:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 34017904 <st_int16_to_f32+0x80>
340178c2:	ee07 3a90 	vmov	s15, r3
340178c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340178ca:	ee67 7a87 	vmul.f32	s15, s15, s14
340178ce:	3a01      	subs	r2, #1
340178d0:	edc1 7a00 	vstr	s15, [r1]
340178d4:	d015      	beq.n	34017902 <st_int16_to_f32+0x7e>
340178d6:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
340178da:	2a01      	cmp	r2, #1
340178dc:	ee07 3a90 	vmov	s15, r3
340178e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340178e4:	ee67 7a87 	vmul.f32	s15, s15, s14
340178e8:	edc1 7a01 	vstr	s15, [r1, #4]
340178ec:	d009      	beq.n	34017902 <st_int16_to_f32+0x7e>
340178ee:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
340178f2:	ee07 3a90 	vmov	s15, r3
340178f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340178fa:	ee67 7a87 	vmul.f32	s15, s15, s14
340178fe:	edc1 7a02 	vstr	s15, [r1, #8]
34017902:	bd30      	pop	{r4, r5, pc}
34017904:	38000000 	.word	0x38000000

34017908 <st_int8_to_f32>:
34017908:	ea5f 0c92 	movs.w	ip, r2, lsr #2
3401790c:	b530      	push	{r4, r5, lr}
3401790e:	d042      	beq.n	34017996 <st_int8_to_f32+0x8e>
34017910:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
34017914:	f1ae 0e04 	sub.w	lr, lr, #4
34017918:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
3401791c:	f10e 0e01 	add.w	lr, lr, #1
34017920:	f04e e001 	dls	lr, lr
34017924:	460b      	mov	r3, r1
34017926:	eb00 048c 	add.w	r4, r0, ip, lsl #2
3401792a:	4605      	mov	r5, r0
3401792c:	ed95 6f00 	ldc	15, cr6, [r5]
34017930:	461d      	mov	r5, r3
34017932:	efb9 6e56 	vcvt.f32.s32	q3, q3, #7
34017936:	3004      	adds	r0, #4
34017938:	ed85 7f00 	stc	15, cr7, [r5]
3401793c:	3310      	adds	r3, #16
3401793e:	f00f c00d 	le	lr, 3401792a <st_int8_to_f32+0x22>
34017942:	eb01 110c 	add.w	r1, r1, ip, lsl #4
34017946:	f012 0203 	ands.w	r2, r2, #3
3401794a:	d023      	beq.n	34017994 <st_int8_to_f32+0x8c>
3401794c:	f994 3000 	ldrsb.w	r3, [r4]
34017950:	ed9f 7a12 	vldr	s14, [pc, #72]	@ 3401799c <st_int8_to_f32+0x94>
34017954:	ee07 3a90 	vmov	s15, r3
34017958:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3401795c:	ee67 7a87 	vmul.f32	s15, s15, s14
34017960:	3a01      	subs	r2, #1
34017962:	edc1 7a00 	vstr	s15, [r1]
34017966:	d015      	beq.n	34017994 <st_int8_to_f32+0x8c>
34017968:	f994 3001 	ldrsb.w	r3, [r4, #1]
3401796c:	2a01      	cmp	r2, #1
3401796e:	ee07 3a90 	vmov	s15, r3
34017972:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34017976:	ee67 7a87 	vmul.f32	s15, s15, s14
3401797a:	edc1 7a01 	vstr	s15, [r1, #4]
3401797e:	d009      	beq.n	34017994 <st_int8_to_f32+0x8c>
34017980:	f994 3002 	ldrsb.w	r3, [r4, #2]
34017984:	ee07 3a90 	vmov	s15, r3
34017988:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3401798c:	ee67 7a87 	vmul.f32	s15, s15, s14
34017990:	edc1 7a02 	vstr	s15, [r1, #8]
34017994:	bd30      	pop	{r4, r5, pc}
34017996:	4604      	mov	r4, r0
34017998:	e7d5      	b.n	34017946 <st_int8_to_f32+0x3e>
3401799a:	bf00      	nop
3401799c:	3c000000 	.word	0x3c000000

340179a0 <__assert_func>:
340179a0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
340179a2:	4614      	mov	r4, r2
340179a4:	461a      	mov	r2, r3
340179a6:	4b09      	ldr	r3, [pc, #36]	@ (340179cc <__assert_func+0x2c>)
340179a8:	4605      	mov	r5, r0
340179aa:	681b      	ldr	r3, [r3, #0]
340179ac:	68d8      	ldr	r0, [r3, #12]
340179ae:	b14c      	cbz	r4, 340179c4 <__assert_func+0x24>
340179b0:	4b07      	ldr	r3, [pc, #28]	@ (340179d0 <__assert_func+0x30>)
340179b2:	9100      	str	r1, [sp, #0]
340179b4:	4907      	ldr	r1, [pc, #28]	@ (340179d4 <__assert_func+0x34>)
340179b6:	e9cd 3401 	strd	r3, r4, [sp, #4]
340179ba:	462b      	mov	r3, r5
340179bc:	f000 ff4e 	bl	3401885c <fiprintf>
340179c0:	f001 fbf4 	bl	340191ac <abort>
340179c4:	4b04      	ldr	r3, [pc, #16]	@ (340179d8 <__assert_func+0x38>)
340179c6:	461c      	mov	r4, r3
340179c8:	e7f3      	b.n	340179b2 <__assert_func+0x12>
340179ca:	bf00      	nop
340179cc:	3403eeec 	.word	0x3403eeec
340179d0:	3401e053 	.word	0x3401e053
340179d4:	3401e060 	.word	0x3401e060
340179d8:	3401d163 	.word	0x3401d163

340179dc <malloc>:
340179dc:	4b02      	ldr	r3, [pc, #8]	@ (340179e8 <malloc+0xc>)
340179de:	4601      	mov	r1, r0
340179e0:	6818      	ldr	r0, [r3, #0]
340179e2:	f000 b825 	b.w	34017a30 <_malloc_r>
340179e6:	bf00      	nop
340179e8:	3403eeec 	.word	0x3403eeec

340179ec <sbrk_aligned>:
340179ec:	b570      	push	{r4, r5, r6, lr}
340179ee:	4e0f      	ldr	r6, [pc, #60]	@ (34017a2c <sbrk_aligned+0x40>)
340179f0:	460c      	mov	r4, r1
340179f2:	4605      	mov	r5, r0
340179f4:	6831      	ldr	r1, [r6, #0]
340179f6:	b911      	cbnz	r1, 340179fe <sbrk_aligned+0x12>
340179f8:	f001 fb66 	bl	340190c8 <_sbrk_r>
340179fc:	6030      	str	r0, [r6, #0]
340179fe:	4621      	mov	r1, r4
34017a00:	4628      	mov	r0, r5
34017a02:	f001 fb61 	bl	340190c8 <_sbrk_r>
34017a06:	1c43      	adds	r3, r0, #1
34017a08:	d103      	bne.n	34017a12 <sbrk_aligned+0x26>
34017a0a:	f04f 34ff 	mov.w	r4, #4294967295
34017a0e:	4620      	mov	r0, r4
34017a10:	bd70      	pop	{r4, r5, r6, pc}
34017a12:	1cc4      	adds	r4, r0, #3
34017a14:	f024 0403 	bic.w	r4, r4, #3
34017a18:	42a0      	cmp	r0, r4
34017a1a:	d0f8      	beq.n	34017a0e <sbrk_aligned+0x22>
34017a1c:	1a21      	subs	r1, r4, r0
34017a1e:	4628      	mov	r0, r5
34017a20:	f001 fb52 	bl	340190c8 <_sbrk_r>
34017a24:	3001      	adds	r0, #1
34017a26:	d1f2      	bne.n	34017a0e <sbrk_aligned+0x22>
34017a28:	e7ef      	b.n	34017a0a <sbrk_aligned+0x1e>
34017a2a:	bf00      	nop
34017a2c:	340581dc 	.word	0x340581dc

34017a30 <_malloc_r>:
34017a30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34017a34:	1ccd      	adds	r5, r1, #3
34017a36:	4606      	mov	r6, r0
34017a38:	f025 0503 	bic.w	r5, r5, #3
34017a3c:	3508      	adds	r5, #8
34017a3e:	2d0c      	cmp	r5, #12
34017a40:	bf38      	it	cc
34017a42:	250c      	movcc	r5, #12
34017a44:	2d00      	cmp	r5, #0
34017a46:	db01      	blt.n	34017a4c <_malloc_r+0x1c>
34017a48:	42a9      	cmp	r1, r5
34017a4a:	d904      	bls.n	34017a56 <_malloc_r+0x26>
34017a4c:	230c      	movs	r3, #12
34017a4e:	6033      	str	r3, [r6, #0]
34017a50:	2000      	movs	r0, #0
34017a52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
34017a56:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 34017b2c <_malloc_r+0xfc>
34017a5a:	f000 f869 	bl	34017b30 <__malloc_lock>
34017a5e:	f8d8 3000 	ldr.w	r3, [r8]
34017a62:	461c      	mov	r4, r3
34017a64:	bb44      	cbnz	r4, 34017ab8 <_malloc_r+0x88>
34017a66:	4629      	mov	r1, r5
34017a68:	4630      	mov	r0, r6
34017a6a:	f7ff ffbf 	bl	340179ec <sbrk_aligned>
34017a6e:	1c43      	adds	r3, r0, #1
34017a70:	4604      	mov	r4, r0
34017a72:	d158      	bne.n	34017b26 <_malloc_r+0xf6>
34017a74:	f8d8 4000 	ldr.w	r4, [r8]
34017a78:	4627      	mov	r7, r4
34017a7a:	2f00      	cmp	r7, #0
34017a7c:	d143      	bne.n	34017b06 <_malloc_r+0xd6>
34017a7e:	2c00      	cmp	r4, #0
34017a80:	d04b      	beq.n	34017b1a <_malloc_r+0xea>
34017a82:	6823      	ldr	r3, [r4, #0]
34017a84:	4639      	mov	r1, r7
34017a86:	4630      	mov	r0, r6
34017a88:	eb04 0903 	add.w	r9, r4, r3
34017a8c:	f001 fb1c 	bl	340190c8 <_sbrk_r>
34017a90:	4581      	cmp	r9, r0
34017a92:	d142      	bne.n	34017b1a <_malloc_r+0xea>
34017a94:	6821      	ldr	r1, [r4, #0]
34017a96:	4630      	mov	r0, r6
34017a98:	1a6d      	subs	r5, r5, r1
34017a9a:	4629      	mov	r1, r5
34017a9c:	f7ff ffa6 	bl	340179ec <sbrk_aligned>
34017aa0:	3001      	adds	r0, #1
34017aa2:	d03a      	beq.n	34017b1a <_malloc_r+0xea>
34017aa4:	6823      	ldr	r3, [r4, #0]
34017aa6:	442b      	add	r3, r5
34017aa8:	6023      	str	r3, [r4, #0]
34017aaa:	f8d8 3000 	ldr.w	r3, [r8]
34017aae:	685a      	ldr	r2, [r3, #4]
34017ab0:	bb62      	cbnz	r2, 34017b0c <_malloc_r+0xdc>
34017ab2:	f8c8 7000 	str.w	r7, [r8]
34017ab6:	e00f      	b.n	34017ad8 <_malloc_r+0xa8>
34017ab8:	6822      	ldr	r2, [r4, #0]
34017aba:	1b52      	subs	r2, r2, r5
34017abc:	d420      	bmi.n	34017b00 <_malloc_r+0xd0>
34017abe:	2a0b      	cmp	r2, #11
34017ac0:	d917      	bls.n	34017af2 <_malloc_r+0xc2>
34017ac2:	1961      	adds	r1, r4, r5
34017ac4:	42a3      	cmp	r3, r4
34017ac6:	6025      	str	r5, [r4, #0]
34017ac8:	bf18      	it	ne
34017aca:	6059      	strne	r1, [r3, #4]
34017acc:	6863      	ldr	r3, [r4, #4]
34017ace:	bf08      	it	eq
34017ad0:	f8c8 1000 	streq.w	r1, [r8]
34017ad4:	5162      	str	r2, [r4, r5]
34017ad6:	604b      	str	r3, [r1, #4]
34017ad8:	4630      	mov	r0, r6
34017ada:	f000 f82f 	bl	34017b3c <__malloc_unlock>
34017ade:	f104 000b 	add.w	r0, r4, #11
34017ae2:	1d23      	adds	r3, r4, #4
34017ae4:	f020 0007 	bic.w	r0, r0, #7
34017ae8:	1ac2      	subs	r2, r0, r3
34017aea:	bf1c      	itt	ne
34017aec:	1a1b      	subne	r3, r3, r0
34017aee:	50a3      	strne	r3, [r4, r2]
34017af0:	e7af      	b.n	34017a52 <_malloc_r+0x22>
34017af2:	6862      	ldr	r2, [r4, #4]
34017af4:	42a3      	cmp	r3, r4
34017af6:	bf0c      	ite	eq
34017af8:	f8c8 2000 	streq.w	r2, [r8]
34017afc:	605a      	strne	r2, [r3, #4]
34017afe:	e7eb      	b.n	34017ad8 <_malloc_r+0xa8>
34017b00:	4623      	mov	r3, r4
34017b02:	6864      	ldr	r4, [r4, #4]
34017b04:	e7ae      	b.n	34017a64 <_malloc_r+0x34>
34017b06:	463c      	mov	r4, r7
34017b08:	687f      	ldr	r7, [r7, #4]
34017b0a:	e7b6      	b.n	34017a7a <_malloc_r+0x4a>
34017b0c:	461a      	mov	r2, r3
34017b0e:	685b      	ldr	r3, [r3, #4]
34017b10:	42a3      	cmp	r3, r4
34017b12:	d1fb      	bne.n	34017b0c <_malloc_r+0xdc>
34017b14:	2300      	movs	r3, #0
34017b16:	6053      	str	r3, [r2, #4]
34017b18:	e7de      	b.n	34017ad8 <_malloc_r+0xa8>
34017b1a:	230c      	movs	r3, #12
34017b1c:	4630      	mov	r0, r6
34017b1e:	6033      	str	r3, [r6, #0]
34017b20:	f000 f80c 	bl	34017b3c <__malloc_unlock>
34017b24:	e794      	b.n	34017a50 <_malloc_r+0x20>
34017b26:	6005      	str	r5, [r0, #0]
34017b28:	e7d6      	b.n	34017ad8 <_malloc_r+0xa8>
34017b2a:	bf00      	nop
34017b2c:	340581e0 	.word	0x340581e0

34017b30 <__malloc_lock>:
34017b30:	4801      	ldr	r0, [pc, #4]	@ (34017b38 <__malloc_lock+0x8>)
34017b32:	f001 bb16 	b.w	34019162 <__retarget_lock_acquire_recursive>
34017b36:	bf00      	nop
34017b38:	34058324 	.word	0x34058324

34017b3c <__malloc_unlock>:
34017b3c:	4801      	ldr	r0, [pc, #4]	@ (34017b44 <__malloc_unlock+0x8>)
34017b3e:	f001 bb11 	b.w	34019164 <__retarget_lock_release_recursive>
34017b42:	bf00      	nop
34017b44:	34058324 	.word	0x34058324

34017b48 <_realloc_r>:
34017b48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34017b4c:	4607      	mov	r7, r0
34017b4e:	4614      	mov	r4, r2
34017b50:	460d      	mov	r5, r1
34017b52:	b921      	cbnz	r1, 34017b5e <_realloc_r+0x16>
34017b54:	4611      	mov	r1, r2
34017b56:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34017b5a:	f7ff bf69 	b.w	34017a30 <_malloc_r>
34017b5e:	b92a      	cbnz	r2, 34017b6c <_realloc_r+0x24>
34017b60:	4625      	mov	r5, r4
34017b62:	f002 f917 	bl	34019d94 <_free_r>
34017b66:	4628      	mov	r0, r5
34017b68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34017b6c:	f002 fcde 	bl	3401a52c <_malloc_usable_size_r>
34017b70:	4284      	cmp	r4, r0
34017b72:	4606      	mov	r6, r0
34017b74:	d802      	bhi.n	34017b7c <_realloc_r+0x34>
34017b76:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
34017b7a:	d8f4      	bhi.n	34017b66 <_realloc_r+0x1e>
34017b7c:	4621      	mov	r1, r4
34017b7e:	4638      	mov	r0, r7
34017b80:	f7ff ff56 	bl	34017a30 <_malloc_r>
34017b84:	4680      	mov	r8, r0
34017b86:	b908      	cbnz	r0, 34017b8c <_realloc_r+0x44>
34017b88:	4645      	mov	r5, r8
34017b8a:	e7ec      	b.n	34017b66 <_realloc_r+0x1e>
34017b8c:	42b4      	cmp	r4, r6
34017b8e:	4622      	mov	r2, r4
34017b90:	4629      	mov	r1, r5
34017b92:	bf28      	it	cs
34017b94:	4632      	movcs	r2, r6
34017b96:	f001 fafc 	bl	34019192 <memcpy>
34017b9a:	4629      	mov	r1, r5
34017b9c:	4638      	mov	r0, r7
34017b9e:	f002 f8f9 	bl	34019d94 <_free_r>
34017ba2:	e7f1      	b.n	34017b88 <_realloc_r+0x40>

34017ba4 <swapfunc>:
34017ba4:	2b02      	cmp	r3, #2
34017ba6:	b510      	push	{r4, lr}
34017ba8:	d00a      	beq.n	34017bc0 <swapfunc+0x1c>
34017baa:	0892      	lsrs	r2, r2, #2
34017bac:	3a01      	subs	r2, #1
34017bae:	6803      	ldr	r3, [r0, #0]
34017bb0:	680c      	ldr	r4, [r1, #0]
34017bb2:	2a00      	cmp	r2, #0
34017bb4:	f840 4b04 	str.w	r4, [r0], #4
34017bb8:	f841 3b04 	str.w	r3, [r1], #4
34017bbc:	dcf6      	bgt.n	34017bac <swapfunc+0x8>
34017bbe:	bd10      	pop	{r4, pc}
34017bc0:	4402      	add	r2, r0
34017bc2:	7803      	ldrb	r3, [r0, #0]
34017bc4:	780c      	ldrb	r4, [r1, #0]
34017bc6:	f800 4b01 	strb.w	r4, [r0], #1
34017bca:	f801 3b01 	strb.w	r3, [r1], #1
34017bce:	1a13      	subs	r3, r2, r0
34017bd0:	2b00      	cmp	r3, #0
34017bd2:	dcf6      	bgt.n	34017bc2 <swapfunc+0x1e>
34017bd4:	e7f3      	b.n	34017bbe <swapfunc+0x1a>

34017bd6 <med3.constprop.0>:
34017bd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34017bd8:	460f      	mov	r7, r1
34017bda:	4616      	mov	r6, r2
34017bdc:	4604      	mov	r4, r0
34017bde:	461d      	mov	r5, r3
34017be0:	4798      	blx	r3
34017be2:	2800      	cmp	r0, #0
34017be4:	4631      	mov	r1, r6
34017be6:	4638      	mov	r0, r7
34017be8:	da0c      	bge.n	34017c04 <med3.constprop.0+0x2e>
34017bea:	47a8      	blx	r5
34017bec:	2800      	cmp	r0, #0
34017bee:	da02      	bge.n	34017bf6 <med3.constprop.0+0x20>
34017bf0:	463c      	mov	r4, r7
34017bf2:	4620      	mov	r0, r4
34017bf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34017bf6:	4631      	mov	r1, r6
34017bf8:	4620      	mov	r0, r4
34017bfa:	47a8      	blx	r5
34017bfc:	2800      	cmp	r0, #0
34017bfe:	daf8      	bge.n	34017bf2 <med3.constprop.0+0x1c>
34017c00:	4634      	mov	r4, r6
34017c02:	e7f6      	b.n	34017bf2 <med3.constprop.0+0x1c>
34017c04:	47a8      	blx	r5
34017c06:	2800      	cmp	r0, #0
34017c08:	dcf2      	bgt.n	34017bf0 <med3.constprop.0+0x1a>
34017c0a:	4631      	mov	r1, r6
34017c0c:	4620      	mov	r0, r4
34017c0e:	47a8      	blx	r5
34017c10:	2800      	cmp	r0, #0
34017c12:	daf5      	bge.n	34017c00 <med3.constprop.0+0x2a>
34017c14:	e7ed      	b.n	34017bf2 <med3.constprop.0+0x1c>

34017c16 <qsort>:
34017c16:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34017c1a:	b095      	sub	sp, #84	@ 0x54
34017c1c:	4607      	mov	r7, r0
34017c1e:	4615      	mov	r5, r2
34017c20:	9300      	str	r3, [sp, #0]
34017c22:	ea40 0302 	orr.w	r3, r0, r2
34017c26:	079b      	lsls	r3, r3, #30
34017c28:	d119      	bne.n	34017c5e <qsort+0x48>
34017c2a:	f1b2 0804 	subs.w	r8, r2, #4
34017c2e:	bf18      	it	ne
34017c30:	f04f 0801 	movne.w	r8, #1
34017c34:	2300      	movs	r3, #0
34017c36:	9301      	str	r3, [sp, #4]
34017c38:	fb05 f401 	mul.w	r4, r5, r1
34017c3c:	2906      	cmp	r1, #6
34017c3e:	eb07 0b05 	add.w	fp, r7, r5
34017c42:	eb07 0304 	add.w	r3, r7, r4
34017c46:	9302      	str	r3, [sp, #8]
34017c48:	d828      	bhi.n	34017c9c <qsort+0x86>
34017c4a:	9b02      	ldr	r3, [sp, #8]
34017c4c:	459b      	cmp	fp, r3
34017c4e:	d310      	bcc.n	34017c72 <qsort+0x5c>
34017c50:	9b01      	ldr	r3, [sp, #4]
34017c52:	2b00      	cmp	r3, #0
34017c54:	f040 8117 	bne.w	34017e86 <qsort+0x270>
34017c58:	b015      	add	sp, #84	@ 0x54
34017c5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34017c5e:	f04f 0802 	mov.w	r8, #2
34017c62:	e7e7      	b.n	34017c34 <qsort+0x1e>
34017c64:	4643      	mov	r3, r8
34017c66:	462a      	mov	r2, r5
34017c68:	4631      	mov	r1, r6
34017c6a:	4620      	mov	r0, r4
34017c6c:	f7ff ff9a 	bl	34017ba4 <swapfunc>
34017c70:	e00f      	b.n	34017c92 <qsort+0x7c>
34017c72:	465c      	mov	r4, fp
34017c74:	e00e      	b.n	34017c94 <qsort+0x7e>
34017c76:	1b66      	subs	r6, r4, r5
34017c78:	4621      	mov	r1, r4
34017c7a:	9b00      	ldr	r3, [sp, #0]
34017c7c:	4630      	mov	r0, r6
34017c7e:	4798      	blx	r3
34017c80:	2800      	cmp	r0, #0
34017c82:	dd09      	ble.n	34017c98 <qsort+0x82>
34017c84:	f1b8 0f00 	cmp.w	r8, #0
34017c88:	d1ec      	bne.n	34017c64 <qsort+0x4e>
34017c8a:	6823      	ldr	r3, [r4, #0]
34017c8c:	6832      	ldr	r2, [r6, #0]
34017c8e:	6022      	str	r2, [r4, #0]
34017c90:	6033      	str	r3, [r6, #0]
34017c92:	4634      	mov	r4, r6
34017c94:	42a7      	cmp	r7, r4
34017c96:	d3ee      	bcc.n	34017c76 <qsort+0x60>
34017c98:	44ab      	add	fp, r5
34017c9a:	e7d6      	b.n	34017c4a <qsort+0x34>
34017c9c:	ea4f 0951 	mov.w	r9, r1, lsr #1
34017ca0:	1b64      	subs	r4, r4, r5
34017ca2:	2907      	cmp	r1, #7
34017ca4:	fb05 7909 	mla	r9, r5, r9, r7
34017ca8:	443c      	add	r4, r7
34017caa:	d021      	beq.n	34017cf0 <qsort+0xda>
34017cac:	2928      	cmp	r1, #40	@ 0x28
34017cae:	d944      	bls.n	34017d3a <qsort+0x124>
34017cb0:	08ce      	lsrs	r6, r1, #3
34017cb2:	9b00      	ldr	r3, [sp, #0]
34017cb4:	4638      	mov	r0, r7
34017cb6:	436e      	muls	r6, r5
34017cb8:	eb07 0246 	add.w	r2, r7, r6, lsl #1
34017cbc:	19b9      	adds	r1, r7, r6
34017cbe:	f7ff ff8a 	bl	34017bd6 <med3.constprop.0>
34017cc2:	4649      	mov	r1, r9
34017cc4:	eb09 0206 	add.w	r2, r9, r6
34017cc8:	9b00      	ldr	r3, [sp, #0]
34017cca:	4682      	mov	sl, r0
34017ccc:	1b88      	subs	r0, r1, r6
34017cce:	f7ff ff82 	bl	34017bd6 <med3.constprop.0>
34017cd2:	4622      	mov	r2, r4
34017cd4:	4681      	mov	r9, r0
34017cd6:	9b00      	ldr	r3, [sp, #0]
34017cd8:	1ba1      	subs	r1, r4, r6
34017cda:	eba4 0046 	sub.w	r0, r4, r6, lsl #1
34017cde:	f7ff ff7a 	bl	34017bd6 <med3.constprop.0>
34017ce2:	4602      	mov	r2, r0
34017ce4:	4649      	mov	r1, r9
34017ce6:	9b00      	ldr	r3, [sp, #0]
34017ce8:	4650      	mov	r0, sl
34017cea:	f7ff ff74 	bl	34017bd6 <med3.constprop.0>
34017cee:	4681      	mov	r9, r0
34017cf0:	f1b8 0f00 	cmp.w	r8, #0
34017cf4:	d124      	bne.n	34017d40 <qsort+0x12a>
34017cf6:	683b      	ldr	r3, [r7, #0]
34017cf8:	f8d9 2000 	ldr.w	r2, [r9]
34017cfc:	603a      	str	r2, [r7, #0]
34017cfe:	f8c9 3000 	str.w	r3, [r9]
34017d02:	46d9      	mov	r9, fp
34017d04:	46a2      	mov	sl, r4
34017d06:	465e      	mov	r6, fp
34017d08:	2300      	movs	r3, #0
34017d0a:	45a1      	cmp	r9, r4
34017d0c:	d836      	bhi.n	34017d7c <qsort+0x166>
34017d0e:	9303      	str	r3, [sp, #12]
34017d10:	4639      	mov	r1, r7
34017d12:	9b00      	ldr	r3, [sp, #0]
34017d14:	4648      	mov	r0, r9
34017d16:	4798      	blx	r3
34017d18:	2800      	cmp	r0, #0
34017d1a:	9b03      	ldr	r3, [sp, #12]
34017d1c:	dc2c      	bgt.n	34017d78 <qsort+0x162>
34017d1e:	d10a      	bne.n	34017d36 <qsort+0x120>
34017d20:	f1b8 0f00 	cmp.w	r8, #0
34017d24:	d113      	bne.n	34017d4e <qsort+0x138>
34017d26:	6833      	ldr	r3, [r6, #0]
34017d28:	f8d9 2000 	ldr.w	r2, [r9]
34017d2c:	6032      	str	r2, [r6, #0]
34017d2e:	f8c9 3000 	str.w	r3, [r9]
34017d32:	442e      	add	r6, r5
34017d34:	2301      	movs	r3, #1
34017d36:	44a9      	add	r9, r5
34017d38:	e7e7      	b.n	34017d0a <qsort+0xf4>
34017d3a:	4622      	mov	r2, r4
34017d3c:	46ba      	mov	sl, r7
34017d3e:	e7d1      	b.n	34017ce4 <qsort+0xce>
34017d40:	4643      	mov	r3, r8
34017d42:	462a      	mov	r2, r5
34017d44:	4649      	mov	r1, r9
34017d46:	4638      	mov	r0, r7
34017d48:	f7ff ff2c 	bl	34017ba4 <swapfunc>
34017d4c:	e7d9      	b.n	34017d02 <qsort+0xec>
34017d4e:	4643      	mov	r3, r8
34017d50:	462a      	mov	r2, r5
34017d52:	4649      	mov	r1, r9
34017d54:	4630      	mov	r0, r6
34017d56:	f7ff ff25 	bl	34017ba4 <swapfunc>
34017d5a:	e7ea      	b.n	34017d32 <qsort+0x11c>
34017d5c:	d10b      	bne.n	34017d76 <qsort+0x160>
34017d5e:	f1b8 0f00 	cmp.w	r8, #0
34017d62:	d113      	bne.n	34017d8c <qsort+0x176>
34017d64:	6823      	ldr	r3, [r4, #0]
34017d66:	f8da 2000 	ldr.w	r2, [sl]
34017d6a:	6022      	str	r2, [r4, #0]
34017d6c:	f8ca 3000 	str.w	r3, [sl]
34017d70:	ebaa 0a05 	sub.w	sl, sl, r5
34017d74:	2301      	movs	r3, #1
34017d76:	1b64      	subs	r4, r4, r5
34017d78:	45a1      	cmp	r9, r4
34017d7a:	d90e      	bls.n	34017d9a <qsort+0x184>
34017d7c:	2b00      	cmp	r3, #0
34017d7e:	d140      	bne.n	34017e02 <qsort+0x1ec>
34017d80:	9b02      	ldr	r3, [sp, #8]
34017d82:	459b      	cmp	fp, r3
34017d84:	f4bf af64 	bcs.w	34017c50 <qsort+0x3a>
34017d88:	465c      	mov	r4, fp
34017d8a:	e036      	b.n	34017dfa <qsort+0x1e4>
34017d8c:	4643      	mov	r3, r8
34017d8e:	462a      	mov	r2, r5
34017d90:	4651      	mov	r1, sl
34017d92:	4620      	mov	r0, r4
34017d94:	f7ff ff06 	bl	34017ba4 <swapfunc>
34017d98:	e7ea      	b.n	34017d70 <qsort+0x15a>
34017d9a:	9303      	str	r3, [sp, #12]
34017d9c:	4639      	mov	r1, r7
34017d9e:	9b00      	ldr	r3, [sp, #0]
34017da0:	4620      	mov	r0, r4
34017da2:	4798      	blx	r3
34017da4:	2800      	cmp	r0, #0
34017da6:	9b03      	ldr	r3, [sp, #12]
34017da8:	dad8      	bge.n	34017d5c <qsort+0x146>
34017daa:	f1b8 0f00 	cmp.w	r8, #0
34017dae:	d107      	bne.n	34017dc0 <qsort+0x1aa>
34017db0:	f8d9 3000 	ldr.w	r3, [r9]
34017db4:	6822      	ldr	r2, [r4, #0]
34017db6:	f8c9 2000 	str.w	r2, [r9]
34017dba:	6023      	str	r3, [r4, #0]
34017dbc:	1b64      	subs	r4, r4, r5
34017dbe:	e7b9      	b.n	34017d34 <qsort+0x11e>
34017dc0:	4643      	mov	r3, r8
34017dc2:	462a      	mov	r2, r5
34017dc4:	4621      	mov	r1, r4
34017dc6:	4648      	mov	r0, r9
34017dc8:	f7ff feec 	bl	34017ba4 <swapfunc>
34017dcc:	e7f6      	b.n	34017dbc <qsort+0x1a6>
34017dce:	4643      	mov	r3, r8
34017dd0:	462a      	mov	r2, r5
34017dd2:	4631      	mov	r1, r6
34017dd4:	4620      	mov	r0, r4
34017dd6:	f7ff fee5 	bl	34017ba4 <swapfunc>
34017dda:	e00d      	b.n	34017df8 <qsort+0x1e2>
34017ddc:	1b66      	subs	r6, r4, r5
34017dde:	4621      	mov	r1, r4
34017de0:	9b00      	ldr	r3, [sp, #0]
34017de2:	4630      	mov	r0, r6
34017de4:	4798      	blx	r3
34017de6:	2800      	cmp	r0, #0
34017de8:	dd09      	ble.n	34017dfe <qsort+0x1e8>
34017dea:	f1b8 0f00 	cmp.w	r8, #0
34017dee:	d1ee      	bne.n	34017dce <qsort+0x1b8>
34017df0:	6823      	ldr	r3, [r4, #0]
34017df2:	6832      	ldr	r2, [r6, #0]
34017df4:	6022      	str	r2, [r4, #0]
34017df6:	6033      	str	r3, [r6, #0]
34017df8:	4634      	mov	r4, r6
34017dfa:	42a7      	cmp	r7, r4
34017dfc:	d3ee      	bcc.n	34017ddc <qsort+0x1c6>
34017dfe:	44ab      	add	fp, r5
34017e00:	e7be      	b.n	34017d80 <qsort+0x16a>
34017e02:	eba9 0b06 	sub.w	fp, r9, r6
34017e06:	1bf2      	subs	r2, r6, r7
34017e08:	455a      	cmp	r2, fp
34017e0a:	bfa8      	it	ge
34017e0c:	465a      	movge	r2, fp
34017e0e:	b12a      	cbz	r2, 34017e1c <qsort+0x206>
34017e10:	4643      	mov	r3, r8
34017e12:	eba9 0102 	sub.w	r1, r9, r2
34017e16:	4638      	mov	r0, r7
34017e18:	f7ff fec4 	bl	34017ba4 <swapfunc>
34017e1c:	9b02      	ldr	r3, [sp, #8]
34017e1e:	ebaa 0404 	sub.w	r4, sl, r4
34017e22:	eba3 020a 	sub.w	r2, r3, sl
34017e26:	1b52      	subs	r2, r2, r5
34017e28:	42a2      	cmp	r2, r4
34017e2a:	bf28      	it	cs
34017e2c:	4622      	movcs	r2, r4
34017e2e:	b12a      	cbz	r2, 34017e3c <qsort+0x226>
34017e30:	9902      	ldr	r1, [sp, #8]
34017e32:	4643      	mov	r3, r8
34017e34:	4648      	mov	r0, r9
34017e36:	1a89      	subs	r1, r1, r2
34017e38:	f7ff feb4 	bl	34017ba4 <swapfunc>
34017e3c:	9b02      	ldr	r3, [sp, #8]
34017e3e:	455c      	cmp	r4, fp
34017e40:	eba3 0604 	sub.w	r6, r3, r4
34017e44:	d805      	bhi.n	34017e52 <qsort+0x23c>
34017e46:	4623      	mov	r3, r4
34017e48:	465c      	mov	r4, fp
34017e4a:	469b      	mov	fp, r3
34017e4c:	4633      	mov	r3, r6
34017e4e:	463e      	mov	r6, r7
34017e50:	461f      	mov	r7, r3
34017e52:	45ab      	cmp	fp, r5
34017e54:	d920      	bls.n	34017e98 <qsort+0x282>
34017e56:	9b01      	ldr	r3, [sp, #4]
34017e58:	2b07      	cmp	r3, #7
34017e5a:	fbbb f1f5 	udiv	r1, fp, r5
34017e5e:	d80b      	bhi.n	34017e78 <qsort+0x262>
34017e60:	aa14      	add	r2, sp, #80	@ 0x50
34017e62:	fbb4 f4f5 	udiv	r4, r4, r5
34017e66:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34017e6a:	f843 6c40 	str.w	r6, [r3, #-64]
34017e6e:	f843 4c3c 	str.w	r4, [r3, #-60]
34017e72:	9b01      	ldr	r3, [sp, #4]
34017e74:	3301      	adds	r3, #1
34017e76:	e6de      	b.n	34017c36 <qsort+0x20>
34017e78:	9b00      	ldr	r3, [sp, #0]
34017e7a:	462a      	mov	r2, r5
34017e7c:	4638      	mov	r0, r7
34017e7e:	f7ff feca 	bl	34017c16 <qsort>
34017e82:	42ac      	cmp	r4, r5
34017e84:	d80b      	bhi.n	34017e9e <qsort+0x288>
34017e86:	9b01      	ldr	r3, [sp, #4]
34017e88:	aa14      	add	r2, sp, #80	@ 0x50
34017e8a:	3b01      	subs	r3, #1
34017e8c:	9301      	str	r3, [sp, #4]
34017e8e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34017e92:	e953 7110 	ldrd	r7, r1, [r3, #-64]	@ 0x40
34017e96:	e6cf      	b.n	34017c38 <qsort+0x22>
34017e98:	42ac      	cmp	r4, r5
34017e9a:	f67f aed9 	bls.w	34017c50 <qsort+0x3a>
34017e9e:	4637      	mov	r7, r6
34017ea0:	fbb4 f1f5 	udiv	r1, r4, r5
34017ea4:	e6c8      	b.n	34017c38 <qsort+0x22>

34017ea6 <__cvt>:
34017ea6:	b5f0      	push	{r4, r5, r6, r7, lr}
34017ea8:	ed2d 8b02 	vpush	{d8}
34017eac:	eeb0 8b40 	vmov.f64	d8, d0
34017eb0:	b085      	sub	sp, #20
34017eb2:	4617      	mov	r7, r2
34017eb4:	460c      	mov	r4, r1
34017eb6:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
34017eb8:	ee18 2a90 	vmov	r2, s17
34017ebc:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
34017ebe:	f025 0520 	bic.w	r5, r5, #32
34017ec2:	2a00      	cmp	r2, #0
34017ec4:	bfb6      	itet	lt
34017ec6:	222d      	movlt	r2, #45	@ 0x2d
34017ec8:	2200      	movge	r2, #0
34017eca:	eeb1 8b40 	vneglt.f64	d8, d0
34017ece:	2d46      	cmp	r5, #70	@ 0x46
34017ed0:	701a      	strb	r2, [r3, #0]
34017ed2:	d004      	beq.n	34017ede <__cvt+0x38>
34017ed4:	2d45      	cmp	r5, #69	@ 0x45
34017ed6:	d100      	bne.n	34017eda <__cvt+0x34>
34017ed8:	3401      	adds	r4, #1
34017eda:	2102      	movs	r1, #2
34017edc:	e000      	b.n	34017ee0 <__cvt+0x3a>
34017ede:	2103      	movs	r1, #3
34017ee0:	ab03      	add	r3, sp, #12
34017ee2:	eeb0 0b48 	vmov.f64	d0, d8
34017ee6:	4622      	mov	r2, r4
34017ee8:	9301      	str	r3, [sp, #4]
34017eea:	ab02      	add	r3, sp, #8
34017eec:	9300      	str	r3, [sp, #0]
34017eee:	4633      	mov	r3, r6
34017ef0:	f001 f9f2 	bl	340192d8 <_dtoa_r>
34017ef4:	2d47      	cmp	r5, #71	@ 0x47
34017ef6:	d114      	bne.n	34017f22 <__cvt+0x7c>
34017ef8:	07fb      	lsls	r3, r7, #31
34017efa:	d50a      	bpl.n	34017f12 <__cvt+0x6c>
34017efc:	1902      	adds	r2, r0, r4
34017efe:	eeb5 8b40 	vcmp.f64	d8, #0.0
34017f02:	2130      	movs	r1, #48	@ 0x30
34017f04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017f08:	bf08      	it	eq
34017f0a:	9203      	streq	r2, [sp, #12]
34017f0c:	9b03      	ldr	r3, [sp, #12]
34017f0e:	4293      	cmp	r3, r2
34017f10:	d319      	bcc.n	34017f46 <__cvt+0xa0>
34017f12:	9b03      	ldr	r3, [sp, #12]
34017f14:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
34017f16:	1a1b      	subs	r3, r3, r0
34017f18:	6013      	str	r3, [r2, #0]
34017f1a:	b005      	add	sp, #20
34017f1c:	ecbd 8b02 	vpop	{d8}
34017f20:	bdf0      	pop	{r4, r5, r6, r7, pc}
34017f22:	2d46      	cmp	r5, #70	@ 0x46
34017f24:	eb00 0204 	add.w	r2, r0, r4
34017f28:	d1e9      	bne.n	34017efe <__cvt+0x58>
34017f2a:	7803      	ldrb	r3, [r0, #0]
34017f2c:	2b30      	cmp	r3, #48	@ 0x30
34017f2e:	d107      	bne.n	34017f40 <__cvt+0x9a>
34017f30:	eeb5 8b40 	vcmp.f64	d8, #0.0
34017f34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34017f38:	bf1c      	itt	ne
34017f3a:	f1c4 0401 	rsbne	r4, r4, #1
34017f3e:	6034      	strne	r4, [r6, #0]
34017f40:	6833      	ldr	r3, [r6, #0]
34017f42:	441a      	add	r2, r3
34017f44:	e7db      	b.n	34017efe <__cvt+0x58>
34017f46:	1c5c      	adds	r4, r3, #1
34017f48:	9403      	str	r4, [sp, #12]
34017f4a:	7019      	strb	r1, [r3, #0]
34017f4c:	e7de      	b.n	34017f0c <__cvt+0x66>

34017f4e <__exponent>:
34017f4e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34017f50:	2900      	cmp	r1, #0
34017f52:	7002      	strb	r2, [r0, #0]
34017f54:	bfba      	itte	lt
34017f56:	4249      	neglt	r1, r1
34017f58:	232d      	movlt	r3, #45	@ 0x2d
34017f5a:	232b      	movge	r3, #43	@ 0x2b
34017f5c:	2909      	cmp	r1, #9
34017f5e:	7043      	strb	r3, [r0, #1]
34017f60:	dd28      	ble.n	34017fb4 <__exponent+0x66>
34017f62:	f10d 0307 	add.w	r3, sp, #7
34017f66:	270a      	movs	r7, #10
34017f68:	461d      	mov	r5, r3
34017f6a:	461a      	mov	r2, r3
34017f6c:	3b01      	subs	r3, #1
34017f6e:	fbb1 f6f7 	udiv	r6, r1, r7
34017f72:	fb07 1416 	mls	r4, r7, r6, r1
34017f76:	3430      	adds	r4, #48	@ 0x30
34017f78:	f802 4c01 	strb.w	r4, [r2, #-1]
34017f7c:	460c      	mov	r4, r1
34017f7e:	4631      	mov	r1, r6
34017f80:	2c63      	cmp	r4, #99	@ 0x63
34017f82:	dcf2      	bgt.n	34017f6a <__exponent+0x1c>
34017f84:	3130      	adds	r1, #48	@ 0x30
34017f86:	1e94      	subs	r4, r2, #2
34017f88:	f803 1c01 	strb.w	r1, [r3, #-1]
34017f8c:	1c41      	adds	r1, r0, #1
34017f8e:	4623      	mov	r3, r4
34017f90:	42ab      	cmp	r3, r5
34017f92:	d30a      	bcc.n	34017faa <__exponent+0x5c>
34017f94:	f10d 0309 	add.w	r3, sp, #9
34017f98:	1a9b      	subs	r3, r3, r2
34017f9a:	42ac      	cmp	r4, r5
34017f9c:	bf88      	it	hi
34017f9e:	2300      	movhi	r3, #0
34017fa0:	3302      	adds	r3, #2
34017fa2:	4403      	add	r3, r0
34017fa4:	1a18      	subs	r0, r3, r0
34017fa6:	b003      	add	sp, #12
34017fa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
34017faa:	f813 6b01 	ldrb.w	r6, [r3], #1
34017fae:	f801 6f01 	strb.w	r6, [r1, #1]!
34017fb2:	e7ed      	b.n	34017f90 <__exponent+0x42>
34017fb4:	2330      	movs	r3, #48	@ 0x30
34017fb6:	3130      	adds	r1, #48	@ 0x30
34017fb8:	7083      	strb	r3, [r0, #2]
34017fba:	1d03      	adds	r3, r0, #4
34017fbc:	70c1      	strb	r1, [r0, #3]
34017fbe:	e7f1      	b.n	34017fa4 <__exponent+0x56>

34017fc0 <_printf_float>:
34017fc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34017fc4:	b08d      	sub	sp, #52	@ 0x34
34017fc6:	460c      	mov	r4, r1
34017fc8:	4616      	mov	r6, r2
34017fca:	461f      	mov	r7, r3
34017fcc:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
34017fd0:	4605      	mov	r5, r0
34017fd2:	f001 f841 	bl	34019058 <_localeconv_r>
34017fd6:	f8d0 b000 	ldr.w	fp, [r0]
34017fda:	4658      	mov	r0, fp
34017fdc:	f7e9 faa6 	bl	3400152c <strlen>
34017fe0:	2300      	movs	r3, #0
34017fe2:	f894 9018 	ldrb.w	r9, [r4, #24]
34017fe6:	930a      	str	r3, [sp, #40]	@ 0x28
34017fe8:	f8d8 3000 	ldr.w	r3, [r8]
34017fec:	6822      	ldr	r2, [r4, #0]
34017fee:	3307      	adds	r3, #7
34017ff0:	9005      	str	r0, [sp, #20]
34017ff2:	f023 0307 	bic.w	r3, r3, #7
34017ff6:	f103 0108 	add.w	r1, r3, #8
34017ffa:	f8c8 1000 	str.w	r1, [r8]
34017ffe:	ed93 0b00 	vldr	d0, [r3]
34018002:	ed9f 6b97 	vldr	d6, [pc, #604]	@ 34018260 <_printf_float+0x2a0>
34018006:	eeb0 7bc0 	vabs.f64	d7, d0
3401800a:	ed84 0b12 	vstr	d0, [r4, #72]	@ 0x48
3401800e:	eeb4 7b46 	vcmp.f64	d7, d6
34018012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34018016:	dd24      	ble.n	34018062 <_printf_float+0xa2>
34018018:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
3401801c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34018020:	d502      	bpl.n	34018028 <_printf_float+0x68>
34018022:	232d      	movs	r3, #45	@ 0x2d
34018024:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34018028:	498f      	ldr	r1, [pc, #572]	@ (34018268 <_printf_float+0x2a8>)
3401802a:	4b90      	ldr	r3, [pc, #576]	@ (3401826c <_printf_float+0x2ac>)
3401802c:	f1b9 0f47 	cmp.w	r9, #71	@ 0x47
34018030:	bf8c      	ite	hi
34018032:	4688      	movhi	r8, r1
34018034:	4698      	movls	r8, r3
34018036:	f022 0204 	bic.w	r2, r2, #4
3401803a:	2303      	movs	r3, #3
3401803c:	f04f 0a00 	mov.w	sl, #0
34018040:	6022      	str	r2, [r4, #0]
34018042:	6123      	str	r3, [r4, #16]
34018044:	4633      	mov	r3, r6
34018046:	aa0b      	add	r2, sp, #44	@ 0x2c
34018048:	4621      	mov	r1, r4
3401804a:	4628      	mov	r0, r5
3401804c:	9700      	str	r7, [sp, #0]
3401804e:	f000 f9d1 	bl	340183f4 <_printf_common>
34018052:	3001      	adds	r0, #1
34018054:	f040 8089 	bne.w	3401816a <_printf_float+0x1aa>
34018058:	f04f 30ff 	mov.w	r0, #4294967295
3401805c:	b00d      	add	sp, #52	@ 0x34
3401805e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34018062:	eeb4 0b40 	vcmp.f64	d0, d0
34018066:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401806a:	d709      	bvc.n	34018080 <_printf_float+0xc0>
3401806c:	ee10 3a90 	vmov	r3, s1
34018070:	497f      	ldr	r1, [pc, #508]	@ (34018270 <_printf_float+0x2b0>)
34018072:	2b00      	cmp	r3, #0
34018074:	bfbc      	itt	lt
34018076:	232d      	movlt	r3, #45	@ 0x2d
34018078:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
3401807c:	4b7d      	ldr	r3, [pc, #500]	@ (34018274 <_printf_float+0x2b4>)
3401807e:	e7d5      	b.n	3401802c <_printf_float+0x6c>
34018080:	6863      	ldr	r3, [r4, #4]
34018082:	f009 0adf 	and.w	sl, r9, #223	@ 0xdf
34018086:	1c59      	adds	r1, r3, #1
34018088:	d139      	bne.n	340180fe <_printf_float+0x13e>
3401808a:	2306      	movs	r3, #6
3401808c:	6063      	str	r3, [r4, #4]
3401808e:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
34018092:	2300      	movs	r3, #0
34018094:	4628      	mov	r0, r5
34018096:	6022      	str	r2, [r4, #0]
34018098:	9303      	str	r3, [sp, #12]
3401809a:	ab0a      	add	r3, sp, #40	@ 0x28
3401809c:	e9cd 9301 	strd	r9, r3, [sp, #4]
340180a0:	ab09      	add	r3, sp, #36	@ 0x24
340180a2:	9300      	str	r3, [sp, #0]
340180a4:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
340180a8:	6861      	ldr	r1, [r4, #4]
340180aa:	f7ff fefc 	bl	34017ea6 <__cvt>
340180ae:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
340180b2:	4680      	mov	r8, r0
340180b4:	9909      	ldr	r1, [sp, #36]	@ 0x24
340180b6:	d129      	bne.n	3401810c <_printf_float+0x14c>
340180b8:	1cc8      	adds	r0, r1, #3
340180ba:	db02      	blt.n	340180c2 <_printf_float+0x102>
340180bc:	6863      	ldr	r3, [r4, #4]
340180be:	4299      	cmp	r1, r3
340180c0:	dd41      	ble.n	34018146 <_printf_float+0x186>
340180c2:	f1a9 0902 	sub.w	r9, r9, #2
340180c6:	fa5f f989 	uxtb.w	r9, r9
340180ca:	3901      	subs	r1, #1
340180cc:	464a      	mov	r2, r9
340180ce:	f104 0050 	add.w	r0, r4, #80	@ 0x50
340180d2:	9109      	str	r1, [sp, #36]	@ 0x24
340180d4:	f7ff ff3b 	bl	34017f4e <__exponent>
340180d8:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
340180da:	4682      	mov	sl, r0
340180dc:	1813      	adds	r3, r2, r0
340180de:	2a01      	cmp	r2, #1
340180e0:	6123      	str	r3, [r4, #16]
340180e2:	dc02      	bgt.n	340180ea <_printf_float+0x12a>
340180e4:	6822      	ldr	r2, [r4, #0]
340180e6:	07d2      	lsls	r2, r2, #31
340180e8:	d501      	bpl.n	340180ee <_printf_float+0x12e>
340180ea:	3301      	adds	r3, #1
340180ec:	6123      	str	r3, [r4, #16]
340180ee:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
340180f2:	2b00      	cmp	r3, #0
340180f4:	d0a6      	beq.n	34018044 <_printf_float+0x84>
340180f6:	232d      	movs	r3, #45	@ 0x2d
340180f8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340180fc:	e7a2      	b.n	34018044 <_printf_float+0x84>
340180fe:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
34018102:	d1c4      	bne.n	3401808e <_printf_float+0xce>
34018104:	2b00      	cmp	r3, #0
34018106:	d1c2      	bne.n	3401808e <_printf_float+0xce>
34018108:	2301      	movs	r3, #1
3401810a:	e7bf      	b.n	3401808c <_printf_float+0xcc>
3401810c:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
34018110:	d9db      	bls.n	340180ca <_printf_float+0x10a>
34018112:	f1b9 0f66 	cmp.w	r9, #102	@ 0x66
34018116:	d118      	bne.n	3401814a <_printf_float+0x18a>
34018118:	2900      	cmp	r1, #0
3401811a:	6863      	ldr	r3, [r4, #4]
3401811c:	dd0b      	ble.n	34018136 <_printf_float+0x176>
3401811e:	6121      	str	r1, [r4, #16]
34018120:	b913      	cbnz	r3, 34018128 <_printf_float+0x168>
34018122:	6822      	ldr	r2, [r4, #0]
34018124:	07d0      	lsls	r0, r2, #31
34018126:	d502      	bpl.n	3401812e <_printf_float+0x16e>
34018128:	3301      	adds	r3, #1
3401812a:	440b      	add	r3, r1
3401812c:	6123      	str	r3, [r4, #16]
3401812e:	f04f 0a00 	mov.w	sl, #0
34018132:	65a1      	str	r1, [r4, #88]	@ 0x58
34018134:	e7db      	b.n	340180ee <_printf_float+0x12e>
34018136:	b913      	cbnz	r3, 3401813e <_printf_float+0x17e>
34018138:	6822      	ldr	r2, [r4, #0]
3401813a:	07d2      	lsls	r2, r2, #31
3401813c:	d501      	bpl.n	34018142 <_printf_float+0x182>
3401813e:	3302      	adds	r3, #2
34018140:	e7f4      	b.n	3401812c <_printf_float+0x16c>
34018142:	2301      	movs	r3, #1
34018144:	e7f2      	b.n	3401812c <_printf_float+0x16c>
34018146:	f04f 0967 	mov.w	r9, #103	@ 0x67
3401814a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
3401814c:	4299      	cmp	r1, r3
3401814e:	db05      	blt.n	3401815c <_printf_float+0x19c>
34018150:	6823      	ldr	r3, [r4, #0]
34018152:	6121      	str	r1, [r4, #16]
34018154:	07d8      	lsls	r0, r3, #31
34018156:	d5ea      	bpl.n	3401812e <_printf_float+0x16e>
34018158:	1c4b      	adds	r3, r1, #1
3401815a:	e7e7      	b.n	3401812c <_printf_float+0x16c>
3401815c:	2900      	cmp	r1, #0
3401815e:	bfd4      	ite	le
34018160:	f1c1 0202 	rsble	r2, r1, #2
34018164:	2201      	movgt	r2, #1
34018166:	4413      	add	r3, r2
34018168:	e7e0      	b.n	3401812c <_printf_float+0x16c>
3401816a:	6823      	ldr	r3, [r4, #0]
3401816c:	055a      	lsls	r2, r3, #21
3401816e:	d407      	bmi.n	34018180 <_printf_float+0x1c0>
34018170:	6923      	ldr	r3, [r4, #16]
34018172:	4642      	mov	r2, r8
34018174:	4631      	mov	r1, r6
34018176:	4628      	mov	r0, r5
34018178:	47b8      	blx	r7
3401817a:	3001      	adds	r0, #1
3401817c:	d12a      	bne.n	340181d4 <_printf_float+0x214>
3401817e:	e76b      	b.n	34018058 <_printf_float+0x98>
34018180:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
34018184:	f240 80e0 	bls.w	34018348 <_printf_float+0x388>
34018188:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
3401818c:	eeb5 7b40 	vcmp.f64	d7, #0.0
34018190:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34018194:	d133      	bne.n	340181fe <_printf_float+0x23e>
34018196:	2301      	movs	r3, #1
34018198:	4a37      	ldr	r2, [pc, #220]	@ (34018278 <_printf_float+0x2b8>)
3401819a:	4631      	mov	r1, r6
3401819c:	4628      	mov	r0, r5
3401819e:	47b8      	blx	r7
340181a0:	3001      	adds	r0, #1
340181a2:	f43f af59 	beq.w	34018058 <_printf_float+0x98>
340181a6:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
340181aa:	4543      	cmp	r3, r8
340181ac:	db02      	blt.n	340181b4 <_printf_float+0x1f4>
340181ae:	6823      	ldr	r3, [r4, #0]
340181b0:	07d8      	lsls	r0, r3, #31
340181b2:	d50f      	bpl.n	340181d4 <_printf_float+0x214>
340181b4:	9b05      	ldr	r3, [sp, #20]
340181b6:	465a      	mov	r2, fp
340181b8:	4631      	mov	r1, r6
340181ba:	4628      	mov	r0, r5
340181bc:	47b8      	blx	r7
340181be:	3001      	adds	r0, #1
340181c0:	f43f af4a 	beq.w	34018058 <_printf_float+0x98>
340181c4:	f04f 0900 	mov.w	r9, #0
340181c8:	f108 38ff 	add.w	r8, r8, #4294967295
340181cc:	f104 0a1a 	add.w	sl, r4, #26
340181d0:	45c8      	cmp	r8, r9
340181d2:	dc09      	bgt.n	340181e8 <_printf_float+0x228>
340181d4:	6823      	ldr	r3, [r4, #0]
340181d6:	079b      	lsls	r3, r3, #30
340181d8:	f100 8107 	bmi.w	340183ea <_printf_float+0x42a>
340181dc:	68e0      	ldr	r0, [r4, #12]
340181de:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
340181e0:	4298      	cmp	r0, r3
340181e2:	bfb8      	it	lt
340181e4:	4618      	movlt	r0, r3
340181e6:	e739      	b.n	3401805c <_printf_float+0x9c>
340181e8:	2301      	movs	r3, #1
340181ea:	4652      	mov	r2, sl
340181ec:	4631      	mov	r1, r6
340181ee:	4628      	mov	r0, r5
340181f0:	47b8      	blx	r7
340181f2:	3001      	adds	r0, #1
340181f4:	f43f af30 	beq.w	34018058 <_printf_float+0x98>
340181f8:	f109 0901 	add.w	r9, r9, #1
340181fc:	e7e8      	b.n	340181d0 <_printf_float+0x210>
340181fe:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34018200:	2b00      	cmp	r3, #0
34018202:	dc3b      	bgt.n	3401827c <_printf_float+0x2bc>
34018204:	2301      	movs	r3, #1
34018206:	4a1c      	ldr	r2, [pc, #112]	@ (34018278 <_printf_float+0x2b8>)
34018208:	4631      	mov	r1, r6
3401820a:	4628      	mov	r0, r5
3401820c:	47b8      	blx	r7
3401820e:	3001      	adds	r0, #1
34018210:	f43f af22 	beq.w	34018058 <_printf_float+0x98>
34018214:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
34018218:	ea59 0303 	orrs.w	r3, r9, r3
3401821c:	d102      	bne.n	34018224 <_printf_float+0x264>
3401821e:	6823      	ldr	r3, [r4, #0]
34018220:	07d9      	lsls	r1, r3, #31
34018222:	d5d7      	bpl.n	340181d4 <_printf_float+0x214>
34018224:	9b05      	ldr	r3, [sp, #20]
34018226:	465a      	mov	r2, fp
34018228:	4631      	mov	r1, r6
3401822a:	4628      	mov	r0, r5
3401822c:	47b8      	blx	r7
3401822e:	3001      	adds	r0, #1
34018230:	f43f af12 	beq.w	34018058 <_printf_float+0x98>
34018234:	f04f 0a00 	mov.w	sl, #0
34018238:	f104 0b1a 	add.w	fp, r4, #26
3401823c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401823e:	425b      	negs	r3, r3
34018240:	4553      	cmp	r3, sl
34018242:	dc01      	bgt.n	34018248 <_printf_float+0x288>
34018244:	464b      	mov	r3, r9
34018246:	e794      	b.n	34018172 <_printf_float+0x1b2>
34018248:	2301      	movs	r3, #1
3401824a:	465a      	mov	r2, fp
3401824c:	4631      	mov	r1, r6
3401824e:	4628      	mov	r0, r5
34018250:	47b8      	blx	r7
34018252:	3001      	adds	r0, #1
34018254:	f43f af00 	beq.w	34018058 <_printf_float+0x98>
34018258:	f10a 0a01 	add.w	sl, sl, #1
3401825c:	e7ee      	b.n	3401823c <_printf_float+0x27c>
3401825e:	bf00      	nop
34018260:	ffffffff 	.word	0xffffffff
34018264:	7fefffff 	.word	0x7fefffff
34018268:	3401e093 	.word	0x3401e093
3401826c:	3401e08f 	.word	0x3401e08f
34018270:	3401e09b 	.word	0x3401e09b
34018274:	3401e097 	.word	0x3401e097
34018278:	3401d306 	.word	0x3401d306
3401827c:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401827e:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
34018282:	4553      	cmp	r3, sl
34018284:	bfa8      	it	ge
34018286:	4653      	movge	r3, sl
34018288:	2b00      	cmp	r3, #0
3401828a:	4699      	mov	r9, r3
3401828c:	dc37      	bgt.n	340182fe <_printf_float+0x33e>
3401828e:	2300      	movs	r3, #0
34018290:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
34018294:	f104 021a 	add.w	r2, r4, #26
34018298:	9307      	str	r3, [sp, #28]
3401829a:	6da3      	ldr	r3, [r4, #88]	@ 0x58
3401829c:	9907      	ldr	r1, [sp, #28]
3401829e:	9306      	str	r3, [sp, #24]
340182a0:	eba3 0309 	sub.w	r3, r3, r9
340182a4:	428b      	cmp	r3, r1
340182a6:	dc31      	bgt.n	3401830c <_printf_float+0x34c>
340182a8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340182aa:	459a      	cmp	sl, r3
340182ac:	dc3b      	bgt.n	34018326 <_printf_float+0x366>
340182ae:	6823      	ldr	r3, [r4, #0]
340182b0:	07da      	lsls	r2, r3, #31
340182b2:	d438      	bmi.n	34018326 <_printf_float+0x366>
340182b4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340182b6:	ebaa 0903 	sub.w	r9, sl, r3
340182ba:	9b06      	ldr	r3, [sp, #24]
340182bc:	ebaa 0303 	sub.w	r3, sl, r3
340182c0:	4599      	cmp	r9, r3
340182c2:	bfa8      	it	ge
340182c4:	4699      	movge	r9, r3
340182c6:	f1b9 0f00 	cmp.w	r9, #0
340182ca:	dc34      	bgt.n	34018336 <_printf_float+0x376>
340182cc:	f04f 0800 	mov.w	r8, #0
340182d0:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
340182d4:	f104 0b1a 	add.w	fp, r4, #26
340182d8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340182da:	ebaa 0303 	sub.w	r3, sl, r3
340182de:	eba3 0309 	sub.w	r3, r3, r9
340182e2:	4543      	cmp	r3, r8
340182e4:	f77f af76 	ble.w	340181d4 <_printf_float+0x214>
340182e8:	2301      	movs	r3, #1
340182ea:	465a      	mov	r2, fp
340182ec:	4631      	mov	r1, r6
340182ee:	4628      	mov	r0, r5
340182f0:	47b8      	blx	r7
340182f2:	3001      	adds	r0, #1
340182f4:	f43f aeb0 	beq.w	34018058 <_printf_float+0x98>
340182f8:	f108 0801 	add.w	r8, r8, #1
340182fc:	e7ec      	b.n	340182d8 <_printf_float+0x318>
340182fe:	4642      	mov	r2, r8
34018300:	4631      	mov	r1, r6
34018302:	4628      	mov	r0, r5
34018304:	47b8      	blx	r7
34018306:	3001      	adds	r0, #1
34018308:	d1c1      	bne.n	3401828e <_printf_float+0x2ce>
3401830a:	e6a5      	b.n	34018058 <_printf_float+0x98>
3401830c:	2301      	movs	r3, #1
3401830e:	4631      	mov	r1, r6
34018310:	4628      	mov	r0, r5
34018312:	9206      	str	r2, [sp, #24]
34018314:	47b8      	blx	r7
34018316:	3001      	adds	r0, #1
34018318:	f43f ae9e 	beq.w	34018058 <_printf_float+0x98>
3401831c:	9b07      	ldr	r3, [sp, #28]
3401831e:	9a06      	ldr	r2, [sp, #24]
34018320:	3301      	adds	r3, #1
34018322:	9307      	str	r3, [sp, #28]
34018324:	e7b9      	b.n	3401829a <_printf_float+0x2da>
34018326:	9b05      	ldr	r3, [sp, #20]
34018328:	465a      	mov	r2, fp
3401832a:	4631      	mov	r1, r6
3401832c:	4628      	mov	r0, r5
3401832e:	47b8      	blx	r7
34018330:	3001      	adds	r0, #1
34018332:	d1bf      	bne.n	340182b4 <_printf_float+0x2f4>
34018334:	e690      	b.n	34018058 <_printf_float+0x98>
34018336:	9a06      	ldr	r2, [sp, #24]
34018338:	464b      	mov	r3, r9
3401833a:	4631      	mov	r1, r6
3401833c:	4628      	mov	r0, r5
3401833e:	4442      	add	r2, r8
34018340:	47b8      	blx	r7
34018342:	3001      	adds	r0, #1
34018344:	d1c2      	bne.n	340182cc <_printf_float+0x30c>
34018346:	e687      	b.n	34018058 <_printf_float+0x98>
34018348:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
3401834c:	f1b9 0f01 	cmp.w	r9, #1
34018350:	dc01      	bgt.n	34018356 <_printf_float+0x396>
34018352:	07db      	lsls	r3, r3, #31
34018354:	d536      	bpl.n	340183c4 <_printf_float+0x404>
34018356:	2301      	movs	r3, #1
34018358:	4642      	mov	r2, r8
3401835a:	4631      	mov	r1, r6
3401835c:	4628      	mov	r0, r5
3401835e:	47b8      	blx	r7
34018360:	3001      	adds	r0, #1
34018362:	f43f ae79 	beq.w	34018058 <_printf_float+0x98>
34018366:	9b05      	ldr	r3, [sp, #20]
34018368:	465a      	mov	r2, fp
3401836a:	4631      	mov	r1, r6
3401836c:	4628      	mov	r0, r5
3401836e:	47b8      	blx	r7
34018370:	3001      	adds	r0, #1
34018372:	f43f ae71 	beq.w	34018058 <_printf_float+0x98>
34018376:	f109 39ff 	add.w	r9, r9, #4294967295
3401837a:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
3401837e:	eeb5 7b40 	vcmp.f64	d7, #0.0
34018382:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34018386:	d018      	beq.n	340183ba <_printf_float+0x3fa>
34018388:	464b      	mov	r3, r9
3401838a:	f108 0201 	add.w	r2, r8, #1
3401838e:	4631      	mov	r1, r6
34018390:	4628      	mov	r0, r5
34018392:	47b8      	blx	r7
34018394:	3001      	adds	r0, #1
34018396:	d10c      	bne.n	340183b2 <_printf_float+0x3f2>
34018398:	e65e      	b.n	34018058 <_printf_float+0x98>
3401839a:	2301      	movs	r3, #1
3401839c:	465a      	mov	r2, fp
3401839e:	4631      	mov	r1, r6
340183a0:	4628      	mov	r0, r5
340183a2:	47b8      	blx	r7
340183a4:	3001      	adds	r0, #1
340183a6:	f43f ae57 	beq.w	34018058 <_printf_float+0x98>
340183aa:	f108 0801 	add.w	r8, r8, #1
340183ae:	45c8      	cmp	r8, r9
340183b0:	dbf3      	blt.n	3401839a <_printf_float+0x3da>
340183b2:	4653      	mov	r3, sl
340183b4:	f104 0250 	add.w	r2, r4, #80	@ 0x50
340183b8:	e6dc      	b.n	34018174 <_printf_float+0x1b4>
340183ba:	f04f 0800 	mov.w	r8, #0
340183be:	f104 0b1a 	add.w	fp, r4, #26
340183c2:	e7f4      	b.n	340183ae <_printf_float+0x3ee>
340183c4:	2301      	movs	r3, #1
340183c6:	4642      	mov	r2, r8
340183c8:	e7e1      	b.n	3401838e <_printf_float+0x3ce>
340183ca:	2301      	movs	r3, #1
340183cc:	464a      	mov	r2, r9
340183ce:	4631      	mov	r1, r6
340183d0:	4628      	mov	r0, r5
340183d2:	47b8      	blx	r7
340183d4:	3001      	adds	r0, #1
340183d6:	f43f ae3f 	beq.w	34018058 <_printf_float+0x98>
340183da:	f108 0801 	add.w	r8, r8, #1
340183de:	68e3      	ldr	r3, [r4, #12]
340183e0:	990b      	ldr	r1, [sp, #44]	@ 0x2c
340183e2:	1a5b      	subs	r3, r3, r1
340183e4:	4543      	cmp	r3, r8
340183e6:	dcf0      	bgt.n	340183ca <_printf_float+0x40a>
340183e8:	e6f8      	b.n	340181dc <_printf_float+0x21c>
340183ea:	f04f 0800 	mov.w	r8, #0
340183ee:	f104 0919 	add.w	r9, r4, #25
340183f2:	e7f4      	b.n	340183de <_printf_float+0x41e>

340183f4 <_printf_common>:
340183f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340183f8:	4616      	mov	r6, r2
340183fa:	4698      	mov	r8, r3
340183fc:	688a      	ldr	r2, [r1, #8]
340183fe:	4607      	mov	r7, r0
34018400:	690b      	ldr	r3, [r1, #16]
34018402:	460c      	mov	r4, r1
34018404:	f8dd 9020 	ldr.w	r9, [sp, #32]
34018408:	4293      	cmp	r3, r2
3401840a:	bfb8      	it	lt
3401840c:	4613      	movlt	r3, r2
3401840e:	6033      	str	r3, [r6, #0]
34018410:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
34018414:	b10a      	cbz	r2, 3401841a <_printf_common+0x26>
34018416:	3301      	adds	r3, #1
34018418:	6033      	str	r3, [r6, #0]
3401841a:	6823      	ldr	r3, [r4, #0]
3401841c:	0699      	lsls	r1, r3, #26
3401841e:	bf42      	ittt	mi
34018420:	6833      	ldrmi	r3, [r6, #0]
34018422:	3302      	addmi	r3, #2
34018424:	6033      	strmi	r3, [r6, #0]
34018426:	6825      	ldr	r5, [r4, #0]
34018428:	f015 0506 	ands.w	r5, r5, #6
3401842c:	d106      	bne.n	3401843c <_printf_common+0x48>
3401842e:	f104 0a19 	add.w	sl, r4, #25
34018432:	68e3      	ldr	r3, [r4, #12]
34018434:	6832      	ldr	r2, [r6, #0]
34018436:	1a9b      	subs	r3, r3, r2
34018438:	42ab      	cmp	r3, r5
3401843a:	dc2b      	bgt.n	34018494 <_printf_common+0xa0>
3401843c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
34018440:	6822      	ldr	r2, [r4, #0]
34018442:	3b00      	subs	r3, #0
34018444:	bf18      	it	ne
34018446:	2301      	movne	r3, #1
34018448:	0692      	lsls	r2, r2, #26
3401844a:	d430      	bmi.n	340184ae <_printf_common+0xba>
3401844c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
34018450:	4641      	mov	r1, r8
34018452:	4638      	mov	r0, r7
34018454:	47c8      	blx	r9
34018456:	3001      	adds	r0, #1
34018458:	d023      	beq.n	340184a2 <_printf_common+0xae>
3401845a:	6823      	ldr	r3, [r4, #0]
3401845c:	341a      	adds	r4, #26
3401845e:	f854 2c0a 	ldr.w	r2, [r4, #-10]
34018462:	f003 0306 	and.w	r3, r3, #6
34018466:	2b04      	cmp	r3, #4
34018468:	bf0a      	itet	eq
3401846a:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
3401846e:	2500      	movne	r5, #0
34018470:	6833      	ldreq	r3, [r6, #0]
34018472:	f04f 0600 	mov.w	r6, #0
34018476:	bf08      	it	eq
34018478:	1aed      	subeq	r5, r5, r3
3401847a:	f854 3c12 	ldr.w	r3, [r4, #-18]
3401847e:	bf08      	it	eq
34018480:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
34018484:	4293      	cmp	r3, r2
34018486:	bfc4      	itt	gt
34018488:	1a9b      	subgt	r3, r3, r2
3401848a:	18ed      	addgt	r5, r5, r3
3401848c:	42b5      	cmp	r5, r6
3401848e:	d11a      	bne.n	340184c6 <_printf_common+0xd2>
34018490:	2000      	movs	r0, #0
34018492:	e008      	b.n	340184a6 <_printf_common+0xb2>
34018494:	2301      	movs	r3, #1
34018496:	4652      	mov	r2, sl
34018498:	4641      	mov	r1, r8
3401849a:	4638      	mov	r0, r7
3401849c:	47c8      	blx	r9
3401849e:	3001      	adds	r0, #1
340184a0:	d103      	bne.n	340184aa <_printf_common+0xb6>
340184a2:	f04f 30ff 	mov.w	r0, #4294967295
340184a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
340184aa:	3501      	adds	r5, #1
340184ac:	e7c1      	b.n	34018432 <_printf_common+0x3e>
340184ae:	18e1      	adds	r1, r4, r3
340184b0:	1c5a      	adds	r2, r3, #1
340184b2:	2030      	movs	r0, #48	@ 0x30
340184b4:	3302      	adds	r3, #2
340184b6:	4422      	add	r2, r4
340184b8:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
340184bc:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
340184c0:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
340184c4:	e7c2      	b.n	3401844c <_printf_common+0x58>
340184c6:	2301      	movs	r3, #1
340184c8:	4622      	mov	r2, r4
340184ca:	4641      	mov	r1, r8
340184cc:	4638      	mov	r0, r7
340184ce:	47c8      	blx	r9
340184d0:	3001      	adds	r0, #1
340184d2:	d0e6      	beq.n	340184a2 <_printf_common+0xae>
340184d4:	3601      	adds	r6, #1
340184d6:	e7d9      	b.n	3401848c <_printf_common+0x98>

340184d8 <_printf_i>:
340184d8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
340184dc:	7e0f      	ldrb	r7, [r1, #24]
340184de:	4691      	mov	r9, r2
340184e0:	4680      	mov	r8, r0
340184e2:	460c      	mov	r4, r1
340184e4:	2f78      	cmp	r7, #120	@ 0x78
340184e6:	469a      	mov	sl, r3
340184e8:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
340184ea:	f101 0243 	add.w	r2, r1, #67	@ 0x43
340184ee:	d807      	bhi.n	34018500 <_printf_i+0x28>
340184f0:	2f62      	cmp	r7, #98	@ 0x62
340184f2:	d80a      	bhi.n	3401850a <_printf_i+0x32>
340184f4:	2f00      	cmp	r7, #0
340184f6:	f000 80d1 	beq.w	3401869c <_printf_i+0x1c4>
340184fa:	2f58      	cmp	r7, #88	@ 0x58
340184fc:	f000 80b8 	beq.w	34018670 <_printf_i+0x198>
34018500:	f104 0642 	add.w	r6, r4, #66	@ 0x42
34018504:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
34018508:	e03a      	b.n	34018580 <_printf_i+0xa8>
3401850a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
3401850e:	2b15      	cmp	r3, #21
34018510:	d8f6      	bhi.n	34018500 <_printf_i+0x28>
34018512:	a101      	add	r1, pc, #4	@ (adr r1, 34018518 <_printf_i+0x40>)
34018514:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
34018518:	34018571 	.word	0x34018571
3401851c:	34018585 	.word	0x34018585
34018520:	34018501 	.word	0x34018501
34018524:	34018501 	.word	0x34018501
34018528:	34018501 	.word	0x34018501
3401852c:	34018501 	.word	0x34018501
34018530:	34018585 	.word	0x34018585
34018534:	34018501 	.word	0x34018501
34018538:	34018501 	.word	0x34018501
3401853c:	34018501 	.word	0x34018501
34018540:	34018501 	.word	0x34018501
34018544:	34018683 	.word	0x34018683
34018548:	340185af 	.word	0x340185af
3401854c:	3401863d 	.word	0x3401863d
34018550:	34018501 	.word	0x34018501
34018554:	34018501 	.word	0x34018501
34018558:	340186a5 	.word	0x340186a5
3401855c:	34018501 	.word	0x34018501
34018560:	340185af 	.word	0x340185af
34018564:	34018501 	.word	0x34018501
34018568:	34018501 	.word	0x34018501
3401856c:	34018645 	.word	0x34018645
34018570:	6833      	ldr	r3, [r6, #0]
34018572:	1d1a      	adds	r2, r3, #4
34018574:	681b      	ldr	r3, [r3, #0]
34018576:	6032      	str	r2, [r6, #0]
34018578:	f104 0642 	add.w	r6, r4, #66	@ 0x42
3401857c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
34018580:	2301      	movs	r3, #1
34018582:	e09c      	b.n	340186be <_printf_i+0x1e6>
34018584:	6833      	ldr	r3, [r6, #0]
34018586:	6820      	ldr	r0, [r4, #0]
34018588:	1d19      	adds	r1, r3, #4
3401858a:	6031      	str	r1, [r6, #0]
3401858c:	0606      	lsls	r6, r0, #24
3401858e:	d501      	bpl.n	34018594 <_printf_i+0xbc>
34018590:	681d      	ldr	r5, [r3, #0]
34018592:	e003      	b.n	3401859c <_printf_i+0xc4>
34018594:	0645      	lsls	r5, r0, #25
34018596:	d5fb      	bpl.n	34018590 <_printf_i+0xb8>
34018598:	f9b3 5000 	ldrsh.w	r5, [r3]
3401859c:	2d00      	cmp	r5, #0
3401859e:	da03      	bge.n	340185a8 <_printf_i+0xd0>
340185a0:	232d      	movs	r3, #45	@ 0x2d
340185a2:	426d      	negs	r5, r5
340185a4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340185a8:	4858      	ldr	r0, [pc, #352]	@ (3401870c <_printf_i+0x234>)
340185aa:	230a      	movs	r3, #10
340185ac:	e011      	b.n	340185d2 <_printf_i+0xfa>
340185ae:	6821      	ldr	r1, [r4, #0]
340185b0:	6833      	ldr	r3, [r6, #0]
340185b2:	0608      	lsls	r0, r1, #24
340185b4:	f853 5b04 	ldr.w	r5, [r3], #4
340185b8:	d402      	bmi.n	340185c0 <_printf_i+0xe8>
340185ba:	0649      	lsls	r1, r1, #25
340185bc:	bf48      	it	mi
340185be:	b2ad      	uxthmi	r5, r5
340185c0:	2f6f      	cmp	r7, #111	@ 0x6f
340185c2:	6033      	str	r3, [r6, #0]
340185c4:	4851      	ldr	r0, [pc, #324]	@ (3401870c <_printf_i+0x234>)
340185c6:	bf14      	ite	ne
340185c8:	230a      	movne	r3, #10
340185ca:	2308      	moveq	r3, #8
340185cc:	2100      	movs	r1, #0
340185ce:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
340185d2:	6866      	ldr	r6, [r4, #4]
340185d4:	2e00      	cmp	r6, #0
340185d6:	60a6      	str	r6, [r4, #8]
340185d8:	db05      	blt.n	340185e6 <_printf_i+0x10e>
340185da:	6821      	ldr	r1, [r4, #0]
340185dc:	432e      	orrs	r6, r5
340185de:	f021 0104 	bic.w	r1, r1, #4
340185e2:	6021      	str	r1, [r4, #0]
340185e4:	d04b      	beq.n	3401867e <_printf_i+0x1a6>
340185e6:	4616      	mov	r6, r2
340185e8:	fbb5 f1f3 	udiv	r1, r5, r3
340185ec:	fb03 5711 	mls	r7, r3, r1, r5
340185f0:	5dc7      	ldrb	r7, [r0, r7]
340185f2:	f806 7d01 	strb.w	r7, [r6, #-1]!
340185f6:	462f      	mov	r7, r5
340185f8:	460d      	mov	r5, r1
340185fa:	42bb      	cmp	r3, r7
340185fc:	d9f4      	bls.n	340185e8 <_printf_i+0x110>
340185fe:	2b08      	cmp	r3, #8
34018600:	d10b      	bne.n	3401861a <_printf_i+0x142>
34018602:	6823      	ldr	r3, [r4, #0]
34018604:	07df      	lsls	r7, r3, #31
34018606:	d508      	bpl.n	3401861a <_printf_i+0x142>
34018608:	6923      	ldr	r3, [r4, #16]
3401860a:	6861      	ldr	r1, [r4, #4]
3401860c:	4299      	cmp	r1, r3
3401860e:	bfde      	ittt	le
34018610:	2330      	movle	r3, #48	@ 0x30
34018612:	f806 3c01 	strble.w	r3, [r6, #-1]
34018616:	f106 36ff 	addle.w	r6, r6, #4294967295
3401861a:	1b92      	subs	r2, r2, r6
3401861c:	6122      	str	r2, [r4, #16]
3401861e:	464b      	mov	r3, r9
34018620:	aa03      	add	r2, sp, #12
34018622:	4621      	mov	r1, r4
34018624:	4640      	mov	r0, r8
34018626:	f8cd a000 	str.w	sl, [sp]
3401862a:	f7ff fee3 	bl	340183f4 <_printf_common>
3401862e:	3001      	adds	r0, #1
34018630:	d14a      	bne.n	340186c8 <_printf_i+0x1f0>
34018632:	f04f 30ff 	mov.w	r0, #4294967295
34018636:	b004      	add	sp, #16
34018638:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401863c:	6823      	ldr	r3, [r4, #0]
3401863e:	f043 0320 	orr.w	r3, r3, #32
34018642:	6023      	str	r3, [r4, #0]
34018644:	2778      	movs	r7, #120	@ 0x78
34018646:	4832      	ldr	r0, [pc, #200]	@ (34018710 <_printf_i+0x238>)
34018648:	6823      	ldr	r3, [r4, #0]
3401864a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
3401864e:	061f      	lsls	r7, r3, #24
34018650:	6831      	ldr	r1, [r6, #0]
34018652:	f851 5b04 	ldr.w	r5, [r1], #4
34018656:	d402      	bmi.n	3401865e <_printf_i+0x186>
34018658:	065f      	lsls	r7, r3, #25
3401865a:	bf48      	it	mi
3401865c:	b2ad      	uxthmi	r5, r5
3401865e:	6031      	str	r1, [r6, #0]
34018660:	07d9      	lsls	r1, r3, #31
34018662:	bf44      	itt	mi
34018664:	f043 0320 	orrmi.w	r3, r3, #32
34018668:	6023      	strmi	r3, [r4, #0]
3401866a:	b11d      	cbz	r5, 34018674 <_printf_i+0x19c>
3401866c:	2310      	movs	r3, #16
3401866e:	e7ad      	b.n	340185cc <_printf_i+0xf4>
34018670:	4826      	ldr	r0, [pc, #152]	@ (3401870c <_printf_i+0x234>)
34018672:	e7e9      	b.n	34018648 <_printf_i+0x170>
34018674:	6823      	ldr	r3, [r4, #0]
34018676:	f023 0320 	bic.w	r3, r3, #32
3401867a:	6023      	str	r3, [r4, #0]
3401867c:	e7f6      	b.n	3401866c <_printf_i+0x194>
3401867e:	4616      	mov	r6, r2
34018680:	e7bd      	b.n	340185fe <_printf_i+0x126>
34018682:	6833      	ldr	r3, [r6, #0]
34018684:	6825      	ldr	r5, [r4, #0]
34018686:	1d18      	adds	r0, r3, #4
34018688:	6961      	ldr	r1, [r4, #20]
3401868a:	6030      	str	r0, [r6, #0]
3401868c:	062e      	lsls	r6, r5, #24
3401868e:	681b      	ldr	r3, [r3, #0]
34018690:	d501      	bpl.n	34018696 <_printf_i+0x1be>
34018692:	6019      	str	r1, [r3, #0]
34018694:	e002      	b.n	3401869c <_printf_i+0x1c4>
34018696:	0668      	lsls	r0, r5, #25
34018698:	d5fb      	bpl.n	34018692 <_printf_i+0x1ba>
3401869a:	8019      	strh	r1, [r3, #0]
3401869c:	2300      	movs	r3, #0
3401869e:	4616      	mov	r6, r2
340186a0:	6123      	str	r3, [r4, #16]
340186a2:	e7bc      	b.n	3401861e <_printf_i+0x146>
340186a4:	6833      	ldr	r3, [r6, #0]
340186a6:	2100      	movs	r1, #0
340186a8:	1d1a      	adds	r2, r3, #4
340186aa:	6032      	str	r2, [r6, #0]
340186ac:	681e      	ldr	r6, [r3, #0]
340186ae:	6862      	ldr	r2, [r4, #4]
340186b0:	4630      	mov	r0, r6
340186b2:	f000 fd60 	bl	34019176 <memchr>
340186b6:	b108      	cbz	r0, 340186bc <_printf_i+0x1e4>
340186b8:	1b80      	subs	r0, r0, r6
340186ba:	6060      	str	r0, [r4, #4]
340186bc:	6863      	ldr	r3, [r4, #4]
340186be:	6123      	str	r3, [r4, #16]
340186c0:	2300      	movs	r3, #0
340186c2:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340186c6:	e7aa      	b.n	3401861e <_printf_i+0x146>
340186c8:	6923      	ldr	r3, [r4, #16]
340186ca:	4632      	mov	r2, r6
340186cc:	4649      	mov	r1, r9
340186ce:	4640      	mov	r0, r8
340186d0:	47d0      	blx	sl
340186d2:	3001      	adds	r0, #1
340186d4:	d0ad      	beq.n	34018632 <_printf_i+0x15a>
340186d6:	6823      	ldr	r3, [r4, #0]
340186d8:	079b      	lsls	r3, r3, #30
340186da:	d413      	bmi.n	34018704 <_printf_i+0x22c>
340186dc:	68e0      	ldr	r0, [r4, #12]
340186de:	9b03      	ldr	r3, [sp, #12]
340186e0:	4298      	cmp	r0, r3
340186e2:	bfb8      	it	lt
340186e4:	4618      	movlt	r0, r3
340186e6:	e7a6      	b.n	34018636 <_printf_i+0x15e>
340186e8:	2301      	movs	r3, #1
340186ea:	4632      	mov	r2, r6
340186ec:	4649      	mov	r1, r9
340186ee:	4640      	mov	r0, r8
340186f0:	47d0      	blx	sl
340186f2:	3001      	adds	r0, #1
340186f4:	d09d      	beq.n	34018632 <_printf_i+0x15a>
340186f6:	3501      	adds	r5, #1
340186f8:	68e3      	ldr	r3, [r4, #12]
340186fa:	9903      	ldr	r1, [sp, #12]
340186fc:	1a5b      	subs	r3, r3, r1
340186fe:	42ab      	cmp	r3, r5
34018700:	dcf2      	bgt.n	340186e8 <_printf_i+0x210>
34018702:	e7eb      	b.n	340186dc <_printf_i+0x204>
34018704:	2500      	movs	r5, #0
34018706:	f104 0619 	add.w	r6, r4, #25
3401870a:	e7f5      	b.n	340186f8 <_printf_i+0x220>
3401870c:	3401e09f 	.word	0x3401e09f
34018710:	3401e0b0 	.word	0x3401e0b0

34018714 <std>:
34018714:	2300      	movs	r3, #0
34018716:	b510      	push	{r4, lr}
34018718:	4604      	mov	r4, r0
3401871a:	6083      	str	r3, [r0, #8]
3401871c:	8181      	strh	r1, [r0, #12]
3401871e:	4619      	mov	r1, r3
34018720:	6643      	str	r3, [r0, #100]	@ 0x64
34018722:	81c2      	strh	r2, [r0, #14]
34018724:	2208      	movs	r2, #8
34018726:	6183      	str	r3, [r0, #24]
34018728:	e9c0 3300 	strd	r3, r3, [r0]
3401872c:	e9c0 3304 	strd	r3, r3, [r0, #16]
34018730:	305c      	adds	r0, #92	@ 0x5c
34018732:	f000 fa97 	bl	34018c64 <memset>
34018736:	4b0d      	ldr	r3, [pc, #52]	@ (3401876c <std+0x58>)
34018738:	6224      	str	r4, [r4, #32]
3401873a:	6263      	str	r3, [r4, #36]	@ 0x24
3401873c:	4b0c      	ldr	r3, [pc, #48]	@ (34018770 <std+0x5c>)
3401873e:	62a3      	str	r3, [r4, #40]	@ 0x28
34018740:	4b0c      	ldr	r3, [pc, #48]	@ (34018774 <std+0x60>)
34018742:	62e3      	str	r3, [r4, #44]	@ 0x2c
34018744:	4b0c      	ldr	r3, [pc, #48]	@ (34018778 <std+0x64>)
34018746:	6323      	str	r3, [r4, #48]	@ 0x30
34018748:	4b0c      	ldr	r3, [pc, #48]	@ (3401877c <std+0x68>)
3401874a:	429c      	cmp	r4, r3
3401874c:	d006      	beq.n	3401875c <std+0x48>
3401874e:	f103 0268 	add.w	r2, r3, #104	@ 0x68
34018752:	4294      	cmp	r4, r2
34018754:	d002      	beq.n	3401875c <std+0x48>
34018756:	33d0      	adds	r3, #208	@ 0xd0
34018758:	429c      	cmp	r4, r3
3401875a:	d105      	bne.n	34018768 <std+0x54>
3401875c:	f104 0058 	add.w	r0, r4, #88	@ 0x58
34018760:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34018764:	f000 bcfc 	b.w	34019160 <__retarget_lock_init_recursive>
34018768:	bd10      	pop	{r4, pc}
3401876a:	bf00      	nop
3401876c:	34018a09 	.word	0x34018a09
34018770:	34018a2b 	.word	0x34018a2b
34018774:	34018a63 	.word	0x34018a63
34018778:	34018a87 	.word	0x34018a87
3401877c:	340581e4 	.word	0x340581e4

34018780 <stdio_exit_handler>:
34018780:	4a02      	ldr	r2, [pc, #8]	@ (3401878c <stdio_exit_handler+0xc>)
34018782:	4903      	ldr	r1, [pc, #12]	@ (34018790 <stdio_exit_handler+0x10>)
34018784:	4803      	ldr	r0, [pc, #12]	@ (34018794 <stdio_exit_handler+0x14>)
34018786:	f000 b87b 	b.w	34018880 <_fwalk_sglue>
3401878a:	bf00      	nop
3401878c:	3403eee0 	.word	0x3403eee0
34018790:	3401ab79 	.word	0x3401ab79
34018794:	3403eef0 	.word	0x3403eef0

34018798 <cleanup_stdio>:
34018798:	6841      	ldr	r1, [r0, #4]
3401879a:	4b0c      	ldr	r3, [pc, #48]	@ (340187cc <cleanup_stdio+0x34>)
3401879c:	4299      	cmp	r1, r3
3401879e:	b510      	push	{r4, lr}
340187a0:	4604      	mov	r4, r0
340187a2:	d001      	beq.n	340187a8 <cleanup_stdio+0x10>
340187a4:	f002 f9e8 	bl	3401ab78 <_fflush_r>
340187a8:	68a1      	ldr	r1, [r4, #8]
340187aa:	4b09      	ldr	r3, [pc, #36]	@ (340187d0 <cleanup_stdio+0x38>)
340187ac:	4299      	cmp	r1, r3
340187ae:	d002      	beq.n	340187b6 <cleanup_stdio+0x1e>
340187b0:	4620      	mov	r0, r4
340187b2:	f002 f9e1 	bl	3401ab78 <_fflush_r>
340187b6:	68e1      	ldr	r1, [r4, #12]
340187b8:	4b06      	ldr	r3, [pc, #24]	@ (340187d4 <cleanup_stdio+0x3c>)
340187ba:	4299      	cmp	r1, r3
340187bc:	d004      	beq.n	340187c8 <cleanup_stdio+0x30>
340187be:	4620      	mov	r0, r4
340187c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
340187c4:	f002 b9d8 	b.w	3401ab78 <_fflush_r>
340187c8:	bd10      	pop	{r4, pc}
340187ca:	bf00      	nop
340187cc:	340581e4 	.word	0x340581e4
340187d0:	3405824c 	.word	0x3405824c
340187d4:	340582b4 	.word	0x340582b4

340187d8 <global_stdio_init.part.0>:
340187d8:	b510      	push	{r4, lr}
340187da:	4b0b      	ldr	r3, [pc, #44]	@ (34018808 <global_stdio_init.part.0+0x30>)
340187dc:	2104      	movs	r1, #4
340187de:	4c0b      	ldr	r4, [pc, #44]	@ (3401880c <global_stdio_init.part.0+0x34>)
340187e0:	4a0b      	ldr	r2, [pc, #44]	@ (34018810 <global_stdio_init.part.0+0x38>)
340187e2:	4620      	mov	r0, r4
340187e4:	601a      	str	r2, [r3, #0]
340187e6:	2200      	movs	r2, #0
340187e8:	f7ff ff94 	bl	34018714 <std>
340187ec:	f104 0068 	add.w	r0, r4, #104	@ 0x68
340187f0:	2201      	movs	r2, #1
340187f2:	2109      	movs	r1, #9
340187f4:	f7ff ff8e 	bl	34018714 <std>
340187f8:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
340187fc:	2202      	movs	r2, #2
340187fe:	2112      	movs	r1, #18
34018800:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34018804:	f7ff bf86 	b.w	34018714 <std>
34018808:	3405831c 	.word	0x3405831c
3401880c:	340581e4 	.word	0x340581e4
34018810:	34018781 	.word	0x34018781

34018814 <__sfp_lock_acquire>:
34018814:	4801      	ldr	r0, [pc, #4]	@ (3401881c <__sfp_lock_acquire+0x8>)
34018816:	f000 bca4 	b.w	34019162 <__retarget_lock_acquire_recursive>
3401881a:	bf00      	nop
3401881c:	34058325 	.word	0x34058325

34018820 <__sfp_lock_release>:
34018820:	4801      	ldr	r0, [pc, #4]	@ (34018828 <__sfp_lock_release+0x8>)
34018822:	f000 bc9f 	b.w	34019164 <__retarget_lock_release_recursive>
34018826:	bf00      	nop
34018828:	34058325 	.word	0x34058325

3401882c <__sinit>:
3401882c:	b510      	push	{r4, lr}
3401882e:	4604      	mov	r4, r0
34018830:	f7ff fff0 	bl	34018814 <__sfp_lock_acquire>
34018834:	6a23      	ldr	r3, [r4, #32]
34018836:	b11b      	cbz	r3, 34018840 <__sinit+0x14>
34018838:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
3401883c:	f7ff bff0 	b.w	34018820 <__sfp_lock_release>
34018840:	4b04      	ldr	r3, [pc, #16]	@ (34018854 <__sinit+0x28>)
34018842:	6223      	str	r3, [r4, #32]
34018844:	4b04      	ldr	r3, [pc, #16]	@ (34018858 <__sinit+0x2c>)
34018846:	681b      	ldr	r3, [r3, #0]
34018848:	2b00      	cmp	r3, #0
3401884a:	d1f5      	bne.n	34018838 <__sinit+0xc>
3401884c:	f7ff ffc4 	bl	340187d8 <global_stdio_init.part.0>
34018850:	e7f2      	b.n	34018838 <__sinit+0xc>
34018852:	bf00      	nop
34018854:	34018799 	.word	0x34018799
34018858:	3405831c 	.word	0x3405831c

3401885c <fiprintf>:
3401885c:	b40e      	push	{r1, r2, r3}
3401885e:	b503      	push	{r0, r1, lr}
34018860:	ab03      	add	r3, sp, #12
34018862:	4601      	mov	r1, r0
34018864:	4805      	ldr	r0, [pc, #20]	@ (3401887c <fiprintf+0x20>)
34018866:	f853 2b04 	ldr.w	r2, [r3], #4
3401886a:	6800      	ldr	r0, [r0, #0]
3401886c:	9301      	str	r3, [sp, #4]
3401886e:	f001 ffe7 	bl	3401a840 <_vfiprintf_r>
34018872:	b002      	add	sp, #8
34018874:	f85d eb04 	ldr.w	lr, [sp], #4
34018878:	b003      	add	sp, #12
3401887a:	4770      	bx	lr
3401887c:	3403eeec 	.word	0x3403eeec

34018880 <_fwalk_sglue>:
34018880:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34018884:	4607      	mov	r7, r0
34018886:	4688      	mov	r8, r1
34018888:	4614      	mov	r4, r2
3401888a:	2600      	movs	r6, #0
3401888c:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
34018890:	f1b9 0901 	subs.w	r9, r9, #1
34018894:	d505      	bpl.n	340188a2 <_fwalk_sglue+0x22>
34018896:	6824      	ldr	r4, [r4, #0]
34018898:	2c00      	cmp	r4, #0
3401889a:	d1f7      	bne.n	3401888c <_fwalk_sglue+0xc>
3401889c:	4630      	mov	r0, r6
3401889e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
340188a2:	89ab      	ldrh	r3, [r5, #12]
340188a4:	2b01      	cmp	r3, #1
340188a6:	d907      	bls.n	340188b8 <_fwalk_sglue+0x38>
340188a8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
340188ac:	3301      	adds	r3, #1
340188ae:	d003      	beq.n	340188b8 <_fwalk_sglue+0x38>
340188b0:	4629      	mov	r1, r5
340188b2:	4638      	mov	r0, r7
340188b4:	47c0      	blx	r8
340188b6:	4306      	orrs	r6, r0
340188b8:	3568      	adds	r5, #104	@ 0x68
340188ba:	e7e9      	b.n	34018890 <_fwalk_sglue+0x10>

340188bc <iprintf>:
340188bc:	b40f      	push	{r0, r1, r2, r3}
340188be:	b507      	push	{r0, r1, r2, lr}
340188c0:	4906      	ldr	r1, [pc, #24]	@ (340188dc <iprintf+0x20>)
340188c2:	ab04      	add	r3, sp, #16
340188c4:	6808      	ldr	r0, [r1, #0]
340188c6:	f853 2b04 	ldr.w	r2, [r3], #4
340188ca:	6881      	ldr	r1, [r0, #8]
340188cc:	9301      	str	r3, [sp, #4]
340188ce:	f001 ffb7 	bl	3401a840 <_vfiprintf_r>
340188d2:	b003      	add	sp, #12
340188d4:	f85d eb04 	ldr.w	lr, [sp], #4
340188d8:	b004      	add	sp, #16
340188da:	4770      	bx	lr
340188dc:	3403eeec 	.word	0x3403eeec

340188e0 <_puts_r>:
340188e0:	6a03      	ldr	r3, [r0, #32]
340188e2:	b570      	push	{r4, r5, r6, lr}
340188e4:	4605      	mov	r5, r0
340188e6:	460e      	mov	r6, r1
340188e8:	6884      	ldr	r4, [r0, #8]
340188ea:	b90b      	cbnz	r3, 340188f0 <_puts_r+0x10>
340188ec:	f7ff ff9e 	bl	3401882c <__sinit>
340188f0:	6e63      	ldr	r3, [r4, #100]	@ 0x64
340188f2:	07db      	lsls	r3, r3, #31
340188f4:	d405      	bmi.n	34018902 <_puts_r+0x22>
340188f6:	89a3      	ldrh	r3, [r4, #12]
340188f8:	0598      	lsls	r0, r3, #22
340188fa:	d402      	bmi.n	34018902 <_puts_r+0x22>
340188fc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340188fe:	f000 fc30 	bl	34019162 <__retarget_lock_acquire_recursive>
34018902:	89a3      	ldrh	r3, [r4, #12]
34018904:	0719      	lsls	r1, r3, #28
34018906:	d502      	bpl.n	3401890e <_puts_r+0x2e>
34018908:	6923      	ldr	r3, [r4, #16]
3401890a:	2b00      	cmp	r3, #0
3401890c:	d135      	bne.n	3401897a <_puts_r+0x9a>
3401890e:	4621      	mov	r1, r4
34018910:	4628      	mov	r0, r5
34018912:	f000 f937 	bl	34018b84 <__swsetup_r>
34018916:	b380      	cbz	r0, 3401897a <_puts_r+0x9a>
34018918:	f04f 35ff 	mov.w	r5, #4294967295
3401891c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401891e:	07da      	lsls	r2, r3, #31
34018920:	d405      	bmi.n	3401892e <_puts_r+0x4e>
34018922:	89a3      	ldrh	r3, [r4, #12]
34018924:	059b      	lsls	r3, r3, #22
34018926:	d402      	bmi.n	3401892e <_puts_r+0x4e>
34018928:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401892a:	f000 fc1b 	bl	34019164 <__retarget_lock_release_recursive>
3401892e:	4628      	mov	r0, r5
34018930:	bd70      	pop	{r4, r5, r6, pc}
34018932:	2b00      	cmp	r3, #0
34018934:	da04      	bge.n	34018940 <_puts_r+0x60>
34018936:	69a2      	ldr	r2, [r4, #24]
34018938:	429a      	cmp	r2, r3
3401893a:	dc17      	bgt.n	3401896c <_puts_r+0x8c>
3401893c:	290a      	cmp	r1, #10
3401893e:	d015      	beq.n	3401896c <_puts_r+0x8c>
34018940:	6823      	ldr	r3, [r4, #0]
34018942:	1c5a      	adds	r2, r3, #1
34018944:	6022      	str	r2, [r4, #0]
34018946:	7019      	strb	r1, [r3, #0]
34018948:	68a3      	ldr	r3, [r4, #8]
3401894a:	f816 1f01 	ldrb.w	r1, [r6, #1]!
3401894e:	3b01      	subs	r3, #1
34018950:	60a3      	str	r3, [r4, #8]
34018952:	2900      	cmp	r1, #0
34018954:	d1ed      	bne.n	34018932 <_puts_r+0x52>
34018956:	2b00      	cmp	r3, #0
34018958:	da11      	bge.n	3401897e <_puts_r+0x9e>
3401895a:	4622      	mov	r2, r4
3401895c:	210a      	movs	r1, #10
3401895e:	4628      	mov	r0, r5
34018960:	f000 f8d2 	bl	34018b08 <__swbuf_r>
34018964:	3001      	adds	r0, #1
34018966:	d0d7      	beq.n	34018918 <_puts_r+0x38>
34018968:	250a      	movs	r5, #10
3401896a:	e7d7      	b.n	3401891c <_puts_r+0x3c>
3401896c:	4622      	mov	r2, r4
3401896e:	4628      	mov	r0, r5
34018970:	f000 f8ca 	bl	34018b08 <__swbuf_r>
34018974:	3001      	adds	r0, #1
34018976:	d1e7      	bne.n	34018948 <_puts_r+0x68>
34018978:	e7ce      	b.n	34018918 <_puts_r+0x38>
3401897a:	3e01      	subs	r6, #1
3401897c:	e7e4      	b.n	34018948 <_puts_r+0x68>
3401897e:	6823      	ldr	r3, [r4, #0]
34018980:	1c5a      	adds	r2, r3, #1
34018982:	6022      	str	r2, [r4, #0]
34018984:	220a      	movs	r2, #10
34018986:	701a      	strb	r2, [r3, #0]
34018988:	e7ee      	b.n	34018968 <_puts_r+0x88>
	...

3401898c <puts>:
3401898c:	4b02      	ldr	r3, [pc, #8]	@ (34018998 <puts+0xc>)
3401898e:	4601      	mov	r1, r0
34018990:	6818      	ldr	r0, [r3, #0]
34018992:	f7ff bfa5 	b.w	340188e0 <_puts_r>
34018996:	bf00      	nop
34018998:	3403eeec 	.word	0x3403eeec

3401899c <sniprintf>:
3401899c:	b40c      	push	{r2, r3}
3401899e:	4b19      	ldr	r3, [pc, #100]	@ (34018a04 <sniprintf+0x68>)
340189a0:	b530      	push	{r4, r5, lr}
340189a2:	1e0c      	subs	r4, r1, #0
340189a4:	b09d      	sub	sp, #116	@ 0x74
340189a6:	681d      	ldr	r5, [r3, #0]
340189a8:	da08      	bge.n	340189bc <sniprintf+0x20>
340189aa:	238b      	movs	r3, #139	@ 0x8b
340189ac:	f04f 30ff 	mov.w	r0, #4294967295
340189b0:	602b      	str	r3, [r5, #0]
340189b2:	b01d      	add	sp, #116	@ 0x74
340189b4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
340189b8:	b002      	add	sp, #8
340189ba:	4770      	bx	lr
340189bc:	f44f 7302 	mov.w	r3, #520	@ 0x208
340189c0:	9002      	str	r0, [sp, #8]
340189c2:	9006      	str	r0, [sp, #24]
340189c4:	a902      	add	r1, sp, #8
340189c6:	f8ad 3014 	strh.w	r3, [sp, #20]
340189ca:	f04f 0300 	mov.w	r3, #0
340189ce:	9a20      	ldr	r2, [sp, #128]	@ 0x80
340189d0:	4628      	mov	r0, r5
340189d2:	931b      	str	r3, [sp, #108]	@ 0x6c
340189d4:	bf14      	ite	ne
340189d6:	f104 33ff 	addne.w	r3, r4, #4294967295
340189da:	4623      	moveq	r3, r4
340189dc:	9304      	str	r3, [sp, #16]
340189de:	9307      	str	r3, [sp, #28]
340189e0:	f64f 73ff 	movw	r3, #65535	@ 0xffff
340189e4:	f8ad 3016 	strh.w	r3, [sp, #22]
340189e8:	ab21      	add	r3, sp, #132	@ 0x84
340189ea:	9301      	str	r3, [sp, #4]
340189ec:	f001 fe02 	bl	3401a5f4 <_svfiprintf_r>
340189f0:	1c43      	adds	r3, r0, #1
340189f2:	bfbc      	itt	lt
340189f4:	238b      	movlt	r3, #139	@ 0x8b
340189f6:	602b      	strlt	r3, [r5, #0]
340189f8:	2c00      	cmp	r4, #0
340189fa:	d0da      	beq.n	340189b2 <sniprintf+0x16>
340189fc:	9b02      	ldr	r3, [sp, #8]
340189fe:	2200      	movs	r2, #0
34018a00:	701a      	strb	r2, [r3, #0]
34018a02:	e7d6      	b.n	340189b2 <sniprintf+0x16>
34018a04:	3403eeec 	.word	0x3403eeec

34018a08 <__sread>:
34018a08:	b510      	push	{r4, lr}
34018a0a:	460c      	mov	r4, r1
34018a0c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34018a10:	f000 fb48 	bl	340190a4 <_read_r>
34018a14:	2800      	cmp	r0, #0
34018a16:	bfab      	itete	ge
34018a18:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
34018a1a:	89a3      	ldrhlt	r3, [r4, #12]
34018a1c:	181b      	addge	r3, r3, r0
34018a1e:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
34018a22:	bfac      	ite	ge
34018a24:	6563      	strge	r3, [r4, #84]	@ 0x54
34018a26:	81a3      	strhlt	r3, [r4, #12]
34018a28:	bd10      	pop	{r4, pc}

34018a2a <__swrite>:
34018a2a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34018a2e:	461f      	mov	r7, r3
34018a30:	898b      	ldrh	r3, [r1, #12]
34018a32:	4605      	mov	r5, r0
34018a34:	460c      	mov	r4, r1
34018a36:	05db      	lsls	r3, r3, #23
34018a38:	4616      	mov	r6, r2
34018a3a:	d505      	bpl.n	34018a48 <__swrite+0x1e>
34018a3c:	2302      	movs	r3, #2
34018a3e:	2200      	movs	r2, #0
34018a40:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34018a44:	f000 fb1c 	bl	34019080 <_lseek_r>
34018a48:	89a3      	ldrh	r3, [r4, #12]
34018a4a:	4632      	mov	r2, r6
34018a4c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
34018a50:	4628      	mov	r0, r5
34018a52:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
34018a56:	81a3      	strh	r3, [r4, #12]
34018a58:	463b      	mov	r3, r7
34018a5a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34018a5e:	f000 bb43 	b.w	340190e8 <_write_r>

34018a62 <__sseek>:
34018a62:	b510      	push	{r4, lr}
34018a64:	460c      	mov	r4, r1
34018a66:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34018a6a:	f000 fb09 	bl	34019080 <_lseek_r>
34018a6e:	1c43      	adds	r3, r0, #1
34018a70:	89a3      	ldrh	r3, [r4, #12]
34018a72:	bf15      	itete	ne
34018a74:	6560      	strne	r0, [r4, #84]	@ 0x54
34018a76:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
34018a7a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
34018a7e:	81a3      	strheq	r3, [r4, #12]
34018a80:	bf18      	it	ne
34018a82:	81a3      	strhne	r3, [r4, #12]
34018a84:	bd10      	pop	{r4, pc}

34018a86 <__sclose>:
34018a86:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34018a8a:	f000 bae9 	b.w	34019060 <_close_r>

34018a8e <_vsniprintf_r>:
34018a8e:	b530      	push	{r4, r5, lr}
34018a90:	4614      	mov	r4, r2
34018a92:	b09b      	sub	sp, #108	@ 0x6c
34018a94:	4605      	mov	r5, r0
34018a96:	461a      	mov	r2, r3
34018a98:	2c00      	cmp	r4, #0
34018a9a:	da05      	bge.n	34018aa8 <_vsniprintf_r+0x1a>
34018a9c:	238b      	movs	r3, #139	@ 0x8b
34018a9e:	6003      	str	r3, [r0, #0]
34018aa0:	f04f 30ff 	mov.w	r0, #4294967295
34018aa4:	b01b      	add	sp, #108	@ 0x6c
34018aa6:	bd30      	pop	{r4, r5, pc}
34018aa8:	f44f 7302 	mov.w	r3, #520	@ 0x208
34018aac:	9100      	str	r1, [sp, #0]
34018aae:	9104      	str	r1, [sp, #16]
34018ab0:	4669      	mov	r1, sp
34018ab2:	f8ad 300c 	strh.w	r3, [sp, #12]
34018ab6:	f04f 0300 	mov.w	r3, #0
34018aba:	9319      	str	r3, [sp, #100]	@ 0x64
34018abc:	bf14      	ite	ne
34018abe:	f104 33ff 	addne.w	r3, r4, #4294967295
34018ac2:	4623      	moveq	r3, r4
34018ac4:	9302      	str	r3, [sp, #8]
34018ac6:	9305      	str	r3, [sp, #20]
34018ac8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34018acc:	f8ad 300e 	strh.w	r3, [sp, #14]
34018ad0:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
34018ad2:	f001 fd8f 	bl	3401a5f4 <_svfiprintf_r>
34018ad6:	1c43      	adds	r3, r0, #1
34018ad8:	bfbc      	itt	lt
34018ada:	238b      	movlt	r3, #139	@ 0x8b
34018adc:	602b      	strlt	r3, [r5, #0]
34018ade:	2c00      	cmp	r4, #0
34018ae0:	d0e0      	beq.n	34018aa4 <_vsniprintf_r+0x16>
34018ae2:	9b00      	ldr	r3, [sp, #0]
34018ae4:	2200      	movs	r2, #0
34018ae6:	701a      	strb	r2, [r3, #0]
34018ae8:	e7dc      	b.n	34018aa4 <_vsniprintf_r+0x16>
	...

34018aec <vsniprintf>:
34018aec:	b507      	push	{r0, r1, r2, lr}
34018aee:	9300      	str	r3, [sp, #0]
34018af0:	4613      	mov	r3, r2
34018af2:	460a      	mov	r2, r1
34018af4:	4601      	mov	r1, r0
34018af6:	4803      	ldr	r0, [pc, #12]	@ (34018b04 <vsniprintf+0x18>)
34018af8:	6800      	ldr	r0, [r0, #0]
34018afa:	f7ff ffc8 	bl	34018a8e <_vsniprintf_r>
34018afe:	b003      	add	sp, #12
34018b00:	f85d fb04 	ldr.w	pc, [sp], #4
34018b04:	3403eeec 	.word	0x3403eeec

34018b08 <__swbuf_r>:
34018b08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34018b0a:	460e      	mov	r6, r1
34018b0c:	4614      	mov	r4, r2
34018b0e:	4605      	mov	r5, r0
34018b10:	b118      	cbz	r0, 34018b1a <__swbuf_r+0x12>
34018b12:	6a03      	ldr	r3, [r0, #32]
34018b14:	b90b      	cbnz	r3, 34018b1a <__swbuf_r+0x12>
34018b16:	f7ff fe89 	bl	3401882c <__sinit>
34018b1a:	69a3      	ldr	r3, [r4, #24]
34018b1c:	60a3      	str	r3, [r4, #8]
34018b1e:	89a3      	ldrh	r3, [r4, #12]
34018b20:	071a      	lsls	r2, r3, #28
34018b22:	d501      	bpl.n	34018b28 <__swbuf_r+0x20>
34018b24:	6923      	ldr	r3, [r4, #16]
34018b26:	b943      	cbnz	r3, 34018b3a <__swbuf_r+0x32>
34018b28:	4621      	mov	r1, r4
34018b2a:	4628      	mov	r0, r5
34018b2c:	f000 f82a 	bl	34018b84 <__swsetup_r>
34018b30:	b118      	cbz	r0, 34018b3a <__swbuf_r+0x32>
34018b32:	f04f 37ff 	mov.w	r7, #4294967295
34018b36:	4638      	mov	r0, r7
34018b38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34018b3a:	6823      	ldr	r3, [r4, #0]
34018b3c:	b2f6      	uxtb	r6, r6
34018b3e:	6922      	ldr	r2, [r4, #16]
34018b40:	4637      	mov	r7, r6
34018b42:	1a98      	subs	r0, r3, r2
34018b44:	6963      	ldr	r3, [r4, #20]
34018b46:	4283      	cmp	r3, r0
34018b48:	dc05      	bgt.n	34018b56 <__swbuf_r+0x4e>
34018b4a:	4621      	mov	r1, r4
34018b4c:	4628      	mov	r0, r5
34018b4e:	f002 f813 	bl	3401ab78 <_fflush_r>
34018b52:	2800      	cmp	r0, #0
34018b54:	d1ed      	bne.n	34018b32 <__swbuf_r+0x2a>
34018b56:	68a3      	ldr	r3, [r4, #8]
34018b58:	3b01      	subs	r3, #1
34018b5a:	60a3      	str	r3, [r4, #8]
34018b5c:	6823      	ldr	r3, [r4, #0]
34018b5e:	1c5a      	adds	r2, r3, #1
34018b60:	6022      	str	r2, [r4, #0]
34018b62:	701e      	strb	r6, [r3, #0]
34018b64:	1c43      	adds	r3, r0, #1
34018b66:	6962      	ldr	r2, [r4, #20]
34018b68:	429a      	cmp	r2, r3
34018b6a:	d004      	beq.n	34018b76 <__swbuf_r+0x6e>
34018b6c:	89a3      	ldrh	r3, [r4, #12]
34018b6e:	07db      	lsls	r3, r3, #31
34018b70:	d5e1      	bpl.n	34018b36 <__swbuf_r+0x2e>
34018b72:	2e0a      	cmp	r6, #10
34018b74:	d1df      	bne.n	34018b36 <__swbuf_r+0x2e>
34018b76:	4621      	mov	r1, r4
34018b78:	4628      	mov	r0, r5
34018b7a:	f001 fffd 	bl	3401ab78 <_fflush_r>
34018b7e:	2800      	cmp	r0, #0
34018b80:	d0d9      	beq.n	34018b36 <__swbuf_r+0x2e>
34018b82:	e7d6      	b.n	34018b32 <__swbuf_r+0x2a>

34018b84 <__swsetup_r>:
34018b84:	b538      	push	{r3, r4, r5, lr}
34018b86:	4b29      	ldr	r3, [pc, #164]	@ (34018c2c <__swsetup_r+0xa8>)
34018b88:	4605      	mov	r5, r0
34018b8a:	460c      	mov	r4, r1
34018b8c:	6818      	ldr	r0, [r3, #0]
34018b8e:	b118      	cbz	r0, 34018b98 <__swsetup_r+0x14>
34018b90:	6a03      	ldr	r3, [r0, #32]
34018b92:	b90b      	cbnz	r3, 34018b98 <__swsetup_r+0x14>
34018b94:	f7ff fe4a 	bl	3401882c <__sinit>
34018b98:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34018b9c:	0719      	lsls	r1, r3, #28
34018b9e:	d422      	bmi.n	34018be6 <__swsetup_r+0x62>
34018ba0:	06da      	lsls	r2, r3, #27
34018ba2:	d407      	bmi.n	34018bb4 <__swsetup_r+0x30>
34018ba4:	2209      	movs	r2, #9
34018ba6:	602a      	str	r2, [r5, #0]
34018ba8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34018bac:	f04f 30ff 	mov.w	r0, #4294967295
34018bb0:	81a3      	strh	r3, [r4, #12]
34018bb2:	e033      	b.n	34018c1c <__swsetup_r+0x98>
34018bb4:	0758      	lsls	r0, r3, #29
34018bb6:	d512      	bpl.n	34018bde <__swsetup_r+0x5a>
34018bb8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
34018bba:	b141      	cbz	r1, 34018bce <__swsetup_r+0x4a>
34018bbc:	f104 0344 	add.w	r3, r4, #68	@ 0x44
34018bc0:	4299      	cmp	r1, r3
34018bc2:	d002      	beq.n	34018bca <__swsetup_r+0x46>
34018bc4:	4628      	mov	r0, r5
34018bc6:	f001 f8e5 	bl	34019d94 <_free_r>
34018bca:	2300      	movs	r3, #0
34018bcc:	6363      	str	r3, [r4, #52]	@ 0x34
34018bce:	89a3      	ldrh	r3, [r4, #12]
34018bd0:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
34018bd4:	81a3      	strh	r3, [r4, #12]
34018bd6:	2300      	movs	r3, #0
34018bd8:	6063      	str	r3, [r4, #4]
34018bda:	6923      	ldr	r3, [r4, #16]
34018bdc:	6023      	str	r3, [r4, #0]
34018bde:	89a3      	ldrh	r3, [r4, #12]
34018be0:	f043 0308 	orr.w	r3, r3, #8
34018be4:	81a3      	strh	r3, [r4, #12]
34018be6:	6923      	ldr	r3, [r4, #16]
34018be8:	b94b      	cbnz	r3, 34018bfe <__swsetup_r+0x7a>
34018bea:	89a3      	ldrh	r3, [r4, #12]
34018bec:	f403 7320 	and.w	r3, r3, #640	@ 0x280
34018bf0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34018bf4:	d003      	beq.n	34018bfe <__swsetup_r+0x7a>
34018bf6:	4621      	mov	r1, r4
34018bf8:	4628      	mov	r0, r5
34018bfa:	f002 f80a 	bl	3401ac12 <__smakebuf_r>
34018bfe:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34018c02:	f013 0201 	ands.w	r2, r3, #1
34018c06:	d00a      	beq.n	34018c1e <__swsetup_r+0x9a>
34018c08:	2200      	movs	r2, #0
34018c0a:	60a2      	str	r2, [r4, #8]
34018c0c:	6962      	ldr	r2, [r4, #20]
34018c0e:	4252      	negs	r2, r2
34018c10:	61a2      	str	r2, [r4, #24]
34018c12:	6922      	ldr	r2, [r4, #16]
34018c14:	b942      	cbnz	r2, 34018c28 <__swsetup_r+0xa4>
34018c16:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
34018c1a:	d1c5      	bne.n	34018ba8 <__swsetup_r+0x24>
34018c1c:	bd38      	pop	{r3, r4, r5, pc}
34018c1e:	0799      	lsls	r1, r3, #30
34018c20:	bf58      	it	pl
34018c22:	6962      	ldrpl	r2, [r4, #20]
34018c24:	60a2      	str	r2, [r4, #8]
34018c26:	e7f4      	b.n	34018c12 <__swsetup_r+0x8e>
34018c28:	2000      	movs	r0, #0
34018c2a:	e7f7      	b.n	34018c1c <__swsetup_r+0x98>
34018c2c:	3403eeec 	.word	0x3403eeec

34018c30 <memmove>:
34018c30:	4288      	cmp	r0, r1
34018c32:	b510      	push	{r4, lr}
34018c34:	eb01 0402 	add.w	r4, r1, r2
34018c38:	d902      	bls.n	34018c40 <memmove+0x10>
34018c3a:	4284      	cmp	r4, r0
34018c3c:	4623      	mov	r3, r4
34018c3e:	d807      	bhi.n	34018c50 <memmove+0x20>
34018c40:	1e43      	subs	r3, r0, #1
34018c42:	42a1      	cmp	r1, r4
34018c44:	d008      	beq.n	34018c58 <memmove+0x28>
34018c46:	f811 2b01 	ldrb.w	r2, [r1], #1
34018c4a:	f803 2f01 	strb.w	r2, [r3, #1]!
34018c4e:	e7f8      	b.n	34018c42 <memmove+0x12>
34018c50:	4402      	add	r2, r0
34018c52:	4601      	mov	r1, r0
34018c54:	428a      	cmp	r2, r1
34018c56:	d100      	bne.n	34018c5a <memmove+0x2a>
34018c58:	bd10      	pop	{r4, pc}
34018c5a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
34018c5e:	f802 4d01 	strb.w	r4, [r2, #-1]!
34018c62:	e7f7      	b.n	34018c54 <memmove+0x24>

34018c64 <memset>:
34018c64:	4402      	add	r2, r0
34018c66:	4603      	mov	r3, r0
34018c68:	4293      	cmp	r3, r2
34018c6a:	d100      	bne.n	34018c6e <memset+0xa>
34018c6c:	4770      	bx	lr
34018c6e:	f803 1b01 	strb.w	r1, [r3], #1
34018c72:	e7f9      	b.n	34018c68 <memset+0x4>

34018c74 <_strerror_r>:
34018c74:	b510      	push	{r4, lr}
34018c76:	4604      	mov	r4, r0
34018c78:	4608      	mov	r0, r1
34018c7a:	4611      	mov	r1, r2
34018c7c:	461a      	mov	r2, r3
34018c7e:	288e      	cmp	r0, #142	@ 0x8e
34018c80:	f200 8130 	bhi.w	34018ee4 <_strerror_r+0x270>
34018c84:	e8df f010 	tbh	[pc, r0, lsl #1]
34018c88:	0138008f 	.word	0x0138008f
34018c8c:	00940092 	.word	0x00940092
34018c90:	00980096 	.word	0x00980096
34018c94:	009c009a 	.word	0x009c009a
34018c98:	00a2009e 	.word	0x00a2009e
34018c9c:	00a800a4 	.word	0x00a800a4
34018ca0:	00ac00aa 	.word	0x00ac00aa
34018ca4:	012e00ae 	.word	0x012e00ae
34018ca8:	00b200b0 	.word	0x00b200b0
34018cac:	00b600b4 	.word	0x00b600b4
34018cb0:	00be00b8 	.word	0x00be00b8
34018cb4:	00c600c0 	.word	0x00c600c0
34018cb8:	00ca00c8 	.word	0x00ca00c8
34018cbc:	00ce00cc 	.word	0x00ce00cc
34018cc0:	00d600d2 	.word	0x00d600d2
34018cc4:	00da00d8 	.word	0x00da00d8
34018cc8:	00de00dc 	.word	0x00de00dc
34018ccc:	00e200e0 	.word	0x00e200e0
34018cd0:	012e00e4 	.word	0x012e00e4
34018cd4:	012e012e 	.word	0x012e012e
34018cd8:	012e012e 	.word	0x012e012e
34018cdc:	012e012e 	.word	0x012e012e
34018ce0:	00e8012e 	.word	0x00e8012e
34018ce4:	012e00ec 	.word	0x012e00ec
34018ce8:	012e012e 	.word	0x012e012e
34018cec:	012e012e 	.word	0x012e012e
34018cf0:	012e012e 	.word	0x012e012e
34018cf4:	012e012e 	.word	0x012e012e
34018cf8:	012e012e 	.word	0x012e012e
34018cfc:	012e012e 	.word	0x012e012e
34018d00:	010800ee 	.word	0x010800ee
34018d04:	00f200f0 	.word	0x00f200f0
34018d08:	012e012e 	.word	0x012e012e
34018d0c:	00f4012e 	.word	0x00f4012e
34018d10:	012e012e 	.word	0x012e012e
34018d14:	00f6012e 	.word	0x00f6012e
34018d18:	012e012e 	.word	0x012e012e
34018d1c:	012e00fa 	.word	0x012e00fa
34018d20:	00fc012e 	.word	0x00fc012e
34018d24:	012e012e 	.word	0x012e012e
34018d28:	012e012e 	.word	0x012e012e
34018d2c:	012e012e 	.word	0x012e012e
34018d30:	012e012e 	.word	0x012e012e
34018d34:	012e012e 	.word	0x012e012e
34018d38:	012e00fe 	.word	0x012e00fe
34018d3c:	01020100 	.word	0x01020100
34018d40:	012e0104 	.word	0x012e0104
34018d44:	0126012e 	.word	0x0126012e
34018d48:	012e012e 	.word	0x012e012e
34018d4c:	012e012e 	.word	0x012e012e
34018d50:	012e012e 	.word	0x012e012e
34018d54:	012e012e 	.word	0x012e012e
34018d58:	01060114 	.word	0x01060114
34018d5c:	010c010a 	.word	0x010c010a
34018d60:	0110010e 	.word	0x0110010e
34018d64:	0112012e 	.word	0x0112012e
34018d68:	011a0116 	.word	0x011a0116
34018d6c:	00c200ea 	.word	0x00c200ea
34018d70:	00ba012c 	.word	0x00ba012c
34018d74:	00bc00d0 	.word	0x00bc00d0
34018d78:	00a600a0 	.word	0x00a600a0
34018d7c:	00f8012a 	.word	0x00f8012a
34018d80:	0118012e 	.word	0x0118012e
34018d84:	011e00c4 	.word	0x011e00c4
34018d88:	012e011c 	.word	0x012e011c
34018d8c:	012e012e 	.word	0x012e012e
34018d90:	012e012e 	.word	0x012e012e
34018d94:	012e00d4 	.word	0x012e00d4
34018d98:	012e012e 	.word	0x012e012e
34018d9c:	012800e6 	.word	0x012800e6
34018da0:	01220120 	.word	0x01220120
34018da4:	0124      	.short	0x0124
34018da6:	4b55      	ldr	r3, [pc, #340]	@ (34018efc <_strerror_r+0x288>)
34018da8:	4618      	mov	r0, r3
34018daa:	bd10      	pop	{r4, pc}
34018dac:	4b54      	ldr	r3, [pc, #336]	@ (34018f00 <_strerror_r+0x28c>)
34018dae:	e7fb      	b.n	34018da8 <_strerror_r+0x134>
34018db0:	4b54      	ldr	r3, [pc, #336]	@ (34018f04 <_strerror_r+0x290>)
34018db2:	e7f9      	b.n	34018da8 <_strerror_r+0x134>
34018db4:	4b54      	ldr	r3, [pc, #336]	@ (34018f08 <_strerror_r+0x294>)
34018db6:	e7f7      	b.n	34018da8 <_strerror_r+0x134>
34018db8:	4b54      	ldr	r3, [pc, #336]	@ (34018f0c <_strerror_r+0x298>)
34018dba:	e7f5      	b.n	34018da8 <_strerror_r+0x134>
34018dbc:	4b54      	ldr	r3, [pc, #336]	@ (34018f10 <_strerror_r+0x29c>)
34018dbe:	e7f3      	b.n	34018da8 <_strerror_r+0x134>
34018dc0:	4b54      	ldr	r3, [pc, #336]	@ (34018f14 <_strerror_r+0x2a0>)
34018dc2:	e7f1      	b.n	34018da8 <_strerror_r+0x134>
34018dc4:	4b54      	ldr	r3, [pc, #336]	@ (34018f18 <_strerror_r+0x2a4>)
34018dc6:	e7ef      	b.n	34018da8 <_strerror_r+0x134>
34018dc8:	4b54      	ldr	r3, [pc, #336]	@ (34018f1c <_strerror_r+0x2a8>)
34018dca:	e7ed      	b.n	34018da8 <_strerror_r+0x134>
34018dcc:	4b54      	ldr	r3, [pc, #336]	@ (34018f20 <_strerror_r+0x2ac>)
34018dce:	e7eb      	b.n	34018da8 <_strerror_r+0x134>
34018dd0:	4b54      	ldr	r3, [pc, #336]	@ (34018f24 <_strerror_r+0x2b0>)
34018dd2:	e7e9      	b.n	34018da8 <_strerror_r+0x134>
34018dd4:	4b54      	ldr	r3, [pc, #336]	@ (34018f28 <_strerror_r+0x2b4>)
34018dd6:	e7e7      	b.n	34018da8 <_strerror_r+0x134>
34018dd8:	4b54      	ldr	r3, [pc, #336]	@ (34018f2c <_strerror_r+0x2b8>)
34018dda:	e7e5      	b.n	34018da8 <_strerror_r+0x134>
34018ddc:	4b54      	ldr	r3, [pc, #336]	@ (34018f30 <_strerror_r+0x2bc>)
34018dde:	e7e3      	b.n	34018da8 <_strerror_r+0x134>
34018de0:	4b54      	ldr	r3, [pc, #336]	@ (34018f34 <_strerror_r+0x2c0>)
34018de2:	e7e1      	b.n	34018da8 <_strerror_r+0x134>
34018de4:	4b54      	ldr	r3, [pc, #336]	@ (34018f38 <_strerror_r+0x2c4>)
34018de6:	e7df      	b.n	34018da8 <_strerror_r+0x134>
34018de8:	4b54      	ldr	r3, [pc, #336]	@ (34018f3c <_strerror_r+0x2c8>)
34018dea:	e7dd      	b.n	34018da8 <_strerror_r+0x134>
34018dec:	4b54      	ldr	r3, [pc, #336]	@ (34018f40 <_strerror_r+0x2cc>)
34018dee:	e7db      	b.n	34018da8 <_strerror_r+0x134>
34018df0:	4b54      	ldr	r3, [pc, #336]	@ (34018f44 <_strerror_r+0x2d0>)
34018df2:	e7d9      	b.n	34018da8 <_strerror_r+0x134>
34018df4:	4b54      	ldr	r3, [pc, #336]	@ (34018f48 <_strerror_r+0x2d4>)
34018df6:	e7d7      	b.n	34018da8 <_strerror_r+0x134>
34018df8:	4b54      	ldr	r3, [pc, #336]	@ (34018f4c <_strerror_r+0x2d8>)
34018dfa:	e7d5      	b.n	34018da8 <_strerror_r+0x134>
34018dfc:	4b54      	ldr	r3, [pc, #336]	@ (34018f50 <_strerror_r+0x2dc>)
34018dfe:	e7d3      	b.n	34018da8 <_strerror_r+0x134>
34018e00:	4b54      	ldr	r3, [pc, #336]	@ (34018f54 <_strerror_r+0x2e0>)
34018e02:	e7d1      	b.n	34018da8 <_strerror_r+0x134>
34018e04:	4b54      	ldr	r3, [pc, #336]	@ (34018f58 <_strerror_r+0x2e4>)
34018e06:	e7cf      	b.n	34018da8 <_strerror_r+0x134>
34018e08:	4b54      	ldr	r3, [pc, #336]	@ (34018f5c <_strerror_r+0x2e8>)
34018e0a:	e7cd      	b.n	34018da8 <_strerror_r+0x134>
34018e0c:	4b54      	ldr	r3, [pc, #336]	@ (34018f60 <_strerror_r+0x2ec>)
34018e0e:	e7cb      	b.n	34018da8 <_strerror_r+0x134>
34018e10:	4b54      	ldr	r3, [pc, #336]	@ (34018f64 <_strerror_r+0x2f0>)
34018e12:	e7c9      	b.n	34018da8 <_strerror_r+0x134>
34018e14:	4b54      	ldr	r3, [pc, #336]	@ (34018f68 <_strerror_r+0x2f4>)
34018e16:	e7c7      	b.n	34018da8 <_strerror_r+0x134>
34018e18:	4b54      	ldr	r3, [pc, #336]	@ (34018f6c <_strerror_r+0x2f8>)
34018e1a:	e7c5      	b.n	34018da8 <_strerror_r+0x134>
34018e1c:	4b54      	ldr	r3, [pc, #336]	@ (34018f70 <_strerror_r+0x2fc>)
34018e1e:	e7c3      	b.n	34018da8 <_strerror_r+0x134>
34018e20:	4b54      	ldr	r3, [pc, #336]	@ (34018f74 <_strerror_r+0x300>)
34018e22:	e7c1      	b.n	34018da8 <_strerror_r+0x134>
34018e24:	4b54      	ldr	r3, [pc, #336]	@ (34018f78 <_strerror_r+0x304>)
34018e26:	e7bf      	b.n	34018da8 <_strerror_r+0x134>
34018e28:	4b54      	ldr	r3, [pc, #336]	@ (34018f7c <_strerror_r+0x308>)
34018e2a:	e7bd      	b.n	34018da8 <_strerror_r+0x134>
34018e2c:	4b54      	ldr	r3, [pc, #336]	@ (34018f80 <_strerror_r+0x30c>)
34018e2e:	e7bb      	b.n	34018da8 <_strerror_r+0x134>
34018e30:	4b54      	ldr	r3, [pc, #336]	@ (34018f84 <_strerror_r+0x310>)
34018e32:	e7b9      	b.n	34018da8 <_strerror_r+0x134>
34018e34:	4b54      	ldr	r3, [pc, #336]	@ (34018f88 <_strerror_r+0x314>)
34018e36:	e7b7      	b.n	34018da8 <_strerror_r+0x134>
34018e38:	4b54      	ldr	r3, [pc, #336]	@ (34018f8c <_strerror_r+0x318>)
34018e3a:	e7b5      	b.n	34018da8 <_strerror_r+0x134>
34018e3c:	4b54      	ldr	r3, [pc, #336]	@ (34018f90 <_strerror_r+0x31c>)
34018e3e:	e7b3      	b.n	34018da8 <_strerror_r+0x134>
34018e40:	4b54      	ldr	r3, [pc, #336]	@ (34018f94 <_strerror_r+0x320>)
34018e42:	e7b1      	b.n	34018da8 <_strerror_r+0x134>
34018e44:	4b54      	ldr	r3, [pc, #336]	@ (34018f98 <_strerror_r+0x324>)
34018e46:	e7af      	b.n	34018da8 <_strerror_r+0x134>
34018e48:	4b54      	ldr	r3, [pc, #336]	@ (34018f9c <_strerror_r+0x328>)
34018e4a:	e7ad      	b.n	34018da8 <_strerror_r+0x134>
34018e4c:	4b54      	ldr	r3, [pc, #336]	@ (34018fa0 <_strerror_r+0x32c>)
34018e4e:	e7ab      	b.n	34018da8 <_strerror_r+0x134>
34018e50:	4b54      	ldr	r3, [pc, #336]	@ (34018fa4 <_strerror_r+0x330>)
34018e52:	e7a9      	b.n	34018da8 <_strerror_r+0x134>
34018e54:	4b54      	ldr	r3, [pc, #336]	@ (34018fa8 <_strerror_r+0x334>)
34018e56:	e7a7      	b.n	34018da8 <_strerror_r+0x134>
34018e58:	4b54      	ldr	r3, [pc, #336]	@ (34018fac <_strerror_r+0x338>)
34018e5a:	e7a5      	b.n	34018da8 <_strerror_r+0x134>
34018e5c:	4b54      	ldr	r3, [pc, #336]	@ (34018fb0 <_strerror_r+0x33c>)
34018e5e:	e7a3      	b.n	34018da8 <_strerror_r+0x134>
34018e60:	4b54      	ldr	r3, [pc, #336]	@ (34018fb4 <_strerror_r+0x340>)
34018e62:	e7a1      	b.n	34018da8 <_strerror_r+0x134>
34018e64:	4b54      	ldr	r3, [pc, #336]	@ (34018fb8 <_strerror_r+0x344>)
34018e66:	e79f      	b.n	34018da8 <_strerror_r+0x134>
34018e68:	4b54      	ldr	r3, [pc, #336]	@ (34018fbc <_strerror_r+0x348>)
34018e6a:	e79d      	b.n	34018da8 <_strerror_r+0x134>
34018e6c:	4b54      	ldr	r3, [pc, #336]	@ (34018fc0 <_strerror_r+0x34c>)
34018e6e:	e79b      	b.n	34018da8 <_strerror_r+0x134>
34018e70:	4b54      	ldr	r3, [pc, #336]	@ (34018fc4 <_strerror_r+0x350>)
34018e72:	e799      	b.n	34018da8 <_strerror_r+0x134>
34018e74:	4b54      	ldr	r3, [pc, #336]	@ (34018fc8 <_strerror_r+0x354>)
34018e76:	e797      	b.n	34018da8 <_strerror_r+0x134>
34018e78:	4b54      	ldr	r3, [pc, #336]	@ (34018fcc <_strerror_r+0x358>)
34018e7a:	e795      	b.n	34018da8 <_strerror_r+0x134>
34018e7c:	4b54      	ldr	r3, [pc, #336]	@ (34018fd0 <_strerror_r+0x35c>)
34018e7e:	e793      	b.n	34018da8 <_strerror_r+0x134>
34018e80:	4b54      	ldr	r3, [pc, #336]	@ (34018fd4 <_strerror_r+0x360>)
34018e82:	e791      	b.n	34018da8 <_strerror_r+0x134>
34018e84:	4b54      	ldr	r3, [pc, #336]	@ (34018fd8 <_strerror_r+0x364>)
34018e86:	e78f      	b.n	34018da8 <_strerror_r+0x134>
34018e88:	4b54      	ldr	r3, [pc, #336]	@ (34018fdc <_strerror_r+0x368>)
34018e8a:	e78d      	b.n	34018da8 <_strerror_r+0x134>
34018e8c:	4b54      	ldr	r3, [pc, #336]	@ (34018fe0 <_strerror_r+0x36c>)
34018e8e:	e78b      	b.n	34018da8 <_strerror_r+0x134>
34018e90:	4b54      	ldr	r3, [pc, #336]	@ (34018fe4 <_strerror_r+0x370>)
34018e92:	e789      	b.n	34018da8 <_strerror_r+0x134>
34018e94:	4b54      	ldr	r3, [pc, #336]	@ (34018fe8 <_strerror_r+0x374>)
34018e96:	e787      	b.n	34018da8 <_strerror_r+0x134>
34018e98:	4b54      	ldr	r3, [pc, #336]	@ (34018fec <_strerror_r+0x378>)
34018e9a:	e785      	b.n	34018da8 <_strerror_r+0x134>
34018e9c:	4b54      	ldr	r3, [pc, #336]	@ (34018ff0 <_strerror_r+0x37c>)
34018e9e:	e783      	b.n	34018da8 <_strerror_r+0x134>
34018ea0:	4b54      	ldr	r3, [pc, #336]	@ (34018ff4 <_strerror_r+0x380>)
34018ea2:	e781      	b.n	34018da8 <_strerror_r+0x134>
34018ea4:	4b54      	ldr	r3, [pc, #336]	@ (34018ff8 <_strerror_r+0x384>)
34018ea6:	e77f      	b.n	34018da8 <_strerror_r+0x134>
34018ea8:	4b54      	ldr	r3, [pc, #336]	@ (34018ffc <_strerror_r+0x388>)
34018eaa:	e77d      	b.n	34018da8 <_strerror_r+0x134>
34018eac:	4b54      	ldr	r3, [pc, #336]	@ (34019000 <_strerror_r+0x38c>)
34018eae:	e77b      	b.n	34018da8 <_strerror_r+0x134>
34018eb0:	4b54      	ldr	r3, [pc, #336]	@ (34019004 <_strerror_r+0x390>)
34018eb2:	e779      	b.n	34018da8 <_strerror_r+0x134>
34018eb4:	4b54      	ldr	r3, [pc, #336]	@ (34019008 <_strerror_r+0x394>)
34018eb6:	e777      	b.n	34018da8 <_strerror_r+0x134>
34018eb8:	4b54      	ldr	r3, [pc, #336]	@ (3401900c <_strerror_r+0x398>)
34018eba:	e775      	b.n	34018da8 <_strerror_r+0x134>
34018ebc:	4b54      	ldr	r3, [pc, #336]	@ (34019010 <_strerror_r+0x39c>)
34018ebe:	e773      	b.n	34018da8 <_strerror_r+0x134>
34018ec0:	4b54      	ldr	r3, [pc, #336]	@ (34019014 <_strerror_r+0x3a0>)
34018ec2:	e771      	b.n	34018da8 <_strerror_r+0x134>
34018ec4:	4b54      	ldr	r3, [pc, #336]	@ (34019018 <_strerror_r+0x3a4>)
34018ec6:	e76f      	b.n	34018da8 <_strerror_r+0x134>
34018ec8:	4b54      	ldr	r3, [pc, #336]	@ (3401901c <_strerror_r+0x3a8>)
34018eca:	e76d      	b.n	34018da8 <_strerror_r+0x134>
34018ecc:	4b54      	ldr	r3, [pc, #336]	@ (34019020 <_strerror_r+0x3ac>)
34018ece:	e76b      	b.n	34018da8 <_strerror_r+0x134>
34018ed0:	4b54      	ldr	r3, [pc, #336]	@ (34019024 <_strerror_r+0x3b0>)
34018ed2:	e769      	b.n	34018da8 <_strerror_r+0x134>
34018ed4:	4b54      	ldr	r3, [pc, #336]	@ (34019028 <_strerror_r+0x3b4>)
34018ed6:	e767      	b.n	34018da8 <_strerror_r+0x134>
34018ed8:	4b54      	ldr	r3, [pc, #336]	@ (3401902c <_strerror_r+0x3b8>)
34018eda:	e765      	b.n	34018da8 <_strerror_r+0x134>
34018edc:	4b54      	ldr	r3, [pc, #336]	@ (34019030 <_strerror_r+0x3bc>)
34018ede:	e763      	b.n	34018da8 <_strerror_r+0x134>
34018ee0:	4b54      	ldr	r3, [pc, #336]	@ (34019034 <_strerror_r+0x3c0>)
34018ee2:	e761      	b.n	34018da8 <_strerror_r+0x134>
34018ee4:	2a00      	cmp	r2, #0
34018ee6:	bf08      	it	eq
34018ee8:	4622      	moveq	r2, r4
34018eea:	f000 f8b3 	bl	34019054 <_user_strerror>
34018eee:	4b52      	ldr	r3, [pc, #328]	@ (34019038 <_strerror_r+0x3c4>)
34018ef0:	2800      	cmp	r0, #0
34018ef2:	bf18      	it	ne
34018ef4:	4603      	movne	r3, r0
34018ef6:	e757      	b.n	34018da8 <_strerror_r+0x134>
34018ef8:	4b50      	ldr	r3, [pc, #320]	@ (3401903c <_strerror_r+0x3c8>)
34018efa:	e755      	b.n	34018da8 <_strerror_r+0x134>
34018efc:	3401e0c1 	.word	0x3401e0c1
34018f00:	3401e0d3 	.word	0x3401e0d3
34018f04:	3401e0ed 	.word	0x3401e0ed
34018f08:	3401e0fd 	.word	0x3401e0fd
34018f0c:	3401e115 	.word	0x3401e115
34018f10:	3401e11f 	.word	0x3401e11f
34018f14:	3401e139 	.word	0x3401e139
34018f18:	3401e14b 	.word	0x3401e14b
34018f1c:	3401e15d 	.word	0x3401e15d
34018f20:	3401e176 	.word	0x3401e176
34018f24:	3401e186 	.word	0x3401e186
34018f28:	3401e192 	.word	0x3401e192
34018f2c:	3401e1af 	.word	0x3401e1af
34018f30:	3401e1c1 	.word	0x3401e1c1
34018f34:	3401e1d2 	.word	0x3401e1d2
34018f38:	3401e1e4 	.word	0x3401e1e4
34018f3c:	3401e1f0 	.word	0x3401e1f0
34018f40:	3401e208 	.word	0x3401e208
34018f44:	3401e214 	.word	0x3401e214
34018f48:	3401e226 	.word	0x3401e226
34018f4c:	3401e235 	.word	0x3401e235
34018f50:	3401e245 	.word	0x3401e245
34018f54:	3401e252 	.word	0x3401e252
34018f58:	3401e271 	.word	0x3401e271
34018f5c:	3401e280 	.word	0x3401e280
34018f60:	3401e291 	.word	0x3401e291
34018f64:	3401e2b5 	.word	0x3401e2b5
34018f68:	3401e2d3 	.word	0x3401e2d3
34018f6c:	3401e2f1 	.word	0x3401e2f1
34018f70:	3401e311 	.word	0x3401e311
34018f74:	3401e328 	.word	0x3401e328
34018f78:	3401e337 	.word	0x3401e337
34018f7c:	3401e346 	.word	0x3401e346
34018f80:	3401e35a 	.word	0x3401e35a
34018f84:	3401e372 	.word	0x3401e372
34018f88:	3401e380 	.word	0x3401e380
34018f8c:	3401e38d 	.word	0x3401e38d
34018f90:	3401e3a3 	.word	0x3401e3a3
34018f94:	3401e3b2 	.word	0x3401e3b2
34018f98:	3401e3be 	.word	0x3401e3be
34018f9c:	3401e3ed 	.word	0x3401e3ed
34018fa0:	3401e3fe 	.word	0x3401e3fe
34018fa4:	3401e419 	.word	0x3401e419
34018fa8:	3401e42c 	.word	0x3401e42c
34018fac:	3401e442 	.word	0x3401e442
34018fb0:	3401e44b 	.word	0x3401e44b
34018fb4:	3401e462 	.word	0x3401e462
34018fb8:	3401e46a 	.word	0x3401e46a
34018fbc:	3401e477 	.word	0x3401e477
34018fc0:	3401e48c 	.word	0x3401e48c
34018fc4:	3401e4a0 	.word	0x3401e4a0
34018fc8:	3401e4b8 	.word	0x3401e4b8
34018fcc:	3401e4c7 	.word	0x3401e4c7
34018fd0:	3401e4d8 	.word	0x3401e4d8
34018fd4:	3401e4eb 	.word	0x3401e4eb
34018fd8:	3401e4f7 	.word	0x3401e4f7
34018fdc:	3401e510 	.word	0x3401e510
34018fe0:	3401e524 	.word	0x3401e524
34018fe4:	3401e53f 	.word	0x3401e53f
34018fe8:	3401e557 	.word	0x3401e557
34018fec:	3401e571 	.word	0x3401e571
34018ff0:	3401e579 	.word	0x3401e579
34018ff4:	3401e5a9 	.word	0x3401e5a9
34018ff8:	3401e5c8 	.word	0x3401e5c8
34018ffc:	3401e5e7 	.word	0x3401e5e7
34019000:	3401e5fe 	.word	0x3401e5fe
34019004:	3401e611 	.word	0x3401e611
34019008:	3401e62a 	.word	0x3401e62a
3401900c:	3401e641 	.word	0x3401e641
34019010:	3401e657 	.word	0x3401e657
34019014:	3401e678 	.word	0x3401e678
34019018:	3401e690 	.word	0x3401e690
3401901c:	3401e6ac 	.word	0x3401e6ac
34019020:	3401e6bf 	.word	0x3401e6bf
34019024:	3401e6d5 	.word	0x3401e6d5
34019028:	3401e6e9 	.word	0x3401e6e9
3401902c:	3401e70b 	.word	0x3401e70b
34019030:	3401e731 	.word	0x3401e731
34019034:	3401e742 	.word	0x3401e742
34019038:	3401d163 	.word	0x3401d163
3401903c:	3401e0c9 	.word	0x3401e0c9

34019040 <strerror>:
34019040:	4601      	mov	r1, r0
34019042:	2300      	movs	r3, #0
34019044:	4802      	ldr	r0, [pc, #8]	@ (34019050 <strerror+0x10>)
34019046:	461a      	mov	r2, r3
34019048:	6800      	ldr	r0, [r0, #0]
3401904a:	f7ff be13 	b.w	34018c74 <_strerror_r>
3401904e:	bf00      	nop
34019050:	3403eeec 	.word	0x3403eeec

34019054 <_user_strerror>:
34019054:	2000      	movs	r0, #0
34019056:	4770      	bx	lr

34019058 <_localeconv_r>:
34019058:	4800      	ldr	r0, [pc, #0]	@ (3401905c <_localeconv_r+0x4>)
3401905a:	4770      	bx	lr
3401905c:	3403f02c 	.word	0x3403f02c

34019060 <_close_r>:
34019060:	b538      	push	{r3, r4, r5, lr}
34019062:	2300      	movs	r3, #0
34019064:	4d05      	ldr	r5, [pc, #20]	@ (3401907c <_close_r+0x1c>)
34019066:	4604      	mov	r4, r0
34019068:	4608      	mov	r0, r1
3401906a:	602b      	str	r3, [r5, #0]
3401906c:	f7e9 fc71 	bl	34002952 <_close>
34019070:	1c43      	adds	r3, r0, #1
34019072:	d102      	bne.n	3401907a <_close_r+0x1a>
34019074:	682b      	ldr	r3, [r5, #0]
34019076:	b103      	cbz	r3, 3401907a <_close_r+0x1a>
34019078:	6023      	str	r3, [r4, #0]
3401907a:	bd38      	pop	{r3, r4, r5, pc}
3401907c:	34058320 	.word	0x34058320

34019080 <_lseek_r>:
34019080:	b538      	push	{r3, r4, r5, lr}
34019082:	4604      	mov	r4, r0
34019084:	4d06      	ldr	r5, [pc, #24]	@ (340190a0 <_lseek_r+0x20>)
34019086:	4608      	mov	r0, r1
34019088:	4611      	mov	r1, r2
3401908a:	2200      	movs	r2, #0
3401908c:	602a      	str	r2, [r5, #0]
3401908e:	461a      	mov	r2, r3
34019090:	f7e9 fc69 	bl	34002966 <_lseek>
34019094:	1c43      	adds	r3, r0, #1
34019096:	d102      	bne.n	3401909e <_lseek_r+0x1e>
34019098:	682b      	ldr	r3, [r5, #0]
3401909a:	b103      	cbz	r3, 3401909e <_lseek_r+0x1e>
3401909c:	6023      	str	r3, [r4, #0]
3401909e:	bd38      	pop	{r3, r4, r5, pc}
340190a0:	34058320 	.word	0x34058320

340190a4 <_read_r>:
340190a4:	b538      	push	{r3, r4, r5, lr}
340190a6:	4604      	mov	r4, r0
340190a8:	4d06      	ldr	r5, [pc, #24]	@ (340190c4 <_read_r+0x20>)
340190aa:	4608      	mov	r0, r1
340190ac:	4611      	mov	r1, r2
340190ae:	2200      	movs	r2, #0
340190b0:	602a      	str	r2, [r5, #0]
340190b2:	461a      	mov	r2, r3
340190b4:	f7e9 fc31 	bl	3400291a <_read>
340190b8:	1c43      	adds	r3, r0, #1
340190ba:	d102      	bne.n	340190c2 <_read_r+0x1e>
340190bc:	682b      	ldr	r3, [r5, #0]
340190be:	b103      	cbz	r3, 340190c2 <_read_r+0x1e>
340190c0:	6023      	str	r3, [r4, #0]
340190c2:	bd38      	pop	{r3, r4, r5, pc}
340190c4:	34058320 	.word	0x34058320

340190c8 <_sbrk_r>:
340190c8:	b538      	push	{r3, r4, r5, lr}
340190ca:	2300      	movs	r3, #0
340190cc:	4d05      	ldr	r5, [pc, #20]	@ (340190e4 <_sbrk_r+0x1c>)
340190ce:	4604      	mov	r4, r0
340190d0:	4608      	mov	r0, r1
340190d2:	602b      	str	r3, [r5, #0]
340190d4:	f002 fd70 	bl	3401bbb8 <_sbrk>
340190d8:	1c43      	adds	r3, r0, #1
340190da:	d102      	bne.n	340190e2 <_sbrk_r+0x1a>
340190dc:	682b      	ldr	r3, [r5, #0]
340190de:	b103      	cbz	r3, 340190e2 <_sbrk_r+0x1a>
340190e0:	6023      	str	r3, [r4, #0]
340190e2:	bd38      	pop	{r3, r4, r5, pc}
340190e4:	34058320 	.word	0x34058320

340190e8 <_write_r>:
340190e8:	b538      	push	{r3, r4, r5, lr}
340190ea:	4604      	mov	r4, r0
340190ec:	4d06      	ldr	r5, [pc, #24]	@ (34019108 <_write_r+0x20>)
340190ee:	4608      	mov	r0, r1
340190f0:	4611      	mov	r1, r2
340190f2:	2200      	movs	r2, #0
340190f4:	602a      	str	r2, [r5, #0]
340190f6:	461a      	mov	r2, r3
340190f8:	f7e9 fc1d 	bl	34002936 <_write>
340190fc:	1c43      	adds	r3, r0, #1
340190fe:	d102      	bne.n	34019106 <_write_r+0x1e>
34019100:	682b      	ldr	r3, [r5, #0]
34019102:	b103      	cbz	r3, 34019106 <_write_r+0x1e>
34019104:	6023      	str	r3, [r4, #0]
34019106:	bd38      	pop	{r3, r4, r5, pc}
34019108:	34058320 	.word	0x34058320

3401910c <__errno>:
3401910c:	4b01      	ldr	r3, [pc, #4]	@ (34019114 <__errno+0x8>)
3401910e:	6818      	ldr	r0, [r3, #0]
34019110:	4770      	bx	lr
34019112:	bf00      	nop
34019114:	3403eeec 	.word	0x3403eeec

34019118 <__libc_init_array>:
34019118:	b570      	push	{r4, r5, r6, lr}
3401911a:	4d0d      	ldr	r5, [pc, #52]	@ (34019150 <__libc_init_array+0x38>)
3401911c:	2600      	movs	r6, #0
3401911e:	4c0d      	ldr	r4, [pc, #52]	@ (34019154 <__libc_init_array+0x3c>)
34019120:	1b64      	subs	r4, r4, r5
34019122:	10a4      	asrs	r4, r4, #2
34019124:	42a6      	cmp	r6, r4
34019126:	d109      	bne.n	3401913c <__libc_init_array+0x24>
34019128:	4d0b      	ldr	r5, [pc, #44]	@ (34019158 <__libc_init_array+0x40>)
3401912a:	2600      	movs	r6, #0
3401912c:	4c0b      	ldr	r4, [pc, #44]	@ (3401915c <__libc_init_array+0x44>)
3401912e:	f002 fd51 	bl	3401bbd4 <_init>
34019132:	1b64      	subs	r4, r4, r5
34019134:	10a4      	asrs	r4, r4, #2
34019136:	42a6      	cmp	r6, r4
34019138:	d105      	bne.n	34019146 <__libc_init_array+0x2e>
3401913a:	bd70      	pop	{r4, r5, r6, pc}
3401913c:	f855 3b04 	ldr.w	r3, [r5], #4
34019140:	3601      	adds	r6, #1
34019142:	4798      	blx	r3
34019144:	e7ee      	b.n	34019124 <__libc_init_array+0xc>
34019146:	f855 3b04 	ldr.w	r3, [r5], #4
3401914a:	3601      	adds	r6, #1
3401914c:	4798      	blx	r3
3401914e:	e7f2      	b.n	34019136 <__libc_init_array+0x1e>
34019150:	3403ed54 	.word	0x3403ed54
34019154:	3403ed54 	.word	0x3403ed54
34019158:	3403ed54 	.word	0x3403ed54
3401915c:	3403ed58 	.word	0x3403ed58

34019160 <__retarget_lock_init_recursive>:
34019160:	4770      	bx	lr

34019162 <__retarget_lock_acquire_recursive>:
34019162:	4770      	bx	lr

34019164 <__retarget_lock_release_recursive>:
34019164:	4770      	bx	lr

34019166 <strcpy>:
34019166:	4603      	mov	r3, r0
34019168:	f811 2b01 	ldrb.w	r2, [r1], #1
3401916c:	f803 2b01 	strb.w	r2, [r3], #1
34019170:	2a00      	cmp	r2, #0
34019172:	d1f9      	bne.n	34019168 <strcpy+0x2>
34019174:	4770      	bx	lr

34019176 <memchr>:
34019176:	b2c9      	uxtb	r1, r1
34019178:	4603      	mov	r3, r0
3401917a:	4402      	add	r2, r0
3401917c:	b510      	push	{r4, lr}
3401917e:	4293      	cmp	r3, r2
34019180:	4618      	mov	r0, r3
34019182:	d101      	bne.n	34019188 <memchr+0x12>
34019184:	2000      	movs	r0, #0
34019186:	e003      	b.n	34019190 <memchr+0x1a>
34019188:	7804      	ldrb	r4, [r0, #0]
3401918a:	3301      	adds	r3, #1
3401918c:	428c      	cmp	r4, r1
3401918e:	d1f6      	bne.n	3401917e <memchr+0x8>
34019190:	bd10      	pop	{r4, pc}

34019192 <memcpy>:
34019192:	440a      	add	r2, r1
34019194:	1e43      	subs	r3, r0, #1
34019196:	4291      	cmp	r1, r2
34019198:	d100      	bne.n	3401919c <memcpy+0xa>
3401919a:	4770      	bx	lr
3401919c:	b510      	push	{r4, lr}
3401919e:	f811 4b01 	ldrb.w	r4, [r1], #1
340191a2:	4291      	cmp	r1, r2
340191a4:	f803 4f01 	strb.w	r4, [r3, #1]!
340191a8:	d1f9      	bne.n	3401919e <memcpy+0xc>
340191aa:	bd10      	pop	{r4, pc}

340191ac <abort>:
340191ac:	2006      	movs	r0, #6
340191ae:	b508      	push	{r3, lr}
340191b0:	f001 fd94 	bl	3401acdc <raise>
340191b4:	2001      	movs	r0, #1
340191b6:	f7e9 fbaa 	bl	3400290e <_exit>

340191ba <quorem>:
340191ba:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340191be:	6903      	ldr	r3, [r0, #16]
340191c0:	4607      	mov	r7, r0
340191c2:	690c      	ldr	r4, [r1, #16]
340191c4:	42a3      	cmp	r3, r4
340191c6:	f2c0 8083 	blt.w	340192d0 <quorem+0x116>
340191ca:	3c01      	subs	r4, #1
340191cc:	f100 0514 	add.w	r5, r0, #20
340191d0:	f101 0814 	add.w	r8, r1, #20
340191d4:	00a3      	lsls	r3, r4, #2
340191d6:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
340191da:	eb08 0984 	add.w	r9, r8, r4, lsl #2
340191de:	9300      	str	r3, [sp, #0]
340191e0:	eb05 0384 	add.w	r3, r5, r4, lsl #2
340191e4:	9301      	str	r3, [sp, #4]
340191e6:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
340191ea:	3301      	adds	r3, #1
340191ec:	429a      	cmp	r2, r3
340191ee:	fbb2 f6f3 	udiv	r6, r2, r3
340191f2:	d331      	bcc.n	34019258 <quorem+0x9e>
340191f4:	f04f 0a00 	mov.w	sl, #0
340191f8:	46c4      	mov	ip, r8
340191fa:	46ae      	mov	lr, r5
340191fc:	46d3      	mov	fp, sl
340191fe:	f85c 3b04 	ldr.w	r3, [ip], #4
34019202:	b298      	uxth	r0, r3
34019204:	45e1      	cmp	r9, ip
34019206:	ea4f 4313 	mov.w	r3, r3, lsr #16
3401920a:	fb06 a000 	mla	r0, r6, r0, sl
3401920e:	ea4f 4210 	mov.w	r2, r0, lsr #16
34019212:	b280      	uxth	r0, r0
34019214:	fb06 2303 	mla	r3, r6, r3, r2
34019218:	f8de 2000 	ldr.w	r2, [lr]
3401921c:	b292      	uxth	r2, r2
3401921e:	ea4f 4a13 	mov.w	sl, r3, lsr #16
34019222:	eba2 0200 	sub.w	r2, r2, r0
34019226:	b29b      	uxth	r3, r3
34019228:	f8de 0000 	ldr.w	r0, [lr]
3401922c:	445a      	add	r2, fp
3401922e:	ebc3 4322 	rsb	r3, r3, r2, asr #16
34019232:	b292      	uxth	r2, r2
34019234:	eb03 4310 	add.w	r3, r3, r0, lsr #16
34019238:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3401923c:	ea4f 4b23 	mov.w	fp, r3, asr #16
34019240:	f84e 2b04 	str.w	r2, [lr], #4
34019244:	d2db      	bcs.n	340191fe <quorem+0x44>
34019246:	9b00      	ldr	r3, [sp, #0]
34019248:	58eb      	ldr	r3, [r5, r3]
3401924a:	b92b      	cbnz	r3, 34019258 <quorem+0x9e>
3401924c:	9b01      	ldr	r3, [sp, #4]
3401924e:	3b04      	subs	r3, #4
34019250:	429d      	cmp	r5, r3
34019252:	461a      	mov	r2, r3
34019254:	d330      	bcc.n	340192b8 <quorem+0xfe>
34019256:	613c      	str	r4, [r7, #16]
34019258:	4638      	mov	r0, r7
3401925a:	f001 f85b 	bl	3401a314 <__mcmp>
3401925e:	2800      	cmp	r0, #0
34019260:	db26      	blt.n	340192b0 <quorem+0xf6>
34019262:	4629      	mov	r1, r5
34019264:	2000      	movs	r0, #0
34019266:	f858 2b04 	ldr.w	r2, [r8], #4
3401926a:	f8d1 c000 	ldr.w	ip, [r1]
3401926e:	fa1f fe82 	uxth.w	lr, r2
34019272:	45c1      	cmp	r9, r8
34019274:	fa1f f38c 	uxth.w	r3, ip
34019278:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401927c:	eba3 030e 	sub.w	r3, r3, lr
34019280:	4403      	add	r3, r0
34019282:	ebc2 4223 	rsb	r2, r2, r3, asr #16
34019286:	b29b      	uxth	r3, r3
34019288:	eb02 421c 	add.w	r2, r2, ip, lsr #16
3401928c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
34019290:	ea4f 4022 	mov.w	r0, r2, asr #16
34019294:	f841 3b04 	str.w	r3, [r1], #4
34019298:	d2e5      	bcs.n	34019266 <quorem+0xac>
3401929a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
3401929e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
340192a2:	b922      	cbnz	r2, 340192ae <quorem+0xf4>
340192a4:	3b04      	subs	r3, #4
340192a6:	429d      	cmp	r5, r3
340192a8:	461a      	mov	r2, r3
340192aa:	d30b      	bcc.n	340192c4 <quorem+0x10a>
340192ac:	613c      	str	r4, [r7, #16]
340192ae:	3601      	adds	r6, #1
340192b0:	4630      	mov	r0, r6
340192b2:	b003      	add	sp, #12
340192b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340192b8:	6812      	ldr	r2, [r2, #0]
340192ba:	3b04      	subs	r3, #4
340192bc:	2a00      	cmp	r2, #0
340192be:	d1ca      	bne.n	34019256 <quorem+0x9c>
340192c0:	3c01      	subs	r4, #1
340192c2:	e7c5      	b.n	34019250 <quorem+0x96>
340192c4:	6812      	ldr	r2, [r2, #0]
340192c6:	3b04      	subs	r3, #4
340192c8:	2a00      	cmp	r2, #0
340192ca:	d1ef      	bne.n	340192ac <quorem+0xf2>
340192cc:	3c01      	subs	r4, #1
340192ce:	e7ea      	b.n	340192a6 <quorem+0xec>
340192d0:	2000      	movs	r0, #0
340192d2:	e7ee      	b.n	340192b2 <quorem+0xf8>
340192d4:	0000      	movs	r0, r0
	...

340192d8 <_dtoa_r>:
340192d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340192dc:	69c7      	ldr	r7, [r0, #28]
340192de:	4681      	mov	r9, r0
340192e0:	ed2d 8b02 	vpush	{d8}
340192e4:	b091      	sub	sp, #68	@ 0x44
340192e6:	ec55 4b10 	vmov	r4, r5, d0
340192ea:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
340192ec:	9107      	str	r1, [sp, #28]
340192ee:	9209      	str	r2, [sp, #36]	@ 0x24
340192f0:	930d      	str	r3, [sp, #52]	@ 0x34
340192f2:	ed8d 0b02 	vstr	d0, [sp, #8]
340192f6:	b97f      	cbnz	r7, 34019318 <_dtoa_r+0x40>
340192f8:	2010      	movs	r0, #16
340192fa:	f7fe fb6f 	bl	340179dc <malloc>
340192fe:	4602      	mov	r2, r0
34019300:	f8c9 001c 	str.w	r0, [r9, #28]
34019304:	b920      	cbnz	r0, 34019310 <_dtoa_r+0x38>
34019306:	4ba0      	ldr	r3, [pc, #640]	@ (34019588 <_dtoa_r+0x2b0>)
34019308:	21ef      	movs	r1, #239	@ 0xef
3401930a:	48a0      	ldr	r0, [pc, #640]	@ (3401958c <_dtoa_r+0x2b4>)
3401930c:	f7fe fb48 	bl	340179a0 <__assert_func>
34019310:	e9c0 7701 	strd	r7, r7, [r0, #4]
34019314:	6007      	str	r7, [r0, #0]
34019316:	60c7      	str	r7, [r0, #12]
34019318:	f8d9 301c 	ldr.w	r3, [r9, #28]
3401931c:	6819      	ldr	r1, [r3, #0]
3401931e:	b159      	cbz	r1, 34019338 <_dtoa_r+0x60>
34019320:	685a      	ldr	r2, [r3, #4]
34019322:	2301      	movs	r3, #1
34019324:	4648      	mov	r0, r9
34019326:	4093      	lsls	r3, r2
34019328:	604a      	str	r2, [r1, #4]
3401932a:	608b      	str	r3, [r1, #8]
3401932c:	f000 fdbc 	bl	34019ea8 <_Bfree>
34019330:	f8d9 301c 	ldr.w	r3, [r9, #28]
34019334:	2200      	movs	r2, #0
34019336:	601a      	str	r2, [r3, #0]
34019338:	1e2b      	subs	r3, r5, #0
3401933a:	bfb7      	itett	lt
3401933c:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
34019340:	2300      	movge	r3, #0
34019342:	2201      	movlt	r2, #1
34019344:	9303      	strlt	r3, [sp, #12]
34019346:	bfac      	ite	ge
34019348:	6033      	strge	r3, [r6, #0]
3401934a:	6032      	strlt	r2, [r6, #0]
3401934c:	4b90      	ldr	r3, [pc, #576]	@ (34019590 <_dtoa_r+0x2b8>)
3401934e:	9e03      	ldr	r6, [sp, #12]
34019350:	43b3      	bics	r3, r6
34019352:	d110      	bne.n	34019376 <_dtoa_r+0x9e>
34019354:	f242 730f 	movw	r3, #9999	@ 0x270f
34019358:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401935a:	6013      	str	r3, [r2, #0]
3401935c:	f3c6 0313 	ubfx	r3, r6, #0, #20
34019360:	4323      	orrs	r3, r4
34019362:	f000 84e6 	beq.w	34019d32 <_dtoa_r+0xa5a>
34019366:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34019368:	4f8a      	ldr	r7, [pc, #552]	@ (34019594 <_dtoa_r+0x2bc>)
3401936a:	2b00      	cmp	r3, #0
3401936c:	f000 84e8 	beq.w	34019d40 <_dtoa_r+0xa68>
34019370:	1cfb      	adds	r3, r7, #3
34019372:	f000 bce3 	b.w	34019d3c <_dtoa_r+0xa64>
34019376:	ed9d 8b02 	vldr	d8, [sp, #8]
3401937a:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401937e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019382:	d10a      	bne.n	3401939a <_dtoa_r+0xc2>
34019384:	2301      	movs	r3, #1
34019386:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
34019388:	6013      	str	r3, [r2, #0]
3401938a:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
3401938c:	b113      	cbz	r3, 34019394 <_dtoa_r+0xbc>
3401938e:	4b82      	ldr	r3, [pc, #520]	@ (34019598 <_dtoa_r+0x2c0>)
34019390:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
34019392:	6013      	str	r3, [r2, #0]
34019394:	4f81      	ldr	r7, [pc, #516]	@ (3401959c <_dtoa_r+0x2c4>)
34019396:	f000 bcd3 	b.w	34019d40 <_dtoa_r+0xa68>
3401939a:	aa0e      	add	r2, sp, #56	@ 0x38
3401939c:	eeb0 0b48 	vmov.f64	d0, d8
340193a0:	a90f      	add	r1, sp, #60	@ 0x3c
340193a2:	4648      	mov	r0, r9
340193a4:	f001 f86a 	bl	3401a47c <__d2b>
340193a8:	f3c6 530a 	ubfx	r3, r6, #20, #11
340193ac:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340193ae:	9001      	str	r0, [sp, #4]
340193b0:	2b00      	cmp	r3, #0
340193b2:	d045      	beq.n	34019440 <_dtoa_r+0x168>
340193b4:	ee18 1a90 	vmov	r1, s17
340193b8:	eeb0 7b48 	vmov.f64	d7, d8
340193bc:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
340193c0:	2500      	movs	r5, #0
340193c2:	f3c1 0113 	ubfx	r1, r1, #0, #20
340193c6:	f041 517f 	orr.w	r1, r1, #1069547520	@ 0x3fc00000
340193ca:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
340193ce:	eeb7 6b08 	vmov.f64	d6, #120	@ 0x3fc00000  1.5
340193d2:	ee07 1a90 	vmov	s15, r1
340193d6:	ed9f 5b66 	vldr	d5, [pc, #408]	@ 34019570 <_dtoa_r+0x298>
340193da:	ee37 7b46 	vsub.f64	d7, d7, d6
340193de:	ed9f 6b66 	vldr	d6, [pc, #408]	@ 34019578 <_dtoa_r+0x2a0>
340193e2:	eea7 6b05 	vfma.f64	d6, d7, d5
340193e6:	ee07 3a90 	vmov	s15, r3
340193ea:	eeb8 4be7 	vcvt.f64.s32	d4, s15
340193ee:	ed9f 5b64 	vldr	d5, [pc, #400]	@ 34019580 <_dtoa_r+0x2a8>
340193f2:	eeb0 7b46 	vmov.f64	d7, d6
340193f6:	eea4 7b05 	vfma.f64	d7, d4, d5
340193fa:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
340193fe:	eefd 6bc7 	vcvt.s32.f64	s13, d7
34019402:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019406:	ee16 8a90 	vmov	r8, s13
3401940a:	d508      	bpl.n	3401941e <_dtoa_r+0x146>
3401940c:	eeb8 6be6 	vcvt.f64.s32	d6, s13
34019410:	eeb4 6b47 	vcmp.f64	d6, d7
34019414:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019418:	bf18      	it	ne
3401941a:	f108 38ff 	addne.w	r8, r8, #4294967295
3401941e:	f1b8 0f16 	cmp.w	r8, #22
34019422:	d82d      	bhi.n	34019480 <_dtoa_r+0x1a8>
34019424:	495e      	ldr	r1, [pc, #376]	@ (340195a0 <_dtoa_r+0x2c8>)
34019426:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
3401942a:	ed91 7b00 	vldr	d7, [r1]
3401942e:	eeb4 8bc7 	vcmpe.f64	d8, d7
34019432:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019436:	d501      	bpl.n	3401943c <_dtoa_r+0x164>
34019438:	f108 38ff 	add.w	r8, r8, #4294967295
3401943c:	2100      	movs	r1, #0
3401943e:	e020      	b.n	34019482 <_dtoa_r+0x1aa>
34019440:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
34019442:	2501      	movs	r5, #1
34019444:	4413      	add	r3, r2
34019446:	f203 4132 	addw	r1, r3, #1074	@ 0x432
3401944a:	2920      	cmp	r1, #32
3401944c:	bfc9      	itett	gt
3401944e:	f1c1 0140 	rsbgt	r1, r1, #64	@ 0x40
34019452:	f1c1 0120 	rsble	r1, r1, #32
34019456:	408e      	lslgt	r6, r1
34019458:	f203 4112 	addwgt	r1, r3, #1042	@ 0x412
3401945c:	bfd8      	it	le
3401945e:	fa04 f101 	lslle.w	r1, r4, r1
34019462:	f103 33ff 	add.w	r3, r3, #4294967295
34019466:	bfc4      	itt	gt
34019468:	fa24 f101 	lsrgt.w	r1, r4, r1
3401946c:	4331      	orrgt	r1, r6
3401946e:	ee07 1a90 	vmov	s15, r1
34019472:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34019476:	ee17 1a90 	vmov	r1, s15
3401947a:	f1a1 71f8 	sub.w	r1, r1, #32505856	@ 0x1f00000
3401947e:	e7a6      	b.n	340193ce <_dtoa_r+0xf6>
34019480:	2101      	movs	r1, #1
34019482:	1ad2      	subs	r2, r2, r3
34019484:	910c      	str	r1, [sp, #48]	@ 0x30
34019486:	1e53      	subs	r3, r2, #1
34019488:	9306      	str	r3, [sp, #24]
3401948a:	bf49      	itett	mi
3401948c:	f1c2 0301 	rsbmi	r3, r2, #1
34019490:	2300      	movpl	r3, #0
34019492:	9304      	strmi	r3, [sp, #16]
34019494:	2300      	movmi	r3, #0
34019496:	bf54      	ite	pl
34019498:	9304      	strpl	r3, [sp, #16]
3401949a:	9306      	strmi	r3, [sp, #24]
3401949c:	f1b8 0f00 	cmp.w	r8, #0
340194a0:	db16      	blt.n	340194d0 <_dtoa_r+0x1f8>
340194a2:	9b06      	ldr	r3, [sp, #24]
340194a4:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
340194a8:	4443      	add	r3, r8
340194aa:	9306      	str	r3, [sp, #24]
340194ac:	2300      	movs	r3, #0
340194ae:	9a07      	ldr	r2, [sp, #28]
340194b0:	2a09      	cmp	r2, #9
340194b2:	d843      	bhi.n	3401953c <_dtoa_r+0x264>
340194b4:	2a05      	cmp	r2, #5
340194b6:	bfc5      	ittet	gt
340194b8:	3a04      	subgt	r2, #4
340194ba:	2400      	movgt	r4, #0
340194bc:	2401      	movle	r4, #1
340194be:	9207      	strgt	r2, [sp, #28]
340194c0:	9a07      	ldr	r2, [sp, #28]
340194c2:	3a02      	subs	r2, #2
340194c4:	2a03      	cmp	r2, #3
340194c6:	d844      	bhi.n	34019552 <_dtoa_r+0x27a>
340194c8:	e8df f002 	tbb	[pc, r2]
340194cc:	0b173634 	.word	0x0b173634
340194d0:	9b04      	ldr	r3, [sp, #16]
340194d2:	2200      	movs	r2, #0
340194d4:	eba3 0308 	sub.w	r3, r3, r8
340194d8:	920a      	str	r2, [sp, #40]	@ 0x28
340194da:	9304      	str	r3, [sp, #16]
340194dc:	f1c8 0300 	rsb	r3, r8, #0
340194e0:	e7e5      	b.n	340194ae <_dtoa_r+0x1d6>
340194e2:	2201      	movs	r2, #1
340194e4:	9208      	str	r2, [sp, #32]
340194e6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
340194e8:	eb08 0b02 	add.w	fp, r8, r2
340194ec:	f10b 0a01 	add.w	sl, fp, #1
340194f0:	4652      	mov	r2, sl
340194f2:	2a01      	cmp	r2, #1
340194f4:	bfb8      	it	lt
340194f6:	2201      	movlt	r2, #1
340194f8:	e006      	b.n	34019508 <_dtoa_r+0x230>
340194fa:	2201      	movs	r2, #1
340194fc:	9208      	str	r2, [sp, #32]
340194fe:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34019500:	2a00      	cmp	r2, #0
34019502:	dd29      	ble.n	34019558 <_dtoa_r+0x280>
34019504:	4693      	mov	fp, r2
34019506:	4692      	mov	sl, r2
34019508:	f8d9 701c 	ldr.w	r7, [r9, #28]
3401950c:	2100      	movs	r1, #0
3401950e:	2004      	movs	r0, #4
34019510:	f100 0614 	add.w	r6, r0, #20
34019514:	4296      	cmp	r6, r2
34019516:	d926      	bls.n	34019566 <_dtoa_r+0x28e>
34019518:	6079      	str	r1, [r7, #4]
3401951a:	4648      	mov	r0, r9
3401951c:	9305      	str	r3, [sp, #20]
3401951e:	f000 fc83 	bl	34019e28 <_Balloc>
34019522:	9b05      	ldr	r3, [sp, #20]
34019524:	4607      	mov	r7, r0
34019526:	2800      	cmp	r0, #0
34019528:	d13e      	bne.n	340195a8 <_dtoa_r+0x2d0>
3401952a:	4b1e      	ldr	r3, [pc, #120]	@ (340195a4 <_dtoa_r+0x2cc>)
3401952c:	4602      	mov	r2, r0
3401952e:	f240 11af 	movw	r1, #431	@ 0x1af
34019532:	e6ea      	b.n	3401930a <_dtoa_r+0x32>
34019534:	2200      	movs	r2, #0
34019536:	e7e1      	b.n	340194fc <_dtoa_r+0x224>
34019538:	2200      	movs	r2, #0
3401953a:	e7d3      	b.n	340194e4 <_dtoa_r+0x20c>
3401953c:	2401      	movs	r4, #1
3401953e:	2200      	movs	r2, #0
34019540:	e9cd 2407 	strd	r2, r4, [sp, #28]
34019544:	f04f 3bff 	mov.w	fp, #4294967295
34019548:	2100      	movs	r1, #0
3401954a:	2212      	movs	r2, #18
3401954c:	46da      	mov	sl, fp
3401954e:	9109      	str	r1, [sp, #36]	@ 0x24
34019550:	e7da      	b.n	34019508 <_dtoa_r+0x230>
34019552:	2201      	movs	r2, #1
34019554:	9208      	str	r2, [sp, #32]
34019556:	e7f5      	b.n	34019544 <_dtoa_r+0x26c>
34019558:	f04f 0b01 	mov.w	fp, #1
3401955c:	46da      	mov	sl, fp
3401955e:	465a      	mov	r2, fp
34019560:	f8cd b024 	str.w	fp, [sp, #36]	@ 0x24
34019564:	e7d0      	b.n	34019508 <_dtoa_r+0x230>
34019566:	3101      	adds	r1, #1
34019568:	0040      	lsls	r0, r0, #1
3401956a:	e7d1      	b.n	34019510 <_dtoa_r+0x238>
3401956c:	f3af 8000 	nop.w
34019570:	636f4361 	.word	0x636f4361
34019574:	3fd287a7 	.word	0x3fd287a7
34019578:	8b60c8b3 	.word	0x8b60c8b3
3401957c:	3fc68a28 	.word	0x3fc68a28
34019580:	509f79fb 	.word	0x509f79fb
34019584:	3fd34413 	.word	0x3fd34413
34019588:	3401e764 	.word	0x3401e764
3401958c:	3401e77b 	.word	0x3401e77b
34019590:	7ff00000 	.word	0x7ff00000
34019594:	3401e760 	.word	0x3401e760
34019598:	3401d307 	.word	0x3401d307
3401959c:	3401d306 	.word	0x3401d306
340195a0:	3403c7b8 	.word	0x3403c7b8
340195a4:	3401e7d3 	.word	0x3401e7d3
340195a8:	f8d9 201c 	ldr.w	r2, [r9, #28]
340195ac:	f1ba 0f0e 	cmp.w	sl, #14
340195b0:	6010      	str	r0, [r2, #0]
340195b2:	d86e      	bhi.n	34019692 <_dtoa_r+0x3ba>
340195b4:	2c00      	cmp	r4, #0
340195b6:	d06c      	beq.n	34019692 <_dtoa_r+0x3ba>
340195b8:	f1b8 0f00 	cmp.w	r8, #0
340195bc:	f340 80b4 	ble.w	34019728 <_dtoa_r+0x450>
340195c0:	f008 010f 	and.w	r1, r8, #15
340195c4:	4ac7      	ldr	r2, [pc, #796]	@ (340198e4 <_dtoa_r+0x60c>)
340195c6:	f418 7f80 	tst.w	r8, #256	@ 0x100
340195ca:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
340195ce:	ea4f 1128 	mov.w	r1, r8, asr #4
340195d2:	ed92 7b00 	vldr	d7, [r2]
340195d6:	f000 809b 	beq.w	34019710 <_dtoa_r+0x438>
340195da:	4ac3      	ldr	r2, [pc, #780]	@ (340198e8 <_dtoa_r+0x610>)
340195dc:	f001 010f 	and.w	r1, r1, #15
340195e0:	ed92 6b08 	vldr	d6, [r2, #32]
340195e4:	2203      	movs	r2, #3
340195e6:	ee88 6b06 	vdiv.f64	d6, d8, d6
340195ea:	ed8d 6b02 	vstr	d6, [sp, #8]
340195ee:	48be      	ldr	r0, [pc, #760]	@ (340198e8 <_dtoa_r+0x610>)
340195f0:	2900      	cmp	r1, #0
340195f2:	f040 808f 	bne.w	34019714 <_dtoa_r+0x43c>
340195f6:	ed9d 6b02 	vldr	d6, [sp, #8]
340195fa:	ee86 7b07 	vdiv.f64	d7, d6, d7
340195fe:	ed8d 7b02 	vstr	d7, [sp, #8]
34019602:	990c      	ldr	r1, [sp, #48]	@ 0x30
34019604:	ed9d 7b02 	vldr	d7, [sp, #8]
34019608:	2900      	cmp	r1, #0
3401960a:	f000 80b3 	beq.w	34019774 <_dtoa_r+0x49c>
3401960e:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
34019612:	eeb4 7bc6 	vcmpe.f64	d7, d6
34019616:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401961a:	f140 80ab 	bpl.w	34019774 <_dtoa_r+0x49c>
3401961e:	f1ba 0f00 	cmp.w	sl, #0
34019622:	f000 80a7 	beq.w	34019774 <_dtoa_r+0x49c>
34019626:	f1bb 0f00 	cmp.w	fp, #0
3401962a:	dd30      	ble.n	3401968e <_dtoa_r+0x3b6>
3401962c:	eeb2 6b04 	vmov.f64	d6, #36	@ 0x41200000  10.0
34019630:	f108 31ff 	add.w	r1, r8, #4294967295
34019634:	3201      	adds	r2, #1
34019636:	465c      	mov	r4, fp
34019638:	9105      	str	r1, [sp, #20]
3401963a:	ee27 7b06 	vmul.f64	d7, d7, d6
3401963e:	ed8d 7b02 	vstr	d7, [sp, #8]
34019642:	ee07 2a90 	vmov	s15, r2
34019646:	eeb1 5b0c 	vmov.f64	d5, #28	@ 0x40e00000  7.0
3401964a:	ed9d 6b02 	vldr	d6, [sp, #8]
3401964e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34019652:	eea7 5b06 	vfma.f64	d5, d7, d6
34019656:	ee15 2a90 	vmov	r2, s11
3401965a:	ec51 0b15 	vmov	r0, r1, d5
3401965e:	f1a2 7150 	sub.w	r1, r2, #54525952	@ 0x3400000
34019662:	2c00      	cmp	r4, #0
34019664:	f040 808a 	bne.w	3401977c <_dtoa_r+0x4a4>
34019668:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
3401966c:	ee36 6b47 	vsub.f64	d6, d6, d7
34019670:	ec41 0b17 	vmov	d7, r0, r1
34019674:	eeb4 6bc7 	vcmpe.f64	d6, d7
34019678:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401967c:	f300 826a 	bgt.w	34019b54 <_dtoa_r+0x87c>
34019680:	eeb1 7b47 	vneg.f64	d7, d7
34019684:	eeb4 6bc7 	vcmpe.f64	d6, d7
34019688:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401968c:	d423      	bmi.n	340196d6 <_dtoa_r+0x3fe>
3401968e:	ed8d 8b02 	vstr	d8, [sp, #8]
34019692:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
34019694:	2a00      	cmp	r2, #0
34019696:	f2c0 8129 	blt.w	340198ec <_dtoa_r+0x614>
3401969a:	f1b8 0f0e 	cmp.w	r8, #14
3401969e:	f300 8125 	bgt.w	340198ec <_dtoa_r+0x614>
340196a2:	4b90      	ldr	r3, [pc, #576]	@ (340198e4 <_dtoa_r+0x60c>)
340196a4:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
340196a8:	ed93 6b00 	vldr	d6, [r3]
340196ac:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340196ae:	2b00      	cmp	r3, #0
340196b0:	f280 80c8 	bge.w	34019844 <_dtoa_r+0x56c>
340196b4:	f1ba 0f00 	cmp.w	sl, #0
340196b8:	f300 80c4 	bgt.w	34019844 <_dtoa_r+0x56c>
340196bc:	d10b      	bne.n	340196d6 <_dtoa_r+0x3fe>
340196be:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
340196c2:	ee26 6b07 	vmul.f64	d6, d6, d7
340196c6:	ed9d 7b02 	vldr	d7, [sp, #8]
340196ca:	eeb4 6bc7 	vcmpe.f64	d6, d7
340196ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340196d2:	f2c0 823c 	blt.w	34019b4e <_dtoa_r+0x876>
340196d6:	2400      	movs	r4, #0
340196d8:	4625      	mov	r5, r4
340196da:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340196dc:	463e      	mov	r6, r7
340196de:	43db      	mvns	r3, r3
340196e0:	9305      	str	r3, [sp, #20]
340196e2:	f04f 0800 	mov.w	r8, #0
340196e6:	4621      	mov	r1, r4
340196e8:	4648      	mov	r0, r9
340196ea:	f000 fbdd 	bl	34019ea8 <_Bfree>
340196ee:	2d00      	cmp	r5, #0
340196f0:	f000 80a2 	beq.w	34019838 <_dtoa_r+0x560>
340196f4:	f1b8 0f00 	cmp.w	r8, #0
340196f8:	d005      	beq.n	34019706 <_dtoa_r+0x42e>
340196fa:	45a8      	cmp	r8, r5
340196fc:	d003      	beq.n	34019706 <_dtoa_r+0x42e>
340196fe:	4641      	mov	r1, r8
34019700:	4648      	mov	r0, r9
34019702:	f000 fbd1 	bl	34019ea8 <_Bfree>
34019706:	4629      	mov	r1, r5
34019708:	4648      	mov	r0, r9
3401970a:	f000 fbcd 	bl	34019ea8 <_Bfree>
3401970e:	e093      	b.n	34019838 <_dtoa_r+0x560>
34019710:	2202      	movs	r2, #2
34019712:	e76c      	b.n	340195ee <_dtoa_r+0x316>
34019714:	07cc      	lsls	r4, r1, #31
34019716:	d504      	bpl.n	34019722 <_dtoa_r+0x44a>
34019718:	3201      	adds	r2, #1
3401971a:	ed90 6b00 	vldr	d6, [r0]
3401971e:	ee27 7b06 	vmul.f64	d7, d7, d6
34019722:	1049      	asrs	r1, r1, #1
34019724:	3008      	adds	r0, #8
34019726:	e763      	b.n	340195f0 <_dtoa_r+0x318>
34019728:	d022      	beq.n	34019770 <_dtoa_r+0x498>
3401972a:	f1c8 0100 	rsb	r1, r8, #0
3401972e:	4a6d      	ldr	r2, [pc, #436]	@ (340198e4 <_dtoa_r+0x60c>)
34019730:	2400      	movs	r4, #0
34019732:	f001 000f 	and.w	r0, r1, #15
34019736:	1109      	asrs	r1, r1, #4
34019738:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
3401973c:	486a      	ldr	r0, [pc, #424]	@ (340198e8 <_dtoa_r+0x610>)
3401973e:	ed92 7b00 	vldr	d7, [r2]
34019742:	2202      	movs	r2, #2
34019744:	ee28 7b07 	vmul.f64	d7, d8, d7
34019748:	ed8d 7b02 	vstr	d7, [sp, #8]
3401974c:	b929      	cbnz	r1, 3401975a <_dtoa_r+0x482>
3401974e:	2c00      	cmp	r4, #0
34019750:	f43f af57 	beq.w	34019602 <_dtoa_r+0x32a>
34019754:	ed8d 7b02 	vstr	d7, [sp, #8]
34019758:	e753      	b.n	34019602 <_dtoa_r+0x32a>
3401975a:	07ce      	lsls	r6, r1, #31
3401975c:	d505      	bpl.n	3401976a <_dtoa_r+0x492>
3401975e:	3201      	adds	r2, #1
34019760:	2401      	movs	r4, #1
34019762:	ed90 6b00 	vldr	d6, [r0]
34019766:	ee27 7b06 	vmul.f64	d7, d7, d6
3401976a:	1049      	asrs	r1, r1, #1
3401976c:	3008      	adds	r0, #8
3401976e:	e7ed      	b.n	3401974c <_dtoa_r+0x474>
34019770:	2202      	movs	r2, #2
34019772:	e746      	b.n	34019602 <_dtoa_r+0x32a>
34019774:	4654      	mov	r4, sl
34019776:	f8cd 8014 	str.w	r8, [sp, #20]
3401977a:	e762      	b.n	34019642 <_dtoa_r+0x36a>
3401977c:	4a59      	ldr	r2, [pc, #356]	@ (340198e4 <_dtoa_r+0x60c>)
3401977e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
34019782:	443c      	add	r4, r7
34019784:	ed12 4b02 	vldr	d4, [r2, #-8]
34019788:	9a08      	ldr	r2, [sp, #32]
3401978a:	ec41 0b17 	vmov	d7, r0, r1
3401978e:	b34a      	cbz	r2, 340197e4 <_dtoa_r+0x50c>
34019790:	eeb6 3b00 	vmov.f64	d3, #96	@ 0x3f000000  0.5
34019794:	463e      	mov	r6, r7
34019796:	eeb7 2b00 	vmov.f64	d2, #112	@ 0x3f800000  1.0
3401979a:	ee83 5b04 	vdiv.f64	d5, d3, d4
3401979e:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
340197a2:	ee35 7b47 	vsub.f64	d7, d5, d7
340197a6:	eefd 4bc6 	vcvt.s32.f64	s9, d6
340197aa:	eeb8 5be4 	vcvt.f64.s32	d5, s9
340197ae:	ee14 2a90 	vmov	r2, s9
340197b2:	3230      	adds	r2, #48	@ 0x30
340197b4:	ee36 6b45 	vsub.f64	d6, d6, d5
340197b8:	f806 2b01 	strb.w	r2, [r6], #1
340197bc:	eeb4 6bc7 	vcmpe.f64	d6, d7
340197c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340197c4:	d438      	bmi.n	34019838 <_dtoa_r+0x560>
340197c6:	ee32 5b46 	vsub.f64	d5, d2, d6
340197ca:	eeb4 5bc7 	vcmpe.f64	d5, d7
340197ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340197d2:	d46e      	bmi.n	340198b2 <_dtoa_r+0x5da>
340197d4:	42a6      	cmp	r6, r4
340197d6:	f43f af5a 	beq.w	3401968e <_dtoa_r+0x3b6>
340197da:	ee27 7b03 	vmul.f64	d7, d7, d3
340197de:	ee26 6b03 	vmul.f64	d6, d6, d3
340197e2:	e7e0      	b.n	340197a6 <_dtoa_r+0x4ce>
340197e4:	ee27 7b04 	vmul.f64	d7, d7, d4
340197e8:	4621      	mov	r1, r4
340197ea:	463e      	mov	r6, r7
340197ec:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
340197f0:	eefd 4bc6 	vcvt.s32.f64	s9, d6
340197f4:	ee14 2a90 	vmov	r2, s9
340197f8:	eeb8 5be4 	vcvt.f64.s32	d5, s9
340197fc:	3230      	adds	r2, #48	@ 0x30
340197fe:	ee36 6b45 	vsub.f64	d6, d6, d5
34019802:	f806 2b01 	strb.w	r2, [r6], #1
34019806:	42a6      	cmp	r6, r4
34019808:	d119      	bne.n	3401983e <_dtoa_r+0x566>
3401980a:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
3401980e:	ee37 4b05 	vadd.f64	d4, d7, d5
34019812:	eeb4 6bc4 	vcmpe.f64	d6, d4
34019816:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401981a:	dc4a      	bgt.n	340198b2 <_dtoa_r+0x5da>
3401981c:	ee35 5b47 	vsub.f64	d5, d5, d7
34019820:	eeb4 6bc5 	vcmpe.f64	d6, d5
34019824:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019828:	f57f af31 	bpl.w	3401968e <_dtoa_r+0x3b6>
3401982c:	460e      	mov	r6, r1
3401982e:	3901      	subs	r1, #1
34019830:	f816 3c01 	ldrb.w	r3, [r6, #-1]
34019834:	2b30      	cmp	r3, #48	@ 0x30
34019836:	d0f9      	beq.n	3401982c <_dtoa_r+0x554>
34019838:	f8dd 8014 	ldr.w	r8, [sp, #20]
3401983c:	e027      	b.n	3401988e <_dtoa_r+0x5b6>
3401983e:	ee26 6b03 	vmul.f64	d6, d6, d3
34019842:	e7d5      	b.n	340197f0 <_dtoa_r+0x518>
34019844:	ed9d 7b02 	vldr	d7, [sp, #8]
34019848:	eeb2 4b04 	vmov.f64	d4, #36	@ 0x41200000  10.0
3401984c:	463e      	mov	r6, r7
3401984e:	ee87 5b06 	vdiv.f64	d5, d7, d6
34019852:	eebd 5bc5 	vcvt.s32.f64	s10, d5
34019856:	ee15 3a10 	vmov	r3, s10
3401985a:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
3401985e:	3330      	adds	r3, #48	@ 0x30
34019860:	eea3 7b46 	vfms.f64	d7, d3, d6
34019864:	f806 3b01 	strb.w	r3, [r6], #1
34019868:	1bf3      	subs	r3, r6, r7
3401986a:	459a      	cmp	sl, r3
3401986c:	d132      	bne.n	340198d4 <_dtoa_r+0x5fc>
3401986e:	ee37 7b07 	vadd.f64	d7, d7, d7
34019872:	eeb4 7bc6 	vcmpe.f64	d7, d6
34019876:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401987a:	dc18      	bgt.n	340198ae <_dtoa_r+0x5d6>
3401987c:	eeb4 7b46 	vcmp.f64	d7, d6
34019880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34019884:	d103      	bne.n	3401988e <_dtoa_r+0x5b6>
34019886:	ee15 3a10 	vmov	r3, s10
3401988a:	07db      	lsls	r3, r3, #31
3401988c:	d40f      	bmi.n	340198ae <_dtoa_r+0x5d6>
3401988e:	9901      	ldr	r1, [sp, #4]
34019890:	4648      	mov	r0, r9
34019892:	f000 fb09 	bl	34019ea8 <_Bfree>
34019896:	2300      	movs	r3, #0
34019898:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3401989a:	7033      	strb	r3, [r6, #0]
3401989c:	f108 0301 	add.w	r3, r8, #1
340198a0:	6013      	str	r3, [r2, #0]
340198a2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
340198a4:	2b00      	cmp	r3, #0
340198a6:	f000 824b 	beq.w	34019d40 <_dtoa_r+0xa68>
340198aa:	601e      	str	r6, [r3, #0]
340198ac:	e248      	b.n	34019d40 <_dtoa_r+0xa68>
340198ae:	f8cd 8014 	str.w	r8, [sp, #20]
340198b2:	4633      	mov	r3, r6
340198b4:	461e      	mov	r6, r3
340198b6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
340198ba:	2a39      	cmp	r2, #57	@ 0x39
340198bc:	d106      	bne.n	340198cc <_dtoa_r+0x5f4>
340198be:	429f      	cmp	r7, r3
340198c0:	d1f8      	bne.n	340198b4 <_dtoa_r+0x5dc>
340198c2:	9a05      	ldr	r2, [sp, #20]
340198c4:	3201      	adds	r2, #1
340198c6:	9205      	str	r2, [sp, #20]
340198c8:	2230      	movs	r2, #48	@ 0x30
340198ca:	703a      	strb	r2, [r7, #0]
340198cc:	781a      	ldrb	r2, [r3, #0]
340198ce:	3201      	adds	r2, #1
340198d0:	701a      	strb	r2, [r3, #0]
340198d2:	e7b1      	b.n	34019838 <_dtoa_r+0x560>
340198d4:	ee27 7b04 	vmul.f64	d7, d7, d4
340198d8:	eeb5 7b40 	vcmp.f64	d7, #0.0
340198dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340198e0:	d1b5      	bne.n	3401984e <_dtoa_r+0x576>
340198e2:	e7d4      	b.n	3401988e <_dtoa_r+0x5b6>
340198e4:	3403c7b8 	.word	0x3403c7b8
340198e8:	3403c790 	.word	0x3403c790
340198ec:	9908      	ldr	r1, [sp, #32]
340198ee:	2900      	cmp	r1, #0
340198f0:	f000 80e9 	beq.w	34019ac6 <_dtoa_r+0x7ee>
340198f4:	9907      	ldr	r1, [sp, #28]
340198f6:	2901      	cmp	r1, #1
340198f8:	f300 80cb 	bgt.w	34019a92 <_dtoa_r+0x7ba>
340198fc:	2d00      	cmp	r5, #0
340198fe:	f000 80c4 	beq.w	34019a8a <_dtoa_r+0x7b2>
34019902:	f202 4233 	addw	r2, r2, #1075	@ 0x433
34019906:	461c      	mov	r4, r3
34019908:	9e04      	ldr	r6, [sp, #16]
3401990a:	9305      	str	r3, [sp, #20]
3401990c:	2101      	movs	r1, #1
3401990e:	9b04      	ldr	r3, [sp, #16]
34019910:	4648      	mov	r0, r9
34019912:	4413      	add	r3, r2
34019914:	9304      	str	r3, [sp, #16]
34019916:	9b06      	ldr	r3, [sp, #24]
34019918:	4413      	add	r3, r2
3401991a:	9306      	str	r3, [sp, #24]
3401991c:	f000 fb7a 	bl	3401a014 <__i2b>
34019920:	9b05      	ldr	r3, [sp, #20]
34019922:	4605      	mov	r5, r0
34019924:	b166      	cbz	r6, 34019940 <_dtoa_r+0x668>
34019926:	9a06      	ldr	r2, [sp, #24]
34019928:	2a00      	cmp	r2, #0
3401992a:	dd09      	ble.n	34019940 <_dtoa_r+0x668>
3401992c:	42b2      	cmp	r2, r6
3401992e:	9904      	ldr	r1, [sp, #16]
34019930:	bfa8      	it	ge
34019932:	4632      	movge	r2, r6
34019934:	1a89      	subs	r1, r1, r2
34019936:	1ab6      	subs	r6, r6, r2
34019938:	9104      	str	r1, [sp, #16]
3401993a:	9906      	ldr	r1, [sp, #24]
3401993c:	1a8a      	subs	r2, r1, r2
3401993e:	9206      	str	r2, [sp, #24]
34019940:	b30b      	cbz	r3, 34019986 <_dtoa_r+0x6ae>
34019942:	9a08      	ldr	r2, [sp, #32]
34019944:	2a00      	cmp	r2, #0
34019946:	f000 80c5 	beq.w	34019ad4 <_dtoa_r+0x7fc>
3401994a:	2c00      	cmp	r4, #0
3401994c:	f000 80bf 	beq.w	34019ace <_dtoa_r+0x7f6>
34019950:	4629      	mov	r1, r5
34019952:	4622      	mov	r2, r4
34019954:	4648      	mov	r0, r9
34019956:	930b      	str	r3, [sp, #44]	@ 0x2c
34019958:	f000 fc16 	bl	3401a188 <__pow5mult>
3401995c:	9a01      	ldr	r2, [sp, #4]
3401995e:	4601      	mov	r1, r0
34019960:	4605      	mov	r5, r0
34019962:	4648      	mov	r0, r9
34019964:	f000 fb6c 	bl	3401a040 <__multiply>
34019968:	9901      	ldr	r1, [sp, #4]
3401996a:	9005      	str	r0, [sp, #20]
3401996c:	4648      	mov	r0, r9
3401996e:	f000 fa9b 	bl	34019ea8 <_Bfree>
34019972:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34019974:	1b1b      	subs	r3, r3, r4
34019976:	f000 80b0 	beq.w	34019ada <_dtoa_r+0x802>
3401997a:	461a      	mov	r2, r3
3401997c:	9905      	ldr	r1, [sp, #20]
3401997e:	4648      	mov	r0, r9
34019980:	f000 fc02 	bl	3401a188 <__pow5mult>
34019984:	9001      	str	r0, [sp, #4]
34019986:	2101      	movs	r1, #1
34019988:	4648      	mov	r0, r9
3401998a:	f000 fb43 	bl	3401a014 <__i2b>
3401998e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34019990:	4604      	mov	r4, r0
34019992:	2b00      	cmp	r3, #0
34019994:	f000 81da 	beq.w	34019d4c <_dtoa_r+0xa74>
34019998:	461a      	mov	r2, r3
3401999a:	4601      	mov	r1, r0
3401999c:	4648      	mov	r0, r9
3401999e:	f000 fbf3 	bl	3401a188 <__pow5mult>
340199a2:	9b07      	ldr	r3, [sp, #28]
340199a4:	4604      	mov	r4, r0
340199a6:	2b01      	cmp	r3, #1
340199a8:	f300 80a0 	bgt.w	34019aec <_dtoa_r+0x814>
340199ac:	9b02      	ldr	r3, [sp, #8]
340199ae:	2b00      	cmp	r3, #0
340199b0:	f040 8096 	bne.w	34019ae0 <_dtoa_r+0x808>
340199b4:	9b03      	ldr	r3, [sp, #12]
340199b6:	f3c3 0213 	ubfx	r2, r3, #0, #20
340199ba:	2a00      	cmp	r2, #0
340199bc:	f040 8092 	bne.w	34019ae4 <_dtoa_r+0x80c>
340199c0:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
340199c4:	0d12      	lsrs	r2, r2, #20
340199c6:	0512      	lsls	r2, r2, #20
340199c8:	2a00      	cmp	r2, #0
340199ca:	f000 808d 	beq.w	34019ae8 <_dtoa_r+0x810>
340199ce:	9b04      	ldr	r3, [sp, #16]
340199d0:	3301      	adds	r3, #1
340199d2:	9304      	str	r3, [sp, #16]
340199d4:	9b06      	ldr	r3, [sp, #24]
340199d6:	3301      	adds	r3, #1
340199d8:	9306      	str	r3, [sp, #24]
340199da:	2301      	movs	r3, #1
340199dc:	930b      	str	r3, [sp, #44]	@ 0x2c
340199de:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
340199e0:	2b00      	cmp	r3, #0
340199e2:	f000 81b9 	beq.w	34019d58 <_dtoa_r+0xa80>
340199e6:	6922      	ldr	r2, [r4, #16]
340199e8:	eb04 0282 	add.w	r2, r4, r2, lsl #2
340199ec:	6910      	ldr	r0, [r2, #16]
340199ee:	f000 fac5 	bl	34019f7c <__hi0bits>
340199f2:	f1c0 0020 	rsb	r0, r0, #32
340199f6:	9b06      	ldr	r3, [sp, #24]
340199f8:	4418      	add	r0, r3
340199fa:	f010 001f 	ands.w	r0, r0, #31
340199fe:	f000 8081 	beq.w	34019b04 <_dtoa_r+0x82c>
34019a02:	f1c0 0220 	rsb	r2, r0, #32
34019a06:	2a04      	cmp	r2, #4
34019a08:	dd73      	ble.n	34019af2 <_dtoa_r+0x81a>
34019a0a:	f1c0 001c 	rsb	r0, r0, #28
34019a0e:	9b04      	ldr	r3, [sp, #16]
34019a10:	4403      	add	r3, r0
34019a12:	4406      	add	r6, r0
34019a14:	9304      	str	r3, [sp, #16]
34019a16:	9b06      	ldr	r3, [sp, #24]
34019a18:	4403      	add	r3, r0
34019a1a:	9306      	str	r3, [sp, #24]
34019a1c:	9b04      	ldr	r3, [sp, #16]
34019a1e:	2b00      	cmp	r3, #0
34019a20:	dd05      	ble.n	34019a2e <_dtoa_r+0x756>
34019a22:	461a      	mov	r2, r3
34019a24:	9901      	ldr	r1, [sp, #4]
34019a26:	4648      	mov	r0, r9
34019a28:	f000 fc08 	bl	3401a23c <__lshift>
34019a2c:	9001      	str	r0, [sp, #4]
34019a2e:	9b06      	ldr	r3, [sp, #24]
34019a30:	2b00      	cmp	r3, #0
34019a32:	dd05      	ble.n	34019a40 <_dtoa_r+0x768>
34019a34:	4621      	mov	r1, r4
34019a36:	461a      	mov	r2, r3
34019a38:	4648      	mov	r0, r9
34019a3a:	f000 fbff 	bl	3401a23c <__lshift>
34019a3e:	4604      	mov	r4, r0
34019a40:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
34019a42:	2b00      	cmp	r3, #0
34019a44:	d060      	beq.n	34019b08 <_dtoa_r+0x830>
34019a46:	4621      	mov	r1, r4
34019a48:	9801      	ldr	r0, [sp, #4]
34019a4a:	f000 fc63 	bl	3401a314 <__mcmp>
34019a4e:	2800      	cmp	r0, #0
34019a50:	da5a      	bge.n	34019b08 <_dtoa_r+0x830>
34019a52:	f108 33ff 	add.w	r3, r8, #4294967295
34019a56:	220a      	movs	r2, #10
34019a58:	9901      	ldr	r1, [sp, #4]
34019a5a:	4648      	mov	r0, r9
34019a5c:	9305      	str	r3, [sp, #20]
34019a5e:	2300      	movs	r3, #0
34019a60:	f000 fa44 	bl	34019eec <__multadd>
34019a64:	9b08      	ldr	r3, [sp, #32]
34019a66:	9001      	str	r0, [sp, #4]
34019a68:	2b00      	cmp	r3, #0
34019a6a:	f000 8177 	beq.w	34019d5c <_dtoa_r+0xa84>
34019a6e:	4629      	mov	r1, r5
34019a70:	2300      	movs	r3, #0
34019a72:	220a      	movs	r2, #10
34019a74:	4648      	mov	r0, r9
34019a76:	f000 fa39 	bl	34019eec <__multadd>
34019a7a:	f1bb 0f00 	cmp.w	fp, #0
34019a7e:	4605      	mov	r5, r0
34019a80:	dc6e      	bgt.n	34019b60 <_dtoa_r+0x888>
34019a82:	9b07      	ldr	r3, [sp, #28]
34019a84:	2b02      	cmp	r3, #2
34019a86:	dc48      	bgt.n	34019b1a <_dtoa_r+0x842>
34019a88:	e06a      	b.n	34019b60 <_dtoa_r+0x888>
34019a8a:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
34019a8c:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
34019a90:	e739      	b.n	34019906 <_dtoa_r+0x62e>
34019a92:	f10a 34ff 	add.w	r4, sl, #4294967295
34019a96:	42a3      	cmp	r3, r4
34019a98:	db07      	blt.n	34019aaa <_dtoa_r+0x7d2>
34019a9a:	f1ba 0f00 	cmp.w	sl, #0
34019a9e:	eba3 0404 	sub.w	r4, r3, r4
34019aa2:	db0b      	blt.n	34019abc <_dtoa_r+0x7e4>
34019aa4:	9e04      	ldr	r6, [sp, #16]
34019aa6:	4652      	mov	r2, sl
34019aa8:	e72f      	b.n	3401990a <_dtoa_r+0x632>
34019aaa:	1ae2      	subs	r2, r4, r3
34019aac:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34019aae:	9e04      	ldr	r6, [sp, #16]
34019ab0:	4413      	add	r3, r2
34019ab2:	4652      	mov	r2, sl
34019ab4:	930a      	str	r3, [sp, #40]	@ 0x28
34019ab6:	4623      	mov	r3, r4
34019ab8:	2400      	movs	r4, #0
34019aba:	e726      	b.n	3401990a <_dtoa_r+0x632>
34019abc:	9a04      	ldr	r2, [sp, #16]
34019abe:	eba2 060a 	sub.w	r6, r2, sl
34019ac2:	2200      	movs	r2, #0
34019ac4:	e721      	b.n	3401990a <_dtoa_r+0x632>
34019ac6:	461c      	mov	r4, r3
34019ac8:	9e04      	ldr	r6, [sp, #16]
34019aca:	9d08      	ldr	r5, [sp, #32]
34019acc:	e72a      	b.n	34019924 <_dtoa_r+0x64c>
34019ace:	9a01      	ldr	r2, [sp, #4]
34019ad0:	9205      	str	r2, [sp, #20]
34019ad2:	e752      	b.n	3401997a <_dtoa_r+0x6a2>
34019ad4:	461a      	mov	r2, r3
34019ad6:	9901      	ldr	r1, [sp, #4]
34019ad8:	e751      	b.n	3401997e <_dtoa_r+0x6a6>
34019ada:	9b05      	ldr	r3, [sp, #20]
34019adc:	9301      	str	r3, [sp, #4]
34019ade:	e752      	b.n	34019986 <_dtoa_r+0x6ae>
34019ae0:	2300      	movs	r3, #0
34019ae2:	e77b      	b.n	340199dc <_dtoa_r+0x704>
34019ae4:	9b02      	ldr	r3, [sp, #8]
34019ae6:	e779      	b.n	340199dc <_dtoa_r+0x704>
34019ae8:	920b      	str	r2, [sp, #44]	@ 0x2c
34019aea:	e778      	b.n	340199de <_dtoa_r+0x706>
34019aec:	2300      	movs	r3, #0
34019aee:	930b      	str	r3, [sp, #44]	@ 0x2c
34019af0:	e779      	b.n	340199e6 <_dtoa_r+0x70e>
34019af2:	d093      	beq.n	34019a1c <_dtoa_r+0x744>
34019af4:	321c      	adds	r2, #28
34019af6:	9b04      	ldr	r3, [sp, #16]
34019af8:	4413      	add	r3, r2
34019afa:	4416      	add	r6, r2
34019afc:	9304      	str	r3, [sp, #16]
34019afe:	9b06      	ldr	r3, [sp, #24]
34019b00:	4413      	add	r3, r2
34019b02:	e78a      	b.n	34019a1a <_dtoa_r+0x742>
34019b04:	4602      	mov	r2, r0
34019b06:	e7f5      	b.n	34019af4 <_dtoa_r+0x81c>
34019b08:	f1ba 0f00 	cmp.w	sl, #0
34019b0c:	46d3      	mov	fp, sl
34019b0e:	f8cd 8014 	str.w	r8, [sp, #20]
34019b12:	dc21      	bgt.n	34019b58 <_dtoa_r+0x880>
34019b14:	9b07      	ldr	r3, [sp, #28]
34019b16:	2b02      	cmp	r3, #2
34019b18:	dd1e      	ble.n	34019b58 <_dtoa_r+0x880>
34019b1a:	f1bb 0f00 	cmp.w	fp, #0
34019b1e:	f47f addc 	bne.w	340196da <_dtoa_r+0x402>
34019b22:	4621      	mov	r1, r4
34019b24:	465b      	mov	r3, fp
34019b26:	2205      	movs	r2, #5
34019b28:	4648      	mov	r0, r9
34019b2a:	f000 f9df 	bl	34019eec <__multadd>
34019b2e:	4601      	mov	r1, r0
34019b30:	4604      	mov	r4, r0
34019b32:	9801      	ldr	r0, [sp, #4]
34019b34:	f000 fbee 	bl	3401a314 <__mcmp>
34019b38:	2800      	cmp	r0, #0
34019b3a:	f77f adce 	ble.w	340196da <_dtoa_r+0x402>
34019b3e:	2331      	movs	r3, #49	@ 0x31
34019b40:	463e      	mov	r6, r7
34019b42:	f806 3b01 	strb.w	r3, [r6], #1
34019b46:	9b05      	ldr	r3, [sp, #20]
34019b48:	3301      	adds	r3, #1
34019b4a:	9305      	str	r3, [sp, #20]
34019b4c:	e5c9      	b.n	340196e2 <_dtoa_r+0x40a>
34019b4e:	4654      	mov	r4, sl
34019b50:	f8cd 8014 	str.w	r8, [sp, #20]
34019b54:	4625      	mov	r5, r4
34019b56:	e7f2      	b.n	34019b3e <_dtoa_r+0x866>
34019b58:	9b08      	ldr	r3, [sp, #32]
34019b5a:	2b00      	cmp	r3, #0
34019b5c:	f000 8102 	beq.w	34019d64 <_dtoa_r+0xa8c>
34019b60:	2e00      	cmp	r6, #0
34019b62:	dd05      	ble.n	34019b70 <_dtoa_r+0x898>
34019b64:	4629      	mov	r1, r5
34019b66:	4632      	mov	r2, r6
34019b68:	4648      	mov	r0, r9
34019b6a:	f000 fb67 	bl	3401a23c <__lshift>
34019b6e:	4605      	mov	r5, r0
34019b70:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34019b72:	2b00      	cmp	r3, #0
34019b74:	d058      	beq.n	34019c28 <_dtoa_r+0x950>
34019b76:	6869      	ldr	r1, [r5, #4]
34019b78:	4648      	mov	r0, r9
34019b7a:	f000 f955 	bl	34019e28 <_Balloc>
34019b7e:	4606      	mov	r6, r0
34019b80:	b928      	cbnz	r0, 34019b8e <_dtoa_r+0x8b6>
34019b82:	4b82      	ldr	r3, [pc, #520]	@ (34019d8c <_dtoa_r+0xab4>)
34019b84:	4602      	mov	r2, r0
34019b86:	f240 21ef 	movw	r1, #751	@ 0x2ef
34019b8a:	f7ff bbbe 	b.w	3401930a <_dtoa_r+0x32>
34019b8e:	692a      	ldr	r2, [r5, #16]
34019b90:	f105 010c 	add.w	r1, r5, #12
34019b94:	300c      	adds	r0, #12
34019b96:	3202      	adds	r2, #2
34019b98:	0092      	lsls	r2, r2, #2
34019b9a:	f7ff fafa 	bl	34019192 <memcpy>
34019b9e:	2201      	movs	r2, #1
34019ba0:	4631      	mov	r1, r6
34019ba2:	4648      	mov	r0, r9
34019ba4:	f000 fb4a 	bl	3401a23c <__lshift>
34019ba8:	1c7b      	adds	r3, r7, #1
34019baa:	46a8      	mov	r8, r5
34019bac:	4605      	mov	r5, r0
34019bae:	9304      	str	r3, [sp, #16]
34019bb0:	eb07 030b 	add.w	r3, r7, fp
34019bb4:	9309      	str	r3, [sp, #36]	@ 0x24
34019bb6:	9b02      	ldr	r3, [sp, #8]
34019bb8:	f003 0301 	and.w	r3, r3, #1
34019bbc:	9308      	str	r3, [sp, #32]
34019bbe:	9b04      	ldr	r3, [sp, #16]
34019bc0:	4621      	mov	r1, r4
34019bc2:	9801      	ldr	r0, [sp, #4]
34019bc4:	f103 3bff 	add.w	fp, r3, #4294967295
34019bc8:	f7ff faf7 	bl	340191ba <quorem>
34019bcc:	4641      	mov	r1, r8
34019bce:	9002      	str	r0, [sp, #8]
34019bd0:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
34019bd4:	9801      	ldr	r0, [sp, #4]
34019bd6:	f000 fb9d 	bl	3401a314 <__mcmp>
34019bda:	462a      	mov	r2, r5
34019bdc:	9006      	str	r0, [sp, #24]
34019bde:	4621      	mov	r1, r4
34019be0:	4648      	mov	r0, r9
34019be2:	f000 fbb3 	bl	3401a34c <__mdiff>
34019be6:	68c2      	ldr	r2, [r0, #12]
34019be8:	4606      	mov	r6, r0
34019bea:	b9fa      	cbnz	r2, 34019c2c <_dtoa_r+0x954>
34019bec:	4601      	mov	r1, r0
34019bee:	9801      	ldr	r0, [sp, #4]
34019bf0:	f000 fb90 	bl	3401a314 <__mcmp>
34019bf4:	4602      	mov	r2, r0
34019bf6:	4631      	mov	r1, r6
34019bf8:	4648      	mov	r0, r9
34019bfa:	920a      	str	r2, [sp, #40]	@ 0x28
34019bfc:	f000 f954 	bl	34019ea8 <_Bfree>
34019c00:	9b07      	ldr	r3, [sp, #28]
34019c02:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
34019c04:	9e04      	ldr	r6, [sp, #16]
34019c06:	ea42 0103 	orr.w	r1, r2, r3
34019c0a:	9b08      	ldr	r3, [sp, #32]
34019c0c:	4319      	orrs	r1, r3
34019c0e:	d10f      	bne.n	34019c30 <_dtoa_r+0x958>
34019c10:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34019c14:	d028      	beq.n	34019c68 <_dtoa_r+0x990>
34019c16:	9b06      	ldr	r3, [sp, #24]
34019c18:	2b00      	cmp	r3, #0
34019c1a:	dd02      	ble.n	34019c22 <_dtoa_r+0x94a>
34019c1c:	9b02      	ldr	r3, [sp, #8]
34019c1e:	f103 0a31 	add.w	sl, r3, #49	@ 0x31
34019c22:	f88b a000 	strb.w	sl, [fp]
34019c26:	e55e      	b.n	340196e6 <_dtoa_r+0x40e>
34019c28:	4628      	mov	r0, r5
34019c2a:	e7bd      	b.n	34019ba8 <_dtoa_r+0x8d0>
34019c2c:	2201      	movs	r2, #1
34019c2e:	e7e2      	b.n	34019bf6 <_dtoa_r+0x91e>
34019c30:	9b06      	ldr	r3, [sp, #24]
34019c32:	2b00      	cmp	r3, #0
34019c34:	db04      	blt.n	34019c40 <_dtoa_r+0x968>
34019c36:	9907      	ldr	r1, [sp, #28]
34019c38:	430b      	orrs	r3, r1
34019c3a:	9908      	ldr	r1, [sp, #32]
34019c3c:	430b      	orrs	r3, r1
34019c3e:	d120      	bne.n	34019c82 <_dtoa_r+0x9aa>
34019c40:	2a00      	cmp	r2, #0
34019c42:	ddee      	ble.n	34019c22 <_dtoa_r+0x94a>
34019c44:	2201      	movs	r2, #1
34019c46:	9901      	ldr	r1, [sp, #4]
34019c48:	4648      	mov	r0, r9
34019c4a:	f000 faf7 	bl	3401a23c <__lshift>
34019c4e:	4621      	mov	r1, r4
34019c50:	9001      	str	r0, [sp, #4]
34019c52:	f000 fb5f 	bl	3401a314 <__mcmp>
34019c56:	2800      	cmp	r0, #0
34019c58:	dc03      	bgt.n	34019c62 <_dtoa_r+0x98a>
34019c5a:	d1e2      	bne.n	34019c22 <_dtoa_r+0x94a>
34019c5c:	f01a 0f01 	tst.w	sl, #1
34019c60:	d0df      	beq.n	34019c22 <_dtoa_r+0x94a>
34019c62:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34019c66:	d1d9      	bne.n	34019c1c <_dtoa_r+0x944>
34019c68:	2339      	movs	r3, #57	@ 0x39
34019c6a:	f88b 3000 	strb.w	r3, [fp]
34019c6e:	4633      	mov	r3, r6
34019c70:	461e      	mov	r6, r3
34019c72:	3b01      	subs	r3, #1
34019c74:	f816 2c01 	ldrb.w	r2, [r6, #-1]
34019c78:	2a39      	cmp	r2, #57	@ 0x39
34019c7a:	d052      	beq.n	34019d22 <_dtoa_r+0xa4a>
34019c7c:	3201      	adds	r2, #1
34019c7e:	701a      	strb	r2, [r3, #0]
34019c80:	e531      	b.n	340196e6 <_dtoa_r+0x40e>
34019c82:	2a00      	cmp	r2, #0
34019c84:	dd07      	ble.n	34019c96 <_dtoa_r+0x9be>
34019c86:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34019c8a:	d0ed      	beq.n	34019c68 <_dtoa_r+0x990>
34019c8c:	f10a 0301 	add.w	r3, sl, #1
34019c90:	f88b 3000 	strb.w	r3, [fp]
34019c94:	e527      	b.n	340196e6 <_dtoa_r+0x40e>
34019c96:	9b04      	ldr	r3, [sp, #16]
34019c98:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34019c9a:	f803 ac01 	strb.w	sl, [r3, #-1]
34019c9e:	4293      	cmp	r3, r2
34019ca0:	d029      	beq.n	34019cf6 <_dtoa_r+0xa1e>
34019ca2:	2300      	movs	r3, #0
34019ca4:	220a      	movs	r2, #10
34019ca6:	9901      	ldr	r1, [sp, #4]
34019ca8:	4648      	mov	r0, r9
34019caa:	f000 f91f 	bl	34019eec <__multadd>
34019cae:	45a8      	cmp	r8, r5
34019cb0:	9001      	str	r0, [sp, #4]
34019cb2:	f04f 0300 	mov.w	r3, #0
34019cb6:	f04f 020a 	mov.w	r2, #10
34019cba:	4641      	mov	r1, r8
34019cbc:	4648      	mov	r0, r9
34019cbe:	d107      	bne.n	34019cd0 <_dtoa_r+0x9f8>
34019cc0:	f000 f914 	bl	34019eec <__multadd>
34019cc4:	4680      	mov	r8, r0
34019cc6:	4605      	mov	r5, r0
34019cc8:	9b04      	ldr	r3, [sp, #16]
34019cca:	3301      	adds	r3, #1
34019ccc:	9304      	str	r3, [sp, #16]
34019cce:	e776      	b.n	34019bbe <_dtoa_r+0x8e6>
34019cd0:	f000 f90c 	bl	34019eec <__multadd>
34019cd4:	4629      	mov	r1, r5
34019cd6:	4680      	mov	r8, r0
34019cd8:	2300      	movs	r3, #0
34019cda:	220a      	movs	r2, #10
34019cdc:	4648      	mov	r0, r9
34019cde:	f000 f905 	bl	34019eec <__multadd>
34019ce2:	4605      	mov	r5, r0
34019ce4:	e7f0      	b.n	34019cc8 <_dtoa_r+0x9f0>
34019ce6:	f1bb 0f00 	cmp.w	fp, #0
34019cea:	f04f 0800 	mov.w	r8, #0
34019cee:	bfcc      	ite	gt
34019cf0:	465e      	movgt	r6, fp
34019cf2:	2601      	movle	r6, #1
34019cf4:	443e      	add	r6, r7
34019cf6:	2201      	movs	r2, #1
34019cf8:	9901      	ldr	r1, [sp, #4]
34019cfa:	4648      	mov	r0, r9
34019cfc:	f000 fa9e 	bl	3401a23c <__lshift>
34019d00:	4621      	mov	r1, r4
34019d02:	9001      	str	r0, [sp, #4]
34019d04:	f000 fb06 	bl	3401a314 <__mcmp>
34019d08:	2800      	cmp	r0, #0
34019d0a:	dcb0      	bgt.n	34019c6e <_dtoa_r+0x996>
34019d0c:	d102      	bne.n	34019d14 <_dtoa_r+0xa3c>
34019d0e:	f01a 0f01 	tst.w	sl, #1
34019d12:	d1ac      	bne.n	34019c6e <_dtoa_r+0x996>
34019d14:	4633      	mov	r3, r6
34019d16:	461e      	mov	r6, r3
34019d18:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
34019d1c:	2a30      	cmp	r2, #48	@ 0x30
34019d1e:	d0fa      	beq.n	34019d16 <_dtoa_r+0xa3e>
34019d20:	e4e1      	b.n	340196e6 <_dtoa_r+0x40e>
34019d22:	429f      	cmp	r7, r3
34019d24:	d1a4      	bne.n	34019c70 <_dtoa_r+0x998>
34019d26:	9b05      	ldr	r3, [sp, #20]
34019d28:	3301      	adds	r3, #1
34019d2a:	9305      	str	r3, [sp, #20]
34019d2c:	2331      	movs	r3, #49	@ 0x31
34019d2e:	703b      	strb	r3, [r7, #0]
34019d30:	e4d9      	b.n	340196e6 <_dtoa_r+0x40e>
34019d32:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34019d34:	4f16      	ldr	r7, [pc, #88]	@ (34019d90 <_dtoa_r+0xab8>)
34019d36:	b11b      	cbz	r3, 34019d40 <_dtoa_r+0xa68>
34019d38:	f107 0308 	add.w	r3, r7, #8
34019d3c:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
34019d3e:	6013      	str	r3, [r2, #0]
34019d40:	4638      	mov	r0, r7
34019d42:	b011      	add	sp, #68	@ 0x44
34019d44:	ecbd 8b02 	vpop	{d8}
34019d48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34019d4c:	9b07      	ldr	r3, [sp, #28]
34019d4e:	2b01      	cmp	r3, #1
34019d50:	f77f ae2c 	ble.w	340199ac <_dtoa_r+0x6d4>
34019d54:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34019d56:	930b      	str	r3, [sp, #44]	@ 0x2c
34019d58:	2001      	movs	r0, #1
34019d5a:	e64c      	b.n	340199f6 <_dtoa_r+0x71e>
34019d5c:	f1bb 0f00 	cmp.w	fp, #0
34019d60:	f77f aed8 	ble.w	34019b14 <_dtoa_r+0x83c>
34019d64:	463e      	mov	r6, r7
34019d66:	4621      	mov	r1, r4
34019d68:	9801      	ldr	r0, [sp, #4]
34019d6a:	f7ff fa26 	bl	340191ba <quorem>
34019d6e:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
34019d72:	f806 ab01 	strb.w	sl, [r6], #1
34019d76:	1bf2      	subs	r2, r6, r7
34019d78:	4593      	cmp	fp, r2
34019d7a:	ddb4      	ble.n	34019ce6 <_dtoa_r+0xa0e>
34019d7c:	2300      	movs	r3, #0
34019d7e:	220a      	movs	r2, #10
34019d80:	9901      	ldr	r1, [sp, #4]
34019d82:	4648      	mov	r0, r9
34019d84:	f000 f8b2 	bl	34019eec <__multadd>
34019d88:	9001      	str	r0, [sp, #4]
34019d8a:	e7ec      	b.n	34019d66 <_dtoa_r+0xa8e>
34019d8c:	3401e7d3 	.word	0x3401e7d3
34019d90:	3401e757 	.word	0x3401e757

34019d94 <_free_r>:
34019d94:	b538      	push	{r3, r4, r5, lr}
34019d96:	4605      	mov	r5, r0
34019d98:	2900      	cmp	r1, #0
34019d9a:	d041      	beq.n	34019e20 <_free_r+0x8c>
34019d9c:	f851 3c04 	ldr.w	r3, [r1, #-4]
34019da0:	1f0c      	subs	r4, r1, #4
34019da2:	2b00      	cmp	r3, #0
34019da4:	bfb8      	it	lt
34019da6:	18e4      	addlt	r4, r4, r3
34019da8:	f7fd fec2 	bl	34017b30 <__malloc_lock>
34019dac:	4a1d      	ldr	r2, [pc, #116]	@ (34019e24 <_free_r+0x90>)
34019dae:	6813      	ldr	r3, [r2, #0]
34019db0:	b933      	cbnz	r3, 34019dc0 <_free_r+0x2c>
34019db2:	6063      	str	r3, [r4, #4]
34019db4:	6014      	str	r4, [r2, #0]
34019db6:	4628      	mov	r0, r5
34019db8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
34019dbc:	f7fd bebe 	b.w	34017b3c <__malloc_unlock>
34019dc0:	42a3      	cmp	r3, r4
34019dc2:	d908      	bls.n	34019dd6 <_free_r+0x42>
34019dc4:	6820      	ldr	r0, [r4, #0]
34019dc6:	1821      	adds	r1, r4, r0
34019dc8:	428b      	cmp	r3, r1
34019dca:	bf01      	itttt	eq
34019dcc:	6819      	ldreq	r1, [r3, #0]
34019dce:	685b      	ldreq	r3, [r3, #4]
34019dd0:	1809      	addeq	r1, r1, r0
34019dd2:	6021      	streq	r1, [r4, #0]
34019dd4:	e7ed      	b.n	34019db2 <_free_r+0x1e>
34019dd6:	461a      	mov	r2, r3
34019dd8:	685b      	ldr	r3, [r3, #4]
34019dda:	b10b      	cbz	r3, 34019de0 <_free_r+0x4c>
34019ddc:	42a3      	cmp	r3, r4
34019dde:	d9fa      	bls.n	34019dd6 <_free_r+0x42>
34019de0:	6811      	ldr	r1, [r2, #0]
34019de2:	1850      	adds	r0, r2, r1
34019de4:	42a0      	cmp	r0, r4
34019de6:	d10b      	bne.n	34019e00 <_free_r+0x6c>
34019de8:	6820      	ldr	r0, [r4, #0]
34019dea:	4401      	add	r1, r0
34019dec:	1850      	adds	r0, r2, r1
34019dee:	6011      	str	r1, [r2, #0]
34019df0:	4283      	cmp	r3, r0
34019df2:	d1e0      	bne.n	34019db6 <_free_r+0x22>
34019df4:	6818      	ldr	r0, [r3, #0]
34019df6:	685b      	ldr	r3, [r3, #4]
34019df8:	4408      	add	r0, r1
34019dfa:	6053      	str	r3, [r2, #4]
34019dfc:	6010      	str	r0, [r2, #0]
34019dfe:	e7da      	b.n	34019db6 <_free_r+0x22>
34019e00:	d902      	bls.n	34019e08 <_free_r+0x74>
34019e02:	230c      	movs	r3, #12
34019e04:	602b      	str	r3, [r5, #0]
34019e06:	e7d6      	b.n	34019db6 <_free_r+0x22>
34019e08:	6820      	ldr	r0, [r4, #0]
34019e0a:	1821      	adds	r1, r4, r0
34019e0c:	428b      	cmp	r3, r1
34019e0e:	bf02      	ittt	eq
34019e10:	6819      	ldreq	r1, [r3, #0]
34019e12:	685b      	ldreq	r3, [r3, #4]
34019e14:	1809      	addeq	r1, r1, r0
34019e16:	6063      	str	r3, [r4, #4]
34019e18:	bf08      	it	eq
34019e1a:	6021      	streq	r1, [r4, #0]
34019e1c:	6054      	str	r4, [r2, #4]
34019e1e:	e7ca      	b.n	34019db6 <_free_r+0x22>
34019e20:	bd38      	pop	{r3, r4, r5, pc}
34019e22:	bf00      	nop
34019e24:	340581e0 	.word	0x340581e0

34019e28 <_Balloc>:
34019e28:	b570      	push	{r4, r5, r6, lr}
34019e2a:	69c6      	ldr	r6, [r0, #28]
34019e2c:	4604      	mov	r4, r0
34019e2e:	460d      	mov	r5, r1
34019e30:	b976      	cbnz	r6, 34019e50 <_Balloc+0x28>
34019e32:	2010      	movs	r0, #16
34019e34:	f7fd fdd2 	bl	340179dc <malloc>
34019e38:	4602      	mov	r2, r0
34019e3a:	61e0      	str	r0, [r4, #28]
34019e3c:	b920      	cbnz	r0, 34019e48 <_Balloc+0x20>
34019e3e:	4b18      	ldr	r3, [pc, #96]	@ (34019ea0 <_Balloc+0x78>)
34019e40:	216b      	movs	r1, #107	@ 0x6b
34019e42:	4818      	ldr	r0, [pc, #96]	@ (34019ea4 <_Balloc+0x7c>)
34019e44:	f7fd fdac 	bl	340179a0 <__assert_func>
34019e48:	e9c0 6601 	strd	r6, r6, [r0, #4]
34019e4c:	6006      	str	r6, [r0, #0]
34019e4e:	60c6      	str	r6, [r0, #12]
34019e50:	69e6      	ldr	r6, [r4, #28]
34019e52:	68f3      	ldr	r3, [r6, #12]
34019e54:	b183      	cbz	r3, 34019e78 <_Balloc+0x50>
34019e56:	69e3      	ldr	r3, [r4, #28]
34019e58:	68db      	ldr	r3, [r3, #12]
34019e5a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
34019e5e:	b9b8      	cbnz	r0, 34019e90 <_Balloc+0x68>
34019e60:	2101      	movs	r1, #1
34019e62:	4620      	mov	r0, r4
34019e64:	fa01 f605 	lsl.w	r6, r1, r5
34019e68:	1d72      	adds	r2, r6, #5
34019e6a:	0092      	lsls	r2, r2, #2
34019e6c:	f000 ff74 	bl	3401ad58 <_calloc_r>
34019e70:	b160      	cbz	r0, 34019e8c <_Balloc+0x64>
34019e72:	e9c0 5601 	strd	r5, r6, [r0, #4]
34019e76:	e00e      	b.n	34019e96 <_Balloc+0x6e>
34019e78:	2221      	movs	r2, #33	@ 0x21
34019e7a:	2104      	movs	r1, #4
34019e7c:	4620      	mov	r0, r4
34019e7e:	f000 ff6b 	bl	3401ad58 <_calloc_r>
34019e82:	69e3      	ldr	r3, [r4, #28]
34019e84:	60f0      	str	r0, [r6, #12]
34019e86:	68db      	ldr	r3, [r3, #12]
34019e88:	2b00      	cmp	r3, #0
34019e8a:	d1e4      	bne.n	34019e56 <_Balloc+0x2e>
34019e8c:	2000      	movs	r0, #0
34019e8e:	bd70      	pop	{r4, r5, r6, pc}
34019e90:	6802      	ldr	r2, [r0, #0]
34019e92:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
34019e96:	2300      	movs	r3, #0
34019e98:	e9c0 3303 	strd	r3, r3, [r0, #12]
34019e9c:	e7f7      	b.n	34019e8e <_Balloc+0x66>
34019e9e:	bf00      	nop
34019ea0:	3401e764 	.word	0x3401e764
34019ea4:	3401e7e4 	.word	0x3401e7e4

34019ea8 <_Bfree>:
34019ea8:	b570      	push	{r4, r5, r6, lr}
34019eaa:	69c6      	ldr	r6, [r0, #28]
34019eac:	4605      	mov	r5, r0
34019eae:	460c      	mov	r4, r1
34019eb0:	b976      	cbnz	r6, 34019ed0 <_Bfree+0x28>
34019eb2:	2010      	movs	r0, #16
34019eb4:	f7fd fd92 	bl	340179dc <malloc>
34019eb8:	4602      	mov	r2, r0
34019eba:	61e8      	str	r0, [r5, #28]
34019ebc:	b920      	cbnz	r0, 34019ec8 <_Bfree+0x20>
34019ebe:	4b09      	ldr	r3, [pc, #36]	@ (34019ee4 <_Bfree+0x3c>)
34019ec0:	218f      	movs	r1, #143	@ 0x8f
34019ec2:	4809      	ldr	r0, [pc, #36]	@ (34019ee8 <_Bfree+0x40>)
34019ec4:	f7fd fd6c 	bl	340179a0 <__assert_func>
34019ec8:	e9c0 6601 	strd	r6, r6, [r0, #4]
34019ecc:	6006      	str	r6, [r0, #0]
34019ece:	60c6      	str	r6, [r0, #12]
34019ed0:	b13c      	cbz	r4, 34019ee2 <_Bfree+0x3a>
34019ed2:	69eb      	ldr	r3, [r5, #28]
34019ed4:	6862      	ldr	r2, [r4, #4]
34019ed6:	68db      	ldr	r3, [r3, #12]
34019ed8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
34019edc:	6021      	str	r1, [r4, #0]
34019ede:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
34019ee2:	bd70      	pop	{r4, r5, r6, pc}
34019ee4:	3401e764 	.word	0x3401e764
34019ee8:	3401e7e4 	.word	0x3401e7e4

34019eec <__multadd>:
34019eec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34019ef0:	f101 0c14 	add.w	ip, r1, #20
34019ef4:	4607      	mov	r7, r0
34019ef6:	460c      	mov	r4, r1
34019ef8:	461e      	mov	r6, r3
34019efa:	690d      	ldr	r5, [r1, #16]
34019efc:	2000      	movs	r0, #0
34019efe:	f8dc 3000 	ldr.w	r3, [ip]
34019f02:	3001      	adds	r0, #1
34019f04:	b299      	uxth	r1, r3
34019f06:	4285      	cmp	r5, r0
34019f08:	fb02 6101 	mla	r1, r2, r1, r6
34019f0c:	ea4f 4613 	mov.w	r6, r3, lsr #16
34019f10:	ea4f 4311 	mov.w	r3, r1, lsr #16
34019f14:	b289      	uxth	r1, r1
34019f16:	fb02 3306 	mla	r3, r2, r6, r3
34019f1a:	eb01 4103 	add.w	r1, r1, r3, lsl #16
34019f1e:	ea4f 4613 	mov.w	r6, r3, lsr #16
34019f22:	f84c 1b04 	str.w	r1, [ip], #4
34019f26:	dcea      	bgt.n	34019efe <__multadd+0x12>
34019f28:	b30e      	cbz	r6, 34019f6e <__multadd+0x82>
34019f2a:	68a3      	ldr	r3, [r4, #8]
34019f2c:	42ab      	cmp	r3, r5
34019f2e:	dc19      	bgt.n	34019f64 <__multadd+0x78>
34019f30:	6861      	ldr	r1, [r4, #4]
34019f32:	4638      	mov	r0, r7
34019f34:	3101      	adds	r1, #1
34019f36:	f7ff ff77 	bl	34019e28 <_Balloc>
34019f3a:	4680      	mov	r8, r0
34019f3c:	b928      	cbnz	r0, 34019f4a <__multadd+0x5e>
34019f3e:	4602      	mov	r2, r0
34019f40:	4b0c      	ldr	r3, [pc, #48]	@ (34019f74 <__multadd+0x88>)
34019f42:	21ba      	movs	r1, #186	@ 0xba
34019f44:	480c      	ldr	r0, [pc, #48]	@ (34019f78 <__multadd+0x8c>)
34019f46:	f7fd fd2b 	bl	340179a0 <__assert_func>
34019f4a:	6922      	ldr	r2, [r4, #16]
34019f4c:	f104 010c 	add.w	r1, r4, #12
34019f50:	300c      	adds	r0, #12
34019f52:	3202      	adds	r2, #2
34019f54:	0092      	lsls	r2, r2, #2
34019f56:	f7ff f91c 	bl	34019192 <memcpy>
34019f5a:	4621      	mov	r1, r4
34019f5c:	4644      	mov	r4, r8
34019f5e:	4638      	mov	r0, r7
34019f60:	f7ff ffa2 	bl	34019ea8 <_Bfree>
34019f64:	eb04 0385 	add.w	r3, r4, r5, lsl #2
34019f68:	3501      	adds	r5, #1
34019f6a:	615e      	str	r6, [r3, #20]
34019f6c:	6125      	str	r5, [r4, #16]
34019f6e:	4620      	mov	r0, r4
34019f70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34019f74:	3401e7d3 	.word	0x3401e7d3
34019f78:	3401e7e4 	.word	0x3401e7e4

34019f7c <__hi0bits>:
34019f7c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
34019f80:	4603      	mov	r3, r0
34019f82:	bf36      	itet	cc
34019f84:	0403      	lslcc	r3, r0, #16
34019f86:	2000      	movcs	r0, #0
34019f88:	2010      	movcc	r0, #16
34019f8a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34019f8e:	bf3c      	itt	cc
34019f90:	021b      	lslcc	r3, r3, #8
34019f92:	3008      	addcc	r0, #8
34019f94:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34019f98:	bf3c      	itt	cc
34019f9a:	011b      	lslcc	r3, r3, #4
34019f9c:	3004      	addcc	r0, #4
34019f9e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34019fa2:	bf3c      	itt	cc
34019fa4:	009b      	lslcc	r3, r3, #2
34019fa6:	3002      	addcc	r0, #2
34019fa8:	2b00      	cmp	r3, #0
34019faa:	db05      	blt.n	34019fb8 <__hi0bits+0x3c>
34019fac:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
34019fb0:	f100 0001 	add.w	r0, r0, #1
34019fb4:	bf08      	it	eq
34019fb6:	2020      	moveq	r0, #32
34019fb8:	4770      	bx	lr

34019fba <__lo0bits>:
34019fba:	6803      	ldr	r3, [r0, #0]
34019fbc:	4602      	mov	r2, r0
34019fbe:	f013 0007 	ands.w	r0, r3, #7
34019fc2:	d00b      	beq.n	34019fdc <__lo0bits+0x22>
34019fc4:	07d9      	lsls	r1, r3, #31
34019fc6:	d421      	bmi.n	3401a00c <__lo0bits+0x52>
34019fc8:	0798      	lsls	r0, r3, #30
34019fca:	bf47      	ittee	mi
34019fcc:	085b      	lsrmi	r3, r3, #1
34019fce:	2001      	movmi	r0, #1
34019fd0:	089b      	lsrpl	r3, r3, #2
34019fd2:	2002      	movpl	r0, #2
34019fd4:	bf4c      	ite	mi
34019fd6:	6013      	strmi	r3, [r2, #0]
34019fd8:	6013      	strpl	r3, [r2, #0]
34019fda:	4770      	bx	lr
34019fdc:	b299      	uxth	r1, r3
34019fde:	b909      	cbnz	r1, 34019fe4 <__lo0bits+0x2a>
34019fe0:	0c1b      	lsrs	r3, r3, #16
34019fe2:	2010      	movs	r0, #16
34019fe4:	b2d9      	uxtb	r1, r3
34019fe6:	b909      	cbnz	r1, 34019fec <__lo0bits+0x32>
34019fe8:	3008      	adds	r0, #8
34019fea:	0a1b      	lsrs	r3, r3, #8
34019fec:	0719      	lsls	r1, r3, #28
34019fee:	bf04      	itt	eq
34019ff0:	091b      	lsreq	r3, r3, #4
34019ff2:	3004      	addeq	r0, #4
34019ff4:	0799      	lsls	r1, r3, #30
34019ff6:	bf04      	itt	eq
34019ff8:	089b      	lsreq	r3, r3, #2
34019ffa:	3002      	addeq	r0, #2
34019ffc:	07d9      	lsls	r1, r3, #31
34019ffe:	d403      	bmi.n	3401a008 <__lo0bits+0x4e>
3401a000:	085b      	lsrs	r3, r3, #1
3401a002:	f100 0001 	add.w	r0, r0, #1
3401a006:	d003      	beq.n	3401a010 <__lo0bits+0x56>
3401a008:	6013      	str	r3, [r2, #0]
3401a00a:	4770      	bx	lr
3401a00c:	2000      	movs	r0, #0
3401a00e:	4770      	bx	lr
3401a010:	2020      	movs	r0, #32
3401a012:	4770      	bx	lr

3401a014 <__i2b>:
3401a014:	b510      	push	{r4, lr}
3401a016:	460c      	mov	r4, r1
3401a018:	2101      	movs	r1, #1
3401a01a:	f7ff ff05 	bl	34019e28 <_Balloc>
3401a01e:	4602      	mov	r2, r0
3401a020:	b928      	cbnz	r0, 3401a02e <__i2b+0x1a>
3401a022:	4b05      	ldr	r3, [pc, #20]	@ (3401a038 <__i2b+0x24>)
3401a024:	f240 1145 	movw	r1, #325	@ 0x145
3401a028:	4804      	ldr	r0, [pc, #16]	@ (3401a03c <__i2b+0x28>)
3401a02a:	f7fd fcb9 	bl	340179a0 <__assert_func>
3401a02e:	2301      	movs	r3, #1
3401a030:	6144      	str	r4, [r0, #20]
3401a032:	6103      	str	r3, [r0, #16]
3401a034:	bd10      	pop	{r4, pc}
3401a036:	bf00      	nop
3401a038:	3401e7d3 	.word	0x3401e7d3
3401a03c:	3401e7e4 	.word	0x3401e7e4

3401a040 <__multiply>:
3401a040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a044:	4617      	mov	r7, r2
3401a046:	690a      	ldr	r2, [r1, #16]
3401a048:	4689      	mov	r9, r1
3401a04a:	b085      	sub	sp, #20
3401a04c:	693b      	ldr	r3, [r7, #16]
3401a04e:	429a      	cmp	r2, r3
3401a050:	bfa2      	ittt	ge
3401a052:	463b      	movge	r3, r7
3401a054:	460f      	movge	r7, r1
3401a056:	4699      	movge	r9, r3
3401a058:	693d      	ldr	r5, [r7, #16]
3401a05a:	68bb      	ldr	r3, [r7, #8]
3401a05c:	f8d9 a010 	ldr.w	sl, [r9, #16]
3401a060:	6879      	ldr	r1, [r7, #4]
3401a062:	eb05 060a 	add.w	r6, r5, sl
3401a066:	42b3      	cmp	r3, r6
3401a068:	bfb8      	it	lt
3401a06a:	3101      	addlt	r1, #1
3401a06c:	f7ff fedc 	bl	34019e28 <_Balloc>
3401a070:	b930      	cbnz	r0, 3401a080 <__multiply+0x40>
3401a072:	4602      	mov	r2, r0
3401a074:	4b42      	ldr	r3, [pc, #264]	@ (3401a180 <__multiply+0x140>)
3401a076:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3401a07a:	4842      	ldr	r0, [pc, #264]	@ (3401a184 <__multiply+0x144>)
3401a07c:	f7fd fc90 	bl	340179a0 <__assert_func>
3401a080:	f100 0414 	add.w	r4, r0, #20
3401a084:	2200      	movs	r2, #0
3401a086:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
3401a08a:	4623      	mov	r3, r4
3401a08c:	4573      	cmp	r3, lr
3401a08e:	d320      	bcc.n	3401a0d2 <__multiply+0x92>
3401a090:	f107 0814 	add.w	r8, r7, #20
3401a094:	f109 0114 	add.w	r1, r9, #20
3401a098:	eb08 0585 	add.w	r5, r8, r5, lsl #2
3401a09c:	eb01 038a 	add.w	r3, r1, sl, lsl #2
3401a0a0:	9302      	str	r3, [sp, #8]
3401a0a2:	1beb      	subs	r3, r5, r7
3401a0a4:	3715      	adds	r7, #21
3401a0a6:	3b15      	subs	r3, #21
3401a0a8:	f023 0303 	bic.w	r3, r3, #3
3401a0ac:	3304      	adds	r3, #4
3401a0ae:	42bd      	cmp	r5, r7
3401a0b0:	bf38      	it	cc
3401a0b2:	2304      	movcc	r3, #4
3401a0b4:	9301      	str	r3, [sp, #4]
3401a0b6:	9b02      	ldr	r3, [sp, #8]
3401a0b8:	9103      	str	r1, [sp, #12]
3401a0ba:	428b      	cmp	r3, r1
3401a0bc:	d80c      	bhi.n	3401a0d8 <__multiply+0x98>
3401a0be:	2e00      	cmp	r6, #0
3401a0c0:	dd03      	ble.n	3401a0ca <__multiply+0x8a>
3401a0c2:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
3401a0c6:	2b00      	cmp	r3, #0
3401a0c8:	d057      	beq.n	3401a17a <__multiply+0x13a>
3401a0ca:	6106      	str	r6, [r0, #16]
3401a0cc:	b005      	add	sp, #20
3401a0ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a0d2:	f843 2b04 	str.w	r2, [r3], #4
3401a0d6:	e7d9      	b.n	3401a08c <__multiply+0x4c>
3401a0d8:	f8b1 a000 	ldrh.w	sl, [r1]
3401a0dc:	f1ba 0f00 	cmp.w	sl, #0
3401a0e0:	d021      	beq.n	3401a126 <__multiply+0xe6>
3401a0e2:	46c4      	mov	ip, r8
3401a0e4:	46a1      	mov	r9, r4
3401a0e6:	2700      	movs	r7, #0
3401a0e8:	f85c 2b04 	ldr.w	r2, [ip], #4
3401a0ec:	f8d9 3000 	ldr.w	r3, [r9]
3401a0f0:	fa1f fb82 	uxth.w	fp, r2
3401a0f4:	4565      	cmp	r5, ip
3401a0f6:	b29b      	uxth	r3, r3
3401a0f8:	ea4f 4212 	mov.w	r2, r2, lsr #16
3401a0fc:	fb0a 330b 	mla	r3, sl, fp, r3
3401a100:	443b      	add	r3, r7
3401a102:	f8d9 7000 	ldr.w	r7, [r9]
3401a106:	ea4f 4717 	mov.w	r7, r7, lsr #16
3401a10a:	fb0a 7202 	mla	r2, sl, r2, r7
3401a10e:	eb02 4213 	add.w	r2, r2, r3, lsr #16
3401a112:	b29b      	uxth	r3, r3
3401a114:	ea4f 4712 	mov.w	r7, r2, lsr #16
3401a118:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401a11c:	f849 3b04 	str.w	r3, [r9], #4
3401a120:	d8e2      	bhi.n	3401a0e8 <__multiply+0xa8>
3401a122:	9b01      	ldr	r3, [sp, #4]
3401a124:	50e7      	str	r7, [r4, r3]
3401a126:	9b03      	ldr	r3, [sp, #12]
3401a128:	3104      	adds	r1, #4
3401a12a:	f8b3 9002 	ldrh.w	r9, [r3, #2]
3401a12e:	f1b9 0f00 	cmp.w	r9, #0
3401a132:	d020      	beq.n	3401a176 <__multiply+0x136>
3401a134:	6823      	ldr	r3, [r4, #0]
3401a136:	4647      	mov	r7, r8
3401a138:	46a4      	mov	ip, r4
3401a13a:	f04f 0a00 	mov.w	sl, #0
3401a13e:	f8b7 b000 	ldrh.w	fp, [r7]
3401a142:	b29b      	uxth	r3, r3
3401a144:	f8bc 2002 	ldrh.w	r2, [ip, #2]
3401a148:	fb09 220b 	mla	r2, r9, fp, r2
3401a14c:	4452      	add	r2, sl
3401a14e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3401a152:	f84c 3b04 	str.w	r3, [ip], #4
3401a156:	f857 3b04 	ldr.w	r3, [r7], #4
3401a15a:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401a15e:	f8bc 3000 	ldrh.w	r3, [ip]
3401a162:	42bd      	cmp	r5, r7
3401a164:	fb09 330a 	mla	r3, r9, sl, r3
3401a168:	eb03 4312 	add.w	r3, r3, r2, lsr #16
3401a16c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3401a170:	d8e5      	bhi.n	3401a13e <__multiply+0xfe>
3401a172:	9a01      	ldr	r2, [sp, #4]
3401a174:	50a3      	str	r3, [r4, r2]
3401a176:	3404      	adds	r4, #4
3401a178:	e79d      	b.n	3401a0b6 <__multiply+0x76>
3401a17a:	3e01      	subs	r6, #1
3401a17c:	e79f      	b.n	3401a0be <__multiply+0x7e>
3401a17e:	bf00      	nop
3401a180:	3401e7d3 	.word	0x3401e7d3
3401a184:	3401e7e4 	.word	0x3401e7e4

3401a188 <__pow5mult>:
3401a188:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3401a18c:	4615      	mov	r5, r2
3401a18e:	f012 0203 	ands.w	r2, r2, #3
3401a192:	4607      	mov	r7, r0
3401a194:	460e      	mov	r6, r1
3401a196:	d007      	beq.n	3401a1a8 <__pow5mult+0x20>
3401a198:	3a01      	subs	r2, #1
3401a19a:	4c25      	ldr	r4, [pc, #148]	@ (3401a230 <__pow5mult+0xa8>)
3401a19c:	2300      	movs	r3, #0
3401a19e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
3401a1a2:	f7ff fea3 	bl	34019eec <__multadd>
3401a1a6:	4606      	mov	r6, r0
3401a1a8:	10ad      	asrs	r5, r5, #2
3401a1aa:	d03d      	beq.n	3401a228 <__pow5mult+0xa0>
3401a1ac:	69fc      	ldr	r4, [r7, #28]
3401a1ae:	b97c      	cbnz	r4, 3401a1d0 <__pow5mult+0x48>
3401a1b0:	2010      	movs	r0, #16
3401a1b2:	f7fd fc13 	bl	340179dc <malloc>
3401a1b6:	4602      	mov	r2, r0
3401a1b8:	61f8      	str	r0, [r7, #28]
3401a1ba:	b928      	cbnz	r0, 3401a1c8 <__pow5mult+0x40>
3401a1bc:	4b1d      	ldr	r3, [pc, #116]	@ (3401a234 <__pow5mult+0xac>)
3401a1be:	f240 11b3 	movw	r1, #435	@ 0x1b3
3401a1c2:	481d      	ldr	r0, [pc, #116]	@ (3401a238 <__pow5mult+0xb0>)
3401a1c4:	f7fd fbec 	bl	340179a0 <__assert_func>
3401a1c8:	e9c0 4401 	strd	r4, r4, [r0, #4]
3401a1cc:	6004      	str	r4, [r0, #0]
3401a1ce:	60c4      	str	r4, [r0, #12]
3401a1d0:	f8d7 801c 	ldr.w	r8, [r7, #28]
3401a1d4:	f8d8 4008 	ldr.w	r4, [r8, #8]
3401a1d8:	b94c      	cbnz	r4, 3401a1ee <__pow5mult+0x66>
3401a1da:	f240 2171 	movw	r1, #625	@ 0x271
3401a1de:	4638      	mov	r0, r7
3401a1e0:	f7ff ff18 	bl	3401a014 <__i2b>
3401a1e4:	2300      	movs	r3, #0
3401a1e6:	4604      	mov	r4, r0
3401a1e8:	f8c8 0008 	str.w	r0, [r8, #8]
3401a1ec:	6003      	str	r3, [r0, #0]
3401a1ee:	f04f 0900 	mov.w	r9, #0
3401a1f2:	07eb      	lsls	r3, r5, #31
3401a1f4:	d50a      	bpl.n	3401a20c <__pow5mult+0x84>
3401a1f6:	4631      	mov	r1, r6
3401a1f8:	4622      	mov	r2, r4
3401a1fa:	4638      	mov	r0, r7
3401a1fc:	f7ff ff20 	bl	3401a040 <__multiply>
3401a200:	4680      	mov	r8, r0
3401a202:	4631      	mov	r1, r6
3401a204:	4638      	mov	r0, r7
3401a206:	4646      	mov	r6, r8
3401a208:	f7ff fe4e 	bl	34019ea8 <_Bfree>
3401a20c:	106d      	asrs	r5, r5, #1
3401a20e:	d00b      	beq.n	3401a228 <__pow5mult+0xa0>
3401a210:	6820      	ldr	r0, [r4, #0]
3401a212:	b938      	cbnz	r0, 3401a224 <__pow5mult+0x9c>
3401a214:	4622      	mov	r2, r4
3401a216:	4621      	mov	r1, r4
3401a218:	4638      	mov	r0, r7
3401a21a:	f7ff ff11 	bl	3401a040 <__multiply>
3401a21e:	6020      	str	r0, [r4, #0]
3401a220:	f8c0 9000 	str.w	r9, [r0]
3401a224:	4604      	mov	r4, r0
3401a226:	e7e4      	b.n	3401a1f2 <__pow5mult+0x6a>
3401a228:	4630      	mov	r0, r6
3401a22a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3401a22e:	bf00      	nop
3401a230:	3403c780 	.word	0x3403c780
3401a234:	3401e764 	.word	0x3401e764
3401a238:	3401e7e4 	.word	0x3401e7e4

3401a23c <__lshift>:
3401a23c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401a240:	460c      	mov	r4, r1
3401a242:	4607      	mov	r7, r0
3401a244:	4691      	mov	r9, r2
3401a246:	ea4f 1a62 	mov.w	sl, r2, asr #5
3401a24a:	6923      	ldr	r3, [r4, #16]
3401a24c:	6849      	ldr	r1, [r1, #4]
3401a24e:	eb03 1862 	add.w	r8, r3, r2, asr #5
3401a252:	68a3      	ldr	r3, [r4, #8]
3401a254:	f108 0601 	add.w	r6, r8, #1
3401a258:	42b3      	cmp	r3, r6
3401a25a:	db0b      	blt.n	3401a274 <__lshift+0x38>
3401a25c:	4638      	mov	r0, r7
3401a25e:	f7ff fde3 	bl	34019e28 <_Balloc>
3401a262:	4605      	mov	r5, r0
3401a264:	b948      	cbnz	r0, 3401a27a <__lshift+0x3e>
3401a266:	4602      	mov	r2, r0
3401a268:	4b28      	ldr	r3, [pc, #160]	@ (3401a30c <__lshift+0xd0>)
3401a26a:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3401a26e:	4828      	ldr	r0, [pc, #160]	@ (3401a310 <__lshift+0xd4>)
3401a270:	f7fd fb96 	bl	340179a0 <__assert_func>
3401a274:	3101      	adds	r1, #1
3401a276:	005b      	lsls	r3, r3, #1
3401a278:	e7ee      	b.n	3401a258 <__lshift+0x1c>
3401a27a:	2300      	movs	r3, #0
3401a27c:	f100 0114 	add.w	r1, r0, #20
3401a280:	f100 0210 	add.w	r2, r0, #16
3401a284:	4618      	mov	r0, r3
3401a286:	4553      	cmp	r3, sl
3401a288:	db33      	blt.n	3401a2f2 <__lshift+0xb6>
3401a28a:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
3401a28e:	f104 0314 	add.w	r3, r4, #20
3401a292:	6920      	ldr	r0, [r4, #16]
3401a294:	f019 091f 	ands.w	r9, r9, #31
3401a298:	eb01 018a 	add.w	r1, r1, sl, lsl #2
3401a29c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
3401a2a0:	d02b      	beq.n	3401a2fa <__lshift+0xbe>
3401a2a2:	f1c9 0e20 	rsb	lr, r9, #32
3401a2a6:	468a      	mov	sl, r1
3401a2a8:	2200      	movs	r2, #0
3401a2aa:	6818      	ldr	r0, [r3, #0]
3401a2ac:	fa00 f009 	lsl.w	r0, r0, r9
3401a2b0:	4310      	orrs	r0, r2
3401a2b2:	f84a 0b04 	str.w	r0, [sl], #4
3401a2b6:	f853 2b04 	ldr.w	r2, [r3], #4
3401a2ba:	459c      	cmp	ip, r3
3401a2bc:	fa22 f20e 	lsr.w	r2, r2, lr
3401a2c0:	d8f3      	bhi.n	3401a2aa <__lshift+0x6e>
3401a2c2:	ebac 0304 	sub.w	r3, ip, r4
3401a2c6:	f104 0015 	add.w	r0, r4, #21
3401a2ca:	3b15      	subs	r3, #21
3401a2cc:	f023 0303 	bic.w	r3, r3, #3
3401a2d0:	3304      	adds	r3, #4
3401a2d2:	4560      	cmp	r0, ip
3401a2d4:	bf88      	it	hi
3401a2d6:	2304      	movhi	r3, #4
3401a2d8:	50ca      	str	r2, [r1, r3]
3401a2da:	b10a      	cbz	r2, 3401a2e0 <__lshift+0xa4>
3401a2dc:	f108 0602 	add.w	r6, r8, #2
3401a2e0:	3e01      	subs	r6, #1
3401a2e2:	4638      	mov	r0, r7
3401a2e4:	4621      	mov	r1, r4
3401a2e6:	612e      	str	r6, [r5, #16]
3401a2e8:	f7ff fdde 	bl	34019ea8 <_Bfree>
3401a2ec:	4628      	mov	r0, r5
3401a2ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401a2f2:	3301      	adds	r3, #1
3401a2f4:	f842 0f04 	str.w	r0, [r2, #4]!
3401a2f8:	e7c5      	b.n	3401a286 <__lshift+0x4a>
3401a2fa:	3904      	subs	r1, #4
3401a2fc:	f853 2b04 	ldr.w	r2, [r3], #4
3401a300:	459c      	cmp	ip, r3
3401a302:	f841 2f04 	str.w	r2, [r1, #4]!
3401a306:	d8f9      	bhi.n	3401a2fc <__lshift+0xc0>
3401a308:	e7ea      	b.n	3401a2e0 <__lshift+0xa4>
3401a30a:	bf00      	nop
3401a30c:	3401e7d3 	.word	0x3401e7d3
3401a310:	3401e7e4 	.word	0x3401e7e4

3401a314 <__mcmp>:
3401a314:	4603      	mov	r3, r0
3401a316:	690a      	ldr	r2, [r1, #16]
3401a318:	6900      	ldr	r0, [r0, #16]
3401a31a:	1a80      	subs	r0, r0, r2
3401a31c:	b530      	push	{r4, r5, lr}
3401a31e:	d10e      	bne.n	3401a33e <__mcmp+0x2a>
3401a320:	3314      	adds	r3, #20
3401a322:	3114      	adds	r1, #20
3401a324:	eb03 0482 	add.w	r4, r3, r2, lsl #2
3401a328:	eb01 0182 	add.w	r1, r1, r2, lsl #2
3401a32c:	f854 5d04 	ldr.w	r5, [r4, #-4]!
3401a330:	f851 2d04 	ldr.w	r2, [r1, #-4]!
3401a334:	4295      	cmp	r5, r2
3401a336:	d003      	beq.n	3401a340 <__mcmp+0x2c>
3401a338:	d205      	bcs.n	3401a346 <__mcmp+0x32>
3401a33a:	f04f 30ff 	mov.w	r0, #4294967295
3401a33e:	bd30      	pop	{r4, r5, pc}
3401a340:	42a3      	cmp	r3, r4
3401a342:	d3f3      	bcc.n	3401a32c <__mcmp+0x18>
3401a344:	e7fb      	b.n	3401a33e <__mcmp+0x2a>
3401a346:	2001      	movs	r0, #1
3401a348:	e7f9      	b.n	3401a33e <__mcmp+0x2a>
	...

3401a34c <__mdiff>:
3401a34c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a350:	4689      	mov	r9, r1
3401a352:	4606      	mov	r6, r0
3401a354:	4611      	mov	r1, r2
3401a356:	4614      	mov	r4, r2
3401a358:	4648      	mov	r0, r9
3401a35a:	f7ff ffdb 	bl	3401a314 <__mcmp>
3401a35e:	1e05      	subs	r5, r0, #0
3401a360:	d112      	bne.n	3401a388 <__mdiff+0x3c>
3401a362:	4629      	mov	r1, r5
3401a364:	4630      	mov	r0, r6
3401a366:	f7ff fd5f 	bl	34019e28 <_Balloc>
3401a36a:	4602      	mov	r2, r0
3401a36c:	b928      	cbnz	r0, 3401a37a <__mdiff+0x2e>
3401a36e:	4b41      	ldr	r3, [pc, #260]	@ (3401a474 <__mdiff+0x128>)
3401a370:	f240 2137 	movw	r1, #567	@ 0x237
3401a374:	4840      	ldr	r0, [pc, #256]	@ (3401a478 <__mdiff+0x12c>)
3401a376:	f7fd fb13 	bl	340179a0 <__assert_func>
3401a37a:	2301      	movs	r3, #1
3401a37c:	e9c0 3504 	strd	r3, r5, [r0, #16]
3401a380:	4610      	mov	r0, r2
3401a382:	b003      	add	sp, #12
3401a384:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a388:	bfbc      	itt	lt
3401a38a:	464b      	movlt	r3, r9
3401a38c:	46a1      	movlt	r9, r4
3401a38e:	4630      	mov	r0, r6
3401a390:	bfb8      	it	lt
3401a392:	2501      	movlt	r5, #1
3401a394:	f8d9 1004 	ldr.w	r1, [r9, #4]
3401a398:	bfb4      	ite	lt
3401a39a:	461c      	movlt	r4, r3
3401a39c:	2500      	movge	r5, #0
3401a39e:	f7ff fd43 	bl	34019e28 <_Balloc>
3401a3a2:	4602      	mov	r2, r0
3401a3a4:	b918      	cbnz	r0, 3401a3ae <__mdiff+0x62>
3401a3a6:	4b33      	ldr	r3, [pc, #204]	@ (3401a474 <__mdiff+0x128>)
3401a3a8:	f240 2145 	movw	r1, #581	@ 0x245
3401a3ac:	e7e2      	b.n	3401a374 <__mdiff+0x28>
3401a3ae:	f8d9 7010 	ldr.w	r7, [r9, #16]
3401a3b2:	f104 0e14 	add.w	lr, r4, #20
3401a3b6:	6926      	ldr	r6, [r4, #16]
3401a3b8:	f100 0b14 	add.w	fp, r0, #20
3401a3bc:	60c5      	str	r5, [r0, #12]
3401a3be:	f109 0514 	add.w	r5, r9, #20
3401a3c2:	f109 0310 	add.w	r3, r9, #16
3401a3c6:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
3401a3ca:	eb05 0887 	add.w	r8, r5, r7, lsl #2
3401a3ce:	46d9      	mov	r9, fp
3401a3d0:	f04f 0c00 	mov.w	ip, #0
3401a3d4:	9301      	str	r3, [sp, #4]
3401a3d6:	9b01      	ldr	r3, [sp, #4]
3401a3d8:	f85e 0b04 	ldr.w	r0, [lr], #4
3401a3dc:	f853 af04 	ldr.w	sl, [r3, #4]!
3401a3e0:	4576      	cmp	r6, lr
3401a3e2:	9301      	str	r3, [sp, #4]
3401a3e4:	fa1f f38a 	uxth.w	r3, sl
3401a3e8:	4619      	mov	r1, r3
3401a3ea:	b283      	uxth	r3, r0
3401a3ec:	ea4f 4010 	mov.w	r0, r0, lsr #16
3401a3f0:	eba1 0303 	sub.w	r3, r1, r3
3401a3f4:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
3401a3f8:	4463      	add	r3, ip
3401a3fa:	eb00 4023 	add.w	r0, r0, r3, asr #16
3401a3fe:	b29b      	uxth	r3, r3
3401a400:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401a404:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3401a408:	f849 3b04 	str.w	r3, [r9], #4
3401a40c:	d8e3      	bhi.n	3401a3d6 <__mdiff+0x8a>
3401a40e:	1b33      	subs	r3, r6, r4
3401a410:	3415      	adds	r4, #21
3401a412:	3b15      	subs	r3, #21
3401a414:	f023 0303 	bic.w	r3, r3, #3
3401a418:	3304      	adds	r3, #4
3401a41a:	42a6      	cmp	r6, r4
3401a41c:	bf38      	it	cc
3401a41e:	2304      	movcc	r3, #4
3401a420:	441d      	add	r5, r3
3401a422:	445b      	add	r3, fp
3401a424:	462c      	mov	r4, r5
3401a426:	461e      	mov	r6, r3
3401a428:	4544      	cmp	r4, r8
3401a42a:	d30e      	bcc.n	3401a44a <__mdiff+0xfe>
3401a42c:	f108 0103 	add.w	r1, r8, #3
3401a430:	1b49      	subs	r1, r1, r5
3401a432:	3d03      	subs	r5, #3
3401a434:	f021 0103 	bic.w	r1, r1, #3
3401a438:	45a8      	cmp	r8, r5
3401a43a:	bf38      	it	cc
3401a43c:	2100      	movcc	r1, #0
3401a43e:	440b      	add	r3, r1
3401a440:	f853 1d04 	ldr.w	r1, [r3, #-4]!
3401a444:	b199      	cbz	r1, 3401a46e <__mdiff+0x122>
3401a446:	6117      	str	r7, [r2, #16]
3401a448:	e79a      	b.n	3401a380 <__mdiff+0x34>
3401a44a:	f854 1b04 	ldr.w	r1, [r4], #4
3401a44e:	46e6      	mov	lr, ip
3401a450:	fa1f fc81 	uxth.w	ip, r1
3401a454:	0c08      	lsrs	r0, r1, #16
3401a456:	4471      	add	r1, lr
3401a458:	44f4      	add	ip, lr
3401a45a:	b289      	uxth	r1, r1
3401a45c:	eb00 402c 	add.w	r0, r0, ip, asr #16
3401a460:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
3401a464:	ea4f 4c20 	mov.w	ip, r0, asr #16
3401a468:	f846 1b04 	str.w	r1, [r6], #4
3401a46c:	e7dc      	b.n	3401a428 <__mdiff+0xdc>
3401a46e:	3f01      	subs	r7, #1
3401a470:	e7e6      	b.n	3401a440 <__mdiff+0xf4>
3401a472:	bf00      	nop
3401a474:	3401e7d3 	.word	0x3401e7d3
3401a478:	3401e7e4 	.word	0x3401e7e4

3401a47c <__d2b>:
3401a47c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
3401a480:	460f      	mov	r7, r1
3401a482:	2101      	movs	r1, #1
3401a484:	4616      	mov	r6, r2
3401a486:	ec59 8b10 	vmov	r8, r9, d0
3401a48a:	f7ff fccd 	bl	34019e28 <_Balloc>
3401a48e:	4604      	mov	r4, r0
3401a490:	b930      	cbnz	r0, 3401a4a0 <__d2b+0x24>
3401a492:	4602      	mov	r2, r0
3401a494:	4b23      	ldr	r3, [pc, #140]	@ (3401a524 <__d2b+0xa8>)
3401a496:	f240 310f 	movw	r1, #783	@ 0x30f
3401a49a:	4823      	ldr	r0, [pc, #140]	@ (3401a528 <__d2b+0xac>)
3401a49c:	f7fd fa80 	bl	340179a0 <__assert_func>
3401a4a0:	f3c9 550a 	ubfx	r5, r9, #20, #11
3401a4a4:	f3c9 0313 	ubfx	r3, r9, #0, #20
3401a4a8:	b10d      	cbz	r5, 3401a4ae <__d2b+0x32>
3401a4aa:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
3401a4ae:	9301      	str	r3, [sp, #4]
3401a4b0:	f1b8 0300 	subs.w	r3, r8, #0
3401a4b4:	d023      	beq.n	3401a4fe <__d2b+0x82>
3401a4b6:	4668      	mov	r0, sp
3401a4b8:	9300      	str	r3, [sp, #0]
3401a4ba:	f7ff fd7e 	bl	34019fba <__lo0bits>
3401a4be:	e9dd 1200 	ldrd	r1, r2, [sp]
3401a4c2:	b1d0      	cbz	r0, 3401a4fa <__d2b+0x7e>
3401a4c4:	f1c0 0320 	rsb	r3, r0, #32
3401a4c8:	fa02 f303 	lsl.w	r3, r2, r3
3401a4cc:	40c2      	lsrs	r2, r0
3401a4ce:	430b      	orrs	r3, r1
3401a4d0:	9201      	str	r2, [sp, #4]
3401a4d2:	6163      	str	r3, [r4, #20]
3401a4d4:	9b01      	ldr	r3, [sp, #4]
3401a4d6:	2b00      	cmp	r3, #0
3401a4d8:	61a3      	str	r3, [r4, #24]
3401a4da:	bf0c      	ite	eq
3401a4dc:	2201      	moveq	r2, #1
3401a4de:	2202      	movne	r2, #2
3401a4e0:	6122      	str	r2, [r4, #16]
3401a4e2:	b1a5      	cbz	r5, 3401a50e <__d2b+0x92>
3401a4e4:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
3401a4e8:	4405      	add	r5, r0
3401a4ea:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
3401a4ee:	603d      	str	r5, [r7, #0]
3401a4f0:	6030      	str	r0, [r6, #0]
3401a4f2:	4620      	mov	r0, r4
3401a4f4:	b003      	add	sp, #12
3401a4f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
3401a4fa:	6161      	str	r1, [r4, #20]
3401a4fc:	e7ea      	b.n	3401a4d4 <__d2b+0x58>
3401a4fe:	a801      	add	r0, sp, #4
3401a500:	f7ff fd5b 	bl	34019fba <__lo0bits>
3401a504:	9b01      	ldr	r3, [sp, #4]
3401a506:	3020      	adds	r0, #32
3401a508:	2201      	movs	r2, #1
3401a50a:	6163      	str	r3, [r4, #20]
3401a50c:	e7e8      	b.n	3401a4e0 <__d2b+0x64>
3401a50e:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
3401a512:	eb04 0382 	add.w	r3, r4, r2, lsl #2
3401a516:	6038      	str	r0, [r7, #0]
3401a518:	6918      	ldr	r0, [r3, #16]
3401a51a:	f7ff fd2f 	bl	34019f7c <__hi0bits>
3401a51e:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
3401a522:	e7e5      	b.n	3401a4f0 <__d2b+0x74>
3401a524:	3401e7d3 	.word	0x3401e7d3
3401a528:	3401e7e4 	.word	0x3401e7e4

3401a52c <_malloc_usable_size_r>:
3401a52c:	f851 3c04 	ldr.w	r3, [r1, #-4]
3401a530:	1f18      	subs	r0, r3, #4
3401a532:	2b00      	cmp	r3, #0
3401a534:	bfbc      	itt	lt
3401a536:	580b      	ldrlt	r3, [r1, r0]
3401a538:	18c0      	addlt	r0, r0, r3
3401a53a:	4770      	bx	lr

3401a53c <__ssputs_r>:
3401a53c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
3401a540:	461f      	mov	r7, r3
3401a542:	688e      	ldr	r6, [r1, #8]
3401a544:	4682      	mov	sl, r0
3401a546:	460c      	mov	r4, r1
3401a548:	42be      	cmp	r6, r7
3401a54a:	4690      	mov	r8, r2
3401a54c:	680b      	ldr	r3, [r1, #0]
3401a54e:	d82d      	bhi.n	3401a5ac <__ssputs_r+0x70>
3401a550:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401a554:	f412 6f90 	tst.w	r2, #1152	@ 0x480
3401a558:	d026      	beq.n	3401a5a8 <__ssputs_r+0x6c>
3401a55a:	6965      	ldr	r5, [r4, #20]
3401a55c:	6909      	ldr	r1, [r1, #16]
3401a55e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
3401a562:	eba3 0901 	sub.w	r9, r3, r1
3401a566:	1c7b      	adds	r3, r7, #1
3401a568:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
3401a56c:	444b      	add	r3, r9
3401a56e:	106d      	asrs	r5, r5, #1
3401a570:	429d      	cmp	r5, r3
3401a572:	bf38      	it	cc
3401a574:	461d      	movcc	r5, r3
3401a576:	0553      	lsls	r3, r2, #21
3401a578:	d527      	bpl.n	3401a5ca <__ssputs_r+0x8e>
3401a57a:	4629      	mov	r1, r5
3401a57c:	f7fd fa58 	bl	34017a30 <_malloc_r>
3401a580:	4606      	mov	r6, r0
3401a582:	b360      	cbz	r0, 3401a5de <__ssputs_r+0xa2>
3401a584:	464a      	mov	r2, r9
3401a586:	6921      	ldr	r1, [r4, #16]
3401a588:	f7fe fe03 	bl	34019192 <memcpy>
3401a58c:	89a3      	ldrh	r3, [r4, #12]
3401a58e:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
3401a592:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401a596:	81a3      	strh	r3, [r4, #12]
3401a598:	6126      	str	r6, [r4, #16]
3401a59a:	444e      	add	r6, r9
3401a59c:	6165      	str	r5, [r4, #20]
3401a59e:	eba5 0509 	sub.w	r5, r5, r9
3401a5a2:	6026      	str	r6, [r4, #0]
3401a5a4:	463e      	mov	r6, r7
3401a5a6:	60a5      	str	r5, [r4, #8]
3401a5a8:	42be      	cmp	r6, r7
3401a5aa:	d900      	bls.n	3401a5ae <__ssputs_r+0x72>
3401a5ac:	463e      	mov	r6, r7
3401a5ae:	4632      	mov	r2, r6
3401a5b0:	4641      	mov	r1, r8
3401a5b2:	6820      	ldr	r0, [r4, #0]
3401a5b4:	f7fe fb3c 	bl	34018c30 <memmove>
3401a5b8:	68a3      	ldr	r3, [r4, #8]
3401a5ba:	2000      	movs	r0, #0
3401a5bc:	1b9b      	subs	r3, r3, r6
3401a5be:	60a3      	str	r3, [r4, #8]
3401a5c0:	6823      	ldr	r3, [r4, #0]
3401a5c2:	4433      	add	r3, r6
3401a5c4:	6023      	str	r3, [r4, #0]
3401a5c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
3401a5ca:	462a      	mov	r2, r5
3401a5cc:	f7fd fabc 	bl	34017b48 <_realloc_r>
3401a5d0:	4606      	mov	r6, r0
3401a5d2:	2800      	cmp	r0, #0
3401a5d4:	d1e0      	bne.n	3401a598 <__ssputs_r+0x5c>
3401a5d6:	6921      	ldr	r1, [r4, #16]
3401a5d8:	4650      	mov	r0, sl
3401a5da:	f7ff fbdb 	bl	34019d94 <_free_r>
3401a5de:	230c      	movs	r3, #12
3401a5e0:	f04f 30ff 	mov.w	r0, #4294967295
3401a5e4:	f8ca 3000 	str.w	r3, [sl]
3401a5e8:	89a3      	ldrh	r3, [r4, #12]
3401a5ea:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401a5ee:	81a3      	strh	r3, [r4, #12]
3401a5f0:	e7e9      	b.n	3401a5c6 <__ssputs_r+0x8a>
	...

3401a5f4 <_svfiprintf_r>:
3401a5f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a5f8:	4698      	mov	r8, r3
3401a5fa:	898b      	ldrh	r3, [r1, #12]
3401a5fc:	b09d      	sub	sp, #116	@ 0x74
3401a5fe:	4607      	mov	r7, r0
3401a600:	061b      	lsls	r3, r3, #24
3401a602:	460d      	mov	r5, r1
3401a604:	4614      	mov	r4, r2
3401a606:	d510      	bpl.n	3401a62a <_svfiprintf_r+0x36>
3401a608:	690b      	ldr	r3, [r1, #16]
3401a60a:	b973      	cbnz	r3, 3401a62a <_svfiprintf_r+0x36>
3401a60c:	2140      	movs	r1, #64	@ 0x40
3401a60e:	f7fd fa0f 	bl	34017a30 <_malloc_r>
3401a612:	6028      	str	r0, [r5, #0]
3401a614:	6128      	str	r0, [r5, #16]
3401a616:	b930      	cbnz	r0, 3401a626 <_svfiprintf_r+0x32>
3401a618:	230c      	movs	r3, #12
3401a61a:	603b      	str	r3, [r7, #0]
3401a61c:	f04f 30ff 	mov.w	r0, #4294967295
3401a620:	b01d      	add	sp, #116	@ 0x74
3401a622:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a626:	2340      	movs	r3, #64	@ 0x40
3401a628:	616b      	str	r3, [r5, #20]
3401a62a:	2300      	movs	r3, #0
3401a62c:	f8cd 800c 	str.w	r8, [sp, #12]
3401a630:	f04f 0901 	mov.w	r9, #1
3401a634:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 3401a7d8 <_svfiprintf_r+0x1e4>
3401a638:	9309      	str	r3, [sp, #36]	@ 0x24
3401a63a:	2320      	movs	r3, #32
3401a63c:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401a640:	2330      	movs	r3, #48	@ 0x30
3401a642:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401a646:	4623      	mov	r3, r4
3401a648:	469a      	mov	sl, r3
3401a64a:	f813 2b01 	ldrb.w	r2, [r3], #1
3401a64e:	b10a      	cbz	r2, 3401a654 <_svfiprintf_r+0x60>
3401a650:	2a25      	cmp	r2, #37	@ 0x25
3401a652:	d1f9      	bne.n	3401a648 <_svfiprintf_r+0x54>
3401a654:	ebba 0b04 	subs.w	fp, sl, r4
3401a658:	d00b      	beq.n	3401a672 <_svfiprintf_r+0x7e>
3401a65a:	465b      	mov	r3, fp
3401a65c:	4622      	mov	r2, r4
3401a65e:	4629      	mov	r1, r5
3401a660:	4638      	mov	r0, r7
3401a662:	f7ff ff6b 	bl	3401a53c <__ssputs_r>
3401a666:	3001      	adds	r0, #1
3401a668:	f000 80a7 	beq.w	3401a7ba <_svfiprintf_r+0x1c6>
3401a66c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401a66e:	445a      	add	r2, fp
3401a670:	9209      	str	r2, [sp, #36]	@ 0x24
3401a672:	f89a 3000 	ldrb.w	r3, [sl]
3401a676:	2b00      	cmp	r3, #0
3401a678:	f000 809f 	beq.w	3401a7ba <_svfiprintf_r+0x1c6>
3401a67c:	2300      	movs	r3, #0
3401a67e:	f04f 32ff 	mov.w	r2, #4294967295
3401a682:	f10a 0a01 	add.w	sl, sl, #1
3401a686:	9304      	str	r3, [sp, #16]
3401a688:	9307      	str	r3, [sp, #28]
3401a68a:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401a68e:	931a      	str	r3, [sp, #104]	@ 0x68
3401a690:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401a694:	4654      	mov	r4, sl
3401a696:	2205      	movs	r2, #5
3401a698:	484f      	ldr	r0, [pc, #316]	@ (3401a7d8 <_svfiprintf_r+0x1e4>)
3401a69a:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a69e:	f7fe fd6a 	bl	34019176 <memchr>
3401a6a2:	9a04      	ldr	r2, [sp, #16]
3401a6a4:	b9d8      	cbnz	r0, 3401a6de <_svfiprintf_r+0xea>
3401a6a6:	06d0      	lsls	r0, r2, #27
3401a6a8:	bf44      	itt	mi
3401a6aa:	2320      	movmi	r3, #32
3401a6ac:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a6b0:	0711      	lsls	r1, r2, #28
3401a6b2:	bf44      	itt	mi
3401a6b4:	232b      	movmi	r3, #43	@ 0x2b
3401a6b6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a6ba:	f89a 3000 	ldrb.w	r3, [sl]
3401a6be:	2b2a      	cmp	r3, #42	@ 0x2a
3401a6c0:	d015      	beq.n	3401a6ee <_svfiprintf_r+0xfa>
3401a6c2:	9a07      	ldr	r2, [sp, #28]
3401a6c4:	4654      	mov	r4, sl
3401a6c6:	2000      	movs	r0, #0
3401a6c8:	f04f 0c0a 	mov.w	ip, #10
3401a6cc:	4621      	mov	r1, r4
3401a6ce:	f811 3b01 	ldrb.w	r3, [r1], #1
3401a6d2:	3b30      	subs	r3, #48	@ 0x30
3401a6d4:	2b09      	cmp	r3, #9
3401a6d6:	d94b      	bls.n	3401a770 <_svfiprintf_r+0x17c>
3401a6d8:	b1b0      	cbz	r0, 3401a708 <_svfiprintf_r+0x114>
3401a6da:	9207      	str	r2, [sp, #28]
3401a6dc:	e014      	b.n	3401a708 <_svfiprintf_r+0x114>
3401a6de:	eba0 0308 	sub.w	r3, r0, r8
3401a6e2:	46a2      	mov	sl, r4
3401a6e4:	fa09 f303 	lsl.w	r3, r9, r3
3401a6e8:	4313      	orrs	r3, r2
3401a6ea:	9304      	str	r3, [sp, #16]
3401a6ec:	e7d2      	b.n	3401a694 <_svfiprintf_r+0xa0>
3401a6ee:	9b03      	ldr	r3, [sp, #12]
3401a6f0:	1d19      	adds	r1, r3, #4
3401a6f2:	681b      	ldr	r3, [r3, #0]
3401a6f4:	2b00      	cmp	r3, #0
3401a6f6:	9103      	str	r1, [sp, #12]
3401a6f8:	bfbb      	ittet	lt
3401a6fa:	425b      	neglt	r3, r3
3401a6fc:	f042 0202 	orrlt.w	r2, r2, #2
3401a700:	9307      	strge	r3, [sp, #28]
3401a702:	9307      	strlt	r3, [sp, #28]
3401a704:	bfb8      	it	lt
3401a706:	9204      	strlt	r2, [sp, #16]
3401a708:	7823      	ldrb	r3, [r4, #0]
3401a70a:	2b2e      	cmp	r3, #46	@ 0x2e
3401a70c:	d10a      	bne.n	3401a724 <_svfiprintf_r+0x130>
3401a70e:	7863      	ldrb	r3, [r4, #1]
3401a710:	2b2a      	cmp	r3, #42	@ 0x2a
3401a712:	d132      	bne.n	3401a77a <_svfiprintf_r+0x186>
3401a714:	9b03      	ldr	r3, [sp, #12]
3401a716:	3402      	adds	r4, #2
3401a718:	1d1a      	adds	r2, r3, #4
3401a71a:	681b      	ldr	r3, [r3, #0]
3401a71c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401a720:	9203      	str	r2, [sp, #12]
3401a722:	9305      	str	r3, [sp, #20]
3401a724:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 3401a7e8 <_svfiprintf_r+0x1f4>
3401a728:	2203      	movs	r2, #3
3401a72a:	7821      	ldrb	r1, [r4, #0]
3401a72c:	4650      	mov	r0, sl
3401a72e:	f7fe fd22 	bl	34019176 <memchr>
3401a732:	b138      	cbz	r0, 3401a744 <_svfiprintf_r+0x150>
3401a734:	eba0 000a 	sub.w	r0, r0, sl
3401a738:	2240      	movs	r2, #64	@ 0x40
3401a73a:	9b04      	ldr	r3, [sp, #16]
3401a73c:	3401      	adds	r4, #1
3401a73e:	4082      	lsls	r2, r0
3401a740:	4313      	orrs	r3, r2
3401a742:	9304      	str	r3, [sp, #16]
3401a744:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a748:	2206      	movs	r2, #6
3401a74a:	4824      	ldr	r0, [pc, #144]	@ (3401a7dc <_svfiprintf_r+0x1e8>)
3401a74c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401a750:	f7fe fd11 	bl	34019176 <memchr>
3401a754:	2800      	cmp	r0, #0
3401a756:	d036      	beq.n	3401a7c6 <_svfiprintf_r+0x1d2>
3401a758:	4b21      	ldr	r3, [pc, #132]	@ (3401a7e0 <_svfiprintf_r+0x1ec>)
3401a75a:	bb1b      	cbnz	r3, 3401a7a4 <_svfiprintf_r+0x1b0>
3401a75c:	9b03      	ldr	r3, [sp, #12]
3401a75e:	3307      	adds	r3, #7
3401a760:	f023 0307 	bic.w	r3, r3, #7
3401a764:	3308      	adds	r3, #8
3401a766:	9303      	str	r3, [sp, #12]
3401a768:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401a76a:	4433      	add	r3, r6
3401a76c:	9309      	str	r3, [sp, #36]	@ 0x24
3401a76e:	e76a      	b.n	3401a646 <_svfiprintf_r+0x52>
3401a770:	fb0c 3202 	mla	r2, ip, r2, r3
3401a774:	460c      	mov	r4, r1
3401a776:	2001      	movs	r0, #1
3401a778:	e7a8      	b.n	3401a6cc <_svfiprintf_r+0xd8>
3401a77a:	2300      	movs	r3, #0
3401a77c:	3401      	adds	r4, #1
3401a77e:	f04f 0c0a 	mov.w	ip, #10
3401a782:	4619      	mov	r1, r3
3401a784:	9305      	str	r3, [sp, #20]
3401a786:	4620      	mov	r0, r4
3401a788:	f810 2b01 	ldrb.w	r2, [r0], #1
3401a78c:	3a30      	subs	r2, #48	@ 0x30
3401a78e:	2a09      	cmp	r2, #9
3401a790:	d903      	bls.n	3401a79a <_svfiprintf_r+0x1a6>
3401a792:	2b00      	cmp	r3, #0
3401a794:	d0c6      	beq.n	3401a724 <_svfiprintf_r+0x130>
3401a796:	9105      	str	r1, [sp, #20]
3401a798:	e7c4      	b.n	3401a724 <_svfiprintf_r+0x130>
3401a79a:	fb0c 2101 	mla	r1, ip, r1, r2
3401a79e:	4604      	mov	r4, r0
3401a7a0:	2301      	movs	r3, #1
3401a7a2:	e7f0      	b.n	3401a786 <_svfiprintf_r+0x192>
3401a7a4:	ab03      	add	r3, sp, #12
3401a7a6:	462a      	mov	r2, r5
3401a7a8:	a904      	add	r1, sp, #16
3401a7aa:	4638      	mov	r0, r7
3401a7ac:	9300      	str	r3, [sp, #0]
3401a7ae:	4b0d      	ldr	r3, [pc, #52]	@ (3401a7e4 <_svfiprintf_r+0x1f0>)
3401a7b0:	f7fd fc06 	bl	34017fc0 <_printf_float>
3401a7b4:	1c42      	adds	r2, r0, #1
3401a7b6:	4606      	mov	r6, r0
3401a7b8:	d1d6      	bne.n	3401a768 <_svfiprintf_r+0x174>
3401a7ba:	89ab      	ldrh	r3, [r5, #12]
3401a7bc:	065b      	lsls	r3, r3, #25
3401a7be:	f53f af2d 	bmi.w	3401a61c <_svfiprintf_r+0x28>
3401a7c2:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401a7c4:	e72c      	b.n	3401a620 <_svfiprintf_r+0x2c>
3401a7c6:	ab03      	add	r3, sp, #12
3401a7c8:	462a      	mov	r2, r5
3401a7ca:	a904      	add	r1, sp, #16
3401a7cc:	4638      	mov	r0, r7
3401a7ce:	9300      	str	r3, [sp, #0]
3401a7d0:	4b04      	ldr	r3, [pc, #16]	@ (3401a7e4 <_svfiprintf_r+0x1f0>)
3401a7d2:	f7fd fe81 	bl	340184d8 <_printf_i>
3401a7d6:	e7ed      	b.n	3401a7b4 <_svfiprintf_r+0x1c0>
3401a7d8:	3401e83d 	.word	0x3401e83d
3401a7dc:	3401e847 	.word	0x3401e847
3401a7e0:	34017fc1 	.word	0x34017fc1
3401a7e4:	3401a53d 	.word	0x3401a53d
3401a7e8:	3401e843 	.word	0x3401e843

3401a7ec <__sfputc_r>:
3401a7ec:	6893      	ldr	r3, [r2, #8]
3401a7ee:	3b01      	subs	r3, #1
3401a7f0:	2b00      	cmp	r3, #0
3401a7f2:	b410      	push	{r4}
3401a7f4:	6093      	str	r3, [r2, #8]
3401a7f6:	da08      	bge.n	3401a80a <__sfputc_r+0x1e>
3401a7f8:	6994      	ldr	r4, [r2, #24]
3401a7fa:	42a3      	cmp	r3, r4
3401a7fc:	db01      	blt.n	3401a802 <__sfputc_r+0x16>
3401a7fe:	290a      	cmp	r1, #10
3401a800:	d103      	bne.n	3401a80a <__sfputc_r+0x1e>
3401a802:	f85d 4b04 	ldr.w	r4, [sp], #4
3401a806:	f7fe b97f 	b.w	34018b08 <__swbuf_r>
3401a80a:	6813      	ldr	r3, [r2, #0]
3401a80c:	1c58      	adds	r0, r3, #1
3401a80e:	6010      	str	r0, [r2, #0]
3401a810:	4608      	mov	r0, r1
3401a812:	7019      	strb	r1, [r3, #0]
3401a814:	f85d 4b04 	ldr.w	r4, [sp], #4
3401a818:	4770      	bx	lr

3401a81a <__sfputs_r>:
3401a81a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401a81c:	4606      	mov	r6, r0
3401a81e:	460f      	mov	r7, r1
3401a820:	4614      	mov	r4, r2
3401a822:	18d5      	adds	r5, r2, r3
3401a824:	42ac      	cmp	r4, r5
3401a826:	d101      	bne.n	3401a82c <__sfputs_r+0x12>
3401a828:	2000      	movs	r0, #0
3401a82a:	e007      	b.n	3401a83c <__sfputs_r+0x22>
3401a82c:	463a      	mov	r2, r7
3401a82e:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a832:	4630      	mov	r0, r6
3401a834:	f7ff ffda 	bl	3401a7ec <__sfputc_r>
3401a838:	1c43      	adds	r3, r0, #1
3401a83a:	d1f3      	bne.n	3401a824 <__sfputs_r+0xa>
3401a83c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

3401a840 <_vfiprintf_r>:
3401a840:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401a844:	460d      	mov	r5, r1
3401a846:	b09d      	sub	sp, #116	@ 0x74
3401a848:	4614      	mov	r4, r2
3401a84a:	4698      	mov	r8, r3
3401a84c:	4606      	mov	r6, r0
3401a84e:	b118      	cbz	r0, 3401a858 <_vfiprintf_r+0x18>
3401a850:	6a03      	ldr	r3, [r0, #32]
3401a852:	b90b      	cbnz	r3, 3401a858 <_vfiprintf_r+0x18>
3401a854:	f7fd ffea 	bl	3401882c <__sinit>
3401a858:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401a85a:	07d9      	lsls	r1, r3, #31
3401a85c:	d405      	bmi.n	3401a86a <_vfiprintf_r+0x2a>
3401a85e:	89ab      	ldrh	r3, [r5, #12]
3401a860:	059a      	lsls	r2, r3, #22
3401a862:	d402      	bmi.n	3401a86a <_vfiprintf_r+0x2a>
3401a864:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401a866:	f7fe fc7c 	bl	34019162 <__retarget_lock_acquire_recursive>
3401a86a:	89ab      	ldrh	r3, [r5, #12]
3401a86c:	071b      	lsls	r3, r3, #28
3401a86e:	d501      	bpl.n	3401a874 <_vfiprintf_r+0x34>
3401a870:	692b      	ldr	r3, [r5, #16]
3401a872:	b99b      	cbnz	r3, 3401a89c <_vfiprintf_r+0x5c>
3401a874:	4629      	mov	r1, r5
3401a876:	4630      	mov	r0, r6
3401a878:	f7fe f984 	bl	34018b84 <__swsetup_r>
3401a87c:	b170      	cbz	r0, 3401a89c <_vfiprintf_r+0x5c>
3401a87e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401a880:	07dc      	lsls	r4, r3, #31
3401a882:	d504      	bpl.n	3401a88e <_vfiprintf_r+0x4e>
3401a884:	f04f 30ff 	mov.w	r0, #4294967295
3401a888:	b01d      	add	sp, #116	@ 0x74
3401a88a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401a88e:	89ab      	ldrh	r3, [r5, #12]
3401a890:	0598      	lsls	r0, r3, #22
3401a892:	d4f7      	bmi.n	3401a884 <_vfiprintf_r+0x44>
3401a894:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401a896:	f7fe fc65 	bl	34019164 <__retarget_lock_release_recursive>
3401a89a:	e7f3      	b.n	3401a884 <_vfiprintf_r+0x44>
3401a89c:	2300      	movs	r3, #0
3401a89e:	f8cd 800c 	str.w	r8, [sp, #12]
3401a8a2:	f04f 0901 	mov.w	r9, #1
3401a8a6:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 3401aa5c <_vfiprintf_r+0x21c>
3401a8aa:	9309      	str	r3, [sp, #36]	@ 0x24
3401a8ac:	2320      	movs	r3, #32
3401a8ae:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
3401a8b2:	2330      	movs	r3, #48	@ 0x30
3401a8b4:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
3401a8b8:	4623      	mov	r3, r4
3401a8ba:	469a      	mov	sl, r3
3401a8bc:	f813 2b01 	ldrb.w	r2, [r3], #1
3401a8c0:	b10a      	cbz	r2, 3401a8c6 <_vfiprintf_r+0x86>
3401a8c2:	2a25      	cmp	r2, #37	@ 0x25
3401a8c4:	d1f9      	bne.n	3401a8ba <_vfiprintf_r+0x7a>
3401a8c6:	ebba 0b04 	subs.w	fp, sl, r4
3401a8ca:	d00b      	beq.n	3401a8e4 <_vfiprintf_r+0xa4>
3401a8cc:	465b      	mov	r3, fp
3401a8ce:	4622      	mov	r2, r4
3401a8d0:	4629      	mov	r1, r5
3401a8d2:	4630      	mov	r0, r6
3401a8d4:	f7ff ffa1 	bl	3401a81a <__sfputs_r>
3401a8d8:	3001      	adds	r0, #1
3401a8da:	f000 80a7 	beq.w	3401aa2c <_vfiprintf_r+0x1ec>
3401a8de:	9a09      	ldr	r2, [sp, #36]	@ 0x24
3401a8e0:	445a      	add	r2, fp
3401a8e2:	9209      	str	r2, [sp, #36]	@ 0x24
3401a8e4:	f89a 3000 	ldrb.w	r3, [sl]
3401a8e8:	2b00      	cmp	r3, #0
3401a8ea:	f000 809f 	beq.w	3401aa2c <_vfiprintf_r+0x1ec>
3401a8ee:	2300      	movs	r3, #0
3401a8f0:	f04f 32ff 	mov.w	r2, #4294967295
3401a8f4:	f10a 0a01 	add.w	sl, sl, #1
3401a8f8:	9304      	str	r3, [sp, #16]
3401a8fa:	9307      	str	r3, [sp, #28]
3401a8fc:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
3401a900:	931a      	str	r3, [sp, #104]	@ 0x68
3401a902:	e9cd 2305 	strd	r2, r3, [sp, #20]
3401a906:	4654      	mov	r4, sl
3401a908:	2205      	movs	r2, #5
3401a90a:	4854      	ldr	r0, [pc, #336]	@ (3401aa5c <_vfiprintf_r+0x21c>)
3401a90c:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a910:	f7fe fc31 	bl	34019176 <memchr>
3401a914:	9a04      	ldr	r2, [sp, #16]
3401a916:	b9d8      	cbnz	r0, 3401a950 <_vfiprintf_r+0x110>
3401a918:	06d1      	lsls	r1, r2, #27
3401a91a:	bf44      	itt	mi
3401a91c:	2320      	movmi	r3, #32
3401a91e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a922:	0713      	lsls	r3, r2, #28
3401a924:	bf44      	itt	mi
3401a926:	232b      	movmi	r3, #43	@ 0x2b
3401a928:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
3401a92c:	f89a 3000 	ldrb.w	r3, [sl]
3401a930:	2b2a      	cmp	r3, #42	@ 0x2a
3401a932:	d015      	beq.n	3401a960 <_vfiprintf_r+0x120>
3401a934:	9a07      	ldr	r2, [sp, #28]
3401a936:	4654      	mov	r4, sl
3401a938:	2000      	movs	r0, #0
3401a93a:	f04f 0c0a 	mov.w	ip, #10
3401a93e:	4621      	mov	r1, r4
3401a940:	f811 3b01 	ldrb.w	r3, [r1], #1
3401a944:	3b30      	subs	r3, #48	@ 0x30
3401a946:	2b09      	cmp	r3, #9
3401a948:	d94b      	bls.n	3401a9e2 <_vfiprintf_r+0x1a2>
3401a94a:	b1b0      	cbz	r0, 3401a97a <_vfiprintf_r+0x13a>
3401a94c:	9207      	str	r2, [sp, #28]
3401a94e:	e014      	b.n	3401a97a <_vfiprintf_r+0x13a>
3401a950:	eba0 0308 	sub.w	r3, r0, r8
3401a954:	46a2      	mov	sl, r4
3401a956:	fa09 f303 	lsl.w	r3, r9, r3
3401a95a:	4313      	orrs	r3, r2
3401a95c:	9304      	str	r3, [sp, #16]
3401a95e:	e7d2      	b.n	3401a906 <_vfiprintf_r+0xc6>
3401a960:	9b03      	ldr	r3, [sp, #12]
3401a962:	1d19      	adds	r1, r3, #4
3401a964:	681b      	ldr	r3, [r3, #0]
3401a966:	2b00      	cmp	r3, #0
3401a968:	9103      	str	r1, [sp, #12]
3401a96a:	bfbb      	ittet	lt
3401a96c:	425b      	neglt	r3, r3
3401a96e:	f042 0202 	orrlt.w	r2, r2, #2
3401a972:	9307      	strge	r3, [sp, #28]
3401a974:	9307      	strlt	r3, [sp, #28]
3401a976:	bfb8      	it	lt
3401a978:	9204      	strlt	r2, [sp, #16]
3401a97a:	7823      	ldrb	r3, [r4, #0]
3401a97c:	2b2e      	cmp	r3, #46	@ 0x2e
3401a97e:	d10a      	bne.n	3401a996 <_vfiprintf_r+0x156>
3401a980:	7863      	ldrb	r3, [r4, #1]
3401a982:	2b2a      	cmp	r3, #42	@ 0x2a
3401a984:	d132      	bne.n	3401a9ec <_vfiprintf_r+0x1ac>
3401a986:	9b03      	ldr	r3, [sp, #12]
3401a988:	3402      	adds	r4, #2
3401a98a:	1d1a      	adds	r2, r3, #4
3401a98c:	681b      	ldr	r3, [r3, #0]
3401a98e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
3401a992:	9203      	str	r2, [sp, #12]
3401a994:	9305      	str	r3, [sp, #20]
3401a996:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 3401aa6c <_vfiprintf_r+0x22c>
3401a99a:	2203      	movs	r2, #3
3401a99c:	7821      	ldrb	r1, [r4, #0]
3401a99e:	4650      	mov	r0, sl
3401a9a0:	f7fe fbe9 	bl	34019176 <memchr>
3401a9a4:	b138      	cbz	r0, 3401a9b6 <_vfiprintf_r+0x176>
3401a9a6:	eba0 000a 	sub.w	r0, r0, sl
3401a9aa:	2240      	movs	r2, #64	@ 0x40
3401a9ac:	9b04      	ldr	r3, [sp, #16]
3401a9ae:	3401      	adds	r4, #1
3401a9b0:	4082      	lsls	r2, r0
3401a9b2:	4313      	orrs	r3, r2
3401a9b4:	9304      	str	r3, [sp, #16]
3401a9b6:	f814 1b01 	ldrb.w	r1, [r4], #1
3401a9ba:	2206      	movs	r2, #6
3401a9bc:	4828      	ldr	r0, [pc, #160]	@ (3401aa60 <_vfiprintf_r+0x220>)
3401a9be:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
3401a9c2:	f7fe fbd8 	bl	34019176 <memchr>
3401a9c6:	2800      	cmp	r0, #0
3401a9c8:	d03f      	beq.n	3401aa4a <_vfiprintf_r+0x20a>
3401a9ca:	4b26      	ldr	r3, [pc, #152]	@ (3401aa64 <_vfiprintf_r+0x224>)
3401a9cc:	bb1b      	cbnz	r3, 3401aa16 <_vfiprintf_r+0x1d6>
3401a9ce:	9b03      	ldr	r3, [sp, #12]
3401a9d0:	3307      	adds	r3, #7
3401a9d2:	f023 0307 	bic.w	r3, r3, #7
3401a9d6:	3308      	adds	r3, #8
3401a9d8:	9303      	str	r3, [sp, #12]
3401a9da:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3401a9dc:	443b      	add	r3, r7
3401a9de:	9309      	str	r3, [sp, #36]	@ 0x24
3401a9e0:	e76a      	b.n	3401a8b8 <_vfiprintf_r+0x78>
3401a9e2:	fb0c 3202 	mla	r2, ip, r2, r3
3401a9e6:	460c      	mov	r4, r1
3401a9e8:	2001      	movs	r0, #1
3401a9ea:	e7a8      	b.n	3401a93e <_vfiprintf_r+0xfe>
3401a9ec:	2300      	movs	r3, #0
3401a9ee:	3401      	adds	r4, #1
3401a9f0:	f04f 0c0a 	mov.w	ip, #10
3401a9f4:	4619      	mov	r1, r3
3401a9f6:	9305      	str	r3, [sp, #20]
3401a9f8:	4620      	mov	r0, r4
3401a9fa:	f810 2b01 	ldrb.w	r2, [r0], #1
3401a9fe:	3a30      	subs	r2, #48	@ 0x30
3401aa00:	2a09      	cmp	r2, #9
3401aa02:	d903      	bls.n	3401aa0c <_vfiprintf_r+0x1cc>
3401aa04:	2b00      	cmp	r3, #0
3401aa06:	d0c6      	beq.n	3401a996 <_vfiprintf_r+0x156>
3401aa08:	9105      	str	r1, [sp, #20]
3401aa0a:	e7c4      	b.n	3401a996 <_vfiprintf_r+0x156>
3401aa0c:	fb0c 2101 	mla	r1, ip, r1, r2
3401aa10:	4604      	mov	r4, r0
3401aa12:	2301      	movs	r3, #1
3401aa14:	e7f0      	b.n	3401a9f8 <_vfiprintf_r+0x1b8>
3401aa16:	ab03      	add	r3, sp, #12
3401aa18:	462a      	mov	r2, r5
3401aa1a:	a904      	add	r1, sp, #16
3401aa1c:	4630      	mov	r0, r6
3401aa1e:	9300      	str	r3, [sp, #0]
3401aa20:	4b11      	ldr	r3, [pc, #68]	@ (3401aa68 <_vfiprintf_r+0x228>)
3401aa22:	f7fd facd 	bl	34017fc0 <_printf_float>
3401aa26:	4607      	mov	r7, r0
3401aa28:	1c78      	adds	r0, r7, #1
3401aa2a:	d1d6      	bne.n	3401a9da <_vfiprintf_r+0x19a>
3401aa2c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
3401aa2e:	07d9      	lsls	r1, r3, #31
3401aa30:	d405      	bmi.n	3401aa3e <_vfiprintf_r+0x1fe>
3401aa32:	89ab      	ldrh	r3, [r5, #12]
3401aa34:	059a      	lsls	r2, r3, #22
3401aa36:	d402      	bmi.n	3401aa3e <_vfiprintf_r+0x1fe>
3401aa38:	6da8      	ldr	r0, [r5, #88]	@ 0x58
3401aa3a:	f7fe fb93 	bl	34019164 <__retarget_lock_release_recursive>
3401aa3e:	89ab      	ldrh	r3, [r5, #12]
3401aa40:	065b      	lsls	r3, r3, #25
3401aa42:	f53f af1f 	bmi.w	3401a884 <_vfiprintf_r+0x44>
3401aa46:	9809      	ldr	r0, [sp, #36]	@ 0x24
3401aa48:	e71e      	b.n	3401a888 <_vfiprintf_r+0x48>
3401aa4a:	ab03      	add	r3, sp, #12
3401aa4c:	462a      	mov	r2, r5
3401aa4e:	a904      	add	r1, sp, #16
3401aa50:	4630      	mov	r0, r6
3401aa52:	9300      	str	r3, [sp, #0]
3401aa54:	4b04      	ldr	r3, [pc, #16]	@ (3401aa68 <_vfiprintf_r+0x228>)
3401aa56:	f7fd fd3f 	bl	340184d8 <_printf_i>
3401aa5a:	e7e4      	b.n	3401aa26 <_vfiprintf_r+0x1e6>
3401aa5c:	3401e83d 	.word	0x3401e83d
3401aa60:	3401e847 	.word	0x3401e847
3401aa64:	34017fc1 	.word	0x34017fc1
3401aa68:	3401a81b 	.word	0x3401a81b
3401aa6c:	3401e843 	.word	0x3401e843

3401aa70 <__sflush_r>:
3401aa70:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
3401aa74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
3401aa78:	0716      	lsls	r6, r2, #28
3401aa7a:	4605      	mov	r5, r0
3401aa7c:	460c      	mov	r4, r1
3401aa7e:	d454      	bmi.n	3401ab2a <__sflush_r+0xba>
3401aa80:	684b      	ldr	r3, [r1, #4]
3401aa82:	2b00      	cmp	r3, #0
3401aa84:	dc02      	bgt.n	3401aa8c <__sflush_r+0x1c>
3401aa86:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
3401aa88:	2b00      	cmp	r3, #0
3401aa8a:	dd48      	ble.n	3401ab1e <__sflush_r+0xae>
3401aa8c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401aa8e:	2e00      	cmp	r6, #0
3401aa90:	d045      	beq.n	3401ab1e <__sflush_r+0xae>
3401aa92:	2300      	movs	r3, #0
3401aa94:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
3401aa98:	682f      	ldr	r7, [r5, #0]
3401aa9a:	6a21      	ldr	r1, [r4, #32]
3401aa9c:	602b      	str	r3, [r5, #0]
3401aa9e:	d030      	beq.n	3401ab02 <__sflush_r+0x92>
3401aaa0:	6d62      	ldr	r2, [r4, #84]	@ 0x54
3401aaa2:	89a3      	ldrh	r3, [r4, #12]
3401aaa4:	0759      	lsls	r1, r3, #29
3401aaa6:	d505      	bpl.n	3401aab4 <__sflush_r+0x44>
3401aaa8:	6863      	ldr	r3, [r4, #4]
3401aaaa:	1ad2      	subs	r2, r2, r3
3401aaac:	6b63      	ldr	r3, [r4, #52]	@ 0x34
3401aaae:	b10b      	cbz	r3, 3401aab4 <__sflush_r+0x44>
3401aab0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
3401aab2:	1ad2      	subs	r2, r2, r3
3401aab4:	2300      	movs	r3, #0
3401aab6:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
3401aab8:	6a21      	ldr	r1, [r4, #32]
3401aaba:	4628      	mov	r0, r5
3401aabc:	47b0      	blx	r6
3401aabe:	1c43      	adds	r3, r0, #1
3401aac0:	89a3      	ldrh	r3, [r4, #12]
3401aac2:	d106      	bne.n	3401aad2 <__sflush_r+0x62>
3401aac4:	6829      	ldr	r1, [r5, #0]
3401aac6:	291d      	cmp	r1, #29
3401aac8:	d82b      	bhi.n	3401ab22 <__sflush_r+0xb2>
3401aaca:	4a2a      	ldr	r2, [pc, #168]	@ (3401ab74 <__sflush_r+0x104>)
3401aacc:	40ca      	lsrs	r2, r1
3401aace:	07d6      	lsls	r6, r2, #31
3401aad0:	d527      	bpl.n	3401ab22 <__sflush_r+0xb2>
3401aad2:	2200      	movs	r2, #0
3401aad4:	04d9      	lsls	r1, r3, #19
3401aad6:	6062      	str	r2, [r4, #4]
3401aad8:	6922      	ldr	r2, [r4, #16]
3401aada:	6022      	str	r2, [r4, #0]
3401aadc:	d504      	bpl.n	3401aae8 <__sflush_r+0x78>
3401aade:	1c42      	adds	r2, r0, #1
3401aae0:	d101      	bne.n	3401aae6 <__sflush_r+0x76>
3401aae2:	682b      	ldr	r3, [r5, #0]
3401aae4:	b903      	cbnz	r3, 3401aae8 <__sflush_r+0x78>
3401aae6:	6560      	str	r0, [r4, #84]	@ 0x54
3401aae8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3401aaea:	602f      	str	r7, [r5, #0]
3401aaec:	b1b9      	cbz	r1, 3401ab1e <__sflush_r+0xae>
3401aaee:	f104 0344 	add.w	r3, r4, #68	@ 0x44
3401aaf2:	4299      	cmp	r1, r3
3401aaf4:	d002      	beq.n	3401aafc <__sflush_r+0x8c>
3401aaf6:	4628      	mov	r0, r5
3401aaf8:	f7ff f94c 	bl	34019d94 <_free_r>
3401aafc:	2300      	movs	r3, #0
3401aafe:	6363      	str	r3, [r4, #52]	@ 0x34
3401ab00:	e00d      	b.n	3401ab1e <__sflush_r+0xae>
3401ab02:	2301      	movs	r3, #1
3401ab04:	4628      	mov	r0, r5
3401ab06:	47b0      	blx	r6
3401ab08:	4602      	mov	r2, r0
3401ab0a:	1c50      	adds	r0, r2, #1
3401ab0c:	d1c9      	bne.n	3401aaa2 <__sflush_r+0x32>
3401ab0e:	682b      	ldr	r3, [r5, #0]
3401ab10:	2b00      	cmp	r3, #0
3401ab12:	d0c6      	beq.n	3401aaa2 <__sflush_r+0x32>
3401ab14:	2b1d      	cmp	r3, #29
3401ab16:	d001      	beq.n	3401ab1c <__sflush_r+0xac>
3401ab18:	2b16      	cmp	r3, #22
3401ab1a:	d11d      	bne.n	3401ab58 <__sflush_r+0xe8>
3401ab1c:	602f      	str	r7, [r5, #0]
3401ab1e:	2000      	movs	r0, #0
3401ab20:	e021      	b.n	3401ab66 <__sflush_r+0xf6>
3401ab22:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401ab26:	b21b      	sxth	r3, r3
3401ab28:	e01a      	b.n	3401ab60 <__sflush_r+0xf0>
3401ab2a:	690f      	ldr	r7, [r1, #16]
3401ab2c:	2f00      	cmp	r7, #0
3401ab2e:	d0f6      	beq.n	3401ab1e <__sflush_r+0xae>
3401ab30:	0793      	lsls	r3, r2, #30
3401ab32:	680e      	ldr	r6, [r1, #0]
3401ab34:	600f      	str	r7, [r1, #0]
3401ab36:	bf0c      	ite	eq
3401ab38:	694b      	ldreq	r3, [r1, #20]
3401ab3a:	2300      	movne	r3, #0
3401ab3c:	eba6 0807 	sub.w	r8, r6, r7
3401ab40:	608b      	str	r3, [r1, #8]
3401ab42:	f1b8 0f00 	cmp.w	r8, #0
3401ab46:	ddea      	ble.n	3401ab1e <__sflush_r+0xae>
3401ab48:	4643      	mov	r3, r8
3401ab4a:	463a      	mov	r2, r7
3401ab4c:	6a21      	ldr	r1, [r4, #32]
3401ab4e:	4628      	mov	r0, r5
3401ab50:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
3401ab52:	47b0      	blx	r6
3401ab54:	2800      	cmp	r0, #0
3401ab56:	dc08      	bgt.n	3401ab6a <__sflush_r+0xfa>
3401ab58:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401ab5c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3401ab60:	f04f 30ff 	mov.w	r0, #4294967295
3401ab64:	81a3      	strh	r3, [r4, #12]
3401ab66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3401ab6a:	4407      	add	r7, r0
3401ab6c:	eba8 0800 	sub.w	r8, r8, r0
3401ab70:	e7e7      	b.n	3401ab42 <__sflush_r+0xd2>
3401ab72:	bf00      	nop
3401ab74:	20400001 	.word	0x20400001

3401ab78 <_fflush_r>:
3401ab78:	b538      	push	{r3, r4, r5, lr}
3401ab7a:	690b      	ldr	r3, [r1, #16]
3401ab7c:	4605      	mov	r5, r0
3401ab7e:	460c      	mov	r4, r1
3401ab80:	b913      	cbnz	r3, 3401ab88 <_fflush_r+0x10>
3401ab82:	2500      	movs	r5, #0
3401ab84:	4628      	mov	r0, r5
3401ab86:	bd38      	pop	{r3, r4, r5, pc}
3401ab88:	b118      	cbz	r0, 3401ab92 <_fflush_r+0x1a>
3401ab8a:	6a03      	ldr	r3, [r0, #32]
3401ab8c:	b90b      	cbnz	r3, 3401ab92 <_fflush_r+0x1a>
3401ab8e:	f7fd fe4d 	bl	3401882c <__sinit>
3401ab92:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401ab96:	2b00      	cmp	r3, #0
3401ab98:	d0f3      	beq.n	3401ab82 <_fflush_r+0xa>
3401ab9a:	6e62      	ldr	r2, [r4, #100]	@ 0x64
3401ab9c:	07d0      	lsls	r0, r2, #31
3401ab9e:	d404      	bmi.n	3401abaa <_fflush_r+0x32>
3401aba0:	0599      	lsls	r1, r3, #22
3401aba2:	d402      	bmi.n	3401abaa <_fflush_r+0x32>
3401aba4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401aba6:	f7fe fadc 	bl	34019162 <__retarget_lock_acquire_recursive>
3401abaa:	4628      	mov	r0, r5
3401abac:	4621      	mov	r1, r4
3401abae:	f7ff ff5f 	bl	3401aa70 <__sflush_r>
3401abb2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
3401abb4:	4605      	mov	r5, r0
3401abb6:	07da      	lsls	r2, r3, #31
3401abb8:	d4e4      	bmi.n	3401ab84 <_fflush_r+0xc>
3401abba:	89a3      	ldrh	r3, [r4, #12]
3401abbc:	059b      	lsls	r3, r3, #22
3401abbe:	d4e1      	bmi.n	3401ab84 <_fflush_r+0xc>
3401abc0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
3401abc2:	f7fe facf 	bl	34019164 <__retarget_lock_release_recursive>
3401abc6:	e7dd      	b.n	3401ab84 <_fflush_r+0xc>

3401abc8 <__swhatbuf_r>:
3401abc8:	b570      	push	{r4, r5, r6, lr}
3401abca:	460c      	mov	r4, r1
3401abcc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
3401abd0:	b096      	sub	sp, #88	@ 0x58
3401abd2:	4615      	mov	r5, r2
3401abd4:	2900      	cmp	r1, #0
3401abd6:	461e      	mov	r6, r3
3401abd8:	da0c      	bge.n	3401abf4 <__swhatbuf_r+0x2c>
3401abda:	89a3      	ldrh	r3, [r4, #12]
3401abdc:	2100      	movs	r1, #0
3401abde:	f013 0f80 	tst.w	r3, #128	@ 0x80
3401abe2:	bf14      	ite	ne
3401abe4:	2340      	movne	r3, #64	@ 0x40
3401abe6:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
3401abea:	2000      	movs	r0, #0
3401abec:	6031      	str	r1, [r6, #0]
3401abee:	602b      	str	r3, [r5, #0]
3401abf0:	b016      	add	sp, #88	@ 0x58
3401abf2:	bd70      	pop	{r4, r5, r6, pc}
3401abf4:	466a      	mov	r2, sp
3401abf6:	f000 f879 	bl	3401acec <_fstat_r>
3401abfa:	2800      	cmp	r0, #0
3401abfc:	dbed      	blt.n	3401abda <__swhatbuf_r+0x12>
3401abfe:	9901      	ldr	r1, [sp, #4]
3401ac00:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
3401ac04:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
3401ac08:	4259      	negs	r1, r3
3401ac0a:	4159      	adcs	r1, r3
3401ac0c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401ac10:	e7eb      	b.n	3401abea <__swhatbuf_r+0x22>

3401ac12 <__smakebuf_r>:
3401ac12:	898b      	ldrh	r3, [r1, #12]
3401ac14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3401ac16:	079d      	lsls	r5, r3, #30
3401ac18:	4606      	mov	r6, r0
3401ac1a:	460c      	mov	r4, r1
3401ac1c:	d507      	bpl.n	3401ac2e <__smakebuf_r+0x1c>
3401ac1e:	f104 0347 	add.w	r3, r4, #71	@ 0x47
3401ac22:	6023      	str	r3, [r4, #0]
3401ac24:	6123      	str	r3, [r4, #16]
3401ac26:	2301      	movs	r3, #1
3401ac28:	6163      	str	r3, [r4, #20]
3401ac2a:	b003      	add	sp, #12
3401ac2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
3401ac2e:	ab01      	add	r3, sp, #4
3401ac30:	466a      	mov	r2, sp
3401ac32:	f7ff ffc9 	bl	3401abc8 <__swhatbuf_r>
3401ac36:	9f00      	ldr	r7, [sp, #0]
3401ac38:	4605      	mov	r5, r0
3401ac3a:	4630      	mov	r0, r6
3401ac3c:	4639      	mov	r1, r7
3401ac3e:	f7fc fef7 	bl	34017a30 <_malloc_r>
3401ac42:	b948      	cbnz	r0, 3401ac58 <__smakebuf_r+0x46>
3401ac44:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3401ac48:	059a      	lsls	r2, r3, #22
3401ac4a:	d4ee      	bmi.n	3401ac2a <__smakebuf_r+0x18>
3401ac4c:	f023 0303 	bic.w	r3, r3, #3
3401ac50:	f043 0302 	orr.w	r3, r3, #2
3401ac54:	81a3      	strh	r3, [r4, #12]
3401ac56:	e7e2      	b.n	3401ac1e <__smakebuf_r+0xc>
3401ac58:	89a3      	ldrh	r3, [r4, #12]
3401ac5a:	6020      	str	r0, [r4, #0]
3401ac5c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
3401ac60:	81a3      	strh	r3, [r4, #12]
3401ac62:	9b01      	ldr	r3, [sp, #4]
3401ac64:	e9c4 0704 	strd	r0, r7, [r4, #16]
3401ac68:	b15b      	cbz	r3, 3401ac82 <__smakebuf_r+0x70>
3401ac6a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3401ac6e:	4630      	mov	r0, r6
3401ac70:	f000 f84e 	bl	3401ad10 <_isatty_r>
3401ac74:	b128      	cbz	r0, 3401ac82 <__smakebuf_r+0x70>
3401ac76:	89a3      	ldrh	r3, [r4, #12]
3401ac78:	f023 0303 	bic.w	r3, r3, #3
3401ac7c:	f043 0301 	orr.w	r3, r3, #1
3401ac80:	81a3      	strh	r3, [r4, #12]
3401ac82:	89a3      	ldrh	r3, [r4, #12]
3401ac84:	431d      	orrs	r5, r3
3401ac86:	81a5      	strh	r5, [r4, #12]
3401ac88:	e7cf      	b.n	3401ac2a <__smakebuf_r+0x18>

3401ac8a <_raise_r>:
3401ac8a:	291f      	cmp	r1, #31
3401ac8c:	b538      	push	{r3, r4, r5, lr}
3401ac8e:	4605      	mov	r5, r0
3401ac90:	460c      	mov	r4, r1
3401ac92:	d904      	bls.n	3401ac9e <_raise_r+0x14>
3401ac94:	2316      	movs	r3, #22
3401ac96:	6003      	str	r3, [r0, #0]
3401ac98:	f04f 30ff 	mov.w	r0, #4294967295
3401ac9c:	bd38      	pop	{r3, r4, r5, pc}
3401ac9e:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
3401aca0:	b112      	cbz	r2, 3401aca8 <_raise_r+0x1e>
3401aca2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
3401aca6:	b94b      	cbnz	r3, 3401acbc <_raise_r+0x32>
3401aca8:	4628      	mov	r0, r5
3401acaa:	f000 f853 	bl	3401ad54 <_getpid_r>
3401acae:	4622      	mov	r2, r4
3401acb0:	4601      	mov	r1, r0
3401acb2:	4628      	mov	r0, r5
3401acb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
3401acb8:	f000 b83a 	b.w	3401ad30 <_kill_r>
3401acbc:	2b01      	cmp	r3, #1
3401acbe:	d00a      	beq.n	3401acd6 <_raise_r+0x4c>
3401acc0:	1c59      	adds	r1, r3, #1
3401acc2:	d103      	bne.n	3401accc <_raise_r+0x42>
3401acc4:	2316      	movs	r3, #22
3401acc6:	6003      	str	r3, [r0, #0]
3401acc8:	2001      	movs	r0, #1
3401acca:	e7e7      	b.n	3401ac9c <_raise_r+0x12>
3401accc:	2100      	movs	r1, #0
3401acce:	4620      	mov	r0, r4
3401acd0:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
3401acd4:	4798      	blx	r3
3401acd6:	2000      	movs	r0, #0
3401acd8:	e7e0      	b.n	3401ac9c <_raise_r+0x12>
	...

3401acdc <raise>:
3401acdc:	4b02      	ldr	r3, [pc, #8]	@ (3401ace8 <raise+0xc>)
3401acde:	4601      	mov	r1, r0
3401ace0:	6818      	ldr	r0, [r3, #0]
3401ace2:	f7ff bfd2 	b.w	3401ac8a <_raise_r>
3401ace6:	bf00      	nop
3401ace8:	3403eeec 	.word	0x3403eeec

3401acec <_fstat_r>:
3401acec:	b538      	push	{r3, r4, r5, lr}
3401acee:	2300      	movs	r3, #0
3401acf0:	4d06      	ldr	r5, [pc, #24]	@ (3401ad0c <_fstat_r+0x20>)
3401acf2:	4604      	mov	r4, r0
3401acf4:	4608      	mov	r0, r1
3401acf6:	4611      	mov	r1, r2
3401acf8:	602b      	str	r3, [r5, #0]
3401acfa:	f7e7 fe2d 	bl	34002958 <_fstat>
3401acfe:	1c43      	adds	r3, r0, #1
3401ad00:	d102      	bne.n	3401ad08 <_fstat_r+0x1c>
3401ad02:	682b      	ldr	r3, [r5, #0]
3401ad04:	b103      	cbz	r3, 3401ad08 <_fstat_r+0x1c>
3401ad06:	6023      	str	r3, [r4, #0]
3401ad08:	bd38      	pop	{r3, r4, r5, pc}
3401ad0a:	bf00      	nop
3401ad0c:	34058320 	.word	0x34058320

3401ad10 <_isatty_r>:
3401ad10:	b538      	push	{r3, r4, r5, lr}
3401ad12:	2300      	movs	r3, #0
3401ad14:	4d05      	ldr	r5, [pc, #20]	@ (3401ad2c <_isatty_r+0x1c>)
3401ad16:	4604      	mov	r4, r0
3401ad18:	4608      	mov	r0, r1
3401ad1a:	602b      	str	r3, [r5, #0]
3401ad1c:	f7e7 fe21 	bl	34002962 <_isatty>
3401ad20:	1c43      	adds	r3, r0, #1
3401ad22:	d102      	bne.n	3401ad2a <_isatty_r+0x1a>
3401ad24:	682b      	ldr	r3, [r5, #0]
3401ad26:	b103      	cbz	r3, 3401ad2a <_isatty_r+0x1a>
3401ad28:	6023      	str	r3, [r4, #0]
3401ad2a:	bd38      	pop	{r3, r4, r5, pc}
3401ad2c:	34058320 	.word	0x34058320

3401ad30 <_kill_r>:
3401ad30:	b538      	push	{r3, r4, r5, lr}
3401ad32:	2300      	movs	r3, #0
3401ad34:	4d06      	ldr	r5, [pc, #24]	@ (3401ad50 <_kill_r+0x20>)
3401ad36:	4604      	mov	r4, r0
3401ad38:	4608      	mov	r0, r1
3401ad3a:	4611      	mov	r1, r2
3401ad3c:	602b      	str	r3, [r5, #0]
3401ad3e:	f7e7 fdde 	bl	340028fe <_kill>
3401ad42:	1c43      	adds	r3, r0, #1
3401ad44:	d102      	bne.n	3401ad4c <_kill_r+0x1c>
3401ad46:	682b      	ldr	r3, [r5, #0]
3401ad48:	b103      	cbz	r3, 3401ad4c <_kill_r+0x1c>
3401ad4a:	6023      	str	r3, [r4, #0]
3401ad4c:	bd38      	pop	{r3, r4, r5, pc}
3401ad4e:	bf00      	nop
3401ad50:	34058320 	.word	0x34058320

3401ad54 <_getpid_r>:
3401ad54:	f7e7 bdd1 	b.w	340028fa <_getpid>

3401ad58 <_calloc_r>:
3401ad58:	b570      	push	{r4, r5, r6, lr}
3401ad5a:	fba1 5402 	umull	r5, r4, r1, r2
3401ad5e:	b934      	cbnz	r4, 3401ad6e <_calloc_r+0x16>
3401ad60:	4629      	mov	r1, r5
3401ad62:	f7fc fe65 	bl	34017a30 <_malloc_r>
3401ad66:	4606      	mov	r6, r0
3401ad68:	b928      	cbnz	r0, 3401ad76 <_calloc_r+0x1e>
3401ad6a:	4630      	mov	r0, r6
3401ad6c:	bd70      	pop	{r4, r5, r6, pc}
3401ad6e:	220c      	movs	r2, #12
3401ad70:	2600      	movs	r6, #0
3401ad72:	6002      	str	r2, [r0, #0]
3401ad74:	e7f9      	b.n	3401ad6a <_calloc_r+0x12>
3401ad76:	462a      	mov	r2, r5
3401ad78:	4621      	mov	r1, r4
3401ad7a:	f7fd ff73 	bl	34018c64 <memset>
3401ad7e:	e7f4      	b.n	3401ad6a <_calloc_r+0x12>

3401ad80 <__ascii_mbtowc>:
3401ad80:	b082      	sub	sp, #8
3401ad82:	b901      	cbnz	r1, 3401ad86 <__ascii_mbtowc+0x6>
3401ad84:	a901      	add	r1, sp, #4
3401ad86:	b142      	cbz	r2, 3401ad9a <__ascii_mbtowc+0x1a>
3401ad88:	b14b      	cbz	r3, 3401ad9e <__ascii_mbtowc+0x1e>
3401ad8a:	7813      	ldrb	r3, [r2, #0]
3401ad8c:	600b      	str	r3, [r1, #0]
3401ad8e:	7812      	ldrb	r2, [r2, #0]
3401ad90:	1e10      	subs	r0, r2, #0
3401ad92:	bf18      	it	ne
3401ad94:	2001      	movne	r0, #1
3401ad96:	b002      	add	sp, #8
3401ad98:	4770      	bx	lr
3401ad9a:	4610      	mov	r0, r2
3401ad9c:	e7fb      	b.n	3401ad96 <__ascii_mbtowc+0x16>
3401ad9e:	f06f 0001 	mvn.w	r0, #1
3401ada2:	e7f8      	b.n	3401ad96 <__ascii_mbtowc+0x16>

3401ada4 <__ascii_wctomb>:
3401ada4:	4603      	mov	r3, r0
3401ada6:	4608      	mov	r0, r1
3401ada8:	b141      	cbz	r1, 3401adbc <__ascii_wctomb+0x18>
3401adaa:	2aff      	cmp	r2, #255	@ 0xff
3401adac:	d904      	bls.n	3401adb8 <__ascii_wctomb+0x14>
3401adae:	228a      	movs	r2, #138	@ 0x8a
3401adb0:	f04f 30ff 	mov.w	r0, #4294967295
3401adb4:	601a      	str	r2, [r3, #0]
3401adb6:	4770      	bx	lr
3401adb8:	2001      	movs	r0, #1
3401adba:	700a      	strb	r2, [r1, #0]
3401adbc:	4770      	bx	lr
	...

3401adc0 <log10>:
3401adc0:	b508      	push	{r3, lr}
3401adc2:	ed2d 8b02 	vpush	{d8}
3401adc6:	eeb0 8b40 	vmov.f64	d8, d0
3401adca:	f000 fd8d 	bl	3401b8e8 <__ieee754_log10>
3401adce:	eeb4 8b48 	vcmp.f64	d8, d8
3401add2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401add6:	d60f      	bvs.n	3401adf8 <log10+0x38>
3401add8:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
3401addc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ade0:	d80a      	bhi.n	3401adf8 <log10+0x38>
3401ade2:	eeb5 8b40 	vcmp.f64	d8, #0.0
3401ade6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401adea:	d108      	bne.n	3401adfe <log10+0x3e>
3401adec:	f7fe f98e 	bl	3401910c <__errno>
3401adf0:	2322      	movs	r3, #34	@ 0x22
3401adf2:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 3401ae18 <log10+0x58>
3401adf6:	6003      	str	r3, [r0, #0]
3401adf8:	ecbd 8b02 	vpop	{d8}
3401adfc:	bd08      	pop	{r3, pc}
3401adfe:	f7fe f985 	bl	3401910c <__errno>
3401ae02:	2321      	movs	r3, #33	@ 0x21
3401ae04:	ecbd 8b02 	vpop	{d8}
3401ae08:	6003      	str	r3, [r0, #0]
3401ae0a:	4805      	ldr	r0, [pc, #20]	@ (3401ae20 <log10+0x60>)
3401ae0c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
3401ae10:	f000 b82a 	b.w	3401ae68 <nan>
3401ae14:	f3af 8000 	nop.w
3401ae18:	00000000 	.word	0x00000000
3401ae1c:	fff00000 	.word	0xfff00000
3401ae20:	3401d163 	.word	0x3401d163
3401ae24:	00000000 	.word	0x00000000

3401ae28 <sqrt>:
3401ae28:	b508      	push	{r3, lr}
3401ae2a:	ed2d 8b04 	vpush	{d8-d9}
3401ae2e:	eeb0 8b40 	vmov.f64	d8, d0
3401ae32:	f000 fd56 	bl	3401b8e2 <__ieee754_sqrt>
3401ae36:	eeb4 8b48 	vcmp.f64	d8, d8
3401ae3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ae3e:	d60c      	bvs.n	3401ae5a <sqrt+0x32>
3401ae40:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 3401ae60 <sqrt+0x38>
3401ae44:	eeb4 8bc9 	vcmpe.f64	d8, d9
3401ae48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401ae4c:	d505      	bpl.n	3401ae5a <sqrt+0x32>
3401ae4e:	f7fe f95d 	bl	3401910c <__errno>
3401ae52:	ee89 0b09 	vdiv.f64	d0, d9, d9
3401ae56:	2321      	movs	r3, #33	@ 0x21
3401ae58:	6003      	str	r3, [r0, #0]
3401ae5a:	ecbd 8b04 	vpop	{d8-d9}
3401ae5e:	bd08      	pop	{r3, pc}
	...

3401ae68 <nan>:
3401ae68:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401ae70 <nan+0x8>
3401ae6c:	4770      	bx	lr
3401ae6e:	bf00      	nop
3401ae70:	00000000 	.word	0x00000000
3401ae74:	7ff80000 	.word	0x7ff80000

3401ae78 <with_errno>:
3401ae78:	b510      	push	{r4, lr}
3401ae7a:	ed2d 8b02 	vpush	{d8}
3401ae7e:	eeb0 8b40 	vmov.f64	d8, d0
3401ae82:	4604      	mov	r4, r0
3401ae84:	f7fe f942 	bl	3401910c <__errno>
3401ae88:	6004      	str	r4, [r0, #0]
3401ae8a:	eeb0 0b48 	vmov.f64	d0, d8
3401ae8e:	ecbd 8b02 	vpop	{d8}
3401ae92:	bd10      	pop	{r4, pc}

3401ae94 <xflow>:
3401ae94:	b082      	sub	sp, #8
3401ae96:	b158      	cbz	r0, 3401aeb0 <xflow+0x1c>
3401ae98:	eeb1 7b40 	vneg.f64	d7, d0
3401ae9c:	2022      	movs	r0, #34	@ 0x22
3401ae9e:	ed8d 7b00 	vstr	d7, [sp]
3401aea2:	ed9d 7b00 	vldr	d7, [sp]
3401aea6:	ee20 0b07 	vmul.f64	d0, d0, d7
3401aeaa:	b002      	add	sp, #8
3401aeac:	f7ff bfe4 	b.w	3401ae78 <with_errno>
3401aeb0:	eeb0 7b40 	vmov.f64	d7, d0
3401aeb4:	e7f2      	b.n	3401ae9c <xflow+0x8>
	...

3401aeb8 <__math_uflow>:
3401aeb8:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401aec0 <__math_uflow+0x8>
3401aebc:	f7ff bfea 	b.w	3401ae94 <xflow>
3401aec0:	00000000 	.word	0x00000000
3401aec4:	10000000 	.word	0x10000000

3401aec8 <__math_oflow>:
3401aec8:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 3401aed0 <__math_oflow+0x8>
3401aecc:	f7ff bfe2 	b.w	3401ae94 <xflow>
3401aed0:	00000000 	.word	0x00000000
3401aed4:	70000000 	.word	0x70000000

3401aed8 <__math_divzero>:
3401aed8:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3401aedc:	b082      	sub	sp, #8
3401aede:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3401aee2:	2800      	cmp	r0, #0
3401aee4:	f04f 0022 	mov.w	r0, #34	@ 0x22
3401aee8:	fe07 7b06 	vseleq.f64	d7, d7, d6
3401aeec:	ed8d 7b00 	vstr	d7, [sp]
3401aef0:	ed9d 0b00 	vldr	d0, [sp]
3401aef4:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 3401af08 <__math_divzero+0x30>
3401aef8:	ee80 0b07 	vdiv.f64	d0, d0, d7
3401aefc:	b002      	add	sp, #8
3401aefe:	f7ff bfbb 	b.w	3401ae78 <with_errno>
3401af02:	bf00      	nop
3401af04:	f3af 8000 	nop.w
	...

3401af10 <__math_invalid>:
3401af10:	eeb0 7b40 	vmov.f64	d7, d0
3401af14:	ee30 6b40 	vsub.f64	d6, d0, d0
3401af18:	eeb4 7b47 	vcmp.f64	d7, d7
3401af1c:	ee86 0b06 	vdiv.f64	d0, d6, d6
3401af20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401af24:	d602      	bvs.n	3401af2c <__math_invalid+0x1c>
3401af26:	2021      	movs	r0, #33	@ 0x21
3401af28:	f7ff bfa6 	b.w	3401ae78 <with_errno>
3401af2c:	4770      	bx	lr

3401af2e <__math_check_uflow>:
3401af2e:	eeb5 0b40 	vcmp.f64	d0, #0.0
3401af32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401af36:	d102      	bne.n	3401af3e <__math_check_uflow+0x10>
3401af38:	2022      	movs	r0, #34	@ 0x22
3401af3a:	f7ff bf9d 	b.w	3401ae78 <with_errno>
3401af3e:	4770      	bx	lr

3401af40 <__math_check_oflow>:
3401af40:	eeb0 7bc0 	vabs.f64	d7, d0
3401af44:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 3401af60 <__math_check_oflow+0x20>
3401af48:	eeb4 7b46 	vcmp.f64	d7, d6
3401af4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401af50:	dd02      	ble.n	3401af58 <__math_check_oflow+0x18>
3401af52:	2022      	movs	r0, #34	@ 0x22
3401af54:	f7ff bf90 	b.w	3401ae78 <with_errno>
3401af58:	4770      	bx	lr
3401af5a:	bf00      	nop
3401af5c:	f3af 8000 	nop.w
3401af60:	ffffffff 	.word	0xffffffff
3401af64:	7fefffff 	.word	0x7fefffff

3401af68 <checkint>:
3401af68:	f3c1 520a 	ubfx	r2, r1, #20, #11
3401af6c:	f240 33fe 	movw	r3, #1022	@ 0x3fe
3401af70:	429a      	cmp	r2, r3
3401af72:	b570      	push	{r4, r5, r6, lr}
3401af74:	dd2a      	ble.n	3401afcc <checkint+0x64>
3401af76:	f240 4333 	movw	r3, #1075	@ 0x433
3401af7a:	429a      	cmp	r2, r3
3401af7c:	dc24      	bgt.n	3401afc8 <checkint+0x60>
3401af7e:	1a9b      	subs	r3, r3, r2
3401af80:	f04f 32ff 	mov.w	r2, #4294967295
3401af84:	f1a3 0620 	sub.w	r6, r3, #32
3401af88:	fa02 f403 	lsl.w	r4, r2, r3
3401af8c:	f1c3 0520 	rsb	r5, r3, #32
3401af90:	fa02 f606 	lsl.w	r6, r2, r6
3401af94:	fa22 f505 	lsr.w	r5, r2, r5
3401af98:	409a      	lsls	r2, r3
3401af9a:	4334      	orrs	r4, r6
3401af9c:	ea20 0202 	bic.w	r2, r0, r2
3401afa0:	432c      	orrs	r4, r5
3401afa2:	ea21 0404 	bic.w	r4, r1, r4
3401afa6:	4322      	orrs	r2, r4
3401afa8:	f1a3 0420 	sub.w	r4, r3, #32
3401afac:	f1c3 0220 	rsb	r2, r3, #32
3401afb0:	d10c      	bne.n	3401afcc <checkint+0x64>
3401afb2:	40d8      	lsrs	r0, r3
3401afb4:	fa01 f302 	lsl.w	r3, r1, r2
3401afb8:	40e1      	lsrs	r1, r4
3401afba:	4318      	orrs	r0, r3
3401afbc:	4308      	orrs	r0, r1
3401afbe:	f000 0001 	and.w	r0, r0, #1
3401afc2:	f1d0 0002 	rsbs	r0, r0, #2
3401afc6:	bd70      	pop	{r4, r5, r6, pc}
3401afc8:	2002      	movs	r0, #2
3401afca:	e7fc      	b.n	3401afc6 <checkint+0x5e>
3401afcc:	2000      	movs	r0, #0
3401afce:	e7fa      	b.n	3401afc6 <checkint+0x5e>

3401afd0 <pow>:
3401afd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401afd4:	ee10 4a90 	vmov	r4, s1
3401afd8:	f240 73fd 	movw	r3, #2045	@ 0x7fd
3401afdc:	ee11 aa90 	vmov	sl, s3
3401afe0:	ee10 5a10 	vmov	r5, s0
3401afe4:	ea4f 5814 	mov.w	r8, r4, lsr #20
3401afe8:	ee11 0a10 	vmov	r0, s2
3401afec:	ea4f 561a 	mov.w	r6, sl, lsr #20
3401aff0:	f108 32ff 	add.w	r2, r8, #4294967295
3401aff4:	46c4      	mov	ip, r8
3401aff6:	429a      	cmp	r2, r3
3401aff8:	ed2d 8b0a 	vpush	{d8-d12}
3401affc:	b087      	sub	sp, #28
3401affe:	d806      	bhi.n	3401b00e <pow+0x3e>
3401b000:	f3c6 030a 	ubfx	r3, r6, #0, #11
3401b004:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
3401b008:	2b7f      	cmp	r3, #127	@ 0x7f
3401b00a:	f240 8157 	bls.w	3401b2bc <pow+0x2ec>
3401b00e:	1802      	adds	r2, r0, r0
3401b010:	f06f 0b01 	mvn.w	fp, #1
3401b014:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
3401b018:	eb4a 010a 	adc.w	r1, sl, sl
3401b01c:	1e57      	subs	r7, r2, #1
3401b01e:	f141 33ff 	adc.w	r3, r1, #4294967295
3401b022:	45bb      	cmp	fp, r7
3401b024:	eb7e 0303 	sbcs.w	r3, lr, r3
3401b028:	d242      	bcs.n	3401b0b0 <pow+0xe0>
3401b02a:	ea52 0301 	orrs.w	r3, r2, r1
3401b02e:	f04f 0300 	mov.w	r3, #0
3401b032:	d10c      	bne.n	3401b04e <pow+0x7e>
3401b034:	196d      	adds	r5, r5, r5
3401b036:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
3401b03a:	4164      	adcs	r4, r4
3401b03c:	42ab      	cmp	r3, r5
3401b03e:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
3401b042:	41a3      	sbcs	r3, r4
3401b044:	f0c0 808f 	bcc.w	3401b166 <pow+0x196>
3401b048:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b04c:	e02b      	b.n	3401b0a6 <pow+0xd6>
3401b04e:	4ed4      	ldr	r6, [pc, #848]	@ (3401b3a0 <pow+0x3d0>)
3401b050:	42b4      	cmp	r4, r6
3401b052:	bf08      	it	eq
3401b054:	429d      	cmpeq	r5, r3
3401b056:	d109      	bne.n	3401b06c <pow+0x9c>
3401b058:	1800      	adds	r0, r0, r0
3401b05a:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
3401b05e:	eb4a 0a0a 	adc.w	sl, sl, sl
3401b062:	4283      	cmp	r3, r0
3401b064:	4bcf      	ldr	r3, [pc, #828]	@ (3401b3a4 <pow+0x3d4>)
3401b066:	eb73 030a 	sbcs.w	r3, r3, sl
3401b06a:	e7eb      	b.n	3401b044 <pow+0x74>
3401b06c:	196d      	adds	r5, r5, r5
3401b06e:	48ce      	ldr	r0, [pc, #824]	@ (3401b3a8 <pow+0x3d8>)
3401b070:	4164      	adcs	r4, r4
3401b072:	42ab      	cmp	r3, r5
3401b074:	eb70 0604 	sbcs.w	r6, r0, r4
3401b078:	d375      	bcc.n	3401b166 <pow+0x196>
3401b07a:	4281      	cmp	r1, r0
3401b07c:	bf08      	it	eq
3401b07e:	429a      	cmpeq	r2, r3
3401b080:	d171      	bne.n	3401b166 <pow+0x196>
3401b082:	4aca      	ldr	r2, [pc, #808]	@ (3401b3ac <pow+0x3dc>)
3401b084:	4294      	cmp	r4, r2
3401b086:	bf08      	it	eq
3401b088:	429d      	cmpeq	r5, r3
3401b08a:	d0dd      	beq.n	3401b048 <pow+0x78>
3401b08c:	4294      	cmp	r4, r2
3401b08e:	ea6f 0a0a 	mvn.w	sl, sl
3401b092:	bf34      	ite	cc
3401b094:	2400      	movcc	r4, #0
3401b096:	2401      	movcs	r4, #1
3401b098:	ea4f 7ada 	mov.w	sl, sl, lsr #31
3401b09c:	4554      	cmp	r4, sl
3401b09e:	f040 81dc 	bne.w	3401b45a <pow+0x48a>
3401b0a2:	ee21 0b01 	vmul.f64	d0, d1, d1
3401b0a6:	b007      	add	sp, #28
3401b0a8:	ecbd 8b0a 	vpop	{d8-d12}
3401b0ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3401b0b0:	196f      	adds	r7, r5, r5
3401b0b2:	eb44 0904 	adc.w	r9, r4, r4
3401b0b6:	1e7a      	subs	r2, r7, #1
3401b0b8:	f169 0300 	sbc.w	r3, r9, #0
3401b0bc:	4593      	cmp	fp, r2
3401b0be:	eb7e 0303 	sbcs.w	r3, lr, r3
3401b0c2:	d225      	bcs.n	3401b110 <pow+0x140>
3401b0c4:	2c00      	cmp	r4, #0
3401b0c6:	ee20 0b00 	vmul.f64	d0, d0, d0
3401b0ca:	da13      	bge.n	3401b0f4 <pow+0x124>
3401b0cc:	4651      	mov	r1, sl
3401b0ce:	f7ff ff4b 	bl	3401af68 <checkint>
3401b0d2:	2801      	cmp	r0, #1
3401b0d4:	d10e      	bne.n	3401b0f4 <pow+0x124>
3401b0d6:	eeb1 0b40 	vneg.f64	d0, d0
3401b0da:	ea57 0909 	orrs.w	r9, r7, r9
3401b0de:	d10b      	bne.n	3401b0f8 <pow+0x128>
3401b0e0:	f1ba 0f00 	cmp.w	sl, #0
3401b0e4:	dadf      	bge.n	3401b0a6 <pow+0xd6>
3401b0e6:	b007      	add	sp, #28
3401b0e8:	ecbd 8b0a 	vpop	{d8-d12}
3401b0ec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b0f0:	f7ff bef2 	b.w	3401aed8 <__math_divzero>
3401b0f4:	2000      	movs	r0, #0
3401b0f6:	e7f0      	b.n	3401b0da <pow+0x10a>
3401b0f8:	f1ba 0f00 	cmp.w	sl, #0
3401b0fc:	dad3      	bge.n	3401b0a6 <pow+0xd6>
3401b0fe:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
3401b102:	ee86 7b00 	vdiv.f64	d7, d6, d0
3401b106:	ed8d 7b00 	vstr	d7, [sp]
3401b10a:	ed9d 0b00 	vldr	d0, [sp]
3401b10e:	e7ca      	b.n	3401b0a6 <pow+0xd6>
3401b110:	2c00      	cmp	r4, #0
3401b112:	da2b      	bge.n	3401b16c <pow+0x19c>
3401b114:	4651      	mov	r1, sl
3401b116:	f7ff ff27 	bl	3401af68 <checkint>
3401b11a:	b930      	cbnz	r0, 3401b12a <pow+0x15a>
3401b11c:	b007      	add	sp, #28
3401b11e:	ecbd 8b0a 	vpop	{d8-d12}
3401b122:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b126:	f7ff bef3 	b.w	3401af10 <__math_invalid>
3401b12a:	1e41      	subs	r1, r0, #1
3401b12c:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
3401b130:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
3401b134:	4248      	negs	r0, r1
3401b136:	4148      	adcs	r0, r1
3401b138:	0480      	lsls	r0, r0, #18
3401b13a:	f3c6 020a 	ubfx	r2, r6, #0, #11
3401b13e:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
3401b142:	2b7f      	cmp	r3, #127	@ 0x7f
3401b144:	d92d      	bls.n	3401b1a2 <pow+0x1d2>
3401b146:	2000      	movs	r0, #0
3401b148:	4b95      	ldr	r3, [pc, #596]	@ (3401b3a0 <pow+0x3d0>)
3401b14a:	429c      	cmp	r4, r3
3401b14c:	bf08      	it	eq
3401b14e:	4285      	cmpeq	r5, r0
3401b150:	f43f af7a 	beq.w	3401b048 <pow+0x78>
3401b154:	f240 31bd 	movw	r1, #957	@ 0x3bd
3401b158:	428a      	cmp	r2, r1
3401b15a:	d80c      	bhi.n	3401b176 <pow+0x1a6>
3401b15c:	42a8      	cmp	r0, r5
3401b15e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b162:	41a3      	sbcs	r3, r4
3401b164:	d204      	bcs.n	3401b170 <pow+0x1a0>
3401b166:	ee31 0b00 	vadd.f64	d0, d1, d0
3401b16a:	e79c      	b.n	3401b0a6 <pow+0xd6>
3401b16c:	2000      	movs	r0, #0
3401b16e:	e7e4      	b.n	3401b13a <pow+0x16a>
3401b170:	ee30 0b41 	vsub.f64	d0, d0, d1
3401b174:	e797      	b.n	3401b0a6 <pow+0xd6>
3401b176:	2d01      	cmp	r5, #1
3401b178:	f240 72ff 	movw	r2, #2047	@ 0x7ff
3401b17c:	eb74 0303 	sbcs.w	r3, r4, r3
3401b180:	bf34      	ite	cc
3401b182:	2301      	movcc	r3, #1
3401b184:	2300      	movcs	r3, #0
3401b186:	4296      	cmp	r6, r2
3401b188:	bf8c      	ite	hi
3401b18a:	2600      	movhi	r6, #0
3401b18c:	2601      	movls	r6, #1
3401b18e:	42b3      	cmp	r3, r6
3401b190:	f000 809c 	beq.w	3401b2cc <pow+0x2fc>
3401b194:	b007      	add	sp, #28
3401b196:	ecbd 8b0a 	vpop	{d8-d12}
3401b19a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b19e:	f7ff be93 	b.w	3401aec8 <__math_oflow>
3401b1a2:	f1bc 0f00 	cmp.w	ip, #0
3401b1a6:	d10a      	bne.n	3401b1be <pow+0x1ee>
3401b1a8:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 3401b390 <pow+0x3c0>
3401b1ac:	ee20 7b07 	vmul.f64	d7, d0, d7
3401b1b0:	ec53 2b17 	vmov	r2, r3, d7
3401b1b4:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
3401b1b8:	4615      	mov	r5, r2
3401b1ba:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
3401b1be:	4a7c      	ldr	r2, [pc, #496]	@ (3401b3b0 <pow+0x3e0>)
3401b1c0:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
3401b1c4:	4422      	add	r2, r4
3401b1c6:	1513      	asrs	r3, r2, #20
3401b1c8:	f3c2 3146 	ubfx	r1, r2, #13, #7
3401b1cc:	f36f 0213 	bfc	r2, #0, #20
3401b1d0:	ee03 3a10 	vmov	s6, r3
3401b1d4:	4b77      	ldr	r3, [pc, #476]	@ (3401b3b4 <pow+0x3e4>)
3401b1d6:	1aa7      	subs	r7, r4, r2
3401b1d8:	eb03 1641 	add.w	r6, r3, r1, lsl #5
3401b1dc:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
3401b1e0:	eb03 1241 	add.w	r2, r3, r1, lsl #5
3401b1e4:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
3401b1e8:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
3401b1ec:	1e2e      	subs	r6, r5, #0
3401b1ee:	ec47 6b14 	vmov	d4, r6, r7
3401b1f2:	eea4 6b05 	vfma.f64	d6, d4, d5
3401b1f6:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
3401b1fa:	ed93 5b00 	vldr	d5, [r3]
3401b1fe:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
3401b202:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
3401b206:	eea3 2b05 	vfma.f64	d2, d3, d5
3401b20a:	ed93 5b02 	vldr	d5, [r3, #8]
3401b20e:	eea3 7b05 	vfma.f64	d7, d3, d5
3401b212:	ee36 4b02 	vadd.f64	d4, d6, d2
3401b216:	ed93 5b04 	vldr	d5, [r3, #16]
3401b21a:	ee32 2b44 	vsub.f64	d2, d2, d4
3401b21e:	ee26 5b05 	vmul.f64	d5, d6, d5
3401b222:	ee32 2b06 	vadd.f64	d2, d2, d6
3401b226:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
3401b22a:	ee26 0b05 	vmul.f64	d0, d6, d5
3401b22e:	ee37 7b02 	vadd.f64	d7, d7, d2
3401b232:	ee34 8b00 	vadd.f64	d8, d4, d0
3401b236:	eeb0 9b40 	vmov.f64	d9, d0
3401b23a:	ee26 bb00 	vmul.f64	d11, d6, d0
3401b23e:	ee34 4b48 	vsub.f64	d4, d4, d8
3401b242:	ee96 9b05 	vfnms.f64	d9, d6, d5
3401b246:	ee34 ab00 	vadd.f64	d10, d4, d0
3401b24a:	ed93 5b06 	vldr	d5, [r3, #24]
3401b24e:	ed93 4b08 	vldr	d4, [r3, #32]
3401b252:	eea6 5b04 	vfma.f64	d5, d6, d4
3401b256:	ee37 7b09 	vadd.f64	d7, d7, d9
3401b25a:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
3401b25e:	ee37 7b0a 	vadd.f64	d7, d7, d10
3401b262:	eea6 4b03 	vfma.f64	d4, d6, d3
3401b266:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
3401b26a:	eea6 3b0c 	vfma.f64	d3, d6, d12
3401b26e:	eea0 4b03 	vfma.f64	d4, d0, d3
3401b272:	eea0 5b04 	vfma.f64	d5, d0, d4
3401b276:	eeab 7b05 	vfma.f64	d7, d11, d5
3401b27a:	ee38 4b07 	vadd.f64	d4, d8, d7
3401b27e:	ee21 6b04 	vmul.f64	d6, d1, d4
3401b282:	ee38 8b44 	vsub.f64	d8, d8, d4
3401b286:	eeb0 5b46 	vmov.f64	d5, d6
3401b28a:	ee16 3a90 	vmov	r3, s13
3401b28e:	ee38 8b07 	vadd.f64	d8, d8, d7
3401b292:	f3c3 560a 	ubfx	r6, r3, #20, #11
3401b296:	ee91 5b04 	vfnms.f64	d5, d1, d4
3401b29a:	18b2      	adds	r2, r6, r2
3401b29c:	2a3e      	cmp	r2, #62	@ 0x3e
3401b29e:	eea1 5b08 	vfma.f64	d5, d1, d8
3401b2a2:	d91b      	bls.n	3401b2dc <pow+0x30c>
3401b2a4:	2a00      	cmp	r2, #0
3401b2a6:	da0b      	bge.n	3401b2c0 <pow+0x2f0>
3401b2a8:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b2ac:	ee36 0b00 	vadd.f64	d0, d6, d0
3401b2b0:	2800      	cmp	r0, #0
3401b2b2:	f43f aef8 	beq.w	3401b0a6 <pow+0xd6>
3401b2b6:	eeb1 0b40 	vneg.f64	d0, d0
3401b2ba:	e6f4      	b.n	3401b0a6 <pow+0xd6>
3401b2bc:	2000      	movs	r0, #0
3401b2be:	e77e      	b.n	3401b1be <pow+0x1ee>
3401b2c0:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
3401b2c4:	d909      	bls.n	3401b2da <pow+0x30a>
3401b2c6:	2b00      	cmp	r3, #0
3401b2c8:	f6bf af64 	bge.w	3401b194 <pow+0x1c4>
3401b2cc:	b007      	add	sp, #28
3401b2ce:	ecbd 8b0a 	vpop	{d8-d12}
3401b2d2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b2d6:	f7ff bdef 	b.w	3401aeb8 <__math_uflow>
3401b2da:	2600      	movs	r6, #0
3401b2dc:	4936      	ldr	r1, [pc, #216]	@ (3401b3b8 <pow+0x3e8>)
3401b2de:	2700      	movs	r7, #0
3401b2e0:	ed91 4b02 	vldr	d4, [r1, #8]
3401b2e4:	ed91 3b00 	vldr	d3, [r1]
3401b2e8:	eeb0 7b44 	vmov.f64	d7, d4
3401b2ec:	eea6 7b03 	vfma.f64	d7, d6, d3
3401b2f0:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
3401b2f4:	ee17 5a10 	vmov	r5, s14
3401b2f8:	ee37 7b44 	vsub.f64	d7, d7, d4
3401b2fc:	ed91 4b04 	vldr	d4, [r1, #16]
3401b300:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
3401b304:	eea7 6b04 	vfma.f64	d6, d7, d4
3401b308:	18dc      	adds	r4, r3, r3
3401b30a:	1940      	adds	r0, r0, r5
3401b30c:	f104 030f 	add.w	r3, r4, #15
3401b310:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
3401b314:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
3401b318:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
3401b31c:	ed91 4b06 	vldr	d4, [r1, #24]
3401b320:	f8d2 e004 	ldr.w	lr, [r2, #4]
3401b324:	eb17 020c 	adds.w	r2, r7, ip
3401b328:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
3401b32c:	eea7 6b04 	vfma.f64	d6, d7, d4
3401b330:	ed91 4b08 	vldr	d4, [r1, #32]
3401b334:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3401b338:	ee35 5b06 	vadd.f64	d5, d5, d6
3401b33c:	eea5 4b03 	vfma.f64	d4, d5, d3
3401b340:	ee25 6b05 	vmul.f64	d6, d5, d5
3401b344:	ee35 7b07 	vadd.f64	d7, d5, d7
3401b348:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
3401b34c:	eea6 7b04 	vfma.f64	d7, d6, d4
3401b350:	ee26 6b06 	vmul.f64	d6, d6, d6
3401b354:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
3401b358:	eea5 4b03 	vfma.f64	d4, d5, d3
3401b35c:	eea6 7b04 	vfma.f64	d7, d6, d4
3401b360:	2e00      	cmp	r6, #0
3401b362:	d175      	bne.n	3401b450 <pow+0x480>
3401b364:	42bd      	cmp	r5, r7
3401b366:	db29      	blt.n	3401b3bc <pow+0x3ec>
3401b368:	f103 4140 	add.w	r1, r3, #3221225472	@ 0xc0000000
3401b36c:	4610      	mov	r0, r2
3401b36e:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
3401b372:	ec41 0b10 	vmov	d0, r0, r1
3401b376:	eea7 0b00 	vfma.f64	d0, d7, d0
3401b37a:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 3401b398 <pow+0x3c8>
3401b37e:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b382:	b007      	add	sp, #28
3401b384:	ecbd 8b0a 	vpop	{d8-d12}
3401b388:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b38c:	f7ff bdd8 	b.w	3401af40 <__math_check_oflow>
3401b390:	00000000 	.word	0x00000000
3401b394:	43300000 	.word	0x43300000
3401b398:	00000000 	.word	0x00000000
3401b39c:	7f000000 	.word	0x7f000000
3401b3a0:	3ff00000 	.word	0x3ff00000
3401b3a4:	fff00000 	.word	0xfff00000
3401b3a8:	ffe00000 	.word	0xffe00000
3401b3ac:	7fe00000 	.word	0x7fe00000
3401b3b0:	c0196aab 	.word	0xc0196aab
3401b3b4:	3403d1f8 	.word	0x3403d1f8
3401b3b8:	3403c988 	.word	0x3403c988
3401b3bc:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
3401b3c0:	4610      	mov	r0, r2
3401b3c2:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
3401b3c6:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
3401b3ca:	ec41 0b15 	vmov	d5, r0, r1
3401b3ce:	ee27 6b05 	vmul.f64	d6, d7, d5
3401b3d2:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 3401b460 <pow+0x490>
3401b3d6:	ee35 7b06 	vadd.f64	d7, d5, d6
3401b3da:	eeb0 4bc7 	vabs.f64	d4, d7
3401b3de:	eeb4 4bc3 	vcmpe.f64	d4, d3
3401b3e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b3e6:	d52a      	bpl.n	3401b43e <pow+0x46e>
3401b3e8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3401b3ec:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
3401b3f0:	ee35 5b47 	vsub.f64	d5, d5, d7
3401b3f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b3f8:	ee35 5b06 	vadd.f64	d5, d5, d6
3401b3fc:	bf58      	it	pl
3401b3fe:	eeb0 4b43 	vmovpl.f64	d4, d3
3401b402:	ee37 3b04 	vadd.f64	d3, d7, d4
3401b406:	ee34 6b43 	vsub.f64	d6, d4, d3
3401b40a:	ee36 6b07 	vadd.f64	d6, d6, d7
3401b40e:	ee36 6b05 	vadd.f64	d6, d6, d5
3401b412:	ee36 6b03 	vadd.f64	d6, d6, d3
3401b416:	ee36 7b44 	vsub.f64	d7, d6, d4
3401b41a:	eeb5 7b40 	vcmp.f64	d7, #0.0
3401b41e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b422:	d104      	bne.n	3401b42e <pow+0x45e>
3401b424:	4632      	mov	r2, r6
3401b426:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
3401b42a:	ec43 2b17 	vmov	d7, r2, r3
3401b42e:	ed8d 0b02 	vstr	d0, [sp, #8]
3401b432:	ed9d 6b02 	vldr	d6, [sp, #8]
3401b436:	ee26 6b00 	vmul.f64	d6, d6, d0
3401b43a:	ed8d 6b04 	vstr	d6, [sp, #16]
3401b43e:	ee27 0b00 	vmul.f64	d0, d7, d0
3401b442:	b007      	add	sp, #28
3401b444:	ecbd 8b0a 	vpop	{d8-d12}
3401b448:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3401b44c:	f7ff bd6f 	b.w	3401af2e <__math_check_uflow>
3401b450:	ec43 2b10 	vmov	d0, r2, r3
3401b454:	eea7 0b00 	vfma.f64	d0, d7, d0
3401b458:	e625      	b.n	3401b0a6 <pow+0xd6>
3401b45a:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 3401b468 <pow+0x498>
3401b45e:	e622      	b.n	3401b0a6 <pow+0xd6>
3401b460:	00000000 	.word	0x00000000
3401b464:	00100000 	.word	0x00100000
	...

3401b470 <expf>:
3401b470:	ee10 2a10 	vmov	r2, s0
3401b474:	f240 412a 	movw	r1, #1066	@ 0x42a
3401b478:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
3401b47c:	f3c2 530a 	ubfx	r3, r2, #20, #11
3401b480:	428b      	cmp	r3, r1
3401b482:	b430      	push	{r4, r5}
3401b484:	d92a      	bls.n	3401b4dc <expf+0x6c>
3401b486:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
3401b48a:	d058      	beq.n	3401b53e <expf+0xce>
3401b48c:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
3401b490:	d303      	bcc.n	3401b49a <expf+0x2a>
3401b492:	ee30 0a00 	vadd.f32	s0, s0, s0
3401b496:	bc30      	pop	{r4, r5}
3401b498:	4770      	bx	lr
3401b49a:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 3401b544 <expf+0xd4>
3401b49e:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401b4a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b4a6:	dd03      	ble.n	3401b4b0 <expf+0x40>
3401b4a8:	2000      	movs	r0, #0
3401b4aa:	bc30      	pop	{r4, r5}
3401b4ac:	f000 b9f2 	b.w	3401b894 <__math_oflowf>
3401b4b0:	eddf 7a25 	vldr	s15, [pc, #148]	@ 3401b548 <expf+0xd8>
3401b4b4:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401b4b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b4bc:	d503      	bpl.n	3401b4c6 <expf+0x56>
3401b4be:	2000      	movs	r0, #0
3401b4c0:	bc30      	pop	{r4, r5}
3401b4c2:	f000 b9db 	b.w	3401b87c <__math_uflowf>
3401b4c6:	eddf 7a21 	vldr	s15, [pc, #132]	@ 3401b54c <expf+0xdc>
3401b4ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
3401b4ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b4d2:	d503      	bpl.n	3401b4dc <expf+0x6c>
3401b4d4:	2000      	movs	r0, #0
3401b4d6:	bc30      	pop	{r4, r5}
3401b4d8:	f000 b9d6 	b.w	3401b888 <__math_may_uflowf>
3401b4dc:	4b1c      	ldr	r3, [pc, #112]	@ (3401b550 <expf+0xe0>)
3401b4de:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b4e2:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
3401b4e6:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
3401b4ea:	eeb0 7b44 	vmov.f64	d7, d4
3401b4ee:	eea5 7b06 	vfma.f64	d7, d5, d6
3401b4f2:	ee17 0a10 	vmov	r0, s14
3401b4f6:	ee37 7b44 	vsub.f64	d7, d7, d4
3401b4fa:	f000 021f 	and.w	r2, r0, #31
3401b4fe:	ee95 7b06 	vfnms.f64	d7, d5, d6
3401b502:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
3401b506:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
3401b50a:	684d      	ldr	r5, [r1, #4]
3401b50c:	2100      	movs	r1, #0
3401b50e:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
3401b512:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
3401b516:	190a      	adds	r2, r1, r4
3401b518:	eea5 6b07 	vfma.f64	d6, d5, d7
3401b51c:	ee27 4b07 	vmul.f64	d4, d7, d7
3401b520:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
3401b524:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3401b528:	eea5 0b07 	vfma.f64	d0, d5, d7
3401b52c:	ec43 2b17 	vmov	d7, r2, r3
3401b530:	eea6 0b04 	vfma.f64	d0, d6, d4
3401b534:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b538:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401b53c:	e7ab      	b.n	3401b496 <expf+0x26>
3401b53e:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3401b554 <expf+0xe4>
3401b542:	e7a8      	b.n	3401b496 <expf+0x26>
3401b544:	42b17217 	.word	0x42b17217
3401b548:	c2cff1b4 	.word	0xc2cff1b4
3401b54c:	c2ce8ecf 	.word	0xc2ce8ecf
3401b550:	3403e240 	.word	0x3403e240
3401b554:	00000000 	.word	0x00000000

3401b558 <checkint>:
3401b558:	f3c0 53c7 	ubfx	r3, r0, #23, #8
3401b55c:	2b7e      	cmp	r3, #126	@ 0x7e
3401b55e:	d910      	bls.n	3401b582 <checkint+0x2a>
3401b560:	2b96      	cmp	r3, #150	@ 0x96
3401b562:	d80c      	bhi.n	3401b57e <checkint+0x26>
3401b564:	2201      	movs	r2, #1
3401b566:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
3401b56a:	fa02 f303 	lsl.w	r3, r2, r3
3401b56e:	1e5a      	subs	r2, r3, #1
3401b570:	4202      	tst	r2, r0
3401b572:	d106      	bne.n	3401b582 <checkint+0x2a>
3401b574:	4203      	tst	r3, r0
3401b576:	bf14      	ite	ne
3401b578:	2001      	movne	r0, #1
3401b57a:	2002      	moveq	r0, #2
3401b57c:	4770      	bx	lr
3401b57e:	2002      	movs	r0, #2
3401b580:	4770      	bx	lr
3401b582:	2000      	movs	r0, #0
3401b584:	4770      	bx	lr
	...

3401b588 <powf>:
3401b588:	b537      	push	{r0, r1, r2, r4, r5, lr}
3401b58a:	ee10 1a10 	vmov	r1, s0
3401b58e:	ee10 4a90 	vmov	r4, s1
3401b592:	eef0 7a40 	vmov.f32	s15, s0
3401b596:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
3401b59a:	0063      	lsls	r3, r4, #1
3401b59c:	eeb0 7a60 	vmov.f32	s14, s1
3401b5a0:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
3401b5a4:	f103 30ff 	add.w	r0, r3, #4294967295
3401b5a8:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
3401b5ac:	d252      	bcs.n	3401b654 <powf+0xcc>
3401b5ae:	4290      	cmp	r0, r2
3401b5b0:	d258      	bcs.n	3401b664 <powf+0xdc>
3401b5b2:	2000      	movs	r0, #0
3401b5b4:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
3401b5b8:	4a9f      	ldr	r2, [pc, #636]	@ (3401b838 <powf+0x2b0>)
3401b5ba:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
3401b5be:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
3401b5c2:	f3c3 44c3 	ubfx	r4, r3, #19, #4
3401b5c6:	f36f 0316 	bfc	r3, #0, #23
3401b5ca:	1ac9      	subs	r1, r1, r3
3401b5cc:	eb02 1404 	add.w	r4, r2, r4, lsl #4
3401b5d0:	15db      	asrs	r3, r3, #23
3401b5d2:	ee07 1a90 	vmov	s15, r1
3401b5d6:	ed94 4b00 	vldr	d4, [r4]
3401b5da:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
3401b5de:	ee07 3a90 	vmov	s15, r3
3401b5e2:	ed94 5b02 	vldr	d5, [r4, #8]
3401b5e6:	eea4 2b06 	vfma.f64	d2, d4, d6
3401b5ea:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3401b5ee:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3401b5f2:	ee36 6b05 	vadd.f64	d6, d6, d5
3401b5f6:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
3401b5fa:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
3401b5fe:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
3401b602:	ee22 4b02 	vmul.f64	d4, d2, d2
3401b606:	eea2 1b05 	vfma.f64	d1, d2, d5
3401b60a:	ee24 0b04 	vmul.f64	d0, d4, d4
3401b60e:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
3401b612:	eea2 5b03 	vfma.f64	d5, d2, d3
3401b616:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
3401b61a:	eea2 6b03 	vfma.f64	d6, d2, d3
3401b61e:	eea4 6b05 	vfma.f64	d6, d4, d5
3401b622:	eea1 6b00 	vfma.f64	d6, d1, d0
3401b626:	ee27 7b06 	vmul.f64	d7, d7, d6
3401b62a:	ee17 3a90 	vmov	r3, s15
3401b62e:	f3c3 32cf 	ubfx	r2, r3, #15, #16
3401b632:	f248 03bf 	movw	r3, #32959	@ 0x80bf
3401b636:	429a      	cmp	r2, r3
3401b638:	f0c0 8098 	bcc.w	3401b76c <powf+0x1e4>
3401b63c:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 3401b818 <powf+0x290>
3401b640:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b644:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b648:	dd79      	ble.n	3401b73e <powf+0x1b6>
3401b64a:	b003      	add	sp, #12
3401b64c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b650:	f000 b920 	b.w	3401b894 <__math_oflowf>
3401b654:	4290      	cmp	r0, r2
3401b656:	d330      	bcc.n	3401b6ba <powf+0x132>
3401b658:	b12b      	cbz	r3, 3401b666 <powf+0xde>
3401b65a:	0049      	lsls	r1, r1, #1
3401b65c:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
3401b660:	d808      	bhi.n	3401b674 <powf+0xec>
3401b662:	e015      	b.n	3401b690 <powf+0x108>
3401b664:	b953      	cbnz	r3, 3401b67c <powf+0xf4>
3401b666:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
3401b66a:	0049      	lsls	r1, r1, #1
3401b66c:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
3401b670:	f240 80ca 	bls.w	3401b808 <powf+0x280>
3401b674:	ee37 0a87 	vadd.f32	s0, s15, s14
3401b678:	b003      	add	sp, #12
3401b67a:	bd30      	pop	{r4, r5, pc}
3401b67c:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
3401b680:	d105      	bne.n	3401b68e <powf+0x106>
3401b682:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
3401b686:	0064      	lsls	r4, r4, #1
3401b688:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
3401b68c:	e7f0      	b.n	3401b670 <powf+0xe8>
3401b68e:	0049      	lsls	r1, r1, #1
3401b690:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
3401b694:	d1ee      	bne.n	3401b674 <powf+0xec>
3401b696:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3401b69a:	f000 80b5 	beq.w	3401b808 <powf+0x280>
3401b69e:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
3401b6a2:	ea6f 0404 	mvn.w	r4, r4
3401b6a6:	bf34      	ite	cc
3401b6a8:	2100      	movcc	r1, #0
3401b6aa:	2101      	movcs	r1, #1
3401b6ac:	0fe4      	lsrs	r4, r4, #31
3401b6ae:	42a1      	cmp	r1, r4
3401b6b0:	f040 80ad 	bne.w	3401b80e <powf+0x286>
3401b6b4:	ee27 0a07 	vmul.f32	s0, s14, s14
3401b6b8:	e7de      	b.n	3401b678 <powf+0xf0>
3401b6ba:	004d      	lsls	r5, r1, #1
3401b6bc:	1e6b      	subs	r3, r5, #1
3401b6be:	4293      	cmp	r3, r2
3401b6c0:	d31b      	bcc.n	3401b6fa <powf+0x172>
3401b6c2:	2900      	cmp	r1, #0
3401b6c4:	ee20 0a00 	vmul.f32	s0, s0, s0
3401b6c8:	da0e      	bge.n	3401b6e8 <powf+0x160>
3401b6ca:	4620      	mov	r0, r4
3401b6cc:	f7ff ff44 	bl	3401b558 <checkint>
3401b6d0:	2801      	cmp	r0, #1
3401b6d2:	d109      	bne.n	3401b6e8 <powf+0x160>
3401b6d4:	eeb1 0a40 	vneg.f32	s0, s0
3401b6d8:	b945      	cbnz	r5, 3401b6ec <powf+0x164>
3401b6da:	2c00      	cmp	r4, #0
3401b6dc:	dacc      	bge.n	3401b678 <powf+0xf0>
3401b6de:	b003      	add	sp, #12
3401b6e0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b6e4:	f000 b8dc 	b.w	3401b8a0 <__math_divzerof>
3401b6e8:	2000      	movs	r0, #0
3401b6ea:	e7f5      	b.n	3401b6d8 <powf+0x150>
3401b6ec:	2c00      	cmp	r4, #0
3401b6ee:	dac3      	bge.n	3401b678 <powf+0xf0>
3401b6f0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401b6f4:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401b6f8:	e7be      	b.n	3401b678 <powf+0xf0>
3401b6fa:	2900      	cmp	r1, #0
3401b6fc:	da1d      	bge.n	3401b73a <powf+0x1b2>
3401b6fe:	4620      	mov	r0, r4
3401b700:	f7ff ff2a 	bl	3401b558 <checkint>
3401b704:	b920      	cbnz	r0, 3401b710 <powf+0x188>
3401b706:	b003      	add	sp, #12
3401b708:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b70c:	f000 b8da 	b.w	3401b8c4 <__math_invalidf>
3401b710:	1e43      	subs	r3, r0, #1
3401b712:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
3401b716:	4258      	negs	r0, r3
3401b718:	4158      	adcs	r0, r3
3401b71a:	0400      	lsls	r0, r0, #16
3401b71c:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3401b720:	f4bf af48 	bcs.w	3401b5b4 <powf+0x2c>
3401b724:	eddf 6a45 	vldr	s13, [pc, #276]	@ 3401b83c <powf+0x2b4>
3401b728:	ee27 0aa6 	vmul.f32	s0, s15, s13
3401b72c:	ee10 3a10 	vmov	r3, s0
3401b730:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3401b734:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
3401b738:	e73c      	b.n	3401b5b4 <powf+0x2c>
3401b73a:	2000      	movs	r0, #0
3401b73c:	e7ee      	b.n	3401b71c <powf+0x194>
3401b73e:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 3401b820 <powf+0x298>
3401b742:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b746:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b74a:	dd45      	ble.n	3401b7d8 <powf+0x250>
3401b74c:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
3401b750:	b3d0      	cbz	r0, 3401b7c8 <powf+0x240>
3401b752:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
3401b756:	9301      	str	r3, [sp, #4]
3401b758:	eddd 6a01 	vldr	s13, [sp, #4]
3401b75c:	ee76 6a66 	vsub.f32	s13, s12, s13
3401b760:	eef4 6a46 	vcmp.f32	s13, s12
3401b764:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b768:	f47f af6f 	bne.w	3401b64a <powf+0xc2>
3401b76c:	4b34      	ldr	r3, [pc, #208]	@ (3401b840 <powf+0x2b8>)
3401b76e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3401b772:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
3401b776:	ee37 6b05 	vadd.f64	d6, d7, d5
3401b77a:	ee16 2a10 	vmov	r2, s12
3401b77e:	ee36 6b45 	vsub.f64	d6, d6, d5
3401b782:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
3401b786:	ee37 7b46 	vsub.f64	d7, d7, d6
3401b78a:	f002 011f 	and.w	r1, r2, #31
3401b78e:	1880      	adds	r0, r0, r2
3401b790:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
3401b794:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
3401b798:	ee27 4b07 	vmul.f64	d4, d7, d7
3401b79c:	2100      	movs	r1, #0
3401b79e:	686d      	ldr	r5, [r5, #4]
3401b7a0:	190a      	adds	r2, r1, r4
3401b7a2:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
3401b7a6:	eea7 6b05 	vfma.f64	d6, d7, d5
3401b7aa:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
3401b7ae:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
3401b7b2:	eea7 0b05 	vfma.f64	d0, d7, d5
3401b7b6:	ec43 2b17 	vmov	d7, r2, r3
3401b7ba:	eea6 0b04 	vfma.f64	d0, d6, d4
3401b7be:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b7c2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
3401b7c6:	e757      	b.n	3401b678 <powf+0xf0>
3401b7c8:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
3401b7cc:	9300      	str	r3, [sp, #0]
3401b7ce:	eddd 6a00 	vldr	s13, [sp]
3401b7d2:	ee76 6a86 	vadd.f32	s13, s13, s12
3401b7d6:	e7c3      	b.n	3401b760 <powf+0x1d8>
3401b7d8:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 3401b828 <powf+0x2a0>
3401b7dc:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b7e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b7e4:	d804      	bhi.n	3401b7f0 <powf+0x268>
3401b7e6:	b003      	add	sp, #12
3401b7e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b7ec:	f000 b846 	b.w	3401b87c <__math_uflowf>
3401b7f0:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 3401b830 <powf+0x2a8>
3401b7f4:	eeb4 7bc6 	vcmpe.f64	d7, d6
3401b7f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b7fc:	d5b6      	bpl.n	3401b76c <powf+0x1e4>
3401b7fe:	b003      	add	sp, #12
3401b800:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
3401b804:	f000 b840 	b.w	3401b888 <__math_may_uflowf>
3401b808:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3401b80c:	e734      	b.n	3401b678 <powf+0xf0>
3401b80e:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 3401b844 <powf+0x2bc>
3401b812:	e731      	b.n	3401b678 <powf+0xf0>
3401b814:	f3af 8000 	nop.w
3401b818:	ffd1d571 	.word	0xffd1d571
3401b81c:	405fffff 	.word	0x405fffff
3401b820:	ffa3aae2 	.word	0xffa3aae2
3401b824:	405fffff 	.word	0x405fffff
3401b828:	00000000 	.word	0x00000000
3401b82c:	c062c000 	.word	0xc062c000
3401b830:	00000000 	.word	0x00000000
3401b834:	c062a000 	.word	0xc062a000
3401b838:	3403ec18 	.word	0x3403ec18
3401b83c:	4b000000 	.word	0x4b000000
3401b840:	3403e240 	.word	0x3403e240
3401b844:	00000000 	.word	0x00000000

3401b848 <with_errnof>:
3401b848:	b510      	push	{r4, lr}
3401b84a:	ed2d 8b02 	vpush	{d8}
3401b84e:	eeb0 8a40 	vmov.f32	s16, s0
3401b852:	4604      	mov	r4, r0
3401b854:	f7fd fc5a 	bl	3401910c <__errno>
3401b858:	6004      	str	r4, [r0, #0]
3401b85a:	eeb0 0a48 	vmov.f32	s0, s16
3401b85e:	ecbd 8b02 	vpop	{d8}
3401b862:	bd10      	pop	{r4, pc}

3401b864 <xflowf>:
3401b864:	b130      	cbz	r0, 3401b874 <xflowf+0x10>
3401b866:	eef1 7a40 	vneg.f32	s15, s0
3401b86a:	ee27 0a80 	vmul.f32	s0, s15, s0
3401b86e:	2022      	movs	r0, #34	@ 0x22
3401b870:	f7ff bfea 	b.w	3401b848 <with_errnof>
3401b874:	eef0 7a40 	vmov.f32	s15, s0
3401b878:	e7f7      	b.n	3401b86a <xflowf+0x6>
	...

3401b87c <__math_uflowf>:
3401b87c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401b884 <__math_uflowf+0x8>
3401b880:	f7ff bff0 	b.w	3401b864 <xflowf>
3401b884:	10000000 	.word	0x10000000

3401b888 <__math_may_uflowf>:
3401b888:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401b890 <__math_may_uflowf+0x8>
3401b88c:	f7ff bfea 	b.w	3401b864 <xflowf>
3401b890:	1a200000 	.word	0x1a200000

3401b894 <__math_oflowf>:
3401b894:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 3401b89c <__math_oflowf+0x8>
3401b898:	f7ff bfe4 	b.w	3401b864 <xflowf>
3401b89c:	70000000 	.word	0x70000000

3401b8a0 <__math_divzerof>:
3401b8a0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3401b8a4:	2800      	cmp	r0, #0
3401b8a6:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
3401b8aa:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 3401b8c0 <__math_divzerof+0x20>
3401b8ae:	f04f 0022 	mov.w	r0, #34	@ 0x22
3401b8b2:	fe47 7a87 	vseleq.f32	s15, s15, s14
3401b8b6:	ee87 0a80 	vdiv.f32	s0, s15, s0
3401b8ba:	f7ff bfc5 	b.w	3401b848 <with_errnof>
3401b8be:	bf00      	nop
3401b8c0:	00000000 	.word	0x00000000

3401b8c4 <__math_invalidf>:
3401b8c4:	eef0 7a40 	vmov.f32	s15, s0
3401b8c8:	ee30 7a40 	vsub.f32	s14, s0, s0
3401b8cc:	eef4 7a67 	vcmp.f32	s15, s15
3401b8d0:	ee87 0a07 	vdiv.f32	s0, s14, s14
3401b8d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401b8d8:	d602      	bvs.n	3401b8e0 <__math_invalidf+0x1c>
3401b8da:	2021      	movs	r0, #33	@ 0x21
3401b8dc:	f7ff bfb4 	b.w	3401b848 <with_errnof>
3401b8e0:	4770      	bx	lr

3401b8e2 <__ieee754_sqrt>:
3401b8e2:	eeb1 0bc0 	vsqrt.f64	d0, d0
3401b8e6:	4770      	bx	lr

3401b8e8 <__ieee754_log10>:
3401b8e8:	ee10 3a90 	vmov	r3, s1
3401b8ec:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401b8f0:	b510      	push	{r4, lr}
3401b8f2:	ed2d 8b02 	vpush	{d8}
3401b8f6:	da21      	bge.n	3401b93c <__ieee754_log10+0x54>
3401b8f8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3401b8fc:	ee10 1a10 	vmov	r1, s0
3401b900:	430a      	orrs	r2, r1
3401b902:	d108      	bne.n	3401b916 <__ieee754_log10+0x2e>
3401b904:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 3401b990 <__ieee754_log10+0xa8>
3401b908:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 3401b998 <__ieee754_log10+0xb0>
3401b90c:	ee86 0b07 	vdiv.f64	d0, d6, d7
3401b910:	ecbd 8b02 	vpop	{d8}
3401b914:	bd10      	pop	{r4, pc}
3401b916:	2b00      	cmp	r3, #0
3401b918:	da02      	bge.n	3401b920 <__ieee754_log10+0x38>
3401b91a:	ee30 6b40 	vsub.f64	d6, d0, d0
3401b91e:	e7f3      	b.n	3401b908 <__ieee754_log10+0x20>
3401b920:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 3401b9a0 <__ieee754_log10+0xb8>
3401b924:	f06f 0235 	mvn.w	r2, #53	@ 0x35
3401b928:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b92c:	ee10 3a90 	vmov	r3, s1
3401b930:	4923      	ldr	r1, [pc, #140]	@ (3401b9c0 <__ieee754_log10+0xd8>)
3401b932:	428b      	cmp	r3, r1
3401b934:	dd04      	ble.n	3401b940 <__ieee754_log10+0x58>
3401b936:	ee30 0b00 	vadd.f64	d0, d0, d0
3401b93a:	e7e9      	b.n	3401b910 <__ieee754_log10+0x28>
3401b93c:	2200      	movs	r2, #0
3401b93e:	e7f7      	b.n	3401b930 <__ieee754_log10+0x48>
3401b940:	1518      	asrs	r0, r3, #20
3401b942:	f240 34ff 	movw	r4, #1023	@ 0x3ff
3401b946:	f3c3 0113 	ubfx	r1, r3, #0, #20
3401b94a:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
3401b94e:	4410      	add	r0, r2
3401b950:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
3401b954:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
3401b958:	ee08 3a10 	vmov	s16, r3
3401b95c:	ec53 2b10 	vmov	r2, r3, d0
3401b960:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
3401b964:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
3401b968:	ec43 2b10 	vmov	d0, r2, r3
3401b96c:	f000 f82c 	bl	3401b9c8 <log>
3401b970:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401b9a8 <__ieee754_log10+0xc0>
3401b974:	ee20 0b07 	vmul.f64	d0, d0, d7
3401b978:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401b9b0 <__ieee754_log10+0xc8>
3401b97c:	eea8 0b07 	vfma.f64	d0, d8, d7
3401b980:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3401b9b8 <__ieee754_log10+0xd0>
3401b984:	eea8 0b07 	vfma.f64	d0, d8, d7
3401b988:	e7c2      	b.n	3401b910 <__ieee754_log10+0x28>
3401b98a:	bf00      	nop
3401b98c:	f3af 8000 	nop.w
3401b990:	00000000 	.word	0x00000000
3401b994:	c3500000 	.word	0xc3500000
	...
3401b9a4:	43500000 	.word	0x43500000
3401b9a8:	1526e50e 	.word	0x1526e50e
3401b9ac:	3fdbcb7b 	.word	0x3fdbcb7b
3401b9b0:	11f12b36 	.word	0x11f12b36
3401b9b4:	3d59fef3 	.word	0x3d59fef3
3401b9b8:	509f6000 	.word	0x509f6000
3401b9bc:	3fd34413 	.word	0x3fd34413
3401b9c0:	7fefffff 	.word	0x7fefffff
3401b9c4:	00000000 	.word	0x00000000

3401b9c8 <log>:
3401b9c8:	ee10 0a90 	vmov	r0, s1
3401b9cc:	ee10 3a10 	vmov	r3, s0
3401b9d0:	b4f0      	push	{r4, r5, r6, r7}
3401b9d2:	f100 4140 	add.w	r1, r0, #3221225472	@ 0xc0000000
3401b9d6:	f04f 34ff 	mov.w	r4, #4294967295
3401b9da:	0c02      	lsrs	r2, r0, #16
3401b9dc:	429c      	cmp	r4, r3
3401b9de:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
3401b9e2:	4c71      	ldr	r4, [pc, #452]	@ (3401bba8 <log+0x1e0>)
3401b9e4:	418c      	sbcs	r4, r1
3401b9e6:	ed2d 8b02 	vpush	{d8}
3401b9ea:	d35a      	bcc.n	3401baa2 <log+0xda>
3401b9ec:	4a6f      	ldr	r2, [pc, #444]	@ (3401bbac <log+0x1e4>)
3401b9ee:	4290      	cmp	r0, r2
3401b9f0:	bf08      	it	eq
3401b9f2:	2b00      	cmpeq	r3, #0
3401b9f4:	f000 80c7 	beq.w	3401bb86 <log+0x1be>
3401b9f8:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
3401b9fc:	4b6c      	ldr	r3, [pc, #432]	@ (3401bbb0 <log+0x1e8>)
3401b9fe:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3401ba02:	ee30 0b47 	vsub.f64	d0, d0, d7
3401ba06:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
3401ba0a:	ee20 2b00 	vmul.f64	d2, d0, d0
3401ba0e:	eea6 7b00 	vfma.f64	d7, d6, d0
3401ba12:	ee20 4b02 	vmul.f64	d4, d0, d2
3401ba16:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
3401ba1a:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
3401ba1e:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
3401ba22:	eea6 7b02 	vfma.f64	d7, d6, d2
3401ba26:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
3401ba2a:	eea5 6b00 	vfma.f64	d6, d5, d0
3401ba2e:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
3401ba32:	eea5 6b02 	vfma.f64	d6, d5, d2
3401ba36:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
3401ba3a:	eea3 5b00 	vfma.f64	d5, d3, d0
3401ba3e:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
3401ba42:	eea3 5b02 	vfma.f64	d5, d3, d2
3401ba46:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
3401ba4a:	eea3 5b04 	vfma.f64	d5, d3, d4
3401ba4e:	eeb0 3b40 	vmov.f64	d3, d0
3401ba52:	eea5 6b04 	vfma.f64	d6, d5, d4
3401ba56:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
3401ba5a:	eea6 7b04 	vfma.f64	d7, d6, d4
3401ba5e:	eeb0 6b40 	vmov.f64	d6, d0
3401ba62:	eeb0 2b47 	vmov.f64	d2, d7
3401ba66:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 3401bb90 <log+0x1c8>
3401ba6a:	eea0 6b07 	vfma.f64	d6, d0, d7
3401ba6e:	eea0 6b47 	vfms.f64	d6, d0, d7
3401ba72:	ee26 1b06 	vmul.f64	d1, d6, d6
3401ba76:	ee30 8b46 	vsub.f64	d8, d0, d6
3401ba7a:	eea1 3b05 	vfma.f64	d3, d1, d5
3401ba7e:	ee30 7b43 	vsub.f64	d7, d0, d3
3401ba82:	ee30 0b06 	vadd.f64	d0, d0, d6
3401ba86:	eea1 7b05 	vfma.f64	d7, d1, d5
3401ba8a:	ee25 5b08 	vmul.f64	d5, d5, d8
3401ba8e:	eea5 7b00 	vfma.f64	d7, d5, d0
3401ba92:	eea2 7b04 	vfma.f64	d7, d2, d4
3401ba96:	ee33 0b07 	vadd.f64	d0, d3, d7
3401ba9a:	ecbd 8b02 	vpop	{d8}
3401ba9e:	bcf0      	pop	{r4, r5, r6, r7}
3401baa0:	4770      	bx	lr
3401baa2:	f1a2 0410 	sub.w	r4, r2, #16
3401baa6:	f647 71df 	movw	r1, #32735	@ 0x7fdf
3401baaa:	428c      	cmp	r4, r1
3401baac:	d923      	bls.n	3401baf6 <log+0x12e>
3401baae:	18d9      	adds	r1, r3, r3
3401bab0:	eb40 0400 	adc.w	r4, r0, r0
3401bab4:	4321      	orrs	r1, r4
3401bab6:	d105      	bne.n	3401bac4 <log+0xfc>
3401bab8:	2001      	movs	r0, #1
3401baba:	ecbd 8b02 	vpop	{d8}
3401babe:	bcf0      	pop	{r4, r5, r6, r7}
3401bac0:	f7ff ba0a 	b.w	3401aed8 <__math_divzero>
3401bac4:	493b      	ldr	r1, [pc, #236]	@ (3401bbb4 <log+0x1ec>)
3401bac6:	4288      	cmp	r0, r1
3401bac8:	bf08      	it	eq
3401baca:	2b00      	cmpeq	r3, #0
3401bacc:	d0e5      	beq.n	3401ba9a <log+0xd2>
3401bace:	0413      	lsls	r3, r2, #16
3401bad0:	d403      	bmi.n	3401bada <log+0x112>
3401bad2:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
3401bad6:	4393      	bics	r3, r2
3401bad8:	d104      	bne.n	3401bae4 <log+0x11c>
3401bada:	ecbd 8b02 	vpop	{d8}
3401bade:	bcf0      	pop	{r4, r5, r6, r7}
3401bae0:	f7ff ba16 	b.w	3401af10 <__math_invalid>
3401bae4:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 3401bb98 <log+0x1d0>
3401bae8:	ee20 7b07 	vmul.f64	d7, d0, d7
3401baec:	ec53 2b17 	vmov	r2, r3, d7
3401baf0:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
3401baf4:	4613      	mov	r3, r2
3401baf6:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
3401bafa:	492d      	ldr	r1, [pc, #180]	@ (3401bbb0 <log+0x1e8>)
3401bafc:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
3401bb00:	1e1e      	subs	r6, r3, #0
3401bb02:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
3401bb06:	f3c2 3446 	ubfx	r4, r2, #13, #7
3401bb0a:	ea4f 5c12 	mov.w	ip, r2, lsr #20
3401bb0e:	1512      	asrs	r2, r2, #20
3401bb10:	eb01 1504 	add.w	r5, r1, r4, lsl #4
3401bb14:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
3401bb18:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
3401bb1c:	eba0 070c 	sub.w	r7, r0, ip
3401bb20:	ec47 6b16 	vmov	d6, r6, r7
3401bb24:	eea7 5b06 	vfma.f64	d5, d7, d6
3401bb28:	ee07 2a90 	vmov	s15, r2
3401bb2c:	eeb8 6be7 	vcvt.f64.s32	d6, s15
3401bb30:	ed91 4b00 	vldr	d4, [r1]
3401bb34:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
3401bb38:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
3401bb3c:	eea4 7b06 	vfma.f64	d7, d4, d6
3401bb40:	ee25 2b05 	vmul.f64	d2, d5, d5
3401bb44:	ee35 4b07 	vadd.f64	d4, d5, d7
3401bb48:	ee25 1b02 	vmul.f64	d1, d5, d2
3401bb4c:	ee37 0b44 	vsub.f64	d0, d7, d4
3401bb50:	ed91 7b02 	vldr	d7, [r1, #8]
3401bb54:	ee30 0b05 	vadd.f64	d0, d0, d5
3401bb58:	eea7 0b06 	vfma.f64	d0, d7, d6
3401bb5c:	ed91 7b04 	vldr	d7, [r1, #16]
3401bb60:	ed91 6b08 	vldr	d6, [r1, #32]
3401bb64:	eea7 0b02 	vfma.f64	d0, d7, d2
3401bb68:	ed91 7b06 	vldr	d7, [r1, #24]
3401bb6c:	eea6 7b05 	vfma.f64	d7, d6, d5
3401bb70:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
3401bb74:	eea3 6b05 	vfma.f64	d6, d3, d5
3401bb78:	eea6 7b02 	vfma.f64	d7, d6, d2
3401bb7c:	eea1 0b07 	vfma.f64	d0, d1, d7
3401bb80:	ee30 0b04 	vadd.f64	d0, d0, d4
3401bb84:	e789      	b.n	3401ba9a <log+0xd2>
3401bb86:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 3401bba0 <log+0x1d8>
3401bb8a:	e786      	b.n	3401ba9a <log+0xd2>
3401bb8c:	f3af 8000 	nop.w
3401bb90:	00000000 	.word	0x00000000
3401bb94:	41a00000 	.word	0x41a00000
3401bb98:	00000000 	.word	0x00000000
3401bb9c:	43300000 	.word	0x43300000
	...
3401bba8:	000308ff 	.word	0x000308ff
3401bbac:	3ff00000 	.word	0x3ff00000
3401bbb0:	3403e388 	.word	0x3403e388
3401bbb4:	7ff00000 	.word	0x7ff00000

3401bbb8 <_sbrk>:
3401bbb8:	4a04      	ldr	r2, [pc, #16]	@ (3401bbcc <_sbrk+0x14>)
3401bbba:	4603      	mov	r3, r0
3401bbbc:	6811      	ldr	r1, [r2, #0]
3401bbbe:	b909      	cbnz	r1, 3401bbc4 <_sbrk+0xc>
3401bbc0:	4903      	ldr	r1, [pc, #12]	@ (3401bbd0 <_sbrk+0x18>)
3401bbc2:	6011      	str	r1, [r2, #0]
3401bbc4:	6810      	ldr	r0, [r2, #0]
3401bbc6:	4403      	add	r3, r0
3401bbc8:	6013      	str	r3, [r2, #0]
3401bbca:	4770      	bx	lr
3401bbcc:	34058328 	.word	0x34058328
3401bbd0:	34058330 	.word	0x34058330

3401bbd4 <_init>:
3401bbd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401bbd6:	bf00      	nop
3401bbd8:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401bbda:	bc08      	pop	{r3}
3401bbdc:	469e      	mov	lr, r3
3401bbde:	4770      	bx	lr

3401bbe0 <_fini>:
3401bbe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3401bbe2:	bf00      	nop
3401bbe4:	bcf8      	pop	{r3, r4, r5, r6, r7}
3401bbe6:	bc08      	pop	{r3}
3401bbe8:	469e      	mov	lr, r3
3401bbea:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3401bc00 <SECURE_SystemCoreClockUpdate>:
3401bc00:	e97f e97f 	sg
3401bc04:	f7e8 be1c 	b.w	34004840 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
